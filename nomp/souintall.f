*CMZ :  4.01/05 26/04/2024  14.26.24  by  Michael Scheer
*CMZ :  4.01/03 29/06/2023  11.47.09  by  Michael Scheer
*CMZ :  4.00/15 27/04/2022  08.35.33  by  Michael Scheer
*CMZ :  4.00/05 29/11/2019  13.11.04  by  Michael Scheer
*CMZ :  4.00/04 17/05/2019  14.22.20  by  Michael Scheer
*CMZ :  3.08/01 02/04/2019  15.33.15  by  Michael Scheer
*CMZ :  3.06/00 26/02/2019  17.25.55  by  Michael Scheer
*CMZ :  3.05/04 27/06/2018  14.21.59  by  Michael Scheer
*CMZ :  3.05/03 17/05/2018  15.20.37  by  Michael Scheer
*CMZ :  3.05/02 14/05/2018  12.06.08  by  Michael Scheer
*CMZ :  3.03/04 19/10/2017  15.16.22  by  Michael Scheer
*CMZ :  3.03/03 10/07/2017  09.04.23  by  Michael Scheer
*CMZ :  3.02/06 12/06/2015  14.16.15  by  Michael Scheer
*CMZ :  3.02/03 06/11/2014  18.17.54  by  Michael Scheer
*CMZ :  3.02/00 09/09/2014  16.46.27  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 05/03/2013  13.13.47  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  14.04.56  by  Michael Scheer
*CMZ :  2.70/00 07/12/2012  18.23.27  by  Michael Scheer
*CMZ :  2.69/02 08/11/2012  09.32.00  by  Michael Scheer
*CMZ :  2.69/01 31/10/2012  10.40.22  by  Michael Scheer
*CMZ :  2.69/00 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.68/05 18/10/2012  15.12.59  by  Michael Scheer
*CMZ :  2.68/03 07/08/2012  16.06.17  by  Michael Scheer
*CMZ :  2.68/02 05/07/2012  15.46.52  by  Michael Scheer
*CMZ :  2.68/01 28/05/2012  15.48.19  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  13.34.13  by  Michael Scheer
*CMZ :  2.67/02 16/03/2012  14.39.05  by  Michael Scheer
*CMZ :  2.66/20 06/07/2011  11.58.46  by  Michael Scheer
*CMZ :  2.66/13 25/06/2010  15.54.28  by  Michael Scheer
*CMZ :  2.66/12 24/06/2010  12.50.52  by  Michael Scheer
*CMZ :  2.66/09 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.66/07 10/03/2010  09.23.32  by  Michael Scheer
*CMZ :  2.66/05 27/11/2009  15.57.31  by  Michael Scheer
*CMZ :  2.66/04 16/11/2009  16.16.20  by  Michael Scheer
*CMZ :  2.66/03 11/11/2009  16.07.50  by  Michael Scheer
*CMZ :  2.65/03 28/10/2009  15.52.52  by  Michael Scheer
*CMZ :  2.65/00 18/09/2009  08.42.36  by  Michael Scheer
*CMZ :  2.64/06 14/09/2009  15.19.42  by  Michael Scheer
*CMZ :  2.64/05 08/09/2009  14.20.10  by  Michael Scheer
*CMZ :  2.63/05 12/08/2009  08.49.28  by  Michael Scheer
*CMZ :  2.61/02 16/01/2008  12.30.01  by  Michael Scheer
*CMZ :  2.52/11 08/12/2004  12.14.22  by  Michael Scheer
*CMZ :  2.52/02 08/07/2004  10.27.29  by  Michael Scheer
*CMZ :  2.52/00 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.51/00 26/05/2004  12.21.57  by  Michael Scheer
*CMZ :  2.50/02 30/04/2004  15.27.49  by  Michael Scheer
*CMZ :  2.50/00 29/04/2004  17.45.51  by  Michael Scheer
*CMZ :  2.41/09 14/08/2002  17.09.37  by  Michael Scheer
*CMZ :  2.41/05 16/04/2002  16.54.59  by  Michael Scheer
*CMZ :  2.41/04 16/04/2002  14.28.11  by  Michael Scheer
*CMZ :  2.36/01 08/11/2001  16.00.32  by  Michael Scheer
*CMZ :  2.36/00 08/11/2001  11.32.45  by  Michael Scheer
*CMZ :  2.33/08 05/11/2001  15.31.11  by  Michael Scheer
*CMZ :  2.33/00 03/05/2001  11.22.25  by  Michael Scheer
*CMZ :  2.32/01 25/04/2001  18.59.57  by  Michael Scheer
*CMZ :  2.31/01 25/04/2001  10.48.33  by  Michael Scheer
*CMZ :  2.30/01 12/04/2001  14.35.13  by  Michael Scheer
*CMZ :  2.20/12 11/04/2001  16.38.33  by  Michael Scheer
*CMZ :  2.20/11 11/04/2001  12.20.03  by  Michael Scheer
*CMZ :  2.20/10 05/04/2001  12.44.17  by  Michael Scheer
*CMZ :  2.20/08 18/03/2001  20.51.21  by  Michael Scheer
*CMZ :  2.20/04 09/03/2001  15.08.55  by  Michael Scheer
*CMZ :  2.20/03 22/02/2001  18.37.06  by  Michael Scheer
*CMZ :  2.20/01 11/02/2001  19.28.38  by  Michael Scheer
*CMZ :  2.16/08 31/10/2000  14.40.08  by  Michael Scheer
*CMZ :  2.16/07 21/09/2000  11.21.00  by  Michael Scheer
*CMZ :  2.16/06 28/08/2000  14.39.42  by  Michael Scheer
*CMZ :  2.16/05 02/08/2000  13.53.32  by  Michael Scheer
*CMZ :  2.16/04 19/06/2000  14.27.19  by  Michael Scheer
*CMZ :  2.16/03 16/06/2000  14.35.02  by  Michael Scheer
*CMZ :  2.15/00 05/05/2000  19.25.24  by  Michael Scheer
*CMZ :  2.14/02 26/04/2000  16.40.34  by  Michael Scheer
*CMZ :  2.13/07 17/02/2000  15.11.13  by  Michael Scheer
*CMZ :  2.13/03 18/01/2000  17.44.41  by  Michael Scheer
*CMZ :  2.12/03 21/07/99  10.47.09  by  Michael Scheer
*CMZ :  2.12/01 10/06/99  17.49.00  by  Michael Scheer
*CMZ :  2.12/00 04/06/99  10.43.55  by  Michael Scheer
*CMZ :  2.11/01 20/05/99  17.44.32  by  Michael Scheer
*CMZ :  2.10/01 24/02/99  10.20.40  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  11.18.17  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.54.05  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.44  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE SOUINTALL(ISOUR)
*KEEP,gplhint.
*KEND.

*KEEP,trackf90u.
      include 'trackf90u.cmn'
*KEEP,sourcef90u.
      include 'sourcef90u.cmn'
*KEEP,observf90u.
      include 'observf90u.cmn'
*KEEP,spectf90u.
      include 'spectf90u.cmn'
*KEEP,wfoldf90u.
      include 'wfoldf90u.cmn'
*KEEP,afreqf90u.
      include 'afreqf90u.cmn'
*KEEP,amplif90u.
      include 'amplif90u.cmn'
*KEND.

      use bunchmod
      use ompmod
      use wbetaf90m
      use souintmod

C--- EVALUATE INTEGRALES FOR A SINGLE SOURCE

      IMPLICIT NONE

*KEEP,cmpara.
      include 'cmpara.cmn'
*KEEP,contrl.
      include 'contrl.cmn'
*KEEP,myfiles.
      include 'myfiles.cmn'
*KEEP,phycon.
      include 'phycon.cmn'
*KEEP,track.
      include 'track.cmn'
*KEEP,sourcef90.
      include 'sourcef90.cmn'
*KEEP,observf90.
      include 'observf90.cmn'
*KEEP,spect.
      include 'spect.cmn'
*KEEP,freqs.
      include 'freqs.cmn'
*KEEP,ampli.
      include 'ampli.cmn'
*KEEP,wfoldf90.
      include 'wfoldf90.cmn'
*KEEP,depola.
      include 'depola.cmn'
*KEEP,tralin.
      include 'tralin.cmn'
*KEEP,b0scglob.
      include 'b0scglob.cmn'
*KEEP,uservar.
      include 'uservar.cmn'
*KEEP,strings.
      include 'strings.cmn'
*KEEP,ustep.
      include 'ustep.cmn'
*KEEP,datetime.
      include 'datetime.cmn'
*KEND.

      DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE :: RESRAN
      DOUBLE PRECISION :: RMS,RESPOW,vx1,vy1,vz1,vn,schwingungen,
     &  yy,zz,yyp,zzp,
     &  tfmh(2,2),tfmv(2,2),tfmhi(2,2),tfmvi(2,2),
     &  tfmdeh(2,2),tfmdev(2,2),tfmdehi(2,2),tfmdevi(2,2),tfm1(2,2),
     &  w22(2,2),dum22(2,2),
     &  x1,y1,z1,x2,wx1,dxb
     &  ,alpha0(2),beta0(2),alphah,alphav,
     &  xub,yub,zub,ypub,zpub,gammaub,tphase,
     &  beta0h,s0h,beta0v,s0v,gammah,gammav,
     &  xco,yco,zco,ypco,zpco,egammaco,dpp=0.0d0,
     &  xfirst,yfirst,zfirst,ypfirst,zpfirst,egammafirst
     &  ,rm,rq,alpha,beta
     &  ,psi,spsi,cpsi

      real xran(5),rr(2)

      INTEGER IOBSV,ISOUR,JX10,JDX10,IX10,INSIDE,nutracko
      INTEGER NTOTIN,NTOT2IN,IREP,KINSIDE
      INTEGER JEFOLD,JFOLD,JPIN,ICAL,IFREQ,ICOUNT,nelec,kobsv,jobunch,
     &  iw2(2),ifail,i1,icen,ierr,i2

      common/souintc/jpin

      DATA tfm1(1,1),tfm1(1,2),tfm1(2,1),tfm1(2,2)/1.0d0,0.0d0,0.0d0,1.0d0/
      DATA tfmhi(1,1),tfmhi(1,2),tfmhi(2,1),tfmhi(2,2)/1.0d0,0.0d0,0.0d0,1.0d0/
      DATA tfmvi(1,1),tfmvi(1,2),tfmvi(2,1),tfmvi(2,2)/1.0d0,0.0d0,0.0d0,1.0d0/
      DATA ICAL/0/

      allocate(ampzmax(nfreq),kobs(nfreq))

      IF (ICAL.EQ.0) THEN

        if (bunchcharge.eq.0.0d0) then
          bunchcharge=neinbunch*echarge1
        endif

        if (ibunch.eq.0) then
          ibunphase=0
          iobunch=0
        else if (abs(ibunch).ne.1) then
                write(LUNGFO,*)
     &            '*** Error in SOUINTALL: Bad value of IBUNCH (not -1,0,1)!  ***'
                write(6,*)
     &            '*** Error in SOUINTALL: Bad value of IBUNCH (not -1,0,1)!  ***'
                stop '*** Program WAVE aborted ***'
        endif

        if (iwbunch.gt.0) then
          open(unit=22,file='wave_phasespace_bunch.dat',status='old',
     &      iostat=ierr)
          if (ierr.eq.0) close(22,status='delete')
          open(unit=22,file='wave_phasespace_bunch.dat',status='new')
        endif

        if (mpinr.eq.0) then
          if (ibunphase.eq.0) iobunch=icbrill
          jobunch=icbrill
          if (iobunch.eq.0) then
            iobunch=icbrill
          endif
        else
          if (ibunphase.eq.0) iobunch=1
          jobunch=1
          if (iobunch.eq.0) then
            iobunch=1
          endif
        endif

        if (ibunch.eq.0) then
          neinbunch=1
          nbunch=1
          if (iobunch.eq.-9999) then
            if (mpinr.ne.0) then
              jobunch=icbrill
            else
              jobunch=1
            endif
          else
            jobunch=iobunch
          endif
        else if (iobunch.ne.-9999) then
          jobunch=iobunch
        endif

        nelec=nbunch*neinbunch

        IF (IAMPSEED.NE.0) CALL RMARIN(IAMPSEED,NTOTIN,NTOT2IN)

        if (jobunch.gt.nobsv) then
          write(6,*)' '
          write(6,*)' *** WARNING IN SOUINTALL: IOBUNCH.GT.NOBSV'
          write(6,*)' SET ACCORDING TO SELECTED POINT'
          write(6,*)' '
          write(lungfo,*)' '
          write(lungfo,*)' *** WARNING IN SOUINTALL: IOBUNCH.GT.NOBSV'
          write(lungfo,*)' SET ACCORDING TO SELECTED POINT'
          write(lungfo,*)' '
        endif

        allocate(wbetasub(16,3))

        ICAL=1
      ENDIF !ICAL

      xub=sourceao(1,1,isour)
      yub=sourceao(2,1,isour)
      zub=sourceao(3,1,isour)
      ypub=sourceao(2,2,isour)/sourceao(1,2,isour)
      zpub=sourceao(3,2,isour)/sourceao(1,2,isour)
      gammaub=sourceg(1,1,isour)

      xco=xub
      yco=yub
      zco=zub
      ypco=ypub
      zpco=zpub
      egammaco=gammaub

      xfirst=xco
      yfirst=yco
      zfirst=zco
      ypfirst=ypco
      zpfirst=zpco
      egammafirst=egammaco

      xelec=xco
      yelec=yco
      zelec=zco
      ypelec=ypco
      zpelec=zpco
      egamma=egammaco

      if (ibunch.ne.0) then

        if (iemit.eq.0.and.ilintra.lt.0) then
          nutracko=nutrack
          allocate(wbeta(16,nco))
          allocate(wbetak(3,nco))
c calculate transfer matrix from entrance to center
          call wbetfn
          nutrack=nutracko
        endif

        if (ilintra.lt.0) then

          tfmh=tfm1
          tfmv=tfm1
          tfmdeh=tfm1
          tfmdev=tfm1

          x1=sourceao(1,1,isour)
          y1=sourceao(2,1,isour)
          z1=sourceao(3,1,isour)
          x2=sourceeo(1,1,isour)

          dxb=(wbeta(1,nco)-wbeta(1,1))/(nco-1)

          wx1=wbeta(1,1)

          i1=nint((x1-wx1)/dxb)
          i2=nint((x2-wx1)/dxb)

          if (i1.lt.1) then
            if (i1.lt.0) then
              write(6,*)
     &          '*** Error in SOUTINALL: No horizontal beta function for first point of source found ***'
              write(6,*)
     &          'Taking value from x = ',wbeta(1,1)
            endif
            i1=1
          endif

          if (i2.gt.nco) then
              write(6,*)
     &          '*** Error in SOUTINALL: No horizontal beta function for last point of source found ***'
              write(6,*)
     &          'Taking value from x = ',wbeta(1,nco)
            i2=nco
          endif

          if (xlintra.eq.-9999.0d9) then
            icen=nint(((x1+x2)/2.0d0-wx1)/dxb)
          else
            icen=nint(xlintra/dxb)+1
            if (icen.le.i1.or.icen.gt.i2) then
              write(6,*)
     &          '*** Error in SOUINTALL: Bad XLINTRA, please check input *** '
              write(6,*)
     &          '*** XLINTRA MUST BE INSIDE SOURCE! *** '
              stop '*** WAVE aborted'
            endif
          endif

          wbetasub(1:16,1)=wbeta(1:16,i1)
          wbetasub(1:16,2)=wbeta(1:16,icen)
          wbetasub(1:16,3)=wbeta(1:16,i2)

          alpha0(1)=-wbeta(3,i1)/2.d0
          alpha0(2)=-wbeta(5,i1)/2.d0
          beta0(1)=wbeta(2,i1)
          beta0(2)=wbeta(4,i1)

          alpha=-wbeta(3,icen)/2.d0
          beta=  wbeta(2,icen)
          psi=   wbeta(8,icen)

          cpsi=cos(psi)
          spsi=sin(psi)
          rq=sqrt(beta/beta0(1))
          rm=sqrt(beta*beta0(1))
          tfmh(1,1) = rq * (cpsi+alpha0(1)*spsi)
          tfmh(1,2) = rm * spsi
          tfmh(2,1)=
     &      ((alpha0(1)-alpha)*cpsi - (1.0d0+alpha0(1)*alpha)*spsi) / rm
          tfmh(2,2)=
     &      (cpsi-alpha*spsi) / rq

          alpha=-wbeta(5,icen)/2.d0
          beta=  wbeta(4,icen)
          psi=   wbeta(9,icen)

          cpsi=cos(psi)
          spsi=sin(psi)
          rq=sqrt(beta/beta0(2))
          rm=sqrt(beta*beta0(2))
          tfmv(1,1) = rq * (cpsi+alpha0(2)*spsi)
          tfmv(1,2) = rm * spsi
          tfmv(2,1)=
     &      ((alpha0(2)-alpha)*cpsi - (1.0d0+alpha0(2)*alpha)*spsi) / rm
          tfmv(2,2)=
     &      (cpsi-alpha*spsi) / rq


          tfmdeh=tfmh
          tfmdev=tfmv


        endif !(ilintra.eq.0) then

        if(ilintra.gt.0) then

          open(unit=99,file='wave_lintra.dat',status='old')
          call util_skip_comment(99)
          read(99,*)tfmh(1,1),tfmh(1,2)
          read(99,*)tfmh(2,1),tfmh(2,2)
          read(99,*)tfmv(1,1),tfmv(1,2)
          read(99,*)tfmv(2,1),tfmv(2,2)
          read(99,*)wbetasub(1:16,1)
          read(99,*)wbetasub(1:16,2)
          read(99,*)wbetasub(1:16,3)
          close(99)

          tfmdeh=tfmh
          tfmdev=tfmv

          write(lungfo,*)' '
          write(lungfo,*)'      SOUTINALL:'
          write(lungfo,*)' '
          write(lungfo,*)'      Horizontal lineare transfer-matrix:'
          write(lungfo,*)' '
          write(lungfo,*)'      ',tfmh(1,1),tfmh(1,2)
          write(lungfo,*)'      ',tfmh(2,1),tfmh(2,2)
          write(lungfo,*)' '
          write(lungfo,*)'      Vertical lineare transfer-matrix:'
          write(lungfo,*)' '
          write(lungfo,*)'      ',tfmv(1,1),tfmv(1,2)
          write(lungfo,*)'      ',tfmv(2,1),tfmv(2,2)
          write(lungfo,*)' '

        else if(ilintra.lt.0) then

          open(unit=99,file='wave_lintra.dat',status='unknown',recl=256)
          write(99,*)'* ',icode,code(1:len_trim(code))
          write(99,*)tfmh(1,1),tfmh(1,2)
          write(99,*)tfmh(2,1),tfmh(2,2)
          write(99,*)tfmv(1,1),tfmv(1,2)
          write(99,*)tfmv(2,1),tfmv(2,2)
          write(99,*)wbetasub(1:16,1)
          write(99,*)wbetasub(1:16,2)
          write(99,*)wbetasub(1:16,3)
          close(99)

        endif !(ilintra.eq.0) then

        if (ilintra.ne.0) then !(ilintra.ne.0) then

          w22=tfmh

          dum22(1,1)=1.0d0
          dum22(1,2)=0.0d0
          dum22(2,1)=0.0d0
          dum22(2,2)=1.0d0

          call deqinv(2,w22,2,iw2,ifail,2,dum22)

          if (ifail.ne.0) then
            write(6,*)'*** Error in SOUINTALL: Matrix invertation failed'
            write(6,*)'Please check horizontal beta functions.'
            write(lungfo,*)'*** Error in SOUINTALL: Matrix invertation failed'
            write(lungfo,*)'Please check horizontal beta functions.'
            stop '*** Program WAVE aborted ***'
          endif

          tfmhi=w22

          w22=tfmv

          dum22(1,1)=1.0d0
          dum22(1,2)=0.0d0
          dum22(2,1)=0.0d0
          dum22(2,2)=1.0d0

          call deqinv(2,w22,2,iw2,ifail,2,dum22)

          if (ifail.ne.0) then
            write(6,*)'*** Error in SOUINTALL: Matrix invertation failed'
            write(6,*)'Please check vertical beta functions.'
            write(lungfo,*)'*** Error in SOUINTALL: Matrix invertation failed'
            write(lungfo,*)'Please check vertical beta functions.'
            stop '*** Program WAVE aborted ***'
          endif

          tfmvi=w22

          tfmdehi=tfmhi
          tfmdevi=tfmvi


        endif !(ilintra.eq.0) then

      endif !ibunch.ne.0

      if (mpinr.ne.0) then
        allocate(phaserphi(nobsvrphi));
        allocate(expom1rphi(nobsvrphi));
        allocate(afferphi(6,nobsvrphi*nfreq))
        allocate(unphrphi(6,nobsvrphi*nfreq))
        phaserphi=0.0d0
        expom1rphi=(0.0d0,0.0d0)
        afferphi=(0.0d0,0.0d0)
        unphrphi=(0.0d0,0.0d0)
      else
        allocate(affe(6,nobsv*nfreq))
        affe=(0.0d0,0.0d0)
      endif

      allocate(ampz(nfreq))
      ampz=0.0d0
      allocate(azcos(nfreq))
      allocate(azsin(nfreq))
      allocate(phrnrn(nfreq))
      allocate(phexp(nfreq))
      azcos=1.0d0
      azsin=0.0d0
      phrnrn=0.0d0
      phexp=0.0d0

      JPIN=IPIN
      if (ipin.eq.3) ipin=0
      JFOLD=IFOLD
      JEFOLD=IEFOLD

      IF (IAMPLI.LT.0) THEN
        IF (ISOUR.EQ.1) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'      repetition of amplitude activated:'
          WRITE(LUNGFO,*)
     &      '      A -> A * (1 + exp(i*phi) + exp(i*2*phi)...'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'      IAMPLI:',IAMPLI
          WRITE(LUNGFO,*)
        ENDIF !ISOUR
        IF (AMPRAN.NE.0.D0) THEN
          IF (ISOUR.EQ.1) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'      phase errors for repetition activated:'
            WRITE(LUNGFO,*)
     &        '      A -> A * (1 + exp(i*phi*xran1) + exp(i*2*phi*xran2)...'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'      IAMPSEED: ',IAMPSEED
            WRITE(LUNGFO,*)
          ENDIF !ISOUR
c          ALLOCATE(XRANA(-IAMPLI))
          CALL RNORML(XRANA,-IAMPLI,rr)
          RMS=0.D0
          DO IREP=1,-IAMPLI
            XRANA(IREP)=AMPRAN*XRANA(IREP)
            RMS=RMS+XRANA(IREP)**2
          ENDDO
          RMS=SQRT(RMS/(-IAMPLI))
          WRITE(LUNGFO,*)
     &      '      rel. rms phase AMPRAN (input): ',SNGL(AMPRAN)
          WRITE(LUNGFO,*)
     &      '      rel. rms phase error 1. source (from generated errors): '
     &      ,SNGL(RMS)
        ENDIF   !(AMPRAN.NE.0.D0)

        IF (ABS(IMAMPLI).EQ.3) THEN
C--- WRITE FILES FOR PROGRAM PHASE OF JOHANNES BAHRDT
          CALL PHASE_BAHRDT
        ENDIF

      ENDIF   !IAMPLI

      JDX10=NOBSV/10
      JX10=JDX10

      IF (JDX10.LT.1) JDX10=1

      IF (ISOUR.EQ.1.AND.NOBSV.GT.1) THEN
        WRITE(6,*)' '
        WRITE(6,*)
     &    '      counting from 1 to 10 for first source to show progress:'
        WRITE(6,*)' '
        WRITE(6,*)' '
      ENDIF

      IF (ISPECMODE.EQ.1) CALL TRASOU(ISOUR)

      IF (JPIN.NE.2) THEN

C CALCULATE DISTRIBUTION IN PINHOLE {

        IX10=1
        KINSIDE=0

        ielec=0
        phrnrn=0.0
        phexp=cdexp(dcmplx(0.0d0,dble(phrnrn*twopi1)))

        egamma=sourceg(1,1,isour)

        do ibun=1,nbunch

          do isub=1,neinbunch

            ielec=ielec+1
            ampz=0.0d0

            if (ibunch.ne.0) then

c5.2.2013 bug?              if (iubunch.eq.0.or.iubunch.eq.1.or.ibunch.eq.1) then
              if (iubunch.eq.0.or.iubunch.eq.1) then

                if (bunchlen.eq.0.0d0) then
                  CALL GRNDMm(phrnrn,1)
                  phrnrn=phrnrn(1)
c                  CALL GRNDMm(phrnrn,nfreq)
c                  phexp=cdexp(dcmplx(0.0d0,dble(phrnrn*twopi1)))
                  phexp=cdexp(dcmplx(0.0d0,dble(phrnrn(1)*twopi1)))
                else if (bunchlen.gt.0.0d0)  then !(bunchlen.eq.0.0d0) then
c                  CALL RNORML(phrnrn,nfreq)
                  CALL RNORML(phrnrn,1,rr)
                  phrnrn=phrnrn(1)
                  do ifreq=1,nfreq
                    schwingungen = bunchlen*1.0d9 /
c     &                (WTOE1/freq(ifreq)) * phrnrn(ifreq)
     &                (WTOE1/freq(ifreq)) * phrnrn(1)
                    schwingungen=mod(schwingungen,1.0d0)
                    phexp(ifreq)=cdexp(dcmplx(0.0d0,schwingungen*twopi1))
                  enddo
                else ! bunchlen
                  phrnrn=0.0d0
                  phexp=(1.0d0,0.0d0)
                endif !(bunchlen.eq.0.0d0) then

                bunchx=phrnrn(1)*bunchlen !long. position in bunch

              else if (iubunch.eq.2.or.iubunch.eq.3.or.iubunch.eq.4) then

c here for all frequencies have the same phase
                if (nsource.gt.1) then
                  write(6,*)'*** WARNING IN SOUINTALL: USE OF IBUNCH IS RATHER'
                  write(6,*)'*** TRICKY SINCE MULTIPLE SOURCES ARE NOT YET FULLY'
                  write(6,*)'*** IMPLEMENTED! ELECTRONS ON FILE wave_phasespace.dat'
                  write(6,*)'*** ARE READ FOR EACH SOURCE AND ALL VARIABLES MUST'
                  write(6,*)'*** MUST MATCH THE SOURCE, GOOD LUCK...'
                  write(6,*)'*** TYPICAL PROBLEMS: NUMBER OF STEPS IN SOURCES SEEMS TO BE EXCEEDED'
                  write(6,*)'*** OR END OF FILE FOR wave_phasespace.dat IS REACHED AND SO ON!'
                endif
                call bunch(tphase)
                bunchx=tphase*clight1 !long. position in bunch

                do ifreq=1,nfreq
                  phexp(ifreq)=cdexp(dcmplx(0.0d0,tphase*freq(ifreq)/hbarev1))
                enddo !ifreq

              else if (iubunch.eq.-2) then
                write(6,*)
     &            '*** Error in souintall: IUBUNCH=-2 is not supported anymore ***'
                write(6,*)'*** Program WAVE aborted ***'
                write(lungfo,*)
     &            '*** Error in souintall: IUBUNCH=-2 is not supported anymore ***'
                write(lungfo,*)'*** Program WAVE aborted ***'
                stop

              else if (iubunch.eq.-1) then

                call ubunch(xub,yub,zub,ypub,zpub,gammaub,tphase)
                bunchx=tphase*clight1 !long. position in bunch
                egamma=gammaub
                xelec=xub
                yelec=yub
                zelec=zub
                ypelec=ypub
                zpelec=zpub

                do ifreq=1,nfreq
                  schwingungen = bunchlen*1.0d9*clight1 /
     &              (freq(ifreq)/hbarev1) * tphase
                  schwingungen=mod(schwingungen,1.0d0)
                  phexp(ifreq)=cdexp(dcmplx(0.0d0,schwingungen*twopi1))
                enddo !ifreq

              else !if (iubunch.eq.0) then

                write(LUNGFO,*)
     &            '*** Error in SOUINTALL: Bad value of IUBUNCH (not -1,0,1,2,3,4)!  ***'
                write(6,*)
     &            '*** Error in SOUINTALL: Bad value of IUBUNCH (not -1,0,1,2,3,4)!  ***'
                stop '*** Program WAVE aborted ***'

              endif !iubunch

              if (iubunch.ne.3.and.iubunch.ne.-1) then

                xelec=SOURCEAO(1,1,ISOUR)
                yelec=SOURCEAO(2,1,ISOUR)
                zelec=SOURCEAO(3,1,ISOUR)

                vx1=SOURCEAO(1,2,ISOUR)
                vy1=SOURCEAO(2,2,ISOUR)
                vz1=SOURCEAO(3,2,ISOUR)

                ypelec=vy1/VX1
                zpelec=vz1/VX1
                egamma=sourceg(1,1,isour)

                xco=xelec
                yco=yelec
                zco=zelec
                ypco=ypelec
                zpco=zpelec
                egammaco=egamma

              endif !(iubunch.ne.3.and.iubunch.ne.1) then

              if (iubunch.ne.3.and.iubunch.ne.4.and.iubunch.ne.-1) then

                CALL RNORML(XRAN,5,rr)

                if (espread.gt.0.0d0.and.iefold.eq.0) then
                  dpp=espread*xran(1)
                  egamma=egamma*(1.0d0+dpp)
                endif

                if (iubunch.ne.1) then

                  if (ifold.eq.0) then
                    if (bsigy(isour).gt.0.0d0) then
                      yy=bsigy(isour)*xran(2)
                    else
                      yy=0.0d0
                    endif
                    if (bsigyp(isour).gt.0.0d0) then
                      yyp=bsigyp(isour)*xran(3)
                    else
                      yyp=0.0d0
                    endif
                    if (bsigz(isour).gt.0.0d0) then
                      zz=bsigz(isour)*xran(4)
                    else
                      zz=0.0d0
                    endif
                    if (bsigzp(isour).gt.0.0d0) then
                      zzp=bsigzp(isour)*xran(5)
                    else
                      zzp=0.0d0
                    endif

                    zelec= tfmhi(1,1)*zz+tfmhi(1,2)*zzp
                    zpelec=tfmhi(2,1)*zz+tfmhi(2,2)*zzp
                    yelec= tfmvi(1,1)*yy+tfmvi(1,2)*yyp
                    ypelec=tfmvi(2,1)*yy+tfmvi(2,2)*yyp
                  endif !ifold

c simple treatment of closed orbit, assume small angles
c bug 4.5.2018!?                  zelec=zz+zco
c                  zpelec=zzp+zpco
c                  yelec=yy+yco
c                  ypelec=yyp+ypco
c                  print*,"debug all:",ielec,zelec
                  zelec=zelec+zco
                  zpelec=zpelec+zpco
                  yelec=yelec+yco
                  ypelec=ypelec+ypco

                else !iubunch.ne.1

c phasespace ellipse: gammah*z**2+2*alphah*z*zp+betah*zp**2=eps0h

                  CALL RNORML(XRAN,5,rr)

c26.4.2024                  if (espread.gt.0.0d0.and.iefold.eq.0) then
c                    egamma=egamma*(1.0d0+espread*xran(1))
c                  endif

                  if (ifold.eq.0) then

                    ! assume beta(s)=beta0(s)+s**2/beta(0) and alpha0=-s/beta(0)
                    ! and a drift transfer-matrix ((1,s),(1,0))

                    alphah=-betaph/2.0d0
                    gammah=(1.0d0+alphah**2)/betah
                    beta0h=1.0d0/gammah
                    s0h=alphah/gammah

                    zz=sqrt(eps0h*beta0h)*xran(2)
                    zzp=-sqrt(eps0h/beta0h)*xran(3)
                    zelec=zz-s0h*zzp !inverse transformation
                    zpelec=zzp

                    alphav=-betapv/2.0d0
                    gammav=(1.0d0+alphav**2)/betav
                    beta0v=1.0d0/gammav
                    s0v=alphav/gammah

                    yy=sqrt(eps0v*beta0v)*xran(4)
                    yyp=-sqrt(eps0v/beta0v)*xran(5)
                    yelec=yy-s0v*yyp
                    ypelec=yyp

c simple treatment of closed orbit, assume small angles

                    xelec=sourceao(1,1,isour)
                    yelec=yelec+sourceao(2,1,isour)
                    zelec=zelec+sourceao(3,1,isour)
                    ypelec=ypelec+sourceao(2,2,isour)/sourceao(1,2,isour)
                    zpelec=zpelec+sourceao(3,2,isour)/sourceao(1,2,isour)

                  else !if (ifold.eq.0) then
                    write(6,*)
     &                '*** Error in souintall: IFOLD.ne.0.and.IUBUNCH.eq.1 are incompatible'
                    write(6,*)'*** Program WAVE aborted ***'
                    write(lungfo,*)
     &                '*** Error in souintall: IFOLD.ne.0.and.IUBUNCH.eq.1 are incompatible'
                    write(lungfo,*)'*** Program WAVE aborted ***'
                    stop
                  endif !(ifold.eq.0) then

                endif !(iubunch.ne.1) then

              endif !iubunch.ne.3.and.iubunch.ne.4.and.iubunch.ne.-1

              if (ielec.eq.1.and.ibunch.eq.-1) then
                egamma=egammafirst
                xelec=xfirst
                yelec=yfirst
                zelec=zfirst
                ypelec=ypfirst
                zpelec=zpfirst
              endif

              if (iwbunch.gt.0) then
                write(22,'(7e20.10)')egamma,bunchx,
     &            xelec,yelec,zelec,ypelec,zpelec
              endif

            endif !ibunch

            vn=clight1*dsqrt((1.0d0-1.0d0/egamma)*(1.0d0+1.0d0/egamma))

            zelec=zelec+dpp*disp0
            zpelec=zpelec+dpp*ddisp0

            vxelec=vn/sqrt(1.0d0+ypelec**2+zpelec**2)
            vyelec=vxelec*ypelec
            vzelec=vxelec*zpelec

            kobsv=nobsv

            call tracks(isour)

            if (mpinr.ne.0) then

              call souintrphi(isour,inside)

            else

              do iobsv=1,kobsv

                if (isour.eq.1.and.iobsv.eq.1.and.nobsv.eq.1.and.ielec.eq.1) then
                  write(6,*)' '
                  write(6,*)
     &              '      counting from 1 to 10 for first source to show progress:'
                  write(6,*)' '
                  write(6,*)' '
                endif

                if (iobsv.eq.1)  then
                  inside=1
                  if (jpin.eq.3) inside=-3
                  call souintana(isour,jobunch,inside)
                  inside=1
                else if (iobsv.eq.jobunch) then
                  call souintana(isour,1,inside)
                else
                  call souintana(isour,iobsv,inside)
                endif

                if (inside.eq.0) then
                  kinside=1
                  write(lungfo,*)
                  write(lungfo,*)
     &              '      found observation point outside radiation cone;'
                  write(lungfo,*)
     &              '      number of source, number and (X,Y,Z) of observation point:'
                  write(lungfo,*)
     &              '      ',isour,iobsv,sngl(obsv(1,iobsv)),
     &              sngl(obsv(2,iobsv)),sngl(obsv(3,iobsv))
                  write(lungfo,*)
                endif   !inside

              enddo !nobsv

            endif !mpinr

          enddo !isub=1,neinbunch
        enddo !ibun=1,nbunch

C CALCULATE DISTRIBUTION IN PINHOLE }

      ELSE !JPIN.NE.2

        if (mpinr.gt.0)
     &    stop '*** Error in SOUINTALL: MPINR NOT ALLOWED FOR IPIN.EQ.2'

      ENDIF !JPIN.NE.2

      IF (ISPECMODE.EQ.1.AND.ISOUR.EQ.NSOURCE) THEN
        DEALLOCATE(DWT)
        DEALLOCATE(DWX)
        DEALLOCATE(DWX2P)
        DEALLOCATE(DWB)
        DEALLOCATE(DWB2P)
        DEALLOCATE(DWY)
        DEALLOCATE(DWY2P)
        DEALLOCATE(DWZ)
        DEALLOCATE(DWZ2P)
      ENDIF

      IF (AMPRAN.NE.0.D0.AND.IAMPLI.LT.0) THEN
        DEALLOCATE(XRANA)
      ENDIF   !(AMPRAN.NE.0.D0)

      IF (ISOUR.EQ.NSOURCE.AND.KINSIDE.NE.0) THEN
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN SOUINTALL:'
        WRITE(6,*)'there are observation points outside radiation cone'
        WRITE(6,*)'maybe WGWINFC, WBL0CUT... or collimators not suitable'
        WRITE(6,*)'see output file WAVE.OUT for details'
        WRITE(6,*)
      ENDIF !KINSIDE

      IPIN=JPIN
      IFOLD=JFOLD
      IEFOLD=JEFOLD

      deallocate(phrnrn)
      deallocate(phexp)
      if (mpinr.ne.0) then
        deallocate(phaserphi);
        deallocate(expom1rphi);
        deallocate(afferphi)
        deallocate(unphrphi)
      else
        deallocate(affe)
      endif
      deallocate(ampz)
      deallocate(azcos)
      deallocate(azsin)

      if (ibunch.ne.0.and.isour.eq.nsource.and.ilintra.lt.0) then
        deallocate(wbeta)
        deallocate(wbetak)
      endif !ibunch.ne.0

      deallocate(ampzmax,kobs)

      RETURN
      END subroutine souintall
