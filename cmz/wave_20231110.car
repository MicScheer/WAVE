+PATCH,FOR.
*CMZ : 00.00/00 10/01/95  15.22.39  by  Michael Scheer
+DECK,gfinit.
*CMZ :          07/11/2023  14.41.30  by  Michael Scheer
*CMZ :  4.01/03 29/06/2023  10.07.32  by  Michael Scheer
*CMZ :  4.01/03 15/05/2023  16.38.53  by  Michael Scheer
*CMZ :  4.01/02 14/05/2023  13.42.26  by  Michael Scheer
*CMZ :  4.01/00 08/01/2023  16.56.29  by  Michael Scheer
*CMZ :  4.00/17 15/11/2022  10.57.19  by  Michael Scheer
*CMZ :  4.00/16 09/09/2022  17.24.46  by  Michael Scheer
*CMZ :  4.00/15 30/05/2022  15.47.16  by  Michael Scheer
*CMZ :  4.00/14 30/12/2021  11.57.49  by  Michael Scheer
*CMZ :  4.00/13 09/11/2021  09.50.16  by  Michael Scheer
*CMZ :  4.00/11 27/06/2021  11.57.49  by  Michael Scheer
*CMZ :  4.00/10 22/09/2020  09.17.04  by  Michael Scheer
*CMZ :  4.00/07 06/06/2020  13.59.12  by  Michael Scheer
*CMZ :  4.00/06 02/12/2019  15.36.11  by  Michael Scheer
*CMZ :  4.00/04 24/09/2019  10.58.03  by  Michael Scheer
*CMZ :  4.00/03 09/05/2019  11.04.11  by  Michael Scheer
*CMZ :  4.00/01 12/04/2019  10.43.33  by  Michael Scheer
*CMZ :  4.00/00 04/04/2019  12.37.42  by  Michael Scheer
*CMZ :  3.08/01 03/04/2019  16.19.59  by  Michael Scheer
*CMZ :  3.07/01 29/03/2019  14.39.14  by  Michael Scheer
*CMZ :  3.06/00 28/02/2019  15.01.36  by  Michael Scheer
*CMZ :  3.05/28 18/12/2018  13.52.06  by  Michael Scheer
*CMZ :  3.05/14 25/09/2018  08.52.05  by  Michael Scheer
*CMZ :  3.05/13 19/09/2018  13.56.36  by  Michael Scheer
*CMZ :  3.05/06 17/07/2018  11.15.16  by  Michael Scheer
*CMZ :  3.05/05 11/07/2018  09.20.23  by  Michael Scheer
*CMZ :  3.05/04 28/06/2018  09.36.14  by  Michael Scheer
*CMZ :  3.05/03 18/05/2018  11.56.52  by  Michael Scheer
*CMZ :  3.05/02 15/05/2018  16.25.19  by  Michael Scheer
*CMZ :  3.05/01 04/05/2018  16.04.30  by  Michael Scheer
*CMZ :  3.05/00 26/04/2018  15.51.12  by  Michael Scheer
*CMZ :  3.04/00 01/03/2018  12.10.21  by  Michael Scheer
*CMZ :  3.03/04 06/11/2017  16.05.55  by  Michael Scheer
*CMZ :  3.03/02 28/06/2017  13.49.04  by  Michael Scheer
*CMZ :  3.03/01 11/11/2015  14.37.19  by  Michael Scheer
*CMZ :  3.03/00 25/09/2015  15.02.58  by  Michael Scheer
*CMZ :  3.02/09 08/07/2015  12.22.02  by  Michael Scheer
*CMZ :  3.02/06 12/06/2015  15.06.01  by  Michael Scheer
*CMZ :  3.02/05 22/03/2015  19.47.46  by  Michael Scheer
*CMZ :  3.02/04 11/03/2015  13.46.12  by  Michael Scheer
*CMZ :  3.02/03 10/11/2014  11.01.30  by  Michael Scheer
*CMZ :  3.02/00 09/09/2014  13.16.05  by  Michael Scheer
*CMZ :  3.01/10 14/08/2014  14.43.07  by  Michael Scheer
*CMZ :  3.01/08 04/07/2014  09.03.18  by  Michael Scheer
*CMZ :  3.01/06 20/06/2014  16.28.51  by  Michael Scheer
*CMZ :  3.01/01 18/09/2013  12.33.23  by  Michael Scheer
*CMZ :  3.01/00 18/07/2013  11.34.23  by  Michael Scheer
*CMZ :  3.00/02 08/04/2013  14.49.02  by  Michael Scheer
*CMZ :  3.00/01 20/03/2013  14.29.33  by  Michael Scheer
*CMZ :  3.00/00 14/03/2013  10.24.03  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.70/11 22/02/2013  14.32.53  by  Michael Scheer
*CMZ :  2.70/09 15/01/2013  13.58.17  by  Michael Scheer
*CMZ :  2.70/08 14/01/2013  17.39.36  by  Michael Scheer
*CMZ :  2.70/07 14/01/2013  16.55.40  by  Michael Scheer
*CMZ :  2.70/06 03/01/2013  15.40.36  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  14.05.34  by  Michael Scheer
*CMZ :  2.70/04 21/12/2012  10.03.13  by  Michael Scheer
*CMZ :  2.70/01 12/12/2012  12.39.56  by  Michael Scheer
*CMZ :  2.69/02 05/11/2012  12.35.44  by  Michael Scheer
*CMZ :  2.69/00 30/10/2012  16.25.27  by  Michael Scheer
*CMZ :  2.68/05 18/10/2012  09.38.10  by  Michael Scheer
*CMZ :  2.68/03 27/08/2012  15.39.32  by  Michael Scheer
*CMZ :  2.68/02 01/08/2012  14.02.50  by  Michael Scheer
*CMZ :  2.68/01 29/05/2012  16.08.27  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  09.56.07  by  Michael Scheer
*CMZ :  2.67/06 24/05/2012  12.11.08  by  Michael Scheer
*CMZ :  2.67/05 16/05/2012  13.53.49  by  Michael Scheer
*CMZ :  2.67/04 15/05/2012  12.59.15  by  Michael Scheer
*CMZ :  2.67/02 08/05/2012  16.36.00  by  Michael Scheer
*CMZ :  2.67/00 16/02/2012  13.07.31  by  Michael Scheer
*CMZ :  2.66/22 22/11/2011  13.58.07  by  Michael Scheer
*CMZ :  2.66/20 22/11/2011  10.45.51  by  Michael Scheer
*CMZ :  2.66/17 23/11/2010  10.01.44  by  Michael Scheer
*CMZ :  2.66/16 22/11/2010  14.00.45  by  Michael Scheer
*CMZ :  2.66/13 15/07/2010  12.58.56  by  Michael Scheer
*CMZ :  2.66/12 20/05/2010  09.00.48  by  Michael Scheer
*CMZ :  2.66/09 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.66/07 10/03/2010  12.23.23  by  Michael Scheer
*CMZ :  2.66/06 27/11/2009  15.57.31  by  Michael Scheer
*CMZ :  2.66/04 24/11/2009  08.18.52  by  Michael Scheer
*CMZ :  2.66/03 16/11/2009  13.49.00  by  Michael Scheer
*CMZ :  2.65/03 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  2.65/02 29/09/2009  09.24.12  by  Michael Scheer
*CMZ :  2.64/01 14/09/2009  15.19.42  by  Michael Scheer
*CMZ :  2.64/00 18/08/2009  15.17.59  by  Michael Scheer
*CMZ :  2.63/05 12/08/2009  08.49.28  by  Michael Scheer
*CMZ :  2.63/03 15/04/2008  09.57.05  by  Michael Scheer
*CMZ :  2.63/02 13/03/2008  15.28.16  by  Michael Scheer
*CMZ :  2.63/00 10/01/2008  12.43.13  by  Michael Scheer
*CMZ :  2.62/02 16/07/2007  08.39.06  by  Michael Scheer
*CMZ :  2.61/05 11/04/2007  11.58.30  by  Michael Scheer
*CMZ :  2.61/02 26/03/2007  20.08.09  by  Michael Scheer
*CMZ :  2.60/00 26/01/2007  10.48.21  by  Michael Scheer
*CMZ :  2.59/01 24/01/2007  14.13.43  by  Michael Scheer
*CMZ :  2.58/00 16/01/2007  12.28.50  by  Michael Scheer
*CMZ :  2.57/05 13/12/2006  10.49.24  by  Michael Scheer
*CMZ :  2.57/00 22/11/2005  09.53.36  by  Michael Scheer
*CMZ :  2.56/02 21/10/2005  13.13.47  by  Michael Scheer
*CMZ :  2.56/00 17/10/2005  12.32.39  by  Michael Scheer
*CMZ :  2.55/00 10/08/2005  13.53.39  by  Michael Scheer
*CMZ :  2.54/07 16/06/2005  09.40.54  by  Michael Scheer
*CMZ :  2.54/06 02/06/2005  13.53.54  by  Michael Scheer
*CMZ :  2.54/05 02/06/2005  08.14.28  by  Michael Scheer
*CMZ :  2.54/01 07/03/2005  10.32.21  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  11.05.51  by  Michael Scheer
*CMZ :  2.52/16 07/01/2005  16.08.34  by  Michael Scheer
*CMZ :  2.52/15 05/01/2005  16.24.14  by  Michael Scheer
*CMZ :  2.52/13 16/12/2004  21.13.02  by  Michael Scheer
*CMZ :  2.52/10 08/12/2004  13.39.18  by  Michael Scheer
*CMZ :  2.52/09 29/10/2004  11.12.01  by  Michael Scheer
*CMZ :  2.52/05 16/08/2004  13.37.21  by  Michael Scheer
*CMZ :  2.52/00 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.51/02 22/06/2004  13.57.32  by  Michael Scheer
*CMZ :  2.51/01 16/06/2004  17.05.27  by  Michael Scheer
*CMZ :  2.51/00 26/05/2004  16.17.52  by  Michael Scheer
*CMZ :  2.50/02 30/04/2004  15.27.48  by  Michael Scheer
*CMZ :  2.50/00 29/04/2004  17.07.53  by  Michael Scheer
*CMZ :  2.49/00 19/03/2004  17.58.17  by  Michael Scheer
*CMZ :  2.48/04 16/03/2004  10.43.05  by  Michael Scheer
*CMZ :  2.48/03 03/03/2004  12.49.38  by  Michael Scheer
*CMZ :  2.47/23 17/02/2004  11.00.48  by  Michael Scheer
*CMZ :  2.47/18 27/11/2003  14.31.04  by  Michael Scheer
*CMZ :  2.47/15 08/08/2003  10.34.03  by  Michael Scheer
*CMZ :  2.47/14 07/08/2003  09.42.49  by  Michael Scheer
*CMZ :  2.47/12 03/07/2003  09.22.07  by  Michael Scheer
*CMZ :  2.47/10 28/05/2003  15.25.10  by  Michael Scheer
*CMZ :  2.47/09 27/05/2003  15.50.23  by  Michael Scheer
*CMZ :  2.47/08 16/05/2003  14.34.52  by  Michael Scheer
*CMZ :  2.47/07 14/04/2003  14.14.46  by  Michael Scheer
*CMZ :  2.47/06 28/03/2003  15.40.34  by  Michael Scheer
*CMZ :  2.47/04 13/03/2003  09.59.14  by  Michael Scheer
*CMZ :  2.47/03 12/03/2003  15.45.44  by  Michael Scheer
*CMZ :  2.44/01 11/12/2002  11.15.11  by  Michael Scheer
*CMZ :  2.44/00 08/11/2002  11.15.00  by  Michael Scheer
*CMZ :  2.41/13 02/09/2002  15.35.59  by  Michael Scheer
*CMZ :  2.41/07 15/07/2002  16.10.05  by  Michael Scheer
*CMZ :  2.41/06 10/05/2002  15.24.47  by  Michael Scheer
*CMZ :  2.41/03 21/03/2002  12.44.08  by  Michael Scheer
*CMZ :  2.41/02 21/03/2002  12.41.22  by  Michael Scheer
*CMZ :  2.41/00 20/03/2002  14.16.00  by  Michael Scheer
*CMZ :  2.40/03 20/03/2002  12.31.55  by  Michael Scheer
*CMZ :  2.38/00 13/12/2001  11.26.22  by  Michael Scheer
*CMZ :  2.37/06 07/12/2001  15.01.29  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.35/02 30/10/2001  17.13.56  by  Michael Scheer
*CMZ :  2.34/09 19/09/2001  13.39.52  by  Michael Scheer
*CMZ :  2.34/08 11/09/2001  14.21.00  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  10.25.20  by  Michael Scheer
*CMZ :  2.34/03 11/07/2001  11.18.43  by  Michael Scheer
*CMZ :  2.34/01 01/06/2001  15.26.15  by  Michael Scheer
*CMZ :  2.33/06 04/05/2001  13.56.33  by  Michael Scheer
*CMZ :  2.33/00 03/05/2001  10.35.09  by  Michael Scheer
*CMZ :  2.32/04 26/04/2001  12.17.53  by  Michael Scheer
*CMZ :  2.32/03 26/04/2001  11.11.52  by  Michael Scheer
*CMZ :  2.32/02 26/04/2001  11.09.09  by  Michael Scheer
*CMZ :  2.31/01 25/04/2001  15.12.03  by  Michael Scheer
*CMZ :  2.30/04 23/04/2001  12.32.14  by  Michael Scheer
*CMZ :  2.30/03 20/04/2001  16.29.29  by  Michael Scheer
*CMZ :  2.20/10 05/04/2001  16.02.13  by  Michael Scheer
*CMZ :  2.20/09 23/03/2001  11.10.39  by  Michael Scheer
*CMZ :  2.20/03 21/02/2001  14.28.56  by  Michael Scheer
*CMZ :  2.20/01 20/02/2001  14.28.03  by  Michael Scheer
*CMZ :  2.20/00 07/11/2000  18.38.35  by  Michael Scheer
*CMZ :  2.17/00 07/11/2000  18.36.28  by  Michael Scheer
*CMZ :  2.16/09 01/11/2000  19.18.54  by  Michael Scheer
*CMZ :  2.16/08 01/11/2000  18.46.41  by  Michael Scheer
*CMZ :  2.16/07 13/10/2000  12.33.36  by  Michael Scheer
*CMZ :  2.16/05 25/08/2000  16.07.46  by  Michael Scheer
*CMZ :  2.16/04 21/07/2000  14.48.52  by  Michael Scheer
*CMZ :  2.16/03 19/06/2000  12.19.35  by  Michael Scheer
*CMZ :  2.16/02 15/06/2000  17.28.05  by  Michael Scheer
*CMZ :  2.16/01 15/06/2000  17.27.10  by  Michael Scheer
*CMZ :  2.16/00 15/06/2000  12.08.02  by  Michael Scheer
*CMZ :  2.15/00 19/05/2000  11.05.28  by  Michael Scheer
*CMZ :  2.14/02 19/04/2000  17.14.40  by  Michael Scheer
*CMZ :  2.14/01 19/04/2000  13.54.26  by  Michael Scheer
*CMZ :  2.14/00 19/04/2000  11.58.09  by  Michael Scheer
*CMZ :  2.13/10 23/03/2000  13.06.35  by  Michael Scheer
*CMZ :  2.13/11 10/03/2000  15.07.30  by  Michael Scheer
*CMZ :  2.13/10 09/03/2000  17.39.34  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  18.08.34  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  17.10.43  by  Michael Scheer
*CMZ :  2.13/08 02/03/2000  12.13.35  by  Michael Scheer
*CMZ :  2.13/07 18/02/2000  12.32.29  by  Michael Scheer
*CMZ :  2.13/04 24/01/2000  17.59.24  by  Michael Scheer
*CMZ :  2.13/02 14/12/99  16.41.31  by  Michael Scheer
*CMZ :  2.13/00 26/10/99  15.40.04  by  Michael Scheer
*CMZ :  2.12/04 27/08/99  12.30.27  by  Michael Scheer
*CMZ :  2.12/03 06/08/99  15.36.20  by  Michael Scheer
*CMZ :  2.12/02 15/06/99  16.13.28  by  Michael Scheer
*CMZ :  2.12/01 14/06/99  15.34.53  by  Michael Scheer
*CMZ :  2.12/00 04/06/99  13.28.31  by  Michael Scheer
*CMZ :  2.11/01 12/05/99  12.19.46  by  Michael Scheer
*CMZ :  2.11/00 11/05/99  16.21.08  by  Michael Scheer
*CMZ :  2.10/02 07/05/99  12.23.41  by  Michael Scheer
*CMZ :  2.10/01 17/03/99  18.20.52  by  Michael Scheer
*CMZ :  2.02/00 15/02/99  10.20.15  by  Michael Scheer
*CMZ :  2.01/00 21/01/99  16.58.37  by  Michael Scheer
*CMZ :  2.00/03 13/01/99  10.57.51  by  Michael Scheer
*CMZ :  2.00/01 11/01/99  16.06.57  by  Michael Scheer
*CMZ :  2.00/00 11/01/99  16.04.55  by  Michael Scheer
*CMZ :  1.04/03 11/12/98  16.57.07  by  Michael Scheer
*CMZ :  1.04/02 11/12/98  11.35.47  by  Michael Scheer
*CMZ :  1.04/01 11/12/98  11.21.43  by  Michael Scheer
*CMZ :  1.04/00 11/12/98  10.45.26  by  Michael Scheer
*CMZ :  1.03/06 02/10/98  15.51.15  by  Michael Scheer
*CMZ :  1.03/05 27/04/98  13.57.17  by  Michael Scheer
*CMZ :  1.03/04 27/03/98  14.22.25  by  Michael Scheer
*CMZ :  1.03/02 23/02/98  14.31.16  by  Michael Scheer
*CMZ :  1.03/01 10/02/98  17.33.38  by  Michael Scheer
*CMZ :  1.03/00 16/01/98  14.55.02  by  Michael Scheer
*CMZ :  1.02/05 16/01/98  11.00.30  by  Michael Scheer
*CMZ :  1.02/04 16/01/98  10.59.38  by  Michael Scheer
*CMZ :  1.02/02 06/01/98  17.07.13  by  Michael Scheer
*CMZ :  1.02/00 06/01/98  14.56.08  by  Michael Scheer
*CMZ :  1.01/01 10/12/97  13.23.56  by  Michael Scheer
*CMZ :  1.01/00 04/12/97  15.59.21  by  Michael Scheer
*CMZ :  1.00/04 21/10/97  13.41.08  by  Michael Scheer
*CMZ :  1.00/03 20/10/97  15.20.55  by  Michael Scheer
*CMZ :  1.00/02 20/10/97  15.15.32  by  Michael Scheer
*CMZ :  1.00/00 29/09/97  17.11.38  by  Michael Scheer
*CMZ : 00.02/05 16/04/97  16.32.33  by  Michael Scheer
*CMZ : 00.02/04 25/02/97  17.37.37  by  Michael Scheer
*CMZ : 00.02/03 31/01/97  11.25.25  by  Michael Scheer
*CMZ : 00.02/02 15/01/97  13.21.25  by  Michael Scheer
*CMZ : 00.02/01 18/12/96  13.23.11  by  Michael Scheer
*CMZ : 00.01/12 07/10/96  13.32.57  by  Michael Scheer
*CMZ : 00.01/10 02/09/96  13.52.46  by  Michael Scheer
*CMZ : 00.01/09 28/05/96  12.08.51  by  Michael Scheer
*CMZ : 00.01/08 17/07/95  16.20.53  by  Michael Scheer
*CMZ : 00.01/07 23/03/95  11.36.42  by  Michael Scheer
*CMZ : 00.01/04 27/01/95  10.15.13  by  Michael Scheer
*CMZ : 00.01/03 28/11/94  12.04.13  by  Michael Scheer
*CMZ : 00.01/02 22/11/94  10.20.21  by  Michael Scheer
*CMZ : 00.01/01 23/06/94  13.25.42  by  Michael Scheer
*CMZ : 00.01/00 21/06/94  09.57.03  by  Michael Scheer
*CMZ : 00.00/07 25/05/94  17.37.44  by  Michael Scheer
*CMZ : 00.00/06 29/04/94  21.08.08  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  18.05.26  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.33  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE GFINIT(BETX0,BETY0,BETZ0,BETXF0,BETYF0,BETZF0,
     &                     DTIM,BSHIFT,GAMMA)
+seq,gplhint.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,WFOLDF90U.
+SEQ,TRACKF90U.
+SEQ,WBETAF90U.
+SEQ,BPOLYMAGF90U.
+SEQ,bwpolyederf90U.

      use omp_lib
      use ompmod
      use bunchmod
      use clustermod
      use f1k
      !use waveenv
      use fbtabzymod
      !use waveenv

      IMPLICIT NONE

+seq,datetime.
+SELF,IF=LINUX.
      EXTERNAL DCOSD,DSIND
      DOUBLE PRECISION  DCOSD,DSIND
+SELF.

      INTEGER IGFNUM,ICOMP,ISTORE,IAMBI,I,IELEM,ISTO,IROI,JWSECTMAGS,
     &  KSUM,lun,idum,lunsi,ieof,istat,iclusterold

      DOUBLE PRECISION BETX0,BETY0,BETZ0,ZP0,YP0,ZPF0,YPF0,
     &  BETXF0,BETYF0,BETZF0,BTAPV,BTAPH,dtshort,
     &  DTIM,BSHIFT,GAMMA,XJUST,YJUST,XSTARTO,XSTOPO

      DOUBLE PRECISION ZP,YP,VXINO,VYINO,VZINO,YSTARTO,ZSTARTO
     &  ,GAMMAL,gamma1,omegac,emom1,rho1,vxi,vyi,vzi,
     &  wlen1,rhv,park,b0eff

+SELF,IF=-NOCMPLX.
      COMPLEX*16 VPOLAN
+SELF,IF=NOCMPLX.
      DOUBLE PRECISION VPOLAN
+SELF.
      DOUBLE PRECISION VSTO

      DOUBLE PRECISION BETA,VN,V0,ENERGV
      DOUBLE PRECISION BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM,DUM
      DOUBLE PRECISION ENEGEV,TAUPOL0,TAUPOL0EP,BSTORE,BSTORE2,BSTORE2Z
      DOUBLE PRECISION BDIPL1G,POLFC1G,POLLV1G,TAUPL1G,EMINPOL
      DOUBLE PRECISION BDIPLEP,POLFCEP,ASTORE,XSTOPR
      DOUBLE PRECISION BSTOREY,BSTOREZ,ASTOREZ,ASTOREY
      DOUBLE PRECISION BY,RI,TANPHI,BANA,BPANA,BANAC,BPANAC,
     &  YCEN,ZCEN,YPCEN,ZPCEN

+SEQ,CMPARA.
+seq,pawcmn.
+SEQ,CONTRL.
+SEQ,B0SCGLOB.
+SEQ,MYFILES.
+SEQ,OPTIC.
+SEQ,BFELD.
+SEQ,mgsqc.
+SEQ,HALBACH.
+SEQ,HALBASY.
+SEQ,undugap.
+SEQ,FOURIER.
+SEQ,TRANPO.
+SEQ,DEPOLA.
+SEQ,WLSOPT.
+SEQ,TRACK.
+SEQ,BETAWLS.
+seq,wbetaf90.
+SEQ,PHYCON.
+SEQ,COLLI.
+seq,reargf90.
+seq,sourcef90.
+SEQ,SPECT.
+SEq,wfoldf90.
+SEq,observf90.
+SEQ,FREQS.
+SEQ,UCROSS.
+SEQ,ELLIP.
+SEQ,ELLANA.
+SEQ,WBTAB.
+SEQ,USERVAR.
+SEQ,KLOTZ.
+SEQ,MODULATOR.
+SEQ,BMAP.
+SEQ,BAMWLS.
+SEQ,BPOLY3D.
+SEQ,BPOLY2DH.
+SEQ,BPHARM.
+SEQ,BPOLY3DG.
+SEQ,BHELM.
+SEQ,TRALIN.
+SEQ,PHASETRACK.
+SEQ,SPECDIP.
+SEQ,BFORCE.
+SEq,phasef90.
+SEQ,AMPLI.
+SEQ,BERROR.
+SEQ,CMZSEL.
+SEQ,GENESIS.
+SEQ,TRACK0.
+seq,primkin.
+seq,efield.
+seq,photon.
c+seq,gseed,if=grndm.
+seq,random.
+seq,ustep.
+seq,whbook.
+seq,undumagc.
+seq,waveenv.

      integer irootmode

+SELF,IF=-newwave.
      stop '**** +self,if=newwave ist erforderlich! ***'
+SELF.
+SELF,IF=-f90.
      stop '**** +self,if=f90 ist erforderlich! ***'
+SELF.
+SELF,IF=NOCMPLX.
      stop '**** +self,if=nocmplx ist obsolet! ***'
+SELF.

C--- LOGICAL UNITS
      LUNGFI=15
      LUNGFO=16
      FILEI='wave.in'
      FILEGFO='wave.out'
+SELF,IF=HPUX,TRUE64.
      call system('rm wave.out 2>/dev/null')
      CALL UNCOMNAMELIST
      FILEI='wave.in.linux'
      FILEGFO='wave.out'
+SELF,IF=VMS.
      FILEI='WI:WAVE.IN'
      FILEGFO='WO:WAVE.OUT'
+SELF.

C--- CHECK CMZ-SELECTIONS{

      IXAMAG_I=0
      ICMZF90=1

+SELF,IF=NEWWAVE.
      ICMZNEWWAVE=1
+SELF.

+SELF,IF=F90.
      ICMZNOCMPLX=1
+SELF.

+SELF,IF=VMS.
      ICMZVMS=1
+SELF,IF=-VMS.
      ICMZVMS=0
+SELF.

+SELF,IF=HPUX.
      ICMZHPUX=1
+SELF,IF=-HPUX.
      ICMZHPUX=0
+SELF.

+SELF,IF=TRUE64.
        ICMZTRUE64=1
+SELF,IF=-TRUE64.
        ICMZTRUE64=0
+SELF.

+SELF,IF=LINUX.
      ICMZLINUX=1
+SELF,IF=-LINUX.
      ICMZLINUX=0
+SELF.

+SELF,IF=WINDOWS.
      ICMZWINDOWS=1
+SELF,IF=-WINDOWS.
      ICMZWINDOWS=0
+SELF.

        IF (ABS(ICMZVMS)+ABS(ICMZLINUX)+ABS(ICMZHPUX)+ABS(ICMZTRUE64)+
     &      ABS(ICMZWINDOWS).NE.1) THEN
          WRITE(6,*)'*** BAD CMZ-SELECTION VMS, LINUX OR WINDOWS ***'
          STOP
      ENDIF

+seq,setf1k.

C--- CHECK CMZ-SELECTIONS}

C     CALL UTIL_TEST_BATCH(IBATCH)

      fouentr=-9999.
      fouexit=-9999.
      scbfour=-9999.
      xshbfour=-9999.

      XINTER=-9999.
      xbetfun=9999.
      IW_BLEN=0
      IW_BLENF=0
      IW_CIRC=0

      BMAXGL2=-1.0D30

C--- PHYSICAL CONSTANTS

+seq,phycon1.

+SELF,IF=LINUX,WINDOWS.
      XMX=-1.0D30
      YMX=-1.0D30
      ZMX=-1.0D30
      BXMX=-1.0D30
      BYMX=-1.0D30
      BZMX=-1.0D30
      PHIMX=-1.0D30
      XMN=1.0D30
      YMN=1.0D30
      ZMN=1.0D30
      BXMN=1.0D30
      BYMN=1.0D30
      BZMN=1.0D0
      PHIMN=1.0D30
+SELF.

C--- STORE DIMENSION-PARAMETERS

      NDPOL=NDPOLP
      NDOBSVZ=NDOBSVZP
      NDOBSVY=NDOBSVYP
      NDMASHZ=NDMASHZP
      NDMASHY=NDMASHYP
+self,if=-mhbook.
      NDPAWC=NDPAWCP
+self.
      NDARGU=NDARGUP
      NDFREQ=NDFREQP
      NDOBSV=NDOBSVP
      NWMAX=NWMAXP
      NBETA=NBETAP
C5.10.95      NBDIM=NBDIMP
      LIDIM=LIDIMP
      NOMDIM=NOMDIMP
      IBFDIM4=IBFDIM4P
      IBFDIM2=IBFDIM2P
      NXPAN=NXPANP
      NYPAN=NYPANP
      NBTAB=NBTABP
      NDWSOU=NDWSOUP
      NGCOEF=NGCOEFP
      NDSPAR=NDSPARP

      IF(NDOBSVZ*NDOBSVY.NE.NDOBSV) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'     DIMENSION DECLARATIONS NOT CONSISTENT'
        WRITE(LUNGFO,*)'     NDOBSVP MUST BE EQUAL TO NDOBSVZP*NDOBSVYP'
        WRITE(LUNGFO,*)'     CHANGE PARAMETER IN CMPARA.CMN'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'     *** ERROR IN GFINIT ***'
        WRITE(6,*)'     DIMENSION DECLARATIONS NOT CONSISTENT'
        WRITE(6,*)'     NDOBSVP MUST BE EQUAL TO NDOBSVZP*NDOBSVYP'
        WRITE(6,*)'     CHANGE PARAMETER IN CMPARA.'
        WRITE(6,*)
        STOP
      ENDIF

C--- READ PARAMETER AND CONTRL-FLAGS FROM NAMELISTS

      iclusterold=icluster

      OPEN (UNIT=LUNGFI,FILE=FILEI,STATUS='OLD')

      READ(LUNGFI, CONTRL )
+SELF,if=grndm.
c      READ(LUNGFI,gseedn)
+SELF.,if=grndm.
      READ(LUNGFI,randomn)
      READ(LUNGFI,cluster)
c     WRITE(6,*)'READING NAMELIST B0SCGLOBN'
      READ(LUNGFI, B0SCGLOBN )
      IF(IBHELM.NE.0 ) WRITE(6,*)'READING NAMELIST BBHELM'
      IF(IBHELM.NE.0 ) READ(LUNGFI, BBHELM )
c     WRITE(6,*)'READING NAMELIST BBFELD'
      READ(LUNGFI, BBFELD )
c     WRITE(6,*)'READING NAMELIST HALBACH'
      READ(LUNGFI, HALBACH )
c     WRITE(6,*)'READING NAMELIST HALBASY'
      READ(LUNGFI, HALBASY )
      READ(LUNGFI, undugapn)
c     WRITE(6,*)'READING NAMELIST UCROSSN'
      READ(LUNGFI, UCROSSN )
c     WRITE(6,*)'READING NAMELIST ELLIPN'
      READ(LUNGFI, ELLIPN )
c     WRITE(6,*)'READING NAMELIST ELLANAN'
      READ(LUNGFI, ELLANAN )
c     WRITE(6,*)'READING NAMELIST FOURIER'
      READ(LUNGFI, FOURIER )
      if (ifourbtabzy.ne.0) READ(LUNGFI, fbtabzyn )
c     WRITE(6,*)'READING NAMELIST DEPOLA'
      READ(LUNGFI, DEPOLA )
c     WRITE(6,*)'READING NAMELIST WLSOPTN'
      READ(LUNGFI, WLSOPTN )
c     WRITE(6,*)'READING NAMELIST MYFILES'
      READ(LUNGFI, MYFILES )
c     WRITE(6,*)'READING NAMELIST TRALINN'
      READ(LUNGFI, TRALINN )
c     WRITE(6,*)'READING NAMELIST PHASETRACKN'
      READ(LUNGFI, PHASETRACKN )
c     WRITE(6,*)'READING NAMELIST OPTIK'
      READ(LUNGFI, OPTIK )
c     WRITE(6,*)'READING NAMELIST TRANPON'
      READ(LUNGFI, TRANPON )
c     WRITE(6,*)'READING NAMELIST COLLIN'
      READ(LUNGFI, COLLIN )
c     WRITE(6,*)'READING NAMELIST SPECTN'
      READ(LUNGFI, SPECTN )
c     WRITE(6,*)'READING NAMELIST WFOLDN'
      READ(LUNGFI, WFOLDN )
      READ(LUNGFI,BUNCHN)
c     WRITE(6,*)'READING NAMELIST PINHOLE'
      READ(LUNGFI, PINHOLE )
c     WRITE(6,*)'READING NAMELIST FREQN'
      READ(LUNGFI, FREQN )
c     WRITE(6,*)'READING NAMELIST WBTABN'
      READ(LUNGFI, WBTABN )
c     WRITE(6,*)'READING NAMELIST RECN'
      READ(LUNGFI, RECN )
c     WRITE(6,*)'READING NAMELIST MODUN'
      READ(LUNGFI, MODUN )
c      IF (kbundumag.ne.0) THEN
        READ(LUNGFI,unduhybridn)
        READ(LUNGFI,undumagn)
        kbundumag_c=kbundumag
        kbunduverb_c=kbunduverb
        kbundumap_c=kbundumap
c      ENDIF
      IF (KBPOLYMAG.GT.0) THEN
c        WRITE(6,*)'READING NAMELIST POLYMAGN'
        READ(LUNGFI,POLYMAGN)
      ENDIF
c     WRITE(6,*)'READING NAMELIST BMAPN'
      READ(LUNGFI, BMAPN )
c     WRITE(6,*)'READING NAMELIST BAMWLSN'
      IF (KBAMWLS.NE.0) READ(LUNGFI, BAMWLSN )
c     WRITE(6,*)'READING NAMELIST BPOLY3DN'
      READ(LUNGFI, BPOLY3DN )
c     WRITE(6,*)'READING NAMELIST BPOLY2DHN'
      READ(LUNGFI, BPOLY2DHN )
c     WRITE(6,*)'READING NAMELIST BPHARMN'
      READ(LUNGFI, BPHARMN )
c     WRITE(6,*)'READING NAMELIST BGRIDN'
      READ(LUNGFI, BGRIDN )
c     WRITE(6,*)'READING NAMELIST SPECDIPN'
      READ(LUNGFI, SPECDIPN )

C--- READ AND WRITE CURRENT NUMBER

      OPEN(UNIT=LUNCOD,FILE=FILECOD,STATUS='OLD',FORM='FORMATTED',
     &       ERR=99)
          READ(LUNCOD,*,ERR=99)IGFNUM

99    IGFNUM=IGFNUM+1

      CLOSE(LUNCOD)
+SELF,IF=VMS.
      OPEN(UNIT=LUNCOD,FILE=FILECOD,STATUS='NEW',FORM='FORMATTED')
+SELF,IF=LINUX,WINDOWS,HPUX,TRUE64.
      OPEN(UNIT=LUNCOD,FILE=FILECOD,status='unknown',FORM='FORMATTED')
      REWIND(LUNCOD)
+SELF.
      WRITE(LUNCOD,*)IGFNUM
      ICODE=IGFNUM
C          IF(IGFLOAT.NE.0) ICODE=-ICODE
      CLOSE(LUNCOD)

C--- OPEN OUTPUT-FILE

      call util_file_delete(trim(filegfo),istat)
      OPEN (UNIT=LUNGFO,FILE=FILEGFO)

      CALL ZEIT(LUNGFO)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'          *********************************************'
      WRITE(LUNGFO,*)'          *          PROGRAM WAVE                     *'
      WRITE(LUNGFO,*)'          *                                           *'
      WRITE(LUNGFO,*)
+SEQ,WVERSION.
      WRITE(LUNGFO,*)'          *                                           *'
      WRITE(LUNGFO,*)'          *          Michael Scheer                   *'
      WRITE(LUNGFO,*)'          *              BESSY                        *'
      WRITE(LUNGFO,*)'          *********************************************'
      WRITE(LUNGFO,*)

      write(lungfo,*)
      write(lungfo,*)"     Compiler-Version: ",trim(chcompiler)
      write(lungfo,*)"     Hostname: ",trim(chhostname)
      write(lungfo,*)"     Working directory: ",trim(chcwd)
      write(lungfo,*)

      WRITE(LUNGFO,*)'     USER COMMENT:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     ',CODE
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     CURRENT NUMBER:',ICODE
      WRITE(LUNGFO,*)


      WRITE(6,*)
      WRITE(6,*)
      WRITE(6,*)'          USER COMMENT:'
      WRITE(6,*)
      WRITE(6,*)'          ',CODE
      WRITE(6,*)
      WRITE(6,*)'          CURRENT NUMBER:',ICODE
      WRITE(6,*)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     USER NAMELIST:'
      WRITE(LUNGFO,*)
      DO I=1,1000
        IF (USER(I).NE.0.) THEN
          WRITE(LUNGFO,*)'     USER(',I,'): ',USER(I)
        ENDIF
      ENDDO
      WRITE(LUNGFO,*)

      icluster=iclusterold

      if (ibunch.ne.0) then
        if (iundulator.ne.2) then
          mthreads=0
        endif
        if (nbunch.le.0) nbunch=1
        if (neinbunch.le.0) neinbunch=1
      endif

      if (iemit.ne.0.or.ibunch.ne.0) imagspln=0

C--- USER MAY OVERWRITE HERE VARIABLES OF NAMELISTS

      mmedgey=0 !3.4.2019, to avoid trouble with OMP
      mmedgez=0

      IF (IUNAME.NE.0) THEN
        CALL UNAME
        IF (IABEND.EQ.5) goto 9999
      ENDIF

      if (kbrec.ne.0.and.scaladd.eq.0.0d0.and.scalkl.eq.0.0d0
     &    .and.irecmodu.eq.0.and.irecu.eq.0) then
        irecu=1
      endif

+self,if=xxnoroot.
      if (iroothdf5.ne.0.or.iroottrees.ne.0) then
        print*
        write(6,*)'*** Warning in gfinit:'
        print*,'CERN package ROOT is not available'
        write(6,*)'for this version of WAVE, use ROOT-macro mhbook_to_root.C '
        print*,'to convert WAVE.mhb etc..'
        iroothdf5=0
        iroottrees=0
      endif
+self.
      if (nocern.ne.0) iroottrees=0
+self,if=-noroot.
      if (iroothdf5.ne.0.and.iroottrees.eq.0) iroottrees=-1
      if (ihisascii.ne.0.and.iroottrees.lt.0) then
        iroottrees=1
        write(6,*)''
        write(6,*)'*** WARNING: IROOTREES SET TO 1, DUE TO IHISASCII'
        write(6,*)''
        write(LUNGFO,*)''
        write(LUNGFO,*)'*** WARNING: IROOTREES SET TO 1, DUE TO IHISASCII'
        write(LUNGFO,*)''
      endif

      irootmode=0
      if (iroottrees.ne.0) call rootini(irootmode)
+self.

      kefield=iefield

      IF (BMOVECUT.LE.0.0D0) BMOVECUT=1.0D-6

      IF (IBFORCE.NE.0) THEN
+SELF,IF=LINUX,WINDOWS.
c     WRITE(6,*)'READING NAMELIST BFORCN'
+SELF.
        READ(LUNGFI,BFORCN)
      ENDIF

      IF (MPINZ.LE.0) MPINZ=1
      IF (MPINY.LE.0) MPINY=1

      IF (IF1DIM.NE.0) THEN
        IF1DIM=1
      ENDIF

      IF (IPHASE.NE.0) THEN
        DO IELEM=1,NPHELEMP
          PHELEM(1,1,IELEM)=1.0D0
          PHELEM(2,2,IELEM)=1.0D0
          PHELEM(3,3,IELEM)=1.0D0
          PHELEM(4,4,IELEM)=1.0D0
          PHELEM(5,1,IELEM)=-1.0D30
          PHELEM(5,2,IELEM)=+1.0D30
          PHELEM(5,3,IELEM)=-1.0D30
          PHELEM(5,4,IELEM)=+1.0D30
        ENDDO
+SELF,IF=LINUX,WINDOWS.
c     WRITE(6,*)'READING NAMELIST PHASEN'
+SELF.
        READ(LUNGFI,PHASEN)
      ENDIF

      if (ibunch.ne.0.and.neinbunch.gt.1.and.icluster.gt.0) then
        if (neinbunch.ne.(neinbunch/nwgood)*nwgood) then
          write(lungfo,*)"Warning in GFINIT: NEINBUNCH changed to fit number of WAVE instances ***"
          neinbunch=(neinbunch/nwgood)*nwgood
          write(lungfo,*)"New value:", neinbunch
          print*,"Warning in GFINIT: NEINBUNCH changed to fit number of WAVE instances ***"
          neinbunch=(neinbunch/nwgood)*nwgood
          print*,"New value:", neinbunch
        endif
      endif

      if (neinbunch.gt.0.and.bunchcharge.eq.-9999.)
     &  bunchcharge=echarge1*neinbunch

      if (ibunch.eq.0) then
        iubunch=0
        neinbunch=0
        nbunch=0
      else
        if (ispecdip.ne.0) then
          print*,"*** Error: ISPECDIP is not allowed for IBUNCH option ***"
          iabend=11
          goto 9999
        endif
      endif

      nbuncho=nbunch
      neinbuncho=neinbunch

      IF (KAMPLI.NE.0.or.iundulator.eq.2) THEN
        READ(LUNGFI,PHASEREPN)
        if (ibunch.ne.0.and.nbunch.ne.1.and.neinbunch.ne.1) then
          write(lungfo,*)'*** Error in GFINIT: For IUNDULATOR=2 or KAMPLI.ne.0, one of NBUNCH or NEINBUNCH must be one ***'
          stop '*** Error in GFINIT: For IUNDULATOR=2 or KAMPLI.ne.0, one of NBUNCH or NEINBUNCH must be one ***'
        endif
        if (noespreadph.ne.0) phrespread=0.0d0
        if (noemitph.ne.0) then
          phremith=0.0d0
          phremitv=0.0d0
        endif
      ENDIF

c      IF (IAMPLI.NE.0.or.ibunch.ne.0.or.iundulator.eq.2) THEN
        READ(LUNGFI,AMPLIN)
c        IF (IAMPLI.LT.0) IAMPSKIP=0
c      ENDIF

+SELF,IF=LINUX,WINDOWS.
c     WRITE(6,*)'READING NAMELIST ROIN'
+SELF.
      READ(LUNGFI,ROIN)

+SELF,IF=LINUX,WINDOWS.
c     WRITE(6,*)'READING NAMELIST BERRORN'
+SELF.
      READ(LUNGFI, BERRORN )
      ihphotons=0
      if (ieneloss.lt.0) read(lungfi,photonn)
+SELF,IF=LINUX,WINDOWS.
c     WRITE(6,*)'READING NAMELIST USERN'
+SELF.
      READ(LUNGFI,USERN)
+SELF,IF=LINUX,WINDOWS.
      WRITE(6,*)
      WRITE(6,*)
      WRITE(6,*)
+SELF.

C      CLOSE (LUNGFI)

      if (irbtabxyz.ne.0) then
        irbtab=0
        irbtabzy=0
      else if (irbtabzy.ne.0) then
        irbtab=0
      endif

      IF (XABSORB   .EQ.9999.) XABSORB=XWALLE
      IF (ZABSORB(1).EQ.9999.) ZABSORB(1)=WALL(1)
      IF (ZABSORB(2).EQ.9999.) ZABSORB(2)=WALL(2)

C ALL MULTIPLICATIONS WITH REFLEC ARE WRONG, SO WE CORRECT IT HERE
C (15. MAI 2004)

      DO I=1,3
        REFLEC(I)=CONJG(REFLEC(I))
      ENDDO

      IF (IWBMAP.EQ.-1) IHBPOLY3D=1
      IF (IWBMAP.EQ.-1.AND.IWBPOLY2DH.NE.0) IHBPOLY2DH=1
      IF (IWBMAP.EQ.-1.AND.IWBPOLY2DH.NE.0) IHBPHARM=1

      CALL date_and_time(dtday,dttime,dtzone,idatetime)

      OPEN(UNIT=99,FILE='wave_run.log',status='unknown',access='append')
      WRITE(99,*)icode,' ',dtday,' ',dttime
      close(99)

      if (iampseed.eq.-9999) iampseed=icode

      IF (ABS(KBGENESIS).EQ.2) THEN
        OPEN(UNIT=LUNGENI,FILE='genesis.start',STATUS='OLD')
        READ(LUNGENI,*)XSTART,DMYGAMMA,DUM,ZSTART,YSTART,VZIN,VYIN
        VXIN=1.0D0
        VYIN=VYIN/DMYGAMMA
        VZIN=VZIN/DMYGAMMA
        DMYENERGY=DMYGAMMA*EMASSG1
        CLOSE(LUNGENI)
      ENDIF

      if (abs(xstart).ne.9999.0d0.and.xstop.ne.9999.0d0
     &    .and.xstart.ge.xstop-1.0d0/myinum) then
        write(LUNGFO,*)' '
        write(LUNGFO,*)'*** Error in GFINIT: XSTART and XSTOP are not compatible.'
        write(LUNGFO,*)'Decrease XSTART or nncrease MYINUM or XSTOP!'
        write(LUNGFO,*)' '
        write(6,*)' '
        write(6,*)'*** Error in GFINIT: XSTART and XSTOP are not compatible.'
        write(6,*)'Decrease XSTART or nncrease MYINUM or XSTOP!'
        write(6,*)' '
        STOP '*** PROGRAM WAVE ABORTED ***'
      endif

      DMYGAMMA=DMYENERGY/EMASSG1

      if (ibunch.ne.0.and.ispec.eq.0) then
        write(6,*)' '
        write(6,*)'*** WARNING: ISPEC SET DUE TO IBUNCH AND IUBUNCH'
        write(6,*)' '
        write(lungfo,*)' '
        write(lungfo,*)'*** WARNING: ISPEC SET DUE TO IBUNCH AND IUBUNCH'
        write(lungfo,*)' '
        ispec=1
      endif

      if (ibunch.ne.0.and.iubunch.eq.3) then
        open(unit=21,file='wave_phasespace.dat',status='old')
        call util_skip_comment_end(21,ieof)
        read(21,*)dmygamma,bunchx,xstart,ystart,zstart,yp0,zp0
        close(21)
        dmyenergy=dmygamma*emassg1
        vxin=1.0d0
        vyin=yp0
        vzin=zp0
        xinter=-9999.0d0
c        write(6,*)' '
c        write(6,*)'*** WARNING: IBUNCH AND IUBUNCH HAVE TRIGGERED OVERWRITING'
c        write(6,*)'*** WARNING: OF XSTART ETC.'
c        write(6,*)' '
        write(lungfo,*)' '
        write(lungfo,*)'*** WARNING: IBUNCH AND IUBUNCH HAVE TRIGGERED OVERWRITING'
        write(lungfo,*)'*** WARNING: OF XSTART ETC.'
        write(lungfo,*)' '
      endif

      dmyenergyP=DMYENERGY
      dmygammaP=DMYGAMMA
      DMYBETA=DSQRT((1.0D0-1.0D0/DMYGAMMA)*(1.0D0+1.0D0/DMYGAMMA))
      dmybetaP=DMYBETA
      gammaustep=dmygamma

C--- MODES

      IF (IUNDULATOR*IWIGGLER.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'BOTH FLAGS IUNDULATOR AND IWIGGLER ARE SET'
        WRITE(LUNGFO,*)'ONLY ONE IS ALLOWED'
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'BOTH FLAGS IUNDULATOR AND IWIGGLER ARE SET'
        WRITE(6,*)'ONLY ONE IS ALLOWED'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IWIGGLER.NE.0) THEN
        IEXPERT=0
      ENDIF

C{--- CONVERT B-FIELD TO MAP

      IF (IWBMAP.EQ.5) THEN
        CALL WBMAP5
        IABEND=7
        goto 9999
      ENDIF
C}--- CONVERT B-FIELD TO MAP

      if (iundulator.eq.2) then
        ispec=1
        ifreq2p=3
      endif

      if (iwiggler.ne.0.or.iundulator.ne.0) then
        istokes=1
      endif

c      if (kampli.ne.0.or.iundulator.eq.2) then
c        CALL BELLIP(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
c        phb0h=B0ELLIPh
c        phb0v=B0ELLIPv
c        phperl=xlellip
c        phshift=ellshft*phperl
c      endif

      if (iundulator.eq.2) then

c        iundulator=0
        kampli=nint(perellip)
        perellip=5.
        xcenell=0.0d0

        xstart=-(perellip*xlellip+ellshft*xlellip)/2.0d0+xcenell

        park=parkell

        if (nharmell.ne.0.and.harmell.ne.0.0d0) then
          if (harmell.eq.-9999.0d0) then
            if (ifreq2p.eq.1) then
              harmell=freqlow
            else
              harmell=(freqlow+freqhig)/2.0d0
            endif
          endif
          if (harmell.lt.0.0d0) then
            harmell=-wtoe1/harmell
          endif
          WLEN1=wtoe1/abs(harmell/nharmell)
          park=2.0d0*(wlen1/(xlellip*1.0D9/2.0d0/DMYGAMMA**2)-1.0d0)
          if (park.lt.0.0d0) then
            write(6,*)
     &        '*** Error in GFINIT:'
            write(6,*)
     &        'Inconsistent values of NHARMELL, HARMELL, and XLELLIP'
            write(6,*)' '
            write(lungfo,*)
     &        '*** Error in GFINIT:'
            write(lungfo,*)
     &        'Inconsistent values of NHARMELL, HARMELL, and XELLIP'
            write(lungfo,*)' '
            stop
          endif
          park=sqrt(park)
          parkell=park
        endif

        IF (parkell.NE.0.0) THEN
          B0EFF=parkell/(echarge1*XLELLIP/(2.*PI1*EMASSKG1*CLIGHT1))
          if (b0elliph.eq.0.0d0.and.b0ellipv.ne.0d0) then
            b0ellipv=b0ellipv/abs(b0ellipv)*b0eff
          else if (b0ellipv.eq.0.0d0.and.b0elliph.ne.0d0) then
            b0elliph=b0elliph/abs(b0elliph)*b0eff
          else
            rhv=b0elliph/b0ellipv
            b0elliph=b0eff/sqrt(1.0d0+1.0d0/rhv**2)*b0elliph/abs(b0elliph)
            b0ellipv=b0elliph/rhv
          endif
        endif

        if (phrb0h.eq.9999.0d0) phrb0h=B0ELLIPh
        if (phrb0v.eq.9999.0d0) phrb0v=B0ELLIPV
        if (phrperl.eq.9999.0d0) phrperl=xlellip
        if (phrshift.eq.9999.0d0) phrshift=ellshft*phrperl

        WGWINFC = 45.
        nlpoi=0
        ibsuper=0
        KBEXTERN=0
        KBAMWLS=0
        KHALBA=0
        KBFELD=0
        KHALBASY=0
        KUNDUGAP=0
        IRFILF=0
        IRFILB=0
        IRBTAB=0
        IFOURBTABZY=0
        IRBTABZY=0
        IRBTABXYZ=0
        KUCROSS=0
        KELLANA=0
        KBREC=0
        kbundumag=0
        kbundumag_c=kbundumag
        KBPOLYMAG=0
        KBGENESIS=0
        KBPOLYH=0
        KBPOLY3D=0
        KBPOLY2DH=0
        KBPHARM=0
        IRFILP=0
        IRFILB0=0
        IBHELM=0
        IMAGSPLN=0
        KMAGSEQ=0
        IWSECTMAGS=0
        ibmasksp=0
        ibsym=0
        ibsymy=0
        ibsymz=0
        bygoff=0.0d0
        bzgoff=0.0d0
        jbmask=0
        ibmask=0
        B0SCGLOBY=1.0
        B0SCGLOBz=1.0
        xbshift=0.0d0
        hshift=0.0d0
        vshift=0.0d0
        xrotd=0.0d0
        IPERIODG=0.0d0
        BTAPERV=0.0d0
        BTAPERH=0.0d0
        XTAPER=0.0d0
        iampli=0

        kellip=1

        xstop=phrperl/2.0d0
        ieneloss=0
        !imagspln=0

        gamma=dmygamma

        DTIM=1.0D0/(CLIGHT1*dmybetap*MYINUM)   !TIME INTERVALLS FOR TRACKING
        BSHIFT=0.5D0          !DONT WORRY

        DS0=CLIGHT1*DTIM
        GAMMA=DMYGAMMA
        ENERGV=GAMMA*EMASSE1
        GMOM=EMASSG1*DSQRT((GAMMA-1.0d0)*(GAMMA+1.0d0))
        EMOM=EMASSE1*DSQRT((GAMMA-1.0d0)*(GAMMA+1.0d0))
        DBRHO=ICHARGE*EMOM/CLIGHT1
        BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
        DMYBETA=BETA
        V0=CLIGHT1*BETA

        VN=1.0D0/DSQRT(VXIN**2+VYIN**2+VZIN**2)
        VXIN=VXIN*VN*v0
        VYIN=VYIN*VN*v0
        VZIN=VZIN*VN*v0

        TAUPOL01G=POL2CON1*UMFANG*RDIPOL**2/1.**5

        ecdipev1=3.0d0/2.0d0*hbarev1*(clight1/emasse1)**2/emasse1*1.0d18

        gamma1=1.0d0/emassg1
        emom1=emasse1*dsqrt((gamma1-1.0d0)*(gamma1+1.0d0))
        rho1=emom1/clight1
        omegac=1.5d0*gamma1**3*clight1/rho1

        CROTD=DCOSD(XROTD)
        SROTD=DSIND(XROTD)

        IF (XINTER.NE.XSTART.AND.XINTER.NE.-9999.) THEN

          YSTARTO=YSTART
          ZSTARTO=ZSTART

          VXINO=VXIN
          VYINO=VYIN
          VZINO=VZIN

          BETX0=VXIN*BETA
          BETY0=VYIN*BETA
          BETZ0=VZIN*BETA

          X0=XSTART
          Y0=YSTART
          Z0=ZSTART

          VX0=VXIN*V0
          VY0=VYIN*V0
          VZ0=VZIN*V0

          IF (XINTER.GT.XSTART) THEN

            BYDUM=B0SCGLOB
            B0SCGLOB=-B0SCGLOB
            btaperv=-btaperv
            btaperh=-btaperh

            CALL TRACKSHORT(ISNORDER,XINTER,Y0,Z0,-VX0,-VY0,-VZ0,
     &        XSTART,0.0D0,0.0D0,-1.0D0,0.0D0,0.0D0,
     &        XF0,YF0,ZF0,dtshort,VXF0,VYF0,VZF0,DTIM,BSHIFT,GAMMA,BMOVECUT,
     &        IUSTEP,IENELOSS,GAMMAL)

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Result of back-tracking due to XINTER:'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     x:',XF0
            WRITE(LUNGFO,*)'     y:',YF0
            WRITE(LUNGFO,*)'     z:',ZF0
            WRITE(LUNGFO,*)'     vx:',-VXF0
            WRITE(LUNGFO,*)'     vy:',-VYF0
            WRITE(LUNGFO,*)'     vz:',-VZF0
            WRITE(LUNGFO,*)'     yp:',VYF0/VXF0
            WRITE(LUNGFO,*)'     zp:',VZF0/VXF0
            WRITE(LUNGFO,*)

            B0SCGLOB=BYDUM
            btaperv=-btaperv
            btaperh=-btaperh
            XSTART=XF0
            YSTART=YF0
            ZSTART=ZF0
            VXIN=-VXF0
            VYIN=-VYF0
            VZIN=-VZF0

            GAMMA=GAMMA-GAMMAL !We gain energy here, and gammal is negative!
            DMYGAMMA=GAMMA
            DMYENERGY=GAMMA*EMASSG1

            ENERGV=GAMMA*EMASSE1
            GMOM=EMASSG1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
            EMOM=EMASSE1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
            DBRHO=ICHARGE*EMOM/CLIGHT1
            BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
            DMYBETA=BETA
            V0=CLIGHT1*BETA

          ELSE   !XINTER.GT.XSTART

            CALL TRACKSHORT(ISNORDER,XINTER,Y0,Z0,VX0,VY0,VZ0,
     &        XSTART,0.0D0,0.0D0,1.0D0,0.0D0,0.0D0,
     &        XF0,YF0,ZF0,dtshort,VXF0,VYF0,VZF0,DTIM,BSHIFT,GAMMA,BMOVECUT,
     &        IUSTEP,IENELOSS,GAMMAL)

            XSTART=XF0
            YSTART=YF0
            ZSTART=ZF0
            VXIN=VXF0
            VYIN=VYF0
            VZIN=VZF0

            GAMMA=GAMMA+GAMMAL !We lose energy here!
            DMYGAMMA=GAMMA
            DMYENERGY=GAMMA*EMASSG1

            ENERGV=GAMMA*EMASSE1
            GMOM=EMASSG1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
            EMOM=EMASSE1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
            DBRHO=ICHARGE*EMOM/CLIGHT1
            BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
            DMYBETA=BETA
            V0=CLIGHT1*BETA

          ENDIF  !XINTER.GT.XSTART

        ENDIF !(XINTER.NE.-9999.)

        xinter=-9999.0d0

        call trackshort(isnorder,
     &    xstart,ystart,zstart,vxin,vyin,vzin,
     &    -xlellip/2.0d0,0.0d0,0.0d0,  1.0d0,0.0d0,0.0d0,
     &    xstart,ystart,zstart,dum,vxin,vyin,vzin,
     &    1.0d0/(clight1*dmybeta*myinum),0.5d0,dmygamma,bmovecut
     &    ,0,0,GAMMAL)

      endif

      IF (IUNDULATOR.NE.0) THEN

        IEXPERT=0
        ihtrackm=0

        if (ibunch.eq.0) then

+self,if=20220316.
          IF ((IWBMAP.NE.0.OR.IWBTAB.NE.0.OR.IBFORCE.NE.0.OR.IOPTIC.NE.0) then
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
            WRITE(LUNGFO,*)'IUNDULATOR HAS SET IMAGSPLN=-9999,'
            WRITE(LUNGFO,*)
     &        'WHICH IS INCOMPATIBLE WITH IWBMAP/IWBTAB/IBFORCE/IOPTIC'
            WRITE(LUNGFO,*)'TURN OFF IUNDULATOR, IF YOU USE IWBMAP/IWBTAB/IBFORCE/IOPTIC'
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN GFINIT ***'
            WRITE(6,*)'IUNDULATOR HAS SET IMAGSPLN=-9999,'
            WRITE(6,*)
     &        'WHICH IS INCOMPATIBLE WITH IWBMAP/IWBTAB/IBFORCE/IOPTIC'
            WRITE(6,*)'TURN OFF IUNDULATOR, IF YOU USE IWBMAP/IWBTAB/IBFORCE/IOPTIC'
            WRITE(6,*)
            STOP '*** PROGRAM WAVE ABORTED ***'
          ENDIF
+self,if=-20220316.
          IF ((IWBMAP.NE.0.OR.IBFORCE.NE.0.OR.IOPTIC.NE.0)
     &        .and.
     &    (iemit.ne.0.or.kbrec.ne.0.or.kbundumag.ne.0.or.kbextern.ne.0.or.kbpolymag.ne.0)) then
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
            WRITE(LUNGFO,*)'IUNDULATOR HAS SET IMAGSPLN=-9999,'
            WRITE(LUNGFO,*)
     &        'WHICH IS INCOMPATIBLE WITH IWBMAP/IBFORCE/IOPTIC'
            WRITE(LUNGFO,*)'TURN OFF IUNDULATOR, IF YOU USE IWBMAP/IBFORCE/IOPTIC'
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN GFINIT ***'
            WRITE(6,*)'IUNDULATOR HAS SET IMAGSPLN=-9999,'
            WRITE(6,*)
     &        'WHICH IS INCOMPATIBLE WITH IWBMAP/IBFORCE/IOPTIC'
            WRITE(6,*)'TURN OFF IUNDULATOR, IF YOU USE IWBMAP/IBFORCE/IOPTIC'
            WRITE(6,*)
            STOP '*** PROGRAM WAVE ABORTED ***'
          ENDIF
+self.

          icluster=0

          IF (ISPEC.NE.0) THEN

            ispecmode=2

            !if (nroi.ne.0) ispecmode=1

            IF (IAMPLI.GT.0.AND.ISPECMODE.NE.3.and.iamprep.ge.0) THEN
c noch ueberdenken, iphase bereits kompatible gemacht, 17.10.2012
              WRITE(LUNGFO,*)
     &          '*** Warning in GFINIT: ISPECMODE not 3, but IAMPLI.gt.0 and IAMPREP.gt.0'
              WRITE(6,*)"*** BE CAREFUL ***"
              PRINT *,
     &          '*** Warning in GFINIT: ISPECMODE not 3, but IAMPLI.gt.0 and IAMPREP.gt.0'
              print*,"*** BE CAREFUL ***"
            ENDIF

          ENDIF !ISPEC

          IMAGSPLN=-9999
          if (iemit.ne.0.or.kbrec.ne.0.or.kbundumag.ne.0.or.kbextern.ne.0.or.kbpolymag.ne.0) IMAGSPLN=0

          IRFILL0=0
C         IWFILL0=1
c          NLPOI=-9999
          NLPOI=0
          CX1=9999.
          CY1=9999.
          CZ1=9999.
          HIG1=1000.
          WID1=1000.
          CX2=9999.
          CY2=9999.
          CZ2=9999.
          HIG2=1000.
          WID2=1000.
          WGWINFC=PI1/4.0D0*DMYGAMMA
          WBL0CUT=0.0
          WBL0HYS=1.0
          IBL0CUT=0
          ISOUREXT=0
          ISPECDIP=0
          IF (IFOLD.NE.0) IFOLD=1
          IF (iefold.ne.0.and.IEFOLD.ne.1.and.iefold.ne.-1.and.iefold.ne.3) then
            write(lungfo,*)
            write(lungfo,*)"*** Warning in gfinit: IEFOLD MUST BE ONE OF [0,1,3,-1]"
            write(lungfo,*)"*** Will set it to IEFOLD=1 ***"
            write(lungfo,*)
            print*
            print*,"*** Warning in gfinit: IEFOLD MUST BE ONE OF [0,1,3,-1]"
            print*,"*** Will set it to IEFOLD=1 ***"
            print*
            IEFOLD=1
          endif
          IF (IPIN.GT.0.and.ipin.ne.3) IPIN=1
          BMOVECUT=1.0D-6

        else !ibunch

          if (icluster.ne.0) mthreads=0

          IF (ISPEC.NE.0) THEN

            ISPECMODE=2

            IF (IPHASE.NE.0) THEN
              WRITE(LUNGFO,*)' '
              WRITE(LUNGFO,*)
     &          '*** Warning in GFINIT: IPHASE set to zero, due to IBUNCH'
              WRITE(LUNGFO,*)' '
              PRINT *,' '
              PRINT *,
     &          '*** Warning in GFINIT: IPHASE set to zero, due to IBUNCH'
              PRINT *,' '
              iphase=0
            ENDIF

            IF (iampli.ne.0.and.iamprep.lt.0) THEN
              WRITE(LUNGFO,*)
     &          '*** Error in GFINIT: IBUNCH and IAMPREP < 0 are not compatible ***'
              PRINT *,
     &          '*** Error in GFINIT: IBUNCH and IAMPREP < 0 are not compatible ***'
              STOP '*** PROGRAM WAVE ABORTED ***'
            ENDIF

          ENDIF !ISPEC

          IFOLD=0
          IEFOLD=0
          !IMAGSPLN=0
          IRFILL0=0
c          NLPOI=-9999
          NLPOI=0
          CX1=9999.
          CY1=9999.
          CZ1=9999.
          HIG1=1000.
          WID1=1000.
          CX2=9999.
          CY2=9999.
          CZ2=9999.
          HIG2=1000.
          WID2=1000.
          WGWINFC=PI1/4.0D0*DMYGAMMA
          WBL0CUT=0.0
          WBL0HYS=1.0
          IBL0CUT=0
          ISOUREXT=0
          ISPECDIP=0
          IFOLD=0
          IEFOLD=0

          if (iefold.ne.0) then
            WRITE(6,*)' '
            WRITE(6,*)
     &        '      *** Warning in GFINIT: IEFOLD is used for IBUNCH, be careful!'
            WRITE(6,*)' '
            WRITE(LUNGFO,*)' '
            WRITE(LUNGFO,*)
     &        '      *** Warning in GFINIT: IEFOLD is used for IBUNCH, be careful!'
            WRITE(LUNGFO,*)' '
          endif

          IF (iundulator.ne.2
     &        .and.IPIN.GT.0.and.ipin.ne.3.and.neinbunch.eq.1) then
            IPIN=3
            WRITE(6,*)' '
            WRITE(6,*)
     &        '      *** GFINIT: IPIN=3 has been set due to IUNDULATOR and IBUNCH and NEINBUNCH=1, be careful!'
            WRITE(lungfo,*)' '
            WRITE(lungfo,*)
     &        '      *** GFINIT: IPIN=3 has been set due to IUNDULATOR and IBUNCH and NEINBUNCH=1, be careful!'
            WRITE(6,*)' '
          endif

          BMOVECUT=1.0D-6

        endif !ibunch

      ENDIF !IUNDULATOR

      IF (IWIGGLER.GT.1) THEN

        IF (ibunch.ne.0) then
          WRITE(LUNGFO,*)
     &      '*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      '*** IWIGGLER.GT.1 .AND. IBUNCH.NE.0 ARE INCOMPATIBLE ***'
          WRITE(6,*)
     &      '*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      '*** IWIGGLER.GT.1 .AND. IBUNCH.NE.0 ARE INCOMPATIBLE ***'
          STOP '*** PROGRAM WAVE ABORTED ***'
        endif

+self,if=20220316.
        IF (IWBMAP.NE.0.OR.IWBTAB.NE.0.OR.IBFORCE.NE.0.OR.IOPTIC.NE.0)THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'IWIGGLER HAS TURNED SET IMAGSPLN=-9999,'
          WRITE(LUNGFO,*)
     &      'WHICH IS INCOMPATIBLE WITH IWBMAP/IWBTAB/IBFORCE/IOPTIC/IBUNCH'
          WRITE(LUNGFO,*)'TURN OFF IWIGGLER, IF YOU USE IWBMAP/IWBTAB/IBFORCE/IOPTIC/IBUNCH'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'IWIGGLER HAS TURNED SET IMAGSPLN=-9999,'
          WRITE(6,*)
     &      'WHICH IS INCOMPATIBLE WITH IWBMAP/IWBTAB/IBFORCE/IOPTIC/IBUNCH'
          WRITE(6,*)'TURN OFF IWIGGLER, IF YOU USE IWBMAP/IWBTAB/IBFORCE/IOPTIC/IBUNCH'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF
+self,if=-20220316.
          IF ((IWBMAP.NE.0.OR.IBFORCE.NE.0.OR.IOPTIC.NE.0)
     &        .and.
     &    (iemit.ne.0.or.kbrec.ne.0.or.kbundumag.ne.0.or.kbextern.ne.0.or.kbpolymag.ne.0)) then

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'IWIGGLER HAS TURNED SET IMAGSPLN=-9999,'
          WRITE(LUNGFO,*)
     &      'WHICH IS INCOMPATIBLE WITH IWBMAP/IBFORCE/IOPTIC/IBUNCH'
          WRITE(LUNGFO,*)'TURN OFF IWIGGLER, IF YOU USE IWBMAP/IBFORCE/IOPTIC/IBUNCH'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'IWIGGLER HAS TURNED SET IMAGSPLN=-9999,'
          WRITE(6,*)
     &      'WHICH IS INCOMPATIBLE WITH IWBMAP/IBFORCE/IOPTIC/IBUNCH'
          WRITE(6,*)'TURN OFF IWIGGLER, IF YOU USE IWBMAP/IBFORCE/IOPTIC/IBUNCH'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF
+self.

        ISPECDIP=-2

        IMAGSPLN=-9999
        !if (iemit.ne.0.or.kbrec.ne.0.or.kbundumag.ne.0.or.kbextern.ne.0.or.kbpolymag.ne.0) IMAGSPLN=0

        IRFILL0=0
C         IWFILL0=1
        NLPOI=-9999
        WGWINFC=10.
        CX1=9999.
        CY1=9999.
        CZ1=9999.
        HIG1=9999.
        WID1=9999.
        CX2=9999.
        CY2=9999.
        CZ2=9999.
        HIG2=9999.
        WID2=9999.
        !WBL0CUT=0.1
        !WBL0HYS=1.0
        !IBL0CUT=1
        ISOUREXT=0
        IF (IFOLD.NE.0) IFOLD=1
        IF (IEFOLD.NE.0) IEFOLD=1
      ENDIF !IWIGGLER

      IF (IWIGGLER.EQ.1) THEN

+self,if=20220316.
        IF (IWBMAP.NE.0.OR.IWBTAB.NE.0.OR.IBFORCE.NE.0.OR.IOPTIC.NE.0)THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'IWIGGLER HAS TURNED SET IMAGSPLN=-9999,'
          WRITE(LUNGFO,*)
     &      'WHICH IS INCOMPATIBLE WITH IWBMAP/IWBTAB/IBFORCE/IOPTIC/IBUNCH'
          WRITE(LUNGFO,*)'TURN OFF IWIGGLER, IF YOU USE IWBMAP/IWBTAB/IBFORCE/IOPTIC/IBUNCH'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'IWIGGLER HAS TURNED SET IMAGSPLN=-9999,'
          WRITE(6,*)
     &      'WHICH IS INCOMPATIBLE WITH IWBMAP/IWBTAB/IBFORCE/IOPTIC/IBUNCH'
          WRITE(6,*)'TURN OFF IWIGGLER, IF YOU USE IWBMAP/IWBTAB/IBFORCE/IOPTIC/IBUNCH'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF
+self,if=-20220316.
          IF ((IWBMAP.NE.0.OR.IBFORCE.NE.0.OR.IOPTIC.NE.0)
     &        .and.
     &    (iemit.ne.0.or.kbrec.ne.0.or.kbundumag.ne.0.or.kbextern.ne.0.or.kbpolymag.ne.0)) then
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'IWIGGLER HAS TURNED SET IMAGSPLN=-9999,'
          WRITE(LUNGFO,*)
     &      'WHICH IS INCOMPATIBLE WITH IWBMAP/IBFORCE/IOPTIC/IBUNCH'
          WRITE(LUNGFO,*)'TURN OFF IWIGGLER, IF YOU USE IWBMAP/IBFORCE/IOPTIC/IBUNCH'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'IWIGGLER HAS TURNED SET IMAGSPLN=-9999,'
          WRITE(6,*)
     &      'WHICH IS INCOMPATIBLE WITH IWBMAP/IBFORCE/IOPTIC/IBUNCH'
          WRITE(6,*)'TURN OFF IWIGGLER, IF YOU USE IWBMAP/IBFORCE/IOPTIC/IBUNCH'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF
+self.

C        IF (IPHASE.NE.0.OR.IAMPLI.NE.0) THEN
c noch ueberdenken, iphase bereits kompatible gemacht, 17.10.2012
C          WRITE(LUNGFO,*)
C     &      '*** Warning in GFINIT: ISPECMODE set to 3, due to IPHASE'
C          PRINT *,
C     &      '*** Warning in GFINIT: ISPECMODE set to 3, due to IPHASE'
C          ISPECMODE=3
C        ELSE
C          ISPECMODE=2
C          if (icluster.eq.0.and.ibunch.eq.0.and.nroi.eq.0) ispecmode=3
C        ENDIF

        IF (ISPECMODE.NE.3.AND.(IPHASE.NE.0.OR.IAMPLI.NE.0)) THEN
          WRITE(6,*)
     &      '*** Warning in GFINIT: ISPECMODE not 3, but IPHASE or IAMPLI set ***'
          WRITE(6,*)
     &      '*** This is not yet fully tested, be careful ***'
          WRITE(LUNGFO,*)
     &      '*** Warning in GFINIT: ISPECMODE not 3, but IPHASE or IAMPLI set ***'
          WRITE(LUNGFO,*)
     &      '*** This is not yet fully tested, be careful ***'
        ENDIF

        IMAGSPLN=-9999
        !if (iemit.ne.0.or.kbrec.ne.0.or.kbundumag.ne.0.or.kbextern.ne.0.or.kbpolymag.ne.0) IMAGSPLN=-9999

        IRFILL0=0
C         IWFILL0=1
        NLPOI=-9999
        WGWINFC=9999.
        CX1=9999.
        CY1=9999.
        CZ1=9999.
        HIG1=9999.
        WID1=9999.
        CX2=9999.
        CY2=9999.
        CZ2=9999.
        HIG2=9999.
        WID2=9999.
        WBL0CUT=0.1
        WBL0HYS=1.0
        IBL0CUT=1
        ISOUREXT=0
        ISPECDIP=0

        IF (IFOLD.NE.0) IFOLD=1

        if (ibunch.ne.0) ibunch=-1
        if (ibunch.ne.0) then
          IFOLD=0
          IEFOLD=0
        endif
      ENDIF !IWIGGLER

      if (iwiggler.ne.0.and.ibunch.ne.0.and.ipin.ne.0.and.neinbunch.eq.1) ipin=3

      if (espread.le.0.0d0.and.iefold.ne.0) then
        iefold=0
        write(lungfo,*)'     *** Warning in GFINIT: IEFOLD set zero, since ESPREAD <= 0.0'
        write(6,*)'     *** Warning in GFINIT: IEFOLD set zero, since ESPREAD <= 0.0'
      endif

      IF (ISPEC.NE.0) THEN

        if (ibunch.ne.0.and.ifold.ne.0) then
          write(6,*)' '
          write(6,*)' *** Warning in gfinit: IBUNCH and IFOLD are both set, be careful!'
          write(6,*)' '
          write(lungfo,*)' '
          write(lungfo,*)' *** Warning in gfinit: IBUNCH and IFOLD are both set, be careful!'
          write(lungfo,*)' '
        endif

        if (ibunch.ne.0.and.iefold.ne.0) then
          write(6,*)' '
          write(6,*)' *** Warning in gfinit: IBUNCH and IEFOLD are both set, be careful!'
          write(6,*)' '
          write(lungfo,*)' '
          write(lungfo,*)' *** Warning in gfinit: IBUNCH and IEFOLD are both set, be careful!'
          write(lungfo,*)' '
        endif

        if (ieneloss.ne.0.and.ispecmode.gt.3) then
          write(lungfo,*)' '
          write(lungfo,*)'*** Error: IENELOSS and ISPECMODE are incompatible ***'
          WRITE(lungfo,*)'*** PROGRAM WAVE ABORTED'
          write(lungfo,*)' '
          write(6,*)' '
          write(6,*)'*** Error: IENELOSS and ISPECMODE are incompatible ***'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED'
          write(6,*)' '
          stop
        endif

        if (ibunch.ne.0.and.ispecmode.ne.2) then
          write(6,*)' '
          write(6,*)' *** ERROR IN GFINIT: IBUNCH set, but ISPECMODE.ne.2!'
          write(6,*)' **** Please check namelist $CONTRL in wave.in'
          write(6,*)' '
          WRITE(6,*)'*** PROGRAM WAVE ABORTED'
          write(6,*)' '
          write(lungfo,*)' '
          write(lungfo,*)' *** ERROR IN GFINIT: IBUNCH set, but ISPECMODE.ne.2!'
          write(lungfo,*)' **** Please check namelist $CONTRL in wave.in'
          write(lungfo,*)' '
          WRITE(lungfo,*)'*** PROGRAM WAVE ABORTED'
          write(lungfo,*)' '
          stop
        endif

        if (iefold.ne.0.and.ifreq2p.ne.3) then
          write(LUNGFO,*)' '
          write(LUNGFO,*)'*** Warning in GFINIT: IEFOLD.ne.0 and IFRQE2P.ne.3 ***'
          write(LUNGFO,*)'IFREQ2P set to IFREQ2P=3'
          write(LUNGFO,*)' '
          write(6,*)' '
          write(6,*)'*** Warning in GFINIT: IEFOLD.ne.0 and IFRQE2P.ne.3 ***'
          write(6,*)'IFREQ2P set to IFREQ2P=3'
          write(6,*)' '
          IFREQ2P=3
        endif

        IF (ISPECMODE.NE.5) THEN
          IF (IPIN.EQ.2) THEN
            WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. ISPECMODE.NE.5'
            WRITE(6,*)'*** IPIN SET TO 1'
            WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. ISPECMODE.NE.5'
            WRITE(LUNGFO,*)'*** IPIN SET TO 1'
            IPIN=1
          ENDIF !IPIN.EQ.2
          if (ibunch.eq.0) then
            IF (IFOLD.EQ.2) THEN
              WRITE(6,*)'*** WARNING IN GFINIT: IFOLD.EQ.2 .AND. ISPECMODE.NE.5'
              WRITE(6,*)'*** IFOLD SET TO 1'
              WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IFOLD.EQ.2 .AND. ISPECMODE.NE.5'
              WRITE(LUNGFO,*)'*** IFOLD SET TO 1'
              IFOLD=1
            ENDIF !IPIN.EQ.2
            IF (IEFOLD.EQ.2) THEN
              WRITE(6,*)'*** WARNING IN GFINIT: IEFOLD.EQ.2 .AND. ISPECMODE.NE.5'
              WRITE(6,*)'*** IEFOLD SET TO 1'
              WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IEFOLD.EQ.2 .AND. ISPECMODE.NE.5'
              WRITE(LUNGFO,*)'*** IEFOLD SET TO 1'
              IEFOLD=1
            ENDIF !IEFOLD.EQ.2
          endif
        ENDIF !ISPECMODE

        IF (IPIN.EQ.2.AND.ISPECDIP.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. ISPECDIP.NE.0'
          WRITE(6,*)'*** IPIN SET TO 1'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. ISPECDIP.NE.0'
          WRITE(LUNGFO,*)'*** IPIN SET TO 1'
          IPIN=1
        ENDIF !IPIN.EQ.2

        if (ibunch.eq.0) then
          IF (IFOLD.NE.0.AND.IPIN.EQ.0.AND.IFOLD.NE.2) THEN
            PRINT*,'            *** WARNING IN GFINIT: IPIN.EQ.0 .AND. IFOLD.NE.2'
            PRINT*,'            *** IFOLD SET TO ZERO'
            print*
            WRITE(LUNGFO,*)'             *** WARNING IN GFINIT: IPIN.EQ.0 .AND. IFOLD.NE.2'
            WRITE(LUNGFO,*)'             *** IFOLD SET TO ZERO'
            write(lungfo,*)
            IFOLD=0
          ENDIF
        endif !(ibunch.eq.0) then

        IF (IPIN.EQ.2.AND.IPINALL.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IPINALL.NE.0'
          WRITE(6,*)'*** IPINALL SET TO ZERO'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IPINALL.NE.0'
          WRITE(LUNGFO,*)'*** IPINALL SET TO ZERO'
          IPINALL=0
        ENDIF !IPIN.EQ.2

        IF (IPIN.EQ.2.AND.IWFILRAY.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IWFILRAY.NE.0'
          WRITE(6,*)'*** IWFILRAY SET TO ZERO'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IWFILRAY.NE.0'
          WRITE(LUNGFO,*)'*** IWFILRAY SET TO ZERO'
          IWFILRAY=0
        ENDIF !IPIN.EQ.2

        IF (IPIN.EQ.3.AND.IWFILRAY.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.3 .AND. IWFILRAY.NE.0'
          WRITE(6,*)'*** IWFILRAY SET TO ZERO'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.3 .AND. IWFILRAY.NE.0'
          WRITE(LUNGFO,*)'*** IWFILRAY SET TO ZERO'
          IWFILRAY=0
        ENDIF !IPIN.EQ.2

        IF (IPIN.EQ.2.AND.ISPECSUM.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. ISPECSUM.NE.0'
          WRITE(6,*)'*** ISPECSUM SET TO ZERO'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. ISPECSUM.NE.0'
          WRITE(LUNGFO,*)'*** ISPECSUM SET TO ZERO'
          ISPECSUM=0
        ENDIF !IPIN.EQ.2

        IF (IPIN.EQ.2.AND.ISPECANA.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. ISPECANA.NE.0'
          WRITE(6,*)'*** IPIN SET TO 1'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. ISPECANA.NE.0'
          WRITE(LUNGFO,*)'*** IPIN SET TO 1'
          IPIN=1
        ENDIF !IPIN.EQ.2

        IF (IPIN.EQ.2.AND.IAMPLI.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IAMPLI.NE.0'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IAMPLI.NE.0'
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED'
          STOP
        ENDIF !IPIN.EQ.2

        IF (IPIN.EQ.2.AND.IRFILOB.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IRFILOB.NE.0'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IRFILOB.NE.0'
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED'
          STOP
        ENDIF !IPIN.EQ.2

        IF (IPIN.EQ.2.AND.IUSEM.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IUSEM.NE.0'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IUSEM.NE.0'
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED'
          STOP
        ENDIF !IPIN.EQ.2

      ENDIF !ISPEC.NE.0

      IF (IFOLD.NE.0
     &    .AND.IFOLD.NE.1.AND.IFOLD.NE.2.AND.IFOLD.NE.-1.AND.IFOLD.NE.-2
     &    ) THEN
        WRITE(LUNGFO,*)
     &    '*** ERROR IN GFINIT: BAD VALUE OF IFOLD, CHECK INPUT '
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
        WRITE(6,*)
     &    '*** ERROR IN GFINIT: BAD VALUE OF IFOLD, CHECK INPUT '
        WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
        STOP
      ENDIF

      IF (NROI.EQ.0) THEN
        NROI=2
        ROIX(1)=-1.0D10
        ROIX(2)=1.0D10
        ROIP(1)=1.0D0
        ROIP(2)=1.0D0
        IROIASYEXP(1)=0
      ENDIF

      NROIA=ABS(NROI)

      IF (NROIA.GT.NROIP) THEN
        WRITE(6,*)
     &    '*** PARAMETER NROIP EXCEEDED: CHECK NROI IN NAMELIST ROIN'
        WRITE(6,*)
     &    'OR INCREASE NROIP IN SOURCE.CMN  ***'
        WRITE(LUNGFO,*)
     &    '*** PARAMETER NROIP EXCEEDED: CHECK NROI IN NAMELIST ROIN'
        WRITE(LUNGFO,*)
     &    'OR INCREASE NROIP IN SOURCE.CMN  ***'
        STOP
      ENDIF

      DO IROI=1,NROIA
        IF (ROIP(IROI).EQ.0.0D0) THEN
          ROIP(IROI)=1.0D0
        ENDIF
      ENDDO   !IROI

      IF (NROI.GT.0) THEN
        DO IROI=1,NROIA-1
          IF (ROIX(IROI).GE.ROIX(IROI+1)) THEN
            WRITE(6,*)
     &        '*** ERROR IN NAMELIST ROIN: VALUES OF ROIX NOT IN INCREASING ORDER'
            WRITE(6,*)
     &        '*** OR NUMBER OF ROIX DOES NOT MATCH NROI'
            WRITE(LUNGFO,*)
     &        '*** ERROR IN NAMELIST ROIN: VALUES OF ROIX NOT IN INCREASING ORDER'
            WRITE(LUNGFO,*)
     &        '*** OR NUMBER OF ROIX DOES NOT MATCH NROI'
            STOP
          ENDIF
        ENDDO   !IROI
      ENDIF

      IF (IPIN.EQ.2) THEN
        mpinyorig=mpiny
        mpinzorig=mpinz
        MPINZ=1
        MPINY=1
      ENDIF

      IF (ISIGSTO.EQ.0) ISIGSTO=1

      IF (ISPec.ne.0.and.ipin.eq.3.AND.IBRILL.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
        WRITE(LUNGFO,*)'FLAG IBRILL AND IPIN=3 ARE NOT COMPATIBLE'
        WRITE(LUNGFO,*)'IBRILL SET TO ZERO'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN GFINIT ***'
        WRITE(6,*)'FLAG IBRILL AND IPIN=3 ARE NOT COMPATIBLE'
        WRITE(6,*)'IBRILL SET TO ZERO'
        WRITE(6,*)
        ibrill=0
      ENDIF

      IF (ISPEC.NE.0.AND.IBRILL.NE.0.AND.ISTOKES.EQ.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'FLAG IBRILL IS SET BUT ISTOKES IS NOT'
        WRITE(LUNGFO,*)'SET ALSO FLAG ISTOKES IN INPUT FILE'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'FLAG IBRILL IS SET BUT ISTOKES IS NOT'
        WRITE(6,*)'SET ALSO FLAG ISTOKES IN INPUT FILE'
        WRITE(6,*)
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPEC.NE.0.AND.IWFILRAY.NE.0.AND.ISTOKES.EQ.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'FLAG IWFILRAY IS SET BUT ISTOKES IS NOT'
        WRITE(LUNGFO,*)'SET ALSO FLAG ISTOKES IN INPUT FILE'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'FLAG IWFILRAY IS SET BUT ISTOKES IS NOT'
        WRITE(6,*)'SET ALSO FLAG ISTOKES IN INPUT FILE'
        WRITE(6,*)
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPECMODE.LT.0) ISPECMODE=-ISPECMODE
      IF (ISPECMODE.EQ.0) ISPECMODE=2

      IF (
     &    ISPECMODE.NE.1.AND.
     &    ISPECMODE.NE.2.AND.
     &    ISPECMODE.NE.3.AND.
     &    ISPECMODE.NE.4.AND.
     &    ISPECMODE.NE.5) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'BAD VALUE OF ISPECMODE'
        WRITE(LUNGFO,*)'CHECK INPUT FILE WAVE.IN'
        WRITE(LUNGFO,*)

        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'BAD VALUE OF ISPECMODE'
        WRITE(6,*)'CHECK INPUT FILE WAVE.IN'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'

      ENDIF

C7MAR97      IF (IFILTER.EQ.0) IHFIL=0

      IF (IFILTER.LT.0.AND.IFILMUL.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'IFILTER.LT.0.AND.IFILMUL.NE.0'
        WRITE(LUNGFO,*)'CHECK INPUT FILE WAVE.IN'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'IFILTER.LT.0.AND.IFILMUL.NE.0'
        WRITE(6,*)'CHECK INPUT FILE WAVE.IN'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IFILTER.EQ.0.AND.IFILMUL.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
        WRITE(LUNGFO,*)'IFILMUL.NE.0 .AND. IFILTER.EQ.0'
        WRITE(LUNGFO,*)'IFILTER SET TO ONE'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN GFINIT ***'
        WRITE(6,*)'IFILMUL.NE.0 .AND. IFILTER.EQ.0'
        WRITE(6,*)'IFILTER SET TO ONE'
        WRITE(6,*)
        IFILTER=1
      ENDIF

      if (imagspln.eq.-9999.and.ibunch.ne.0) then
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
        WRITE(LUNGFO,*)'IMAGSPLN.EQ.-9999.AND.IUBUNCH.NE.0'
        WRITE(LUNGFO,*)'IMAGSPLN SET TO ZERO'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN GFINIT ***'
        WRITE(6,*)'IMAGSPLN.EQ.-9999.AND.IUBUNCH.NE.0'
        WRITE(6,*)'IMAGSPLN SET TO ZERO'
        WRITE(6,*)
        imagspln=0
      endif

      IF (IMAGSPLN.NE.-9999.AND.IMAGSPLN.LT.0) IMAGSPLN=-1

      IF (IMAGSPLN.GT.0) THEN

        OPEN(UNIT=99,FILE='magjob.dat',STATUS='OLD'
+SELF,IF=-windows.
     &    ,RECL=256)
+SELF,IF=WINDOWS.
     &    )
+SELF.

        READ(99,*)IMAGJOB
        READ(99,*)

        IF (IMAGSPLN.NE.IMAGJOB) THEN

          WRITE(6,*)'*** ERROR IN GFINIT:'
          WRITE(6,*)
     &      'IMAGSPLN DOES NOT MATCH JOB NUMBER ON FILE IMAGSPL:magjob.dat'
          WRITE(6,*)'FIELD TAKEN FROM REFERENCE ORBIT'
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT:'
          WRITE(LUNGFO,*)
     &      'IMAGSPLN DOES NOT MATCH JOB NUMBER ON FILE IMAGSPL:magjob.dat'
          WRITE(LUNGFO,*)'FIELD TAKEN FROM REFERENCE ORBIT'
          READ(99,*)XSTART,YSTART,ZSTART
          READ(99,*)VXIN,VYIN,VZIN
          READ(99,*)XSTOPR,DMYENERGY
          IF (XSTOP.EQ.9999.) XSTOP=XSTOPR

        ENDIF   !IMAGJOB

        CLOSE(99)

      ENDIF   !IMAGSPLN

C5.10.95 IF (ISPEC.NE.0.AND.IMAGSPLN.NE.0.AND.IOPTIC.NE.0) THEN
C5.10.95 WARUM ISPEC ?? IN ABFRAGE?? BEOBACHTEN
      IF (IMAGSPLN.NE.0.AND.IOPTIC.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'FLAGS IMAGSPLN AND IOPTIC ARE SET'
        WRITE(LUNGFO,*)'TURN OFF IMAGSPLN, IF YOU USE IOPTIC'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'FLAGS IMAGSPLN AND IOPTIC ARE SET'
        WRITE(6,*)'TURN OFF IMAGSPLN, IF YOU USE IOPTIC'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IMAGSPLN.NE.0.AND.IBFORCE.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'FLAGS IMAGSPLN AND IBFORCE ARE SET'
        WRITE(LUNGFO,*)'TURN OFF IMAGSPLN, IF YOU USE IBFORCE'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'FLAGS IMAGSPLN AND IBFORCE ARE SET'
        WRITE(6,*)'TURN OFF IMAGSPLN, IF YOU USE IBFORCE'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

+self,if=20220316.
      IF (IMAGSPLN.NE.0.AND.IWBMAP.NE.0
     &    .OR.
     &    IMAGSPLN.NE.0.AND.IWBTAB.NE.0
     &    ) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'BOTH FLAGS IMAGSPLN AND IWBMAP/IWBTAB ARE SET'
        WRITE(LUNGFO,*)'TURN OFF IMAGSPLN, IF YOU USE IWBMAP/IWBTAB'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'BOTH FLAGS IMAGSPLN AND IWBMAP/IWBTAB ARE SET'
        WRITE(6,*)'TURN OFF IMAGSPLN, IF YOU USE IWBMAP/IWBTAB'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF
+self,if=-20220316.
          IF ((IWBMAP.NE.0.OR.IBFORCE.NE.0.OR.IOPTIC.NE.0)
     &        .and.
     &    (iemit.ne.0.or.kbrec.ne.0.or.kbundumag.ne.0.or.kbextern.ne.0.or.kbpolymag.ne.0)) then
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'BOTH FLAGS IMAGSPLN AND IWBMAP ARE SET'
        WRITE(LUNGFO,*)'TURN OFF IMAGSPLN, IF YOU USE IWBMAP'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'BOTH FLAGS IMAGSPLN AND IWBMAP ARE SET'
        WRITE(6,*)'TURN OFF IMAGSPLN, IF YOU USE IWBMAP'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF
+self.

      IF (ISPEC.NE.0) THEN

        IF (IDESYNC.NE.0.AND.IFOLD.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IDESYNC AND IFOLD ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'IFOLD SET TO ZERO'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IDESYNC AND IFOLD ARE INCOMPATIBLE'
          WRITE(6,*)'IFOLD SET TO ZERO'
          WRITE(6,*)
          IFOLD=0
        ENDIF

        IF (IDESYNC.NE.0.AND.IDOSE.EQ.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IDESYNC AND IDOSE ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'IDOSE SET TO ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IDESYNC AND IDOSE ARE INCOMPATIBLE'
          WRITE(6,*)'IDOSE SET TO ONE'
          WRITE(6,*)
          IDOSE=1
        ENDIF

        IF (IDESYNC.NE.0.AND.ISTOKES.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IDESYNC AND ISTOKES ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'ISTOKES SET TO ZERO'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IDESYNC AND ISTOKES ARE INCOMPATIBLE'
          WRITE(6,*)'ISTOKES SET TO ZERO'
          WRITE(6,*)
          ISTOKES=0
        ENDIF

        IF (IRFILSP0.NE.0.AND.IBRILL.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IRFILSP0 AND IBRILL ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'IBRILL SET TO ZERO'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IRFILSP0 AND IBRILL ARE INCOMPATIBLE'
          WRITE(6,*)'IBRILL SET TO ZERO'
          WRITE(6,*)
          IBRILL=0
        ENDIF

        IF (IRFILSP0.NE.0.AND.ISTOKES.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IRFILSP0 AND ISTOKES ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'ISTOKES SET TO ZERO'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IRFILSP0 AND ISTOKES ARE INCOMPATIBLE'
          WRITE(6,*)'ISTOKES SET TO ZERO'
          WRITE(6,*)
          ISTOKES=0
        ENDIF

        IF (IDESYNC.NE.0.AND.IPIN.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IDESYNC AND IPIN ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'IPIN SET TO ZERO'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IDESYNC AND IPIN ARE INCOMPATIBLE'
          WRITE(6,*)'IPIN SET TO ZERO'
          WRITE(6,*)
          IPIN=0
        ENDIF

        IF (IPHASE.NE.0.AND.(IPIN.EQ.0.OR.IPIN.EQ.2)) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAGS IPHASE AND IPIN ARE INCOMPATIBLE'
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAGS IPHASE AND IPIN ARE INCOMPATIBLE'
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF

+self,if=testiampli
        IF (iampskip.eq.0
     &      .and.IAMPLI.GT.0.AND.ISPECMODE.lt.3.and.iamprep.ge.0) THEN
c noch ueberdenken, iphase bereits kompatibel gemacht, 17.10.2012
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAGS IAMPLI AND ISPECMODE ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'WILL RESULTS IN ERRORS FOR PHASE PROPAGATION'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN GFINIT ***'
          WRITE(6,*)'FLAGS IAMPLI AND ISPECMODE ARE INCOMPATIBLE'
          WRITE(6,*)'WILL RESULTS IN ERRORS FOR PHASE PROPAGATION'
          WRITE(LUNGFO,*)
     &      '*** ISPECMODE set to 3, due to IPHASE'
          PRINT *,
     &      '*** ISPECMODE set to 3, due to IPHASE'
                ISPECMODE=3
          WRITE(6,*)
        ENDIF
+self...,if=testiampli

      ENDIF !ISPEC

      IF (IF1DIM.EQ.1.AND.IRPHI.NE.0.AND.IPINCIRC.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '*** WARNING IN GFINIT: IF1DIM.EQ.1.AND.IRPHI.NE.0.AND.IPINCIRC.NE.0'
        WRITE(LUNGFO,*)'IRPHI SET TO ZERO'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)
     &    '*** WARNING IN GFINIT: IF1DIM.EQ.1.AND.IRPHI.NE.0.AND.IPINCIRC.NE.0'
        WRITE(6,*)'IRPHI SET TO ZERO'
        WRITE(6,*)
        IRPHI=0
      ENDIF

      IF (IPIN.EQ.0.AND.IPINCIRC.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'WARNING IN GFINIT: IPIN.EQ.0.AND.IPINCIRC.NE.0'
        WRITE(LUNGFO,*)'IPINCIRC SET TO ZERO'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'WARNING IN GFINIT: IPIN.EQ.0.AND.IPINCIRC.NE.0'
        WRITE(6,*)'IPINCIRC SET TO ZERO'
        WRITE(6,*)
        IPINCIRC=0
      ENDIF

      if (ivelofield.eq.2) then
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '*** IVELOFIELD=2 is obsolete and not supported anymore ***'
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED'
        WRITE(6,*)
        WRITE(6,*)
     &    '*** IVELOFIELD=2 is obsolete and not supported anymore ***'
        WRITE(6,*)'*** PROGRAM WAVE ABORTED'
        stop
      endif

      IF (iphfold.ne.0.and.(phbeth.eq.-9999.0d0 .or. phbetav.eq.-9999.0d0)) THEN
        print*,'--- IEMIT triggerd due to IPHFOLD and (IPHBETH=-9999 or IPHBETAV=-9999 ---'
        iemit=1
      ENDIF

C--- WRITE CONTROL FLAGS

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     MODE FLAGS:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     IUNDULATOR,IWIGGLER: ',IUNDULATOR,IWIGGLER
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     CONTROL FLAGS:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)'     IUNAME,IUSTEP,IUOUT: ',IUNAME,IUSTEP,IUOUT
      WRITE(LUNGFO,*)'     IOPTIC,IGENFUN:      ',IOPTIC,IGENFUN
      WRITE(LUNGFO,*)'     IMAGSPLN:            ',IMAGSPLN
      IF (IOPTIC.NE.0.) THEN
       WRITE(LUNGFO,*)'        IPHASPAC, IHPHSPAC:         ',IPHASPAC,IHPHSPAC
      ENDIF
      IF (IOPTIC.NE.0.OR.IGENFUN.NE.0) THEN
         WRITE(LUNGFO,*)'        IERZANA,IERZFUN,I2DIM:     ',
     &                             IERZANA,IERZFUN,I2DIM
      ENDIF
      WRITE(LUNGFO,*)'     IEMIT,IEMIAHW:       ',IEMIT,IEMIAHW
      WRITE(LUNGFO,*)'     IWLSOPT,IBEAMPOL:    ',IWLSOPT,IBEAMPOL
      IF (IWLSOPT.NE.0) THEN
         WRITE(LUNGFO,*)'        IEMICRIT:                  ',IEMICRIT
      ENDIF
      WRITE(LUNGFO,*)'     IENELOSS, IEFIELD:   ',IENELOSS,IEFIELD
      WRITE(LUNGFO,*)'     IPOWER,ISPEC:        ',IPOWER,ISPEC
      WRITE(LUNGFO,*)'     IVELOFIELD,ISPECMODE:',IVELOFIELD,ISPECMODE

      IF (JWFILINT.LE.0) JWFILINT=-jwfilint

      IF (ISPEC.NE.0) THEN
        if (mthreads.ne.0.and.mthreads.ne.1.and.iwfilint.ne.0) then
          print*,"*** Warning in gfinit: MTHREADS set to zero, since IWFILINT is set ***"
          mthreads=0
        endif
        WRITE(LUNGFO,*)'        IWFILL0,IRFILL0:           ',IWFILL0,IRFILL0
        WRITE(LUNGFO,*)'        ISPECINT,IPIN:             ',ISPECINT,IPIN
        WRITE(LUNGFO,*)'        ISTOKES,IBRILL:            ',ISTOKES,IBRILL
        WRITE(LUNGFO,*)'        IPINCIRC,IRPHI:            ',IPINCIRC,IRPHI
        WRITE(LUNGFO,*)'        IFOLD,ISIGUSR:             ',IFOLD,ISIGUSR
        WRITE(LUNGFO,*)'        IF1DIM,IPOLA:              ',IF1DIM,IPOLA
        WRITE(LUNGFO,*)'        IWFILSP0,IWFILSPF:         ',IWFILSP0,IWFILSPF
        WRITE(LUNGFO,*)'        IRFILSP0,IRFILSTO:         ',IRFILSP0,IRFILSTO
        WRITE(LUNGFO,*)'        IWFILSTO,IWFLSTOF:         ',IWFILSTO,IWFLSTOF
        WRITE(LUNGFO,*)'        ISPECANA,ISPECANAF:        ',ISPECANA,ISPECANAF
        WRITE(LUNGFO,*)'        IAMPLI,IAMPSKIP:           ',IAMPLI,IAMPSKIP
        WRITE(LUNGFO,*)'        IWFILFL0,IWFILFLF:         ',IWFILFL0,IWFILFLF
        WRITE(LUNGFO,*)'        IWFILS,IWFILSF:            ',IWFILS,IWFILSF
        WRITE(LUNGFO,*)'        IWFILSE,IWFILSEF:          ',IWFILSE,IWFILSEF
        WRITE(LUNGFO,*)'        IWFILB,IWFILBF:            ',IWFILB,IWFILBF
        WRITE(LUNGFO,*)'        IWFILBE,IWFILBEF:          ',IWFILBE,IWFILBEF
        WRITE(LUNGFO,*)'        IWFILINT,IPINALL:          ',IWFILINT,IPINALL
        WRITE(LUNGFO,*)'        IRFILOB,IFILTER:           ',IRFILOB,IFILTER
        WRITE(LUNGFO,*)'        IWFILRAY,IDESYNC:          ',IWFILRAY,IDESYNC
        WRITE(LUNGFO,*)'        IPHASE,IPHASEANA:          ',IPHASE,IPHASEANA
        WRITE(LUNGFO,*)'        IDOSE,IEFOLD:              ',IDOSE,IEFOLD
        WRITE(LUNGFO,*)'        ISPECDIP,IBL0CUT:          ',ISPECDIP,IBL0CUT
        WRITE(LUNGFO,*)'        IEFFI,IFILMUL:             ',IEFFI,IFILMUL
        WRITE(LUNGFO,*)'        IBUNCH, IUBUNCH, NBUNCH:   ',IBUNCH,IUBUNCH,NBUNCH
      ENDIF !ISPEC

      WRITE(LUNGFO,*)'     IWFILF:              ',IWFILF


      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     MAGNETIC FIELD FLAGS:'
      WRITE(LUNGFO,*)
      IF (ICHARGE.GT.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'ATTENTION: TRACKING POSITRONS ***'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'ATTENTION: TRACKING POSITRONS ***'
        WRITE(6,*)
        ICHARGE=1
      ELSE IF (ICHARGE.LT.0) THEN
        ICHARGE=-1
      ELSE
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** Error in GFINIT: ICHARGE IS ZERO, check wave.in'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** Error in GFINIT: ICHARGE IS ZERO, check wave.in'
        WRITE(6,*)
        STOP '*** Program WAVE aborted ***'
      ENDIF !ICHARGE

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     ICHARGE,IBMASK,JBMASK:',ICHARGE,IBMASK,JBMASK
      WRITE(LUNGFO,*)'     IBSUPER,IBERROR:      ',IBSUPER,IBERROR
      WRITE(LUNGFO,*)'     ICUTFIBO:             ',ICUTFIBO
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)'     IPERIODG,IBSYM:      ',IPERIODG,IBSYM
      WRITE(LUNGFO,*)'     IBSYMY,IBSYMZ:       ',IBSYMY,IBSYMZ
      WRITE(LUNGFO,*)'     KBEXTERN,KBFELD:     ',KBEXTERN,KBFELD
      WRITE(LUNGFO,*)'     KHALBA,KHALBASY:     ',KHALBA,KHALBASY
      WRITE(LUNGFO,*)'     KUCROSS,IRFILP:      ',KUCROSS,IRFILP
      WRITE(LUNGFO,*)'     KMAGSEQ,IMGSQF:      ',KMAGSEQ,IMGSQF
      WRITE(LUNGFO,*)'            KMAGCOR:      ',KMAGCOR
      WRITE(LUNGFO,*)'     IRFILF,KELLIP:       ',IRFILF,KELLIP
      WRITE(LUNGFO,*)'     IRBTAB,IRBTABZY:     ',IRBTAB,IRBTABZY
      WRITE(LUNGFO,*)'     IFOURBTABZY:         ',IFOURBTABZY
      WRITE(LUNGFO,*)'     IRFILT0,IRBTABXYZ:   ',IRFILT0,IRBTABXYZ
      WRITE(LUNGFO,*)'     KBPOLYH,KBPOLY3D:    ',KBPOLYH,KBPOLY3D
      WRITE(LUNGFO,*)'     KBREC,KELLANA:       ',KBREC,KELLANA
      if (kbrec.gt.0) then
        WRITE(LUNGFO,*)'          IRECU:          ',IRECU
        WRITE(LUNGFO,*)'          IRECMODU:       ',IRECMODU
      endif
      WRITE(LUNGFO,*)'     KUNDUGAP,KBUNDUMAG:  ',kundugap,kbundumag
      WRITE(LUNGFO,*)'     KBPOLYMAG,KBGENESIS: ',KBPOLYMAG,KBGENESIS
      WRITE(LUNGFO,*)'     KBAMWLS,IRFILB0:     ',KBAMWLS,IRFILB0
      WRITE(LUNGFO,*)'     ICLUSTER:            ',ICLUSTER
      WRITE(LUNGFO,*)

+self,if=omp.
      if (iundulator.ne.2.and.ibunch.ne.0.and.mthreads.ne.0.and.icluster.eq.0) then
        write(6,*)""
        write(6,*)"*** Warning in gfinit: IBUNCH and MTHREAD not zero ***"
        write(6,*)"*** This is not yet implemented, be careful, better set MTHREADS=0 ***"
        write(6,*)"*** Or consider IUNDULATOR=2 ***"
        write(6,*)""
      endif

      if (ipin.ne.3.and.ipin.ne.0) then
        call omp_ini(lungfo,mthreads,1)
      else
        mthreads=0
        iomp=0
      endif
+self.

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     HISTOGRAM FLAGS:'
      WRITE(LUNGFO,*)

      IF (NINTFREQ.GT.99.AND.IHPIN.GT.0.and.IFREQ2P.gt.1.and.ispec.ne.0) THEN
      IHPIN=0
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &'*** WARNING IN GFINIT: MORE THAN 99 PHOTONENERGIES CONSIDERED'
      WRITE(LUNGFO,*)
     &'HISTOGRAMS FOR FOLDING FUNCTION AND FLUX DISTRIBUTION CANCELED'
      WRITE(LUNGFO,*)
      WRITE(6,*)
      WRITE(6,*)
     &'*** WARNING IN GFINIT: MORE THAN 99 PHOTONENERGIES CONSIDERED'
      WRITE(6,*)
     &'HISTOGRAMS FOR FOLDING FUNCTION AND FLUX DISTRIBUTION CANCELED'
      WRITE(6,*)
      ENDIF

      IF (IEMIT.EQ.0) IHBETA=0
      IF (IPIN.EQ.0)  IHPIN=0
      IF (IPIN.EQ.0)  IHFOLD=0
      IF (IFOLD.EQ.0)  IHFOLD=0
      IF (ISPEC.EQ.0) then
        IHFREQ=0
        ihpin=0
      endif

      if (ihpin.ne.0.and.ihfreq.eq.0) then
        write(6,*)'*** Warning in GFINIT: IHPIN.NE.0 but IHFREQ.EQ.0 ***'
        write(6,*)'*** IHFREQ SET TO ONE ***'
        write(LUNGFO,*)'*** Warning in GFINIT: IHPIN.NE.0 but IHFREQ.EQ.0 ***'
        write(LUNGFO,*)'*** IHFREQ SET TO ONE ***'
        ihfreq=1
      endif

      if (ntupgrid.ne.0.and.mhbookp.ne.0) then
        write(6,*)'*** WARNING: NTUPGRID is set zero, since it is obsolete for this version of WAVE!'
        ntupgrid=0
      endif

      ihtrack=-abs(ihtrack) ! Block old fashioned histograms
      ihtrackm=-abs(ihtrackm) ! Block old fashioned histograms

      IF (IHFIL.NE.0.OR.IHPIN.NE.0.OR.IHTRACK.NE.0.OR.IHBETA.NE.0
     &  .OR.IHTRACKM.NE.0.OR. IHFREQ.NE.0.OR.IPOWER.NE.0
     &  .OR.IHPHSPAC.NE.0.OR.IHINPUT.NE.0
     &  .OR.IHBPOLY3D.NE.0.OR.IHBPOLY2DH.NE.0.OR.IHBPHARM.NE.0
     &  .OR.IHSEL.NE.0.OR.IHFOLD.NE.0.OR.NTUPGRID.NE.0.OR.KBGENESIS.GT.0
     &  .or.ihbunch.ne.0.or.(ieneloss.lt.0.and.ihphotons.ne.0)
     &  )IHBOOK=1

      if (ihbook.eq.0) ihindex=0

      WRITE(LUNGFO,*)'     IHBOOK,IHINDEX:      ',IHBOOK,IHINDEX

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     OTHER OPTIONS:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)'     IWBTAB,IWFILT0:      ',IWBTAB,IWFILT0
      WRITE(LUNGFO,*)'     IWSECTMAGS:          ',IWSECTMAGS
      WRITE(LUNGFO,*)'     IJUST,ISNORDER:      ',IJUST,ISNORDER
      WRITE(LUNGFO,*)'     IWBMAP,IWBPOLY3D:    ',IWBMAP,IWBPOLY3D
      WRITE(LUNGFO,*)'     IWBPOLY2DH,IWBPHARM: ',IWBPOLY2DH,IWBPHARM
      WRITE(LUNGFO,*)

      if (irfilt0.ne.0) call trajectory_to_bfield_ini

C--- MERGE FILE WITH ABSORPTION COEFFICIENTS AND EXIT

      IF (ISPEC.NE.0.AND.IFILTER.LT.0) THEN
          CALL ABSCOEF_MERGE
      ENDIF

C--- SOME USEFUL CONSTANTS AND VARIABLES

c11.10.2017      DTIM=1.0D0/(CLIGHT1*MYINUM)   !TIME INTERVALLS FOR TRACKING
      DTIM=1.0D0/(CLIGHT1*dmybetap*MYINUM)   !TIME INTERVALLS FOR TRACKING
      BSHIFT=0.5D0          !DONT WORRY

      DS0=CLIGHT1*DTIM
      GAMMA=DMYGAMMA
      ENERGV=GAMMA*EMASSE1
      GMOM=EMASSG1*DSQRT((GAMMA-1.0d0)*(GAMMA+1.0d0))
      EMOM=EMASSE1*DSQRT((GAMMA-1.0d0)*(GAMMA+1.0d0))
      DBRHO=ICHARGE*EMOM/CLIGHT1
      BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
      DMYBETA=BETA
      V0=CLIGHT1*BETA
      TAUPOL01G=POL2CON1*UMFANG*RDIPOL**2/1.**5

      ecdipev1=3.0d0/2.0d0*hbarev1*(clight1/emasse1)**2/emasse1*1.0d18

      gamma1=1.0d0/emassg1
      emom1=emasse1*dsqrt((gamma1-1.0d0)*(gamma1+1.0d0))
      rho1=emom1/clight1
      omegac=1.5d0*gamma1**3*clight1/rho1
c      ecdipev=omegac*hbar1/echarge1
c      ecdipkev=ecdipev/1000.0d0

      CROTD=DCOSD(XROTD)
      SROTD=DSIND(XROTD)

C--- NORMALIZATION OF SPECTRUM
C    THE INTEGRATION (SR SPECTRUM) YIELDS THE PHOTON POWER PER ENERGY INTERVAL
C    dE AND SURFACE ELEMENT dA. THIS RESULT IS MULITPLIED BY THE NUMBER OF
C    ELECTRONS (DMYCUR/ECHARGE1),
C    A CONSTANT (ECHARGE1**2/(16*PI**3*EPS01*CLIGHT),
C    dE/E AND THE RELATIVE BANDWIDTH (USUALLY 1/1000). THE FINAL RESULT IS
C    OBTAINED BY A DIVISION THROUGH THE PHOTON ENERGY HBAR*OMEGA, WHICH GIVES
C    NOW THE PHOTON RATE PER BANDWIDTH AND SURFACE ELEMENT IN SI-UNITS

C     SPECNOR=    !DONT USE IT!!!
C     &          ECHARGE1**2/(4.D0*PI1**2*CLIGHT1)
C     &          /(4.D0*PI1*EPS01)
C     &          *DMYCUR/ECHARGE1
C     &          *BANWID
C     &          /(HBAREV1*ECHARGE1)

      SPECNOR=
     &          BANWID
     &          /(4.0D0*PI1**2*CLIGHT1*HBAREV1)
     &          /(4.0D0*PI1*EPS01)
     &          *DMYCUR

      POWNOR=ECHARGE1/16.0D0/PI1/PI1/EPS01/CLIGHT1*DMYCUR

C- NORMALIZE POLARIZATION VECTOR

      IF (IPOLA.NE.0) THEN

+SELF,IF=-NOCMPLX.

          VPOLAN=CDSQRT(
     &             VPOLA(1)*CONJG(VPOLA(1))
     &            +VPOLA(2)*CONJG(VPOLA(2))
     &            +VPOLA(3)* CONJG(VPOLA(3)))

          IF (VPOLAN.EQ.0.0) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
         WRITE(LUNGFO,*)'     POLARIZATION PLANE NOT DEFINED'
         WRITE(LUNGFO,*)'     CHECK VECTOR VPOLA IN NAMELIST SPECTN'
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)'     *** ERROR IN GFINIT ***'
         WRITE(6,*)'     POLARIZATION PLANE NOT DEFINED'
         WRITE(6,*)'     CHECK VECTOR VPOLA IN NAMELIST SPECTN'
         WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
          ENDIF !VPOLAN
          DO ICOMP=1,3
         VPOLA(ICOMP)=VPOLA(ICOMP)/VPOLAN
          ENDDO   !ICOMP
      ENDIF !IPOLA


        VSTOKES(1,1)=( 0.0d0,        0.0d0)      !HORIZONTAL POLARIZATION
        VSTOKES(1,2)=( 0.0d0,        0.0d0)
c        VSTOKES(1,3)=(-1.0d0,        0.0d0) !7mar05
        VSTOKES(1,3)=(-1.0d0,       -1.0d0) !Definition siehe
                                       !scienceworld.wolfram.com
                                       !liefert aber nur Phasenfaktor
                                       !im Vergleich zur alten Fassung

        VSTOKES(2,1)=( 0.0d0,        0.0d0)      !RIGHT HANDED POLARIZATION
        VSTOKES(2,2)=( 0.0d0,       -1.0d0)
        VSTOKES(2,3)=(+1.0d0,        0.0d0)

        VSTOKES(3,1)=( 0.0d0,        0.0d0)      !LEFT HANDED POLARIZATION
        VSTOKES(3,2)=( 0.0d0,       -1.0d0)
        VSTOKES(3,3)=(-1.0d0,        0.0d0)

        VSTOKES(4,1)=( 0.0d0,        0.0d0)      !45 DEGREE LINEAR POLARIZATION
        VSTOKES(4,2)=( 1.0d0,        0.0d0)
        VSTOKES(4,3)=(-1.0d0,        0.0d0)

         DO ISTO=1,4
             VSTO=DSQRT
     &            (CDABS(VSTOKES(ISTO,1))**2
     &            +CDABS(VSTOKES(ISTO,2))**2
     &            +CDABS(VSTOKES(ISTO,3))**2)
             VSTOKES(ISTO,1)=VSTOKES(ISTO,1)/VSTO
             VSTOKES(ISTO,2)=VSTOKES(ISTO,2)/VSTO
             VSTOKES(ISTO,3)=VSTOKES(ISTO,3)/VSTO

+SELF,IF=NOCMPLX.

          VPOLAN=SQRT(
     &             VPOLAR(1)*VPOLAR(1)+VPOLAI(1)*VPOLAI(1)
     &            +VPOLAR(2)*VPOLAR(2)+VPOLAI(2)*VPOLAI(2)
     &            +VPOLAR(3)*VPOLAR(3)+VPOLAI(3)*VPOLAI(3))

          IF (VPOLAN.EQ.0.0) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
         WRITE(LUNGFO,*)'     POLARIZATION PLANE NOT DEFINED'
         WRITE(LUNGFO,*)'     CHECK VECTOR VPOLA IN NAMELIST SPECTN'
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)'     *** ERROR IN GFINIT ***'
         WRITE(6,*)'     POLARIZATION PLANE NOT DEFINED'
         WRITE(6,*)'     CHECK VECTOR VPOLA IN NAMELIST SPECTN'
         WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
          ENDIF !VPOLAN

          DO ICOMP=1,3
              VPOLAR(ICOMP)=VPOLAR(ICOMP)/VPOLAN
              VPOLAI(ICOMP)=VPOLAI(ICOMP)/VPOLAN
          ENDDO   !ICOMP

      ENDIF !IPOLA


        VSTOKESR(1,1)=0.0D0      !HORIZONTAL POLARIZATION
        VSTOKESR(1,2)=0.0D0
        VSTOKESR(1,3)=-1.0D0
        VSTOKESI(1,1)=0.0D0      !HORIZONTAL POLARIZATION
        VSTOKESI(1,2)=0.0D0
        VSTOKESI(1,3)=0.0D0

        VSTOKESR(2,1)=0.0D0    !RIGHT HANDED POLARIZATION
        VSTOKESR(2,2)=0.0D0
        VSTOKESR(2,3)=+1.0D0
        VSTOKESI(2,1)=0.0D0      !RIGHT HANDED POLARIZATION
        VSTOKESI(2,2)=-1.0D0
        VSTOKESI(2,3)=0.0D0

        VSTOKESR(3,1)=0.0D0  !LEFT HANDED POLARIZATION
        VSTOKESR(3,2)=0.0D0
        VSTOKESR(3,3)=-1.0D0
        VSTOKESI(3,1)=0.0D0      !LEFT HANDED POLARIZATION
        VSTOKESI(3,2)=-1.0D0
        VSTOKESI(3,3)=0.0D0

        VSTOKESR(4,1)=0.0D0  !45 DEGREE LINEAR POLARIZATION
        VSTOKESR(4,2)=1.0D0
        VSTOKESR(4,3)=-1.0D0
      VSTOKESI(4,1)=0.0D0      !45 DEGREE LINEAR POLARIZATION
        VSTOKESI(4,2)=0.0D0
        VSTOKESI(4,3)=0.0D0

         DO ISTO=1,4
             VSTO=SQRT(
     &            VSTOKESR(ISTO,1)**2+VSTOKESI(ISTO,1)**2
     &           +VSTOKESR(ISTO,2)**2+VSTOKESI(ISTO,2)**2
     &           +VSTOKESR(ISTO,3)**2+VSTOKESI(ISTO,3)**2)
             VSTOKESR(ISTO,1)=VSTOKESR(ISTO,1)/VSTO
             VSTOKESR(ISTO,2)=VSTOKESR(ISTO,2)/VSTO
             VSTOKESR(ISTO,3)=VSTOKESR(ISTO,3)/VSTO
             VSTOKESI(ISTO,1)=VSTOKESI(ISTO,1)/VSTO
             VSTOKESI(ISTO,2)=VSTOKESI(ISTO,2)/VSTO
             VSTOKESI(ISTO,3)=VSTOKESI(ISTO,3)/VSTO

+SELF.
         ENDDO

C--- RETURN IF WLSOPT IS SELECTED

c      IF(IDISPER.EQ.0.AND.IWLSOPT.NE.0) RETURN !NUR OPTIMALEN AHW SUCHEN

C--- ADJUST SOMETHING

      IF(IJUST.NE.0) THEN
         XJUST=HSHIFT   !XJUST is adjusted by bringing YJUST to zero
         YJUST=ZF0
         CALL WLSJUST(XJUST,YJUST)
         HSHIFT=XJUST
      ENDIF

C--- CHECK CONTROL FLAGS (HBOOK FLAGS ALREADY CHECKED)

c24.3.94{ wegen efold und anderer unsicherheiten, da evtl irgendwo statements
c         wie dfreq=freq(2)-freq(1) auftauchen}

      IF (IUNIT.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'OPTION iunit DISABLED, DO NOT USE!'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'OPTION iunit DISABLED, DO NOT USE!'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

c24.3.94}

      IF (IWBPOLY3D.NE.0.AND.KBPOLY3D.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAGS IWBPOLY3D AND KBPOLY3D ARE BOTH SET'
          WRITE(LUNGFO,*)'ONLY ONE IS ALLOWED'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAGS IWBPOLY3D AND KBPOLY3D ARE BOTH SET'
          WRITE(6,*)'ONLY ONE IS ALLOWED'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IWBPOLY3D.NE.0.AND.IWBPOLY2DH.NE.0.AND.IWBPHARM.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &'MORE THAN ONE FLAG OF IWBPOLY3D,IWBPOLY2DH,IWBPHARM ARE SET'
          WRITE(LUNGFO,*)'ONLY ONE IS ALLOWED'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &'MORE THAN ONE FLAG OF IWBPOLY3D,IWBPOLY2DH,IWBPHARM ARE SET'
          WRITE(6,*)'ONLY ONE IS ALLOWED'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IWBPOLY3D.NE.0.AND.IWBMAP.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAGS IWBPOLY3D AND IWBMAP ARE BOTH SET'
          WRITE(LUNGFO,*)'ONLY ONE IS ALLOWED'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAGS IWBPOLY3D AND IWBMAP ARE BOTH SET'
          WRITE(6,*)'ONLY ONE IS ALLOWED'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IWBPOLY2DH.NE.0.AND.KBPOLY2DH.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAGS IWBPOLY2DH AND KBPOLY2DH ARE BOTH SET'
          WRITE(LUNGFO,*)'ONLY ONE IS ALLOWED'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAGS IWBPOLY2DH AND KBPOLY2DH ARE BOTH SET'
          WRITE(6,*)'ONLY ONE IS ALLOWED'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IWBPHARM.NE.0.AND.KBPHARM.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAGS IWBPHARM AND KBPHARM ARE BOTH SET'
          WRITE(LUNGFO,*)'ONLY ONE IS ALLOWED'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAGS IWBPHARM AND KBPHARM ARE BOTH SET'
          WRITE(6,*)'ONLY ONE IS ALLOWED'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IWBPOLY2DH.NE.0.AND.IWBMAP.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAGS IWBPOLY2DH AND IWBMAP ARE BOTH SET'
          WRITE(LUNGFO,*)'ONLY ONE IS ALLOWED'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAGS IWBPOLY2DH AND IWBMAP ARE BOTH SET'
          WRITE(6,*)'ONLY ONE IS ALLOWED'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IWBPHARM.NE.0.AND.IWBMAP.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAGS IWBPHARM AND IWBMAP ARE BOTH SET'
          WRITE(LUNGFO,*)'ONLY ONE IS ALLOWED'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAGS IWBPHARM AND IWBMAP ARE BOTH SET'
          WRITE(6,*)'ONLY ONE IS ALLOWED'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPEC.NE.0.AND.IEFOLD.NE.0.AND.ISTOKES.EQ.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAG IEFOLD IS SET BUT ISTOKES IS NOT'
          WRITE(LUNGFO,*)'SET ALSO FLAG ISTOKES IN INPUT FILE'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAG IEFOLD IS SET BUT ISTOKES IS NOT'
          WRITE(6,*)'SET ALSO FLAG ISTOKES IN INPUT FILE'
          WRITE(6,*)
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPEC.NE.0.AND.IDOSE.NE.0.AND.ISPECINT.EQ.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAG IDOSE IS SET BUT ISPECINT IS NOT'
          WRITE(LUNGFO,*)'SET FLAG ISPECINT IN INPUT FILE'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAG IDOSE IS SET BUT ISPECINT IS NOT'
          WRITE(6,*)'SET FLAG ISPECINT IN INPUT FILE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF
      IF (IWFILSP0.NE.0.AND.IRFILSP0.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IWFILSP0 AND IRFILSP0 ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IWFILSP0 AND IRFILSP0 ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IWFILSTO.NE.0.AND.IRFILSTO.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IWFILSTO AND IRFILSTO ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IWFILSTO AND IRFILSTO ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPECANA.NE.0.AND.IDESYNC.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS ISPECANA AND IDESYNC ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS ISPECANA AND IDESYNC ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPECANA.NE.0.AND.ISPECDIP.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS ISPECANA AND ISPECDIP ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS ISPECANA AND ISPECDIP ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPECDIP.NE.0.AND.IDESYNC.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS ISPECDIP AND IDESYNC ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS ISPECDIP AND IDESYNC ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPECANA.NE.0.AND.IRFILSP0.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS ISPECANA AND IRFILSP0 ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS ISPECANA AND IRFILSP0 ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPECDIP.NE.0.AND.IRFILSP0.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS ISPECDIP AND IRFILSP0 ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS ISPECDIP AND IRFILSP0 ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPECANA.NE.0.AND.IRFILSTO.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS ISPECANA AND IRFILSTO ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS ISPECANA AND IRFILSTO ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IUSEM.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'IUSEM IS NOT SUPPORTED ANYMORE!'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'IUSEM IS NOT SUPPORTED ANYMORE!'
          WRITE(6,*)
          stop "*** WAVE aborted ***"
      ENDIF

      IF (IUSEM.NE.0 .AND. IF1DIM.EQ.1) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IF1DIM AND IUSEM ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IF1DIM AND IUSEM ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

C     IF (IPINCIRC.NE.0 .AND. IUSEM.EQ.0) THEN
C         WRITE(LUNGFO,*)
C         WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
C         WRITE(LUNGFO,*)
C     &      'FLAG IPINCIRC IS SET BUT FLAG IUSEM IS NOT'
C         WRITE(LUNGFO,*)
C     &      'SET BOTH FLAGS TO CALCULATE FLUX THROUGH CIRCULAR PINHOLE'
C         WRITE(LUNGFO,*)
C         WRITE(6,*)
C         WRITE(6,*)'*** ERROR IN GFINIT ***'
C         WRITE(6,*)
C     &      'FLAG IPINCIRC IS SET BUT FLAG IUSEM IS NOT'
C         WRITE(6,*)
C     &      'SET BOTH FLAGS TO CALCULATE FLUX THROUGH CIRCULAR PINHOLE'
C         WRITE(6,*)
C         STOP
C     ENDIF

C     IF (ISTOKES.NE.0.AND.IPIN.NE.0  .AND. IUSEM.EQ.0) THEN
C         WRITE(LUNGFO,*)
C         WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
C         WRITE(LUNGFO,*)
C     &      'FLAG ISTOKES AND IPIN ARE SET BUT FLAG IUSEM IS NOT'
C         WRITE(LUNGFO,*)
C     &      'SET ALL THESE FLAGS TO CALCULATE STOKES VECTORS FOR PINHOLE'
C         WRITE(LUNGFO,*)
C         WRITE(6,*)
C         WRITE(6,*)'*** ERROR IN GFINIT ***'
C         WRITE(6,*)
C     &      'FLAG ISTOKES AND IPIN ARE SET BUT FLAG IUSEM IS NOT'
C         WRITE(6,*)
C     &      'SET ALL THESE FLAGS TO CALCULATE STOKES VECTORS FOR PINHOLE'
C         WRITE(6,*)
C         STOP
C     ENDIF

      IF (IEMIAHW.NE.0.AND.DDISP0.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'     FLAG IEMIAHW INCOMPATIBLE WITH DDISP0.NE.0)'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'     *** ERROR IN GFINIT ***'
          WRITE(6,*)'     FLAG IEMIAHW INCOMPATIBLE WITH DDISP0.NE.0)'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IEMIAHW.NE.0.AND.KHALBASY.EQ.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'     FLAG IEMIAHW SET BUT KHALBASY=0'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'     *** ERROR IN GFINIT ***'
          WRITE(6,*)'     FLAG IEMIAHW SET BUT KHALBASY=0'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IFOLD.NE.0.AND.IPIN.LT.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &'     FLAG IFOLD SET. FLAG IPIN MUST BE GREATER OR EQUAL ZERO'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*) '     *** ERROR IN GFINIT ***'
          WRITE(6,*)
     &'     FLAG IFOLD SET. FLAG IPIN MUST BE GREATER OR EQUAL ZERO'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ispec.ne.0.and.IFOLD.NE.0.AND.ISIGUSR.EQ.0.AND.IEMIT.EQ.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &       '     FLAG ISIGUSR NOT SET. THIS REQUIRES FLAG IEMIT TO BE SET'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*) '     *** ERROR IN GFINIT ***'
          WRITE(6,*)
     &       '     FLAG ISIGUSR NOT SET. THIS REQUIRES FLAG IEMIT TO BE SET'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF(NDWSOU.LT.NDARGU) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     *** ERROR IN IN GFINIT ***'
          WRITE(LUNGFO,*)'     PARAMETER NDWSOUP.LT.NDWARGUP'
          WRITE(LUNGFO,*)'     LOOK AT FILE CMPARA.CMN'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'     *** ERROR IN IN GFINIT ***'
          WRITE(6,*)'     PARAMETER NDWSOUP.LT.NDWARGUP'
          WRITE(6,*)'     LOOK AT FILE CMPARA.CMN'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

C- B-FIELD

      IF (IWSECTMAGS.LT.0) THEN
        JWSECTMAGS=1
      ELSE
        JWSECTMAGS=0
      ENDIF

      KSUM=
     &      KBEXTERN**2
     &      +KBAMWLS**2
     &      +KHALBA**2
     &      +KBFELD**2
     &      +ibmasksp**2
     &      +KHALBASY**2
     &      +KUNDUGAP**2
     &      +IRFILF**2
     &      +IRBTAB**2
     &      +IFOURBTABZY**2
     &      +IRBTABZY**2
     &      +IRBTABXYZ**2
     &      +KUCROSS**2
     &      +KELLIP**2
     &      +KELLANA**2
     &      +KBREC**2
     &      +KBGENESIS**2
     &      +IRFILP**2
     &      +KMAGSEQ**2
     &      +IBHELM**2
     &      +KBPOLYH**2
     &      +KBPOLY3D**2
     &      +KBPOLY2DH**2
     &      +KBPHARM**2
     &      +IRFILB0**2
     &      +IRFILB**2
     &      +JWSECTMAGS

      IF (kbundumag.ne.0) KSUM=KSUM+1
      IF (KBPOLYMAG.GT.0) KSUM=KSUM+1

      IF (KSUM.LT.1) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     *** Warning in GFINIT ***'
        WRITE(LUNGFO,*)'     No magnetic field specified'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)
        WRITE(6,*)'     *** Warning in GFINIT ***'
        WRITE(6,*)'     No magnetic field specified'
        WRITE(6,*)
c        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IBSUPER.EQ.0) THEN

      IAMBI=0

      IF (KBEXTERN .NE.0) IAMBI=IAMBI+1
      IF (KBAMWLS .NE.0) IAMBI=IAMBI+1
      IF (KHALBA  .NE.0) IAMBI=IAMBI+1
      IF (KBFELD  .NE.0) IAMBI=IAMBI+1
      IF (KHALBASY.NE.0) IAMBI=IAMBI+1
      IF (KUNDUGAP.NE.0) IAMBI=IAMBI+1
      IF (IRFILF  .NE.0) IAMBI=IAMBI+1
      IF (IRFILB .NE.0) IAMBI=IAMBI+1
      IF (IRBTAB  .NE.0) IAMBI=IAMBI+1
      IF (IFOURBTABZY.NE.0) IAMBI=IAMBI+1
      IF (IRBTABZY.NE.0) IAMBI=IAMBI+1
      IF (IRBTABXYZ.NE.0) IAMBI=IAMBI+1
      IF (KUCROSS .NE.0) IAMBI=IAMBI+1
      IF (KELLIP  .NE.0) IAMBI=IAMBI+1
      IF (KELLANA .NE.0) IAMBI=IAMBI+1
      IF (KBREC   .gt.0) IAMBI=IAMBI+1
      IF (kbundumag.ne.0) IAMBI=IAMBI+1
      IF (KBPOLYMAG.GT.0) IAMBI=IAMBI+1
      IF (KBGENESIS.GT.0) IAMBI=IAMBI+1
      IF (KBPOLYH .NE.0) IAMBI=IAMBI+1
      IF (KBPOLY3D .NE.0)IAMBI=IAMBI+1
      IF (KBPOLY2DH .NE.0)IAMBI=IAMBI+1
      IF (KBPHARM .NE.0)IAMBI=IAMBI+1
      IF (IRFILP  .NE.0) IAMBI=IAMBI+1
      IF (IRFILB0 .NE.0) IAMBI=IAMBI+1
      IF (IBHELM  .NE.0) IAMBI=IAMBI+1
      IF (IMAGSPLN.GT.0) IAMBI=IAMBI+1
      IF (KMAGSEQ.GT.0) IAMBI=IAMBI+1
      IF (IWSECTMAGS.LT.0) IAMBI=IAMBI+1
      IF (IAMBI.GT.1) THEN
      IF (ibmasksp.LT.0) IAMBI=IAMBI+1
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
      WRITE(LUNGFO,*)'     MAGNETIC FIELD AMBIGIOUSLY SPECIFIED'
      WRITE(LUNGFO,*)'     CHECK FIELD SELECTION AND IBMASKSP'
      WRITE(LUNGFO,*)
      WRITE(6,*)
      WRITE(6,*)
      WRITE(6,*)'     *** ERROR IN GFINIT ***'
      WRITE(6,*)'     MAGNETIC FIELD AMBIGIOUSLY SPECIFIED'
      WRITE(6,*)'     CHECK FIELD SELECTION AND IBMASKSP'
      WRITE(6,*)
      STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      ENDIF !IBSUPER

C- ANALYTICALLY DEFINED GENERATING FUNCTION

      IAMBI=0
      IF (IERZFUN.NE.0) IAMBI=IAMBI+1
      IF (IERZANA.NE.0) IAMBI=IAMBI+1
      IF (IAMBI.GT.1) THEN
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
      WRITE(LUNGFO,*)'     FLAGS IERZRANA AND IERZFUN COLLIDE'
      WRITE(LUNGFO,*)'     SET ONLY ONE'
      WRITE(LUNGFO,*)
      WRITE(6,*)
      WRITE(6,*)
      WRITE(6,*)'     *** ERROR IN GFINIT ***'
      WRITE(6,*)'     FLAGS IERZRANA AND IERZFUN COLLIDE'
      WRITE(6,*)'     SET ONLY ONE'
      WRITE(6,*)
      STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

C- FOURIER-TRANSFORMATION

      IAMBI=0
      IF (IRFILF.NE.0) IAMBI=IAMBI+1
      IF (IWFILF.NE.0) IAMBI=IAMBI+1
      IF (IAMBI.GT.1) THEN
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
      WRITE(LUNGFO,*)'     FLAGS IRFILF AND IWFILF COLLIDE'
      WRITE(LUNGFO,*)'     SET ONLY ONE'
      WRITE(LUNGFO,*)
      WRITE(6,*)
      WRITE(6,*)
      WRITE(6,*)'     *** ERROR IN GFINIT ***'
      WRITE(6,*)'     FLAGS IRFILF AND IWFILF COLLIDE'
      WRITE(6,*)'     SET ONLY ONE'
      WRITE(6,*)
      STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

C--- DEFAULT VALUES

C030414      IF (XINTER.EQ.9999..AND.IBSUPER.EQ.0) THEN

C--- CALCULATE FOURIER-COEFFIZIENTS OF B-FIELD FOR SEQUENCE OF MAGNETS

      IF (KMAGSEQ.NE.0.AND.IMGSQF.NE.0) THEN

        xstarto=xstart
        idum=imgsqf
        if (xstart.eq.9999.) then
          imgsqf=0
          CALL bmagseq(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=bmsqbounds(1)
          imgsqf=idum
c          print*
c          print*,"*** Error in GFINIT: Default 9999 not allowed for XSTART for IMGSQF not zero"
c          print*
c          IABEND=8
c          goto 9999
        endif

        if (xstop.eq.9999.) then
          imgsqf=0
          if (xstopo.ne.9999.) then
            CALL bmagseq(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          endif
          XSTOP=bmsqbounds(2)
c          print*
c          print*,"*** Error in GFINIT: Default 9999 not allowed for XSTOP for IMGSQF not zero"
c          print*
c          IABEND=8
c          goto 9999
        endif
        imgsqf=idum

        ISTORE=IWFILF
        IWFILF=99
        BSTORE=B0SCGLOB
        btapv=btaperv
        btaph=btaperh
        btaperv=0.0d0
        btaperh=0.0d0
        ASTORE=A0SCGLOB
        BSTOREY=B0SCGLOBY
        ASTOREY=A0SCGLOBY
        BSTOREZ=B0SCGLOBZ
        ASTOREZ=A0SCGLOBZ
        BSTORE2=BYGOFF
        BSTORE2Z=BZGOFF
        B0SCGLOB=1.0D0
        A0SCGLOB=1.0D0
        B0SCGLOBY=1.0D0
        A0SCGLOBY=1.0D0
        B0SCGLOBZ=1.0D0
        A0SCGLOBZ=1.0D0
        BYGOFF=0.0
        BZGOFF=0.0

        CALL FOURWLS

        IWFILF=ISTORE
        btaperh=btaph
        btaperv=btapv
        A0SCGLOB=ASTORE
        B0SCGLOB=BSTORE
        A0SCGLOBY=ASTOREY
        B0SCGLOBY=BSTOREY
        A0SCGLOBZ=ASTOREZ
        B0SCGLOBZ=BSTOREZ
        BYGOFF=BSTORE2
        BZGOFF=BSTORE2Z

      ENDIF

      IF (KHALBASY.NE.0.and.mod(nint(ahwpol),2).eq.0) THEN
        print*,"*** WARNING: AHWPOL should be odd, or be aware of strange results ***"
        write(lungfo,*)"*** WARNING: AHWPOL should be odd, or be aware of strange results ***"
      endif

      IF (XINTER.EQ.9999.) THEN

        XSTARTO=XSTART

        IF (KHALBA.NE.0) THEN
          CALL BHALBA(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=-ZLENHAL/2.0D0
        ELSE IF (KBFELD.NE.0) THEN
          CALL MYBFELD(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=XLIM(1)
          IF (IKBFORM.NE.0) XINTER=-XP5
        ELSE IF (KHALBASY.NE.0) THEN
          CALL BHALBASY(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          IF (FASYM.NE.2.0D0) THEN
            XINTER=-ZLHALBASY*(AHWPOL+FASYM)/4.0D0+xcenhal
          ELSE
            XINTER=-ZLHALBASY*((AHWPOL-1.0D0)/2.0D0+1.0D0)/2.+xcenhal
          ENDIF
        ELSE IF (KUNDUGAP.NE.0) THEN
          CALL BUNDUGAP(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM,-1)
          XINTER=-ZLUNDUGAP*((UNDUGAPPOL-1.0D0)/2.0D0+1.0D0)/2.+xcenUNDUGAP
        ELSE IF (IRFILF.eq.1) THEN
          CALL BFOUR(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=-DEVLEN2
        ELSE IF (IFOURBTABZY.NE.0) THEN
          CALL BFOURTABZY(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=XSTART
        ELSE IF (IRBTAB.NE.0) THEN
          CALL BTAB(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=XSTART
        ELSE IF (IRBTABZY.NE.0) THEN
          CALL BTABZY(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=XSTART
        ELSE IF (IRBTABXYZ.NE.0) THEN
          CALL BTABXYZ(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=XSTART
        ELSE IF (KUCROSS.NE.0) THEN
          CALL BUCROSS(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=ULIMI(1)
        ELSE IF (KELLIP.NE.0) THEN
          CALL BELLIP(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          Xinter=-(perellip*xlellip+ellshft*xlellip)/2.0d0+xcenell
        ELSE IF (KELLANA.NE.0) THEN
          CALL BELLANA(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=-HLENELL
        ELSE IF (KBPOLYH.NE.0) THEN
          CALL BPHARM(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
        ELSE IF (KBPOLY3D.NE.0) THEN
          CALL BPOLY3D(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=X3DMIN
        ELSE IF (KBPOLY2DH.NE.0) THEN
          CALL BPOLY2DH(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=X2DHMIN
        ELSE IF (KBPOLY2DH.NE.0) THEN
          CALL BPHARM(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=XPHMIN
        ELSE IF (KBREC.gt.0) THEN
          CALL REC_INIT
        ELSE IF (kbundumag.ne.0) THEN
          muthreads=mthreads
          if (kbundumag.eq.2.or.kbundumag.eq.4) then
            uebeam=dmyenergy
            kwrun=icode
            chwcom=code
            call run_undumag(kbundumag,lungfo)
          else  if (kbundumag.lt.0) then
            call run_undumag(kbundumag,lungfo)
          endif
          CALL bundumag_ini(XSTART,XSTOP,LUNGFO)
        ELSE IF (KBPOLYMAG.GT.0) THEN
          CALL BPOLYINI(XSTART,XSTOP,LUNGFO)
        ELSE IF (KBGENESIS.NE.0) THEN
          CALL BGENESIS(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=GSTOTLEN/2.0D0
        ELSE IF (IRFILB0.EQ.-4) THEN
          CALL BMESSINI4
        ELSE IF (IRFILB0.NE.0.and.abs(irfilb0).ne.6) THEN
          CALL BMESSINI
        ELSE IF (IWSECTMAGS.LT.0) THEN
          CALL BSECTMAGS(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=XSTART
        ENDIF !xinter

        IF (XINTER.EQ.9999.) THEN

          WRITE (LUNGFO,*)
          WRITE (LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE (LUNGFO,*)'DEFAULT 9999. NOT ALLOWED HERE FOR XINTER '
          WRITE (LUNGFO,*)
          WRITE (6,*)
          WRITE (6,*)'*** ERROR IN GFINIT ***'
          WRITE (6,*)'DEFAULT 9999. NOT ALLOWED HERE FOR XINTER '
          WRITE (6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'

        ENDIF !xinter

        XSTART=XSTARTO

      ENDIF !XINTER.EQ.9999.

      XSTOPO=XSTOP

C030414      IF (XSTART.EQ.9999..AND.IBSUPER.EQ.0) THEN
      IF (XSTART.EQ.9999.) THEN

        XSTARTO=XSTART

        IF (KHALBA.NE.0) THEN
          CALL BHALBA(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=-ZLENHAL/2.0D0
        ELSE IF (kmagseq.NE.0) THEN
          CALL bmagseq(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=bmsqbounds(1)
        ELSE IF (KBFELD.NE.0) THEN
          CALL MYBFELD(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=XLIM(1)
          IF (IKBFORM.NE.0) XSTART=-XP5
        ELSE IF (KHALBASY.NE.0) THEN
          CALL BHALBASY(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          IF (FASYM.NE.2.0D0) THEN
            XSTART=-ZLHALBASY*(AHWPOL+FASYM)/4.0D0+xcenhal
          ELSE
            XSTART=-ZLHALBASY*((AHWPOL-1.0D0)/2.0D0+1.0D0)/2.+xcenhal
          ENDIF
        ELSE IF (KUNDUGAP.NE.0) THEN
          CALL BUNDUGAP(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM,-2)
          XSTART=-ZLUNDUGAP*((UNDUGAPPOL-1.0D0)/2.0D0+1.0D0)/2.+xcenUNDUGAP
        ELSE IF (IRFILF.eq.1) THEN
          CALL BFOUR(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=-DEVLEN2
        ELSE IF (IFOURBTABZY.NE.0) THEN
          CALL BFOURTABZY(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=XSTART
        ELSE IF (IRBTAB.NE.0) THEN
          CALL BTAB(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
        ELSE IF (IRBTABZY.NE.0) THEN
          CALL BTABZY(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=XSTART
        ELSE IF (IRBTABXYZ.NE.0) THEN
          CALL BTABXYZ(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=XSTART
        ELSE IF (KUCROSS.NE.0) THEN
          CALL BUCROSS(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=ULIMI(1)
        ELSE IF (KELLIP.NE.0) THEN
          CALL BELLIP(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=-(perellip*xlellip+ellshft*xlellip)/2.0d0+xcenell
        ELSE IF (KELLANA.NE.0) THEN
          CALL BELLANA(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=-HLENELL
        ELSE IF (KBPOLYH.NE.0) THEN
          CALL BPHARM(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
        ELSE IF (KBPOLY3D.NE.0) THEN
          CALL BPOLY3D(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=X3DMIN
        ELSE IF (KBPOLY2DH.NE.0) THEN
          CALL BPOLY2DH(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=X2DHMIN
        ELSE IF (KBPOLY2DH.NE.0) THEN
          CALL BPHARM(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=XPHMIN
        ELSE IF (KBREC.gt.0) THEN
          CALL REC_INIT
        ELSE IF (kbundumag.ne.0) THEN
          muthreads=mthreads
          if (kbundumag.eq.2.or.kbundumag.eq.4) then
            uebeam=dmyenergy
            uebeam_h=dmyenergy
            kwrun=icode
            chwcom=code
            call run_undumag(kbundumag,lungfo)
          else  if (kbundumag.lt.0) then
            call run_undumag(kbundumag,lungfo)
          endif
          CALL bundumag_ini(XSTART,XSTOP,LUNGFO)
        ELSE IF (KBPOLYMAG.GT.0) THEN
          CALL BPOLYINI(XSTART,XSTOP,LUNGFO)
        ELSE IF (KBGENESIS.NE.0) THEN
          XSTART=0.0D0
        ELSE IF (IRFILB0.EQ.-4) THEN
          CALL BMESSINI4
        ELSE IF (abs(IRFILB0).EQ.6) THEN
          bxdum=-9999.0d0
          CALL BMAP(axdum,aydum,azdum,bxdum,bydum,bzdum)
          xstart=axdum
        ELSE IF (IRFILB0.NE.0) THEN
          CALL BMESSINI
        ELSE IF (IWSECTMAGS.LT.0) THEN
          CALL BSECTMAGS(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
        ENDIF

        IF (XSTART.EQ.9999.) THEN

          WRITE (LUNGFO,*)
          WRITE (LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE (LUNGFO,*)'DEFAULT NOT ALLOWED HERE FOR XSTART '
          WRITE (LUNGFO,*)
          WRITE (6,*)
          WRITE (6,*)'*** ERROR IN GFINIT ***'
          WRITE (6,*)'DEFAULT NOT ALLOWED HERE FOR XSTART '
          WRITE (6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'

        ENDIF

      ENDIF !XSTART.EQ.9999.

C030414      IF (XSTOP.EQ.9999..AND.IBSUPER.EQ.0) THEN
      IF (XSTOP.EQ.9999.) THEN

        IF (KHALBA.NE.0) THEN
          CALL BHALBA(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=ZLENHAL/2.0D0
        ELSE IF (kmagseq.NE.0) THEN
          CALL bmagseq(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=bmsqbounds(2)
        ELSE IF (KBFELD.NE.0) THEN
          XSTOP=XLIM(12)
          IF (IKBFORM.NE.0) XSTOP=-XSTART
        ELSE IF (KHALBASY.NE.0) THEN
          CALL BHALBASY(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          IF (FASYM.NE.2.0D0) THEN
            XSTOP=ZLHALBASY*(AHWPOL+FASYM)/4.0D0+xcenhal
          ELSE
            XSTOP=ZLHALBASY*((AHWPOL-1.0D0)/2.0D0+1.0D0)/2.+xcenhal
          ENDIF
        ELSE IF (KUNDUGAP.NE.0) THEN
          CALL BUNDUGAP(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM,-3)
          XSTOP=ZLUNDUGAP*((UNDUGAPPOL-1.0D0)/2.0D0+1.0D0)/2.+xcenUNDUGAP
        ELSE IF (IRFILF.eq.1) THEN
          CALL BFOUR(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=DEVLEN2
        ELSE IF (IFOURBTABZY.NE.0) THEN
          CALL BFOURTABZY(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=XSTOP
        ELSE IF (IRBTAB.NE.0) THEN
          CALL BTAB(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
        ELSE IF (IRBTABZY.NE.0) THEN
          CALL BTABZY(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=XSTOP
        ELSE IF (IRBTABXYZ.NE.0) THEN
          CALL BTABXYZ(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=XSTOP
        ELSE IF (KUCROSS.NE.0) THEN
          CALL BUCROSS(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=ULIMI(4)
        ELSE IF (KELLIP.NE.0) THEN
          CALL BELLIP(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XStop=(perellip*xlellip+ellshft*xlellip)/2.0d0+xcenell
        ELSE IF (KELLANA.NE.0) THEN
          CALL BELLANA(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=HLENELL
        ELSE IF (KBPOLYH.NE.0) THEN
          CALL BPHARM(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
        ELSE IF (KBPOLY3D.NE.0) THEN
          CALL BPOLY3D(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=X3DMAX
        ELSE IF (KBPOLY2DH.NE.0) THEN
          CALL BPOLY2DH(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=X2DHMAX
        ELSE IF (KBPHARM.NE.0) THEN
          CALL BPHARM(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=XPHMAX
        ELSE IF (KBREC.gt.0) THEN
          CALL REC_INIT
        ELSE IF (kbundumag.ne.0) THEN
          muthreads=mthreads
          if (kbundumag.eq.2.or.kbundumag.eq.4) then
            uebeam=dmyenergy
            uebeam_h=dmyenergy
            kwrun=icode
            chwcom=code
            call run_undumag(kbundumag,lungfo)
          else  if (kbundumag.lt.0) then
            call run_undumag(kbundumag,lungfo)
          endif
          CALL bundumag_ini(XSTART,XSTOP,LUNGFO)
        ELSE IF (KBPOLYMAG.GT.0) THEN
          CALL BPOLYINI(XSTART,XSTOP,LUNGFO)
        ELSE IF (abs(IRFILB0).EQ.6) THEN
          bxdum=9999.0d0
          CALL BMAP(axdum,aydum,azdum,bxdum,bydum,bzdum)
          xstop=axdum
        ELSE IF (IRFILB0.EQ.-4) THEN
          CALL BMESSINI4
        ELSE IF (IRFILB0.NE.0.and.abs(irfilb0).ne.6) THEN
          CALL BMESSINI
        ELSE IF (KBGENESIS.NE.0) THEN
          CALL BGENESIS(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=GSTOTLEN
        ELSE IF (IWSECTMAGS.LT.0) THEN
          CALL BSECTMAGS(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
        ENDIF

        if (xstop.eq.9999.) then
          WRITE (LUNGFO,*)
          WRITE (LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE (LUNGFO,*)'DEFAULT NOT ALLOWED HERE FOR XSTOP '
          WRITE (LUNGFO,*)
          WRITE (6,*)
          WRITE (6,*)'*** ERROR IN GFINIT ***'
          WRITE (6,*)'DEFAULT NOT ALLOWED HERE FOR XSTOP '
          WRITE (6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF

      ENDIF !XSTOP.EQ.9999.

      if (ibunduini.eq.0.and.kbundumag.ne.0) then
          muthreads=mthreads
          if (kbundumag.eq.2.or.kbundumag.eq.4) then
            uebeam=dmyenergy
            uebeam_h=dmyenergy
            kwrun=icode
            chwcom=code
            call run_undumag(kbundumag,lungfo)
          else  if (kbundumag.lt.0) then
            call run_undumag(kbundumag,lungfo)
          endif
          CALL bundumag_ini(XSTART,XSTOP,LUNGFO)
      endif

      IF (IPERIODG.NE.0.AND.XSTOPO.EQ.9999.) THEN
        XSTOP=XSTOP+(XPERWMX-XPERWMN)
      ENDIF

      IF (IBSYM.NE.0.AND.XSTARTO.EQ.9999.) XSTART=-XSTOP

      IF (XSTARTO.EQ.9999.) XSTART=XSTART-XSHIFT
      IF (XSTOPO.EQ.9999.) XSTOP=XSTOP-XSHIFT

      IF (XSTART.EQ.XSTOP) THEN
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT: XSTART=XSTOP ***'
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
        WRITE(6,*)'*** ERROR IN GFINIT: XSTART=XSTOP ***'
        WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
        STOP
      ENDIF

      if (xtaper.eq.9999.0d0) xtaper=xstart

      IF (NSTEPMX.EQ.0) THEN
        NSTEPMX=NWMAXP
      ELSE IF (NSTEPMX.LT.0) THEN
        NSTEPMX=(XSTOP-XSTART)*MYINUM*2.*(-NSTEPMX)
      ENDIF
      IF (NSTEPMX.LE.0) THEN
        NSTEPMX=NWMAXP
      ENDIF
      NWMAX=NSTEPMX

      IF (NPOLMX.EQ.0) NPOLMX=NDPOLP
      NDPOL=NPOLMX

      CALL MYBFELD(XSTART,YSTART,ZSTART,
     &  BXSTART,BYSTART,BZSTART,
     &  AXSTART,AYSTART,AZSTART)


      IF (VXIN.EQ.0.0D0.AND.VYIN.EQ.0.0D0.AND.VZIN.EQ.0.0D0) VXIN=1.0D0

      IF (XINTER.NE.XSTART.AND.XINTER.NE.-9999.) THEN

        YSTARTO=YSTART
        ZSTARTO=ZSTART

        VXINO=VXIN
        VYINO=VYIN
        VZINO=VZIN

        VN=1.0D0/DSQRT(VXIN**2+VYIN**2+VZIN**2)
        VXIN=VXIN*VN
        VYIN=VYIN*VN
        VZIN=VZIN*VN

        BETX0=VXIN*BETA
        BETY0=VYIN*BETA
        BETZ0=VZIN*BETA

        X0=XSTART
        Y0=YSTART
        Z0=ZSTART

        VX0=VXIN*V0
        VY0=VYIN*V0
        VZ0=VZIN*V0

        IF (XINTER.GT.XSTART) THEN

          BYDUM=B0SCGLOB
          B0SCGLOB=-B0SCGLOB
          btaperv=-btaperv
          btaperh=-btaperh

          CALL TRACKSHORT(ISNORDER,XINTER,Y0,Z0,-VX0,-VY0,-VZ0,
     &      XSTART,0.0D0,0.0D0,-1.0D0,0.0D0,0.0D0,
     &      XF0,YF0,ZF0,dtshort,VXF0,VYF0,VZF0,DTIM,BSHIFT,GAMMA,BMOVECUT,
     &      IUSTEP,IENELOSS,GAMMAL)

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Result of back-tracking due to XINTER:'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     x:',XF0
          WRITE(LUNGFO,*)'     y:',YF0
          WRITE(LUNGFO,*)'     z:',ZF0
          WRITE(LUNGFO,*)'     vx:',-VXF0
          WRITE(LUNGFO,*)'     vy:',-VYF0
          WRITE(LUNGFO,*)'     vz:',-VZF0
          WRITE(LUNGFO,*)'     yp:',VYF0/VXF0
          WRITE(LUNGFO,*)'     zp:',VZF0/VXF0
          WRITE(LUNGFO,*)

          B0SCGLOB=BYDUM
          btaperv=-btaperv
          btaperh=-btaperh
          XSTART=XF0
          YSTART=YF0
          ZSTART=ZF0
          VXIN=-VXF0
          VYIN=-VYF0
          VZIN=-VZF0

          GAMMA=GAMMA-GAMMAL !We gain energy here, and gammal is negative!
          DMYGAMMA=GAMMA
          DMYENERGY=GAMMA*EMASSG1

          ENERGV=GAMMA*EMASSE1
          GMOM=EMASSG1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
          EMOM=EMASSE1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
          DBRHO=ICHARGE*EMOM/CLIGHT1
          BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
          DMYBETA=BETA
          V0=CLIGHT1*BETA

        ELSE   !XINTER.GT.XSTART

          CALL TRACKSHORT(ISNORDER,XINTER,Y0,Z0,VX0,VY0,VZ0,
     &      XSTART,0.0D0,0.0D0,1.0D0,0.0D0,0.0D0,
     &      XF0,YF0,ZF0,dtshort,VXF0,VYF0,VZF0,DTIM,BSHIFT,GAMMA,BMOVECUT,
     &      IUSTEP,IENELOSS,GAMMAL)

          XSTART=XF0
          YSTART=YF0
          ZSTART=ZF0
          VXIN=VXF0
          VYIN=VYF0
          VZIN=VZF0

          GAMMA=GAMMA+GAMMAL !We lose energy here!
          DMYGAMMA=GAMMA
          DMYENERGY=GAMMA*EMASSG1

          ENERGV=GAMMA*EMASSE1
          GMOM=EMASSG1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
          EMOM=EMASSE1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
          DBRHO=ICHARGE*EMOM/CLIGHT1
          BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
          DMYBETA=BETA
          V0=CLIGHT1*BETA

        ENDIF  !XINTER.GT.XSTART

      ENDIF !(XINTER.NE.-9999.)

c20aug09      ROIX(1)=XSTART
c20aug09      ROIX(NROIA)=XSTOP

      IF (XSTART.LT.ROIX(1)) THEN
        WRITE(LUNGFO,*)
     &    '*** ERROR IN NAMELIST ROIN: XSTART < ROIX(1)'
        WRITE(6,*)
     &    '*** ERROR IN NAMELIST ROIN: XSTART < ROIX(1)'
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF !(XSTART.LT.ROIX(1))

      IF (XSTOP.GT.ROIX(NROIA)) THEN
        WRITE(LUNGFO,*)
     &    '*** ERROR IN NAMELIST ROIN: XSTOP GREATER THAN LAST ROI-BOUNDARY'
        WRITE(6,*)
     &    '*** ERROR IN NAMELIST ROIN: XSTOP GREATER THAN LAST ROI-BOUNDARY'
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF !(XSTART.GT.ROIX(1))

      IF (XIANF.EQ.9999.) XIANF=-1.0D30
      IF (XIEND.EQ.9999.) XIEND=1.0D30

      if (iexpert.ne.0) then
        xianf=-1.0d30
        xiend=1.0d30
      endif

      IF (XIANF.EQ.XIEND) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN GFINIT: XIANF=XIEND ***'
        WRITE(LUNGFO,*)'*** SET TO XSTART/XSTOP ***'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN GFINIT: XIANF=XIEND ***'
        WRITE(6,*)'*** SET TO XSTART/XSTOP ***'
        WRITE(6,*)
        XIANF=XSTART
        XIEND=XSTOP
      ENDIF

C--- B-FIELD FROM PANDIRA

      IF (IRFILP.NE.0) CALL READBP

C--- CALCULATE FOURIER-COEFFICIENTS OF B-FIELD AND EXIT

      IF (IWFILF.NE.0) THEN
        CALL FOURWLS
        IABEND=1
        goto 9999
      ENDIF

C--- FIND DEFAULTS FOR VXIN,VYIN,VZIN IF NECESSARY

      IF (VYIN.EQ.9999..AND.VZIN.EQ.9999.) THEN

        VXIN=1.0D0
        VYIN=0.0D0
        VZIN=0.0D0

        BETX0=VXIN*BETA
        BETY0=VYIN*BETA
        BETZ0=VZIN*BETA

        X0=XSTART
        Y0=YSTART
        Z0=ZSTART

        VX0=VXIN*V0
        VY0=VYIN*V0
        VZ0=VZIN*V0

        CALL TRACKSHORT(ISNORDER,X0,Y0,Z0,VX0,VY0,VZ0,
     &    XSTART+PERIODG,0.0D0,0.0D0,1.0D0,0.0D0,0.0D0,
     &    XF0,YF0,ZF0,dtshort,VXF0,VYF0,VZF0,DTIM,BSHIFT,GAMMA,BMOVECUT,
     &    IUSTEP,IENELOSS,GAMMAL)

        GAMMA=GAMMA-GAMMAL !We lose energy here!
        DMYGAMMA=GAMMA
        DMYENERGY=GAMMA*EMASSG1

        ENERGV=GAMMA*EMASSE1
        GMOM=EMASSG1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
        EMOM=EMASSE1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
        DBRHO=ICHARGE*EMOM/CLIGHT1
        BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
        DMYBETA=BETA
        V0=CLIGHT1*BETA

        YP=-YF0/PERIODG
        ZP=-ZF0/PERIODG

        VXIN=V0/DSQRT(1.0D0+ZP*ZP+YP*YP)
        VYIN=YP*VXIN
        VZIN=ZP*VXIN

      ELSE IF (VYIN.EQ.9999.) THEN

        VYIN=0.0D0
        VN=1.0D0/DSQRT(VXIN**2+VYIN**2+VZIN**2)
        VXIN=VXIN*VN
        VYIN=VYIN*VN
        VZIN=VZIN*VN

        BETX0=VXIN*BETA
        BETY0=VYIN*BETA
        BETZ0=VZIN*BETA

        X0=XSTART
        Y0=YSTART
        Z0=ZSTART

        VX0=VXIN*V0
        VY0=VYIN*V0
        VZ0=VZIN*V0

        CALL TRACKSHORT(ISNORDER,X0,Y0,Z0,VX0,VY0,VZ0,
     &    XSTART+PERIODG,0.0D0,0.0D0,1.0D0,0.0D0,0.0D0,
     &    XF0,YF0,ZF0,dtshort,VXF0,VYF0,VZF0,DTIM,BSHIFT,GAMMA,BMOVECUT,
     &    IUSTEP,IENELOSS,GAMMAL)

        GAMMA=GAMMA+GAMMAL !We loose energy here!
        DMYGAMMA=GAMMA
        DMYENERGY=GAMMA*EMASSG1

        ENERGV=GAMMA*EMASSE1
        GMOM=EMASSG1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
        EMOM=EMASSE1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
        DBRHO=ICHARGE*EMOM/CLIGHT1
        BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
        DMYBETA=BETA
        V0=CLIGHT1*BETA

        YP=-YF0/PERIODG
        ZP=VZIN/VXIN

        VXIN=V0/DSQRT(1.0D0+ZP*ZP+YP*YP)
        VYIN=YP*VXIN
        VZIN=ZP*VXIN

      ELSE IF (VZIN.EQ.9999.) THEN

        VZIN=0.0D0
        VN=1.0D0/DSQRT(VXIN**2+VYIN**2+VZIN**2)
        VXIN=VXIN*VN
        VYIN=VYIN*VN
        VZIN=VZIN*VN

        BETX0=VXIN*BETA
        BETY0=VYIN*BETA
        BETZ0=VZIN*BETA

        X0=XSTART
        Y0=YSTART
        Z0=ZSTART

        VX0=VXIN*V0
        VY0=VYIN*V0
        VZ0=VZIN*V0

        CALL TRACKSHORT(ISNORDER,X0,Y0,Z0,VX0,VY0,VZ0,
     &    XSTART+PERIODG,0.0D0,0.0D0,1.0D0,0.0D0,0.0D0,
     &    XF0,YF0,ZF0,dtshort,VXF0,VYF0,VZF0,DTIM,BSHIFT,GAMMA,BMOVECUT,
     &    IUSTEP,IENELOSS,GAMMAL)

        GAMMA=GAMMA+GAMMAL !We lose energy here!
        DMYGAMMA=GAMMA
        DMYENERGY=GAMMA*EMASSG1

        ENERGV=GAMMA*EMASSE1
        GMOM=EMASSG1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
        EMOM=EMASSE1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
        DBRHO=ICHARGE*EMOM/CLIGHT1
        BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
        DMYBETA=BETA
        V0=CLIGHT1*BETA

        ZP=-ZF0/PERIODG
        YP=VYIN/VXIN

        VXIN=V0/DSQRT(1.0D0+ZP*ZP+YP*YP)
        VYIN=YP*VXIN
        VZIN=ZP*VXIN

      ENDIF !VYIN.EQ.9999..AND.VZIN.EQ.9999.

      xstartP=XSTART
      ystartP=YSTART
      zstartP=ZSTART

      vxinP=VXIN
      vyinP=VYIN
      vzinP=VZIN

C--- TRACK REFERENCE ORBIT FROM XSTART TO XSTOP

C-   NORMALIZE VELOCITY

      VN=1.0D0/DSQRT(VXIN**2+VYIN**2+VZIN**2)
      VXIN=VXIN*VN
      VYIN=VYIN*VN
      VZIN=VZIN*VN

      BETX0=VXIN*BETA
      BETY0=VYIN*BETA
      BETZ0=VZIN*BETA

      X0=XSTART
      Y0=YSTART
      Z0=ZSTART

      VX0=VXIN*V0
      VY0=VYIN*V0
      VZ0=VZIN*V0

      if (xstart.ge.xstop) then
        write(lungfo,*)"*** Error in subroutine gfinit: XSTART >= XSTOP ***"
        write(6,*)"*** Error in subroutine gfinit: XSTART >= XSTOP ***"
        stop "*** Program WAVE aborted ***"
      endif

      CALL TRACK(X0,Y0,Z0,VX0,VY0,VZ0,
     &  XSTOP,0.0D0,0.0D0,1.0D0,0.0D0,0.0D0,
     &  XF0,YF0,ZF0,VXF0,VYF0,VZF0,DTIM,BSHIFT,GAMMA,GAMMAL)
      t0track=wtim0(1)
      tftrack=wtim0(nco)

      CALL TRACEN(0.0D0,YCEN,ZCEN,YPCEN,ZPCEN)
      CALL TRACEN(XIANF,YIANF,ZIANF,YPIANF,ZPIANF)
      CALL TRACEN(XIEND,YIEND,ZIEND,YPIEND,ZPIEND)

      !if (eps0h.eq.0.0d0) eps0h=bsigz(1)*bsigzp(1)
      !if (eps0v.eq.0.0d0) eps0v=bsigy(1)*bsigyp(1)

      IF (betfun.EQ.0.0d0) THEN
        if (eps0h.eq.0.0d0) then
          write(lungfo,*)
     &      '*** Error in GFINIT: EPS0H and BETFUN are zero'
          write(lungfo,*)
     &      '*** Error in GFINIT: Please check namelists DEPOLA and WFOLDN'
          write(6,*)
     &      '*** Error in GFINIT: EPS0H and BETFUN are zero'
          write(6,*)
     &      '*** Error in GFINIT: Please check namelists DEPOLA and WFOLDN'
          stop '*** Program WAVE aborted ***'
        endif
        betfun=bsigz(1)**2/eps0h
      endif

      IF (betfunv.EQ.0.0d0) THEN
        if (eps0v.eq.0.0d0) then
          write(lungfo,*)
     &      '*** Error in GFINIT: EPS0V and BETFUN are zero'
          write(lungfo,*)
     &      '*** Error in GFINIT: Please check namelists DEPOLA and WFOLDN'
          write(6,*)
     &      '*** Error in GFINIT: EPS0V and BETFUN are zero'
          write(6,*)
     &      '*** Error in GFINIT: Please check namelists DEPOLA and WFOLDN'
          stop '*** Program WAVE aborted ***'
        endif
        betfunv=bsigy(1)**2/eps0v
      endif

      IF (iemit.ne.0.or.ibunch.eq.-1.and.iubunch.eq.1.and.betfun*eps0h.EQ.0.0d0) THEN

        if (betfun*eps0h.eq.0.0d0) then
          write(lungfo,*)
     &      '*** Warning in GFINIT: EPS0H or BETFUN are zero'
          write(lungfo,*)
     &      '*** Warning in GFINIT: Please check namelists DEPOLA and WFOLDN'
          write(6,*)
     &      '*** Warning in GFINIT: EPS0H or BETFUN are zero'
          write(6,*)
     &      '*** Warning in GFINIT: Please check namelists DEPOLA and WFOLDN'
        endif

        if ((bsigz(1)*bsigzp(1)).eq.0.0d0) then
          write(lungfo,*)
     &      '*** Warning in GFINIT: BSIGZ(1) and BSIGZP(1) are zero'
          write(lungfo,*)
     &      '*** Warning in GFINIT: Please check namelists DEPOLA and WFOLDN'
          write(6,*)
     &      '*** Warning in GFINIT: BSIGZ(1) and BSIGZP(1) are zero'
          write(6,*)
     &      '*** Warning in GFINIT: Please check namelists DEPOLA and WFOLDN'
        endif

      endif

      IF (iemit.ne.0.or.ibunch.eq.-1.and.iubunch.eq.1.and.betfun*eps0v.EQ.0.0d0) THEN

        if (betfun*eps0v.eq.0.0d0) then
          write(lungfo,*)
     &      '*** Warning in GFINIT: EPS0V or BETFUN are zero'
          write(lungfo,*)
     &      '*** Warning in GFINIT: Please check namelists DEPOLA and WFOLDN'
          write(6,*)
     &      '*** Warning in GFINIT: EPS0V or BETFUN are zero'
          write(6,*)
     &      '*** Warning in GFINIT: Please check namelists DEPOLA and WFOLDN'
        endif

        if ((bsigy(1)*bsigyp(1)).eq.0.0d0) then
          write(lungfo,*)
     &      '*** Warning in GFINIT: BSIGY(1) and BSIGYP(1) are zero'
          write(lungfo,*)
     &      '*** Warning in GFINIT: Please check namelists DEPOLA and WFOLDN'
          write(6,*)
     &      '*** Warning in GFINIT: BSIGY(1) and BSIGYP(1) are zero'
          write(6,*)
     &      '*** Warning in GFINIT: Please check namelists DEPOLA and WFOLDN'
        endif

      endif

      IF (betfun.ne.-9999.0d0) THEN
        IF (ABS(BETAH).EQ.9999.) THEN
          BY    =WTRA(2,3,1)
          RI    =CLIGHT1*BY/EMOM
          TANPHI=WTRA(3,2,1)/WTRA(1,2,1)
          BANA  =BETFUN+X0**2./BETFUN
          BPANA =2.*X0/BETFUN
          BANAC =BANA/(1.+TANPHI**2)
          BPANAC=BPANA/(1+TANPHI**2)+2.*BANA*TANPHI/(1.+TANPHI**2)
     &      *RI/(1+TANPHI**2)
          IF (BETAH.EQ.-9999.) THEN
            BETAH=BANAC
          ELSE IF (BETAH.EQ.9999.) THEN
            BETAH=BANA
          ENDIF
        ENDIF

        IF (ABS(BETAPH).EQ.9999.) THEN
          BY    =WTRA(2,3,1)
          RI    =CLIGHT1*BY/EMOM
          TANPHI=WTRA(3,2,1)/WTRA(1,2,1)
          BANA  =BETFUN+X0**2./BETFUN
          BPANA =2.*X0/BETFUN
          BANAC =BANA/(1.+TANPHI**2)
          BPANAC=BPANA/(1+TANPHI**2)+2.*BANA*TANPHI/(1.+TANPHI**2)
     &      *RI/(1+TANPHI**2)
          IF (BETAPH.EQ.-9999.) THEN
            BETAPH=BPANAC
          ELSE IF (BETAPH.EQ.9999.) THEN
            BETAPH=BPANA
          ENDIF
        ENDIF
      endif ! betfun.ne.-9999.

      IF (betfunv.ne.-9999.0d0) THEN
        IF (ABS(BETAV).EQ.9999.) THEN
          IF (BETFUNV.EQ.0.0) BETFUNV=1.0D0
          BETAV =BETFUNV+X0**2./BETFUNV
        ENDIF

        IF (ABS(BETAPV).EQ.9999.) THEN
          IF (BETFUNV.EQ.0.0) BETFUNV=1.0D0
          BETAPV =2.*X0/BETFUNV
        ENDIF
      endif

      if (ibunch.ne.0.or.iemit.ne.0) then
        write(lungfo,*)' '
        WRITE(LUNGFO,*)'     Horizontal emittance EPS0H [m-rad]:',EPS0H
        WRITE(LUNGFO,*)'     Vertical emittance EPS0V [m-rad]:  ',EPS0V
        write(lungfo,*)'     Horizontal beta-function BETAH [m]:',betah
        write(lungfo,*)'     Horizontal derivative BETAPH:      ',betaph
        write(lungfo,*)'     Vertical beta-function BETAV [m]:  ',betav
        write(lungfo,*)'     Vertical derivative BETAPV:        ',betapv
        write(lungfo,*)' '
        write(lungfo,*)'     --> Note: These values may differ from that of spectrum calculations!!'
        write(lungfo,*)' '
        if (iubunch.eq.1) then
          if (betah.lt.0.1.or.betah.gt.100.) then
            print*,"*** Warning in GFINIT: Strange value of BETAH:",betah
            print*,"*** This can cause program crashes for IUBUNCH=1!"
          endif
          if (betav.lt.0.1.or.betav.gt.100.) then
            print*,"*** Warning in GFINIT: Strange value of BETAH:",betah
            print*,"*** This can cause program crashes for IUBUNCH=1!"
          endif
          write(lungfo,*)' '
        endif
      endif

      IF (IWSECTMAGS.GT.0) THEN
        CALL SECTMAGS
      ENDIF !IWSECTMAGS

      IF (IMAGSPLN.LT.0
     &    .OR.
     &    ispec.ne.0.and.(ISPECMODE.EQ.3.or.ispecmode.eq.2)) THEN
C DO NOT USE WTRA(1:3,3,I) OR WBXYZ(1:3,I) DUE TO BSHIFT

        ALLOCATE(XAMAG(NCO))
        ALLOCATE(BXAMAG(NCO))
        ALLOCATE(BYAMAG(NCO))
        ALLOCATE(BZAMAG(NCO))
        ALLOCATE(BX2A(NCO))
        ALLOCATE(BY2A(NCO))
        ALLOCATE(BZ2A(NCO))
        IXAMAG_I=1

        DO I=1,NCO
          XAMAG(I)=WTRA(1,1,I)
          CALL MYBFELD
     &      (WTRA(1,1,I),WTRA(2,1,I),WTRA(3,1,I),
     &      BXAMAG(I),BYAMAG(I),BZAMAG(I),AXDUM,AYDUM,AZDUM)
        ENDDO  !NCO

        IF (IMAGSPLN.LT.0.AND.IMAGSPLN.NE.-9999) THEN
          CALL BMAGSPLN
     &      (WTRA(1,1,1),WTRA(2,1,1),WTRA(3,1,1),AXDUM,AYDUM,AZDUM)
        ENDIF

      ENDIF !IMAGSPLN

      CALL MYBFELD(XF0,YF0,ZF0,
     &  BXSTOP,BYSTOP,BZSTOP,
     &  AXSTOP,AYSTOP,AZSTOP)


      IF (IMAGSPLN.EQ.-9999) THEN
        IMAGSPLN=-999
      ELSE IF (IMAGSPLN.LT.0) THEN
        IMAGSPLN=-1111
      ENDIF

      ZP0=VZ0/VX0
      YP0=VY0/VX0

      ZPF0=VZF0/VXF0
      YPF0=VYF0/VXF0

      BETXF0=VXF0/CLIGHT1
      BETYF0=VYF0/CLIGHT1
      BETZF0=VZF0/CLIGHT1

C--- POLARIZATION

      ENEGEV=ENERGV/1.0D9
      BDIPOL=ENEGEV/RDIPOL*1.0D9/CLIGHT1
      BDIPL1G=1./RDIPOL*1.0D9/CLIGHT1
      TAUPOL0=POL2CON1*UMFANG*RDIPOL**2/ENEGEV**5
      TAUPOL01G=POL2CON1*UMFANG*RDIPOL**2/1.**5
      POLFAC=1.0D0+BINT3YA/2.0D0/PI1/BDIPOL**3/RDIPOL
      POLFC1G=1.0D0+BINT3YA/2.0D0/PI1/BDIPL1G**3/RDIPOL
      TAUPOL=TAUPOL0/POLFAC
      POLLEV=(2.*PI1*RDIPOL*BDIPOL**3+BINT3Y)/
     &  (2.*PI1*RDIPOL*BDIPOL**3+BINT3YA)*POL1CON1
      TAUPL1G=TAUPOL01G/POLFC1G
      POLLV1G=(2.*PI1*RDIPOL*BDIPL1G**3+BINT3Y)/
     &  (2.*PI1*RDIPOL*BDIPL1G**3+BINT3YA)*POL1CON1

      CALL EMINP(RDIPOL,BINT3YA,TAUPOL01G,TAUKRIT,EMINPOL)

      BDIPLEP=EMINPOL/RDIPOL*1.0D9/CLIGHT1
      TAUPOL0EP=POL2CON1*UMFANG*RDIPOL**2/EMINPOL**5
      POLFCEP=1.0D0+BINT3YA/2.0D0/PI1/BDIPLEP**3/RDIPOL
      TAUPLEP=TAUPOL0EP/POLFCEP
      POLLVEP=(2.*PI1*RDIPOL*BDIPLEP**3+BINT3Y)/
     &  (2.*PI1*RDIPOL*BDIPLEP**3+BINT3YA)*POL1CON1

C--- SIMPLE ESTIMATE OF LINEAR TRANSFER MATRIX

c20180111+self,if=notralinshort.
c      if  (betfun.eq.-9999.or.betfunv.eq.-9999.or.iphellip.ne.0
      if  (iemit.ne.0.or.iphellip.ne.0) then

        if (deltaz.eq.0.0d0)  deltaz=0.0001
        if (deltazp.eq.0.0d0) deltazp=0.0001
        if (deltay.eq.0.0d0)  deltay=0.0001
        if (deltayp.eq.0.0d0) deltayp=0.0001

        write(lungfo,*)
        write(lungfo,*)
     &    '--- Remark: Call of TRALIN triggered and IMAGSPLN=0 due to'
        write(lungfo,*)
     &    '            IEMIT or IPHELLIP'
        write(lungfo,*)

        write(6,*)
        write(6,*)
     &    '--- Remark: Call of TRALIN triggered and IMAGSPLN=0 due to'
        write(6,*)
     &    '            IEMIT or IPHELLIP'
        write(6,*)

        imagspln=0

      endif

c20180111+self.

      IF (
     &    DABS(DELTAZ)+DABS(DELTAZP)+DABS(DELTAY)+DABS(DELTAYP).GT.0.0
     &    D0.OR.IPHELLIP.NE.0.or.betfun.eq.-9999.or.betfunv.eq.-9999.) THEN
c23.3.2022        IF (IRBTAB.NE.0.OR.IRBTABZY.NE.0.OR.IRBTABXYZ.NE.0.OR.IMAGSPLN.NE.0) THEN
        IF (IMAGSPLN.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
c23.3.2022          WRITE(LUNGFO,*)'     MAGNETIC FIELD FLAG IMAGSPLN,IRBTAB/IRBTABZY/IRBTABXYZ'
          WRITE(LUNGFO,*)'     MAGNETIC FIELD FLAG IMAGSPLN'
          WRITE(LUNGFO,*)'     NOT COMPATIBLE WITH CALL TO SR TRALIN OR'
          WRITE(LUNGFO,*)'     IPHELLIP.NE.0'
          WRITE(LUNGFO,*)'     SET PARAMETERS IN NAMELIST $TRALINN AND IPHELLIP'
          WRITE(LUNGFO,*)'     TO ZERO OR USE OTHER MAGNETIG FIELD FLAG'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'     *** ERROR IN GFINIT ***'
c23.3.2022          WRITE(6,*)'     MAGNETIC FIELD FLAG IMAGSPLN,IRBTAB/IRBTABZY/IRBTABXYZ'
          WRITE(6,*)'     MAGNETIC FIELD FLAG IMAGSPLN'
          WRITE(6,*)'     NOT COMPATIBLE WITH CALL TO SR TRALIN'
          WRITE(6,*)'     SET PARAMETERS IN NAMELIST $TRALINN AND IPHELLIP'
          WRITE(6,*)'     TO ZERO OR USE OTHER MAGNETIG FIELD FLAG'
          WRITE(6,*)
          STOP '--- Program aborted ---'
        ENDIF
        CALL TRALIN
      ENDIF

C--- WRITE SOME RESULTS

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Number of tracking steps per meter (MYINUM): ',MYINUM
      WRITE(LUNGFO,*)

      IF (XINTER.NE.-9999.) THEN

       WRITE(LUNGFO,*)'     Start of the trajectory given by XINTER:'
       WRITE(LUNGFO,*)'     X [m], Y [m], Z[m]:'
       WRITE(LUNGFO,*)'     ',SNGL(XINTER),SNGL(YSTARTO),SNGL(ZSTARTO)
       WRITE(LUNGFO,*)'     VX, VY , VZ:'
       WRITE(LUNGFO,*)'     ',SNGL(VXINO),SNGL(VYINO),SNGL(VZINO)
       WRITE(LUNGFO,*)

      ENDIF   !(XINTER.NE.-9999.)

      WRITE(LUNGFO,*)'     Start and end of the trajectory [m](XSTART,XSTOP):'
      WRITE(LUNGFO,*)'     ',SNGL(XSTART),SNGL(XSTOP)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     BMOVECUT:',SNGL(BMOVECUT)
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)'     Initial energy [GeV] and gamma: '
     &  ,SNGL(ENEGEV),GAMMA
      WRITE(LUNGFO,*)'     Final energy [GeV] and gamma:   '
     &  ,SNGL(ENEGEV-ENEGEV*GAMMAL/DMYGAMMA),DMYGAMMA-GAMMAL
      WRITE(LUNGFO,*)'     Relative change:                '
     &  ,SNGL((DMYGAMMA-GAMMAL-GAMMA)/DMYGAMMA)
      IF (ieneloss.eq.-1) then
        if (nqfphotons.gt.0) then
          qfmean=qfmean/nqfphotons
          qfrms=sqrt((qfrms/nqfphotons-qfmean**2))
        endif
c qfrms is rms of the energy of the irradiated photons, thus
c qfrms*nqfphotons should be the sqrt(nqfphotons)*qfrms
        WRITE(LUNGFO,*)'     number of photons, RMS (keV) and rel. RMS of quantum fluctuation:'
        WRITE(LUNGFO,*)'     ',
     &    nqfphotons,
     &    sngl(qfrms*1.0d6*sqrt(dble(nqfphotons))),
     &    sngl(qfrms*sqrt(dble(nqfphotons))/dmyenergy)
      endif

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     B-rho [Tm], current [A]: ',SNGL(DBRHO),SNGL(DMYCUR)
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)
     &  '     Offset for vert. and hori. magnetic field (BYGOFF, BZGOFF):'
      WRITE(LUNGFO,*)
     &  '      ',SNGL(BYGOFF),SNGL(BZGOFF)
      WRITE(LUNGFO,*)
     &  '     Global scaling factor for mag. field (B0SCGLOB,A0SCGLOB):'
      WRITE(LUNGFO,*)
     &  '      ',SNGL(B0SCGLOB),SNGL(A0SCGLOB)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Global rel. taper (XTAPER, BTAPERV, BTAPERH):'
      WRITE(LUNGFO,*)
     &  '      ',SNGL(XTAPER),SNGL(BTAPERV),SNGL(BTAPERH)
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)
     &  '     Long. shift [m] of device (X(e-) -> X(e-)+XSHIFT): '
     &  ,SNGL(XSHIFT)
      WRITE(LUNGFO,*)
     &  '     Vert. shift [m] of device (Y(e-) -> Y(e-)+VSHIFT): '
     &  ,SNGL(VSHIFT)
      WRITE(LUNGFO,*)
     &  '     Hori. shift [m] of device (Z(e-) -> Z(e-)+HSHIFT): '
     &  ,SNGL(HSHIFT)
      WRITE(LUNGFO,*)
     &  '     Rotation angle [degree] of device:                 '
     &  ,SNGL(XROTD)
      WRITE(LUNGFO,*)
     &  '     Y(e-) -> Y(e-)*sin(XROTD) + Y(e-)*cos(XROTD)'
      WRITE(LUNGFO,*)
     &  '     Z(e-) -> Z(e-)*cos(XROTD) - Y(e-)*sin(XROTD)'
      WRITE(LUNGFO,*)
      IF (IPERIODG.NE.0) THEN
      WRITE(LUNGFO,*)
     &  '     period length of mag. field (PERIODG):               ',SNGL(PERIODG)
      WRITE(LUNGFO,*)
     &  '     longitudinal x-offset for periodical field (PEROFFG):',SNGL(PEROFFG)
      WRITE(LUNGFO,*)
     &  '     scaling and alternating sign reverse factor (SIGNG):',SNGL(SIGNG)
      WRITE(LUNGFO,*)
     &  '     scaling and alternating sign reverse factor (SIGNG2):',SNGL(SIGNG2)
      WRITE(LUNGFO,*)
      ENDIF

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Magnetic field [T] at starting point:'
      WRITE(LUNGFO,*)'     ',SNGL(BXSTART),SNGL(BYSTART),SNGL(BZSTART)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Vector potential [T-m] at starting point:'
      WRITE(LUNGFO,*)'     ',SNGL(AXSTART),SNGL(AYSTART),SNGL(AZSTART)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Magnetic field [T] at stopping point:'
      WRITE(LUNGFO,*)'     ',SNGL(BXSTOP),SNGL(BYSTOP),SNGL(BZSTOP)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Vector potential [T-m] at stopping point:'
      WRITE(LUNGFO,*)'     ',SNGL(AXSTOP),SNGL(AYSTOP),SNGL(AZSTOP)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Extrema of magnetic field [T] and the trajectory [m]:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     BXmax,BXmin: ',SNGL(BXMX),SNGL(BXMN)
      WRITE(LUNGFO,*)'     BYmax,BYmin: ',SNGL(BYMX),SNGL(BYMN)
      WRITE(LUNGFO,*)'     BZmax,BZmin: ',SNGL(BZMX),SNGL(BZMN)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Xmax,Xmin: ',SNGL(XMX),SNGL(XMN)
      WRITE(LUNGFO,*)'     Ymax,Ymin: ',SNGL(YMX),SNGL(YMN)
      WRITE(LUNGFO,*)'     Zmax,Zmin: ',SNGL(ZMX),SNGL(ZMN)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Extrema of magnetic field [T] and the trajectory [m] between'
      WRITE(LUNGFO,*)
     &  '     XIANF and XIEND'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     BXmaxAE,BXminAE: ',SNGL(BXMXAE),SNGL(BXMNAE)
      WRITE(LUNGFO,*)'     BYmaxAE,BYminAE: ',SNGL(BYMXAE),SNGL(BYMNAE)
      WRITE(LUNGFO,*)'     BZmaxAE,BZminAE: ',SNGL(BZMXAE),SNGL(BZMNAE)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     XmaxAE,XminAE: ',SNGL(XMXAE),SNGL(XMNAE)
      WRITE(LUNGFO,*)'     YmaxAE,YminAE: ',SNGL(YMXAE),SNGL(YMNAE)
      WRITE(LUNGFO,*)'     ZmaxAE,ZminAE: ',SNGL(ZMXAE),SNGL(ZMNAE)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Start values (coordinates [m] and slopes) of trajectory:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     X0: ',X0
      WRITE(LUNGFO,*)'     Y0: ',Y0
      WRITE(LUNGFO,*)'     Z0: ',Z0
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     ZP0:',ZP0
      WRITE(LUNGFO,*)'     YP0:',YP0
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     VX0:',VX0
      WRITE(LUNGFO,*)'     VY0:',VY0
      WRITE(LUNGFO,*)'     VZ0:',VZ0
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Values for X=0 (coordinates [m] and slopes) of trajectory:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     YCEN: ',YCEN
      WRITE(LUNGFO,*)'     ZCEN: ',ZCEN
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     YPCEN:',YPCEN
      WRITE(LUNGFO,*)'     ZPCEN:',ZPCEN
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     End values (coordinates [m] and slopes) of trajectory:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     XF0: ',XF0
      WRITE(LUNGFO,*)'     YF0: ',YF0
      WRITE(LUNGFO,*)'     ZF0: ',ZF0
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     ZPF0: ',ZPF0
      WRITE(LUNGFO,*)'     YPF0: ',YPF0
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     VXF0: ',VXF0
      WRITE(LUNGFO,*)'     VYF0: ',VYF0
      WRITE(LUNGFO,*)'     VZF0: ',VZF0
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Values for X=XIANF (coordinates [m] and slopes) of trajectory:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     XIANF: ',XIANF
      WRITE(LUNGFO,*)'     YIANF: ',YIANF
      WRITE(LUNGFO,*)'     ZIANF: ',ZIANF
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     YPIANF:',YPIANF
      WRITE(LUNGFO,*)'     ZPIANF:',ZPIANF
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Values for X=XIEND (coordinates [m] and slopes) of trajectory:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     XIEND: ',XIEND
      WRITE(LUNGFO,*)'     YIEND: ',YIEND
      WRITE(LUNGFO,*)'     ZIEND: ',ZIEND
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     YPIEND:',YPIEND
      WRITE(LUNGFO,*)'     ZPIEND:',ZPIEND
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

      IF (XSTOP.NE.XSTART) THEN
       WRITE(LUNGFO,*)'     ZF0/(XSTOP-XSTART): ',ZF0/(XSTOP-XSTART)
       WRITE(LUNGFO,*)'     YF0/(XSTOP-XSTART): ',YF0/(XSTOP-XSTART)
      ENDIF

      IF (DABS(Z0-ZF0).GT.1.0D-5) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'     *** WARNING IN GFINIT ***'
         WRITE(LUNGFO,*)'     CLOSED ORBIT OFFSET EXCEEDS 1E-5 METER'
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)
         WRITE(6,*)'     *** WARNING IN GFINIT ***'
         WRITE(6,*)'     CLOSED ORBIT OFFSET EXCEEDS 1E-5 METER'
         WRITE(6,*)'     ZF0-Z0:',ZF0-Z0
         WRITE(6,*)
         WRITE(6,*)
      ENDIF

      IF (DABS(ZP0-ZPF0).GT.1.0D-5) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'     *** WARNING IN GFINIT ***'
         WRITE(LUNGFO,*)'     CLOSED ORBIT KICK EXCEEDS 1E-5 RADIAN'
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)
         WRITE(6,*)'     *** WARNING IN GFINIT ***'
         WRITE(6,*)'     CLOSED ORBIT KICK EXCEEDS 1E-5 RADIAN'
         WRITE(6,*)'     ZPF0-ZP0:',ZPF0-ZP0
         WRITE(6,*)
         WRITE(6,*)
      ENDIF

      IF (DABS(Y0-YF0).GT.1.0D-5) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'     *** WARNING IN GFINIT ***'
         WRITE(LUNGFO,*)'     CLOSED ORBIT OFFSET EXCEEDS 1E-5 METER'
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)
         WRITE(6,*)'     *** WARNING IN GFINIT ***'
         WRITE(6,*)'     CLOSED ORBIT OFFSET EXCEEDS 1E-5 METER'
         WRITE(6,*)'     YF0-Y0:',YF0-Y0
         WRITE(6,*)
         WRITE(6,*)
      ENDIF

      IF (DABS(YP0-YPF0).GT.1.0D-5) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'     *** WARNING IN GFINIT ***'
         WRITE(LUNGFO,*)'     CLOSED ORBIT KICK EXCEEDS 1E-5 RADIAN'
         WRITE(LUNGFO,*)'     YPF0-YP0:',YPF0-YP0
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)
         WRITE(6,*)'     *** WARNING IN GFINIT ***'
         WRITE(6,*)'     CLOSED ORBIT KICK EXCEEDS 1E-5 RADIAN'
         WRITE(6,*)'     YPF0-YP0:',YPF0-YP0
         WRITE(6,*)
         WRITE(6,*)
      ENDIF

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     YF0-Y0:',YF0-Y0
      WRITE(LUNGFO,*)'     ZF0-Z0:',ZF0-Z0
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     YPF0-YP0:',YPF0-YP0
      WRITE(LUNGFO,*)'     ZPF0-ZP0:',ZPF0-ZP0
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)'     Straight line fit of z(x):'
      WRITE(LUNGFO,*)'     offset:', zoffstr
      WRITE(LUNGFO,*)'     slope:', zslopetr
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Straight line fit of vz(x)/vx(x):'
      WRITE(LUNGFO,*)'     offset:', zpoffstr
      WRITE(LUNGFO,*)'     slope:', zpslopetr
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)'     Straight line fit of y(x):'
      WRITE(LUNGFO,*)'     offset:', yoffstr
      WRITE(LUNGFO,*)'     slope:', yslopetr
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Straight line fit of vy(x)/vx(x):'
      WRITE(LUNGFO,*)'     offset:', ypoffstr
      WRITE(LUNGFO,*)'     slope:', ypslopetr

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     1. magnetic integral [T-m]: '
     &  ,SNGL(BINT1X),SNGL(BINT1Y),SNGL(BINT1Z)
      WRITE(LUNGFO,*)'     2. mag. integral [T-m**2]: '
     &  ,SNGL(BINT2X),SNGL(BINT2Y),SNGL(BINT2Z)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Integrated By**2 [T**2-m]:                   '
     &  ,SNGL(B2INTY)
      if (kampli.eq.0) then
        WRITE(LUNGFO,*)
     &    '     Energy irradiated by the device per e- [MeV]:'
     &    ,SNGL(PINT/DMYCUR/1.0d6)
        WRITE(LUNGFO,*)
     &    '     Rel. energy loss:                            '
     &    ,SNGL(PINT/DMYCUR/1.0d9/DMYENERGY)
        WRITE(LUNGFO,*)
     &    '     Power irradiated by the device [kWATT]:      '
     &    ,SNGL(PINT/1000.)
      else
        WRITE(LUNGFO,*)
     &    '     Energy irradiated by the device per e- [MeV]:'
     &    ,SNGL(PINT/DMYCUR/1.0d6*iabs(kampli))
        WRITE(LUNGFO,*)
     &    '     Rel. energy loss:                            '
     &    ,SNGL(PINT/DMYCUR/1.0d9/DMYENERGY*iabs(kampli))
        WRITE(LUNGFO,*)
     &    '     Power irradiated by the device [kWATT]:      '
     &    ,SNGL(PINT/1000.*iabs(kampli))
      endif

      IF (IAMPLI.GT.0) THEN
        WRITE(LUNGFO,*)'     (Option IAMPLI not taken into account!!)'
      ENDIF

      IF (IAMPLI.LT.0) THEN
        WRITE(LUNGFO,*)'     scaled according to IAMPLI:     '
     &    ,SNGL(PINT/1000.*(-IAMPLI))
      ENDIF !IAMPLI

      IF (IAMPLI.lt.0.and.icluster.ne.0) THEN
        write(6,*)"*** Warning in GFINIT: IAMPLI < 0 and ICLUSTER <> 0 may cause problems, be careful ***"
        write(lungfo,*)"*** Warning in GFINIT: IAMPLI < 0 and ICLUSTER <> 0 may cause problems, be careful ***"
      endif

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Length of trajectory (BINT0) [m]:'
      WRITE(LUNGFO,*)
     &  '     ',BINT0
      WRITE(LUNGFO,*)
     &  '     Integrated (YP**2+ZP**2)/2 of trajectory (WTRA2I) [m]:'
      WRITE(LUNGFO,*)
     &  '     ',WTRA2I

      IF (HTRA2I.NE.0.0D0) THEN
        WRITE(LUNGFO,*)
     &    '     corresponding phase advance [nm and eV]:'
        WRITE(LUNGFO,*)
     &    '     ',HTRA2I*1.0D9
     &    ,CLIGHT1*HPLANCK1/ECHARGE1/HTRA2I
      ELSE
        WRITE(LUNGFO,*)
     &    '     corresponding phase advance [nm and eV]:'
        WRITE(LUNGFO,*)
     &    '     ',SNGL(HTRA2I*1.0D9),'    0.000'
      ENDIF

      WRITE(LUNGFO,*)
     &    '     dE/E and corresponding dL = 2 * dE/E * L [nm]:'
      WRITE(LUNGFO,*)
     &  '     ',SNGL(ESPREAD)
     &  ,SNGL(2.0D9*ESPREAD*WTRA2I)

      WRITE(LUNGFO,*)
     &  '     Circumference of the ring [m]:              ',SNGL( UMFANG  )
      WRITE(LUNGFO,*)
     &  '     Rel. change of total circumference (from BINT0):         '
      WRITE(LUNGFO,*)
     &  '     ',SNGL((BINT0+XSTART-XSTOP)/UMFANG  )
      WRITE(LUNGFO,*)
     &  '     Rel. change of total circumference (from WTRA2I):'
      WRITE(LUNGFO,*)
     &  '     ',SNGL(WTRA2I/UMFANG  )
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Max. and min. deflection angle [rad]: '
     &  ,SNGL(PHIMX),SNGL(PHIMN)
      WRITE(LUNGFO,*)

      IF (IBEAMPOL.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     Beam polarization time (time constant) [h]: '
     &    ,SNGL (TAUPOL)
        WRITE(LUNGFO,*)'     Reduction factor due to device:             '
     &    ,SNGL (POLFAC)
        WRITE(LUNGFO,*)'     Final level of beam polarization:           '
     &    ,SNGL (POLLEV)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     Same numbers for a beam energy of 1 GeV:    '
     &    ,SNGL(TAUPL1G)
        WRITE(LUNGFO,*)'                                                 '
     &    ,SNGL(POLFC1G)
        WRITE(LUNGFO,*)'                                                 '
     &    ,SNGL(POLLV1G)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     Critical polarization time (TAUKRIT) and corresponding beam'
        WRITE(LUNGFO,*)
     &    '     energy [GeV], reduction factor, and final polarization level:'
        WRITE(LUNGFO,*)'     '
     &    ,SNGL(TAUKRIT),SNGL(EMINPOL),SNGL(POLFCEP),SNGL(POLLVEP)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     Integrals of By**3, |By|**3 of device and integral of By**3'
        WRITE(LUNGFO,*)'     of ring [T-m**3]:'
     &    ,SNGL(BINT3Y),SNGL(BINT3YA),SNGL(6.283185*RDIPOL*BDIPOL**3)
      ENDIF !IBEAMPOL

      IF (IDISPER.NE.0.OR.IBEAMPOL.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Bending radius of the ring dipoles [m]: '
     &      ,SNGL(RDIPOL)
          WRITE(LUNGFO,*)'     Circumference of the ring [m]:          '
     &      ,SNGL(UMFANG)
          WRITE(LUNGFO,*)
      ENDIF

      IF (IDISPER.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     BETA FUNCTION FOR WLS:      ',SNGL(BETFUN)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     INTEGRAL I2 OF RING:        ',SNGL(DI2RING)
          WRITE(LUNGFO,*)'     INTEGRAL I4 OF RING:        ',SNGL(DI4RING)
          WRITE(LUNGFO,*)'     INTEGRAL I5 OF RING:        ',SNGL(DI5RING)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
      ENDIF

C--- ADJUST SOMETHING

      IF (IJUST.NE.0) THEN !SEE ABOVE
         XJUST=HSHIFT
         YJUST=ZF0
         WRITE(6,*)'HSHIFT, ZF0:', HSHIFT,ZF0
         CALL WLSJUST(XJUST,YJUST)
         IF (IJUST.LE.3) THEN
            IABEND=2
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     HSHIFT ADJUSTED'
            WRITE(LUNGFO,*)
            RETURN
         ENDIF
      ENDIF

C--- HBOOK

      IF (IHBOOK.NE.0) CALL HISINI

C--- WRITE B-FIELD TO FILE

      IF (IWBTAB.NE.0) CALL WBTAB

C--- WRITE B-FIELD TO MAP FILE

      IF (IWBMAP.NE.0) CALL WBMAP

C--- CALCULATE 3D POLYNOMIAL-COEFFICIENTS OF B-FIELD AND EXIT

      IF (IWBPOLY3D.NE.0) THEN
          CALL BPOLY3DFIT
          IABEND=3
          goto 9999
      ENDIF

C--- CALCULATE 3D POLYNOMIAL-COEFFICIENTS OF B-FIELD AND EXIT

      IF (IWBPOLY2DH.NE.0) THEN
          CALL BPOLY2DHFIT
          IABEND=3
          goto 9999
      ENDIF

      IF (IWBPHARM.NE.0) THEN
          CALL BPHARMFIT
          IABEND=3
          goto 9999
      ENDIF

      IF (IHTRACK.NE.0) CALL HTRACK

      if (icluster.ne.0.and.ispecmode.eq.3) then
        PRINT *,
     &      '*** Warning in GFINIT: ICLUSTER .NE. 0 but ISPECMODE=3 ***'
        print*,"*** BE CAREFUL ***"
      endif

      if (icluster.ne.0.and.ispecmode.eq.3) then
        PRINT *,
     &      '*** Warning in GFINIT: ICLUSTER .NE. 0 but ISPECMODE=3 ***'
        print*,"*** BE CAREFUL ***"
      endif

      if (iemit.ne.0.or.ibunch.ne.0) imagspln=0

      if (phrxbeta.eq.-9999.0d0) xbetfun=xstart

      if (abs(phrxbeta).eq.9999.0d0) then
        phrxbeta=xstart
      endif

      if (phrbunlen.eq.9999.0d0) then
        phrbunlen=bunchlen
      endif
      if (phrbunlen.eq.-9999.0d0) then
        phrbunlen=ampbunchlen
      endif

      if (phrbetah.eq.9999.0d0) then
        phrbetah=betah
      endif
      if (phralphah.eq.9999.0d0) then
        phralphah=-betaph/2.0d0
      endif

      if (phrdisph.eq.9999.0d0) then
        phrdisph=disp0
      endif

      if (phrdispph.eq.9999.0d0) then
        phrdisph=ddisp0
      endif

      if (phrbetav.eq.9999.0d0) then
        phrbetav=betav
      endif
      if (phralphav.eq.9999.0d0) then
        phralphav=-betapv/2.0d0
      endif

      if (phremith.eq.9999.0d0) then
        phremith=eps0h
      endif

      if (phremitv.eq.9999.0d0) then
        phremitv=eps0v
      endif

      if (phrespread.eq.9999.0d0) then
        phrespread=delgam
      endif

      if (phrespread.eq.-9999.0d0) then
        phrespread=espread
      endif

      if (phremith.eq.9999.0d0) then
        phremith=eps0h
      endif

      if (phremith.eq.-9999.0d0) then
        phremith=bsigz(1)*bsigzp(1)
        phralphah=0.0d0
      endif

      if (phremitv.eq.-9999.0d0) then
        phremitv=bsigy(1)*bsigyp(1)
        phralphav=0.0d0
      endif

      if (phrbetah.eq.-9999.0d0) then
        phrbetah=bsigz(1)**2/phremith
        phralphah=0.0d0
      endif

      if (phrbetav.eq.-9999.0d0) then
        phrbetav=bsigy(1)**2/phremitv
        phralphav=0.0d0
      endif

      return

9999  iroottrees=0

      return
      END
+DECK,spectrum.
*CMZ :          17/10/2023  13.27.14  by  Michael Scheer
*CMZ :  4.01/03 01/07/2023  10.08.32  by  Michael Scheer
*CMZ :  4.01/02 14/05/2023  13.25.57  by  Michael Scheer
*CMZ :  4.01/00 05/12/2022  10.23.29  by  Michael Scheer
*CMZ :  4.00/17 15/11/2022  10.09.14  by  Michael Scheer
*CMZ :  4.00/15 31/05/2022  09.04.28  by  Michael Scheer
*CMZ :  4.00/13 07/12/2021  18.47.10  by  Michael Scheer
*CMZ :  4.00/11 15/06/2021  12.33.13  by  Michael Scheer
*CMZ :  4.00/10 03/09/2020  13.24.08  by  Michael Scheer
*CMZ :  4.00/07 26/06/2020  10.05.00  by  Michael Scheer
*CMZ :  4.00/05 29/11/2019  17.42.27  by  Michael Scheer
*CMZ :  4.00/04 27/08/2019  11.49.27  by  Michael Scheer
*CMZ :  3.08/01 03/04/2019  16.22.16  by  Michael Scheer
*CMZ :  3.07/01 29/03/2019  15.08.52  by  Michael Scheer
*CMZ :  3.07/00 14/03/2019  15.32.16  by  Michael Scheer
*CMZ :  3.06/00 19/02/2019  11.45.45  by  Michael Scheer
*CMZ :  3.05/14 28/09/2018  12.28.08  by  Michael Scheer
*CMZ :  3.05/10 13/08/2018  14.40.26  by  Michael Scheer
*CMZ :  3.05/06 17/07/2018  11.15.17  by  Michael Scheer
*CMZ :  3.05/03 17/05/2018  08.46.21  by  Michael Scheer
*CMZ :  3.05/02 09/05/2018  12.55.31  by  Michael Scheer
*CMZ :  3.03/02 04/05/2018  13.55.11  by  Michael Scheer
*CMZ :  3.03/01 12/11/2015  10.13.14  by  Michael Scheer
*CMZ :  3.02/07 22/06/2015  15.01.50  by  Michael Scheer
*CMZ :  3.02/06 15/04/2015  12.01.22  by  Michael Scheer
*CMZ :  3.02/03 07/11/2014  17.09.23  by  Michael Scheer
*CMZ :  3.02/00 18/09/2014  15.43.00  by  Michael Scheer
*CMZ :  3.01/00 03/07/2013  15.42.09  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.70/11 21/02/2013  10.24.53  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  14.04.56  by  Michael Scheer
*CMZ :  2.70/04 21/12/2012  12.38.11  by  Michael Scheer
*CMZ :  2.69/00 30/10/2012  14.15.43  by  Michael Scheer
*CMZ :  2.68/05 18/10/2012  14.25.09  by  Michael Scheer
*CMZ :  2.68/02 05/07/2012  11.19.57  by  Michael Scheer
*CMZ :  2.68/01 29/05/2012  09.43.05  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  16.32.34  by  Michael Scheer
*CMZ :  2.67/04 11/05/2012  15.40.01  by  Michael Scheer
*CMZ :  2.66/18 02/12/2010  14.59.07  by  Michael Scheer
*CMZ :  2.66/16 22/11/2010  14.01.42  by  Michael Scheer
*CMZ :  2.66/13 18/06/2010  14.17.37  by  Michael Scheer
*CMZ :  2.66/09 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.66/08 15/03/2010  15.14.36  by  Michael Scheer
*CMZ :  2.66/07 10/03/2010  09.03.13  by  Michael Scheer
*CMZ :  2.66/06 24/02/2010  17.11.25  by  Michael Scheer
*CMZ :  2.66/04 18/11/2009  10.22.04  by  Michael Scheer
*CMZ :  2.66/03 12/11/2009  16.27.11  by  Michael Scheer
*CMZ :  2.66/00 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  2.65/03 02/10/2009  13.09.16  by  Michael Scheer
*CMZ :  2.65/02 29/09/2009  12.00.20  by  Michael Scheer
*CMZ :  2.64/07 17/09/2009  15.40.31  by  Michael Scheer
*CMZ :  2.64/06 15/09/2009  15.08.58  by  Michael Scheer
*CMZ :  2.64/05 14/09/2009  15.19.42  by  Michael Scheer
*CMZ :  2.64/01 19/08/2009  08.45.04  by  Michael Scheer
*CMZ :  2.64/00 14/08/2009  14.25.09  by  Michael Scheer
*CMZ :  2.63/05 12/08/2009  08.49.28  by  Michael Scheer
*CMZ :  2.62/03 16/07/2007  12.15.22  by  Michael Scheer
*CMZ :  2.62/02 16/07/2007  07.31.52  by  Michael Scheer
*CMZ :  2.61/01 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.57/04 01/02/2006  12.28.09  by  Michael Scheer
*CMZ :  2.57/01 22/11/2005  13.07.59  by  Michael Scheer
*CMZ :  2.56/01 17/10/2005  14.36.43  by  Michael Scheer
*CMZ :  2.56/00 17/10/2005  13.26.33  by  Michael Scheer
*CMZ :  2.54/05 26/05/2005  08.07.59  by  Michael Scheer
*CMZ :  2.53/05 17/02/2005  14.00.32  by  Michael Scheer
*CMZ :  2.52/16 19/01/2005  10.32.23  by  Michael Scheer
*CMZ :  2.52/13 10/12/2004  10.43.51  by  Michael Scheer
*CMZ :  2.52/11 08/12/2004  13.11.32  by  Michael Scheer
*CMZ :  2.52/10 05/11/2004  15.45.33  by  Michael Scheer
*CMZ :  2.52/01 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.52/00 29/06/2004  11.53.01  by  Michael Scheer
*CMZ :  2.51/02 22/06/2004  09.06.04  by  Michael Scheer
*CMZ :  2.51/01 17/06/2004  11.33.47  by  Michael Scheer
*CMZ :  2.51/00 26/05/2004  15.54.25  by  Michael Scheer
*CMZ :  2.50/02 30/04/2004  15.27.49  by  Michael Scheer
*CMZ :  2.50/00 29/04/2004  17.07.16  by  Michael Scheer
*CMZ :  2.49/00 22/03/2004  13.30.23  by  Michael Scheer
*CMZ :  2.47/09 20/05/2003  14.31.10  by  Michael Scheer
*CMZ :  2.47/05 25/03/2003  12.09.15  by  Michael Scheer
*CMZ :  2.47/01 10/03/2003  11.54.47  by  Michael Scheer
*CMZ :  2.46/02 07/03/2003  11.02.34  by  Michael Scheer
*CMZ :  2.44/01 21/11/2002  16.45.47  by  Michael Scheer
*CMZ :  2.44/00 15/11/2002  18.31.22  by  Michael Scheer
*CMZ :  2.41/11 21/08/2002  11.23.26  by  Michael Scheer
*CMZ :  2.41/09 14/08/2002  17.20.18  by  Michael Scheer
*CMZ :  2.41/07 31/05/2002  16.37.13  by  Michael Scheer
*CMZ :  2.38/00 12/12/2001  18.21.12  by  Michael Scheer
*CMZ :  2.35/02 30/10/2001  17.06.49  by  Michael Scheer
*CMZ :  2.34/09 26/09/2001  17.14.17  by  Michael Scheer
*CMZ :  2.34/00 11/05/2001  17.06.33  by  Michael Scheer
*CMZ :  2.33/04 04/05/2001  11.31.09  by  Michael Scheer
*CMZ :  2.33/01 03/05/2001  13.48.25  by  Michael Scheer
*CMZ :  2.33/00 03/05/2001  10.49.22  by  Michael Scheer
*CMZ :  2.31/01 25/04/2001  14.38.57  by  Michael Scheer
*CMZ :  2.31/00 24/04/2001  11.16.55  by  Michael Scheer
*CMZ :  2.30/01 12/04/2001  12.43.20  by  Michael Scheer
*CMZ :  2.20/11 11/04/2001  13.15.39  by  Michael Scheer
*CMZ :  2.20/10 04/04/2001  16.52.12  by  Michael Scheer
*CMZ :  2.20/09 03/04/2001  14.51.24  by  Michael Scheer
*CMZ :  2.20/04 09/03/2001  19.13.21  by  Michael Scheer
*CMZ :  2.20/03 23/02/2001  14.46.53  by  Michael Scheer
*CMZ :  2.20/01 19/02/2001  10.53.35  by  Michael Scheer
*CMZ :  2.17/00 06/11/2000  17.32.34  by  Michael Scheer
*CMZ :  2.16/08 01/11/2000  18.52.39  by  Michael Scheer
*CMZ :  2.16/07 17/10/2000  11.06.19  by  Michael Scheer
*CMZ :  2.16/06 28/08/2000  16.04.39  by  Michael Scheer
*CMZ :  2.16/05 02/08/2000  13.56.30  by  Michael Scheer
*CMZ :  2.16/04 20/07/2000  15.20.32  by  Michael Scheer
*CMZ :  2.16/03 16/06/2000  14.59.25  by  Michael Scheer
*CMZ :  2.16/01 15/06/2000  16.12.25  by  Michael Scheer
*CMZ :  2.16/00 13/06/2000  14.00.28  by  Michael Scheer
*CMZ :  2.15/00 06/05/2000  11.15.11  by  Michael Scheer
*CMZ :  2.13/10 06/04/2000  13.55.09  by  Michael Scheer
*CMZ :  2.13/08 28/02/2000  10.59.59  by  Michael Scheer
*CMZ :  2.13/07 17/02/2000  15.11.13  by  Michael Scheer
*CMZ :  2.13/04 21/01/2000  14.49.57  by  Michael Scheer
*CMZ :  2.13/03 18/01/2000  17.58.11  by  Michael Scheer
*CMZ :  2.13/02 14/12/99  16.47.46  by  Michael Scheer
*CMZ :  2.13/00 02/12/99  13.19.08  by  Michael Scheer
*CMZ :  2.12/04 20/08/99  11.42.59  by  Michael Scheer
*CMZ :  2.12/03 08/07/99  10.46.11  by  Michael Scheer
*CMZ :  2.12/02 15/06/99  16.10.08  by  Michael Scheer
*CMZ :  2.12/01 14/06/99  15.26.07  by  Michael Scheer
*CMZ :  2.12/00 03/06/99  15.38.11  by  Michael Scheer
*CMZ :  2.11/01 18/05/99  10.04.01  by  Michael Scheer
*CMZ :  2.11/00 12/05/99  11.35.36  by  Michael Scheer
*CMZ :  2.10/01 19/03/99  11.45.33  by  Michael Scheer
*CMZ :  2.02/00 12/02/99  16.13.41  by  Michael Scheer
*CMZ :  2.00/00 06/01/99  11.58.17  by  Michael Scheer
*CMZ :  1.04/03 11/12/98  16.35.36  by  Michael Scheer
*CMZ :  1.04/02 11/12/98  11.35.23  by  Michael Scheer
*CMZ :  1.04/01 11/12/98  11.21.18  by  Michael Scheer
*CMZ :  1.04/00 05/10/98  15.04.38  by  Michael Scheer
*CMZ :  1.03/06 25/09/98  11.00.44  by  Michael Scheer
*CMZ :  1.03/03 24/02/98  12.03.00  by  Michael Scheer
*CMZ :  1.03/02 18/02/98  16.56.26  by  Michael Scheer
*CMZ :  1.03/01 16/01/98  16.52.08  by  Michael Scheer
*CMZ :  1.02/03 16/01/98  10.58.48  by  Michael Scheer
*CMZ :  1.00/00 05/08/97  15.02.55  by  Michael Scheer
*CMZ : 00.02/05 25/03/97  13.44.31  by  Michael Scheer
*CMZ : 00.02/04 26/02/97  12.24.14  by  Michael Scheer
*CMZ : 00.02/03 16/01/97  11.07.55  by  Michael Scheer
*CMZ : 00.02/02 15/01/97  13.14.58  by  Michael Scheer
*CMZ : 00.01/12 04/11/96  11.52.18  by  Michael Scheer
*CMZ : 00.01/10 16/07/96  15.25.52  by  Michael Scheer
*CMZ : 00.01/09 01/09/95  13.05.18  by  Michael Scheer
*CMZ : 00.01/08 22/06/95  18.18.43  by  Michael Scheer
*CMZ : 00.01/07 24/02/95  11.21.39  by  Michael Scheer
*CMZ : 00.01/06 02/02/95  19.03.32  by  Michael Scheer
*CMZ : 00.01/05 31/01/95  15.35.41  by  Michael Scheer
*CMZ : 00.01/04 26/01/95  16.20.02  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  18.37.44  by  Michael Scheer
*CMZ : 00.00/07 25/05/94  16.45.07  by  Michael Scheer
*CMZ : 00.00/05 29/04/94  20.07.34  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.54.43  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.39  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE SPECTRUM
+seq,gplhint.

C--- MAIN ROUTINE TO CALCULATE SYNCHROTRON RADIATION SPECTRA

+SEQ,TRACKF90U.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,REARGF90U.
+SEQ,WFOLDF90U.
+SEQ,AFREQF90U.
+SEQ,AMPLIF90U.

      use clustermod
      use bunchmod
      use ompmod
      use uradphasemod
      !use waveenv

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,TRACK.
+SEQ,OPTIC.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,SPECDIP.
+SEQ,COLLI.
+SEq,wfoldf90.
+SEQ,DEPOLA.
+SEQ,WUSEM.
+SEQ,AMPLI.
+SEQ,USERVAR.
+SEQ,PHYCON.
+SEQ,PRIMKIN.
+seq,datetime.
+seq,debugwave.
+seq,waveenv.

      INTEGER ISOUR,IS,IFR,IO,IX,IC,JC,IZ,IY,IFREQ,IOBSV,IBUFF
      INTEGER ICEN,ISTO,MSADD,IFAIL,I,ISTOK
      INTEGER NTOTIN,NTOT2IN,IREP,ipino,ibuncho,ihbuncho,mbuncho,meinbuncho

      REAL*4 POL,rr(2)
      REAL*4 THERAY,PHIRAY,RAY,ZRAY,YRAY,DRAY,RAY1,RAY2,RAY3,RAY1N,RAY2N,RAY3N

      DOUBLE PRECISION ENEDOSMX,S1,S2,S3,S4,DUM1,DUM2,RMS
      DOUBLE PRECISION WSNOBFR1(NDFREQP),WSNOBFR2(NDFREQP),SPECBUFF(NDFREQP)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SPECTRUM'
      WRITE(LUNGFO,*)'     ==========='
      WRITE(LUNGFO,*)

      ipino=ipin
      ibuncho=ibunch
      mbuncho=nbunch
      meinbuncho=neinbunch
      ihbuncho=ihbunch
      if (kampli.ne.0) then
        ibunch=0
        ihbunch=0
      endif

      if (ispecmode.ne.3.and.ispecmode.ne.1.and.ispecmode.ne.2) then
        write(6,*)
     &    '*** ERROR IN SPECTRUM: ISPECMODE must be 1, 2, or 3***'
        write(LUNGFO,*)
     &    '*** ERROR IN SPECTRUM: ISPECMODE must be 1, 2, or 3***'
        stop '*** PROGRAM WAVE ABORTED ***'
      endif

      if (ipin.eq.3.and.ispecmode.ne.1.and.ispecmode.ne.2) then
        write(LUNGFO,*)
     &    '*** ERROR IN SPECTRUM: For IPIN=3, ISPECMODE must be 1 or 2 ***'
        write(6,*)
     &    '*** ERROR IN SPECTRUM: For IPIN=3, ISPECMODE must be 1 or 2 ***'
        stop
      endif

      IF (ISPECDIP.GT.0.and.ibrill.ne.0) THEN
        write(6,*)'*** WARNING IN SPECTRUM: ISPECDIP.gt.0 and IBRILL.ne.0'
        write(6,*)'*** IBRILL SET TO ZERO ***'
        write(LUNGFO,*)'*** WARNING IN SPECTRUM: ISPECDIP.gt.0 and IBRILL.ne.0'
        write(lungfo,*)'*** IBRILL SET TO ZERO ***'
        IBRILL=0
      endif

      IF (ISPECDIP.GT.0.and.ifold.ne.0) THEN
        write(6,*)'*** WARNING IN SPECTRUM: ISPECDIP.gt.0 and IFOLD.ne.0'
        write(6,*)'*** IFOLD SET TO ZERO ***'
        write(LUNGFO,*)'*** WARNING IN SPECTRUM: ISPECDIP.gt.0 and IFOLD.ne.0'
        write(lungfo,*)'*** IFOLD SET TO ZERO ***'
        ifold=0
        ihfold=0
      endif

      IF (ISPECDIP.GT.0.and.IEFOLD.ne.0) THEN
        write(6,*)'*** WARNING IN SPECTRUM: ISPECDIP.gt.0 and IEFOLD.ne.0'
        write(6,*)'*** IEFOLD SET TO ZERO ***'
        write(LUNGFO,*)'*** WARNING IN SPECTRUM: ISPECDIP.gt.0 and IEFOLD.ne.0'
        write(lungfo,*)'*** IEFOLD SET TO ZERO ***'
        IEFOLD=0
      endif

      IF (ISPECDIP.eq.2.and.if1dim.eq.0) THEN
        write(LUNGFO,*)'*** WARNING IN SPECTRUM: ISPECDIP.eq.2 and IF1DIM.eq.0'
        write(LUNGFO,*)'*** IF1DIM SET TO ONE ***'
        write(6,*)'*** WARNING IN SPECTRUM: ISPECDIP.eq.2 and IF1DIM.eq.0'
        write(6,*)'*** IF1DIM SET TO ONE ***'
        If1dim=1
      endif

      IF (ISPECMODE.gt.2.and.mpinr.ne.0) THEN
        WRITE(LUNGFO,*)' '
        WRITE(LUNGFO,*)
     &    '*** WARNING IN SPECTRUM: ISPECMODE .gt. 2 .and. MPINR .ne. 0'
        WRITE(LUNGFO,*)'*** MPINR will be ignored and set to zero'
        WRITE(LUNGFO,*)' '
        WRITE(6,*)' '
        WRITE(6,*)
     &    '*** WARNING IN SPECTRUM: ISPECMODE .gt. 2 .and. MPINR .ne. 0'
        WRITE(6,*)'*** MPINR will be ignored and set to zero'
        WRITE(6,*)' '
c        mpinr=0
      endif
c 20150622{
c      IF (IFREQ2P.EQ.0.AND.ISPECMODE.LT.3) THEN
c
c        WRITE(LUNGFO,*)
c     &    '*** WARNING IN SPECTRUM: Option IFREQ2P=0 NOT available for ISPECMODE<3'
c        WRITE(LUNGFO,*)
c     &    '*** ISPECMODE set to 3'
c        WRITE(LUNGFO,*)''
c
c        WRITE(6,*)
c     &    '*** WARNING IN SPECTRUM: Option IFREQ2P=0 NOT available for ISPECMODE<3'
c        WRITE(6,*)
c     &    '*** ISPECMODE set to 3'
c        WRITE(6,*)''
c
c        ISPECMODE=3
c
c 20150622}      ENDIF

      IF (ibunch.ne.0) THEN
        write(lungfo,*)'      Bunch parameters:'
        write(lungfo,*)'      mode IUBUNCH:                    ',IUBUNCH
        write(lungfo,*)'      number of bunches NBUNCH:        ',NBUNCH
        write(lungfo,*)'      number of e- per bunch NEINBUNCH:',NEINBUNCH
        write(lungfo,*)'      bunch length [m]: BUNCHLEN:      ',BUNCHLEN
        write(lungfo,*)'      bunch charge [C]: BUNCHCHARGE:   ',BUNCHCHARGE
        WRITE(lungfo,*)''
        WRITE(lungfo,*)''
      endif

      IF (ISPECDIP.LE.0) THEN

        WRITE(LUNGFO,*)
     &    '     Start and end of points [m] of integration for spectrum'
        WRITE(LUNGFO,*)'     calculations (XIANF,XIEND):'
     &    ,SNGL(XIANF),SNGL(XIEND)
        WRITE(LUNGFO,*)

        IF ((XIANF.NE.XSTART.OR.XIEND.NE.XSTOP)
     &      .AND.XIANF.NE.-1.D30.AND.XIEND.NE.1.D30) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      ' *** Start or end of points (XIANF,XIEND) of integration differ'
          WRITE(LUNGFO,*)
     &      ' *** from XSTART or XSTOP respectively'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)
     &      ' *** Start or end of points (XIANF,XIEND) of integration differ'
          WRITE(6,*)
     &      ' *** from XSTART or XSTOP respectively'
          WRITE(6,*)
          WRITE(6,*)
        ENDIF

      ENDIF !ISPECDIP.LE.0

      IF (IWFILINT.GT.0) THEN
        OPEN(UNIT=LUNINT,FILE=FILEINT)
      ENDIF !IWFILINT

C--- NEW VERSION OF TRACKS REQUIRES IMAGSPLN

      IF (ISPECMODE.EQ.3) IMAGSPLN=-999

C----   FREQUENCES TO BE TREATED

      CALL RFILFR

C--- NOW WE ARE DEALING WITH PHOTON ENERGIES

C260194  IF (IUNIT.NE.0) CALL CONVUN

C---  DEFAULTS FOR WGWINFC

      if (pinr.eq.-9999.) pinr=max(pinw,pinh)/2.0d0
      if (pinr.eq.9999.) pinr=sqrt(pinw*pinh/pi1)
      IF (WGWINFC.EQ.9999.AND.IUNDULATOR.EQ.0) CALL SETWGWIN

C---  DEFAULTS FOR PINCEN

      IOBSV_A=1
      IOBSVZ_A=1
      IOBSVY_A=1

      ALLOCATE(OBSV(3,IOBSV_A))
      ALLOCATE(OBSVY(IOBSVY_A))
      ALLOCATE(OBSVZ(IOBSVZ_A))

      IF (IPIN.NE.0) THEN
        CALL PINCENIN
      ENDIF

      IF (OBS1X.EQ.-9999.) OBS1X=PINCEN(1)
      IF (aperX.EQ.-9999.) aperx=PINCEN(1)

      if (ipin.eq.0.and.obs1x.le.xstop) then
        write(6,*)
     &    '*** Error: OBS1X (x of observation point) must be bigger than XSTOP'
        write(6,*)
     &    '*** Please check input file'
        write(6,*)
     &    '*** Program WAVE aborted ***'
        stop
      else if (ipin.ne.0.and.pincen(1).le.xstop) then
        write(6,*)
     &    '*** Error: PINCEN(1) (x of pinhole) must be bigger than XSTOP'
        write(6,*)
     &    '*** Please check input file'
        write(6,*)
     &    '*** Program WAVE aborted ***'
        stop
      endif

      IF (OBS1y.EQ.-9999.) then
        OBS1y=ySTART+VyIN/VXIN*(OBS1X-XSTART)
      else IF (obs1y.EQ.-8888.) THEN
        obs1y=yoffstr+yslopetr*obs1x
      else IF (obs1y.EQ.-9000.) THEN
        obs1y=0.0d0
        do i=1,nco
          obs1y=obs1y+
     &      wtra(2,1,i)+wtra(2,2,i)/wtra(1,2,i)*(PINCEN(1)-wtra(1,1,i))
        enddo
        obs1y=obs1y/nco
      ENDIF

      IF (OBS1Z.EQ.-9999.) then
        OBS1Z=ZSTART+VZIN/VXIN*(OBS1X-XSTART)
      else IF (obs1z.EQ.-8888.) THEN
        obs1z=zoffstr+zslopetr*obs1x
      else IF (obs1z.EQ.-9000.) THEN
        obs1z=0.0d0
        do i=1,nco
          obs1z=obs1z+
     &      wtra(3,1,i)+wtra(3,2,i)/wtra(1,2,i)*(PINCEN(1)-wtra(1,1,i))
        enddo
        obs1z=obs1z/nco
      ENDIF

      IF (IPIN.EQ.0) PINCEN(1)=OBS1X

C---  SOURCES OF LIGHT. SOURCES ARE READ OR DEFINED BY COLLIMATOR

      IF (CX1.EQ.9999.) THEN
        IF (IRFILOB.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '*** DEFAULT FOR CX1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
          WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)
     &      '*** DEFAULT FOR CX1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
          WRITE(6,*)'*** CHECK INPUT FILE ***'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF
        IF (IPIN.NE.0) THEN
          CX1=PINCEN(1)-0.00001
        ELSE
          CX1=OBS1X-0.00001
        ENDIF
      ENDIF

      IF (CX2.EQ.9999.) THEN
        IF (IRFILOB.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '*** DEFAULT FOR CX2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
          WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)
     &      '*** DEFAULT FOR CX2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
          WRITE(6,*)'*** CHECK INPUT FILE ***'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF
        IF (IPIN.NE.0) THEN
          CX2=PINCEN(1)
        ELSE
          CX2=OBS1X
        ENDIF
      ENDIF

      IF (CY1.EQ.9999.) THEN
        IF (IRFILOB.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '*** DEFAULT FOR CY1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
          WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)
     &      '*** DEFAULT FOR CY1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
          WRITE(6,*)'*** CHECK INPUT FILE ***'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF
        IF (IPIN.NE.0) THEN
          CY1=PINCEN(2)
        ELSE
          CY1=OBS1Y
        ENDIF
      ENDIF !CY1

       IF (CY2.EQ.9999.) THEN
         IF (IRFILOB.NE.0) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
     &       '*** DEFAULT FOR CY2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)
     &       '*** DEFAULT FOR CY2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(6,*)'*** CHECK INPUT FILE ***'
           WRITE(6,*)
           STOP '*** PROGRAM WAVE ABORTED ***'
         ENDIF
         IF (IPIN.NE.0) THEN
           CY2=PINCEN(2)
         ELSE
           CY2=OBS1Y
         ENDIF
       ENDIF !CY2

       IF (CZ1.EQ.9999.) THEN
         IF (IRFILOB.NE.0) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
     &       '*** DEFAULT FOR CZ1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)
     &       '*** DEFAULT FOR CZ1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(6,*)'*** CHECK INPUT FILE ***'
           WRITE(6,*)
           STOP '*** PROGRAM WAVE ABORTED ***'
         ENDIF
         IF (IPIN.NE.0) THEN
           CZ1=PINCEN(3)
         ELSE
           CZ1=OBS1Z
         ENDIF
       ENDIF !CZ1

       IF (CZ2.EQ.9999.) THEN
         IF (IRFILOB.NE.0) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
     &       '*** DEFAULT FOR CZ2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)
     &       '*** DEFAULT FOR CZ2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(6,*)'*** CHECK INPUT FILE ***'
           WRITE(6,*)
           STOP '*** PROGRAM WAVE ABORTED ***'
         ENDIF
         IF (IPIN.NE.0) THEN
           CZ2=PINCEN(3)
         ELSE
           CZ2=OBS1Z
         ENDIF
       ENDIF !CZ2

       IF (WID1.EQ.9999.) THEN
         IF (IRFILOB.NE.0) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
     &       '*** DEFAULT FOR WID1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)
     &       '*** DEFAULT FOR WID1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(6,*)'*** CHECK INPUT FILE ***'
           WRITE(6,*)
           STOP '*** PROGRAM WAVE ABORTED ***'
         ENDIF
         IF (IPIN.NE.0) THEN
           WID1=PINW+4.*PINW/MPINZ
         ELSE
           WID1=0.001
         ENDIF
       ENDIF !WID1

       IF (WID2.EQ.9999.) THEN
         IF (IRFILOB.NE.0) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
     &       '*** DEFAULT FOR WID2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)
     &       '*** DEFAULT FOR WID2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(6,*)'*** CHECK INPUT FILE ***'
           WRITE(6,*)
           STOP '*** PROGRAM WAVE ABORTED ***'
         ENDIF
         IF (IPIN.NE.0) THEN
           WID2=PINW+4.*PINW/MPINZ
         ELSE
           WID2=0.001
         ENDIF
       ENDIF !WID2

       IF (HIG1.EQ.9999.) THEN
         IF (IRFILOB.NE.0) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
     &       '*** DEFAULT FOR HIG1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)
     &       '*** DEFAULT FOR HIG1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(6,*)'*** CHECK INPUT FILE ***'
           WRITE(6,*)
           STOP '*** PROGRAM WAVE ABORTED ***'
         ENDIF
         IF (IPIN.NE.0) THEN
           HIG1=PINH+4.*PINH/MPINY
         ELSE
           HIG1=0.001
         ENDIF
       ENDIF !HIG1

       IF (HIG2.EQ.9999.) THEN
         IF (IRFILOB.NE.0) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
     &       '*** DEFAULT FOR HIG2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)
     &       '*** DEFAULT FOR HIG2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(6,*)'*** CHECK INPUT FILE ***'
           WRITE(6,*)
           STOP '*** PROGRAM WAVE ABORTED ***'
         ENDIF
         IF (IPIN.NE.0) THEN
           HIG2=PINH+4.*PINH/MPINY
         ELSE
           HIG2=0.001
         ENDIF
       ENDIF !HIG2

       IF(IRFILL0.NE.0) THEN
         CALL RFILL0
       ELSE IF (ISPECDIP.LE.0) THEN
         CALL WFILL0
       ELSE IF (ISPECDIP.GT.0) THEN
         NSOURCE=NDIP
       ENDIF

       if (nsource.gt.1.and.ibrill.ne.0) then
         write(6,*) "*** Warning: More then one source. This is not compatible with IBRILL=1"
         write(6,*) "*** IBRILL is set to zero!"
         write(LUNGFO,*) "*** Warning: More then one source. This is not compatible with IBRILL=1"
         write(LUNGFO,*) "*** IBRILL is set to zero!"
         ibrill=0
       endif

       if (nsource.gt.1.and.kampli.ne.0) then
         write(6,*) "*** Error: More then one source. This is not compatible with KAMPLI"
         stop "*** Program WAVE aborted ***"
       endif

       ALLOCATE(IPOISOU(NSOURCE))

       IF (ISPECDIP.LE.0) THEN

C        SOURCEE,SOUREA... ARE ALLOCATED IN RFILL0/WFILL0

         ALLOCATE(IWARNROI(NROIA,NSOURCE))
         ALLOCATE(IPOIROI(NROIA+1))
         ALLOCATE(IZTOT(NSOURCE))
         ALLOCATE(ECSOUR(4,NSOURCE))
         ALLOCATE(ECMAX(NSOURCE))

         DO I=1,NSOURCE
           ECSOUR(1,I)=0.0d0
           ECSOUR(2,I)=0.0d0
           ECSOUR(3,I)=0.0d0
           ECSOUR(4,I)=0.0d0
           ECMAX(I)=0.0d0
         ENDDO

C--- HISTOGRAMS OF MINITRAJECTORIES OF SOURCES

         IF (IHTRACKM.NE.0) CALL HSOURCE

C---- COHERENCE OF SOURCES

         CALL COHEREN

       ENDIF   !ISPECDIP.LE.0

C----   OBSERVATION POINTS TO BE TREATED

       IF (IPIN.NE.0) THEN

         if (ipin.eq.3) then
           call pinin3
         else
           CALL PININ
         endif

       ELSE !ipin

         MPINR=0

         IF (IFOLD.EQ.2) THEN

           CALL WSIGFOL

           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'     Horizontal emittance EPS0H [m-rad]:',EPS0H
           WRITE(LUNGFO,*)'     Vertical emittance EPS0V [m-rad]:  ',EPS0V
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'     Number of sigmas for horiz. folding:'
           WRITE(LUNGFO,*)'     ',(SNGL(DGSIGZ(IS)),IS=1,NSOURCE)
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'     Number of sigmas for vert. folding:'
           WRITE(LUNGFO,*)'     ',(SNGL(DGSIGY(IS)),IS=1,NSOURCE)
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'     Sigmas of sources for horiz. folding:'
           WRITE(LUNGFO,*)'     ',(SNGL(WSIGZ(IS)),IS=1,NSOURCE)
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'     Sigmas of sources for vert. folding:'
           WRITE(LUNGFO,*)'     ',(SNGL(WSIGY(IS)),IS=1,NSOURCE)
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'     Sigmas of horizontal beam size and divergence:'
           WRITE(LUNGFO,*)
     &       '     (if not zero, sigmas for folding are calculated from these values)'
           WRITE(LUNGFO,*)'     ',(SNGL(BSIGZ(IS)),SNGL(BSIGZP(IS)),IS=1,NSOURCE)
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'     Sigmas of vertical beam size and divergence:'
           WRITE(LUNGFO,*)
     &       '     (if not zero, sigmas for folding are calculated from these values)'
           WRITE(LUNGFO,*)'     ',(SNGL(BSIGY(IS)),SNGL(BSIGYP(IS)),IS=1,NSOURCE)
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)

           IF (ISTOKES.NE.0) THEN
             WRITE(LUNGFO,*)
     &         '     Sigmas for folding of components of STOKES vector:'
             WRITE(LUNGFO,*)
     &         '     ',SNGL(WSIGZ(ISIGSTO)),SNGL(WSIGY(ISIGSTO))
           ENDIF !ISTOKES

           WRITE(LUNGFO,*)

         ENDIF !IFOLD.EQ.2

         ICBRILL=1
         CALL RFILOB
         IF (IRFILOB.NE.0.AND.IPBRILL.NE.0) THEN
           ICBRILL=IPBRILL
           IF (ICBRILL.GT.NOBSV) THEN
             WRITE(LUNGFO,*)'*** ERROR IN SPECTRUM: BAD SELECTED POINT ***'
             WRITE(LUNGFO,*)'*** CHECK INPUT IPBRILL IN WAVE.IN'
             WRITE(6,*)'*** ERROR IN SPECTRUM: BAD SELECTED POINT ***'
             WRITE(6,*)'*** CHECK INPUT IPBRILL IN WAVE.IN'
             STOP
           ENDIF
         ENDIF
       ENDIF !ipin

       IF (NOBSVZ.GT.NDOBSVZP) THEN
         WRITE(6,*)'*** DIMENSION ERROR IN SPECTRUM FOR NDOBSVZP ***'
         WRITE(6,*)'DIMENSION IS: ',NDOBSVZP
         WRITE(6,*)'CALCULATION REQUIRES: ',NOBSVZ
         WRITE(6,*)'*** CHANGE PARAMETER NDOBSVZP IN CMPARA.CMN***'
         WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
         STOP
       ENDIF   !(NOBSVZ.GT.NDOBSVZP)

       IF (NOBSVY.GT.NDOBSVYP) THEN
         WRITE(6,*)'*** DIMENSION ERROR IN SPECTRUM FOR NDOBSVYP ***'
         WRITE(6,*)'DIMENSION IS: ',NDOBSVYP
         WRITE(6,*)'CALCULATION REQUIRES: ',NOBSVY
         WRITE(6,*)'*** CHANGE PARAMETER NDOBSVYP IN CMPARA.CMN***'
         WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
         STOP
         IF (NOBSV.GT.NDOBSVP) THEN
           WRITE(6,*)'*** DIMENSION ERROR IN SPECTRUM FOR NDOBSVP ***'
           WRITE(6,*)'DIMENSION IS: ',NDOBSVP
           WRITE(6,*)'CALCULATION REQUIRES: ',NOBSV
           WRITE(6,*)'*** CHANGE PARAMETER NDOBSVP IN CMPARA.CMN***'
           WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
           STOP
         ENDIF !(NOBSV.GT.NDOBSVP)
       ENDIF   !(NOBSVY.GT.NDOBSVYP)

       ALLOCATE(schwingercen(4,nobsv,nsource))
       ALLOCATE(SPEC(NSOURCE*NOBSV*NFREQ))
       spec=0.0d0

      IF (MPINR.NE.0) THEN
        ALLOCATE(SPECRPHI(NSOURCE*NOBSVRPHI*NFREQ))
        SPECRPHI=0.0D0
      ENDIF

      ALLOCATE(SPECI(NSOURCE*NOBSV))
      ALLOCATE(SPECIV(NSOURCE*NOBSV))
      ALLOCATE(SPECPOW(NSOURCE*NOBSV))
      if (ifold.ne.0) then
        ALLOCATE(SPECPOWF(NSOURCE*NOBSV))
        ALLOCATE(SPECPOWTF(NOBSV))
      endif
      IF (MPINR.GT.0) THEN
        ALLOCATE(SPECPOWRPHI(NSOURCE*NOBSVRPHI))
        SPECPOWRPHI=0.0D0
      ENDIF

      SPECI=0.0d0
      SPECIV=0.0d0
      SPECPOW=0.0d0

      ALLOCATE(SPECPOWV(NSOURCE*NOBSVZ))
      DO I=1,NSOURCE*NOBSVZ
        SPECPOWV(I)=0.0d0
      ENDDO

      ALLOCATE(WFLUX(NSOURCE*NFREQ))
      DO I=1,NSOURCE*NFREQ
        WFLUX(I)=0.0d0
      ENDDO

      ALLOCATE(SPECTOT(NOBSV*NFREQ))
      DO I=1,NOBSV*NFREQ
        SPECTOT(I)=0.0d0
      ENDDO

      ALLOCATE(REAIMA(10,2,NOBSV*NFREQ))
      REAIMA=0.0d0

      IF (MPINR.NE.0) THEN
        ALLOCATE(REAIMARPHI(10,2,NOBSV*NFREQ))
        REAIMARPHI=0.0d0
      ENDIF

      IF (ISTOKES.NE.0) THEN
        ALLOCATE(STOKES(4,NOBSV*NFREQ))
        STOKES=0.0D0
        IF (IEFOLD.NE.0) THEN
          ALLOCATE(STOKESE(4,NOBSV*NFREQ))
          STOKESE=0.0D0
          IF (IFOLD.NE.0) THEN
            ALLOCATE(STOKESEF(4,NOBSV*NFREQ))
            STOKESE=0.0D0
          ENDIF
        ENDIF
      ENDIF

      ALLOCATE(SPECPOWVH(NSOURCE))
      ALLOCATE(WFLUXI(NSOURCE))
      DO I=1,NSOURCE
        SPECPOWVH(I)=0.0d0
        WFLUXI(I)=0.0d0
      ENDDO

      ALLOCATE(SPECTOTI(NOBSV))
      ALLOCATE(SPECPOWT(NOBSV))
      ALLOCATE(SPECPOWTgraz(NOBSV))
      ALLOCATE(ENEDOS(NOBSV))
      ALLOCATE(SPCOEFM(NOBSV))
      ALLOCATE(WOBS1(NOBSV))
      ALLOCATE(WOBS2(NOBSV))
      ALLOCATE(WOBS3(NOBSV))
      ALLOCATE(WOBS4(NOBSV))
      ALLOCATE(WOBS5(NOBSV))
      ALLOCATE(WOBS6(NOBSV))
      ALLOCATE(WOBS7(NOBSV))
      ALLOCATE(WOBS8(NOBSV))
      ALLOCATE(SPCOEF(NOBSV))
      DO I=1,NOBSV
        SPECTOTI(I)=0.0d0
        SPECPOWT(I)=0.0d0
        SPECPOWTgraz(I)=0.0d0
        ENEDOS(I)=0.0d0
        SPCOEFM(I)=0.0d0
        WOBS1(I)=0.0d0
        WOBS2(I)=0.0d0
        WOBS3(I)=0.0d0
        WOBS4(I)=0.0d0
        WOBS5(I)=0.0d0
        WOBS6(I)=0.0d0
        WOBS7(I)=0.0d0
        WOBS8(I)=0.0d0
        SPCOEF(I)=0.0d0
      ENDDO

      ALLOCATE(SPECPOWVT(NOBSVZ))
      DO I=1,NOBSVZ
        SPECPOWVT(I)=0.0d0
      ENDDO

      ALLOCATE(WFLUXT(NFREQ))

      DO I=1,NFREQ
        WFLUXT(I)=0.0D0
      ENDDO

      IF (ISTOKES.NE.0) THEN
        ALLOCATE(WSTOKES(4,NFREQ))
        ALLOCATE(STOKEC(4,NFREQ))
        DO I=1,NFREQ
          WSTOKES(1,I)=0.0D0
          WSTOKES(2,I)=0.0D0
          WSTOKES(3,I)=0.0D0
          WSTOKES(4,I)=0.0D0
          STOKEC(1,I)=0.0D0
          STOKEC(2,I)=0.0D0
          STOKEC(3,I)=0.0D0
          STOKEC(4,I)=0.0D0
        ENDDO
      ENDIF !ISTOKES

      IF (IBRILL.NE.0) THEN
        ALLOCATE(BRILLC(4,NFREQ))
        ALLOCATE(BRILLCF(4,NFREQ))  !also for ifold.eq.0
        DO I=1,NFREQ
          BRILLC(1,I)=0.0D0
          BRILLC(2,I)=0.0D0
          BRILLC(3,I)=0.0D0
          BRILLC(4,I)=0.0D0
          BRILLCF(1,I)=0.0D0
          BRILLCF(2,I)=0.0D0
          BRILLCF(3,I)=0.0D0
          BRILLCF(4,I)=0.0D0
        ENDDO
      ENDIF !IBRILL

      IF (IEFOLD.NE.0) THEN

        IF (ISTOKES.NE.0) THEN
          ALLOCATE(WSTOKESE(4,NFREQ))
          ALLOCATE(STOKECE(4,NFREQ))
          DO I=1,NFREQ
            WSTOKESE(1,I)=0.0D0
            WSTOKESE(2,I)=0.0D0
            WSTOKESE(3,I)=0.0D0
            WSTOKESE(4,I)=0.0D0
            STOKECE(1,I)=0.0D0
            STOKECE(2,I)=0.0D0
            STOKECE(3,I)=0.0D0
            STOKECE(4,I)=0.0D0
          ENDDO
        ENDIF !ISTOKES

        IF (IBRILL.NE.0) THEN
          ALLOCATE(BRILLCE(4,NFREQ))
          ALLOCATE(BRILLCEF(4,NFREQ)) !also for ifold.eq.0
          DO I=1,NFREQ
            BRILLCE(1,I)=0.0D0
            BRILLCE(2,I)=0.0D0
            BRILLCE(3,I)=0.0D0
            BRILLCE(4,I)=0.0D0
            BRILLCEF(1,I)=0.0D0
            BRILLCEF(2,I)=0.0D0
            BRILLCEF(3,I)=0.0D0
            BRILLCEF(4,I)=0.0D0
          ENDDO
        ENDIF   !IBRILL

      ENDIF !IEFOLD

      IF (IFOLD.NE.0) THEN

        ALLOCATE(SPECF(NSOURCE*NOBSV*NFREQ))
        DO I=1,NSOURCE*NOBSV*NFREQ
          SPECF(I)=0.0d0
        ENDDO

        ALLOCATE(SPECIF(NSOURCE*NOBSV))
        DO I=1,NSOURCE*NOBSV
          SPECIF(I)=0.0d0
        ENDDO

        ALLOCATE(SPECIVF(NSOURCE*NOBSVY))
        DO I=1,NSOURCE*NOBSVY
          SPECIVF(I)=0.0d0
        ENDDO

        ALLOCATE(WFLUXF(NSOURCE*NFREQ))
        DO I=1,NSOURCE*NFREQ
          WFLUXF(I)=0.0d0
        ENDDO

        ALLOCATE(DOBUFF(NOBSV))
        ALLOCATE(DOBUFF1(NOBSV))
        ALLOCATE(DOBUFF2(NOBSV))

        ALLOCATE(SPECTOTF(NOBSV*NFREQ))
        DO I=1,NOBSV*NFREQ
          SPECTOTF(I)=0.0D0
        ENDDO

        IF (ISTOKES.NE.0) THEN
          ALLOCATE(STOKESF(4,NOBSV*NFREQ))
          DO I=1,NOBSV*NFREQ
            STOKESF(1,I)=0.0d0
            STOKESF(2,I)=0.0d0
            STOKESF(3,I)=0.0d0
            STOKESF(4,I)=0.0d0
          ENDDO
        ENDIF

        ALLOCATE(WFLUXIF(NSOURCE))
        DO I=1,NSOURCE
          WFLUXIF(I)=0.0d0
        ENDDO

        ALLOCATE(SPECTOTIF(NOBSV))
        DO I=1,NOBSV
          SPECTOTIF(I)=0.0d0
        ENDDO

        ALLOCATE(WFLUXTF(NFREQ))
        DO I=1,NFREQ
          WFLUXTF(I)=0.0D0
        ENDDO

        IF (ISTOKES.NE.0) THEN
          ALLOCATE(WSTOKESF(4,NFREQ))
          ALLOCATE(STOKECF(4,NFREQ))
          DO I=1,NFREQ
            WSTOKESF(1,I)=0.0d0
            STOKECF(1,I)=0.0d0
            WSTOKESF(2,I)=0.0d0
            STOKECF(2,I)=0.0d0
            WSTOKESF(3,I)=0.0d0
            STOKECF(3,I)=0.0d0
            WSTOKESF(4,I)=0.0d0
            STOKECF(4,I)=0.0d0
          ENDDO
        ENDIF  !ISTOKES

        IF (IEFOLD.NE.0) THEN

          IF (ISTOKES.NE.0) THEN
            ALLOCATE(WSTOKESEF(4,NFREQ))
            ALLOCATE(STOKECEF(4,NFREQ))
            DO I=1,NFREQ
              WSTOKESEF(1,I)=0.0d0
              STOKECEF(1,I)=0.0d0
              WSTOKESEF(2,I)=0.0d0
              STOKECEF(2,I)=0.0d0
              WSTOKESEF(3,I)=0.0d0
              STOKECEF(3,I)=0.0d0
              WSTOKESEF(4,I)=0.0d0
              STOKECEF(4,I)=0.0d0
            ENDDO
          ENDIF   !ISTOKES

        ENDIF  !IEFOLD
      ENDIF !IFOLD

      if (ipin.ne.3) then
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'      selected observation point:'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'      '
     &    ,SNGL(OBSV(1,ICBRILL)),SNGL(OBSV(2,ICBRILL)),SNGL(OBSV(3,ICBRILL))
        WRITE(LUNGFO,*)
      endif

      CALL CHECKOB

C--- LOOP OVER ALL SOURCES, EVALUATE INTEGRALS

      IF (IAMPSKIP.NE.0) THEN
        ALLOCATE(AFREQ(6,NOBSV*NFREQ))
        AFREQ=(0.0D0,0.0D0)
        IF (MPINR.GT.0) THEN
          ALLOCATE(AFREQRPHI(6,NOBSVRPHI*NFREQ))
          afreqrphi=(0.0d0,0.0d0)
        ENDIF
        ALLOCATE(EXPOM2P0(2,NFREQ))
      ENDIF !(IAMPSKIP.NE.0)

      IF (NLPOI.EQ.0) nlpoi=(xstop-xstart)*myinum+1

      IF (
     &    ISPECANA.EQ.0
     &    .AND.
     &    IDESYNC.EQ.0
     &    .AND.
     &    ISPECDIP.EQ.0
     &    .AND.
     &    (IRFILSP0.EQ.0.OR.IRFILSTO.EQ.0.AND.ISTOKES.NE.0)
     &    .AND.
     &    IAMPSKIP.EQ.0
     &    ) THEN

C DEFAULT FOR NLPOI

        IF (NLPOI.EQ.-9999) CALL SETNLPOI

C STORE VALUES, REINITIALIZE SOURCEE

        NDWSOU=MAX(NLPOI,NCO)+NBADDP
        NDARGU=NDWSOU
        NLPOIO=NLPOI
        NBUFF=1

        IF (ISPECMODE.EQ.3.OR.ISPECMODE.EQ.4) THEN
          ALLOCATE(REARGUM(11,NDWSOU))
        ENDIF

        IF (ISPECMODE.EQ.1.OR.ISPECMODE.EQ.3.OR.ISPECMODE.EQ.4) THEN
          ALLOCATE(WSOU(3,5,NDWSOU))
        ENDIF

C BEGIN OF RAW SPECTRUM CALCULATION

        IF (NSOURCE.GE.1.and.icluster.lt.0) THEN
          CALL date_and_time(dtday,dttime,dtzone,idatetime)
          WRITE(6,*)
          WRITE(6,*)'     Starting spectrum calculations '
     &      ,dttime(1:2),':',dttime(3:4),':',dttime(5:6)
          WRITE(6,*)
        ENDIF

        DO ISOUR=1,NSOURCE
CERR101292      DO JC=1,3

          DO JC=1,4
            DO IC=1,3
              SOURCEAO(IC,JC,ISOUR)=SOURCEA(IC,JC,ISOUR)
              SOURCEEO(IC,JC,ISOUR)=SOURCEE(IC,JC,ISOUR)
            ENDDO
          ENDDO

          DO JC=1,1
            DO IC=1,3
              SOURCEE(IC,JC,ISOUR)=SOURCEA(IC,JC,ISOUR)+
     &          (SOURCEEO(IC,JC,ISOUR)-SOURCEAO(IC,JC,ISOUR))/NBUFF
            ENDDO
          ENDDO

        ENDDO   !ISOUR

        ISOURO=0

        IF (IAMPSKIP.EQ.0) THEN
          ALLOCATE(AFREQ(6,NOBSV*NFREQ))
          AFREQ=(0.0D0,0.0D0)
          ALLOCATE(EXPOM2P0(2,NFREQ))
          IF (MPINR.GT.0) THEN
            ALLOCATE(AFREQRPHI(6,NOBSVRPHI*NFREQ))
            afreqrphi=(0.0d0,0.0d0)
          ENDIF
        ENDIF !(IAMPSKIP.EQ.0)
        ALLOCATE(TBUFF(NOBSV))
        IF (ISPECMODE.EQ.3.OR.ISPECMODE.EQ.4) THEN
          ALLOCATE(NARGUM(NOBSV,NSOURCE))
        ELSE IF (ISPECMODE.EQ.1.OR.ISPECMODE.EQ.2) THEN
          ALLOCATE(DARGEXPO(6,NOBSV))
        ENDIF

        IF (IAMPLI.LT.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'      repetition of amplitude activated:'
          WRITE(LUNGFO,*)
     &      '      A -> A * (1 + exp(i*phi) + exp(i*2*phi)...'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'      IAMPLI, AMPSHIFT(1):',IAMPLI,AMPSHIFT(1)
          WRITE(LUNGFO,*)
     &      '      Total phase-advance [nm] and corresponding photon energy [eV]:'
          WRITE(LUNGFO,*)
     &      '      ',(AMPSHIFT(1)/2.0D0/DMYGAMMAP**2+HTRA2I)*1.0D9
     &      ,CLIGHT1*HPLANCK1/ECHARGE1/(AMPSHIFT(1)/2.0D0/DMYGAMMAP**2+HTRA2I)
c          WRITE(LUNGFO,*)
c     &      '      MYINUM has to be tuned,'
c          WRITE(LUNGFO,*)
c     &      '      since phase advance is calculated form trajectory.'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'      repetition of amplitude activated:'
          WRITE(6,*)
     &      '      A -> A * (1 + exp(i*phi) + exp(i*2*phi)...'
          WRITE(6,*)
          WRITE(6,*)'      IAMPLI, AMPSHIFT(1):',IAMPLI,AMPSHIFT(1)
          WRITE(6,*)
     &      '      Total phase-advance [nm] and corresponding photon energy [eV]:'
          WRITE(6,*)
     &      '      ',(AMPSHIFT(1)/2.0D0/DMYGAMMAP**2+HTRA2I)*1.0D9
     &      ,CLIGHT1*HPLANCK1/ECHARGE1/(AMPSHIFT(1)/2.0D0/DMYGAMMAP**2+HTRA2I)
          WRITE(6,*)
c          WRITE(6,*)
c     &      '*****>>>>      MYINUM has to be tuned,'
c          WRITE(6,*)
c     &      '      since phase advance is calculated from trajectory.'
c          WRITE(6,*)
c          CALL UTIL_WAIT_1
          IF (AMPRAN.NE.0.D0) THEN
            IF (ISOUR.EQ.1) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'      phase errors for repetition activated:'
              WRITE(LUNGFO,*)
     &          '      A -> A * (1 + exp(i*phi*xran1) + exp(i*2*phi*xran2)...'
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'      IAMPSEED: ',IAMPSEED
              WRITE(LUNGFO,*)
            ENDIF !ISOUR
            ALLOCATE(XRANA(-IAMPLI))
            IF (IAMPSEED.NE.0) CALL RMARIN(IAMPSEED,NTOTIN,NTOT2IN)
            CALL RNORML(XRANA,-IAMPLI,rr)
            RMS=0.0d0
            DO IREP=1,-IAMPLI
              XRANA(IREP)=AMPRAN*XRANA(IREP)
              RMS=RMS+XRANA(IREP)**2
            ENDDO
            RMS=SQRT(RMS/(-IAMPLI))
            WRITE(LUNGFO,*)
     &        '      rel. rms phase AMPRAN (input): ',SNGL(AMPRAN)
            WRITE(LUNGFO,*)
     &        '      rel. rms phase error 1. source (from generated errors): '
     &        ,SNGL(RMS)
          ENDIF   !(AMPRAN.NE.0.D0)
        ENDIF !IAMPLI

        DO ISOUR=1,NSOURCE

          IF (ISPECMODE.EQ.1.OR.ISPECMODE.EQ.2) THEN
            if (icluster.gt.0) goto 1357
+self,if=wsou.
            IF (ISPECMODE.EQ.2) THEN
              call sourcesteps(isour,ndwsou)
              ALLOCATE(WSOU(3,5,NDWSOU))
              nsadd=1
            endif
+self,if=-wsou.
            print*,'******************************************'
            print*,'CMZ-Selection wsou not active!!'
            print*,'******************************************'
+self. if=wsou.
            if (iundulator.ne.2) then
+self,if=omp.
              if (iomp.eq.0.or.(ipin.eq.0.and.mthreads.eq.0)) then
+self.
                CALL SOUINTALL(ISOUR)
+self,if=omp.
              else
                CALL SOUINTALL_omp(ISOUR)
              endif
+self.
            endif
+self,if=wsou.
            IF (ISPECMODE.EQ.2) THEN
              deALLOCATE(WSOU)
            endif
+self. if=wsou.
            GOTO 1357
          ENDIF !ISPECMODE

          IF (ISOUR.EQ.2) THEN
            WRITE(6,*)' '
            WRITE(6,*)'     sources done and time:'
            WRITE(6,*)' '
          ENDIF !NSOURCE

          DO IOBSV=1,NOBSV
            TBUFF(IOBSV)=0.0
          ENDDO   !IOBSV

          MSADD=0
          DO IBUFF=1,NBUFF

            IF (MSADD.EQ.1) THEN
              IF (AMPRAN.NE.0.D0.AND.IAMPLI.LT.0) THEN
                DEALLOCATE(XRANA)
              ENDIF   !(AMPRAN.NE.0.D0)
              GOTO 1357 !EXIT IBUFF LOOP
            ENDIF

            IF (IBUFF.EQ.NBUFF.OR.MSADD.EQ.-1) THEN
              NSADD=1
              MSADD=1
            ELSE
              NSADD=0
            ENDIF

            IF (ISPECMODE.EQ.3) THEN
              CALL TRACKS(ISOUR)   !TRACKING OF SOURCE
            ELSE IF (ISPECMODE.EQ.4) THEN
              CALL TRACKSOLD(ISOUR)   !TRACKING OF SOURCE
            ELSE
              PRINT*, '*** ERROR IN SPECTRUM: BAD ISPECMODE: ',ISPECMODE
              STOP '*** PROGRAMM WAVE ABORTED ***'
            ENDIF

            CALL SOUINT(ISOUR,IBUFF)   !INTEGRATION

            DO JC=1,1
              DO IC=1,3
C SOURCEA IS RECALCULATED IN SR TRACKS
                SOURCEE(IC,JC,ISOUR)=SOURCEA(IC,JC,ISOUR)+
     &            (SOURCEEO(IC,JC,ISOUR)-SOURCEAO(IC,JC,ISOUR))/NBUFF
              ENDDO
            ENDDO

            IF (SOURCEE(1,1,ISOUR).GT.SOURCEEO(1,1,ISOUR)) THEN

              DO JC=1,1
                DO IC=1,3
                  SOURCEE(IC,JC,ISOUR)=SOURCEEO(IC,JC,ISOUR)
                ENDDO
              ENDDO

              IF (MSADD.EQ.0) MSADD=-1

            ENDIF !(SOURCEE(1,1,ISOUR).GT.SOURCEEO(1,1,ISOUR))

            IF (MSADD.NE.1
     &          .AND.SOURCEA(1,1,ISOUR).GE.SOURCEE(1,1,ISOUR)) THEN
              WRITE(LUNGFO,*)'*** ERROR IN SPECTRUM:'
              WRITE(LUNGFO,*)'SOMETHING WRONG WITH SOURCE BUFFER'
              WRITE(LUNGFO,*)
     &          'CHANGE INTEGRATION BUFFER OR CHECK SOURCE CODE'
              WRITE(LUNGFO,*)
     &          'IBUFF,NBUFF,SOURCEA(1,1,ISOUR),SOURCEE(1,1,ISOUR)'
              WRITE(LUNGFO,*)IBUFF,NBUFF
              WRITE(LUNGFO,*)SOURCEA(1,1,ISOUR),SOURCEE(1,1,ISOUR)
              WRITE(6,*)'*** ERROR IN SPECTRUM:'
              WRITE(6,*)'SOMETHING WRONG WITH SOURCE BUFFER'
              WRITE(6,*)
     &          'CHANGE INTEGRATION BUFFER OR CHECK SOURCE CODE'
              WRITE(6,*)
     &          'IBUFF,NBUFF,SOURCEA(1,1,ISOUR),SOURCEE(1,1,ISOUR)'
              WRITE(6,*)IBUFF,NBUFF
              WRITE(6,*)SOURCEA(1,1,ISOUR),SOURCEE(1,1,ISOUR)
              STOP
            ENDIF

            ISOURO=ISOUR

          ENDDO   !IBUFF

1357    CONTINUE

        if (kampli.ne.0) then

          if (ibunch.eq.0) then
            nbunch=mbuncho
            neinbunch=meinbuncho
            ibunch=ibuncho
            ihbunch=ihbuncho
          endif

          if (ipin.eq.0) then
            call pinin ! to get pincen etc.
            nobsv=1
            nobsvz=1
            nobsvy=1
            icbrill=1
            obsv(:,1)=pincen(:)
          endif

          call amprep_omp

          pow_u=pow_u*1.0d6
          stokes_u=stokes_u*1.0d6

          fbunch_u(4:14,:)=fbunch_u(4:14,:)/1000.0d0
          fbunch_u(17:19,:)=fbunch_u(17:19,:)/1000.0d0
          fbunch_u(22:26,:)=fbunch_u(22:26,:)*1.0d3
          fbunch_u(30:41,:)=fbunch_u(30:41,:)*1.0d3
          arad_u=arad_u*1000.0d0

          specpow=pow_u
          spec(:)=stokes_u(1,:)
          stokes=stokes_u

          do iobsv=1,nobsv
            do ifr=1,nfreq
              iobfr=iobsv+nobsv*(ifr-1)
              reaima(1:3,1,iobfr)=dreal(arad_u(1:3,iobfr))
              reaima(1:3,2,iobfr)=dimag(arad_u(1:3,iobfr))
              reaima(6:8,1,iobfr)=dreal(arad_u(4:6,iobfr))
              reaima(6:8,2,iobfr)=dimag(arad_u(4:6,iobfr))
            enddo
          enddo

          if (ibunch.ne.0) then
            do i=1,nbunch*neinbunch*nfreq
              if (fbunch_u(21,i).ne.0.0d0) then
                call hfm(nidbunch,fbunch_u(:,i))
              endif
            enddo
          endif
        endif

        if (icluster.ne.0) then
          call wpamp
        endif

        IF (ISOUR.EQ.1.and.nsource.gt.1) THEN
          WRITE(6,*)' '
          WRITE(6,*)' '
          WRITE(6,*)' sources treated so far:'
          WRITE(6,*)' '
        ENDIF

c        CALL APHASE(ISOUR)

        IF (nsource.gt.1) THEN
          CALL date_and_time(dtday,dttime,dtzone,idatetime)

          WRITE(6,2000)ISOUR,NSOURCE,dttime(1:2),dttime(3:4),dttime(5:6)
2000      FORMAT(10X,I4,' of',I4,2X,A,':',A,':',A)
        ENDIF


      ENDDO !LOOP OVER SOURCES

      if (abs(ifold).eq.1) CALL AMPFOLD

C     CALL LIB$SHOW_TIMER

C RESTORE OLD VALUES

      NLPOI=NLPOIO

      IF(ISPECDIP.EQ.0.and.ipin.eq.0) THEN
        if (iundulator.eq.0) then
          CALL SPECDIPA  ! To calculate schwingercen for powgraz
        else
          DO ISOUR=1,NSOURCE
            do jc=1,nobsv
              DO IC=1,3
                schwingercen(IC,JC,ISOUR)=(SOURCEAO(IC,1,ISOUR)+
     &            SOURCEEO(IC,1,ISOUR))/2.0d0
              enddo
            enddo
          enddo
        endif
      ENDIF

      DO ISOUR=1,NSOURCE
CERR101292      DO JC=1,3
        DO JC=1,4
          DO IC=1,3
            SOURCEA(IC,JC,ISOUR)=SOURCEAO(IC,JC,ISOUR)
            SOURCEE(IC,JC,ISOUR)=SOURCEEO(IC,JC,ISOUR)
          ENDDO
        ENDDO
        IPOISOU(ISOUR)=IZTOT(ISOUR)
      ENDDO   !ISOUR

      ELSE IF(ISPECANA.NE.0)   THEN !ISPECANA

        CALL SPECANA      !USER SUPPLIED SPECTRUM
C                  !(E.G. FOR TESTING)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** MESSAGE SR SPECTRUM ***'
        WRITE(LUNGFO,*)
     &    'FLUX OVERWRITTEN BY SR SPECANA (FLAG ISPECANA)'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)

      ELSE IF(IDESYNC.NE.0)   THEN !ISPECANA

        CALL SYNC_SPEC      !SPECTRUM FROM PROGRAM DESYNC

      ELSE IF(ISPECDIP.GT.0)   THEN !ISPECANA

        CALL SPECDIP  !DIPOL SPECTRUM ACCORDING TO BESSEL FUNCTIONS

      ELSE IF(ISPECDIP.LT.0)   THEN !ISPECANA

        CALL SPECDIPA  !DIPOL SPECTRUM ACCORDING TO BESSEL FUNCTIONS FOR
                       !GIVEN SOURCES
      ELSE

        IF (IRFILSP0.NE.0) CALL RFILSP0
        IF (IRFILSTO.NE.0) CALL RFILSTO

      ENDIF !ISPECANA

C }CHANGE FROM CYLINDRICAL TO CARTHESIAN GRID

      IF (IAMPLI.gt.0.or.iamprep.lt.0) CALL ADDAMPLI
      IF (IAMPLI.LT.0) THEN
        FACAMPLI=-IAMPLI
      ELSE
        FACAMPLI=1.D0
      ENDIF

C END OF RAW SPECTRUM CALCULATION

      IF (IABEND.EQ.6) then
        iroottrees=0
        RETURN
      endif

C--- TAKE FILTER INTO ACCOUNT

      IF (IFILTER.GT.0) THEN
        IF (IFILMUL.EQ.0) THEN
          CALL FILTER !ARRAY SPEC IS OVERWRITTEN
        ELSE
          ABSMUTOT=0.0D0
          OPEN(UNIT=LUNAM,FILE=FILEAM,STATUS='OLD')
          DO I=1,IFILMUL
            READ(LUNAM,*)ABSTHI,FILEABS
            CALL FILTER !ARRAY SPEC IS OVERWRITTEN
            ABSMUTOT=ABSMUTOT+ABSMU
          ENDDO !IFILMUL
          CLOSE(LUNAM)
        ENDIF !IFILTER

      ENDIF !IFILTER

C--- TAKE PHOTO YIELD INTO ACCOUNT

      IF (IEFFI.NE.0) THEN
        CALL EFFI !ARRAY SPEC IS OVERWRITTEN
      ENDIF !IEFFI

C--- LOOP OVER ALL SOURCES, ADD UP CONTRIBUTIONS OF EVALUATED INTEGRALS

      if (iomp.eq.0) CALL SOUADD

C--- FLUX TRHOUGH PINHOLE

      IF(IPINo.GT.0) THEN

        print*
        call zeit(6)
        print*,"     Start integration over pinhole"

+self,if=omp.
        if (iomp.eq.0) then
+self.

          DO IFREQ=1,NFREQ

            IF(IPIN.NE.2.and.ipin.ne.3) THEN !SPECTOT IN SOUADD CALCULATED

              DO IY=1,NOBSVY
                DO IZ=1,NOBSVZ
                  IOBSV=(IY-1)*NOBSVZ+IZ
                  SPECTOT(IOBSV+NOBSV*(IFREQ-1))=0.0D0
                ENDDO   !IZ
              ENDDO   !IY

            ENDIF !IPIN.NE.2

            WFLUXT(IFREQ)=0.0

            DO ISOUR=1,NSOURCE

              IF(IPIN.NE.2.and.ipin.ne.3) THEN

C--- SPLINE INTERPOLATION INSIDE PINHOLE

                IF (IUSEM.EQ.0) THEN
                  IF (IPINCIRC.EQ.0.OR.IPINCIRC*IRPHI.NE.0)
     &              CALL PSPLINE(ISOUR,IFREQ)
                ENDIF

C--- INTEGRATION OF FLUX IN PINHOLE (BLENDE)

                IF (IUSEM.EQ.0) THEN

c                if (isour.eq.1.and.ifreq.eq.1) then
c                  caLL Zeit(6)
c                  print*,"     Starting integration over pinhole"
c                endif

                  CALL BLENDE(ISOUR,IFREQ)
                  IF(ISOUR.EQ.NSOURCE.AND.ISTOKES.NE.0) then
                    CALL BLENSTO(IFREQ)
                  endif

                ELSE

                  ICONV=0
                  IF (IPINCIRC.EQ.0) THEN
                    IFLUSS=1
                  ELSE  !IPINCIRC
                    IFLUSS=2
                  ENDIF !IPINCIRC
                  CALL USMCON2

                ENDIF

                DO IY=1,NOBSVY
                  DO IZ=1,NOBSVZ
                    IOBSV=(IY-1)*NOBSVZ+IZ
                    IOBFR=IOBSV+NOBSV*(IFREQ-1)
                    SPECTOT(IOBFR)=SPECTOT(IOBFR)+
     &                SPEC(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))
                  ENDDO   !IZ
                ENDDO   !IY

              else if (ipin.eq.3) then

                CALL BLENDE(ISOUR,IFREQ)
                IF(ISOUR.EQ.NSOURCE.AND.ISTOKES.NE.0)
     &            CALL BLENSTO(IFREQ)
              ENDIF !(IPIN.GT.0)

              WFLUXT(IFREQ)=WFLUXT(IFREQ)+WFLUX(ISOUR+NSOURCE*(IFREQ-1))

            ENDDO !NSOURCE
          ENDDO !IFREQ

+self,if=omp.
        else !if (iomp.eq.0) then

c          if (ipincirc.eq.0) then
            call blendfreq_omp
c          else
c            call blendcircfreq_omp
c          endif

          if (istokes.ne.0) then
            call blenstofreq_omp
          endif

        endif !iomp
+self.

C--- FOLD INTENSITY DISTRIBUTIONS

        IF (IFOLD.NE.0.AND.IFOLD.NE.2) THEN
          print*,""
          call zeit(6)
          print*,"     Starting folding procedure"
          IF (IUSEM.EQ.0) THEN
            ALLOCATE(COFOLD(4,4,NOBSV))
c            caLL Zeit(6)
c            print*,"     Starting folding procedure"
            IF (IFOLD.EQ.-2) ALLOCATE(SPCOEFU(3,NOBSV))
            IF (ABS(IFOLD).EQ.1) then
+self,if=omp.
              if (iomp.eq.0) then
+self.
                CALL WFOLD
                IF (ISTOKES.NE.0) CALL WFOLDSTO
+self,if=omp.
              else
                call wfold_omp
                IF (ISTOKES.NE.0) then
                  CALL WFOLDSTO_omp
                endif
              endif
+self.,if=omp.
            endif
            call powfold
          ELSE !IUSEM
            ICONV=0
            IFLUSS=0
            IF (ISPECANAF.NE.0) THEN
              CALL SPECANAF
            ENDIF
            CALL USMCON2
          ENDIF !IUSEM
        ENDIF !IFOLD

      print*
      call zeit(6)
      print*,"     Finished integration over pinhole"

      ENDIF !IPIN

C--- INTEGRATE SPECTRUM OVER ALL FREQUENCIES

      IF (ISPECINT.NE.0) THEN
        CALL SPECINT
        IF (IFOLD.NE.0) CALL SPECINTF
        IF (IPIN.NE.0) THEN
          CALL CRIFREQ
        ELSE
          CALL CRIFREQS(1)
        ENDIF
      ENDIF

C--- CONVERT FREQUENCES FROM ELECTRONVOLT TO NANOMETER

C260194  IF (IUNIT.EQ.1) CALL CONVUN

      IF (ISTOKES.NE.0) THEN
        ICEN=ICBRILL
        DO IFREQ=1,NFREQ
          DO IC=1,4
            STOKEC(IC,IFREQ)=STOKES(IC,ICEN+NOBSV*(IFREQ-1))
          ENDDO !IC
        ENDDO !NFREQ
      ENDIF !ISTOKES

      IF (ISTOKES.NE.0.AND.IFOLD.NE.0) THEN
        ICEN=ICBRILL
        DO IFREQ=1,NFREQ
          DO IC=1,4
            STOKECF(IC,IFREQ)=STOKESF(IC,ICEN+NOBSV*(IFREQ-1))
          ENDDO !NOBSV
        ENDDO !NFREQ
      ENDIF !ISTOKES

C--- WRITE RESULTS TO FILE

c      print*
c      call zeit(6)
c      print*,"     Writing results to files"

      IF (ISPECDIP.EQ.0) THEN

        WRITE (LUNGFO,*)
        WRITE (LUNGFO,*)
     &'     Source number, mean mag. field (sign from By), abs. mean and rel. rms'
        WRITE (LUNGFO,*)
     &'     for sources, and critical photon energy [eV] or wavelength [nm]'
        WRITE (LUNGFO,*)
     &    '     (with respect to abs. mean):'
        WRITE (LUNGFO,*)

        DO ISOUR=1,NSOURCE
          WRITE (LUNGFO,*)ISOUR
     &      ,SNGL(ECSOUR(4,ISOUR))
     &      ,SNGL(ECSOUR(1,ISOUR))
     &      ,SNGL(ECSOUR(3,ISOUR))
     &      ,SNGL(ECSOUR(2,ISOUR))
        ENDDO !ISOUR

        WRITE (LUNGFO,*)
        WRITE (LUNGFO,*)'     Photon energy cut-off (SPECCUT):',SNGL(SPECCUT)
        WRITE (LUNGFO,*)
        WRITE (LUNGFO,*)
     &    '     Max. field and photon energy cuts for source points:'
        WRITE (LUNGFO,*)
        DO ISOUR=1,NSOURCE
          WRITE (LUNGFO,*)ISOUR
     &      ,SNGL(ECMAX(ISOUR))
     &      ,SNGL(SPECCUT*ecdipev1*DMYENERGY**2*ECMAX(ISOUR))
        ENDDO !ISOUR

      ENDIF !ISPECDIP

      IF(IPIN*ISPECINT.NE.0) THEN

        WRITE (LUNGFO,*)
        WRITE (LUNGFO,*)
     &    '     Critical photon energy or wavelength of calculated flux through'

        IF (IFOLD.NE.0) THEN

          IF (IUNIT.EQ.0)
     &      WRITE (LUNGFO,*)'     pinhole (raw and folded):'
     &      ,SNGL(FREQC),SNGL(FREQCF)
          IF (IUNIT.NE.0)
     &      WRITE (LUNGFO,*)'     pinhole (raw and folded):'
     &      ,SNGL(WELLENC),SNGL(WELLENCF)

        ELSE  !IFOLD

          IF (IUNIT.EQ.0)
     &      WRITE (LUNGFO,*)'     pinhole:',SNGL(FREQC)
          IF (IUNIT.NE.0)
     &      WRITE (LUNGFO,*)'     pinhole:',SNGL(WELLENC)
        ENDIF !IFOLD

        WRITE (LUNGFO,*)

        WRITE (LUNGFO,*)

      ENDIF !IPIN*ISPECINT

      IF(IWFILSP0.NE.0) THEN

        OPEN(UNIT=LUNSP0,FILE=FILESP0)

        WRITE(LUNSP0,*)ICODE,' ',CODE
        WRITE(LUNSP0,*)
        WRITE(LUNSP0,*)NSOURCE,NOBSV,NFREQ,IFREQ2P
        WRITE(LUNSP0,*)NOBSVZ,NOBSVY,MOBSVZ,MOBSVY
        WRITE(LUNSP0,*)MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY
        WRITE(LUNSP0,*)
        WRITE(LUNSP0,*)PINW,PINH,PINR
        WRITE(LUNSP0,*)OBSVDZ,OBSVDY
        WRITE(LUNSP0,*)

        WRITE(LUNSP0,*)(OBSVZ(IO),IO=1,NOBSVZ)
        WRITE(LUNSP0,*)
        WRITE(LUNSP0,*)(OBSVY(IO),IO=1,NOBSVY)
        WRITE(LUNSP0,*)

        DO IO=1,NOBSV
          WRITE(LUNSP0,*)(OBSV(IX,IO),IX=1,3)
          DO IFR=1,NFREQ
            IF (IUNIT.EQ.0) THEN !260194
              WRITE(LUNSP0,*)FREQ(IFR),
     &          (SPEC(IS+NSOURCE*(IO-1+NOBSV*(IFR-1))),IS=1,NSOURCE)
     &          ,SPECTOT(IO+NOBSV*(IFR-1))
            ELSE !IUNIT
              WRITE(LUNSP0,*)WELLEN(IFR),
     &          (SPEC(IS+NSOURCE*(IO-1+NOBSV*(IFR-1))),IS=1,NSOURCE)
     &          ,SPECTOT(IO+NOBSV*(IFR-1))
            ENDIF !IUNIT
          ENDDO !NFREQ
        ENDDO !NOBSV

        CLOSE(LUNSP0)

      ENDIF !IWFILSP0

      IF(IPHASEANA.NE.0) THEN
        CALL PHASEANA
      ENDIF !(IPHASEANA.NE.0)

      IF(IPHASE.NE.0) THEN
c        if (mthreads.eq.0) then
c          CALL PHASE
c        else
          CALL PHASE_omp
c        endif
      ENDIF !(IPHASE.NE.0)

      IF(IWFILRAY.NE.0) THEN

        OPEN(UNIT=LUNRAY,FILE=FILERAY,STATUS='NEW')

        WRITE(LUNRAY,*)MOBSVZ,MOBSVY,ICODE,SNGL(FREQ(1)),' WAVE'

        DRAY=PINCEN(1)
        DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
          YRAY=OBSVY(IY)
          THERAY=ATAN(YRAY/DRAY)*10000. !*10000 mm
          DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
            IO=(IY-1)*NOBSVZ+IZ
            ZRAY=OBSVZ(IZ)
            PHIRAY=ATAN(ZRAY/DRAY)*10000.

            RAY=STOKES(1,IO)
     &        /DMYCUR*0.1
     &        /BANWID*0.001
     &        *OBSVDZ*OBSVDY
            RAY1=STOKES(2,IO)
     &        /DMYCUR*0.1
     &        /BANWID*0.001
     &        *OBSVDZ*OBSVDY
            RAY2=STOKES(3,IO)
     &        /DMYCUR*0.1
     &        /BANWID*0.001
     &        *OBSVDZ*OBSVDY
            RAY3=STOKES(4,IO)
     &        /DMYCUR*0.1
     &        /BANWID*0.001
     &        *OBSVDZ*OBSVDY

            IF (RAY.NE.0.0) THEN
              RAY1N=RAY1/RAY
              RAY2N=RAY2/RAY
              RAY3N=RAY3/RAY
            ELSE
              RAY1N=0.0
              RAY2N=0.0
              RAY3N=0.0
            ENDIF   !RAY

C     RAY/PHIRAY/THERAY IS NUMBER OF PHOTONS PER mm**2 PER sec PER 0.001BW
C     PER 100mA IN 10m DISTANCE !?; COORDINATES VALUES IN mm ON FILE

C ABSPRACHE MIT FRANZ            WRITE(LUNRAY,7788) PHIRAY,THERAY,RAY,-RAY1N,RAY2N,RAY3N
      WRITE(LUNRAY,7788) PHIRAY,THERAY,RAY,RAY1N,RAY2N,RAY3N
7788        FORMAT(6(1PE12.4))

          ENDDO !IZ
        ENDDO !IY

        CLOSE(LUNRAY)

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     Data-file written for program RAY'
        WRITE(LUNGFO,*)'     File: ',FILERAY
        WRITE(LUNGFO,*)'     (Device center is assumed at (0,0,0)'
        IF (IUNIT.EQ.0) THEN !260194
          WRITE(LUNGFO,*)'     Photon energy:',SNGL(FREQ(1))
        ELSE
          WRITE(LUNGFO,*)'     Photon energy:',SNGL(WELLEN(1))
        ENDIF
        WRITE(LUNGFO,*)

        WRITE(6,*)
        WRITE(6,*)'     Data-file written for program RAY'
        WRITE(6,*)'     File: ',FILERAY
        WRITE(6,*)'     (Device center is assumed at (0,0,0)'
        IF (IUNIT.EQ.0) THEN !260194
          WRITE(6,*)'     Photon energy:',SNGL(FREQ(1))
        ELSE
          WRITE(6,*)'     Photon energy:',SNGL(WELLEN(1))
        ENDIF
        WRITE(6,*)

      ENDIF !IWFILRAY

      IF(IWFILSTO.NE.0.AND.ISTOKES.NE.0) THEN

        OPEN(UNIT=LUNSTO,FILE=FILESTO)

        WRITE(LUNSTO,*)ICODE,' ',CODE
        WRITE(LUNSTO,*)
        WRITE(LUNSTO,*)NSOURCE,NOBSV,NFREQ,IFREQ2P
        WRITE(LUNSTO,*)NOBSVZ,NOBSVY,MOBSVZ,MOBSVY
        WRITE(LUNSTO,*)MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY
        WRITE(LUNSTO,*)
        WRITE(LUNSTO,*)PINW,PINH,PINR
        WRITE(LUNSTO,*)OBSVDZ,OBSVDY
        WRITE(LUNSTO,*)

        WRITE(LUNSTO,*)(OBSVZ(IO),IO=1,NOBSVZ)
        WRITE(LUNSTO,*)
        WRITE(LUNSTO,*)(OBSVY(IO),IO=1,NOBSVY)
        WRITE(LUNSTO,*)

        DO IO=1,NOBSV
          WRITE(LUNSTO,*)(OBSV(IX,IO),IX=1,3)
          DO IFR=1,NFREQ
            IF (IUNIT.EQ.0) THEN !260194
              IOBFR=IO+NOBSV*(IFR-1)
              WRITE(LUNSTO,*)FREQ(IFR),(STOKES(IS,IOBFR),IS=1,4)
            ELSE
              WRITE(LUNSTO,*)WELLEN(IFR),(STOKES(IS,IOBFR),IS=1,4)
            ENDIF
          ENDDO !NFREQ
        ENDDO !NOBSV

        CLOSE(LUNSTO)

      ENDIF !IWFILSTO

      IF(IFOLD.NE.0 .AND. IWFILSPF.NE.0) THEN

        OPEN(UNIT=LUNSPF,FILE=FILESPF)

        WRITE(LUNSPF,*)ICODE,' ',CODE
        WRITE(LUNSPF,*)
        WRITE(LUNSPF,*)NSOURCE,NOBSV,NFREQ
        WRITE(LUNSPF,*)NOBSVZ,NOBSVY,MOBSVZ,MOBSVY
        WRITE(LUNSPF,*)MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY
        WRITE(LUNSPF,*)
        WRITE(LUNSPF,*)PINW,PINH,PINR
        WRITE(LUNSPF,*)OBSVDZ,OBSVDY
        WRITE(LUNSPF,*)

        WRITE(LUNSPF,*)(OBSVZ(IO),IO=1,NOBSVZ)
        WRITE(LUNSPF,*)
        WRITE(LUNSPF,*)(OBSVY(IO),IO=1,NOBSVY)
        WRITE(LUNSPF,*)

        DO IO=1,NOBSV
          WRITE(LUNSPF,*)(OBSV(IX,IO),IX=1,3)
          DO IFR=1,NFREQ
            IF (IUNIT.EQ.0) WRITE(LUNSPF,*)FREQ(IFR)
     &        ,(SPECF(IS+NSOURCE*(IO-1+NOBSV*(IFR-1))),IS=1,NSOURCE)
     &        ,SPECTOTF(IO+NOBSV*(IFR-1))
            IF (IUNIT.NE.0) WRITE(LUNSPF,*)WELLEN(IFR)
     &        ,(SPECF(IS+NSOURCE*(IO-1+NOBSV*(IFR-1))),IS=1,NSOURCE)
     &        ,SPECTOTF(IO+NOBSV*(IFR-1))
          ENDDO !NFREQ
        ENDDO !NOBSV

        CLOSE(LUNSPF)

      ENDIF !IWFILSPF

      IF(istokes.ne.0.and.IFOLD.NE.0 .AND. IWFLSTOF.NE.0) THEN

        OPEN(UNIT=LUNSTOF,FILE=FILESTOF)

        WRITE(LUNSTOF,*)ICODE,' ',CODE
        WRITE(LUNSTOF,*)
        WRITE(LUNSTOF,*)NSOURCE,NOBSV,NFREQ,IFREQ2P
        WRITE(LUNSTOF,*)NOBSVZ,NOBSVY,MOBSVZ,MOBSVY
        WRITE(LUNSTOF,*)MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY
        WRITE(LUNSTOF,*)
        WRITE(LUNSTOF,*)PINW,PINH,PINR
        WRITE(LUNSTOF,*)OBSVDZ,OBSVDY
        WRITE(LUNSTOF,*)

        WRITE(LUNSTOF,*)(OBSVZ(IO),IO=1,NOBSVZ)
        WRITE(LUNSTOF,*)
        WRITE(LUNSTOF,*)(OBSVY(IO),IO=1,NOBSVY)
        WRITE(LUNSTOF,*)

        DO IO=1,NOBSV
          WRITE(LUNSTOF,*)(OBSV(IX,IO),IX=1,3)
          DO IFR=1,NFREQ
            IF (IUNIT.EQ.0)  !260194
     &        WRITE(LUNSTOF,*)FREQ(IFR),(STOKESF(IS,IO+NOBSV*(IFR-1)),IS=1,4)
            IF (IUNIT.NE.0)
     &        WRITE(LUNSTOF,*)WELLEN(IFR),(STOKESF(IS,IO+NOBSV*(IFR-1)),IS=1,4)
          ENDDO !NFREQ
        ENDDO !NOBSV

        CLOSE(LUNSTOF)

      ENDIF !IWFLSTOF

C--- OUTPUT RESULTS

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Results of spectrum calculations'
      WRITE(LUNGFO,*)'     ================================'
      WRITE(LUNGFO,*)
      IF (IPOLA.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     Photons are polarized parallely to complex vector VPOLA:'
        DO IC=1,3
          WRITE(LUNGFO,*)'     ',CMPLX(VPOLA(IC))
        ENDDO
        WRITE(LUNGFO,*)
      ENDIF !IPOLA

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Reflectivity coefficients (complex):'
      WRITE(LUNGFO,*)
      DO IC=1,3
        WRITE(LUNGFO,*)'     ',CONJG(REFLEC(IC))
      ENDDO
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

      IF (ISPECMODE.EQ.3.OR.ISPECMODE.EQ.4) THEN
        WRITE(LUNGFO,*)
     &    '     Buffer size for integration (NDWSOU):',NDWSOU
        WRITE(LUNGFO,*)
      ENDIF

      IF (ISPECMODE.EQ.3.OR.ISPECMODE.EQ.4) THEN
        WRITE(LUNGFO,*)
     &    '     Provided number of integration steps for each source'
        WRITE(LUNGFO,*)
     &    '     (controlled by NLPOI)'
        WRITE(LUNGFO,*)
     &    '     (not necessarily used)'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)(IPOISOU(IS),IS=1,NSOURCE)
      ENDIF

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Bandwidth:',SNGL(BANWID)
      WRITE(LUNGFO,*)

      IF(IPIN.EQ.0) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)

        WRITE(LUNGFO,*)
     &    '     Photon energy [eV] or wavelength [nm] for all observation'
        WRITE(LUNGFO,*)
     &    '     points, flux per unit area [m**2] for each source,'
        WRITE(LUNGFO,*)
     &    '     total flux density:'
        WRITE(LUNGFO,*)

        WRITE(LUNGFO,*)

        if (iundulator.eq.0) call powgraz

        DO IO=1,NOBSV

          WRITE(LUNGFO,*)'          Observation point (x,y,z) [m]:'
          WRITE(LUNGFO,*)'          ',(SNGL(OBSV(IX,IO)),IX=1,3)

          IF ((ISPECMODE.EQ.3.OR.ISPECMODE.EQ.4).AND.ISPECDIP.EQ.0
     &        .and.ispecana.eq.0) THEN
            WRITE(LUNGFO,*)
     &        '          Number of integration steps for each source:'
            WRITE(LUNGFO,*)
     &        '                 (controlled by NLPOI)'
            WRITE(LUNGFO,*)'          ',(NARGUM(IO,IS),IS=1,NSOURCE)
          ENDIF

          WRITE(LUNGFO,*)
          DO IFR=1,NFREQ
            IF (IUNIT.EQ.0)  !260194
     &        WRITE(LUNGFO,*)'  ',SNGL(FREQ(IFR))
     &        ,(SNGL(SPEC(IS+NSOURCE*(IO-1+NOBSV*(IFR-1)))),IS=1,NSOURCE)
     &        ,SNGL(SPECTOT(IO+NOBSV*(IFR-1)))
            IF (IUNIT.NE.0)  !260194
     &        WRITE(LUNGFO,*)'  ',SNGL(WELLEN(IFR))
     &        ,(SNGL(SPEC(IS+NSOURCE*(IO-1+NOBSV*(IFR-1)))),IS=1,NSOURCE)
     &        ,SNGL(SPECTOT(IO+NOBSV*(IFR-1)))
          ENDDO !IFR


C maximum of spectot{

          IF (NFREQ.GT.1) THEN

            DO IFR=1,NFREQ
              SPECBUFF(IFR)=SPECTOT(IO+NOBSV*(IFR-1))
            ENDDO !IFR

            CALL UTIL_MAX_PARABEL
     &        (NFREQ,FREQ,SPECBUFF,SPECTOTMX(3),SPECTOTMX(4)
     &        ,WSNOBFR1,WSNOBFR2,IFAIL)

            IF (IFAIL.NE.0) THEN
              WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED'
              WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
            ENDIF

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Estimated maximum:'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     ',SNGL(SPECTOTMX(3)),SNGL(SPECTOTMX(4))
            WRITE(LUNGFO,*)

          ENDIF   !NFREQ

C maximum of spectot}

      IF (IFOLD.EQ.2) THEN

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)

          WRITE(LUNGFO,*)
     &      '     flux per unit area [m**2] for each source,'
          WRITE(LUNGFO,*)
     &      '     total flux density with emittance:'
          WRITE(LUNGFO,*)

          WRITE(LUNGFO,*)
          DO IFR=1,NFREQ
            SPECTOTF(IO+NOBSV*(IFR-1))=0.0D0
            DO IS=1,NSOURCE
              SPECTOTF(IO+NOBSV*(IFR-1))=
     &          SPECTOTF(IO+NOBSV*(IFR-1))+
     &          SPECF(IS+NSOURCE*(IO-1+NOBSV*(IFR-1)))
            ENDDO
            IF (IUNIT.EQ.0)  !260194
     &        WRITE(LUNGFO,*)'  ',SNGL(FREQ(IFR))
     &        ,(SNGL(SPECF(IS+NSOURCE*(IO-1+NOBSV*(IFR-1)))),IS=1,NSOURCE)
     &        ,SNGL(SPECTOTF(IO+NOBSV*(IFR-1)))
            IF (IUNIT.NE.0)  !260194
     &        WRITE(LUNGFO,*)'  ',SNGL(WELLEN(IFR))
     &        ,(SNGL(SPECF(IS+NSOURCE*(IO-1+NOBSV*(IFR-1)))),IS=1,NSOURCE)
     &        ,SNGL(SPECTOTF(IO+NOBSV*(IFR-1)))
          ENDDO !IFR

C maximum of spectot{

          IF (NFREQ.GT.1) THEN

            DO IFR=1,NFREQ
              SPECBUFF(IFR)=SPECTOTF(IO+NOBSV*(IFR-1))
            ENDDO !IFR

            CALL UTIL_MAX_PARABEL
     &        (NFREQ,FREQ,SPECBUFF,SPECTOTMX(3),SPECTOTMX(4)
     &        ,WSNOBFR1,WSNOBFR2,IFAIL)

            IF (IFAIL.NE.0) THEN
              WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED'
              WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
            ENDIF

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Estimated maximum:'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     ',SNGL(SPECTOTMX(3)),SNGL(SPECTOTMX(4))
            WRITE(LUNGFO,*)

          ENDIF   !NFREQ

        ENDIF !IFOLD.EQ.2

C maximum of spectot}

        WRITE(LUNGFO,*)' '

        WRITE(LUNGFO,*)' '
        WRITE(LUNGFO,*)
     &    '     Power density at selected point [W/m**2]:'
        WRITE(LUNGFO,*)

        if (nsource.le.5) then

          WRITE(LUNGFO,*)
     &      '     (for all sources,sum, and sum grazing)'
          IF (IAMPLI.GT.0) THEN
            WRITE(LUNGFO,*)
     &        '     (Option IAMPLI not taken into account!!)'
          ENDIF   !IAMPLI

          WRITE(LUNGFO,*)'   '
     &      ,(SNGL(SPECPOW(IS+NSOURCE*(IO-1))),IS=1,NSOURCE)
     &      ,SNGL(SPECPOWT(IO))
     &      ,SNGL(SPECPOWTgraz(IO))
        else

          WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'

          IF (IAMPLI.GT.0) THEN
            WRITE(LUNGFO,*)
     &        '     (Option IAMPLI not taken into account!!)'
          ENDIF   !IAMPLI

          WRITE(LUNGFO,*)'   '
     &      ,(SNGL(SPECPOW(IS+NSOURCE*(IO-1))),IS=1,2)
     &      ,SNGL(SPECPOW(IS+(NSOURCE/2+1)*(IO-1)))
     &      ,(SNGL(SPECPOW(IS+NSOURCE*(IO-1))),IS=NSOURCE-1,NSOURCE)
     &      ,SNGL(SPECPOWT(IO))
     &      ,SNGL(SPECPOWTgraz(IO))
        endif

        WRITE(LUNGFO,*)' '

        if (ifold.ne.0) then
          WRITE(LUNGFO,*)' '
          WRITE(LUNGFO,*)
     &      '     Power density with emittance at selected point [W/m**2]:'
          WRITE(LUNGFO,*)
          if (nsource.le.5) then
            WRITE(LUNGFO,*)
     &        '     (for all sources and sum)'
            IF (IAMPLI.GT.0) THEN
              WRITE(LUNGFO,*)
     &          '     (Option IAMPLI not taken into account!!)'
            ENDIF !IAMPLI

            WRITE(LUNGFO,*)'   '
     &        ,(SNGL(SPECPOWf(IS+NSOURCE*(IO-1))),IS=1,NSOURCE)
     &        ,SNGL(SPECPOWTf(IO))
          else
            WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
            IF (IAMPLI.GT.0) THEN
              WRITE(LUNGFO,*)
     &          '     (Option IAMPLI not taken into account!!)'
            ENDIF !IAMPLI

            WRITE(LUNGFO,*)'   '
     &        ,(SNGL(SPECPOWf(IS+NSOURCE*(IO-1))),IS=1,2)
     &        ,SNGL(SPECPOWf(IS+(NSOURCE/2+1)*(IO-1)))
     &        ,(SNGL(SPECPOWf(IS+NSOURCE*(IO-1))),IS=NSOURCE-1,NSOURCE)
     &        ,SNGL(SPECPOWTf(IO))
          endif
          WRITE(LUNGFO,*)' '
        endif !(ifold.ne.0) then

c          IF (IAMPLI.LT.0) THEN
c            WRITE(LUNGFO,*)'     scaled according to IAMPLI:'
c            WRITE(LUNGFO,*)'            '
c     &        ,(SNGL(SPECPOW(IS+NSOURCE*(IO-1))*(-IAMPLI)),IS=1,NSOURCE)
c     &        ,SNGL(SPECPOWT(IO)*(-IAMPLI))
c            WRITE(LUNGFO,*)' '
c          ENDIF  !IAMPLI

          IF (ISPECINT.NE.0) THEN

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '     Power density [W/m**2]:'
            WRITE(LUNGFO,*)
     &        '     (by integration over spectral range:',
     &        SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','

            if (nsource.le.5) then

              WRITE(LUNGFO,*)
     &          '     for all sources and sum)'
              WRITE(LUNGFO,*)'   '
     &          ,(SNGL(SPECI(IS+NSOURCE*(IO-1))),IS=1,NSOURCE)
     &          ,SNGL(SPECTOTI(IO))

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          '     Divided by total power density:'
              WRITE(LUNGFO,*)'   '
     &          ,(SNGL(SPECI(IS+NSOURCE*(IO-1))/SPECPOW(IS+NSOURCE*(IO-1))),
     &          IS=1,NSOURCE)
     &          ,SNGL(SPECTOTI(IO)/SPECPOWT(IO))

            else

              WRITE(LUNGFO,*)
     &    '     for the first two, the central, and the last sources and sum)'
              WRITE(LUNGFO,*)
     &          '   '
     &          ,(SNGL(SPECI(IS+NSOURCE*(IO-1))),IS=1,2)
     &          ,SNGL(SPECI(IS+(NSOURCE/2+1)*(IO-1)))
     &          ,(SNGL(SPECI(IS+NSOURCE*(IO-1))),IS=nsource-1,NSOURCE)
     &          ,SNGL(SPECTOTI(IO))

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          '     Divided by total power density:'
              WRITE(LUNGFO,*)'   '
     &          ,(SNGL(SPECI(IS+NSOURCE*(IO-1))/SPECPOW(IS+NSOURCE*(IO-1))),
     &          IS=1,2)
     &          ,SNGL(SPECI(IS+(NSOURCE/2+1)*(IO-1))/
     &          SPECPOW(IS+(NSOURCE/2+1)*(IO-1)))
     &          ,(SNGL(SPECI(IS+NSOURCE*(IO-1))/SPECPOW(IS+NSOURCE*(IO-1))),
     &          IS=nsource-1,NSOURCE)
     &          ,SNGL(SPECTOTI(IO)/SPECPOWT(IO))

            endif

            WRITE(LUNGFO,*)

            WRITE (LUNGFO,*)
            WRITE (LUNGFO,*)
     &        '     Critical photon energy or wavelength of calculated flux density'

            IF (IUNIT.EQ.0)
     &        WRITE (LUNGFO,*)'     first observation point:',SNGL(FREQC)
            IF (IUNIT.NE.0)
     &        WRITE (LUNGFO,*)'     first observation point:',SNGL(WELLENC)
            WRITE (LUNGFO,*)

            WRITE(LUNGFO,*)
     &        '     Total number of photons per second at critical energy'
            WRITE(LUNGFO,*)
     &        '     for first observation point:'
            WRITE(LUNGFO,*)'            ',
     &        SNGL(SNGL(SPECTOTI(1))/FREQC/ECHARGE1)

            IF (IDESYNC.NE.0) THEN

              WRITE(LUNGFO,*)
     &          '     Power density at selected point [W/m**2] * AREAM2:'
              WRITE(LUNGFO,*)
     &          '     (by integration over spectral range:',
     &          SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','
              if (nsource.le.5) then
                WRITE(LUNGFO,*)
     &            '     for all sources and sum)'
                WRITE(LUNGFO,*)'   '
     &            ,(SNGL(SPECI(IS+NSOURCE*(IO-1))*AREAM2),IS=1,NSOURCE)
     &            ,SNGL(SPECTOTI(IO)*AREAM2)
              else
                WRITE(LUNGFO,*)'     for the first two, the central, and the last sources and sum)'
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'   '
     &            ,(SNGL(SPECI(IS+NSOURCE*(IO-1))*AREAM2),IS=1,2)
     &            ,(SNGL(SPECI(IS+(NSOURCE/2+1)*(IO-1))*AREAM2))
     &            ,(SNGL(SPECI(IS+NSOURCE*(IO-1))*AREAM2),IS=nsource-1,NSOURCE)
     &            ,SNGL(SPECTOTI(IO)*AREAM2)
              endif
            ENDIF !IDESYNC
            WRITE(LUNGFO,*)

        IF (IDOSE.NE.0) THEN

          WRITE(LUNGFO,*)" "
          WRITE(LUNGFO,*)"     *** CAUTION: THE DOSE CALCULATIONS ARE NOT MEANT FOR RADITATION SAFETY PRUPOSES OR MEDICAL APPLICATIONS ***"
          WRITE(LUNGFO,*)" "

          WRITE(LUNGFO,*)
     &      '     Absorbed energy dose rate [Gy/sec]:',SNGL(ENEDOS(IO))
          WRITE(LUNGFO,*)
     &      '     Absorbed energy dose rate [mGy/h]:',SNGL(ENEDOS(IO)
     &      *1000.*3600)
          WRITE(LUNGFO,*)
     &      '     Absorbed energy dose rate [mGy/6000h]:',SNGL(ENEDOS(IO)
     &      *1000.*3600*6000)
           WRITE(LUNGFO,*)

          IF (IO.EQ.NOBSV) THEN
            ENEDOSMX=-1.D30
            DO IOBSV=1,NOBSV
              IF (ENEDOS(IOBSV).GT.ENEDOSMX) ENEDOSMX=ENEDOS(IOBSV)
            ENDDO
            WRITE(LUNGFO,*)
     &        '     Maximum absorbed energy dose rate [Gy/sec]:',SNGL(ENEDOSMX)
            WRITE(LUNGFO,*)
     &        '     Maximum absorbed energy dose rate [mGy/h]:',SNGL(ENEDOSMX
     &        *1000.*3600)
            WRITE(LUNGFO,*)
     &        '     Maximum absorbed energy dose rate [mGy/6000h]:',SNGL(ENEDOSMX
     &        *1000.*3600*6000)
            WRITE(LUNGFO,*)

          ENDIF   !IO=NOBSV

        ENDIF !IDOSE

      ENDIF !ISPECINT


        ENDDO !IO

      ENDIF  !IPIN.eq.0

      IF(IPIN.NE.0) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     Pinhole position (x,y,z) [m]:'
        WRITE(LUNGFO,*)'     ',(SNGL(PINCEN(IO)),IO=1,3)
        WRITE(LUNGFO,*)

        IF(IPIN.NE.2.and.ipin.ne.3) THEN

          WRITE(LUNGFO,*)
     &      '     Numbers defining inner vert. and hori. edges (MMEDGEY,MMEDGEZ): ',
     &      MMEDGEY,MMEDGEZ," (obsolete, MUST be zero)"
          if (mmedgey.ne.0.or.mmedgez.ne.0) stop "MMEDGEY OR MMEDGEZ NOT ZERO!"
          WRITE(LUNGFO,*)
     &      '     Numbers defining outerer vert. and hori. edges (MEDGEY,MEDGEZ): ',
     &      MEDGEY,MEDGEZ
          WRITE(LUNGFO,*)
     &      '     Total number of vert. and hori. points:          ',NOBSVY,NOBSVZ
          WRITE(LUNGFO,*)
     &      '     Number of vert. and horiz. points inside pinhole:',MOBSVY,MOBSVZ
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     Vertical and horizontal grid size [m]:     '
     &      ,SNGL(OBSVDY),SNGL(OBSVDZ)

        ENDIF !IPIN.NE.2

        IF (MPINR.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     IQAUDPHI, NOBSVR, NOBSVPHI: ',IQUADPHI,NOBSVR, NOBSVPHI
          WRITE(LUNGFO,*)
     &      '     OBSVDR, OBSVDPHI: ',SNGL(OBSVDR),SNGL(OBSVDPHI*RADGRA1)
          WRITE(LUNGFO,*)
        ENDIF

        IF(IPIN.NE.2.and.ipin.ne.3) THEN

          WRITE(LUNGFO,*)
     &      '     Vertical and horizontal size [m x m]:      '
     &      ,AMAX1(SNGL(OBSVDY),(MOBSVY-1)*SNGL(OBSVDY))
     &      ,AMAX1(SNGL(OBSVDZ),(MOBSVZ-1)*SNGL(OBSVDZ))

          WRITE(LUNGFO,*)
     &      '     Total vert. and horiz. size [m x m]:       '
     &      ,AMAX1(SNGL(OBSVDY),(NOBSVY-1)*SNGL(OBSVDY))
     &      ,AMAX1(SNGL(OBSVDZ),(NOBSVZ-1)*SNGL(OBSVDZ))

        else

          if (ipincirc.eq.0) then
            WRITE(LUNGFO,*)
     &        '     Vertical and horizontal size [m x m]:      ',
     &        SNGL(pinh),sngl(pinw)
          endif

        ENDIF !(IPIN.NE.2)

        IF (IPINCIRC.NE.0) THEN

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &'     Flux is calculated through circ. pinhole, radius [m] and area [m x m]:'
          WRITE(LUNGFO,*)'      ',SNGL(pinr),sngl(pi1*pinr**2)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)

        ENDIF

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     Photon energy or wavelength and flux through pinhole:'

        if (nsource.le.5) then
          WRITE(LUNGFO,*)'     (for all sources and sum)'
          WRITE(LUNGFO,*)

          DO IFR=1,NFREQ

            IF (IUNIT.EQ.0)
     &        WRITE(LUNGFO,*)'  ',SNGL(FREQ(IFR))
     &        ,(SNGL(WFLUX(IS+NSOURCE*(IFR-1))),IS=1,NSOURCE)
     &        ,SNGL(WFLUXT(IFR))

            IF (IUNIT.NE.0)
     &        WRITE(LUNGFO,*)'  ',SNGL(WELLEN(IFR))
     &        ,(SNGL(WFLUX(IS+NSOURCE*(IFR-1))),IS=1,NSOURCE)
     &        ,SNGL(WFLUXT(IFR))

          ENDDO !IFR
        else
          WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
          WRITE(LUNGFO,*)

          DO IFR=1,NFREQ

            IF (IUNIT.EQ.0)
     &        WRITE(LUNGFO,*)'  ',SNGL(FREQ(IFR))
     &        ,(SNGL(WFLUX(IS+NSOURCE*(IFR-1))),IS=1,2)
     &        ,SNGL(WFLUX(IS+(NSOURCE/2+1)*(IFR-1)))
     &        ,(SNGL(WFLUX(IS+NSOURCE*(IFR-1))),IS=nsource-1,NSOURCE)
     &        ,SNGL(WFLUXT(IFR))

            IF (IUNIT.NE.0)
     &        WRITE(LUNGFO,*)'  ',SNGL(WELLEN(IFR))
     &        ,(SNGL(WFLUX(IS+NSOURCE*(IFR-1))),IS=1,2)
     &        ,SNGL(WFLUX(IS+(NSOURCE/2+1)*(IFR-1)))
     &        ,(SNGL(WFLUX(IS+NSOURCE*(IFR-1))),IS=nsource-1,NSOURCE)
     &        ,SNGL(WFLUXT(IFR))

          ENDDO !IFR
        endif

C maximum of spectot{

        IF (NFREQ.GT.1) THEN

          DO IFR=1,NFREQ
            SPECBUFF(IFR)=WFLUXT(IFR)
          ENDDO   !IFR

          CALL UTIL_MAX_PARABEL
     &      (NFREQ,FREQ,SPECBUFF,SPECTOTMX(5),SPECTOTMX(6)
     &      ,WSNOBFR1,WSNOBFR2,IFAIL)

          IF (IFAIL.NE.0) THEN
            WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED'
            WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
          ENDIF

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Estimated maximum:'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     ',SNGL(SPECTOTMX(5)),SNGL(SPECTOTMX(6))
          WRITE(LUNGFO,*)

        ENDIF  !NFREQ

C maximum of spectot}

        IF (IPINALL.NE.0) THEN

          if (ipin.ne.3) then
            DO IFR=1,NFREQ

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'     Flux density at each grid point:'
              WRITE(LUNGFO,*)
              DO IY=1,NOBSVY
                IF (IF1DIM.EQ.0) WRITE(LUNGFO,*)
                DO IZ=1,NOBSVZ
                  IOBSV=(IY-1)*NOBSVZ+IZ
                  WRITE(LUNGFO,*)'           '
     &              ,(SNGL(SPEC(IS+NSOURCE*(IOBSV-1+NOBSV*(IFR-1)))),IS=1,NSOURCE)
     &              ,SNGL(SPECTOT(IOBSV+NOBSV*(IFR-1)))
                ENDDO   !IZ
              ENDDO   !IY
              WRITE(LUNGFO,*)

            ENDDO !NFREQ

          endif !ipin.ne.3

        ELSE !IPINALL.NE.0

          if (ipin.ne.3) then
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Flux density for selected point:'
            WRITE(LUNGFO,*)
          else
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Mean flux density:'
            WRITE(LUNGFO,*)
          endif

          DO IFR=1,NFREQ

            IOBSV=ICBRILL

            WRITE(LUNGFO,*)'           '
     &        ,SNGL(FREQ(IFR)),(SNGL(SPEC(IS+NSOURCE*(IOBSV-1+NOBSV*(IFR-1)))),IS=1,NSOURCE)
     &        ,SNGL(SPECTOT(IOBSV+NOBSV*(IFR-1)))

          ENDDO   !NFREQ

C maximum of spectot{

          IF (NFREQ.GT.1) THEN

            DO IFR=1,NFREQ
              SPECBUFF(IFR)=SPECTOT(ICBRILL+NOBSV*(IFR-1))
            ENDDO !IFR

            CALL UTIL_MAX_PARABEL
     &        (NFREQ,FREQ,SPECBUFF,SPECTOTMX(1),SPECTOTMX(2)
     &        ,WSNOBFR1,WSNOBFR2,IFAIL)

            IF (IFAIL.NE.0) THEN
              WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED'
              WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
            ENDIF

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Estimated maximum:'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     ',SNGL(SPECTOTMX(1)),SNGL(SPECTOTMX(2))
            WRITE(LUNGFO,*)

          ENDIF   !NFREQ

C maximum of spectot}

        ENDIF !IPINALL

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     Power through pinhole [W]:'
        if (nsource.le.5) then
          WRITE(LUNGFO,*)'     (for all sources and sum)'
          IF (IAMPLI.GT.0) THEN
            WRITE(LUNGFO,*)
     &        '     (Option IAMPLI not taken into account!!)'
          ENDIF   !IAMPLI
          WRITE(LUNGFO,*)'   '
     &      ,(SNGL(SPECPOWVH(IS)),IS=1,NSOURCE)
     &      ,SNGL(SPECPOWVHT)
          WRITE(LUNGFO,*)
        else
          WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
          IF (IAMPLI.GT.0) THEN
            WRITE(LUNGFO,*)
     &        '     (Option IAMPLI not taken into account!!)'
          ENDIF   !IAMPLI
          WRITE(LUNGFO,*)'   '
     &      ,(SNGL(SPECPOWVH(IS)),IS=1,2)
     &      ,SNGL(SPECPOWVH(nsource/2+1))
     &      ,(SNGL(SPECPOWVH(IS)),IS=nsource-1,NSOURCE)
     &      ,SNGL(SPECPOWVHT)
          WRITE(LUNGFO,*)
        endif
c        IF (IAMPLI.LT.0) THEN
c          WRITE(LUNGFO,*)'     scaled according to IAMPLI:'
c          WRITE(LUNGFO,*)'            '
c     &      ,(SNGL(SPECPOWVH(IS)*(-IAMPLI)),IS=1,NSOURCE)
c     &      ,SNGL(SPECPOWVHT*(-IAMPLI))
c          WRITE(LUNGFO,*)' '
c        ENDIF !IAMPLI

        WRITE(LUNGFO,*)
        if (ipin.ne.3) then
          WRITE(LUNGFO,*)
     &      '     Power density at selected point [W/m**2]:'
          IF (IAMPLI.GT.0) THEN
            WRITE(LUNGFO,*)
     &        '     (Option IAMPLI not taken into account!!)'
          ENDIF   !IAMPLI
        else
          WRITE(LUNGFO,*)
     &      '     Mean power density [W/m**2]:'
          IF (IAMPLI.GT.0) THEN
            WRITE(LUNGFO,*)
     &        '     (Option IAMPLI not taken into account!!)'
          ENDIF   !IAMPLI
        endif
        WRITE(LUNGFO,*)

        IOBSV=ICBRILL
        WRITE(LUNGFO,*)'            '
     &    ,(SNGL(SPECPOW(IS+NSOURCE*(IOBSV-1))),IS=1,NSOURCE)
     &    ,SNGL(SPECPOWT(IOBSV))
        WRITE(LUNGFO,*)

c        IF (IAMPLI.LT.0) THEN
c          WRITE(LUNGFO,*)'     scaled according to IAMPLI:'
c          WRITE(LUNGFO,*)'            '
c     &      ,(SNGL(SPECPOW(IS+NSOURCE*(IOBSV-1))*(-IAMPLI)),IS=1,NSOURCE)
c     &      ,SNGL(SPECPOWT(IOBSV)*(-IAMPLI))
c          WRITE(LUNGFO,*)' '
c        ENDIF !IAMPLI

        IF (ISPECINT.NE.0) THEN

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     Power [W] through pinhole or power density [W/m**2]:'
          WRITE(LUNGFO,*)
     &      '     (by integration over spectral range:',
     &      SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','
          if (nsource.le.5) then
            WRITE(LUNGFO,*)
     &        '     for all sources and sum)'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'   '
     &        ,(SNGL(WFLUXI(IS)),IS=1,NSOURCE)
     &        ,SNGL(WFLUXTI)
          else
            WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
            WRITE(LUNGFO,*)
     &        '     for all sources and sum)'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'   '
     &        ,(SNGL(WFLUXI(IS)),IS=1,2)
     &        ,SNGL(WFLUXI(nsource/2+1))
     &        ,(SNGL(WFLUXI(IS)),IS=nsource-1,NSOURCE)
     &        ,SNGL(WFLUXTI)
          endif
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     Corresponding total number of photons at critical energy:'
          WRITE(LUNGFO,*)'            ',SNGL(WFLUXTI/FREQC/ECHARGE1)
          WRITE(LUNGFO,*)

          IF (IPINALL.NE.0) THEN

            if (ipin.ne.3) then

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          '     Power density at each grid point [W/m**2]:'
              WRITE(LUNGFO,*)
     &          '     (by integration over spectral range:',
     &          SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','
              if (nsource.le.5) then
                WRITE(LUNGFO,*)
     &            '     for all sources and sum)'
                WRITE(LUNGFO,*)
                DO IY=1,NOBSVY
                  IF (IF1DIM.EQ.0) WRITE(LUNGFO,*)
                  DO IZ=1,NOBSVZ
                    IOBSV=(IY-1)*NOBSVZ+IZ
                    WRITE(LUNGFO,*)'   '
     &                ,(SNGL(SPECI(IS+NSOURCE*(IOBSV-1))),IS=1,NSOURCE)
     &                ,SNGL(SPECTOTI(IOBSV))
                  ENDDO   !IZ
                ENDDO   !IY
              else
                WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
                WRITE(LUNGFO,*)
                DO IY=1,NOBSVY
                  IF (IF1DIM.EQ.0) WRITE(LUNGFO,*)
                  DO IZ=1,NOBSVZ
                    IOBSV=(IY-1)*NOBSVZ+IZ
                    WRITE(LUNGFO,*)'   '
     &                ,(SNGL(SPECI(IS+NSOURCE*(IOBSV-1))),IS=1,2)
     &                ,SNGL(SPECI(IS+(NSOURCE/2+1)*(IOBSV-1)))
     &                ,(SNGL(SPECI(IS+NSOURCE*(IOBSV-1))),IS=nsource-1,NSOURCE)
     &                ,SNGL(SPECTOTI(IOBSV))
                  ENDDO   !IZ
                ENDDO   !IY
              endif
              WRITE(LUNGFO,*)

            endif !ipin.ne.3

          ELSE !(IPINALL.NE.0)

            WRITE(LUNGFO,*)
            if (ipin.ne.3) then
              WRITE(LUNGFO,*)
     &          '     Power density at selected point [W/m**2]:'
              WRITE(LUNGFO,*)
     &          '     (by integration over spectral range:',
     &          SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','
              if (nsource.le.5) then
                WRITE(LUNGFO,*)
     &            '     for all sources and sum)'
              else
                WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
              endif
            else
              WRITE(LUNGFO,*)
     &          '     Mean power density [W/m**2]:'
              WRITE(LUNGFO,*)
     &          '     (by integration over spectral range:',
     &          SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','
              if (nsource.le.5) then
                WRITE(LUNGFO,*)
     &            '     for all sources and sum)'
              else
                WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
              endif
            endif
            WRITE(LUNGFO,*)

            IOBSV=ICBRILL
            if (nsource.le.5) then
              WRITE(LUNGFO,*)'     '
     &          ,(SNGL(SPECI(IS+NSOURCE*(IOBSV-1))),IS=1,NSOURCE)
     &          ,SNGL(SPECTOTI(IOBSV))
            else
              WRITE(LUNGFO,*)'   '
     &          ,(SNGL(SPECI(IS+NSOURCE*(IOBSV-1))),IS=1,2)
     &          ,SNGL(SPECI(IS+(NSOURCE/2+1)*(IOBSV-1)))
     &          ,(SNGL(SPECI(IS+NSOURCE*(IOBSV-1))),IS=nsource-1,NSOURCE)
     &          ,SNGL(SPECTOTI(IOBSV))
              WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
            endif
            WRITE(LUNGFO,*)

          ENDIF !IPINALL

          WRITE(LUNGFO,*)

          IF (IDOSE.NE.0) THEN

            WRITE(LUNGFO,*)" "
            WRITE(LUNGFO,*)"     *** CAUTION: THE DOSE CALCULATIONS ARE NOT MEANT FOR RADITATION SAFETY PRUPOSES OR MEDICAL APPLICATIONS ***"
            WRITE(LUNGFO,*)" "

            DO IO=1,NOBSV

              IF (IPINALL.NE.0) THEN

                WRITE(LUNGFO,*)
     &            '     Z, Y:',SNGL(OBSVZ(IO)),SNGL(OBSVY(IO))
                WRITE(LUNGFO,*)
     &            '     Absorbed energy dose rate [mGy/h]:',SNGL(ENEDOS(IO)
     &            *1000.*3600)
                WRITE(LUNGFO,*)

              ENDIF  !IPINALL

              IF (IO.EQ.NOBSV) THEN
                ENEDOSMX=-1.D30
                DO IOBSV=1,NOBSV
                  IF (ENEDOS(IOBSV).GT.ENEDOSMX) ENEDOSMX=ENEDOS(IOBSV)
                ENDDO
                WRITE(LUNGFO,*)
     &            '     Maximum absorbed energy dose rate [Gy/sec]:',SNGL(ENEDOSMX)
                WRITE(LUNGFO,*)
     &            '     Maximum absorbed energy dose rate [mGy/h]:',SNGL(ENEDOSMX
     &            *1000.*3600)
                WRITE(LUNGFO,*)
     &            '     Maximum absorbed energy dose rate [mGy/a]:',SNGL(ENEDOSMX
     &            *1000.*3600*6000)
                WRITE(LUNGFO,*)

              ENDIF  !IO=NOBSV
            ENDDO !IO

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '      Dose rate averaged over pinhole [Gy/sec]:',SNGL(PINDOS)
            WRITE(LUNGFO,*)
     &        '      Dose rate averaged over pinhole [mGy/h]:',SNGL(PINDOS
     &        *1000.*3600)
            WRITE(LUNGFO,*)
     &        '      Dose rate averaged over pinhole [mGy/a]:',SNGL(PINDOS
     &        *1000.*3600*6000)
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Effective pinhole size [m**2]:'
     &        ,PINDOS*PINW*PINH/ENEDOSMX
            WRITE(LUNGFO,*)'     Effective pinhole height [m]:'
     &        ,PINDOS*PINH/ENEDOSMX

            if (ipincirc.ne.0) then
              print*,"Error in spectrum: Dose calculation require rectangular pinhole ***"
              print*,"*** Program WAVE aborted ***"
              stop
            endif

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '      The estimated scattered dose behind the filter is the averaged dose scaled to the full solid angle.'
            WRITE(LUNGFO,*)
     &        '      *** DO NOT USE THESE ESTIMATIONS FOR RADIATION SAFETY OF MEDICAL APPLICATONS ***'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '      Estimated scattered dose 1m behind the filter 1m distance [Gy/sec]',
     &        SNGL(PINDOS*(pinw*pinh/pincen(1)**2)/4./pi1)
            WRITE(LUNGFO,*)
     &        '      Estimated scattered dose 1m behind the filter in 1m distance [mGy/h]',
     &        SNGL(PINDOS*(pinw*pinh/pincen(1)**2)/4./pi1*1000.*3600)
            WRITE(LUNGFO,*)
     &        '      Estimated scattered dose behind the filter in 1m distance [mGy/a]',
     &        SNGL(PINDOS*(pinw*pinh/pincen(1)**2)/4./pi1*1000.*3600*6000)
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Effective pinhole size [m**2]:'
     &        ,PINDOS*PINW*PINH/ENEDOSMX
            WRITE(LUNGFO,*)'     Effective pinhole height [m]:'
     &        ,PINDOS*PINH/ENEDOSMX

          ENDIF !IDOSE

        ENDIF !ISPECINT
        WRITE(LUNGFO,*)

        if (ipin.eq.3) then

           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'     Horizontal emittance EPS0H [m-rad]:',EPS0H
           WRITE(LUNGFO,*)'     Vertical emittance EPS0V [m-rad]:  ',EPS0V
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Sigmas of sources for horiz. folding:'
          WRITE(LUNGFO,*)'     ',(SNGL(WSIGZ(IS)),IS=1,NSOURCE)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Sigmas of sources for vert. folding:'
          WRITE(LUNGFO,*)'     ',(SNGL(WSIGY(IS)),IS=1,NSOURCE)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Sigmas of horizontal beam size and divergence:'
          WRITE(LUNGFO,*)
     &      '     (if not zero, sigmas for folding are calculated from these values)'
          WRITE(LUNGFO,*)'     ',(SNGL(BSIGZ(IS)),SNGL(BSIGZP(IS)),IS=1,NSOURCE)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Sigmas of vertical beam size and divergence:'
          WRITE(LUNGFO,*)
     &      '     (if not zero, sigmas for folding are calculated from these values)'
          WRITE(LUNGFO,*)'     ',(SNGL(BSIGY(IS)),SNGL(BSIGYP(IS)),IS=1,NSOURCE)
          WRITE(LUNGFO,*)

        else IF (IFOLD.NE.0)   THEN

          WRITE(LUNGFO,*)

          if (ipin.ne.3) then
            IF (IFOLD.NE.2.AND.IFOLD.NE.1)
     &        WRITE(LUNGFO,*)
     &        '     Number of Fourier coefficients for folding:',NGFOURZ,NGFOURY

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Number of sigmas for horiz. folding:'
            WRITE(LUNGFO,*)'     ',(SNGL(DGSIGZ(IS)),IS=1,NSOURCE)
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Number of sigmas for vert. folding:'
            WRITE(LUNGFO,*)'     ',(SNGL(DGSIGY(IS)),IS=1,NSOURCE)
            WRITE(LUNGFO,*)
          endif
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Sigmas of sources for horiz. folding:'
          WRITE(LUNGFO,*)'     ',(SNGL(WSIGZ(IS)),IS=1,NSOURCE)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Sigmas of sources for vert. folding:'
          WRITE(LUNGFO,*)'     ',(SNGL(WSIGY(IS)),IS=1,NSOURCE)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Sigmas of horizontal beam size and divergence:'
          WRITE(LUNGFO,*)
     &      '     (if not zero, sigmas for folding are calculated from these values)'
          WRITE(LUNGFO,*)'     ',(SNGL(BSIGZ(IS)),SNGL(BSIGZP(IS)),IS=1,NSOURCE)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Sigmas of vertical beam size and divergence:'
          WRITE(LUNGFO,*)
     &      '     (if not zero, sigmas for folding are calculated from these values)'
          WRITE(LUNGFO,*)'     ',(SNGL(BSIGY(IS)),SNGL(BSIGYP(IS)),IS=1,NSOURCE)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)

          IF (ISTOKES.NE.0) THEN
            WRITE(LUNGFO,*)
     &        '     Sigmas for folding of components of STOKES vector:'
            WRITE(LUNGFO,*)
     &        '     ',SNGL(WSIGZ(ISIGSTO)),SNGL(WSIGY(ISIGSTO))
            WRITE(LUNGFO,*)
          ENDIF !ISTOKES
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     Photon energy or wavelen. and flux through pinhole with emittance effects:'
          WRITE(LUNGFO,*)

          DO IFR=1,NFREQ

            IF (IUNIT.EQ.0)
     &        WRITE(LUNGFO,*)'  ',SNGL(FREQ(IFR))
     &        ,(SNGL(WFLUXF(IS+NSOURCE*(IFR-1))),IS=1,NSOURCE)
     &        ,SNGL(WFLUXTF(IFR))
            IF (IUNIT.NE.0)
     &        WRITE(LUNGFO,*)'  ',SNGL(WELLEN(IFR))
     &        ,(SNGL(WFLUXF(IS+NSOURCE*(IFR-1))),IS=1,NSOURCE)
     &        ,SNGL(WFLUXTF(IFR))

          ENDDO !IFR

C maximum of spectot{

          IF (NFREQ.GT.1) THEN

            DO IFR=1,NFREQ
              SPECBUFF(IFR)=WFLUXTF(IFR)
            ENDDO !IFR

            CALL UTIL_MAX_PARABEL
     &        (NFREQ,FREQ,SPECBUFF,SPECTOTMX(1),SPECTOTMX(2)
     &        ,WSNOBFR1,WSNOBFR2,IFAIL)

            IF (IFAIL.NE.0) THEN
              WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED'
              WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
            ENDIF

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Estimated maximum:'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     ',SNGL(SPECTOTMX(1)),SNGL(SPECTOTMX(2))
            WRITE(LUNGFO,*)

          ENDIF   !NFREQ

C maximum of spectot}

          if (ipin.ne.3) then

            IF (IPINALL.NE.0) THEN

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'     Flux density at each grid point with emittance:'
              WRITE(LUNGFO,*)

              DO IFR=1,NFREQ

                DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
                  IF (IF1DIM.EQ.0) WRITE(LUNGFO,*)
                  DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
                    IOBSV=(IY-1)*NOBSVZ+IZ
                    WRITE(LUNGFO,*)'           '
     &                ,(SNGL(SPECF(IS+NSOURCE*(IOBSV-1+NOBSV*(IFR-1)))),IS=1,NSOURCE)
     &                ,SNGL(SPECTOTF(IOBSV+NOBSV*(IFR-1)))
                  ENDDO   !IZ
                ENDDO   !IY
                WRITE(LUNGFO,*)

              ENDDO    !IFR

            ELSE !(IPINALL.NE.0)

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          '     Flux density at selected point with emittance:'
              WRITE(LUNGFO,*)

              DO IFR=1,NFREQ

                IOBSV=ICBRILL
                WRITE(LUNGFO,*)'           '
     &            ,SNGL(FREQ(IFR))
     &            ,(SNGL(SPECF(IS+NSOURCE*(IOBSV-1+NOBSV*(IFR-1)))),IS=1,NSOURCE)
     &            ,SNGL(SPECTOTF(IOBSV+NOBSV*(IFR-1)))

              ENDDO    !IFR

C maximum of spectot{

              IF (NFREQ.GT.1) THEN

                DO IFR=1,NFREQ
                  SPECBUFF(IFR)=SPECTOTF(ICBRILL+NOBSV*(IFR-1))
                ENDDO   !IFR

                CALL UTIL_MAX_PARABEL
     &            (NFREQ,FREQ,SPECBUFF,SPECTOTMX(1),SPECTOTMX(2)
     &            ,WSNOBFR1,WSNOBFR2,IFAIL)

                IF (IFAIL.NE.0) THEN
                  WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED'
                  WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
                ENDIF

                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'     Estimated maximum:'
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'     ',SNGL(SPECTOTMX(1)),SNGL(SPECTOTMX(2))
                WRITE(LUNGFO,*)

              ENDIF  !NFREQ

C maximum of spectot}

            ENDIF !IPINALL

            IF (ISPECINT.NE.0) THEN

              WRITE(LUNGFO,*)
     &          '     Power [W] or power density [W/m**2] with emittance'
              WRITE(LUNGFO,*)
     &          '     (by integration over spectral range:',
     &          SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','
              if (nsource.le.5) then
                WRITE(LUNGFO,*)
     &            '     for all sources and sum)'
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'   '
     &            ,(SNGL(WFLUXIF(IS)),IS=1,NSOURCE)
     &            ,SNGL(WFLUXTIF)
              else
                WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'   '
     &            ,(SNGL(WFLUXIF(IS)),IS=1,2)
     &            ,SNGL(WFLUXIF(nsource/2+1))
     &            ,(SNGL(WFLUXIF(IS)),IS=nsource-1,NSOURCE)
     &            ,SNGL(WFLUXTIF)
              endif
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          '     Corresponding total number of photons at critical energy:'
              WRITE(LUNGFO,*)'     ',SNGL(WFLUXTIF/FREQCF/ECHARGE1)

              IF (IPINALL.NE.0) THEN

                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)
     &            '     Power density at each grid point [W/m**2] with emittance:'
                WRITE(LUNGFO,*)
     &            '     (by integration over spectral range:',
     &            SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','
                if (nsource.le.5) then
                  WRITE(LUNGFO,*)
     &              '     for all sources and sum)'
                  WRITE(LUNGFO,*)
                  DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
                    IF (IF1DIM.EQ.0) WRITE(LUNGFO,*)
                    DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
                      IOBSV=(IY-1)*NOBSVZ+IZ
                      WRITE(LUNGFO,*)'   '
     &                  ,(SNGL(SPECIF(IS+NSOURCE*(IOBSV-1))),IS=1,NSOURCE)
     &                  ,SNGL(SPECTOTIF(IOBSV))
                    ENDDO   !IZ
                  ENDDO   !IY
                else
                  WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
                  WRITE(LUNGFO,*)
                  DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
                    IF (IF1DIM.EQ.0) WRITE(LUNGFO,*)
                    DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
                      IOBSV=(IY-1)*NOBSVZ+IZ
                      WRITE(LUNGFO,*)'   '
     &                  ,(SNGL(SPECIF(IS+NSOURCE*(IOBSV-1))),IS=1,2)
     &                  ,SNGL(SPECIF(IS+(NSOURCE/2+1)*(IOBSV-1)))
     &                  ,(SNGL(SPECIF(IS+NSOURCE*(IOBSV-1))),IS=nsource-1,NSOURCE)
     &                  ,SNGL(SPECTOTIF(IOBSV))
                    ENDDO   !IZ
                  ENDDO   !IY
                endif
                WRITE(LUNGFO,*)

              ELSE !(IPINALL.NE.0)

                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)
     &            '     Power density at selected point [W/m**2] with emittance:'
                WRITE(LUNGFO,*)
     &            '     (by integration over spectral range:',
     &            SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','
                if (nsource.le.5) then
                  WRITE(LUNGFO,*)
     &              '     for all sources and sum)'
                  WRITE(LUNGFO,*)
                  IOBSV=ICBRILL
                  WRITE(LUNGFO,*)'   '
     &              ,(SNGL(SPECIF(IS+NSOURCE*(IOBSV-1))),IS=1,NSOURCE)
     &              ,SNGL(SPECTOTIF(IOBSV))
                else
                  WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
                  WRITE(LUNGFO,*)
     &              '     for all sources and sum)'
                  WRITE(LUNGFO,*)
                  IOBSV=ICBRILL
                  WRITE(LUNGFO,*)'   '
     &              ,(SNGL(SPECIF(IS+NSOURCE*(IOBSV-1))),IS=1,2)
     &              ,SNGL(SPECIF(IS+(NSOURCE/2+1)*(IOBSV-1)))
     &              ,(SNGL(SPECIF(IS+NSOURCE*(IOBSV-1))),IS=nsource-1,NSOURCE)
     &              ,SNGL(SPECTOTIF(IOBSV))
                endif
                WRITE(LUNGFO,*)

              ENDIF !IPINALL

            ENDIF !ISPECINT

          ENDIF !IFOLD

        endif !ipin3 and ifold

      ENDIF  !IPIN.ne.0

      IF (ISTOKES.NE.0) THEN

        IF (IPIN.EQ.0) THEN

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)

          WRITE(LUNGFO,*)
     &      '     Photon energy [eV] or wavelength [nm] for all observation'
          WRITE(LUNGFO,*)
     &      '     points, normalized components S0, S1/S0, S2/S0, S3/S0, P of'
          WRITE(LUNGFO,*)
     &      '     STOKES vector per unit area [m**2]:'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)

          DO IO=1,NOBSV

            WRITE(LUNGFO,*)'          Observation point (x,y,z) [m]:'
            WRITE(LUNGFO,*)'          ',(SNGL(OBSV(IX,IO)),IX=1,3)
            WRITE(LUNGFO,*)

            DO IFR=1,NFREQ
              IOBFR=IO+NOBSV*(IFR-1)
              IF (STOKES(1,IOBFR).EQ.0.0) STOKES(1,IOBFR)=1.E-10
              S1=STOKES(1,IOBFR)
              S2=STOKES(2,IOBFR)
              S3=STOKES(3,IOBFR)
              S4=STOKES(4,IOBFR)
              POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1
              IF (STOKES(1,IOBFR).EQ.1.E-10) POL=0.0
              IF (IUNIT.EQ.0)
     &          WRITE(LUNGFO,2584)SNGL(FREQ(IFR)),STOKES(1,IOBFR)
     &          ,(STOKES(IS,IOBFR)/STOKES(1,IOBFR),IS=2,4),POL
              IF (IUNIT.NE.0)
     &          WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &          ,(STOKES(IS,IOBFR)/STOKES(1,IOBFR),IS=2,4),POL
            ENDDO !IFR

            IF (IFOLD.EQ.2) THEN

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)

              WRITE(LUNGFO,*)
     &          '       Photon energy [eV] or wavelength [nm] for all observation'
              WRITE(LUNGFO,*)
     &          '       points, normalized components S0, S1/S0, S2/S0, S3/S0, P of'
              WRITE(LUNGFO,*)
     &          '       STOKES vector per unit area [m**2] with emittance:'
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)

              DO IFR=1,NFREQ
                IOBFR=IO+NOBSV*(IFR-1)
                IF (STOKESF(1,IOBFR).EQ.0.0) STOKESF(1,IOBFR)=1.E-10
                S1=STOKESF(1,IOBFR)
                S2=STOKESF(2,IOBFR)
                S3=STOKESF(3,IOBFR)
                S4=STOKESF(4,IOBFR)
                POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1
                IF (STOKESF(1,IOBFR).EQ.1.E-10) POL=0.0
                IF (IUNIT.EQ.0)
     &            WRITE(LUNGFO,2584)SNGL(FREQ(IFR)),STOKESF(1,IOBFR)
     &            ,(STOKESF(IS,IOBFR)/STOKESF(1,IOBFR),IS=2,4),POL
                IF (IUNIT.NE.0)
     &            WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &            ,(STOKESF(IS,IOBFR)/STOKESF(1,IOBFR),IS=2,4),POL
              ENDDO !IFR
            ENDIF !IFOLD.EQ.2

          ENDDO !NOBSV

        ELSE   !IPIN

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     Photon energy or wavelength and normalized components S0, S1/S0,'
          WRITE(LUNGFO,*)
     &      '     S2/S0, S3/S0 of STOKES vector and polarization for pinhole:'
          WRITE(LUNGFO,*)

          DO IFR=1,NFREQ

            IF (WSTOKES(1,IFR).EQ.0.0) WSTOKES(1,IFR)=1.E-10
            S1=WSTOKES(1,IFR)
            S2=WSTOKES(2,IFR)
            S3=WSTOKES(3,IFR)
            S4=WSTOKES(4,IFR)
            POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1
C         POL=SQRT(WSTOKES(2,IFR)**2+WSTOKES(3,IFR)**2+
C     &               WSTOKES(4,IFR)**2)/WSTOKES(1,IFR)

            IF (IUNIT.EQ.0)
     &        WRITE(LUNGFO,2584)SNGL(FREQ(IFR))
     &        ,WSTOKES(1,IFR)
     &        ,(WSTOKES(IS,IFR)/WSTOKES(1,IFR),IS=2,4),POL

            IF (IUNIT.NE.0)
     &        WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &        ,WSTOKES(1,IFR)
     &        ,(WSTOKES(IS,IFR)/WSTOKES(1,IFR),IS=2,4),POL
2584        FORMAT('     ',6(1PE12.4))

          ENDDO !IFR

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          if (ipin.ne.3) then
            WRITE(LUNGFO,*)
     &        '     Photon energy [eV] or wavelength [nm] for selected point'
            WRITE(LUNGFO,*)'     of pinhole, S0, S1/S0, S2/S0, S3/S0, P of'
            WRITE(LUNGFO,*)
     &        '     STOKES vector per unit area [m**2]:'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
            IO=ICBRILL
            WRITE(LUNGFO,*)'          Observation point (x,y,z) [m]:'
            WRITE(LUNGFO,*)'          ',(SNGL(OBSV(IX,IO)),IX=1,3)
            WRITE(LUNGFO,*)
          else
            WRITE(LUNGFO,*)
     &        '     Photon energy [eV] or wavelength [nm]'
            WRITE(LUNGFO,*)'     , mean densities of S0, S1/S0, S2/S0, S3/S0, P of'
            WRITE(LUNGFO,*)
     &        '     STOKES vector per unit area [m**2]:'
          endif

          DO IFR=1,NFREQ
            IF (STOKEC(1,IFR).EQ.0.0) STOKEC(1,IFR)=1.E-10
            S1=STOKEC(1,IFR)
            S2=STOKEC(2,IFR)
            S3=STOKEC(3,IFR)
            S4=STOKEC(4,IFR)
            POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1
C         POL=
C     &                   SQRT(
C     &          (STOKEC(2,IFR)**2
C     &          +STOKEC(3,IFR)**2
C     &          +STOKEC(4,IFR)**2))
C     &          /STOKEC(1,IFR)
            IF (STOKEC(1,IFR).EQ.1.E-10) POL=0.0
            IF (IUNIT.EQ.0)
     &        WRITE(LUNGFO,2584)SNGL(FREQ(IFR))
     &        ,STOKEC(1,IFR),(STOKEC(IS,IFR)/STOKEC(1,IFR),IS=2,4),POL
            IF (IUNIT.NE.0)
     &        WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &        ,STOKEC(1,IFR),(STOKEC(IS,IFR)/STOKEC(1,IFR),IS=2,4),POL
          ENDDO !IFR

          IF (IFOLD.NE.0.and.ipin.ne.3)   THEN

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '     Energy, S0, S1/S0, S2/S0, S3/S0 and P for pinhole with emittance:'
            WRITE(LUNGFO,*)

            DO IFR=1,NFREQ

              IF (WSTOKESF(1,IFR).EQ.0.0) WSTOKESF(1,IFR)=1.E-10

              S1=WSTOKESF(1,IFR)
              S2=WSTOKESF(2,IFR)
              S3=WSTOKESF(3,IFR)
              S4=WSTOKESF(4,IFR)
              POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1
C         POL=SQRT(WSTOKESF(2,IFR)**2+WSTOKESF(3,IFR)**2+
C     &               WSTOKESF(4,IFR)**2)/WSTOKESF(1,IFR)

              IF (IUNIT.EQ.0)
     &          WRITE(LUNGFO,2584)SNGL(FREQ(IFR))
     &          ,WSTOKESF(1,IFR)
     &          ,(WSTOKESF(IS,IFR)/WSTOKESF(1,IFR),IS=2,4),POL

              IF (IUNIT.NE.0)
     &          WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &          ,WSTOKESF(1,IFR)
     &          ,(WSTOKESF(IS,IFR)/WSTOKESF(1,IFR),IS=2,4),POL

            ENDDO !IFR
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '     Photon energy [eV] or wavelength [nm] for selected point'
            WRITE(LUNGFO,*)
     &        '     of pinhole, S0, S1/S0, S2/S0, S3/S0, P of with emittance'
            WRITE(LUNGFO,*)
     &        '     STOKES vector per unit area [m**2]:'
            WRITE(LUNGFO,*)

            DO IFR=1,NFREQ
              IF (STOKECF(1,IFR).EQ.0.0) STOKECF(1,IFR)=1.E-10
              S1=STOKECF(1,IFR)
              S2=STOKECF(2,IFR)
              S3=STOKECF(3,IFR)
              S4=STOKECF(4,IFR)
              POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1
C         POL=
C     &                   SQRT(
C     &          (STOKECF(2,IFR)**2
C     &          +STOKECF(3,IFR)**2
C     &          +STOKECF(4,IFR)**2))
C     &          /STOKECF(1,IFR)
              IF (STOKECF(1,IFR).EQ.1.E-10) POL=0.0
              IF (IUNIT.EQ.0)
     &          WRITE(LUNGFO,2584)SNGL(FREQ(IFR))
     &          ,STOKECF(1,IFR),(STOKECF(IS,IFR)/STOKECF(1,IFR),
     &          IS=2,4),POL
              IF (IUNIT.NE.0)
     &          WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &          ,STOKECF(1,IFR),
     &          (STOKECF(IS,IFR)/STOKECF(1,IFR),IS=2,4),POL
            ENDDO !IFR

          ENDIF !IFOLD

        ENDIF  !IPIN


      ENDIF !ISTOKES

      IF (IW_BLENF.NE.0) ISPECSUM=1

C--- USE SIMPLE SUMMATION TO EVALUATE FLUX THROUGH PINHOLE (TEST PURPOSES)

      IF (IPIN.NE.0..AND.IPIN.NE.2.and.ipin.ne.3.AND.ISPECSUM.NE.0) THEN

          IF (ISTOKES.NE.0) THEN
               CALL STOKSUM
          ELSE
               CALL SPECSUM
          ENDIF   !ISTOKES

          IF (IFOLD.NE.0.AND.IFOLD.NE.2) THEN

         IF (ISTOKES.NE.0) THEN
             CALL STOKSUMF
         ELSE
             CALL SPECSUMF
         ENDIF !ISTOKES

          ENDIF   !IFOLD

      ENDIF !IPIN AND ISPECSUM

C--- WRITE FLUX THROUGH PINHOLE TO FILE

      IF(IWFILFL0.NE.0) THEN

         OPEN(UNIT=LUNFL0,FILE=FILEFL0,STATUS='NEW')

         WRITE(LUNFL0,*)ICODE,' ',CODE
         WRITE(LUNFL0,*)NFREQ,NSOURCE

         DO IFR=1,NFREQ
            IF (IUNIT.EQ.0)
     &         WRITE(LUNFL0,*)SNGL(FREQ(IFR))
     &                        ,(SNGL(WFLUX(IS+NSOURCE*(IFR-1))),IS=1,NSOURCE)
     &                           ,SNGL(WFLUXT(IFR))
            IF (IUNIT.NE.0)
     &         WRITE(LUNFL0,*)SNGL(WELLEN(IFR))
     &                        ,(SNGL(WFLUX(IS+NSOURCE*(IFR-1))),IS=1,NSOURCE)
     &                           ,SNGL(WFLUXT(IFR))
         ENDDO

         CLOSE(LUNFL0)
      ENDIF !IWFILFL0

      IF(ipin.ne.3.and.IFOLD.NE.0.AND.IWFILFLF.NE.0) THEN

         OPEN(UNIT=LUNFLF,FILE=FILEFLF)

         WRITE(LUNFLF,*)ICODE,' ',CODE
         WRITE(LUNFLF,*)NFREQ,NSOURCE

         DO IFR=1,NFREQ
            IF (IUNIT.EQ.0)
     &         WRITE(LUNFLF,*)SNGL(FREQ(IFR))
     &        ,(SNGL(WFLUXF(IS+NSOURCE*(IFR-1))),IS=1,NSOURCE)
     &        ,SNGL(WFLUXTF(IFR))
            IF (IUNIT.NE.0)
     &         WRITE(LUNFLF,*)SNGL(WELLEN(IFR))
     &        ,(SNGL(WFLUXF(IS+NSOURCE*(IFR-1))),IS=1,NSOURCE)
     &        ,SNGL(WFLUXTF(IFR))
         ENDDO

         CLOSE(LUNFLF)
      ENDIF !IWFILFLF

      IF (IPIN.NE.0) THEN

        STOKESMAX=0.0

        IF (ISTOKES.NE.0) THEN

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '      Total absolute maxima found for Stokes-V. (z,y,Eph,fluxdens.)'
          WRITE(LUNGFO,*)

          DO ISTOK=1,4

            DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
              DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
                IO=(IY-1)*NOBSVZ+IZ
                DO IFR=1,NFREQ
                  IF (ABS(STOKES(ISTOK,IO+NOBSV*(IFR-1))).GT.
     &                STOKESMAX(4,ISTOK)) THEN
                    STOKESMAX(1,ISTOK)=OBSV(2,IO)
                    STOKESMAX(2,ISTOK)=OBSV(3,IO)
                    STOKESMAX(3,ISTOK)=FREQ(IFR)
                    STOKESMAX(4,ISTOK)=STOKES(ISTOK,IO+NOBSV*(IFR-1))
                  ENDIF
                ENDDO   !IFR
              ENDDO  !IZ
            ENDDO !IY

            WRITE(LUNGFO,'(6X,4((1PE12.4)))')STOKESMAX(1:4,ISTOK)

          ENDDO !ISTOK

        ELSE !(ISTOKES.NE.0)

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '      Total absolute maxima found for flux-density (z,y,Eph,fluxdens.)'
          WRITE(LUNGFO,*)

          DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
            DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
              IO=(IY-1)*NOBSVZ+IZ
              DO IFR=1,NFREQ
                IF (SPECTOT(IO+NOBSV*(IFR-1)).GT.STOKESMAX(4,1)) THEN
                  STOKESMAX(1,1)=OBSV(2,IO)
                  STOKESMAX(2,1)=OBSV(3,IO)
                  STOKESMAX(3,1)=FREQ(IFR)
                  STOKESMAX(4,1)=SPECTOT(IO+NOBSV*(IFR-1))
                ENDIF
              ENDDO  !IFR
            ENDDO !IZ
          ENDDO   !IY

          WRITE(LUNGFO,'(6X,4((1PE12.4)))')STOKESMAX(1:4,1)

        ENDIF !(ISTOKES.NE.0)

        STOKESMAXF=0.0

        IF (IFOLD.NE.0.and.ipin.ne.3) THEN

          IF (ISTOKES.NE.0) THEN

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '      Total absolute maxima found for Stokes-V. with emittance'
            WRITE(LUNGFO,*)
     &        '      (z,y,Eph,fluxdens.)'
            WRITE(LUNGFO,*)

            DO ISTOK=1,4

              DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
                DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
                  IO=(IY-1)*NOBSVZ+IZ
                  DO IFR=1,NFREQ
                    IF (ABS(STOKESF(ISTOK,IO+NOBSV*(IFR-1))).GT.
     &                  STOKESMAXF(4,ISTOK)) THEN
                      STOKESMAXF(1,ISTOK)=OBSV(2,IO)
                      STOKESMAXF(2,ISTOK)=OBSV(3,IO)
                      STOKESMAXF(3,ISTOK)=FREQ(IFR)
                      STOKESMAXF(4,ISTOK)=STOKESF(ISTOK,IO+NOBSV*(IFR-1))
                    ENDIF
                  ENDDO !IFR
                ENDDO   !IZ
              ENDDO  !IY

              WRITE(LUNGFO,'(6X,4((1PE12.4)))')STOKESMAXF(1:4,ISTOK)

            ENDDO !ISTOK

          ELSE !(ISTOKES.NE.0)

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '      Total absolute maxima found for flux-dens. with emit. (z,y,Eph,fluxd.)'
            WRITE(LUNGFO,*)

            DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
              DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
                IO=(IY-1)*NOBSVZ+IZ
                DO IFR=1,NFREQ
                  IF (SPECTOTF(IO+NOBSV*(IFR-1)).GT.STOKESMAXF(4,1)) THEN
                    STOKESMAXF(1,1)=OBSV(2,IO)
                    STOKESMAXF(2,1)=OBSV(3,IO)
                    STOKESMAXF(3,1)=FREQ(IFR)
                    STOKESMAXF(4,1)=SPECTOTF(IO+NOBSV*(IFR-1))
                  ENDIF
                ENDDO   !IFR
              ENDDO  !IZ
            ENDDO !IY

            WRITE(LUNGFO,'(XXXXXX,4((1PE12.4)))')STOKESMAXF(1:4,1)

          ENDIF !(ISTOKES.NE.0)

        ENDIF !IFOLD

      ENDIF !IPIN

      IF(IEFOLD.NE.0) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)

        IF (ipin.ne.3.and.IEFOLD.NE.0) THEN
          CALL EFOLD
        ELSE IF (ipin.eq.3) THEN
          WRITE(LUNGFO,*)
     &      '     Beam energy spread (ESPREAD) for energy folding:'
          WRITE(LUNGFO,*)'     ',SNGL(ESPREAD)
        ELSE IF (IEFOLD.lt.0) THEN
          WRITE(LUNGFO,*)
     &      '     Beam energy spread (ESPREAD) and number of sigmas'
          WRITE(LUNGFO,*)
     &      '     for energy folding:'
          WRITE(LUNGFO,*)'     ',SNGL(ESPREAD),NSIGE
          WRITE(LUNGFO,*)
        ENDIF

        IF (IPIN.EQ.0) THEN

          IF (NOBSV.GT.1) THEN
            WRITE(LUNGFO,*)
     &        '       Photon energy [eV] or wavelength [nm] for first observation'
            IO=1
          ELSE
            WRITE(LUNGFO,*)
     &        '       Photon energy [eV] or wavelength [nm] for selected observation'
            IO=ICBRILL
          ENDIF

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     point, normalized components S0, S1/S0, S2/S0, S3/S0, P of'
          WRITE(LUNGFO,*)
     &      '     STOKES vector per unit area [m**2] (e-folded):'
          WRITE(LUNGFO,*)

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'          Observation point (x,y,z) [m]:'
          WRITE(LUNGFO,*)'          ',(SNGL(OBSV(IX,IO)),IX=1,3)
          WRITE(LUNGFO,*)

          DO IFR=1,NFREQ
            IF (WSTOKESE(1,IFR).EQ.0.0) WSTOKESE(1,IFR)=1.E-10
            S1=WSTOKESE(1,IFR)
            S2=WSTOKESE(2,IFR)
            S3=WSTOKESE(3,IFR)
            S4=WSTOKESE(4,IFR)
            POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1
            IF (WSTOKESE(1,IFR).EQ.1.E-10) POL=0.0
            IF (IUNIT.EQ.0)
     &        WRITE(LUNGFO,2584)SNGL(FREQ(IFR)),WSTOKESE(1,IFR)
     &        ,(WSTOKESE(IS,IFR)/WSTOKESE(1,IFR),IS=2,4),POL
            IF (IUNIT.NE.0)
     &        WRITE(LUNGFO,2584)SNGL(WELLEN(IFR)),WSTOKESE(1,IFR)
     &        ,(WSTOKESE(IS,IFR)/WSTOKESE(1,IFR),IS=2,4),POL
          ENDDO !IFR

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          IF (IFOLD.EQ.2) THEN
            IF (NOBSV.GT.1) THEN
              WRITE(LUNGFO,*)
     &          '       Photon energy [eV] or wavelength [nm] for first observation'
              IO=1
            ELSE
              WRITE(LUNGFO,*)
     &          '       Photon energy [eV] or wavelength [nm] for selected observation'
              IO=ICBRILL
            ENDIF

            WRITE(LUNGFO,*)
     &        '     point, normalized components S0, S1/S0, S2/S0, S3/S0, P of'
            WRITE(LUNGFO,*)
     &        '     STOKES vector per unit area [m**2] with emittance (e-folded):'
            WRITE(LUNGFO,*)

            DO IFR=1,NFREQ
              IF (WSTOKESEF(1,IFR).EQ.0.0) WSTOKESEF(1,IFR)=1.E-10
              S1=WSTOKESEF(1,IFR)
              S2=WSTOKESEF(2,IFR)
              S3=WSTOKESEF(3,IFR)
              S4=WSTOKESEF(4,IFR)
              POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1
              IF (WSTOKESEF(1,IFR).EQ.1.E-10) POL=0.0
              IF (IUNIT.EQ.0)
     &          WRITE(LUNGFO,2584)SNGL(FREQ(IFR)),WSTOKESEF(1,IFR)
     &          ,(WSTOKESEF(IS,IFR)/WSTOKESEF(1,IFR),IS=2,4),POL
              IF (IUNIT.NE.0)
     &          WRITE(LUNGFO,2584)SNGL(WELLEN(IFR)),WSTOKESEF(1,IFR)
     &          ,(WSTOKESEF(IS,IFR)/WSTOKESEF(1,IFR),IS=2,4),POL
            ENDDO !IFR
          ENDIF !IFOLD.EQ.2

        ELSE   !IPIN

          IF(IWFLSTOE.NE.0.AND.IEFOLD.NE.0) THEN

            OPEN(UNIT=LUNSTO,FILE=FILESTOE)

            WRITE(LUNSTO,*)ICODE,' ',CODE
            WRITE(LUNSTO,*)
            WRITE(LUNSTO,*)NSOURCE,NOBSV,NFREQ,IFREQ2P
            WRITE(LUNSTO,*)NOBSVZ,NOBSVY,MOBSVZ,MOBSVY
            WRITE(LUNSTO,*)MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY
            WRITE(LUNSTO,*)
            WRITE(LUNSTO,*)PINW,PINH,PINR
            WRITE(LUNSTO,*)OBSVDZ,OBSVDY
            WRITE(LUNSTO,*)

            WRITE(LUNSTO,*)(OBSVZ(IO),IO=1,NOBSVZ)
            WRITE(LUNSTO,*)
            WRITE(LUNSTO,*)(OBSVY(IO),IO=1,NOBSVY)
            WRITE(LUNSTO,*)

            DO IO=1,NOBSV
              WRITE(LUNSTO,*)(OBSV(IX,IO),IX=1,3)
              DO IFR=1,NFREQ
                IF (IUNIT.EQ.0) THEN !260194
                  IOBFR=IO+NOBSV*(IFR-1)
                  WRITE(LUNSTO,*)FREQ(IFR),(STOKESE(IS,IOBFR),IS=1,4)
                ELSE
                  WRITE(LUNSTO,*)WELLEN(IFR),(STOKESE(IS,IOBFR),IS=1,4)
                ENDIF
              ENDDO !NFREQ
            ENDDO !NOBSV

            CLOSE(LUNSTO)

          ENDIF !IWFLSTOE

          IF(IWFLSTOEF.NE.0.AND.IEFOLD.NE.0.AND.IFOLD.NE.0) THEN

            OPEN(UNIT=LUNSTO,FILE=FILESTOEF)

            WRITE(LUNSTO,*)ICODE,' ',CODE
            WRITE(LUNSTO,*)
            WRITE(LUNSTO,*)NSOURCE,NOBSV,NFREQ,IFREQ2P
            WRITE(LUNSTO,*)NOBSVZ,NOBSVY,MOBSVZ,MOBSVY
            WRITE(LUNSTO,*)MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY
            WRITE(LUNSTO,*)
            WRITE(LUNSTO,*)PINW,PINH,PINR
            WRITE(LUNSTO,*)OBSVDZ,OBSVDY
            WRITE(LUNSTO,*)

            WRITE(LUNSTO,*)(OBSVZ(IO),IO=1,NOBSVZ)
            WRITE(LUNSTO,*)
            WRITE(LUNSTO,*)(OBSVY(IO),IO=1,NOBSVY)
            WRITE(LUNSTO,*)

            DO IO=1,NOBSV
              WRITE(LUNSTO,*)(OBSV(IX,IO),IX=1,3)
              DO IFR=1,NFREQ
                IF (IUNIT.EQ.0) THEN !260194
                  IOBFR=IO+NOBSV*(IFR-1)
                  WRITE(LUNSTO,*)FREQ(IFR),(STOKESEF(IS,IOBFR),IS=1,4)
                ELSE
                  WRITE(LUNSTO,*)WELLEN(IFR),(STOKESEF(IS,IOBFR),IS=1,4)
                ENDIF
              ENDDO !NFREQ
            ENDDO !NOBSV

            CLOSE(LUNSTO)

          ENDIF !IWFLSTOEF

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     Photon energy or wavelength and normalized components S0, S1/S0,'
          WRITE(LUNGFO,*)
     &      '     S2/S0, S3/S0 of STOKES vector and polarization for pinhole'
          WRITE(LUNGFO,*)
     &      '     (e-folded):'
          WRITE(LUNGFO,*)

          DO IFR=1,NFREQ

            IF (WSTOKESE(1,IFR).EQ.0.0) WSTOKESE(1,IFR)=1.E-10

            S1=WSTOKESE(1,IFR)
            S2=WSTOKESE(2,IFR)
            S3=WSTOKESE(3,IFR)
            S4=WSTOKESE(4,IFR)
            POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1

            IF (IUNIT.EQ.0)
     &        WRITE(LUNGFO,2584)SNGL(FREQ(IFR))
     &        ,WSTOKESE(1,IFR)
     &        ,(WSTOKESE(IS,IFR)/WSTOKESE(1,IFR),IS=2,4),POL

            IF (IUNIT.NE.0)
     &        WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &        ,WSTOKESE(1,IFR)
     &        ,(WSTOKESE(IS,IFR)/WSTOKESE(1,IFR),IS=2,4),POL

          ENDDO !IFR

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     Photon energy or wavelength and normalized components S0, S1/S0,'
          WRITE(LUNGFO,*)
     &      '     S2/S0, S3/S0 of STOKES vector and polarization for selected point of'
          WRITE(LUNGFO,*)
     &      '     pinhole (e-folded):'
          WRITE(LUNGFO,*)

          DO IFR=1,NFREQ

            IF (STOKECE(1,IFR).EQ.0.0) STOKECE(1,IFR)=1.E-10

            S1=STOKECE(1,IFR)
            S2=STOKECE(2,IFR)
            S3=STOKECE(3,IFR)
            S4=STOKECE(4,IFR)
            POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1

            IF (IUNIT.EQ.0)
     &        WRITE(LUNGFO,2584)SNGL(FREQ(IFR))
     &        ,STOKECE(1,IFR)
     &        ,(STOKECE(IS,IFR)/STOKECE(1,IFR),IS=2,4),POL

            IF (IUNIT.NE.0)
     &        WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &        ,STOKECE(1,IFR)
     &        ,(STOKECE(IS,IFR)/STOKECE(1,IFR),IS=2,4),POL

          ENDDO !IFR

          STOKESMAXE=0.0

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '      Total absolute maxima found for Stokes-V. with'
          WRITE(LUNGFO,*)
     &      '      e-spread (z,y,Eph,fluxdens.)'
          WRITE(LUNGFO,*)

          DO ISTOK=1,4

            DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
              DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
                IO=(IY-1)*NOBSVZ+IZ
                DO IFR=1,NFREQ
                  IF (ABS(STOKESE(ISTOK,IO+NOBSV*(IFR-1))).GT.
     &                STOKESMAXE(4,ISTOK)) THEN
                    STOKESMAXE(1,ISTOK)=OBSV(2,IO)
                    STOKESMAXE(2,ISTOK)=OBSV(3,IO)
                    STOKESMAXE(3,ISTOK)=FREQ(IFR)
                    STOKESMAXE(4,ISTOK)=STOKESE(ISTOK,IO+NOBSV*(IFR-1))
                  ENDIF
                ENDDO   !IFR
              ENDDO  !IZ
            ENDDO !IY

            WRITE(LUNGFO,'(6X,4((1PE12.4)))')STOKESMAXE(1:4,ISTOK)

          ENDDO !ISTOK

          IF (IFOLD.NE.0.and.ipin.ne.3)   THEN

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '     Energy, S0, S1/S0, S2/S0, S3/S0 and P for pinhole with emittance'
            WRITE(LUNGFO,*)
     &        '     (e-folded):'
            WRITE(LUNGFO,*)

            DO IFR=1,NFREQ

              IF (WSTOKESEF(1,IFR).EQ.0.0) WSTOKESEF(1,IFR)=1.E-10

              S1=WSTOKESEF(1,IFR)
              S2=WSTOKESEF(2,IFR)
              S3=WSTOKESEF(3,IFR)
              S4=WSTOKESEF(4,IFR)
              POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1

              IF (IUNIT.EQ.0)
     &          WRITE(LUNGFO,2584)SNGL(FREQ(IFR))
     &          ,WSTOKESEF(1,IFR)
     &          ,(WSTOKESEF(IS,IFR)/WSTOKESEF(1,IFR),IS=2,4),POL

              IF (IUNIT.NE.0)
     &          WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &          ,WSTOKESEF(1,IFR)
     &          ,(WSTOKESEF(IS,IFR)/WSTOKESEF(1,IFR),IS=2,4),POL

            ENDDO !IFR

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '     Energy, S0, S1/S0, S2/S0, S3/S0 and P for selected point of pinhole'
            WRITE(LUNGFO,*)
     &        '     with emittance (e-folded):'
            WRITE(LUNGFO,*)

            DO IFR=1,NFREQ

              IF (STOKECEF(1,IFR).EQ.0.0) STOKECEF(1,IFR)=1.E-10

              S1=STOKECEF(1,IFR)
              S2=STOKECEF(2,IFR)
              S3=STOKECEF(3,IFR)
              S4=STOKECEF(4,IFR)
              POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1

              IF (IUNIT.EQ.0)
     &          WRITE(LUNGFO,2584)SNGL(FREQ(IFR))
     &          ,STOKECEF(1,IFR)
     &          ,(STOKECEF(IS,IFR)/STOKECEF(1,IFR),IS=2,4),POL

              IF (IUNIT.NE.0)
     &          WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &          ,STOKECEF(1,IFR)
     &          ,(STOKECEF(IS,IFR)/STOKECEF(1,IFR),IS=2,4),POL

            ENDDO !IFR

          ENDIF !IFOLD

        ENDIF  !IPIN

        STOKESMAXEF=0.0

        IF (ipin.ne.3.and.IFOLD.NE.0) THEN

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '      Total absolute maxima found for Stokes-V. with'
          WRITE(LUNGFO,*)
     &      '      emit. and e-spread (z,y,Eph,fluxdens.)'
          WRITE(LUNGFO,*)

          DO ISTOK=1,4

            DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
              DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
                IO=(IY-1)*NOBSVZ+IZ
                DO IFR=1,NFREQ
                  IF (ABS(STOKESEF(ISTOK,IO+NOBSV*(IFR-1))).GT.
     &                STOKESMAXEF(4,ISTOK)) THEN
                    STOKESMAXEF(1,ISTOK)=OBSV(2,IO)
                    STOKESMAXEF(2,ISTOK)=OBSV(3,IO)
                    STOKESMAXEF(3,ISTOK)=FREQ(IFR)
                    STOKESMAXEF(4,ISTOK)=STOKESEF(ISTOK,IO+NOBSV*(IFR-1))
                  ENDIF
                ENDDO   !IFR
              ENDDO  !IZ
            ENDDO !IY

            WRITE(LUNGFO,'(6X,4((1PE12.4)))')STOKESMAXEF(1:4,ISTOK)

          ENDDO !ISTOK

        ENDIF !IFOLD

      ENDIF !IEFOLD

      IF(IWFILS.NE.0.AND.ISTOKES.NE.0) THEN

        OPEN(UNIT=LUNS,FILE=FILES)

        WRITE(LUNS,*)ICODE,' ',CODE
        WRITE(LUNS,*)NFREQ

        DO IFR=1,NFREQ
          IF (IUNIT.EQ.0)
     &      WRITE(LUNS,*)SNGL(FREQ(IFR))
     &      ,((WSTOKES(IS,IFR)),IS=1,4)
          IF (IUNIT.NE.0)
     &      WRITE(LUNS,*)SNGL(WELLEN(IFR))
     &      ,((WSTOKES(IS,IFR)),IS=1,4)
        ENDDO

        CLOSE(LUNS)
      ENDIF !IWFILS

      IF(IFOLD.NE.0.AND.IWFILSF.NE.0.AND.ISTOKES.NE.0) THEN

        OPEN(UNIT=LUNSF,FILE=FILESF)

        WRITE(LUNSF,*)ICODE,' ',CODE
        WRITE(LUNSF,*)NFREQ

        DO IFR=1,NFREQ
          IF (IUNIT.EQ.0)
     &      WRITE(LUNSF,*)SNGL(FREQ(IFR))
     &      ,((WSTOKESF(IS,IFR)),IS=1,4)
          IF (IUNIT.NE.0)
     &      WRITE(LUNSF,*)SNGL(WELLEN(IFR))
     &      ,((WSTOKESF(IS,IFR)),IS=1,4)
        ENDDO

        CLOSE(LUNSF)
      ENDIF !IWFILSF

      IF(IEFOLD.NE.0.AND.IWFILSE.NE.0.AND.ISTOKES.NE.0) THEN

        OPEN(UNIT=LUNSE,FILE=FILESE)

        WRITE(LUNSE,*)ICODE,' ',CODE
        WRITE(LUNSE,*)NFREQ

        DO IFR=1,NFREQ
          IF (IUNIT.EQ.0)
     &      WRITE(LUNSE,*)SNGL(FREQ(IFR))
     &      ,((WSTOKESE(IS,IFR)),IS=1,4)
          IF (IUNIT.NE.0)
     &      WRITE(LUNSE,*)SNGL(WELLEN(IFR))
     &      ,((WSTOKESE(IS,IFR)),IS=1,4)
        ENDDO

        CLOSE(LUNSE)
      ENDIF !IWFILSE

      IF(IEFOLD.NE.0.AND.IFOLD.NE.0.AND.IWFILSEF.NE.0.AND.ISTOKES.NE.0) THEN

        OPEN(UNIT=LUNSEF,FILE=FILESEF)

        WRITE(LUNSEF,*)ICODE,' ',CODE
        WRITE(LUNSEF,*)NFREQ

        DO IFR=1,NFREQ
          IF (IUNIT.EQ.0)
     &      WRITE(LUNSEF,*)SNGL(FREQ(IFR))
     &      ,((WSTOKESEF(IS,IFR)),IS=1,4)
          IF (IUNIT.NE.0)
     &      WRITE(LUNSEF,*)SNGL(WELLEN(IFR))
     &      ,((WSTOKESEF(IS,IFR)),IS=1,4)
        ENDDO

        CLOSE(LUNSEF)
      ENDIF !IWFILSEF

      IF(IWFILB.NE.0.AND.ISTOKES.NE.0) THEN

        OPEN(UNIT=LUNC,FILE=FILEC)

        WRITE(LUNC,*)ICODE,' ',CODE
        WRITE(LUNC,*)nintFREQ

        DO IFR=1,NFREQ
           if (freq(ifr).ge.freqlow-(freq(2)-freq(1))/2.0d0
     &         .and.freq(ifr).le.freqhig+(freq(2)-freq(1))/2.0d0) then
          IF (IUNIT.EQ.0)
     &      WRITE(LUNC,*)SNGL(FREQ(IFR))
     &      ,((STOKEC(IS,IFR)),IS=1,4)
          IF (IUNIT.NE.0)
     &      WRITE(LUNC,*)SNGL(WELLEN(IFR))
     &      ,((STOKEC(IS,IFR)),IS=1,4)
          endif
        ENDDO

        CLOSE(LUNC)
      ENDIF !IWFILB

      IF(IFOLD.NE.0.AND.IWFILBF.NE.0.AND.ISTOKES.NE.0) THEN

        OPEN(UNIT=LUNCF,FILE=FILECF)

        WRITE(LUNCF,*)ICODE,' ',CODE
        WRITE(LUNCF,*)NintFREQ

        DO IFR=1,NFREQ
           if (freq(ifr).ge.freqlow-(freq(2)-freq(1))/2.0d0
     &         .and.freq(ifr).le.freqhig+(freq(2)-freq(1))/2.0d0) then
          IF (IUNIT.EQ.0)
     &      WRITE(LUNCF,*)SNGL(FREQ(IFR))
     &      ,((STOKECF(IS,IFR)),IS=1,4)
          IF (IUNIT.NE.0)
     &      WRITE(LUNCF,*)SNGL(WELLEN(IFR))
     &      ,((STOKECF(IS,IFR)),IS=1,4)
          endif
        ENDDO

        CLOSE(LUNCF)
      ENDIF !IWFILBF

      IF(IEFOLD.NE.0.AND.IWFILBE.NE.0.AND.ISTOKES.NE.0) THEN

         OPEN(UNIT=LUNCE,FILE=FILECE)

         WRITE(LUNCE,*)ICODE,' ',CODE
         WRITE(LUNCE,*)nintFREQ

         DO IFR=1,NFREQ
           if (freq(ifr).ge.freqlow-(freq(2)-freq(1))/2.0d0
     &         .and.freq(ifr).le.freqhig+(freq(2)-freq(1))/2.0d0) then
           IF (IUNIT.EQ.0)
     &       WRITE(LUNCE,*)SNGL(FREQ(IFR))
     &       ,((STOKECE(IS,IFR)),IS=1,4)
           IF (IUNIT.NE.0)
     &       WRITE(LUNCE,*)SNGL(WELLEN(IFR))
     &       ,((STOKECE(IS,IFR)),IS=1,4)
           endif
         ENDDO

         CLOSE(LUNCE)
       ENDIF !IWFILBE

       IF(IEFOLD.NE.0.AND.IFOLD.NE.0.AND.IWFILBEF.NE.0.AND.ISTOKES.NE.0) THEN

         OPEN(UNIT=LUNCEF,FILE=FILECEF)

         WRITE(LUNCEF,*)ICODE,' ',CODE
         WRITE(LUNCEF,*)NintFREQ

         DO IFR=1,NFREQ
           if (freq(ifr).ge.freqlow-(freq(2)-freq(1))/2.0d0
     &         .and.freq(ifr).le.freqhig+(freq(2)-freq(1))/2.0d0) then
           IF (IUNIT.EQ.0)
     &       WRITE(LUNCEF,*)SNGL(FREQ(IFR))
     &       ,((STOKECEF(IS,IFR)),IS=1,4)
           IF (IUNIT.NE.0)
     &       WRITE(LUNCEF,*)SNGL(WELLEN(IFR))
     &       ,((STOKECEF(IS,IFR)),IS=1,4)
           endif
         ENDDO

         CLOSE(LUNCEF)
       ENDIF !IWFILBEF

       IF (ISTOKES.NE.0) THEN

         DO ISTO=1,4

           DO IFREQ=1,NFREQ
             SPECBUFF(IFREQ)=ABS(STOKEC(ISTO,IFREQ))
           ENDDO  !IFR
           CALL UTIL_MAX_PARABEL
     &       (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
           STOKCMX(ISTO,1)=DUM1
           STOKCMX(ISTO,2)=DUM2

           IF (IFAIL.NE.0) THEN
             WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S',ISTO
             WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
           ENDIF

           IF (IFOLD.NE.0) THEN
             DO IFREQ=1,NFREQ
               SPECBUFF(IFREQ)=ABS(STOKECF(ISTO,IFREQ))
             ENDDO   !IFR
             CALL UTIL_MAX_PARABEL
     &         (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
             STOKCMXF(ISTO,1)=DUM1
             STOKCMXF(ISTO,2)=DUM2
             IF (IFAIL.NE.0) THEN
               WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S',ISTO
               WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
             ENDIF
           ENDIF

           IF (IEFOLD.NE.0) THEN
             DO IFREQ=1,NFREQ
               SPECBUFF(IFREQ)=ABS(STOKECE(ISTO,IFREQ))
             ENDDO   !IFR
             CALL UTIL_MAX_PARABEL
     &         (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
             STOKCMXE(ISTO,1)=DUM1
             STOKCMXE(ISTO,2)=DUM2
             IF (IFAIL.NE.0) THEN
               WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S',ISTO
               WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
             ENDIF
           ENDIF

           IF (IFOLD.NE.0.AND.IEFOLD.NE.0) THEN
             DO IFREQ=1,NFREQ
               SPECBUFF(IFREQ)=ABS(STOKECEF(ISTO,IFREQ))
             ENDDO   !IFR
             CALL UTIL_MAX_PARABEL
     &         (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
             STOKCMXEF(ISTO,1)=DUM1
             STOKCMXEF(ISTO,2)=DUM2
             IF (IFAIL.NE.0) THEN
               WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S',ISTO
               WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
             ENDIF
           ENDIF

         ENDDO !ISTO

       ENDIF   !ISTOKES

       IF (NFREQ.GT.1) THEN

         IF (ISTOKES.NE.0) THEN

           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
          if (ipin.ne.3) then
            WRITE(LUNGFO,*)
     &        '      Estimated maxima of s0, s1, s2 ,s3 for selected point:'
          else
            WRITE(LUNGFO,*)
     &        '      Estimated maxima of mean densities of s0, s1, s2 ,s3:'
          endif
           DO ISTO=1,4
             WRITE(LUNGFO,*)'      ',STOKCMX(ISTO,1),STOKCMX(ISTO,2)
           ENDDO  !ISTO

           IF (IFOLD.NE.0) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &         '      Estimated maxima of s0, s1, s2 ,s3 for selected point with emittance:'
             DO ISTO=1,4
               WRITE(LUNGFO,*)'      ',STOKCMXF(ISTO,1),STOKCMXF(ISTO,2)
             ENDDO   !ISTO
           ENDIF  !IFOLD

           IF (IEFOLD.NE.0) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &         '      Estimated maxima of s0, s1, s2 ,s3 for selected point with energy spread:'
             DO ISTO=1,4
               WRITE(LUNGFO,*)'      ',STOKCMXE(ISTO,1),STOKCMXE(ISTO,2)
             ENDDO   !ISTO
           ENDIF  !IFOLD

           IF (IFOLD.NE.0.AND.IEFOLD.NE.0) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &         '      Estimated maxima of s0, s1, s2 ,s3 for selected point'
             WRITE(LUNGFO,*)
     &         '      with emittance and energy spread:'
             DO ISTO=1,4
               WRITE(LUNGFO,*)'      ',STOKCMXEF(ISTO,1),STOKCMXEF(ISTO,2)
             ENDDO   !ISTO
           ENDIF

           DO IFREQ=1,NFREQ
             S1=STOKEC(1,IFREQ)
             S2=STOKEC(2,IFREQ)
             S3=STOKEC(3,IFREQ)
             S4=STOKEC(4,IFREQ)
             IF (S1.NE.0.0) THEN
               POL=S4/S1*S4
             ELSE
               POL=0.0d0
             ENDIF
             SPECBUFF(IFREQ)=ABS(POL)
           ENDDO  !IFR
           CALL UTIL_MAX_PARABEL
     &       (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
           G3CMX(1)=DUM1
           G3CMX(2)=DUM2
           IF (IFAIL.NE.0) THEN
             WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S'
             WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
           ENDIF

           IF (IFOLD.NE.0) THEN
             DO IFREQ=1,NFREQ
               S1=STOKECF(1,IFREQ)
               S2=STOKECF(2,IFREQ)
               S3=STOKECF(3,IFREQ)
               S4=STOKECF(4,IFREQ)
               IF (S1.NE.0.0) THEN
                 POL=S4/S1*S4
               ELSE
                 POL=0.0d0
               ENDIF
               SPECBUFF(IFREQ)=ABS(POL)
             ENDDO   !IFR
             CALL UTIL_MAX_PARABEL
     &         (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
             G3CMXF(1)=DUM1
             G3CMXF(2)=DUM2
             IF (IFAIL.NE.0) THEN
               WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S3*S3/S0'
               WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
             ENDIF
           ENDIF

           IF (IEFOLD.NE.0) THEN
             DO IFREQ=1,NFREQ
               S1=STOKECE(1,IFREQ)
               S2=STOKECE(2,IFREQ)
               S3=STOKECE(3,IFREQ)
               S4=STOKECE(4,IFREQ)
               IF (S1.NE.0.0) THEN
                 POL=S4/S1*S4
               ELSE
                 POL=0.0d0
               ENDIF
               SPECBUFF(IFREQ)=ABS(POL)
             ENDDO   !IFR
             CALL UTIL_MAX_PARABEL
     &         (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
             G3CMXE(1)=DUM1
             G3CMXE(2)=DUM2
             IF (IFAIL.NE.0) THEN
               WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S3*S3/S0'
               WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
             ENDIF
           ENDIF

           IF (IFOLD.NE.0.AND.IEFOLD.NE.0) THEN

             DO IFREQ=1,NFREQ
               S1=STOKECEF(1,IFREQ)
               S2=STOKECEF(2,IFREQ)
               S3=STOKECEF(3,IFREQ)
               S4=STOKECEF(4,IFREQ)
               IF (S1.NE.0.0) THEN
                 POL=S4/S1*S4
               ELSE
                 POL=0.0d0
               ENDIF
               SPECBUFF(IFREQ)=ABS(POL)
             ENDDO   !IFREQ

             CALL UTIL_MAX_PARABEL
     &         (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
             G3CMXEF(1)=DUM1
             G3CMXEF(2)=DUM2
             IF (IFAIL.NE.0) THEN
               WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S3*S3/S0'
               WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
             ENDIF

           ENDIF  !IFOLD,IEFOLD

           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
           if (ipin.ne.3) then
             WRITE(LUNGFO,*)
     &         '      Estimated maximum of s3*s3/s0 for selected point:'
           else
             WRITE(LUNGFO,*)
     &         '      Estimated maximum of mean density s3*s3/s0:'
           endif
           WRITE(LUNGFO,*)'      ',G3CMX(1),G3CMX(2)

           IF (IFOLD.NE.0) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &         '      Estimated maximum of s3*s3/s0 for selected point with emittance:'
             WRITE(LUNGFO,*)'      ',G3CMXF(1),G3CMXF(2)
           ENDIF!IFOLD

           IF (IEFOLD.NE.0) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &         '      Estimated maximum of s3*s3/s0 for selected point with energy spread:'
             WRITE(LUNGFO,*)'      ',G3CMXE(1),G3CMXE(2)
           ENDIF  !IEFOLD

           IF (IFOLD.NE.0.AND.IEFOLD.NE.0) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &         '      Estimated maximum of s3*s3/s0 for selected point'
             WRITE(LUNGFO,*)
     &         '      with emittance and energy spread:'
             WRITE(LUNGFO,*)'      ',G3CMXEF(1),G3CMXEF(2)
           ENDIF !IFOLD,IEFOLD

           IF (IPIN.NE.0) THEN

             DO ISTO=1,4

               DO IFREQ=1,NFREQ
                 SPECBUFF(IFREQ)=ABS(WSTOKES(ISTO,IFREQ))
c                 print*,"spectrum:",isto,ifreq,wstokes(isto,ifreq)
               ENDDO !IFR
               CALL UTIL_MAX_PARABEL
     &           (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
               WSTOKMX(ISTO,1)=DUM1
               WSTOKMX(ISTO,2)=DUM2
               IF (IFAIL.NE.0) THEN
                 WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S',ISTO
                 WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
               ENDIF


               IF (IFOLD.NE.0) THEN
                 DO IFREQ=1,NFREQ
                   SPECBUFF(IFREQ)=ABS(WSTOKESF(ISTO,IFREQ))
                 ENDDO  !IFR
                 CALL UTIL_MAX_PARABEL
     &             (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
                 WSTOKMXF(ISTO,1)=DUM1
                 WSTOKMXF(ISTO,2)=DUM2
                 IF (IFAIL.NE.0) THEN
                   WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S',ISTO
                   WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
                 ENDIF
               ENDIF !IFOLD

               IF (IEFOLD.NE.0) THEN
                 DO IFREQ=1,NFREQ
                   SPECBUFF(IFREQ)=ABS(WSTOKESE(ISTO,IFREQ))
                 ENDDO  !IFR
                 CALL UTIL_MAX_PARABEL
     &             (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
                 WSTOKMXE(ISTO,1)=DUM1
                 WSTOKMXE(ISTO,2)=DUM2
                 IF (IFAIL.NE.0) THEN
                   WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S',ISTO
                   WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
                 ENDIF
               ENDIF !IEFOLD

               IF (IFOLD.NE.0.AND.IEFOLD.NE.0) THEN
                 DO IFREQ=1,NFREQ
                   SPECBUFF(IFREQ)=ABS(WSTOKESEF(ISTO,IFREQ))
                 ENDDO  !IFR
                 CALL UTIL_MAX_PARABEL
     &             (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
                 WSTOKMXEF(ISTO,1)=DUM1
                 WSTOKMXEF(ISTO,2)=DUM2
                 IF (IFAIL.NE.0) THEN
                   WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S',ISTO
                   WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
                 ENDIF
               ENDIF !IFOLD,IEFOLD

             ENDDO   !ISTO

             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &         '      Estimated maxima of fluxes s0, s1, s2 ,s3:'
             DO ISTO=1,4
               WRITE(LUNGFO,*)'      ',WSTOKMX(ISTO,1),WSTOKMX(ISTO,2)
             ENDDO   !ISTO

             IF (IFOLD.NE.0) THEN
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
     &           '      Estimated maxima of fluxes s0, s1, s2 ,s3 with emittance:'
               DO ISTO=1,4
                 WRITE(LUNGFO,*)'      ',WSTOKMXF(ISTO,1),WSTOKMXF(ISTO,2)
               ENDDO !ISTO
             ENDIF

             IF (IEFOLD.NE.0) THEN
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
     &           '      Estimated maxima of fluxes s0, s1, s2 ,s3 with energy spread:'
               DO ISTO=1,4
                 WRITE(LUNGFO,*)'      ',WSTOKMXE(ISTO,1),WSTOKMXE(ISTO,2)
               ENDDO !ISTO
             ENDIF

             IF (IFOLD.NE.0.AND.IEFOLD.NE.0) THEN
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
     &           '      Estimated maxima of fluxes s0, s1, s2 ,s3'
               WRITE(LUNGFO,*)
     &           '      with emittance and energy spread:'
               DO ISTO=1,4
                 WRITE(LUNGFO,*)'      ',WSTOKMXEF(ISTO,1),WSTOKMXEF(ISTO,2)
               ENDDO !ISTO
             ENDIF

             DO IFREQ=1,NFREQ
               S1=WSTOKES(1,IFREQ)
               S2=WSTOKES(2,IFREQ)
               S3=WSTOKES(3,IFREQ)
               S4=WSTOKES(4,IFREQ)
               IF (S1.NE.0.0) THEN
                 POL=S4/S1*S4
               ELSE
                 POL=0.0d0
               ENDIF
               SPECBUFF(IFREQ)=ABS(POL)
             ENDDO   !IFR
             CALL UTIL_MAX_PARABEL
     &         (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
             WG3MX(1)=DUM1
             WG3MX(2)=DUM2
             IF (IFAIL.NE.0) THEN
               WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S3*S3/S0'
               WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
             ENDIF

             IF (IEFOLD.NE.0) THEN
               DO IFREQ=1,NFREQ
                 S1=WSTOKESE(1,IFREQ)
                 S2=WSTOKESE(2,IFREQ)
                 S3=WSTOKESE(3,IFREQ)
                 S4=WSTOKESE(4,IFREQ)
                 IF (S1.NE.0.0) THEN
                   POL=S4/S1*S4
                 ELSE
                   POL=0.0d0
                 ENDIF
                 SPECBUFF(IFREQ)=ABS(POL)
               ENDDO !IFR
               CALL UTIL_MAX_PARABEL
     &           (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
               WG3MXE(1)=DUM1
               WG3MXE(2)=DUM2
               IF (IFAIL.NE.0) THEN
                 WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S3*S3/S0'
                 WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
               ENDIF
             ENDIF   !IEFOLD

             IF (IFOLD.NE.0) THEN
               DO IFREQ=1,NFREQ
                 S1=WSTOKESF(1,IFREQ)
                 S2=WSTOKESF(2,IFREQ)
                 S3=WSTOKESF(3,IFREQ)
                 S4=WSTOKESF(4,IFREQ)
                 IF (S1.NE.0.0) THEN
                   POL=S4/S1*S4
                 ELSE
                   POL=0.0d0
                 ENDIF
                 SPECBUFF(IFREQ)=ABS(POL)
               ENDDO !IFR
               CALL UTIL_MAX_PARABEL
     &           (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
               WG3MXF(1)=DUM1
               WG3MXF(2)=DUM2
               IF (IFAIL.NE.0) THEN
                 WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S3*S3/S0'
                 WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
               ENDIF
             ENDIF   !IFOLD

             IF (IFOLD.NE.0.AND.IEFOLD.NE.0) THEN
               DO IFREQ=1,NFREQ
                 S1=WSTOKESEF(1,IFREQ)
                 S2=WSTOKESEF(2,IFREQ)
                 S3=WSTOKESEF(3,IFREQ)
                 S4=WSTOKESEF(4,IFREQ)
                 IF (S1.NE.0.0) THEN
                   POL=S4/S1*S4
                 ELSE
                   POL=0.0d0
                 ENDIF
                 SPECBUFF(IFREQ)=ABS(POL)
               ENDDO !IFR
               CALL UTIL_MAX_PARABEL
     &           (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
               WG3MXEF(1)=DUM1
               WG3MXEF(2)=DUM2
               IF (IFAIL.NE.0) THEN
                 WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S3*S3/S0'
                 WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
               ENDIF
             ENDIF   !IFOLD,IEFOLD

             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &         '      Estimated maxima of fluxes s3*s3/s0:'
             WRITE(LUNGFO,*)'      ',WG3MX(1),WG3MX(2)

             IF (IFOLD.NE.0) THEN
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
     &           '      Estimated maxima of fluxes s3*s3/s0 with emittance:'
               WRITE(LUNGFO,*)'      ',WG3MXF(1),WG3MXF(2)
             ENDIF

             IF (IEFOLD.NE.0) THEN
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
     &           '      Estimated maxima of fluxes s3*s3/s0 with energy spread:'
               WRITE(LUNGFO,*)'      ',WG3MXE(1),WG3MXE(2)
             ENDIF

             IF (IFOLD.NE.0.AND.IEFOLD.NE.0) THEN
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
     &           '      Estimated maxima of fluxes s3*s3/s0'
               WRITE(LUNGFO,*)
     &           '      with emittance and energy spread:'
               WRITE(LUNGFO,*)'      ',WG3MXEF(1),WG3MXEF(2)
             ENDIF

           ENDIF  !ISTOKES

         ENDIF !IPIN

      ENDIF !NFREQ

C---BRILLIANCE


      IF (IBRILL.NE.0) CALL BRILL

C--- STORE RESULT IN HISTOGRAMS

      ALLOCATE(FILL(NOBSV))
      DO I=1,NOBSV
        FILL(I)=0.0d0
      ENDDO

      IF(IHPIN.GT.0) THEN
        CALL HSPEC
      ELSE IF (IHFOLD.NE.0) THEN
        CALL HFOLD
      ENDIF

      !{ Fold power density
      !Baustelle
      !} Fold power density

      IF(IWFILPOW.NE.0) THEN

         OPEN(UNIT=LUNPOW,FILE=FILEPOW)

         IF (IWFILPOW.GT.0) THEN
           WRITE(LUNPOW,*)ICODE,' ',CODE
         ENDIF

         if (ipin.ne.0) then
           DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
             DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
               IO=(IY-1)*NOBSVZ+IZ
               DUM1=0.0d0
               IF(IFOLD.NE.0) DUM1=SPECTOTIF(IO)
               WRITE(LUNPOW,'(7(1PE13.5))')(OBSV(IX,IO)*1.E3,IX=1,3)
     &           ,SPECPOWT(IO)/1.0E6,SPECTOTI(IO)/1.E6,DUM1/1.E6
     &           ,SPECPOWTgraz(IO)/1.0e6
             ENDDO
           ENDDO
         else
           dum1=0.0d0
           do iobsv=1,nobsv
             write(lunpow,'(7(1pe13.5))')(obsv(ix,iobsv)*1.e3,ix=1,3)
     &         ,specpowt(iobsv)/1.0e6,spectoti(iobsv)/1.e6,dum1/1.e6
     &         ,SPECPOWTgraz(iobsv)/1.0e6
           enddo
         endif

         CLOSE(LUNPOW)

      ENDIF !IWFILPOW

      if (iphoton.ne.0.and.ecphoton.gt.0.0d0) call uout_photon

      IF(IHFREQ.NE.0) CALL HFREQ

      RETURN
      END
+DECK,uout.
*CMZ :          17/10/2023  12.50.02  by  Michael Scheer
*CMZ :  4.01/03 15/05/2023  14.11.27  by  Michael Scheer
*CMZ :  4.00/17 15/11/2022  10.13.07  by  Michael Scheer
*CMZ :  4.00/15 01/06/2022  16.47.26  by  Michael Scheer
*CMZ :  4.00/11 28/06/2021  10.33.06  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine uout

+seq,trackf90u.
+seq,spectf90u.

      use sourcef90
      use observf90
      use afreqf90
      !use waveenv

      implicit none

+self,if=uout_scheer.
      complex*16 amp0(3),amp(3),zexp

      double precision dtelec,dtpho,t0,perlen,dph,dobs(3),drn(3),cosang,
     &  dobsn(3),r0(3),r(3),dr(3),v(3),t,dt,dist,obs(3),om,fd,dist0

      double precision :: enemax=0.0d0,s0max=-1.0d30

      integer ifreq,iobsv,nper,i,lunio,iseed
      integer, parameter :: ndimsplit=100
      integer :: nwords=0, ipos(2,ndimsplit),istat=0,mode=0,io,ifr

      character(2048) cline
+self.
+seq,contrl.
+seq,cmpara.
+seq,track.
+seq,track0.
+seq,spect.
+seq,observ.
+seq,freqs.
+seq,sourcef90.
+seq,berror.
+seq,ampli.
+seq,phycon.
+seq,waveenv.
+seq,uservar.

+self,if=uout_scheer.
      if (iuout.eq.20220601) then
        enemax=spectotmx(3)
        s0max=spectotmx(4)/1.0d6
        open(newunit=lunio,file='uout.in',status='old',iostat=iseed)
        if (iseed.eq.0) then
          read(lunio,*) iseed
        else
          iseed=0
        endif
        close(lunio)
        open(newunit=lunio,file='serie_pherror.out',access='append')
        if (iberror.ne.0) then
          if (nberror.eq.0) then
            write(lunio,*) trim(chwstage)//'-1/2_1_-1/2',iseed,b0error,resrms*360.0d0,
     &        enemax,s0max
          else if (nberror.eq.1) then
            write(lunio,*) trim(chwstage)//'_1_',iseed,b0error,resrms*360.0d0,
     &        enemax,s0max
          else if (nberror.eq.2) then
            write(lunio,*) trim(chwstage)//'-1_1_',iseed,b0error,resrms*360.0d0,
     &        enemax,s0max
          endif
        else
          if (userchar(1).eq.'b0error') then
            write(lunio,*) trim(chwstage)//"_berr",iseed,'-1',user(1),resrms*360.0d0,
     &        enemax,s0max
          else
            write(lunio,*) trim(chwstage)//'_pherr',iseed,'-2',phrerror,resrms*360.0d0,
     &        enemax,s0max
          endif
        endif
        flush(lunio)
        close(lunio)
        return
      endif

      if (iuout.eq.20220516) then
c        s0max=-1.0d30
c        do io=1,nobsv
c          do ifr=1,nfreq
c            if (spectot(io+nobsv*(ifr-1)).gt.s0max) then
c              enemax=freq(ifr)
c              s0max=spectot(io+nobsv*(ifr-1))/1.0d6
c            endif
c          enddo
c        enddo
        enemax=spectotmx(3)
        s0max=spectotmx(4)/1.0d6
        open(newunit=lunio,file='uout.in',status='old',iostat=iseed)
        if (iseed.eq.0) then
          read(lunio,*) iseed
        else
          iseed=0
        endif
        close(lunio)
        open(newunit=lunio,file='serie_b0error.out',access='append')
        write(lunio,'(2I10,4(1pe15.7))') icode,iseed,b0error,resrms*360.0d0,
     &    enemax,s0max
        flush(lunio)
        close(lunio)
        return
      endif

      if (iuout.eq.20220517) then
c        s0max=-1.0d30
c        do io=1,nobsv
c          do ifr=1,nfreq
c            if (spectot(io+nobsv*(ifr-1)).gt.s0max) then
c              enemax=freq(ifr)
c              s0max=spectot(io+nobsv*(ifr-1))/1.0d6
c            endif
c          enddo
c        enddo
        enemax=spectotmx(3)
        s0max=spectotmx(4)/1.0d6
        open(newunit=lunio,file='uout.in',status='old',iostat=iseed)
        if (iseed.eq.0) then
          read(lunio,'(a)') cline
          call util_string_split(cline,ndimsplit,nwords,ipos,istat)
        else
          cline='0 unknown'
        endif
        close(lunio)
        open(newunit=lunio,file='serie_amprep.out',access='append')
        write(lunio,'(I10," ",a," ",3(1pe15.7))') icode,trim(cline),
     &    phrerror,enemax,s0max
        flush(lunio)
        close(lunio)
        return
      endif

      afreq=(0.0d0,0.0d0)
      dtelec=tftrack-t0track

      r0=[x0,y0,z0]
      dr=[xf0-x0,yf0-y0,zf0-z0]
      drn=dr/norm2(dr)

      perlen=norm2(dr)
      dtpho=perlen/clight1

      nper=100

      do iobsv=1,nobsv
        obs=obsv(1:3,iobsv)
        dist0=norm2(obs-r0)
        do ifreq=1,nfreq
          om=freq(ifreq)/hbarev1
          ifrob=iobsv+nobsv*(ifreq-1)
          amp=(0.0d0,0.0d0)
          amp0(1:3)=dcmplx(reaima(1:3,1,ifrob),reaima(1:3,2,ifrob))
          t=-dt
          do i=1-nper/2,nper-nper/2
            r=r0+i*dr
            dobs=obs-r
            dist=norm2(obs-r)
            dobsn=dobs/dist
            cosang=dot_product(drn,dobsn)
            dt=dtelec-dtpho*cosang
            t=t+dt
            dph=om*t
            zexp=cdexp(dcmplx(0.0d0,dph))
            amp=amp+amp0*zexp*dist0/dist
          enddo
          afreq(:,ifrob)=amp
          fd=sum(real(amp)**2+imag(amp)**2)*specnor
          write(66,*)sngl(obsv(:,iobsv)),sngl(freq(ifreq)),
     &      sngl(real(amp(3))),sngl(imag(amp(3))),sngl(fd)
        enddo !ifreq
      enddo !nobsv
+self.
+self,if=ivue32,if=uout_scheer.

+seq,spectf90u.
      use sourcef90
      use observf90

      implicit none
c      include 'uservar.cmn'

+seq,cmpara.
+seq,spect.
+seq,observ.
+seq,sourcef90.

      double precision sou(3),x,y,z,dx,dy,dz,cosa,dxs,dys,dzs

      integer :: iobsv,isour,lun,lunob

      open(newunit=lunob,file='observ.in',status='old',readonly)

      open(newunit=lun,file='ivue32_uout.dat',recl=512)
      write(lun,'(a)')"* Nsour, Nobs, Xsou, Ysou, Zsou, Xobs, Yobs, Zobs, PowPerp, PowGraz ( Watt and mm)"

      do isour=1,nsource

        rewind(lunob)

        do iobsv=1,nobsv

          read(lunob,*) x,y,z,dx,dy,dz

          dxs=obsv(1,iobsv)-schwingercen(1,iobsv,isour)
          dys=obsv(2,iobsv)-schwingercen(2,iobsv,isour)
          dzs=obsv(3,iobsv)-schwingercen(3,iobsv,isour)

          cosa=(dx*dxs+dy*dys+dz*dzs)/
     &      sqrt(dx**2+dy**2+dz**2)/
     &      sqrt(dxs**2+dys**2+dzs**2)

          write(lun,'(2i5,8g15.5)') nsource,iobsv,
     &      schwingercen(1:3,iobsv,isour),obsv(1:3,iobsv)*1000.0,
     &      specpowt(iobsv)/1.0e6,
     &      specpowt(iobsv)/1.0e6*sqrt(1.0d0-min(1.0d0,cosa**2))

        enddo !nobsv

      enddo ! nsource

      flush(lun)
      close(lun)
      close(lunob)

      print*,""
      print*,"     UOUT: ivue32_uout.dat written "
      print*,""
+self.

      return
      end
+DECK,UOUT_PHOTON.
*CMZ :          17/10/2023  13.35.53  by  Michael Scheer
*CMZ :  2.15/00 15/03/2007  11.13.54  by  Michael Scheer
*CMZ : 00.02/05 19/03/97  14.10.43  by  Michael Scheer
*CMZ : 00.02/04 26/02/97  10.23.26  by  Michael Scheer
*-- Author :    Michael Scheer   25/02/97

      SUBROUTINE UOUT_photon

+seq,spectf90u.

C     INTERFACE FUER PHOTON
C     USER(1) MUSS KRITISCHE ENERGIE ENTHALTEN

C     EIGENTLICH IST DIE KRITISCHE ENERGIE UND GAMMA UNWICHTIG,
C     ABER VORERST FUER CHECKS MITAUSGEBEN.
C     PINCEN(2) MUSS NULL SEIN (FAKTOR 2)
C
C     AUSGEBEN WIRD dFLUX/dTHETA[mrad]

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,SPECT.
+SEQ,OBSERV.
+SEQ,FREQS.
+SEQ,USERVAR.


      INTEGER IFREQ
      DOUBLE PRECISION EGAMMA,PHOTONS

      WRITE(6,*)
      WRITE(6,*)'SUBROUTINE UOUT_PHOTON:'
      WRITE(6,*)'======================='
      WRITE(6,*)
      WRITE(6,*)'Writing file WAVE.PHOTON for program PHOTON'
      WRITE(6,*)'Ecrit:',ecphoton
      WRITE(6,*)


      IF (IPIN.NE.1) STOP '*** ERROR IN UOUT_PHOTON: IPIN.NE.1'
      IF (IF1DIM.NE.1) STOP '*** ERROR IN UOUT_PHOTON: IF1DIM.NE.1'
      IF (PINCEN(2).NE.0.0)STOP
     &  '*** ERROR IN UOUT_PHOTON: PINCEN(2).NE.0.0'

      OPEN(UNIT=99,FILE='WAVE.PHOTON',STATUS='NEW')

      WRITE(99,*)'WAVE.PHOTON'
      WRITE(99,*)ICODE,' ',CODE
      WRITE(99,*)ECPHOTON,DMYGAMMA
      WRITE(99,*)PINW,PINH
      WRITE(99,*)OBSVDZ,OBSVDY
      WRITE(99,*)PINCEN
      WRITE(99,*)NFREQ

      DO IFREQ=1,NFREQ
        EGAMMA=FREQ(IFREQ)/ECPHOTON
        PHOTONS=WFLUXT(IFREQ)
     &    /1.327D13 ! 1.327e13 * Ebeam**2  * Icurr * H2(y) yields flux-dens.
     &    /BANWID*0.001D0
     &    *(PINCEN(1)/PINW/1000.0D0)
     &    /(DMYCUR*1000.0D0)
     &    /DMYENERGY**2
     &    /2.D0
        WRITE(99,*)EGAMMA,PHOTONS
      ENDDO

      CLOSE(99)

      RETURN
      END
+PATCH,INPUT,T=TEXT.
*CMZ :  2.70/12 01/03/2013  12.26.02  by  Michael Scheer
+DECK,wave,T=TEXT.
*CMZ :          17/10/2023  13.35.28  by  Michael Scheer
*CMZ :  4.01/03 03/06/2023  11.02.39  by  Michael Scheer
*CMZ :  4.01/03 30/05/2023  08.18.01  by  Michael Scheer
*CMZ :  4.01/02 12/05/2023  13.31.01  by  Michael Scheer
*CMZ :  4.01/01 15/03/2023  13.25.57  by  Michael Scheer
*CMZ :  4.01/00 14/03/2023  11.17.26  by  Michael Scheer
*CMZ :  4.00/17 05/12/2022  09.05.20  by  Michael Scheer
*CMZ :  4.00/16 29/09/2022  11.26.25  by  Michael Scheer
*CMZ :  4.00/15 07/07/2022  19.48.11  by  Michael Scheer
*CMZ :  4.00/14 11/02/2022  10.51.30  by  Michael Scheer
*CMZ :  4.00/13 20/12/2021  16.35.32  by  Michael Scheer
*CMZ :  4.00/12 29/07/2021  10.03.35  by  Michael Scheer
*CMZ :  4.00/11 26/07/2021  09.37.05  by  Michael Scheer
*CMZ :  4.00/10 25/09/2020  11.25.53  by  Michael Scheer
*CMZ :  4.00/09 15/08/2020  09.03.29  by  Michael Scheer
*CMZ :  4.00/08 07/08/2020  11.10.56  by  Michael Scheer
*CMZ :  4.00/07 06/08/2020  11.14.22  by  Michael Scheer
*CMZ :  4.00/06 02/01/2020  12.16.58  by  Michael Scheer
*CMZ :  4.00/05 30/11/2019  16.49.03  by  Michael Scheer
*CMZ :  4.00/04 28/11/2019  13.58.28  by  Michael Scheer
*CMZ :  4.00/03 09/05/2019  11.05.27  by  Michael Scheer
*CMZ :  4.00/02 13/04/2019  10.06.52  by  Michael Scheer
*CMZ :  4.00/01 12/04/2019  13.43.18  by  Michael Scheer
*CMZ :  4.00/00 04/04/2019  19.42.45  by  Michael Scheer
*CMZ :  3.08/01 04/04/2019  12.02.36  by  Michael Scheer
*CMZ :  3.08/00 29/03/2019  15.51.05  by  Michael Scheer
*CMZ :  3.07/01 29/03/2019  15.50.11  by  Michael Scheer
*CMZ :  3.07/00 18/03/2019  10.37.01  by  Michael Scheer
*CMZ :  3.06/00 28/02/2019  17.26.08  by  Michael Scheer
*CMZ :  3.05/28 07/01/2019  17.16.43  by  Michael Scheer
*CMZ :  3.05/27 12/12/2018  12.20.51  by  Michael Scheer
*CMZ :  3.05/26 09/12/2018  13.47.12  by  Michael Scheer
*CMZ :  3.05/25 06/12/2018  10.32.09  by  Michael Scheer
*CMZ :  3.05/22 08/11/2018  16.06.16  by  Michael Scheer
*CMZ :  3.05/21 07/11/2018  12.38.39  by  Michael Scheer
*CMZ :  3.05/20 01/11/2018  17.21.17  by  Michael Scheer
*CMZ :  3.05/19 18/10/2018  14.59.31  by  Michael Scheer
*CMZ :  3.05/18 17/10/2018  09.19.35  by  Michael Scheer
*CMZ :  3.05/17 11/10/2018  13.22.53  by  Michael Scheer
*CMZ :  3.05/16 10/10/2018  14.54.18  by  Michael Scheer
*CMZ :  3.05/15 08/10/2018  18.46.27  by  Michael Scheer
*CMZ :  3.05/14 01/10/2018  14.05.51  by  Michael Scheer
*CMZ :  3.05/13 24/09/2018  14.47.29  by  Michael Scheer
*CMZ :  3.05/12 29/08/2018  14.01.05  by  Michael Scheer
*CMZ :  3.05/11 16/08/2018  15.24.29  by  Michael Scheer
*CMZ :  3.05/10 14/08/2018  11.02.38  by  Michael Scheer
*CMZ :  3.05/09 08/08/2018  14.26.36  by  Michael Scheer
*CMZ :  3.05/08 26/07/2018  15.29.30  by  Michael Scheer
*CMZ :  3.05/07 21/07/2018  16.40.57  by  Michael Scheer
*CMZ :  3.05/06 19/07/2018  15.14.31  by  Michael Scheer
*CMZ :  3.05/05 13/07/2018  14.31.05  by  Michael Scheer
*CMZ :  3.05/04 09/07/2018  11.39.17  by  Michael Scheer
*CMZ :  3.05/03 22/05/2018  07.40.12  by  Michael Scheer
*CMZ :  3.05/02 16/05/2018  08.36.21  by  Michael Scheer
*CMZ :  3.05/01 09/05/2018  09.26.46  by  Michael Scheer
*CMZ :  3.05/00 02/05/2018  12.31.37  by  Michael Scheer
*CMZ :  3.04/01 03/04/2018  14.27.58  by  Michael Scheer
*CMZ :  3.04/00 01/03/2018  16.59.08  by  Michael Scheer
*CMZ :  3.03/04 02/01/2018  16.27.57  by  Michael Scheer
*CMZ :  3.03/03 11/07/2017  12.44.06  by  Michael Scheer
*CMZ :  3.03/02 28/06/2017  14.10.41  by  Michael Scheer
*CMZ :  3.03/01 13/11/2015  10.19.07  by  Michael Scheer
*CMZ :  3.03/00 30/09/2015  11.38.35  by  Michael Scheer
*CMZ :  3.02/09 09/07/2015  19.31.48  by  Michael Scheer
*CMZ :  3.02/08 25/06/2015  14.22.11  by  Michael Scheer
*CMZ :  3.02/07 24/06/2015  12.52.35  by  Michael Scheer
*CMZ :  3.02/06 18/06/2015  14.16.54  by  Michael Scheer
*CMZ :  3.02/05 13/04/2015  11.56.50  by  Michael Scheer
*CMZ :  3.02/04 18/03/2015  10.20.29  by  Michael Scheer
*CMZ :  3.02/03 10/11/2014  16.22.22  by  Michael Scheer
*CMZ :  3.02/02 22/10/2014  13.35.24  by  Michael Scheer
*CMZ :  3.02/01 16/10/2014  06.18.03  by  Michael Scheer
*CMZ :  3.02/00 09/10/2014  15.07.08  by  Michael Scheer
*CMZ :  3.01/10 19/08/2014  11.32.15  by  Michael Scheer
*CMZ :  3.01/09 12/08/2014  17.20.11  by  Michael Scheer
*CMZ :  3.01/08 12/08/2014  14.40.32  by  Michael Scheer
*CMZ :  3.01/07 23/06/2014  16.16.32  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  10.16.10  by  Michael Scheer
*CMZ :  3.01/05 13/06/2014  13.17.52  by  Michael Scheer
*CMZ :  3.01/04 11/06/2014  12.53.44  by  Michael Scheer
*CMZ :  3.01/03 20/03/2014  13.34.18  by  Michael Scheer
*CMZ :  3.01/02 27/02/2014  09.44.51  by  Michael Scheer
*CMZ :  3.01/01 31/07/2013  12.25.55  by  Michael Scheer
*CMZ :  3.01/00 18/07/2013  13.41.43  by  Michael Scheer
*CMZ :  3.00/02 10/04/2013  09.29.16  by  Michael Scheer
*CMZ :  3.00/01 03/04/2013  12.14.27  by  Michael Scheer
*CMZ :  3.00/00 14/03/2013  12.31.37  by  Michael Scheer
*CMZ :  2.70/12 05/03/2013  13.35.00  by  Michael Scheer
*CMZ :  2.70/11 22/02/2013  14.47.36  by  Michael Scheer
*CMZ :  2.70/10 16/01/2013  12.43.13  by  Michael Scheer
*CMZ :  2.70/09 15/01/2013  14.58.55  by  Michael Scheer
*CMZ :  2.70/08 14/01/2013  17.51.04  by  Michael Scheer
*CMZ :  2.70/07 14/01/2013  16.57.20  by  Michael Scheer
*CMZ :  2.70/06 14/01/2013  09.57.49  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  15.37.12  by  Michael Scheer
*CMZ :  2.70/04 21/12/2012  12.44.10  by  Michael Scheer
*CMZ :  2.70/03 17/12/2012  15.04.17  by  Michael Scheer
*CMZ :  2.70/02 14/12/2012  10.52.18  by  Michael Scheer
*CMZ :  2.70/01 12/12/2012  15.53.22  by  Michael Scheer
*CMZ :  2.70/00 11/12/2012  17.12.43  by  Michael Scheer
*CMZ :  2.69/02 08/11/2012  10.18.11  by  Michael Scheer
*CMZ :  2.69/01 31/10/2012  17.01.40  by  Michael Scheer
*CMZ :  2.69/00 30/10/2012  16.26.11  by  Michael Scheer
*CMZ :  2.68/05 19/10/2012  14.10.19  by  Unknown
*CMZ :  2.68/04 04/09/2012  11.30.28  by  Michael Scheer
*CMZ :  2.68/03 01/09/2012  16.18.06  by  Michael Scheer
*CMZ :  2.68/02 01/08/2012  15.11.21  by  Michael Scheer
*CMZ :  2.68/01 29/05/2012  17.05.29  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  16.50.47  by  Michael Scheer
*CMZ :  2.67/06 24/05/2012  14.37.42  by  Michael Scheer
*CMZ :  2.67/05 16/05/2012  14.35.26  by  Michael Scheer
*CMZ :  2.67/04 15/05/2012  13.09.01  by  Michael Scheer
*CMZ :  2.67/03 09/05/2012  16.33.50  by  Michael Scheer
*CMZ :  2.67/02 09/05/2012  12.07.48  by  Michael Scheer
*CMZ :  2.67/01 16/03/2012  09.16.38  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  16.26.39  by  Michael Scheer
*CMZ :  2.66/22 16/01/2012  12.51.43  by  Michael Scheer
*CMZ :  2.66/21 22/11/2011  13.55.13  by  Michael Scheer
*CMZ :  2.66/20 22/11/2011  10.47.23  by  Michael Scheer
*CMZ :  2.66/19 07/06/2011  14.54.51  by  Michael Scheer
*CMZ :  2.66/18 16/12/2010  12.54.13  by  Michael Scheer
*CMZ :  2.66/17 23/11/2010  10.02.57  by  Michael Scheer
*CMZ :  2.66/16 22/11/2010  14.03.46  by  Michael Scheer
*CMZ :  2.66/15 09/11/2010  16.18.47  by  Michael Scheer
*CMZ :  2.66/14 09/11/2010  15.40.53  by  Michael Scheer
*CMZ :  2.66/13 02/08/2010  09.16.07  by  Michael Scheer
*CMZ :  2.66/12 27/05/2010  02.40.34  by  Michael Scheer
*CMZ :  2.66/11 05/05/2010  08.25.21  by  Michael Scheer
*CMZ :  2.66/10 04/05/2010  12.42.43  by  Michael Scheer
*CMZ :  2.66/09 03/05/2010  16.12.46  by  Michael Scheer
*CMZ :  2.66/08 17/03/2010  14.45.31  by  Michael Scheer
*CMZ :  2.66/07 11/03/2010  15.51.53  by  Michael Scheer
*CMZ :  2.66/06 27/11/2009  16.14.35  by  Michael Scheer
*CMZ :  2.66/05 17/11/2009  16.10.27  by  Michael Scheer
*CMZ :  2.66/04 17/11/2009  10.13.31  by  Michael Scheer
*CMZ :  2.66/03 11/11/2009  16.17.07  by  Michael Scheer
*CMZ :  2.66/02 26/10/2009  14.31.17  by  Michael Scheer
*CMZ :  2.66/01 21/10/2009  09.36.01  by  Michael Scheer
*CMZ :  2.66/00 14/10/2009  11.57.40  by  Michael Scheer
*CMZ :  2.65/03 02/10/2009  13.18.17  by  Michael Scheer
*CMZ :  2.65/02 29/09/2009  12.22.11  by  Michael Scheer
*CMZ :  2.65/01 21/09/2009  14.35.53  by  Michael Scheer
*CMZ :  2.65/00 18/09/2009  09.46.03  by  Michael Scheer
*CMZ :  2.64/07 17/09/2009  16.27.57  by  Michael Scheer
*CMZ :  2.64/06 15/09/2009  15.16.47  by  Michael Scheer
*CMZ :  2.64/05 14/09/2009  11.36.35  by  Michael Scheer
*CMZ :  2.64/04 21/08/2009  17.39.56  by  Michael Scheer
*CMZ :  2.64/03 21/08/2009  17.33.23  by  Michael Scheer
*CMZ :  2.64/02 21/08/2009  17.28.01  by  Michael Scheer
*CMZ :  2.64/01 20/08/2009  15.48.22  by  Michael Scheer
*CMZ :  2.64/00 17/08/2009  09.32.31  by  Michael Scheer
*CMZ :  2.63/05 14/08/2009  13.06.55  by  Michael Scheer
*CMZ :  2.63/04 22/07/2009  07.41.07  by  Michael Scheer
*CMZ :  2.63/03 02/06/2009  16.24.57  by  Michael Scheer
*CMZ :  2.63/02 08/04/2008  12.20.17  by  Michael Scheer
*CMZ :  2.63/01 16/01/2008  13.14.20  by  Michael Scheer
*CMZ :  2.63/00 11/01/2008  16.42.22  by  Michael Scheer
*CMZ :  2.62/04 03/01/2008  17.15.40  by  Michael Scheer
*CMZ :  2.62/03 17/07/2007  16.15.27  by  Michael Scheer
*CMZ :  2.62/02 16/07/2007  11.27.56  by  Michael Scheer
*CMZ :  2.62/01 24/04/2007  12.00.23  by  Michael Scheer
*CMZ :  2.62/00 17/04/2007  08.48.15  by  Michael Scheer
*CMZ :  2.61/06 12/04/2007  13.39.48  by  Michael Scheer
*CMZ :  2.61/05 12/04/2007  09.31.10  by  Michael Scheer
*CMZ :  2.61/04 29/03/2007  16.31.30  by  Michael Scheer
*CMZ :  2.61/03 27/03/2007  13.28.57  by  Michael Scheer
*CMZ :  2.61/02 26/03/2007  20.10.23  by  Michael Scheer
*CMZ :  2.61/01 15/02/2007  14.24.13  by  Michael Scheer
*CMZ :  2.61/00 30/01/2007  20.26.35  by  Michael Scheer
*CMZ :  2.60/00 26/01/2007  10.51.17  by  Michael Scheer
*CMZ :  2.59/02 25/01/2007  16.09.16  by  Michael Scheer
*CMZ :  2.59/01 24/01/2007  14.31.57  by  Michael Scheer
*CMZ :  2.59/00 23/01/2007  15.40.31  by  Michael Scheer
*CMZ :  2.58/01 23/01/2007  13.25.37  by  Michael Scheer
*CMZ :  2.58/00 16/01/2007  17.45.07  by  Michael Scheer
*CMZ :  2.57/05 10/01/2007  13.39.01  by  Michael Scheer
*CMZ :  2.57/04 01/02/2006  16.20.46  by  Michael Scheer
*CMZ :  2.57/03 23/12/2005  11.47.54  by  Michael Scheer
*CMZ :  2.57/02 09/12/2005  11.14.11  by  Michael Scheer
*CMZ :  2.57/01 22/11/2005  13.32.26  by  Michael Scheer
*CMZ :  2.57/00 22/11/2005  12.34.51  by  Michael Scheer
*CMZ :  2.56/02 21/10/2005  16.32.41  by  Michael Scheer
*CMZ :  2.56/01 21/10/2005  12.35.13  by  Michael Scheer
*CMZ :  2.56/00 17/10/2005  13.31.12  by  Michael Scheer
*CMZ :  2.55/01 10/08/2005  16.11.58  by  Michael Scheer
*CMZ :  2.55/00 10/08/2005  16.09.07  by  Michael Scheer
*CMZ :  2.54/07 16/06/2005  12.25.44  by  Michael Scheer
*CMZ :  2.54/06 02/06/2005  13.55.03  by  Michael Scheer
*CMZ :  2.54/05 02/06/2005  08.17.02  by  Michael Scheer
*CMZ :  2.54/04 19/04/2005  14.13.18  by  Michael Scheer
*CMZ :  2.54/03 18/04/2005  08.55.59  by  Michael Scheer
*CMZ :  2.54/02 13/04/2005  13.53.43  by  Michael Scheer
*CMZ :  2.54/01 13/04/2005  09.16.10  by  Michael Scheer
*CMZ :  2.54/00 28/02/2005  17.31.30  by  Michael Scheer
*CMZ :  2.53/05 25/02/2005  12.01.44  by  Michael Scheer
*CMZ :  2.53/04 10/02/2005  10.01.32  by  Michael Scheer
*CMZ :  2.53/03 26/01/2005  15.37.28  by  Michael Scheer
*CMZ :  2.53/02 25/01/2005  18.20.27  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  13.29.43  by  Michael Scheer
*CMZ :  2.53/00 21/01/2005  17.23.24  by  Michael Scheer
*CMZ :  2.52/16 20/01/2005  15.01.12  by  Michael Scheer
*CMZ :  2.52/15 05/01/2005  16.38.50  by  Michael Scheer
*CMZ :  2.52/14 22/12/2004  16.29.13  by  Michael Scheer
*CMZ :  2.52/13 16/12/2004  21.17.47  by  Michael Scheer
*CMZ :  2.52/12 08/12/2004  14.07.18  by  Michael Scheer
*CMZ :  2.52/11 08/12/2004  13.39.43  by  Michael Scheer
*CMZ :  2.52/10 05/11/2004  17.17.16  by  Michael Scheer
*CMZ :  2.52/09 29/10/2004  13.08.04  by  Michael Scheer
*CMZ :  2.52/08 14/10/2004  14.53.26  by  Michael Scheer
*CMZ :  2.52/07 14/10/2004  09.24.13  by  Michael Scheer
*CMZ :  2.52/05 17/08/2004  15.57.24  by  Michael Scheer
*CMZ :  2.52/04 13/07/2004  08.24.46  by  Michael Scheer
*CMZ :  2.52/03 08/07/2004  13.38.12  by  Michael Scheer
*CMZ :  2.52/02 08/07/2004  10.29.10  by  Michael Scheer
*CMZ :  2.52/01 30/06/2004  16.24.34  by  Michael Scheer
*CMZ :  2.52/00 30/06/2004  10.54.07  by  Michael Scheer
*CMZ :  2.51/03 23/06/2004  12.25.39  by  Michael Scheer
*CMZ :  2.51/02 22/06/2004  16.31.15  by  Michael Scheer
*CMZ :  2.51/01 17/06/2004  16.18.09  by  Michael Scheer
*CMZ :  2.51/00 26/05/2004  16.34.19  by  Michael Scheer
*CMZ :  2.50/03 10/05/2004  14.41.05  by  Michael Scheer
*CMZ :  2.50/02 30/04/2004  15.33.25  by  Michael Scheer
*CMZ :  2.50/01 30/04/2004  08.58.17  by  Michael Scheer
*CMZ :  2.50/00 29/04/2004  18.46.08  by  Michael Scheer
*CMZ :  2.49/01 23/03/2004  14.32.39  by  Michael Scheer
*CMZ :  2.49/00 19/03/2004  17.19.49  by  Michael Scheer
*CMZ :  2.48/04 17/03/2004  14.53.55  by  Michael Scheer
*CMZ :  2.48/03 10/03/2004  16.04.05  by  Michael Scheer
*CMZ :  2.48/02 03/03/2004  11.26.09  by  Michael Scheer
*CMZ :  2.48/01 02/03/2004  16.43.58  by  Michael Scheer
*CMZ :  2.48/00 01/03/2004  18.05.39  by  Michael Scheer
*CMZ :  2.47/23 17/02/2004  13.48.29  by  Michael Scheer
*CMZ :  2.47/22 03/12/2003  13.18.02  by  Michael Scheer
*CMZ :  2.47/21 03/12/2003  09.49.57  by  Michael Scheer
*CMZ :  2.47/20 01/12/2003  15.34.24  by  Michael Scheer
*CMZ :  2.47/19 01/12/2003  08.24.39  by  Michael Scheer
*CMZ :  2.47/18 27/11/2003  14.45.55  by  Michael Scheer
*CMZ :  2.47/17 12/09/2003  10.10.41  by  Michael Scheer
*CMZ :  2.47/16 11/09/2003  15.10.39  by  Michael Scheer
*CMZ :  2.47/15 04/09/2003  09.28.22  by  Michael Scheer
*CMZ :  2.47/14 07/08/2003  09.43.55  by  Michael Scheer
*CMZ :  2.47/13 03/07/2003  09.57.35  by  Michael Scheer
*CMZ :  2.47/12 03/07/2003  09.56.31  by  Michael Scheer
*CMZ :  2.47/11 30/05/2003  12.54.10  by  Michael Scheer
*CMZ :  2.47/10 30/05/2003  12.43.17  by  Michael Scheer
*CMZ :  2.47/09 27/05/2003  15.58.13  by  Michael Scheer
*CMZ :  2.47/08 20/05/2003  15.48.20  by  Michael Scheer
*CMZ :  2.47/07 15/04/2003  10.52.26  by  Michael Scheer
*CMZ :  2.47/06 28/03/2003  15.40.47  by  Michael Scheer
*CMZ :  2.47/05 27/03/2003  15.27.30  by  Michael Scheer
*CMZ :  2.47/04 13/03/2003  11.06.28  by  Michael Scheer
*CMZ :  2.47/03 12/03/2003  16.02.28  by  Michael Scheer
*CMZ :  2.47/01 10/03/2003  11.57.11  by  Michael Scheer
*CMZ :  2.47/00 07/03/2003  11.19.50  by  Michael Scheer
*CMZ :  2.46/02 07/03/2003  11.17.07  by  Michael Scheer
*CMZ :  2.46/01 18/12/2002  11.47.16  by  Michael Scheer
*CMZ :  2.46/00 17/12/2002  16.46.40  by  Michael Scheer
*CMZ :  2.45/03 17/12/2002  15.15.44  by  Michael Scheer
*CMZ :  2.45/02 16/12/2002  14.36.24  by  Michael Scheer
*CMZ :  2.45/01 13/12/2002  17.25.35  by  Michael Scheer
*CMZ :  2.45/00 13/12/2002  12.43.54  by  Michael Scheer
*CMZ :  2.44/03 13/12/2002  12.42.56  by  Michael Scheer
*CMZ :  2.44/02 13/12/2002  11.39.11  by  Michael Scheer
*CMZ :  2.44/01 12/12/2002  13.31.59  by  Michael Scheer
*CMZ :  2.44/00 15/11/2002  18.31.42  by  Michael Scheer
*CMZ :  2.43/00 29/10/2002  11.36.07  by  Michael Scheer
*CMZ :  2.42/04 29/10/2002  11.33.20  by  Michael Scheer
*CMZ :  2.42/03 13/09/2002  18.47.25  by  Michael Scheer
*CMZ :  2.42/02 12/09/2002  11.07.50  by  Michael Scheer
*CMZ :  2.42/01 09/09/2002  18.56.15  by  Michael Scheer
*CMZ :  2.42/00 09/09/2002  18.55.21  by  Michael Scheer
*CMZ :  2.41/13 03/09/2002  14.29.30  by  Michael Scheer
*CMZ :  2.41/12 22/08/2002  12.13.41  by  Michael Scheer
*CMZ :  2.41/11 21/08/2002  11.28.36  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.50.01  by  Michael Scheer
*CMZ :  2.41/09 14/08/2002  17.27.15  by  Michael Scheer
*CMZ :  2.41/08 14/08/2002  17.06.19  by  Michael Scheer
*CMZ :  2.41/07 30/07/2002  12.13.03  by  Michael Scheer
*CMZ :  2.41/06 10/05/2002  15.25.53  by  Michael Scheer
*CMZ :  2.41/05 18/04/2002  11.47.27  by  Michael Scheer
*CMZ :  2.41/04 16/04/2002  14.29.46  by  Michael Scheer
*CMZ :  2.41/03 21/03/2002  12.44.49  by  Michael Scheer
*CMZ :  2.41/02 21/03/2002  12.41.53  by  Michael Scheer
*CMZ :  2.41/01 21/03/2002  12.36.32  by  Michael Scheer
*CMZ :  2.41/00 20/03/2002  19.23.52  by  Michael Scheer
*CMZ :  2.40/04 20/03/2002  12.33.18  by  Michael Scheer
*CMZ :  2.40/03 19/03/2002  17.46.32  by  Michael Scheer
*CMZ :  2.40/02 14/03/2002  16.23.01  by  Michael Scheer
*CMZ :  2.40/01 12/03/2002  14.36.07  by  Michael Scheer
*CMZ :  2.40/00 12/03/2002  14.28.17  by  Michael Scheer
*CMZ :  2.39/02 22/01/2002  13.35.38  by  Michael Scheer
*CMZ :  2.39/01 15/01/2002  16.49.12  by  Michael Scheer
*CMZ :  2.39/00 14/01/2002  14.37.48  by  Michael Scheer
*CMZ :  2.38/03 13/12/2001  15.06.34  by  Michael Scheer
*CMZ :  2.38/02 13/12/2001  13.44.27  by  Michael Scheer
*CMZ :  2.38/01 13/12/2001  12.16.47  by  Michael Scheer
*CMZ :  2.38/00 13/12/2001  11.22.22  by  Michael Scheer
*CMZ :  2.37/07 12/12/2001  14.47.45  by  Michael Scheer
*CMZ :  2.37/06 07/12/2001  15.01.55  by  Michael Scheer
*CMZ :  2.37/05 07/12/2001  14.52.05  by  Michael Scheer
*CMZ :  2.37/04 05/12/2001  17.37.05  by  Michael Scheer
*CMZ :  2.37/03 23/11/2001  18.19.27  by  Michael Scheer
*CMZ :  2.37/02 15/11/2001  17.25.11  by  Michael Scheer
*CMZ :  2.37/01 14/11/2001  11.08.36  by  Michael Scheer
*CMZ :  2.37/00 13/11/2001  17.33.02  by  Michael Scheer
*CMZ :  2.36/01 08/11/2001  17.39.36  by  Michael Scheer
*CMZ :  2.36/00 08/11/2001  15.34.18  by  Michael Scheer
*CMZ :  2.35/02 30/10/2001  17.15.11  by  Michael Scheer
*CMZ :  2.35/01 17/10/2001  11.40.45  by  Michael Scheer
*CMZ :  2.35/00 26/09/2001  17.19.30  by  Michael Scheer
*CMZ :  2.34/09 26/09/2001  17.17.04  by  Michael Scheer
*CMZ :  2.34/08 17/09/2001  19.44.42  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  17.41.26  by  Michael Scheer
*CMZ :  2.34/04 11/07/2001  11.20.28  by  Michael Scheer
*CMZ :  2.34/02 02/07/2001  17.24.43  by  Michael Scheer
*CMZ :  2.34/01 26/06/2001  16.49.30  by  Michael Scheer
*CMZ :  2.34/00 11/05/2001  17.26.52  by  Michael Scheer
*CMZ :  2.33/09 10/05/2001  18.03.14  by  Michael Scheer
*CMZ :  2.33/08 08/05/2001  17.52.15  by  Michael Scheer
*CMZ :  2.33/07 08/05/2001  17.43.25  by  Michael Scheer
*CMZ :  2.33/06 04/05/2001  11.54.03  by  Michael Scheer
*CMZ :  2.33/03 03/05/2001  17.29.14  by  Michael Scheer
*CMZ :  2.33/02 03/05/2001  14.31.29  by  Michael Scheer
*CMZ :  2.33/00 03/05/2001  10.35.20  by  Michael Scheer
*CMZ :  2.32/04 26/04/2001  12.07.24  by  Michael Scheer
*CMZ :  2.32/02 26/04/2001  11.08.42  by  Michael Scheer
*CMZ :  2.32/01 25/04/2001  17.40.53  by  Michael Scheer
*CMZ :  2.31/01 25/04/2001  14.39.31  by  Michael Scheer
*CMZ :  2.31/00 24/04/2001  14.05.11  by  Michael Scheer
*CMZ :  2.30/03 20/04/2001  16.25.55  by  Michael Scheer
*CMZ :  2.30/02 12/04/2001  18.54.32  by  Michael Scheer
*CMZ :  2.20/11 11/04/2001  11.51.23  by  Michael Scheer
*CMZ :  2.20/10 05/04/2001  10.53.04  by  Michael Scheer
*CMZ :  2.20/09 03/04/2001  14.25.24  by  Michael Scheer
*CMZ :  2.15/01 27/03/2001  16.39.10  by  Michael Scheer
*CMZ :  2.20/05 13/03/2001  17.09.46  by  Michael Scheer
*CMZ :  2.20/04 09/03/2001  18.38.18  by  Michael Scheer
*CMZ :  2.20/02 20/02/2001  15.55.32  by  Michael Scheer
*CMZ :  2.20/01 19/02/2001  12.12.56  by  Michael Scheer
*CMZ :  2.17/00 06/11/2000  14.07.18  by  Michael Scheer
*CMZ :  2.16/08 30/10/2000  12.01.57  by  Michael Scheer
*CMZ :  2.16/07 22/09/2000  10.57.59  by  Michael Scheer
*CMZ :  2.16/06 29/08/2000  13.13.38  by  Michael Scheer
*CMZ :  2.16/05 01/08/2000  17.19.27  by  Michael Scheer
*CMZ :  2.16/04 21/07/2000  14.42.10  by  Michael Scheer
*CMZ :  2.16/01 15/06/2000  17.05.33  by  Michael Scheer
*CMZ :  2.16/00 13/06/2000  13.55.50  by  Michael Scheer
*CMZ :  2.15/00 19/05/2000  10.31.49  by  Michael Scheer
*CMZ :  2.13/12 14/04/2000  17.30.45  by  Michael Scheer
*CMZ :  2.13/11 14/04/2000  17.30.08  by  Michael Scheer
*CMZ :  2.13/10 14/04/2000  14.37.07  by  Michael Scheer
*CMZ :  2.13/11 19/03/2000  12.31.19  by  Michael Scheer
*CMZ :  2.13/08 02/03/2000  10.04.37  by  Michael Scheer
*CMZ :  2.13/02 14/12/99  16.36.32  by  Michael Scheer
*CMZ :  2.13/00 02/12/99  13.15.53  by  Michael Scheer
*CMZ :  2.12/04 27/08/99  11.46.53  by  Michael Scheer
*CMZ :  2.12/03 06/08/99  15.56.29  by  Michael Scheer
*CMZ :  2.12/02 14/06/99  16.08.06  by  Michael Scheer
*CMZ :  2.12/01 14/06/99  15.19.05  by  Michael Scheer
*CMZ :  2.12/00 03/06/99  15.46.15  by  Michael Scheer
*CMZ :  2.10/01 30/04/99  13.44.35  by  Michael Scheer
*CMZ :  2.02/00 12/02/99  17.13.24  by  Michael Scheer
*CMZ :  2.01/00 19/01/99  10.58.48  by  Michael Scheer
*CMZ :  2.00/00 11/01/99  13.40.20  by  Michael Scheer
*CMZ :  1.03/06 29/09/98  11.02.27  by  Michael Scheer
*CMZ :  1.03/05 30/03/98  17.31.01  by  Michael Scheer
*CMZ :  1.03/03 27/03/98  13.59.57  by  Michael Scheer
*CMZ :  1.02/00 06/01/98  16.06.51  by  Michael Scheer
*CMZ :  1.01/00 26/11/97  15.02.15  by  Michael Scheer
*CMZ :  1.00/01 20/10/97  14.41.17  by  Michael Scheer
*CMZ :  1.00/03 01/10/97  12.03.30  by  Michael Scheer
*-- Author : Michael Scheer
+seq,gplhint.
 !
 ! VERSION 4.01/03
 !
 $CONTRL
  !-------------------------- USER COMMENT ---------------------------

      CODE='WAVE.EXAMPLE'

  !-------------------------- MAIN MODES -----------------------------

      ! The undulator and wiggler modes should work for standard
      ! insertion devices. Reasonable settings for some parameters
      ! are taken (mainly in namelist COLLIN).
      ! Experienced users might prefere there own settings.

      IUNDULATOR=1   ! UNDULATOR MODE:

       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       !  IUNDULATOR=1   ! UNDULATOR MODE:
       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

         ! IBUNCH.EQ.0:
            ! whole trajectory is taken as source of
            ! synchroton light (ignoring input of
            ! parameters WGWINFC, collimators ...)
            ! ISPECMODE = 2
            ! NLPOI = 0
            ! WGWINFC = 45.
            ! ISPECDIP = 0
            ! ISTOKES = 1
            ! IFOLD = 1, if IFOLD.NE.0
            ! IEFOLD = 1, if IEFOLD NOT IN [-1,0,1,3]
            ! IF (IPIN.GT.0) IPIN = 1
            ! BMOVECUT = 1.E-6
            ! IHTRACKM = 0
            ! icluster = 0

         ! IBUNCH.NE.0:
            ! IBUNCH = -1
            ! ISPECMODE = 2
            ! IMAGSPLN = 0
            ! NLPOI = 0
            ! WGWINFC = 45.
            ! ISPECDIP = 0
          ! ISTOKES = 1
            ! IFOLD = 0
            ! IEFOLD = 0
            ! IPIN = 3, IF IPIN.NE.0 AND NEINBUNCH = 1
            ! BMOVECUT = 1.E-6
            ! IHTRACKM = 0

       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       !  IUNDULATOR=2   Like IUNDULATOR=1, but the radiation field is
       !                 calculated for a single period only and summed
       !                 with appropriate phase shift for the remaining
       !                 periods, s.a. KAMPLI
       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

         ! IBUNCH.EQ.0:
            ! whole trajectory is taken as source of
            ! synchroton light (ignoring input of
            ! parameters WGWINFC, collimators ...)
            ! ISPECMODE = 2
            ! IMAGSPLN = 0 for KBREC,KBUNDUMAG, etc.
            ! NLPOI = 0
            ! WGWINFC = 45.
            ! ISPECDIP = 0
            ! ISTOKES = 1
            ! IFOLD = 1, if IFOLD.NE.0
            ! IEFOLD = 1, if IEFOLD NOT IN [-1,0,1,3]
            ! IF (IPIN.GT.0) IPIN = 1
            ! BMOVECUT = 1.E-6
            ! IHTRACKM = 0
            ! icluster = 0

         ! IBUNCH.NE.0:
            ! IBUNCH = -1
            ! ISPECMODE = 2
            ! IMAGSPLN = 0
            ! NLPOI = 0
            ! WGWINFC = 45.
            ! ISPECDIP = 0
            ! ISTOKES = 1
            ! IFOLD = 0
            ! IEFOLD = 0
            ! IPIN = 3, IF IPIN.NE.0 AND NEINBUNCH = 1
            ! BMOVECUT = 1.E-6
            ! IHTRACKM = 0
          ! NBUNCH or NEINBUNCH must be 1

      IWIGGLER=0  ! WIGGLER MODE:
            !----------------------------------------------
            ! IWIGGLER = 1:
            !----------------------------------------------
            ! all poles are treated as separated sources
            ! added incoherently
            !
            ! fixed parameters
            ! (essentially in namelist COLLIN):
            ! NLPOI = -9999   (i.e. automaticly calculated)
            ! WGWINFC = 9999. (i.e. automaticly calculated)
            ! WBL0CUT = 0.1
            ! (i.e. lowest considered mag. field)
            ! WBL0HYS = 1.0
            ! (i.e. hysteresis factor of WBL0CUT)
            ! IBL0CUT = 1  (i.e. parts of the trajectory
            !      with different sign of the
            !      magnetic field are treated as
            !      separat sources)
            ! CX1,CY1,CZ1,HIG1,WID1 = 9999.
            ! (i.e. automaticly calculated)
            ! CX2,CY2,CZ2,HIG2,WID2 = 9999.
            ! (i.e. automaticly calculated)
            ! ISOUREXT = 0 (i.e. no extansion of source
            !      to check overlapping sources)
            ! SPECCUT = 20.   if considered photon energy is
            !               higher than 20 times the critical
            !     energy of the source, photon flux
            !               is set to zero
            ! ISPECMODE = 2
            ! ISPECDIP = 0
            ! ISTOKES = 1
            ! IFOLD = 1
            ! IEFOLD = 1, if IEFOLD NOT IN [-1,0,1,3]
            ! IF (IPIN.GT.0) IPIN = 1
            !
            ! IBUNCH.NE.0:
            !
              ! ISPECMODE = 2
              ! ISPECDIP = 0
              ! IFOLD = 0
              ! IEFOLD = 0
            !
            !----------------------------------------------
            ! SCHWINGER MODE:
            !----------------------------------------------
            ! (IWIGGLER > 1)
            !----------------------------------------------
            ! all poles are treated as separated sources
            ! added incoherently; spectrum is calculated
            ! according to SCHWINGER
            !
            ! fixed parameters
            ! (essentially in namelist COLLIN):
            ! *** ISPECDIP = -2
            ! WGWINFC = 10.
            ! CX1,CY1,CZ1,HIG1,WID1 = 9999.
            ! (i.e. automaticly calculated)
            ! CX2,CY2,CZ2,HIG2,WID2 = 9999.
            ! (i.e. automaticly calculated)
            ! ISOUREXT = 0 (i.e. no extansion of source
            !      to check overlapping sources)

      IEXPERT=0   ! export mode, set to null if IUNDULATOR
                  ! or IWIGGLER are set

  !-------------------------- ELECTRON -------------------------------

      NSTEPMX=-1  ! max. number of steps of electron trajectory
                  ! (array dimension, F90 only, replaces NWMAXP)
           ! if NSTEPMX<0 then NSTEPMX is set to
           ! (XSTOP-XSTART)*MYINUM*1.1*(-NSTEPMX)

      MYINUM=5000 ! number of steps per meter for the tracking
                  ! for more recent version of WAVE this parameter
           ! must be high enough for spectrum calculations
           ! (particularly for ISPECMODE =1)

      DMYENERGY=1.722   ! total electron energy [GeV]

      IENELOSS=1 ! electron energy loss due to synchrotron radiation
                 ! is taken into account.
          ! -1: Quantum fluctuations are taken into account
          !     see namelist PHOTONN
          ! For IEFIELD.ne.0 the energy
          ! gain is taken into account

      IEFIELD=0  ! take electrical field of efield.dat into account
                 ! The energy gain is only taken into account
          ! for IENELOSS.ne.0

      DMYCUR=0.1 ! current [A] of the ring

      XSTART=9999. ! initial x of the trajectory [m]
                   ! 9999. means default is used if possible
            ! i.e. entrance of the device
            ! -9999. XSTART is set to -XSTOP
      XINTER=-9999.  ! if XINTER not -9999. and not missing tracking starts
                     ! at XINTER. The particle is tracked forward or
              ! backward to XSTART.
              ! XSTART,YSTART,...,VXIN,... are overwritten
              ! for restart of tracking now beginning at XSTART
              ! 9999. means default is used if possible
              ! i.e. entrance of the device
              ! XINTER = XSTART = 9999. is allowed but makes no sense
      XSTOP=9999. ! final x of the trajectory [m]
                  ! 9999. means default is used if possible
           ! i.e. exit of the device
      YSTART=0.0  ! initial y of the trajectory [m]
      ZSTART=0.0  ! initial z of the trajectory [m]

      VXIN=1.0 ! initial x-component of velocity vector (relative)
      VYIN=0.0 ! initial y-component of velocity vector (relative)
      VZIN=0.0 ! initial z-component of velocity vector (relative)

      BMOVECUT=1.E-6  ! in tracking routines, mag. fields below BMOVECUT
                      ! are treated as zero. This cuts might crucially effect
               ! spectrum calculations. In case of problems check
               ! convergence of integrations by changing MYINUM, NLPOI
               ! etc.

      IHINPUT=-3 ! this input file is stored as CWN on histogram file
                 ! 0: no storage
                 ! 1: first 32 characters of line are stored
                 ! 2: first 64 characters of line are
                 ! 3: first 96 characters of line are stored
                 ! neg. value means compression (i.e. skipping
                 ! of comment lines) is suppressed

       IHOUTP=3  ! output file WAVE.OUT is stored as CWN on histogram file

       IHISASCII=0 ! non zero flag generates ASCII-Files
                   ! of histograms
                   ! filename is histogramtitle_index.wvh
                   ! IHISASCII=1 means 1D histos only
                   ! IHISASCII=10 means 2D histos only
                   ! IHISASCII=100 means ntuples only
                   ! for combinations add numbers, e.g. 1+10=11
                   ! means 1D and 2D histos to be treated
                   ! negative values means no header on file
                   ! In addition some other files e.g. of the
                   ! trajectory are written (names: *.wva)
                   ! (IROOTREES >= 0)

       CHISASCII='*' ! Comment marker for header lines i.e. first character

       IROOTTREES=0  ! OBSOLETE. Use mhbook_to_root.exe to convert
                     ! WAVE.mhb to WAVE.root
                     ! Write histograms and NTuples to file wave.root for
                     ! analysis program root
                     ! <0: Do not write histogram file for PAW

       IROOTHDF5=0 ! Write histograms and NTuples HDF5 File wave.h5
                   ! roottohdf5_main.exe must be in search path

   !-------------------------- MAGNETIC FIELD -------------------------------

      IRFILT0=0 ! calculate Bx(x),By(x),Bz(x) from the trajectory of file FILETR

      IBSUPER=1 ! flag to allow superposition of magnetic field
                ! configurations

      IBERROR=0 ! superimpose magnetic field errors (namelist BERRORN)
                ! if IHTRACK is set, phase error analysis is given

      KBEXTERN=0  ! magnetic field is taken from user routine BEXTERN

      KBFELD=0 ! magnetic field is a sequence of hard edge dipoles
               ! parameters namelist BBFELD
               ! fring field simulation is offered
               ! fields are not MAXWELL conform
               ! magnet field routine BFELD
               ! maybe it's better to use flag KMAGSEQ

      IBGAUSS=0 ! instead of hard edge, use Gaussian field

      KMAGSEQ=0 ! sequence of different magnets and undulators
                ! the sequence is read from file FILEMG
                ! if negative, magnets to not radiate for IBMASKSP.ne.0

                ! file format: *
                ! 1th column (ASCII): dummy
                ! 2th column (ASCII): magnet type (DI or QP)
                !
                ! for dipoles (BEND),
                !(see manual of tracking code elegant for CSBEND):

                !   First line:
                !   3th column: deflection angle [rad]
                !   4th column: bending radius [m]
                !   5th column: entrance edge [rad]
                !   6th column: exit edge [rad]
                !   7th column: Integral of fringe
                !   8th column: Full gap of magnet
                !   9th order of interpolation:
                !                '1': linear
                !                '3': cubic spline
                !                '5': quintic spline
                !
                !   2nd line: x,y,z of magnet center
                !   3rd line: x,y,z of entrance point, ex,ey,ez of nor. vec.
                !   4th line: x,y,z of exit point, ex,ey,ez of normal vector

                ! for dipoles (DI):
                !   3th column: deflection angle [rad]
                !   4th column: bending radius [m]
                !   5th column: x-position of magnet center [m]
                !   6th column: parameter s of fringe field function f
                !               f = 1/(1+exp(s*...))
                !               infinit s means hard edge
                !   the field is a product of two Fermi distributions
                !
                ! for dipoles with Fourier expanded field (DIF):
                !   3th column: deflection angle [rad]
                !   4th column: bending radius [m]
                !   5th column: x-position of magnet center [m]
                !   6th column: parameter s of fringe field function f
                !               f = 1/(1+exp(s*...))
                !               infinit s means hard edge
                !   the field is a product of two Fermi distributions
                !   7th column: k-value of transversal field gradient
                !   8th column: number of Fourier coefficients
                !
                ! for dipoles with horizontal field (DH):
                !   3th column: deflection angle [rad]
                !   4th column: bending radius [m]
                !   5th column: x-position of magnet center [m]
                !   6th column: parameter s of fringe field function f
                !               f = 1/(1+exp(s*...))
                !               infinit s means hard edge
                !   the field is a product of two Fermi distributions
                !   7th column: ---
                !   THE FOURIER TRANSFORMED VARIATION IS NOT AVAILABLE
                !   I.E. IMGSQF IS IGNORED
                !
                ! for hori. dipoles  with Fourier expanded field (DHF):
                !   3th column: deflection angle [rad]
                !   4th column: bending radius [m]
                !   5th column: x-position of magnet center [m]
                !   6th column: parameter s of fringe field function f
                !               f = 1/(1+exp(s*...))
                !               infinit s means hard edge
                !   the field is a product of two Fermi distributions
                !   7th column: k-value of transversal field gradient [1/m]
                !   8th column: number of Fourier coefficients
                !
                ! for undulators (UE):
                !   3th column: K parameter, if not zero B0V and
                !               B0H are overwritten, but the
                !               ratio is kept
                !   4th column: B0 vertical [T]
                !   5th column: B0 horizontal [T]
                !   6th column: shift between hori. and vert. field [m]
                !   7th column: Long. pos. of undulator center [m]
                !   8th column: Period-length [m]
                !   9th column: Number of periods
                !   10th column: Base length l of trans. gradient [m],
                !                i.e. k=2*pi/l, ONLY useful for B0H=0!
                !   11th column: Nth harmonic to which columne 12 refers
                !   12th column: Energy of Nth harmonic
                !   13th column: Scaling factor for taper
                !   14th column: Offset in z
                !   15th column: Rotation angle in the x-z plane
                !
                ! for quadrupoles (QP):
                !   3th column: length of magnet [m]
                !   4th column: gradient g of quadrupole [1/m**2]
                !   5th column: x-position of magnet center [m]
                !   6th column: z-position of magnet center [m]
                !               to take displacement of beam into
                !               account (due to dipoles)
                !   7th column: rotation angle of magnet in the orbit
         !                      plane [rad] to take slope of trajectory into
                !               account (due to dipoles)

                ! for sextupoles (SX):
                !   3th column: length of magnet [m]
                !   4th column: gradient g of quadrupole [1/m**3]
                !   5th column: x-position of magnet center [m]
                !   6th column: z-position of magnet center [m]
                !               to take displacement of beam into
                !               account (due to dipoles)
                !   7th column: rotation angle of magnet in the
                !               orbit plane [rad]
                !               to take slope of trajectory into
                !               account (due to dipoles)

                ! for quadrupoles (QF): like QP, but with fringe field

                ! magnetic field routine BMAGSEQ

          KMAGCOR=1  ! flag to correct fringe field effects and slopes of
                     ! trajectory on the deflection angle
                     ! Be aware of side-effects
                     ! KMAGCOR<0: Only the on-axis integral is corrected

          IMGSQF=0   ! Fourier transformation used for dipole fields
                     ! makes dipole fields MAXWELL conform. Only file
              ! FILEF is used, better consider magnet models like
              ! DIF

      KHALBA=0 ! insertion device described by HALBACH's formulas
               ! parameter namelist HALBACH
               ! magnetic field routine BHALBA
               ! KHALBA.lt.0 means zero field outside device

      KHALBASY=0  ! simple WLS or undulator/wiggler model
                  ! parameter namelist HALBASY
                  ! each pole described by HALBACH's formulas

      KUNDUGAP=0  ! Undulator/wiggler model with fitted Beff(gap) dependency
                  ! parameter namelist UNDUGAPN
                  ! each pole described by HALBACH's formulas

      KUCROSS=0  ! crossed undulator with modulator
                 ! parameter namelist UCROSSN
                 ! field is not smooth nor MAXWELL conform
                 ! at pole edges
                 ! magnetic field routine BUCROSS

      KELLIP=1   ! helical undulator, parameter namelist ELLIPN

      KELLANA=0  ! analytical field for helical undulator,
                 ! parameter namelist ELLANAN, SR BELLANA

      KBREC=0    ! Magnetic field from REC-structure on file
                 ! FILEREC or according to parameter namelist RECN
                 ! SR BREC (rectangularly shaped magnets)

      KBUNDUMAG=0     !  1:  Use field of an APPLE-II undulator calculated by
                      !      UNDUMAG
                      !  2:  like 1, but run UNDUMAG first (namelist UNDUMAGN)
                      !
                      !  3:  Use field of a planar hybrid undulator calculated
                      !      by UNDUMAG (namelist UNDUHYBRIDN)
                      !  4:  like 3, but run UNDUMAG first
                      !
                      ! <0: Run UNDUMAG first, but use undumag.nam and undumag.clc
                      !     as rather their templates, and don't [over]write
                      !     undumag_mu.dat. This means, UNDUMAG runs as
                      !     externally set-up by the user
      KBUNDUVERB=1    !  1: Watch UNDUMAG working
      KBUNDUMAP=1     !  1: use undumag.map for field calculations, quad. interpolation
                      !  2: use undumag.map for field calculations, lin. interpolation
                      !

      KBPOLYMAG=0     ! >0: Read Magnetic field from REC-structure on file
                      ! FILEPM, parameter namelist POLYMAGN
                      ! SR BPOLYMAG (magnets are polyeder)
                      ! <0: Write Magnetic field from REC-structure (BREC)
                      ! to file wave_to_polymag.dat

      IRBTAB=0 ! magnetic field By on device axis is read
               ! from data file FILETB and interpolated by splines
               ! particle must move in orbit plane i.e. y=0
               ! magnetic field from routine BTAB
               ! fileformat:
               ! 1. line: user comment
               ! 2. line: scaling factors for x and By to convert to
               !          meter and Tesla
               ! 3. line: number of data points (negative means
               !          symmetric field relative to x=0
               ! following lines: x By data
               !
               ! fileformat for IRBTAB<0:
               ! x By
               ! fileformat for IRBTAB=-2:
               ! x/mm By

      IFOURBTABZY=0  ! magnetic fields By and Bz on device axis are read
                     ! from data files FILETB and FILETBZ. The FFT is
                     ! caculated for a superposition of Halbach undulators
                     ! in y and z. Namelist FBTABZYN

      IRBTABZY=0  ! magnetic fields By and Bz on device axis are read
                  ! from data files FILETB and FILETBZ and interpolated
                  ! by splines (some format as for IRBTAB>0)

      IRBTABXYZ=0 ! magnetic fields Bx,By and Bz on device axis are read
                  ! from data files FILETB, FILETBX, FILETBZ and interpolated
                  ! by splines (some format as for IRBTAB>0)

      IRFILB0=0   ! read 3D mag. field table from file FILEB0
                  ! format of routine BMESS
                  ! field is interpolated from equally spaced grid
                  ! IRFILB0=-1 means field is taken from grid point
                  ! IRFILB0=-2 means field is linearily interpolated
                  ! IRFILB0=-4 means field map is given in terms of
                  ! coefficients of polynomials
                  ! IRFILB0=nonzero else means field is fitted according to
                  ! Maxwell's equations, see NAMELIST BGRIDN
                  ! IRFILB0=6 to use 3D mag. field map in the
                  ! format of IWBMAP = 6, linear interpolation scheme
                  ! IRFILB0=-6 to use 3D mag. field map in the
                  ! format of IWBMAP = 6, quadratic interpolation scheme
                  ! See also hints under IWBMAP, where scaling options etc.
                  ! are explained

      IRFILF=0 ! magnetic field is given as a superposition
               ! of HALBACH insertion devices
               ! the coefficients of the superposition are read from
               ! file FILEF
               ! parameter namelist FOURIER
               ! magnetic field routine BFOUR

      KBAMWLS=0       ! straight section of BAM/PTB-WLS; namelist BAMWLSN

      KBPOLYH=0 ! magnetic field is given as a superposition
                ! of HALBACH insertion devices calculated by
                ! program POLYHARM
                ! the coefficients are read from file
                ! wave_bpolyharm_coef.dat
                ! the magnetic field is calculated by routine BPOLYHARM

      KBPOLY3D=0 ! magnetic field is calculated from 3D Maxwell conform
                 ! polynomial potential. Coefficients are read from file
                 ! FILE3DFIT
                 ! used coefficients are given via NAMELIST BPOLY3DN

      KBPOLY2DH=0 ! magnetic field is calculated from transversal
                  ! polynomial and longitudinal harmonical ansatz
                  ! Coefficients are read from file FILE2DHFIT

      KBPHARM=0 ! magnetic field is calculated from
                ! 3D harmonical fit according to SR BPHARMFIT
                ! Coefficients are read from file FILEPHFIT

      IRFILP=0 ! magnetic field from PANDIRA (file FILEP)
               ! magnet field routine BPAND
               ! contact M. Scheer

      IBHELM=0 ! magnetic field form Helmholtz-coils

      KBGENESIS=0 ! read lattice file FILEGEN of FEL-code GENESIS
                  ! and calculate corresponding mag. field
                  ! KBGENESIS > 0: Ntuple of trajectory and
                  !                field is created
                  ! KBGENESIS < 0: no Ntuple
                  ! KBGENESIS = +/- 2: read start conditions form
                  ! file genesis.start

 !-------------------------- OPTIONS -------------------------------


      IBFORCE=0   ! Calculation of magnetic forces
                  ! ***ATTENTION: Together with REC calculations are
                  ! wrong if considered volume inside or partially inside
                  ! magnet block.
                  ! Namelist BFORCN
                  ! Subroutine BFORCE

      IWBPOLY3D=0 ! 3D Maxwell conform polynomial field is fitted
                  ! to field map FILEBMAP.
                  ! IWBPOLY3D=1 means standard format of FILEBMAP
                  ! IWBPOLY3D=2 means column format of FILEBMAP
                  ! Output file is FILE3DFIT
                  ! Relation between coefficients are read from
                  ! file FILE3DCOE
                  ! Order of fit is given via NAMELIST BPOLY3DN

      IWBPOLY2DH=0 ! Field map FILEBMAP is fitted with polynomial
                   ! ansatz in y,z and harmonical ansatz in x.
                   ! IWBPOLY2DH=1 means standard format of FILEBMAP
                   ! IWBPOLY2DH=2 means column format of FILEBMAP
                   ! Output file is FILE2DHFIT
                   ! Periodlength of device and other parameters
                   ! are given in namelist BPOLY2DHN

       IWBPHARM=0 ! Field map FILEBMAP is fitted 3D harmonical
                  ! ansatz. Field is expanded as series of cosine-like
                  ! vertical Halbach-Fields and sine-like horizontal
                  ! Halbach-Fields plus constant offsets
                  ! Scalar potential:
                  ! VC:=-B0C/KYC(N,NXY)*COS(NXY*KXC*X)
                  !    *SINH(KYC(N,NXY)*Y)*COS(N*KZ*Z
                  ! VS:=-B0S/KXS(N,NXY)*COS(NXY*KYS*Y)
                  !    *SINH(KXS(N,NXY)*X)*SIN(N*KZ*Z)
                  ! V0:=-(B0X*X+B0Y*Y+B0Z*Z)
                  ! V:=VC+VS+V0
                  ! BX:=-DF(V,X)
                  ! BY:=-DF(V,Y)
                  ! BZ:=-DF(V,Z)
                  ! IWBPHARM = 1 means standard format of FILEBMAP
                  ! IWBPHARM = 2 means column format of FILEBMAP
                  ! Output file is FILEPHFIT
                  ! Periodlength of device and other parameters
                  ! are given in namelist BPHARMN

      IWFILF=0 ! coefficients for superposition of HALBACH
               ! insertion devices are computed for given field
               ! and written to file FILEF
               ! in later runs this file is input if flag IRFILF
               ! is set
               ! parameter namelist FOURIER

      IWSECTMAGS=0 ! approximate vertical magnetic field by IWSECTMAGS
                   !  sector magnets, and write them to files wave.smag,
                   ! wave.xmag and wave.strmag
                   ! IWSECTMAGS < 0: use sector magnets on files wave.smag
                   ! and wave.xmag as magnetic field for tracking

      IWBTAB=0 ! to write By along straight line parallel to
               ! device axis or along trajectory onto file
               ! FILEWBT
               ! for parameters and file formats see NAMELIST WBTABN
               ! first and second field integrals and integrated
               ! quadrupole and sextupole terms etc. are calculated
               ! results of integrations are step by step
               ! written to files FILEWBT and wbtab_sextupole.dat
               ! if (IWBTAB.eq. 100) then trajectory is used
               ! rather than straight line

      IWBMAP=0 ! to write 3D mag. field map to file FILEBMAP
               ! according to namelist BMAPN
               !
               ! IWBMAP = 1 means field map in standard format
               ! IWBMAP = 2 means field map in column format
               ! IWBMAP = 3 means field map in column format for
               !            BMESS etc.
               ! IWBMAP = 4 means field map is written in terms of
               !          fitted coefficients of polynomials for
               !          BMESS. The coefficients are calculated
               !          according to namelist BGRIDN
               !          IBMRADIAL must be zero
               ! IWBMAP = 5 convert map of FILEB0 from column format
               !          to format for BMESS; grid input data must
               !          match that of namelist BMAP
               ! IWBMAP = -1 means field map as Ntuple only
               ! (option IHBPOLY3D for Ntuple must be set)
               !
               ! IWBMAP = 6 means the following format:
               !          lines starting with %,*,!,#,@ are comments
               !          or discription lines, empty lines
               !          are ignored
               !          WAVE writes the run number and CODE to the
               !          first two lines, e.g.
               !          the data line must come after an
               !          scaling factor line for x,y,z,bx,by,bz,
               !          containig the key-word scaling,
               !          e.g. * scaling = 1. 1. 1. 1. 1. 1.
               !          data columns contain x,y,z,bx,by,bz
               !          z runs the fastes, then y, then x
             ! IWBMAP = 7 means suitable for spectra

      IBSYM=0  ! IBSYM .ne. 0 means symmetry of device assumed
               ! Bx(-x) is set to -Bx(x)
               ! By(-x) is set to By(x)
               ! Bz(-x) is set to Bz(x)
               ! IBSYM .lt. 0 means negative field for x.lt.0

      XBSYM=0.0 ! X of symmetry point i.e.
                ! e.g. BY(-(X-XBSYM))=BY(X-XBSYM) etc.
                !(depending on IBSYM)

      IBSYMY=0 ! IBSYMY .ne. 0 means symmetry of device assumed
               ! Bx(-y) is set to Bx(y)
               ! By(-y) is set to -By(y)
               ! Bz(-y) is set to Bz(y)
               ! IBSYMY .lt. 0 means negative field for y.lt.0

      IBSYMZ=0 ! IBSYMZ .ne. 0 means symmetry of device assumed
               ! Bx(-z) is set to Bx(z)
               ! By(-z) is set to By(z)
               ! Bz(-z) is set to -Bz(z)
               ! IBSYMZ .lt. 0 means negative field for z.lt.0

               ! HALBACH classic
               ! (note WAVE coordinate-system!!)
               ! IBSYM=1, IBSYMY=-1, IBSYMZ=1

      IWFILT0=0 ! write for each IWFILT0th step of the trajectory
                ! x,y,z,vx,vy,vz,Bx,By,Bz,Ax,Ay,Az
                ! to file FILETR using '*' Format
                ! IWFILT0 = 1 means with header:
                ! 1. line: * run number
                ! 2. line: * user comment
                ! IWFILT0 > 1 means with header:
                ! 1. line: run number
                ! 2. line: user comment
                ! IWFILT0 < 0 without header

      IHTRACK=1  !to get Ntuple of trajectory and !magnetic field
                 !every abs(IHTRSMP)th point is taken
                 !IHTRACK=abs(n) means spacing of points
                 !in 0.5xIHTRACK mm for trajectory on grid (ntuple 20)
                 !for ABS(IHTRACK)=9999 namelist WBTABN is used to
                 !define sample range and stepping size

                 !if IBERROR is set, phase error analysis is given

      IHTRSMP=1 !every IHTRSMPth point is taken for NTuple 10

      XSTARTH=9999. !lower edge of histogram (9999. XSTARTH=XSTART)
      XSTOPH =9999. !upper edge of histogram (9999. XSTOPH=XSTOP)

      IJUST=0 ! to adjust closed orbit offset to zero by shifting
              ! device horizontally, i.e. adjust variable HSHIFT
              ! in of namelist B0SCGLOBN
              ! 1. set HSHIFT=0.001(for example), IJUST=1, run WAVE
              ! 2. set IJUST=2, re-run WAVE
              ! 3. set IJUST=3, re-run WAVE
              !                 re-run WAVE (as often as necessary)
              ! 4. set IJUST=4 to use optimized value of HSHIFT
              !    which is written to file FILEJ
              !    or
              !    set IJUST=0 and set HSHIFT accordingly
              !
              ! iteration steps are written to file FILEJ

      IUNAME=0 ! to call SR UNAME
      IUSTEP=0 ! to call SR USTEP
      IUOUT=0  ! to call SR UOUT

 !-------------------------- SPECTRUM CALCULATIONS---------------------------

      ISPEC=1 ! to activate spectrum calculations
              ! parameter namelists :
              ! COLLIN
              ! SPECTN
              ! WFOLDN
              ! PINHOLE
              ! FREQN

      ISPECMODE=2 ! 0: same as 2
                  ! 1: spectrum is calculated by interpolation
                  !    from reference orbit,
                  !    i.e. no tracking of source point with high
                  !    resolution; ROIs are taken into account
                  ! 2: source is retracked with precision according to
                  !    NLPOI
                  !    ROIs are taken into account
                  !    (recommended for wigglers)
                  ! 3: use still older algorithm, no ROIs,
                  !    no bunches etc., less precise, but faster
                  ! 4: use still older tracking routine (TRACKSOLD)
                  ! (test purpose)

      IVELOFIELD=0 ! to take velocity field into account
                   ! IVELOFIELD.eq.0 add velocity field
                   ! IVELOFIELD.eq.1 do not add velocity field
                   ! IVELOFIELD.lt.0 velocity field only

      IMAGSPLN=0     ! to use spline interpolation of magnetic
                     ! field from arrays of reference orbit
                     ! (faster, but maybe less accurate)
                     ! IMAGSPLN<0 means field is stored on file
                     ! magjob.dat
                     ! -9999 means memory mode
                     ! IMAGSPLN>0 means field is read from file
                     ! magjob.dat
                     ! (out of range problems may occur if NLPOI
                     ! is of similar size as number of points
                     ! on reference orbit)
                     ! NOT COMPATIBLE WITH IWBMAP/IWBTAB/IBFORCE AND IOPTIC
                     ! is set to -9999 by IUNDULATOR and IWIGGLER

        XIANF=9999.  ! limits of X for integration and
                     ! for straight line fits through z(x) and y(x)
        XIEND=9999.  ! 9999. means whole trajectory is taken
                     ! for straight line fits through z(x) and y(x)
                     ! only available in the export mode (IEXPERT.ne.0)

        BANWID=0.001 ! bandwidth for spectrum calculations

        IWFILL0=0    ! write sources to file FILEL0

        IHTRACKM=1   ! Ntuple of mini-trajectory

        IRFILL0=0    ! read sources from file FILEL0
                     ! one and only one of these flags must be set
              ! IWFILL0=1 is recommended

        NLPOI=-9999  ! Maximal number of integration steps per source
                     ! The accuracy of the integration depends on
                     ! this number. Check results of integration by
                     ! increasing NLPOI. For dipoles, wiggler, etc., i.e.
                     ! if you have several sources, the step size of the
                     ! integration depends both on NLPOI and
                     ! WGWINFC (namelist COLLIN), since WGWINFC
                     ! influences the extension of the source.
                     ! For this sources for a rough calculations
                     ! NLPOI = 1000 should work,
                     ! for high precision calculations
                     ! 5000<NLPOI<20000 should be good.
                     ! To get a feeling compare results of WAVE with
                     ! results of Schwinger mode ISPECDIP.
                     ! Rule of thumb:
                     ! NLPOI = 500 * WGWINFC * Eph,max/Ecrit
                     !
                     ! NLPOI = 0 means NLPOI = (XSTOP-XSTART)*MYINUM+1
                     !
                     ! NLPOI = -9999 means NLPOI is estimated by
                     ! SR NLPOIWIN
                     !
                     ! For undulators, try some 50 steps per period to
                     ! start with.
                     !
                     ! WAVE knows regions of interest (ROI) with
                     ! individuell step size; see namelist ROIN
                     ! Check also MYINUM (ISPECMODE.EQ.1)

        IFREQ2P=3 ! =0 : spectrum is calculated for listed photon
                  !      energies on file FILEFR
                  ! =1 : spectrum is calculated for energy FREQLOW
                  !      in namelist FREQN
                  ! =-1: spectrum is calculated for energy
                  !       (FREQLOW+FREQHIG)/2. in namelist FREQN
                  ! =2 : spectrum is calculated for the energy range
                  !      FREQLOW -> FREQHIG (namelist FREQN)
                  !      each step increases energy by powers of 2
                  !      fast calculation due to
                  !      exp(2**N*E0)=exp(2**(N-1)*E0)**2

                  ! >2: spectrum is calculated for NINTFREQ
                  !     (namelist FREQN) equidistant
                  !     energies from FREQLOW TO FREQHIG
                  !     (namelist FREQN)
                  !     fast calculation due to
                  !     exp(N*E0)=EXP((N-1)*E0)*EXP(E0)

        IHFREQ=1  ! to get histograms of spectrum over photon energies
                  ! (if IFREQ2P > 2)
                  ! Ntuple for PAW with all information of
                  ! array SPECT is generated
                  ! every IHFREQth photon energy is considered

        ISPECINT=0   ! spectrum is integrated over photon energy range

        IPIN=1  ! to calculate spectrum in pinhole rather
                ! than for list of observation points
                ! for the parameters of the pinhole see namelist PINHOLE
                ! if negative integration over pinhole is skipped
                ! [ OBSOLETE: IPIN = 2 (for ISPECMODE = 5) allows flux calculation with
                ! only one mash point in pinhole (see ISPECMODE) ]
                !
                ! IPIN = 3, flux through pinhole by Monte-Carlo.
                ! Only useful for IBUNCH set and NEINBUNCH = 1. For each electron
                ! the observation point is chosen randomly
                ! inside the pinhole. The flux-density is calculated
                ! from the flux divided by the size of the pinhole
                ! If IBUNCH.ne.0 be careful with the interpretation
                ! of the flux-density. If e.g. the flux-density is
                ! plotted from the Ntuple of 3600 (PAW) or n3600 (root)
                ! as a profile histogram, the histogram corresponds
                ! to the complete incoherent sum of all
                ! electrons, even if they are radiation
                ! coherently. The histogram of the mean flux-density
                ! on the contrary shows the flux-density from the
                ! coherent radiation

          IHPIN=0 ! to get histograms of flux distributions inside pinhole
                  ! if negative or zero only histograms 10998,10999,11000
                  ! are booked (for KUMAC NFLUX)
                  ! will be set to zero for IPIN = 3

          IHFOLD=1 ! histograms of folding function for emittance
                   ! procedure
                   ! will be set to zero for IPIN = 3

          IUSEM=0 ! to use the subroutine CONV2 of the program
                  ! USEM for the integration over the pinhole
                  ! and the folding (obsolete, not supported)

          IPINCIRC=0 ! to calculate flux through circular pinhole
             IRPHI=0 ! OBSOLETE to use polar coordinates if IPINCIRC is set and
                     ! IUSEM is not

          ISTOKES=1   ! to calculate Stokes vector for flux through pinhole

          IBRILL=1 ! to calculate brilliance (spectral brightness)
                   ! flag ISTOKES must be set

          ISPECSUM=0 ! Integration of arrays SPEC and STOKES are additionally
                     ! performed by a simple summation (test purposes)

          IFOLD=1 ! to invoke folding procedure to take emittance into
                  ! account (namelist WFOLDN)
           ! IFOLD.EQ.1: use routine UTIL_FOLD_FUNCTION_GAUSS
           ! IFOLD.EQ.2: use Monte-Carlo techniques (ISPECMODE = 5)
           ! IFOLD.EQ.-1: use routine UTIL_FOLD_FOURIER
           ! IFOLD.LT.-2: use routine old precedure of WAVE
           ! parameter namelist WFOLDN

          ISIGUSR=1  ! if flag is set sigmas for folding are taken from
                     ! namelist WFOLDN, otherwise calculated from emittance
                     ! and beta functions BETAH, BETAHP, BETAV, BETAPV
                     ! in namelist DEPOLA (be careful, if distributions are
                     ! not Gaussians)

        IBUNCH=0     ! Take bunch structure into account.
                     ! IBUNCH = 1: First electron is also randomized
                     ! IBUNCH = -1: First electron is not randomized,
                     ! be careful with biases.
                     ! See namelist BUNCHN

        IPHASE=0     ! calculate complex amplitude in pinhole and
                     ! transform back to source plan and get
                     ! phase space distribution from geometrical
                     ! optic (namelist PHASEN)
                     ! IPHASE.LT.0 means spline-integration used
                     ! ABS(IPHASE.GT.1) means additional application of
                     ! geometrical optic

        IDOSE=0      ! To calculate absorbed energy dose
                     !IDOSE > 0: F(X)=AA*X**BB interpolation of coef.
                     !IDOSE < 0: linear interpolation of coef.

      IPHOTON=0       ! Write file WAVE.PHOTON for program PHOTON
      ECPHOTON=2.5575e3 ! Critical energy of dipole for program PHOTON [eV]

        IF1DIM=0     ! spectrum calculation and folding only in vertical direction

        IPOLA=0      ! if flag is set the flux is calculated from component
                     ! of complex amplitude parallel to complex vector VPOLA
                     ! STOKES-Vectors are not affected!!
                     ! (NAMELIST SPECTN)

        IEFOLD=1     ! =1: fold spectrum with Gaussian to take energy spread
                     ! of electrons into account (namelist WFOLDN)
              ! =-1: old algorithm
              ! of electrons into account (namelist WFOLDN)
              ! =2: take beam energy spread into account by Monte-
              ! Carlo-technique (ISPECMODE = 5) (check precision) OBSOLETE
              ! =3 like 1, but lin. interpolation rather than splinesused;
              !    needed when spectrum is not smooth enough

        IWFILSP0=0   ! write integration results (arrays SPEC,SPECT) to
                     ! file FILESP0

        IWFILPOW=0   ! write power distributions to file FILEPOW
                     ! IWFILPOW.lt.0 means no user comment on file
              ! Meaning of columns: x, y, z, total power density,
              ! power density within spectral range, power density
              ! within spectral range with emittance, total power dens. grazing
              ! *** UNITS: mm Watt/mm**2!!

        IWFILRAY=0   ! write integration results to data file for RAY
                     ! (only for first photon energy)

        IRFILSP0=0   ! read integration results (arrays SPEC,SPECT) from
                   ! file FILESP0 (test purposes)

        IRFILSTO=0   ! read integration results for Stokes vectors from
                     ! file FILESTO

        KAMPLI=0     ! Modern version of option IAMPLI to simulate undulator
                   ! of KAMPLI periods by simple phase shifting.

              ! Namelists PHASEREPN, BUNCHN
              ! From BUNCHN only NBUNCH, IHBUNCH, IUBUNCH are available
              ! IHBUNCH is adjusted to the number of threads
              ! (MTHREADS.NE.0).
              ! Only the field options KELLIP in combination with
              ! PHSHIFT are available for MTHREADS.NE.0

        IAMPLI=0   ! IAMPLI>0:
                   ! reads or writes amplitudes of integration
            ! to file FILEAMPLI (array REAIMA).
            ! Treatment of data is done in SR ADDAMPLI and
            ! controlled by namelist AMPLIN
            ! IAMPLI<0:
            ! sums up IAMPLI times the calculated
            ! amplitude such that:
            ! Asum=|A1|*(exp(i*phi1) + |A2|*exp(i*2*phi2)+...)
            ! where the amplitudes and phases are corrected for
            ! depth of field effects.
            ! To take random phase errros into account, use
            ! variables AMPRAN and IAMPSEED in namelist
            ! AMPLIN. AMPRAN referes here the length of the
            ! repeated amplitude, AMPFREQ is adjusted to 1. harm.
            ! AMPSHIFT(1) is applied in addition.
            ! Check contribution of endpoles!!!
            ! To ignore end poles use variables XIANF and XIEND.

           IAMPJIT=0    ! Jitter on phase is calculated by tracking the device
                        ! period by period (IAMPLI.LT.0)

        IWFILSPF=0   ! write folded integration results
                     ! (arrays SPECF,SPECTF) to FILESPF

        IWFILSTO=0 ! write integration results for Stokes vectors to
                   ! file FILESTO. PAW-Macros NFILS0 and HFILSTO can be used to
                   ! visualize data.

        IWFLSTOF=0 ! write integration results for folded Stokes vectors to
                   ! file FILESTOF. PAW-Macros NFILS0F and HFILSTOF can
                   ! be used to visualize data.

        IWFLSTOE=0  ! write integration results for Stokes vectors with
                    ! energy spread to file FILESTOE
                    ! PAW-Macros NFILS0E and HFILSTOE can be used to
                    ! visualize data.

        IWFLSTOEF=0  ! write integration results for folded Stokes vectors
                     ! with energy spread to file FILESTOEF
                     ! PAW-Macros NFILS0EF and HFILSTOEF can be used to
                     ! visualize data.

        IWFILFL0=0   ! write flux through pinhole to file FILEFL0

        IWFILFLF=0   ! write folded flux through pinhole to file FILEFLF

        IWFILS=0     ! write STOKES vector of flux through pinhole to file FILES

        IWFILSE=0  ! write STOKES vector of flux through pinhole to
                   ! file FILESE including beam energy spread
        IWFILSF=0  ! write STOKES vector of flux through pinhole to
                   ! file FILESF including beam emittance
        IWFILSEF=0 ! write STOKES vector of flux through pinhole to
                   ! file FILESEF including beam emittance and beam
                   ! energy spread

        IWFILB=0   ! write STOKES vector of selected point to file FILEC
        IWFILBE=0  ! write STOKES vector of selected point to file FILECE
                   ! including beam energy spread
        IWFILBF=0  ! write STOKES vector of selected point to file FILECF
                   ! including beam emittance
        IWFILBEF=0 ! write STOKES vector of selected point to file FILECEF
                   ! including beam emittance and beam energy spread

        IWFILBRILL=0   ! write brilliance of STOKES vector of selected point to
                       ! file FILEBRILL
        IWFILBRILLE=0  ! write brilliance of STOKES vector of selected point
                       ! to file FILEBRILLE
                       ! including beam energy spread
        IWFILBRILLF=0  ! write brilliance of STOKES vector of selected
                       ! point to file FILEBRILLF
                       ! including beam emittance
        IWFILBRILLEF=0 ! write brilliance of STOKES vector of selected
                       ! point to file FILEBRILLEF
                       ! including beam emittance and beam energy spread

        IWFILINT=0 ! if set to N, the integral of the Nth source for first
                   ! observation point and first photon energy is
                   ! written to file FILEINT (test purposes)
                   ! IWFILINT.LT.0 means field amplitudes are
                   ! written to Ntuple, more information, recommended
                   ! (range from XIANF to XIEND)

          JWFILINT=1 ! spacing of points for IWFILINT

        IPINALL=0 ! to print results of spectrum calculation for
                  ! all observation points to output file WAVE.OUT

        ISPECANA=0   ! spectrum is taken from user routine SPECANA
                     ! (test purposes)

        ISPECANAF=0  ! folded spectrum is taken from user routine SPECANAF
            ! (test purposes)

        IDESYNC=0 ! to calculate dose from DESYNC spectrum file
            ! IDESYNC.EQ.-9999 programs uses EGS4 spectrum file
            ! IDESYNC.lt.0 programs asks for spectrum number
            ! IDESYNC.gt.0 IDESYNC is spectrum number

        ISPECDIP=0    ! to calculate spectrum from pure dipole from
            ! Bessel functions
            ! ISPECDIP > 0: calc. according to namelist SPECDIPN
            ! ISPECDIP = 2: G1 is calculated instead of photon flux
                        ! FREQLOW and FREQHIGH are interpreted as
                        ! Egamma/Ec
            ! ISPECDIP=-1: calc. spectrum at center of found sources
            !              according to SCHWINGER (fast)
            ! ISPECDIP=-2: calc. spectrum at according to SCHWINGER
            !              the source is located where the
            !              observation angle has a mininum
            !              the angle is calculated from particle
            !              trajectory
            !         *** recommended ***
            ! ISPECDIP=-3: calc. spectrum at according to SCHWINGER
            !              the source is located where the
            !              observation angle has a mininum
            !              the angle is calculated from particle
            !              trajectory retracked within source with
            !              high resolution (slow but more precise!?)
            ! ISPECDIP=-4: SCHWINGER's formula is applied
                        ! for each step of the source points

        IUNIT=0   ! to use wavelength [nm] rather than energy [eV]
            ! to characterize photons


 !-------------------------- GENERATING FUNCTION  -------------------------

      IOPTIC=0 ! to generate a set of trajectories
               ! for fitting of generating function
               ! trajectories are written to file FILEO
               ! parameter namelist OPTIK (IOPTIC.gt.0)
               ! IOPTIC=-1: Tracks are generated according to
               ! phasespace ellipse given by
               ! EPS0H, BETAH, BETAPH, EPS0V, BETAV, BETAPV
               ! in namelist DEPOLA

      IGENFUN=0  ! trajectories are read from file FILEO
                 ! to fit generating function
                 ! parameter namelist TRANPON
                 ! if negativ not generating function but
                 ! mapping (xf,xpf,yf,ypf) of (xi,xpi,yi)
                 ! is calculated

      IERZFUN=0 ! to generate set of trajectories using
                ! given coefficients of generating function
                ! coefficients are user supplied by file
                ! wave_erzfun.in (test purposes)

                ! IERZFUN=+/-100 (subroutine IDTRMSHGF)
                ! subroutine ERZFUN else

                ! in context of phase ellipse tracking this
                ! flag controls the use of Generating Funktion
                ! IERZFUN<0: Only linear tracking, all coeffs.

                ! else

      IERZANA =0     ! set of trajectories calculated analytically
               ! by user supplied routine ERZANA.FOR
               ! (test purposes)

 !-------------------------- OTHER TASKS  -------------------------------

      IPOWER=0 ! to calculate power and photon distributions on
               ! beamline walls
               ! distributions are stored in histogramms
               ! parameter namelist SPECTN

      IEMIT=0 ! to calculate emittance change due to WLS
              ! radiation integrals I2,I4 and I5
              ! and optical functions at WLS
              ! location must be given by user in
              ! namelist DEPOLA.
              ! Additionally the trajetory with start values of
              ! namelist PHASETRACKN is tracked an written to
              ! the file FILEZZPYYP

      IHBETA=1 ! to get histograms of optical functions
               ! every IHTRSMPth point is taken for histograms
               ! IEMT must be set

      IEMIAHW=0 ! to calculate emittance effects for simple WLS
                ! model form analytical formulas
                ! device must have only one main pole
                ! flag KHALBASY must be set, derivation
                ! of external dispersion must be DDISP0=0
                ! radiation integrals I2,I4 and I5
                ! and optical functions at WLS
                ! location must be given by user in
                ! namelist DEPOLA

      IWLSOPT=0 ! seach for optimal parameter of simple
                ! WLS model (one main pole)
                ! parameter namelist WLSOPTN

      IBEAMPOL=0  ! to get information about beam polarization time
                  ! and final level of beam polarisation
                  ! parameter of ring must be given in namelist DEPOLA

      MTHREADS=-1     ! >0: Number of CPU cores to be used
                      ! <0: Use all cores

      $END

 $GSEEDN

      !***** Obsolete, see namelist RANDOMN

      IGSEED1=0   ! first seed for random generator grndm used by
                  ! various routines
                  ! to set seed, both seeds must be given
      IGSEED2=0   ! second seed for random numbers
                  ! -9999 (both): Seeds are read from file wave.gseed,
                  ! which is written before WAVE terminates
        $END

 $RANDOMN
        ! Seeds to initialize the FORTRAN random generator.
        ! Since Version 3.02/02 of WAVE all old  random functions
        ! are faked, i.e. replaced by calls to random_number routine.
        ! Twelfe seed values are require; the first four seem to have no effect
        ! under Linux and gfortran

        irnmode=1 ! 0: Seed is initialize automatically, i.e. via
                  !    call random_seed(isize) with isize=64
                  ! 1: Seeds of this namelist are taken
                  !    to have reproducible results
                  !<0: Seeds are read from file wave.seeds
                  ! This file is written is overwritten by WAVE!!

+self,if=-oldseed.
        irnseed(1)=376577121
        irnseed(2)=52147852
        irnseed(3)=-1273034815
        irnseed(4)=-1963249100
        irnseed(5)=1195262240
        irnseed(6)=-1718716574
        irnseed(7)=-224354675
        irnseed(8)=432587481
        irnseed(9)=1692325775
        irnseed(10)=1934175653
        irnseed(11)=-107106772
        irnseed(12)=648589804
        irnseed(13)=-1919014861
        irnseed(14)=-1763988460
        irnseed(15)=-1039845022
        irnseed(16)=1414926465
        irnseed(17)=-1214705659
        irnseed(18)=560082688
        irnseed(19)=527470902
        irnseed(20)=-1078636718
        irnseed(21)=272932485
        irnseed(22)=-356992740
        irnseed(23)=-2013991490
        irnseed(24)=-588501795
        irnseed(25)=-1010120436
        irnseed(26)=-1558306344
        irnseed(27)=-1116776222
        irnseed(28)=794926823
        irnseed(29)=-1157173406
        irnseed(30)=63711032
        irnseed(31)=-1870802148
        irnseed(32)=-674825931
        irnseed(33)=-690546468
        irnseed(34)=1671737514
        irnseed(35)=-224394481
        irnseed(36)=2026233226
        irnseed(37)=-1141752469
        irnseed(38)=2061158685
        irnseed(39)=-1225625467
        irnseed(40)=-147464566
        irnseed(41)=1692325775
        irnseed(42)=1934175653
        irnseed(43)=-107106772
        irnseed(44)=648589804
        irnseed(45)=-1919014861
        irnseed(46)=-1763988460
        irnseed(47)=-1039845022
        irnseed(48)=1414926465
        irnseed(49)=-1214705659
        irnseed(50)=560082688
        irnseed(51)=527470902
        irnseed(52)=-1078636718
        irnseed(53)=272932485
        irnseed(54)=-356992740
        irnseed(55)=-2013991490
        irnseed(56)=-588501795
        irnseed(57)=-1010120436
        irnseed(58)=-1558306344
        irnseed(59)=-1116776222
        irnseed(60)=794926823
        irnseed(61)=-1157173406
        irnseed(62)=63711032
        irnseed(63)=-1870802148
        irnseed(64)=-674825931

+self,if=oldseed.
         irnseed(1)= 1222957173
         irnseed(2)=  972333141
         irnseed(3)=-1558163966
         irnseed(4)= 2015003664
         irnseed(5)=  405090142
         irnseed(6)=-2139608104
         irnseed(7)=-1811865884
         irnseed(8)= -720677015
         irnseed(9)= 1692325775
         irnseed(10)= 1934175653
         irnseed(11)= -107106772
         irnseed(12)=  648589804
         irnseed(13)=-1919014861
         irnseed(14)=-1763988460
         irnseed(15)=-1039845022
         irnseed(16)= 1414926465
         irnseed(17)=-1214705659
         irnseed(18)=  560082688
         irnseed(19)=  527470902
         irnseed(20)=-1078636718
         irnseed(21)=  272932485
         irnseed(22)= -356992740
         irnseed(23)=-2013991490
         irnseed(24)= -588501795
         irnseed(25)=-1010120436
         irnseed(26)=-1558306344
         irnseed(27)=-1116776222
         irnseed(28)=  794926823
         irnseed(29)=-1157173406
         irnseed(30)=   63711032
         irnseed(31)=-1870802148
         irnseed(32)= -674825931
+self.,if=oldseed.

        $END

 !-------------------------- Parallel processing  -------------------------------

 $cluster
       !Only useful with IBUNCH set
       icluster=0 !<0: split run for parallel processing, i.e. slave mode
                  !>0: collect results of parallel processing, i.e. master mode
       iclubun=0  ! Internal flag to control wpamp
 $end

 !-------------------------- PARAMETER NAMELISTS -------------------------------

 $B0SCGLOBN

      ICHARGE=-1  ! particle charge
                  ! ICHARGE.LE.0 means e-
                  ! ICHARGE.GT.0 means e+

      IBMASK=0 ! field of namelist BBFELD is used as
               ! weight function for magnetic field, i.e.
               ! BX=BX*BMASK, BY=BY*BMASK, BZ=BZ*BMASK
               ! negative values of IBMASK means field is added, i.e.
               ! BY=BY+BMASK
             !
               ! IBMASK=10 means masks are taken from file FILEFTV
               ! Xi Xe Bmask, i.e. intervall boundary and scaling factor
               ! as spline interpolation and multiplication. File format:
               ! 1. comment
               ! 2. x-scale-factor, y-scaling-factor
               ! 3. data lines
             !
               ! IBMASK=100 means masks are read from file wave.bmask
               ! (multiplication only)
             !
               ! IBMASK=-100 a user defined function UBMASK is called
               ! (multiplication)
             !
               ! IBMASK=-200 a user defined function UBMASK is called
               ! (summation)
               ! Format of wave.bmask: x,By,Bz

        JBMASK=0  ! Like IBMASK, but it is applied after all symmetry
                  ! operations etc., i.e. at the end of MYBFELD

        IBMASKSP=0  ! field is taken into account for tracking only,
                    ! but does not contribute to radiation,
                    ! i.e. phase-shifter
                    ! works only for ispecmode = 1 or ispecmode = 2
                    ! IBMASKSP.NE.0 works only for IBMASK=0

      BYGOFF=0.0     ! global offset for magnetic field
                     ! By is set to By+BYGOFF
      BZGOFF=0.0     ! global offset for magnetic field
                     ! Bz is set to Bz+BZGOFF
      A0SCGLOB=1.0   ! global scaling factor for magnetic vector
                     ! potential
      B0SCGLOB=1.0   ! global scaling factor for magnetic field
                     ! B is set to B*B0SCGLOB
                     ! (BYGOFF is added before)
      A0SCGLOBY=1.0  ! global scal. factor for magnetic vector
                     ! potential in Y
      B0SCGLOBY=1.0  ! global scaling factor for magnetic field in Y

      A0SCGLOBZ=1.0  ! global scal. factor for magnetic vector
                     ! potential in Z
      B0SCGLOBZ=1.0  ! global scaling factor for magnetic field in Z

      XSHIFT=0.0     ! x-shift of device
                     ! (x(elect) -> x(elect)+XSHIFT) [m]

      XBSHIFT=0.0    ! x-shift of device immediately before specific
                     ! field routine is called, i.e. after all symmertry
                     ! operations etc.
                     ! (x(elect) -> x(elect)+XBSHIFT) [m]
                     ! Useful to symmtrize e.g. the fixed REC-undulators
                     ! by setting xbshift to a quarter of the periodlength
                     ! and ibsym=1

      XSHBTAB=0.0    ! x-shift for FILETBX, FILETB and  FILETBZ (option IRBTAB)
      XSHMAGSEQ=0.0  ! x-shift for option KMAGSEQ

      HSHIFT=0.0    ! horizontal shift (z(elec)->z(elec)+HSHIFT)
      VSHIFT=0.0    ! vertical (y(elec)->y(elec)+VSHIFT)

      XROTD= 0.0    ! rotation angle around x-axis [degree]
                    ! z(elec) -> z*cos(XROTD) - y*sin(XROTD)
                    ! y(elec) -> z*sin(XROTD) + y*cos(XROTD)
                    ! the rotation is performed after the
                    ! translation !!
                    ! before you use these options, please consult
                    ! the manual
      IPERIODG=0    ! *** Attention: The options are applied in
                    ! the order:
                    ! XSHIFT..., IPERIODG, IBSYM...
                    !>0: magnetic field is taken periodically
                    !    with period length PERIODG
                    !-1: magnetic field is taken periodically with
                    !    period length PERIODG, for
                    !    XPERWMN < X < XPERWMMX
                    !-2: magnetic field is taken periodically with
                    !    period length PERIODG from half period,
                    !    for XPERWMN < X < XPERWMMX
                    !-3: magnetic field is taken periodically with
                    !    period length PERIODG from quarter of
                    !    period for cosine-like fields (in X)
                    !    for XPERWMN < X < XPERWMMX
                    !-4: magnetic field is taken periodically with
                    !    period length PERIODG from quarter of
                    !    period for sine-like fields (in X) for
                    !    XPERWMN < X < XPERWMMX
             ! Example, which extenses the device by 5 periods,
             ! i.e. 1 meter:
             !    KHALBASY=1
             !    AHWPOLT=3
             !    ZLHALBASY=0.2
             !    IPERIODG=-1
             !    PERIODG=0.2
             !    PEROFFG=-0.1
             !    XPERWMN=0.0
             !    XPERWMX=1.0
             !    XSHIFT=-0.5 ! to center the device
      XPERWMN=0.    !    lower X, for which field is taken
                    !    periodically
      XPERWMX=0.    !    upper X, for which field is taken
                    !    periodically
      PERIODG=0.8   ! period length of magnetic field
      PEROFFG=-0.4  ! X-offset of magnetic field
                    ! B(X,Y,Z)=B(MOD(X-PEROFFG,PERIODG),Y,Z)
      SIGNG=1.D0    ! factor to scale or reverse (if negative)
                    ! field after half a period
      SIGNG2=0.D0   ! factor to scale or reverse (if negative)
                    ! field after a full period
                    ! is ignored if zero

      BTAPERV=0.0d0  ! global vertical rel. taper, after all other operations
                     ! not Maxwell-conform
      BTAPERH=0.0d0  ! global horizontal rel. taper, after all other operations
                     ! not Maxwell-conform
      XTAPER=0.      ! x, where the taper factor is btaperv or btaperh,
                     ! respectively. 9999. means XTAPER=XSTART

 $END

 $BBHELM
        P0HELM(1,1)=-0.000    !x-position of coil center
        P0HELM(3,1)=0.0       !z-position of coil center
        P0HELM(1,2)=0.0
        P0HELM(3,2)=0.0
        P0HELM(1,3)=0.000
        P0HELM(3,3)=0.0
        R0HELM(1)=0.883782970238297  !radius [m] of coil
        R0HELM(2)=0.2
        R0HELM(3)=0.6
        B0HELM(1)=-1.5
        B0HELM(2)=7.5
        B0HELM(3)=0.
        INTHELM=100    ! number of linear segments to form coil
        $END

 $BBFELD ! hard-edge dipoles with optional fringes
         ! field is not MAXWELL conform
         ! selected by flag KBFELD

      XM1=-1. !entrance [m]
      XP1=+1. !exit[m]
      BBY1=1. !field [T]
      YSOFT1(1)=0.1    !width of left fring field[m]
      YSOFT1(2)=0.1    !width of right fring field [m]

      XM2=2.  !entrance [m]
      XP2=3.  !exit[m]
      BBY2=1. !field [T]
      YSOFT2(1)=0.0000    !width of left fring field[m]
      YSOFT2(2)=0.0000    !width of right fring field [m]

      XM3=4.  !entrance [m]
      XP3=5.  !exit[m]
      BBY3=1. !field [T]
      YSOFT3(1)=0.0000    !width of left fring field[m]
      YSOFT3(2)=0.0000    !width of right fring field [m]

      XM4=6.  !entrance [m]
      XP4=7.  !exit[m]
      BBY4=1. !field [T]
      YSOFT4(1)=0.0000    !width of left fring field[m]
      YSOFT4(2)=0.0000    !width of right fring field [m]

      XM5=8.  !entrance [m]
      XP5=9.  !exit[m]
      BBY5=1. !field [T]
      YSOFT5(1)=0.0000    !width of left fring field[m]
      YSOFT5(2)=0.0000    !width of right fring field [m]

      XM6=10.   !entrance [m]
        XP6=11. !exit[m]
      BBY6=1.   !field [T]
      YSOFT6(1)=0.0000    !width of left fring field[m]
      YSOFT6(2)=0.0000    !width of right fring field [m]

      XM7=12. !entrance [m]
      XP7=13. !exit[m]
      BBY7=1. !field [T]
      YSOFT7(1)=0.0000    !width of left fring field[m]
      YSOFT7(2)=0.0000    !width of right fring field [m]

      $END

 $HALBACH   ! magnetic field defined by HALBACH formula
            ! coordinate system here different from the
            ! standard of WAVE, HALBACH's convention used
            ! i.e. z is longitudinal device axis
            ! the system is internally converted to WAVE standard

      B0HALBA=0.5    ! peak field [T]
      PKHALBA=0.     ! Deflection parameter K, if not zero, B0HALBA is overwritten
      XLHALBA=0.0    ! 2*pi/kx (horizontal gradient) [m]
                     ! XLHALBA=0 means YLHALBA=ZLHALBA (no gradient)
      YLHALBA=9999.  ! is calculated from the relation ky**2=kx**2+kz**2
      ZLHALBA=0.05   ! 2*pi/kz [m]
      ZLENHAL=9999.  ! total device length [m]
      PERHAL=50.     ! number of periods (NOT NECESSARYLY INTEGER)
                     ! if positive then ZLENHAL is recalculated
                     ! ZLENHAL=ZLHALBA*PERHAL
                     ! if negative then ZLHALBA is recalculated
                     ! ZLHALBA=-ZLENHAL/PERHAL
      NHHALBA=1      ! if not zero, magnetic field is calculated such, that
                     ! the energy of the NHHALBAth harmonic is HHALBA
                     ! OVERWRITES PKHALBA!
      HHALBA=-9999.   ! photon energy of considered harmonic [eV]
                     !-9999.: HHALBA=(FREQLOW+FREQHIG)/2 or
                     ! or = FREQLOW for single photon energy
                     ! other negative values: HHALBA denotes wavelength [nm]
      XCENHALBA=0.0  ! longitudinal position of undulator center [m]

      $END

 $HALBASY   ! Device consists of a HALBACH device and two endpoles
            ! endpoles are also described by HALBACH formulas
            ! the pole width is adjusted to have zero first and
            ! second field integrals. The field is
            ! not fully Maxwell conform nor continuous.
            ! coordinate system here different from the
            ! standard of WAVE, HALBACH's convention used
            ! i.e. z is longitudinal device axis
            ! the system is internally converted to WAVE standard
      B0HALBASY=2.    ! peak field [T]
      PKHALBASY=0.    ! Deflection parameter K, if not zero, B0HALBASY is overwritten

      XLHALBASY=0.    ! 2*pi/kx for global horizontal gradient [m]
                      ! XLHALBASY=0 means YLHALBASY=ZLHALBASY (no gradient)
      YLHALBASY=9999. ! calculated from ky**2=kx**2+kz**2
      ZLHALBASY=0.2   ! 2*pi/kz of main poles [m]
      FASYM=2.0       ! asymmetry parameter, i.e.
                      ! absolute value of peak field ratio of main-
               ! and endpoles
               ! for FASYM=2.0, cos(k*x)+cos(2*k*x) is used, i.e.
               ! sign changes at ZLHALBASY/6.
               ! for FASYM=2.0+eps, cos(k*x)+cos(2*k*x) is used, i.e.
               ! sign changes at ZLHALBASY/4.
      AHWPOL=21.      ! number of main poles, should be an odd number
      IAHWFOUR=0      ! use field composed by Fourier superposition of
                      ! HALBACH devices; fourier coefficients A(1)...A(NFOUR)
               ! are calculated analytically
               ! parameter NFOUR in namelist FOURIER
      NHHALBASY=0     ! if not zero, magnetic field is calculated such, that
                      ! the energy of the NHHALBASYth harmonic is HHALBASY
                      ! OVERWRITES PKHALBASY!
      HHALBASY=1000.  ! photon energy of considered harmonic [eV]
                      !-9999.: HHALBASY=(FREQLOW+FREQHIG)/2 or
               ! or = FREQLOW for single photon energy
               ! other negative values: HHALBASY denotes wavelength [nm]
      XCENHAL=0.0     ! longitudinal position of undulator center [m]

      $END

 $UNDUGAPN  ! Device consists of a HALBACH device and two endpoles
            ! endpoles are also described by HALBACH formulas
            ! the pole width is adjusted to have zero first and
            ! second field integrals.

            ! Beff = a * exp( b*gap/perlen + c *(gap/perlen)**2 )

      UNDUFULLGAP=0.0055 ! Full gap [m]

      XLUNDUGAP=0. ! 2*pi/kx for global horizontal gradient [m]
                   ! XLUNDUGAP=0 means YLUNDUGAP=ZLUNDUGAP (no gradient)

      YLUNDUGAP=9999.   ! calculated from ky**2=kx**2+kz**2
      ZLUNDUGAP=0.017   ! 2*pi/kz of main poles [m]

      UNDUGAPPOL=161.  ! number of main poles, should be an odd number

      XCENUNDUGAP=0.0 ! longitudinal position of undulator center [m]

      ! Refer to NIM A 60711, Fit parameters for Beff

      ! Cryo-undulator, fit with chamfers
      !UNDUGAPA =  3.60959
      !UNDUGAPB = -3.91248
      !UNDUGAPC =  0.415708

      ! Sm2Co17
      !UNDUGAPA =  2.43479
      !UNDUGAPB = -3.50336
      !UNDUGAPC = -0.0500684

      ! Cryo-undulator, as in NIM A 907 (2018) 149-168
      !UNDUGAPA =  3.177
      !UNDUGAPB = -3.111
      !UNDUGAPC = -0.495

      ! Cryo-undulator, as in NIM A 60711
      UNDUGAPA =  3.598
      UNDUGAPB = -3.840
      UNDUGAPC =  0.6311

      $END

 $UCROSSN               ! crossed undulator consisting of a horizontal
                        ! undulator, a modulator, and a vertical undulator
                        ! each device consists of main poles and two end poles

        B0UCROSS(1)=-0.125 ! peak field of first undulator (horizontal) [T]
        B0UCROSS(2)= 0.035 ! peak field of modulator [T]
        B0UCROSS(3)=-0.125 ! peak field of second undulator (vertical) [T]

        UASYM(1)=2.4      ! asymmetry parameter, i.e.
                          ! absolute value of peak field ratio of main-
                          ! and endpoles
        UASYM(2)=1.5
        UASYM(3)=2.4

        NMUPOL(1)=11      ! number of main poles of first undulator
        NMUPOL(2)=1       ! number of main poles of modulator
        NMUPOL(3)=13      ! number of main poles of second undulator

        ZLUHAL(1)=0.084 !period length of first undulator [m]
        ZLUHAL(2)=0.140 !period length of modulator [m]
        ZLUHAL(3)=0.084 !period length of second undulator [m]

        IUCRSAX=0       !IUCRSAX.NE.0 end pole splitting 1:3:4
                        !IUCRSAX=2 horizontal undulator is centered
                        !IUCRSAX=3 vertical undulator is centered

      $END

 $ELLIPN          ! helical undulator

      PARKELL=0.  ! if not zero, it is effective K-parameter of undulator
                  ! mag. fields B0ELLIPV and B0ELLIPH are adjusted
                  ! signs and ratio of B0ELLIPV and B0ELLIP are kept

      B0ELLIPV=0.353553390593   ! vertical peak field   [T]
      B0ELLIPH=0.353553390593   ! horizontal peak field   [T]

      XLELLIP=0.056   ! period length [m]
      PERELLIP=31.    ! number of periods
      ELLSHFT=0.25    ! shift of horiz. and vert. fields [periods]

      NHARMELL=0 ! if not zero, magnetic field is calculated such, that
                 ! the energy of the NHARMth harmonic is HARMELL
                 ! signs and ratio of B0ELLIPV and B0ELLIP are kept
                 ! OVERWRITES PARKELL!

      HARMELL=1000.  ! photon energy of considered harmonic [eV]
                     !-9999.: HARMELL=(FREQLOW+FREQHIG)/2 or
                     ! or = FREQLOW for single photon energy
                     !other negative values: HARMELL denotes wavelength [nm]

      XCENELL=0.0 ! longitudinal position of undulator center [m]
      ELLTAP=0.0  ! scaling factor for taper to compansate energy loss
                  ! ELLTAP=1 means, that the field is corrected to shift the
                  ! harmonic to compensate for the energy-loss
                  ! It scales the whole device, since it is ment for a series
                  ! of undulators

      $END

 $ELLANAN ! helical undulator from anaytical field with
          ! hard edge endpoles (be careful)

      B0ELLANA=1.     ! field amplitude [T]
      NPERELLA=32     ! number of periods
      XLELLANA=0.2    ! lx [m]
      ZLELLANA=0.112  ! lz [m]
      X0ELLANA=0.0205   ! x0 [m], distance of magnet center from device axis
      GAPELL=0.024    ! full gap [m]
      REFGAPELL=0.02  ! reference gap of coefficiens [m]
      SHELLANA=0.25   ! shift in units of ZLELLANA
      ROWSHELLA=0.    ! additional row shift of lower rows
                        ! shift in units of ZLELLANA
      IELLS2S3=1      !>=0: S3-MODE; <0: S2-MODE
      IELLCOEF=0      !>0: read IELLCOEF Fourier coefficients from file
                      !    bellana.coef
                      !=<0: First and second coefficients only with C0=0.5,
                      ! and C1=1.

        $END

 $FOURIER   !to calculate FFT of magnetic field on the device
            !axis
            !coefficients are weights for superposition of
            !a series of HALBACH devices

      NFOUR=-9999 !number of coefficient taken for superposition
                  !-9999 NFOUR is read from file FILEF (IRFILF set)
      NFOURWLS=32 !number of coefficients written to file FILEF
      IFOUR0=0 ![0/1] coefficient A(0) is not/is set to zero
            !this allows one to adjust first and second
            !integral of magnetic field to zero
      XLENFOUR=0.0   !2*pi/kx (to superimpose horizontal gradient) [m]
      DBHOMF=0.0001  !x is calculated for which dB(x)/B(0) = DBHOMF [m]
      IPRNTF=0 !to print coefficients to output file WAVE.OUT

      FOUENTR=-9999.      ! Entrance of window for field calculation
                          ! Missing or equal -9999.:
                          ! Minus halve device length - XSHBFOUR
      FOUEXIT=-9999.      ! Exit of window for field calculation
                          ! Missing or equal -9999.:
                          ! Halve device length + XSHBFOUR
                          ! XSHBFOUR is applied before window cut

      SCBFOUR=1.0         ! Scaling factor for B-field
      XSHBFOUR=0.0      ! X -> X+XSHBFOUR in subroutine BFOUR


      $END

 $FBTABZYN
      FOURYSH=0.0   ! Shift for Bz, i.e. By(x+fourysh) is calculated
      FOURZSH=0.0   ! Shift for Bz, i.e. Bz(x+fourzsh) is calculated
      NFOURZY=64    ! Number of FFT coefficients
      IFOURZY0=0    ! Suppress offset:
                    ! 1:  Suppress offset of By
                    ! 10: Suppress offset of Bz
             ! 11: Both
      KLINEARFBT=0  ! Use linear interpolation rather then splines for
                    ! preparing FFT from data files
      ! Note: FFT are written to FILETB.fft and FILETBZ.fft
 $END

 $DEPOLA          ! storage ring parameters BESSY

      RDIPOL=  4.359 ! 1.3 Tesla
      UMFANG=  240.
      TAUKRIT=4.0

            ! Reference Paul Goslawki, Jul 2019:
            ! High Beta:
            !
            !           epsilon_x = 7.70E-9 m-rad
            !           epsilon_y = 1.54e-10 m-rad
            !
            !           sigma_x  = 275.e-6 m
            !           sigma_xp = 28e.1-6 rad
            !           sigma_y = 22.5e-6 m
            !           sigma_yp= 6.80e-6 rad


            ! Reference:
            ! Einige_Parameter_der_Elektronenoptik_beim_Top.doc
            ! Sigmas include dispersion

              ! natural emittance  epsilon_n = 5.34E-9 m-rad
              ! hori. emittance    epsilon_n = 5.34E-9 m-rad
              ! vert. emittance    epsilon_n = 8.01E-11 m-rad
              ! 1.5 % coupl.

            ! high beta:

               !     beta_x   = 8.71 m
               !     sigma_x  = 216.e-6 m
               !     sigma_xp = 24.8e-6 rad

               !     SIG_X_10m = 329.e-6 m

               !               beta_y  = 4.36 m
               !     sigma_y = 18.7e-6 m
               !     sigma_yp= 4.29e-6 rad

               !     SIG_Y_10m = 46.8E-6 m

            ! low beta:

               !     beta_x   = 0.96 m
               !     sigma_x  = 71.6e-6 m
               !     sigma_xp = 74.6e-6 rad

               !     SIG_X_10m = 749.4e-6 m

               !               beta_y  =  1.23 m
               !     sigma_y =  9.93e-6 m
               !     sigma_yp = 8.07e-6 rad

               !     SIG_Y_10m = 81.3e-6 m

      IBETBACK=0     ! BETAH, BETAHP, BETAV, BETAPV refere to exit rather than to entrance

      XBETFUN=9999. ! X, where BETAH,BETAV, etc. refer to
                    ! 9999: XBETFUN = XSTART or XSTOP respectively (IBETBACK)
             !       (compatibilty mode for old versions)

      BETFUN=0.0  ! hori. beta-function in the center, where the
                  ! derivative is zero
                  ! 0.: calculated from BSIGZ(1) in namelist WFOLDN
                  ! -9999.: BETAH and BETAPH are calculated as periodic
                  !        solution from lineare Transfermatrix

      BETAH=9999. ! hor. beta-function at XSTART
                  ! 9999.: calculated from BETFUN with parabolic ansatz
                  ! under the assuption, that the derivative is zero
                  ! where the hori. beta-function equals BETFUN
                  ! -9999.: calculated analytically from BETFUN
                  ! under the assuption, that the derivative is zero
                  ! where the hori. beta-function equals BETFUN

      BETAPH=9999. ! derivative of hor. beta-function at XSTART
                   ! 9999.: calculated from BETFUN with parabolic ansatz
                   ! under the assuption, that the derivative is zero
                   ! where the hor. beta-function equals BETFUN
                   ! -9999.: calculated analytically from BETFUN
                   ! under the assuption, that the derivative is zero
                   ! where the hori. beta-function equals BETFUN

      EPS0H=7.70e-9  ! horizontal emittance

      BETFUNV=0.0    ! vert. beta-function in the center
                     ! 0.: calculated from BSIGZ(1) in namelist WFOLDN
                     ! -9999.: BETAV and BETAPV are calculated as periodic
                     ! solution from lineare transfermatrix

      BETAV=9999.    ! vert. beta-function at XSTART
                     ! 9999.: calculated from BETFUNV with parabolic ansatz
                     ! under the assuption, that the derivative is zero
                     ! where the vert. beta-function equals BETFUNV
                     ! -9999.: calculated analytically from BETFUNV
                     ! under the assuption, that the derivative is zero
                     ! where the vert. beta-function equals BETFUNV
      BETAPV=9999.   ! derivative of vert. beta-function at XSTART
                     ! 9999.: calculated from BETFUNV with parabolic ansatz
                     ! under the assuption, that the derivative is zero
                     ! where the vert. beta-function equals BETFUNV
                     ! -9999.: calculated analytically from BETFUNV
                     ! under the assuption, that the derivative is zero
                     ! where the vert. beta-function equals BETFUNV

      EPS0V=15.4e-11

      DISP0=0.0   ! external dispersion [m]
      DDISP0=0.0   ! derivative of external dispersion [m]

      DI2RING=1.4414  ! radiation integral I2 of storage ring
      DI4RING=0.0 ! I4
      DI5RING=0.0020588 ! I5

      DELGAM=0.001

      $END

 $WLSOPTN   ! parameter for search of optimal WLS (simple model with
         ! one main pole and two endpoles
         ! refere to namelist HALBASY
         ! the three parameters are variated on a grid
         ! the device which meets best the boundary
         ! condition is selected

      B0MIN=6.0   ! minimum peak field of main pole
      B0MAX=6.0   ! maximum peak field of main pole
      DB0=  0.1   ! step size for variation

      XLAM0MN=0.4 ! minimum double width of main pole
      XLAM0MX=1.0 ! maximum double width of main pole
      DXLAM0=0.01 ! step size of variation

      FASYMMN=2.0 ! minimum asymmetry parameter
      FASYMMX=10.0   ! maximum asymmetry parameter
      DFASYM= 0.1 ! step size

      EMICRTMX=1.0   ! critical emittance change that can be accepted
            ! relative factor i.e. emittance of ring + wls
            ! over emittance of ring
            ! referes to actual beam energy (DMYENERGY)
      IEMICRIT=0  ! if not zero EMICRTMX referes to minimal beam energy
            ! that is acceptable from polarization time
            ! for this option must DISP0=0
      TAUCRTMX=4. ! critical beam polarization time that is acceptable [h]
      POLLEVMN=.80   ! critical final beam polarization that is required
            ! referes to lowest beam energy [POLLEVMN < 0.92]
      ZMAXMN=0.015   ! minimum required displacement of trajectory [m]
      ZMAXMX=1.0  ! maximum required displacement of trajectory [m]
      DXHOM=0.0   ! x-value for which homogenity requirements of the
            ! magnetic field are still fulfilled
            ! homogenity limit is given by DBHOMF in
            ! namelist FOURIER
      $END

 $MYFILES   ! file names and logical unit numbers of most user files
         ! all other files written or read have names beginning with
         ! WAVE_....
                ! the logical unit numbers below 50 are used by WAVE
         ! and must not be used by the user

      FILEOB=     'observ.in'    ! list of observation points
      LUNOB=      71

      FILEFR=     'freqs.in'     ! list of photon energies
      LUNFR=      72

      FILESP0= 'wave.sp0'     ! data of calculated spectrum
      LUNSP0=     73

      FILEPOW= 'wave.pow'     ! power distributions
      LUNPOW=     73

      FILEINT= 'wave_int.dat'    ! integrand of spectrum
      LUNINT=     74       ! calculations


      FILEHB=     'wave_histo.his'  ! HBOOK/PAW histogram file
      LUNHB=      75

      FILEL0=     'wave_l0.dat'     ! source points
      LUNL0=      76

      FILERAY= 'wave_ray.dat'    ! data for RAY
      LUNRAY=     80

      FILEO=      'wave_optic.dat'  ! set of trajectories for
      LUNO=    81       ! generating function fit

      FILED=      'wave_disper.dat'    ! obsolete
      LUND=    82

      FILECOD= 'WAVE_CODE.DAT'      ! program run counter (ICODE)
      LUNCOD=     83

      FILEF=      'btab.fou'     ! Fourier coefficients of
      LUNF=    84       ! magnetic field

      FILETB=     'btab.dat'
      LUNTB=      85

      FILETBZ= 'bz.dat' ! 1D table of magnetic field Bz
      LUNTBZ=     70

      FILETBX= 'bx.dat' ! 1D table of magnetic field Bz

      FILETR=     'wave_track.dat'  ! trajectory and magnetic field
      LUNTR=      86

      FILEP=      'wave_poisson.dat'   ! POISSON output data
      LUNP=    87       ! (modified version of POISSON)

      FILEJ=      'wave_adjust.dat' ! scratch file for option IJUST
      LUNJ=    88

      FILEB0=     'bmap.ntup' ! 3D table of B-field
      LUNB0=      89

      FILEBE=     'wave_beta.dat'      ! obsolete
      LUNBE=      89

      FILEWB=     'wave_wbeta.dat'  ! optical functions
      LUNWB=      90

      FILEZZPYYP= 'wave_zzpyyp.dat'       ! phase space trajectory
      LUNZZPYYP=   91

      FILESPF= 'wave_specf.dat'  ! data of folded spectrum
      LUNSPF=     92

      FILEWBT= 'wave_wbtab.dat'  ! magnetic field and integral
      LUNWBT=     93       ! multipole terms along
                     ! straight line

      FILEABS= 'sigma_tot.pb'    ! absorption coefficients
      LUNABS=     94       ! of filter

      FILEFF=     'gold.eff'     ! photo yield of gold
      LUNEFF=     94

      FILEMG=     'magseq.in'    ! sequence of magnets
      LUNMG=      95

      FILEFL0= 'wave_flux.dat'  ! flux through pinhole
      LUNFL0=     96

      FILEFLF= 'wave_fluxf.dat'  ! folded flux through pinhole
      LUNFLF=     97

      FILESTO= 'wave_stokes.dat' ! stokes dist. in  pinhole
      LUNSTO=     98

      FILESTOF=   'wave_stokesf.dat'   ! f-folded stokes dist. in  pinhole
      LUNSTOF= 99

      FILESTOE=   'wave_stokese.dat'   ! e-folded stokes in pinhole

      FILESTOEF=  'wave_stokesef.dat'  ! ef-folded stokes in  pinhole

      FILES=          'wave_stokes_flux.dat'  ! STOKES vector of flux through
      LUNS=           69

      FILESE=         'wave_stokese_flux.dat' ! STOKES vector of flux through
      LUNSE=          69                      ! with beam energy spread

      FILESF=         'wave_stokesf_flux.dat' ! STOKES vector of flux through
      LUNSF=          69                      ! with beam emittance

      FILESEF=        'wave_stokesef_flux.dat' ! STOKES vector of flux through
      LUNSEF=         69                      ! with beam energy spread and e

      FILEC=          'wave_stokes_selected.dat'  ! STOKES vector of flux-density through
      LUNC=           69

      FILECE=         'wave_stokese_selected.dat' ! STOKES vector of flux-density through
      LUNCE=          69                      ! with beam energy spread

      FILECF=         'wave_stokesf_selected.dat' ! STOKES vector of flux-density through
      LUNCF=          69                      ! with beam emittance

      FILECEF=        'wave_stokesef_selected.dat' ! STOKES vector of flux-density through
      LUNCEF=         69                      ! with beam energy spread and e

      FILEBRILL='wave_stokes_brilliance_selected.dat'  ! brilliance of STOKES vector of flux-density through


      FILEBRILLE='wave_stokes_brilliance_e_selected.dat' ! brilliance of STOKES vector of flux-density through
      ! with beam energy spread

      FILEBRILLF='wave_stokes_brilliance_f_selected.dat' ! brilliance of STOKES vector of flux-density through
      ! with beam emittance

      FILEBRILLEF='wave_stokes_brilliance_ef_selected.dat' ! brilliance of STOKES vector of flux-density through
      ! with beam energy spread and e

      FILEAM= 'abscoef_merge.in'   !List of files to be merged
      !OR input files
      !for option IFILMUL

      LUNAM= 67

      FILEAMO= 'ABSCOEF_MERGE.OUT'  !Resulting absorption coefficients
      LUNAMO= 68

      FILEREC= 'rec.par'           ! REC-structure
      LUNREC= 69

      FILEBMAP= 'bmap.dat'        ! Magnetic field map
      LUNBMAP= 67

      FILE3DCOE= 'bpoly3d.coef'          ! REDUCE coefficient file
      LUN3DCOE= 67

      FILE3DFIT= 'bpoly3d.fit'           ! fitted coefficient file

      FILE2DHFIT= 'bpoly2dh.fit'        ! fitted coefficient file
      LUN2DHFIT= 67

      FILEPHFIT= 'bpharm.fit'        ! fitted coefficient file
      LUNPHFIT= 67
+self,if=-mshhbook.
      FILEPH= 'phase.his'        ! NTUPLE-file for sr phase
      LUNPH= 67
+self.
      FILEAMPLI= 'reaima.dat'       ! File for field amplitudes
      LUNAMPLI= 67

      FILEFTH= 'htaper.dat'       ! File for field amplitudes
      FILEFTV= 'vtaper.dat'       ! File for field amplitudes
      LUNFT= 50

      FILEGENL= 'genesis.lat'      ! Lattice-File of FEL-code GENESIS
      LUNGENL= 67

      FILEGENI= 'genesis.lat'      ! Lattice-File of FEL-code GENESIS
      LUNGENI= 67

 $END

 $TRALINN ! The linear transfer matrix is estimated from four trajectories
          ! (DELTAZ,0,0,0), (0,DELTAZP,0,0), ...
          ! The matrix is written to file tralin.wav.
          ! Entrance and exit planes are perpendicular to closed orbit
          ! be careful for dipoles (are treated as sectors)

          ! For BETFUN=-9999. and BETFUNV=-9999., the periodic solution for the
          ! beta-functions and the beta matrices are calculated.

          ! Phasespace ellipses are calculated, if IPHELLIP.ne.0

          ! the transfer matrix is also applied to the variables of namelist
          ! PHASETRACKN

        DELTAZ= 0.0  !horizontal coordinate [m]
        DELTAZP=0.0  !horizontal slope [radian]
        DELTAY= 0.0  !vertical coordinate [m]
        DELTAYP=0.0  !vertical slope [radian]

        DELTAE=0.0  !rel. energy spread

        $END

 $PHASETRACKN

      PHTRZ0=0.001    !Z0 in phase with respect to closed orbit (hori.)
      PHTRZP0=0.001   !ZP0 in phase with respect to closed orbit
      PHTRY0=0.001    !Y0 in phase with respect to closed orbit (vert.)
      PHTRYP0=0.001   !YP0 in phase with respect to closed orbit
                      !the hor. ellipse is calculated for y=PHTRY0
                      !and yp=PHTRYP0, the vert. with z=PTHRZ0 etc.
                      !the results are written files
                      !wave_phase_ellipse_hori.wva and
                      !wave_phase_ellipse_vert.wva

      IPHELLIP=0      !number of angle steps for calculation of phasespace
                      !ellipses: PTHTRZ0,... are
                      !taken as half-axis of phasespace ellipses
      PHDISPH=0.0d0   !horizontal displacement
      PHBETAH=0.0d0   !horizontal beta-function
      PHDISPV=0.0d0   !vertical displacement
      PHBETAV=0.0d0   !vertical beta-function

      $END

 $OPTIK ! parameter to track set of particles through device for fitting
        ! coefficients of generating function
        ! trajectories are spaced on a grid with a mesh size of
        ! 2*DZOPT,2*DYOPT etc ...
        ! e.g. IZ=-NZOPT,...,-4,-2,0,2,4,...,NZOPT  or IZ=...,-3,-1,1,3,...
        ! ****  its a hollow beam if NZOPT etc. are odd ****
        ! the phase space is defined by a collimator
        ! trajectories are written to file FILEO

        ! for mash sizes of the grid i.e. e.g DZOPT=9999.
        ! mash is fit do aperture according to number of mash points

        NZOPT=8     !grid of horizontal displacement
        DZOPT=9999.  !grid of horizontal displacement
        NYOPT=8     !grid of vertical displacement
        DYOPT=9999.  !grid of vertical displacement

        NZPOPT=8     !grid of horizontal slope
        DZPOPT=9999. !grid of horizontal slope
        NYPOPT=8     !grid of vertical slope
        DYPOPT=9999. !grid of vertical slope

        DLAPER=5.8    ! length of collimator, if eq. 9999. then DLAPER is device
                      ! length, collimator is centered around reference orbit
        ZAPERT=0.03   ! horizontal apertur is +/- ZAPERT
        YAPERT=0.0075 ! vertical apertur is +/- YAPERT

        IPHASPAC=0   ! aperture cut takes phase space according to
                     ! subsequent beta functions into account

        IHPHSPAC=1   ! store tracks and phase space distribution in ntuple
                     ! on histogram file

        BETA0ZL=10.0  ! value of horizontal low beta function
        BETA0ZH=10.0  ! value of horizontal high beta function
        BETA0YL=10.0  ! value of vertical low beta function
        BETA0YH=10.0  ! value of vertical high beta function

        OPSTARTX=9999. ! point in starting plane for the tracking
            ! the point (OPSTARTX,OPSTARTY,OPSTARTZ)
            ! defines together with the vector (OPNX,OPNY,OPNZ)
            ! the entrance plane of the device
            ! OPSTARTX=9999. ->
            !(OPSTARTX,...Y,...Z)=(XSTART,YSTART,ZSTART)
        OPSTARTY=0.
        OPSTARTZ=0.

        OPNX=9999.  ! normal vector of starting plane
                    ! starting plane is normal to reference orbit
                    ! OPNX=9999. -> (OPNX,OPNY,OPNZ)=(VXIN,VYIN,VZIN)
        OPNY=0.0
        OPNZ=0.0

        OPENDX=9999.  ! x of point in exit plane of device
                      ! (9999. -> OPENDX=XF0, OPENDY=YF0, OPENDZ=ZF0)
        OPENDY=0.       ! y of point in exit plane of device
        OPENDZ=0.       ! z of point in exit plane of device

        OPNFX=9999. ! normal vector of end plane
                    ! OPNFX=+9999. means vector is calculated
                    ! from reference orbit where it reaches (OPENDX)
        OPNFY=0.0
        OPNFZ=0.0

        DRANDO=0.  ! start values of trajectories are modified by adding
                   ! random numbers in the range of DRANDO * mesh-size
        DSCALE=1.  ! scaling factor for linear equation system

        isnorder=0 ! 0/1 to increase precision of tracking a little bit
                   ! and slow down the program

        I2DIM=0    ! to restrict problem to orbit plane; y,y' are taken
                   ! from matrix of drift space
      $END

 $TRANPON   ! to determine coefficients of generating function
            ! reads in a set of trajectories from file FILEO

      NTRAJ=-9999 ! use only mtraj trajectories for fitting
                  ! -9999: use all trajectories
                  ! -1: use as much trajectories as number of coeffs. to fit

      ISELECT=51  ! if set to ISELECT=N, each Nth of the tracks is printed

      IKOEFF=1    ! IKOEFF.NE.0 -> coefficients are printed

      IHALBA=0    ! to get equivalent HALBACH device (I2DIM must be 0)

      NPERTRA=78  ! number of periods of equivalent HALBACH device

      IQUAD=1     ! calculate quadrupole matrix

      IA1000=0    ! IA1000.NE.0 means A1000 is not fittet
      IA0100=0    ! IA0100.NE.0 means A0100 is not fittet
      IA0010=0    ! IA0010.NE.0 means A0010 is not fittet
      IA0001=0    ! IA0001.NE.0 means A0001 is not fittet

      IA11A20=0   ! IA11A20.NE.0 means set to A1100=1 and A2000=0,
                  ! coefficients are not fitted

      IWLSHOR=0   ! IWLSHOR.NE.0 means that in the horizontal plane only
                  ! the first and second order are fitted

      ISYM=0      ! ISYM.NE.0 means symmetry is assumed with respect to the
                  ! orbit plane

      DRAUSCHX=0.  ! absolute amplitudes of the noise superimposed on the
                   ! final coordinates and slopes (standard deviation)
      DRAUSCHY=0.  ! XF(1:2,I)=XF(1:2,I)+XRAN(1:2)*DRAUSCHX
                   ! XF(3:4,I)=XF(3:4,I)+XRAN(3:4)*DRAUSCHY
                   ! XRAN is normal random number
                   ! (test purposes, to simulate noise in tracking routine)
      STRAILEN=5.8 ! full length of straigth section

      $END

 $COLLIN ! CX1,...,HIG2 form a collimator for the spectrum
       ! calculations (just two rectangular pinholes)
       ! this collimator selects the sources taken into account
       ! Once having defined the sources, the collimator is ignored
       !
       ! The aperture given by APERX,...,APERHIG, is taken into
       ! account during the spectrum calculations. All
       ! contributions to the photon flux at a given observation point
       ! are ignored if a straight line from the electron to the
       ! observer does not pass the aperture

      CX1=9999.   ! (CX1,CY1,CZ1) is center of first pinhole [m,m,m]
                        ! 9999. means according to PINCEN(1) or OBSV(1,1)
      CY1=9999.      ! 9999. means according to PINCEN(2) or OBSV(2,1)
      CZ1=9999.      ! 9999. means according to PINCEN(2) or OBSV(3,1)
      WID1=9999.  ! width of first pinhole [m]
            ! 9999. WID1=PINW+4.*PINW/MPINZ
      HIG1=9999.  ! height of first pinhole [m]
            ! 9999. HIG1=PINH+4.*PINW/MPINY

      CX2=9999.       ! datas of second pinhole
                        ! 9999. means according to PINCEN(1) or OBSV(1,1)
      CY2=9999.
      CZ2=9999.
      WID2=9999.  ! 9999. WID2=PINW+4.*PINW/MPINZ
      HIG2=9999.  ! 9999. HIG2=PINH+4.*PINW/MPINY

      WGWINFC=9999.  ! defines source points; those parts of the trajectory
            ! are taken into account for which the radiation cone of
            ! opening angle +/- WGWINFG/GAMMA passes the collimator
            ! 9999. means WGWINFC is calculated by SR SETWGWIN

      WBL0CUT=0.0 ! cut on magnetic field; source starts at
            ! B > (WBL0CUT*WBL0HYS)
            ! source ends at B < WBL0CUT

      WBL0HYS=1.0 ! hysteresis for cut on magnetic field
            ! at beginning of source WBL0CUT-->WBL0CUT*WBL0HYS
            ! at end of the source WBL0CUT-->WBL0CUT/WBL0HYS

      IBL0CUT=0   ! for IBL0CUT greater zero source is split when the
            ! sign of the vertical magnetic field changes
            ! IBL0CUT=-1 means source points are accepted
            ! even for zero field
            ! IBL0CUT=-2 means whole trajectory is single source

      ISOUREXT=0  ! program extends source by ISOUREXT points
            ! to check if neighbouring sources overlap and
            ! should be treated as coherent source
                      ! ISOUREXT.LT.0 means to ignored occured errors
                      ! due to overlapping sources


      ! The following aperture works only for old version (ISPECMODE=3)
      APERX=-9999.   ! x-position of aperture, -9999. means equal to PINCEN(1)
      APERY=0. ! y-position of aperture
      APERZ=0.0   ! z-position of aperture

      APERWID=1.0d30  ! full width of aperture
      APERHIG=1.0d30  ! full hight of aperture

    $END

 $SPECTN ! complex polarization vector
         ! intensity is calculated from amplitude projected on this
         ! vector

+SELF,IF=-NOCMPLX.
      VPOLA(1)=(0.,0.)  ! linear horizontal     [(0,0),(0, 0),(-1,0)]
      VPOLA(2)=(0.,0.)  ! right handed circular [(0,0),(0,-1),( 1,0)]
      VPOLA(3)=(-1.,0.) ! left handed circular  [(0,0),(0,-1),(-1,0)]

      REFLEC(1)=(1.,0.) ! complex reflectivity coefficients
      REFLEC(2)=(1.,0.)    ! the field amplitude is multiplied with
      REFLEC(3)=(1.,0.)    ! these coefficients
+SELF,IF=NOCMPLX.
      VPOLAR(1)=0.   ! linear horizontal     [(0,0),(0, 0),(-1,0)]
      VPOLAI(1)=0.   ! linear horizontal     [(0,0),(0, 0),(-1,0)]
      VPOLAR(2)=0.   ! linear horizontal     [(0,0),(0, 0),(-1,0)]
      VPOLAI(2)=0.   ! linear horizontal     [(0,0),(0, 0),(-1,0)]
      VPOLAR(3)=-1.  ! left handed circular  [(0,0),(0,-1),(-1,0)]
      VPOLAI(3)=0.   ! left handed circular  [(0,0),(0,-1),(-1,0)]

      REFLECR(1)=1.  ! complex reflectivity coefficients
      REFLECR(2)=1.  ! the field amplitude is multiplied with
      REFLECR(3)=1.  ! these coefficients
      REFLECI(1)=0.  ! complex reflectivity coefficients
      REFLECI(2)=0.  ! the field amplitude is multiplied with
      REFLECI(3)=0.  ! these coefficients
+SELF.

      NPOLMX=6 ! max. number of poles
            ! (array dimension for, F90 only, replaces NDPOLP)

      XWALLI=0.   ! begin of beamline for power density calculations
      XWALLE=15.  ! end of beamline for power density calculations
      WALL(1)=+0.05  ! z-positions of beamline walls
      WALL(2)=-0.05  ! (WALL(1) .GE. WALL(2))

      XABSORB=9999.  ! x-position of absorber normal to beamline
            ! =9999. means XABSORB=XWALLE
      ZABSORB(1)=2.   ! upper edge (z) of absorber
            ! =9999. means ZABSORB(1)=WALL(1)
      ZABSORB(2)=-2.   ! lower lower edge (z) of absorber
            ! =9999. means ZABSORB(2)=WALL(2)

      NPWALL=1000 ! number of points on beam line wall for plots

      POWBCUT=0.025  ! cut on magnetic field to find poles
            ! if B < POWBCUT the corresponding part of the
            ! trajectory is ignored
            ! cut should not be too small to avoid problems
            ! in subroutine BEAMPOW
            ! maybe the product MYINUM * POWCUT is a criterion
                        ! POWCUT*MYINUM .GE. 25
      $END

 $WFOLDN    ! to apply emittance folding procedure to spectrum

            ! Reference Paul Goslawki, Jul 2019:
            ! High Beta:
            !
            !
            !           epsilon_x = 7.70E-9 m-rad
            !           epsilon_y = 1.54e-10 m-rad
            !
            !           sigma_x  = 275.e-6 m
            !           sigma_xp = 28e.1-6 rad
            !           sigma_y = 22.5e-6 m
            !           sigma_yp= 6.80e-6 rad

            ! Reference:
            ! Einige_Parameter_der_Elektronenoptik_beim_Top.doc
            ! Sigmas include dispersion

            ! natural emittance  epsilon_n = 5.34E-9 m-rad
            ! hori. emittance    epsilon_n = 5.34E-9 m-rad
            ! vert. emittance    epsilon_n = 8.01E-11 m-rad
            ! 1.5 % coupl.

            ! high beta:

            !     beta_x   = 8.71 m
            !     sigma_x  = 216.e-6 m
            !     sigma_xp = 24.8e-6 rad

            !     SIG_X_10m = 329.e-6 m

            !     beta_y  = 4.36 m
            !     sigma_y = 18.7e-6 m
            !     sigma_yp= 4.29e-6 rad

            !     SIG_Y_10m = 46.8E-6 m

            ! low beta:

            !     beta_x   = 0.96 m
            !     sigma_x  = 71.6e-6 m
            !     sigma_xp = 74.6e-6 rad

            !     SIG_X_10m = 749.4e-6 m

            !     beta_y  =  1.23 m
            !     sigma_y =  9.93e-6 m
            !     sigma_yp = 8.07e-6 rad

            !     SIG_Y_10m = 81.3e-6 m

            ! if not zero WSIGZ-values are overwritten!!

      BSIGZ(1)=275.e-6  ! horizontal beam size [m]
      BSIGZP(1)=28.1e-6 ! horizontal beam divergency [rad]

                        ! if not zero WSIGY-values are overwritten!!
      BSIGY(1)=22.5e-6  ! vertical beam size [m]
      BSIGYP(1)=6.80e-6 ! vertical beam divergency [rad]

      WSIGZ(1)=329.e-6 ! sigmas of Gaussians for folding
             ! if ISIGUSR is set
             ! values are overwritten if BSIGZ or BSIGZP
             ! not zero according to
             ! WSIGZ=SQRT(BSIGZ**2+(PINCEN(1)*BSIGZP)**2)

      WSIGY(1)=46.8E-6 ! the same for the verticale direction
             ! values are overwritten if BSIGY or BSIGYP
             ! not zero according to
             ! WSIGY=SQRT(BSIGY**2+(PINCEN(1)*BSIGYP)**2)

             ! *** IF VALUES ZERO FOR FURTHER SOURCES,
             ! *** VALUES A TAKEN FROM FIRST SOURCE.

      DGSIGZ(1)=3.     ! number of sigmas taken into account for folding
      DGSIGY(1)=3.

      NGFOURZ=5    ! the Gaussians are approximated by Fourier expansion
      NGFOURY=7    ! these parameter give the number of used coefficients
                   ! (OBSOLETE, only for IFOLD=-1 OR IFOLD=-2)

      ISIGSTO=1    ! sigmas for folding of STOKES vectors are taken
                   ! form source point ISIGSTO
                   ! ISIGSTO=0 means ISIGSTO=1

      SIGRC=0.841  ! empirical correction factor for SIGR

                ! SIGR=SQRT(2*LAMBDA*L)/2/PI*SIGRC
                ! needed for brilliance estimations
                ! Walker agrees with WAVE flux, but brilliance is
                ! twice that of WAVE
                !
                ! Kim: SIGRC=1/2/SQRT(2)
                ! SIGRC=0.353553, i.e. Faktor of 8 in brilliance,
                ! for zero emittance

              ! Try 1./sqrt(sqrt(2.)) = 0.841

      SIGRPC=0.841 ! empirical correction factor SIGRP
                ! SIGRP=SQRT(LAMBDA/2/L)*SIGRPC

                ! needed for brilliance estimations
                ! Kim: SIGRC=SQRT(2)
                ! SIGRPC=1.414D0
                ! Kim: SIGRC=SQRT(2)
                ! SIGRC=1.4142136, i.e. Faktor of 2 in flux,
                ! for zero emittance, which corresponds to the real
                ! maximum of the flux, not to that, where the
                ! brilliance has its maximum

              ! Try 1./sqrt(sqrt(2.)) = 0.841

      ESPREAD=0.001  ! rel. energy spread of the beam (for energy folding)
      NSIGE=3        ! number of sigmas for energy folding

      $END

 $BUNCHN

 !*** Still experimental!! Check results carefully ***!

      NBUNCH=1        ! Number of bunches

      NEINBUNCH=1     ! NEINBUNCH particles are treated coherently

      ILINTRA=0       ! >0: read linear transfer matrices from file
                      ! wave_lintra.dat
               ! <0: write linear transfer matrices to file
               ! wave_lintra.dat
               ! Note: This matrix transforms from the
               ! beginning of the source (not necessaryly XSTART) to
               ! XLINTRA, NOT to the end
               ! ISPEC and IBUNCH must not be zero
               ! The matrix is calculated from BETAH, BETAPH,
               ! BETAV, and BETAPV, which must correspond to XLINTRA
               ! BSIGZ, BSIGZP, BSIGY, and BSIGYP must
               ! be consistant with the beta-functions at XLINTRA

      XLINTRA=-9999.  ! x [m], where the alphah and alphav are zero, i.e.
                      ! minima or maxima of the beta-functions.
                      ! -9999. means source center
                      ! XLINTRA must lay within the source

      BUNCHLEN=1000.0d-9  ! Length [m] of a  bunch.
                          ! The phase of the field amplitude of each particle
                          ! is affected by BUNCHLEN.
              ! =0: Also in this case the phase of the field
              !     is randomized for each bunch
              ! <0: No global phase randomization for bunches
              !*** Since there is a variety of
              ! combinations of IAMPLI, IMAMPLI, IBUNCH, IUBUNCH
              ! etc., there might be an unexpected behaviour.
              ! Please, be careful and watch the effects
              ! on the field amplitude and the flux-densities

      IUBUNCH=0   ! to calculate phase space distribution of electrons
                  ! *** The principle trajectory from XSTART
           ! etc. is taken as the center of the phase-space,
           ! i.e. the coordinates and velocity are added to the
           ! generated ones.
           !
           ! 0: Gaussian distribution according to BSIGZ, BSIGY
           !    etc. in namelist WFOLDN
           !
           ! 1: Gaussian distribution according to
           !    ESP0H, BETAH, BETAPH, and
           !    ESP0V, BETAV, BETAPV in namelist DEPOLA,
           !    which refer here to the beginning of the source.
           !    The might be different, depending e.g. on IAMPLI,
           !    so, please, check the source in wave.out
           !    and adjust the beta functions etc. accordingly.
           !    IFOLD must be zero, IBUNCH must be non-zero.
           !
           ! -1: user routine UBUNCH(x,y,z,yp,zp,gamma,dt),
           !     where x referes to the center of the bunch
           !
           ! 2: routine BUNCH(dt) for longitudinale
           !    distribution according to Saldin,
           !    NIM A 539 (2005) 499-526
           !    with parameters BUNCHP0, BUNCHR56, NBUNCHHARM
           !    and AMPFREQ in namelist AMPLIN
           !
           ! 3: read phasespace distribution
           !    gamma,xbunch,x,y,z,dpy/p,dpz/p from
           !    file wave_phasespace.dat  (LUN=21)
           !
           ! 4: longitudinale distribution within bunch is read in
           !    terms of FOURIER-coefficients from file
           !    fourier-bunch.dat
           !
           !    Format:
           !    Lines starting with * in first column or empty
           !    lines are comments
           !    other lines give coefficients c1...cn for harmonics
           !    first nbunchharm coefficients are used

      BUNCHP0=250.d-6 ![GeV]
      BUNCHR56=30.d-6 !R56 [m]
      NBUNCHHARM=1   !number of harmonics of microbunching (IUBUNCH = 2)

      BUNCHCHARGE=-9999.   !charge per bunch [C]
                           !-9999.: BUNCHCHARGE is 1.60218E-19 * NEINBUNCH

      IBUNPHASE=0       ! Treatment of overall phase of single electron in
                        ! a bunch.
                        ! 1: For each photon energy the field is  phase-shifted
                        !    such, that the imaginary part of the amplitude Az
                        !    vanishes for observation point IOBUNCH.
                        !    THIS IS A FULLY COHERENT BEAM (within each bunch)

      IOBUNCH=-9999     ! number of reference observation point for IBUNPHASE=1
                        ! 0: IOBUNCH=ICBRILL, i.e. selected point according to
                        ! IPBRILL
                        ! -9999: IOBUNCH is taken, where flux-density is highest

      IHBUNCH=1       ! to get N-tuple of beam IHBUNCHth electrons
                      ! for KAMPLI > 0, only first thread is considered
               ! if AMPREP_OMP is called

      IWBUNCH=0       ! write distribution of iwbunch electrons to file
                      ! wave_phasespace_bunch.dat (LUN=22)
                      ! (gamma,xbunch,x,y,z,dpy/p,dpz/p)

      $END

 $PINHOLE   ! rectangular pinhole for spectrum calculations
            ! or single observation points are defined here

      RPINSPH=0.0d0  ! use part of a sphere rather than plain pinhole
                     !-9999.: RPINSPH=PINCEN(1)

      PINCEN(1)=10.  ! x-center of pinhole [m]

      PINCEN(2)=9999.   !y-center of pinhole [m]
            !9999. means centered according to IPBRILL, such
            !that corner or center is on-axis
            !-8888. means centered according to
            !set according to straight line fit of trajectory
            !between XIANF and XIEND
            !-9999. means centered according to
            !YSTART+VYIN/VXIN*(PINCEN(1)-XSTART)
            !-9000. means estimate position by averaging
            ! y(x)+vy(x)/vx(x)*(x-pincen(1))

      PINCEN(3)=9999. !z-center of pinhole [m]
            !9999. means centered according to IPBRILL, such
            !that corner or center is on-axis
            !-8888. means centered according to
            !set according to straight line fit of trajectory
            !between XIANF and XIEND
            !-9999. means centered according to
            !ZSTART+VZIN/VXIN*(PINCEN(1)-XSTART)
            !-9000. means estimate position by averaging
            ! z(x)+vz(x)/vx(x)*(x-pincen(1))

      IPBRILL=0 ! observation point inside pinhole for brilliance calculations
            ! =0 center of pinhole
            ! =1 lower left corner
            ! =2 lower right corner
            ! =3 upper right corner
            ! =4 upper left corner
                      ! if no pinhole specified first (IPBRILL=0)
                      ! or observation point IPBRILL is taken

      MPINZ=21  ! number of horizontal grid points, if OBSVDZ is zero,
                ! otherwize calculated from PINW and OBSVDZ
      MPINY=21  ! number of vertical grid points, if OBSVDY is zero,
                ! otherwize calculated from PINH and OBSVDY

       ! for undulator radiation it might be useful to use
       ! cylindrical grid for observation points.
       ! If MPINR is not zero, this option is assumed

      MPINR=0 ! number of radial grid points, if OBSVDR is zero,
            ! otherwize calculated from PINRAD and OBSVDR
            ! if 9999, MPINR is set to max(MPINZ,MPINY)*sqrt(2)


      MPINPHI=16   ! number of azimuthal grid points, if OBSVDPHI is zero

      MEDGEZ=1 ! outer edge outside of pinhole to avoid edge effects
      MEDGEY=1 ! must be at least 1

      MMEDGEZ=0   ! inner edge outside of pinhole to avoid edge effects
      MMEDGEY=0   ! may be 0

      OBSVDZ=0.   ! horizontal mesh width in pinhole
                  ! (is calculated from PINW and MPINZ if zero)
      OBSVDY=0.   ! vertical mesh width in pinhole
                  ! (is calculated from PINH and MPINY if zero)

      PINW=0.003   ! width of pinhole [m]
                   ! 9999. means automatic calculation if flag
                   ! IUNDULATOR is not zero
      PINWSC=1.    ! to scale PINW

      PINH=0.003   ! height of pinhole [m]
                   ! 9999. means automatic calculation if flag
                   ! IUNDULATOR is not zero
      PINHSC=1.    ! to scale PINH

      PINR=-9999.  ! radius of circular pinhole [m]
                   ! if PINR=-9999., PINR is set to max(PINW/2.,PINH/2.)
                   ! if PINR=9999., PINR is set to sqrt(PINW*PINH/PI)

      PINRAD=9999. ! radius of circular pinhole for routine SOUINTRPHI [m]
                   ! triggered by MPINR.NE.0
                   ! if 0., PINRAD is set to PINR
                   ! if 9999., PINRAD is set to
                   ! sqrt(obsvy(nobsv)**2+obsvz(nobsv)**2)

      OBSVDR=0.   ! radial mesh width in pinhole
                  ! (is calculated from PINRAD and MPINR if zero)
                  ! OBSVDR=9999. means OBSVDR=min(OBSVDZ,OBSVDY)

      OBSVDPHI=0. ! angle steps [degree]
                  ! (is calculated from MPINR if zero)

        IQUADPHI=0   ! if not zero, phi is limited to 90 degree, i.e.
                     ! first quadrant of pinhole, and 4-fold symmetry is
                     ! assumed

      IRFILOB=0   ! =1 to read list of observation points
                  ! from file FILEOB (IPIN must not be set)

      OBS1X=-9999. ! x-coordinate of single observation point [m]
                   ! -9999. means value from PINCEN(1)
      OBS1Y=0.0    ! y-coordinate of single observation point [m]
                   ! if IPIN and IRFILOB are not set
            !-9999. means centered according to
            !YSTART+VYIN/VXIN*(PINCEN(1)-XSTART)
            !-8888. means centered according to
            !set according to straight line fit of trajectory
            !between XIANF and XIEND
            !-9000. means estimate position by averaging
            ! y(x)+vy(x)/vx(x)*(x-pincen(1))
      OBS1Z=0.0    ! z-coordinate of single observation point [m]
                   !-9999. means centered according to
            !ZSTART+VZIN/VXIN*(PINCEN(1)-XSTART)
            !-8888. means centered according to
            !set according to straight line fit of trajectory
            !between XIANF and XIEND
            !-9000. means estimate position by averaging
            ! z(x)+vz(x)/vx(x)*(x-pincen(1))

    $END

 $FREQN     !photon energies in eV for spectrum calcualtions

      FREQLOW=105. !lowest photon energy for spectrum calculations
            ! -9999. means automatic calculation if flag
            ! IUNDULATOR is not zero (estimation might fail,
            ! if mag. field is not strictly periodic)

      FREQHIG=117. !highest photon energy for spectrum calculations
            ! -9999. means automatic calculation if flag
            ! IUNDULATOR is not zero (estimation might fail,
            ! if mag. field is not strictly periodic)
            ! for IFREQ2P=1, FREQHIG-FREQLOW is the bin size of
            ! the spectrum histograms

      NINTFREQ=13  !number of photon energies for IFREQ2P>2 (namelist CONTRL)

      FRSCALE=1.   !scaling factor for window [FREQLOW,FREQHIG]
                   !i.e. center and width are scaled to get higher
                   !harmonics
                   !<0: FREQLOW, FREQHIG, and NINTFREQ are scaled

      IFILTER=0    !absorbing filter is applied to spectrum
                   !absorption coefficients on file FILEABS
                   !IFILTER = 1: F(X)=AA*X**BB interpolation of coef.
                   !IFILTER > 1: linear interpolation of coef.
                   !IFILTER < 0 means files of list FILEAM are merged
                   !IFILTER = -1: F(X)=AA*X**BB interpolation of coef.
                   !IFILTER < -1: linear interpolation of coef.
                   !by SR ABSCOEF_MERGE and written to file FILEAMO

      IFILMUL=0    !IFILMUL = N:  N absorbing filters are applied to
                   !spectrum. Filter thicknesses and filenames
                   !of coefficient files are read from FILEAM

      IEFFI=0      !detector efficiency filter is applied to spectrum
                   !factors are read from file FILEFF
                   !IEFFI > 0: spline interpolation of yield function
                   !IEFFI = -1: F(X)=AA*X**BB interpolation
                   !IEFFI < -1: linear interpolation

      IHFIL=0     !Ntuples of absorption coefficients

      SPECCUT=0.  !if the photon energy exceeds SPECCUT times the critical
                  !energy belonging to the maximal field strength of the
                  !source point, the flux is set to zero in SR SOUADD
                  !SPECCUT=0. means option is ignored.

      ABSTHI=0.002   !thickness of absorber [m]
      AREAM2=628.D-6 !area of probe [m**2] for program DESYNC (flag IDESYNC)

      $END

 $WBTABN    ! to write magnetic field By and some integrals
            ! along straight line parallel to the x-axis
            ! of the device or along trajectory to file FILEWBT
            !
            ! File format FILEWBT:
            ! 1. line: Run number and CODE
            ! 2. line: Scaling factors vor X and BY
            ! 3. line: Number of following data lines
            ! Data lines: x By y z 1.Int(By) 2.Int(By) Int(
            !   1. Col.: x
            !   2. Col.: By
            !   3. Col.: y
            !   4. Col.: z
            !   5. Col.: first integral of By, i.e. Int(By,dx)
            !   6. Col.: second integral of By,
            !            i.e Int(Int(By,dx),dx)
            !   7. Col.: Int(dBy/dz,dx)
            !   8. Col.: Int(d2By/dz**2,dx)
            !   9. Col.: Int(d2Bz/dz**2,dx)
            !  10. Col.: Int(d2By/dy**2,dx)
            !  11. Col.: Int(d2Bz/dy**2,dx)
            !  12. Col.: Int(Int(d2By/dz**2,dx),dx)
            !  13. Col.: Int(Int(d2Bz/dz**2,dx),dx)
            !  14. Col.: Int(Int(d2By/dy**2,dx),dx)
            !  15. Col.: Int(Int(d2Bz/dy**2,dx),dx)
            !  16. Col.: Int(Ay,dx)
            !  17. Col.: Int(Az,dx)

            ! File format wbtab_sextupole.dat:
            ! 1. line: Run number and CODE
            ! 2. line: Number of data
            ! Data lines:
            !   1. Col.: x
            !   2. Col.: By
            !   3. Col.: y
            !   4. Col.: z
            !   5. Col.: d2By/dy**2
            !   6. Col.: d2By/dz**2
            !   7. Col.: d2Bz/dy**2
            !   8. Col.: d2Bz/dz**2

      BTABS=9999. ! x of first point (9999. means XSTART)
      BTABE=9999. ! x of last point (9999. MEANS XSTOP)
      BTABY=0.0   ! y of first point
      BTABZ=0.0   ! z of first point

      NPWBTAB=9999   ! number of points
                     ! (the trajectory is recalculated with this number)
                     ! 9999 means number of points of main  trajectory taken

      BTABEPS=0.1E-3 ! epsilon for numerical differentiations
      $END

 $RECN

      BCRAN=0.0 ! sigma of rel. random noise on BC(IMAG)
                ! BCRAN.lt.0 means 1.+BCRAN is scaling factor without
                ! random noise (see also NURANMOD)

      BCRANSIG=1000.0 ! allowed max. for BCRAN (in multiple of rms-value)
                      ! if generated error exceeds BCRANSIG*BCRAN it's
                      ! generated once again

      IRECSEED=1  !seed for generation of random errors
                  ! *** obsolete, see, $RANDOMN ***

      K90270=0  ! K90270.ne.0 means BCRAN acts only on theta=90,270
                ! (only for NURANMOD.EQ.0)

      BCSTART=9999.   ! begin of random error region (9999. means no limit)
                      ! [mm]

      BCEND=9999. ! end of random error region (9999. means no limit)
                  ! [mm]

      WINREC=1.0  ! Window for calculation of magnetic field
                  ! of REC-structure (SR REC_BFELD) [m]

      RANGREC=1.0 ! Tracking starts and stops at distance RANGREC
                  ! from beginning and end of structure [m]
                  ! (only if XSTART, XSTOP = 9999.)

      SCALADD=0.  ! to scale strength of additional magnets on FILEREC
      SCALKL=0.   ! to scale strength of all but additional magnets

      IPLREC=1    ! write plotfile rec_plotm.eps

      RPLXMN=9999.   ! plotting range [mm]
      RPLXMX=9999.   ! 9999. means defaults used,
      !RPLXMN=-100.  ! plotting range [mm]
      !RPLXMX=100.   ! 9999. means defaults used,
      !RPLXMN=-2100. ! plotting range [mm]
      !RPLXMX=-2020. ! 9999. means defaults used,
      RPLYMN=9999.   ! minima and maxima
      RPLYMX=9999.   ! (or XSTART, XSTOP if -9999. in x)
      RPLZMN=9999.
      RPLZMX=9999.

      RECGAP=7.5  ! half gap [mm]
      USHIFT= 0.0 ! shift parameter [mm]

      DSHIFT=0.0  ! additional row shift [mm]

      IRECMODU=0  ! call to special modulator routine

      IHTAPER=0   ! to apply horizontal taper function to pos. of mags.
                  ! function is given as two columns table in file
                  ! FILEFTH
                  ! Format:
                  ! 1. comment
                  ! 2. x-scale-factor, y-scaling-factor
                  ! 3. data lines

      IVTAPER=0 ! to apply vertical taper function to pos. of mags.
                ! function is given as two columns table in file
                ! FILEFTV
                ! Format:
                ! 1. comment
                ! 2. x-scale-factor, y-scaling-factor
                ! 3. data lines

      IRECU=0   ! IRECU is number of additional simple undulator

      NURANMOD=1  ! modus for field error generation:
                  ! 0: BCRAN is applied as explained above, no special
                  !    treatment of additional undulators
                  ! 1: BCRAN is applied for additional undulators
                  !    in a -B/2,+B,-B/2 scheme
                  ! 2: BCRAN is applied for additional undulators
                  !    in a +B,-B scheme
                  ! 3: BCRAN is applied for additional undulators,
                  !    for each pole errors are generated,
                  !    kick is compensated by endpoles
                  !    (planar devices only, so far)
                  ! 4: same as 3, but in addition offset is
                  !    compensated by first endpole

      KRECPER(1)=30   ! number of periods

      URECLX(1)=14.   ! length of magnets [mm]
      URECLY(1)=40.   ! height of magnets [mm]
      URECLZ(1)=40.   ! width of magnets [mm]
      URECGAP(1)=11.6 ! half gap of undulator [mm]
      UTAPER(1)=0.    ! taper (dy/dx of half gap)
      URECCX(1)=0.    ! center in x of undulator [mm]
      URECCZ(1)=0.    ! center in z of undulator [mm]
      URECBC(1)=1.22  ! remanence of magnets [T]
      UBANGERR(1)=0.0 ! angle error of magnets [degree]
      UBANSIG(1)=1000.0  ! allowed max. for UBANGERR (in multiple of rms-value)
                         ! if generated error exceeds UBANSIG*UBANGERR it's
                         ! generated once again
      USIGOFFY(1)=0.0 ! allowed offset for accumulated errors
                      ! if the sum of the accumulated Gaussian random numbers
                      ! exceeds UBANGERR, the center of the Gaussian errors
                      ! will be shifted such that the trajectory comes back
                      ! to the orbit plane.
                      ! Set to 1.e30 if zero

      IUHELI(1)=1     ! helical undulator
                      ! positive value means S3 mode
                      ! negative value means S2 mode
      URSPLIT(1)=0.8  ! horizontal distance of rows for helical undulator [mm]
      URSHIFT(1)=10.  ! rowshift for helical undulator [mm]
                      ! lower-left (+URSHIFT) and upper-right (-URSHIFT)
                      ! rows are shifted
      URSHADD(1)=0.   ! additional shift for lower rows [mm]

      IKRESTOR=0      ! <0 means magnet strukture is stored on
                        ! rec.store
                        ! >0 means magnet strukture is read form
                        ! rec.restore
                        ! The file format looks like:
                        ! First line: Run number and comment of the
                        ! writing WAVE run
                        ! Second line: Number of blocks
                        ! Then follow three lines for each block:
                        !   1: dimensions in x,y,z in mm
                        !   2: the polar and azimuthal angles of the mag. axis
                        !   with respect to the vertical and the remanence
                        !   3: position x,y,z
    $END

 $MODUN

      SCALMOD=1.      ! scaling factor for modulator field
      SCALRAD=1.      ! scaling factor for radii of magnets
      SCALTHE=1.      ! scaling factor for theta of magnets

      NMAGMOD=16  ! number of modulator magnets
      NSLICE=51   ! number of slices per magnet

      RADIMOD(1) =6.3   ! radius of magnet [mm]
      RADIMOD(2) =6.3   ! radius of magnet [mm]
      RADIMOD(3) =6.3   ! radius of magnet [mm]
      RADIMOD(4) =6.3   ! radius of magnet [mm]
      RADIMOD(5) =11.   ! radius of magnet [mm]
      RADIMOD(6) =11.   ! radius of magnet [mm]
      RADIMOD(7) =11.   ! radius of magnet [mm]
      RADIMOD(8) =11.   ! radius of magnet [mm]
      RADIMOD(9) =11.   ! radius of magnet [mm]
      RADIMOD(10)=11.   ! radius of magnet [mm]
      RADIMOD(11)=11.   ! radius of magnet [mm]
      RADIMOD(12)=11.   ! radius of magnet [mm]
      RADIMOD(13)=6.3   ! radius of magnet [mm]
      RADIMOD(14)=6.3   ! radius of magnet [mm]
      RADIMOD(15)=6.3   ! radius of magnet [mm]
      RADIMOD(16)=6.3   ! radius of magnet [mm]

      ZLENMOD(1)=90. ! length in z of magnet [mm]
      ZLENMOD(2)=90. ! length in z of magnet [mm]
      ZLENMOD(3)=90. ! length in z of magnet [mm]
      ZLENMOD(4)=90. ! length in z of magnet [mm]
      ZLENMOD(5)=90. ! length in z of magnet [mm]
      ZLENMOD(6)=90. ! length in z of magnet [mm]
      ZLENMOD(7)=90. ! length in z of magnet [mm]
      ZLENMOD(8)=90. ! length in z of magnet [mm]
      ZLENMOD(9)=90. ! length in z of magnet [mm]
      ZLENMOD(10)=90.   ! length in z of magnet [mm]
      ZLENMOD(11)=90.   ! length in z of magnet [mm]
      ZLENMOD(12)=90.   ! length in z of magnet [mm]
      ZLENMOD(13)=90.   ! length in z of magnet [mm]
      ZLENMOD(14)=90.   ! length in z of magnet [mm]
      ZLENMOD(15)=90.   ! length in z of magnet [mm]
      ZLENMOD(16)=90.   ! length in z of magnet [mm]

      CENMODX(1) =-2086.   ! x of magnet center [mm]
      CENMODY(1) =+30.00       ! y of magnet center [mm]
      CENMODX(2) =-2086.   ! x of magnet center [mm]
      CENMODY(2) =-30.00       ! y of magnet center [mm]
      CENMODX(3) =-2046.   ! x of magnet center [mm]
      CENMODY(3) =+30.00       ! y of magnet center [mm]
      CENMODX(4) =-2046.   ! x of magnet center [mm]
      CENMODY(4) =-30.00       ! y of magnet center [mm]

      CENMODX(5) =-90.   ! x of magnet center [mm]
      CENMODY(5) =+30.00       ! y of magnet center [mm]
      CENMODX(6) =-90.   ! x of magnet center [mm]
      CENMODY(6) =-30.00       ! y of magnet center [mm]
      CENMODX(7) =-30.0   ! x of magnet center [mm]
      CENMODY(7) =+30.00       ! y of magnet center [mm]
      CENMODX(8) =-30.0   ! x of magnet center [mm]
      CENMODY(8) =-30.00       ! y of magnet center [mm]
      CENMODX(9) =30.0   ! x of magnet center [mm]
      CENMODY(9) =+30.00       ! y of magnet center [mm]
      CENMODX(10) =30.0   ! x of magnet center [mm]
      CENMODY(10) =-30.00      ! y of magnet center [mm]
      CENMODX(11) =+90.   ! x of magnet center [mm]
      CENMODY(11) =+30.00      ! y of magnet center [mm]
      CENMODX(12)=+90.   ! x of magnet center [mm]
      CENMODY(12)=-30.00       ! y of magnet center [mm]

      CENMODX(13) =2046.   ! x of magnet center [mm]
      CENMODY(13) =+30.00      ! y of magnet center [mm]
      CENMODX(14) =2046.   ! x of magnet center [mm]
      CENMODY(14) =-30.00      ! y of magnet center [mm]
      CENMODX(15) =2086.   ! x of magnet center [mm]
      CENMODY(15) =+30.00      ! y of magnet center [mm]
      CENMODX(16) =2086.   ! x of magnet center [mm]
      CENMODY(16) =-30.00      ! y of magnet center [mm]

      THEROT(1) =90.     ! rotation angle of magnet [degree]
      THEROT(2) =-90.       ! rotation angle of magnet [degree]
      THEROT(3) =-90.       ! rotation angle of magnet [degree]
      THEROT(4) =90.     ! rotation angle of magnet [degree]

        THEROT(5) =-90.00     ! rotation angle of magnet [degree]
      THEROT(6) =90.00      ! rotation angle of magnet [degree]
      THEROT(7) =90.00      ! rotation angle of magnet [degree]
      THEROT(8) =-90.00     ! rotation angle of magnet [degree]
      THEROT(9) =-90.00     ! rotation angle of magnet [degree]
      THEROT(10)=90.00      ! rotation angle of magnet [degree]
      THEROT(11)=90.00      ! rotation angle of magnet [degree]
      THEROT(12)=-90.00     ! rotation angle of magnet [degree]

      THEROT(13) =90.       ! rotation angle of magnet [degree]
      THEROT(14) =-90.      ! rotation angle of magnet [degree]
      THEROT(15) =-90.      ! rotation angle of magnet [degree]
      THEROT(16) =90.       ! rotation angle of magnet [degree]

      BCMOD(1) =1.22877642516581265e+00       ! strength of magnet [T]
      BCMOD(2) =1.22877642516581265e+00       ! strength of magnet [T]
      BCMOD(3) =1.22877642516581265e+00       ! strength of magnet [T]
      BCMOD(4) =1.22877642516581265e+00       ! strength of magnet [T]

      BCMOD(5) =1.22877642516581265e+00       ! strength of magnet [T]
      BCMOD(6) =1.22877642516581265e+00       ! strength of magnet [T]
      BCMOD(7) =1.22877642516581265e+00       ! strength of magnet [T]
      BCMOD(8) =1.22877642516581265e+00       ! strength of magnet [T]
      BCMOD(9) =1.22877642516581265e+00       ! strength of magnet [T]
      BCMOD(10)=1.22877642516581265e+00       ! strength of magnet [T]
      BCMOD(11)=1.22877642516581265e+00       ! strength of magnet [T]
      BCMOD(12)=1.22877642516581265e+00       ! strength of magnet [T]

      BCMOD(13)=1.22877642516581265e+00       ! strength of magnet [T]
      BCMOD(14)=1.22877642516581265e+00       ! strength of magnet [T]
      BCMOD(15)=1.22877642516581265e+00       ! strength of magnet [T]
      BCMOD(16)=1.22877642516581265e+00       ! strength of magnet [T]

      $END

 $UNDUHYBRIDN

    ! *** Please, also check variables in undumag.nam ***

    UNDUGAP_H=10.  ! full gap of undulator [mm]
    NPERIOD_H=4    ! number of periods
    NPERIODW_H=0   ! number of periods for WAVE,
                   ! i.e. if NPERIODW_H > NPERIOD_H, field is expanded

    UPERLEN_H=0.0    ! Period-length, calculated if <= 0  [mm]
    UMAGLX_H=13.9    ! length of main magnets [mm]
                     ! WILL BE OVERWRITTEN INF UPERLEN_H > 0
    UMAGLY_H=40.     ! height of main magnets [mm]
    UMAGLZ_H=40.     ! width of main magnets [mm]
    UMAGSPAC_H=0.1   ! spacer to next downstream pole [mm]
    UMAGCH_H=0.3     ! chamfer [mm]
    UCOATING_H=0.014 ! coating and dead layer of magnets

    UMAGBC_H=1.62   ! remanence of magnets [T]
    UMUPAR_H=1.03   ! mu parallel for linear REC material
    UKSIPER_H=0.17  ! ksi perpendicular for linear REC material

    NUMDIVX_H=3 ! number of divisions of magnets in X
    NUMDIVY_H=3 ! number of divisions of magnets in Y
    NUMDIVZ_H=3 ! number of divisions of magnets in Z, consider z-symmetry

    UPOLLX_H=6.9   ! length of main poles [mm]
    UPOLLY_H=35.   ! height of main poles [mm]
    UPOLLZ_H=30.   ! width of main poles [mm]
    UPOLCH_H=0.1   ! chamfer [mm]
    UPOLSPAC_H=0.1 ! spacer to next downstream magnet [mm]

    NUPDIVX_H=6 ! number of divisions of poles in X, consider x-symmetry
    NUPDIVY_H=5 ! number of divisions of poles in Y
    NUPDIVZ_H=12 ! number of divisions of poles in Z, consider z-symmetry

    FRACDIVFE_H=2.  ! factor for exponential vertical segmentation of poles
    FRACDIVFEZ_H=2. ! factor for exponential horizontal segmentation of poles

    IXSYM_H=1 ! x-symmetry
    IYSYM_H=1 ! y-symmetry
    IZSYM_H=1 ! z-symmetry

    ! List of special, non-periodic magnets and poles
    ! the easy axis of magnets is parallel or antiparallel
    ! to the x-axis, according to the sign of the material index

    NSPEC_H=1     ! number of special items

    USMAGLX_H(1)=13.9  ! length [mm]
    USMAGLY_H(1)=5.865898402796422   ! height [mm]
    USMAGLZ_H(1)=40.   ! width [mm]
    USMAGCH_H(1)=0.3   ! chamfer [mm]
    MSMAG_H(1)=1       ! material index (sign controls easy axis for magnets)
    USMAGSPAC_H(1)=0.1 ! spacer from to previous item  [mm]
    USMAGDY_H(1)=0.0   ! vertical offset [mm]

    USMAGLX_H(2)=6.9   ! length [mm]
    USMAGLY_H(2)=35.   ! height [mm]
    USMAGLZ_H(2)=30.   ! width [mm]
    USMAGCH_H(2)=0.1   ! chamfer [mm]
    MSMAG_H(2)=2       ! material index (sign controls easy axis for magnets)
    USMAGSPAC_H(2)=0.1 ! spacer to previous item  [mm]
    USMAGDY_H(2)=0.    ! vertical offset [mm]

    KXSTART_H=-1 ! 1: Use XELEC of UNDUMAG for XSTART (if XSTART =9999.)
                 !-1: Use xMapMin of UNDUMAG for XSTART (if XSTART =9999.)
    KXSTOP_H=-1  ! 1: Use XF of UNDUMAG for XSTOP (if XSTOP =9999.)
                 !-1: Use xMapMax of UNDUMAG for XSTART (if XSTART =9999.)

    UCORRTINY_H=0.001 ! x,y,z-shift for corrections of boundary errors [mm]

    URANDOX_H=0.0005  ! smear x for field calculations [mm]
    URANDOY_H=0.0     ! smear y for field calculations [mm]
    URANDOZ_H=0.0005  ! smear z for field calculations [mm]

    UWWINDOW_H=1000.  ! Only items with x-uwwindow <= x <= x+uwwindow contribute
                    ! to field at x [mm]

    ! The following files are expected in $WAVE/undumag

    CHUNDUMAG_H='undumag.exe'     ! Executable of UNDUMAG
    CHUNDUNAM_H='undumag_nam.tmp' ! template for namlist file undumag.nam
    CHUNDUIRON_H='Vanadium_Permendur_Radia.dat' ! Magnetization curve of iron

    ! Field map, check also IWBMAP and namelist BMAPN

    ! NOTE: XMAPMINU and XMAPMAXU can overwrite XSTART/XSTOP, see. KSTART below
    XMAPMINU_H=9999. ! xmin for field map [mm]
                   ! 9999.: Auto scaling
    XMAPMAXU_H=9999. ! xmax for field map [mm]
                   ! 9999.: Auto scaling
    DXMAPU_H=1.      ! Step size of field map in x [mm]
                   ! 9999.: Same as for Beff calculations, i.e. perlen/(nxbeff-1)
    NXMAPU_H=0       ! Number of steps in x, if dxmap is zero

    YMAPMINU_H=-3.0  ! ymin for field map [mm]
    YMAPMAXU_H= 3.0  ! ymax for field map [mm]
    NYMAPU_H=1       ! Number of steps for field map in y.
                   ! nymapu_H=1 means y=(ymapmax+ymapmin)/2 is used

    ZMAPMINU_H=-20.0 ! zmin for field map [mm]
    ZMAPMAXU_H= 20.0 ! zmax for field map [mm]
    NZMAPU_H=1       ! Number of steps for field map in z
                     ! nzmapu=1 means z=(zmapmax+zmapmin)/2 is used

    $END

 $UNDUMAGN

    ! *** Please, also check variables in undumag.nam ***

    NUNDUPER=7     ! number of periods of undulator
    NUNDUPERW=0    ! number of periods for WAVE,
                   ! i.e. if NUNDUPERW > NUNDUPER, field is expanded

    UNDUGAP=10.  ! full gap of undulator [mm]

    US2SHIFT=0. ! S2 shift [mm]
    US3SHIFT=10. ! S3 shift [mm]

    ! Field map, check also IWBMAP and namelist BMAPN

    ! NOTE: XMAPMINU and XMAPMAXU can overwrite XSTART/XSTOP, see. KSTART below
    XMAPMINU=9999. ! xmin for field map [mm]
                   ! 9999.: Auto scaling
    XMAPMAXU=9999. ! xmax for field map [mm]
                   ! 9999.: Auto scaling
    DXMAPU=1.      ! Step size of field map in x [mm]
                   ! 9999.: Same as for Beff calculations, i.e. perlen/(nxbeff-1)
    NXMAPU=0       ! Number of steps in x, if dxmap is zero

    YMAPMINU=-3.0  ! ymin for field map [mm]
    YMAPMAXU= 3.0  ! ymax for field map [mm]
    NYMAPU=1       ! Number of steps for field map in y.
                   ! nymapu=1 means y=(ymapmax+ymapmin)/2 is used

    ZMAPMINU=-20.0 ! zmin for field map [mm]
    ZMAPMAXU= 20.0 ! zmax for field map [mm]
    NZMAPU=1       ! Number of steps for field map in z
                   ! nzmapu=1 means z=(zmapmax+zmapmin)/2 is used

    UMAGLX=14.     ! length of magnets [mm]
    UMAGLY=40.     ! height of magnets [mm]
    UMAGLZ=40.     ! width of magnets [mm]

    UAIRGAP=0.1    ! airgap between magnets [mm]
                   ! period-length = 4 * (UMAGLX+AIRGAP)
    UCOATING=0.014 ! coating and dead layer of magnets

    UMAGBC=1.62    ! remanence of magnets [T]
    UMUPAR=1.03    ! mu parallel for linear REC material
    UKSIPER=0.17   ! ksi perpendicular for linear REC material
    UNDUSPLIT=0.8  ! horizontal distance of rows for helical undulator [mm]

    NUDIVX=1  ! number of divisions of magnets in X
    NUHDIVX=1 ! number of divisions of half magnets in X
    NUDIVY=3  ! number of divisions of magnets in Y
    NUDIVZ=3  ! number of divisions of magnets in Z

    KXSTART=-1 ! 1: Use XELEC of UNDUMAG for XSTART (if XSTART =9999.)
               !-1: Use xMapMin of UNDUMAG for XSTART (if XSTART =9999.)
    KXSTOP=-1  ! 1: Use XELEC of UNDUMAG for XSTOP (if XSTOP =9999.)
               !-1: Use xMapMax of UNDUMAG for XSTART (if XSTART =9999.)

    UCORRTINY=0.001   ! x,y,z-shift for corrections of boundary errors [mm]

    URANDOX=0.00002   ! smear x for field calculations [mm]
    URANDOY=0.0       ! smear y for field calculations [mm]
    URANDOZ=0.00005   ! smear z for field calculations [mm]

    UWWINDOW=1000.   ! Only items with x-uwwindow <= x <= x-uwwindow contribute
                     ! to field at x [mm]

    ! The following files are expected in $WAVE/undumag
    CHUNDUMAG='undumag.exe'     ! Executable of UNDUMAG
    CHUNDUNAM='undumag_nam.tmp' ! template for namlist file undumag.nam

    $END

 $POLYMAGN

       BSCALEPM=1.         ! Scaling factor for mag. field
       WINPM=1.0           ! Window in x for calculation of magnetic field [m]
       RANGPM=0.5          ! Tracking starts and stops at distance RANGPM
                           ! from beginning and end of structure [m]
                           ! (only if XSTART, XSTOP = 9999.)

               ! all sift values are added to those of polymag.in
       SHIFTLL=0.    ! shift of lower-left magnets
       SHIFTLR=0.    ! shift of lower-right magnets
       SHIFTUL=0.    ! shift of upper-left magnets
       SHIFTUR=0.    ! shift of upper-right magnets

       GAPPM=20.     ! full gap [mm]; value is added to y-pos. of magnets

       FILEPM='polymag.in' ! input file for POLYMAG routines

       IBPNOWARN=0         ! to suppress annoying warnings
 $END

 $BMAPN

   IBMAPX=1      ! x-component
                 ! 1 means written
          ! 0 means not written i.e. set to -9999.
   IBMAPY=1      ! y-component
   IBMAPZ=1      ! z-component

   IBMRADIAL=0
                 ! X is taken as radial coordinate [m]
          ! Y is taken as azimuth angle [degree]
          ! IBMRADIAL=2:
          ! Z is taken as radial coordinate [m]
          ! Y is taken as azimuth angle [degree]

   BMRADX0=0.0   ! X/Z center of radial map
   BMRADY0=0.0   ! Y center of radial map

   XMAPMN=9999.  ! xmin of map (9999. means XSTART taken)
   XMAPMX=9999.  ! xmax of map (9999. means XSTOP taken)
   NMAPX=-9999   ! number of data points in x
                 ! -9999 means: NMAXP=(XSTOP-XSTART)*MYINUM
                         !
   YMAPMN=-0.007 ! ymin of map
   YMAPMX=+0.007 ! ymax of map
   NMAPY=3       ! number of data points in y
                         !
   ZMAPMN=-0.03  ! zmin of map
   ZMAPMX=+0.03  ! zmax of map
   NMAPZ=31      ! number of data points in z

   IWBMAPEXT=0   ! to extend fitted field map for IWBMAP = 4

   $END

 $BAMWLSN

        MBAMWLS=0       ! mode:
                        ! 0: field map
                        ! 1: btab

        CORRMS=1.       ! scaling for side poles
        CORRMM=1.       ! scaling for main pole

        CURRL=97.6585   ! current of upstream corrector [A]
        CURRR=13.22435  ! current of downstream corrector [A]

        CORRL=1.0      ! field correction factor of upstream corrector [A]
        CORRR=1.03264  ! field correction factor of downstream corrector [A]

        XCORRL=-1.035  ! X-position of upstream steerer [m]
        XCORRR=1.735   ! X-position of downstream steerer [m]

        XLCORRL=0.0     ! transversal fundamental length [m]
        XLCORRR=0.0     ! transversal fundamental length [m]

        $END

 $BPOLY3DN

           X3DMIN=-0.02 ! Xmin of fitted region (9999. lowest x taken)
           X3DMAX=0.02  ! Xmax of fitted region (9999. largest x taken)
           Y3DMIN=-0.007 ! Ymin of fitted region (9999. lowest y taken)
           Y3DMAX=0.007 ! Ymax of fitted region (9999. largest y taken)
           Z3DMIN=0.02 ! Zmin of fitted region (9999. lowest z taken)
           Z3DMAX=0.03 ! Zmax of fitted region (9999. largest z taken)

           XYZ3DSC=100.D0 ! scaling factor for x,y, and z

           LORD3D=1     ! lowest used order of polynomial potential
           MORD3D=10     ! highest used order of polynomial potential
           NDORD3D=1    ! step of used orders of polynomial potential

           IHBPOLY3D=0  ! Ntuple of fitted field or field map of SR WBMAP

           $END

 $BPOLY2DHN

           NORD2DH=13    !harmonical order of fit

         PERLEN2DH=0.212 !period length [m]
         PHASE2DH=0.25  !long. shift:
             !X is set to X+PERIODLENGTH*X2DHSHIFT for
             !the fitting and field calculations
             !this is done before scaling with XYZ2DH

           X2DHMIN=9999. ! Xmin of fitted region (9999. lowest x taken)
           X2DHMAX=9999. ! Xmax of fitted region (9999. largest x taken)
           Y2DHMIN=9999. ! Ymin of fitted region (9999. lowest y taken)
           Y2DHMAX=9999. ! Ymax of fitted region (9999. largest y taken)
           Z2DHMIN=-0.02 ! Zmin of fitted region (9999. lowest z taken)
           Z2DHMAX=0.02 ! Zmax of fitted region (9999. largest z taken)
             ! this values refere to the unshifted data!!

           XYZ2DH=100.D0  ! scaling factor for x,y, and z

           IHBPOLY2DH=0  !Ntuple of fitted field or field map of SR WBMAP

           $END

 $BPHARMN

         NTRANS0=1   !lowest transversal order of fit
         NTRANS=21   !highest transversal order of fit
         NTRANSD=2   !increment of transversal order of fit

         NHARM0=1 !lowest longitudinal order of fit
         NHARM=21 !highest longitudinal order of fit
         NHARMD=2 !increment of longitudinal order of fit
            !even orders correspond to horizontal sine-like fields??
            ! VS:=-B0S/KXS(N,NXY)*COS(NXY*KYS*Y)
                        !    *SINH(KXS(N,NXY)*X)*SIN(N*KZ*Z)

           PERLENPH=0.212 !period length [m]
           PHASEPH=0.    !long. shift:
                         !X is set to X+PERIODLENGTH*XPHSHIFT for
                         !the fitting and field calculations

           XPHMIN=9999. ! Xmin of fitted region (9999. lowest x taken)
           XPHMAX=9999. ! Xmax of fitted region (9999. largest x taken)
           YPHMIN=9999. ! Ymin of fitted region (9999. lowest y taken)
           YPHMAX=9999. ! Ymax of fitted region (9999. largest y taken)
           ZPHMIN=-0.03 ! Zmin of fitted region (9999. lowest z taken)
           ZPHMAX=0.03 ! Zmax of fitted region (9999. largest z taken)
                         ! this values refere to the unshifted data!!

           XLENCPH=9999.  !Lambda_x of cos-like device [m]
            !x here horizontal coordinate
            !9999. means horizontal fit-range
           YLENSPH=9999.  !Lambda_y of sin-like device [m]
            !9999. means vertical fit-range

           IHBPHARM=0  !Ntuple of fitted field

           $END

 $BGRIDN
+self,if=-mshhbook.
            NTUPGRID=0  ! NTUPGRID greater than zero means read field from
                        ! Ntuple on file FILEB0
                        ! NTUPGRID equal zero otherwise column format is
                        ! assumed for file
                        ! NTUPGRID lower zero creates Ntuple of read map
+self.
            MORD3DG=3   ! polynomial order in potential of fit coefficients
            NBMDATX=4   ! number of data points in x-direction for fit
            NBMDATY=4   ! number of data points in y-direction for fit
            NBMDATZ=4   ! number of data points in z-direction for fit

            $END

 $SPECDIPN !(option ISPECDIP)

            NDIP=1      ! number of dipoles (limited to 100)
            BXDIP(1)=0.0   ! field strength of dipoles [T]
            BYDIP(1)=1.3   ! field strength of dipoles [T]
            BZDIP(1)=0.0   ! field strength of dipoles [T]
                           ! *** only the field perpendicular to
               ! (VXDIP,VYDIP,VZDIP) is used
            X0DIP(1)=0.0   ! x-position of source i.e. tangent point [m]
            Y0DIP(1)=0.0   ! Y-position of source [m]
            Z0DIP(1)=0.0   ! Z-position of source [m]
            VXDIP(1)=1.0   ! velocity vector of electron at source (a.u)
            VYDIP(1)=0.0   ! velocity vector of electron at source (a.u)
            VZDIP(1)=0.0   ! velocity vector of electron at source (a.u)

            APERTHICK=0.0  ! thickness of aperture pinhole [m]
            APERHANG=0.0   ! horizontal angle of aperture pinhole [rad]
            APERVANG=0.0   ! vertical angle of aperture pinhole [rad]
                           ! option is only valid for small angles, i.e.
               ! cos(x) approximatly 1

            $END

 $BFORCN

      BFCENX=0.0  !x-position of volume center
      BFCENY=0.0  !y-position of volume center
      BFCENZ=0.0  !z-position of volume center

      BFLENX=1.   !Length of volume [m]
      BFLENY=1.   !height of volume [m]
      BFLENZ=1.   !width of volume

      TORQCENX=0.0 !x-position of reference point for torques
      TORQCENY=0.0 !y-position of reference point for torques
      TORQCENZ=0.0 !z-position of reference point for torques

      NBFORCX=1   !number of longitudinal intervalls
      NBFORCY=1   !number of vertical intervalls
      NBFORCZ=1   !number of intervalls in z

      $END

 $PHASEN

        PHCENX=0.0      !x of source plan center
        PHCENY=0.0      !y of source plan center
                        !-9999: PHCENY=YSTART+VYIN/VXIN*(PHCENX-XSTART)
        PHCENZ=0.0      !z of source plan center
                        !-9999: PHCENZ=ZSTART+VZIN/VXIN*(PHCENX-XSTART)

        PHWID=-9999.    !full width of source plan
                        !-9999.: Estimated from device length and photon energy
        PHHIG=-9999.    !full heigth of source plan
                        !-9999.: Estimated from device length and photon energy

                        !The fields calculated for the NPHASEZ x NPHASEY
                        !points. The other points given be MPHASEZ, MPHASEY
                        !serve as edge for the folding procedure

        NPHASEZ=51      !number of horizontal mesh points
        NPHASEY=51      !number of vertical mesh points
        MPHASEZ=-9999   !total number of horizontal mesh points
                        !-9999: MPHASEZ according to dgsigz(1) and the
                        ! sigma of the Gaussian
        MPHASEY=-9999   !total number of vertical mesh points
                        !-9999: MPHASEY according to dgsigy(1) and the
                        ! sigma of the Gaussian

        IPHFOLD=1       !Folding of flux-density distribution according
                        !to beta functions PHBETH and PBETV, and the
                        !emittances EPS0H and ESP0V of namelist DEPOLA
                        !>0: use util_function_fold_gauss(...)
                        !<0: use util_function_fold_gauss_lin(...)
        PHBETH=-9999.   !Hori. beta-function at PHCENX
                        ! -9999.: Calculate via option IEMIT=1
        PHBETV=-9999.   !vert. beta-function at PHCENX
                        ! -9999.: Calculate via option IEMIT=1

        PHAPERZM=-1.   !neg. hor. phasespace cut (geom. optic)
        PHAPERZP=+1.   !pos. hor. phasespace cut (geom. optic)
        PHAPERZPM=-1.  !neg. hor. slope phasespace cut (geom. optic)
        PHAPERZPP=+1.  !pos. hor. slope phasespace cut (geom. optic)
        PHAPERYM=-1.   !neg. vert. phasespace cut (geom. optic)
        PHAPERYP=+1.   !pos. vert. phasespace cut (geom. optic)
        PHAPERYPM=-1.  !neg. vert. slope phasespace cut (geom. optic)
        PHAPERYPP=+1.  !pos. vert. slope phasespace cut (geom. optic)

        NPHELEM=0      !number of optical elements in beamline
                       ! phase space cuts PHAPER... are applied first
                       ! PHELEM(1:4,1:4,n) is matrix of optical
                       ! element n
                       ! PHELEM(5,1:4,n) is phase space aperture of
                       ! optical element n
        PHELEM(1,1,1)=1.
        PHELEM(2,2,1)=1.
        PHELEM(3,3,1)=1.
        PHELEM(4,4,1)=1.
        PHELEM(5,1,1)=1.   !low aperture in z
        PHELEM(5,2,1)=1.   !high aperture in z
        PHELEM(5,3,1)=1.   !low aperture in y
        PHELEM(5,4,1)=1.   !high aperture in y

        IHSEL=0     !to get histograms of integrated phasespace

      $END

 $PHASEREPN

      NOEMITPH=0       ! Emittance is ignored
      NOESPREADPH=0    ! E-spread is ignored

      PHRPERL=9999.0d0  ! period-length  [m]
                       ! 9999: Value of namelist ELLIPN is taken
      PHRB0H=9999.0d0   ! horizontal field amplitude [T]
                       ! 9999: Value of namelist ELLIPN is taken
      PHRB0V=9999.0d0   ! vertical field amplitude [T]
                       ! 9999: Value of namelist ELLIPN is taken
      PHRSHIFT=9999.0D0 ! Shift for elliptical undulator (fraction of the period-length)
                       ! 9999: Value of namelist ELLIPN is taken
+self,if=phdx.
                    ! [PHDX,PHDY,PHDZ] will be normalized to one
      PHDX=9999.0D0 ! x of normal vector for spacing of periods
                    ! 9999.: phdx=vx at entrance of amprep or amprep_omp
      PHDY=9999.0D0 ! y of normal vector for spacing of periods
                    ! 9999.: phdy=vy at entrance of amprep or amprep_omp
      PHDZ=9999.0D0 ! z of normal vector for spacing of periods
                    ! 9999.: phdz=vz at entrance of amprep or amprep_omp
+self.
      PHRXBETA=-9999.   ! X where the beta-function are given
                        ! 9999.: XSTART
                        ! -9999: XBETFUN of namelist DEPOLA
      PHRBETAH=-9999.   ! Hori. beta-function [m]
                        ! 9999: BETAH of namelist DEPOLA
                        ! -9999: Calcuted from sigmas of namelist WFOLDN
      PHRALPHAH=-9999.  ! Hori. alpha [m]
                        ! 9999: from BETAPH of namelist DEPOLA
                        ! -9999: 0.0
      PHRBETAV=-9999.   ! Vert. beta-function [m]
                        ! 9999: BETAV of namelist DEPOLA
                        ! -9999: Calcuted from sigmas of namelist WFOLDN
      PHRALPHAV=-9999.  ! Vert. alpha [m]
                        ! 9999: from BETAPV of namelist DEPOLA
      PHRDISPH=-9999.   ! Hori. dispersion [m]
                        ! 9999: DISP0 of namelist DEPOLA
                        ! -9999: 0.0
      PHRDISPPH=-9999.  ! Hori. alpha [m]
                        ! 9999: DDISP0 of namelist DEPOLA
                        ! -9999: 0.0
      PHRDISPV=0.0      ! Vert. dispersion [m]
      PHRDISPPV=0.0     ! Vert. alpha [m]

      PHREMITH=-9999.   ! Hori. emittance [m]
                        ! 9999: BETAH of namelist DEPOLA
                        ! -9999: Calcuted from sigmas of namelist WFOLDN

      PHREMITV=-9999.   ! Vert. emittance [m]
                        ! 9999: BETAH of namelist DEPOLA
                        ! -9999: Calcuted from sigmas of namelist WFOLDN

      PHRESPREAD=-9999. ! Rel. energy-spread
                        ! -9999: Taken from namelist DEPOLA
                        ! -9999: Taken from namelist WFOLDN

      PHRBUNLEN=0.0     ! Rel. energy-spread
                        !  9999: Taken from namelist AMPLIN
                        ! -9999: Taken from namelist BUNCHN

      MODEPH=0          ! Mode of phase error
                        ! 0: PHRERROR is RMS of phase error
                 ! 1: PHRERROR applies to K-parameter
                 ! 2: PHRERROR applies to K-parameter by -B +B +B -B scheme

      PHRERROR=0.0D0    ! RMS of phase error of first harmonic [deg.]

      $END

 $AMPLIN

      IAMPSKIP=0  ! if not zero, spectrum calculation is skipped and
                  ! SR ADDAMPLI is called immediately

      IAMPTERM=0  ! if not zero program terminates after call
                  ! to SR ADDAMPLI

      IAMPCOMP=3  !component of field to adjust phase

      IMAMPLI=1   ! mode flag
                  !  1:   write amplitude array REAIMA to new file
                  !  2:   append amplitude array REAIMA to file
                  !  3:   same as 1, but in addition
                  !       write amplitude array REAIMA to files
                  !       eyre*.dat, eyim*.dat, ezre*.dat, ezim*.dat, ey2*.dat
                  !       for program PHASE of Johannes Bahrdt
                  !     (one photon energy per file)
                  ! -1:   read amplitude array REAIMA from file,
                  !     fill arrays for spectrum calculations, i.e.
                  !     SPEC, STOKES ...
                  !     sum up all spectra on file applying
                  !     phaseshifts AMPSHIFT
                  !        *** Be careful, if the field was written
                  !       under for IBUNCH.ne.0. The flux-density and the
                  !       field might differ with respect to the
                  !       phase, especially if BUNCHLEN was lower
                  !       then zero, while writing the file
                  ! -3:   same as -1, but in addition
                  !       write amplitude array REAIMA to files for
                  !       program PHASE of Johannes Bahrdt
                  !     (one photon energy per file)

      IAMPSUP=0   ! write resulting field amplitude to file
                  ! FILEAMPLI"_SUPER"

      AMPSHIFT(1)=0. ! From distance AMPSHIFT [m] a phaseshift for the
                     ! amplitude is calculated for each photon energy
                     ! before the amplitude is added to the spectrum.
                     ! The index referes to the spectrum on the file.
                     ! The phaseshift corresponds to the phase advance
                     ! of a photon with respect to an electron in a
                     ! drift space (phi=L/c/2g**2*w). In an undulator
                     ! field the phase advance is given by
                     ! phi=L*(1+K**2/2)/c/2g**2*w

      AMPSCALE(1)=1. ! the scaling factor AMPSCALE is applied to
                     ! amplitude before adding amplitude
                     ! the index referes to the spectrum on the file

      IAMPREP=0   ! number of superpositions of field
                  ! *** no correction for depth of field effects
                  ! (option IAMPLI<0 is recommended instead)

                  ! IAMPREP<0: Superposition is done according to
                  ! longitudinal density of electrons as defined by
                  ! IAMPCOH. In this case, the spectra are normlized to
                  ! AMPBUNCHCHARGE if AMPBUNCHCHARGE not zero

       IAMPCOH=0   ! mode to calculate longitudinale
                   ! distribution of electrons
                   ! the first 10000 phase shifts [nm] are
                   ! written to file wave_bunch.dat
                   !
                   ! 0: Gaussian distribution with sigma=AMPCOHSIG
                   !
                   ! -1: user routine UBUNCH(x,y,z,yp,zp,gamma,dt),
                   !     where x referes to the center of the bunch
                   !
                   ! 2: routine BUNCH(dt,weight) according to Saldin,
                   !    NIM A 539 (2005) 499-526
                   !    with parameters BUNCHP0, BUNCHR56, NBUNCHHARM
                   !    and AMPFREQ
                   !
                   ! 3: read phasespace distribution
                   !    x,y,z,dpx/p,dpy/p,dpz/p,weight from
                   !    file wave_phasespace.dat (LUN=21)
                   !
                   ! 4: density distribution within bunch is read in
                   !    terms of FOURIER-coefficients from file
                   !    fourier-bunch.dat (LUN=21)
                   !
                   !    Format:
                   !    Lines starting with * in first column or empty
                   !    lines are comments
                   !    other lines give coefficients c1...cn for harmonics
                   !    first NAMPBUNCHHARM are used

      IAMPINCOH=0 !    suppress incoherent background
                  !    use with care!!

      AMPCOHSIG=264.e-9 ! sigma of Gaussian [m] for IAMPCOH=0.and.IAMPREP<0

      AMPBUNCHLEN=20.E-9 ! length [m] of the whole bunch
      AMPBUNCHCHARGE=20.E-9 ! charge [C] of the whole bunch
                              ! if zero, normalization is done according
                              ! to number of electron, i.e. -IAMPREP

      AMPBUNCHP0=250.d-6 ![GeV]
      AMPBUNCHR56=30.d-6 !R56 [m]
      NAMPBUNCHHARM=1   !number of harmonics of microbunching (IAMPCOH=2)

      AMPRAN=0.   !rel. rms of gaussian random phaseshift error
                  !(referes to AMPFREQ)

      IAMPSEED=0  ! seed for random numbers [1...900000]
            ! -9999: Current job runnumber is used as seed
            ! *** obsolete, see, $RANDOMN ***

      AMPFREQ=-9999.  ! photonenergy [eV] to which AMPPHI referes
                      !-9999. means is taken from 1. harm. of considered device
                      !*** Be careful: Only correct for one period devices, since
                      !*** it scales with number of periods
                      !0: Is allowed and avoids check of AMPFREQ (useful for
                      !   IAMPSKIP=1),

      AMPR2CORR=-9999. !effective length of repeated section [m]
               !if the repeated is long, e.g. a whole undulator,
               !this is the length of the undulator without the
               !zero field section between repeated undulators.
               !-9999. means full length of repeated section, which
               !       is a good approximation

      AMPPHI(1)=1. !
             !----------------
             !  AMPPHI.GT.0:
             !----------------
             ! phaseshift for superpositions in fractions of 2*pi
             ! *** Attention: AMPPHI corresponds to phase advance
             ! due to the length of the trajectory through the
             ! phase-shifting device.
             ! Hence AMPPHI + 1 is not the same as AMPPHI!!
             !----------------
             !  AMPPHI.LT.0:
             !----------------
             ! AMPPHI is detour of trajectory [m] through phase-shifting
             ! device, i.e. total length of trajectory minus AMPSHIFT

      $END

 $ROIN

      NROI=0      !number of ROI-boundaries for spectrum calculation
            !ROI are regions between the boundaries, i.e.
            !e.g. third ROI is between ROIX(3) and ROIX(4)
            !zero values means: NROI set to 2, roi is whole source,
            !relative precision is set to one
            !negative values means equally spaced ROIs within
            !source, i.e. values of ROIX are ignored
            !IF ROIS ARE USED, THE RANGE  XSTART->XSTOP MUST
            !BE COVERED.
      ROIX(1)=0.  !x-value of ROI-boundary
      ROIP(1)=1.  !relative precision i.e. number of integration steps
            !per unitlength is multiplied with this factor
            !within the ROI
            !zero-value is set to one
      ROIX(2)=0.  !x-value of ROI-boundary
      ROIP(2)=1.  !relative precision i.e. number of integration steps
      ROIX(3)=0.  !x-value of ROI-boundary
      ROIP(3)=1.  !relative precision i.e. number of integration steps
      ROIX(4)=0.  !x-value of ROI-boundary
      ROIP(4)=1.  !relative precision i.e. number of integration steps
      ROIX(5)=0.  !x-value of ROI-boundary
      ROIP(5)=1.  !relative precision i.e. number of integration steps
      ROIX(6)=0.  !x-value of ROI-boundary
      $END

 $BERRORN

        !*** CHECK ERROR FIELD BY PLOTTING TO AVOID CONFUSION

        B0ERROR=0.      ! amplitude of field error

        IBERRSEED=0     ! seed for random numbers [1...900000]
                      ! *** obsolete, see, $RANDOMN ***

        NBERRMOD=0      ! mode of error treatment:
                      !
            ! 0: error applies for three poles with -B/2,+B,-B/2
            ! 1: error applies for two poles with +B,-B
            ! 2: error applies for single pole with +B
            ! 3: error applies for four poles with -B +B +B -B
            ! 10,11,12 or 13: like 0,1,2,3 respectively, but errors
            ! are read from file wave_berror.dat

        XLENERR=0.      ! 2*pi/kx for global horizontal gradient [m]
                      ! XLERROR=0 means YLERROR=ZLERROR (no gradient)
            ! *** NEGATIVE: BELLANA is used to calculate error
                 ! ***           field, B0ERROR is taken for B0ELLANA

        ZLENERR=0.032   ! 2*pi/kz of poles [m]

        NBERROR=-9999   !  number of poles

            !  for NBERRMOD=0 one error affects three poles
            !  for NBERRMOD=1 one error affects two poles
            !  for NBERRMOD=2 one error affects one pole
            !
            !  for NBERRMOD=10 errors are read from file wave_berror.dat
            !  and  affects three poles
            !  for NBERRMOD=11 errors are read from file wave_berror.dat
            !  and  affects two poles
            !  for NBERRMOD=12 errors are read from file wave_berror.dat
            !  and  affects one pole
            !
            !  for NBERRMOD=-1 poles from Fibonacci series,
            !  error is B0ERROR=const
            !  file fibonacci_used_cut.dat contains used cut
            !  file fibonacci_available_cuts.dat contains
            !  available cuts of series

            ! -9999 means number of poles are calculated from
            ! XSTART and XSTOP

        XCENERR=0.      ! center of error field in X [m]

        ETAFIBO=4.05177 ! eta for Fibonacci-series
        ICUTFIBO=1      ! use cut with icut .gt. ICUTOFIBO of series

        $END

 $PHOTONN

      IHPHOTONS=1 ! to get Ntuple with photons generated for IENELOSS = -1

      EECMAXG1=5.0 ! max. energy of generated photons in units of Ec
      NBING1=1000  ! number of bins for histogram of probability
                   ! distribution

      IPHMODE=0    !0: use WAVE routine to generate photons
                   !1: use HRNDM1 from CERN to generate photons
                   !<0: use WAVE routine to generate photons
                   ! addionally with transversal momentum

 $END

 $USERN

 !The first 10 values are also stored as Ntuple 223
 !or n223 for PAW or root respectively

        USER(1)=0.       !USER REAL*8 ARRAY (1000)
        USERCHAR(1)=''   !USER CHARACTER(128) ARRAY (1000)

      $END

 $WAVES
   INULL=0
   IONE=1
   ITWO=2
   ITHREE=3
   IFOUR=4
   IFIVE=5
   ISIX=6
   ISEVEN=7
   IEIGHT=8
   ININE=9
   DWAVES=0.0E0      !DUMMY
   RWAVES=0.  !DUMMY
   IWAVES=0   !DUMMY
   CWAVES=(0.,0.)   !DUMMY
   IAMPW=0
   IAMPNW=1
   IAMPNP=1
   IAMPLI11=0
   IAMPLI21=0
   IAMPLI12=0
   IAMPLI22=0
   INURAN=0
   IRBMAP=0
   IRBMAP2=0
   IWBMAPT=0
   TROTCHIC0=0.
   TROTCHIC=0.
   TROTMODU0=0.
   TROTMODU=86.76
   T180=180.
   TROT=86.76
   TROTEND=90.
   TROT900=90.
   TROT90=90.
   TROTM=0.
   TROT1800=180.
   TROT180=180.
   UE112SH=0.
   UE112SH=0.
   SHLL=0.0
   SHLR=+1.0
   SHUL=-1.0
   SHUR=0.0
   UESHIFTLL=0.0
   UESHIFTUL=0.
   UESHIFTLR=0.
   UESHIFTUR=0.0
   SHIFTLLM=0.0
   SHIFTULM=0.
   SHIFTLRM=0.
   SHIFTURM=0.0
   UESHIFTLLM=0.0
   UESHIFTULM=0.
   UESHIFTLRM=0.
   UESHIFTURM=0.0
   IUE112MOD=1
   NUE112MOD=0
   IUE46=0
   IUE56=0
   IUE112=0
   IWORK1=0
   IWORK2=0
   IWORK3=0
   IBEAMFOLD=0
   IBEAMEFOLD=0
   IAMPREPP=0
   MPINRT=0
   IBUNCHT=1
   R9999=9999.
   IPINHV=0
   IPINWV=0
   IPINRV=1
   IPIN3=0
   KBUNDUMAG1=0
   KBUNDUMAG2=0
   KBUNDUMAG3=0
   KBUNDUMAG4=0
   KAPPLE=0
   KHYBRID=0
   KUNDUWAV=0
   IRMAP2=0
   KHYBRID=0
   KAPPLE=0
   IUNDU2=0
 $end
+DECK,urad_phase,T=TEXT.
*CMZ :          07/11/2023  11.07.37  by  Michael Scheer
*-- Author :    Michael Scheer   07/11/2023
 $uradphasen

  Mthreads=-1                  !Number of threads (<0: Use all cores)
  Ebeam=1.722                  !Beam energy [GeV]
  Curr=0.1                     !Current [A]
  Step=0.2                     !Tracking step size [mm]
  Nelec=1                      !Nelec
  Noranone=1                   !No random change for first e-
  Icohere=0                    !
  Ihbunch=100                  !Each Ihbunch_th bunch is recorded
  Bunchlen=0.0                 !Not yet
  BunchCharge=0.0              !Not yet
  Modebunch=0                  !Not yet
  PinX=10000.0                 !X of PinHole [mm]
  PinY=0.0                     !Y of PinHole [mm]
  PinZ=0.0                     !Z of PinHole [mm]
  PinW=1.0                     !Width of PinHole [mm]
  PinH=1.0                     !Height of PinHole [mm]
  NpinY=1                      !Number of vert. points
  NpinZ=1                      !Number of hori. points
  Modepin=0                    !Monte-Carlo mode [0,1]
  Modesphere=0                 !Observation points are on a sphere
  Perlen=50.0                  !Period-length [mm]
  Shift=12.5                   !Shift [mm] (for spectra only)
  Nper=51                      !Number of periods
  Nharm=5                      !Nharm (>0: overwrites Beff)
  Harm=1000.0                  !Harm [eV]
  Beffv=1.0                    !B0 vert. [T]
  Beffh=0.32                   !B0 hori.. [T]
  Nepho=21                     !Number of Photon Energies
  EphMin=595.0                 !Min. Photon Energy [eV]
  EphMax=605.0                 !Max. Photon Energy [eV]
  Espread=0.001                !Rel. energy spread
  BetaH=14.0                   !Hori. Beta function
  BetaV=3.4                    !Vert. Beta function
  EmitH=4.4                    !Hor. Emit. [nm-rad]
  EmitV=0.066                  !Ver. Emit. [nm-rad]
  Disph=0.0                    !Horizontal dispersion [mm]
  Dispph=0.0                   !Derivative of hori. dispersion [mrad]
  Dispv=0.0                    !Vertical dispersion [mm]
  Disppv=0.0                   !Derivative of vert. dispersion [mrad]
  Modeph=0                     !Mode for phase-error
  Pherror=0.0                  !Phase errors

 $end

 $seedn

  Ifixseed=1                   !Fix Seeds [0,1]
  irnseed(1)=376577121
  irnseed(2)=52147852
  irnseed(3)=-1273034815
  irnseed(4)=-1963249100
  irnseed(5)=1195262240
  irnseed(6)=-1718716574
  irnseed(7)=-224354675
  irnseed(8)=432587481
  irnseed(9)=1692325775
  irnseed(10)=1934175653
  irnseed(11)=-107106772
  irnseed(12)=648589804
  irnseed(13)=-1919014861
  irnseed(14)=-1763988460
  irnseed(15)=-1039845022
  irnseed(16)=1414926465
  irnseed(17)=-1214705659
  irnseed(18)=560082688
  irnseed(19)=527470902
  irnseed(20)=-1078636718
  irnseed(21)=272932485
  irnseed(22)=-356992740
  irnseed(23)=-2013991490
  irnseed(24)=-588501795
  irnseed(25)=-1010120436
  irnseed(26)=-1558306344
  irnseed(27)=-1116776222
  irnseed(28)=794926823
  irnseed(29)=-1157173406
  irnseed(30)=63711032
  irnseed(31)=-1870802148
  irnseed(32)=-674825931
  irnseed(33)=-690546468
  irnseed(34)=1671737514
  irnseed(35)=-224394481
  irnseed(36)=2026233226
  irnseed(37)=-1141752469
  irnseed(38)=2061158685
  irnseed(39)=-1225625467
  irnseed(40)=-147464566
  irnseed(41)=1692325775
  irnseed(42)=1934175653
  irnseed(43)=-107106772
  irnseed(44)=648589804
  irnseed(45)=-1919014861
  irnseed(46)=-1763988460
  irnseed(47)=-1039845022
  irnseed(48)=1414926465
  irnseed(49)=-1214705659
  irnseed(50)=560082688
  irnseed(51)=527470902
  irnseed(52)=-1078636718
  irnseed(53)=272932485
  irnseed(54)=-356992740
  irnseed(55)=-2013991490
  irnseed(56)=-588501795
  irnseed(57)=-1010120436
  irnseed(58)=-1558306344
  irnseed(59)=-1116776222
  irnseed(60)=794926823
  irnseed(61)=-1157173406
  irnseed(62)=63711032
  irnseed(63)=-1870802148
  irnseed(64)=-674825931

 $end
+PATCH,WKUMAC,T=KUMAC.
*CMZ :  2.37/05 05/12/2001  18.20.16  by  Michael Scheer
+DECK,WAVE_VERSION.
*CMZ :          07/11/2023  17.45.37  by  Michael Scheer
*CMZ :  3.05/09 08/08/2018  14.26.07  by  Michael Scheer
*CMZ :  3.00/01 14/03/2013  12.41.45  by  Michael Scheer
*CMZ :  2.70/06 14/01/2013  09.57.27  by  Michael Scheer
*CMZ :  2.52/07 14/10/2004  09.23.32  by  Michael Scheer
*CMZ :  2.37/03 22/11/2001  16.08.21  by  Michael Scheer
*CMZ :  2.20/02 21/02/2001  11.40.28  by  Michael Scheer
*-- Author :    Michael Scheer   21/02/2001

macro wave_version chopt=+

mess 'current version:'
vers
exec dinput
edi wave
exec dfor
cd cmn

edi $wversion
cop $wversion /cmnn
cop $wversion /incln
cop $wversion /incl
cop $wversion /seqver

vers [chopt]

edi /mrad/$mrad_version

set f77 -lan
cd seqver
seq .
seq /seqver
set ~/wav/cmz/wversdum.f -f
cx wversdum
seq -f $WAVE_INCL/for/*.cmn

seq .
exec dgfor

+DECK,outuradphase,T=KUMAC.
*CMZ :          10/11/2023  11.38.13  by  Michael Scheer
*CMZ :  4.01/03 18/05/2023  14.49.41  by  Michael Scheer
*CMZ :  4.01/02 12/05/2023  11.50.25  by  Michael Scheer
*CMZ :  4.01/00 10/02/2023  13.39.11  by  Michael Scheer
*-- Author :    Michael Scheer   14/01/2023
macro outuradphase
exec duradphase

set ../urad_phase/for/*.f -f
cx urad_modules

set ../urad_phase/for/urad_util.f -f
cx util_break /omp/util_random_gauss_omp /for/util_random _
/for/util_spline_inter /for/util_spline_coef /for/util_parabel _
/for/util_spline_running_integral /for/util_g1_static /for/util_sort_func _
/for/util_get_electron _
/for/util_beta_function_drift _
/for/util_random_gauss _
/for/util_spline_integral_2d _
/for/util_spline_integral_stat _
/for/util_spline_coef_status _
/for/util_random_set_seed _
/for/util_random_get_seed /for/util_random_init

set ../urad_phase/for/urad_phase_main.f -f
cx urad_phase_main _
urad_phase urad_amprep urad_field_ini urad_e_b_field _
/omp/urad?* /omp/bhalba_omp _
/urad/uradphoton /urad/uradstep /urad/uradestep /urad/uradrndm

seq .
seq /inclcmn

set $WAVE_INCL/omp/mod/*.f -f
cx //wave/uradmod/uradphasemod

set $WAVE_INCL/nomp/mod/*.f -f
cx //wave/uradmod/uradphasemod

buff //wave/uradphase
buff //wave/urad/uradestep //wave/urad/uradphoton //wave/urad/uradrndm
buff -//wave/uradphase/urad_phase_main

set $WAVE_INCL/omp/*.f -f
cx -b

set ../urad_phase/for/*.f -f

*exec dkumac
exitm
+DECK,out_contrl_cmn,T=KUMAC.
*CMZ :          17/10/2023  13.15.19  by  Michael Scheer
*-- Author :    Michael Scheer   17/10/2023
macro load_contrl_cmn

exec dfor
seq .
cd test
cc load_contrl_cmn
seq -f ~/wav/for/*.cmn

exitm
+PATCH,UFOR.
*CMZ :  1.00/00 01/10/97  17.57.14  by  Michael Scheer
+DECK,UOUT_PHOTON.
*CMZ :          17/10/2023  12.43.22  by  Michael Scheer
*CMZ :  2.15/00 15/03/2007  11.13.54  by  Michael Scheer
*CMZ : 00.02/05 19/03/97  14.10.43  by  Michael Scheer
*CMZ : 00.02/04 26/02/97  10.23.26  by  Michael Scheer
*-- Author :    Michael Scheer   25/02/97

      SUBROUTINE UOUT

C     INTERFACE FUER PHOTON
C     USER(1) MUSS KRITISCHE ENERGIE ENTHALTEN

C     EIGENTLICH IST DIE KRITISCHE ENERGIE UND GAMMA UNWICHTIG,
C     ABER VORERST FUER CHECKS MITAUSGEBEN.
C     PINCEN(2) MUSS NULL SEIN (FAKTOR 2)
C
C     AUSGEBEN WIRD dFLUX/dTHETA[mrad]

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,SPECT.
+SEQ,OBSERV.
+SEQ,FREQS.
+SEQ,USERVAR.


      INTEGER IFREQ
      DOUBLE PRECISION EGAMMA,PHOTONS

      WRITE(6,*)
      WRITE(6,*)'SUBROUTINE UOUT_PHOTON:'
      WRITE(6,*)'======================='
      WRITE(6,*)
      WRITE(6,*)'WRITING FILE FOR PHOTON'
      WRITE(6,*)'Ekrit (USER(1)):',USER(1)
      WRITE(6,*)


      IF (IPIN.NE.1) STOP '*** ERROR IN UOUT_PHOTON: IPIN.NE.1'
      IF (IF1DIM.NE.1) STOP '*** ERROR IN UOUT_PHOTON: IF1DIM.NE.1'
      IF (PINCEN(2).NE.0.0)STOP
     &  '*** ERROR IN UOUT_PHOTON: PINCEN(2).NE.0.0'

      OPEN(UNIT=99,FILE='WAVE.PHOTON',STATUS='NEW')

      WRITE(99,*)'WAVE.PHOTON'
      WRITE(99,*)ICODE,' ',CODE
      WRITE(99,*)USER(1),DMYGAMMA
      WRITE(99,*)PINW,PINH
      WRITE(99,*)OBSVDZ,OBSVDY
      WRITE(99,*)PINCEN
      WRITE(99,*)NFREQ

      DO IFREQ=1,NFREQ
        EGAMMA=FREQ(IFREQ)/USER(1)
        PHOTONS=WFLUXT(IFREQ)
     &    /1.327D13 ! 1.327e13 * Ebeam**2  * Icurr * H2(y) yields flux-dens.
     &    /BANWID*0.001D0
     &    *(PINCEN(1)/PINW/1000.0D0)
     &    /(DMYCUR*1000.0D0)
     &    /DMYENERGY**2
     &    /2.D0
        WRITE(99,*)EGAMMA,PHOTONS
      ENDDO

      CLOSE(99)

      RETURN
      END
+PATCH,SHELL,T=SHELL.
*CMZ :  2.57/05 10/04/2006  16.42.30  by  Michael Scheer
+DECK,compile_urad_phase  ,T=SHELL.
*CMZ :          07/11/2023  09.02.40  by  Michael Scheer
*CMZ :  4.01/02 04/04/2023  12.46.55  by  Michael Scheer
*CMZ :  4.01/00 13/02/2023  11.36.12  by  Michael Scheer
*-- Author : Michael Scheer
# +PATCH,//WAVE/SHELL
# +DECK,compile_urad_phase  ,T=SHELL.
rm -f b/urad_phase.exe

c f

echo
echo
echo

gfortran -c -O3 -cpp \
-ffpe-summary=invalid,zero,overflow \
-fopenmp \
-fcheck=all \
-fdec -fd-lines-as-comments \
-Wno-align-commons \
-ffixed-line-length-none \
-finit-local-zero -funroll-loops \
urad_modules.f

gfortran -c -O3 -cpp \
-ffpe-summary=invalid,zero,overflow \
-fopenmp \
-fcheck=all \
-fdec -fd-lines-as-comments \
-Wno-align-commons \
-ffixed-line-length-none \
-finit-local-zero -funroll-loops \
urad_util.f

gfortran -O3 -cpp \
-ffpe-summary=invalid,zero,overflow \
-fcheck=all \
-fopenmp \
-fdec -fd-lines-as-comments \
-Wno-align-commons \
-ffixed-line-length-none \
-finit-local-zero -funroll-loops \
urad_modules.o urad_util.o \
-o ../bin/urad_phase.exe \
urad_phase_main.f

c ..
+PATCH,CMNN,T=F77.
*CMZ :  3.03/02 09/12/2015  09.12.49  by  Michael Scheer
+KEEP,CONTRL.
*CMZ :          17/10/2023  13.03.54  by  Michael Scheer
*CMZ :  4.01/02 04/05/2023  09.42.54  by  Michael Scheer
*CMZ :  4.00/15 04/04/2022  10.24.47  by  Michael Scheer
*CMZ :  4.00/11 16/05/2021  15.27.36  by  Michael Scheer
*CMZ :  4.00/07 05/05/2020  18.12.57  by  Michael Scheer
*CMZ :  4.00/06 02/12/2019  12.04.53  by  Michael Scheer
*CMZ :  3.05/01 03/05/2018  11.26.16  by  Michael Scheer
*CMZ :  3.05/00 25/04/2018  15.20.02  by  Michael Scheer
*CMZ :  3.03/04 27/11/2017  14.31.32  by  Michael Scheer
*CMZ :  3.03/02 11/12/2015  12.41.59  by  Michael Scheer
*CMZ :  3.02/03 10/11/2014  10.54.59  by  Michael Scheer
*CMZ :  3.02/00 10/09/2014  11.58.23  by  Michael Scheer
*CMZ :  3.01/00 23/05/2013  12.58.00  by  Michael Scheer
*CMZ :  2.68/02 18/06/2012  08.32.21  by  Michael Scheer
*CMZ :  2.67/02 30/04/2012  15.32.33  by  Michael Scheer
*CMZ :  2.67/00 10/02/2012  09.32.25  by  Michael Scheer
*CMZ :  2.66/20 22/11/2011  10.02.36  by  Michael Scheer
*CMZ :  2.66/03 03/11/2009  10.36.14  by  Michael Scheer
*CMZ :  2.66/02 25/10/2009  18.51.21  by  Michael Scheer
*CMZ :  2.66/00 03/10/2009  10.41.16  by  Michael Scheer
*CMZ :  2.63/05 22/09/2009  09.52.39  by  Michael Scheer
*CMZ :  2.61/02 15/03/2007  11.13.25  by  Michael Scheer
*CMZ :  2.54/05 19/05/2005  08.16.19  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  10.35.00  by  Michael Scheer
*CMZ :  2.52/16 17/01/2005  12.51.54  by  Michael Scheer
*CMZ :  2.52/13 15/12/2004  10.22.51  by  Michael Scheer
*CMZ :  2.50/02 30/04/2004  15.30.01  by  Michael Scheer
*CMZ :  2.48/04 12/03/2004  14.29.11  by  Michael Scheer
*CMZ :  2.47/23 17/02/2004  09.32.25  by  Michael Scheer
*CMZ :  2.47/08 15/05/2003  16.10.09  by  Michael Scheer
*CMZ :  2.46/00 17/12/2002  15.37.06  by  Michael Scheer
*CMZ :  2.44/00 15/11/2002  15.38.11  by  Michael Scheer
*CMZ :  2.41/13 22/08/2002  13.33.58  by  Michael Scheer
*CMZ :  2.40/00 04/03/2002  12.22.17  by  Michael Scheer
*CMZ :  2.37/06 07/12/2001  14.56.59  by  Michael Scheer
*CMZ :  2.31/01 25/04/2001  11.16.16  by  Michael Scheer
*CMZ :  2.30/03 20/04/2001  14.55.56  by  Michael Scheer
*CMZ :  2.16/08 25/10/2000  12.03.15  by  Michael Scheer
*CMZ :  2.16/00 09/06/2000  10.38.39  by  Michael Scheer
*CMZ :  2.15/00 15/05/2000  16.29.51  by  Michael Scheer
*CMZ :  2.14/02 27/04/2000  09.34.00  by  Michael Scheer
*CMZ :  2.13/02 14/12/99  16.34.53  by  Michael Scheer
*CMZ :  2.12/04 27/08/99  11.47.41  by  Michael Scheer
*CMZ :  2.12/00 03/06/99  15.39.28  by  Michael Scheer
*CMZ :  2.10/01 18/02/99  11.12.35  by  Michael Scheer
*CMZ :  2.02/00 12/02/99  16.38.34  by  Michael Scheer
*CMZ :  2.01/00 19/01/99  11.00.55  by  Michael Scheer
*CMZ :  2.00/00 06/01/99  15.44.04  by  Michael Scheer
*CMZ :  1.03/06 25/09/98  11.15.49  by  Michael Scheer
*CMZ :  1.02/00 06/01/98  15.19.43  by  Michael Scheer
*CMZ :  1.01/00 26/11/97  17.27.50  by  Michael Scheer
*CMZ :  1.00/00 23/09/97  12.28.25  by  Michael Scheer
*CMZ : 00.02/04 14/02/97  12.24.12  by  Michael Scheer
*CMZ : 00.02/03 22/01/97  12.17.34  by  Michael Scheer
*CMZ : 00.02/02 15/01/97  10.44.29  by  Michael Scheer
*CMZ : 00.02/00 25/11/96  14.48.54  by  Michael Scheer
*CMZ : 00.01/08 18/07/95  10.10.22  by  Michael Scheer
*CMZ : 00.01/07 08/03/95  16.44.52  by  Michael Scheer
*CMZ : 00.01/04 09/12/94  11.23.19  by  Michael Scheer
*CMZ : 00.01/03 28/11/94  11.34.21  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  13.43.54  by  Michael Scheer
*CMZ : 00.01/01 23/06/94  13.23.42  by  Michael Scheer
*CMZ : 00.00/07 25/05/94  16.27.38  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  15.11.40  by  Michael Scheer
*-- Author : Michael Scheer
+SELF,IF=HPUX,TRUE64.
      DOUBLE PRECISION DABS

+SELF.
      DOUBLE PRECISION ECPHOTON,XSTART,XINTER,XSTOP,XIANF,XIEND,GWINFC,BL0CUT,BL0HYS
     &  ,DMYGAMMA,DMYBETA,VXIN,VYIN,DMYCUR,BANWID,D1MBETA
     &  ,VZIN,YSTART,ZSTART,DEVLEN,DEVLEN2,DMYENERGY,GMOM,EMOM
     &  ,XSTARTH,XSTOPH,DBRHO,BMOVECUT
     &  ,BXSTART,BYSTART,BZSTART,AXSTART,AYSTART,AZSTART
     &  ,BXSTOP,BYSTOP,BZSTOP,AXSTOP,AYSTOP,AZSTOP,XBSYM

      INTEGER       LIDIM,NBDIM,NOMDIM,IBFDIM4,IBFDIM2,IANZPL,LUNGFI,
     &  LUNGFO,IWFILSP0,IWFILSPF,IWFILPOW,
     &  NXPAN,NYPAN,
     &  ICODE,KOUT,KBFELD,KHALBA,KHALBASY,KUNDUGAP,KBEXTERN,KBAMWLS,
     &  IRFILF,IBGAUSS,KCIRC,
     &  KSIGN,ICHECK,KBETAX,IFORM0,IFORM,
     &  IWFILB0,IRFILB0,IWFILF,IWSECTMAGS,IRFILP,IRFILB,ITRAKT,
     &  IWFILT0,IRFILT0,IWFILL0,IRFILL0,
     &  IEXPL0,NLPOI,IWFILL,IWFILA,IRFILA,ISAVLO,
     &  IOPTIC,IGENFUN,IDISPER,IEMIT,IERZANA,IEMIAHW,
     &  IBHARD,IERZFUN,IRANDO,IBHTRACK,IBHELM,KBGENESIS,ISPLINE,
     &  IBSYM,IWLSOPT,IKBFORM,IRBTAB,NBTAB,IJUST,MYINUM,NSTEPMX,
     &  ICTEST ,IHFOLD,IBSYMY,IBSYMZ,
     &  NWMAX,ISPEC,IVELOFIELD,NDFREQ,NDOBSV,IFREQ2P,IWFILINT,JWFILINT,
     &  IHPIN,
     &  NDPAWC,IPIN,IPOLA,ifold,ibunch,ISPECANA,NGCOEF,ISPECMODE,
     &  NDMASHZ,NDMASHY,NDOBSVZ,NDOBSVY,ISIGUSR,ISPECINT,
     &  IPINALL,IHBOOK,IHINDEX,
     &  IHTRACK,IHTRSMP,IHTRACKM,IHBETA,IUNIT,IUNITS,IF1DIM,IHFREQ,
     &  IPOWER,NDPOL,IBEAMPOL,KUCROSS,KMAGSEQ,IMGSQF,KMAGCOR,
     &  IWBTAB,IABEND,irbmap6,iwbmap,
     &  IWFILFL0,IWFILFLF,IRPHI,
     &  IUSEM,IPINCIRC,ISTOKES,irbtabzy,ifourbtabzy,IRBTABXYZ,ISPECANAF,IBRILL,
     &  IWFILSTO,IWFLSTOF,IWFLSTOE,IWFLSTOEF,IRFILSP0,IRFILSTO,ISPECSUM,
     &  IWFILS,IWFILSF,IWFILSE,IWFILSEF,
     &  IWFILB,IWFILBF,IWFILBE,IWFILBEF,
     &  IWFILBRILL,IWFILBRILLF,IWFILBRILLE,IWFILBRILLEF,
     &  KELLIP,IWFILRAY,KELLANA,
     &  IPHASE,IDOSE,IPHOTON,IEFOLD,IDESYNC,ISPECDIP,
     &  IUOUT,IUNAME,IUSTEP,IPHASEANA,
     &  KBPOLYH,IGFLOAT
     &  ,KBPOLY3D,IWBPOLY3D
     &  ,KBPOLY2DH,IWBPOLY2DH
     &  ,KBPharm,IWBpharm
     &  ,KBREC,KBPOLYMAG,IBATCH,kbundumag,kbundumap,kbunduverb
     &  ,IMAGSPLN,IHINPUT,IHOUTP,IMHBCOM,IMAGJOB
     &  ,IW_BLEN,IW_BLENF,IW_CIRC
     &  ,IHLIMIT_C,IHISINI_C,ihisascii,iroottrees,IBFORCE
     &  ,iampli,kampli,IAMPJIT,IUNDULATOR,IWIGGLER,IEXPERT,IBSUPER,IBERROR
     &  ,ieneloss,iefield,iroothdf5,nocern,iadjust,iwarnbmap,iwarnmyb,mthreads

      CHARACTER(65) CODE
      CHARACTER     CHISASCII

      COMMON/CONTRL/ECPHOTON,
     &  XSTART,XINTER,XSTOP,XIANF,XIEND,GWINFC,BL0CUT,BL0HYS
     &  ,DMYGAMMA,DMYBETA,VXIN,VYIN,DMYCUR,BANWID,D1MBETA
     &  ,VZIN,YSTART,ZSTART,DEVLEN,DEVLEN2,DMYENERGY,GMOM,EMOM
     &  ,XSTARTH,XSTOPH,DBRHO,BMOVECUT
     &  ,BXSTART,BYSTART,BZSTART,AXSTART,AYSTART,AZSTART
     &  ,BXSTOP,BYSTOP,BZSTOP,AXSTOP,AYSTOP,AZSTOP,XBSYM
     &  ,LIDIM,NBDIM,NOMDIM,IBFDIM4,IBFDIM2,IANZPL,LUNGFI,
     &  LUNGFO,IWFILSP0,IWFILSPF,IWFILPOW,
     &  NXPAN,NYPAN,
     &  ICODE,KOUT,KBFELD,KHALBA,KHALBASY,KUNDUGAP,KBEXTERN,KBAMWLS,
     &  IRFILF,IBGAUSS,KCIRC,
     &  KSIGN,ICHECK,KBETAX,IFORM0,IFORM,
     &  IWFILB0,IRFILB0,IWFILF,IWSECTMAGS,IRFILP,IRFILB,ITRAKT,
     &  IWFILT0,IRFILT0,IWFILL0,IRFILL0,
     &  IEXPL0,NLPOI,IWFILL,IWFILA,IRFILA,ISAVLO,
     &  IOPTIC,IGENFUN,IDISPER,IEMIT,IERZANA,IEMIAHW,
     &  IBHARD,IERZFUN,IRANDO,IBHTRACK,IBHELM,KBGENESIS,ISPLINE,
     &  IBSYM,IWLSOPT,IKBFORM,IRBTAB,NBTAB,IJUST,MYINUM,NSTEPMX,
     &  ICTEST ,IHFOLD,IBSYMY,IBSYMZ,
     &  NWMAX,ISPEC,IVELOFIELD,NDFREQ,NDOBSV,IFREQ2P,IWFILINT,JWFILINT,
     &  IHPIN,
     &  NDPAWC,IPIN,IPOLA,ifold,ibunch,ISPECANA,NGCOEF,ISPECMODE,
     &  NDMASHZ,NDMASHY,NDOBSVZ,NDOBSVY,ISIGUSR,ISPECINT,
     &  IPINALL,IHBOOK,IHINDEX,
     &  IHTRACK,IHTRSMP,IHTRACKM,IHBETA,IUNIT,IUNITS,IF1DIM,IHFREQ,
     &  IPOWER,NDPOL,IBEAMPOL,KUCROSS,KMAGSEQ,KMAGCOR,IMGSQF,
     &  IWBTAB,IABEND,irbmap6,iwbmap,
     &  IWFILFL0,IWFILFLF,IRPHI,
     &  IUSEM,IPINCIRC,ISTOKES,irbtabzy,ifourbtabzy,IRBTABXYZ,ISPECANAF,IBRILL,
     &  IWFILSTO,IWFLSTOF,IWFLSTOE,IWFLSTOEF,IRFILSP0,IRFILSTO,ISPECSUM,
     &  KELLIP,IWFILRAY,KELLANA,
     &  IPHASE,IDOSE,IPHOTON,IEFOLD,IDESYNC,ISPECDIP,IPHASEANA,
     &  IUOUT,IUNAME,IUSTEP,
     &  KBPOLYH,IGFLOAT
     &  ,KBPOLY3D,IWBPOLY3D
     &  ,KBPOLY2DH,IWBPOLY2DH,
     &  KBPharm,IWBpharm,
     &  IWFILS,IWFILSF,IWFILSE,IWFILSEF,
     &  IWFILB,IWFILBF,IWFILBE,IWFILBEF,
     &  IWFILBRILL,IWFILBRILLF,IWFILBRILLE,IWFILBRILLEF
     &  ,KBREC,KBPOLYMAG,IBATCH,kbundumag,kbundumap,kbunduverb
     &  ,IMAGSPLN,IHINPUT,IHOUTP,IMHBCOM, IMAGJOB
     &  ,IW_BLEN,IW_BLENF,IW_CIRC
     &  ,IHLIMIT_C,IHISINI_C,ihisascii,iroottrees,IBFORCE
     &  ,iampli,kampli,IAMPJIT,IUNDULATOR,IWIGGLER,IEXPERT,IBSUPER,IBERROR
     &  ,ieneloss,iefield,iroothdf5,iwarnbmap,iwarnmyb,mthreads
     &  ,CODE,CHISASCII


      NAMELIST/CONTRL/CODE,ECPHOTON,MYINUM,NSTEPMX,DMYENERGY,VXIN,VYIN,VZIN,BMOVECUT
     &  ,KBFELD,KHALBA,KHALBASY,KUNDUGAP,IRFILF,IRBTAB,
     &  KBEXTERN,KBAMWLS,IBGAUSS,KCIRC,IRPHI,
     &  xstart,XINTER,xstop,xianf,xiend,
     &  KSIGN,ICHECK,KBETAX,IFORM0,IFORM,
     &  IWFILB0,IRFILB0,IWFILF,IWSECTMAGS,IRFILP,IRFILB,ITRAKT,
     &  IWFILT0,IRFILT0,IWFILL0,GWINFC,BL0CUT,BL0HYS,
     &  IRFILL0,
     &  IEXPL0,NLPOI,IWFILL,IWFILA,IRFILA,ISAVLO,IOPTIC,
     &  IBHARD,IERZFUN,IERZANA,IGENFUN,
     &  IRANDO,IBHTRACK,IBHELM,KBGENESIS,ISPLINE,IDISPER,
     &  IBSYM,XBSYM,IWLSOPT,IKBFORM,IJUST,IBSYMY,IBSYMZ
     &  ,YSTART,ZSTART,DMYCUR,BANWID
     &  ,ICTEST,IEMIT,IEMIAHW,IHFOLD
     &  ,ISPEC,IVELOFIELD,IWFILSP0,IFREQ2P,IWFILINT,JWFILINT,IWFILSPF
     &  ,IWFILPOW
     &  ,IHPIN,IPOLA,ifold,ibunch,IPIN,ISPECANA,ISIGUSR,ISPECINT,ISPECMODE
     &  ,IPINALL,IHINDEX
     &  ,IHTRACK,IHTRSMP,IHTRACKM,IHBETA,IUNIT,IUNITS,IF1DIM,IHFREQ
     &  ,XSTARTH,XSTOPH,IPOWER,IBEAMPOL,KUCROSS,KMAGSEQ,KMAGCOR,IMGSQF,
     &  IWBTAB,irbmap6,iwbmap
     &  ,IWFILFL0,IWFILFLF
     &  ,IUSEM,IPINCIRC,ISTOKES,irbtabzy,ifourbtabzy,IRBTABXYZ,ISPECANAF,IBRILL
     &  ,IWFILSTO,IWFLSTOF,IWFLSTOE,IWFLSTOEF,IRFILSP0,IRFILSTO,ISPECSUM
     &  ,KELLIP,IWFILRAY,KELLANA
     &  ,IPHASE,IDOSE,IPHOTON,IEFOLD,IDESYNC,ISPECDIP,IPHASEANA
     &  ,IUOUT,IUNAME,IUSTEP
     &  ,KBPOLYH
     &  ,KBPOLY3D,IWBPOLY3D
     &  ,KBPOLY2DH,IWBPOLY2DH,
     &  KBPharm,IWBpharm,
     &  IWFILS,IWFILSF,IWFILSE,IWFILSEF,
     &  IWFILB,IWFILBF,IWFILBE,IWFILBEF,
     &  IWFILBRILL,IWFILBRILLF,IWFILBRILLE,IWFILBRILLEF
     &  ,KBREC,KBPOLYMAG,kbundumag,kbundumap,kbunduverb
     &  ,IMAGSPLN,IHINPUT,IHOUTP,IMHBCOM, ihisascii,iroottrees,
     &  ieneloss,iefield,iroothdf5,
     &  iampli,kampli,IAMPJIT,IUNDULATOR,IWIGGLER,IEXPERT,IBSUPER,IBERROR,ibforce,
     &  nocern,iadjust,mthreads,
     &  CHISASCII
+PATCH,OMP.
*CMZ :  3.05/01 04/05/2018  15.06.07  by  Michael Scheer
+DECK,amprep_omp.
*CMZ :          07/11/2023  15.02.53  by  Michael Scheer
*CMZ :  4.01/02 12/05/2023  15.12.26  by  Michael Scheer
*CMZ :  4.01/00 11/02/2023  16.38.29  by  Michael Scheer
*CMZ :  4.00/17 05/12/2022  10.30.41  by  Michael Scheer
*CMZ :  4.00/16 17/09/2022  15.46.32  by  Michael Scheer
*CMZ :  4.00/15 02/06/2022  09.45.10  by  Michael Scheer
*CMZ :  4.00/11 28/06/2021  10.33.06  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine amprep_omp

! Interface WAVE -> urad_phase

+seq,trackf90u.
+seq,spectf90u.

      use sourcef90
      use observf90
      use afreqf90
      use bunchmod
      use uradphasemod
      use omp_lib

      implicit none

+seq,datetime.
+seq,contrl.
+seq,cmpara.
+seq,track.
+seq,track0.
+seq,spect.
+seq,observ.
+seq,sourcef90.
+seq,freqs.
+seq,ampli.
+seq,ellip.
+seq,wfoldf90.
+seq,optic.
+seq,b0scglob.
+seq,depola.
+seq,phycon.
+seq,uservar.

      double precision step,sigzp,sigz,sigyp,sigy,perlen,shift,ephmin,ephmax,
     &  ebeam,disp,dispp,curr,beffh,beffv,pherror,pw,ph,xbeta,
     &  beth,alphh,betv,alphv,de,disph,dispph,dispv,disppv

      integer :: modewave=1,icohere,nelec,noranone,modebunch,npinz,npiny,
     &  modepin,modesphere,nper,nepho

      modewave=1
      step=1.0d0/dble(myinum)*1000.0d0

      perlen=phrperl*1000.0d0
      shift=phrshift*1000.0d0
      beffv=phrb0v
      beffh=phrb0h
      nper=kampli

      nepho=nfreq
      ephmin=freq(1)
      ephmax=freq(nfreq)

      if (rpinsph.gt.0.0d0) modesphere=1

      if (ipin.ne.0) then
        npiny=nobsvy
        npinz=nobsvz
      else
        npiny=1
        npinz=1
      endif

      if (ipin.eq.3) then
        ph=pinh*1000.0d0
        pw=pinw*1000.0d0
      else
        ph=(obsv(2,nobsv)-obsv(2,1))*1000.0d0
        pw=(obsv(3,nobsv)-obsv(3,1))*1000.0d0
      endif

      xbeta=phrxbeta
      beth=phrbetah
      alphh=phralphah
      disph=phrdisph
      dispph=phrdispph

      betv=phrbetav
      alphv=phralphav
      dispv=phrdispv
      disppv=phrdisppv

      de=phrespread
      pherror=phrerror

      bunchlen=phrbunlen
      modebunch=iubunch

      if (ibunch.eq.0) then

        icohere=0
        nelec=1
        noranone=1
        modepin=0

        if (ifold.ne.0) then
          if (ifold.ne.1) then
            print*,''
            print*,'--- Warning in ampre_omp: IFOLD set, but not 1, setting it to 1 ---'
            write(lungfo,*)''
            write(lungfo,*)'--- Warning in ampre_omp: IFOLD set, but not 1, setting it to 1 ---'
            ifold=1
          endif

        endif

      else

        if (nbunch.gt.1.and.neinbunch.gt.1) then
          print*,'*** Error in ampre_omp: Both, NBUNCH and NEINBUNCH > 1. This is not allowed here.'
          print*
          write(lungfo,*)'*** Error in ampre_omp: Both, NBUNCH and NEINBUNCH > 1. This is not allowed here.'
          stop "*** Program WAVE terminated ***"
        endif

        if (neinbunch.gt.1) then
          icohere=1
        else
          icohere=0
        endif

        nelec=max(nbunch,nelec)

        if (ibunch.eq.-1) then
          noranone=1
        else
          noranone=0
        endif

        if (ipin.eq.0.or.ipin.eq.1) then
          modepin=0
        else
          modepin=1
        endif

      endif !ibunch

      call urad_phase(
     &  mthreads,nelec,noranone,icohere,modebunch,bunchlen,bunchcharge,ihbunch,
     &  perlen,shift,nper,beffv,beffh,
     &  dmyenergy,dmycur,step,
     &  pincen*1000.0d0,pw,ph,npiny,npinz,modepin,modesphere,
     &  nepho,ephmin,ephmax,banwid,
     &  xbeta,beth,alphh,betv,alphv,de,phremith,phremitv,
     &  disph,dispph,dispv,disppv,
     &  modeph,pherror,modewave
     &  )

      return
      end
+PATCH,PYTHON,T=PYTHON.
*CMZ :  3.05/04 05/07/2018  14.52.56  by  Michael Scheer
+DECK,make_wave,T=PYTHON.
*CMZ :          07/11/2023  16.09.41  by  Michael Scheer
*CMZ :  4.01/03 29/06/2023  09.29.02  by  Michael Scheer
*CMZ :  4.01/02 07/05/2023  09.12.43  by  Michael Scheer
*-- Author :    Michael Scheer   17/03/2023

# +PATCH,//WAVE/PYTHON
# +DECK,wave_make,T=PYTHON.

import os
import sys
import platform
import glob

def Quit(*args, delay=0):
  #reakpoint()
  nargs =  len(args)

  text = ''
  for i in range(nargs):
    text += str(args[i]) + " "
  #endif

  if delay > 0:

    if len(text):
      print("\n",text, "\nWaiting",delay," seconds before kill")
      #time.sleep(delay)
    else:
      print("\nWaiting",delay," seconds before kill")
      #time.sleep(delay)
    #endif len(text):

    if platform.system() == 'Windows':
      os.system("sleep " + str(delay) + " && taskkill /F /PID " + str(os.getpid()) + " &")
    else:
      os.system("sleep " + str(delay) + " && kill " + str(os.getpid()) + " &")
    #endif platform.system() == 'Windows'

  elif delay < 0:
    return
  else:
    print("\n",text)
    if platform.system() == 'Windows':
      os.system("taskkill /F /PID " + str(os.getpid()))
    else:
      os.system("kill " + str(os.getpid()))
    #endif platform.system() == 'Windows'

#enddef Quit(text = '', delay=0)

global Iverbose,Idry,Idebug,WI

args=sys.argv; nargs = len(args)

try:
  WI = os.environ['WAVE_INCL'] + "/"
except:
  WI = ''
  path = args[0].split("/")
  l = len(path)
  if l == 1:
    path = os.getcwd().split("/")
    path.append(args[0])
  elif l == 2:
    path = os.getcwd().split("/")
    pp = args[0].split("/")
    path.append(pp[0])
    path.append(pp[1])
  #endif
  for i in range(len(path)-2):
    WI += path[i] + "/"
  #endfor
  print("\n*** Warning: Shell variable WAVE_INCL not defined ***")
  print("*** Assuming: ",WI," ***")
  os.system('sleep 3')
#endtry


Iverbose = 0
Idebug = 0
Idry = 0

if nargs > 1:
  try:
    Iverbose = int(args[1])
  except:
    n = '\n'
    print(n)
    print("Usage: python3 " + WI + args[0] + " [verbose level]",n)
    print("To force total recompilation delete ",n,WI + "bin/wave.exe",n)
    Quit()
  #end try
#endif

if nargs > 2: Idebug = int(args[2])

global Wave_tree,Scomp_all,Scomp_omp,Scomp,Texe,Tlib,Scomp_nowarn

Scomp = "gfortran -std=legacy -c -O2 -cpp -fbacktrace -ffpe-summary=invalid,zero,overflow -fdec -fd-lines-as-comments -Wno-align-commons -fno-automatic -ffixed-line-length-none -finit-local-zero -funroll-loops "
Scomp_nowarn = "gfortran -w -std=legacy -c -O2 -cpp -fbacktrace -ffpe-summary=invalid,zero,overflow -fdec -fd-lines-as-comments -Wno-align-commons -fno-automatic -ffixed-line-length-none -finit-local-zero -funroll-loops "
Scomp_all = "gfortran -std=legacy -c -O2 -cpp -fcheck=all -fbacktrace -ffpe-summary=invalid,zero,overflow -fdec -fd-lines-as-comments -Wno-align-commons -fno-automatic -ffixed-line-length-none -finit-local-zero -funroll-loops "
Scomp_omp = "gfortran -std=legacy -c -O2 -cpp -finit-local-zero -fcheck=all -fopenmp -fbacktrace -ffpe-summary=invalid,zero,overflow -fdec -fd-lines-as-comments -Wno-align-commons -ffixed-line-length-none -funroll-loops "

def print_wave_tree():
  global Wave_tree

  ftree = open('wave.tre','w')
  itop = 0

  for topd in Wave_tree:

    itop+=1
    ftree.write('\n' + '---- Directory ' + str(itop) + ' ' + topd[0] + ' ' + str(topd[1]) + '\n\n')

    modfor = topd[2]
    imodfor = 0
    for mf in modfor:
      imodfor+=1
      slin = str(imodfor) + ' mod/' + mf[0] + ' ' + str(mf[1])
      #print(slin)
      ftree.write(slin + '\n')
    #endfor

    ftree.write('\n')
    modmod = topd[3]
    imodmod = 0
    for mm in modmod:
      imodmod+=1
      slin = str(imodmod) + ' ' + mm[0] + ' ' + str(mm[1])
      #print(slin)
      ftree.write(slin + '\n')
    #endfor

    ftree.write('\n')
    cmn = topd[4]
    icmn = 0
    for cm in cmn:
      icmn+=1
      slin = str(icmn) + ' ' + cm[0] + ' ' + str(cm[1])
      #print(slin)
      ftree.write(slin + '\n')
    #endfor

    ftree.write('\n')
    ff = topd[5]
    iff = 0
    for f in ff:
      iff+=1
      slin = str(iff) + ' ' + f[0] + ' ' + str(f[1])
      #print(slin)
      ftree.write(slin + '\n')
    #endfor

  #endfor

  ftree.close()
#    Wave_tree.append([topd,t,modfor,modmod,cmn,fort])
#enddef print_wave_tree()

def get_wave_tree():

  global WI,Wave_tree,Iverbose,Idry,Idebug,Texe,Tlib

  try:
    Texe = os.stat(WI + '/bin/wave.exe').st_mtime_ns
  except:
    Texe = 0
  #endtry

  top = glob.glob(WI+"/*")

  Wave_tree = []
  #reakpoint()

  for topd in top:

    dd = topd.split("/")[-1]

    if dd == 'cmz' or dd == 'doc' or dd == 'check_system' or dd == 'bin' \
    or dd == 'python' or dd == 'main' or dd == 'lib': continue

    t = os.stat(topd).st_mtime_ns

    modf = glob.glob(topd+"/mod/*.f")

    modfor = []
    for ff in modf:
      f = ff.split("/")[-1]
      tf = os.stat(ff).st_mtime_ns
      modfor.append([f,tf])
    #endfor

    modm = glob.glob(topd+"/*.mod")
    modmod = []
    for ff in modm:
      f = ff.split("/")[-1]
      tf = os.stat(ff).st_mtime_ns
      modmod.append([f,tf])
    #endfor

    cm = glob.glob(topd+"/*.cmn")
    cmn = []
    for ff in cm:
      f = ff.split("/")[-1]
      tf = os.stat(ff).st_mtime_ns
      cmn.append([f,tf])
    #endfor

    ff = glob.glob(topd+"/*.f")
    fort = []
    for fff in ff:
      f = fff.split("/")[-1]
      tf = os.stat(fff).st_mtime_ns
      fort.append([f,tf])
    #endfor

    Wave_tree.append([topd,t,modfor,modmod,cmn,fort])

  #endfor get_wave_tree

  #print_wave_tree()

#enddef get_wave_tree

def wave_update():

  global WI,Wave_tree,Texe,Scomp_all,Scomp_omp,Scomp,Iverbose,Idry,Idebug,Scomp_nowarn

  kmain = 0

  get_wave_tree()

  for td in Wave_tree:

    dd = td[0]
    ds = dd + "/"
    dsm = dd + "/mod/"
    t = td[1]
    modfor = td[2]
    cmn = td[4]
    fort = td[5]

    scomp = Scomp

    lib = ''
    libm = ''
    ranl = 0
    ranlm = 0
    slibm = ''
    slib = ''

    ddd = dd.split("/")[-1]

    #reakpoint()

    if ddd == 'mhbook':
      if Iverbose >= 0: print("\nProcessing",dd)
      lib = WI + 'lib/libmhbook.a'
      libm = WI + 'lib/libmhbook_modules.a'
    elif ddd == 'mshcern':
      if Iverbose >= 0: print("\nProcessing",dd)
      lib = WI + 'lib/libmshcern.a'
      libm = WI + 'lib/libmshcern_modules.a'
      scomp = Scomp_nowarn
    elif ddd == 'mshplt':
      if Iverbose >= 0: print("\nProcessing",dd)
      lib = WI + 'lib/libmshplt.a'
      libm = WI + 'lib/libmshplt_modules.a'
    elif ddd == 'nomp':
      if Iverbose >= 0: print("\nProcessing",dd)
      lib = WI + 'lib/libwave.a'
      libm = WI + 'lib/libwave_modules.a'
      scomp = Scomp_all
    elif ddd == 'omp':
      if Iverbose >= 0: print("\nProcessing",dd)
      lib = WI + 'lib/libwave_omp.a'
      libm = WI + 'lib/libwave_omp_modules.a'
      scomp = Scomp_omp
    elif ddd == 'urad':
      if Iverbose >= 0: print("\nProcessing",dd)
      lib = WI + 'lib/liburad.a'
      libm = WI + 'lib/liburad_modules.a'
      scomp = Scomp_all  # uradcfft does boundary tricks
    elif ddd == 'user':
      if Iverbose >= 0: print("\nProcessing",dd)
      lib = WI + 'lib/libuser.a'
      libm = WI + 'lib/libuser_modules.a'
      scomp = Scomp_omp
    #endif

    try:
      Tlib = os.stat(lib).st_mtime_ns
      if Tlib > Texe: kmain = 1
    except:
      pass
    #endtry
    try:
      Tlib = os.stat(libm).st_mtime_ns
      if Tlib > Texe: kmain = 1
    except:
      pass
    #endtry

    scompmod = "cd " + dd + "/mod && " + scomp
    scomp = "cd " + dd + " && " + scomp

    for f in modfor: # Compile modules

      ff = f[0]
      t = f[1]

      if t < Texe: continue

      if Iverbose > 0: print(ff)

      fo = ff[:-1] + "o"
      fm = ff[:-1] + "mod"

      Flines = open(ds+"mod/"+ff,'r')

      while True:
        l = Flines.readline()
        if not l: break
        sl = l.split()
        if len(sl) == 0: continue
        key = sl[0].lower()
        if key== 'module':
          m = sl[1].lower()
          break
        #endif
      #end while
      Flines.close()

      if Iverbose > 0: print("\nModule:",m)

      scom = scompmod + "-o " + fo + " " + ff
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)

      scom = 'mv ' + dsm + m + ".mod " + dd
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)

      slibm += " " + dsm + fo
      ranlm = 1

      # Search use of module in *.cmn
      for ft in cmn:

        f = ft[0]
        t = ft[1]

        if t < Texe: continue

        Flines = open(ds+f,'r')
        if Idebug > 1: print("\n",ds+f)

        while True:
          l = Flines.readline()
          if Idebug > 1: print(l)
          if not l: break
          #if len(l) < 10: break
          sl = l.split()
          if len(sl) > 1:
            key = sl[0].lower()
            if key== 'use':
              if sl[1].lower() == m:
                scom = 'touch ' + ds+f
                if Iverbose > 0: print("\n",scom,"\n")
                if Idry == 0: os.system(scom)
                break
              #endif
            #endif
          #endif
        #end while
        Flines.close()

      #endfor

      # Search use of module in *.f
      for ft in fort:

        f = ft[0]
        t = ft[1]

        if Idebug > 1: print(f)

        Flines = open(ds+f,'r')
        while True:
          l = Flines.readline()
          if not l: break
          #if len(l) < 10: break
          sl = l.split()
          if len(sl) > 1:
            key = sl[0].lower()
            if key== 'implicit':
              if sl[1].lower() == 'none': break
            elif key== 'use':
              if sl[1].lower() == m:
                scom = 'touch ' + ds+f
                if Iverbose > 0: print("\n",scom,"\n")
                if Idry == 0: os.system(scom)
                break
              #endif
            #endif
          #endif
        #end while
        Flines.close()

      #endfor

    #endfor modfor

    if ranlm:
      scom = 'ar rc ' + libm + " " + slibm
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)
      scom = 'ranlib ' + libm
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)
      ranlm = 0
      slibm = ''
      kmain = 1
    #endif

    # Check *.cmn

    for ft in cmn:

      f = ft[0]
      #print(f)
      #if f == 'genfun.cmn': debug()
      t = os.stat(ds+f).st_mtime_ns

      if t < Texe: continue

      fcmn = f.split("/")[-1]

      for fft in fort:

        #if fft[0] == 'erzfun.f': debug('erzfun')

        Flines = open(ds+fft[0],'r')
        #Flines = open(ds+fft[0],'r',errors='ignore')
        #Flines = open(ds+fft[0],'r',encoding='latin1') #, errors='ignore')
#        nlin = 0
        while True:
          l = Flines.readline()
          if not l: break
          #if len(l) < 10: break
          sl = l.split()
          #if fft[0] == 'erzfun.f':
#            nlin += 1
#            print(nlin,l)
#            if nlin > 80: debug(nlin)
          if len(sl) < 2: continue
          #print(sl)
          if sl[0][0] == '*' or sl[0][0] == '!' or len(sl[0]) < 7: continue
          key = sl[0].lower()
          #if fft[0] == 'erzfun.f': print(sl)
          if key== 'include':
#            if fft[0] == 'erzfun.f': debug('include')
            if sl[1].lower() == "'" + fcmn + "'" or sl[1].lower() == '"' + fcmn + '"':
              scom = 'touch ' + ds+fft[0]
              if Iverbose > 0: print("\n",scom,"\n")
              if Idry == 0: os.system(scom)
              break
            #endif
          #endif
        #end while
        Flines.close()
#        if fft[0] == 'erzfun.f': Quit()
      #endfor fort

    #endfor cmn

    # Compile *.f if neccessary

    for ft in fort:

      f = ft[0]
#      print(f)
      t = os.stat(ds+f).st_mtime_ns

      if t < Texe: continue

      fo = f[:-1] + "o"

      scom = scomp + "-o " + fo + " " + f
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)

      slib += " " + ds + fo
      ranl = 1

    #endfor

    if ranl:
      scom = 'ar rc ' + lib + " " + slib
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)
      scom = 'ranlib ' + lib
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)
      kmain = 1
      ranl = 0
      slib = ''
    #endif

  #endfor dir

  if kmain:
    scom = WI + "/shell/compile_wave_incl.sh"
    if Iverbose > 0: print("\n",scom,"\n")
    if Idry == 0: os.system(scom)
    if Iverbose >=0: print("\n--- " + WI  + "bin/wave.exe updated ---\n")
  else:
    if Iverbose >=0: print("\n--- No need to update " + WI  + "bin/wave.exe ---\n")
  #endif


#enddef wave_update

def debug(key='debug'):
  print("debug:",key)
#endif

wave_update()
+DECK,make_wave_debug,T=PYTHON.
*CMZ :          07/11/2023  16.09.41  by  Michael Scheer
*CMZ :  4.01/03 28/06/2023  16.38.14  by  Michael Scheer
*CMZ :  4.01/02 07/05/2023  09.58.31  by  Michael Scheer
*-- Author :    Michael Scheer   17/03/2023

# +PATCH,//WAVE/PYTHON
# +DECK,wave_make_debug,T=PYTHON.

import os
import sys
import platform
import glob

def Quit(*args, delay=0):
  #reakpoint()
  nargs =  len(args)

  text = ''
  for i in range(nargs):
    text += str(args[i]) + " "
  #endif

  if delay > 0:

    if len(text):
      print("\n",text, "\nWaiting",delay," seconds before kill")
      #time.sleep(delay)
    else:
      print("\nWaiting",delay," seconds before kill")
      #time.sleep(delay)
    #endif len(text):

    if platform.system() == 'Windows':
      os.system("sleep " + str(delay) + " && taskkill /F /PID " + str(os.getpid()) + " &")
    else:
      os.system("sleep " + str(delay) + " && kill " + str(os.getpid()) + " &")
    #endif platform.system() == 'Windows'

  elif delay < 0:
    return
  else:
    print("\n",text)
    if platform.system() == 'Windows':
      os.system("taskkill /F /PID " + str(os.getpid()))
    else:
      os.system("kill " + str(os.getpid()))
    #endif platform.system() == 'Windows'

#enddef Quit(text = '', delay=0)

global Iverbose,Idry,Idebug,WI

args=sys.argv; nargs = len(args)

try:
  WI = os.environ['WAVE_INCL'] + "/"
except:
  WI = ''
  path = args[0].split("/")
  l = len(path)
  if l == 1:
    path = os.getcwd().split("/")
    path.append(args[0])
  elif l == 2:
    path = os.getcwd().split("/")
    pp = args[0].split("/")
    path.append(pp[0])
    path.append(pp[1])
  #endif
  for i in range(len(path)-2):
    WI += path[i] + "/"
  #endfor
  print("\n*** Warning: Shell variable WAVE_INCL not defined ***")
  print("*** Assuming: ",WI," ***")
  os.system('sleep 3')
#endtry


Iverbose = 0
Idebug = 0
Idry = 0

if nargs > 1:
  try:
    Iverbose = int(args[1])
  except:
    n = '\n'
    print(n)
    print("Usage: python3 " + WI + args[0] + " [verbose level]",n)
    print("To force total recompilation delete ",n,WI + "bin/wave_debug.exe",n)
    Quit()
  #end try
#endif

if nargs > 2: Idebug = int(args[2])

global Wave_tree,Scomp_all,Scomp_omp,Scomp,Texe,Tlib,Scomp_nowarn

Scomp = "gfortran -std=legacy -c -g -cpp -fbacktrace -ffpe-summary=invalid,zero,overflow -fdec -fd-lines-as-comments -Wno-align-commons -fno-automatic -ffixed-line-length-none -finit-local-zero -funroll-loops "
Scomp_nowarn = "gfortran -w -std=legacy -c -g -cpp -fbacktrace -ffpe-summary=invalid,zero,overflow -fdec -fd-lines-as-comments -Wno-align-commons -fno-automatic -ffixed-line-length-none -finit-local-zero -funroll-loops "
Scomp_all = "gfortran -std=legacy -c -g -cpp -fcheck=all -fbacktrace -ffpe-summary=invalid,zero,overflow -fdec -fd-lines-as-comments -Wno-align-commons -fno-automatic -ffixed-line-length-none -finit-local-zero -funroll-loops "
Scomp_omp = "gfortran -std=legacy -c -g -cpp -finit-local-zero -fcheck=all -fopenmp -fbacktrace -ffpe-summary=invalid,zero,overflow -fdec -fd-lines-as-comments -Wno-align-commons -ffixed-line-length-none -funroll-loops "

def get_wave_tree():

  global WI,Wave_tree,Iverbose,Idry,Idebug,Texe,Tlib

  try:
    Texe = os.stat(WI + '/bin/wave_debug.exe').st_mtime_ns
  except:
    Texe = 0
  #endtry

  top = glob.glob(WI+"/*")

  Wave_tree = []
  #reakpoint()

  for topd in top:

    dd = topd.split("/")[-1]

    if dd == 'cmz' or dd == 'doc' or dd == 'check_system' or dd == 'bin' \
    or dd == 'python' or dd == 'main' or dd == 'lib': continue

    t = os.stat(topd).st_mtime_ns

    modf = glob.glob(topd+"/mod/*.f")

    modfor = []
    for ff in modf:
      f = ff.split("/")[-1]
      tf = os.stat(ff).st_mtime_ns
      modfor.append([f,tf])
    #endfor

    modm = glob.glob(topd+"/*.mod")
    modmod = []
    for ff in modm:
      f = ff.split("/")[-1]
      tf = os.stat(ff).st_mtime_ns
      modmod.append([f,tf])
    #endfor

    cm = glob.glob(topd+"/*.cmn")
    cmn = []
    for ff in cm:
      f = ff.split("/")[-1]
      tf = os.stat(ff).st_mtime_ns
      cmn.append([f,tf])
    #endfor

    ff = glob.glob(topd+"/*.f")
    fort = []
    for fff in ff:
      f = fff.split("/")[-1]
      tf = os.stat(fff).st_mtime_ns
      fort.append([f,tf])
    #endfor

    Wave_tree.append([topd,t,modfor,modmod,cmn,fort])

  #endfor get_wave_tree

#enddef get_wave_tree

def wave_update():

  global WI,Wave_tree,Texe,Scomp_all,Scomp_omp,Scomp,Iverbose,Idry,Idebug,Scomp_nowarn

  kmain = 0

  get_wave_tree()

  for td in Wave_tree:

    dd = td[0]
    ds = dd + "/"
    dsm = dd + "/mod/"
    t = td[1]
    modfor = td[2]
    cmn = td[4]
    fort = td[5]

    scomp = Scomp

    lib = ''
    libm = ''
    ranl = 0
    ranlm = 0
    slibm = ''
    slib = ''

    ddd = dd.split("/")[-1]

    if Iverbose >= 0: print("\nProcessing",dd)
    #reakpoint()

    if ddd == 'mhbook':
      lib = WI + 'lib/libmhbook_debug.a'
      libm = WI + 'lib/libmhbook_modules_debug.a'
    elif ddd == 'mshcern':
      lib = WI + 'lib/libmshcern_debug.a'
      libm = WI + 'lib/libmshcern_modules_debug.a'
      scomp = Scomp_nowarn
    elif ddd == 'mshplt':
      lib = WI + 'lib/libmshplt_debug.a'
      libm = WI + 'lib/libmshplt_modules.a'
    elif ddd == 'nomp':
      lib = WI + 'lib/libwave_debug.a'
      libm = WI + 'lib/libwave_modules_debug.a'
      scomp = Scomp_all
    elif ddd == 'omp':
      lib = WI + 'lib/libwave_omp_debug.a'
      libm = WI + 'lib/libwave_omp_modules_debug.a'
      scomp = Scomp_omp
    elif ddd == 'urad':
      lib = WI + 'lib/liburad_debug.a'
      libm = WI + 'lib/liburad_modules_debug.a'
      scomp = Scomp_all  # uradcfft does boundary tricks
    elif ddd == 'user':
      lib = WI + 'lib/libuser_debug.a'
      libm = WI + 'lib/libuser_modules_debug.a'
      scomp = Scomp_omp
    #endif

    try:
      Tlib = os.stat(lib).st_mtime_ns
      if Tlib > Texe: kmain = 1
    except:
      pass
    #endtry
    try:
      Tlib = os.stat(libm).st_mtime_ns
      if Tlib > Texe: kmain = 1
    except:
      pass
    #endtry

    scompmod = "cd " + dd + "/mod && " + scomp
    scomp = "cd " + dd + " && " + scomp

    for f in modfor: # Compile modules

      ff = f[0]
      t = f[1]

      if t < Texe: continue

      if Iverbose > 0: print(ff)

      fo = ff[:-1] + "o"
      fm = ff[:-1] + "mod"

      Flines = open(ds+"mod/"+ff,'r')

      while True:
        l = Flines.readline()
        if not l: break
        sl = l.split()
        if len(sl) == 0: continue
        key = sl[0].lower()
        if key== 'module':
          m = sl[1].lower()
          break
        #endif
      #end while
      Flines.close()

      if Iverbose > 0: print("\nModule:",m)

      scom = scompmod + "-o " + fo + " " + ff
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)

      scom = 'mv ' + dsm + m + ".mod " + dd
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)

      slibm += " " + dsm + fo
      ranlm = 1

      # Search use of module in *.cmn
      for ft in cmn:

        f = ft[0]
        t = ft[1]

        if t < Texe: continue

        Flines = open(ds+f,'r')
        while True:
          l = Flines.readline()
          if Idebug > 1: print(l)
          if not l: break
          #if len(l) < 10: break
          sl = l.split()
          if len(sl) > 1:
            key = sl[0].lower()
            if key== 'use':
              if sl[1].lower() == m:
                scom = 'touch ' + ds+f
                if Iverbose > 0: print("\n",scom,"\n")
                if Idry == 0: os.system(scom)
                break
              #endif
            #endif
          #endif
        #end while
        Flines.close()

      #endfor

      # Search use of module in *.f
      for ft in fort:

        f = ft[0]
        t = ft[1]

        if Idebug > 1: print(f)

        Flines = open(ds+f,'r')
        while True:
          l = Flines.readline()
          if not l: break
          #if len(l) < 10: break
          sl = l.split()
          if len(sl) > 1:
            key = sl[0].lower()
            if key== 'implicit':
              if sl[1].lower() == 'none': break
            elif key== 'use':
              if sl[1].lower() == m:
                scom = 'touch ' + ds+f
                if Iverbose > 0: print("\n",scom,"\n")
                if Idry == 0: os.system(scom)
                break
              #endif
            #endif
          #endif
        #end while
        Flines.close()

      #endfor

    #endfor modfor

    if ranlm:
      scom = 'ar rc ' + libm + " " + slibm
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)
      scom = 'ranlib ' + libm
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)
      ranlm = 0
      slibm = ''
      kmain = 1
    #endif

    # Check *.cmn

    for ft in cmn:

      f = ft[0]
      t = os.stat(ds+f).st_mtime_ns

      if t < Texe: continue

      fcmn = f.split("/")[-1]

      for fft in fort:

        Flines = open(ds+fft[0],'r')
        while True:
          l = Flines.readline()
          if not l: break
          #if len(l) < 10: break
          sl = l.split()
          if len(sl) < 2: continue
          if sl[0][0] == '*' or sl[0][0] == '!' or len(sl[0]) < 7: continue
          key = sl[0].lower()
          if key== 'include':
            if sl[1].lower() == "'" + fcmn + "'" or sl[1].lower() == '"' + fcmn + '"':
              scom = 'touch ' + ds+fft[0]
              if Iverbose > 0: print("\n",scom,"\n")
              if Idry == 0: os.system(scom)
              break
            #endif
          #endif
        #end while
        Flines.close()
      #endfor fort

    #endfor cmn

    # Compile *.f if neccessary

    for ft in fort:

      f = ft[0]
      t = os.stat(ds+f).st_mtime_ns

      if t < Texe: continue

      fo = f[:-1] + "o"

      scom = scomp + "-o " + fo + " " + f
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)

      slib += " " + ds + fo
      ranl = 1

    #endfor

    if ranl:
      scom = 'ar rc ' + lib + " " + slib
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)
      scom = 'ranlib ' + lib
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)
      kmain = 1
      ranl = 0
      slib = ''
    #endif

  #endfor dir

  if kmain:
    scom = WI + "/shell/compile_wave_incl_debug.sh"
    if Iverbose > 0: print("\n",scom,"\n")
    if Idry == 0: os.system(scom)
    if Iverbose >=0: print("\n--- " + WI  + "bin/wave_debug.exe updated ---\n")
  else:
    if Iverbose >=0: print("\n--- No need to update " + WI  + "bin/wave_debug.exe ---\n")
  #endif


#enddef wave_update

wave_update()
+DECK,make_wave_win,T=PYTHON.
*CMZ :          07/11/2023  16.09.41  by  Michael Scheer
*CMZ :  4.01/03 18/05/2023  16.35.28  by  Michael Scheer
*CMZ :  4.01/02 07/05/2023  09.12.43  by  Michael Scheer
*-- Author :    Michael Scheer   17/03/2023

# +PATCH,//WAVE/PYTHON
# +DECK,wave_make,T=PYTHON.

import os
import sys
import platform
import glob

def Quit(*args, delay=0):
  #reakpoint()
  nargs =  len(args)

  text = ''
  for i in range(nargs):
    text += str(args[i]) + " "
  #endif

  if delay > 0:

    if len(text):
      print("\n",text, "\nWaiting",delay," seconds before kill")
      #time.sleep(delay)
    else:
      print("\nWaiting",delay," seconds before kill")
      #time.sleep(delay)
    #endif len(text):

    if platform.system() == 'Windows':
      os.system("sleep " + str(delay) + " && taskkill /F /PID " + str(os.getpid()) + " &")
    else:
      os.system("sleep " + str(delay) + " && kill " + str(os.getpid()) + " &")
    #endif platform.system() == 'Windows'

  elif delay < 0:
    return
  else:
    print("\n",text)
    if platform.system() == 'Windows':
      os.system("taskkill /F /PID " + str(os.getpid()))
    else:
      os.system("kill " + str(os.getpid()))
    #endif platform.system() == 'Windows'

#enddef Quit(text = '', delay=0)

global Iverbose,Idry,Idebug,WI

args=sys.argv; nargs = len(args)

try:
  WI = os.environ['WAVE_INCL_WIN'] + "/"
except:
  WI = ''
  path = args[0].split("/")
  l = len(path)
  if l == 1:
    path = os.getcwd().split("/")
    path.append(args[0])
  elif l == 2:
    path = os.getcwd().split("/")
    pp = args[0].split("/")
    path.append(pp[0])
    path.append(pp[1])
  #endif
  for i in range(len(path)-2):
    WI += path[i] + "/"
  #endfor
  print("\n*** Warning: Shell variable WAVE_INCL_WIN not defined ***")
  print("*** Assuming: ",WI," ***")
  os.system('sleep 3')
#endtry


Iverbose = 0
Idebug = 0
Idry = 0

if nargs > 1:
  try:
    Iverbose = int(args[1])
  except:
    n = '\n'
    print(n)
    print("Usage: python3 " + WI + args[0] + " [verbose level]",n)
    print("To force total recompilation delete ",n,WI + "bin/wave_win32.exe",n)
    Quit()
  #end try
#endif

if nargs > 2: Idebug = int(args[2])

global Wave_tree,Scomp_all,Scomp_omp,Scomp,Texe,Tlib,Scomp_nowarn

fort = "x86_64-w64-mingw32-gfortran-win32 "

Scomp =fort + "-std=legacy -c -O2 -cpp -fbacktrace -ffpe-summary=invalid,zero,overflow -fdec -fd-lines-as-comments -Wno-align-commons -fno-automatic -ffixed-line-length-none -finit-local-zero -funroll-loops "
Scomp_nowarn =fort + "-w -std=legacy -c -O2 -cpp -fbacktrace -ffpe-summary=invalid,zero,overflow -fdec -fd-lines-as-comments -Wno-align-commons -fno-automatic -ffixed-line-length-none -finit-local-zero -funroll-loops "
Scomp_all =fort + "-std=legacy -c -O2 -cpp -fcheck=all -fbacktrace -ffpe-summary=invalid,zero,overflow -fdec -fd-lines-as-comments -Wno-align-commons -fno-automatic -ffixed-line-length-none -finit-local-zero -funroll-loops "
Scomp_omp =fort + "-std=legacy -c -O2 -cpp -finit-local-zero -fcheck=all -fopenmp -fbacktrace -ffpe-summary=invalid,zero,overflow -fdec -fd-lines-as-comments -Wno-align-commons -ffixed-line-length-none -funroll-loops "

def get_wave_tree():

  global WI,Wave_tree,Iverbose,Idry,Idebug,Texe,Tlib

  try:
    Texe = os.stat(WI + '/bin/wave_win32.exe').st_mtime_ns
  except:
    Texe = 0
  #endtry

  top = glob.glob(WI+"/*")

  Wave_tree = []
  #reakpoint()

  for topd in top:

    dd = topd.split("/")[-1]

    if dd == 'cmz' or dd == 'doc' or dd == 'check_system' or dd == 'bin' \
    or dd == 'python' or dd == 'main' or dd == 'lib': continue

    t = os.stat(topd).st_mtime_ns

    modf = glob.glob(topd+"/mod/*.f")

    modfor = []
    for ff in modf:
      f = ff.split("/")[-1]
      tf = os.stat(ff).st_mtime_ns
      modfor.append([f,tf])
    #endfor

    modm = glob.glob(topd+"/*.mod")
    modmod = []
    for ff in modm:
      f = ff.split("/")[-1]
      tf = os.stat(ff).st_mtime_ns
      modmod.append([f,tf])
    #endfor

    cm = glob.glob(topd+"/*.cmn")
    cmn = []
    for ff in cm:
      f = ff.split("/")[-1]
      tf = os.stat(ff).st_mtime_ns
      cmn.append([f,tf])
    #endfor

    ff = glob.glob(topd+"/*.f")
    fort = []
    for fff in ff:
      f = fff.split("/")[-1]
      tf = os.stat(fff).st_mtime_ns
      fort.append([f,tf])
    #endfor

    Wave_tree.append([topd,t,modfor,modmod,cmn,fort])

  #endfor get_wave_tree

#enddef get_wave_tree

def wave_update():

  global WI,Wave_tree,Texe,Scomp_all,Scomp_omp,Scomp,Iverbose,Idry,Idebug,Scomp_nowarn

  kmain = 0

  get_wave_tree()

  for td in Wave_tree:

    dd = td[0]
    ds = dd + "/"
    dsm = dd + "/mod/"
    t = td[1]
    modfor = td[2]
    cmn = td[4]
    fort = td[5]

    scomp = Scomp

    lib = ''
    libm = ''
    ranl = 0
    ranlm = 0
    slibm = ''
    slib = ''

    ddd = dd.split("/")[-1]

    if Iverbose >= 0: print("\nProcessing",dd)
    #reakpoint()

    if ddd == 'mhbook':
      lib = WI + 'lib/libmhbook.a'
      libm = WI + 'lib/libmhbook_modules.a'
    elif ddd == 'mshcern':
      lib = WI + 'lib/libmshcern.a'
      libm = WI + 'lib/libmshcern_modules.a'
      scomp = Scomp_nowarn
    elif ddd == 'mshplt':
      lib = WI + 'lib/libmshplt.a'
      libm = WI + 'lib/libmshplt_modules.a'
    elif ddd == 'nomp':
      lib = WI + 'lib/libwave.a'
      libm = WI + 'lib/libwave_modules.a'
      scomp = Scomp_all
    elif ddd == 'omp':
      lib = WI + 'lib/libwave_omp.a'
      libm = WI + 'lib/libwave_omp_modules.a'
      scomp = Scomp_omp
    elif ddd == 'urad':
      lib = WI + 'lib/liburad.a'
      libm = WI + 'lib/liburad_modules.a'
      scomp = Scomp_all  # uradcfft does boundary tricks
    elif ddd == 'user':
      lib = WI + 'lib/libuser.a'
      libm = WI + 'lib/libuser_modules.a'
      scomp = Scomp_omp
    #endif

    try:
      Tlib = os.stat(lib).st_mtime_ns
      if Tlib > Texe: kmain = 1
    except:
      pass
    #endtry
    try:
      Tlib = os.stat(libm).st_mtime_ns
      if Tlib > Texe: kmain = 1
    except:
      pass
    #endtry

    scompmod = "cd " + dd + "/mod && " + scomp
    scomp = "cd " + dd + " && " + scomp

    for f in modfor: # Compile modules

      ff = f[0]
      t = f[1]

      if t < Texe: continue

      if Iverbose > 0: print(ff)

      fo = ff[:-1] + "o"
      fm = ff[:-1] + "mod"

      Flines = open(ds+"mod/"+ff,'r')

      while True:
        l = Flines.readline()
        if not l: break
        sl = l.split()
        if len(sl) == 0: continue
        key = sl[0].lower()
        if key== 'module':
          m = sl[1].lower()
          break
        #endif
      #end while
      Flines.close()

      if Iverbose > 0: print("\nModule:",m)

      scom = scompmod + "-o " + fo + " " + ff
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)

      scom = 'mv ' + dsm + m + ".mod " + dd
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)

      slibm += " " + dsm + fo
      ranlm = 1

      # Search use of module in *.cmn
      for ft in cmn:

        f = ft[0]
        t = ft[1]

        if t < Texe: continue

        Flines = open(ds+f,'r')
        while True:
          l = Flines.readline()
          if Idebug > 1: print(l)
          if not l: break
          if len(l) < 10: break
          sl = l.split()
          if len(sl) > 1:
            key = sl[0].lower()
            if key== 'use':
              if sl[1].lower() == m:
                scom = 'touch ' + ds+f
                if Iverbose > 0: print("\n",scom,"\n")
                if Idry == 0: os.system(scom)
                break
              #endif
            #endif
          #endif
        #end while
        Flines.close()

      #endfor

      # Search use of module in *.f
      for ft in fort:

        f = ft[0]
        t = ft[1]

        if Idebug > 1: print(f)

        Flines = open(ds+f,'r')
        while True:
          l = Flines.readline()
          if not l: break
          if len(l) < 10: break
          sl = l.split()
          if len(sl) > 1:
            key = sl[0].lower()
            if key== 'implicit':
              if sl[1].lower() == 'none': break
            elif key== 'use':
              if sl[1].lower() == m:
                scom = 'touch ' + ds+f
                if Iverbose > 0: print("\n",scom,"\n")
                if Idry == 0: os.system(scom)
                break
              #endif
            #endif
          #endif
        #end while
        Flines.close()

      #endfor

    #endfor modfor

    if ranlm:
      scom = 'ar rc ' + libm + " " + slibm
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)
      scom = 'ranlib ' + libm
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)
      ranlm = 0
      slibm = ''
      kmain = 1
    #endif

    # Check *.cmn

    for ft in cmn:

      f = ft[0]
      t = os.stat(ds+f).st_mtime_ns

      if t < Texe: continue

      fcmn = f.split("/")[-1]

      for fft in fort:

        Flines = open(ds+fft[0],'r')
        while True:
          l = Flines.readline()
          if not l: break
          if len(l) < 10: break
          sl = l.split()
          if sl[0][0] == '*' or sl[0][0] == '!' or len(sl) < 6: continue
          key = sl[0].lower()
          if key== 'include':
            if sl[1].lower() == "'" + fcmn + "'" or sl[1].lower() == '"' + fcmn + '"':
              scom = 'touch ' + ds+fft[0]
              if Iverbose > 0: print("\n",scom,"\n")
              if Idry == 0: os.system(scom)
              break
            #endif
          #endif
        #end while
        Flines.close()
      #endfor fort

    #endfor cmn

    # Compile *.f if neccessary

    for ft in fort:

      f = ft[0]
      t = os.stat(ds+f).st_mtime_ns

      if t < Texe: continue

      fo = f[:-1] + "o"

      scom = scomp + "-o " + fo + " " + f
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)

      slib += " " + ds + fo
      ranl = 1

    #endfor

    if ranl:
      scom = 'ar rc ' + lib + " " + slib
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)
      scom = 'ranlib ' + lib
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)
      kmain = 1
      ranl = 0
      slib = ''
    #endif

  #endfor dir

  if kmain:
    scom = WI + "/shell/compile_wave_incl_cross_win32.sh"
    if Iverbose > 0: print("\n",scom,"\n")
    if Idry == 0: os.system(scom)
    if Iverbose >=0: print("\n--- " + WI  + "bin/wave_win32.exe updated ---\n")
  else:
    if Iverbose >=0: print("\n--- No need to update " + WI  + "bin/wave_win32.exe ---\n")
  #endif


#enddef wave_update

wave_update()
+DECK,msh_ipylogon_neu,T=PYTHON.
*CMZ :          08/11/2023  10.45.27  by  Michael Scheer
*-- Author :    Michael Scheer   08/11/2023
# +PATCH,//WAVE/PYTHON
# +DECK,msh_ipylogon_neu,T=PYTHON.

print("\n--- wave msh_pylogon.py ---\n")
#plt.style.use('seaborn-dark')

import sys,os

args=sys.argv; nargs = len(args)
pwd = os.getcwd()

import m_hbook as m
from m_hbook import *
from numpy import *

args=sys.argv; nargs = len(args)
seed(0)

NL = '\n'
BL = ' '

ntuples = 0
histos = 1

global Irunmin,Irunmax

def get_phase_error(run):
  Fout = open("a/wave.out." + run,"r")
  fout = Fout.readlines()
  ifound = 0
  for line in fout:
    if ifound:
      phwav = float(line.split()[0])
      phdeg = float(line.split()[1])
      Fout.close()
      return phwav,phdeg
    #endif
    if re.search('deg.\)',line):
      ifound = 1
    #endif
  #endfor
#enddef

def ns0peak(nt):

  iemax = -1
  emax = 0.0
  s0max = -1.0

  res = npeaks(nt,"e:s0/1.0e6",isilent=1,iretval=1)

  try:
    s0list = res[2]
    s0max = 0.0
    for i in range(len(s0list)):
      s0 = s0list[i]
      if s0 > s0max:
        s0max = s0
        is0 = i
      #endif
    #endfor
    iemax = res[0][i]
    emax = res[1][i]
  except:
    print("*** Warning in ns0peak: Bad return from npeaks ***\n")
#    ninfo(nt)
#    Quit("\n*** Aborted in ns0peak(nt)")
  #endtry
  return iemax,emax,s0max
#enddef

def phase_error( key = "stokes", \
fs0="wave_stokes_selected.dat",\
fs0f="wave_stokesf_selected.dat", \
fs0e="wave_stokese_selected.dat", \
fs0ef="wave_stokesef_selected.dat", \
fs0ref="/home/scheer/spectra/wav/a/wave_halbach_pencil_on-axis.dat.1060", \
fs0reff="/home/scheer/spectra/wav/a/wave_halbach_emit_on-axis.dat.949", \
fs0refe="/home/scheer/spectra/wav/a/wave_halbach_espread_on-axis.dat.950", \
fs0refef="/home/scheer/spectra/wav/a/wave_halbach_emit_espread_on-axis.dat.951", \
fall="SRI22_phase-errors.dat"
):

#fs0ref="/home/scheer/spectra/wav/a/wave_halbach_pencil_on-axis.dat.476", \
#fs0reff="/home/scheer/spectra/wav/a/wave_halbach_emit_on-axis.dat.477", \
#fs0refe="/home/scheer/spectra/wav/a/wave_halbach_espread_on-axis.dat.478", \
#fs0refef="/home/scheer/spectra/wav/a/wave_halbach_emit_espread_on-axis.dat.479", \

  global Nhead,Ntup,Nind,Nntup,Irunmin,Irunmax

  nl = "\n"
  print("Ref:",nl,fs0ref,nl,fs0refe,nl,fs0reff,nl,fs0refef,nl)
  print(key,nl,fs0,nl,fs0e,nl,fs0f,nl,fs0ef)

  Irunmin = 1e20
  Irunmax = -1e20

  iruns0 = 0
  iruns0e = 0
  iruns0f = 0
  iruns0ef = 0
  iruns0ref = 0

  vs0ene = None
  vs0 = None
  vs0f = None
  vs0e = None
  vs0ef = None

  optnstat()

  if nexist("ns0"): ndelete("ns0")
  if nexist("ns0e"): ndelete("ns0e")
  if nexist("ns0f"): ndelete("ns0f")
  if nexist("ns0ef"): ndelete("ns0ef")

  if nexist("ns0ref"): ndelete("ns0ref")
  if nexist("ns0refe"): ndelete("ns0refe")
  if nexist("ns0reff"): ndelete("ns0reff")
  if nexist("ns0refef"): ndelete("ns0refef")

  ns0ref = ncread("ns0ref","e:s0:s1:s2:s3",fs0ref,silent=1,skiphead=2)
  iemaxr,emaxr,s0ref = ns0peak(ns0ref)
  vs0refene = ns0ref['e']
  vs0ref = ns0ref['s0']/1.e6
  nener = len(vs0ref)

  ns0reff = ncread("ns0reff","e:s0:s1:s2:s3",fs0reff,silent=1,skiphead=2)
  iemaxrf,emaxrf,s0reff = ns0peak(ns0reff)
  vs0refenef = ns0reff['e']
  vs0reff = ns0reff['s0']/1.e6

  ns0refe = ncread("ns0refe","e:s0:s1:s2:s3",fs0refe,silent=1,skiphead=2)
  iemaxre,emaxre,s0refe = ns0peak(ns0refe)
  vs0refenee = ns0refe['e']
  vs0refe = ns0refe['s0']/1.e6

  ns0refef = ncread("ns0refef","e:s0:s1:s2:s3",fs0refef,silent=1,skiphead=2)
  iemaxref,emaxref,s0refef = ns0peak(ns0refef)
  vs0refeneef = ns0refef['e']
  vs0refef = ns0refef['s0']/1.e6

  phwav = -9999.
  phdeg = -9999.

  try:
    F = open(fs0,"r")
    runs0 = F.readline().strip().split()[0].strip()
    F.close()
    iruns0 = int(runs0)
    phwav,phdeg = get_phase_error(runs0)
    if iruns0 < Irunmin: Irunmin = iruns0
    if iruns0 > Irunmax: Irunmax = iruns0
    ns0 = ncread("ns0","e:s0:s1:s2:s3",fs0,silent=1,skiphead=2)
    if len(ns0) != nener: print("\n*** Warning: Strange number of energies for ns0 ***")
  except:
    print("*** File",fs0,"not found ***")
    Quit("Schlecht")
    return iruns0,iruns0e,iruns0f,iruns0ef,iruns0ef
  #endtry

  try:
    F = open(fs0e,"r")
    runs0e = F.readline().strip().split()[0].strip()
    F.close()
    iruns0e = int(runs0e)
    if iruns0e < Irunmin: Irunmin = iruns0e
    if iruns0e > Irunmax: Irunmax = iruns0e
    ns0e = ncread("ns0e","e:s0:s1:s2:s3",fs0e,silent=1,skiphead=2)
    if len(ns0e) != nener: print("\n*** Warning: Strange number of energies for ns0e ***")
  except: pass

  try:
    F = open(fs0f,"r")
    runs0f = F.readline().strip().split()[0].strip()
    F.close()
    iruns0f = int(runs0f)
    if iruns0f < Irunmin: Irunmin = iruns0f
    if iruns0f > Irunmax: Irunmax = iruns0f
    ns0f = ncread("ns0f","e:s0:s1:s2:s3",fs0f,silent=1,skiphead=2)
    if len(ns0f) != nener: print("\n*** Warning: Strange number of energies for ns0f ***")
  except: pass

  try:
    F = open(fs0ef,"r")
    runs0ef = F.readline().strip().split()[0].strip()
    iruns0ef = int(runs0ef)
    F.close()
    if iruns0ef < Irunmin: Irunmin = iruns0ef
    if iruns0ef > Irunmax: Irunmax = iruns0ef
    ns0ef = ncread("ns0ef","e:s0:s1:s2:s3",fs0ef,silent=1,skiphead=2)
    if len(ns0ef) != nener: print("\n*** Warning: Strange number of energies for ns0ef ***")
  except: pass

  nplc(ns0,"e:s0/1.0e6")

  iemax,emax,s0max = ns0peak(ns0)
  if iemax < 0: s0max = -1.

  vs0ene = ns0['e']
  vs0 = ns0['s0']/1.e6
  vs0e = vs0 * 0.0
  vs0f = vs0 * 0.0
  vs0ef = vs0 * 0.0

  eharmf = 0.0
  eharme = 0.0
  eharmef = 0.0
  s0harmf  =  1.0
  s0harme  =  1.0
  s0harmef =  1.0

  legend("S0max, rref   " + g3(s0max) + "   " + g5(s0max/s0ref))

  cruns = str(Irunmin) + "-" + str(Irunmax)
  tit = "On-axis flux-density for " + key + " (Runs " + cruns + ")"
  txyz(tit,"E$_{ph}$ [eV]","N$_{ph}$/s/mm$^{2}$/100mA/0.1%BW")

  Fred = open("a/real_beam_" + key.strip() + "_" + cruns + ".dat","w")

  print("\nS0ref:   " + g5(s0ref))
  print("S0max:   " + g5(s0max) + "   " + g5(s0max/s0ref))
  Fred.write("S0ref: " + g5(s0ref) + "\n")
  Fred.write("S0max: " + g5(s0max) + "   " + g5(s0max/s0max)  + "   " + g5(s0max/s0ref) + "\n")

  if nexist("ns0f"):
    optnstat()
    nplcgs(ns0f,"e:s0/1.0e6")
    iemaxf,emaxf,s0maxf = ns0peak(ns0f)
    if iemax > 0:
      s0harmf = ns0f.s0[iemax]/1.e6
      eharmf = ns0f.e[iemax]
    vs0enef = ns0f['e']
    vs0f = ns0f['s0']/1.e6
    rdf = s0maxf/s0max
    rdhf = s0harmf/s0max
    line1 = "S0max_f,  Emax_f, rdf  : " + g3(s0maxf)  + BL + g5(emaxf)  \
    + BL + g3(rdf)
    line2 = "S0harm_f, Emax_p,  rdhf : " + g3(s0harmf) + BL + g5(eharmf) \
    + BL + g3(rdhf)
    legend(line1 + "\n" + line2 + "   " + g5(s0max/s0ref))
    print("\n" + line1 + "\n" + line2 + "   " + g5(s0max/s0ref))
    Fred.write("\n" + line1 + "\n" + line2 + "\n")
  #endif

  if nexist("ns0e"):
    optnstat()
    nplcbs(ns0e,"e:s0/1.0e6")
    iemaxe,emaxe,s0maxe = ns0peak(ns0e)
    if iemax > 0:
      s0harme = ns0e.s0[iemax]/1.e6
      eharme = ns0e.e[iemax]
    vs0enee = ns0e['e']
    vs0e = ns0e['s0']/1.e6
    rde = s0maxe/s0max
    rdhe = s0harme/s0max
    line1 = "S0max_e,  Emax_e, rde  : " + g3(s0maxe)  + BL + g5(emaxe)  \
    + BL + g3(rde)
    line2 = "S0harm_e, Emax_p,  rdhe : " + g3(s0harme) + BL + g5(eharme) \
    + BL + g3(rdhe)
    legend(line1 + "\n" + line2 + "   " + g5(s0max/s0ref))
    print("\n" + line1 + "\n" + line2 + "   " + g5(s0max/s0ref))
    Fred.write("\n" + line1 + "\n" + line2 + "\n")
  #endif

  if nexist("ns0ef"):
    optnstat()
    nplccs(ns0ef,"e:s0/1.0e6")
    iemaxef,emaxef,s0maxef = ns0peak(ns0ef)
    if iemax > 0:
      s0harmef = ns0ef.s0[iemax]/1.e6
      eharmef = ns0ef.e[iemax]
    vs0eneef = ns0ef['e']
    vs0ef = ns0ef['s0']/1.e6
    rdef = s0maxef/s0max
    rdhef = s0harmef/s0max
    line1 = "S0max_ef,  Emax_ef, rdef  : " + g3(s0maxef)  + BL + g5(emaxef)  \
    + BL + g3(rdef)
    line2 = "S0harm_ef, Emax_p,  rdhef : " + g3(s0harmef) + BL + g5(eharmef) \
    + BL + g3(rdhef)
    legend(line1 + "\n" + line2 + "   " + g5(s0max/s0ref))
    print("\n" + line1 + "\n" + line2 + "   " + g5(s0max/s0ref))
    Fred.write("\n" + line1 + "\n" + line2 + "\n")
  #endif

  Fred.close()

  pp("a/real_beam_" + key.strip() + "_" + cruns + ".pdf")
  legend()
  pp("a/real_beam_" + key.strip() + "_" + cruns + "_legend.pdf")

  nsig = nget("nsig")

  Fall = open(fall,"a")

  s0maxp =s0max
  s0refp =s0ref

  ksig = int(key.split("_")[1]) - 1
  phsig = nsig.phsig[ksig]

  #  Type beam  run  S0p  S0_pen S0H_pen S0H S0p/S0_pen S0p/S0H_pen S0p/S0H
  res = key + " pencil  " + runs0 + BL + g5(phsig) + BL + g5(phwav)  + BL + g5(phdeg) + BL \
  + g5(s0maxp) + BL + g5(s0maxp) + BL \
  + g5(s0refp) + BL + g5(s0refp) + BL \
  + g5(s0maxp/s0maxp) + BL + g5(s0maxp/s0refp) + BL + g5(s0maxp/s0refp)

  print(res)
  Fall.write(res+nl)

  #  Type beam  run  S0f  S0_pen S0H_en S0H S0f/S0_pen S0f/S0H_pen S0f/S0H
  res = key + " emit    " + runs0f + BL + g5(phsig) + BL + g5(phwav)  + BL + g5(phdeg) + BL \
  + g5(s0maxf) + BL + g5(s0maxp) + BL \
  + g5(s0refp) + BL + g5(s0reff) + BL \
  + g5(s0maxf/s0maxp) + BL + g5(s0maxf/s0refp) + BL + g5(s0maxf/s0reff)

  print(res)
  Fall.write(res+nl)

  #  Type beam  run  S0e  S0_pen S0H_pen S0H S0e/S0_pen S0e/S0H_pen S0e/S0H
  res = key + " espread " + runs0e + BL + g5(phsig) + BL + g5(phwav)  + BL + g5(phdeg) + BL \
  + g5(s0maxe) + BL + g5(s0maxp) + BL \
  + g5(s0refp) + BL + g5(s0refe) + BL \
  + g5(s0maxe/s0maxp) + BL + g5(s0maxe/s0refp) + BL + g5(s0maxe/s0refe)

  print(res)
  Fall.write(res+nl)

  #  Type beam  run  S0ef  S0_pen S0H_pen S0H S0ef/S0_pen S0ef/S0H_pen S0ef/S0H
  res = key + " em+esp  " + runs0ef + BL + g5(phsig) + BL + g5(phwav)  + BL + g5(phdeg) + BL \
  + g5(s0maxef) + BL + g5(s0maxp) + BL \
  + g5(s0refp) + BL + g5(s0refef) + BL \
  + g5(s0maxef/s0maxp) + BL + g5(s0maxef/s0refp) + BL + g5(s0maxef/s0refef)

  print(res)

  Fall.write(res+nl)

  Fall.close()

  optnstat()

  return vs0ene,vs0,vs0f,vs0e,vs0ef

#enddef

if args[1] == "last":
  try:
    Farg = open("ipylogon.arg","r")
    argl = Farg.readlines()
    Farg.close()
    args = []
    for arg in argl: args.append(arg.strip())
    #print(args[1:])
  except: pass
#endif

if not args[1] == "last" and nargs > 1:
  Farg = open("ipylogon.arg","w")
  for arg in args: Farg.write(arg + "\n")
  Farg.close()
#endif

if nargs > 1:

  if args[1] == "last":
    try:
      Farg = open("ipylogon.arg","r")
      argl = Farg.readlines()
      Farg.close()
      args = []
      for arg in argl: args.append(arg.strip())
      #print(args[1:])
    except: pass
  #endif

  if not args[1] == "last" and nargs > 1:
    Farg = open("ipylogon.arg","w")
    for arg in args: Farg.write(arg + "\n")
    Farg.close()
  #endif

  if args[1] == "none":

    pass

  elif args[1] == "default":

    idefault = 0

    if idefault == 1:

      nphi = 6
      rin = 10.0000
      rout = 20.
      h = 50.
      dphi = 180.
      xcen = 0.0
      ycen = 0.
      zcen = 0.0

      ncyl = ncylinder('ncyl_1',
                       xcen,ycen,zcen,rout-rin,rin,rin,h,0.0,90.,dphi,nphi,1)

      #nc = ncylinder(phi=90,dphi=dphi,n=nphi)
      poly = plotncylinder(ncyl)

  elif args[1] == "hull3d":

    n=ncread("n","x:y:z","hull.dat")
    vert,ifaces,faces,bounds = hull3d(n.x,n.y,n.z)

    iplot = 4

    if iplot == 1: vplothull3d(n.x,n.y.n.z)
    elif iplot == 2: vplothull3d(n.x,n.y,n.z,mode='volume')
    elif iplot == 3:vert,ifaces,faces,bounds=nhull3d(n,"x:y:z",iretval=1)
    elif iplot == 3:vert,ifaces,faces,bounds=nhull3d(n,"x:y:z",iretval=1)
    elif iplot == 4: plotfaces(faces)

  elif args[1] == "look":

    if nargs > 2: fdat = args[2]
    else: fdat = 'look.dat'
    Nlook = nlook("Nlook",fdat)
    # consider mlook(fdat) to get m.Nlook

  elif args[1] == "gui":

    import waveplot as w
    from waveplot import *
    set_console_title("wavesPython")
    optconsole()

  elif args[1] == "old":

    import old as w
    from old import *
    set_console_title("wavesPython")
    optconsole()

  elif args[1] == "urad":

    import waveplot as w
    from waveplot import *

    set_console_title("Plot urad_phase")
    optconsole()

    fnam = open("urad_phase.nam","r")
    flines = fnam.readlines()
    fnam.close()

    fpin = open("urad_phase.pin",'r')
    pin = fpin.readline().strip().split()
    pincen = fpin.readline().strip().split()
    fpin.close()

    npinz = int(pin[0])
    npiny = int(pin[1])
    pinw = float(pin[2])
    pinh = float(pin[3])

    pinx = float(pincen[0])
    piny = float(pincen[1])
    pinz = float(pincen[2])

    ymin = piny - pinh/2.
    ymax = piny + pinh/2.

    zmin = pinz - pinw/2.
    zmax = pinz + pinw/2.

    if npiny > 1:
      dy = (ymax-ymin)/(npiny-1)
    else:
      dy = pinh
    #endif

    if npinz > 1:
      dz = (zmax-zmin)/(npinz-1)
    else:
      dz = pinw
    #endif

    nfld = ncread("nfld","x:y:z:iegam:egam:s0:s1:s2:s3:p:exr:exi:eyr:eyi:ezr:ezi:bxr:bxi:byr:byi:bzr:bzi:nx:ny:nz","urad_phase.fld")
    nbun = ncread("nbun","jbun:isub:ibu:bunchx:rxi1:ryi1:rzi1:ypi1:zpi1:rxin:ryin:rzin:ypin:zpin:eel:deel:x:y:z:iegam:egam:spec:s0:s1:s2:s3:p:fb28:dt:axr:axi:ayr:ayr:azr:azi","urad_phase.bun")

    s0max = nfld.s0.max()
    s3max = nfld.s3.max()
    print(pg5(s0max))
    #if not isnan(s0max): kplot = 1

    if nargs > 2:

      if args[2] == 's0pin':

        s0max = nfld.s0.max()
        emax = nfld.query("s0=="+str(s0max)).egam.max()
        selgam = "abs(egam-" + str(emax) + ")<1.0e-10"

        if npinz > 1 and npiny > 1:
          hbook2('Hpin','distribution in pinhole',npinz,zmin,zmax,npiny,ymin,ymax)
          nproj2(nfld,"z:y","s0",selgam,idh='Hpin',ioverwrite=0)
        elif npinz > 1:
          hbook1('Hpin','distribution in pinhole',npinz,zmin,zmax)
          nproj1(nfld,"z","s0",selgam,idh='Hpin',ioverwrite=0)
        elif npiny > 1:
          hbook1('Hpin','distribution in pinhole',npiny,ymin,ymax)
          nproj1(nfld,"y","s0",selgam,idh='Hpin',ioverwrite=0)
        elif len(nbun) > 0:
          hbook2('Hpin','distribution in pinhole',npinz,zmin,zmax,npiny,ymin,ymax)
          nproj2( nbun,"z:y","s0",selgam,idh='Hpin',ioverwrite=0)
        #endif

        hplave('Hpin')
        txyz("nfld,z:y:fd (" + selgam +")")

      #endif

    else:

      kplot = 1

      #nsto = ncread("nsto","x:y:z:iegam:egam:s0:s1:s2:s3","urad_phase.sto")
      nflx = ncread("nflx","iegam:egam:s0:s1:s2:s3","urad_phase.flx")
      nfld = ncread("nfld","x:y:z:iegam:egam:s0:s1:s2:s3:p:exr:exi:eyr:eyi:ezr:ezi:bxr:bxi:byr:byi:bzr:bzi:nx:ny:nz","urad_phase.fld")
      nbun = ncread("nbun","jbun:isub:ibu:bunchx:rxi1:ryi1:rzi1:ypi1:zpi1:rxin:ryin:rzin:ypin:zpin:eel:deel:x:y:z:iegam:egam:spec:s0:s1:s2:s3:p:fb28:dt:axr:axi:ayr:ayr:azr:azi","urad_phase.bun")

      #ninfo(nsto)
      #ninfo(nfld)
      #ninfo(nflx)
      #ninfo(nbun)
      #Quit(pg5(nfld.s0.max()))

      if kplot == 2:
        npll(nfld,"egam:s0")
        setxstat(0.8)
        npllgs(nfld,"egam:s3")
        #nplmgs(nbun,"egam:s0","egam>0")
      #endif

      if kplot == 1:

        s0max = nfld.s0.max()
        emax = nfld.query("s0=="+str(s0max)).egam.max()
        selgam = "abs(egam-" + str(emax) + ")<1.0e-10"

        if npinz > 1 and npiny > 1:
          hbook2('Hpin','distribution in pinhole',npinz,zmin,zmax,npiny,ymin,ymax)
          nproj2(nfld,"z:y","s0",selgam,idh='Hpin',ioverwrite=0)
        elif npinz > 1:
          hbook1('Hpin','distribution in pinhole',npinz,zmin,zmax)
          nproj1(nfld,"z","s0",selgam,idh='Hpin',ioverwrite=0)
        elif npiny > 1:
          hbook1('Hpin','distribution in pinhole',npiny,ymin,ymax)
          nproj1(nfld,"y","s0",selgam,idh='Hpin',ioverwrite=0)
        elif len(nbun) > 0:
          hbook2('Hpin','distribution in pinhole',npinz,zmin,zmax,npiny,ymin,ymax)
          nproj2( nbun,"z:y","s0",selgam,idh='Hpin',ioverwrite=0)
        #endif

        if nfld.iegam.max() == 1:
          if npinz > 1 and npiny > 1:
            hbook2('HpinEzR','Ez_real in pinhole',npinz,zmin,zmax,npiny,ymin,ymax)
            nproj2(nfld,"z:y","ezr",selgam,idh='HpinEzR',ioverwrite=0)
          elif npinz > 1:
            hbook1('HpinEzR','Ez_real in pinhole',npinz,zmin,zmax)
            nproj1(nfld,"z","ezr",selgam,idh='HpinEzR',ioverwrite=0)
          elif npiny > 1:
            hbook1('HpinEzR','Ez_real in pinhole',npiny,ymin,ymax)
            nproj1(nfld,"y","ezr",selgam,idh='HpinEzR',ioverwrite=0)
          elif len(nbun) > 0:
            hbook2('HpinEzR','Ez_real in pinhole',npinz,zmin,zmax,npiny,ymin,ymax)
            nproj2( nbun,"z:y","ezr",selgam,idh='HpinEzR',ioverwrite=0)
          #endif
          if npinz > 1 and npiny > 1:
            hbook2('HpinEyR','Ey_real in pinhole',npinz,zmin,zmax,npiny,ymin,ymax)
            nproj2(nfld,"z:y","eyr",selgam,idh='HpinEyR',ioverwrite=0)
          elif npinz > 1:
            hbook1('HpinEyR','Ey_real in pinhole',npinz,zmin,zmax)
            nproj1(nfld,"z","eyr",selgam,idh='HpinEyR',ioverwrite=0)
          elif npiny > 1:
            hbook1('HpinEyR','Ey_real in pinhole',npiny,ymin,ymax)
            nproj1(nfld,"y","eyr",selgam,idh='HpinEyR',ioverwrite=0)
          elif len(nbun) > 0:
            hbook2('HpinEyR','Ey_real in pinhole',npinz,zmin,zmax,npiny,ymin,ymax)
            nproj2( nbun,"z:y","eyr",selgam,idh='HpinEyR',ioverwrite=0)
          #endif
        #endif

        print("\n","Eg:",emax, " eV")

        if kplot > 0 and npinz*npiny > 1:
          if nfld.iegam.max() > 1:
            zone(2,2)
            nprof(nfld,"egam:s0")
            txyz('nsto,"egam:s0"')
            nextzone()
            npl(nfld,"egam:s0","abs(y)<1.0e-6 and abs(z)<1.0e-6")
            txyz('nsto,"egam:s0","abs(y)<1.0e-6 and abs(z)<1.0e-6"')
            nextzone()
            npl(nflx,"egam:s0")
            txyz("nflx,'egam:s0'")
            nextzone()
            hplave('Hpin')
            txyz("nfld,z:y:fd (" + selgam +")")
          else:
            zone(2,1)
            hplave('HpinEzR')
            txyz("Ez_Real")
            nextzone()
            hplave('HpinEyR')
            txyz("Ey_Real")
            #            nextzone()
            #            hplave('Hpin')
            #            txyz("Flux_dens.")
          #endif
        elif kplot > 0:
          if len(nbun):
            optnstat()
            npl(nbun,"egam:s0",plopt='prof')
            optstat()
            nplmgs(nbun,"egam:s0","ibu==1")
          else:
            npl(nfld,"egam:s0")
          #endif
        #endif

      #endif kplot > 0

    #endif nargs > 2

  elif args[1] == "overview" or args[1] == "over" or args[1] == "ov":
    if os.path.exists("WAVE.mhb"):
      import waveplot as w
      from waveplot import *
      WaveOverview()
    #endif os.path.exists("WAVE.mhb"):

  elif args[1] == "ndistpin" or args[1] == "pin":

    if os.path.exists("WAVE.mhb"):
      import waveplot as w
      from waveplot import *
      ndistpin()
    #endif os.path.exists("WAVE.mhb"):

  elif args[1] == "ndistpinv" or args[1] == "pinv" or args[1] == "vcut":

    if os.path.exists("WAVE.mhb"):
      import waveplot as w
      from waveplot import *
      ndistpinv()
    #endif os.path.exists("WAVE.mhb"):

  elif args[1] == "ndistpinh" or args[1] == "pinh" or args[1] == "hcut":

    if os.path.exists("WAVE.mhb"):
      import waveplot as w
      from waveplot import *
      ndistpinh()
    #endif os.path.exists("WAVE.mhb"):

  elif args[1] == "serie":

    #if os.path.exists("WAVE.mhb"):

    #import waveplot as w
    #from waveplot import *

    fil = "wave_serie_pencil_selected.dat"
    F = open(fil,"r")
    runs0 = F.readline().strip().split()[0].strip()
    ns0 = ncread("ns0","e:s0:s1:s2:s3",fil,silent=1,skiphead=2)
    F.close()

    fil = "wave_serie_espread_selected.dat"
    F = open(fil,"r")
    runs0e = F.readline().strip().split()[0].strip()
    ns0e = ncread("ns0e","e:s0:s1:s2:s3",fil,silent=1,skiphead=2)
    F.close()

    fil = "wave_serie_emit_selected.dat"
    F = open(fil,"r")
    runs0f = F.readline().strip().split()[0].strip()
    ns0f = ncread("ns0f","e:s0:s1:s2:s3",fil,silent=1,skiphead=2)
    F.close()

    fil = "wave_serie_emit_espread_selected.dat"
    F = open(fil,"r")
    runs0ef = F.readline().strip().split()[0].strip()
    ns0ef = ncread("ns0ef","e:s0:s1:s2:s3",fil,silent=1,skiphead=2)
    F.close()

    optnstat()

    nplc(ns0,"e:s0/1.0e6")
    #s0max = ns0.s0.max()/1.0e6
    iemax,emax,s0max = ns0peak(ns0)

    legend("S0,      " + g3(s0max))

    tit = "Ideal Undulator, Real Beam, (" + runs0 + "-" + runs0ef + ")"
    txyz(tit,"E$_{ph}$ [eV]","N$_{ph}$/s/mm$^{2}$/100mA/0.1%BW")

    Fred = open("real_beam_serie_selected.dat","w")

    print("S0max:   " + g5(s0max))
    Fred.write("S0max: " + g5(s0max) + "\n")

    if nexist("ns0e"):
      nplcbs(ns0e,"e:s0/1.0e6")
      iemaxe,emaxe,s0maxe = ns0peak(ns0e)
      if iemax > 0: s0harme = ns0e.s0[iemax]/1.e6
      rde = s0maxe/s0max
      rdhe = s0harme/s0max
      line1 = "S0max_e, rde  : " + g3(s0maxe) + BL + g3(rde)
      line2 = "S0harm_e, rdhe: " + g3(s0harme) + BL + g3(rdhe)
      legend(line1 + "\n" + line2)
      print("\n" + line1 + "\n" + line2)
      Fred.write("\n" + line1 + "\n" + line2 + "\n")
    #endif

    if nexist("ns0f"):
      nplcgs(ns0f,"e:s0/1.0e6")
      iemaxf,emaxf,s0maxf = ns0peak(ns0f)
      if iemax > 0: s0harmf = ns0f.s0[iemax]/1.e6
      rdf = s0maxf/s0max
      rdhf = s0harmf/s0max
      line1 = "S0max_f, rdf  : " + g3(s0maxf) + BL + g3(rdf)
      line2 = "S0harm_f, rdhf: " + g3(s0harmf) + BL + g3(rdhf)
      legend(line1 + "\n" + line2)
      print("\n" + line1 + "\n" + line2)
      Fred.write("\n" + line1 + "\n" + line2 + "\n")
    #endif

    if nexist("ns0ef"):
      nplccs(ns0ef,"e:s0/1.0e6")
      iemaxef,emaxef,s0maxef = ns0peak(ns0ef)
      if iemax > 0: s0harmef = ns0ef.s0[iemax]/1.e6
      rdef = s0maxef/s0max
      rdhef = s0harmef/s0max
      line1 = "S0max_ef, rdef  : " + g3(s0maxef) + BL + g3(rdef)
      line2 = "S0harm_ef, rdhef: " + g3(s0harmef) + BL + g3(rdhef)
      legend(line1 + "\n" + line2)
      print("\n" + line1 + "\n" + line2)
      Fred.write("\n" + line1 + "\n" + line2 + "\n")
    #endif

    legend()
    Fred.close()

    pp("real_beam_serie_selected.pdf")

  elif args[1] == "ErnteAlt" or args[1] == "EA" :

    fall = "SRI22_phase-errors_Johannes.dat"
    nph = ncread("nph","key:beam:run:phsig:phwav:phdeg:s0:s0p:s0hp:s0h:rdp:rdhp:rdb",fall)

    ninfo(nph)

    optnstat()

    for btype in ['emit','espread','em+esp']:

      circ()
      phpl = "phsig:s0/s0hp"
      npl(nph,phpl,"beam=='pencil' and key=='bend_01'",legend='bend, single e-')
      nplmbs(nph,phpl,"beam=='pencil' and key=='cos_01'",legend='cos, single e-')
      nplmgs(nph,phpl,"beam=='pencil' and key=='sin_01'",legend='sin, single e-')
      nplmcs(nph,phpl,"beam=='pencil' and key=='taper_01'",legend='taper, single e-')

      bull()
      phpl = "phsig:rdb"
      sel = "beam=='" + btype + "' and key=='bend_01'"

      nplmrs(nph,phpl,sel + " and key=='bend_01'",legend='bend, beam')
      nplmbs(nph,phpl,sel + " and key=='cos_01'",legend='cos, beam')
      nplmgs(nph,phpl,sel + " and key=='sin_01'",legend='sin, beam')
      nplmcs(nph,phpl,sel + " and key=='taper_01'",legend='taper, beam')
      legend()
      txyz("Effect of Field Errors (" + btype + ")","phase error","Normalized of flux-density")

      for key in ['bend','cos','sin','taper']:
        for beam in ['pencil',btype]:

          bull()
          if beam == 'pencil': circle()

          for n in range(1,14):

            phpl = "phsig:rdb"
            if beam == 'pencil': phpl = "phsig:s0p/s0hp"

            if n < 10: keyn = key + "_0" + str(n)
            else: keyn = key + "_" + str(n)

            sel = "beam=='" + beam + "'  and key=='" + keyn + "'"

            if key == 'bend':
              nplmrs(nph,phpl,sel)
            elif key == 'cos':
              nplmbs(nph,phpl,sel)
            elif key == 'sin':
              nplmgs(nph,phpl,sel)
            elif key == 'taper':
              nplmcs(nph,phpl,sel)
            #endif

          #endfor
        #endfor
      #endfor

      fs = fall.split(".")
      fpdf = ""
      for f in fs[:-1]: fpdf += f

      pp(fpdf+"_"+btype+".pdf")
      pp(fpdf+"_"+btype+".png")

    #endfor

  elif args[1] == "Ernte" or args[1] == "E" :

    fall = "SRI22_phase-errors_Johannes.dat"
    nph = ncread("nph","key:beam:run:phsig:phwav:phdeg:s0:s0p:s0hp:s0h:rdp:rdhp:rdb",fall)

    ninfo(nph)

    optnstat()

    for btype in ['emit','espread','em+esp']:

      circ()
      phpl = "phwav*7.:s0/s0hp"
      npl(nph,phpl,"beam=='pencil' and key=='bend_01'",legend='bend, single e-')
      nplmbs(nph,phpl,"beam=='pencil' and key=='cos_01'",legend='cos, single e-')
      nplmgs(nph,phpl,"beam=='pencil' and key=='sin_01'",legend='sin, single e-')
      nplmcs(nph,phpl,"beam=='pencil' and key=='taper_01'",legend='taper, single e-')

      bull()
      phpl = "phwav*7.:rdb"
      sel = "beam=='" + btype + "' and key=='bend_01'"

      nplmrs(nph,phpl,sel + " and key=='bend_01'",legend='bend, beam')
      nplmbs(nph,phpl,sel + " and key=='cos_01'",legend='cos, beam')
      nplmgs(nph,phpl,sel + " and key=='sin_01'",legend='sin, beam')
      nplmcs(nph,phpl,sel + " and key=='taper_01'",legend='taper, beam')
      legend()
      txyz("IVUE32, 7th Harmonic, 2500 keV, Effect of Field Errors (" + btype + ")","n x phase error [rad]","Normalized of flux-density")

      for key in ['bend','cos','sin','taper']:
        for beam in ['pencil',btype]:

          bull()
          if beam == 'pencil': circle()

          for n in range(1,14):

            phpl = "phwav*7.:rdb"
            if beam == 'pencil': phpl = "phwav*7.:s0p/s0hp"

            if n < 10: keyn = key + "_0" + str(n)
            else: keyn = key + "_" + str(n)

            sel = "beam=='" + beam + "'  and key=='" + keyn + "'"

            if key == 'bend':
              nplmrs(nph,phpl,sel)
            elif key == 'cos':
              nplmbs(nph,phpl,sel)
            elif key == 'sin':
              nplmgs(nph,phpl,sel)
            elif key == 'taper':
              nplmcs(nph,phpl,sel)
            #endif

          #endfor
        #endfor
      #endfor

      fs = fall.split(".")
      fpdf = ""
      for f in fs[:-1]: fpdf += f

      pp(fpdf+"_"+btype+".pdf")
      pp(fpdf+"_"+btype+".png")

      ndump(nph,"phwav*7.:s0/s0hp:phsig:key","beam=='pencil'","SRI22_phase-errors_Johannes_pencil.dat")
      ndump(nph,"phwav*7.:rdb:phsig:key","beam=='emit'","SRI22_phase-errors_Johannes_emit.dat")
      ndump(nph,"phwav*7.:rdb:phsig:key","beam=='espread'","SRI22_phase-errors_Johannes_espread.dat")
      ndump(nph,"phwav*7.:rdb:phsig:key","beam=='em+esp'","SRI22_phase-errors_Johannes_emit_espread.dat")

    #endfor

  elif args[1] == "Johannes" or args[1] == "J":

    nsig = ncread("nsig","phsig","n_sigma_phi-corrected.dat")

    fall = "SRI22_phase-errors_Johannes.dat"
    Fall = open(fall,"w")
    Fall.write("* Type beam  run  PhSig PhErr_r PhErr_d S0  S0_pen S0H_pen S0H S0/S0_pen S0/S0H_pen S0/S0H\n")
    date = time.asctime(time.localtime(time.time()))
    Fall.write("* " + date + "\n")
    Fall.close()

    Fprot = open("serie_Johannes.pro","w")

    for key in ['bend','cos','sin','taper']:
      for n in range(1,14):

        if n < 10: keyn = key + "_0" + str(n)
        else: keyn = key + "_" + str(n)

        print(NL,keyn,NL)

        flis = key + ".lis"
        stat = os.system("rm " + flis + " 2>/dev/null")
        stat = os.system("ls -1 a/wave_*" + keyn + "* >> " + flis)
        os.system("cat " + flis)
        sleep(1)
        Flis = open(flis,"r")
        fdo = Flis.readlines()
        Flis.close()

        if len(fdo) == 4:
          nf = 0
          for f in fdo:
            nf += 1
            f = f.strip()
            for i in range(5):
              if re.search("pencil",f):
                fs0p = f
                runp = f.split(".")[-1]
              elif re.search("emit_espread",f):
                fs0ef =f
                runef = f.split(".")[-1]
              elif re.search("emit",f):
                fs0f =f
                runf = f.split(".")[-1]
              elif re.search("espread",f):
                fs0e =f
                rune = f.split(".")[-1]
              else: Quit("*** Bad key-word in " + f)
            #endif
          #endfor
        #endfor

        vs0ene,vs0p,vs0f,vs0e,vs0ef = phase_error(keyn,fs0p,fs0f,fs0e,fs0ef,fall=fall)

        phdeg,phwav = get_phase_error(runp)
        write(Fprot,keyn,phdeg,phwav)

      #endif 4 files
    #endfor key

    Fprot.close()
    Quit()

  elif args[1] == "b0erroramprep":

    fserie = "/home/scheer/wav/stage/serie_amprep.out"
    namp = ncread("namp","run:iseed:key:pherr:e:s0",fserie)
    ninfo(namp)

    fserie = "/home/scheer/wav/work/serie_b0error_pencil.out"
    nb00 = ncread("nb00","run:iseed:b0err:pherr:e:s0",fserie)
    ninfo(nb00)

    fserie = "/home/scheer/wav/work/serie_b0error.out"
    nb0 = ncread("nb0","run:iseed:b0err:pherr:e:s0",fserie)
    ninfo(nb0)

    smpencil = nstat(namp,"s0","key=='pencil' and pherr==0",isilent=1)
    smemit = nstat(namp,"s0","key=='emit' and pherr==0",isilent=1)
    smespread = nstat(namp,"s0","key=='espread' and pherr==0",isilent=1)
    smemiesp = nstat(namp,"s0","key=='emiesp' and pherr==0",isilent=1)

    smbunch = nstat(nb0,"s0","b0err==0",isilent=1)
    smb00= nstat(nb00,"s0","b0err==0",isilent=1)

    optnstat()

    nharm=7
    sharmrad = str(nharm * pi/180.)

    verror=ncopv(namp,"pherr","iseed==1 and key=='pencil'")
    vwalker = exp(-(verror/180.*pi*nharm)**2)
    verrscl = verror * nharm * pi/180.
    vplxy(verrscl,vwalker,"spline",color='black',label='Walker')

    key = 'all'

    if key == 'pencil':
      circ()
      sm=str(smpencil[2])
      nplmrs(namp,sharmrad + "*pherr:s0/"+sm,"key=='pencil'",legend="s0")
      bull()
      npl(namp,sharmrad + "*pherr:s0/"+sm,"","","sameprof",legend="s0_mean + sig_mean",color='g')
    #endif

    if key == 'all':

      sm=str(smb00[2])
      bull()
      npl(nb00,sharmrad + "*pherr:s0/"+sm,"","","same",legend="pencil",color='black')

      sm=str(smbunch[2])
      npl(nb0,sharmrad + "*pherr:s0/"+sm,"","","same",legend="bunch",color='magenta')

      sm=str(smpencil[2])
      npl(namp,sharmrad + "*pherr:s0/"+sm,"key=='pencil'","","sameprof",legend="pencil",color='r')
      sm=str(smemit[2])
      circ()
      npl(namp,sharmrad + "*pherr:s0/"+sm,"key=='emit'","","sameprof",legend="emit",color='g')
      sm=str(smespread[2])
      npl(namp,sharmrad + "*pherr:s0/"+sm,"key=='espread'","","sameprof",legend="espread",color='b')
      sm=str(smemiesp[2])
      bull()
      npl(namp,sharmrad + "*pherr:s0/"+sm,"key=='emiesp'","","sameprof",legend="emit + espread",color='c')

    #endif

    legend()
    txyz("Effects of Phase Errors on the 7th Harmonic","n x PhErr [rad]","Rel. on-axis Flux-density")

  elif args[1] == "b0error":

    fserie = "serie_b0error.out"

    nb0 = ncread("nb0","run:iseed:b0err:pherr:e:s0",fserie)
    ninfo(nb0)

    optnstat()
    #nplt(nb0,"b0err:pherr","","","prof")
    nplt(nb0,"pherr:s0","","","prof")

  elif args[1] == "amprep":

    fserie = "serie_amprep.out"

    namp = ncread("namp","run:iseed:key:pherr:e:s0",fserie)
    ninfo(namp)

    smpencil = nstat(namp,"s0","key=='pencil' and pherr==0",isilent=1)
    smemit = nstat(namp,"s0","key=='emit' and pherr==0",isilent=1)
    smespread = nstat(namp,"s0","key=='espread' and pherr==0",isilent=1)
    smemiesp = nstat(namp,"s0","key=='emiesp' and pherr==0",isilent=1)

    optnstat()

    nharm=7
    sharmrad = str(nharm * pi/180.)

    verror=ncopv(namp,"pherr","iseed==1 and key=='pencil'")
    vwalker = exp(-(verror/180.*pi*nharm)**2)
    verrscl = verror * nharm * pi/180.
    vplxy(verrscl,vwalker,"spline",color='black',label='Walker')

    key = 'all'

    if key == 'pencil':
      circ()
      sm=str(smpencil[2])
      nplmrs(namp,sharmrad + "*pherr:s0/"+sm,"key=='pencil'",legend="s0")
      bull()
      npl(namp,sharmrad + "*pherr:s0/"+sm,"","","sameprof",legend="s0_mean + sig_mean",color='g')
    #endif

    if key == 'all':
      sm=str(smpencil[2])
      npl(namp,sharmrad + "*pherr:s0/"+sm,"key=='pencil'","","sameprof",legend="pencil",color='r')
      sm=str(smemit[2])
      circ()
      npl(namp,sharmrad + "*pherr:s0/"+sm,"key=='emit'","","sameprof",legend="emit",color='g')
      sm=str(smespread[2])
      npl(namp,sharmrad + "*pherr:s0/"+sm,"key=='espread'","","sameprof",legend="espread",color='b')
      sm=str(smemiesp[2])
      bull()
      npl(namp,sharmrad + "*pherr:s0/"+sm,"key=='emiesp'","","sameprof",legend="emit + espread",color='c')
    #endif

    legend()
    txyz("Effects of Phase Errors on the 7th Harmonic","n x PhErr [rad]","Rel. on-axis Flux-density")

  elif args[1] == "amprep_alt":

    fall = "amprep/amprep.dat"
    famp = open(fall,"w")

    nfiles = 0
    nkeys = 0

    for fkey in ["pencil","emit","espread","emiesp"]:

      nkeys += 1
      files = glob.glob("amprep/*" + fkey + "*selected*")
      nfiles += len(files)

      for af in files:
        #          print(af)
        ff = af.split("/")[1]
        try:
          fs = ff.split("_")
          key = fs[1]
          pherr = fs[2]
          seed = fs[4].split(".")[0]
        except:
          Quit(af)
        #endtry
        #          if key == 'pencil': pheall.append(float(pherr))
        fdat = open(af,"r")
        lines = fdat.readlines()
        fdat.close()
        il=0
        for l in lines:
          il += 1
          if il <= 2: continue
          famp.write(key + " " + pherr + " " + seed + " " + l)
        #endfor

      #endfor files

    #endfor fkey

    famp.close()

    namp=ncread("namp","key:phe:seed:e:s0:s1:s2:s3",fall)
    ninfo(namp)

    nseeds = int(namp.seed.max())
    emin = namp.e.min()
    pheall = ncopv(namp,"phe","e == " + str(emin) + " and seed == 1 " + " and key == 'pencil'")
    nerr = len(pheall)

    ierr0 = -1
    for ierr in range(nerr):
      if pheall[ierr] == 0:
        ierr0 = ierr
        break
      #endif
    #endfor

    if ierr0 == -1: Quit("*** Fehler: Zero error case is missing ***")

    s0maxpencil = np.zeros([nerr,nseeds])
    s0maxemit = np.zeros([nerr,nseeds])
    s0maxespread = np.zeros([nerr,nseeds])
    s0maxemiesp = np.zeros([nerr,nseeds])

    iplot = 1
    if iplot > 1:
      optnstat()
      zone(2,1)
    #endif

    iph = 0

    for ierr in range(nerr):

      spherr = str(pheall[ierr])

      for kseed in range(nseeds):

        iseed = kseed + 1
        seed = str(iseed)

        sel = "seed == " + seed + " and phe == " + spherr + " and key == 'pencil'"
        s0maxpencil[ierr,kseed] = namp.query(sel).s0.max()
        if iplot > 1:
          nplls(namp,"e:s0/1.e6",sel)
          if iph == 0: legend('pencil')
        #endif

        sel = "seed == " + seed + " and phe == " + spherr + " and key == 'emit'"
        s0maxemit[ierr,kseed] = namp.query(sel).s0.max()

        if iplot > 1:
          npllgs(namp,"e:s0/1.e6",sel)
          if iph == 0: legend('emit')
        #endif

        sel = "seed == " + seed + " and phe == " + spherr + " and key == 'espread'"
        s0maxespread[ierr,kseed] = namp.query(sel).s0.max()

        if iplot > 1:
          npllbs(namp,"e:s0/1.e6",sel)
          if iph == 0: legend('espread')
        #endif

        sel = "seed == " + seed + " and phe == " + spherr + " and key == 'emiesp'"
        s0maxemiesp[ierr,kseed] = namp.query(sel).s0.max()
        #          if spherr == '0.0' or spherr == '1.0':
        #            print(ierr,seed,kseed,spherr,s0maxemiesp[ierr,kseed])
        if iplot > 1:
          npllcs(namp,"e:s0/1.e6",sel)
          if iph == 0:
            legend('emit + espread')
            legend()
          #endif
        #endif

        iph += 1
        #if iph > 5: break

      #endfor iseed

    #endfor pherr

    if iplot > 1: nextzone()

    fv = open("amprep/recover.dat","w")

    if iplot:

      circ()

      verror = vcre(nerr)
      vpencil = vcre(nerr)
      vemit = vcre(nerr)
      vespread = vcre(nerr)
      vemiesp = vcre(nerr)

      iph = 0

      #        print("\n")
      for iseed in range(nseeds):

        for ierr in range(nerr):

          verror[ierr] = pheall[ierr]

          vpencil[ierr] = s0maxpencil[ierr,iseed] / s0maxpencil[ierr0,iseed]
          vemit[ierr] = s0maxemit[ierr,iseed] / s0maxemit[ierr0,iseed]
          vespread[ierr] = s0maxespread[ierr,iseed] / s0maxespread[ierr0,iseed]
          vemiesp[ierr] = s0maxemiesp[ierr,iseed] / s0maxemiesp[ierr0,iseed]

          fwrite(fv,iseed,ierr,verror[ierr], \
          vpencil[ierr],vemit[ierr],vespread[ierr],vemiesp[ierr])

          if vemiesp[ierr] > 1: print(ierr,iseed,verror[ierr], \
          s0maxemiesp[ierr,iseed], \
          s0maxemiesp[ierr0,iseed])

        #endfor pherr

        if iph == 0:
          vplxy(verror,vpencil,label='pencil')
        #endif

        vplxy(verror+0.2,vemit,'same',color='g')
        if iph == 0: legend('emit')
        vplxy(verror-0.2,vespread,'same',color='b')
        if iph == 0: legend('espread')
        vplxy(verror,vemiesp,'same',color='c')
        if iph == 0:
          legend('emit + espread')
          legend()
          txyz("Effects of Phase Errors on Brilliance","phase error [degree]","rel. reduction")
        #endif

        vplxy(verror,vpencil,'same',color='r')

        iph += 1
        #if iph > 3: break
        #break

      #endfor iseed

      fv.close()
      ns0 = ncread("ns0","is:ie:err:pen:emi:esp:emiesp","amprep/recover.dat")
      ninfo(ns0)

      winr()
      optnstat()
      bull()

      verrsort=vsortx(verror)
      vwalker = exp(-(verrsort/180.*pi*7)**2)
      vplxy(verrsort,vwalker,"spline",color='black',label='Walker')

      npl(ns0,"err:pen","","","sameprof",legend='pencil')
      npl(ns0,"err:emi","","","sameprof",color='g',legend='emit')
      npl(ns0,"err:esp","","","sameprof",color='b',legend='espread')
      npl(ns0,"err:emiesp","","","sameprof",color='c',legend='emit + espread')

      legend()

      txyz("Effects of Phase Errors on Brilliance","phase error [degree]","rel. reduction")

    #endif iplot


    #      sel = "phe == 0 and key == 'espread'"
    #      npllb(namp,"e:s0/1.e6",sel,legend='espread')

  elif args[1] == "bend_01":

    ipencil = 567
    iemit = ipencil + 1
    iespread = ipencil + 2
    ief = ipencil + 3

    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error("bend_01",
                "a/wave_bend_01_pencil_on-axis.dat." + str(ipencil),
                "a/wave_bend_01_emit_on-axis.dat." + str(iemit),
                "a/wave_bend_01_espread_on-axis.dat." + str(iespread),
                "a/wave_bend_01_emit_espread_on-axis.dat." + str(ief),
                fall="real_beam_bend_01.dat")

  elif args[1] == "phase_bend":

    ipencil = 340
    ipencil = 482
    iemit = ipencil + 1
    iespread = ipencil + 2
    ief = ipencil + 3

    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error("bend",
                "a/wave_bend_pencil_on-axis.dat." + str(ipencil),
                "a/wave_bend_emit_on-axis.dat." + str(iemit),
                "a/wave_bend_espread_on-axis.dat." + str(iespread),
                "a/wave_bend_emit_espread_on-axis.dat." + str(ief),
                fall="real_beam_bend.dat")

  elif args[1] == "phase_bold":

    #if os.path.exists("WAVE.mhb"):

    try: nb = ncread("nb","e:s0:s1:s2:s3", \
    "a/wave_bend_pencil_on-axis.dat.340",skiphead=2)
    except: pass

    try: nbf = ncread("nbf","e:s0:s1:s2:s3", \
    "a/wave_bend_emit_on-axis.dat.341",skiphead=2)
    except: pass

    try: nbe = ncread("nbe","e:s0:s1:s2:s3", \
    "a/wave_bend_espread_on-axis.dat.342",skiphead=2)
    except: pass

    try: nbef = ncread("nbef","e:s0:s1:s2:s3", \
    "a/wave_bend_emit_espread_on-axis.dat.343",skiphead=2)
    except: pass

    optnstat()

    try: nplc(nb,"e:s0/1.0e6")
    except: pass

    try: nplcbs(nbe,"e:s0/1.0e6")
    except: pass

    try: nplcgs(nbf,"e:s0/1.0e6")
    except: pass

    try: nplccs(nbef,"e:s0/1.0e6")
    except: pass

    try: s0max = nb.s0.max()/1.0e6
    except: pass

    try: s0maxe = nbe.s0.max()/1.0e6
    except: pass

    try: s0maxf = nbf.s0.max()/1.0e6
    except: pass

    try: s0maxef = nbef.s0.max()/1.0e6
    except: pass

    try: text(0.6,0.9,"S0 Maximum: "+g3(s0max),halign='left')
    except: pass

    try:
      rde = s0maxe/s0max
      text(0.6,0.8,"Reduction e-spread: "+g3(rde),halign='left')
    except: pass

    try:
      rdf = s0maxf/s0max
      text(0.6,0.7,"Reduction emit.: "+g3(rdf),halign='left')
    except: pass

    try:
      rdef = s0maxef/s0max
      text(0.6,0.6,"Reduction both: "+g3(rdef),halign='left')
    except: pass

    txyz("Phase Error (bend.dat), Real Beam, 7th Harm.","E$_{ph}$ [eV]","N$_{ph}$/s/mm$^{2}$/100mA/0.1%BW")

    Fred = open("real_beam_bend_340-343.dat","w")

    try:
      print("S0max: " + g5(s0max))
      Fred.write("S0max: " + g5(s0max) + "\n")
    except: pass

    try:
      print("S0max_f, rdf: " + g5(s0maxf) + BL + g5(rdf))
      Fred.write("S0max_f, rdf: " + g5(s0maxf) + BL + g5(rdf) + "\n")
    except: pass

    try:
      print("S0max_e, rde: " + g5(s0maxe) + BL + g5(rde))
      Fred.write("S0max_e, rde: " + g5(s0maxe) + BL + g5(rde) + "\n")
    except: pass

    try:
      print("S0max_ef, rdef: " + g5(s0maxef) + BL + g5(rdef))
      Fred.write("S0max_ef, rdef: " + g5(s0maxef) + BL + g5(rdef) + "\n")
    except: pass

    Fred.close()

    pp("real_beam_bend_340-343.pdf")

  elif args[1] == "phase_s":

    #if os.path.exists("WAVE.mhb"):

    try: nsi = ncread("nsi","e:s0:s1:s2:s3", \
    "a/wave_sin_pencil_selected.dat.432",skiphead=2)
    except: pass

    try: nsie = ncread("nsie","e:s0:s1:s2:s3", \
    "a/wave_sin_espread_selected.dat.343",skiphead=2)
    except: pass

    try: nsif = ncread("nsif","e:s0:s1:s2:s3", \
    "a/wave_sin_emit_selected.dat.342",skiphead=2)
    except: pass

    try: nsief = ncread("nsief","e:s0:s1:s2:s3", \
    "a/wave_sin_emit_espread_selected.dat.435",skiphead=2)
    except: pass

    optnstat()

    try: nplc(nsi,"e:s0/1.0e6")
    except: pass

    try: nplcbs(nsie,"e:s0/1.0e6")
    except: pass

    try: nplcgs(nsif,"e:s0/1.0e6")
    except: pass

    try: nplccs(nsief,"e:s0/1.0e6")
    except: pass

    try: s0max = nsi.s0.max()/1.0e6
    except: pass

    try: s0maxe = nsie.s0.max()/1.0e6
    except: pass

    try: s0maxf = nsif.s0.max()/1.0e6
    except: pass

    try: s0maxef = nsief.s0.max()/1.0e6
    except: pass

    try: text(0.6,0.9,"S0 Maximum: "+g3(s0max),halign='left')
    except: pass

    try:
      rde = s0maxe/s0max
      text(0.6,0.8,"Reduction e-spread: "+g3(rde),halign='left')
    except: pass

    try:
      rdf = s0maxf/s0max
      text(0.6,0.7,"Reduction emit.: "+g3(rdf),halign='left')
    except: pass

    try:
      rdef = s0maxef/s0max
      text(0.6,0.6,"Reduction both: "+g3(rdef),halign='left')
    except: pass

    txyz("Phase Error (sin.dat), Real Beam, 7th Harm.","E$_{ph}$ [eV]","N$_{ph}$/s/mm$^{2}$/100mA/0.1%BW")

    Fred = open("real_beam_sin_432-435.dat","w")

    try:
      print("S0max: " + g5(s0max))
      Fred.write("S0max: " + g5(s0max) + "\n")
    except: pass

    try:
      print("S0max_f, rdf: " + g5(s0maxf) + BL + g5(rdf))
      Fred.write("S0max_f, rdf: " + g5(s0maxf) + BL + g5(rdf) + "\n")
    except: pass
    try:
      print("S0max_e, rde: " + g5(s0maxe) + BL + g5(rde))
      Fred.write("S0max_e, rde: " + g5(s0maxe) + BL + g5(rde) + "\n")
    except: pass

    try:
      print("S0max_ef, rdef: " + g5(s0maxef) + BL + g5(rdef))
      Fred.write("S0max_ef, rdef: " + g5(s0maxef) + BL + g5(rdef) + "\n")
    except: pass

    Fred.close()

    pp("real_beam_342-345sin.pdf")

  elif args[1] == "phase_c":

    #if os.path.exists("WAVE.mhb"):

    try: nsi = ncread("nsi","e:s0:s1:s2:s3", \
    "a/wave_cos_pencil_selected.dat.336",skiphead=2)
    except: pass
    try: nsie = ncread("nsie","e:s0:s1:s2:s3", \
    "a/wave_cos_espread_selected.dat.338",skiphead=2)
    except: pass
    try: nsif = ncread("nsif","e:s0:s1:s2:s3", \
    "a/wave_cos_emit_selected.dat.337",skiphead=2)
    except: pass
    try: nsief = ncread("nsief","e:s0:s1:s2:s3", \
    "a/wave_cos_emit_espread_selected_339.dat",skiphead=2)
    except: pass

    optnstat()

    try: nplc(nsi,"e:s0/1.0e6")
    except: pass
    try: nplcbs(nsie,"e:s0/1.0e6")
    except: pass
    try: nplcgs(nsif,"e:s0/1.0e6")
    except: pass
    try: nplccs(nsief,"e:s0/1.0e6")
    except: pass

    try: s0max = nsi.s0.max()/1.0e6
    except: pass
    try: s0maxe = nsie.s0.max()/1.0e6
    except: pass
    try: s0maxf = nsif.s0.max()/1.0e6
    except: pass
    try: s0maxef = nsief.s0.max()/1.0e6
    except: pass

    try: text(0.6,0.9,"S0 Maximum: "+g3(s0max),halign='left')
    except: pass
    try:
      rde = s0maxe/s0max
      text(0.6,0.8,"Reduction e-spread: "+g3(rde),halign='left')
    except: pass
    try:
      rdf = s0maxf/s0max
      text(0.6,0.7,"Reduction emit.: "+g3(rdf),halign='left')
    except: pass
    try:
      rdef = s0maxef/s0max
      text(0.6,0.6,"Reduction both: "+g3(rdef),halign='left')
    except: pass

    txyz("Phase Error (cos.dat), Real Beam, 7th Harm.","E$_{ph}$ [eV]","N$_{ph}$/s/mm$^{2}$/100mA/0.1%BW")

    Fred = open("real_beam_cos_336-339.dat","w")

    try:
      print("S0max: " + g5(s0max))
      Fred.write("S0max: " + g5(s0max) + "\n")
    except: pass
    try:
      print("S0max_f, rdf: " + g5(s0maxf) + BL + g5(rdf))
      Fred.write("S0max_f, rdf: " + g5(s0maxf) + BL + g5(rdf) + "\n")
    except: pass
    try:
      print("S0max_e, rde: " + g5(s0maxe) + BL + g5(rde))
      Fred.write("S0max_e, rde: " + g5(s0maxe) + BL + g5(rde) + "\n")
    except: pass
    try:
      print("S0max_ef, rdef: " + g5(s0maxef) + BL + g5(rdef))
      Fred.write("S0max_ef, rdef: " + g5(s0maxef) + BL + g5(rdef) + "\n")
    except: pass

    Fred.close()

    pp("real_beam_cos-336-339.pdf")

  elif args[1] == "phase_h":

    #if os.path.exists("WAVE.mhb"):

    nh = ncread("nh","e:s0:s1:s2:s3", \
    "a/wave_halbach_pencil_selected.dat.347",silent=1,skiphead=2)
    nhf = ncread("nhf","e:s0:s1:s2:s3", \
    "a/wave_halbach_emit_selected.dat.348",silent=1,skiphead=2)
    nhe = ncread("nhe","e:s0:s1:s2:s3", \
    "a/wave_halbach_espread_selected.dat.349",silent=1,skiphead=2)
    nhef = ncread("nhef","e:s0:s1:s2:s3", \
    "a/wave_halbach_emit_espread_selected.dat.350",silent=1,skiphead=2)

    optnstat()
    nplc(nh,"e:s0/1.0e6")
    s0max = nh.s0.max()/1.0e6
    legend("S0,      " + g3(s0max) + ", 1.000")
    txyz("Ideal Undulator, Real Beam, 7th Harm.","E$_{ph}$ [eV]","N$_{ph}$/s/mm$^{2}$/100mA/0.1%BW")

    Fred = open("real_beam_halbach_347-350.dat","w")
    #Fred = open("real_beam_halbach_347-350.dat","w")

    print("S0max:   " + g5(s0max))
    Fred.write("S0max: " + g5(s0max) + "\n")

    if nexist("nhe"):
      nplcbs(nhe,"e:s0/1.0e6")
      s0maxe = nhe.s0.max()/1.0e6
      rde = s0maxe/s0max
      legend("S0_e,   " + g3(s0maxe) + ", " + g3(s0maxe/s0max))
      print("S0max_e, rde: " + g5(s0maxe) + BL + g5(rde))
      Fred.write("S0max_e, rde: " + g5(s0maxe) + BL + g5(rde) + "\n")
    #endif

    if nexist("nhf"):
      nplcgs(nhf,"e:s0/1.0e6")
      s0maxf = nhf.s0.max()/1.0e6
      rdf = s0maxf/s0max
      legend("S0_f ,   " + g3(s0maxf) + ", " + g3(s0maxf/s0max))
      print("S0max_f, rdf: " + g5(s0maxf) + BL + g5(rdf))
      Fred.write("S0max_f, rdf: " + g5(s0maxf) + BL + g5(rdf) + "\n")
    #endif

    if nexist("nhef"):
      nplccs(nhef,"e:s0/1.0e6")
      s0maxef = nhef.s0.max()/1.0e6
      rdef = s0maxef/s0max
      legend("S0_ef,   " + g3(s0maxef) + ", " + g3(s0maxef/s0max))
      Fred.write("S0max_ef, rdef: " + g5(s0maxef) + BL + g5(rdef) + "\n")
      print("Test:",rde*rdf/rdef)
    #endif

    legend()
    Fred.close()

    pp("real_beam_halbach_347-350.pdf")

  elif args[1] == "phase_ht":

    #if os.path.exists("WAVE.mhb"):

    nh = ncread("nh","e:s0:s1:s2:s3", \
    "wave_halba_tab_pencil_selected.dat.437",silent=1,skiphead=2)
    nhf = ncread("nhf","e:s0:s1:s2:s3", \
    "wave_halba_tab_emit_selected.dat.438",silent=1,skiphead=2)
    nhe = ncread("nhe","e:s0:s1:s2:s3", \
    "wave_halba_tab_espread_selected.dat.439",silent=1,skiphead=2)
    nhef = ncread("nhef","e:s0:s1:s2:s3", \
    "wave_halba_tab_emit_espread_selected.dat.340",silent=1,skiphead=2)

    optnstat()
    nplc(nh,"e:s0/1.0e6")
    s0max = nh.s0.max()/1.0e6
    text(0.6,0.9,"S0 Maximum: "+g3(s0max),halign='left')
    txyz("Ideal Undulator, Real Beam, 7th Harm.","E$_{ph}$ [eV]","N$_{ph}$/s/mm$^{2}$/100mA/0.1%BW")

    Fred = open("real_beam_halba_tab_437-440.dat","w")
    #Fred = open("real_beam_halbach_347-350.dat","w")

    print("S0max: " + g5(s0max))
    Fred.write("S0max: " + g5(s0max) + "\n")

    if nexist("nhe"):
      nplcbs(nhe,"e:s0/1.0e6")
      s0maxe = nhe.s0.max()/1.0e6
      rde = s0maxe/s0max
      text(0.6,0.8,"Reduction e-spread: "+g3(rde),halign='left')
      print("S0max_e, rde: " + g5(s0maxe) + BL + g5(rde))
      Fred.write("S0max_e, rde: " + g5(s0maxe) + BL + g5(rde) + "\n")
    #endif

    if nexist("nhf"):
      nplcgs(nhf,"e:s0/1.0e6")
      s0maxf = nhf.s0.max()/1.0e6
      rdf = s0maxf/s0max
      text(0.6,0.7,"Reduction emit.: "+g3(rdf),halign='left')
      print("S0max_f, rdf: " + g5(s0maxf) + BL + g5(rdf))
      Fred.write("S0max_f, rdf: " + g5(s0maxf) + BL + g5(rdf) + "\n")
    #endif

    if nexist("nhef"):
      nplccs(nhef,"e:s0/1.0e6")
      s0maxef = nhef.s0.max()/1.0e6
      rdef = s0maxef/s0max
      text(0.6,0.6,"Reduction both: "+g3(rdef),halign='left')
      print("S0max_ef, rdef: " + g5(s0maxef) + BL + g5(rdef))
      Fred.write("S0max_ef, rdef: " + g5(s0maxef) + BL + g5(rdef) + "\n")
    #endif

    Fred.close()

    pp("real_beam_halba_tab_347-340.pdf")

  elif args[1] == "phase_stokes":

    optnstat()
    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error(fall = args[1] + ".dat")

  elif args[1] == "phase_berror":

    set_y_stat(0.2)

    fall = args[1] + ".dat"
    os.system("rm " + fall)

    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error("berror",
                "wave_berror_pencil_selected.dat",
                "wave_berror_emit_selected.dat",
                "wave_berror_espread_selected.dat",
                "wave_berror_emit_espread_selected.dat",
                fall=fall)

    print("berror runs",iruns0, iruns0e, iruns0f, iruns0ef, iruns0ref)

  elif args[1] == "phase_taper":

    optnstat()
    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error("taper",
                "wave_taper_pencil_selected.dat",
                "wave_taper_emit_selected.dat",
                "wave_taper_espread_selected.dat",
                "wave_taper_emit_espread_selected.dat",
                fall = args[1] + ".dat")

    print("taper runs",iruns0, iruns0e, iruns0f, iruns0ef, iruns0ref)

  elif args[1] == "phase_told":

    nt = ncread("nt","e:s0:s1:s2:s3", \
    "a/wave_taper_pencil_selected.dat.418",silent=1,skiphead=2)
    ntf = ncread("ntf","e:s0:s1:s2:s3", \
    "a/wave_taper_emit_selected.dat.419",silent=1,skiphead=2)
    nte = ncread("nte","e:s0:s1:s2:s3", \
    "a/wave_taper_espread_selected.dat.420",silent=1,skiphead=2)
    ntef = ncread("ntef","e:s0:s1:s2:s3", \
    "a/wave_taper_emit_espread_selected.dat.421",silent=1,skiphead=2)

    optnstat()
    nplc(nt,"e:s0/1.0e6")
    s0max = nt.s0.max()/1.0e6
    text(0.6,0.9,"S0 Maximum: "+g3(s0max),halign='left')
    txyz("Taper, Real Beam, 7th Harm.","E$_{ph}$ [eV]","N$_{ph}$/s/mm$^{2}$/100mA/0.1%BW")

    Fred = open("real_beam_taper_418-421.dat","w")
    #Fred = open("real_beam_taper_347-350.dat","w")

    print("S0max: " + g5(s0max))
    Fred.write("S0max: " + g5(s0max) + "\n")

    if nexist("nte"):
      nplcbs(nte,"e:s0/1.0e6")
      s0maxe = nte.s0.max()/1.0e6
      rde = s0maxe/s0max
      text(0.6,0.8,"Reduction e-spread: "+g3(rde),halign='left')
      print("S0max_e, rde: " + g5(s0maxe) + BL + g5(rde))
      Fred.write("S0max_e, rde: " + g5(s0maxe) + BL + g5(rde) + "\n")
    #endif

    if nexist("ntf"):
      nplcgs(ntf,"e:s0/1.0e6")
      s0maxf = ntf.s0.max()/1.0e6
      rdf = s0maxf/s0max
      text(0.6,0.7,"Reduction emit.: "+g3(rdf),halign='left')
      print("S0max_f, rdf: " + g5(s0maxf) + BL + g5(rdf))
      Fred.write("S0max_f, rdf: " + g5(s0maxf) + BL + g5(rdf) + "\n")
    #endif

    if nexist("ntef"):
      nplccs(ntef,"e:s0/1.0e6")
      s0maxef = ntef.s0.max()/1.0e6
      rdef = s0maxef/s0max
      text(0.6,0.6,"Reduction both: "+g3(rdef),halign='left')
      print("S0max_ef, rdef: " + g5(s0maxef) + BL + g5(rdef))
      Fred.write("S0max_ef, rdef: " + g5(s0maxef) + BL + g5(rdef) + "\n")
    #endif

    Fred.close()

    pp("real_beam_taper_418-421.pdf")

  elif args[1] == "bunch_h":

    if os.path.exists("WAVE.mhb"):
      nb = ncread("nb","e:s0:s1:s2:s3","wave_halbach_bunch_selected.dat",skiphead=2)
      nplc(nb,"e:s0")
      pp("real_beam_halbach_bunch.pdf")
    #endif

  elif args[1] == "phase_err":

    nh = ncread("nh","e:s0:s1:s2:s3","wave_halbach__selected.dat",skiphead=2)
    if type(nh) == int: Quit()
    nhe = ncread("nhe","e:s0:s1:s2:s3","wave_halbach_e_selected.dat",skiphead=2)
    if type(nhe) == int: Quit()
    nhf = ncread("nhf","e:s0:s1:s2:s3","wave_halbach_f_selected.dat",skiphead=2)
    if type(nhf) == int: Quit()
    nhef = ncread("nhef","e:s0:s1:s2:s3","wave_halbach_ef_selected.dat",skiphead=2)
    if type(nhef) == int: Quit()

    nb = ncread("nb","e:s0:s1:s2:s3","wave_bend__selected.dat",skiphead=2)
    if type(nb) == int: Quit()
    nbe = ncread("nbe","e:s0:s1:s2:s3","wave_bend_e_selected.dat",skiphead=2)
    if type(nbe) == int: Quit()
    nbf = ncread("nbf","e:s0:s1:s2:s3","wave_bend_f_selected.dat",skiphead=2)
    if type(nbf) == int: Quit()
    nbef = ncread("nbef","e:s0:s1:s2:s3","wave_bend_ef_selected.dat",skiphead=2)
    if type(nbef) == int: Quit()

    optnstat()
    Fr = open("reduction.dat","w")

    nplc(nh,"e:s0","s0>1")
    nplcbs(nb,"e:s0","s0>1")
    text(0.6,0.8,"Max. Halbach:"+g4(nh.s0.max()),halign='left')
    text(0.6,0.75,"Max. bend.dat:"+g4(nb.s0.max()),halign='left')
    r = nb.s0.max()/nh.s0.max()
    text(0.6,0.7,"Reduction:"+g3(r),halign='left')
    print("single e: " + g5(r))
    Fr.write("single e: " + g5(r)+"\n")
    pp("reduction_single_e.pdf")

    nplc(nhe,"e:s0","s0>1")
    nplcbs(nbe,"e:s0","s0>1")
    text(0.6,0.8,"Max. Halbach:"+g4(nhe.s0.max()),halign='left')
    text(0.6,0.75,"Max. bend.dat:"+g4(nbe.s0.max()),halign='left')
    r = nbe.s0.max()/nhe.s0.max()
    text(0.6,0.7,"Reduction:"+g3(r),halign='left')
    print("espread: " + g5(r))
    Fr.write("espread: " + g5(r)+"\n")
    pp("reduction_espread.pdf")

    nplc(nhef,"e:s0","s0>1")
    nplcbs(nbef,"e:s0","s0>1")
    text(0.6,0.8,"Max. Halbach:"+g4(nhef.s0.max()),halign='left')
    text(0.6,0.75,"Max. bend.dat:"+g4(nbef.s0.max()),halign='left')
    r = nbef.s0.max()/nhef.s0.max()
    text(0.6,0.7,"Reduction:"+g3(r),halign='left')
    print("emit., espread: " + g5(r))
    Fr.write("emit. + espread: " + g5(r)+"\n")
    pp("reduction_emit_espread.pdf")
    Fr.close()

  elif args[1] == "wbmap":
    if nargs > 2:  fbm = args[2]
    else:          fbm = "wave_bmap.dat"
    nwb = ncread("nwb","x:y:z:bx:by:bz",fbm,skiphead=6)
    ninfo(nwb)

  elif args[1] == "umap":
    numap = ncread("numap","x:y:z:bx:by:bz:ifail:kfail","undumag.map",skiphead=4)
    ninfo(numap)

  elif args[1] == "s0dat":

    if nargs > 2:  fall = args[2]
    else:          fall = "wave_stokes_selected.dat"

    ns0 = ncread("ns0","e:s0:s1:s2:s3",fall)
    iemax,emax,s0max = ns0peak(ns0)
    npll(ns0,"e:s0/1.e6")

  elif args[1] == "s0datold":

    Irunmin = 1e20
    Irunmax = -1e20

    optstat()

    fil = "wave_stokes_selected.dat"
    F = open(fil,"r")
    runs0 = F.readline().strip().split()[0].strip()
    iruns0 = int(runs0)
    if iruns0 < Irunmin: Irunmin = iruns0
    if iruns0 > Irunmax: Irunmax = iruns0
    ns0 = ncread("ns0","e:s0:s1:s2:s3",fil,silent=1,skiphead=2)
    F.close()

    try:
      fil = "wave_stokese_selected.dat"
      F = open(fil,"r")
      runs0e = F.readline().strip().split()[0].strip()
      iruns0e = int(runs0e)
      if iruns0e < Irunmin: Irunmin = iruns0e
      if iruns0e > Irunmax: Irunmax = iruns0e
      ns0e = ncread("ns0e","e:s0:s1:s2:s3",fil,silent=1,skiphead=2)
      F.close()
    except: pass

    try:
      fil = "wave_stokesf_selected.dat"
      F = open(fil,"r")
      runs0f = F.readline().strip().split()[0].strip()
      iruns0f = int(runs0f)
      if iruns0f < Irunmin: Irunmin = iruns0f
      if iruns0f > Irunmax: Irunmax = iruns0f
      ns0f = ncread("ns0f","e:s0:s1:s2:s3",fil,silent=1,skiphead=2)
      F.close()
    except: pass

    try:
      fil = "wave_stokesef_selected.dat"
      F = open(fil,"r")
      runs0ef = F.readline().strip().split()[0].strip()
      iruns0ef = int(runs0ef)
      if iruns0ef < Irunmin: Irunmin = iruns0ef
      if iruns0ef > Irunmax: Irunmax = iruns0ef
      ns0ef = ncread("ns0ef","e:s0:s1:s2:s3",fil,silent=1,skiphead=2)
      F.close()
    except: pass

    nplc(ns0,"e:s0/1.0e6")
    #s0max = ns0.s0.max()/1.0e6
    iemax,emax,s0max = ns0peak(ns0)

    legend("S0,      " + g3(s0max))

    tit = "Ideal Undulator, Real Beam, (" + str(Irunmin) + "-" + str(Irunmax) + ")"
    txyz(tit,"E$_{ph}$ [eV]","N$_{ph}$/s/mm$^{2}$/100mA/0.1%BW")

    Fred = open("real_beam_folded_selected.dat","w")
    #Fred = open("real_beam_halbach_347-350.dat","w")

    print("S0max:   " + g5(s0max))
    Fred.write("S0max: " + g5(s0max) + "\n")

    if nexist("ns0e"):
      optnstat()
      nplcbs(ns0e,"e:s0/1.0e6")
      iemaxe,emaxe,s0maxe = ns0peak(ns0e)
      if iemax > 0: s0harme = ns0e.s0[iemax]/1.e6
      rde = s0maxe/s0max
      rdhe = s0harme/s0max
      line1 = "S0max_e, rde  : " + g3(s0maxe) + BL + g3(rde)
      line2 = "S0harm_e, rdhe: " + g3(s0harme) + BL + g3(rdhe)
      legend(line1 + "\n" + line2)
      print("\n" + line1 + "\n" + line2)
      Fred.write("\n" + line1 + "\n" + line2 + "\n")
    #endif

    if nexist("ns0f"):
      optnstat()
      nplcgs(ns0f,"e:s0/1.0e6")
      iemaxf,emaxf,s0maxf = ns0peak(ns0f)
      if iemax > 0: s0harmf = ns0f.s0[iemax]/1.e6
      rdf = s0maxf/s0max
      rdhf = s0harmf/s0max
      line1 = "S0max_f, rdf  : " + g3(s0maxf) + BL + g3(rdf)
      line2 = "S0harm_f, rdhf: " + g3(s0harmf) + BL + g3(rdhf)
      legend(line1 + "\n" + line2)
      print("\n" + line1 + "\n" + line2)
      Fred.write("\n" + line1 + "\n" + line2 + "\n")
    #endif

    if nexist("ns0ef"):
      optnstat()
      nplccs(ns0ef,"e:s0/1.0e6")
      iemaxef,emaxef,s0maxef = ns0peak(ns0ef)
      if iemax > 0: s0harmef = ns0ef.s0[iemax]/1.e6
      rdef = s0maxef/s0max
      rdhef = s0harmef/s0max
      line1 = "S0max_ef, rdef  : " + g3(s0maxef) + BL + g3(rdef)
      line2 = "S0harm_ef, rdhef: " + g3(s0harmef) + BL + g3(rdhef)
      legend(line1 + "\n" + line2)
      print("\n" + line1 + "\n" + line2)
      Fred.write("\n" + line1 + "\n" + line2 + "\n")
    #endif

    legend()
    Fred.close()

    pp("real_beam_folded.selected.pdf")

    optstat()

  elif args[1] == "phase_halbach":

    Fall = open("SRI22_phase-errors.dat","w")
    #  Type beam  run  S0*  S0_pen S0H_pen S0H S0*/S0_pen S0*/S0H_pen S0*/S0H
    Fall.close()

    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error("halbach",
                "a/wave_halbach_pencil_on-axis.dat.347",
                "a/wave_halbach_emit_on-axis.dat.348",
                "a/wave_halbach_espread_on-axis.dat.349",
                "a/wave_halbach_emit_espread_on-axis.dat.350")
    Quit()

  elif args[1] == "phase_all":

    set_y_stat(0.2)

    fall = "a/SRI22_phase-errors.dat"
    Fall = open(fall,"w")
    Fall.write("* Type beam  run  S0  S0_pen S0H_pen S0H S0/S0_pen S0/S0H_pen S0/S0H\n")
    Fall.close()

    ipencil = 347
    ipencil = 476
    iemit = ipencil + 1
    iespread = ipencil + 2
    ief = ipencil + 3

    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error("halbach",
                "a/wave_halbach_pencil_on-axis.dat." + str(ipencil),
                "a/wave_halbach_emit_on-axis.dat." + str(iemit),
                "a/wave_halbach_espread_on-axis.dat." + str(iespread),
                "a/wave_halbach_emit_espread_on-axis.dat." + str(ief),fall=fall)

    runs = str(Irunmin) + "-" + str(Irunmax)
    Fs0 = open("a/wave_halbach_S0_on-axis.dat." + runs,"w")
    for i in range(len(vs0)):
      Fs0.write(g5(vs0ene[i]) + BL + g5(vs0[i]) + BL \
      + g5(vs0f[i]) + BL + g5(vs0e[i]) + BL + g5(vs0ef[i]) + BL + "\n")
    #endfor
    Fs0.close()

    ipencil = 340
    ipencil = 482
    iemit = ipencil + 1
    iespread = ipencil + 2
    ief = ipencil + 3

    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error("bend",
                "a/wave_bend_pencil_on-axis.dat." + str(ipencil),
                "a/wave_bend_emit_on-axis.dat." + str(iemit),
                "a/wave_bend_espread_on-axis.dat." + str(iespread),
                "a/wave_bend_emit_espread_on-axis.dat." + str(ief),fall=fall)

    runs = str(Irunmin) + "-" + str(Irunmax)
    Fs0 = open("a/wave_bend_S0_on-axis.dat." + runs,"w")
    for i in range(len(vs0)):
      Fs0.write(g5(vs0ene[i]) + BL + g5(vs0[i]) + BL \
      + g5(vs0f[i]) + BL + g5(vs0e[i]) + BL + g5(vs0ef[i]) + BL + "\n")
    #endfor
    Fs0.close()

    ipencil = 418
    ipencil = 486
    iemit = ipencil + 1
    iespread = ipencil + 2
    ief = ipencil + 3

    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error("taper",
                "a/wave_taper_pencil_on-axis.dat." + str(ipencil),
                "a/wave_taper_emit_on-axis.dat." + str(iemit),
                "a/wave_taper_espread_on-axis.dat." + str(iespread),
                "a/wave_taper_emit_espread_on-axis.dat." + str(ief),fall=fall)

    runs = str(Irunmin) + "-" + str(Irunmax)
    Fs0 = open("a/wave_taper_S0_on-axis.dat." + runs,"w")
    for i in range(len(vs0)):
      Fs0.write(g5(vs0ene[i]) + BL + g5(vs0[i]) + BL \
      + g5(vs0f[i]) + BL + g5(vs0e[i]) + BL + g5(vs0ef[i]) + BL + "\n")
    #endfor
    Fs0.close()

    ipencil = 336
    ipencil = 491
    iemit = ipencil + 1
    iespread = ipencil + 2
    ief = ipencil + 3

    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error("cos",
                "a/wave_cos_pencil_on-axis.dat." + str(ipencil),
                "a/wave_cos_emit_on-axis.dat." + str(iemit),
                "a/wave_cos_espread_on-axis.dat." + str(iespread),
                "a/wave_cos_emit_espread_on-axis.dat." + str(ief),fall=fall)

    runs = str(Irunmin) + "-" + str(Irunmax)
    Fs0 = open("a/wave_cos_S0_on-axis.dat." + runs,"w")
    for i in range(len(vs0)):
      Fs0.write(g5(vs0ene[i]) + BL + g5(vs0[i]) + BL \
      + g5(vs0f[i]) + BL + g5(vs0e[i]) + BL + g5(vs0ef[i]) + BL + "\n")
    #endfor
    Fs0.close()

    ipencil = 432
    ipencil = 495
    iemit = ipencil + 1
    iespread = ipencil + 2
    ief = ipencil + 3

    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error("sin",
                "a/wave_sin_pencil_on-axis.dat." + str(ipencil),
                "a/wave_sin_emit_on-axis.dat." + str(iemit),
                "a/wave_sin_espread_on-axis.dat." + str(iespread),
                "a/wave_sin_emit_espread_on-axis.dat." + str(ief),fall=fall)

    runs = str(Irunmin) + "-" + str(Irunmax)
    Fs0 = open("a/wave_sin_S0_on-axis.dat." + runs,"w")
    for i in range(len(vs0)):
      Fs0.write(g5(vs0ene[i]) + BL + g5(vs0[i]) + BL \
      + g5(vs0f[i]) + BL + g5(vs0e[i]) + BL + g5(vs0ef[i]) + BL + "\n")
    #endfor
    Fs0.close()

    ipencil = 468
    ipencil = 499
    iemit = ipencil + 1
    iespread = ipencil + 2
    ief = ipencil + 3

    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error("berror",
                "a/wave_berror_pencil_on-axis.dat." + str(ipencil),
                "a/wave_berror_emit_on-axis.dat." + str(iemit),
                "a/wave_berror_espread_on-axis.dat." + str(iespread),
                "a/wave_berror_emit_espread_on-axis.dat." + str(ief),fall=fall)

    runs = str(Irunmin) + "-" + str(Irunmax)
    Fs0 = open("a/wave_berror_S0_on-axis.dat." + runs,"w")
    for i in range(len(vs0)):
      Fs0.write(g5(vs0ene[i]) + BL + g5(vs0[i]) + BL \
      + g5(vs0f[i]) + BL + g5(vs0e[i]) + BL + g5(vs0ef[i]) + BL + "\n")
    #endfor
    Fs0.close()

    ipencil = 472
    ipencil = 503
    iemit = ipencil + 1
    iespread = ipencil + 2
    ief = ipencil + 3

    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error("pherr5",
                "a/wave_pherr5_pencil_on-axis.dat." + str(ipencil),
                "a/wave_pherr5_emit_on-axis.dat." + str(iemit),
                "a/wave_pherr5_espread_on-axis.dat." + str(iespread),
                "a/wave_pherr5_emit_espread_on-axis.dat." + str(ief),fall=fall)

    runs = str(Irunmin) + "-" + str(Irunmax)
    Fs0 = open("a/wave_pherr5_S0_on-axis.dat." + runs,"w")
    for i in range(len(vs0)):
      Fs0.write(g5(vs0ene[i]) + BL + g5(vs0[i]) + BL \
      + g5(vs0f[i]) + BL + g5(vs0e[i]) + BL + g5(vs0ef[i]) + BL + "\n")
    #endfor
    Fs0.close()

    ipencil = 507
    iemit = ipencil + 1
    iespread = ipencil + 2
    ief = ipencil + 3

    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error("berror_12deg",
                "a/wave_berror_12deg_pencil_on-axis.dat." + str(ipencil),
                "a/wave_berror_12deg_emit_on-axis.dat." + str(iemit),
                "a/wave_berror_12deg_espread_on-axis.dat." + str(iespread),
                "a/wave_berror_12deg_emit_espread_on-axis.dat." + str(ief),fall=fall)

    runs = str(Irunmin) + "-" + str(Irunmax)
    Fs0 = open("a/wave_berror_12deg_S0_on-axis.dat." + runs,"w")
    for i in range(len(vs0)):
      Fs0.write(g5(vs0ene[i]) + BL + g5(vs0[i]) + BL \
      + g5(vs0f[i]) + BL + g5(vs0e[i]) + BL + g5(vs0ef[i]) + BL + "\n")
    #endfor
    Fs0.close()

    Quit()

  elif args[1] == "66":

    n66=ncread("n66","iel:yi:zi:ypi:zpi:i:t:dph:r0x:r0y:r0z:x:y:z:ox:oy:oz:dox:doy:doz:ie:rex:iex:rda:ida","fort.66")
    n56=ncread("n56","ical:i:x:dph:ph:az:daz","fort.56")
    n67=ncread("n67","iel:yi:zi:ypi:zpi:i:t:dph:r0x:r0y:r0z:x:y:z:ox:oy:oz:dox:doy:doz:ie:rex:iex:rda:ida","~/wav/work/fort.67")
    n57=ncread("n57","ical:i:x:dph:ph:az:daz","~/wav/work/fort.57")

  elif args[1] == "stokes" or args[1] == "st":

    import waveplot as w
    from waveplot import *

    nsts = ncread("nsts","e:s0:s1:s2:s3","wave_stokes_selected.dat",skiphead=2)
    nst = ncread("nst","e:s0:s1:s2:s3","wave_stokes_flux.dat",skiphead=2)
    nstse = ncread("nstse","e:s0:s1:s2:s3","wave_stokese_selected.dat",skiphead=2)
    nste = ncread("nste","e:s0:s1:s2:s3","wave_stokese_flux.dat",skiphead=2)
    nstsf = ncread("nstsf","e:s0:s1:s2:s3","wave_stokesf_selected.dat",skiphead=2)
    nstf = ncread("nstf","e:s0:s1:s2:s3","wave_stokesf_flux.dat",skiphead=2)
    nstsef = ncread("nstsef","e:s0:s1:s2:s3","wave_stokesef_selected.dat",skiphead=2)
    nstef = ncread("nstef","e:s0:s1:s2:s3","wave_stokesef_flux.dat",skiphead=2)

    nlist()

    optnstat()
    sel = "e > " + str(Wflow) + " and e < " + str(Wfhig)
    #print(sel)

    #lilo()

    if nexist(nst):
      npllb(nst,"e:s0",sel)
      s0max = nst.s0.max()
      legend("S0,     " + g3(s0max) + ", 1.000")
    #endif

    #if nexist(nstf):
    # npllcs(nstf,"e:s0",sel)
    #s0fmax = nstf.s0.max()
    #legend("S0_f,  " + g3(s0fmax) + ", " + g3(s0fmax/s0max))
    #endif

    #if nexist(nste):
    # npllgs(nste,"e:s0",sel)
    # s0emax = nste.s0.max()
    # legend("S0_e,  " + g3(s0emax) + ", " + g3(s0emax/s0max))
    #endif

    if nexist(nstef):
      nplls(nstef,"e:s0",sel)
      s0efmax = nstef.s0.max()
      legend("S0_ef,  " + g3(s0efmax) + ", " + g3(s0efmax/s0max))
    #endif

    legend()

    wave_title()

    xTit="photon energy [eV]"
    yTit = 'N$_{\gamma}$' + '/s/' + str(Wbw) + ' %BW/' + str(int(Wcurr*1000.+0.5)) + "mA"
    txyz(tpinhole(),xTit,yTit)

    pp("wave_stokesf_flux.pdf")

  elif args[1] == "hflux" or args[1] == "f":

    if os.path.exists("WAVE.mhb"):

      import waveplot as w
      from waveplot import *

      for n in range(len(Nhead)):
        snam = Nhead[n][1]
        exec(snam + ' = nget("' + snam + '")')
      #endfor

      hflux(clipe='no')
      optnstat()

      hs0=hget("h48000")

      s0max = hs0.y.max()
      legend("S0,     " + g3(s0max) + ", 1.000")

      #vwritexy(hs0.x,hs0.y,"s0.dat")

      if Wiefo:
        sethistcolor('g')
        hflux('s0e','same')
        hs0e=hget("h70000")
        s0emax = hs0e.y.max()
        legend("S0_e,  " + g3(s0emax) + ", " + g3(s0emax/s0max))
      #endif

      if Wifol:
        sethistcolor('cyan')
        if Wisto:
          hflux('s0f','same')
          hs0f=hget("h60000")
        else:
          hflux('ff','same')
          hs0f=hget("h49000")
        #endif
        s0fmax = hs0f.y.max()
        legend("S0_f,  " + g3(s0fmax)  + ", " + g3(s0fmax/s0max))
      #endif

      if Wifol*Wiefo:
        sethistcolor('r')
        hflux('s0ef','same')
        hs0ef=hget("h80000")
        s0efmax = hs0ef.y.max()
        legend("S0_ef, " + g3(s0efmax)  + ", " + g3(s0efmax/s0max))
      #endif

      legend()
      pp("wave_flux.pdf")

    #endif mhb

  elif args[1] == "hcfluxden" or args[1] == "fd":

    if os.path.exists("WAVE.mhb"):

      import waveplot as w
      from waveplot import *

      for n in range(len(Nhead)):
        snam = Nhead[n][1]
        exec(snam + ' = nget("' + snam + '")')
      #endfor

      if Wif2p == 3.0:

        if Wispe:

          hcfluxden(clipe='no')
          optnstat()

          hs0=hget("h148000")

          s0max = hs0.y.max()
          legend("S0,     " + g3(s0max) + ", 1.000")

          #vwritexy(hs0.x,hs0.y,"s0.dat")

        else:
          print("*** No spectral data, check ISPEC in wave.in ***")
        #endif

        if Wiefo:
          hplot1d('h170000','same')
          hcfluxden('s0e','same')
          hs0e=hget("h170000")
          s0emax = hs0e.y.max()
          legend("S0_e,  " + g3(s0emax) + ", " + g3(s0emax/s0max))
        #endif

        if Wifol:
          if Wisto:
            #                hcfluxden('s0f','same')
            hs0f=hget("h160000")
          else:
            #                hcfluxden('fdf','same')
            hs0f=hget("h149000")
          #endif
          s0fmax = hs0f.y.max()
          legend("S0_f,  " + g3(s0fmax)  + ", " + g3(s0fmax/s0max))
        #endif

        if Wifol*Wiefo:
          # hcfluxden('s0ef','same')
          hs0ef=hget("h180000")
          s0efmax = hs0ef.y.max()
          legend("S0_ef, " + g3(s0efmax)  + ", " + g3(s0efmax/s0max))
        #endif

        #legend()
        #pp("wave_s0.pdf")

      elif Wif2p == 2.0:

        #lolo()

        npl(n3700,"ener:spec/1.e6","abs(y)<1.0e-6 and abs(z)<1.0e-6")

        xTit="photon energy [eV]"
        yTit = 'N$_{\gamma}$' + '/s/' + str(Wbw) + ' %BW/' + str(int(Wcurr*1000.+0.5)) + "mA"
        txyz(tpinhole(),xTit,yTit)

      #endif wif2p

    #endif WAVE.mhb

    ibck = 0
    icomp = 0
    if os.getcwd().split("/")[-1] == 'stage': icomp = 3

    if icomp == 4:
      nj=ncread("nj","e:fd","../job/waveplot_1.dat")
      print(n3700.spec.max()/1.e6/nj.fd.max())
      npllgs(nj)
    #endif

    icomp=0
    if icomp == 3:
      np00=ncread("np00","e:s0","pencil_00_100.dat")
      npllcs(np00,"e:s0")
      print("pencil_00: ",g5(n3700.spec.max()/1.e6/np00.s0.max()))
      text(0.85,0.9,"pencil_00: " + g5(n3700.spec.max()/1.e6/np00.s0.max()))
      np=ncread("np","e:s0","pencil_00005_100.dat")
      npllms(np,"e:s0")
      text(0.85,0.8,"pencil: " + g5(n3700.spec.max()/1.e6/np.s0.max()))
      print("pencil: ",g5(n3700.spec.max()/1.e6/np.s0.max()))
      text(0.85,0.8,"pencil: " + g5(n3700.spec.max()/1.e6/np.s0.max()))
      print("pencil_00: ",g5(n3700.spec.max()/1.e6/np.s0.max()))
      ne=ncread("ne","e:s0","emit_00_100.dat")
      npllbs(ne,"e:s0")
      text(0.85,0.7,"emit: " + g5(n3700.spec.max()/1.e6/ne.s0.max()))
      print("emit: ",g5(n3700.spec.max()/1.e6/ne.s0.max()))
      nb=ncread("nb","e:s0","beam_00_100.dat")
      npllgs(nb,"e:s0")
      text(0.85,0.6,"beam: " + g5(n3700.spec.max()/1.e6/nb.s0.max()))
      print("beam: ",g5(n3700.spec.max()/1.e6/nb.s0.max()))
    elif icomp > 0:

      if icomp == 2:
        #nbad=ncread("nbad","iel:yi:zi:ypi:zpi:i:t:dph:r0x:r0y:r0z:x:y:z:ox:oy:oz:dox:doy:doz:ie:rex:iex:rda:ida","bad.66")
        n66=ncread("n66","iel:yi:zi:ypi:zpi:i:t:dph:r0x:r0y:r0z:x:y:z:ox:oy:oz:dox:doy:doz:ie:rex:iex:rda:ida","fort.66")
        nsi=ncread("nsi","ie:t:x:z:reaz:imaz:spec:nx:nz","../job/n12.dat")
        ninfo(n66)
        ninfo(nsi)
      #endif

      nje=ncread("nje","e:s0","../job/emit_195-201.dat")
      #nje=ncread("nje","e:s0","../job/emit_195-201_1000m.dat")
      npllls(nje)
      text(0.8,0.8,g5(n3700.spec.max()/1.e6/nje.s0.max()))

      njb=ncread("njb","e:s0","../job/beam_195-201.dat")
      #njb=ncread("njb","e:s0","../job/beam_195-201_1000m.dat")
      npllgs(njb)
      text(0.8,0.7,g5(n3700.spec.max()/1.e6/njb.s0.max()))

      print("emit: ",g5(n3700.spec.max()/1.e6/nje.s0.max()))
      print("beam: ",g5(n3700.spec.max()/1.e6/njb.s0.max()))

      if ibck:
        eh = hs0.x
        s0h = hs0.y
        nbck=ncread("nbck","e:s0:s1:s2:s3","wave_stokes_selected.dat.bck")
        npllbs(nbck,"e:s0/1.e6")
        ebck = nbck.e
        s0bck = nbck.s0/1.e6
        vm = (s0bck+s0h)/2.0
        vplxy(eh,vm,"sameline",color='c')
      #endif bck

    #endif

  elif args[1] == "ray":

    if nargs > 2:  fray = args[2]
    else:          fray = "wave_ray.dat"

    waveray("hray",fray)
    Quit()

  elif args[1] == "stokesveraltet":

    #        optconsole()
    #        set_console_title("wavesDefault")

    if os.path.exists("WAVE.mhb"):
      import waveplot as w
      from waveplot import *
      n222=nget("n222")
      ncs0=ncread("ncs0","ener:s0:s1:s2:s3","wave_stokes__selected.dat",skiphead=2)
      ncs0f=ncread("ncs0f","ener:s0:s1:s2:s3","wave_stokesf__selected.dat",skiphead=2)
      ncs0e=ncread("ncs0e","ener:s0:s1:s2:s3","wave_stokese__selected.dat",skiphead=2)
      ncs0ef=ncread("ncs0ef","ener:s0:s1:s2:s3","wave_stokesef__selected.dat",skiphead=2)
      ns0=ncread("ns0","ener:s0:s1:s2:s3","wave_stokes_flux.dat",skiphead=2)
      ns0f=ncread("ns0f","ener:s0:s1:s2:s3","wave_stokesf_flux.dat",skiphead=2)
      ns0e=ncread("ns0e","ener:s0:s1:s2:s3","wave_stokese_flux.dat",skiphead=2)
      ns0ef=ncread("ns0ef","ener:s0:s1:s2:s3","wave_stokesef_flux.dat",skiphead=2)
      iflux=1
      if iflux == 1:
        #                zone(1,2)
        #                npl(ns0,"ener:s0")
        nnpl(ns0ef,"ener:s0","s0>1.")
        ene=(Wfhig+Wflow)/2.
        pp("wave_stokesef_flux_" + str(Wpinw*1000.) + "mm_x_" + str(Wpinh*1000) + "mm_" + str(ene) + "eV.pdf")
        #endif iflux == 1:
        Quit()
      #endif
    #endif

  elif args[1] == "by":

    #        optconsole()
    #        set_console_title("wavesDefault")

    try:
      if os.path.exists("WAVE.mhb"):
        import waveplot as w
        from waveplot import *
        n222=nget("n222")
        nby()
      #endif
    except: Quit()

  elif args[1] == "b" or args[1] == "byz":

    #        optconsole()
    #        set_console_title("wavesDefault")

    import waveplot as w
    from waveplot import *

    try:
      if os.path.exists("WAVE.mhb"):
        n222=nget("n222")
        nbybz()
      #endif
    except:
      nlist()
    #endtry

  elif args[1] == "zy" or args[1] == "yz":

    #        optconsole()
    #        set_console_title("wavesDefault")

    try:
      if os.path.exists("WAVE.mhb"):
        import waveplot as w
        from waveplot import *
        n222=nget("n222")
        nzy()
      #endif
    except: Quit()

  elif args[1] == "zby" or args[1] == "zb":

    # optconsole()
    set_console_title("wavesDefault")

    import waveplot as w
    from waveplot import *
    n222=nget("n222")
    zone(1,2)
    nby()
    nextzone()
    nz()

  elif args[1] == "z":

    #        optconsole()
    #        set_console_title("wavesDefault")

    if os.path.exists("WAVE.mhb"):
      import waveplot as w
      from waveplot import *
      n222=nget("n222")
      nz()
    #endif

  elif args[1] == "y":

    #        optconsole()
    #        set_console_title("wavesDefault")

    if os.path.exists("WAVE.mhb"):
      import waveplot as w
      from waveplot import *
      n222=nget("n222")
      ny()
    #endif

  elif args[1] == "zp":

    #        optconsole()
    #        set_console_title("wavesDefault")

    if os.path.exists("WAVE.mhb"):
      import waveplot as w
      from waveplot import *
      n222=nget("n222")
      nzp()
    #endif

  elif args[1] == "messmodel":

    optconsole()
    set_console_title("wavesDefault")

    if os.path.exists("WAVE.mhb"):
      import waveplot as w
      from waveplot import *
      nhal=ncread("nhal","x:z:zp:by","model.dat",skiphead=1)
      nmess=ncread("nmess","x:z:zp:by","mess.dat",skiphead=1)
      #            zone(1,2)
      #            sel = 'abs(x+0.5)<0.1'
      #            nplc(nhal,"x:by",sel)
      #            nplcgs("n10","x:by",sel)
      #            sel = 'abs(x+1.9)<0.1'
      zone(1,3)
      sel = 'abs(x+1.832)<0.01'
      nplc("n10","x:by",sel)
      nplcgs(nmess,"x:by",sel)
      sel = 'abs(x+1.218)<0.01'
      nnplc("n10","x:by",sel)
      nplcgs(nmess,"x:by",sel)
      sel = 'abs(x+0.535)<0.01'
      nnplc("n10","x:by",sel)
      nplcgs(nmess,"x:by",sel)
      #            sel = 'abs(x+1.9)<0.1'
    #endif

  elif args[1] == "n9988":

    optconsole()
    set_console_title("wavesDefault")

    if os.path.exists("WAVE.mhb"):
      import waveplot as w
      from waveplot import *

      n99=ncread("n99","l:x:y:z:s:vx:vy:vz:b","fort.99")
      n88m=ncread("n88m","x:z:b:ang","mrad.88")
      n88w=ncread("n88w","x:z:b:ang","wave.88")
      n10=nget("n10")

      zone(1,3)

      sel="abs(x-0.55)<1."
      sell="l==9 and " + sel

      dot()
      npl(n10,"x:by",sel)
      #nplmls(n88m,"x:b","abs(x-0.6)<0.1")
      nplmls(n99,"x:b",sell)
      #nplmls(n88w,"x:b",sel)

      nextzone()
      #nplmls(n88m,"x:ang*0.017453292519943295e3","abs(x-0.6)<0.1")
      npl(n10,"x:atand(vz/vx)",sel)
      nplmgs(n99,"x:atand(vz/vx)",sell)
      #nplmgs(n88w,"x:ang*0.017453292519943295e3","abs(x-0.6)<0.1")
      #nplmgs(n99,"x:z*1000")            nextzone()

      nextzone()
      npl(n10,"x:z",sel)
      nplmgs(n99,"x:z",sell)

    else:
      print("*** WAVE.mhb not found, nothing to plot ***")
    #endif

    get_console("wavesDefault")
    wans('Hit Q or q to quit:')

  elif args[1] == "Byz":

    optconsole()
    set_console_title("wavesDefault")

    if os.path.exists("WAVE.mhb"):
      import waveplot as w
      from waveplot import *
      zone(1,2)
      nbybz()
      nextzone()
      nyz()
    else:
      print("*** WAVE.mhb not found, nothing to plot ***")
    #endif

    get_console("wavesDefault")
    wans('Hit Q or q to quit:')

  elif args[1] == "maus":
    set_console_title("wavesPython")
    nmd= ncread("nmd","x:z","maus_disp.dat")
    nms= ncread("nms","x:zp","maus_slope.dat")

  elif args[1] == "tribs_UE52":
    import waveplot as w
    from waveplot import *
    ntribs=ncread("ntribs","i:elem:s:z1:z2:z3:zp1:zp2:zp3","tribs_separation_displacement_angle.dat",skiphead=3)
    #nplc("n10","x:by","abs(x)<4.5")
    #        zone(2,1)
    nplm("n10","x:z*1000.","abs(x)<4.5",color='black')
    #        nplcs(ntribs,"s-75.:z3*1000.","abs(s-75.)<5") #IVUE32
    nplcrs(ntribs,"s-120.:z1*1000.","abs(s-120.)<5") #UE52
    nplcbs(ntribs,"s-120.:z2*1000.","abs(s-120.)<5") #UE52
    nplcgs(ntribs,"s-120.:z3*1000.","abs(s-120.)<5") #UE52
    txyz("UE52, TRIBS","x [m]","z [mm]")
    pp("ue52_tribs_z_vs_x.pdf")
    #        nextzone()
    #        ndistpow()
    #        os.system("cp waveplot_3.dat ivue32_power_upstream_dipole_island-3.dat")
    #        pp("ivue32_power_upstream_dipole_island-3.pdf")
  elif args[1] == "tribs_CPMU17":

    import waveplot as w
    from waveplot import *

    ntribs=ncread("ntribs","i:elem:s:z1:z2:z3:zp1:zp2:zp3","tribs_separation_displacement_angle.dat",skiphead=3)

    n10 = nget("n10")
    xmin = max(n10.x.min(),-4.6)
    xmax = n10.x.max()

    selx = "x >= " + str(xmin)
    sels = "s-165. >= " + str(xmin) + " and s-165. <= " + str(xmax)

    ms()
    nplm("n10","x:z*1000.",selx,color='black',legend='WAVE')

    nplcrs(ntribs,"s-165.:z1*1000.",sels,legend='Turn 1') #CPMU17
    nplcbs(ntribs,"s-165.:z2*1000.",sels,legend='Turn 2') #CPMU17
    nplcgs(ntribs,"s-165.:z3*1000.",sels,legend='Turn 3') #CPMU17

    legend()

    txyz("CPMU17, TRIBS","x [m]","z [mm]")
    pp("cpmu17_tribs_z_vs_x_"+ str(w.Wrun) + ".pdf")

  elif args[1] == "beta":
    import waveplot as w
    from waveplot import *
    optnstat()
    hbeta()
    #nbs=ncread("nbs","x:bx:by","~/spectra/betas.dat",skiphead=1)
    #setlinestyle("dashed")
    #nplcgs(nbs,"x:bx")
    #nplccs(nbs,"x:by")

  elif args[1] == "u41":
    nf81 = ncread("nf81","z:byi:bzi","sw2281_fit.dat")
    nw=ncread("nw","m:z:byi:bzi","fort.99")
    zone(2,1)
    nplc(nf81,"z:byi")
    nplms(nw,"z:byi","m==1")
    nextzone()
    nplc(nf81,"z:bzi")
    wans()

  elif args[1] == "u41fit":

    for i in range(9):
      com='n228'+str(i+1)+' = ncread("n228'+str(i+1)+'","z:byi:bzi","u41_field_integrals/Daten/sw228'+str(i+1)+'.yz1",skiphead=1)'
      exec(com)
    #endfor
    for i in range(2):
      com='n229'+str(i)+' = ncread("n229'+str(i)+'","z:byi:bzi","u41_field_integrals/Daten/sw229'+str(i)+'.yz1",skiphead=1)'
      exec(com)
    #endfor
    nlist()
    zone(2,1)

    nfitxy(n2282,"z/1000.:byi/1000.","",6)
    nf2282y=ncopn("Nfitxy","nf2282y")
    nf2282y.columns = ['z','byi','ey','fit']

    nfitxy(n2282,"z/1000.:bzi/1000.","",6)
    nf2282z=ncopn("Nfitxy","nf2282z")
    nf2282z.columns = ['z','bzi','ey','fit']

    n2282f = nmerge("nf2282y","nf2282z","n2282f","z:byi:fit","bzi:fit","z:byi:fy:bzi:fz")

    npl(n2282f,"z:byi")
    nplcs(n2282f,"z:fy")
    txyz("sw2282.yz1","z/m","ByInt1/Tm")

    nextzone()

    npl(n2282f,"z:bzi")
    nplcs(n2282f,"z:fz")
    txyz("sw2282.yz1","z/m","BzInt1/Tm")

    ndump(n2282f,"z:fy:fz","","sw2282_fit.dat")
    pp("sw2282_yz1.pdf")

    nextzone()
    npl(n2281,"z:byi")
    nplmbs(n2282,"z:byi")
    nplmgs(n2283,"z:byi")
    txyz("sw228-1/2/3.yz1","z/m","ByInt1/Tm")

    nextzone()
    npl(n2281,"z:bzi")
    nplmbs(n2282,"z:bzi")
    nplmgs(n2283,"z:bzi")
    txyz("sw228-1/2/3.yz1","z/m","BzInt1/Tm")
    pp("sw228_1_2_3_yz1.pdf")

  elif args[1] == "power_cpmu17":
    import waveplot as w
    from waveplot import *
    import cpmu17_power
    from cpmu17_power import *
    cpmu17_power()
  elif args[1] == "power":
    import waveplot as w
    from waveplot import *
    #        null()
    #        w,h=getplotsize()
    #        print(w,h)
    #        setplotsize(plt.gcf(),w,h)

    ndistpow()
  elif args[1] == "trib":
    #import waveplot as w
    #from waveplot import *
    set_console_title("wavesPython")
    nref = ncread('nref',"xr:yr:zr:ypr:zpr","traj_ref.dat")
    ntra = ncread('ntra',"x:y:z:yp:zp","traj_trib.dat")
    ntrib = nmerge(ntra,nref,"ntrib")
    nmd= ncread("nmd","x:z","./res_SepOrbitAngle_T6EMIL_1-turn_displacement_maus.dat")
    nms= ncread("nms","x:zp","res_SepOrbitAngle_T6EMIL_1-turn_slope_maus.dat")
    zone(1,2)
    null(nref.xr.min(),nref.xr.max(),-10.,10.)
    nplcbs(nmd,"x-165.:z")
    nplcs(ntrib,"x:z-zr")
    txyz("CPMU17 - TRIBS","x [m]","z [mm]")
    nextzone()
    null(nref.xr.min(),nref.xr.max(),-8.,8)
    nplcbs(nms,"x-165.:zp")
    nplcs(ntrib,"x:zp-zpr","x>-5.2 and x<=0")
    txyz("","x [m]","zp [mm]")
    pp("cpmu17_trib_vergleich.pdf")
    get_console()
    wans('Hit Q or q to quit:')

  elif args[1] == "track":
    import waveplot as w
    from waveplot import *
    set_console_title("wavesPython")
    optconsole()
    ndump("n20","x:by","x<0.0","traj.dat")
    Quit()
    get_console()
    wans('Hit Q or q to quit:')
  #endif arg1

  get_console()
  wans('Hit Q or q to quit:')
#endif nargs > 1

if not ntuples:
    for n in range(len(Nhead)):
        snam = Nhead[n][1]
        exec(snam + ' = nget("' + snam + '")')
    #endfor
#endif

if histos:
  for hh in H1head:
    snam = hh[0]
    exec(snam + ' = hget("' + snam + '")')
  #endfor
  for hh in H2head:
    snam = hh[0]
    exec(snam + ' = hget("' + snam + '")')
  #endfor
#endif
+PATCH,URADPHASE.
*CMZ :  4.01/00 15/01/2023  16.23.59  by  Michael Scheer
+KEEP,uradphasemod.
*CMZ :          07/11/2023  10.39.27  by  Michael Scheer
*CMZ :  4.01/02 12/05/2023  13.39.18  by  Michael Scheer
*CMZ :  4.01/00 13/02/2023  10.56.51  by  Michael Scheer
*-- Author :    Michael Scheer   14/01/2023
      module uradphasemod

      double precision, dimension(:,:), allocatable :: obsv_u, stokes_u,
     &  track_u, fbunch_u
      double precision, dimension(:), allocatable ::  epho_u,specpow_u,pow_u

      double complex, dimension(:,:), allocatable :: arad_u

      double precision
     &  ebeam_u,gamma_u,curr_u,banwid_u,
     &  xi_u,xe_u,yi_u,ye_u,zi_u,ze_u,step_u,
     &  pincen_u(3),pinw_u,pinh_u,
     &  ephmin_u,ephmax_u,emith_u,emitv_u,
     &  perlen_u,shift_u,beffv_u,beffh_u,pherror_u,
     &  xbeta_u,betah_u,alphah_u,betav_u,alphav_u,espread_u,
     &  disph_u,dispph_u,dispv_u,disppv_u,bunchlen_u,bunchcharge_u

      integer nstep_u,nepho_u,nobsv_u,nbunch_u,npiny_u,npinz_u,
     &  nper_u,modeph_u,modepin_u,modesphere_u,noranone_u

      integer
     &  ibunch_u,ihbunch_u,mthreads_u,nelec_u,icohere_u,modebunch_u

      end module uradphasemod
+DECK,urad_phase_main,T=F77.
*CMZ :          07/11/2023  10.39.27  by  Michael Scheer
*CMZ :  4.01/03 17/05/2023  10.57.05  by  Michael Scheer
*CMZ :  4.01/02 12/05/2023  13.32.32  by  Michael Scheer
*CMZ :  4.01/00 22/02/2023  14.57.49  by  Michael Scheer
*-- Author : Michael Scheer
+seq,gplhint.
      program urad_phase_main

      use omp_lib
      use uradphasemod

      implicit none

+seq,phyconparam.

      double precision, dimension(:), allocatable :: z,y
      double precision, dimension(:,:), allocatable :: s

      double precision :: banwid=0.1,xbeta=0.0d0,
     &  perlen,shift,ebeam,curr,step,perl,
     &  pincen(3),pinw,pinh,park,wlen1,gamma,
     &  ephmin,ephmax,beffv,beffh,pherror,stosum(4),
     &  alphah,alphav,espread,harm,b0eff,rhv,
     &  betah,betav,eps0h,eps0v,pinx,piny,pinz,
     &  disph,dispph,dispv,disppv,bunchcharge,bunchlen,efi(3),bfi(3),rn(3),
     &  emith,emitv

      real xran(1),rr(2),axr,axi,ayr,ayi,azr,azi

      integer :: idebug=1,noranone,i,
     &  npiny,npinz,nper,nepho,modeph,modepin,modesphere,nharm,iy,iz,iobs,
     &  mthreads,nelec,icohere,ihbunch,ipho,iobph,iel,modebunch,
     &  modewave=0,isto

      namelist/uradphasen/
     &  perlen,shift,nper,beffv,beffh,
     &  ebeam,curr,step,noranone,
     &  pinx,piny,pinz,pinw,pinh,npiny,npinz,modepin,modesphere,nharm,harm,
     &  nepho,ephmin,ephmax,pherror,
     &  mthreads,nelec,icohere,ihbunch,modeph,modebunch,
     &  betah,betav,alphah,alphav,emith,emitv,espread,
     &  disph,dispph,dispv,disppv,bunchcharge,bunchlen

      integer :: irnsize=64,irnseed(64),ifixseed
      namelist/seedn/irnseed,ifixseed

      integer :: luna,istat,kalloc=1

      open(newunit=luna,file='urad_phase.nam',status='old',iostat=istat)
      if (istat.ne.0) then
        stop "*** Error: Could not open urad_phase.nam"
      endif

      read(luna,uradphasen)
      read(luna,seedn)

      close(luna)

      if(nelec.eq.1.and.noranone.eq.0) then
        noranone=1
        print*
        print*,'*** Changed NORANONE=0 to NORANONE=1, NELEC=1'
        print*
      endif

      pincen=[pinx,piny,pinz]
      eps0h=emith*1.0d-9
      eps0v=emitv*1.0d-9

      bunchlen=bunchlen/1.0d9 !nm->m

      !print*,"sigz, sizp:",sigz/1000.0d0,sigzp/1000.0d0
      !print*,"sigy, siyp:",sigy/1000.0d0,sigyp/1000.0d0

      if (ifixseed.ne.0) then
        ifixseed=1
        call util_random_set_seed(irnsize,irnseed)
      endif

      if (nharm.gt.0.and.harm.gt.0.0d0) then

        gamma=ebeam/emassg1
        wlen1=wtoe1/abs(harm/nharm)
        perl=perlen/1000.0d0
        park=2.0d0*(wlen1/(perl*1.0d9/2.0d0/gamma**2)-1.0d0)

        if (park.lt.0.0d0) then
          write(6,*)
     &      '*** Error in urad_phase_main:'
          write(6,*)
     &      'Inconsistent values of nharm, harm, and perlen'
          write(6,*)' '
          stop
        endif

        park=sqrt(park)
        b0eff=park/(echarge1*perl/(2.*pi1*emasskg1*clight1))

        if (beffh.eq.0.0d0.and.beffv.ne.0d0) then
          beffv=beffv/abs(beffv)*b0eff
        else if (beffv.eq.0.0d0.and.beffh.ne.0d0) then
          beffh=beffh/abs(beffh)*b0eff
        else
          rhv=beffh/beffv
          beffh=b0eff/sqrt(1.0d0+1.0d0/rhv**2)*beffh/abs(beffh)
          beffv=beffh/rhv
        endif

      endif

      npiny=max(1,npiny)
      npinz=max(1,npinz)

      open(newunit=luna,file='urad_phase.pin')
      write(luna,*)npinz,npiny,pinw,pinh
      write(luna,*)pincen
      close(luna)

      if (mthreads.lt.0) then
        mthreads=OMP_GET_MAX_THREADS()
      else if (mthreads.eq.0) then
        mthreads=1
      endif

      call urad_phase(
     &  mthreads,nelec,noranone,icohere,modebunch,bunchlen,bunchcharge,ihbunch,
     &  perlen,shift,nper,beffv,beffh,
     &  ebeam,curr,step,
     &  pincen,pinw,pinh,npiny,npinz,modepin,modesphere,
     &  nepho,ephmin,ephmax,banwid,
     &  xbeta,betah,alphah,betav,alphav,espread,emith,emitv,
     &  disph,dispph,dispv,disppv,
     &  modeph,pherror,modewave
     &  )

      if (idebug.ne.0) call util_break

c      open(newunit=luna,file='urad_phase.sto')
c      do iobs=1,nobsv_u
c        do ipho=1,nepho_u
c          iobph=iobs+nobsv_u*(ipho-1)
c          write(luna,*)obsv_u(1:3,iobs),ipho,epho_u(ipho),stokes_u(1:4,iobph)
c        enddo
c      enddo
c      close(luna)

      open(newunit=luna,file='urad_phase.fld')
      do iobs=1,nobsv_u
        do ipho=1,nepho_u
          iobph=iobs+nobsv_u*(ipho-1)
          efi=real(arad_u(1:3,iobph))
          bfi=real(arad_u(4:6,iobph))
          rn(1)=efi(2)*bfi(3)-efi(3)*bfi(2)
          rn(2)=efi(3)*bfi(1)-efi(1)*bfi(3)
          rn(3)=efi(1)*bfi(2)-efi(2)*bfi(1)
          rn=rn/norm2(rn)
          axr=real(arad_u(1,iobph))
          axi=imag(arad_u(1,iobph))
          ayr=real(arad_u(2,iobph))
          ayi=imag(arad_u(2,iobph))
          azr=real(arad_u(3,iobph))
          azi=imag(arad_u(3,iobph))
          write(luna,'(3(1pe15.6e3),i10,21(1pe15.6e3))')
     &      obsv_u(1:3,iobs),ipho,epho_u(ipho),stokes_u(1:4,iobph),pow_u(iobs),
     &      real(arad_u(1,iobph)),imag(arad_u(1,iobph)),
     &      real(arad_u(2,iobph)),imag(arad_u(2,iobph)),
     &      real(arad_u(3,iobph)),imag(arad_u(3,iobph)),
     &      real(arad_u(4,iobph)),imag(arad_u(4,iobph)),
     &      real(arad_u(5,iobph)),imag(arad_u(5,iobph)),
     &      real(arad_u(6,iobph)),imag(arad_u(6,iobph)),
     &      rn
c          print*,(axr**2+axi**2+ayr**2+ayi**2+azr**2+azi**2)*115370630051.33882/
c     &      stokes_u(1,iobph),stokes_u(1,iobph)
        enddo
      enddo
      close(luna)

      allocate(z(nobsv_u),y(nobsv_u),s(npinz_u,npiny_u))

      open(newunit=luna,file='urad_phase.flx')

      z=obsv_u(3,1:npinz_u)

      do iy=1,npiny_u
        iobs=npinz_u*(iy-1)+iy
        y(iy)=obsv_u(2,iobs)
      enddo

      do ipho=1,nepho_u
        if (modepin.eq.0.and.npinz_u.ge.3.and.npiny_u.ge.3) then
          do isto=1,4
            iobs=0
            do iz=1,npinz_u
              do iy=1,npiny_u
                iobs=iobs+1
                iobph=iobs+nobsv_u*(ipho-1)
                s(iz,iy)=stokes_u(isto,iobph)
              enddo
            enddo
            call util_spline_integral_2d(npinz_u,npiny_u,z,y,s,stosum(isto),
     &        istat,kalloc)
            kalloc=0
          enddo !isto
          write(luna,*)ipho,epho_u(ipho),stosum
        else
          iobs=0
          stosum=0.0d0
          do iz=1,npinz_u
            do iy=1,npiny_u
              iobs=iobs+1
              iobph=iobs+nobsv_u*(ipho-1)
              stosum=stosum+stokes_u(1:4,iobph)
            enddo
          enddo
          write(luna,*)ipho,epho_u(ipho),stosum/nobsv_u*pinw*pinh
        endif
      enddo
      close(luna)

      open(newunit=luna,file='urad_phase.bun')
      if (ihbunch.le.0) then
        write(luna,*)
      else
        do iel=1,nelec_u/ihbunch_u*nepho_u
          if(fbunch_u(21,iel).ne.0.0d0) then
            write(luna,*)fbunch_u(:,iel)
          endif
        enddo
      endif
      close(luna)

      call  util_random_get_seed(irnsize,irnseed)

      open(newunit=luna,file='urad_phase.seeds',status='unknown')
      write(luna,*)irnsize
      do i=1,irnsize
        write(luna,*)i,irnseed(i)
      enddo
      flush(luna)
      close(luna)

      end
+DECK,urad_phase,T=F77.
*CMZ :          07/11/2023  14.55.09  by  Michael Scheer
*CMZ :  4.01/02 12/05/2023  17.13.05  by  Michael Scheer
*CMZ :  4.01/00 21/02/2023  16.51.29  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine urad_phase(
     &  mthreads,nelec,noranone,icohere,modebunch,bunchlen,bunchcharge,ihbunch,
     &  perlen,shift,nper,beffv,beffh,
     &  ebeam,curr,step,
     &  pincen,pinw,pinh,npiny,npinz,modepin,modesphere,
     &  nepho,ephmin,ephmax,banwid,
     &  xbeta,betah,alphah,betav,alphav,espread,emith,emitv,
     &  disph,dispph,dispv,disppv,
     &  modeph,pherror,modewave
     &  )

      use omp_lib
      use uradphasemod

      implicit none

+seq,phyconparam.

      double precision
     &  perlen,shift,ebeam,curr,step,banwid,
     &  pincen(3),pinw,pinh,betah,alphah,betav,alphav,
     &  ephmin,ephmax,beffv,beffh,pherror,espread,emith,emitv,
     &  disph,dispph,dispv,disppv,y,z,dy,dz,ymin,zmin,bunchlen,bunchcharge,
     &  xbeta,df,xx,yy,zz,r,xn,yn,zn

      integer
     &  npiny,npinz,nper,nepho,mthreads,nelec,icohere,ihbunch,i,
     &  modeph,modepin,modesphere,modebunch,iy,iz,iobsv,noranone,modewave

      mthreads_u=mthreads

      nelec_u=nelec
      noranone_u=noranone
      icohere_u=icohere
      modebunch=modebunch_u
      bunchlen_u=bunchlen
      bunchcharge_u=bunchcharge
      ihbunch_u=ihbunch

      perlen_u=perlen/1000.0d0
      shift_u=shift/1000.0d0
      nper_u=nper
      beffv_u=beffv
      beffh_u=beffh

      ebeam_u=ebeam
      gamma_u=ebeam_u/emassg1
      step_u=step/1000.0d0
      nstep_u=max(1,nint(perlen_u/step_u))

      curr_u=curr

      pincen_u=pincen/1000.0d0
      pinw_u=pinw/1000.0d0
      pinh_u=pinh/1000.0d0
      npiny_u=npiny
      npinz_u=npinz
      modepin_u=modepin

      ephmin_u=ephmin_u
      ephmax_u=ephmax_u
      banwid_u=banwid
      nepho_u=nepho

      npiny_u=max(1,npiny_u)
      npinz_u=max(1,npinz_u)

      if (modepin.eq.0) then
        nobsv_u=npiny_u*npinz_u
      else
        npinz_u=1
        npiny_u=1
        nobsv_u=1
      endif

      allocate(epho_u(nepho),obsv_u(3,nobsv_u),
     &  arad_u(6,nobsv_u*nepho_u),
     &  specpow_u(nobsv_u),
     &  fbunch_u(41,nelec_u/max(1,ihbunch_u)*nepho_u),
     &  stokes_u(4,nobsv_u*nepho_u),pow_u(nobsv_u)
     &  )

      stokes_u=0.0d0
      specpow_u=0.0d0
      fbunch_u=0.0d0
      arad_u=(0.0d0,0.0d0)
      pow_u=0.0d0

      if (npiny_u.eq.1) then
        dy=0.0d0
        ymin=pincen_u(2)
      else
        dy=pinh_u/(npiny_u-1)
        ymin=pincen_u(2)-pinh_u/2.0d0
      endif

      if (npinz_u.eq.1) then
        dz=0.0d0
        zmin=pincen_u(3)
      else
        dz=pinw_u/(npinz_u-1)
        zmin=pincen_u(3)-pinw_u/2.0d0
      endif

      iobsv=0
      y=ymin-dy
      do iy=1,npiny_u
        y=y+dy
        z=zmin-dz
        do iz=1,npinz_u
          iobsv=iobsv+1
          z=z+dz
          obsv_u(1,iobsv)=pincen_u(1)
          obsv_u(2,iobsv)=y
          obsv_u(3,iobsv)=z
          if (modesphere.ne.0) then
            !all util_break
            xx=obsv_u(1,iobsv)
            yy=obsv_u(2,iobsv)
            zz=obsv_u(3,iobsv)
            r=sqrt(xx*xx+yy*yy+zz*zz)
            yn=yy/r
            zn=zz/r
            obsv_u(2,iobsv)=yn*xx
            obsv_u(3,iobsv)=zn*xx
          endif
        enddo
      enddo

      nepho_u=max(1,nepho_u)
      if (nepho_u.gt.1) then
        df=(ephmax-ephmin)/(nepho_u-1)
        do i=1,nepho_u
          epho_u(i)=ephmin+(i-1)*df
        enddo
      else
        epho_u(1)=(ephmin+ephmax)/2.0d0
      endif

      xbeta_u=xbeta
      betah_u=betah
      alphah_u=alphah
      betav_u=betav
      alphav_u=alphav
      emith_u=emith
      emitv_u=emitv
      disph_u=disph
      dispph_u=dispph
      dispv_u=dispv
      dispph_u=disppv
      espread_u=espread

      modeph=modeph_u
      pherror_u=pherror

      call urad_amprep(modewave)

      stokes_u=stokes_u/1.0d6 ! photons/mm**2
      fbunch_u(4:14,:)=fbunch_u(4:14,:)*1000.0d0 ! mm
      fbunch_u(17:19,:)=fbunch_u(17:19,:)*1000.0d0 ! mm
      fbunch_u(22:26,:)=fbunch_u(22:26,:)/1.0d6 ! 1/mm**2
      arad_u=arad_u/1.0d3

      obsv_u=obsv_u*1000.0d0

      end
+PATCH,TEST.
*CMZ :  4.01/00 22/02/2023  15.14.45  by  Michael Scheer
+DECK,load_contrl_cmn,T=F77.
*CMZ :          17/10/2023  13.14.01  by  Michael Scheer
*-- Author :    Michael Scheer   17/10/2023
      subroutine load_contrl_cmn
+seq,contrl.
      end
+PATCH,SEQVER.
*CMZ :          07/11/2023  17.41.48  by  Michael Scheer
+DECK,wversdum,T=F77.
*CMZ :          07/11/2023  17.45.05  by  Michael Scheer
*-- Author :    Michael Scheer   07/11/2023
      subroutine wversdum
+seq,wversion.
      return
      end
