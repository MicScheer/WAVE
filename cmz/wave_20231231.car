+PATCH,CMNN						.
*CMZ :  3.01/00 12/07/2013  15.33.12  by  Michael Scheer
+TITLE.
WAVE     4.01/04  28/12/2023  17.35.14
+DECK,good.
*CMZ :  4.01/04 25/11/2023  15.05.11  by  Michael Scheer
*CMZ :  4.01/03 11/06/2023  11.04.36  by  Michael Scheer
*CMZ :  4.00/17 28/11/2022  17.48.39  by  Michael Scheer
*CMZ :  4.00/15 13/03/2022  19.00.20  by  Michael Scheer
*CMZ :  4.00/13 06/12/2021  13.18.24  by  Michael Scheer
*CMZ :  3.08/01 03/04/2019  15.40.06  by  Michael Scheer
*CMZ :  3.07/00 15/03/2019  12.15.25  by  Michael Scheer
*CMZ :  3.06/00 26/02/2019  10.53.54  by  Michael Scheer
*CMZ :  3.05/13 19/09/2018  13.46.31  by  Michael Scheer
*CMZ :  3.05/06 17/07/2018  11.12.29  by  Michael Scheer
*CMZ :  3.05/04 27/06/2018  13.51.56  by  Michael Scheer
*CMZ :  3.05/03 22/05/2018  07.12.30  by  Michael Scheer
*CMZ :  3.05/02 15/05/2018  15.27.15  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE souintana_omp(ISOUR,IOBSV,INSIDE)

+seq,gplhint.
+SEQ,TRACKF90U.
+SEQ,WORKF90U.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,AFREQF90U.
+SEQ,AMPLIF90U.
+SEQ,WFOLDF90U.

      use bunchmod
      use wbetaf90m
      use souintmod

C--- EVALUATE INTEGRALES FOR A SINGLE SOURCE
C---- RESULTS ARE STORE IN AFREQ AND SPECPOW

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,PHYCON.
+SEQ,TRACK.
+seq,sourcef90.
+SEQ,COLLI.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,FREQS.
+SEQ,AMPLI.
+SEQ,B0SCGLOB.
+SEQ,PRIMKIN.
+SEq,wfoldf90.
+seq,ustep.
+SEQ,uservar.
+seq,tralin.
+seq,whbook.
+seq,pawcmn.
+seq,specdip.
+seq,datetime.
+seq,souintanac.

c      double precision ampzmax(ndfreqp)
c      integer kobs(ndfreqp)
c      common/kobsc/ampzmax,kobs

      REAL*8 FSPEC(31)

      double precision rn_cross_beta(3), rn_cross_rn_cross_beta(3)
      double precision h2,ddist,dist0,dist02
     & ,vn,dgamma

c      COMPLEX*16 ZIOM,ZI,ZIDOM,ZONE,ZICR1,ZIC
      COMPLEX*16 EXPOM1,EXPOM,DEXPOMPH1,DEXPOMPH,DDEXPOMPH,DEXPOM,EXPOMV2,
     &  zicr1,baff(3),daff(3)
      COMPLEX*16 APOL,APOLH,APOLR,APOLL,APOL45
     &  ,DMODU,DMODU0,DDMODU,AX,AY,AZ,AX0,AY0,AZ0,bx0,by0,bz0,bxc,byc,bzc

      double precision apz(nfreq),azc(nfreq),azs(nfreq)

      DOUBLE PRECISION T0,T1,T2,TENDSOU,X0,X1,X2,X10,Y1,Y2,Z1,Z2,R0
     &  ,T,DT,DT2,DT0,VXP,VYP,VZP,TENDSOU1
     &  ,R02
c     &  ,H2,H2R2
     &  ,PHI,FREQR,CORRR0,R00,R2,POW,powpow
     &  ,X2B,Y2B,Z2B
     &  ,DGAMSUM,BETA,GAMGAM,GAMGAM0,AMPDT
     &  ,xn1,slopein,slope,drn1,drn2,zn1,yn1,wi,
     &  zz,yy,zzp,yyp,zzi,yyi,yypi,zzpi,
     &  yeleco,zeleco,zpeleco,ypeleco
c     &  ,ef(3),bf(3)

      DOUBLE PRECISION VX1,VY1,VZ1,BX1,BY1,BZ1
      DOUBLE PRECISION VX2,VY2,VZ2,BX2,BY2,BZ2,AX2D,AY2D,AZ2D
      DOUBLE PRECISION ECDUM,BS,BSQ,BS1
      DOUBLE PRECISION TS,DPHASE,DPHSOUR(2,2)
      DOUBLE PRECISION GAMMA

      DOUBLE PRECISION BX,BY,BZ,RX,RY,RZ,PX,PY,PZ,rn,RNBX,RNBY,RNBZ
      DOUBLE PRECISION R1,RNX,RNY,RNZ,DOM1,DOM2,BET1N,DUM11,R,BPX,BPY,BPZ
      DOUBLE PRECISION WGANG,OPANG

      DOUBLE PRECISION RARG(5),PHASE,t0ph

      DOUBLE PRECISION DROIX,DTPHASE,DXEXI,CENXEXI
      DOUBLE PRECISION STOK1,STOK2,STOK3,STOK4,BET1NO
      double precision br2,rnr2,br4,rnr4,b3
     &  ,are(6),aim(6),yp2zp2i,robsv,phiobsv,
     &  f(3),yp(3),ypp,a(3),fdt(3),filo,fihi,dfdt,xobsv,yobsv,zobsv,speck,
     &  tfmh(2,2),tfmv(2,2),tfm1(2,2),
     &  w22(2,2),dum22(2,2),
     &  tfmhi(2,2),tfmvi(2,2),
     &  tfmdehi(2,2),tfmdevi(2,2),
     &  tfmdeh(2,2),tfmdev(2,2),
     &  tfmhc(2,2),tfmvc(2,2),
     &  tfmdehc(2,2),tfmdevc(2,2),
     &  tfmhtoti(2,2),tfmvtoti(2,2),
     &  tfmdehtoti(2,2),tfmdevtoti(2,2)
     &  ,rq,cpsi,alpha,spsi,rm,betafun,psi
     &  ,alpha0(2),beta0(2)

      real*8 fillb(29)
      real rnrn(2)
      INTEGER IINSIDE,JINSIDE,INSIDE,iw2(2),ifail
      INTEGER ISOUR,isourold,IOBSV,kfreq,JFREQ,IZAEHL,NZAEHL,I,ICAL,ICOMP
      INTEGER ICSPL,IROI,II,IZTOTS,LSTEP,IR1,IR2
      integer job,jfrob,norad,iwarnwi,kfrob,jliobfr,jliob,jobfr

      INTEGER IC
      INTEGER jpin
      common /souintc/ jpin

      REAL*8 FILLT(NTUPP)
      CHARACTER(5) CTUP(NTUPP)

      DOUBLE PRECISION wth,wta,
     &                H6,H26,A2,A21H6,A3AH26,B,B2,B21H6,B3BH26,DT10
      integer icount,mode,klo,khi,k

      integer :: kmode=0

      data ctup /'t','x','y','z','rx','ry','rz','rt','p','expr','expi','roi'
     &  ,'iob','ie','yob','zob','bet1n','om','dt','by2','isou'
     &  ,'spec','reax','imax','reay','imay','reaz','imaz','dom1',
     &  'betx','bety','betz','betxp','betyp','betzp','nx','ny','nz'/

      DATA isourold/0/
      DATA ICAL/0/
      DATA tfm1(1,1),tfm1(1,2),tfm1(2,1),tfm1(2,2)/1.0d0,0.0d0,0.0d0,1.0d0/
c      DATA ZI/(0.0D0,1.0D0)/
c      DATA ZONE/(1.0D0,0.0D0)/
c      DATA IWARNBET1N/0/

      ypeleco=vyelec/vxelec
      zpeleco=vzelec/vxelec
      zeleco=zelec
      yeleco=yelec

c Transfermatrices

      if (ibunch.ne.0.and.iampli.lt.0.and.isour.ne.isourold) then

        tfmh=tfm1
        tfmv=tfm1
        tfmhc=tfm1
        tfmvc=tfm1
        tfmhtoti=tfm1
        tfmvtoti=tfm1

        tfmdeh=tfm1
        tfmdev=tfm1
        tfmdehc=tfm1
        tfmdevc=tfm1
        tfmdehtoti=tfm1
        tfmdevtoti=tfm1

        x1=sourceao(1,1,isour)
        y1=sourceao(2,1,isour)
        z1=sourceao(3,1,isour)

        x2=sourceeo(1,1,isour)

        alpha0(1)=-wbetasub(3,1)/2.d0
        alpha0(2)=-wbetasub(5,1)/2.d0
        beta0(1)=wbetasub(2,1)
        beta0(2)=wbetasub(4,1)

        if (alpha0(1).gt.0.001) then
          write(6,*)' '
          write(6,*)'*** Warning in souintana_omp: Derivative of hori. beta function'
          write(6,*)'beginnning of the source is greater than 0.001!'
          write(6,*)' '
        endif

        if (alpha0(2).gt.0.001) then
          write(lungfo,*)' '
          write(lungfo,*)'*** Warning in souintana_omp: Derivative of vert. beta function'
          write(lungfo,*)'in source center is greater than 0.001!'
          write(lungfo,*)'source center:',(x1+x2)/2.0d0
          write(lungfo,*)'beta, alpha:',beta0(2),alpha0(2)
          write(lungfo,*)'Maybe it is useful, to set IBL0CUT'
          write(lungfo,*)' '
          write(6,*)' '
          write(6,*)'*** Warning in souintana_omp: Derivative of vert. beta function'
          write(6,*)'in source center is greater than 0.001!'
          write(6,*)'source center:',(x1+x2)/2.0d0
          write(6,*)'beta, alpha:',beta0(2),alpha0(2)
          write(6,*)'Maybe it is useful, to set IBL0CUT'
          write(6,*)' '
        endif

        alpha=-wbetasub(3,3)/2.0d0
        betafun=  wbetasub(2,3)
        psi=   wbetasub(8,3)

        cpsi=cos(psi)
        spsi=sin(psi)
        rq=sqrt(betafun/beta0(1))
        rm=sqrt(betafun*beta0(1))

        tfmhc(1,1) = rq * (cpsi+alpha0(1)*spsi)
        tfmhc(1,2) = rm * spsi
        tfmhc(2,1)=
     &    ((alpha0(1)-alpha)*cpsi - (1.0d0+alpha0(1)*alpha)*spsi) / rm
        tfmhc(2,2)=
     &    (cpsi-alpha*spsi) / rq

        alpha=-wbetasub(5,3)/2.d0
        betafun=  wbetasub(4,3)
        psi=   wbetasub(9,3)

        cpsi=cos(psi)
        spsi=sin(psi)
        rq=sqrt(betafun/beta0(2))
        rm=sqrt(betafun*beta0(2))

        tfmvc(1,1) = rq * (cpsi+alpha0(2)*spsi)
        tfmvc(1,2) = rm * spsi
        tfmvc(2,1)=
     &    ((alpha0(2)-alpha)*cpsi - (1.0d0+alpha0(2)*alpha)*spsi) / rm
        tfmvc(2,2)=
     &    (cpsi-alpha*spsi) / rq

        alpha=-wbetasub(3,3)/2.d0
        betafun=  wbetasub(2,3)
        psi=   wbetasub(8,3)

        cpsi=cos(psi)
        spsi=sin(psi)
        rq=sqrt(betafun/beta0(1))
        rm=sqrt(betafun*beta0(1))

        tfmh(1,1) = rq * (cpsi+alpha0(1)*spsi)
        tfmh(1,2) = rm * spsi
        tfmh(2,1)=
     &    ((alpha0(1)-alpha)*cpsi - (1.0d0+alpha0(1)*alpha)*spsi) / rm
        tfmh(2,2)=
     &    (cpsi-alpha*spsi) / rq

        alpha=-wbetasub(5,3)/2.d0
        betafun=  wbetasub(4,3)
        psi=   wbetasub(9,3)

        cpsi=cos(psi)
        spsi=sin(psi)
        rq=sqrt(betafun/beta0(2))
        rm=sqrt(betafun*beta0(2))

        tfmv(1,1) = rq * (cpsi+alpha0(2)*spsi)
        tfmv(1,2) = rm * spsi
        tfmv(2,1)=
     &    ((alpha0(2)-alpha)*cpsi - (1.0d0+alpha0(2)*alpha)*spsi) / rm
        tfmv(2,2)=
     &    (cpsi-alpha*spsi) / rq

        w22=tfmh

        dum22(1,1)=1.0d0
        dum22(1,2)=0.0d0
        dum22(2,1)=0.0d0
        dum22(2,2)=1.0d0

        call deqinv(2,w22,2,iw2,ifail,2,dum22)

        if (ifail.ne.0) then
          write(6,*)'*** Error in souintana_omp: Matrix invertation failed'
          write(6,*)'Please check horizontal beta functions.'
          write(lungfo,*)'*** Error in souintana_omp: Matrix invertation failed'
          write(lungfo,*)'Please check horizontal beta functions.'
          stop '*** Program WAVE aborted ***'
        endif

        tfmhi=w22

        w22=tfmv

        dum22(1,1)=1.0d0
        dum22(1,2)=0.0d0
        dum22(2,1)=0.0d0
        dum22(2,2)=1.0d0

        call deqinv(2,w22,2,iw2,ifail,2,dum22)

        if (ifail.ne.0) then
          write(6,*)'*** Error in souintana_omp: Matrix invertation failed'
          write(6,*)'Please check vertical beta functions.'
          write(lungfo,*)'*** Error in souintana_omp: Matrix invertation failed'
          write(lungfo,*)'Please check vertical beta functions.'
          stop '*** Program WAVE aborted ***'
        endif

        tfmvi=w22

        tfmdehi=tfmhi
        tfmdevi=tfmvi

        tfmhtoti=tfmhi
        tfmvtoti=tfmvi

        if (iampli.lt.0) then
          do i=1,-iampli/2-1
            call util_matrix_multiplication(2,2,2,tfmhtoti,tfmhi,tfmhtoti,w22)
            call util_matrix_multiplication(2,2,2,tfmvtoti,tfmvi,tfmvtoti,w22)
          enddo
          tfmdehtoti=tfmhtoti
          tfmdevtoti=tfmhtoti
        endif

      endif !isour

      if (inside.ne.-3.or.ielec.eq.1) then
        xobsv=obsv(1,iobsv)
        yobsv=obsv(2,iobsv)
        zobsv=obsv(3,iobsv)
      else
        call grndmm(rnrn,2)  !s. 39
        xobsv=obsv(1,iobsv)
        yobsv=pincen(2)-pinh/2.0d0+rnrn(1)*pinh
        zobsv=pincen(3)-pinw/2.0d0+rnrn(2)*pinw
        if (ipincirc.ne.0) then
          yobsv=1.0d30
          zobsv=1.0d30
          do while (sqrt(yobsv**2+zobsv**2).gt.pinr)
            call grndmm(rnrn,2)  !s. 39
            yobsv=(rnrn(1)-0.5)*2.0d0*pinr
            zobsv=(rnrn(2)-0.5)*2.0d0*pinr
          enddo
          yobsv=pincen(2)+yobsv
          zobsv=pincen(3)+zobsv
        endif
      endif

      IF (jpin.ne.3.and.ielec.eq.1.and.IOBSV.EQ.jobunch
     &    .or.jpin.eq.3.and.ielec.eq.1) THEN

        WRITE(LUNGFO,*)'            SOURCE NUMBER',ISOUR,':'
        WRITE(LUNGFO,*)

        ampzmax(1:nfreq)=0.0d0
        azcos(1:nfreq)=1.0d0
        azsin(1:nfreq)=0.0d0

        X1=xelec

      ENDIF !IF (ielec.eq.1.and.IOBSV.EQ.jobunch) THEN

      jliob=ISOUR+NSOURCE*(IOBSV-1)
c?6.11.      if (jpin.ne.3.or.jpin.eq.3.and.ielec.eq.1) SPECPOW(jliob)=0.0D0

      LSTEP=0
      DGAMSUM=0.0D0

      gamma=egamma
      beta=dsqrt((1.d0-1.d0/gamma)*(1.d0+1.d0/gamma))

      WGANG=WGWINFC/GAMMA

      ICSPL=0

      if (inside.ne.-3) then
        INSIDE=1
        iinside=-1
      endif
      IINSIDE=0
      JINSIDE=0

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS     T=-R0*C1
      T=0.0D0 !WICHTIG HIER WEGEN TENDSOU-T WEITER UNTEN

      IF (ISPECMODE.EQ.1) THEN
        T0=DWT(1)
        T1=T0
        T2=DWT(MCO)
c        XENDSOU=DWX(MCO)    !FINAL X
      ELSE
        T0=SOURCET(1,ISOUR)
        T1=T0
        T2=SOURCET(2,ISOUR)
c        XENDSOU=SOURCEEO(1,1,ISOUR)    !FINAL X
      ENDIF

      TENDSOU=T2-T1

      IF (X1.LT.roi(1,1).OR.XENDSOU.GT.roi(1,NROIA)) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN souintana_omp: X OUTSIDE ROIS ***'
        WRITE(LUNGFO,*)'CHECK NAMELIST $ROIN'
        WRITE(LUNGFO,*)' *** PROGRAM WAVE ABORTED ***'
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN souintana_omp: X OUTSIDE ROIS ***'
        WRITE(6,*)'CHECK NAMELIST $ROIN'
        WRITE(6,*)' *** PROGRAM WAVE ABORTED ***'
        STOP
      ENDIF   !IROI

      X1=xelec
      Y1=yelec
      Z1=zelec

      VX1=vxelec
      VY1=vyelec
      VZ1=vzelec

      BX1=SOURCEAO(1,4,ISOUR)
      BY1=SOURCEAO(2,4,ISOUR)
      BZ1=SOURCEAO(3,4,ISOUR)
      BS1=SQRT(BX1**2+BY1**2+BZ1**2)

      IZTOTS=0

      X0=X1
      X2=X1
      X10=(XENDSOU-X0)/10.1D0

      NZAEHL=NLPOIO
c      DT0=TENDSOU/NZAEHL
      DT0=TENDSOU/dble(NZAEHL-1)

      DT=DT0
+self,if=kzaehl.
      if (ielec.eq.1) then

        KZAEHL=0

        IR1=-1
        DO IROI=1,NROIA
          IF (ROI(IROI).GT.X1.AND.ROI(IROI).LT.XENDSOU.AND.IR1.EQ.-1) THEN
            IR1=IROI
            GOTO 11
          ENDIF
        ENDDO

11      DO IROI=1,NROIA
          IR2=IROI
          IF (ROI(IROI).GT.XENDSOU) THEN
            ROI(IROI)=XENDSOU
            IR2=IR2-1
            IF (ROI(IR2).LT.X1) THEN
              ROI(IR2)=X1
            ENDIF
            GOTO 12
          ENDIF
        ENDDO

12      CONTINUE

        KZAEHL=KZAEHL+NZAEHL*roi(2,IR2)*(XENDSOU-ROI(IR2))/(XENDSOU-X1)

        IF (IR1.NE.-1) THEN

          KZAEHL=KZAEHL+NZAEHL*roi(2,IR1-1)*(ROI(IR1)-X1)/(XENDSOU-X1)

          DO IROI=IR1,IR2-1
            IF (ROI(IROI).GT.X1.OR.ROI(IROI)+1.LT.XENDSOU) THEN
              KZAEHL=KZAEHL+NZAEHL*roi(2,IROI)*(ROI(IROI+1)-ROI(IROI))/(XENDSOU-X1)
            ELSE IF (ROI(IROI).GT.X1.OR.ROI(IROI)+1.LT.XENDSOU) THEN
              KZAEHL=KZAEHL+NZAEHL*roi(2,IROI)*(ROI(IROI+1)-ROI(IROI))/(XENDSOU-X1)
            ENDIF
          ENDDO

        ENDIF

      endif !ibun.eq.nphsp
+self.,if=kzaehl.

      X2=X1
      Y2=Y1
      Z2=Z1

      VX2=VX1
      VY2=VY1
      VZ2=VZ1

      BX2=BX1
      BY2=BY1
      BZ2=BZ1
      BS=BS1

C--- LOOP OVER STEPS

      IROI=1
      DO I=1,NROIA
        IF (X1.GE.roi(1,I)) THEN
          IROI=I
        ENDIF !(X1.GE.roi(1,I))
      ENDDO   !IROI

      DT=DT0/roi(2,IROI)

      NZAEHL=MAX(5,NINT((TENDSOU-T)/DT))
      DT=(TENDSOU-T)/NZAEHL

      TENDSOU1=TENDSOU-DT
      DT2=DT/2.D0

C- CHECK STEPS SIZE

      IF (IWARNROI(IROI,ISOUR).EQ.0) THEN
        IF (DT-DTIM00.ge.dtim00*0.001) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '*** WARNING IN souintana_omp, SOURCE, ROI:',ISOUR,IROI
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
          WRITE(LUNGFO,*)'SIZE FOR TRAJECTORY!'
          WRITE(LUNGFO,*)
          write(lungfo,*)'Step size for source point:',dt*clight1
          write(lungfo,*)'Step size for trajectory:',dtim00*clight1
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
          WRITE(6,*)
          WRITE(6,*)
     &      '*** WARNING IN souintana_omp, SOURCE, ROI:',ISOUR,IROI
          WRITE(6,*)
          WRITE(6,*)'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
          WRITE(6,*)'SIZE FOR TRAJECTORY!'
          WRITE(6,*)
          write(6,*)'Step size for source point:',dt*clight1
          write(6,*)'Step size for trajectory:',dtim00*clight1
          WRITE(6,*)
          WRITE(6,*)
     &      'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
          WRITE(6,*)
          IWARNROI(IROI,ISOUR)=1
        ENDIF !DT
      ENDIF !IWARNROI

      IROI=IROI+1

      IZAEHL=0 !LOOP COUNTER for each track

      nutrack=ielec
      nustep=izaehl

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS     T=-R0*C1

      T=-DT
      TS=-DT

c20.11.2023
c20.11.2023      R0=XOBSV-SOURCEAO(1,1,ISOUR)
      R0=obsv(1,icbrill)-SOURCEAO(1,1,ISOUR)
      h2=((yobsv-y1)**2+(zobsv-z1)**2)/(xobsv-x1)**2
      if (h2.lt.0.01) then
        r=abs(xobsv-x1)*(1.0d0+(((((-0.0205078125D0*h2+0.02734375D0)*h2
     &    -0.0390625D0)*h2+0.0625D0)*h2-0.125D0)*h2+0.5D0)*h2)
      else
        r=sqrt((xobsv-x1)**2+((yobsv-y1)**2+(zobsv-z1)**2))
      endif
c      phase=(obsv(1,icbrill)-x1)*c1
c20.11.2023
      PHASE=(r-r0)*c1 ! needed for phase of field amplitude
      t0ph=phase

      EXPOM1=ZONE
      DEXPOMPH1=ZONE

      IF (ifreq2p.EQ.0) THEN
        DO JFREQ=1,NFREQ
          EXPOM2P0(1,JFREQ)=ZONE
        ENDDO
      ENDIF

      yp2zp2i=0.0D0
      f=0.0d0

      powpow=0.0d0

1000  IZAEHL=IZAEHL+1
      call util_break
      nustep=izaehl
c      IIZAEHL=IIZAEHL+1 !total step counter

      IF (IROI.LE.NROIA) THEN

        IF (X2.GE.roi(1,IROI)) THEN

          DT=DT0/roi(2,IROI)
          NZAEHL=NINT((TENDSOU-T)/DT)

          IF (ISPECMODE.EQ.1) THEN
            DT=(TENDSOU-T)/(NZAEHL-1)
          ELSE
            DT=(TENDSOU-T)/NZAEHL
          ENDIF

          TENDSOU1=TENDSOU-DT

          DT2=DT/2.D0

          IF (IWARNROI(IROI,ISOUR).EQ.0) THEN

            IF (DT-DTIM00.ge.dtim00*0.001) THEN

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          '*** WARNING IN souintana_omp, SOURCE, ROI:',ISOUR,IROI
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
              WRITE(LUNGFO,*)'SIZE FOR TRAJECTORY!'
              WRITE(LUNGFO,*)
              write(lungfo,*)'Step size for source point:',dt*clight1
              write(lungfo,*)'Step size for trajectory:',dtim00*clight1
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
              WRITE(6,*)
              WRITE(6,*)
     &          '*** WARNING IN souintana_omp, SOURCE, ROI:',ISOUR,IROI
              WRITE(6,*)
              WRITE(6,*)'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
              WRITE(6,*)'SIZE FOR TRAJECTORY!'
              WRITE(6,*)
              write(6,*)'Step size for source point:',dt*clight1
              write(6,*)'Step size for trajectory:',dtim00*clight1
              WRITE(6,*)
              WRITE(6,*)
     &          'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
              WRITE(6,*)

              IWARNROI(IROI,ISOUR)=1

            ENDIF !DT

          ENDIF !IWARNROI

          IROI=IROI+1

        ENDIF   !X2

      ENDIF   !IROI

      if (ibun.eq.1.and.isub.eq.1) IPOIROI(IROI)=IPOIROI(IROI)+1

      T=T+DT

      IF (LSTEP.EQ.1) THEN

        IF (X2.LE.XENDSOU) THEN

          DT=(MIN(XENDSOU,XIEND)-X2)/VX2
          DT2=DT/2.0D0

        ELSE

          TS=TS-DT
          T=T-DT

          DT=(MIN(XENDSOU,XIEND)-X1)/VX2
          DT2=DT/2.0D0

          X2=X1
          Y2=Y1
          Z2=Z1

          VX2=VX1
          VY2=VY1
          VZ2=VZ1

          BX2=BX1
          BY2=BY1
          BZ2=BZ1
          BS=BS1

        ENDIF !X2

      ENDIF !LSTEP

      X1=X2
      Y1=Y2
      Z1=Z2

      VX1=VX2
      VY1=VY2
      VZ1=VZ2

      BX1=BX2
      BY1=BY2
      BZ1=BZ2
      BS1=BS

      IF (ISPECMODE.NE.1) THEN

C GET MAGNETIC FIELD {

        X2B=X1+VX1*DT2
        Y2B=Y1+VY1*DT2
        Z2B=Z1+VZ1*DT2
        norad=0
        if (ibmasksp.ne.0) then
          ibmasksp=-abs(ibmasksp)
          call mybfeld(x2b,y2b,z2b,bx2,by2,bz2,ax2d,ay2d,az2d)
          if ((bx2**2+by2**2+bz2**2).ne.0.0d0) then
            norad=1
          endif
          ibmasksp=-ibmasksp
        endif

        X2=WSOU(1,1,IZAEHL)
        Y2=WSOU(2,1,IZAEHL)
        Z2=WSOU(3,1,IZAEHL)

        VX2=WSOU(1,2,IZAEHL)
        VY2=WSOU(2,2,IZAEHL)
        VZ2=WSOU(3,2,IZAEHL)

        VXP=WSOU(1,3,IZAEHL)
        VYP=WSOU(2,3,IZAEHL)
        VZP=WSOU(3,3,IZAEHL)

        DT=   wsou(1,4,IZAEHL)
        BETA= wsou(2,4,IZAEHL)
        GAMMA=wsou(3,4,IZAEHL)

        bX2=WSOU(1,5,IZAEHL)
        bY2=WSOU(2,5,IZAEHL)
        bZ2=WSOU(3,5,IZAEHL)

        BX=VX2*C1
        BY=VY2*C1
        BZ=VZ2*C1

        BPX=VXP*C1
        BPY=VYP*C1
        BPZ=VZP*C1

C MOVE ONE STEP }

      ELSE  !ISPECMODE

c{wave_track_inter, inline

c        CALL WAVE_TRACK_INTER(TS,X2,Y2,Z2,VX2,VY2,VZ2,VXP,VYP,VZP,BS,ICSPL,
c     &    GAMMA)

        IF (ICOUNT.EQ.0) THEN
          MODE=0
          DT=(DWT(2)-DWT(1))
          DT10=DT*1.D-10
          DO I=2,MCO
         IF (ABS(DWT(I)-DWT(I-1)-DT).GT.DT10) THEN
           MODE=1
           GOTO 19
                ENDIF
          ENDDO
19        KLO=1
          KHI=MCO
          ICOUNT=1
        ENDIF

      IF (MODE.EQ.1) THEN

        IF (KLO.GE.MCO.OR.KLO.LT.1.OR.KHI.GT.MCO.OR.KHI.LT.2) THEN
          KLO=1
          KHI=MCO
        ENDIF

          IF (T.GE.DWT(KLO).AND.T.LT.DWT(KLO+1)) THEN
            KHI=KLO+1
            GOTO 2
          ELSE IF (T.LT.DWT(KLO).OR.T.GE.DWT(KHI)) THEN
            KLO=1
            KHI=MCO
          ENDIF

          K=1
111       K=K*2
          KHI=KLO+K
          IF (KHI.GE.MCO) GOTO 122
          IF (T.GT.DWT(KHI)) THEN
            KLO=KHI
            GOTO 111
          ELSE
            GOTO 1
          ENDIF

122       KHI=MCO

1         IF (KHI-KLO.GT.1) THEN
            K=(KHI+KLO)/2
            IF(DWT(K).GT.T)THEN
              KHI=K
            ELSE
              KLO=K
            ENDIF
            GOTO 1
          ENDIF

        ELSE !MODE

          IF (T.GE.DWT(1).AND.T.LT.DWT(MCO)) THEN
            KLO=T/DT+1
            KHI=KLO+1
            IF (KHI.GT.MCO) THEN
              KHI=MCO
              KLO=KHI-1
            ENDIF
          ELSE IF (T.LT.DWT(1)) THEN
            KLO=1
            KHI=2
          ELSE IF (T.GE.DWT(MCO)) THEN
            KLO=MCO-1
            KHI=MCO
          ENDIF

        ENDIF !MODE

2       wtH=DWT(KHI)-DWT(KLO)

        IF (wtH.EQ.0.) THEN
          WRITE(6,*) '*** ERROR IN WAVE_TRACK_INTER: BAD INPUT ***'
          STOP
        ENDIF

        H6=wtH/6.D0
        H26=H6*wtH
        wta=(DWT(KHI)-T)/wtH
        A2=wta*wta
        A3AH26=(A2-1.D0)*wta*H26
        A21H6=(-3.D0*A2+1.D0)*H6
        B=(T-DWT(KLO))/wtH
        B2=B*B
        B21H6=(3.D0*B2-1.D0)*H6
        B3BH26=(B2-1.D0)*B*H26

        X2=wta*DWX(KLO)+B*DWX(KHI)+A3AH26*DWX2P(KLO)+B3BH26*DWX2P(KHI)
        VX2=(-DWX(KLO)+DWX(KHI))/wtH+A21H6*DWX2P(KLO)+B21H6*DWX2P(KHI)
        VXP=wta*DWX2P(KLO)+B*DWX2P(KHI)

        Y2=wta*DWY(KLO)+B*DWY(KHI)+A3AH26*DWY2P(KLO)+B3BH26*DWY2P(KHI)
        VY2=(-DWY(KLO)+DWY(KHI))/wtH+A21H6*DWY2P(KLO)+B21H6*DWY2P(KHI)
        VYP=wta*DWY2P(KLO)+B*DWY2P(KHI)

        Z2=wta*DWZ(KLO)+B*DWZ(KHI)+A3AH26*DWZ2P(KLO)+B3BH26*DWZ2P(KHI)
        VZ2=(-DWZ(KLO)+DWZ(KHI))/wtH+A21H6*DWZ2P(KLO)+B21H6*DWZ2P(KHI)
        VZP=wta*DWZ2P(KLO)+B*DWZ2P(KHI)

        BS=wta*DWB(KLO)+B*DWB(KHI)+A3AH26*DWB2P(KLO)+B3BH26*DWB2P(KHI)

        GAMMA=(TRAGAM(KLO)+TRAGAM(KHI))/2.0D0

c}wave_track_inter, inline
        norad=0
        if (ibmasksp.ne.0) then
          ibmasksp=-abs(ibmasksp)
          call mybfeld(x2b,y2b,z2b,bx2,by2,bz2,ax2d,ay2d,az2d)
          if ((bx2**2+by2**2+bz2**2).ne.0.0d0) then
            norad=1
          endif
          ibmasksp=-ibmasksp
        endif

        IF (IENELOSS.NE.0) THEN
          BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
        ENDIF

        BSQ=BS*BS
        BY2=BSQ

        BX=VX2*C1
        BY=VY2*C1
        BZ=VZ2*C1

        BPX=VXP*C1
        BPY=VYP*C1
        BPZ=VZP*C1

      ENDIF !ISPECMODE

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION {

C REAL PART OF INTEGRAND {

      RX=XOBSV-X2
      RY=YOBSV-Y2
      RZ=ZOBSV-Z2

      R=SQRT(RX*RX+RY*RY+RZ*RZ)

      R1=1.0D0/R
      ZICR1=ZIC*R1

      RNX=RX*R1
      RNY=RY*R1
      RNZ=RZ*R1

C--- THE DISTANCE R IS INTRODUCED HERE EXPLICITLY (S. PROGRAM OF CHAOEN WANG

      BET1N=(1.0D0-BX*RNX)-BY*RNY-BZ*RNZ

c 20090928{
      br2=by**2+bz**2
      rnr2=rny**2+rnz**2
      b3=beta**3
      br4=br2**2
      rnr4=rnr2**2

      if(br2.lt.1.0d-4.and.rnr2.lt.1.0d-4) then
        bet1n=
     &    1.0d0/(1.0+beta)/gamma**2
     &    +beta*(rnr2/2.0d0
     &    +rnr4/8.0d0)
     &    +(br2/2.0d0
     &    -br2*rnr2/4.0d0
     &    -br2*rnr4/16.0d0)/beta
     &    +b3*br4*(1.0d0/8.0d0
     &    -rnr2/16.0d0
     &    -rnr4/64.0d0)
     &    -by*rny
     &    -bz*rnz
      endif
c }20090928

      OPANG=BX/BETA*RNX+BY/BETA*RNY+BZ/BETA*RNZ

      IF (ABS(OPANG).LE.1.0D0) THEN
        OPANG=ACOS(OPANG)
      ELSE IF (OPANG.GT.1.0D0) THEN
        OPANG=0.0D0
      ELSE
        OPANG=-PI1
      ENDIF

      DUM11=1.D0/BET1N
      DOM1=1.D0/(R*BET1N*BET1N)

      IF (IZAEHL.EQ.1) THEN
        BET1NO=BET1N
      ELSE IF (iundulator.eq.0.and.(BET1N-BET1NO)/BET1N.GT.0.05.AND.IWARNBET1N.EQ.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN souintana_omp  ***'
        WRITE(LUNGFO,*)'DISCONTINUITY IN INTEGRAND'
        WRITE(LUNGFO,*)
     &    'Check results carefully, change BMOVECUT, MYINUM, NLPOI etc.'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'IELEC,ISTEP,X,BET1N,BET1NO:',IELEC,IZAEHL,SNGL(X1),SNGL(BET1N),SNGL(BET1NO)
        WRITE(LUNGFO,*)'FURTHER WARNINGS ARE SUPPRESSED!'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN souintana_omp  ***'
        WRITE(6,*)'DISCONTINUITY IN INTEGRAND'
        WRITE(6,*)
     &    'Check results carefully, change BMOVECUT, MYINUM, NLPOI etc.'
        WRITE(6,*)
        WRITE(6,*)'IELEC,ISTEP,X,BET1N,BET1NO:',IELEC,IZAEHL,SNGL(X1),SNGL(BET1N),SNGL(BET1NO)
        WRITE(6,*)
        WRITE(6,*)'FURTHER WARNINGS ARE SUPPRESSED!'
        WRITE(6,*)
        IWARNBET1N=1
      ENDIF

      BET1NO=BET1N

      RNBX=RNX-BX
      RNBY=RNY-BY
      RNBZ=RNZ-BZ

      PX=(RNBY*BPZ-RNBZ*BPY)
      PY=(RNBZ*BPX-RNBX*BPZ)
      PZ=(RNBX*BPY-RNBY*BPX)

      IF (IVELOFIELD.EQ.0) THEN !2 WEGEN POWER
        DOM2=C*DOM1*R1/GAMMA**2
        RARG(1)=(RNY*PZ-RNZ*PY)*DOM1+(RNX-BX)*DOM2
        RARG(2)=(RNZ*PX-RNX*PZ)*DOM1+(RNY-BY)*DOM2
        RARG(3)=(RNX*PY-RNY*PX)*DOM1+(RNZ-BZ)*DOM2
      ELSE IF (IVELOFIELD.EQ.1) THEN
        RARG(1)=(RNY*PZ-RNZ*PY)*DOM1
        RARG(2)=(RNZ*PX-RNX*PZ)*DOM1
        RARG(3)=(RNX*PY-RNY*PX)*DOM1
      ELSE IF (IVELOFIELD.LT.0) THEN
        DOM2=C*DOM1*R1/GAMMA**2
        RARG(1)=(RNX-BX)*DOM2
        RARG(2)=(RNY-BY)*DOM2
        RARG(3)=(RNZ-BZ)*DOM2
      ELSE  !IVELOFIELD
        WRITE(6,*)
     &    '*** ERROR IN souintana_omp: BAD VALUE OF IVELOFIELD  ***'
        WRITE(6,*) '*** PROGRAM WAVE ABORTED  ***'
        STOP
      ENDIF !IVELOFIELD

      IF (IINSIDE.EQ.0.AND.OPANG.LE.WGANG) THEN
        if (ibun.eq.1.and.isub.eq.neinbunch) then
          DPHSOUR(1,1)=BET1N*DT*FREQ(1)/HBAREV1
          DPHSOUR(1,2)=BET1N*DT*FREQ(NFREQ)/HBAREV1
        endif
        IINSIDE=1
        INSIDE=1
        JINSIDE=JINSIDE+1
        IF (JINSIDE.GT.1.and.ielec.eq.1) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN souintana_omp  ***'
          WRITE(LUNGFO,*)'*** SOURCE:',ISOUR
          WRITE(LUNGFO,*)'STRANGE SOURCE, CONTAINS SEVERAL SOURCES'
          WRITE(LUNGFO,*)'SOURCE AND OBSERVATION POINT:'
          WRITE(LUNGFO,*)ISOUR,XOBSV,YOBSV,ZOBSV
          WRITE(LUNGFO,*)
     &      'RESULTS OF SPECTRUM CALCULATIONS MAY BE UNRELIABLE'
          WRITE(LUNGFO,*)'*** CHECK COLLIMATOR, PINHOLE, WGWINFC ... ***'
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN souintana_omp  ***'
          WRITE(6,*)'*** SOURCE:',ISOUR
          WRITE(6,*)'*** STRANGE SOURCE, CONTAINS SEVERAL SOURCES'
          WRITE(6,*)'SOURCE AND OBSERVATION POINT:'
          WRITE(6,*)ISOUR,XOBSV,YOBSV,ZOBSV
          WRITE(6,*)'*** CHECK COLLIMATOR, PINHOLE, WGWINFC ... ***'
          WRITE(6,*)'WARNING OF SPECTRUM CALCULATIONS ARE UNRELIABLE'
          JINSIDE=JINSIDE-1   !SUPRESS LOTS OF WARNINGS
        ENDIF  !JINSIDE
      ELSE IF (IINSIDE.EQ.1.AND.OPANG.GT.WGANG) THEN
        IINSIDE=0
      ENDIF   !IINSIDE

      IF (IINSIDE.NE.0) THEN

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS      RARG(4)=T+R*C1

        DPHASE=BET1N*DT

        RARG(4)=PHASE
        RARG(5)=(RARG(1)*RARG(1)+RARG(2)*RARG(2)+RARG(3)*RARG(3))*DUM11/
     &    (nphsp*neinbunch)

        if (norad.ne.0) rarg=0.0d0

C REAL PART OF INTEGRAND }

C COMPLEX PART OF INTEGRAND {

C    ASSUMES FREQ(I+1)=2*FREQ(I)   FOR ifreq2p=2
C    OR FREQ(I+1)=FREQ(I)+DELTA    FOR ifreq2p>2

C--- LOOP OVER ALL FREQUENCES

        kfreq=1

        if (nelec.gt.1) then
          dexpbunch=phexp(kfreq)
        else
          dexpbunch=(1.0d0,0.0d0)
        endif

        kfrob=kfreq+NFREQ*(IOBSV-1)

        OM=FREQ(kfreq)/HBAREV1
        ZIOM=ZI*OM

        if (izaehl.eq.1) then
          EXPOM1=CDEXP(DCMPLX(0.D0,phase*OM))
        endif

        EXPOM=EXPOM1
        DEXPOMPH1=EXP(ZIOM*DPHASE)
        DEXPOMPH=DEXPOMPH1

        IF(ifreq2p.GT.2) THEN
          DEXPOM=EXP(ZIDOM*PHASE)
          DDEXPOMPH=EXP(ZIDOM*DPHASE)
        ELSE IF(ifreq2p.EQ.0) THEN
          EXPOM2P0(2,kfreq)=EXP(ZIOM*DPHASE)
          EXPOM=EXPOM2P0(1,kfreq)
        ENDIF  !ifreq2p

        call util_break
        !expom=exp(zidom*)

        IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN

          IF (ECMAXS.LT.BS) ECMAXS=BS

          pow=rarg(5)*dt
          powpow=powpow+pow
          SPECPOW(jliob)=SPECPOW(jliob)+pow

          DO ICOMP=1,3
            daff(icomp)=
     &        RARG(ICOMP)/BET1N/OM*EXPOM*(ZONE-DEXPOMPH)*DEXPbunch/sqnphsp
            affe(icomp,kfrob)=affe(icomp,kfrob)+daff(icomp)
          ENDDO   !ICOMP

c          baff(1)=conjg(rny*daff(3)-rnz*daff(2))
c          baff(2)=conjg(rnz*daff(1)-rnx*daff(3))
c          baff(3)=conjg(rnx*daff(2)-rny*daff(1))

          baff(1)=(rny*daff(3)-rnz*daff(2))
          baff(2)=(rnz*daff(1)-rnx*daff(3))
          baff(3)=(rnx*daff(2)-rny*daff(1))

          !baff(1)=dcmplx(rny*dreal(daff(3))-rnz*dreal(daff(2)),0.0d0)
          !baff(2)=dcmplx(rnz*dreal(daff(1))-rny*dreal(daff(3)),0.0d0)
          !baff(3)=dcmplx(rnx*dreal(daff(2))-rnx*dreal(daff(1)),0.0d0)

          affe(4:6,kfrob)=affe(4:6,kfrob)+baff(1:3)/clight1

        ENDIF  !XIANF

        IF (ibun.eq.1.and.isub.eq.neinbunch) THEN
          IF (IWFILINT.NE.0) THEN
            IF (MOD(IZAEHL,JWFILINT).EQ.0) THEN
              IF (IWFILINT.LT.0) THEN
                FILLT(1)=T+DT
                FILLT(2)=X2
                FILLT(3)=Y2
                FILLT(4)=Z2
                FILLT(5)=RARG(1)
                FILLT(6)=RARG(2)
                FILLT(7)=RARG(3)
                FILLT(8)=RARG(4)
                FILLT(9)=RARG(5)
                FILLT(10)=DREAL(EXPOM*DEXPBUNCH)
                FILLT(11)=DIMAG(EXPOM*DEXPBUNCH)
                FILLT(12)=IROI-1
                FILLT(13)=IOBSV
                FILLT(14)=kfreq
                FILLT(15)=YOBSV
                FILLT(16)=ZOBSV
                FILLT(17)=BET1N
                FILLT(18)=OM
                FILLT(19)=DT
                FILLT(20)=BY2
                FILLT(21)=ISOUR
                FILLT(22)=
     &            (
     &            DREAL(affe(1,kfrob))*DREAL(affe(1,kfrob))
     &            +DIMAG(affe(1,kfrob))*DIMAG(affe(1,kfrob))
     &            +DREAL(affe(2,kfrob))*DREAL(affe(2,kfrob))
     &            +DIMAG(affe(2,kfrob))*DIMAG(affe(2,kfrob))
     &            +DREAL(affe(3,kfrob))*DREAL(affe(3,kfrob))
     &            +DIMAG(affe(3,kfrob))*DIMAG(affe(3,kfrob))
     &            )*specnor*bunnor
                FILLT(23)=DREAL(affe(1,kfrob))*specnor*bunnor
                FILLT(24)=DIMAG(affe(1,kfrob))*specnor*bunnor
                FILLT(25)=DREAL(affe(2,kfrob))*specnor*bunnor
                FILLT(26)=DIMAG(affe(2,kfrob))*specnor*bunnor
                FILLT(27)=DREAL(affe(3,kfrob))*specnor*bunnor
                FILLT(28)=DIMAG(affe(3,kfrob))*specnor*bunnor
                FILLT(29)=DOM1
                FILLT(30)=bx
                FILLT(31)=by
                FILLT(32)=bz
                FILLT(33)=bpx
                FILLT(34)=bpy
                FILLT(35)=bpz
c                ef(1:3)=real(affe(1:3,kfrob))
c                bf(1:3)=real(affe(4:6,kfrob))
c                rnx=ef(2)*bf(3)-ef(3)*bf(2)
c                rny=ef(3)*bf(1)-ef(1)*bf(3)
c                rnz=ef(1)*bf(2)-ef(2)*bf(1)
                rnx=real(
     &            affe(2,kfrob)*conjg(affe(6,kfrob))-
     &            affe(3,kfrob)*conjg(affe(5,kfrob)))
                rny=real(
     &            affe(3,kfrob)*conjg(affe(4,kfrob))-
     &            affe(1,kfrob)*conjg(affe(6,kfrob)))
                rnz=real(
     &            affe(1,kfrob)*conjg(affe(5,kfrob))-
     &            affe(2,kfrob)*conjg(affe(4,kfrob)))
                rn=sqrt(rnx**2+rny**2+rnz**2)
                FILLT(36)=rnx/rn
                FILLT(37)=rny/rn
                FILLT(38)=rnz/rn

                CALL hfm(NIDSOURCE,FILLT)

              ELSE IF (ISOUR.EQ.IWFILINT.AND.IOBSV.EQ.1) THEN

                WRITE(LUNINT,*) IZAEHL,kfreq,X2
                WRITE(LUNINT,*) (RARG(1),IC=1,3)
                WRITE(LUNINT,*) RARG(4)*OM,RARG(5)
                WRITE(LUNINT,*)REAL(EXPOM),IMAG(EXPOM)
                WRITE(LUNINT,*)RARG(1)*REAL(EXPOM*DEXPBUNCH),RARG(1)*IMAG(EXPOM*DEXPBUNCH)
                WRITE(LUNINT,*)RARG(2)*REAL(EXPOM*DEXPBUNCH),RARG(2)*IMAG(EXPOM*DEXPBUNCH)
                WRITE(LUNINT,*)RARG(3)*REAL(EXPOM*DEXPBUNCH),RARG(3)*IMAG(EXPOM*DEXPBUNCH)

              ENDIF !IWFILINT.LT.0
            ENDIF !JFILINT
          ENDIF !IWFILINT.NE.0
        ENDIF !ibun

        DO kfreq=2,NFREQ

          kfrob=kfreq+NFREQ*(IOBSV-1)

          IF    (ifreq2p.GT.2) THEN
            OM=OM+DOM
            EXPOM=EXPOM*DEXPOM
            DEXPOMPH=DEXPOMPH*DDEXPOMPH
          ELSE IF(ifreq2p.EQ.2) THEN
            OM=OM*2.0D0
            EXPOM=EXPOM*EXPOM
            DEXPOMPH=DEXPOMPH*DEXPOMPH
          ELSE IF(ifreq2p.EQ.0) THEN
            OM=FREQ(kfreq)/HBAREV1
            ZIOM=ZI*OM
            EXPOM2P0(2,kfreq)=EXP(ZIOM*DPHASE)
            EXPOM=EXPOM2P0(1,kfreq)
            DEXPOMPH=EXPOM2P0(2,kfreq)
          ELSE
            OM=FREQ(kfreq)/HBAREV1
            ZIOM=ZI*OM
            DEXPOMPH=EXP(ZIOM*DPHASE)
          ENDIF

          if (nelec.gt.1) then
            dexpbunch=phexp(kfreq)
          endif

          IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN

            EXPOMV2=1.0D0/BET1N/OM*EXPOM*(ZONE-DEXPOMPH)

            DO ICOMP=1,3
              daff(icomp)=RARG(ICOMP)*EXPOMV2*DEXPbunch/sqnphsp
              affe(icomp,kfrob)=affe(icomp,kfrob)+daff(icomp)
            ENDDO

c            baff(1)=conjg(rny*daff(3)-rnz*daff(2))
c            baff(2)=conjg(rnz*daff(1)-rnx*daff(3))
c            baff(3)=conjg(rnx*daff(2)-rny*daff(1))

            baff(1)=(rny*daff(3)-rnz*daff(2))
            baff(2)=(rnz*daff(1)-rnx*daff(3))
            baff(3)=(rnx*daff(2)-rny*daff(1))

          !baff(1)=dcmplx(rny*dreal(daff(3))-rnz*dreal(daff(2)),0.0d0)
          !baff(2)=dcmplx(rnz*dreal(daff(1))-rny*dreal(daff(3)),0.0d0)
          !baff(3)=dcmplx(rnx*dreal(daff(2))-rnx*dreal(daff(1)),0.0d0)

            affe(4:6,kfrob)=affe(4:6,kfrob)+baff(1:3)/clight1

          ENDIF !XIEND

          IF (ibun.eq.1.and.isub.eq.neinbunch) then
            IF (IWFILINT.NE.0) THEN
              IF (MOD(IZAEHL,JWFILINT).EQ.0) THEN
                IF (IWFILINT.LT.0) THEN
                  FILLT(1)=T+DT
                  FILLT(2)=X2
                  FILLT(3)=Y2
                  FILLT(4)=Z2
                  FILLT(5)=RARG(1)
                  FILLT(6)=RARG(2)
                  FILLT(7)=RARG(3)
                  FILLT(8)=RARG(4)
                  FILLT(9)=RARG(5)
                  FILLT(10)=DREAL(EXPOM*DEXPBUNCH)
                  FILLT(11)=DIMAG(EXPOM*DEXPBUNCH)
                  FILLT(12)=IROI-1
                  FILLT(13)=IOBSV
                  FILLT(14)=kfreq
                  FILLT(15)=YOBSV
                  FILLT(16)=ZOBSV
                  FILLT(17)=BET1N
                  FILLT(18)=OM
                  FILLT(19)=DT
                  FILLT(20)=BY2
                  FILLT(21)=ISOUR
                  FILLT(22)=
     &              (
     &              DREAL(affe(1,kfrob))*DREAL(affe(1,kfrob))
     &              +DIMAG(affe(1,kfrob))*DIMAG(affe(1,kfrob))
     &              +DREAL(affe(2,kfrob))*DREAL(affe(2,kfrob))
     &              +DIMAG(affe(2,kfrob))*DIMAG(affe(2,kfrob))
     &              +DREAL(affe(3,kfrob))*DREAL(affe(3,kfrob))
     &              +DIMAG(affe(3,kfrob))*DIMAG(affe(3,kfrob))
     &              )*specnor*bunnor
                  FILLT(23)=DREAL(affe(1,kfrob))*specnor*bunnor
                  FILLT(24)=DIMAG(affe(1,kfrob))*specnor*bunnor
                  FILLT(25)=DREAL(affe(2,kfrob))*specnor*bunnor
                  FILLT(26)=DIMAG(affe(2,kfrob))*specnor*bunnor
                  FILLT(27)=DREAL(affe(3,kfrob))*specnor*bunnor
                  FILLT(28)=DIMAG(affe(3,kfrob))*specnor*bunnor
                  FILLT(29)=DOM1
                  FILLT(30)=bx
                  FILLT(31)=by
                  FILLT(32)=bz
                  FILLT(33)=bpx
                  FILLT(34)=bpy
                  FILLT(35)=bpz
c                ef(1:3)=real(affe(1:3,kfrob))
c                bf(1:3)=real(affe(4:6,kfrob))
c                rnx=ef(2)*bf(3)-ef(3)*bf(2)
c                rny=ef(3)*bf(1)-ef(1)*bf(3)
c                rnz=ef(1)*bf(2)-ef(2)*bf(1)
                  rnx=real(
     &              affe(2,kfrob)*conjg(affe(6,kfrob))-
     &              affe(3,kfrob)*conjg(affe(5,kfrob)))
                  rny=real(
     &              affe(3,kfrob)*conjg(affe(4,kfrob))-
     &              affe(1,kfrob)*conjg(affe(6,kfrob)))
                  rnz=real(
     &              affe(1,kfrob)*conjg(affe(5,kfrob))-
     &              affe(2,kfrob)*conjg(affe(4,kfrob)))
                  rn=sqrt(rnx**2+rny**2+rnz**2)
                  FILLT(36)=rnx/rn
                  FILLT(37)=rny/rn
                  FILLT(38)=rnz/rn

                  CALL hfm(NIDSOURCE,FILLT)

                ELSE IF (ISOUR.EQ.IWFILINT.AND.IOBSV.EQ.1) THEN

                  WRITE(LUNINT,*) IZAEHL,kfreq,X2
                  WRITE(LUNINT,*) (RARG(1),IC=1,3)
                  WRITE(LUNINT,*) RARG(4)*OM,RARG(5)
                  WRITE(LUNINT,*)REAL(EXPOM*DEXPBUNCH),IMAG(EXPOM*DEXPBUNCH)
                  WRITE(LUNINT,*)RARG(1)*REAL(EXPOM*DEXPBUNCH),RARG(1)*IMAG(EXPOM*DEXPBUNCH)
                  WRITE(LUNINT,*)RARG(2)*REAL(EXPOM*DEXPBUNCH),RARG(2)*IMAG(EXPOM*DEXPBUNCH)
                  WRITE(LUNINT,*)RARG(3)*REAL(EXPOM*DEXPBUNCH),RARG(3)*IMAG(EXPOM*DEXPBUNCH)

                ENDIF !IWFILINT.LT.0
              ENDIF !JWFILINT
            ENDIF !IWFILINT.NE.0
          ENDIF !ibun

        ENDDO   !LOOP OVER ALL FREQUENCES

      ENDIF   !IINSIDE

C COMPLEX PART OF INTEGRAND }

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION }

      PHASE=PHASE+DPHASE
      EXPOM1=EXPOM1*DEXPOMPH1

      IF(ifreq2p.EQ.0) THEN

        DO JFREQ=1,NFREQ
          OM=FREQ(JFREQ)/HBAREV1
          ZIOM=ZI*OM
          EXPOM2P0(1,JFREQ)=EXPOM2P0(1,JFREQ)*EXPOM2P0(2,JFREQ)
        ENDDO
      ENDIF

      TS=TS+DT

C--- END OF LOOP OVER TIME STEPS

c      yp2zp2ia=yp2zp2ia
c     &  +((vy1/vx1)**2+(vy2/vx2)**2+(vz1/vx1)**2+(vz2/vx2)**2)*beta*clight1*dt2

      f(3)=((vy2/vx2)**2+(vz2/vx2)**2)
      fdt(3)=dt

      if (lstep.eq.1) then
        yp(1)=(f(2)-f(1))/fdt(2)
        yp(3)=(f(3)-f(2))/fdt(3)
        yp(2)=(yp(3)+yp(1))/2.0d0
        ypp=(yp(3)-yp(1))/(fdt(2)+fdt(3))*2.0d0
        a(3)=ypp/2.0d0
        a(2)=yp(2)-2.0d0*a(3)*fdt(2)
        a(1)=f(2)-a(2)*fdt(2)-a(3)*fdt(2)**2
        dfdt=fdt(2)+fdt(3)
        fihi=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        dfdt=0.0d0
        filo=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        yp2zp2i=yp2zp2i+fihi-filo
        yp2zp2i=yp2zp2i*beta*clight1
      else if (izaehl.ge.3) then
        yp(1)=(f(2)-f(1))/fdt(2)
        yp(3)=(f(3)-f(2))/fdt(3)
        yp(2)=(yp(3)+yp(1))/2.0d0
        ypp=(yp(3)-yp(1))/(fdt(2)+fdt(3))*2.0d0
        a(3)=ypp/2.0d0
        a(2)=yp(2)-2.0d0*a(3)*fdt(2)
        a(1)=f(2)-a(2)*fdt(2)-a(3)*fdt(2)**2
        dfdt=fdt(2)+fdt(3)
        fihi=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        dfdt=fdt(2)
        filo=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        yp2zp2i=yp2zp2i+fihi-filo
      endif

      f(1)=f(2)
      fdt(1)=fdt(2)
      f(2)=f(3)
      fdt(2)=fdt(3)

      if (ispecmode.eq.2) then
        if (izaehl.lt.ipoisou(isour)) goto 1000
      else
        IF (X2.LT.XENDSOU-VX2*DT.AND.X2.LT.(XIEND-VX2*DT).AND.LSTEP.EQ.0)
     &    GOTO 1000
        IF (LSTEP.EQ.0) THEN
          LSTEP=1
          GOTO 1000
        ENDIF
      endif

      if (ibun.eq.1.and.isub.eq.neinbunch) then

        IF (IINSIDE.NE.0) THEN
          DPHSOUR(2,1)=BET1N*DT*FREQ(1)/HBAREV1
          DPHSOUR(2,2)=BET1N*DT*FREQ(NFREQ)/HBAREV1
        ENDIF

C- STORE NUMBER OF POINTS FOR INTEGRATION

        IF (IOBSV.EQ.ICBRILL) IZTOT(ISOUR)=IZAEHL

      endif !ibun.eq.1

      IF (IAMPLI.LT.0) THEN

        DXEXI=MIN(SOURCEEO(1,1,ISOUR),XIEND)
     &    -MAX(SOURCEAO(1,1,ISOUR),XIANF)
        if (ampr2corr.eq.-9999.0d0) ampr2corr=dxexi
        CENXEXI=(MIN(SOURCEEO(1,1,ISOUR),XIEND)
     &    +MAX(SOURCEAO(1,1,ISOUR),XIANF))/2.D0
c        GAMGAM0=(SOURCEG(1,1,ISOUR))**2
c        GAMGAM=((SOURCEG(1,1,ISOUR)+SOURCEG(2,2,ISOUR)))**2
        GAMGAM0=(SOURCEG(1,1,ISOUR)*(egamma/dmygamma))**2
        GAMGAM=(
     &    (SOURCEG(1,1,ISOUR)+SOURCEG(2,2,ISOUR))*(egamma/dmygamma)
     &    )**2

c        DTPHASE=(WTRA2IS(ISOUR)+(1.0D0/GAMGAM0)*DXEXI/2.D0)/CLIGHT1
c     &    *GAMGAM0/GAMGAM

        slopein=sqrt(vyin**2+vzin**2)/vxin
        slope=sqrt(vyelec**2+vzelec**2)/vxelec

        if (myinum.gt.nlpoi/dxexi) then
          WI=(WTRA2IS(ISOUR)
     &      -DXEXI/2.0D0*slopein**2) !wi is detour for on-axis particle
     &      *(dmygamma/egamma)**2
        else
          if (iwarnwi.eq.0) then
            write(lungfo,*)
            write(lungfo,*)'*** Warning in souintana_omp:'
            write(lungfo,*)'*** MYINUM is rather small with respect to NLPOI'
            write(lungfo,*)'*** Length of trajectories are now calculated by simple'
            write(lungfo,*)'*** integration with souintana_omp, which might be poor'
            write(lungfo,*)
            write(lungfo,*)
            write(6,*)'*** Warning in souintana_omp:'
            write(6,*)'*** MYINUM is rather small with respect to NLPOI'
            write(6,*)'*** Length of trajectories are now calculated by simple'
            write(6,*)'*** integration with souintana_omp, which might be poor'
            write(6,*)
            iwarnwi=1
          endif
          wi=(yp2zp2i/2.0d0
     &      -DXEXI/2.0D0*slopein**2) !wi is detour for on-axis particle
     &      *(dmygamma/egamma)**2
        endif

        xn1=cenxexi
        yn1=(xn1-cenxexi)*vyelec/vxelec
        zn1=(xn1-cenxexi)*vzelec/vxelec

        drn2=(
     &    (yn1+dxexi*vyelec/vxelec)**2+
     &    (zn1+dxexi*vzelec/vxelec)**2
     &    )/
     &    (2.0d0*(xobsv-xn1-dxexi))

        drn1=(
     &    yn1**2+
     &    zn1**2
     &    )/
     &    (2.0d0*(xobsv-xn1))

        DTPHASE=(
     &    WI+DXEXI*(slope**2/2.0d0+1.0d0/(2.0D0*GAMGAM0))
     &    +drn2-drn1)
     &    /CLIGHT1*GAMGAM0/GAMGAM

        AMPDT=AMPSHIFT(1)/CLIGHT1/2.0D0/GAMGAM0
        FREQR=2.D0*PI1/DTPHASE*HBAREV1
        POW=SPECPOW(jliob)

        if (jpin.ne.3.or.jpin.eq.3.and.ielec.eq.1) SPECPOW(jliob)=0.0D0

        DO I=1,-IAMPLI
          R02=(XOBSV-CENXEXI)**2+YOBSV**2+ZOBSV**2
          R2=(XOBSV-CENXEXI-DXEXI*(I-ABS(IAMPLI)/2+1))**2
     &      +YOBSV**2+ZOBSV**2
          SPECPOW(jliob)=SPECPOW(jliob)+POW*R02/R2
     &      *R2/(sqrt(R2)-ampr2corr/2.0d0)**2/nelec
        ENDDO

      ENDIF  !endif iampli.lt.0

      DO kfreq=1,NFREQ

        jliobfr=ISOUR+NSOURCE*(IOBSV-1+NOBSV*(kfreq-1))
        kfrob=kfreq+NFREQ*(IOBSV-1)
        jobfr=IOBSV+NOBSV*(kfreq-1)

        OM=FREQ(kfreq)/HBAREV1

        IF (IAMPLI.LT.0) THEN

          AX0=affe(1,kfrob)
          AY0=affe(2,kfrob)
          AZ0=affe(3,kfrob)

          AX=AX0
          AY=AY0
          AZ=AZ0

          BX0=affe(4,kfrob)
          BY0=affe(5,kfrob)
          BZ0=affe(6,kfrob)

          BXc=BX0
          BYc=BY0
          BZc=BZ0

          affe(1:6,kfrob)=(0.0D0,0.0D0)

          R0=OBSV(1,NOBSV/2+1)-CENXEXI
          R02=R0*R0
          R00=R0

c          H2=(YOBSV-vyelec)**2+(ZOBSV-vzelec)**2
c          H2R2=H2/R02
c
c          DTPHASE=(WTRA2IS(ISOUR)+(H2R2+1.0D0/GAMGAM0)*DXEXI/2.D0)/CLIGHT1
c     &      *GAMGAM0/GAMGAM
c     &      +AMPDT

          xn1=cenxexi
          yn1=(xn1-cenxexi)*vyelec/vxelec
          zn1=(xn1-cenxexi)*vzelec/vxelec

          drn2=(
     &      (yn1+dxexi*vyelec/vxelec-yobsv)**2+
     &      (zn1+dxexi*vzelec/vxelec-zobsv)**2
     &      )/
     &      (2.0d0*(xobsv-xn1-dxexi))

          drn1=(
     &      (yn1-yobsv)**2+
     &      (zn1-zobsv)**2
     &      )/
     &      (2.0d0*(xobsv-xn1))

          DTPHASE=(
     &      WI+DXEXI*(slope**2/2.0d0+1.0d0/(2.0D0*GAMGAM0))
     &      +drn2-drn1)
     &      /CLIGHT1*GAMGAM0/GAMGAM
     &      +AMPDT

          PHI=2.D0*PI1*FREQ(kfreq)*ECHARGE1/HPLANCK1*DTPHASE

          DMODU=EXP(ZI*PHI)
          DMODU0=DMODU
          DDMODU=ZONE

          if (ibunch.ne.0) then

            zzi=zeleco
            yyi=yeleco
            zzpi=zpeleco
            yypi=ypeleco

c  transform to beginning of first section
            zz=tfmhtoti(1,1)*zzi+tfmhtoti(1,2)*zzpi
            zzp=tfmhtoti(2,1)*zzi+tfmhtoti(2,2)*zzpi
            yy=tfmvtoti(1,1)*yyi+tfmvtoti(1,2)*yypi
            yyp=tfmvtoti(2,1)*yyi+tfmvtoti(2,2)*yypi

          endif !ibunch

          DO I=1,-IAMPLI

            if (ibunch.ne.0) then

c  transform to center of section, no closed orbit!
                zelec=tfmhc(1,1)*zz+tfmhc(1,2)*zzp
                zpelec=tfmhc(2,1)*zz+tfmhc(2,2)*zzp
                yelec=tfmvc(1,1)*yy+tfmvc(1,2)*yyp
                ypelec=tfmvc(2,1)*yy+tfmvc(2,2)*yyp

c  transform to beginning of next section

              zzi=zz
              yyi=yy
              zzpi=zzp
              yypi=yyp

              zz=tfmh(1,1)*zzi+tfmh(1,2)*zzpi
              zzp=tfmh(2,1)*zzi+tfmh(2,2)*zzpi
              yy=tfmv(1,1)*yyi+tfmv(1,2)*yypi
              yyp=tfmv(2,1)*yyi+tfmv(2,2)*yypi

            endif !ibunch

            R0=OBSV(1,NOBSV/2+1)+DXEXI/2.D0*(-IAMPLI-2*(I-1)-1)-CENXEXI
            CORRR0=R00/R0
            !corrects for mistake of averaging over 1/r2, if e.g.
            !the repeated device is a long undulator
     &        *(R0/(R0-ampr2corr/2.0d0))**2

            R02=R0*R0
c            H2=(YOBSV)**2+(ZOBSV)**2
c            H2R2=H2/R02

c            DTPHASE=(WTRA2IS(ISOUR)+(H2R2+1.0D0/GAMGAM0)*DXEXI/2.D0)/CLIGHT1
c     &        *GAMGAM0/GAMGAM
c     &        +AMPDT

c            slope=sqrt(vyelec**2+vzelec**2)/vxelec

            slope=sqrt(ypelec**2+zpelec**2)*gamgam0/gamgam

            slope=sqrt(ypelec**2+zpelec**2)

            xn1=cenxexi-dxexi/2.d0*(-iampli-2*(i-1)-1)
     &          /(R0/(R0-ampr2corr/2.0d0))**2 !empirically
            yn1=(xn1-cenxexi)*ypelec
            zn1=(xn1-cenxexi)*zpelec

            yn1=yelec
            zn1=zelec

            drn2=(
     &        (yn1+dxexi*ypelec-yobsv)**2+
     &        (zn1+dxexi*zpelec-zobsv)**2
     &        )/
     &        (2.0d0*(xobsv-xn1-dxexi))

            drn1=(
     &        (yn1-yobsv)**2+
     &        (zn1-zobsv)**2
     &        )/
     &        (2.0d0*(xobsv-xn1))

            DTPHASE=(
     &        WI+DXEXI*(slope**2/2.0d0+1.0d0/(2.0D0*GAMGAM0))
     &        +drn2-drn1)
     &        /CLIGHT1*GAMGAM0/GAMGAM
     &        +AMPDT

            PHI=2.D0*PI1*FREQ(kfreq)*ECHARGE1/HPLANCK1*DTPHASE

            DMODU=EXP(ZI*PHI)
            DMODU0=DMODU
            DDMODU=ZONE

              affe(1,kfrob)=affe(1,kfrob)+AX
              affe(2,kfrob)=affe(2,kfrob)+AY
              affe(3,kfrob)=affe(3,kfrob)+AZ

              affe(4,kfrob)=affe(4,kfrob)+bXc
              affe(5,kfrob)=affe(5,kfrob)+bYc
              affe(6,kfrob)=affe(6,kfrob)+bZc

            IF (AMPRAN.NE.0.0D0) THEN
              PHI=2.D0*PI1*XRANA(I)/FREQR*FREQ(kfreq)
              DDMODU=EXP(ZI*PHI)
            ENDIF   !(AMPRAN.NE.0.0D0)

            AX0=AX0*DMODU0
            AY0=AY0*DMODU0
            AZ0=AZ0*DMODU0

            AX=AX0*CORRR0
            AY=AY0*CORRR0
            AZ=AZ0*CORRR0

            DMODU=DMODU0*DDMODU
            AX=AX*DMODU
            AY=AY*DMODU
            AZ=AZ*DMODU

            BX0=BX0*DMODU0
            BY0=BY0*DMODU0
            BZ0=BZ0*DMODU0

            BXc=BX0*CORRR0
            BYc=BY0*CORRR0
            BZc=BZ0*CORRR0

            BXc=BXc*DMODU
            BYc=BYc*DMODU
            BZc=BZc*DMODU

          ENDDO !IAMPLI

          zelec=zeleco
          yelec=yeleco

        ENDIF  !(IAMPLI.LT.0)

        if (jpin.eq.3) then

          FSPEC(1)=ISOUR
          FSPEC(2)=IOBSV
          FSPEC(3)=xobsv
          FSPEC(4)=yobsv
          FSPEC(5)=zobsv
          FSPEC(6)=FREQ(kfreq)
          FSPEC(7)=
     &      (
     &      DREAL(affe(1,kfrob))*DREAL(affe(1,kfrob))
     &      +DIMAG(affe(1,kfrob))*DIMAG(affe(1,kfrob))
     &      +DREAL(affe(2,kfrob))*DREAL(affe(2,kfrob))
     &      +DIMAG(affe(2,kfrob))*DIMAG(affe(2,kfrob))
     &      +DREAL(affe(3,kfrob))*DREAL(affe(3,kfrob))
     &      +DIMAG(affe(3,kfrob))*DIMAG(affe(3,kfrob))
     &      )*specnor*bunnor
          FSPEC(8)=1
          FSPEC(9)=1
          FSPEC(10)=kfreq
          FSPEC(11)=dreal(affe(1,kfrob))*sqrt(specnor*bunnor)
          FSPEC(12)=dimag(affe(1,kfrob))*sqrt(specnor*bunnor)
          FSPEC(13)=dreal(affe(2,kfrob))*sqrt(specnor*bunnor)
          FSPEC(14)=dimag(affe(2,kfrob))*sqrt(specnor*bunnor)
          FSPEC(15)=dreal(affe(3,kfrob))*sqrt(specnor*bunnor)
          FSPEC(16)=dimag(affe(3,kfrob))*sqrt(specnor*bunnor)
          FSPEC(17)=0.0d0
          FSPEC(18)=0.0d0
          FSPEC(19)=0.0d0
          FSPEC(20)=0.0d0

          FSPEC(21)=dreal(affe(4,kfrob))*sqrt(specnor*bunnor)
          FSPEC(22)=dimag(affe(4,kfrob))*sqrt(specnor*bunnor)
          FSPEC(23)=dreal(affe(5,kfrob))*sqrt(specnor*bunnor)
          FSPEC(24)=dimag(affe(5,kfrob))*sqrt(specnor*bunnor)
          FSPEC(25)=dreal(affe(6,kfrob))*sqrt(specnor*bunnor)
          FSPEC(26)=dimag(affe(6,kfrob))*sqrt(specnor*bunnor)
          FSPEC(27)=0.0d0
          FSPEC(28)=0.0d0
          FSPEC(29)=0.0d0
          FSPEC(30)=0.0d0

          if (ispecdip.le.0) then
            cenxexi=(min(sourceeo(1,1,isour),xiend)
     &        +max(sourceao(1,1,isour),xianf))/2.d0
          else
            cenxexi=x0dip(isour)
          endif

          dist0=pincen(1)-cenxexi
          dist02=dist0**2

          h2=(yobsv**2+zobsv**2)/dist02
          if (h2.lt.0.01) then
            ddist=dist0*(h2/2.0d0-h2**2/8.0d0)
          else
            ddist=dist0*(sqrt(1.0d0+h2)-1.0d0)
          endif

          dphase=ddist/freq(kfreq)*wtoe1*1.0d9*twopi1

          FSPEC(31)=dphase

          call hfm(nidspec,fspec)

          FSPEC(1)=xobsv
          FSPEC(2)=yobsv
          FSPEC(3)=zobsv
          FSPEC(4)=powpow*pownor
          FSPEC(5)=0.0d0
          FSPEC(6)=1.0d0
          FSPEC(7)=1.0d0
          FSPEC(8)=iobsv
          FSPEC(9)=ISOUR

          call hfm(nidpow,fspec)

          if (istokes.ne.0) then

            APOLH=
     &        affe(1,kfrob)*CONJG(VSTOKES(1,1))
     &        +affe(2,kfrob)*CONJG(VSTOKES(1,2))
     &        +affe(3,kfrob)*CONJG(VSTOKES(1,3))

            APOLR=
     &        affe(1,kfrob)*CONJG(VSTOKES(2,1))
     &        +affe(2,kfrob)*CONJG(VSTOKES(2,2))
     &        +affe(3,kfrob)*CONJG(VSTOKES(2,3))

            APOLL=
     &        affe(1,kfrob)*CONJG(VSTOKES(3,1))
     &        +affe(2,kfrob)*CONJG(VSTOKES(3,2))
     &        +affe(3,kfrob)*CONJG(VSTOKES(3,3))

            APOL45=
     &        affe(1,kfrob)*CONJG(VSTOKES(4,1))
     &        +affe(2,kfrob)*CONJG(VSTOKES(4,2))
     &        +affe(3,kfrob)*CONJG(VSTOKES(4,3))

            STOK1=
     &        APOLR*CONJG(APOLR)+
     &        APOLL*CONJG(APOLL)

            STOK2=-STOK1+
     &        2.0d0*APOLH*CONJG(APOLH)

            STOK3=
     &        2.0d0*APOL45*CONJG(APOL45)-
     &        STOK1

            STOK4=
     &        APOLR*CONJG(APOLR)-
     &        APOLL*CONJG(APOLL)

            FSPEC(1)=IOBSV
            FSPEC(2)=xobsv
            FSPEC(3)=yobsv
            FSPEC(4)=zobsv
            FSPEC(5)=FREQ(kfreq)
            FSPEC(6)=STOK1*specnor*bunnor
            FSPEC(7)=STOK2*specnor*bunnor
            FSPEC(8)=STOK3*specnor*bunnor
            FSPEC(9)=STOK4*specnor*bunnor
            FSPEC(10)=1.0d0
            FSPEC(11)=1.0d0
            FSPEC(12)=kfreq

            CALL hfm(NIDSTOK,FSPEC)

          ENDIF   !ISTOKES

        endif !ipin.eq.3

        if (ihbunch.ne.0.and.iobsv.eq.icbrill) then
            fillb(1)=ibun
            fillb(2)=isub
            fillb(3)=ielec
            fillb(4)=bunchx
            fillb(5)=xelec
            fillb(6)=yelec
            fillb(7)=zelec
            fillb(8)=vyelec/vxelec
            fillb(9)=vzelec/vxelec
            fillb(10)=x2
            fillb(11)=y2
            fillb(12)=z2
            fillb(13)=vy2/vx2
            fillb(14)=vz2/vx2
            fillb(15)=egamma*emassg1
            fillb(16)=gamma*emassg1
            fillb(17)=xobsv
            fillb(18)=yobsv
            fillb(19)=zobsv
            fillb(20)=kfreq
            fillb(21)=freq(kfreq)
            speck=
     &        DREAL(
     &        affe(1,kfrob)*CONJG(affe(1,kfrob))
     &        +affe(2,kfrob)*CONJG(affe(2,kfrob))
     &        +affe(3,kfrob)*CONJG(affe(3,kfrob))
     &        )*specnor*bunnor
            fillb(22)=speck*nelec

            if (istokes.ne.0) then

              APOLH=
     &          affe(1,kfrob)*CONJG(VSTOKES(1,1))
     &          +affe(2,kfrob)*CONJG(VSTOKES(1,2))
     &          +affe(3,kfrob)*CONJG(VSTOKES(1,3))

              APOLR=
     &          affe(1,kfrob)*CONJG(VSTOKES(2,1))
     &          +affe(2,kfrob)*CONJG(VSTOKES(2,2))
     &          +affe(3,kfrob)*CONJG(VSTOKES(2,3))

              APOLL=
     &          affe(1,kfrob)*CONJG(VSTOKES(3,1))
     &          +affe(2,kfrob)*CONJG(VSTOKES(3,2))
     &          +affe(3,kfrob)*CONJG(VSTOKES(3,3))

              APOL45=
     &          affe(1,kfrob)*CONJG(VSTOKES(4,1))
     &          +affe(2,kfrob)*CONJG(VSTOKES(4,2))
     &          +affe(3,kfrob)*CONJG(VSTOKES(4,3))

              STOK1=
     &          APOLR*CONJG(APOLR)+
     &          APOLL*CONJG(APOLL)

              STOK2=-STOK1+
     &          2.0d0*APOLH*CONJG(APOLH)

              STOK3=
     &          2.0d0*APOL45*CONJG(APOL45)-
     &          STOK1

              STOK4=
     &          APOLR*CONJG(APOLR)-
     &          APOLL*CONJG(APOLL)

              fillb(23)=stok1*specnor*bunnor*nelec
              fillb(24)=stok2*specnor*bunnor*nelec
              fillb(25)=stok3*specnor*bunnor*nelec
              fillb(26)=stok4*specnor*bunnor*nelec

            else
              fillb(23)=fillb(22)
              fillb(24:26)=0.0d0
            endif !istokes

          fillb(27)=powpow*pownor*nelec
          fillb(28)=isour
          fillb(29)=t2

          call hfm(nidbunch,fillb)
        endif

        if (ibunphase.eq.1) then

          are(1:6)=dreal(affe(1:6,kfrob))
          aim(1:6)=dimag(affe(1:6,kfrob))

          if (iobunch.eq.-9999.and.ielec.eq.1) then
            ampz(kfreq)=sqrt(are(3)**2+aim(3)**2)
            if (ampz(kfreq).gt.ampzmax(kfreq)) then
              ampzmax(kfreq)=ampz(kfreq)
              kobs(kfreq)=iobsv
            endif
          else if (iobsv.eq.iobunch) then
            ampz(kfreq)=sqrt(are(3)**2+aim(3)**2)
            if (ampz(kfreq).ne.0.0d0) then
              azcos(kfreq)=are(3)/ampz(kfreq)
              azsin(kfreq)=aim(3)/ampz(kfreq)
            else
              azcos(kfreq)=1.0d0
              azsin(kfreq)=0.0d0
            endif
          endif

          if (iobsv.eq.nobsv.and.kfreq.eq.nfreq) then

            do jfreq=1,nfreq

              jfrob=jfreq+nfreq*(kobs(jfreq)-1)
              are(1:6)=dreal(affe(1:6,jfrob))
              aim(1:6)=dimag(affe(1:6,jfrob))

              ampz(jfreq)=sqrt(are(3)**2+aim(3)**2)
              if (ampz(jfreq).ne.0.0d0) then
                azcos(jfreq)=are(3)/ampz(jfreq)
                azsin(jfreq)=aim(3)/ampz(jfreq)
              else
                azcos(jfreq)=1.0d0
                azsin(jfreq)=0.0d0
              endif

            enddo !jfreq

            do job=1,nobsv
              do jfreq=1,nfreq

                jfrob=jfreq+nfreq*(job-1)

                are(1:6)=dreal(affe(1:6,jfrob))
                aim(1:6)=dimag(affe(1:6,jfrob))

                affe(1:6,jfrob)=dcmplx(
     &            azcos(jfreq)*are+azsin(jfreq)*aim,
     &            -azsin(jfreq)*are+azcos(jfreq)*aim
     &            )

                AFREQ(1:6,jfrob)=AFREQ(1:6,jfrob)+affe(1:6,jfrob)

                affe(1:6,jfrob)=(0.0D0,0.0D0)

              enddo
            enddo

          endif !iobsv.eq.nobsv

        else !ibunphase

          if (iobsv.eq.nobsv.and.kfreq.eq.nfreq) then
            AFREQ=AFREQ+affe
            affe=(0.0D0,0.0D0)
          endif

        endif !ibunphase

      ENDDO !kfreq

      if (isub.eq.neinbunch.and.iobsv.eq.nobsv) then

        do job=1,nobsv
          do kfreq=1,nfreq

            kfrob=kfreq+nfreq*(job-1)
            jliobfr=isour+nsource*(job-1+nobsv*(kfreq-1))
            jobfr=job+nobsv*(kfreq-1)

            IF(SPECCUT.GT.0.0D0) THEN
              ECMAXS=ECMAX(ISOUR)
              IF(FREQ(kfreq).GT.SPECCUT*ecdipev1*DMYENERGY**2*ECMAXS) THEN
                AFREQ(1:6,kfrob)=(0.0D0,0.0D0)
              ENDIF
            ENDIF

            AFREQ(1:3,kfrob)=AFREQ(1:3,kfrob)*REFLEC(1:3)
            AFREQ(4:6,kfrob)=AFREQ(4:6,kfrob)*REFLEC(1:3)

            IF (IPOLA.EQ.0) THEN

              speck=
     &          DREAL(
     &          AFREQ(1,kfrob)*CONJG(AFREQ(1,kfrob))
     &          +AFREQ(2,kfrob)*CONJG(AFREQ(2,kfrob))
     &          +AFREQ(3,kfrob)*CONJG(AFREQ(3,kfrob))
     &          )*specnor*bunnor

              SPEC(jliobfr)=SPEC(jliobfr)+speck

              REAIMA(1:3,1,jobfr)=REAIMA(1:3,1,jobfr)+
     &          DREAL(AFREQ(1:3,kfrob))/sqnbunch
              REAIMA(1:3,2,jobfr)=REAIMA(1:3,2,jobfr)+
     &          DIMAG(AFREQ(1:3,kfrob))/sqnbunch

              REAIMA(6:8,1,jobfr)=REAIMA(6:8,1,jobfr)+
     &          DREAL(AFREQ(4:6,kfrob))/sqnbunch
              REAIMA(6:8,2,jobfr)=REAIMA(6:8,2,jobfr)+
     &          DIMAG(AFREQ(4:6,kfrob))/sqnbunch

            ELSE    !IPOLA

              APOL=
     &          AFREQ(1,kfrob)*CONJG(VPOLA(1))
     &          +AFREQ(2,kfrob)*CONJG(VPOLA(2))
     &          +AFREQ(3,kfrob)*CONJG(VPOLA(3))

              SPEC(jliobfr)=SPEC(jliobfr)+
     &          DREAL(APOL*CONJG(APOL))*specnor*bunnor

              REAIMA(1:3,1,jobfr)=REAIMA(1:3,1,jobfr)+
     &          DREAL(AFREQ(1:3,kfrob))/sqnbunch
              REAIMA(1:3,2,jobfr)=REAIMA(1:3,2,jobfr)+
     &          DIMAG(AFREQ(1:3,kfrob))/sqnbunch

              REAIMA(6:8,1,jobfr)=REAIMA(6:8,1,jobfr)+
     &          DREAL(AFREQ(4:6,kfrob))/sqnbunch
              REAIMA(6:8,2,jobfr)=REAIMA(6:8,2,jobfr)+
     &          DIMAG(AFREQ(4:6,kfrob))/sqnbunch

            ENDIF   !IPOLA

            IF (ISTOKES.NE.0) THEN

              APOLH=
     &          AFREQ(1,kfrob)*CONJG(VSTOKES(1,1))
     &          +AFREQ(2,kfrob)*CONJG(VSTOKES(1,2))
     &          +AFREQ(3,kfrob)*CONJG(VSTOKES(1,3))

              APOLR=
     &          AFREQ(1,kfrob)*CONJG(VSTOKES(2,1))
     &          +AFREQ(2,kfrob)*CONJG(VSTOKES(2,2))
     &          +AFREQ(3,kfrob)*CONJG(VSTOKES(2,3))

              APOLL=
     &          AFREQ(1,kfrob)*CONJG(VSTOKES(3,1))
     &          +AFREQ(2,kfrob)*CONJG(VSTOKES(3,2))
     &          +AFREQ(3,kfrob)*CONJG(VSTOKES(3,3))

              APOL45=
     &          AFREQ(1,kfrob)*CONJG(VSTOKES(4,1))
     &          +AFREQ(2,kfrob)*CONJG(VSTOKES(4,2))
     &          +AFREQ(3,kfrob)*CONJG(VSTOKES(4,3))

              STOK1=
     &          APOLR*CONJG(APOLR)+
     &          APOLL*CONJG(APOLL)

              STOK2=-STOK1+
     &          2.0d0*APOLH*CONJG(APOLH)

              STOK3=
     &          2.0d0*APOL45*CONJG(APOL45)-
     &          STOK1

              STOK4=
     &          APOLR*CONJG(APOLR)-
     &          APOLL*CONJG(APOLL)

              STOKES(1,jobfr)=STOKES(1,jobfr)+
     &          STOK1*specnor*bunnor

              STOKES(2,jobfr)=STOKES(2,jobfr)+
     &          STOK2*specnor*bunnor

              STOKES(3,jobfr)=STOKES(3,jobfr)+
     &          STOK3*specnor*bunnor

              STOKES(4,jobfr)=STOKES(4,jobfr)+
     &          STOK4*specnor*bunnor

            ENDIF !ISTOKES

            AFREQ(1,kfrob)=(0.0d0,0.0d0)
            AFREQ(2,kfrob)=(0.0d0,0.0d0)
            AFREQ(3,kfrob)=(0.0d0,0.0d0)

          enddo !kfreq
        enddo !job

      endif !isub.eq.neinbunch

      if (ibun.eq.nbunch.and.isub.eq.neinbunch) then
        jliob=ISOUR+NSOURCE*(IOBSV-1)
        SPECPOW(jliob)=SPECPOW(jliob)*POWNOR
      endif

      IF (
     &    jpin.ne.0.and.jpin.ne.3.and.IOBSV.EQ.jobunch
     &    .or.
     &    (jpin.eq.3.or.jpin.eq.0).and.ielec.eq.1
     &    ) THEN


        WRITE(LUNGFO,*)
     &    '       phase advance per step at beginning and end of source for'
        if (jpin.ne.3) then
          WRITE(LUNGFO,*)
     &      '       lowest and highest photon energy at selected observation point:'
        else
          WRITE(LUNGFO,*)
     &      '       lowest and highest photon energy for first electron:'
        endif
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'       beginning:',SNGL(DPHSOUR(1,1)),SNGL(DPHSOUR(1,2))
        WRITE(LUNGFO,*)'       end:      ',SNGL(DPHSOUR(2,1)),SNGL(DPHSOUR(2,2))
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'       ROIs (boundary, precision, points):'
        WRITE(LUNGFO,*)

        DO IROI=1,NROIA-1
          WRITE(LUNGFO,*)
     &      IROI,SNGL(roi(1,IROI)),SNGL(roi(2,IROI)),IPOIROI(IROI+1)
        ENDDO
        WRITE(LUNGFO,*)
     &    NROI,SNGL(roi(1,NROIA))

      ENDIF !IOBSV

      IF (
     &    jpin.ne.0.and.jpin.ne.3.and.IOBSV.EQ.NOBSV
     &    .or.
     &    (jpin.eq.0.or.jpin.eq.3).and.ielec.eq.1) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'       SOURCE, TOTAL NUMBER OF STEPS:',ISOUR,IZAEHL
        WRITE(LUNGFO,*)'       (controlled by NLPOI and namelist $ROIN)'
        WRITE(LUNGFO,*)
      ENDIF

      isourold=isour

      RETURN
      END
+PATCH,FOR.
*CMZ : 00.00/00 10/01/95  15.22.39  by  Michael Scheer
+DECK,BELLIP.
*CMZ :  4.01/04 06/12/2023  10.37.05  by  Michael Scheer
*CMZ :  4.01/02 26/04/2023  07.35.28  by  Michael Scheer
*CMZ :  4.00/15 28/04/2022  09.27.00  by  Michael Scheer
*CMZ :  4.00/07 09/07/2020  12.37.21  by  Michael Scheer
*CMZ :  3.06/00 26/02/2019  14.12.24  by  Michael Scheer
*CMZ :  3.05/06 17/07/2018  11.15.16  by  Michael Scheer
*CMZ :  3.03/04 03/08/2017  15.33.14  by  Michael Scheer
*CMZ :  3.03/02 31/08/2016  15.06.48  by  Michael Scheer
*CMZ :  3.01/02 02/09/2013  15.00.48  by  Michael Scheer
*CMZ :  3.01/01 19/07/2013  16.20.01  by  Michael Scheer
*CMZ :  3.00/02 10/04/2013  09.27.41  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.67/04 11/05/2012  11.18.26  by  Michael Scheer
*CMZ :  2.67/02 18/04/2012  14.13.08  by  Michael Scheer
*CMZ :  2.66/09 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.66/07 02/03/2010  09.40.31  by  Michael Scheer
*CMZ :  2.62/02 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  2.16/08 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  16.58.05  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  14.44.33  by  Michael Scheer
*CMZ : 00.01/07 28/02/95  14.22.48  by  Michael Scheer
*CMZ : 00.01/06 17/02/95  12.25.05  by  Michael Scheer
*CMZ : 00.01/04 19/01/95  09.36.21  by  Michael Scheer
*CMZ : 00.01/02 24/11/94  15.45.15  by  Michael Scheer
*CMZ : 00.01/01 21/09/94  17.30.43  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.46.58  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.41  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BELLIP(X,Y,Z,BX,BY,BZ,AX,AY,AZ)

      use f1k

+seq,gplhint.

      IMPLICIT NONE

      DOUBLE PRECISION BX,BY,BZ,AX,AY,AZ,X,Y,Z
      DOUBLE PRECISION WLEN1,PARK,B0EFF,EHARM1,parkv,parkh
      DOUBLE PRECISION RHV,pbue(13),f1

      INTEGER,save :: ICAL=0
      INTEGER i

+seq,cmpara.
+SEQ,CONTRL.
+SEQ,PHYCON.
+SEQ,ELLIP.
+seq,mgsqc.
+SEQ,freqs.


      IF (ICAL.EQ.0) THEN

        park=parkell

        if (nharmell.ne.0.and.harmell.ne.0.0d0) then
          if (harmell.eq.-9999.0d0) then
c            if (ifreq2p.eq.1) then
c              harmell=freqlow
c            else
              harmell=(freqlow+freqhig)/2.0d0
c            endif
          endif
          if (harmell.lt.0.0d0) then
            harmell=-wtoe1/harmell
          endif
          WLEN1=wtoe1/abs(harmell/nharmell)
          park=2.0d0*(wlen1/(xlellip*1.0D9/2.0d0/DMYGAMMA**2)-1.0d0)
          if (park.lt.0.0d0) then
            write(6,*)
     &        '*** Error in BELLIP:'
            write(6,*)
     &        'Inconsistent values of NHARMELL, HARMELL, and XLELLIP'
            write(6,*)' '
            write(lungfo,*)
     &        '*** Error in BELLIP:'
            write(lungfo,*)
     &        'Inconsistent values of NHARMELL, HARMELL, and XELLIP'
            write(lungfo,*)' '
            stop
          endif
          park=sqrt(park)
          parkell=park
        endif

        IF (parkell.NE.0.0) THEN

          B0EFF=parkell/(echarge1*XLELLIP/(2.*PI1*EMASSKG1*CLIGHT1))

          if (b0elliph.eq.0.0d0.and.b0ellipv.ne.0d0) then
            b0ellipv=b0ellipv/abs(b0ellipv)*b0eff
          else if (b0ellipv.eq.0.0d0.and.b0elliph.ne.0d0) then
            b0elliph=b0elliph/abs(b0elliph)*b0eff
          else

            rhv=b0elliph/b0ellipv

            b0elliph=b0eff/sqrt(1.0d0+1.0d0/rhv**2)*b0elliph/abs(b0elliph)
            b0ellipv=b0elliph/rhv

          endif

        ENDIF

        IF (B0ELLIPV.NE.0.0) THEN
          RHV=B0ELLIPH/B0ELLIPV
        ELSE
          RHV=0.0D0
        ENDIF

        XLENELL=DABS((PERELLIP+ELLSHFT)*XLELLIP)
        IF (XLELLIP.NE.0.0) then
          XKELLIP=2.D0*PI1/XLELLIP
          zampell=b0ellipv*clight1/emom/xkellip**2
          yampell=b0elliph*clight1/emom/xkellip**2
        endif

        B0EFF=DSQRT(B0ELLIPH**2+B0ELLIPV**2)
        PARKv=ECHARGE1*DABS(B0elliph)*XLELLIP/(2.*PI1*EMASSKG1*CLIGHT1)
        PARKh=ECHARGE1*DABS(B0ellipv)*XLELLIP/(2.*PI1*EMASSKG1*CLIGHT1)
        PARK=ECHARGE1*DABS(B0EFF)*XLELLIP/(2.*PI1*EMASSKG1*CLIGHT1)
        WLEN1=(1.0d0+PARK**2/2.0d0)/2.0d0/DMYGAMMA**2*XLELLIP*1.0D9
        IF (WLEN1.NE.0.0) EHARM1=WTOE1/WLEN1

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     SR BELLIP, Parameters of elliptical undulator:'
        WRITE(LUNGFO,*)
     &    '     horizontal and vertical peak field [T]:'
     &    ,SNGL(B0ELLIPH),SNGL(B0ELLIPV)
        WRITE(LUNGFO,*)
     &    '     number of periods, period and device length [m]:'
        WRITE(LUNGFO,*)
     &    '     ',SNGL(PERELLIP),SNGL(XLELLIP),SNGL(XLENELL)
        WRITE(LUNGFO,*)
     &    '     shift parameter [periods], B_h/B_v:    '
     &    ,SNGL(ELLSHFT),SNGL(RHV)
        WRITE(LUNGFO,*)
     &    '     B0_eff [T], deflection parameter K:'
     &    ,SNGL(B0EFF),SNGL(PARK)
        WRITE(LUNGFO,*)
     &    '     Approximated path hori. and. vert. amplitudes [m]:',
     &    SNGL(zampell),sngl(yampell)
        WRITE(LUNGFO,*)
     &    '     Hori. and. vert. deflection angle [rad]:',
     &    SNGL(parkv/dmygamma),sngl(parkh/dmygamma)
        WRITE(LUNGFO,*)
     &    '     1. harmonical [nm] and [eV], omega [1/s]:',
     &    sngl(wlen1),SNGL(EHARM1),sngl(eharm1/hbarev1)
        WRITE(LUNGFO,*)
     &    '     critical energy [eV]:',SNGL(ecdipev1*DABS(B0EFF)*DMYENERGY**2)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     longitudinal position of device center [m]:',xcenell
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     taper factor to compensate energy-loss:',elltap
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     Estimate of 1. harm. on-axis flux-density in 10m / mm**2 / 0.1%BW'
        do i=1,1000
          if (park.ge.f1kk(i)) cycle
          f1=f1kf(i)
          exit
        enddo
        WRITE(LUNGFO,*)
     &    '     ',
     &    sngl(1.744e14*perellip**2*dmyenergy**2*dmycur*f1/100.0d0)
        WRITE(LUNGFO,*)

        ICAL=1

      ENDIF

      pbue=PMAG(1:13,NMGSQP)

      PMAG(1,NMGSQP)=park
      PMAG(2,NMGSQP)=b0ellipv
      PMAG(3,NMGSQP)=b0elliph
cerror 31.8.2016      PMAG(4,NMGSQP)=ellshft*xlellip
      PMAG(4,NMGSQP)=ellshft
      PMAG(5,NMGSQP)=xcenell
      PMAG(6,NMGSQP)=xlellip
      PMAG(7,NMGSQP)=perellip
      PMAG(8,NMGSQP)=0.0d0
      pmag(11,nmgsqp)=elltap

      call bue(x,y,z,bx,by,bz,ax,ay,az,nmgsqp)

      PMAG(1:13,NMGSQP)=pbue

      RETURN
      END
+DECK,CHECKOB.
*CMZ :  4.01/04 20/11/2023  22.07.55  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.10  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.17/00 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  14.22.44  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  2.12/03 22/07/99  10.49.26  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  15.40.33  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.49.00  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.51  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE CHECKOB
+seq,gplhint.

+SELF,IF=F90.
+SEQ,OBSERVF90U.
+SELF.

C--- CHECKS CONSISTENCE OF OBSERVATION POINTS AND COLLIMATOR

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEq,observf90.
+SEQ,COLLI.

      INTEGER IOBSV

      DOUBLE PRECISION XOB,YOB,ZOB
      DOUBLE PRECISION UP1,DOWN1,RIGHT1,LEFT1,UP2,DOWN2,RIGHT2,LEFT2
      DOUBLE PRECISION YSLOPEU,YSLOPED,ZSLOPEL,ZSLOPER,DLEN,DIST

      UP1=CY1+HIG1/2.D0
      DOWN1=CY1-HIG1/2.D0
      RIGHT1=CZ1+WID1/2.D0
      LEFT1=CZ1-WID1/2.D0

      UP2=CY2+HIG2/2.D0
      DOWN2=CY2-HIG2/2.D0
      RIGHT2=CZ2+WID2/2.D0
      LEFT2=CZ2-WID2/2.D0

      DLEN=CX2-CX1

      IF (DLEN.EQ.0.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING SR CHECKOB ***'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'COLLIMATOR HAS ZERO LENGTH, OBSERVER POSITIONS ARE NOT CHECKED, BE CAREFUL !'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(6,*)'*** WARNING SR CHECKOB ***'
        WRITE(6,*)
        WRITE(6,*)'COLLIMATOR HAS ZERO LENGTH, OBSERVER POSITIONS ARE NOT CHECKED, BE CAREFUL !'
        WRITE(6,*)
        WRITE(6,*)
        RETURN
      ENDIF

      YSLOPEU=(UP2-DOWN1)/DLEN
      YSLOPED=(DOWN2-UP1)/DLEN
      ZSLOPEL=(LEFT2-RIGHT1)/DLEN
      ZSLOPER=(RIGHT2-LEFT1)/DLEN

      DO IOBSV=1,NOBSV

        if (rpinsph.ne.0.0d0) then
          XOB=OBSV(1,IOBSV)+1.0e-5
        else
          XOB=OBSV(1,IOBSV)
        endif
        YOB=OBSV(2,IOBSV)
        ZOB=OBSV(3,IOBSV)
        DIST=XOB-CX2

        IF(
     &      XOB.LT.CX2
     &      .OR.
     &      YOB.GT.UP2+YSLOPEU*DIST
     &      .OR.
     &      YOB.LT.DOWN2+YSLOPED*DIST
     &      .OR.
     &      ZOB.GT.RIGHT2+ZSLOPER*DIST
     &      .OR.
     &      ZOB.LT.LEFT2+ZSLOPEL*DIST
     &      ) THEN
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN SR CHECKOB ***'
          WRITE(6,*)
     &      'OBSERVATION POINTS AND COLLIMATOR INCONSISTENT'
          WRITE(6,*)'CHECK RESULTS CAREFULLY'
          WRITE(6,*)
          WRITE(6,*)'OBSERVATION POINT (X,Y,Z):'
          WRITE(6,*)XOB,YOB,ZOB
          WRITE(6,*)
          WRITE(6,*)'CHECK ALSO DEFINITION OF COLLIMATOR'
          WRITE(6,*)
     &      'IN NAMELIST COLLIN; MAYBE DEFAULTS NOT USEFUL'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN SR CHECKOB ***'
          WRITE(LUNGFO,*)
     &      'OBSERVATION POINTS AND COLLIMATOR INCONSISTENT'
          WRITE(LUNGFO,*)'CHECK RESULTS CAREFULLY'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'OBSERVATION POINT (X,Y,Z):'
          WRITE(LUNGFO,*)XOB,YOB,ZOB
          WRITE(LUNGFO,*)'(REMAINING POINTS NOT CHECKED)'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'CHECK ALSO DEFINITION OF COLLIMATOR'
          WRITE(LUNGFO,*)
     &      'IN NAMELIST COLLIN; MAYBE DEFAULTS NOT USEFUL'
          RETURN
        ENDIF
      ENDDO

      RETURN
      END
+DECK,gfinit.
*CMZ :  4.01/04 27/12/2023  16.20.07  by  Michael Scheer
*CMZ :  4.01/03 29/06/2023  10.07.32  by  Michael Scheer
*CMZ :  4.01/03 15/05/2023  16.38.53  by  Michael Scheer
*CMZ :  4.01/02 14/05/2023  13.42.26  by  Michael Scheer
*CMZ :  4.01/00 08/01/2023  16.56.29  by  Michael Scheer
*CMZ :  4.00/17 15/11/2022  10.57.19  by  Michael Scheer
*CMZ :  4.00/16 09/09/2022  17.24.46  by  Michael Scheer
*CMZ :  4.00/15 30/05/2022  15.47.16  by  Michael Scheer
*CMZ :  4.00/14 30/12/2021  11.57.49  by  Michael Scheer
*CMZ :  4.00/13 09/11/2021  09.50.16  by  Michael Scheer
*CMZ :  4.00/11 27/06/2021  11.57.49  by  Michael Scheer
*CMZ :  4.00/10 22/09/2020  09.17.04  by  Michael Scheer
*CMZ :  4.00/07 06/06/2020  13.59.12  by  Michael Scheer
*CMZ :  4.00/06 02/12/2019  15.36.11  by  Michael Scheer
*CMZ :  4.00/04 24/09/2019  10.58.03  by  Michael Scheer
*CMZ :  4.00/03 09/05/2019  11.04.11  by  Michael Scheer
*CMZ :  4.00/01 12/04/2019  10.43.33  by  Michael Scheer
*CMZ :  4.00/00 04/04/2019  12.37.42  by  Michael Scheer
*CMZ :  3.08/01 03/04/2019  16.19.59  by  Michael Scheer
*CMZ :  3.07/01 29/03/2019  14.39.14  by  Michael Scheer
*CMZ :  3.06/00 28/02/2019  15.01.36  by  Michael Scheer
*CMZ :  3.05/28 18/12/2018  13.52.06  by  Michael Scheer
*CMZ :  3.05/14 25/09/2018  08.52.05  by  Michael Scheer
*CMZ :  3.05/13 19/09/2018  13.56.36  by  Michael Scheer
*CMZ :  3.05/06 17/07/2018  11.15.16  by  Michael Scheer
*CMZ :  3.05/05 11/07/2018  09.20.23  by  Michael Scheer
*CMZ :  3.05/04 28/06/2018  09.36.14  by  Michael Scheer
*CMZ :  3.05/03 18/05/2018  11.56.52  by  Michael Scheer
*CMZ :  3.05/02 15/05/2018  16.25.19  by  Michael Scheer
*CMZ :  3.05/01 04/05/2018  16.04.30  by  Michael Scheer
*CMZ :  3.05/00 26/04/2018  15.51.12  by  Michael Scheer
*CMZ :  3.04/00 01/03/2018  12.10.21  by  Michael Scheer
*CMZ :  3.03/04 06/11/2017  16.05.55  by  Michael Scheer
*CMZ :  3.03/02 28/06/2017  13.49.04  by  Michael Scheer
*CMZ :  3.03/01 11/11/2015  14.37.19  by  Michael Scheer
*CMZ :  3.03/00 25/09/2015  15.02.58  by  Michael Scheer
*CMZ :  3.02/09 08/07/2015  12.22.02  by  Michael Scheer
*CMZ :  3.02/06 12/06/2015  15.06.01  by  Michael Scheer
*CMZ :  3.02/05 22/03/2015  19.47.46  by  Michael Scheer
*CMZ :  3.02/04 11/03/2015  13.46.12  by  Michael Scheer
*CMZ :  3.02/03 10/11/2014  11.01.30  by  Michael Scheer
*CMZ :  3.02/00 09/09/2014  13.16.05  by  Michael Scheer
*CMZ :  3.01/10 14/08/2014  14.43.07  by  Michael Scheer
*CMZ :  3.01/08 04/07/2014  09.03.18  by  Michael Scheer
*CMZ :  3.01/06 20/06/2014  16.28.51  by  Michael Scheer
*CMZ :  3.01/01 18/09/2013  12.33.23  by  Michael Scheer
*CMZ :  3.01/00 18/07/2013  11.34.23  by  Michael Scheer
*CMZ :  3.00/02 08/04/2013  14.49.02  by  Michael Scheer
*CMZ :  3.00/01 20/03/2013  14.29.33  by  Michael Scheer
*CMZ :  3.00/00 14/03/2013  10.24.03  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.70/11 22/02/2013  14.32.53  by  Michael Scheer
*CMZ :  2.70/09 15/01/2013  13.58.17  by  Michael Scheer
*CMZ :  2.70/08 14/01/2013  17.39.36  by  Michael Scheer
*CMZ :  2.70/07 14/01/2013  16.55.40  by  Michael Scheer
*CMZ :  2.70/06 03/01/2013  15.40.36  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  14.05.34  by  Michael Scheer
*CMZ :  2.70/04 21/12/2012  10.03.13  by  Michael Scheer
*CMZ :  2.70/01 12/12/2012  12.39.56  by  Michael Scheer
*CMZ :  2.69/02 05/11/2012  12.35.44  by  Michael Scheer
*CMZ :  2.69/00 30/10/2012  16.25.27  by  Michael Scheer
*CMZ :  2.68/05 18/10/2012  09.38.10  by  Michael Scheer
*CMZ :  2.68/03 27/08/2012  15.39.32  by  Michael Scheer
*CMZ :  2.68/02 01/08/2012  14.02.50  by  Michael Scheer
*CMZ :  2.68/01 29/05/2012  16.08.27  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  09.56.07  by  Michael Scheer
*CMZ :  2.67/06 24/05/2012  12.11.08  by  Michael Scheer
*CMZ :  2.67/05 16/05/2012  13.53.49  by  Michael Scheer
*CMZ :  2.67/04 15/05/2012  12.59.15  by  Michael Scheer
*CMZ :  2.67/02 08/05/2012  16.36.00  by  Michael Scheer
*CMZ :  2.67/00 16/02/2012  13.07.31  by  Michael Scheer
*CMZ :  2.66/22 22/11/2011  13.58.07  by  Michael Scheer
*CMZ :  2.66/20 22/11/2011  10.45.51  by  Michael Scheer
*CMZ :  2.66/17 23/11/2010  10.01.44  by  Michael Scheer
*CMZ :  2.66/16 22/11/2010  14.00.45  by  Michael Scheer
*CMZ :  2.66/13 15/07/2010  12.58.56  by  Michael Scheer
*CMZ :  2.66/12 20/05/2010  09.00.48  by  Michael Scheer
*CMZ :  2.66/09 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.66/07 10/03/2010  12.23.23  by  Michael Scheer
*CMZ :  2.66/06 27/11/2009  15.57.31  by  Michael Scheer
*CMZ :  2.66/04 24/11/2009  08.18.52  by  Michael Scheer
*CMZ :  2.66/03 16/11/2009  13.49.00  by  Michael Scheer
*CMZ :  2.65/03 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  2.65/02 29/09/2009  09.24.12  by  Michael Scheer
*CMZ :  2.64/01 14/09/2009  15.19.42  by  Michael Scheer
*CMZ :  2.64/00 18/08/2009  15.17.59  by  Michael Scheer
*CMZ :  2.63/05 12/08/2009  08.49.28  by  Michael Scheer
*CMZ :  2.63/03 15/04/2008  09.57.05  by  Michael Scheer
*CMZ :  2.63/02 13/03/2008  15.28.16  by  Michael Scheer
*CMZ :  2.63/00 10/01/2008  12.43.13  by  Michael Scheer
*CMZ :  2.62/02 16/07/2007  08.39.06  by  Michael Scheer
*CMZ :  2.61/05 11/04/2007  11.58.30  by  Michael Scheer
*CMZ :  2.61/02 26/03/2007  20.08.09  by  Michael Scheer
*CMZ :  2.60/00 26/01/2007  10.48.21  by  Michael Scheer
*CMZ :  2.59/01 24/01/2007  14.13.43  by  Michael Scheer
*CMZ :  2.58/00 16/01/2007  12.28.50  by  Michael Scheer
*CMZ :  2.57/05 13/12/2006  10.49.24  by  Michael Scheer
*CMZ :  2.57/00 22/11/2005  09.53.36  by  Michael Scheer
*CMZ :  2.56/02 21/10/2005  13.13.47  by  Michael Scheer
*CMZ :  2.56/00 17/10/2005  12.32.39  by  Michael Scheer
*CMZ :  2.55/00 10/08/2005  13.53.39  by  Michael Scheer
*CMZ :  2.54/07 16/06/2005  09.40.54  by  Michael Scheer
*CMZ :  2.54/06 02/06/2005  13.53.54  by  Michael Scheer
*CMZ :  2.54/05 02/06/2005  08.14.28  by  Michael Scheer
*CMZ :  2.54/01 07/03/2005  10.32.21  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  11.05.51  by  Michael Scheer
*CMZ :  2.52/16 07/01/2005  16.08.34  by  Michael Scheer
*CMZ :  2.52/15 05/01/2005  16.24.14  by  Michael Scheer
*CMZ :  2.52/13 16/12/2004  21.13.02  by  Michael Scheer
*CMZ :  2.52/10 08/12/2004  13.39.18  by  Michael Scheer
*CMZ :  2.52/09 29/10/2004  11.12.01  by  Michael Scheer
*CMZ :  2.52/05 16/08/2004  13.37.21  by  Michael Scheer
*CMZ :  2.52/00 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.51/02 22/06/2004  13.57.32  by  Michael Scheer
*CMZ :  2.51/01 16/06/2004  17.05.27  by  Michael Scheer
*CMZ :  2.51/00 26/05/2004  16.17.52  by  Michael Scheer
*CMZ :  2.50/02 30/04/2004  15.27.48  by  Michael Scheer
*CMZ :  2.50/00 29/04/2004  17.07.53  by  Michael Scheer
*CMZ :  2.49/00 19/03/2004  17.58.17  by  Michael Scheer
*CMZ :  2.48/04 16/03/2004  10.43.05  by  Michael Scheer
*CMZ :  2.48/03 03/03/2004  12.49.38  by  Michael Scheer
*CMZ :  2.47/23 17/02/2004  11.00.48  by  Michael Scheer
*CMZ :  2.47/18 27/11/2003  14.31.04  by  Michael Scheer
*CMZ :  2.47/15 08/08/2003  10.34.03  by  Michael Scheer
*CMZ :  2.47/14 07/08/2003  09.42.49  by  Michael Scheer
*CMZ :  2.47/12 03/07/2003  09.22.07  by  Michael Scheer
*CMZ :  2.47/10 28/05/2003  15.25.10  by  Michael Scheer
*CMZ :  2.47/09 27/05/2003  15.50.23  by  Michael Scheer
*CMZ :  2.47/08 16/05/2003  14.34.52  by  Michael Scheer
*CMZ :  2.47/07 14/04/2003  14.14.46  by  Michael Scheer
*CMZ :  2.47/06 28/03/2003  15.40.34  by  Michael Scheer
*CMZ :  2.47/04 13/03/2003  09.59.14  by  Michael Scheer
*CMZ :  2.47/03 12/03/2003  15.45.44  by  Michael Scheer
*CMZ :  2.44/01 11/12/2002  11.15.11  by  Michael Scheer
*CMZ :  2.44/00 08/11/2002  11.15.00  by  Michael Scheer
*CMZ :  2.41/13 02/09/2002  15.35.59  by  Michael Scheer
*CMZ :  2.41/07 15/07/2002  16.10.05  by  Michael Scheer
*CMZ :  2.41/06 10/05/2002  15.24.47  by  Michael Scheer
*CMZ :  2.41/03 21/03/2002  12.44.08  by  Michael Scheer
*CMZ :  2.41/02 21/03/2002  12.41.22  by  Michael Scheer
*CMZ :  2.41/00 20/03/2002  14.16.00  by  Michael Scheer
*CMZ :  2.40/03 20/03/2002  12.31.55  by  Michael Scheer
*CMZ :  2.38/00 13/12/2001  11.26.22  by  Michael Scheer
*CMZ :  2.37/06 07/12/2001  15.01.29  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.35/02 30/10/2001  17.13.56  by  Michael Scheer
*CMZ :  2.34/09 19/09/2001  13.39.52  by  Michael Scheer
*CMZ :  2.34/08 11/09/2001  14.21.00  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  10.25.20  by  Michael Scheer
*CMZ :  2.34/03 11/07/2001  11.18.43  by  Michael Scheer
*CMZ :  2.34/01 01/06/2001  15.26.15  by  Michael Scheer
*CMZ :  2.33/06 04/05/2001  13.56.33  by  Michael Scheer
*CMZ :  2.33/00 03/05/2001  10.35.09  by  Michael Scheer
*CMZ :  2.32/04 26/04/2001  12.17.53  by  Michael Scheer
*CMZ :  2.32/03 26/04/2001  11.11.52  by  Michael Scheer
*CMZ :  2.32/02 26/04/2001  11.09.09  by  Michael Scheer
*CMZ :  2.31/01 25/04/2001  15.12.03  by  Michael Scheer
*CMZ :  2.30/04 23/04/2001  12.32.14  by  Michael Scheer
*CMZ :  2.30/03 20/04/2001  16.29.29  by  Michael Scheer
*CMZ :  2.20/10 05/04/2001  16.02.13  by  Michael Scheer
*CMZ :  2.20/09 23/03/2001  11.10.39  by  Michael Scheer
*CMZ :  2.20/03 21/02/2001  14.28.56  by  Michael Scheer
*CMZ :  2.20/01 20/02/2001  14.28.03  by  Michael Scheer
*CMZ :  2.20/00 07/11/2000  18.38.35  by  Michael Scheer
*CMZ :  2.17/00 07/11/2000  18.36.28  by  Michael Scheer
*CMZ :  2.16/09 01/11/2000  19.18.54  by  Michael Scheer
*CMZ :  2.16/08 01/11/2000  18.46.41  by  Michael Scheer
*CMZ :  2.16/07 13/10/2000  12.33.36  by  Michael Scheer
*CMZ :  2.16/05 25/08/2000  16.07.46  by  Michael Scheer
*CMZ :  2.16/04 21/07/2000  14.48.52  by  Michael Scheer
*CMZ :  2.16/03 19/06/2000  12.19.35  by  Michael Scheer
*CMZ :  2.16/02 15/06/2000  17.28.05  by  Michael Scheer
*CMZ :  2.16/01 15/06/2000  17.27.10  by  Michael Scheer
*CMZ :  2.16/00 15/06/2000  12.08.02  by  Michael Scheer
*CMZ :  2.15/00 19/05/2000  11.05.28  by  Michael Scheer
*CMZ :  2.14/02 19/04/2000  17.14.40  by  Michael Scheer
*CMZ :  2.14/01 19/04/2000  13.54.26  by  Michael Scheer
*CMZ :  2.14/00 19/04/2000  11.58.09  by  Michael Scheer
*CMZ :  2.13/10 23/03/2000  13.06.35  by  Michael Scheer
*CMZ :  2.13/11 10/03/2000  15.07.30  by  Michael Scheer
*CMZ :  2.13/10 09/03/2000  17.39.34  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  18.08.34  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  17.10.43  by  Michael Scheer
*CMZ :  2.13/08 02/03/2000  12.13.35  by  Michael Scheer
*CMZ :  2.13/07 18/02/2000  12.32.29  by  Michael Scheer
*CMZ :  2.13/04 24/01/2000  17.59.24  by  Michael Scheer
*CMZ :  2.13/02 14/12/99  16.41.31  by  Michael Scheer
*CMZ :  2.13/00 26/10/99  15.40.04  by  Michael Scheer
*CMZ :  2.12/04 27/08/99  12.30.27  by  Michael Scheer
*CMZ :  2.12/03 06/08/99  15.36.20  by  Michael Scheer
*CMZ :  2.12/02 15/06/99  16.13.28  by  Michael Scheer
*CMZ :  2.12/01 14/06/99  15.34.53  by  Michael Scheer
*CMZ :  2.12/00 04/06/99  13.28.31  by  Michael Scheer
*CMZ :  2.11/01 12/05/99  12.19.46  by  Michael Scheer
*CMZ :  2.11/00 11/05/99  16.21.08  by  Michael Scheer
*CMZ :  2.10/02 07/05/99  12.23.41  by  Michael Scheer
*CMZ :  2.10/01 17/03/99  18.20.52  by  Michael Scheer
*CMZ :  2.02/00 15/02/99  10.20.15  by  Michael Scheer
*CMZ :  2.01/00 21/01/99  16.58.37  by  Michael Scheer
*CMZ :  2.00/03 13/01/99  10.57.51  by  Michael Scheer
*CMZ :  2.00/01 11/01/99  16.06.57  by  Michael Scheer
*CMZ :  2.00/00 11/01/99  16.04.55  by  Michael Scheer
*CMZ :  1.04/03 11/12/98  16.57.07  by  Michael Scheer
*CMZ :  1.04/02 11/12/98  11.35.47  by  Michael Scheer
*CMZ :  1.04/01 11/12/98  11.21.43  by  Michael Scheer
*CMZ :  1.04/00 11/12/98  10.45.26  by  Michael Scheer
*CMZ :  1.03/06 02/10/98  15.51.15  by  Michael Scheer
*CMZ :  1.03/05 27/04/98  13.57.17  by  Michael Scheer
*CMZ :  1.03/04 27/03/98  14.22.25  by  Michael Scheer
*CMZ :  1.03/02 23/02/98  14.31.16  by  Michael Scheer
*CMZ :  1.03/01 10/02/98  17.33.38  by  Michael Scheer
*CMZ :  1.03/00 16/01/98  14.55.02  by  Michael Scheer
*CMZ :  1.02/05 16/01/98  11.00.30  by  Michael Scheer
*CMZ :  1.02/04 16/01/98  10.59.38  by  Michael Scheer
*CMZ :  1.02/02 06/01/98  17.07.13  by  Michael Scheer
*CMZ :  1.02/00 06/01/98  14.56.08  by  Michael Scheer
*CMZ :  1.01/01 10/12/97  13.23.56  by  Michael Scheer
*CMZ :  1.01/00 04/12/97  15.59.21  by  Michael Scheer
*CMZ :  1.00/04 21/10/97  13.41.08  by  Michael Scheer
*CMZ :  1.00/03 20/10/97  15.20.55  by  Michael Scheer
*CMZ :  1.00/02 20/10/97  15.15.32  by  Michael Scheer
*CMZ :  1.00/00 29/09/97  17.11.38  by  Michael Scheer
*CMZ : 00.02/05 16/04/97  16.32.33  by  Michael Scheer
*CMZ : 00.02/04 25/02/97  17.37.37  by  Michael Scheer
*CMZ : 00.02/03 31/01/97  11.25.25  by  Michael Scheer
*CMZ : 00.02/02 15/01/97  13.21.25  by  Michael Scheer
*CMZ : 00.02/01 18/12/96  13.23.11  by  Michael Scheer
*CMZ : 00.01/12 07/10/96  13.32.57  by  Michael Scheer
*CMZ : 00.01/10 02/09/96  13.52.46  by  Michael Scheer
*CMZ : 00.01/09 28/05/96  12.08.51  by  Michael Scheer
*CMZ : 00.01/08 17/07/95  16.20.53  by  Michael Scheer
*CMZ : 00.01/07 23/03/95  11.36.42  by  Michael Scheer
*CMZ : 00.01/04 27/01/95  10.15.13  by  Michael Scheer
*CMZ : 00.01/03 28/11/94  12.04.13  by  Michael Scheer
*CMZ : 00.01/02 22/11/94  10.20.21  by  Michael Scheer
*CMZ : 00.01/01 23/06/94  13.25.42  by  Michael Scheer
*CMZ : 00.01/00 21/06/94  09.57.03  by  Michael Scheer
*CMZ : 00.00/07 25/05/94  17.37.44  by  Michael Scheer
*CMZ : 00.00/06 29/04/94  21.08.08  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  18.05.26  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.33  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE GFINIT(BETX0,BETY0,BETZ0,BETXF0,BETYF0,BETZF0,
     &                     DTIM,BSHIFT,GAMMA)
+seq,gplhint.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,WFOLDF90U.
+SEQ,TRACKF90U.
+SEQ,WBETAF90U.
+SEQ,BPOLYMAGF90U.
+SEQ,bwpolyederf90U.

      use omp_lib
      use ompmod
      use bunchmod
      use clustermod
      use f1k
      !use waveenv
      use fbtabzymod
      !use waveenv

      IMPLICIT NONE

+seq,datetime.
+SELF,IF=LINUX.
      EXTERNAL DCOSD,DSIND
      DOUBLE PRECISION  DCOSD,DSIND
+SELF.

      INTEGER IGFNUM,ICOMP,ISTORE,IAMBI,I,IELEM,ISTO,IROI,JWSECTMAGS,
     &  KSUM,lun,idum,lunsi,ieof,istat,iclusterold

      DOUBLE PRECISION BETX0,BETY0,BETZ0,ZP0,YP0,ZPF0,YPF0,
     &  BETXF0,BETYF0,BETZF0,BTAPV,BTAPH,dtshort,
     &  DTIM,BSHIFT,GAMMA,XJUST,YJUST,XSTARTO,XSTOPO

      DOUBLE PRECISION ZP,YP,VXINO,VYINO,VZINO,YSTARTO,ZSTARTO
     &  ,GAMMAL,gamma1,omegac,emom1,rho1,vxi,vyi,vzi,
     &  wlen1,rhv,park,b0eff

+SELF,IF=-NOCMPLX.
      COMPLEX*16 VPOLAN
+SELF,IF=NOCMPLX.
      DOUBLE PRECISION VPOLAN
+SELF.
      DOUBLE PRECISION VSTO

      DOUBLE PRECISION BETA,VN,V0,ENERGV
      DOUBLE PRECISION BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM,DUM
      DOUBLE PRECISION ENEGEV,TAUPOL0,TAUPOL0EP,BSTORE,BSTORE2,BSTORE2Z
      DOUBLE PRECISION BDIPL1G,POLFC1G,POLLV1G,TAUPL1G,EMINPOL
      DOUBLE PRECISION BDIPLEP,POLFCEP,ASTORE,XSTOPR
      DOUBLE PRECISION BSTOREY,BSTOREZ,ASTOREZ,ASTOREY
      DOUBLE PRECISION BY,RI,TANPHI,BANA,BPANA,BANAC,BPANAC,
     &  YCEN,ZCEN,YPCEN,ZPCEN

+SEQ,CMPARA.
+seq,pawcmn.
+SEQ,CONTRL.
+SEQ,B0SCGLOB.
+SEQ,MYFILES.
+SEQ,OPTIC.
+SEQ,BFELD.
+SEQ,mgsqc.
+SEQ,HALBACH.
+SEQ,HALBASY.
+SEQ,undugap.
+SEQ,FOURIER.
+SEQ,TRANPO.
+SEQ,DEPOLA.
+SEQ,WLSOPT.
+SEQ,TRACK.
+SEQ,BETAWLS.
+seq,wbetaf90.
+SEQ,PHYCON.
+SEQ,COLLI.
+seq,reargf90.
+seq,sourcef90.
+SEQ,SPECT.
+SEq,wfoldf90.
+SEq,observf90.
+SEQ,FREQS.
+SEQ,UCROSS.
+SEQ,ELLIP.
+SEQ,ELLANA.
+SEQ,WBTAB.
+SEQ,USERVAR.
+SEQ,KLOTZ.
+SEQ,MODULATOR.
+SEQ,BMAP.
+SEQ,BAMWLS.
+SEQ,BPOLY3D.
+SEQ,BPOLY2DH.
+SEQ,BPHARM.
+SEQ,BPOLY3DG.
+SEQ,BHELM.
+SEQ,TRALIN.
+SEQ,PHASETRACK.
+SEQ,SPECDIP.
+SEQ,BFORCE.
+SEq,phasef90.
+SEQ,AMPLI.
+SEQ,BERROR.
+SEQ,CMZSEL.
+SEQ,GENESIS.
+SEQ,TRACK0.
+seq,primkin.
+seq,efield.
+seq,photon.
c+seq,gseed,if=grndm.
+seq,random.
+seq,ustep.
+seq,whbook.
+seq,undumagc.
+seq,waveenv.

      integer irootmode
      character(32) c32

+SELF,IF=-newwave.
      stop '**** +self,if=newwave ist erforderlich! ***'
+SELF.
+SELF,IF=-f90.
      stop '**** +self,if=f90 ist erforderlich! ***'
+SELF.
+SELF,IF=NOCMPLX.
      stop '**** +self,if=nocmplx ist obsolet! ***'
+SELF.

C--- LOGICAL UNITS
      LUNGFI=15
      LUNGFO=16
      FILEI='wave.in'
      FILEGFO='wave.out'
+SELF,IF=HPUX,TRUE64.
      call system('rm wave.out 2>/dev/null')
      CALL UNCOMNAMELIST
      FILEI='wave.in.linux'
      FILEGFO='wave.out'
+SELF,IF=VMS.
      FILEI='WI:WAVE.IN'
      FILEGFO='WO:WAVE.OUT'
+SELF.

C--- CHECK CMZ-SELECTIONS{

      IXAMAG_I=0
      ICMZF90=1

+SELF,IF=NEWWAVE.
      ICMZNEWWAVE=1
+SELF.

+SELF,IF=F90.
      ICMZNOCMPLX=1
+SELF.

+SELF,IF=VMS.
      ICMZVMS=1
+SELF,IF=-VMS.
      ICMZVMS=0
+SELF.

+SELF,IF=HPUX.
      ICMZHPUX=1
+SELF,IF=-HPUX.
      ICMZHPUX=0
+SELF.

+SELF,IF=TRUE64.
        ICMZTRUE64=1
+SELF,IF=-TRUE64.
        ICMZTRUE64=0
+SELF.

+SELF,IF=LINUX.
      ICMZLINUX=1
+SELF,IF=-LINUX.
      ICMZLINUX=0
+SELF.

+SELF,IF=WINDOWS.
      ICMZWINDOWS=1
+SELF,IF=-WINDOWS.
      ICMZWINDOWS=0
+SELF.

        IF (ABS(ICMZVMS)+ABS(ICMZLINUX)+ABS(ICMZHPUX)+ABS(ICMZTRUE64)+
     &      ABS(ICMZWINDOWS).NE.1) THEN
          WRITE(6,*)'*** BAD CMZ-SELECTION VMS, LINUX OR WINDOWS ***'
          STOP
      ENDIF

+seq,setf1k.

C--- CHECK CMZ-SELECTIONS}

C     CALL UTIL_TEST_BATCH(IBATCH)

      fouentr=-9999.
      fouexit=-9999.
      scbfour=-9999.
      xshbfour=-9999.

      XINTER=-9999.
      xbetfun=9999.
      IW_BLEN=0
      IW_BLENF=0
      IW_CIRC=0

      BMAXGL2=-1.0D30

C--- PHYSICAL CONSTANTS

+seq,phycon1.

+SELF,IF=LINUX,WINDOWS.
      XMX=-1.0D30
      YMX=-1.0D30
      ZMX=-1.0D30
      BXMX=-1.0D30
      BYMX=-1.0D30
      BZMX=-1.0D30
      PHIMX=-1.0D30
      XMN=1.0D30
      YMN=1.0D30
      ZMN=1.0D30
      BXMN=1.0D30
      BYMN=1.0D30
      BZMN=1.0D0
      PHIMN=1.0D30
+SELF.

C--- STORE DIMENSION-PARAMETERS

      NDPOL=NDPOLP
      NDOBSVZ=NDOBSVZP
      NDOBSVY=NDOBSVYP
      NDMASHZ=NDMASHZP
      NDMASHY=NDMASHYP
+self,if=-mhbook.
      NDPAWC=NDPAWCP
+self.
      NDARGU=NDARGUP
      NDFREQ=NDFREQP
      NDOBSV=NDOBSVP
      NWMAX=NWMAXP
      NBETA=NBETAP
C5.10.95      NBDIM=NBDIMP
      LIDIM=LIDIMP
      NOMDIM=NOMDIMP
      IBFDIM4=IBFDIM4P
      IBFDIM2=IBFDIM2P
      NXPAN=NXPANP
      NYPAN=NYPANP
      NBTAB=NBTABP
      NDWSOU=NDWSOUP
      NGCOEF=NGCOEFP
      NDSPAR=NDSPARP

      IF(NDOBSVZ*NDOBSVY.NE.NDOBSV) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'     DIMENSION DECLARATIONS NOT CONSISTENT'
        WRITE(LUNGFO,*)'     NDOBSVP MUST BE EQUAL TO NDOBSVZP*NDOBSVYP'
        WRITE(LUNGFO,*)'     CHANGE PARAMETER IN CMPARA.CMN'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'     *** ERROR IN GFINIT ***'
        WRITE(6,*)'     DIMENSION DECLARATIONS NOT CONSISTENT'
        WRITE(6,*)'     NDOBSVP MUST BE EQUAL TO NDOBSVZP*NDOBSVYP'
        WRITE(6,*)'     CHANGE PARAMETER IN CMPARA.'
        WRITE(6,*)
        STOP
      ENDIF

C--- READ PARAMETER AND CONTRL-FLAGS FROM NAMELISTS

      iclusterold=icluster

      userchar=''
      user=0.0d0

      OPEN (UNIT=LUNGFI,FILE=FILEI,STATUS='OLD')

      READ(LUNGFI, CONTRL )
+SELF,if=grndm.
c      READ(LUNGFI,gseedn)
+SELF.,if=grndm.
      READ(LUNGFI,randomn)
      READ(LUNGFI,cluster)
c     WRITE(6,*)'READING NAMELIST B0SCGLOBN'
      READ(LUNGFI, B0SCGLOBN )
      IF(IBHELM.NE.0 ) WRITE(6,*)'READING NAMELIST BBHELM'
      IF(IBHELM.NE.0 ) READ(LUNGFI, BBHELM )
c     WRITE(6,*)'READING NAMELIST BBFELD'
      READ(LUNGFI, BBFELD )
c     WRITE(6,*)'READING NAMELIST HALBACH'
      READ(LUNGFI, HALBACH )
c     WRITE(6,*)'READING NAMELIST HALBASY'
      READ(LUNGFI, HALBASY )
      READ(LUNGFI, undugapn)
c     WRITE(6,*)'READING NAMELIST UCROSSN'
      READ(LUNGFI, UCROSSN )
c     WRITE(6,*)'READING NAMELIST ELLIPN'
      READ(LUNGFI, ELLIPN )
c     WRITE(6,*)'READING NAMELIST ELLANAN'
      READ(LUNGFI, ELLANAN )
c     WRITE(6,*)'READING NAMELIST FOURIER'
      READ(LUNGFI, FOURIER )
      if (ifourbtabzy.ne.0) READ(LUNGFI, fbtabzyn )
c     WRITE(6,*)'READING NAMELIST DEPOLA'
      READ(LUNGFI, DEPOLA )
c     WRITE(6,*)'READING NAMELIST WLSOPTN'
      READ(LUNGFI, WLSOPTN )
c     WRITE(6,*)'READING NAMELIST MYFILES'
      READ(LUNGFI, MYFILES )
c     WRITE(6,*)'READING NAMELIST TRALINN'
      READ(LUNGFI, TRALINN )
c     WRITE(6,*)'READING NAMELIST PHASETRACKN'
      READ(LUNGFI, PHASETRACKN )
c     WRITE(6,*)'READING NAMELIST OPTIK'
      READ(LUNGFI, OPTIK )
c     WRITE(6,*)'READING NAMELIST TRANPON'
      READ(LUNGFI, TRANPON )
c     WRITE(6,*)'READING NAMELIST COLLIN'
      READ(LUNGFI, COLLIN )
c     WRITE(6,*)'READING NAMELIST SPECTN'
      READ(LUNGFI, SPECTN )
c     WRITE(6,*)'READING NAMELIST WFOLDN'
      READ(LUNGFI, WFOLDN )
      READ(LUNGFI,BUNCHN)
c     WRITE(6,*)'READING NAMELIST PINHOLE'
      READ(LUNGFI, PINHOLE )
c     WRITE(6,*)'READING NAMELIST FREQN'
      READ(LUNGFI, FREQN )
c     WRITE(6,*)'READING NAMELIST WBTABN'
      READ(LUNGFI, WBTABN )
c     WRITE(6,*)'READING NAMELIST RECN'
      READ(LUNGFI, RECN )
c     WRITE(6,*)'READING NAMELIST MODUN'
      READ(LUNGFI, MODUN )
c      IF (kbundumag.ne.0) THEN
        READ(LUNGFI,unduhybridn)
        READ(LUNGFI,undumagn)
        kbundumag_c=kbundumag
        kbunduverb_c=kbunduverb
        kbundumap_c=kbundumap
c      ENDIF
      IF (KBPOLYMAG.GT.0) THEN
c        WRITE(6,*)'READING NAMELIST POLYMAGN'
        READ(LUNGFI,POLYMAGN)
      ENDIF
c     WRITE(6,*)'READING NAMELIST BMAPN'
      READ(LUNGFI, BMAPN )
c     WRITE(6,*)'READING NAMELIST BAMWLSN'
      IF (KBAMWLS.NE.0) READ(LUNGFI, BAMWLSN )
c     WRITE(6,*)'READING NAMELIST BPOLY3DN'
      READ(LUNGFI, BPOLY3DN )
c     WRITE(6,*)'READING NAMELIST BPOLY2DHN'
      READ(LUNGFI, BPOLY2DHN )
c     WRITE(6,*)'READING NAMELIST BPHARMN'
      READ(LUNGFI, BPHARMN )
c     WRITE(6,*)'READING NAMELIST BGRIDN'
      READ(LUNGFI, BGRIDN )
c     WRITE(6,*)'READING NAMELIST SPECDIPN'
      READ(LUNGFI, SPECDIPN )

C--- READ AND WRITE CURRENT NUMBER

      OPEN(UNIT=LUNCOD,FILE=FILECOD,STATUS='OLD',FORM='FORMATTED',
     &       ERR=99)
          READ(LUNCOD,*,ERR=99)IGFNUM

99    IGFNUM=IGFNUM+1

      CLOSE(LUNCOD)
+SELF,IF=VMS.
      OPEN(UNIT=LUNCOD,FILE=FILECOD,STATUS='NEW',FORM='FORMATTED')
+SELF,IF=LINUX,WINDOWS,HPUX,TRUE64.
      OPEN(UNIT=LUNCOD,FILE=FILECOD,status='unknown',FORM='FORMATTED')
      REWIND(LUNCOD)
+SELF.
      WRITE(LUNCOD,*)IGFNUM
      ICODE=IGFNUM
C          IF(IGFLOAT.NE.0) ICODE=-ICODE
      CLOSE(LUNCOD)

C--- OPEN OUTPUT-FILE

      call util_file_delete(trim(filegfo),istat)
      OPEN (UNIT=LUNGFO,FILE=FILEGFO)

      CALL ZEIT(LUNGFO)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'          *********************************************'
      WRITE(LUNGFO,*)'          *          PROGRAM WAVE                     *'
      WRITE(LUNGFO,*)'          *                                           *'
      WRITE(LUNGFO,*)
+SEQ,WVERSION.
      WRITE(LUNGFO,*)'          *                                           *'
      WRITE(LUNGFO,*)'          *          Michael Scheer                   *'
      WRITE(LUNGFO,*)'          *              BESSY                        *'
      WRITE(LUNGFO,*)'          *********************************************'
      WRITE(LUNGFO,*)

      write(lungfo,*)
      write(lungfo,*)"     Compiler-Version: ",trim(chcompiler)
      write(lungfo,*)"     Hostname: ",trim(chhostname)
      write(lungfo,*)"     Working directory: ",trim(chcwd)
      write(lungfo,*)

      WRITE(LUNGFO,*)'     USER COMMENT:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     ',CODE
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     CURRENT NUMBER:',ICODE
      WRITE(LUNGFO,*)


      WRITE(6,*)
      WRITE(6,*)
      WRITE(6,*)'          USER COMMENT:'
      WRITE(6,*)
      WRITE(6,*)'          ',CODE
      WRITE(6,*)
      WRITE(6,*)'          CURRENT NUMBER:',ICODE
      WRITE(6,*)

      WRITE(LUNGFO,*)

      icluster=iclusterold

      if (ibunch.ne.0) then
        if (iundulator.ne.2) then
          mthreads=0
        endif
        if (nbunch.le.0) nbunch=1
        if (neinbunch.le.0) neinbunch=1
      endif

      if (iemit.ne.0.or.ibunch.ne.0) imagspln=0

C--- USER MAY OVERWRITE HERE VARIABLES OF NAMELISTS

      mmedgey=0 !3.4.2019, to avoid trouble with OMP
      mmedgez=0

      IF (IUNAME.NE.0) THEN
        CALL UNAME
        IF (IABEND.EQ.5) goto 9999
      ENDIF

      if (kbrec.ne.0.and.scaladd.eq.0.0d0.and.scalkl.eq.0.0d0
     &    .and.irecmodu.eq.0.and.irecu.eq.0) then
        irecu=1
      endif

+self,if=xxnoroot.
      if (iroothdf5.ne.0.or.iroottrees.ne.0) then
        print*
        write(6,*)'*** Warning in gfinit:'
        print*,'CERN package ROOT is not available'
        write(6,*)'for this version of WAVE, use ROOT-macro mhbook_to_root.C '
        print*,'to convert WAVE.mhb etc..'
        iroothdf5=0
        iroottrees=0
      endif
+self.
      if (nocern.ne.0) iroottrees=0
+self,if=-noroot.
      if (iroothdf5.ne.0.and.iroottrees.eq.0) iroottrees=-1
      if (ihisascii.ne.0.and.iroottrees.lt.0) then
        iroottrees=1
        write(6,*)''
        write(6,*)'*** WARNING: IROOTREES SET TO 1, DUE TO IHISASCII'
        write(6,*)''
        write(LUNGFO,*)''
        write(LUNGFO,*)'*** WARNING: IROOTREES SET TO 1, DUE TO IHISASCII'
        write(LUNGFO,*)''
      endif

      irootmode=0
      if (iroottrees.ne.0) call rootini(irootmode)
+self.

      kefield=iefield

      IF (BMOVECUT.LE.0.0D0) BMOVECUT=1.0D-6

      IF (IBFORCE.NE.0) THEN
+SELF,IF=LINUX,WINDOWS.
c     WRITE(6,*)'READING NAMELIST BFORCN'
+SELF.
        READ(LUNGFI,BFORCN)
      ENDIF

      IF (MPINZ.LE.0) MPINZ=1
      IF (MPINY.LE.0) MPINY=1

      IF (IF1DIM.NE.0) THEN
        IF1DIM=1
      ENDIF

      IF (IPHASE.NE.0) THEN
        DO IELEM=1,NPHELEMP
          PHELEM(1,1,IELEM)=1.0D0
          PHELEM(2,2,IELEM)=1.0D0
          PHELEM(3,3,IELEM)=1.0D0
          PHELEM(4,4,IELEM)=1.0D0
          PHELEM(5,1,IELEM)=-1.0D30
          PHELEM(5,2,IELEM)=+1.0D30
          PHELEM(5,3,IELEM)=-1.0D30
          PHELEM(5,4,IELEM)=+1.0D30
        ENDDO
+SELF,IF=LINUX,WINDOWS.
c     WRITE(6,*)'READING NAMELIST PHASEN'
+SELF.
        READ(LUNGFI,PHASEN)
      ENDIF

      if (ibunch.ne.0.and.neinbunch.gt.1.and.icluster.gt.0) then
        if (neinbunch.ne.(neinbunch/nwgood)*nwgood) then
          write(lungfo,*)"Warning in GFINIT: NEINBUNCH changed to fit number of WAVE instances ***"
          neinbunch=(neinbunch/nwgood)*nwgood
          write(lungfo,*)"New value:", neinbunch
          print*,"Warning in GFINIT: NEINBUNCH changed to fit number of WAVE instances ***"
          neinbunch=(neinbunch/nwgood)*nwgood
          print*,"New value:", neinbunch
        endif
      endif

      if (neinbunch.gt.0.and.bunchcharge.eq.-9999.)
     &  bunchcharge=echarge1*neinbunch

      if (ibunch.eq.0) then
        iubunch=0
        neinbunch=0
        nbunch=0
      else
        if (ispecdip.ne.0) then
          print*,"*** Error: ISPECDIP is not allowed for IBUNCH option ***"
          iabend=11
          goto 9999
        endif
      endif

      nbuncho=nbunch
      neinbuncho=neinbunch

      IF (KAMPLI.NE.0.or.iundulator.eq.2) THEN
        READ(LUNGFI,PHASEREPN)
        if (ibunch.ne.0.and.nbunch.ne.1.and.neinbunch.ne.1) then
          write(lungfo,*)'*** Error in GFINIT: For IUNDULATOR=2 or KAMPLI.ne.0, one of NBUNCH or NEINBUNCH must be one ***'
          stop '*** Error in GFINIT: For IUNDULATOR=2 or KAMPLI.ne.0, one of NBUNCH or NEINBUNCH must be one ***'
        endif
        if (noespreadph.ne.0) phrespread=0.0d0
        if (noemitph.ne.0) then
          phremith=0.0d0
          phremitv=0.0d0
        endif
      ENDIF

c      IF (IAMPLI.NE.0.or.ibunch.ne.0.or.iundulator.eq.2) THEN
        READ(LUNGFI,AMPLIN)
c        IF (IAMPLI.LT.0) IAMPSKIP=0
c      ENDIF

+SELF,IF=LINUX,WINDOWS.
c     WRITE(6,*)'READING NAMELIST ROIN'
+SELF.
      READ(LUNGFI,ROIN)

+SELF,IF=LINUX,WINDOWS.
c     WRITE(6,*)'READING NAMELIST BERRORN'
+SELF.
      READ(LUNGFI, BERRORN )
      ihphotons=0
      if (ieneloss.lt.0) read(lungfi,photonn)
+SELF,IF=LINUX,WINDOWS.
c     WRITE(6,*)'READING NAMELIST USERN'
+SELF.
      READ(LUNGFI,USERN)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     USER NAMELIST:'
      WRITE(LUNGFO,*)
      DO I=1,1000
        write(c32,*) i
        IF (USER(I).NE.0.0d0) THEN
          WRITE(LUNGFO,*)'     USER('//trim(adjustl(c32))//'): ',USER(I)
        ENDIF
      ENDDO
      WRITE(LUNGFO,*)
      DO I=1,1000
        write(c32,*) i
        IF (USERCHAR(I).NE.'') THEN
          WRITE(LUNGFO,*)'     USERCHAR('//trim(adjustl(c32))//'): ',USERCHAR(I)
        ENDIF
      ENDDO
      WRITE(LUNGFO,*)
+SELF,IF=LINUX,WINDOWS.
      WRITE(6,*)
      WRITE(6,*)
      WRITE(6,*)
+SELF.

C      CLOSE (LUNGFI)

      if (irbtabxyz.ne.0) then
        irbtab=0
        irbtabzy=0
      else if (irbtabzy.ne.0) then
        irbtab=0
      endif

      IF (XABSORB   .EQ.9999.) XABSORB=XWALLE
      IF (ZABSORB(1).EQ.9999.) ZABSORB(1)=WALL(1)
      IF (ZABSORB(2).EQ.9999.) ZABSORB(2)=WALL(2)

C ALL MULTIPLICATIONS WITH REFLEC ARE WRONG, SO WE CORRECT IT HERE
C (15. MAI 2004)

      DO I=1,3
        REFLEC(I)=CONJG(REFLEC(I))
      ENDDO

      IF (IWBMAP.EQ.-1) IHBPOLY3D=1
      IF (IWBMAP.EQ.-1.AND.IWBPOLY2DH.NE.0) IHBPOLY2DH=1
      IF (IWBMAP.EQ.-1.AND.IWBPOLY2DH.NE.0) IHBPHARM=1

      CALL date_and_time(dtday,dttime,dtzone,idatetime)

      OPEN(UNIT=99,FILE='wave_run.log',status='unknown',access='append')
      WRITE(99,*)icode,' ',dtday,' ',dttime
      close(99)

      if (iampseed.eq.-9999) iampseed=icode

      IF (ABS(KBGENESIS).EQ.2) THEN
        OPEN(UNIT=LUNGENI,FILE='genesis.start',STATUS='OLD')
        READ(LUNGENI,*)XSTART,DMYGAMMA,DUM,ZSTART,YSTART,VZIN,VYIN
        VXIN=1.0D0
        VYIN=VYIN/DMYGAMMA
        VZIN=VZIN/DMYGAMMA
        DMYENERGY=DMYGAMMA*EMASSG1
        CLOSE(LUNGENI)
      ENDIF

      if (abs(xstart).ne.9999.0d0.and.xstop.ne.9999.0d0
     &    .and.xstart.ge.xstop-1.0d0/myinum) then
        write(LUNGFO,*)' '
        write(LUNGFO,*)'*** Error in GFINIT: XSTART and XSTOP are not compatible.'
        write(LUNGFO,*)'Decrease XSTART or nncrease MYINUM or XSTOP!'
        write(LUNGFO,*)' '
        write(6,*)' '
        write(6,*)'*** Error in GFINIT: XSTART and XSTOP are not compatible.'
        write(6,*)'Decrease XSTART or nncrease MYINUM or XSTOP!'
        write(6,*)' '
        STOP '*** PROGRAM WAVE ABORTED ***'
      endif

      DMYGAMMA=DMYENERGY/EMASSG1

      if (ibunch.ne.0.and.ispec.eq.0) then
        write(6,*)' '
        write(6,*)'*** WARNING: ISPEC SET DUE TO IBUNCH AND IUBUNCH'
        write(6,*)' '
        write(lungfo,*)' '
        write(lungfo,*)'*** WARNING: ISPEC SET DUE TO IBUNCH AND IUBUNCH'
        write(lungfo,*)' '
        ispec=1
      endif

      if (ibunch.ne.0.and.iubunch.eq.3) then
        open(unit=21,file='wave_phasespace.dat',status='old')
        call util_skip_comment_end(21,ieof)
        read(21,*)dmygamma,bunchx,xstart,ystart,zstart,yp0,zp0
        close(21)
        dmyenergy=dmygamma*emassg1
        vxin=1.0d0
        vyin=yp0
        vzin=zp0
        xinter=-9999.0d0
c        write(6,*)' '
c        write(6,*)'*** WARNING: IBUNCH AND IUBUNCH HAVE TRIGGERED OVERWRITING'
c        write(6,*)'*** WARNING: OF XSTART ETC.'
c        write(6,*)' '
        write(lungfo,*)' '
        write(lungfo,*)'*** WARNING: IBUNCH AND IUBUNCH HAVE TRIGGERED OVERWRITING'
        write(lungfo,*)'*** WARNING: OF XSTART ETC.'
        write(lungfo,*)' '
      endif

      dmyenergyP=DMYENERGY
      dmygammaP=DMYGAMMA
      DMYBETA=DSQRT((1.0D0-1.0D0/DMYGAMMA)*(1.0D0+1.0D0/DMYGAMMA))
      dmybetaP=DMYBETA
      gammaustep=dmygamma

C--- MODES

      IF (IUNDULATOR*IWIGGLER.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'BOTH FLAGS IUNDULATOR AND IWIGGLER ARE SET'
        WRITE(LUNGFO,*)'ONLY ONE IS ALLOWED'
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'BOTH FLAGS IUNDULATOR AND IWIGGLER ARE SET'
        WRITE(6,*)'ONLY ONE IS ALLOWED'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IWIGGLER.NE.0) THEN
        IEXPERT=0
      ENDIF

C{--- CONVERT B-FIELD TO MAP

      IF (IWBMAP.EQ.5) THEN
        CALL WBMAP5
        IABEND=7
        goto 9999
      ENDIF
C}--- CONVERT B-FIELD TO MAP

      if (iundulator.eq.2) then
        ispec=1
c        ifreq2p=3
      endif

      if (iwiggler.ne.0.or.iundulator.ne.0) then
        istokes=1
      endif

c      if (kampli.ne.0.or.iundulator.eq.2) then
c        CALL BELLIP(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
c        phb0h=B0ELLIPh
c        phb0v=B0ELLIPv
c        phperl=xlellip
c        phshift=ellshft*phperl
c      endif

      if (iundulator.eq.2) then

c        iundulator=0
        kampli=nint(perellip)
        xcenell=0.0d0
c        perellip=5.0d0

        if (xstart.eq.9999.0d0.and.xinter.eq.-9999.0d0
     &      .and.xstop.eq.9999.0d0) then
c          xstart=-(perellip*xlellip+ellshft*xlellip)/2.0d0+xcenell
          xstart=-(5.0d0*xlellip+ellshft*xlellip)/2.0d0+xcenell
        endif

        park=parkell

        if (nharmell.ne.0.and.harmell.ne.0.0d0) then
          if (harmell.eq.-9999.0d0) then
c            if (ifreq2p.eq.1) then
c              harmell=freqlow
c            else
              harmell=(freqlow+freqhig)/2.0d0
c            endif
          endif
          if (harmell.lt.0.0d0) then
            harmell=-wtoe1/harmell
          endif
          WLEN1=wtoe1/abs(harmell/nharmell)
          park=2.0d0*(wlen1/(xlellip*1.0D9/2.0d0/DMYGAMMA**2)-1.0d0)
          if (park.lt.0.0d0) then
            write(6,*)
     &        '*** Error in GFINIT:'
            write(6,*)
     &        'Inconsistent values of NHARMELL, HARMELL, and XLELLIP'
            write(6,*)' '
            write(lungfo,*)
     &        '*** Error in GFINIT:'
            write(lungfo,*)
     &        'Inconsistent values of NHARMELL, HARMELL, and XELLIP'
            write(lungfo,*)' '
            stop
          endif
          park=sqrt(park)
          parkell=park
        endif

        IF (parkell.NE.0.0) THEN
          B0EFF=parkell/(echarge1*XLELLIP/(2.*PI1*EMASSKG1*CLIGHT1))
          if (b0elliph.eq.0.0d0.and.b0ellipv.ne.0d0) then
            b0ellipv=b0ellipv/abs(b0ellipv)*b0eff
          else if (b0ellipv.eq.0.0d0.and.b0elliph.ne.0d0) then
            b0elliph=b0elliph/abs(b0elliph)*b0eff
          else
            rhv=b0elliph/b0ellipv
            b0elliph=b0eff/sqrt(1.0d0+1.0d0/rhv**2)*b0elliph/abs(b0elliph)
            b0ellipv=b0elliph/rhv
          endif
        endif

        if (phrb0h.eq.9999.0d0) phrb0h=B0ELLIPh
        if (phrb0v.eq.9999.0d0) phrb0v=B0ELLIPV
        if (phrperl.eq.9999.0d0) phrperl=xlellip
        if (phrshift.eq.9999.0d0) phrshift=ellshft*phrperl

        WGWINFC = 45.
        nlpoi=0
        ibsuper=0
        KBEXTERN=0
        KBAMWLS=0
        KHALBA=0
        KBFELD=0
        KHALBASY=0
        KUNDUGAP=0
        IRFILF=0
        IRFILB=0
        IRBTAB=0
        IFOURBTABZY=0
        IRBTABZY=0
        IRBTABXYZ=0
        KUCROSS=0
        KELLANA=0
        KBREC=0
        kbundumag=0
        kbundumag_c=kbundumag
        KBPOLYMAG=0
        KBGENESIS=0
        KBPOLYH=0
        KBPOLY3D=0
        KBPOLY2DH=0
        KBPHARM=0
        IRFILP=0
        IRFILB0=0
        IBHELM=0
        IMAGSPLN=0
        KMAGSEQ=0
        IWSECTMAGS=0
        ibmasksp=0
        ibsym=0
        ibsymy=0
        ibsymz=0
        bygoff=0.0d0
        bzgoff=0.0d0
        jbmask=0
        ibmask=0
        B0SCGLOBY=1.0
        B0SCGLOBz=1.0
        xbshift=0.0d0
        hshift=0.0d0
        vshift=0.0d0
        xrotd=0.0d0
        IPERIODG=0.0d0
        BTAPERV=0.0d0
        BTAPERH=0.0d0
        XTAPER=0.0d0
        iampli=0

        kellip=1

        if (xstart.eq.9999.0d0.and.xinter.eq.-9999.0d0
     &      .and.xstop.eq.9999.0d0) then
          xstop=phrperl/2.0d0
        endif
        ieneloss=0
        !imagspln=0

        gamma=dmygamma

        DTIM=1.0D0/(CLIGHT1*dmybetap*MYINUM)   !TIME INTERVALLS FOR TRACKING
        BSHIFT=0.5D0          !DONT WORRY

        DS0=CLIGHT1*DTIM
        GAMMA=DMYGAMMA
        ENERGV=GAMMA*EMASSE1
        GMOM=EMASSG1*DSQRT((GAMMA-1.0d0)*(GAMMA+1.0d0))
        EMOM=EMASSE1*DSQRT((GAMMA-1.0d0)*(GAMMA+1.0d0))
        DBRHO=ICHARGE*EMOM/CLIGHT1
        BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
        DMYBETA=BETA
        V0=CLIGHT1*BETA

        VN=1.0D0/DSQRT(VXIN**2+VYIN**2+VZIN**2)
        VXIN=VXIN*VN*v0
        VYIN=VYIN*VN*v0
        VZIN=VZIN*VN*v0

        TAUPOL01G=POL2CON1*UMFANG*RDIPOL**2/1.**5

        ecdipev1=3.0d0/2.0d0*hbarev1*(clight1/emasse1)**2/emasse1*1.0d18

        gamma1=1.0d0/emassg1
        emom1=emasse1*dsqrt((gamma1-1.0d0)*(gamma1+1.0d0))
        rho1=emom1/clight1
        omegac=1.5d0*gamma1**3*clight1/rho1

        CROTD=DCOSD(XROTD)
        SROTD=DSIND(XROTD)

        IF (XINTER.NE.XSTART.AND.XINTER.NE.-9999.) THEN

          YSTARTO=YSTART
          ZSTARTO=ZSTART

          VXINO=VXIN
          VYINO=VYIN
          VZINO=VZIN

          BETX0=VXIN*BETA
          BETY0=VYIN*BETA
          BETZ0=VZIN*BETA

          X0=XSTART
          Y0=YSTART
          Z0=ZSTART

          VX0=VXIN
          VY0=VYIN
          VZ0=VZIN

          IF (XINTER.GT.XSTART) THEN

            BYDUM=B0SCGLOB
            B0SCGLOB=-B0SCGLOB
            btaperv=-btaperv
            btaperh=-btaperh

            CALL TRACKSHORT(ISNORDER,XINTER,Y0,Z0,-VX0,-VY0,-VZ0,
     &        XSTART,0.0D0,0.0D0,-1.0D0,0.0D0,0.0D0,
     &        XF0,YF0,ZF0,dtshort,VXF0,VYF0,VZF0,DTIM,BSHIFT,GAMMA,BMOVECUT,
     &        IUSTEP,IENELOSS,GAMMAL)

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Result of back-tracking due to XINTER:'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     x:',XF0
            WRITE(LUNGFO,*)'     y:',YF0
            WRITE(LUNGFO,*)'     z:',ZF0
            WRITE(LUNGFO,*)'     vx:',-VXF0
            WRITE(LUNGFO,*)'     vy:',-VYF0
            WRITE(LUNGFO,*)'     vz:',-VZF0
            WRITE(LUNGFO,*)'     yp:',VYF0/VXF0
            WRITE(LUNGFO,*)'     zp:',VZF0/VXF0
            WRITE(LUNGFO,*)

            B0SCGLOB=BYDUM
            btaperv=-btaperv
            btaperh=-btaperh
            XSTART=XF0
            YSTART=YF0
            ZSTART=ZF0
            VXIN=-VXF0
            VYIN=-VYF0
            VZIN=-VZF0

            GAMMA=GAMMA-GAMMAL !We gain energy here, and gammal is negative!
            DMYGAMMA=GAMMA
            DMYENERGY=GAMMA*EMASSG1

            ENERGV=GAMMA*EMASSE1
            GMOM=EMASSG1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
            EMOM=EMASSE1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
            DBRHO=ICHARGE*EMOM/CLIGHT1
            BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
            DMYBETA=BETA
            V0=CLIGHT1*BETA

          ELSE   !XINTER.GT.XSTART

            CALL TRACKSHORT(ISNORDER,XINTER,Y0,Z0,VX0,VY0,VZ0,
     &        XSTART,0.0D0,0.0D0,1.0D0,0.0D0,0.0D0,
     &        XF0,YF0,ZF0,dtshort,VXF0,VYF0,VZF0,DTIM,BSHIFT,GAMMA,BMOVECUT,
     &        IUSTEP,IENELOSS,GAMMAL)

            XSTART=XF0
            YSTART=YF0
            ZSTART=ZF0
            VXIN=VXF0
            VYIN=VYF0
            VZIN=VZF0

            GAMMA=GAMMA+GAMMAL !We lose energy here!
            DMYGAMMA=GAMMA
            DMYENERGY=GAMMA*EMASSG1

            ENERGV=GAMMA*EMASSE1
            GMOM=EMASSG1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
            EMOM=EMASSE1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
            DBRHO=ICHARGE*EMOM/CLIGHT1
            BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
            DMYBETA=BETA
            V0=CLIGHT1*BETA

          ENDIF  !XINTER.GT.XSTART

        ENDIF !(XINTER.NE.-9999.)

        xinter=-9999.0d0

      endif

      IF (IUNDULATOR.NE.0) THEN

        IEXPERT=0
        ihtrackm=0

        if (ibunch.eq.0) then

+self,if=20220316.
          IF ((IWBMAP.NE.0.OR.IWBTAB.NE.0.OR.IBFORCE.NE.0.OR.IOPTIC.NE.0) then
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
            WRITE(LUNGFO,*)'IUNDULATOR HAS SET IMAGSPLN=-9999,'
            WRITE(LUNGFO,*)
     &        'WHICH IS INCOMPATIBLE WITH IWBMAP/IWBTAB/IBFORCE/IOPTIC'
            WRITE(LUNGFO,*)'TURN OFF IUNDULATOR, IF YOU USE IWBMAP/IWBTAB/IBFORCE/IOPTIC'
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN GFINIT ***'
            WRITE(6,*)'IUNDULATOR HAS SET IMAGSPLN=-9999,'
            WRITE(6,*)
     &        'WHICH IS INCOMPATIBLE WITH IWBMAP/IWBTAB/IBFORCE/IOPTIC'
            WRITE(6,*)'TURN OFF IUNDULATOR, IF YOU USE IWBMAP/IWBTAB/IBFORCE/IOPTIC'
            WRITE(6,*)
            STOP '*** PROGRAM WAVE ABORTED ***'
          ENDIF
+self,if=-20220316.
          IF ((IWBMAP.NE.0.OR.IBFORCE.NE.0.OR.IOPTIC.NE.0)
     &        .and.
     &    (iemit.ne.0.or.kbrec.ne.0.or.kbundumag.ne.0.or.kbextern.ne.0.or.kbpolymag.ne.0)) then
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
            WRITE(LUNGFO,*)'IUNDULATOR HAS SET IMAGSPLN=-9999,'
            WRITE(LUNGFO,*)
     &        'WHICH IS INCOMPATIBLE WITH IWBMAP/IBFORCE/IOPTIC'
            WRITE(LUNGFO,*)'TURN OFF IUNDULATOR, IF YOU USE IWBMAP/IBFORCE/IOPTIC'
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN GFINIT ***'
            WRITE(6,*)'IUNDULATOR HAS SET IMAGSPLN=-9999,'
            WRITE(6,*)
     &        'WHICH IS INCOMPATIBLE WITH IWBMAP/IBFORCE/IOPTIC'
            WRITE(6,*)'TURN OFF IUNDULATOR, IF YOU USE IWBMAP/IBFORCE/IOPTIC'
            WRITE(6,*)
            STOP '*** PROGRAM WAVE ABORTED ***'
          ENDIF
+self.

          icluster=0

          IF (ISPEC.NE.0) THEN

            ispecmode=2

            !if (nroi.ne.0) ispecmode=1

            IF (IAMPLI.GT.0.AND.ISPECMODE.NE.3.and.iamprep.ge.0) THEN
c noch ueberdenken, iphase bereits kompatible gemacht, 17.10.2012
              WRITE(LUNGFO,*)
     &          '*** Warning in GFINIT: ISPECMODE not 3, but IAMPLI.gt.0 and IAMPREP.gt.0'
              WRITE(6,*)"*** BE CAREFUL ***"
              PRINT *,
     &          '*** Warning in GFINIT: ISPECMODE not 3, but IAMPLI.gt.0 and IAMPREP.gt.0'
              print*,"*** BE CAREFUL ***"
            ENDIF

          ENDIF !ISPEC

          IMAGSPLN=-9999
          if (iemit.ne.0.or.kbrec.ne.0.or.kbundumag.ne.0.or.kbextern.ne.0.or.kbpolymag.ne.0) IMAGSPLN=0

          IRFILL0=0
C         IWFILL0=1
c          NLPOI=-9999
          NLPOI=0
          CX1=9999.
          CY1=9999.
          CZ1=9999.
          HIG1=1000.
          WID1=1000.
          CX2=9999.
          CY2=9999.
          CZ2=9999.
          HIG2=1000.
          WID2=1000.
          WGWINFC=PI1/4.0D0*DMYGAMMA
          WBL0CUT=0.0
          WBL0HYS=1.0
          IBL0CUT=0
          ISOUREXT=0
          ISPECDIP=0
          IF (IFOLD.NE.0) IFOLD=1
          IF (iefold.ne.0.and.IEFOLD.ne.1.and.iefold.ne.-1.and.iefold.ne.3) then
            write(lungfo,*)
            write(lungfo,*)"*** Warning in gfinit: IEFOLD MUST BE ONE OF [0,1,3,-1]"
            write(lungfo,*)"*** Will set it to IEFOLD=1 ***"
            write(lungfo,*)
            print*
            print*,"*** Warning in gfinit: IEFOLD MUST BE ONE OF [0,1,3,-1]"
            print*,"*** Will set it to IEFOLD=1 ***"
            print*
            IEFOLD=1
          endif
          IF (IPIN.GT.0.and.ipin.ne.3) IPIN=1
          BMOVECUT=1.0D-6

        else !ibunch

          if (icluster.ne.0) mthreads=0

          IF (ISPEC.NE.0) THEN

            ISPECMODE=2

            IF (IPHASE.NE.0) THEN
              WRITE(LUNGFO,*)' '
              WRITE(LUNGFO,*)
     &          '*** Warning in GFINIT: IPHASE set to zero, due to IBUNCH'
              WRITE(LUNGFO,*)' '
              PRINT *,' '
              PRINT *,
     &          '*** Warning in GFINIT: IPHASE set to zero, due to IBUNCH'
              PRINT *,' '
              iphase=0
            ENDIF

            IF (iampli.ne.0.and.iamprep.lt.0) THEN
              WRITE(LUNGFO,*)
     &          '*** Error in GFINIT: IBUNCH and IAMPREP < 0 are not compatible ***'
              PRINT *,
     &          '*** Error in GFINIT: IBUNCH and IAMPREP < 0 are not compatible ***'
              STOP '*** PROGRAM WAVE ABORTED ***'
            ENDIF

          ENDIF !ISPEC

          IFOLD=0
          IEFOLD=0
          !IMAGSPLN=0
          IRFILL0=0
c          NLPOI=-9999
          NLPOI=0
          CX1=9999.
          CY1=9999.
          CZ1=9999.
          HIG1=1000.
          WID1=1000.
          CX2=9999.
          CY2=9999.
          CZ2=9999.
          HIG2=1000.
          WID2=1000.
          WGWINFC=PI1/4.0D0*DMYGAMMA
          WBL0CUT=0.0
          WBL0HYS=1.0
          IBL0CUT=0
          ISOUREXT=0
          ISPECDIP=0
          IFOLD=0
          IEFOLD=0

          if (iefold.ne.0) then
            WRITE(6,*)' '
            WRITE(6,*)
     &        '      *** Warning in GFINIT: IEFOLD is used for IBUNCH, be careful!'
            WRITE(6,*)' '
            WRITE(LUNGFO,*)' '
            WRITE(LUNGFO,*)
     &        '      *** Warning in GFINIT: IEFOLD is used for IBUNCH, be careful!'
            WRITE(LUNGFO,*)' '
          endif

          IF (iundulator.ne.2
     &        .and.IPIN.GT.0.and.ipin.ne.3.and.neinbunch.eq.1) then
            IPIN=3
            WRITE(6,*)' '
            WRITE(6,*)
     &        '      *** GFINIT: IPIN=3 has been set due to IUNDULATOR and IBUNCH and NEINBUNCH=1, be careful!'
            WRITE(lungfo,*)' '
            WRITE(lungfo,*)
     &        '      *** GFINIT: IPIN=3 has been set due to IUNDULATOR and IBUNCH and NEINBUNCH=1, be careful!'
            WRITE(6,*)' '
          endif

          BMOVECUT=1.0D-6

        endif !ibunch

      ENDIF !IUNDULATOR

      IF (IWIGGLER.GT.1) THEN

        IF (ibunch.ne.0) then
          WRITE(LUNGFO,*)
     &      '*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      '*** IWIGGLER.GT.1 .AND. IBUNCH.NE.0 ARE INCOMPATIBLE ***'
          WRITE(6,*)
     &      '*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      '*** IWIGGLER.GT.1 .AND. IBUNCH.NE.0 ARE INCOMPATIBLE ***'
          STOP '*** PROGRAM WAVE ABORTED ***'
        endif

+self,if=20220316.
        IF (IWBMAP.NE.0.OR.IWBTAB.NE.0.OR.IBFORCE.NE.0.OR.IOPTIC.NE.0)THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'IWIGGLER HAS TURNED SET IMAGSPLN=-9999,'
          WRITE(LUNGFO,*)
     &      'WHICH IS INCOMPATIBLE WITH IWBMAP/IWBTAB/IBFORCE/IOPTIC/IBUNCH'
          WRITE(LUNGFO,*)'TURN OFF IWIGGLER, IF YOU USE IWBMAP/IWBTAB/IBFORCE/IOPTIC/IBUNCH'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'IWIGGLER HAS TURNED SET IMAGSPLN=-9999,'
          WRITE(6,*)
     &      'WHICH IS INCOMPATIBLE WITH IWBMAP/IWBTAB/IBFORCE/IOPTIC/IBUNCH'
          WRITE(6,*)'TURN OFF IWIGGLER, IF YOU USE IWBMAP/IWBTAB/IBFORCE/IOPTIC/IBUNCH'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF
+self,if=-20220316.
          IF ((IWBMAP.NE.0.OR.IBFORCE.NE.0.OR.IOPTIC.NE.0)
     &        .and.
     &    (iemit.ne.0.or.kbrec.ne.0.or.kbundumag.ne.0.or.kbextern.ne.0.or.kbpolymag.ne.0)) then

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'IWIGGLER HAS TURNED SET IMAGSPLN=-9999,'
          WRITE(LUNGFO,*)
     &      'WHICH IS INCOMPATIBLE WITH IWBMAP/IBFORCE/IOPTIC/IBUNCH'
          WRITE(LUNGFO,*)'TURN OFF IWIGGLER, IF YOU USE IWBMAP/IBFORCE/IOPTIC/IBUNCH'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'IWIGGLER HAS TURNED SET IMAGSPLN=-9999,'
          WRITE(6,*)
     &      'WHICH IS INCOMPATIBLE WITH IWBMAP/IBFORCE/IOPTIC/IBUNCH'
          WRITE(6,*)'TURN OFF IWIGGLER, IF YOU USE IWBMAP/IBFORCE/IOPTIC/IBUNCH'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF
+self.

        ISPECDIP=-2

        IMAGSPLN=-9999
        !if (iemit.ne.0.or.kbrec.ne.0.or.kbundumag.ne.0.or.kbextern.ne.0.or.kbpolymag.ne.0) IMAGSPLN=0

        IRFILL0=0
C         IWFILL0=1
        NLPOI=-9999
        WGWINFC=10.
        CX1=9999.
        CY1=9999.
        CZ1=9999.
        HIG1=9999.
        WID1=9999.
        CX2=9999.
        CY2=9999.
        CZ2=9999.
        HIG2=9999.
        WID2=9999.
        !WBL0CUT=0.1
        !WBL0HYS=1.0
        !IBL0CUT=1
        ISOUREXT=0
        IF (IFOLD.NE.0) IFOLD=1
        IF (IEFOLD.NE.0) IEFOLD=1
      ENDIF !IWIGGLER

      IF (IWIGGLER.EQ.1) THEN

+self,if=20220316.
        IF (IWBMAP.NE.0.OR.IWBTAB.NE.0.OR.IBFORCE.NE.0.OR.IOPTIC.NE.0)THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'IWIGGLER HAS TURNED SET IMAGSPLN=-9999,'
          WRITE(LUNGFO,*)
     &      'WHICH IS INCOMPATIBLE WITH IWBMAP/IWBTAB/IBFORCE/IOPTIC/IBUNCH'
          WRITE(LUNGFO,*)'TURN OFF IWIGGLER, IF YOU USE IWBMAP/IWBTAB/IBFORCE/IOPTIC/IBUNCH'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'IWIGGLER HAS TURNED SET IMAGSPLN=-9999,'
          WRITE(6,*)
     &      'WHICH IS INCOMPATIBLE WITH IWBMAP/IWBTAB/IBFORCE/IOPTIC/IBUNCH'
          WRITE(6,*)'TURN OFF IWIGGLER, IF YOU USE IWBMAP/IWBTAB/IBFORCE/IOPTIC/IBUNCH'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF
+self,if=-20220316.
          IF ((IWBMAP.NE.0.OR.IBFORCE.NE.0.OR.IOPTIC.NE.0)
     &        .and.
     &    (iemit.ne.0.or.kbrec.ne.0.or.kbundumag.ne.0.or.kbextern.ne.0.or.kbpolymag.ne.0)) then
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'IWIGGLER HAS TURNED SET IMAGSPLN=-9999,'
          WRITE(LUNGFO,*)
     &      'WHICH IS INCOMPATIBLE WITH IWBMAP/IBFORCE/IOPTIC/IBUNCH'
          WRITE(LUNGFO,*)'TURN OFF IWIGGLER, IF YOU USE IWBMAP/IBFORCE/IOPTIC/IBUNCH'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'IWIGGLER HAS TURNED SET IMAGSPLN=-9999,'
          WRITE(6,*)
     &      'WHICH IS INCOMPATIBLE WITH IWBMAP/IBFORCE/IOPTIC/IBUNCH'
          WRITE(6,*)'TURN OFF IWIGGLER, IF YOU USE IWBMAP/IBFORCE/IOPTIC/IBUNCH'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF
+self.

C        IF (IPHASE.NE.0.OR.IAMPLI.NE.0) THEN
c noch ueberdenken, iphase bereits kompatible gemacht, 17.10.2012
C          WRITE(LUNGFO,*)
C     &      '*** Warning in GFINIT: ISPECMODE set to 3, due to IPHASE'
C          PRINT *,
C     &      '*** Warning in GFINIT: ISPECMODE set to 3, due to IPHASE'
C          ISPECMODE=3
C        ELSE
C          ISPECMODE=2
C          if (icluster.eq.0.and.ibunch.eq.0.and.nroi.eq.0) ispecmode=3
C        ENDIF

        IF (ISPECMODE.NE.3.AND.(IPHASE.NE.0.OR.IAMPLI.NE.0)) THEN
          WRITE(6,*)
     &      '*** Warning in GFINIT: ISPECMODE not 3, but IPHASE or IAMPLI set ***'
          WRITE(6,*)
     &      '*** This is not yet fully tested, be careful ***'
          WRITE(LUNGFO,*)
     &      '*** Warning in GFINIT: ISPECMODE not 3, but IPHASE or IAMPLI set ***'
          WRITE(LUNGFO,*)
     &      '*** This is not yet fully tested, be careful ***'
        ENDIF

        IMAGSPLN=-9999
        !if (iemit.ne.0.or.kbrec.ne.0.or.kbundumag.ne.0.or.kbextern.ne.0.or.kbpolymag.ne.0) IMAGSPLN=-9999

        IRFILL0=0
C         IWFILL0=1
        NLPOI=-9999
        WGWINFC=9999.
        CX1=9999.
        CY1=9999.
        CZ1=9999.
        HIG1=9999.
        WID1=9999.
        CX2=9999.
        CY2=9999.
        CZ2=9999.
        HIG2=9999.
        WID2=9999.
        WBL0CUT=0.1
        WBL0HYS=1.0
        IBL0CUT=1
        ISOUREXT=0
        ISPECDIP=0

        IF (IFOLD.NE.0) IFOLD=1

        if (ibunch.ne.0) ibunch=-1
        if (ibunch.ne.0) then
          IFOLD=0
          IEFOLD=0
        endif
      ENDIF !IWIGGLER

      if (iwiggler.ne.0.and.ibunch.ne.0.and.ipin.ne.0.and.neinbunch.eq.1) ipin=3

      if (espread.le.0.0d0.and.iefold.ne.0) then
        iefold=0
        write(lungfo,*)'     *** Warning in GFINIT: IEFOLD set zero, since ESPREAD <= 0.0'
        write(6,*)'     *** Warning in GFINIT: IEFOLD set zero, since ESPREAD <= 0.0'
      endif

      IF (ISPEC.NE.0) THEN

        if (ibunch.ne.0.and.ifold.ne.0) then
          write(6,*)' '
          write(6,*)' *** Warning in gfinit: IBUNCH and IFOLD are both set, be careful!'
          write(6,*)' '
          write(lungfo,*)' '
          write(lungfo,*)' *** Warning in gfinit: IBUNCH and IFOLD are both set, be careful!'
          write(lungfo,*)' '
        endif

        if (ibunch.ne.0.and.iefold.ne.0) then
          write(6,*)' '
          write(6,*)' *** Warning in gfinit: IBUNCH and IEFOLD are both set, be careful!'
          write(6,*)' '
          write(lungfo,*)' '
          write(lungfo,*)' *** Warning in gfinit: IBUNCH and IEFOLD are both set, be careful!'
          write(lungfo,*)' '
        endif

        if (ieneloss.ne.0.and.ispecmode.gt.3) then
          write(lungfo,*)' '
          write(lungfo,*)'*** Error: IENELOSS and ISPECMODE are incompatible ***'
          WRITE(lungfo,*)'*** PROGRAM WAVE ABORTED'
          write(lungfo,*)' '
          write(6,*)' '
          write(6,*)'*** Error: IENELOSS and ISPECMODE are incompatible ***'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED'
          write(6,*)' '
          stop
        endif

        if (ibunch.ne.0.and.ispecmode.ne.2) then
          write(6,*)' '
          write(6,*)' *** ERROR IN GFINIT: IBUNCH set, but ISPECMODE.ne.2!'
          write(6,*)' **** Please check namelist $CONTRL in wave.in'
          write(6,*)' '
          WRITE(6,*)'*** PROGRAM WAVE ABORTED'
          write(6,*)' '
          write(lungfo,*)' '
          write(lungfo,*)' *** ERROR IN GFINIT: IBUNCH set, but ISPECMODE.ne.2!'
          write(lungfo,*)' **** Please check namelist $CONTRL in wave.in'
          write(lungfo,*)' '
          WRITE(lungfo,*)'*** PROGRAM WAVE ABORTED'
          write(lungfo,*)' '
          stop
        endif

        if (iefold.ne.0.and.ifreq2p.ne.3) then
          write(LUNGFO,*)' '
          write(LUNGFO,*)'*** Warning in GFINIT: IEFOLD.ne.0 and IFRQE2P.ne.3 ***'
          write(LUNGFO,*)'IFREQ2P set to IFREQ2P=3'
          write(LUNGFO,*)' '
          write(6,*)' '
          write(6,*)'*** Warning in GFINIT: IEFOLD.ne.0 and IFRQE2P.ne.3 ***'
          write(6,*)'IFREQ2P set to IFREQ2P=3'
          write(6,*)' '
          IFREQ2P=3
        endif

        IF (ISPECMODE.NE.5) THEN
          IF (IPIN.EQ.2) THEN
            WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. ISPECMODE.NE.5'
            WRITE(6,*)'*** IPIN SET TO 1'
            WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. ISPECMODE.NE.5'
            WRITE(LUNGFO,*)'*** IPIN SET TO 1'
            IPIN=1
          ENDIF !IPIN.EQ.2
          if (ibunch.eq.0) then
            IF (IFOLD.EQ.2) THEN
              WRITE(6,*)'*** WARNING IN GFINIT: IFOLD.EQ.2 .AND. ISPECMODE.NE.5'
              WRITE(6,*)'*** IFOLD SET TO 1'
              WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IFOLD.EQ.2 .AND. ISPECMODE.NE.5'
              WRITE(LUNGFO,*)'*** IFOLD SET TO 1'
              IFOLD=1
            ENDIF !IPIN.EQ.2
            IF (IEFOLD.EQ.2) THEN
              WRITE(6,*)'*** WARNING IN GFINIT: IEFOLD.EQ.2 .AND. ISPECMODE.NE.5'
              WRITE(6,*)'*** IEFOLD SET TO 1'
              WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IEFOLD.EQ.2 .AND. ISPECMODE.NE.5'
              WRITE(LUNGFO,*)'*** IEFOLD SET TO 1'
              IEFOLD=1
            ENDIF !IEFOLD.EQ.2
          endif
        ENDIF !ISPECMODE

        IF (IPIN.EQ.2.AND.ISPECDIP.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. ISPECDIP.NE.0'
          WRITE(6,*)'*** IPIN SET TO 1'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. ISPECDIP.NE.0'
          WRITE(LUNGFO,*)'*** IPIN SET TO 1'
          IPIN=1
        ENDIF !IPIN.EQ.2

        if (ibunch.eq.0) then
          IF (IFOLD.NE.0.AND.IPIN.EQ.0.AND.IFOLD.NE.2) THEN
            PRINT*,'            *** WARNING IN GFINIT: IPIN.EQ.0 .AND. IFOLD.NE.2'
            PRINT*,'            *** IFOLD SET TO ZERO'
            print*
            WRITE(LUNGFO,*)'             *** WARNING IN GFINIT: IPIN.EQ.0 .AND. IFOLD.NE.2'
            WRITE(LUNGFO,*)'             *** IFOLD SET TO ZERO'
            write(lungfo,*)
            IFOLD=0
          ENDIF
        endif !(ibunch.eq.0) then

        IF (IPIN.EQ.2.AND.IPINALL.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IPINALL.NE.0'
          WRITE(6,*)'*** IPINALL SET TO ZERO'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IPINALL.NE.0'
          WRITE(LUNGFO,*)'*** IPINALL SET TO ZERO'
          IPINALL=0
        ENDIF !IPIN.EQ.2

        IF (IPIN.EQ.2.AND.IWFILRAY.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IWFILRAY.NE.0'
          WRITE(6,*)'*** IWFILRAY SET TO ZERO'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IWFILRAY.NE.0'
          WRITE(LUNGFO,*)'*** IWFILRAY SET TO ZERO'
          IWFILRAY=0
        ENDIF !IPIN.EQ.2

        IF (IPIN.EQ.3.AND.IWFILRAY.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.3 .AND. IWFILRAY.NE.0'
          WRITE(6,*)'*** IWFILRAY SET TO ZERO'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.3 .AND. IWFILRAY.NE.0'
          WRITE(LUNGFO,*)'*** IWFILRAY SET TO ZERO'
          IWFILRAY=0
        ENDIF !IPIN.EQ.2

        IF (IPIN.EQ.2.AND.ISPECSUM.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. ISPECSUM.NE.0'
          WRITE(6,*)'*** ISPECSUM SET TO ZERO'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. ISPECSUM.NE.0'
          WRITE(LUNGFO,*)'*** ISPECSUM SET TO ZERO'
          ISPECSUM=0
        ENDIF !IPIN.EQ.2

        IF (IPIN.EQ.2.AND.ISPECANA.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. ISPECANA.NE.0'
          WRITE(6,*)'*** IPIN SET TO 1'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. ISPECANA.NE.0'
          WRITE(LUNGFO,*)'*** IPIN SET TO 1'
          IPIN=1
        ENDIF !IPIN.EQ.2

        IF (IPIN.EQ.2.AND.IAMPLI.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IAMPLI.NE.0'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IAMPLI.NE.0'
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED'
          STOP
        ENDIF !IPIN.EQ.2

        IF (IPIN.EQ.2.AND.IRFILOB.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IRFILOB.NE.0'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IRFILOB.NE.0'
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED'
          STOP
        ENDIF !IPIN.EQ.2

        IF (IPIN.EQ.2.AND.IUSEM.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IUSEM.NE.0'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IUSEM.NE.0'
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED'
          STOP
        ENDIF !IPIN.EQ.2

      ENDIF !ISPEC.NE.0

      IF (IFOLD.NE.0
     &    .AND.IFOLD.NE.1.AND.IFOLD.NE.2.AND.IFOLD.NE.-1.AND.IFOLD.NE.-2
     &    ) THEN
        WRITE(LUNGFO,*)
     &    '*** ERROR IN GFINIT: BAD VALUE OF IFOLD, CHECK INPUT '
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
        WRITE(6,*)
     &    '*** ERROR IN GFINIT: BAD VALUE OF IFOLD, CHECK INPUT '
        WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
        STOP
      ENDIF

      IF (NROI.EQ.0) THEN
        NROI=2
        ROIX(1)=-1.0D10
        ROIX(2)=1.0D10
        ROIP(1)=1.0D0
        ROIP(2)=1.0D0
        IROIASYEXP(1)=0
      ENDIF

      NROIA=ABS(NROI)

      IF (NROIA.GT.NROIP) THEN
        WRITE(6,*)
     &    '*** PARAMETER NROIP EXCEEDED: CHECK NROI IN NAMELIST ROIN'
        WRITE(6,*)
     &    'OR INCREASE NROIP IN SOURCE.CMN  ***'
        WRITE(LUNGFO,*)
     &    '*** PARAMETER NROIP EXCEEDED: CHECK NROI IN NAMELIST ROIN'
        WRITE(LUNGFO,*)
     &    'OR INCREASE NROIP IN SOURCE.CMN  ***'
        STOP
      ENDIF

      DO IROI=1,NROIA
        IF (ROIP(IROI).EQ.0.0D0) THEN
          ROIP(IROI)=1.0D0
        ENDIF
      ENDDO   !IROI

      IF (NROI.GT.0) THEN
        DO IROI=1,NROIA-1
          IF (ROIX(IROI).GE.ROIX(IROI+1)) THEN
            WRITE(6,*)
     &        '*** ERROR IN NAMELIST ROIN: VALUES OF ROIX NOT IN INCREASING ORDER'
            WRITE(6,*)
     &        '*** OR NUMBER OF ROIX DOES NOT MATCH NROI'
            WRITE(LUNGFO,*)
     &        '*** ERROR IN NAMELIST ROIN: VALUES OF ROIX NOT IN INCREASING ORDER'
            WRITE(LUNGFO,*)
     &        '*** OR NUMBER OF ROIX DOES NOT MATCH NROI'
            STOP
          ENDIF
        ENDDO   !IROI
      ENDIF

      IF (IPIN.EQ.2) THEN
        mpinyorig=mpiny
        mpinzorig=mpinz
        MPINZ=1
        MPINY=1
      ENDIF

      IF (ISIGSTO.EQ.0) ISIGSTO=1

      IF (ISPec.ne.0.and.ipin.eq.3.AND.IBRILL.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
        WRITE(LUNGFO,*)'FLAG IBRILL AND IPIN=3 ARE NOT COMPATIBLE'
        WRITE(LUNGFO,*)'IBRILL SET TO ZERO'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN GFINIT ***'
        WRITE(6,*)'FLAG IBRILL AND IPIN=3 ARE NOT COMPATIBLE'
        WRITE(6,*)'IBRILL SET TO ZERO'
        WRITE(6,*)
        ibrill=0
      ENDIF

      IF (ISPEC.NE.0.AND.IBRILL.NE.0.AND.ISTOKES.EQ.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'FLAG IBRILL IS SET BUT ISTOKES IS NOT'
        WRITE(LUNGFO,*)'SET ALSO FLAG ISTOKES IN INPUT FILE'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'FLAG IBRILL IS SET BUT ISTOKES IS NOT'
        WRITE(6,*)'SET ALSO FLAG ISTOKES IN INPUT FILE'
        WRITE(6,*)
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPEC.NE.0.AND.IWFILRAY.NE.0.AND.ISTOKES.EQ.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'FLAG IWFILRAY IS SET BUT ISTOKES IS NOT'
        WRITE(LUNGFO,*)'SET ALSO FLAG ISTOKES IN INPUT FILE'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'FLAG IWFILRAY IS SET BUT ISTOKES IS NOT'
        WRITE(6,*)'SET ALSO FLAG ISTOKES IN INPUT FILE'
        WRITE(6,*)
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPECMODE.LT.0) ISPECMODE=-ISPECMODE
      IF (ISPECMODE.EQ.0) ISPECMODE=2

      IF (
     &    ISPECMODE.NE.1.AND.
     &    ISPECMODE.NE.2.AND.
     &    ISPECMODE.NE.3.AND.
     &    ISPECMODE.NE.4.AND.
     &    ISPECMODE.NE.5) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'BAD VALUE OF ISPECMODE'
        WRITE(LUNGFO,*)'CHECK INPUT FILE WAVE.IN'
        WRITE(LUNGFO,*)

        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'BAD VALUE OF ISPECMODE'
        WRITE(6,*)'CHECK INPUT FILE WAVE.IN'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'

      ENDIF

C7MAR97      IF (IFILTER.EQ.0) IHFIL=0

      IF (IFILTER.LT.0.AND.IFILMUL.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'IFILTER.LT.0.AND.IFILMUL.NE.0'
        WRITE(LUNGFO,*)'CHECK INPUT FILE WAVE.IN'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'IFILTER.LT.0.AND.IFILMUL.NE.0'
        WRITE(6,*)'CHECK INPUT FILE WAVE.IN'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IFILTER.EQ.0.AND.IFILMUL.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
        WRITE(LUNGFO,*)'IFILMUL.NE.0 .AND. IFILTER.EQ.0'
        WRITE(LUNGFO,*)'IFILTER SET TO ONE'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN GFINIT ***'
        WRITE(6,*)'IFILMUL.NE.0 .AND. IFILTER.EQ.0'
        WRITE(6,*)'IFILTER SET TO ONE'
        WRITE(6,*)
        IFILTER=1
      ENDIF

      if (imagspln.eq.-9999.and.ibunch.ne.0) then
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
        WRITE(LUNGFO,*)'IMAGSPLN.EQ.-9999.AND.IUBUNCH.NE.0'
        WRITE(LUNGFO,*)'IMAGSPLN SET TO ZERO'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN GFINIT ***'
        WRITE(6,*)'IMAGSPLN.EQ.-9999.AND.IUBUNCH.NE.0'
        WRITE(6,*)'IMAGSPLN SET TO ZERO'
        WRITE(6,*)
        imagspln=0
      endif

      IF (IMAGSPLN.NE.-9999.AND.IMAGSPLN.LT.0) IMAGSPLN=-1

      IF (IMAGSPLN.GT.0) THEN

        OPEN(UNIT=99,FILE='magjob.dat',STATUS='OLD'
+SELF,IF=-windows.
     &    ,RECL=256)
+SELF,IF=WINDOWS.
     &    )
+SELF.

        READ(99,*)IMAGJOB
        READ(99,*)

        IF (IMAGSPLN.NE.IMAGJOB) THEN

          WRITE(6,*)'*** ERROR IN GFINIT:'
          WRITE(6,*)
     &      'IMAGSPLN DOES NOT MATCH JOB NUMBER ON FILE IMAGSPL:magjob.dat'
          WRITE(6,*)'FIELD TAKEN FROM REFERENCE ORBIT'
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT:'
          WRITE(LUNGFO,*)
     &      'IMAGSPLN DOES NOT MATCH JOB NUMBER ON FILE IMAGSPL:magjob.dat'
          WRITE(LUNGFO,*)'FIELD TAKEN FROM REFERENCE ORBIT'
          READ(99,*)XSTART,YSTART,ZSTART
          READ(99,*)VXIN,VYIN,VZIN
          READ(99,*)XSTOPR,DMYENERGY
          IF (XSTOP.EQ.9999.) XSTOP=XSTOPR

        ENDIF   !IMAGJOB

        CLOSE(99)

      ENDIF   !IMAGSPLN

C5.10.95 IF (ISPEC.NE.0.AND.IMAGSPLN.NE.0.AND.IOPTIC.NE.0) THEN
C5.10.95 WARUM ISPEC ?? IN ABFRAGE?? BEOBACHTEN
      IF (IMAGSPLN.NE.0.AND.IOPTIC.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'FLAGS IMAGSPLN AND IOPTIC ARE SET'
        WRITE(LUNGFO,*)'TURN OFF IMAGSPLN, IF YOU USE IOPTIC'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'FLAGS IMAGSPLN AND IOPTIC ARE SET'
        WRITE(6,*)'TURN OFF IMAGSPLN, IF YOU USE IOPTIC'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IMAGSPLN.NE.0.AND.IBFORCE.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'FLAGS IMAGSPLN AND IBFORCE ARE SET'
        WRITE(LUNGFO,*)'TURN OFF IMAGSPLN, IF YOU USE IBFORCE'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'FLAGS IMAGSPLN AND IBFORCE ARE SET'
        WRITE(6,*)'TURN OFF IMAGSPLN, IF YOU USE IBFORCE'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

+self,if=20220316.
      IF (IMAGSPLN.NE.0.AND.IWBMAP.NE.0
     &    .OR.
     &    IMAGSPLN.NE.0.AND.IWBTAB.NE.0
     &    ) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'BOTH FLAGS IMAGSPLN AND IWBMAP/IWBTAB ARE SET'
        WRITE(LUNGFO,*)'TURN OFF IMAGSPLN, IF YOU USE IWBMAP/IWBTAB'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'BOTH FLAGS IMAGSPLN AND IWBMAP/IWBTAB ARE SET'
        WRITE(6,*)'TURN OFF IMAGSPLN, IF YOU USE IWBMAP/IWBTAB'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF
+self,if=-20220316.
          IF ((IWBMAP.NE.0.OR.IBFORCE.NE.0.OR.IOPTIC.NE.0)
     &        .and.
     &    (iemit.ne.0.or.kbrec.ne.0.or.kbundumag.ne.0.or.kbextern.ne.0.or.kbpolymag.ne.0)) then
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'BOTH FLAGS IMAGSPLN AND IWBMAP ARE SET'
        WRITE(LUNGFO,*)'TURN OFF IMAGSPLN, IF YOU USE IWBMAP'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'BOTH FLAGS IMAGSPLN AND IWBMAP ARE SET'
        WRITE(6,*)'TURN OFF IMAGSPLN, IF YOU USE IWBMAP'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF
+self.

      IF (ISPEC.NE.0) THEN

        IF (IDESYNC.NE.0.AND.IFOLD.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IDESYNC AND IFOLD ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'IFOLD SET TO ZERO'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IDESYNC AND IFOLD ARE INCOMPATIBLE'
          WRITE(6,*)'IFOLD SET TO ZERO'
          WRITE(6,*)
          IFOLD=0
        ENDIF

        IF (IDESYNC.NE.0.AND.IDOSE.EQ.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IDESYNC AND IDOSE ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'IDOSE SET TO ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IDESYNC AND IDOSE ARE INCOMPATIBLE'
          WRITE(6,*)'IDOSE SET TO ONE'
          WRITE(6,*)
          IDOSE=1
        ENDIF

        IF (IDESYNC.NE.0.AND.ISTOKES.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IDESYNC AND ISTOKES ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'ISTOKES SET TO ZERO'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IDESYNC AND ISTOKES ARE INCOMPATIBLE'
          WRITE(6,*)'ISTOKES SET TO ZERO'
          WRITE(6,*)
          ISTOKES=0
        ENDIF

        IF (IRFILSP0.NE.0.AND.IBRILL.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IRFILSP0 AND IBRILL ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'IBRILL SET TO ZERO'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IRFILSP0 AND IBRILL ARE INCOMPATIBLE'
          WRITE(6,*)'IBRILL SET TO ZERO'
          WRITE(6,*)
          IBRILL=0
        ENDIF

        IF (IRFILSP0.NE.0.AND.ISTOKES.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IRFILSP0 AND ISTOKES ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'ISTOKES SET TO ZERO'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IRFILSP0 AND ISTOKES ARE INCOMPATIBLE'
          WRITE(6,*)'ISTOKES SET TO ZERO'
          WRITE(6,*)
          ISTOKES=0
        ENDIF

        IF (IDESYNC.NE.0.AND.IPIN.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IDESYNC AND IPIN ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'IPIN SET TO ZERO'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IDESYNC AND IPIN ARE INCOMPATIBLE'
          WRITE(6,*)'IPIN SET TO ZERO'
          WRITE(6,*)
          IPIN=0
        ENDIF

        IF (IPHASE.NE.0.AND.(IPIN.EQ.0.OR.IPIN.EQ.2)) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAGS IPHASE AND IPIN ARE INCOMPATIBLE'
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAGS IPHASE AND IPIN ARE INCOMPATIBLE'
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF

+self,if=testiampli
        IF (iampskip.eq.0
     &      .and.IAMPLI.GT.0.AND.ISPECMODE.lt.3.and.iamprep.ge.0) THEN
c noch ueberdenken, iphase bereits kompatibel gemacht, 17.10.2012
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAGS IAMPLI AND ISPECMODE ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'WILL RESULTS IN ERRORS FOR PHASE PROPAGATION'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN GFINIT ***'
          WRITE(6,*)'FLAGS IAMPLI AND ISPECMODE ARE INCOMPATIBLE'
          WRITE(6,*)'WILL RESULTS IN ERRORS FOR PHASE PROPAGATION'
          WRITE(LUNGFO,*)
     &      '*** ISPECMODE set to 3, due to IPHASE'
          PRINT *,
     &      '*** ISPECMODE set to 3, due to IPHASE'
                ISPECMODE=3
          WRITE(6,*)
        ENDIF
+self...,if=testiampli

      ENDIF !ISPEC

      IF (IF1DIM.EQ.1.AND.IRPHI.NE.0.AND.IPINCIRC.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '*** WARNING IN GFINIT: IF1DIM.EQ.1.AND.IRPHI.NE.0.AND.IPINCIRC.NE.0'
        WRITE(LUNGFO,*)'IRPHI SET TO ZERO'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)
     &    '*** WARNING IN GFINIT: IF1DIM.EQ.1.AND.IRPHI.NE.0.AND.IPINCIRC.NE.0'
        WRITE(6,*)'IRPHI SET TO ZERO'
        WRITE(6,*)
        IRPHI=0
      ENDIF

      IF (IPIN.EQ.0.AND.IPINCIRC.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'WARNING IN GFINIT: IPIN.EQ.0.AND.IPINCIRC.NE.0'
        WRITE(LUNGFO,*)'IPINCIRC SET TO ZERO'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'WARNING IN GFINIT: IPIN.EQ.0.AND.IPINCIRC.NE.0'
        WRITE(6,*)'IPINCIRC SET TO ZERO'
        WRITE(6,*)
        IPINCIRC=0
      ENDIF

      if (ivelofield.eq.2) then
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '*** IVELOFIELD=2 is obsolete and not supported anymore ***'
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED'
        WRITE(6,*)
        WRITE(6,*)
     &    '*** IVELOFIELD=2 is obsolete and not supported anymore ***'
        WRITE(6,*)'*** PROGRAM WAVE ABORTED'
        stop
      endif

      IF (iphfold.ne.0.and.(phbeth.eq.-9999.0d0 .or. phbetav.eq.-9999.0d0)) THEN
        print*,'--- IEMIT triggerd due to IPHFOLD and (IPHBETH=-9999 or IPHBETAV=-9999 ---'
        iemit=1
      ENDIF

C--- WRITE CONTROL FLAGS

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     MODE FLAGS:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     IUNDULATOR,IWIGGLER: ',IUNDULATOR,IWIGGLER
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     CONTROL FLAGS:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)'     IUNAME,IUSTEP,IUOUT: ',IUNAME,IUSTEP,IUOUT
      WRITE(LUNGFO,*)'     IOPTIC,IGENFUN:      ',IOPTIC,IGENFUN
      WRITE(LUNGFO,*)'     IMAGSPLN:            ',IMAGSPLN
      IF (IOPTIC.NE.0.) THEN
       WRITE(LUNGFO,*)'        IPHASPAC, IHPHSPAC:         ',IPHASPAC,IHPHSPAC
      ENDIF
      IF (IOPTIC.NE.0.OR.IGENFUN.NE.0) THEN
         WRITE(LUNGFO,*)'        IERZANA,IERZFUN,I2DIM:     ',
     &                             IERZANA,IERZFUN,I2DIM
      ENDIF
      WRITE(LUNGFO,*)'     IEMIT,IEMIAHW:       ',IEMIT,IEMIAHW
      WRITE(LUNGFO,*)'     IWLSOPT,IBEAMPOL:    ',IWLSOPT,IBEAMPOL
      IF (IWLSOPT.NE.0) THEN
         WRITE(LUNGFO,*)'        IEMICRIT:                  ',IEMICRIT
      ENDIF
      WRITE(LUNGFO,*)'     IENELOSS, IEFIELD:   ',IENELOSS,IEFIELD
      WRITE(LUNGFO,*)'     IPOWER,ISPEC:        ',IPOWER,ISPEC
      WRITE(LUNGFO,*)'     IVELOFIELD,ISPECMODE:',IVELOFIELD,ISPECMODE

      IF (JWFILINT.LE.0) JWFILINT=-jwfilint

      IF (ISPEC.NE.0) THEN
        if (mthreads.ne.0.and.mthreads.ne.1.and.iwfilint.ne.0) then
          print*,"*** Warning in gfinit: MTHREADS set to zero, since IWFILINT is set ***"
          mthreads=0
        endif
        WRITE(LUNGFO,*)'        IWFILL0,IRFILL0:           ',IWFILL0,IRFILL0
        WRITE(LUNGFO,*)'        ISPECINT,IPIN:             ',ISPECINT,IPIN
        WRITE(LUNGFO,*)'        ISTOKES,IBRILL:            ',ISTOKES,IBRILL
        WRITE(LUNGFO,*)'        IPINCIRC,IRPHI:            ',IPINCIRC,IRPHI
        WRITE(LUNGFO,*)'        IFOLD,ISIGUSR:             ',IFOLD,ISIGUSR
        WRITE(LUNGFO,*)'        IF1DIM,IPOLA:              ',IF1DIM,IPOLA
        WRITE(LUNGFO,*)'        IWFILSP0,IWFILSPF:         ',IWFILSP0,IWFILSPF
        WRITE(LUNGFO,*)'        IRFILSP0,IRFILSTO:         ',IRFILSP0,IRFILSTO
        WRITE(LUNGFO,*)'        IWFILSTO,IWFLSTOF:         ',IWFILSTO,IWFLSTOF
        WRITE(LUNGFO,*)'        ISPECANA,ISPECANAF:        ',ISPECANA,ISPECANAF
        WRITE(LUNGFO,*)'        IAMPLI,IAMPSKIP:           ',IAMPLI,IAMPSKIP
        WRITE(LUNGFO,*)'        IWFILFL0,IWFILFLF:         ',IWFILFL0,IWFILFLF
        WRITE(LUNGFO,*)'        IWFILS,IWFILSF:            ',IWFILS,IWFILSF
        WRITE(LUNGFO,*)'        IWFILSE,IWFILSEF:          ',IWFILSE,IWFILSEF
        WRITE(LUNGFO,*)'        IWFILB,IWFILBF:            ',IWFILB,IWFILBF
        WRITE(LUNGFO,*)'        IWFILBE,IWFILBEF:          ',IWFILBE,IWFILBEF
        WRITE(LUNGFO,*)'        IWFILINT,IPINALL:          ',IWFILINT,IPINALL
        WRITE(LUNGFO,*)'        IRFILOB,IFILTER:           ',IRFILOB,IFILTER
        WRITE(LUNGFO,*)'        IWFILRAY,IDESYNC:          ',IWFILRAY,IDESYNC
        WRITE(LUNGFO,*)'        IPHASE,IPHASEANA:          ',IPHASE,IPHASEANA
        WRITE(LUNGFO,*)'        IDOSE,IEFOLD:              ',IDOSE,IEFOLD
        WRITE(LUNGFO,*)'        ISPECDIP,IBL0CUT:          ',ISPECDIP,IBL0CUT
        WRITE(LUNGFO,*)'        IEFFI,IFILMUL:             ',IEFFI,IFILMUL
        WRITE(LUNGFO,*)'        IBUNCH, IUBUNCH, NBUNCH:   ',IBUNCH,IUBUNCH,NBUNCH
      ENDIF !ISPEC

      WRITE(LUNGFO,*)'     IWFILF:              ',IWFILF


      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     MAGNETIC FIELD FLAGS:'
      WRITE(LUNGFO,*)
      IF (ICHARGE.GT.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'ATTENTION: TRACKING POSITRONS ***'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'ATTENTION: TRACKING POSITRONS ***'
        WRITE(6,*)
        ICHARGE=1
      ELSE IF (ICHARGE.LT.0) THEN
        ICHARGE=-1
      ELSE
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** Error in GFINIT: ICHARGE IS ZERO, check wave.in'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** Error in GFINIT: ICHARGE IS ZERO, check wave.in'
        WRITE(6,*)
        STOP '*** Program WAVE aborted ***'
      ENDIF !ICHARGE

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     ICHARGE,IBMASK,JBMASK:',ICHARGE,IBMASK,JBMASK
      WRITE(LUNGFO,*)'     IBSUPER,IBERROR:      ',IBSUPER,IBERROR
      WRITE(LUNGFO,*)'     ICUTFIBO:             ',ICUTFIBO
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)'     IPERIODG,IBSYM:      ',IPERIODG,IBSYM
      WRITE(LUNGFO,*)'     IBSYMY,IBSYMZ:       ',IBSYMY,IBSYMZ
      WRITE(LUNGFO,*)'     KBEXTERN,KBFELD:     ',KBEXTERN,KBFELD
      WRITE(LUNGFO,*)'     KHALBA,KHALBASY:     ',KHALBA,KHALBASY
      WRITE(LUNGFO,*)'     KUCROSS,IRFILP:      ',KUCROSS,IRFILP
      WRITE(LUNGFO,*)'     KMAGSEQ,IMGSQF:      ',KMAGSEQ,IMGSQF
      WRITE(LUNGFO,*)'            KMAGCOR:      ',KMAGCOR
      WRITE(LUNGFO,*)'     IRFILF,KELLIP:       ',IRFILF,KELLIP
      WRITE(LUNGFO,*)'     IRBTAB,IRBTABZY:     ',IRBTAB,IRBTABZY
      WRITE(LUNGFO,*)'     IFOURBTABZY:         ',IFOURBTABZY
      WRITE(LUNGFO,*)'     IRFILT0,IRBTABXYZ:   ',IRFILT0,IRBTABXYZ
      WRITE(LUNGFO,*)'     KBPOLYH,KBPOLY3D:    ',KBPOLYH,KBPOLY3D
      WRITE(LUNGFO,*)'     KBREC,KELLANA:       ',KBREC,KELLANA
      if (kbrec.gt.0) then
        WRITE(LUNGFO,*)'          IRECU:          ',IRECU
        WRITE(LUNGFO,*)'          IRECMODU:       ',IRECMODU
      endif
      WRITE(LUNGFO,*)'     KUNDUGAP,KBUNDUMAG:  ',kundugap,kbundumag
      WRITE(LUNGFO,*)'     KBPOLYMAG,KBGENESIS: ',KBPOLYMAG,KBGENESIS
      WRITE(LUNGFO,*)'     KBAMWLS,IRFILB0:     ',KBAMWLS,IRFILB0
      WRITE(LUNGFO,*)'     ICLUSTER:            ',ICLUSTER
      WRITE(LUNGFO,*)

+self,if=omp.
      if (iundulator.ne.2.and.ibunch.ne.0.and.mthreads.ne.0.and.icluster.eq.0) then
        write(6,*)""
        write(6,*)"*** Warning in gfinit: IBUNCH and MTHREAD not zero ***"
        write(6,*)"*** This is not yet implemented, be careful, better set MTHREADS=0 ***"
        write(6,*)"*** Or consider IUNDULATOR=2 ***"
        write(6,*)""
      endif

      if (ipin.ne.3.and.ipin.ne.0) then
        call omp_ini(lungfo,mthreads,1)
      else
        mthreads=0
        iomp=0
      endif
+self.

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     HISTOGRAM FLAGS:'
      WRITE(LUNGFO,*)

      IF (NINTFREQ.GT.99.AND.IHPIN.GT.0.and.IFREQ2P.gt.1.and.ispec.ne.0) THEN
      IHPIN=0
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &'*** WARNING IN GFINIT: MORE THAN 99 PHOTONENERGIES CONSIDERED'
      WRITE(LUNGFO,*)
     &'HISTOGRAMS FOR FOLDING FUNCTION AND FLUX DISTRIBUTION CANCELED'
      WRITE(LUNGFO,*)
      WRITE(6,*)
      WRITE(6,*)
     &'*** WARNING IN GFINIT: MORE THAN 99 PHOTONENERGIES CONSIDERED'
      WRITE(6,*)
     &'HISTOGRAMS FOR FOLDING FUNCTION AND FLUX DISTRIBUTION CANCELED'
      WRITE(6,*)
      ENDIF

      IF (IEMIT.EQ.0) IHBETA=0
      IF (IPIN.EQ.0)  IHPIN=0
      IF (IPIN.EQ.0)  IHFOLD=0
      IF (IFOLD.EQ.0)  IHFOLD=0
      IF (ISPEC.EQ.0) then
        IHFREQ=0
        ihpin=0
      endif

      if (ihpin.ne.0.and.ihfreq.eq.0) then
        write(6,*)'*** Warning in GFINIT: IHPIN.NE.0 but IHFREQ.EQ.0 ***'
        write(6,*)'*** IHFREQ SET TO ONE ***'
        write(LUNGFO,*)'*** Warning in GFINIT: IHPIN.NE.0 but IHFREQ.EQ.0 ***'
        write(LUNGFO,*)'*** IHFREQ SET TO ONE ***'
        ihfreq=1
      endif

      if (ntupgrid.ne.0.and.mhbookp.ne.0) then
        write(6,*)'*** WARNING: NTUPGRID is set zero, since it is obsolete for this version of WAVE!'
        ntupgrid=0
      endif

      ihtrack=-abs(ihtrack) ! Block old fashioned histograms
      ihtrackm=-abs(ihtrackm) ! Block old fashioned histograms

      IF (IHFIL.NE.0.OR.IHPIN.NE.0.OR.IHTRACK.NE.0.OR.IHBETA.NE.0
     &  .OR.IHTRACKM.NE.0.OR. IHFREQ.NE.0.OR.IPOWER.NE.0
     &  .OR.IHPHSPAC.NE.0.OR.IHINPUT.NE.0
     &  .OR.IHBPOLY3D.NE.0.OR.IHBPOLY2DH.NE.0.OR.IHBPHARM.NE.0
     &  .OR.IHSEL.NE.0.OR.IHFOLD.NE.0.OR.NTUPGRID.NE.0.OR.KBGENESIS.GT.0
     &  .or.ihbunch.ne.0.or.(ieneloss.lt.0.and.ihphotons.ne.0)
     &  )IHBOOK=1

      if (ihbook.eq.0) ihindex=0

      WRITE(LUNGFO,*)'     IHBOOK,IHINDEX:      ',IHBOOK,IHINDEX

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     OTHER OPTIONS:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)'     IWBTAB,IWFILT0:      ',IWBTAB,IWFILT0
      WRITE(LUNGFO,*)'     IWSECTMAGS:          ',IWSECTMAGS
      WRITE(LUNGFO,*)'     IJUST,ISNORDER:      ',IJUST,ISNORDER
      WRITE(LUNGFO,*)'     IWBMAP,IWBPOLY3D:    ',IWBMAP,IWBPOLY3D
      WRITE(LUNGFO,*)'     IWBPOLY2DH,IWBPHARM: ',IWBPOLY2DH,IWBPHARM
      WRITE(LUNGFO,*)

      if (irfilt0.ne.0) call trajectory_to_bfield_ini

C--- MERGE FILE WITH ABSORPTION COEFFICIENTS AND EXIT

      IF (ISPEC.NE.0.AND.IFILTER.LT.0) THEN
          CALL ABSCOEF_MERGE
      ENDIF

C--- SOME USEFUL CONSTANTS AND VARIABLES

c11.10.2017      DTIM=1.0D0/(CLIGHT1*MYINUM)   !TIME INTERVALLS FOR TRACKING
      DTIM=1.0D0/(CLIGHT1*dmybetap*MYINUM)   !TIME INTERVALLS FOR TRACKING
      BSHIFT=0.5D0          !DONT WORRY

      DS0=CLIGHT1*DTIM
      GAMMA=DMYGAMMA
      ENERGV=GAMMA*EMASSE1
      GMOM=EMASSG1*DSQRT((GAMMA-1.0d0)*(GAMMA+1.0d0))
      EMOM=EMASSE1*DSQRT((GAMMA-1.0d0)*(GAMMA+1.0d0))
      DBRHO=ICHARGE*EMOM/CLIGHT1
      BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
      DMYBETA=BETA
      V0=CLIGHT1*BETA
      TAUPOL01G=POL2CON1*UMFANG*RDIPOL**2/1.**5

      ecdipev1=3.0d0/2.0d0*hbarev1*(clight1/emasse1)**2/emasse1*1.0d18

      gamma1=1.0d0/emassg1
      emom1=emasse1*dsqrt((gamma1-1.0d0)*(gamma1+1.0d0))
      rho1=emom1/clight1
      omegac=1.5d0*gamma1**3*clight1/rho1
c      ecdipev=omegac*hbar1/echarge1
c      ecdipkev=ecdipev/1000.0d0

      CROTD=DCOSD(XROTD)
      SROTD=DSIND(XROTD)

C--- NORMALIZATION OF SPECTRUM
C    THE INTEGRATION (SR SPECTRUM) YIELDS THE PHOTON POWER PER ENERGY INTERVAL
C    dE AND SURFACE ELEMENT dA. THIS RESULT IS MULITPLIED BY THE NUMBER OF
C    ELECTRONS (DMYCUR/ECHARGE1),
C    A CONSTANT (ECHARGE1**2/(16*PI**3*EPS01*CLIGHT),
C    dE/E AND THE RELATIVE BANDWIDTH (USUALLY 1/1000). THE FINAL RESULT IS
C    OBTAINED BY A DIVISION THROUGH THE PHOTON ENERGY HBAR*OMEGA, WHICH GIVES
C    NOW THE PHOTON RATE PER BANDWIDTH AND SURFACE ELEMENT IN SI-UNITS

C     SPECNOR=    !DONT USE IT!!!
C     &          ECHARGE1**2/(4.D0*PI1**2*CLIGHT1)
C     &          /(4.D0*PI1*EPS01)
C     &          *DMYCUR/ECHARGE1
C     &          *BANWID
C     &          /(HBAREV1*ECHARGE1)

      SPECNOR=
     &          BANWID
     &          /(4.0D0*PI1**2*CLIGHT1*HBAREV1)
     &          /(4.0D0*PI1*EPS01)
     &          *DMYCUR

      POWNOR=ECHARGE1/16.0D0/PI1/PI1/EPS01/CLIGHT1*DMYCUR

C- NORMALIZE POLARIZATION VECTOR

      IF (IPOLA.NE.0) THEN

+SELF,IF=-NOCMPLX.

          VPOLAN=CDSQRT(
     &             VPOLA(1)*CONJG(VPOLA(1))
     &            +VPOLA(2)*CONJG(VPOLA(2))
     &            +VPOLA(3)* CONJG(VPOLA(3)))

          IF (VPOLAN.EQ.0.0) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
         WRITE(LUNGFO,*)'     POLARIZATION PLANE NOT DEFINED'
         WRITE(LUNGFO,*)'     CHECK VECTOR VPOLA IN NAMELIST SPECTN'
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)'     *** ERROR IN GFINIT ***'
         WRITE(6,*)'     POLARIZATION PLANE NOT DEFINED'
         WRITE(6,*)'     CHECK VECTOR VPOLA IN NAMELIST SPECTN'
         WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
          ENDIF !VPOLAN
          DO ICOMP=1,3
         VPOLA(ICOMP)=VPOLA(ICOMP)/VPOLAN
          ENDDO   !ICOMP
      ENDIF !IPOLA


        VSTOKES(1,1)=( 0.0d0,        0.0d0)      !HORIZONTAL POLARIZATION
        VSTOKES(1,2)=( 0.0d0,        0.0d0)
c        VSTOKES(1,3)=(-1.0d0,        0.0d0) !7mar05
        VSTOKES(1,3)=(-1.0d0,       -1.0d0) !Definition siehe
                                       !scienceworld.wolfram.com
                                       !liefert aber nur Phasenfaktor
                                       !im Vergleich zur alten Fassung

        VSTOKES(2,1)=( 0.0d0,        0.0d0)      !RIGHT HANDED POLARIZATION
        VSTOKES(2,2)=( 0.0d0,       -1.0d0)
        VSTOKES(2,3)=(+1.0d0,        0.0d0)

        VSTOKES(3,1)=( 0.0d0,        0.0d0)      !LEFT HANDED POLARIZATION
        VSTOKES(3,2)=( 0.0d0,       -1.0d0)
        VSTOKES(3,3)=(-1.0d0,        0.0d0)

        VSTOKES(4,1)=( 0.0d0,        0.0d0)      !45 DEGREE LINEAR POLARIZATION
        VSTOKES(4,2)=( 1.0d0,        0.0d0)
        VSTOKES(4,3)=(-1.0d0,        0.0d0)

         DO ISTO=1,4
             VSTO=DSQRT
     &            (CDABS(VSTOKES(ISTO,1))**2
     &            +CDABS(VSTOKES(ISTO,2))**2
     &            +CDABS(VSTOKES(ISTO,3))**2)
             VSTOKES(ISTO,1)=VSTOKES(ISTO,1)/VSTO
             VSTOKES(ISTO,2)=VSTOKES(ISTO,2)/VSTO
             VSTOKES(ISTO,3)=VSTOKES(ISTO,3)/VSTO

+SELF,IF=NOCMPLX.

          VPOLAN=SQRT(
     &             VPOLAR(1)*VPOLAR(1)+VPOLAI(1)*VPOLAI(1)
     &            +VPOLAR(2)*VPOLAR(2)+VPOLAI(2)*VPOLAI(2)
     &            +VPOLAR(3)*VPOLAR(3)+VPOLAI(3)*VPOLAI(3))

          IF (VPOLAN.EQ.0.0) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
         WRITE(LUNGFO,*)'     POLARIZATION PLANE NOT DEFINED'
         WRITE(LUNGFO,*)'     CHECK VECTOR VPOLA IN NAMELIST SPECTN'
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)'     *** ERROR IN GFINIT ***'
         WRITE(6,*)'     POLARIZATION PLANE NOT DEFINED'
         WRITE(6,*)'     CHECK VECTOR VPOLA IN NAMELIST SPECTN'
         WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
          ENDIF !VPOLAN

          DO ICOMP=1,3
              VPOLAR(ICOMP)=VPOLAR(ICOMP)/VPOLAN
              VPOLAI(ICOMP)=VPOLAI(ICOMP)/VPOLAN
          ENDDO   !ICOMP

      ENDIF !IPOLA


        VSTOKESR(1,1)=0.0D0      !HORIZONTAL POLARIZATION
        VSTOKESR(1,2)=0.0D0
        VSTOKESR(1,3)=-1.0D0
        VSTOKESI(1,1)=0.0D0      !HORIZONTAL POLARIZATION
        VSTOKESI(1,2)=0.0D0
        VSTOKESI(1,3)=0.0D0

        VSTOKESR(2,1)=0.0D0    !RIGHT HANDED POLARIZATION
        VSTOKESR(2,2)=0.0D0
        VSTOKESR(2,3)=+1.0D0
        VSTOKESI(2,1)=0.0D0      !RIGHT HANDED POLARIZATION
        VSTOKESI(2,2)=-1.0D0
        VSTOKESI(2,3)=0.0D0

        VSTOKESR(3,1)=0.0D0  !LEFT HANDED POLARIZATION
        VSTOKESR(3,2)=0.0D0
        VSTOKESR(3,3)=-1.0D0
        VSTOKESI(3,1)=0.0D0      !LEFT HANDED POLARIZATION
        VSTOKESI(3,2)=-1.0D0
        VSTOKESI(3,3)=0.0D0

        VSTOKESR(4,1)=0.0D0  !45 DEGREE LINEAR POLARIZATION
        VSTOKESR(4,2)=1.0D0
        VSTOKESR(4,3)=-1.0D0
      VSTOKESI(4,1)=0.0D0      !45 DEGREE LINEAR POLARIZATION
        VSTOKESI(4,2)=0.0D0
        VSTOKESI(4,3)=0.0D0

         DO ISTO=1,4
             VSTO=SQRT(
     &            VSTOKESR(ISTO,1)**2+VSTOKESI(ISTO,1)**2
     &           +VSTOKESR(ISTO,2)**2+VSTOKESI(ISTO,2)**2
     &           +VSTOKESR(ISTO,3)**2+VSTOKESI(ISTO,3)**2)
             VSTOKESR(ISTO,1)=VSTOKESR(ISTO,1)/VSTO
             VSTOKESR(ISTO,2)=VSTOKESR(ISTO,2)/VSTO
             VSTOKESR(ISTO,3)=VSTOKESR(ISTO,3)/VSTO
             VSTOKESI(ISTO,1)=VSTOKESI(ISTO,1)/VSTO
             VSTOKESI(ISTO,2)=VSTOKESI(ISTO,2)/VSTO
             VSTOKESI(ISTO,3)=VSTOKESI(ISTO,3)/VSTO

+SELF.
         ENDDO

C--- RETURN IF WLSOPT IS SELECTED

c      IF(IDISPER.EQ.0.AND.IWLSOPT.NE.0) RETURN !NUR OPTIMALEN AHW SUCHEN

C--- ADJUST SOMETHING

      IF(IJUST.NE.0) THEN
         XJUST=HSHIFT   !XJUST is adjusted by bringing YJUST to zero
         YJUST=ZF0
         CALL WLSJUST(XJUST,YJUST)
         HSHIFT=XJUST
      ENDIF

C--- CHECK CONTROL FLAGS (HBOOK FLAGS ALREADY CHECKED)

c24.3.94{ wegen efold und anderer unsicherheiten, da evtl irgendwo statements
c         wie dfreq=freq(2)-freq(1) auftauchen}

      IF (IUNIT.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'OPTION iunit DISABLED, DO NOT USE!'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'OPTION iunit DISABLED, DO NOT USE!'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

c24.3.94}

      IF (IWBPOLY3D.NE.0.AND.KBPOLY3D.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAGS IWBPOLY3D AND KBPOLY3D ARE BOTH SET'
          WRITE(LUNGFO,*)'ONLY ONE IS ALLOWED'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAGS IWBPOLY3D AND KBPOLY3D ARE BOTH SET'
          WRITE(6,*)'ONLY ONE IS ALLOWED'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IWBPOLY3D.NE.0.AND.IWBPOLY2DH.NE.0.AND.IWBPHARM.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &'MORE THAN ONE FLAG OF IWBPOLY3D,IWBPOLY2DH,IWBPHARM ARE SET'
          WRITE(LUNGFO,*)'ONLY ONE IS ALLOWED'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &'MORE THAN ONE FLAG OF IWBPOLY3D,IWBPOLY2DH,IWBPHARM ARE SET'
          WRITE(6,*)'ONLY ONE IS ALLOWED'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IWBPOLY3D.NE.0.AND.IWBMAP.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAGS IWBPOLY3D AND IWBMAP ARE BOTH SET'
          WRITE(LUNGFO,*)'ONLY ONE IS ALLOWED'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAGS IWBPOLY3D AND IWBMAP ARE BOTH SET'
          WRITE(6,*)'ONLY ONE IS ALLOWED'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IWBPOLY2DH.NE.0.AND.KBPOLY2DH.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAGS IWBPOLY2DH AND KBPOLY2DH ARE BOTH SET'
          WRITE(LUNGFO,*)'ONLY ONE IS ALLOWED'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAGS IWBPOLY2DH AND KBPOLY2DH ARE BOTH SET'
          WRITE(6,*)'ONLY ONE IS ALLOWED'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IWBPHARM.NE.0.AND.KBPHARM.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAGS IWBPHARM AND KBPHARM ARE BOTH SET'
          WRITE(LUNGFO,*)'ONLY ONE IS ALLOWED'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAGS IWBPHARM AND KBPHARM ARE BOTH SET'
          WRITE(6,*)'ONLY ONE IS ALLOWED'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IWBPOLY2DH.NE.0.AND.IWBMAP.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAGS IWBPOLY2DH AND IWBMAP ARE BOTH SET'
          WRITE(LUNGFO,*)'ONLY ONE IS ALLOWED'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAGS IWBPOLY2DH AND IWBMAP ARE BOTH SET'
          WRITE(6,*)'ONLY ONE IS ALLOWED'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IWBPHARM.NE.0.AND.IWBMAP.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAGS IWBPHARM AND IWBMAP ARE BOTH SET'
          WRITE(LUNGFO,*)'ONLY ONE IS ALLOWED'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAGS IWBPHARM AND IWBMAP ARE BOTH SET'
          WRITE(6,*)'ONLY ONE IS ALLOWED'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPEC.NE.0.AND.IEFOLD.NE.0.AND.ISTOKES.EQ.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAG IEFOLD IS SET BUT ISTOKES IS NOT'
          WRITE(LUNGFO,*)'SET ALSO FLAG ISTOKES IN INPUT FILE'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAG IEFOLD IS SET BUT ISTOKES IS NOT'
          WRITE(6,*)'SET ALSO FLAG ISTOKES IN INPUT FILE'
          WRITE(6,*)
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPEC.NE.0.AND.IDOSE.NE.0.AND.ISPECINT.EQ.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAG IDOSE IS SET BUT ISPECINT IS NOT'
          WRITE(LUNGFO,*)'SET FLAG ISPECINT IN INPUT FILE'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAG IDOSE IS SET BUT ISPECINT IS NOT'
          WRITE(6,*)'SET FLAG ISPECINT IN INPUT FILE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF
      IF (IWFILSP0.NE.0.AND.IRFILSP0.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IWFILSP0 AND IRFILSP0 ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IWFILSP0 AND IRFILSP0 ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IWFILSTO.NE.0.AND.IRFILSTO.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IWFILSTO AND IRFILSTO ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IWFILSTO AND IRFILSTO ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPECANA.NE.0.AND.IDESYNC.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS ISPECANA AND IDESYNC ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS ISPECANA AND IDESYNC ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPECANA.NE.0.AND.ISPECDIP.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS ISPECANA AND ISPECDIP ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS ISPECANA AND ISPECDIP ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPECDIP.NE.0.AND.IDESYNC.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS ISPECDIP AND IDESYNC ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS ISPECDIP AND IDESYNC ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPECANA.NE.0.AND.IRFILSP0.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS ISPECANA AND IRFILSP0 ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS ISPECANA AND IRFILSP0 ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPECDIP.NE.0.AND.IRFILSP0.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS ISPECDIP AND IRFILSP0 ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS ISPECDIP AND IRFILSP0 ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPECANA.NE.0.AND.IRFILSTO.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS ISPECANA AND IRFILSTO ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS ISPECANA AND IRFILSTO ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IUSEM.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'IUSEM IS NOT SUPPORTED ANYMORE!'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'IUSEM IS NOT SUPPORTED ANYMORE!'
          WRITE(6,*)
          stop "*** WAVE aborted ***"
      ENDIF

      IF (IUSEM.NE.0 .AND. IF1DIM.EQ.1) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IF1DIM AND IUSEM ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IF1DIM AND IUSEM ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

C     IF (IPINCIRC.NE.0 .AND. IUSEM.EQ.0) THEN
C         WRITE(LUNGFO,*)
C         WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
C         WRITE(LUNGFO,*)
C     &      'FLAG IPINCIRC IS SET BUT FLAG IUSEM IS NOT'
C         WRITE(LUNGFO,*)
C     &      'SET BOTH FLAGS TO CALCULATE FLUX THROUGH CIRCULAR PINHOLE'
C         WRITE(LUNGFO,*)
C         WRITE(6,*)
C         WRITE(6,*)'*** ERROR IN GFINIT ***'
C         WRITE(6,*)
C     &      'FLAG IPINCIRC IS SET BUT FLAG IUSEM IS NOT'
C         WRITE(6,*)
C     &      'SET BOTH FLAGS TO CALCULATE FLUX THROUGH CIRCULAR PINHOLE'
C         WRITE(6,*)
C         STOP
C     ENDIF

C     IF (ISTOKES.NE.0.AND.IPIN.NE.0  .AND. IUSEM.EQ.0) THEN
C         WRITE(LUNGFO,*)
C         WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
C         WRITE(LUNGFO,*)
C     &      'FLAG ISTOKES AND IPIN ARE SET BUT FLAG IUSEM IS NOT'
C         WRITE(LUNGFO,*)
C     &      'SET ALL THESE FLAGS TO CALCULATE STOKES VECTORS FOR PINHOLE'
C         WRITE(LUNGFO,*)
C         WRITE(6,*)
C         WRITE(6,*)'*** ERROR IN GFINIT ***'
C         WRITE(6,*)
C     &      'FLAG ISTOKES AND IPIN ARE SET BUT FLAG IUSEM IS NOT'
C         WRITE(6,*)
C     &      'SET ALL THESE FLAGS TO CALCULATE STOKES VECTORS FOR PINHOLE'
C         WRITE(6,*)
C         STOP
C     ENDIF

      IF (IEMIAHW.NE.0.AND.DDISP0.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'     FLAG IEMIAHW INCOMPATIBLE WITH DDISP0.NE.0)'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'     *** ERROR IN GFINIT ***'
          WRITE(6,*)'     FLAG IEMIAHW INCOMPATIBLE WITH DDISP0.NE.0)'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IEMIAHW.NE.0.AND.KHALBASY.EQ.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'     FLAG IEMIAHW SET BUT KHALBASY=0'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'     *** ERROR IN GFINIT ***'
          WRITE(6,*)'     FLAG IEMIAHW SET BUT KHALBASY=0'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IFOLD.NE.0.AND.IPIN.LT.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &'     FLAG IFOLD SET. FLAG IPIN MUST BE GREATER OR EQUAL ZERO'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*) '     *** ERROR IN GFINIT ***'
          WRITE(6,*)
     &'     FLAG IFOLD SET. FLAG IPIN MUST BE GREATER OR EQUAL ZERO'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ispec.ne.0.and.IFOLD.NE.0.AND.ISIGUSR.EQ.0.AND.IEMIT.EQ.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &       '     FLAG ISIGUSR NOT SET. THIS REQUIRES FLAG IEMIT TO BE SET'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*) '     *** ERROR IN GFINIT ***'
          WRITE(6,*)
     &       '     FLAG ISIGUSR NOT SET. THIS REQUIRES FLAG IEMIT TO BE SET'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF(NDWSOU.LT.NDARGU) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     *** ERROR IN IN GFINIT ***'
          WRITE(LUNGFO,*)'     PARAMETER NDWSOUP.LT.NDWARGUP'
          WRITE(LUNGFO,*)'     LOOK AT FILE CMPARA.CMN'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'     *** ERROR IN IN GFINIT ***'
          WRITE(6,*)'     PARAMETER NDWSOUP.LT.NDWARGUP'
          WRITE(6,*)'     LOOK AT FILE CMPARA.CMN'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

C- B-FIELD

      IF (IWSECTMAGS.LT.0) THEN
        JWSECTMAGS=1
      ELSE
        JWSECTMAGS=0
      ENDIF

      KSUM=
     &      KBEXTERN**2
     &      +KBAMWLS**2
     &      +KHALBA**2
     &      +KBFELD**2
     &      +ibmasksp**2
     &      +KHALBASY**2
     &      +KUNDUGAP**2
     &      +IRFILF**2
     &      +IRBTAB**2
     &      +IFOURBTABZY**2
     &      +IRBTABZY**2
     &      +IRBTABXYZ**2
     &      +KUCROSS**2
     &      +KELLIP**2
     &      +KELLANA**2
     &      +KBREC**2
     &      +KBGENESIS**2
     &      +IRFILP**2
     &      +KMAGSEQ**2
     &      +IBHELM**2
     &      +KBPOLYH**2
     &      +KBPOLY3D**2
     &      +KBPOLY2DH**2
     &      +KBPHARM**2
     &      +IRFILB0**2
     &      +IRFILB**2
     &      +JWSECTMAGS

      IF (kbundumag.ne.0) KSUM=KSUM+1
      IF (KBPOLYMAG.GT.0) KSUM=KSUM+1

      IF (KSUM.LT.1) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     *** Warning in GFINIT ***'
        WRITE(LUNGFO,*)'     No magnetic field specified'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)
        WRITE(6,*)'     *** Warning in GFINIT ***'
        WRITE(6,*)'     No magnetic field specified'
        WRITE(6,*)
c        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IBSUPER.EQ.0) THEN

      IAMBI=0

      IF (KBEXTERN .NE.0) IAMBI=IAMBI+1
      IF (KBAMWLS .NE.0) IAMBI=IAMBI+1
      IF (KHALBA  .NE.0) IAMBI=IAMBI+1
      IF (KBFELD  .NE.0) IAMBI=IAMBI+1
      IF (KHALBASY.NE.0) IAMBI=IAMBI+1
      IF (KUNDUGAP.NE.0) IAMBI=IAMBI+1
      IF (IRFILF  .NE.0) IAMBI=IAMBI+1
      IF (IRFILB .NE.0) IAMBI=IAMBI+1
      IF (IRBTAB  .NE.0) IAMBI=IAMBI+1
      IF (IFOURBTABZY.NE.0) IAMBI=IAMBI+1
      IF (IRBTABZY.NE.0) IAMBI=IAMBI+1
      IF (IRBTABXYZ.NE.0) IAMBI=IAMBI+1
      IF (KUCROSS .NE.0) IAMBI=IAMBI+1
      IF (KELLIP  .NE.0) IAMBI=IAMBI+1
      IF (KELLANA .NE.0) IAMBI=IAMBI+1
      IF (KBREC   .gt.0) IAMBI=IAMBI+1
      IF (kbundumag.ne.0) IAMBI=IAMBI+1
      IF (KBPOLYMAG.GT.0) IAMBI=IAMBI+1
      IF (KBGENESIS.GT.0) IAMBI=IAMBI+1
      IF (KBPOLYH .NE.0) IAMBI=IAMBI+1
      IF (KBPOLY3D .NE.0)IAMBI=IAMBI+1
      IF (KBPOLY2DH .NE.0)IAMBI=IAMBI+1
      IF (KBPHARM .NE.0)IAMBI=IAMBI+1
      IF (IRFILP  .NE.0) IAMBI=IAMBI+1
      IF (IRFILB0 .NE.0) IAMBI=IAMBI+1
      IF (IBHELM  .NE.0) IAMBI=IAMBI+1
      IF (IMAGSPLN.GT.0) IAMBI=IAMBI+1
      IF (KMAGSEQ.GT.0) IAMBI=IAMBI+1
      IF (IWSECTMAGS.LT.0) IAMBI=IAMBI+1
      IF (IAMBI.GT.1) THEN
      IF (ibmasksp.LT.0) IAMBI=IAMBI+1
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
      WRITE(LUNGFO,*)'     MAGNETIC FIELD AMBIGIOUSLY SPECIFIED'
      WRITE(LUNGFO,*)'     CHECK FIELD SELECTION AND IBMASKSP'
      WRITE(LUNGFO,*)
      WRITE(6,*)
      WRITE(6,*)
      WRITE(6,*)'     *** ERROR IN GFINIT ***'
      WRITE(6,*)'     MAGNETIC FIELD AMBIGIOUSLY SPECIFIED'
      WRITE(6,*)'     CHECK FIELD SELECTION AND IBMASKSP'
      WRITE(6,*)
      STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      ENDIF !IBSUPER

C- ANALYTICALLY DEFINED GENERATING FUNCTION

      IAMBI=0
      IF (IERZFUN.NE.0) IAMBI=IAMBI+1
      IF (IERZANA.NE.0) IAMBI=IAMBI+1
      IF (IAMBI.GT.1) THEN
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
      WRITE(LUNGFO,*)'     FLAGS IERZRANA AND IERZFUN COLLIDE'
      WRITE(LUNGFO,*)'     SET ONLY ONE'
      WRITE(LUNGFO,*)
      WRITE(6,*)
      WRITE(6,*)
      WRITE(6,*)'     *** ERROR IN GFINIT ***'
      WRITE(6,*)'     FLAGS IERZRANA AND IERZFUN COLLIDE'
      WRITE(6,*)'     SET ONLY ONE'
      WRITE(6,*)
      STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

C- FOURIER-TRANSFORMATION

      IAMBI=0
      IF (IRFILF.NE.0) IAMBI=IAMBI+1
      IF (IWFILF.NE.0) IAMBI=IAMBI+1
      IF (IAMBI.GT.1) THEN
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
      WRITE(LUNGFO,*)'     FLAGS IRFILF AND IWFILF COLLIDE'
      WRITE(LUNGFO,*)'     SET ONLY ONE'
      WRITE(LUNGFO,*)
      WRITE(6,*)
      WRITE(6,*)
      WRITE(6,*)'     *** ERROR IN GFINIT ***'
      WRITE(6,*)'     FLAGS IRFILF AND IWFILF COLLIDE'
      WRITE(6,*)'     SET ONLY ONE'
      WRITE(6,*)
      STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

C--- DEFAULT VALUES

C030414      IF (XINTER.EQ.9999..AND.IBSUPER.EQ.0) THEN

C--- CALCULATE FOURIER-COEFFIZIENTS OF B-FIELD FOR SEQUENCE OF MAGNETS

      IF (KMAGSEQ.NE.0.AND.IMGSQF.NE.0) THEN

        xstarto=xstart
        idum=imgsqf
        if (xstart.eq.9999.) then
          imgsqf=0
          CALL bmagseq(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=bmsqbounds(1)
          imgsqf=idum
c          print*
c          print*,"*** Error in GFINIT: Default 9999 not allowed for XSTART for IMGSQF not zero"
c          print*
c          IABEND=8
c          goto 9999
        endif

        if (xstop.eq.9999.) then
          imgsqf=0
          if (xstopo.ne.9999.) then
            CALL bmagseq(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          endif
          XSTOP=bmsqbounds(2)
c          print*
c          print*,"*** Error in GFINIT: Default 9999 not allowed for XSTOP for IMGSQF not zero"
c          print*
c          IABEND=8
c          goto 9999
        endif
        imgsqf=idum

        ISTORE=IWFILF
        IWFILF=99
        BSTORE=B0SCGLOB
        btapv=btaperv
        btaph=btaperh
        btaperv=0.0d0
        btaperh=0.0d0
        ASTORE=A0SCGLOB
        BSTOREY=B0SCGLOBY
        ASTOREY=A0SCGLOBY
        BSTOREZ=B0SCGLOBZ
        ASTOREZ=A0SCGLOBZ
        BSTORE2=BYGOFF
        BSTORE2Z=BZGOFF
        B0SCGLOB=1.0D0
        A0SCGLOB=1.0D0
        B0SCGLOBY=1.0D0
        A0SCGLOBY=1.0D0
        B0SCGLOBZ=1.0D0
        A0SCGLOBZ=1.0D0
        BYGOFF=0.0
        BZGOFF=0.0

        CALL FOURWLS

        IWFILF=ISTORE
        btaperh=btaph
        btaperv=btapv
        A0SCGLOB=ASTORE
        B0SCGLOB=BSTORE
        A0SCGLOBY=ASTOREY
        B0SCGLOBY=BSTOREY
        A0SCGLOBZ=ASTOREZ
        B0SCGLOBZ=BSTOREZ
        BYGOFF=BSTORE2
        BZGOFF=BSTORE2Z

      ENDIF

      IF (KHALBASY.NE.0.and.mod(nint(ahwpol),2).eq.0) THEN
        print*,"*** WARNING: AHWPOL should be odd, or be aware of strange results ***"
        write(lungfo,*)"*** WARNING: AHWPOL should be odd, or be aware of strange results ***"
      endif

      IF (XINTER.EQ.9999.) THEN

        XSTARTO=XSTART

        IF (KHALBA.NE.0) THEN
          CALL BHALBA(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=-ZLENHAL/2.0D0
        ELSE IF (KBFELD.NE.0) THEN
          CALL MYBFELD(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=XLIM(1)
          IF (IKBFORM.NE.0) XINTER=-XP5
        ELSE IF (KHALBASY.NE.0) THEN
          CALL BHALBASY(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          IF (FASYM.NE.2.0D0) THEN
            XINTER=-ZLHALBASY*(AHWPOL+FASYM)/4.0D0+xcenhal
          ELSE
            XINTER=-ZLHALBASY*((AHWPOL-1.0D0)/2.0D0+1.0D0)/2.+xcenhal
          ENDIF
        ELSE IF (KUNDUGAP.NE.0) THEN
          CALL BUNDUGAP(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM,-1)
          XINTER=-ZLUNDUGAP*((UNDUGAPPOL-1.0D0)/2.0D0+1.0D0)/2.+xcenUNDUGAP
        ELSE IF (IRFILF.eq.1) THEN
          CALL BFOUR(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=-DEVLEN2
        ELSE IF (IFOURBTABZY.NE.0) THEN
          CALL BFOURTABZY(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=XSTART
        ELSE IF (IRBTAB.NE.0) THEN
          CALL BTAB(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=XSTART
        ELSE IF (IRBTABZY.NE.0) THEN
          CALL BTABZY(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=XSTART
        ELSE IF (IRBTABXYZ.NE.0) THEN
          CALL BTABXYZ(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=XSTART
        ELSE IF (KUCROSS.NE.0) THEN
          CALL BUCROSS(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=ULIMI(1)
        ELSE IF (KELLIP.NE.0) THEN
          CALL BELLIP(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          Xinter=-(perellip*xlellip+ellshft*xlellip)/2.0d0+xcenell
        ELSE IF (KELLANA.NE.0) THEN
          CALL BELLANA(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=-HLENELL
        ELSE IF (KBPOLYH.NE.0) THEN
          CALL BPHARM(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
        ELSE IF (KBPOLY3D.NE.0) THEN
          CALL BPOLY3D(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=X3DMIN
        ELSE IF (KBPOLY2DH.NE.0) THEN
          CALL BPOLY2DH(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=X2DHMIN
        ELSE IF (KBPOLY2DH.NE.0) THEN
          CALL BPHARM(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=XPHMIN
        ELSE IF (KBREC.gt.0) THEN
          CALL REC_INIT
        ELSE IF (kbundumag.ne.0) THEN
          muthreads=mthreads
          if (kbundumag.eq.2.or.kbundumag.eq.4) then
            uebeam=dmyenergy
            kwrun=icode
            chwcom=code
            call run_undumag(kbundumag,lungfo)
          else  if (kbundumag.lt.0) then
            call run_undumag(kbundumag,lungfo)
          endif
          CALL bundumag_ini(XSTART,XSTOP,LUNGFO)
        ELSE IF (KBPOLYMAG.GT.0) THEN
          CALL BPOLYINI(XSTART,XSTOP,LUNGFO)
        ELSE IF (KBGENESIS.NE.0) THEN
          CALL BGENESIS(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=GSTOTLEN/2.0D0
        ELSE IF (IRFILB0.EQ.-4) THEN
          CALL BMESSINI4
        ELSE IF (IRFILB0.NE.0.and.abs(irfilb0).ne.6) THEN
          CALL BMESSINI
        ELSE IF (IWSECTMAGS.LT.0) THEN
          CALL BSECTMAGS(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=XSTART
        ENDIF !xinter

        IF (XINTER.EQ.9999.) THEN

          WRITE (LUNGFO,*)
          WRITE (LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE (LUNGFO,*)'DEFAULT 9999. NOT ALLOWED HERE FOR XINTER '
          WRITE (LUNGFO,*)
          WRITE (6,*)
          WRITE (6,*)'*** ERROR IN GFINIT ***'
          WRITE (6,*)'DEFAULT 9999. NOT ALLOWED HERE FOR XINTER '
          WRITE (6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'

        ENDIF !xinter

        XSTART=XSTARTO

      ENDIF !XINTER.EQ.9999.

      XSTOPO=XSTOP

C030414      IF (XSTART.EQ.9999..AND.IBSUPER.EQ.0) THEN
      IF (XSTART.EQ.9999.) THEN

        XSTARTO=XSTART

        IF (KHALBA.NE.0) THEN
          CALL BHALBA(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=-ZLENHAL/2.0D0
        ELSE IF (kmagseq.NE.0) THEN
          CALL bmagseq(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=bmsqbounds(1)
        ELSE IF (KBFELD.NE.0) THEN
          CALL MYBFELD(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=XLIM(1)
          IF (IKBFORM.NE.0) XSTART=-XP5
        ELSE IF (KHALBASY.NE.0) THEN
          CALL BHALBASY(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          IF (FASYM.NE.2.0D0) THEN
            XSTART=-ZLHALBASY*(AHWPOL+FASYM)/4.0D0+xcenhal
          ELSE
            XSTART=-ZLHALBASY*((AHWPOL-1.0D0)/2.0D0+1.0D0)/2.+xcenhal
          ENDIF
        ELSE IF (KUNDUGAP.NE.0) THEN
          CALL BUNDUGAP(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM,-2)
          XSTART=-ZLUNDUGAP*((UNDUGAPPOL-1.0D0)/2.0D0+1.0D0)/2.+xcenUNDUGAP
        ELSE IF (IRFILF.eq.1) THEN
          CALL BFOUR(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=-DEVLEN2
        ELSE IF (IFOURBTABZY.NE.0) THEN
          CALL BFOURTABZY(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=XSTART
        ELSE IF (IRBTAB.NE.0) THEN
          CALL BTAB(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
        ELSE IF (IRBTABZY.NE.0) THEN
          CALL BTABZY(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=XSTART
        ELSE IF (IRBTABXYZ.NE.0) THEN
          CALL BTABXYZ(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=XSTART
        ELSE IF (KUCROSS.NE.0) THEN
          CALL BUCROSS(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=ULIMI(1)
        ELSE IF (KELLIP.NE.0) THEN
          CALL BELLIP(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=-(perellip*xlellip+ellshft*xlellip)/2.0d0+xcenell
        ELSE IF (KELLANA.NE.0) THEN
          CALL BELLANA(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=-HLENELL
        ELSE IF (KBPOLYH.NE.0) THEN
          CALL BPHARM(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
        ELSE IF (KBPOLY3D.NE.0) THEN
          CALL BPOLY3D(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=X3DMIN
        ELSE IF (KBPOLY2DH.NE.0) THEN
          CALL BPOLY2DH(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=X2DHMIN
        ELSE IF (KBPOLY2DH.NE.0) THEN
          CALL BPHARM(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=XPHMIN
        ELSE IF (KBREC.gt.0) THEN
          CALL REC_INIT
        ELSE IF (kbundumag.ne.0) THEN
          muthreads=mthreads
          if (kbundumag.eq.2.or.kbundumag.eq.4) then
            uebeam=dmyenergy
            uebeam_h=dmyenergy
            kwrun=icode
            chwcom=code
            call run_undumag(kbundumag,lungfo)
          else  if (kbundumag.lt.0) then
            call run_undumag(kbundumag,lungfo)
          endif
          CALL bundumag_ini(XSTART,XSTOP,LUNGFO)
        ELSE IF (KBPOLYMAG.GT.0) THEN
          CALL BPOLYINI(XSTART,XSTOP,LUNGFO)
        ELSE IF (KBGENESIS.NE.0) THEN
          XSTART=0.0D0
        ELSE IF (IRFILB0.EQ.-4) THEN
          CALL BMESSINI4
        ELSE IF (abs(IRFILB0).EQ.6) THEN
          bxdum=-9999.0d0
          CALL BMAP(axdum,aydum,azdum,bxdum,bydum,bzdum)
          xstart=axdum
        ELSE IF (IRFILB0.NE.0) THEN
          CALL BMESSINI
        ELSE IF (IWSECTMAGS.LT.0) THEN
          CALL BSECTMAGS(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
        ENDIF

        IF (XSTART.EQ.9999.) THEN

          WRITE (LUNGFO,*)
          WRITE (LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE (LUNGFO,*)'DEFAULT NOT ALLOWED HERE FOR XSTART '
          WRITE (LUNGFO,*)
          WRITE (6,*)
          WRITE (6,*)'*** ERROR IN GFINIT ***'
          WRITE (6,*)'DEFAULT NOT ALLOWED HERE FOR XSTART '
          WRITE (6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'

        ENDIF

      ENDIF !XSTART.EQ.9999.

C030414      IF (XSTOP.EQ.9999..AND.IBSUPER.EQ.0) THEN
      IF (XSTOP.EQ.9999.) THEN

        IF (KHALBA.NE.0) THEN
          CALL BHALBA(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=ZLENHAL/2.0D0
        ELSE IF (kmagseq.NE.0) THEN
          CALL bmagseq(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=bmsqbounds(2)
        ELSE IF (KBFELD.NE.0) THEN
          XSTOP=XLIM(12)
          IF (IKBFORM.NE.0) XSTOP=-XSTART
        ELSE IF (KHALBASY.NE.0) THEN
          CALL BHALBASY(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          IF (FASYM.NE.2.0D0) THEN
            XSTOP=ZLHALBASY*(AHWPOL+FASYM)/4.0D0+xcenhal
          ELSE
            XSTOP=ZLHALBASY*((AHWPOL-1.0D0)/2.0D0+1.0D0)/2.+xcenhal
          ENDIF
        ELSE IF (KUNDUGAP.NE.0) THEN
          CALL BUNDUGAP(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM,-3)
          XSTOP=ZLUNDUGAP*((UNDUGAPPOL-1.0D0)/2.0D0+1.0D0)/2.+xcenUNDUGAP
        ELSE IF (IRFILF.eq.1) THEN
          CALL BFOUR(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=DEVLEN2
        ELSE IF (IFOURBTABZY.NE.0) THEN
          CALL BFOURTABZY(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=XSTOP
        ELSE IF (IRBTAB.NE.0) THEN
          CALL BTAB(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
        ELSE IF (IRBTABZY.NE.0) THEN
          CALL BTABZY(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=XSTOP
        ELSE IF (IRBTABXYZ.NE.0) THEN
          CALL BTABXYZ(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=XSTOP
        ELSE IF (KUCROSS.NE.0) THEN
          CALL BUCROSS(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=ULIMI(4)
        ELSE IF (KELLIP.NE.0) THEN
          CALL BELLIP(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XStop=(perellip*xlellip+ellshft*xlellip)/2.0d0+xcenell
        ELSE IF (KELLANA.NE.0) THEN
          CALL BELLANA(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=HLENELL
        ELSE IF (KBPOLYH.NE.0) THEN
          CALL BPHARM(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
        ELSE IF (KBPOLY3D.NE.0) THEN
          CALL BPOLY3D(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=X3DMAX
        ELSE IF (KBPOLY2DH.NE.0) THEN
          CALL BPOLY2DH(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=X2DHMAX
        ELSE IF (KBPHARM.NE.0) THEN
          CALL BPHARM(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=XPHMAX
        ELSE IF (KBREC.gt.0) THEN
          CALL REC_INIT
        ELSE IF (kbundumag.ne.0) THEN
          muthreads=mthreads
          if (kbundumag.eq.2.or.kbundumag.eq.4) then
            uebeam=dmyenergy
            uebeam_h=dmyenergy
            kwrun=icode
            chwcom=code
            call run_undumag(kbundumag,lungfo)
          else  if (kbundumag.lt.0) then
            call run_undumag(kbundumag,lungfo)
          endif
          CALL bundumag_ini(XSTART,XSTOP,LUNGFO)
        ELSE IF (KBPOLYMAG.GT.0) THEN
          CALL BPOLYINI(XSTART,XSTOP,LUNGFO)
        ELSE IF (abs(IRFILB0).EQ.6) THEN
          bxdum=9999.0d0
          CALL BMAP(axdum,aydum,azdum,bxdum,bydum,bzdum)
          xstop=axdum
        ELSE IF (IRFILB0.EQ.-4) THEN
          CALL BMESSINI4
        ELSE IF (IRFILB0.NE.0.and.abs(irfilb0).ne.6) THEN
          CALL BMESSINI
        ELSE IF (KBGENESIS.NE.0) THEN
          CALL BGENESIS(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=GSTOTLEN
        ELSE IF (IWSECTMAGS.LT.0) THEN
          CALL BSECTMAGS(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
        ENDIF

        if (xstop.eq.9999.) then
          WRITE (LUNGFO,*)
          WRITE (LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE (LUNGFO,*)'DEFAULT NOT ALLOWED HERE FOR XSTOP '
          WRITE (LUNGFO,*)
          WRITE (6,*)
          WRITE (6,*)'*** ERROR IN GFINIT ***'
          WRITE (6,*)'DEFAULT NOT ALLOWED HERE FOR XSTOP '
          WRITE (6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF

      ENDIF !XSTOP.EQ.9999.

      if (ibunduini.eq.0.and.kbundumag.ne.0) then
          muthreads=mthreads
          if (kbundumag.eq.2.or.kbundumag.eq.4) then
            uebeam=dmyenergy
            uebeam_h=dmyenergy
            kwrun=icode
            chwcom=code
            call run_undumag(kbundumag,lungfo)
          else  if (kbundumag.lt.0) then
            call run_undumag(kbundumag,lungfo)
          endif
          CALL bundumag_ini(XSTART,XSTOP,LUNGFO)
      endif

      IF (IPERIODG.NE.0.AND.XSTOPO.EQ.9999.) THEN
        XSTOP=XSTOP+(XPERWMX-XPERWMN)
      ENDIF

      IF (IBSYM.NE.0.AND.XSTARTO.EQ.9999.) XSTART=-XSTOP

      IF (XSTARTO.EQ.9999.) XSTART=XSTART-XSHIFT
      IF (XSTOPO.EQ.9999.) XSTOP=XSTOP-XSHIFT

      IF (XSTART.EQ.XSTOP) THEN
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT: XSTART=XSTOP ***'
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
        WRITE(6,*)'*** ERROR IN GFINIT: XSTART=XSTOP ***'
        WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
        STOP
      ENDIF

      if (xtaper.eq.9999.0d0) xtaper=xstart

      IF (NSTEPMX.EQ.0) THEN
        NSTEPMX=NWMAXP
      ELSE IF (NSTEPMX.LT.0) THEN
        NSTEPMX=(XSTOP-XSTART)*MYINUM*2.*(-NSTEPMX)
      ENDIF
      IF (NSTEPMX.LE.0) THEN
        NSTEPMX=NWMAXP
      ENDIF
      NWMAX=NSTEPMX

      IF (NPOLMX.EQ.0) NPOLMX=NDPOLP
      NDPOL=NPOLMX

      CALL MYBFELD(XSTART,YSTART,ZSTART,
     &  BXSTART,BYSTART,BZSTART,
     &  AXSTART,AYSTART,AZSTART)


      IF (VXIN.EQ.0.0D0.AND.VYIN.EQ.0.0D0.AND.VZIN.EQ.0.0D0) VXIN=1.0D0

      IF (XINTER.NE.XSTART.AND.XINTER.NE.-9999.) THEN

        YSTARTO=YSTART
        ZSTARTO=ZSTART

        VXINO=VXIN
        VYINO=VYIN
        VZINO=VZIN

        VN=1.0D0/DSQRT(VXIN**2+VYIN**2+VZIN**2)
        VXIN=VXIN*VN
        VYIN=VYIN*VN
        VZIN=VZIN*VN

        BETX0=VXIN*BETA
        BETY0=VYIN*BETA
        BETZ0=VZIN*BETA

        X0=XSTART
        Y0=YSTART
        Z0=ZSTART

        VX0=VXIN*V0
        VY0=VYIN*V0
        VZ0=VZIN*V0

        IF (XINTER.GT.XSTART) THEN

          BYDUM=B0SCGLOB
          B0SCGLOB=-B0SCGLOB
          btaperv=-btaperv
          btaperh=-btaperh

          CALL TRACKSHORT(ISNORDER,XINTER,Y0,Z0,-VX0,-VY0,-VZ0,
     &      XSTART,0.0D0,0.0D0,-1.0D0,0.0D0,0.0D0,
     &      XF0,YF0,ZF0,dtshort,VXF0,VYF0,VZF0,DTIM,BSHIFT,GAMMA,BMOVECUT,
     &      IUSTEP,IENELOSS,GAMMAL)

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Result of back-tracking due to XINTER:'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     x:',XF0
          WRITE(LUNGFO,*)'     y:',YF0
          WRITE(LUNGFO,*)'     z:',ZF0
          WRITE(LUNGFO,*)'     vx:',-VXF0
          WRITE(LUNGFO,*)'     vy:',-VYF0
          WRITE(LUNGFO,*)'     vz:',-VZF0
          WRITE(LUNGFO,*)'     yp:',VYF0/VXF0
          WRITE(LUNGFO,*)'     zp:',VZF0/VXF0
          WRITE(LUNGFO,*)

          B0SCGLOB=BYDUM
          btaperv=-btaperv
          btaperh=-btaperh
          XSTART=XF0
          YSTART=YF0
          ZSTART=ZF0
          VXIN=-VXF0
          VYIN=-VYF0
          VZIN=-VZF0

          GAMMA=GAMMA-GAMMAL !We gain energy here, and gammal is negative!
          DMYGAMMA=GAMMA
          DMYENERGY=GAMMA*EMASSG1

          ENERGV=GAMMA*EMASSE1
          GMOM=EMASSG1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
          EMOM=EMASSE1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
          DBRHO=ICHARGE*EMOM/CLIGHT1
          BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
          DMYBETA=BETA
          V0=CLIGHT1*BETA

        ELSE   !XINTER.GT.XSTART

          CALL TRACKSHORT(ISNORDER,XINTER,Y0,Z0,VX0,VY0,VZ0,
     &      XSTART,0.0D0,0.0D0,1.0D0,0.0D0,0.0D0,
     &      XF0,YF0,ZF0,dtshort,VXF0,VYF0,VZF0,DTIM,BSHIFT,GAMMA,BMOVECUT,
     &      IUSTEP,IENELOSS,GAMMAL)

          XSTART=XF0
          YSTART=YF0
          ZSTART=ZF0
          VXIN=VXF0
          VYIN=VYF0
          VZIN=VZF0

          GAMMA=GAMMA+GAMMAL !We lose energy here!
          DMYGAMMA=GAMMA
          DMYENERGY=GAMMA*EMASSG1

          ENERGV=GAMMA*EMASSE1
          GMOM=EMASSG1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
          EMOM=EMASSE1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
          DBRHO=ICHARGE*EMOM/CLIGHT1
          BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
          DMYBETA=BETA
          V0=CLIGHT1*BETA

        ENDIF  !XINTER.GT.XSTART

      ENDIF !(XINTER.NE.-9999.)

c20aug09      ROIX(1)=XSTART
c20aug09      ROIX(NROIA)=XSTOP

      IF (XSTART.LT.ROIX(1)) THEN
        WRITE(LUNGFO,*)
     &    '*** ERROR IN NAMELIST ROIN: XSTART < ROIX(1)'
        WRITE(6,*)
     &    '*** ERROR IN NAMELIST ROIN: XSTART < ROIX(1)'
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF !(XSTART.LT.ROIX(1))

      IF (XSTOP.GT.ROIX(NROIA)) THEN
        WRITE(LUNGFO,*)
     &    '*** ERROR IN NAMELIST ROIN: XSTOP GREATER THAN LAST ROI-BOUNDARY'
        WRITE(6,*)
     &    '*** ERROR IN NAMELIST ROIN: XSTOP GREATER THAN LAST ROI-BOUNDARY'
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF !(XSTART.GT.ROIX(1))

      IF (XIANF.EQ.9999.) XIANF=-1.0D30
      IF (XIEND.EQ.9999.) XIEND=1.0D30

      if (iexpert.ne.0) then
        xianf=-1.0d30
        xiend=1.0d30
      endif

      IF (XIANF.EQ.XIEND) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN GFINIT: XIANF=XIEND ***'
        WRITE(LUNGFO,*)'*** SET TO XSTART/XSTOP ***'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN GFINIT: XIANF=XIEND ***'
        WRITE(6,*)'*** SET TO XSTART/XSTOP ***'
        WRITE(6,*)
        XIANF=XSTART
        XIEND=XSTOP
      ENDIF

C--- B-FIELD FROM PANDIRA

      IF (IRFILP.NE.0) CALL READBP

C--- CALCULATE FOURIER-COEFFICIENTS OF B-FIELD AND EXIT

      IF (IWFILF.NE.0) THEN
        CALL FOURWLS
        IABEND=1
        goto 9999
      ENDIF

C--- FIND DEFAULTS FOR VXIN,VYIN,VZIN IF NECESSARY

      IF (VYIN.EQ.9999..AND.VZIN.EQ.9999.) THEN

        VXIN=1.0D0
        VYIN=0.0D0
        VZIN=0.0D0

        BETX0=VXIN*BETA
        BETY0=VYIN*BETA
        BETZ0=VZIN*BETA

        X0=XSTART
        Y0=YSTART
        Z0=ZSTART

        VX0=VXIN*V0
        VY0=VYIN*V0
        VZ0=VZIN*V0

        CALL TRACKSHORT(ISNORDER,X0,Y0,Z0,VX0,VY0,VZ0,
     &    XSTART+PERIODG,0.0D0,0.0D0,1.0D0,0.0D0,0.0D0,
     &    XF0,YF0,ZF0,dtshort,VXF0,VYF0,VZF0,DTIM,BSHIFT,GAMMA,BMOVECUT,
     &    IUSTEP,IENELOSS,GAMMAL)

        GAMMA=GAMMA-GAMMAL !We lose energy here!
        DMYGAMMA=GAMMA
        DMYENERGY=GAMMA*EMASSG1

        ENERGV=GAMMA*EMASSE1
        GMOM=EMASSG1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
        EMOM=EMASSE1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
        DBRHO=ICHARGE*EMOM/CLIGHT1
        BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
        DMYBETA=BETA
        V0=CLIGHT1*BETA

        YP=-YF0/PERIODG
        ZP=-ZF0/PERIODG

        VXIN=V0/DSQRT(1.0D0+ZP*ZP+YP*YP)
        VYIN=YP*VXIN
        VZIN=ZP*VXIN

      ELSE IF (VYIN.EQ.9999.) THEN

        VYIN=0.0D0
        VN=1.0D0/DSQRT(VXIN**2+VYIN**2+VZIN**2)
        VXIN=VXIN*VN
        VYIN=VYIN*VN
        VZIN=VZIN*VN

        BETX0=VXIN*BETA
        BETY0=VYIN*BETA
        BETZ0=VZIN*BETA

        X0=XSTART
        Y0=YSTART
        Z0=ZSTART

        VX0=VXIN*V0
        VY0=VYIN*V0
        VZ0=VZIN*V0

        CALL TRACKSHORT(ISNORDER,X0,Y0,Z0,VX0,VY0,VZ0,
     &    XSTART+PERIODG,0.0D0,0.0D0,1.0D0,0.0D0,0.0D0,
     &    XF0,YF0,ZF0,dtshort,VXF0,VYF0,VZF0,DTIM,BSHIFT,GAMMA,BMOVECUT,
     &    IUSTEP,IENELOSS,GAMMAL)

        GAMMA=GAMMA+GAMMAL !We loose energy here!
        DMYGAMMA=GAMMA
        DMYENERGY=GAMMA*EMASSG1

        ENERGV=GAMMA*EMASSE1
        GMOM=EMASSG1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
        EMOM=EMASSE1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
        DBRHO=ICHARGE*EMOM/CLIGHT1
        BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
        DMYBETA=BETA
        V0=CLIGHT1*BETA

        YP=-YF0/PERIODG
        ZP=VZIN/VXIN

        VXIN=V0/DSQRT(1.0D0+ZP*ZP+YP*YP)
        VYIN=YP*VXIN
        VZIN=ZP*VXIN

      ELSE IF (VZIN.EQ.9999.) THEN

        VZIN=0.0D0
        VN=1.0D0/DSQRT(VXIN**2+VYIN**2+VZIN**2)
        VXIN=VXIN*VN
        VYIN=VYIN*VN
        VZIN=VZIN*VN

        BETX0=VXIN*BETA
        BETY0=VYIN*BETA
        BETZ0=VZIN*BETA

        X0=XSTART
        Y0=YSTART
        Z0=ZSTART

        VX0=VXIN*V0
        VY0=VYIN*V0
        VZ0=VZIN*V0

        CALL TRACKSHORT(ISNORDER,X0,Y0,Z0,VX0,VY0,VZ0,
     &    XSTART+PERIODG,0.0D0,0.0D0,1.0D0,0.0D0,0.0D0,
     &    XF0,YF0,ZF0,dtshort,VXF0,VYF0,VZF0,DTIM,BSHIFT,GAMMA,BMOVECUT,
     &    IUSTEP,IENELOSS,GAMMAL)

        GAMMA=GAMMA+GAMMAL !We lose energy here!
        DMYGAMMA=GAMMA
        DMYENERGY=GAMMA*EMASSG1

        ENERGV=GAMMA*EMASSE1
        GMOM=EMASSG1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
        EMOM=EMASSE1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
        DBRHO=ICHARGE*EMOM/CLIGHT1
        BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
        DMYBETA=BETA
        V0=CLIGHT1*BETA

        ZP=-ZF0/PERIODG
        YP=VYIN/VXIN

        VXIN=V0/DSQRT(1.0D0+ZP*ZP+YP*YP)
        VYIN=YP*VXIN
        VZIN=ZP*VXIN

      ENDIF !VYIN.EQ.9999..AND.VZIN.EQ.9999.

      xstartP=XSTART
      ystartP=YSTART
      zstartP=ZSTART

      vxinP=VXIN
      vyinP=VYIN
      vzinP=VZIN

C--- TRACK REFERENCE ORBIT FROM XSTART TO XSTOP

C-   NORMALIZE VELOCITY

      VN=1.0D0/DSQRT(VXIN**2+VYIN**2+VZIN**2)
      VXIN=VXIN*VN
      VYIN=VYIN*VN
      VZIN=VZIN*VN

      BETX0=VXIN*BETA
      BETY0=VYIN*BETA
      BETZ0=VZIN*BETA

      X0=XSTART
      Y0=YSTART
      Z0=ZSTART

      VX0=VXIN*V0
      VY0=VYIN*V0
      VZ0=VZIN*V0

      if (xstart.ge.xstop) then
        write(lungfo,*)"*** Error in subroutine gfinit: XSTART >= XSTOP ***"
        write(6,*)"*** Error in subroutine gfinit: XSTART >= XSTOP ***"
        stop "*** Program WAVE aborted ***"
      endif

      CALL TRACK(X0,Y0,Z0,VX0,VY0,VZ0,
     &  XSTOP,0.0D0,0.0D0,1.0D0,0.0D0,0.0D0,
     &  XF0,YF0,ZF0,VXF0,VYF0,VZF0,DTIM,BSHIFT,GAMMA,GAMMAL)
      t0track=wtim0(1)
      tftrack=wtim0(nco)

      CALL TRACEN(0.0D0,YCEN,ZCEN,YPCEN,ZPCEN)
      CALL TRACEN(XIANF,YIANF,ZIANF,YPIANF,ZPIANF)
      CALL TRACEN(XIEND,YIEND,ZIEND,YPIEND,ZPIEND)

      !if (eps0h.eq.0.0d0) eps0h=bsigz(1)*bsigzp(1)
      !if (eps0v.eq.0.0d0) eps0v=bsigy(1)*bsigyp(1)

      IF (betfun.EQ.0.0d0) THEN
        if (eps0h.eq.0.0d0) then
          write(lungfo,*)
     &      '*** Error in GFINIT: EPS0H and BETFUN are zero'
          write(lungfo,*)
     &      '*** Error in GFINIT: Please check namelists DEPOLA and WFOLDN'
          write(6,*)
     &      '*** Error in GFINIT: EPS0H and BETFUN are zero'
          write(6,*)
     &      '*** Error in GFINIT: Please check namelists DEPOLA and WFOLDN'
          stop '*** Program WAVE aborted ***'
        endif
        betfun=bsigz(1)**2/eps0h
      endif

      IF (betfunv.EQ.0.0d0) THEN
        if (eps0v.eq.0.0d0) then
          write(lungfo,*)
     &      '*** Error in GFINIT: EPS0V and BETFUN are zero'
          write(lungfo,*)
     &      '*** Error in GFINIT: Please check namelists DEPOLA and WFOLDN'
          write(6,*)
     &      '*** Error in GFINIT: EPS0V and BETFUN are zero'
          write(6,*)
     &      '*** Error in GFINIT: Please check namelists DEPOLA and WFOLDN'
          stop '*** Program WAVE aborted ***'
        endif
        betfunv=bsigy(1)**2/eps0v
      endif

      IF (iemit.ne.0.or.ibunch.eq.-1.and.iubunch.eq.1.and.betfun*eps0h.EQ.0.0d0) THEN

        if (betfun*eps0h.eq.0.0d0) then
          write(lungfo,*)
     &      '*** Warning in GFINIT: EPS0H or BETFUN are zero'
          write(lungfo,*)
     &      '*** Warning in GFINIT: Please check namelists DEPOLA and WFOLDN'
          write(6,*)
     &      '*** Warning in GFINIT: EPS0H or BETFUN are zero'
          write(6,*)
     &      '*** Warning in GFINIT: Please check namelists DEPOLA and WFOLDN'
        endif

        if ((bsigz(1)*bsigzp(1)).eq.0.0d0) then
          write(lungfo,*)
     &      '*** Warning in GFINIT: BSIGZ(1) and BSIGZP(1) are zero'
          write(lungfo,*)
     &      '*** Warning in GFINIT: Please check namelists DEPOLA and WFOLDN'
          write(6,*)
     &      '*** Warning in GFINIT: BSIGZ(1) and BSIGZP(1) are zero'
          write(6,*)
     &      '*** Warning in GFINIT: Please check namelists DEPOLA and WFOLDN'
        endif

      endif

      IF (iemit.ne.0.or.ibunch.eq.-1.and.iubunch.eq.1.and.betfun*eps0v.EQ.0.0d0) THEN

        if (betfun*eps0v.eq.0.0d0) then
          write(lungfo,*)
     &      '*** Warning in GFINIT: EPS0V or BETFUN are zero'
          write(lungfo,*)
     &      '*** Warning in GFINIT: Please check namelists DEPOLA and WFOLDN'
          write(6,*)
     &      '*** Warning in GFINIT: EPS0V or BETFUN are zero'
          write(6,*)
     &      '*** Warning in GFINIT: Please check namelists DEPOLA and WFOLDN'
        endif

        if ((bsigy(1)*bsigyp(1)).eq.0.0d0) then
          write(lungfo,*)
     &      '*** Warning in GFINIT: BSIGY(1) and BSIGYP(1) are zero'
          write(lungfo,*)
     &      '*** Warning in GFINIT: Please check namelists DEPOLA and WFOLDN'
          write(6,*)
     &      '*** Warning in GFINIT: BSIGY(1) and BSIGYP(1) are zero'
          write(6,*)
     &      '*** Warning in GFINIT: Please check namelists DEPOLA and WFOLDN'
        endif

      endif

      IF (betfun.ne.-9999.0d0) THEN
        IF (ABS(BETAH).EQ.9999.) THEN
          BY    =WTRA(2,3,1)
          RI    =CLIGHT1*BY/EMOM
          TANPHI=WTRA(3,2,1)/WTRA(1,2,1)
          BANA  =BETFUN+X0**2./BETFUN
          BPANA =2.*X0/BETFUN
          BANAC =BANA/(1.+TANPHI**2)
          BPANAC=BPANA/(1+TANPHI**2)+2.*BANA*TANPHI/(1.+TANPHI**2)
     &      *RI/(1+TANPHI**2)
          IF (BETAH.EQ.-9999.) THEN
            BETAH=BANAC
          ELSE IF (BETAH.EQ.9999.) THEN
            BETAH=BANA
          ENDIF
        ENDIF

        IF (ABS(BETAPH).EQ.9999.) THEN
          BY    =WTRA(2,3,1)
          RI    =CLIGHT1*BY/EMOM
          TANPHI=WTRA(3,2,1)/WTRA(1,2,1)
          BANA  =BETFUN+X0**2./BETFUN
          BPANA =2.*X0/BETFUN
          BANAC =BANA/(1.+TANPHI**2)
          BPANAC=BPANA/(1+TANPHI**2)+2.*BANA*TANPHI/(1.+TANPHI**2)
     &      *RI/(1+TANPHI**2)
          IF (BETAPH.EQ.-9999.) THEN
            BETAPH=BPANAC
          ELSE IF (BETAPH.EQ.9999.) THEN
            BETAPH=BPANA
          ENDIF
        ENDIF
      endif ! betfun.ne.-9999.

      IF (betfunv.ne.-9999.0d0) THEN
        IF (ABS(BETAV).EQ.9999.) THEN
          IF (BETFUNV.EQ.0.0) BETFUNV=1.0D0
          BETAV =BETFUNV+X0**2./BETFUNV
        ENDIF

        IF (ABS(BETAPV).EQ.9999.) THEN
          IF (BETFUNV.EQ.0.0) BETFUNV=1.0D0
          BETAPV =2.*X0/BETFUNV
        ENDIF
      endif

      if (ibunch.ne.0.or.iemit.ne.0) then
        write(lungfo,*)' '
        WRITE(LUNGFO,*)'     Horizontal emittance EPS0H [m-rad]:',EPS0H
        WRITE(LUNGFO,*)'     Vertical emittance EPS0V [m-rad]:  ',EPS0V
        write(lungfo,*)'     Horizontal beta-function BETAH [m]:',betah
        write(lungfo,*)'     Horizontal derivative BETAPH:      ',betaph
        write(lungfo,*)'     Vertical beta-function BETAV [m]:  ',betav
        write(lungfo,*)'     Vertical derivative BETAPV:        ',betapv
        write(lungfo,*)' '
        write(lungfo,*)'     --> Note: These values may differ from that of spectrum calculations!!'
        write(lungfo,*)' '
        if (iubunch.eq.1) then
          if (betah.lt.0.1.or.betah.gt.100.) then
            print*,"*** Warning in GFINIT: Strange value of BETAH:",betah
            print*,"*** This can cause program crashes for IUBUNCH=1!"
          endif
          if (betav.lt.0.1.or.betav.gt.100.) then
            print*,"*** Warning in GFINIT: Strange value of BETAH:",betah
            print*,"*** This can cause program crashes for IUBUNCH=1!"
          endif
          write(lungfo,*)' '
        endif
      endif

      IF (IWSECTMAGS.GT.0) THEN
        CALL SECTMAGS
      ENDIF !IWSECTMAGS

      IF (IMAGSPLN.LT.0
     &    .OR.
     &    ispec.ne.0.and.(ISPECMODE.EQ.3.or.ispecmode.eq.2)) THEN
C DO NOT USE WTRA(1:3,3,I) OR WBXYZ(1:3,I) DUE TO BSHIFT

        ALLOCATE(XAMAG(NCO))
        ALLOCATE(BXAMAG(NCO))
        ALLOCATE(BYAMAG(NCO))
        ALLOCATE(BZAMAG(NCO))
        ALLOCATE(BX2A(NCO))
        ALLOCATE(BY2A(NCO))
        ALLOCATE(BZ2A(NCO))
        IXAMAG_I=1

        DO I=1,NCO
          XAMAG(I)=WTRA(1,1,I)
          CALL MYBFELD
     &      (WTRA(1,1,I),WTRA(2,1,I),WTRA(3,1,I),
     &      BXAMAG(I),BYAMAG(I),BZAMAG(I),AXDUM,AYDUM,AZDUM)
        ENDDO  !NCO

        IF (IMAGSPLN.LT.0.AND.IMAGSPLN.NE.-9999) THEN
          CALL BMAGSPLN
     &      (WTRA(1,1,1),WTRA(2,1,1),WTRA(3,1,1),AXDUM,AYDUM,AZDUM)
        ENDIF

      ENDIF !IMAGSPLN

      CALL MYBFELD(XF0,YF0,ZF0,
     &  BXSTOP,BYSTOP,BZSTOP,
     &  AXSTOP,AYSTOP,AZSTOP)


      IF (IMAGSPLN.EQ.-9999) THEN
        IMAGSPLN=-999
      ELSE IF (IMAGSPLN.LT.0) THEN
        IMAGSPLN=-1111
      ENDIF

      ZP0=VZ0/VX0
      YP0=VY0/VX0

      ZPF0=VZF0/VXF0
      YPF0=VYF0/VXF0

      BETXF0=VXF0/CLIGHT1
      BETYF0=VYF0/CLIGHT1
      BETZF0=VZF0/CLIGHT1

C--- POLARIZATION

      ENEGEV=ENERGV/1.0D9
      BDIPOL=ENEGEV/RDIPOL*1.0D9/CLIGHT1
      BDIPL1G=1./RDIPOL*1.0D9/CLIGHT1
      TAUPOL0=POL2CON1*UMFANG*RDIPOL**2/ENEGEV**5
      TAUPOL01G=POL2CON1*UMFANG*RDIPOL**2/1.**5
      POLFAC=1.0D0+BINT3YA/2.0D0/PI1/BDIPOL**3/RDIPOL
      POLFC1G=1.0D0+BINT3YA/2.0D0/PI1/BDIPL1G**3/RDIPOL
      TAUPOL=TAUPOL0/POLFAC
      POLLEV=(2.*PI1*RDIPOL*BDIPOL**3+BINT3Y)/
     &  (2.*PI1*RDIPOL*BDIPOL**3+BINT3YA)*POL1CON1
      TAUPL1G=TAUPOL01G/POLFC1G
      POLLV1G=(2.*PI1*RDIPOL*BDIPL1G**3+BINT3Y)/
     &  (2.*PI1*RDIPOL*BDIPL1G**3+BINT3YA)*POL1CON1

      CALL EMINP(RDIPOL,BINT3YA,TAUPOL01G,TAUKRIT,EMINPOL)

      BDIPLEP=EMINPOL/RDIPOL*1.0D9/CLIGHT1
      TAUPOL0EP=POL2CON1*UMFANG*RDIPOL**2/EMINPOL**5
      POLFCEP=1.0D0+BINT3YA/2.0D0/PI1/BDIPLEP**3/RDIPOL
      TAUPLEP=TAUPOL0EP/POLFCEP
      POLLVEP=(2.*PI1*RDIPOL*BDIPLEP**3+BINT3Y)/
     &  (2.*PI1*RDIPOL*BDIPLEP**3+BINT3YA)*POL1CON1

C--- SIMPLE ESTIMATE OF LINEAR TRANSFER MATRIX

c20180111+self,if=notralinshort.
c      if  (betfun.eq.-9999.or.betfunv.eq.-9999.or.iphellip.ne.0
      if  (iemit.ne.0.or.iphellip.ne.0) then

        if (deltaz.eq.0.0d0)  deltaz=0.0001
        if (deltazp.eq.0.0d0) deltazp=0.0001
        if (deltay.eq.0.0d0)  deltay=0.0001
        if (deltayp.eq.0.0d0) deltayp=0.0001

        write(lungfo,*)
        write(lungfo,*)
     &    '--- Remark: Call of TRALIN triggered and IMAGSPLN=0 due to'
        write(lungfo,*)
     &    '            IEMIT or IPHELLIP'
        write(lungfo,*)

        write(6,*)
        write(6,*)
     &    '--- Remark: Call of TRALIN triggered and IMAGSPLN=0 due to'
        write(6,*)
     &    '            IEMIT or IPHELLIP'
        write(6,*)

        imagspln=0

      endif

c20180111+self.

      IF (
     &    DABS(DELTAZ)+DABS(DELTAZP)+DABS(DELTAY)+DABS(DELTAYP).GT.0.0
     &    D0.OR.IPHELLIP.NE.0.or.betfun.eq.-9999.or.betfunv.eq.-9999.) THEN
c23.3.2022        IF (IRBTAB.NE.0.OR.IRBTABZY.NE.0.OR.IRBTABXYZ.NE.0.OR.IMAGSPLN.NE.0) THEN
        IF (IMAGSPLN.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
c23.3.2022          WRITE(LUNGFO,*)'     MAGNETIC FIELD FLAG IMAGSPLN,IRBTAB/IRBTABZY/IRBTABXYZ'
          WRITE(LUNGFO,*)'     MAGNETIC FIELD FLAG IMAGSPLN'
          WRITE(LUNGFO,*)'     NOT COMPATIBLE WITH CALL TO SR TRALIN OR'
          WRITE(LUNGFO,*)'     IPHELLIP.NE.0'
          WRITE(LUNGFO,*)'     SET PARAMETERS IN NAMELIST $TRALINN AND IPHELLIP'
          WRITE(LUNGFO,*)'     TO ZERO OR USE OTHER MAGNETIG FIELD FLAG'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'     *** ERROR IN GFINIT ***'
c23.3.2022          WRITE(6,*)'     MAGNETIC FIELD FLAG IMAGSPLN,IRBTAB/IRBTABZY/IRBTABXYZ'
          WRITE(6,*)'     MAGNETIC FIELD FLAG IMAGSPLN'
          WRITE(6,*)'     NOT COMPATIBLE WITH CALL TO SR TRALIN'
          WRITE(6,*)'     SET PARAMETERS IN NAMELIST $TRALINN AND IPHELLIP'
          WRITE(6,*)'     TO ZERO OR USE OTHER MAGNETIG FIELD FLAG'
          WRITE(6,*)
          STOP '--- Program aborted ---'
        ENDIF
        CALL TRALIN
      ENDIF

C--- WRITE SOME RESULTS

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Number of tracking steps per meter (MYINUM): ',MYINUM
      WRITE(LUNGFO,*)

      IF (XINTER.NE.-9999.) THEN

       WRITE(LUNGFO,*)'     Start of the trajectory given by XINTER:'
       WRITE(LUNGFO,*)'     X [m], Y [m], Z[m]:'
       WRITE(LUNGFO,*)'     ',SNGL(XINTER),SNGL(YSTARTO),SNGL(ZSTARTO)
       WRITE(LUNGFO,*)'     VX, VY , VZ:'
       WRITE(LUNGFO,*)'     ',SNGL(VXINO),SNGL(VYINO),SNGL(VZINO)
       WRITE(LUNGFO,*)

      ENDIF   !(XINTER.NE.-9999.)

      WRITE(LUNGFO,*)'     Start and end of the trajectory [m](XSTART,XSTOP):'
      WRITE(LUNGFO,*)'     ',SNGL(XSTART),SNGL(XSTOP)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     BMOVECUT:',SNGL(BMOVECUT)
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)'     Initial energy [GeV] and gamma: '
     &  ,SNGL(ENEGEV),GAMMA
      WRITE(LUNGFO,*)'     Final energy [GeV] and gamma:   '
     &  ,SNGL(ENEGEV-ENEGEV*GAMMAL/DMYGAMMA),DMYGAMMA-GAMMAL
      WRITE(LUNGFO,*)'     Relative change:                '
     &  ,SNGL((DMYGAMMA-GAMMAL-GAMMA)/DMYGAMMA)
      IF (ieneloss.eq.-1) then
        if (nqfphotons.gt.0) then
          qfmean=qfmean/nqfphotons
          qfrms=sqrt((qfrms/nqfphotons-qfmean**2))
        endif
c qfrms is rms of the energy of the irradiated photons, thus
c qfrms*nqfphotons should be the sqrt(nqfphotons)*qfrms
        WRITE(LUNGFO,*)'     number of photons, RMS (keV) and rel. RMS of quantum fluctuation:'
        WRITE(LUNGFO,*)'     ',
     &    nqfphotons,
     &    sngl(qfrms*1.0d6*sqrt(dble(nqfphotons))),
     &    sngl(qfrms*sqrt(dble(nqfphotons))/dmyenergy)
      endif

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     B-rho [Tm], current [A]: ',SNGL(DBRHO),SNGL(DMYCUR)
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)
     &  '     Offset for vert. and hori. magnetic field (BYGOFF, BZGOFF):'
      WRITE(LUNGFO,*)
     &  '      ',SNGL(BYGOFF),SNGL(BZGOFF)
      WRITE(LUNGFO,*)
     &  '     Global scaling factor for mag. field (B0SCGLOB,A0SCGLOB):'
      WRITE(LUNGFO,*)
     &  '      ',SNGL(B0SCGLOB),SNGL(A0SCGLOB)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Global rel. taper (XTAPER, BTAPERV, BTAPERH):'
      WRITE(LUNGFO,*)
     &  '      ',SNGL(XTAPER),SNGL(BTAPERV),SNGL(BTAPERH)
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)
     &  '     Long. shift [m] of device (X(e-) -> X(e-)+XSHIFT): '
     &  ,SNGL(XSHIFT)
      WRITE(LUNGFO,*)
     &  '     Vert. shift [m] of device (Y(e-) -> Y(e-)+VSHIFT): '
     &  ,SNGL(VSHIFT)
      WRITE(LUNGFO,*)
     &  '     Hori. shift [m] of device (Z(e-) -> Z(e-)+HSHIFT): '
     &  ,SNGL(HSHIFT)
      WRITE(LUNGFO,*)
     &  '     Rotation angle [degree] of device:                 '
     &  ,SNGL(XROTD)
      WRITE(LUNGFO,*)
     &  '     Y(e-) -> Y(e-)*sin(XROTD) + Y(e-)*cos(XROTD)'
      WRITE(LUNGFO,*)
     &  '     Z(e-) -> Z(e-)*cos(XROTD) - Y(e-)*sin(XROTD)'
      WRITE(LUNGFO,*)
      IF (IPERIODG.NE.0) THEN
      WRITE(LUNGFO,*)
     &  '     period length of mag. field (PERIODG):               ',SNGL(PERIODG)
      WRITE(LUNGFO,*)
     &  '     longitudinal x-offset for periodical field (PEROFFG):',SNGL(PEROFFG)
      WRITE(LUNGFO,*)
     &  '     scaling and alternating sign reverse factor (SIGNG):',SNGL(SIGNG)
      WRITE(LUNGFO,*)
     &  '     scaling and alternating sign reverse factor (SIGNG2):',SNGL(SIGNG2)
      WRITE(LUNGFO,*)
      ENDIF

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Magnetic field [T] at starting point:'
      WRITE(LUNGFO,*)'     ',SNGL(BXSTART),SNGL(BYSTART),SNGL(BZSTART)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Vector potential [T-m] at starting point:'
      WRITE(LUNGFO,*)'     ',SNGL(AXSTART),SNGL(AYSTART),SNGL(AZSTART)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Magnetic field [T] at stopping point:'
      WRITE(LUNGFO,*)'     ',SNGL(BXSTOP),SNGL(BYSTOP),SNGL(BZSTOP)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Vector potential [T-m] at stopping point:'
      WRITE(LUNGFO,*)'     ',SNGL(AXSTOP),SNGL(AYSTOP),SNGL(AZSTOP)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Extrema of magnetic field [T] and the trajectory [m]:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     BXmax,BXmin: ',SNGL(BXMX),SNGL(BXMN)
      WRITE(LUNGFO,*)'     BYmax,BYmin: ',SNGL(BYMX),SNGL(BYMN)
      WRITE(LUNGFO,*)'     BZmax,BZmin: ',SNGL(BZMX),SNGL(BZMN)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Xmax,Xmin: ',SNGL(XMX),SNGL(XMN)
      WRITE(LUNGFO,*)'     Ymax,Ymin: ',SNGL(YMX),SNGL(YMN)
      WRITE(LUNGFO,*)'     Zmax,Zmin: ',SNGL(ZMX),SNGL(ZMN)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Extrema of magnetic field [T] and the trajectory [m] between'
      WRITE(LUNGFO,*)
     &  '     XIANF and XIEND'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     BXmaxAE,BXminAE: ',SNGL(BXMXAE),SNGL(BXMNAE)
      WRITE(LUNGFO,*)'     BYmaxAE,BYminAE: ',SNGL(BYMXAE),SNGL(BYMNAE)
      WRITE(LUNGFO,*)'     BZmaxAE,BZminAE: ',SNGL(BZMXAE),SNGL(BZMNAE)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     XmaxAE,XminAE: ',SNGL(XMXAE),SNGL(XMNAE)
      WRITE(LUNGFO,*)'     YmaxAE,YminAE: ',SNGL(YMXAE),SNGL(YMNAE)
      WRITE(LUNGFO,*)'     ZmaxAE,ZminAE: ',SNGL(ZMXAE),SNGL(ZMNAE)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Start values (coordinates [m] and slopes) of trajectory:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     X0: ',X0
      WRITE(LUNGFO,*)'     Y0: ',Y0
      WRITE(LUNGFO,*)'     Z0: ',Z0
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     ZP0:',ZP0
      WRITE(LUNGFO,*)'     YP0:',YP0
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     VX0:',VX0
      WRITE(LUNGFO,*)'     VY0:',VY0
      WRITE(LUNGFO,*)'     VZ0:',VZ0
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Values for X=0 (coordinates [m] and slopes) of trajectory:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     YCEN: ',YCEN
      WRITE(LUNGFO,*)'     ZCEN: ',ZCEN
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     YPCEN:',YPCEN
      WRITE(LUNGFO,*)'     ZPCEN:',ZPCEN
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     End values (coordinates [m] and slopes) of trajectory:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     XF0: ',XF0
      WRITE(LUNGFO,*)'     YF0: ',YF0
      WRITE(LUNGFO,*)'     ZF0: ',ZF0
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     ZPF0: ',ZPF0
      WRITE(LUNGFO,*)'     YPF0: ',YPF0
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     VXF0: ',VXF0
      WRITE(LUNGFO,*)'     VYF0: ',VYF0
      WRITE(LUNGFO,*)'     VZF0: ',VZF0
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Values for X=XIANF (coordinates [m] and slopes) of trajectory:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     XIANF: ',XIANF
      WRITE(LUNGFO,*)'     YIANF: ',YIANF
      WRITE(LUNGFO,*)'     ZIANF: ',ZIANF
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     YPIANF:',YPIANF
      WRITE(LUNGFO,*)'     ZPIANF:',ZPIANF
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Values for X=XIEND (coordinates [m] and slopes) of trajectory:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     XIEND: ',XIEND
      WRITE(LUNGFO,*)'     YIEND: ',YIEND
      WRITE(LUNGFO,*)'     ZIEND: ',ZIEND
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     YPIEND:',YPIEND
      WRITE(LUNGFO,*)'     ZPIEND:',ZPIEND
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

      IF (XSTOP.NE.XSTART) THEN
       WRITE(LUNGFO,*)'     ZF0/(XSTOP-XSTART): ',ZF0/(XSTOP-XSTART)
       WRITE(LUNGFO,*)'     YF0/(XSTOP-XSTART): ',YF0/(XSTOP-XSTART)
      ENDIF

      IF (DABS(Z0-ZF0).GT.1.0D-5) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'     *** WARNING IN GFINIT ***'
         WRITE(LUNGFO,*)'     CLOSED ORBIT OFFSET EXCEEDS 1E-5 METER'
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)
         WRITE(6,*)'     *** WARNING IN GFINIT ***'
         WRITE(6,*)'     CLOSED ORBIT OFFSET EXCEEDS 1E-5 METER'
         WRITE(6,*)'     ZF0-Z0:',ZF0-Z0
         WRITE(6,*)
         WRITE(6,*)
      ENDIF

      IF (DABS(ZP0-ZPF0).GT.1.0D-5) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'     *** WARNING IN GFINIT ***'
         WRITE(LUNGFO,*)'     CLOSED ORBIT KICK EXCEEDS 1E-5 RADIAN'
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)
         WRITE(6,*)'     *** WARNING IN GFINIT ***'
         WRITE(6,*)'     CLOSED ORBIT KICK EXCEEDS 1E-5 RADIAN'
         WRITE(6,*)'     ZPF0-ZP0:',ZPF0-ZP0
         WRITE(6,*)
         WRITE(6,*)
      ENDIF

      IF (DABS(Y0-YF0).GT.1.0D-5) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'     *** WARNING IN GFINIT ***'
         WRITE(LUNGFO,*)'     CLOSED ORBIT OFFSET EXCEEDS 1E-5 METER'
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)
         WRITE(6,*)'     *** WARNING IN GFINIT ***'
         WRITE(6,*)'     CLOSED ORBIT OFFSET EXCEEDS 1E-5 METER'
         WRITE(6,*)'     YF0-Y0:',YF0-Y0
         WRITE(6,*)
         WRITE(6,*)
      ENDIF

      IF (DABS(YP0-YPF0).GT.1.0D-5) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'     *** WARNING IN GFINIT ***'
         WRITE(LUNGFO,*)'     CLOSED ORBIT KICK EXCEEDS 1E-5 RADIAN'
         WRITE(LUNGFO,*)'     YPF0-YP0:',YPF0-YP0
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)
         WRITE(6,*)'     *** WARNING IN GFINIT ***'
         WRITE(6,*)'     CLOSED ORBIT KICK EXCEEDS 1E-5 RADIAN'
         WRITE(6,*)'     YPF0-YP0:',YPF0-YP0
         WRITE(6,*)
         WRITE(6,*)
      ENDIF

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     YF0-Y0:',YF0-Y0
      WRITE(LUNGFO,*)'     ZF0-Z0:',ZF0-Z0
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     YPF0-YP0:',YPF0-YP0
      WRITE(LUNGFO,*)'     ZPF0-ZP0:',ZPF0-ZP0
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)'     Straight line fit of z(x):'
      WRITE(LUNGFO,*)'     offset:', zoffstr
      WRITE(LUNGFO,*)'     slope:', zslopetr
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Straight line fit of vz(x)/vx(x):'
      WRITE(LUNGFO,*)'     offset:', zpoffstr
      WRITE(LUNGFO,*)'     slope:', zpslopetr
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)'     Straight line fit of y(x):'
      WRITE(LUNGFO,*)'     offset:', yoffstr
      WRITE(LUNGFO,*)'     slope:', yslopetr
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Straight line fit of vy(x)/vx(x):'
      WRITE(LUNGFO,*)'     offset:', ypoffstr
      WRITE(LUNGFO,*)'     slope:', ypslopetr

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     1. magnetic integral [T-m]: '
     &  ,SNGL(BINT1X),SNGL(BINT1Y),SNGL(BINT1Z)
      WRITE(LUNGFO,*)'     2. mag. integral [T-m**2]: '
     &  ,SNGL(BINT2X),SNGL(BINT2Y),SNGL(BINT2Z)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Integrated By**2 [T**2-m]:                   '
     &  ,SNGL(B2INTY)
      if (kampli.eq.0) then
        WRITE(LUNGFO,*)
     &    '     Energy irradiated by the device per e- [MeV]:'
     &    ,SNGL(PINT/DMYCUR/1.0d6)
        WRITE(LUNGFO,*)
     &    '     Rel. energy loss:                            '
     &    ,SNGL(PINT/DMYCUR/1.0d9/DMYENERGY)
        WRITE(LUNGFO,*)
     &    '     Power irradiated by the device [kWATT]:      '
     &    ,SNGL(PINT/1000.)
      else
        WRITE(LUNGFO,*)
     &    '     Energy irradiated by the device per e- [MeV]:'
     &    ,SNGL(PINT/DMYCUR/1.0d6*iabs(kampli))
        WRITE(LUNGFO,*)
     &    '     Rel. energy loss:                            '
     &    ,SNGL(PINT/DMYCUR/1.0d9/DMYENERGY*iabs(kampli))
        WRITE(LUNGFO,*)
     &    '     Power irradiated by the device [kWATT]:      '
     &    ,SNGL(PINT/1000.*iabs(kampli))
      endif

      IF (IAMPLI.GT.0) THEN
        WRITE(LUNGFO,*)'     (Option IAMPLI not taken into account!!)'
      ENDIF

      IF (IAMPLI.LT.0) THEN
        WRITE(LUNGFO,*)'     scaled according to IAMPLI:     '
     &    ,SNGL(PINT/1000.*(-IAMPLI))
      ENDIF !IAMPLI

      IF (IAMPLI.lt.0.and.icluster.ne.0) THEN
        write(6,*)"*** Warning in GFINIT: IAMPLI < 0 and ICLUSTER <> 0 may cause problems, be careful ***"
        write(lungfo,*)"*** Warning in GFINIT: IAMPLI < 0 and ICLUSTER <> 0 may cause problems, be careful ***"
      endif

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Length of trajectory (BINT0) [m]:'
      WRITE(LUNGFO,*)
     &  '     ',BINT0
      WRITE(LUNGFO,*)
     &  '     Integrated (YP**2+ZP**2)/2 of trajectory (WTRA2I) [m]:'
      WRITE(LUNGFO,*)
     &  '     ',WTRA2I

      IF (HTRA2I.NE.0.0D0) THEN
        WRITE(LUNGFO,*)
     &    '     corresponding phase advance [nm and eV]:'
        WRITE(LUNGFO,*)
     &    '     ',HTRA2I*1.0D9
     &    ,CLIGHT1*HPLANCK1/ECHARGE1/HTRA2I
      ELSE
        WRITE(LUNGFO,*)
     &    '     corresponding phase advance [nm and eV]:'
        WRITE(LUNGFO,*)
     &    '     ',SNGL(HTRA2I*1.0D9),'    0.000'
      ENDIF

      WRITE(LUNGFO,*)
     &    '     dE/E and corresponding dL = 2 * dE/E * L [nm]:'
      WRITE(LUNGFO,*)
     &  '     ',SNGL(ESPREAD)
     &  ,SNGL(2.0D9*ESPREAD*WTRA2I)

      WRITE(LUNGFO,*)
     &  '     Circumference of the ring [m]:              ',SNGL( UMFANG  )
      WRITE(LUNGFO,*)
     &  '     Rel. change of total circumference (from BINT0):         '
      WRITE(LUNGFO,*)
     &  '     ',SNGL((BINT0+XSTART-XSTOP)/UMFANG  )
      WRITE(LUNGFO,*)
     &  '     Rel. change of total circumference (from WTRA2I):'
      WRITE(LUNGFO,*)
     &  '     ',SNGL(WTRA2I/UMFANG  )
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Max. and min. deflection angle [rad]: '
     &  ,SNGL(PHIMX),SNGL(PHIMN)
      WRITE(LUNGFO,*)

      IF (IBEAMPOL.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     Beam polarization time (time constant) [h]: '
     &    ,SNGL (TAUPOL)
        WRITE(LUNGFO,*)'     Reduction factor due to device:             '
     &    ,SNGL (POLFAC)
        WRITE(LUNGFO,*)'     Final level of beam polarization:           '
     &    ,SNGL (POLLEV)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     Same numbers for a beam energy of 1 GeV:    '
     &    ,SNGL(TAUPL1G)
        WRITE(LUNGFO,*)'                                                 '
     &    ,SNGL(POLFC1G)
        WRITE(LUNGFO,*)'                                                 '
     &    ,SNGL(POLLV1G)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     Critical polarization time (TAUKRIT) and corresponding beam'
        WRITE(LUNGFO,*)
     &    '     energy [GeV], reduction factor, and final polarization level:'
        WRITE(LUNGFO,*)'     '
     &    ,SNGL(TAUKRIT),SNGL(EMINPOL),SNGL(POLFCEP),SNGL(POLLVEP)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     Integrals of By**3, |By|**3 of device and integral of By**3'
        WRITE(LUNGFO,*)'     of ring [T-m**3]:'
     &    ,SNGL(BINT3Y),SNGL(BINT3YA),SNGL(6.283185*RDIPOL*BDIPOL**3)
      ENDIF !IBEAMPOL

      IF (IDISPER.NE.0.OR.IBEAMPOL.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Bending radius of the ring dipoles [m]: '
     &      ,SNGL(RDIPOL)
          WRITE(LUNGFO,*)'     Circumference of the ring [m]:          '
     &      ,SNGL(UMFANG)
          WRITE(LUNGFO,*)
      ENDIF

      IF (IDISPER.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     BETA FUNCTION FOR WLS:      ',SNGL(BETFUN)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     INTEGRAL I2 OF RING:        ',SNGL(DI2RING)
          WRITE(LUNGFO,*)'     INTEGRAL I4 OF RING:        ',SNGL(DI4RING)
          WRITE(LUNGFO,*)'     INTEGRAL I5 OF RING:        ',SNGL(DI5RING)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
      ENDIF

C--- ADJUST SOMETHING

      IF (IJUST.NE.0) THEN !SEE ABOVE
         XJUST=HSHIFT
         YJUST=ZF0
         WRITE(6,*)'HSHIFT, ZF0:', HSHIFT,ZF0
         CALL WLSJUST(XJUST,YJUST)
         IF (IJUST.LE.3) THEN
            IABEND=2
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     HSHIFT ADJUSTED'
            WRITE(LUNGFO,*)
            RETURN
         ENDIF
      ENDIF

C--- HBOOK

      IF (IHBOOK.NE.0) CALL HISINI

C--- WRITE B-FIELD TO FILE

      IF (IWBTAB.NE.0) CALL WBTAB

C--- WRITE B-FIELD TO MAP FILE

      IF (IWBMAP.NE.0) CALL WBMAP

C--- CALCULATE 3D POLYNOMIAL-COEFFICIENTS OF B-FIELD AND EXIT

      IF (IWBPOLY3D.NE.0) THEN
          CALL BPOLY3DFIT
          IABEND=3
          goto 9999
      ENDIF

C--- CALCULATE 3D POLYNOMIAL-COEFFICIENTS OF B-FIELD AND EXIT

      IF (IWBPOLY2DH.NE.0) THEN
          CALL BPOLY2DHFIT
          IABEND=3
          goto 9999
      ENDIF

      IF (IWBPHARM.NE.0) THEN
          CALL BPHARMFIT
          IABEND=3
          goto 9999
      ENDIF

      IF (IHTRACK.NE.0) CALL HTRACK

      if (icluster.ne.0.and.ispecmode.eq.3) then
        PRINT *,
     &      '*** Warning in GFINIT: ICLUSTER .NE. 0 but ISPECMODE=3 ***'
        print*,"*** BE CAREFUL ***"
      endif

      if (icluster.ne.0.and.ispecmode.eq.3) then
        PRINT *,
     &      '*** Warning in GFINIT: ICLUSTER .NE. 0 but ISPECMODE=3 ***'
        print*,"*** BE CAREFUL ***"
      endif

      if (iemit.ne.0.or.ibunch.ne.0) imagspln=0

      if (phrxbeta.eq.-9999.0d0) xbetfun=xstart

      if (abs(phrxbeta).eq.9999.0d0) then
        phrxbeta=xstart
      endif

      if (phrbunlen.eq.9999.0d0) then
        phrbunlen=bunchlen
      endif
      if (phrbunlen.eq.-9999.0d0) then
        phrbunlen=ampbunchlen
      endif

      if (phrbetah.eq.9999.0d0) then
        phrbetah=betah
      endif
      if (phralphah.eq.9999.0d0) then
        phralphah=-betaph/2.0d0
      endif

      if (phrdisph.eq.9999.0d0) then
        phrdisph=disp0
      endif

      if (phrdispph.eq.9999.0d0) then
        phrdisph=ddisp0
      endif

      if (phrbetav.eq.9999.0d0) then
        phrbetav=betav
      endif
      if (phralphav.eq.9999.0d0) then
        phralphav=-betapv/2.0d0
      endif

      if (phremith.eq.9999.0d0) then
        phremith=eps0h
      endif

      if (phremitv.eq.9999.0d0) then
        phremitv=eps0v
      endif

      if (phrespread.eq.9999.0d0) then
        phrespread=delgam
      endif

      if (phrespread.eq.-9999.0d0) then
        phrespread=espread
      endif

      if (phremith.eq.9999.0d0) then
        phremith=eps0h
      endif

      if (phremith.eq.-9999.0d0) then
        phremith=bsigz(1)*bsigzp(1)
        phralphah=0.0d0
      endif

      if (phremitv.eq.-9999.0d0) then
        phremitv=bsigy(1)*bsigyp(1)
        phralphav=0.0d0
      endif

      if (phrbetah.eq.-9999.0d0) then
        phrbetah=bsigz(1)**2/phremith
        phralphah=0.0d0
      endif

      if (phrbetav.eq.-9999.0d0) then
        phrbetav=bsigy(1)**2/phremitv
        phralphav=0.0d0
      endif

      return

9999  iroottrees=0

      return
      END
+DECK,HFREQ.
*CMZ :  4.01/04 15/11/2023  18.07.40  by  Michael Scheer
*CMZ :  4.01/03 10/06/2023  15.52.02  by  Michael Scheer
*CMZ :  4.01/00 08/01/2023  10.16.47  by  Michael Scheer
*CMZ :  4.00/17 04/10/2022  08.10.22  by  Michael Scheer
*CMZ :  4.00/15 07/04/2022  07.14.03  by  Michael Scheer
*CMZ :  4.00/14 30/12/2021  15.41.22  by  Michael Scheer
*CMZ :  4.00/13 07/12/2021  18.47.10  by  Michael Scheer
*CMZ :  4.00/11 11/06/2021  11.00.05  by  Michael Scheer
*CMZ :  4.00/04 23/08/2019  15.58.25  by  Michael Scheer
*CMZ :  4.00/02 12/04/2019  18.39.49  by  Michael Scheer
*CMZ :  3.04/01 03/04/2018  14.26.06  by  Michael Scheer
*CMZ :  3.03/02 18/04/2016  15.26.59  by  Michael Scheer
*CMZ :  3.03/00 20/08/2015  15.24.19  by  Michael Scheer
*CMZ :  3.02/09 09/07/2015  17.12.40  by  Michael Scheer
*CMZ :  3.02/08 25/06/2015  12.41.28  by  Michael Scheer
*CMZ :  3.02/07 24/06/2015  12.40.15  by  Michael Scheer
*CMZ :  3.02/04 12/12/2014  16.56.09  by  Michael Scheer
*CMZ :  3.02/03 04/11/2014  12.49.47  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  09.14.50  by  Michael Scheer
*CMZ :  3.01/05 12/06/2014  08.52.10  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.13.36  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  15.34.39  by  Michael Scheer
*CMZ :  2.70/00 11/12/2012  10.58.11  by  Michael Scheer
*CMZ :  2.69/00 24/10/2012  16.35.22  by  Michael Scheer
*CMZ :  2.68/05 28/09/2012  13.18.55  by  Michael Scheer
*CMZ :  2.68/01 29/05/2012  13.43.27  by  Michael Scheer
*CMZ :  2.67/02 26/04/2012  14.57.31  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  14.11.28  by  Michael Scheer
*CMZ :  2.66/19 16/12/2010  12.57.57  by  Michael Scheer
*CMZ :  2.66/18 16/12/2010  12.52.11  by  Michael Scheer
*CMZ :  2.66/14 09/11/2010  15.39.16  by  Michael Scheer
*CMZ :  2.66/07 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.66/03 27/11/2009  15.57.31  by  Michael Scheer
*CMZ :  2.66/02 26/10/2009  09.28.27  by  Michael Scheer
*CMZ :  2.65/02 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  2.64/01 14/09/2009  15.19.42  by  Michael Scheer
*CMZ :  2.61/03 27/03/2007  13.10.16  by  Michael Scheer
*CMZ :  2.61/01 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.56/00 17/10/2005  12.42.20  by  Michael Scheer
*CMZ :  2.55/00 07/07/2005  16.35.20  by  Michael Scheer
*CMZ :  2.53/04 28/01/2005  12.42.15  by  Michael Scheer
*CMZ :  2.53/03 26/01/2005  15.02.46  by  Michael Scheer
*CMZ :  2.53/02 25/01/2005  16.49.46  by  Michael Scheer
*CMZ :  2.52/16 21/01/2005  13.34.39  by  Michael Scheer
*CMZ :  2.52/13 09/12/2004  11.06.01  by  Michael Scheer
*CMZ :  2.52/00 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.49/00 22/03/2004  09.56.01  by  Michael Scheer
*CMZ :  2.48/04 17/03/2004  10.57.53  by  Michael Scheer
*CMZ :  2.47/08 20/05/2003  14.46.41  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.41/07 13/06/2002  15.05.28  by  Michael Scheer
*CMZ :  2.41/00 20/03/2002  14.37.14  by  Michael Scheer
*CMZ :  2.36/01 08/11/2001  17.30.36  by  Michael Scheer
*CMZ :  2.33/06 04/05/2001  11.44.17  by  Michael Scheer
*CMZ :  2.33/05 04/05/2001  11.42.26  by  Michael Scheer
*CMZ :  2.20/10 04/04/2001  12.21.46  by  Michael Scheer
*CMZ :  2.20/09 23/03/2001  18.26.22  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  17.29.35  by  Michael Scheer
*CMZ :  2.16/07 01/09/2000  14.32.32  by  Michael Scheer
*CMZ :  2.16/06 30/08/2000  13.48.49  by  Michael Scheer
*CMZ :  2.16/05 04/08/2000  12.09.00  by  Michael Scheer
*CMZ :  2.16/04 28/06/2000  17.39.06  by  Michael Scheer
*CMZ :  2.16/01 15/06/2000  15.45.22  by  Michael Scheer
*CMZ :  2.15/00 11/05/2000  10.25.20  by  Michael Scheer
*CMZ :  2.13/07 17/02/2000  15.11.12  by  Michael Scheer
*CMZ :  2.13/03 12/01/2000  16.33.49  by  Michael Scheer
*CMZ :  2.13/00 02/12/99  13.24.15  by  Michael Scheer
*CMZ :  2.10/01 25/02/99  14.18.30  by  Michael Scheer
*CMZ :  1.03/06 23/09/98  17.07.41  by  Michael Scheer
*CMZ :  1.03/00 16/01/98  11.16.48  by  Michael Scheer
*CMZ :  1.00/00 24/09/97  10.31.27  by  Michael Scheer
*CMZ : 00.02/03 16/01/97  11.48.11  by  Michael Scheer
*CMZ : 00.02/02 10/01/97  16.50.11  by  Michael Scheer
*CMZ : 00.01/12 15/10/96  10.36.48  by  Michael Scheer
*CMZ : 00.01/06 14/02/95  10.54.13  by  Michael Scheer
*CMZ : 00.01/04 30/01/95  13.06.50  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  16.43.29  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.52.08  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.39  by  Michael Scheer
*-- Author :  Michael Scheer
      SUBROUTINE HFREQ
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.

      use clustermod

C--- HISTOGRAMS FOR SPECTRA OF SINGLE OBSERVATION POINTS OR PINHOLE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,whbook.
+seq,pawcmn.

+SEQ,SPECT.
+SEQ,FREQS.
+SEq,observf90.
+seq,sourcef90.
+SEQ,SPECDIP.
+SEq,phasef90.
+SEQ,AMPLI.
+SEQ,MYFILES.
+SEQ,PHYCON.
+seq,debugwave.

      INTEGER ID,IOBSV,ifrq,ISOUR,IOBSVY,IOBSVZ,NDIMPH,IOBSVR,IOBSVPHI
      INTEGER ICYCLE,MFREQ,I,ISTAT,I47,jsource

      REAL*4 FLOW,FHIG,DF
      DOUBLE PRECISION WEIGHT,smax,reanor,
     &  dist,dist0,ddist,h2,censoux,censouy,censouz,dphase,wlen,waves

      CHARACTER(80) TIT
      CHARACTER(4) CHTAGS(5)
      CHARACTER(5) CHTAGSF(36)
      CHARACTER(5) CHTAGSFd(36)
      CHARACTER(4) CHSPEC(31)
      CHARACTER(4) CHSPECRPHI(33)
      CHARACTER(4) CHPOW(8)
      CHARACTER(4) CHPOWF(9)
      CHARACTER(4) CHPOWV(5)
      CHARACTER(4) CHSPECF(18)
      CHARACTER(4) CHSTOK(12)
      CHARACTER(4) CHBRILL(17)
      CHARACTER(128) FILE47
      CHARACTER(8) OLDDIR

      INTEGER ND

      REAL*8 FSTUPLE(100),FSPEC(33)
      real*8 , dimension(:), allocatable :: phfill

      data chtags/'x','y','z','ener','spec'/

      data chtagsf/'iene','ener','flux','fluxf'
     &  ,'s0','s1','s2','s3'
     &  ,'s0f','s1f','s2f','s3f'
     &  ,'s0e','s1e','s2e','s3e'
     &  ,'s0ef','s1ef','s2ef','s3ef'
     &  ,'b0','b1','b2','b3'
     &  ,'b0f','b1f','b2f','b3f'
     &  ,'b0e','b1e','b2e','b3e'
     &  ,'b0ef','b1ef','b2ef','b3ef' /

      data chtagsfd/'iene','ener','fldn','fldnf'
     &  ,'s0','s1','s2','s3'
     &  ,'s0f','s1f','s2f','s3f'
     &  ,'s0e','s1e','s2e','s3e'
     &  ,'s0ef','s1ef','s2ef','s3ef'
     &  ,'b0','b1','b2','b3'
     &  ,'b0f','b1f','b2f','b3f'
     &  ,'b0e','b1e','b2e','b3e'
     &  ,'b0ef','b1ef','b2ef','b3ef' /

      data chspec/'isou','iobs','x','y','z','ener','spec'
     &  ,'iz','iy','iene',
     &  're_x','im_x','re_y','im_y','re_z','im_z','rf_y','if_y','rf_z','if_z',
     &  'rs_x','is_x','rs_y','is_y','rs_z','is_z','rsfy','isfy','rsfz','isfz',
     &  'phi0'
     &  /
      data chspecrphi/'isou','iobs','x','y','z','r','phi','ener','spec'
     &  ,'ir','iphi','iene',
     &  're_x','im_x','re_y','im_y','re_z','im_z','rf_y','if_y','rf_z','if_z',
     &  'rs_x','is_x','rs_y','is_y','rs_z','is_z','rsfy','isfy','rsfz','isfz',
     &  'phi0'
     &  /
      data chbrill/'ener','b0','b1','b2','b3','b0f','b1f','b2f','b3f',
     &  'b0e','b1e','b2e','b3e','b0ef','b1ef','b2ef','b3ef'/

      data chpow/'x','y','z','pow','iz','iy','iobs','isou'/
      data chpowf/'x','y','z','pow','powf','iz','iy','iobs','isou'/

      data chpowv/'x','z','pow','iz','isou'/

      data chspecf/'isou','iobs','x','y','z','ener','spec'
     &  ,'iz','iy','iene',
     &  're_y','im_y','re_z','im_z',
     &  'rs_y','is_y','rs_z','is_z'
     &  /

      data chstok/'iobs','x','y','z','ener','s0','s1','s2','s3'
     &  ,'iz','iy','iene'
     &  /

      NDIMPH=MPHASEZ*MPHASEY
      allocate(PHFILL(NDIMPH))
      phfill=0.0d0

      if (ipin.eq.3) then
        call hfreq3
        if(ibunch.ne.0.and.icluster.gt.0) call wpampntup
        return
      endif

      I47=0

      IF (mhbookp.eq.0.
     &    .and.
     &    IPIN.EQ.1.AND.NOBSV*NFREQ.GT.100000.and.iroottrees.ge.0) THEN

        I47=1

        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN HFREQ: HISTOGRAM FILE PROBABLY TOO SMALL'
        WRITE(6,*)
     & '*** GENERATING SPECIAL HISTOGRAM FILES FOR DISTRIBUTIONS IN PINHOLES'
        WRITE(6,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN HFREQ: HISTOGRAM FILE PROBABLY TOO SMALL'
        WRITE(LUNGFO,*)
     & '*** GENERATING SPECIAL HISTOGRAM FILES FOR DISTRIBUTIONS IN PINHOLES'
        WRITE(LUNGFO,*)

      ENDIF

      IF (IUNIT.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '*** WARNING SR HFREQ: NO HISTOGRAMS ONLY NTUPLES OF SPECTRUM FOR IUNIT.NE.0'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)
     &    '*** WARNING SR HFREQ: NO HISTOGRAMS ONLY NTUPLES OF SPECTRUM FOR IUNIT.NE.0'
        WRITE(6,*)
        GOTO 100
      ENDIF

      IF (ifreq2P.eq.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING SR HFREQ ***'
        WRITE(LUNGFO,*)'PARAMETER ifreq2P=0 , NO HISTOGRAM BOOKED'
        WRITE(LUNGFO,*)
      else IF (ifreq2P.EQ.2) THEN

        DF=FREQ(2)-FREQ(1)
        FLOW=FREQ(1)-DF/2.
        FHIG=FREQ(NFREQ)+DF/2.

        IF (FLOW.LT.0.) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING SR HFREQ ***'
          WRITE(LUNGFO,*)'LOW EDGE OF HISTOGRAM NEGATIVE'
          WRITE(LUNGFO,*)'BE CAREFUL IF X-AXIS IS PLOTTED WITH LOGARITHMIC SCALE'
          WRITE(LUNGFO,*)
        ENDIF

        IF(IPIN.EQ.0) THEN

          DO IOBSV=1,NOBSV

            ID=ICFREQ+IOBSV
            MFREQ=NINT((FHIG-FLOW)/DF)
            call hbook1m(ID,'PHOTON FLUX DENSITY x 1.E-6',
     &        MFREQ,FLOW,FHIG,VMX)

            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          SPECTOT(IOBSV+NOBSV*(ifrq-1))*1.0d-6)
            ENDDO   !NFREQ

            CALL MHROUT(ID,ICYCLE,' ')
            CALL hdeletm(ID)

          IF (IFOLD.EQ.2) THEN
              ID=ICFREQ+1000+IOBSV
              MFREQ=NINT((FHIG-FLOW)/DF)
              call hbook1m(ID,'PHOTON FLUX DENSITY x 1.E-6 (FOLDED)',
     &        MFREQ,FLOW,FHIG,VMX)

              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          SPECTOTF(IOBSV+NOBSV*(ifrq-1))*1.0d-6)
              ENDDO   !NFREQ

              CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

          ENDIF !IFOLDE.EQ.2

          ENDDO !IOBSV

          IF (ISTOKES.NE.0) THEN

            ID=ICFRS0
            call hbook1m(ID,'S0 (sel. obs. point) x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          dble(STOKES(1,1+NOBSV*(ifrq-1))*1.0d-6))
            ENDDO   !NFREQ

            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRS1
            call hbook1m(ID,'S1 (sel. obs. point) x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          dble(STOKES(2,1+NOBSV*(ifrq-1))*1.0d-6))
            ENDDO   !NFREQ

            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRS2
            call hbook1m(ID,'S2 (sel. obs. point) x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          dble(STOKES(3,1+NOBSV*(ifrq-1))*1.0d-6))
            ENDDO   !NFREQ

            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRS3
            call hbook1m(ID,'S3 (sel. obs. point) x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          dble(STOKES(4,1+NOBSV*(ifrq-1))*1.0d-6))
            ENDDO   !NFREQ

            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP
            call hbook1m(ID,'P (sel. obs. point)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=SQRT
     &          ((STOKES(2,IOBFR)/STOKES(1,IOBFR))**2
     &          +(STOKES(3,IOBFR)/STOKES(1,IOBFR))**2
     &         +(STOKES(4,IOBFR)/STOKES(1,IOBFR))**2)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,WEIGHT)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP1
            call hbook1m(ID,'P1 (sel. obs. point)'
     &                    ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=STOKES(2,IOBFR)/STOKES(1,IOBFR)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,WEIGHT)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP2
            call hbook1m(ID,'P2 (sel. obs. point)'
     &                    ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=STOKES(3,IOBFR)/STOKES(1,IOBFR)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,WEIGHT)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP3
            call hbook1m(ID,'P3 (sel. obs. point)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=STOKES(4,IOBFR)/STOKES(1,IOBFR)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,WEIGHT)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP23
            call hbook1m(ID,'P23 (sel. obs. point)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=SQRT((STOKES(3,IOBFR)/STOKES(1,IOBFR))**2
     &          +(STOKES(4,IOBFR)/STOKES(1,IOBFR))**2)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRG3
            call hbook1m(ID,'G3 (sel. obs. point) x 1.E-6 '
     &                    ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=STOKES(4,IOBFR)/STOKES(1,IOBFR)*STOKES(4,IOBFR)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight*1.0d-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRG23
            call hbook1m(ID,'G23 (sel. obs. point) x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=((STOKES(3,IOBFR)/STOKES(1,IOBFR))**2
     &          +(STOKES(4,IOBFR)/STOKES(1,IOBFR))**2)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight*1.0d-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            IF (IEFOLD.NE.0) THEN

              ID=ICFRS0E
              call hbook1m(ID,'S0_E (sel. obs. point) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(WSTOKESE(1,ifrq)*1.0d-6))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRS1E
              call hbook1m(ID,'S1_E (sel. obs. point) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(wstokESE(2,ifrq)*1.0d-6))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRS2E
              call hbook1m(ID,'S2_E (sel. obs. point) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(wstokESE(3,ifrq)*1.0d-6))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRS3E
              call hbook1m(ID,'S3_E (sel. obs. point) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(wstokESE(4,ifrq)*1.0d-6))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRPE
              call hbook1m(ID,'P_E (sel. obs. point)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=SQRT
     &            ((WSTOKESE(2,ifrq)/WSTOKESE(1,ifrq))**2
     &            +(WSTOKESE(3,ifrq)/WSTOKESE(1,ifrq))**2
     &            +(WSTOKESE(4,ifrq)/WSTOKESE(1,ifrq))**2)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP1E
              call hbook1m(ID,'P1_E (sel. obs. point)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(2,ifrq)/WSTOKESE(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP2E
              call hbook1m(ID,'P2_E (sel. obs. point)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(3,ifrq)/WSTOKESE(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP3E
              call hbook1m(ID,'P3_E (sel. obs. point)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(4,ifrq)/WSTOKESE(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP23E
              call hbook1m(ID,'P23_E (sel. obs. point)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=SQRT(
     &            (WSTOKESE(3,ifrq)/WSTOKESE(1,ifrq))**2
     &            +(WSTOKESE(4,ifrq)/WSTOKESE(1,ifrq))**2)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRG3E
              call hbook1m(ID,'G3_E (sel. obs. point) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(4,ifrq)/WSTOKESE(1,ifrq)*WSTOKESE(4,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight*1.0d-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRG23E
              call hbook1m(ID,'G23_E (sel. obs. point) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(3,ifrq)/WSTOKESE(1,ifrq)*WSTOKESE(3,ifrq)
     &            +WSTOKESE(4,ifrq)/WSTOKESE(1,ifrq)*WSTOKESE(4,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight*1.0d-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

            ENDIF !IEFOLD

            IF (IBRILL.NE.0) THEN

              ID=ICFRB0
              call hbook1m(ID,'SELECTED B0 x 1.E-12'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(brillC(1,ifrq)*1.0d-12))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

              ID=ICFRB1
              call hbook1m(ID,'SELECTED B1 x 1.E-12'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(brillC(2,ifrq)*1.0d-12))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

              ID=ICFRB2
              call hbook1m(ID,'SELECTED B2 x 1.E-12'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(brillC(3,ifrq)*1.0d-12))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

              ID=ICFRB3
              call hbook1m(ID,'SELECTED B3 x 1.E-12'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(brillC(4,ifrq)*1.0d-12))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

              IF (IEFOLD.NE.0) THEN

                ID=ICFRB0E
                call hbook1m(ID,'SELECTED B0_E x 1.E-12'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(brillCE(1,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                ID=ICFRB1E
                call hbook1m(ID,'SELECTED B1_E x 1.E-12'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(brillCE(2,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                ID=ICFRB2E
                call hbook1m(ID,'SELECTED B2_E x 1.E-12'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(brillCE(3,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                ID=ICFRB3E
                call hbook1m(ID,'SELECTED B3_E x 1.E-12'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(brillCE(4,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ENDIF !IEFOLD

              IF (IFOLD.EQ.2) THEN

                ID=ICFRB0F
                call hbook1m(ID,'SELECTED B0 x 1.E-12 (FOLDED)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(brillCF(1,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

                ID=ICFRB1F
                call hbook1m(ID,'SELECTED B1 x 1.E-12 (FOLDED)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(brillCF(2,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

                ID=ICFRB2F
                call hbook1m(ID,'SELECTED B2 x 1.E-12 (FOLDED)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(brillCF(3,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

                ID=ICFRB3F
                call hbook1m(ID,'SELECTED B3 x 1.E-12 (FOLDED)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(brillCF(4,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

                IF (IEFOLD.NE.0) THEN

                  ID=ICFRB0EF
                  call hbook1m(ID,'SELECTED B0_E x 1.E-12 (FOLDED)'
     &              ,NFREQ,FLOW,FHIG,VMX)
                  DO ifrq=1,NFREQ,IHFREQ
                    CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &                dble(brillCEF(1,ifrq)*1.0d-12))
                  ENDDO   !NFREQ
                  CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                  ID=ICFRB1EF
                  call hbook1m(ID,'SELECTED B1_E x 1.E-12 (FOLDED)'
     &              ,NFREQ,FLOW,FHIG,VMX)
                  DO ifrq=1,NFREQ,IHFREQ
                    CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &                dble(brillCEF(2,ifrq)*1.0d-12))
                  ENDDO   !NFREQ
                  CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                  ID=ICFRB2EF
                  call hbook1m(ID,'SELECTED B2_E x 1.E-12 (FOLDED)'
     &              ,NFREQ,FLOW,FHIG,VMX)
                  DO ifrq=1,NFREQ,IHFREQ
                    CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &                dble(brillCEF(3,ifrq)*1.0d-12))
                  ENDDO   !NFREQ
                  CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                  ID=ICFRB3EF
                  call hbook1m(ID,'SELECTED B3_E x 1.E-12 (FOLDED)'
     &              ,NFREQ,FLOW,FHIG,VMX)
                  DO ifrq=1,NFREQ,IHFREQ
                    CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &                dble(brillCEF(4,ifrq)*1.0d-12))
                  ENDDO   !NFREQ
                  CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                ENDIF !IEFOLD
              ENDIF !IFOLD.NE.2

            ENDIF !IBRILL

          ENDIF !ISTOKES

        ELSE  !IPIN

          ID=IDFREQ
          MFREQ=NINT((FHIG-FLOW)/DF)
          call hbook1m(ID,'PHOTON FLUX THROUGH PINHOLE',
     &      MFREQ,FLOW,FHIG,VMX)
          DO ifrq=1,NFREQ,IHFREQ
            CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,WFLUXT(ifrq))
          ENDDO   !NFREQ
          CALL MHROUT(ID,ICYCLE,' ')
          call hdeletm(ID)

          IF (IFOLD.NE.0) THEN
            ID=IDFREQF
            MFREQ=NINT((FHIG-FLOW)/DF)
            call hbook1m(ID,'PHOTON FLUX (pinhole, folded)',
     &        MFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,WFLUXTF(ifrq))
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)
          ENDIF   !IFOLD

        ENDIF !IPIN

      ELSE  !ifreq2P

        DF=FREQ(2)-FREQ(1)
        FLOW=FREQ(1)-DF/2.
        FHIG=FREQ(NFREQ)+DF/2.

        if (ifreq2p.eq.1.or.freqlow.eq.freqhig) then
          DF=freqhig-freqlow
          FLOW=freqlow-DF/2.
          FHIG=freqlow+DF/2.
        else if (ifreq2p.eq.-1) then
          FLOW=freqlow
          FHIG=freqhig
        endif

        IF (FLOW.LT.0.) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING SR HFREQ ***'
          WRITE(LUNGFO,*)'LOW EDGE OF HISTOGRAM NEGATIVE'
          WRITE(LUNGFO,*)
     &      'BE CAREFUL IF X-AXIS IS PLOTTED WITH LOGARITHMIC SCALE'
          WRITE(LUNGFO,*)
        ENDIF

        IF(IPIN.EQ.0) THEN

          DO IOBSV=1,NOBSV

            ID=ICFREQ+IOBSV
            call hbook1m(ID,'PHOTON FLUX DENSITY x 1.E-6 ',NFREQ,FLOW,FHIG,VMX)

            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          specTOT(IOBSV+NOBSV*(ifrq-1))*1.0d-6)
            ENDDO   !NFREQ

            CALL MHROUT(ID,ICYCLE,' ')
            CALL hdeletm(ID)

          IF (IFOLD.EQ.2) THEN

              ID=ICFREQ+1000+IOBSV
              call hbook1m(ID,
     &'PHOTON FLUX DENSITY x 1.E-6 (FOLDED)',NFREQ,FLOW,FHIG,VMX)

              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          specTOTF(IOBSV+NOBSV*(ifrq-1))*1.0d-6)
              ENDDO   !NFREQ

              CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

          ENDIF !IFOLD.EQ.2

          ENDDO !IOBSV

          IF (ISTOKES.NE.0) THEN

            ID=ICFRS0
            call hbook1m(ID,'S0 (sel. obs. point) x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          dble(stokES(1,1+NOBSV*(ifrq-1))*1.0d-6))
            ENDDO   !NFREQ

            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRS1
            call hbook1m(ID,'S1 (sel. obs. point) x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          dble(stokES(2,1+NOBSV*(ifrq-1))*1.0d-6))
            ENDDO   !NFREQ

            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRS2
            call hbook1m(ID,'S2 (sel. obs. point) x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          dble(stokES(3,1+NOBSV*(ifrq-1))*1.0d-6))
            ENDDO   !NFREQ

            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRS3
            call hbook1m(ID,'S3 (sel. obs. point) x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          dble(stokES(4,1+NOBSV*(ifrq-1))*1.0d-6))
            ENDDO   !NFREQ

            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP
            call hbook1m(ID,'P (sel. obs. point)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=SQRT
     &          ((STOKES(2,IOBFR)/STOKES(1,IOBFR))**2
     &          +(STOKES(3,IOBFR)/STOKES(1,IOBFR))**2
     &         +(STOKES(4,IOBFR)/STOKES(1,IOBFR))**2)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP1
            call hbook1m(ID,'P1 (sel. obs. point)'
     &                    ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=STOKES(2,IOBFR)/STOKES(1,IOBFR)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP2
            call hbook1m(ID,'P2 (sel. obs. point)'
     &                    ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=STOKES(3,IOBFR)/STOKES(1,IOBFR)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP3
            call hbook1m(ID,'P3 (sel. obs. point)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=STOKES(4,IOBFR)/STOKES(1,IOBFR)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP23
            call hbook1m(ID,'P23 (sel. obs. point)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=SQRT((STOKES(3,IOBFR)/STOKES(1,IOBFR))**2
     &          +(STOKES(4,IOBFR)/STOKES(1,IOBFR))**2)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRG3
            call hbook1m(ID,'G3 (sel. obs. point) x 1.E-6 '
     &                    ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=STOKES(4,IOBFR)/STOKES(1,IOBFR)*STOKES(4,IOBFR)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight*1.0d-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRG23
            call hbook1m(ID,'G23 (sel. obs. point) x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=((STOKES(3,IOBFR)/STOKES(1,IOBFR))**2
     &          +(STOKES(4,IOBFR)/STOKES(1,IOBFR))**2)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight*1.0d-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            IF (IEFOLD.NE.0) THEN

              ID=ICFRS0E
              call hbook1m(ID,'S0_E (sel. obs. point) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(WSTOKESE(1,ifrq)*1.0d-6))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRS1E
              call hbook1m(ID,'S1_E (sel. obs. point) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(wstokESE(2,ifrq)*1.0d-6))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRS2E
              call hbook1m(ID,'S2_E (sel. obs. point) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(wstokESE(3,ifrq)*1.0d-6))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRS3E
              call hbook1m(ID,'S3_E (sel. obs. point) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(wstokESE(4,ifrq)*1.0d-6))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRPE
              call hbook1m(ID,'P_E (sel. obs. point)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=SQRT
     &            ((WSTOKESE(2,ifrq)/WSTOKESE(1,ifrq))**2
     &            +(WSTOKESE(3,ifrq)/WSTOKESE(1,ifrq))**2
     &            +(WSTOKESE(4,ifrq)/WSTOKESE(1,ifrq))**2)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP1E
              call hbook1m(ID,'P1_E (sel. obs. point)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(2,ifrq)/WSTOKESE(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP2E
              call hbook1m(ID,'P2_E (sel. obs. point)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(3,ifrq)/WSTOKESE(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP3E
              call hbook1m(ID,'P3_E (sel. obs. point)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(4,ifrq)/WSTOKESE(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP23E
              call hbook1m(ID,'P23_E (sel. obs. point)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=SQRT(
     &            (WSTOKESE(3,ifrq)/WSTOKESE(1,ifrq))**2
     &            +(WSTOKESE(4,ifrq)/WSTOKESE(1,ifrq))**2)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRG3E
              call hbook1m(ID,'G3_E (sel. obs. point) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(4,ifrq)/WSTOKESE(1,ifrq)*WSTOKESE(4,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight*1.0d-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRG23E
              call hbook1m(ID,'G23_E (sel. obs. point) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(3,ifrq)/WSTOKESE(1,ifrq)*WSTOKESE(3,ifrq)
     &            +WSTOKESE(4,ifrq)/WSTOKESE(1,ifrq)*WSTOKESE(4,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight*1.0d-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

            ENDIF !IEFOLD

            IF (IBRILL.NE.0) THEN

              ID=ICFRB0
              call hbook1m(ID,'SELECTED B0 x 1.E-12'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(brillC(1,ifrq)*1.0d-12))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

              ID=ICFRB1
              call hbook1m(ID,'SELECTED B1 x 1.E-12'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(brillC(2,ifrq)*1.0d-12))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

              ID=ICFRB2
              call hbook1m(ID,'SELECTED B2 x 1.E-12'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(brillC(3,ifrq)*1.0d-12))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

              ID=ICFRB3
              call hbook1m(ID,'SELECTED B3 x 1.E-12'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(brillC(4,ifrq)*1.0d-12))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

              IF (IEFOLD.NE.0) THEN

                ID=ICFRB0E
                call hbook1m(ID,'SELECTED B0_E x 1.E-12'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(brillCE(1,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                ID=ICFRB1E
                call hbook1m(ID,'SELECTED B1_E x 1.E-12'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(brillCE(2,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                ID=ICFRB2E
                call hbook1m(ID,'SELECTED B2_E x 1.E-12'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(BRILLCE(3,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                ID=ICFRB3E
                call hbook1m(ID,'SELECTED B3_E x 1.E-12'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(BRILLCE(4,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ENDIF !IEFOLD

              IF (IFOLD.EQ.2) THEN

                ID=ICFRB0F
                call hbook1m(ID,'SELECTED B0 x 1.E-12 (FOLDED)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(BRILLCF(1,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

                ID=ICFRB1F
                call hbook1m(ID,'SELECTED B1 x 1.E-12 (FOLDED)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(BRILLCF(2,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

                ID=ICFRB2F
                call hbook1m(ID,'SELECTED B2 x 1.E-12 (FOLDED)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(BRILLCF(3,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

                ID=ICFRB3F
                call hbook1m(ID,'SELECTED B3 x 1.E-12 (FOLDED)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(BRILLCF(4,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

                IF (IEFOLD.NE.0) THEN

                  ID=ICFRB0EF
                  call hbook1m(ID,'SELECTED B0_E x 1.E-12 (FOLDED)'
     &              ,NFREQ,FLOW,FHIG,VMX)
                  DO ifrq=1,NFREQ,IHFREQ
                    CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &                dble(BRILLCEF(1,ifrq)*1.0d-12))
                  ENDDO   !NFREQ
                  CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                  ID=ICFRB1EF
                  call hbook1m(ID,'SELECTED B1_E x 1.E-12 (FOLDED)'
     &              ,NFREQ,FLOW,FHIG,VMX)
                  DO ifrq=1,NFREQ,IHFREQ
                    CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &                dble(BRILLCEF(2,ifrq)*1.0d-12))
                  ENDDO   !NFREQ
                  CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                  ID=ICFRB2EF
                  call hbook1m(ID,'SELECTED B2_E x 1.E-12 (FOLDED)'
     &              ,NFREQ,FLOW,FHIG,VMX)
                  DO ifrq=1,NFREQ,IHFREQ
                    CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &                dble(BRILLCEF(3,ifrq)*1.0d-12))
                  ENDDO   !NFREQ
                  CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                  ID=ICFRB3EF
                  call hbook1m(ID,'SELECTED B3_E x 1.E-12 (FOLDED)'
     &              ,NFREQ,FLOW,FHIG,VMX)
                  DO ifrq=1,NFREQ,IHFREQ
                    CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &                dble(BRILLCEF(4,ifrq)*1.0d-12))
                  ENDDO   !NFREQ
                  CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                ENDIF !IEFOLD
              ENDIF !IFOLD.NE.2

            ENDIF !IBRILL

          ENDIF !ISTOKES

        ELSE  !IPIN

          ID=IDFREQ
          call hbook1m(ID,'PHOTON FLUX (pinhole)',NFREQ,FLOW,FHIG,VMX)
          DO ifrq=1,NFREQ,IHFREQ
            CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,WFLUXT(ifrq))
          ENDDO   !NFREQ
          CALL MHROUT(ID,ICYCLE,' ')
         call hdeletm(ID)

          IF (IFOLD.NE.0) THEN
            ID=IDFREQF
            call hbook1m(ID,'PHOTON FLUX (pinhole, folded)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,WFLUXTF(ifrq))
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)
          ENDIF   !IFOLD

          IF (NSOURCE.GT.10) THEN
            JSOURCE=10
            WRITE(6,*)
            WRITE(6,*)'--- Information from HFREQ: More than 10 sources.'
            WRITE(6,*)'--- Generating flux histograms for every 10th source only'
            WRITE(6,*)
            WRITE(lungfo,*)
            WRITE(lungfo,*)'--- Information from HFREQ: More than 10 sources.'
            WRITE(lungfo,*)'--- Generating flux histograms for every 10th source only'
            WRITE(lungfo,*)
          else
            jsource=1
          ENDIF

          DO ISOUR=1,NSOURCE,JSOURCE

            ID=IDFREQ+200000+ISOUR
            call hbook1m(ID,'PHOTON FLUX (pinhole)',NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          WFLUX( ISOUR+NSOURCE*(ifrq-1)))
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
         call hdeletm(ID)

            IF (IFOLD.NE.0) THEN
              ID=IDFREQF+200000+ISOUR
              call hbook1m(ID,'PHOTON FLUX (pinhole, folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            WFLUXF(ISOUR+NSOURCE*(ifrq-1)))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)
            ENDIF   !IFOLD

          ENDDO !ISOURCE

          IF (ISTOKES.NE.0) THEN

            ID=IDFRS0
            call hbook1m(ID,'S0 (pinhole)',NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          dble(WSTOKES(1,ifrq)))
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=IDFRS1
            call hbook1m(ID,'S1 (pinhole)',NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          dble(WSTOKES(2,ifrq)))
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=IDFRS2
            call hbook1m(ID,'S2 (pinhole)',NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          dble(WSTOKES(3,ifrq)))
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=IDFRS3
            call hbook1m(ID,'S3 (pinhole)',NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          dble(WSTOKES(4,ifrq)))
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=IDFRP
            call hbook1m(ID,'P (pinhole)',NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (WSTOKES(1,ifrq).NE.0.0)
     &          WEIGHT=SQRT
     &          (WSTOKES(2,ifrq)**2+WSTOKES(3,ifrq)**2
     &          +WSTOKES(4,ifrq)**2)
     &          /WSTOKES(1,ifrq)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=IDFRP1
            call hbook1m(ID,'P1 (pinhole)',NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (WSTOKES(1,ifrq).NE.0.0)
     &          WEIGHT=WSTOKES(2,ifrq)/WSTOKES(1,ifrq)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=IDFRP2
            call hbook1m(ID,'P2 (pinhole)',NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (WSTOKES(1,ifrq).NE.0.0)
     &          WEIGHT=WSTOKES(3,ifrq)/WSTOKES(1,ifrq)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=IDFRP3
            call hbook1m(ID,'P3 (pinhole)',NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (WSTOKES(1,ifrq).NE.0.0)
     &          WEIGHT=WSTOKES(4,ifrq)/WSTOKES(1,ifrq)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=IDFRP23
            call hbook1m(ID,'P23 (pinhole)',NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (WSTOKES(1,ifrq).NE.0.0)
     &          WEIGHT=SQRT
     &          (WSTOKES(3,ifrq)**2+WSTOKES(4,ifrq)**2)
     &          /WSTOKES(1,ifrq)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=IDFRG3
            call hbook1m(ID,'G3 (pinhole)',NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (WSTOKES(1,ifrq).NE.0.0)
     &          WEIGHT=WSTOKES(4,ifrq)**2/WSTOKES(1,ifrq)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=IDFRG23
            call hbook1m(ID,'G23 (pinhole)',NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (WSTOKES(1,ifrq).NE.0.0)
     &          WEIGHT=
     &          (WSTOKES(3,ifrq)**2+WSTOKES(4,ifrq)**2)
     &          /WSTOKES(1,ifrq)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            IF (IFOLD.NE.0) THEN

              ID=IDFRS0F
              call hbook1m(ID,'S0 (pinhole, folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(WSTOKESF(1,ifrq)))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRS1F
              call hbook1m(ID,'S1  (pinhole, folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(WSTOKESF(2,ifrq)))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRS2F
              call hbook1m(ID,'S2 (pinhole, folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(WSTOKESF(3,ifrq)))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRS3F
              call hbook1m(ID,'S3 (pinhole, folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(WSTOKESF(4,ifrq)))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRPF
              call hbook1m(ID,'P (pinhole, folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESF(1,ifrq).NE.0.0)
     &            WEIGHT=SQRT
     &            (WSTOKESF(2,ifrq)**2+WSTOKESF(3,ifrq)**2
     &            +WSTOKESF(4,ifrq)**2)
     &            /WSTOKESF(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRP1F
              call hbook1m(ID,'P1 (pinhole, folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESF(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESF(2,ifrq)/WSTOKESF(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRP2F
              call hbook1m(ID,'P2 (pinhole, folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESF(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESF(3,ifrq)/WSTOKESF(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRP3F
              call hbook1m(ID,'P3 (pinhole, folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESF(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESF(4,ifrq)/WSTOKESF(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRP23F
              call hbook1m(ID,'P23 (pinhole, folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESF(1,ifrq).NE.0.0)
     &            WEIGHT=SQRT
     &            (WSTOKESF(3,ifrq)**2+WSTOKESF(4,ifrq)**2)
     &            /WSTOKESF(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRG3F
              call hbook1m(ID,'G3 (pinhole, folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESF(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESF(4,ifrq)**2/WSTOKESF(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRG23F
              call hbook1m(ID,'G23 (pinhole, folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESF(1,ifrq).NE.0.0)
     &            WEIGHT=(WSTOKESF(3,ifrq)**2+WSTOKESF(4,ifrq)**2)
     &            /WSTOKESF(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

            ENDIF   !IFOLD

            IF (IEFOLD.NE.0) THEN

              ID=IDFRS0E
              call hbook1m(ID,'S0_E (pinhole)',NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(WSTOKESE(1,ifrq)))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRS1E
              call hbook1m(ID,'S1_E (pinhole)',NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(WSTOKESE(2,ifrq)))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRS2E
              call hbook1m(ID,'S2_E (pinhole)',NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(WSTOKESE(3,ifrq)))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRS3E
              call hbook1m(ID,'S3_E (pinhole)',NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(WSTOKESE(4,ifrq)))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRPE
              call hbook1m(ID,'P_E (pinhole)',NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=SQRT
     &            (WSTOKESE(2,ifrq)**2+WSTOKESE(3,ifrq)**2
     &            +WSTOKESE(4,ifrq)**2)
     &            /WSTOKESE(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRP1E
              call hbook1m(ID,'P1_E (pinhole)',NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(2,ifrq)/WSTOKESE(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRP2E
              call hbook1m(ID,'P2_E (pinhole)',NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(3,ifrq)/WSTOKESE(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRP3E
              call hbook1m(ID,'P3_E (pinhole)',NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(4,ifrq)/WSTOKESE(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRP23E
              call hbook1m(ID,'P23_E (pinhole)',NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=SQRT
     &            (WSTOKESE(3,ifrq)**2+WSTOKESE(4,ifrq)**2)
     &            /WSTOKESE(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRG3E
              call hbook1m(ID,'G3_E (pinhole)',NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(4,ifrq)**2/WSTOKESE(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRG23E
              call hbook1m(ID,'G23_E (pinhole)',NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=
     &            (WSTOKESE(3,ifrq)**2+WSTOKESE(4,ifrq)**2)
     &            /WSTOKESE(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              IF (IFOLD.NE.0) THEN

                ID=IDFRS0EF
                call hbook1m(ID,'S0_E (pinhole, folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(WSTOKESEF(1,ifrq)))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
                 call hdeletm(ID)

                ID=IDFRS1EF
                call hbook1m(ID,'S1_E  (pinhole, folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(WSTOKESEF(2,ifrq)))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
                 call hdeletm(ID)

                ID=IDFRS2EF
                call hbook1m(ID,'S2_E (pinhole, folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(WSTOKESEF(3,ifrq)))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
                 call hdeletm(ID)

                ID=IDFRS3EF
                call hbook1m(ID,'S3_E (pinhole, folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(WSTOKESEF(4,ifrq)))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
                 call hdeletm(ID)

                ID=IDFRPEF
                call hbook1m(ID,'P_E (pinhole, folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (WSTOKESEF(1,ifrq).NE.0.0)
     &              WEIGHT=SQRT
     &              (WSTOKESEF(2,ifrq)**2+WSTOKESEF(3,ifrq)**2
     &              +WSTOKESEF(4,ifrq)**2)
     &              /WSTOKESEF(1,ifrq)
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
                 call hdeletm(ID)

                ID=IDFRP1EF
                call hbook1m(ID,'P1_E (pinhole, folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (WSTOKESEF(1,ifrq).NE.0.0)
     &              WEIGHT=WSTOKESEF(2,ifrq)/WSTOKESEF(1,ifrq)
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
                 call hdeletm(ID)


                ID=IDFRP2EF
                call hbook1m(ID,'P2_E (pinhole, folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (WSTOKESEF(1,ifrq).NE.0.0)
     &              WEIGHT=WSTOKESEF(3,ifrq)/WSTOKESEF(1,ifrq)
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
                 call hdeletm(ID)

                ID=IDFRP3EF
                call hbook1m(ID,'P3_E (pinhole, folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (WSTOKESEF(1,ifrq).NE.0.0)
     &              WEIGHT=WSTOKESEF(4,ifrq)/WSTOKESEF(1,ifrq)
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
                 call hdeletm(ID)

                ID=IDFRP23EF
                call hbook1m(ID,'P23_E (pinhole, folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (WSTOKESEF(1,ifrq).NE.0.0)
     &              WEIGHT=SQRT
     &              (WSTOKESEF(3,ifrq)**2+WSTOKESEF(4,ifrq)**2)
     &              /WSTOKESEF(1,ifrq)
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
                 call hdeletm(ID)

                ID=IDFRG3EF
                call hbook1m(ID,'G3_E (pinhole, folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (WSTOKESEF(1,ifrq).NE.0.0)
     &              WEIGHT=WSTOKESEF(4,ifrq)**2/WSTOKESEF(1,ifrq)
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
                 call hdeletm(ID)

                ID=IDFRG23EF
                call hbook1m(ID,'G23_E (pinhole, folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (WSTOKESEF(1,ifrq).NE.0.0)
     &              WEIGHT=(WSTOKESEF(3,ifrq)**2+WSTOKESEF(4,ifrq)**2)
     &              /WSTOKESEF(1,ifrq)
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
                 call hdeletm(ID)

              ENDIF   !IFOLD

            ENDIF   !IEFOLD

          ENDIF   !ISTOKES

        ENDIF !IPIN

      ENDIF !ifreq2P

C--- NTUPLE

100   CONTINUE

      CALL HFREQC

      IF (IPIN.NE.0) THEN
        DO IOBSV=1,NOBSV
          FILL(IOBSV)=0.0d0
        ENDDO
        TIT='DIST. IN PINHOLE'
        CALL HSPEC2(IDSPEC,TIT)
        TIT='HORIZ. CUT OF DIST. IN PINH.'
        CALL HSPEC1(IDSPEC-1,TIT,1)
        TIT='VERT. CUT OF DIST. IN PINH.'
        CALL HSPEC1(IDSPEC-2,TIT,2)
        IF (IPHASE.NE.0) THEN
          TIT='DIST. IN SOURCE PLANE'
          CALL HPHASE2(IDPHASE,TIT,PHFILL)
        ENDIF
      ENDIF

      IF (I47.EQ.1) THEN

        if (iroottrees.ge.0) then
          CALL hcdirm(OLDDIR,'R')
        endif

        FILE47='3700_'//FILEHB(1:123)

        if (iroottrees.ge.0) then
          CALL hropenm(47,'SPEC',FILE47,'NQ',1024,ISTAT)
          CALL hcdirm('//SPEC',' ')
        endif

        CALL MHROUT(IDCODE,ICYCLE,' ')

        CALL MHROUT(ICFREQ,ICYCLE,' ')

        CALL MHROUT(IDFREQ,ICYCLE,' ')

        CALL MHROUT(IDSPEC,ICYCLE,' ')
        CALL MHROUT(IDSPEC-1,ICYCLE,' ')
        CALL MHROUT(IDSPEC-2,ICYCLE,' ')
        call hdeletm(idspec)
        call hdeletm(idspec-1)
        call hdeletm(idspec-2)

+self,if=-mhbook.
        CALL hbookm(NIDSPEC,'ARRAYS SPECT, REAIMA',31
     &    ,'//SPEC',1024,CHSPEC)
        if (mpinr.ne.0) then
          CALL hbookm(NIDSPECRPHI,'ARRAYS SPECT AND SPECPOW, REAIMARPHI',33
     &      ,'//SPEC',1024,CHSPECRPHI)
        endif
+self,if=mhbook.
        CALL hbookm(NIDSPEC,'ARRAYS SPECT, REAIMA',31
     &    ,'//SPEC',nobsv*nfreq*nsource,CHSPEC)
        if (mpinr.ne.0) then
          CALL hbookm(NIDSPECRPHI,'ARRAYS SPECT AND SPECPOW, REAIMARPHI',33
     &      ,'//SPEC',nobsv*nfreq*nsource,CHSPECRPHI)
        endif
+self.
      ELSE !I47

+self,if=-mhbook.
        CALL hbookm(NIDSPEC,'ARRAYS SPECT, REAIMA',31
     &    ,'//WAVE',1024,CHSPEC)
        if (mpinr.ne.0) then
          CALL hbookm(NIDSPECRPHI,'ARRAYS SPECT, REAIMARPHI',33
     &      ,'//WAVE',1024,CHSPECRPHI)
          endif
+self,if=mhbook.
          CALL hbookm(NIDSPEC,'ARRAYS SPECT, REAIMA',31
     &    ,'//WAVE',nobsv*nfreq*nsource,CHSPEC)
        if (mpinr.ne.0) then
          CALL hbookm(NIDSPECRPHI,'ARRAYS SPECT, REAIMARPHI',33
     &      ,'//WAVE',nobsv*nfreq*nsource,CHSPECRPHI)
          endif
+self.

       ENDIF !I47

      smax=0.0d0
      do ifrq=1,nfreq
        DO iobsv=1,nobsv
          iobfr=iobsv+nobsv*(ifrq-1)
          if (spec(iobfr).gt.smax) then
            smax=spec(iobfr)
            reanor=
     &        reaima(1,1,iobfr)**2+reaima(1,2,iobfr)**2+
     &        reaima(2,1,iobfr)**2+reaima(2,2,iobfr)**2+
     &        reaima(3,1,iobfr)**2+reaima(3,2,iobfr)**2
          endif
        enddo
      enddo

      reanor=sqrt(smax/reanor)

      DO ISOUR=1,NSOURCE

        if (ispecdip.le.0) then
          censoux=(min(sourceeo(1,1,isour),xiend)
     &      +max(sourceao(1,1,isour),xianf))/2.d0
          censouy=sourceeo(2,1,isour)
          censouz=sourceeo(3,1,isour)
        else
          censoux=x0dip(isour)
          censouy=y0dip(isour)
          censouz=z0dip(isour)
        endif

        dist0=sqrt(
     &    ((pincen(3)-censouz)**2+
     &    (pincen(2)-censouy)**2)+
     &    (pincen(1)-censoux)**2)

        DO IOBSV=1,NOBSV

          IF (IPIN.NE.0) THEN
            IOBSVY=(IOBSV-1)/NOBSVZ+1
            IOBSVZ=IOBSV-NOBSVZ*(IOBSVY-1)
          ELSE
            IOBSVY=0
            IOBSVZ=0
          ENDIF
          DO ifrq=1,NFREQ,IHFREQ
            FSPEC(1)=ISOUR
            FSPEC(2)=IOBSV
            FSPEC(3)=OBSV(1,IOBSV)
            FSPEC(4)=OBSV(2,IOBSV)
            FSPEC(5)=OBSV(3,IOBSV)
            FSPEC(6)=FREQ(ifrq)
            FSPEC(7)=SPEC(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(ifrq-1)))
            FSPEC(8)=IOBSVZ
            FSPEC(9)=IOBSVY
            FSPEC(10)=ifrq
            IOBFR=IOBSV+NOBSV*(ifrq-1)
c            IF (ISPECMODE.EQ.3) THEN

              FSPEC(11)=reanor*reaIMA(1,1,IOBFR)
              FSPEC(12)=reanor*reaIMA(1,2,IOBFR)
              FSPEC(13)=reanor*reaIMA(2,1,IOBFR)
              FSPEC(14)=reanor*reaIMA(2,2,IOBFR)
              FSPEC(15)=reanor*reaIMA(3,1,IOBFR)
              FSPEC(16)=reanor*reaIMA(3,2,IOBFR)

              FSPEC(17)=reanor*reaIMA(4,1,IOBFR)
              FSPEC(18)=reanor*reaIMA(4,2,IOBFR)
              FSPEC(19)=reanor*reaIMA(5,1,IOBFR)
              FSPEC(20)=reanor*reaIMA(5,2,IOBFR)

              FSPEC(21)=reanor*reaIMA(6,1,IOBFR)
              FSPEC(22)=reanor*reaIMA(6,2,IOBFR)
              FSPEC(23)=reanor*reaIMA(7,1,IOBFR)
              FSPEC(24)=reanor*reaIMA(7,2,IOBFR)
              FSPEC(25)=reanor*reaIMA(8,1,IOBFR)
              FSPEC(26)=reanor*reaIMA(8,2,IOBFR)

              FSPEC(27)=reanor*reaIMA(9,1,IOBFR)
              FSPEC(28)=reanor*reaIMA(9,2,IOBFR)
              FSPEC(29)=reanor*reaIMA(10,1,IOBFR)
              FSPEC(30)=reanor*reaIMA(10,2,IOBFR)

              dist=sqrt(
     &          ((obsv(3,iobsv)-censouz)**2+
     &          (obsv(2,iobsv)-censouy)**2)+
     &          (obsv(1,iobsv)-censoux)**2)

              ddist=dist-dist0

              wlen=clight1*hbarev1*twopi1/freq(ifrq)
              waves=ddist/wlen
              dphase=waves*twopi1

              FSPEC(31)=dphase

              CALL hfm(NIDSPEC,FSPEC)

          ENDDO   !NFREQ
        ENDDO   !IOBSV
      ENDDO   !ISOUR

      IF (MPINR.NE.0) THEN
        DO ISOUR=1,NSOURCE
          DO IOBSV=1,NOBSVRPHI
            IF (IPIN.NE.0) THEN
              IOBSVPHI=(IOBSV-1)/NOBSVR+1
              IOBSVR=IOBSV-NOBSVR*(IOBSVPHI-1)
            ELSE
              IOBSVR=0
              IOBSVPHI=0
            ENDIF
            DO ifrq=1,NFREQ,IHFREQ
              FSPEC(1)=ISOUR
              FSPEC(2)=IOBSV
              FSPEC(3)=OBSVRPHI(1,IOBSV)
              FSPEC(4)=OBSVRPHI(2,IOBSV)*SIN(OBSVRPHI(3,IOBSV))
              FSPEC(5)=OBSVRPHI(2,IOBSV)*COS(OBSVRPHI(3,IOBSV))
              FSPEC(6)=OBSVRPHI(2,IOBSV)
              FSPEC(7)=OBSVRPHI(3,IOBSV)
              FSPEC(8)=FREQ(ifrq)
              FSPEC(9)=SPECRPHI(ISOUR+NSOURCE*(IOBSV-1+NOBSVRPHI*(ifrq-1)))
              FSPEC(10)=IOBSVR
              FSPEC(11)=IOBSVPHI
              FSPEC(12)=ifrq
              IOBFR=IOBSV+NOBSVRPHI*(ifrq-1)
              FSPEC(13)=reanor*reaIMARPHI(1,1,IOBFR)
              FSPEC(14)=reanor*reaIMARPHI(1,2,IOBFR)
              FSPEC(15)=reanor*reaIMARPHI(2,1,IOBFR)
              FSPEC(16)=reanor*reaIMARPHI(2,2,IOBFR)
              FSPEC(17)=reanor*reaIMARPHI(3,1,IOBFR)
              FSPEC(18)=reanor*reaIMARPHI(3,2,IOBFR)
              FSPEC(19)=reanor*reaIMARPHI(4,1,IOBFR)
              FSPEC(20)=reanor*reaIMARPHI(4,2,IOBFR)
              FSPEC(21)=reanor*reaIMARPHI(5,1,IOBFR)
              FSPEC(22)=reanor*reaIMARPHI(5,2,IOBFR)

              FSPEC(23)=reanor*reaIMARPHI(6,1,IOBFR)
              FSPEC(24)=reanor*reaIMARPHI(6,2,IOBFR)
              FSPEC(25)=reanor*reaIMARPHI(7,1,IOBFR)
              FSPEC(26)=reanor*reaIMARPHI(7,2,IOBFR)
              FSPEC(27)=reanor*reaIMARPHI(8,1,IOBFR)
              FSPEC(28)=reanor*reaIMARPHI(8,2,IOBFR)
              FSPEC(29)=reanor*reaIMARPHI(9,1,IOBFR)
              FSPEC(30)=reanor*reaIMARPHI(9,2,IOBFR)
              FSPEC(31)=reanor*reaIMARPHI(10,1,IOBFR)
              FSPEC(32)=reanor*reaIMARPHI(10,2,IOBFR)

              h2=(obsvr(iobsvr)/dist0)**2

              if (h2.lt.0.01) then
                ddist=dist0*(h2/2.0d0-h2**2/8.0d0)
              else
                ddist=dist0*(sqrt(1.0d0+h2)-1.0d0)
              endif

              dphase=ddist/freq(ifrq)*wtoe1*1.0d9*twopi1

              FSPEC(33)=dphase

              CALL hfm(NIDSPECRPHI,FSPEC)

            ENDDO   !NFREQ
          ENDDO   !IOBSV
        ENDDO   !ISOUR
      ENDIF !MPINR

      IF (I47.EQ.1) THEN

        CALL MHROUT(NIDSPEC,ICYCLE,' ')
        if (mpinr.ne.0) then
          CALL MHROUT(NIDSPECRPHI,ICYCLE,' ')
        endif

        if (iroottrees.ge.0) then
          CALL hrendm('SPEC')
        endif
        CLOSE(47)

        if (iroottrees.ge.0) then
          CALL hcdirm(OLDDIR,' ')
        endif

      ENDIF !I47

+self,if=-mhbook.
      CALL hbookm(NIDSPEC+2,'BRILLIANCE',17
     &  ,'//WAVE',1024,CHBRILL)
+self,if=mhbook.
      CALL hbookm(NIDSPEC+2,'BRILLIANCE',17
     &  ,'//WAVE',nobsv*nfreq*nsource,CHBRILL)
+self.

C BRILLIANCE
      DO ifrq=1,NFREQ,IHFREQ
        FSPEC(1)=FREQ(ifrq)
        DO I=2,16
          FSPEC(I)=0.
        ENDDO
        IF (IBRILL.NE.0) THEN
          FSPEC(2)=BRILLC(1,ifrq)
          FSPEC(3)=BRILLC(2,ifrq)
          FSPEC(4)=BRILLC(3,ifrq)
          FSPEC(5)=BRILLC(4,ifrq)
          IF (IFOLD.NE.0) THEN
            FSPEC(6)=BRILLCF(1,ifrq)
            FSPEC(7)=BRILLCF(2,ifrq)
            FSPEC(8)=BRILLCF(3,ifrq)
            FSPEC(9)=BRILLCF(4,ifrq)
          ENDIF
          IF (IEFOLD.NE.0) THEN
            FSPEC(10)= BRILLCE(1,ifrq)
            FSPEC(11)=BRILLCE(2,ifrq)
            FSPEC(12)=BRILLCE(3,ifrq)
            FSPEC(13)=BRILLCE(4,ifrq)
          ENDIF
          IF (IEFOLD.NE.0.AND.IFOLD.NE.0) THEN
            FSPEC(14)= BRILLCEF(1,ifrq)
            FSPEC(15)=BRILLCEF(2,ifrq)
            FSPEC(16)=BRILLCEF(3,ifrq)
            FSPEC(17)=BRILLCEF(4,ifrq)
          ENDIF
        ENDIF  !IBRILL
        CALL hfm(NIDSPEC+2,FSPEC)
      ENDDO   !NFREQ

      IF (ISPECINT.NE.0) THEN

+self,if=-mhbook.
        CALL hbookm(NIDPOW-1,'POWER DENSITY FROM SPECTRUM',8
     &    ,'//WAVE',1000,CHPOW)
+self,if=mhbook.
        CALL hbookm(NIDPOW-1,'POWER DENSITY FROM SPECTRUM',8
     &    ,'//WAVE',nobsv*nsource,CHPOW)
+self.
        DO ISOUR=1,NSOURCE
          DO IOBSV=1,NOBSV

            IF (IPIN.NE.0) THEN
              IOBSVY=(IOBSV-1)/NOBSVZ+1
              IOBSVZ=IOBSV-NOBSVZ*(IOBSVY-1)
            ELSE
              IOBSVY=1
              IOBSVZ=1
            ENDIF

            FSPEC(1)=OBSV(1,IOBSV)
            FSPEC(2)=OBSV(2,IOBSV)
            FSPEC(3)=OBSV(3,IOBSV)
            FSPEC(4)=SPECI(ISOUR+NSOURCE*(IOBSV-1))
            FSPEC(5)=IOBSVZ
            FSPEC(6)=IOBSVY
            FSPEC(7)=IOBSV
            FSPEC(8)=ISOUR

            CALL hfm(NIDPOW-1,FSPEC)

          ENDDO   !IOBSV
        ENDDO   !ISOUR

+self,if=-mhbook.
        CALL hbookm(NIDPOW-2,'HORIZ. POWER DENSITY FROM SPECTRUM(VERT. INT.)',5
     &    ,'//WAVE',1000,CHPOWV)
+self,if=mhbook.
        CALL hbookm(NIDPOW-2,'HORIZ. POWER DENSITY FROM SPECTRUM(VERT. INT.)',5
     &    ,'//WAVE',nobsv*nsource,CHPOWV)
+self.
        DO ISOUR=1,NSOURCE
          DO IOBSVZ=1,NOBSVZ

            FSPEC(1)=OBSV(1,IOBSVZ)
            FSPEC(2)=OBSV(3,IOBSVZ)
            FSPEC(3)=SPECIV(ISOUR+NSOURCE*(IOBSVZ-1))
            FSPEC(4)=IOBSVZ
            FSPEC(5)=ISOUR

            CALL hfm(NIDPOW-2,FSPEC)

          ENDDO   !IOBSV
        ENDDO   !ISOUR

        IF (IFOLD.NE.0) THEN

+self,if=-mhbook.
          CALL hbookm(NIDPOW-10,'POWER DENSITY FROM SPECTRUM (FOLDED)',8
     &      ,'//WAVE',1000,CHPOW)
+self,if=mhbook.
          CALL hbookm(NIDPOW-10,'POWER DENSITY FROM SPECTRUM (FOLDED)',8
     &      ,'//WAVE',nobsv*nsource,CHPOW)
+self.

          DO ISOUR=1,NSOURCE
            DO IOBSV=1,NOBSV

              IF (IPIN.NE.0) THEN
                IOBSVY=(IOBSV-1)/NOBSVZ+1
                IOBSVZ=IOBSV-NOBSVZ*(IOBSVY-1)
              ELSE
                IOBSVY=1
                IOBSVZ=1
              ENDIF

              FSPEC(1)=OBSV(1,IOBSV)
              FSPEC(2)=OBSV(2,IOBSV)
              FSPEC(3)=OBSV(3,IOBSV)
              FSPEC(4)=SPECIF(ISOUR+NSOURCE*(IOBSV-1))
              FSPEC(5)=IOBSVZ
              FSPEC(6)=IOBSVY
              FSPEC(7)=IOBSV
              FSPEC(8)=ISOUR
              CALL hfm(NIDPOW-10,FSPEC)

            ENDDO   !IOBSV
          ENDDO   !ISOUR

        ENDIF  !IFOLD

      ENDIF !ISPECINT

+self,if=-mhbook.
      CALL hbookm(NIDPOW,'POWER DENSITY',8
     &  ,'//WAVE',1000,CHPOWF)
+self,if=mhbook.
      CALL hbookm(NIDPOW,'POWER DENSITY',8
     &  ,'//WAVE',nobsv*nsource,CHPOWF)
+self.

      DO ISOUR=1,NSOURCE
        DO IOBSV=1,NOBSV

          IF (IPIN.NE.0) THEN
            IOBSVY=(IOBSV-1)/NOBSVZ+1
            IOBSVZ=IOBSV-NOBSVZ*(IOBSVY-1)
          ELSE
            IOBSVY=1
            IOBSVZ=1
          ENDIF

          FSPEC(1)=OBSV(1,IOBSV)
          FSPEC(2)=OBSV(2,IOBSV)
          FSPEC(3)=OBSV(3,IOBSV)
          FSPEC(4)=SPECPOW(ISOUR+NSOURCE*(IOBSV-1))
          if (ifold.ne.0) then
            FSPEC(5)=SPECPOWf(ISOUR+NSOURCE*(IOBSV-1))
          else
            FSPEC(5)=0.0d0
          endif
          FSPEC(6)=IOBSVZ
          FSPEC(7)=IOBSVY
          FSPEC(8)=IOBSV
          FSPEC(9)=ISOUR
          CALL hfm(NIDPOW,FSPEC)

        ENDDO   !IOBSV
      ENDDO   !ISOUR

+self,if=-mhbook.
      CALL hbookm(NIDPOW+1,'HORIZ. POWER DENSITY (VERT. INT.)',5
     &  ,'//WAVE',1000,CHPOWV)
+self,if=mhbook.
      CALL hbookm(NIDPOW+1,'HORIZ. POWER DENSITY (VERT. INT.)',5
     &  ,'//WAVE',nobsv*nsource,CHPOWV)
+self.

      DO ISOUR=1,NSOURCE
        DO IOBSVZ=1,NOBSVZ

          FSPEC(1)=OBSV(1,IOBSVZ)
          FSPEC(2)=OBSV(3,IOBSVZ)
          FSPEC(3)=SPECPOWV(ISOUR+NSOURCE*(IOBSVZ-1))
          FSPEC(4)=IOBSVZ
          FSPEC(5)=ISOUR
          CALL hfm(NIDPOW+1,FSPEC)

        ENDDO   !IOBSV
      ENDDO   !ISOUR

      IF(IPIN.EQ.0) THEN

        ND=NIDFREQ
+self,if=-mhbook.
        CALL hbookm(ND,'PHOTON FLUX DENSITY',5,
     &    '//WAVE',1000,CHTAGS)
+self,if=mhbook.
        CALL hbookm(ND,'PHOTON FLUX DENSITY',5,
     &    '//WAVE',nobsv*nfreq,CHTAGS)
+self.
        DO IOBSV=1,NOBSV
          DO ifrq=1,NFREQ,IHFREQ
            FSTUPLE(1)=OBSV(1,IOBSV)
            FSTUPLE(2)=OBSV(2,IOBSV)
            FSTUPLE(3)=OBSV(3,IOBSV)
            FSTUPLE(4)=FREQ(ifrq)
            FSTUPLE(5)=SPECTOT(IOBSV+NOBSV*(ifrq-1))
            CALL hfm(ND,FSTUPLE)
          ENDDO   !NFREQ
        ENDDO !IOBSV

      ELSE  !IPIN

+self,if=-mhbook.
        CALL hbookm(NIDFREQP,'PHOTON FLUX THROUGH PINHOLE',20,
     &      '//WAVE',1000,CHTAGSf)
+self,if=mhbook.
        CALL hbookm(NIDFREQP,'PHOTON FLUX THROUGH PINHOLE',20,
     &      '//WAVE',nfreq,CHTAGSf)
+self.
          fstuple=0.0
          DO ifrq=1,NFREQ,IHFREQ
            FSTUPLE(1)=ifrq
            FSTUPLE(2)=FREQ(ifrq)
            FSTUPLE(3)=WFLUXT(ifrq)
            if (ifold.ne.0) FSTUPLE(4)=WFLUXTF(ifrq)
            if (istokes.ne.0) then
              FSTUPLE(5)=wstokes(1,ifrq)
              FSTUPLE(6)=wstokes(2,ifrq)
              FSTUPLE(7)=wstokes(3,ifrq)
              FSTUPLE(8)=wstokes(4,ifrq)
              if (ifold.ne.0) then
                FSTUPLE(9)=wstokesf(1,ifrq)
                FSTUPLE(10)=wstokesf(2,ifrq)
                FSTUPLE(11)=wstokesf(3,ifrq)
                FSTUPLE(12)=wstokesf(4,ifrq)
              endif
              if (iefold.ne.0) then
                FSTUPLE(13)=wstokese(1,ifrq)
                FSTUPLE(14)=wstokese(2,ifrq)
                FSTUPLE(15)=wstokese(3,ifrq)
                FSTUPLE(16)=wstokese(4,ifrq)
              endif
              if (ifold*iefold.ne.0) then
                FSTUPLE(17)=wstokesef(1,ifrq)
                FSTUPLE(18)=wstokesef(2,ifrq)
                FSTUPLE(19)=wstokesef(3,ifrq)
                FSTUPLE(20)=wstokesef(4,ifrq)
              endif
            endif !istokes
            CALL hfm(NIDFREQP,FSTUPLE)
          ENDDO   !NFREQ

        ENDIF !IPIN

+self,if=-mhbook.
        CALL hbookm(NIDFREQP+1,'Photon flux-density for selected point',36,
     &    '//WAVE',1000,CHTAGSfd)
+self,if=mhbook.
        CALL hbookm(NIDFREQP+1,'Photon flux-density for selected point',36,
     &    '//WAVE',nfreq,CHTAGSfd)
+self.
        fstuple=0.0
        DO ifrq=1,NFREQ,IHFREQ
          FSTUPLE(1)=ifrq
          FSTUPLE(2)=FREQ(ifrq)
          FSTUPLE(3)=SPECTOT(ICBRILL+NOBSV*(ifrq-1))
          if (ifold.ne.0) FSTUPLE(4)=SPECTOTF(ICBRILL+NOBSV*(ifrq-1))
          if (istokes.ne.0) then
            FSTUPLE(5)=stokec(1,ifrq)
            FSTUPLE(6)=stokec(2,ifrq)
            FSTUPLE(7)=stokec(3,ifrq)
            FSTUPLE(8)=stokec(4,ifrq)
            if (ifold.ne.0) then
              FSTUPLE(9)=stokecf(1,ifrq)
              FSTUPLE(10)=stokecf(2,ifrq)
              FSTUPLE(11)=stokecf(3,ifrq)
              FSTUPLE(12)=stokecf(4,ifrq)
            endif
            if (iefold.ne.0) then
              FSTUPLE(13)=stokece(1,ifrq)
              FSTUPLE(14)=stokece(2,ifrq)
              FSTUPLE(15)=stokece(3,ifrq)
              FSTUPLE(16)=stokece(4,ifrq)
            endif
            if (ifold*iefold.ne.0) then
              FSTUPLE(17)=stokecef(1,ifrq)
              FSTUPLE(18)=stokecef(2,ifrq)
              FSTUPLE(19)=stokecef(3,ifrq)
              FSTUPLE(20)=stokecef(4,ifrq)
            endif
            if (ibrill.ne.0) then
              FSTUPLE(21)=brillc(1,ifrq)
              FSTUPLE(22)=brillc(2,ifrq)
              FSTUPLE(23)=brillc(3,ifrq)
              FSTUPLE(24)=brillc(4,ifrq)
              if (ifold.ne.0) then
                FSTUPLE(25)=brillcf(1,ifrq)
                FSTUPLE(26)=brillcf(2,ifrq)
                FSTUPLE(27)=brillcf(3,ifrq)
                FSTUPLE(28)=brillcf(4,ifrq)
              endif
              if (iefold.ne.0) then
                FSTUPLE(29)=brillce(1,ifrq)
                FSTUPLE(30)=brillce(2,ifrq)
                FSTUPLE(31)=brillce(3,ifrq)
                FSTUPLE(32)=brillce(4,ifrq)
              endif
              if (ifold*iefold.ne.0) then
                FSTUPLE(33)=brillcef(1,ifrq)
                FSTUPLE(34)=brillcef(2,ifrq)
                FSTUPLE(35)=brillcef(3,ifrq)
                FSTUPLE(36)=brillcef(4,ifrq)
              endif
            endif !ibrill
          endif !istokes
          CALL hfm(NIDFREQP+1,FSTUPLE)
        ENDDO   !NFREQ

        IF (IHFIL.NE.0) THEN
          chtags(2)='muph'
          CALL hbookm(NIDFIL,'PHOTON ABSORPTION COEFF. [M**2/KG]',2,
     &      '//WAVE',1000,CHTAGS)
          chtags(2)='muen'
          CALL hbookm(NIDMUEN,'ENERGY ABSORPTION COEFF. [m**2/kg]'
     &      ,2,'//WAVE',1000,CHTAGS)

          DO ifrq=1,NFREQ,IHFREQ
            FSTUPLE(1)=FREQ(ifrq)
            IF (IFILMUL.EQ.0) THEN
              FSTUPLE(2)=ABSMU(ifrq)
            ELSE
              FSTUPLE(2)=ABSMUTOT(ifrq)
            ENDIF
            CALL hfm(NIDFIL,FSTUPLE)
          ENDDO   !NFREQ

          DO ifrq=1,NFREQ,IHFREQ
            FSTUPLE(1)=FREQ(ifrq)
            FSTUPLE(2)=ABSMUEN(ifrq)
            CALL hfm(NIDMUEN,FSTUPLE)
          ENDDO   !NFREQ

        ENDIF !IHFIL

        IF (IFOLD.NE.0) THEN

          IF (I47.EQ.1) THEN

            if (iroottrees.ge.0) then
              CALL hcdirm(OLDDIR,'R')
            endif

            FILE47='3701_'//FILEHB(1:123)

            if (iroottrees.ge.0) then
              CALL hropenm(47,'SPECF',FILE47,'NQ',1024,ISTAT)
              CALL hcdirm('//SPECF',' ')
            endif

            CALL MHROUT(IDCODE,ICYCLE,' ')

            CALL MHROUT(ICFREQF,ICYCLE,' ')

            CALL MHROUT(IDFREQF,ICYCLE,' ')

            CALL MHROUT(IDSPEC,ICYCLE,' ')
            CALL MHROUT(IDSPEC-1,ICYCLE,' ')
            CALL MHROUT(IDSPEC-2,ICYCLE,' ')
            call hdeletm(idspec)
            call hdeletm(idspec-1)
            call hdeletm(idspec-2)

+self,if=mhbook.
            CALL hbookm(NIDSPECF,'ARRAYS SPECF',18
     &        ,'//SPECF',nobsv*nfreq*nsource,CHSPECF)

          ELSE !I47

            CALL hbookm(NIDSPECF,'ARRAYS SPECF',18
     &        ,'//WAVE',nobsv*nfreq*nsource,CHSPECF)
+self,if=-mhbook.
            CALL hbookm(NIDSPECF,'ARRAYS SPECF',18
     &        ,'//SPECF',1024,CHSPECF)

          ELSE !I47

            CALL hbookm(NIDSPECF,'ARRAYS SPECF',18
     &        ,'//WAVE',1024,CHSPECF)
+self.
          ENDIF !I47

          DO ISOUR=1,NSOURCE
            DO IOBSV=1,NOBSV
              IF (IPIN.NE.0) THEN
                IOBSVY=(IOBSV-1)/NOBSVZ+1
                IOBSVZ=IOBSV-NOBSVZ*(IOBSVY-1)
              ELSE
                IOBSVY=1
                IOBSVZ=1
              ENDIF
              DO ifrq=1,NFREQ,IHFREQ
                FSPEC(1)=ISOUR
                FSPEC(2)=IOBSV
                FSPEC(3)=OBSV(1,IOBSV)
                FSPEC(4)=OBSV(2,IOBSV)
                FSPEC(5)=OBSV(3,IOBSV)
                FSPEC(6)=FREQ(ifrq)
                FSPEC(7)=SPECF(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(ifrq-1)))
                FSPEC(8)=IOBSVZ
                FSPEC(9)=IOBSVY
                FSPEC(10)=ifrq

                IOBFR=IOBSV+NOBSV*(ifrq-1)

                FSPEC(11)=reanor*reaIMA(4,1,IOBFR)
                FSPEC(12)=reanor*reaIMA(4,2,IOBFR)
                FSPEC(13)=reanor*reaIMA(5,1,IOBFR)
                FSPEC(14)=reanor*reaIMA(5,2,IOBFR)

c                FSPEC(15)=reanor*reaIMA(6,1,IOBFR)
c                FSPEC(16)=reanor*reaIMA(6,2,IOBFR)
c                FSPEC(17)=reanor*reaIMA(7,1,IOBFR)
c                FSPEC(18)=reanor*reaIMA(7,2,IOBFR)
c                FSPEC(19)=reanor*reaIMA(8,1,IOBFR)
c                FSPEC(20)=reanor*reaIMA(8,2,IOBFR)

                FSPEC(15)=reanor*reaIMA(9,1,IOBFR)
                FSPEC(16)=reanor*reaIMA(9,2,IOBFR)
                FSPEC(17)=reanor*reaIMA(10,1,IOBFR)
                FSPEC(18)=reanor*reaIMA(10,2,IOBFR)

c                FSPEC(21)=reanor*reaIMA(9,1,IOBFR)
c                FSPEC(22)=reanor*reaIMA(9,2,IOBFR)
c                FSPEC(23)=reanor*reaIMA(10,1,IOBFR)
c                FSPEC(24)=reanor*reaIMA(10,2,IOBFR)

                CALL hfm(NIDSPECF,FSPEC)
              ENDDO   !NFREQ
            ENDDO   !IOBSV
        ENDDO   !ISOUR

        IF (I47.EQ.1) THEN
          CALL MHROUT(NIDSPECF,ICYCLE,' ')
          if (iroottrees.ge.0) then
            CALL hrendm('SPECF')
          endif
          CLOSE(47)
          if (iroottrees.ge.0) then
            CALL hcdirm(OLDDIR,' ')
          endif
        ENDIF !I47

      ENDIF !IFOLD

      IF (ISTOKES.NE.0) THEN

        IF (I47.EQ.1) THEN

          if (iroottrees.ge.0) then
            CALL hcdirm(OLDDIR,'R')
          endif

          FILE47='4700_'//FILEHB(1:123)

          if (iroottrees.ge.0) then
            CALL hropenm(47,'STOKES',FILE47,'NQ',1024,ISTAT)
            CALL hcdirm('//STOKES',' ')
          endif

          CALL MHROUT(IDCODE,ICYCLE,' ')

          CALL MHROUT(ICFRS0,ICYCLE,' ')
          CALL MHROUT(ICFRS1,ICYCLE,' ')
          CALL MHROUT(ICFRS2,ICYCLE,' ')
          CALL MHROUT(ICFRS3,ICYCLE,' ')

          CALL MHROUT(ICFRP,ICYCLE,' ')
          CALL MHROUT(ICFRP1,ICYCLE,' ')
          CALL MHROUT(ICFRP2,ICYCLE,' ')
          CALL MHROUT(ICFRP3,ICYCLE,' ')
          CALL MHROUT(ICFRP23,ICYCLE,' ')

          CALL MHROUT(ICFRG3,ICYCLE,' ')
          CALL MHROUT(ICFRG23,ICYCLE,' ')

          IF (IBRILL.NE.0) THEN
            CALL MHROUT(ICFRB0,ICYCLE,' ')
            CALL MHROUT(ICFRB1,ICYCLE,' ')
            CALL MHROUT(ICFRB2,ICYCLE,' ')
            CALL MHROUT(ICFRB3,ICYCLE,' ')
          ENDIF

          CALL MHROUT(IDFRS0,ICYCLE,' ')
          CALL MHROUT(IDFRS1,ICYCLE,' ')
          CALL MHROUT(IDFRS2,ICYCLE,' ')
          CALL MHROUT(IDFRS3,ICYCLE,' ')

          CALL MHROUT(IDFRP,ICYCLE,' ')
          CALL MHROUT(IDFRP1,ICYCLE,' ')
          CALL MHROUT(IDFRP2,ICYCLE,' ')
          CALL MHROUT(IDFRP3,ICYCLE,' ')
          CALL MHROUT(IDFRP23,ICYCLE,' ')

          CALL MHROUT(IDFRG3,ICYCLE,' ')
          CALL MHROUT(IDFRG23,ICYCLE,' ')

          CALL MHROUT(IDSPEC,ICYCLE,' ')
          CALL MHROUT(IDSPEC-1,ICYCLE,' ')
          CALL MHROUT(IDSPEC-2,ICYCLE,' ')
          call hdeletm(idspec)
          call hdeletm(idspec-1)
          call hdeletm(idspec-2)

+self,if=-mhbook.
          CALL hbookm(NIDSTOK,'STOKES ARRAYS',12
     &      ,'//STOKES',1000,CHSTOK)

        ELSE !I47

          CALL hbookm(NIDSTOK,'STOKES ARRAYS',12
     &      ,'//WAVE',1000,CHSTOK)
+self,if=mhbook.
          CALL hbookm(NIDSTOK,'STOKES ARRAYS',12
     &      ,'//STOKES',nobsv*nfreq*nsource,CHSTOK)

        ELSE !I47

          CALL hbookm(NIDSTOK,'STOKES ARRAYS',12
     &      ,'//WAVE',nobsv*nfreq*nsource,CHSTOK)
+self.
        ENDIF !I47

        DO IOBSV=1,NOBSV
          IF (IPIN.NE.0) THEN
            IOBSVY=(IOBSV-1)/NOBSVZ+1
            IOBSVZ=IOBSV-NOBSVZ*(IOBSVY-1)
          ELSE
            IOBSVY=1
            IOBSVZ=1
          ENDIF
          DO ifrq=1,NFREQ,IHFREQ
            FSPEC(1)=IOBSV
            FSPEC(2)=OBSV(1,IOBSV)
            FSPEC(3)=OBSV(2,IOBSV)
            FSPEC(4)=OBSV(3,IOBSV)
            FSPEC(5)=FREQ(ifrq)
            IOBFR=IOBSV+NOBSV*(ifrq-1)
            FSPEC(6)=STOKES(1,IOBFR)
            FSPEC(7)=STOKES(2,IOBFR)
            FSPEC(8)=STOKES(3,IOBFR)
            FSPEC(9)=STOKES(4,IOBFR)
            FSPEC(10)=IOBSVZ
            FSPEC(11)=IOBSVY
            FSPEC(12)=ifrq
            CALL hfm(NIDSTOK,FSPEC)
            ENDDO   !NFREQ
          ENDDO   !IOBSV

          IF (I47.EQ.1) THEN

            CALL MHROUT(NIDSTOK,ICYCLE,' ')

            if (iroottrees.ge.0) then
              CALL hrendm('STOKES')
            endif
            CLOSE(47)

            if (iroottrees.ge.0) then
              CALL hcdirm(OLDDIR,' ')
            endif

          ENDIF !I47

        ENDIF  !ISTOKES

        IF (ISTOKES.NE.0.AND.IFOLD.EQ.1) THEN

          IF (I47.EQ.1) THEN

            if (iroottrees.ge.0) then
              CALL hcdirm(OLDDIR,'R')
            endif

            FILE47='4701_'//FILEHB(1:123)

            if (iroottrees.ge.0) then
              CALL hropenm(47,'STOKESF',FILE47,'NQ',1024,ISTAT)
              CALL hcdirm('//STOKESF',' ')
            endif

            CALL MHROUT(IDCODE,ICYCLE,' ')

            CALL MHROUT(ICFRS0F,ICYCLE,' ')
            CALL MHROUT(ICFRS1F,ICYCLE,' ')
            CALL MHROUT(ICFRS2F,ICYCLE,' ')
            CALL MHROUT(ICFRS3F,ICYCLE,' ')

            CALL MHROUT(ICFRPF,ICYCLE,' ')
            CALL MHROUT(ICFRP1F,ICYCLE,' ')
            CALL MHROUT(ICFRP2F,ICYCLE,' ')
            CALL MHROUT(ICFRP3F,ICYCLE,' ')
            CALL MHROUT(ICFRP23F,ICYCLE,' ')

            CALL MHROUT(ICFRG3F,ICYCLE,' ')
            CALL MHROUT(ICFRG23F,ICYCLE,' ')

            IF (IBRILL.NE.0) THEN
              CALL MHROUT(ICFRB0F,ICYCLE,' ')
              CALL MHROUT(ICFRB1F,ICYCLE,' ')
              CALL MHROUT(ICFRB2F,ICYCLE,' ')
              CALL MHROUT(ICFRB3F,ICYCLE,' ')
            ENDIF

            CALL MHROUT(IDFRS0F,ICYCLE,' ')
            CALL MHROUT(IDFRS1F,ICYCLE,' ')
            CALL MHROUT(IDFRS2F,ICYCLE,' ')
            CALL MHROUT(IDFRS3F,ICYCLE,' ')

            CALL MHROUT(IDFRPF,ICYCLE,' ')
            CALL MHROUT(IDFRP1F,ICYCLE,' ')
            CALL MHROUT(IDFRP2F,ICYCLE,' ')
            CALL MHROUT(IDFRP3F,ICYCLE,' ')
            CALL MHROUT(IDFRP23F,ICYCLE,' ')

            CALL MHROUT(IDFRG3F,ICYCLE,' ')
            CALL MHROUT(IDFRG23F,ICYCLE,' ')

            CALL MHROUT(IDSPEC,ICYCLE,' ')
            CALL MHROUT(IDSPEC-1,ICYCLE,' ')
            CALL MHROUT(IDSPEC-2,ICYCLE,' ')
            call hdeletm(idspec)
            call hdeletm(idspec-1)
            call hdeletm(idspec-2)

+self,if=-mhbook.
            CALL hbookm(NIDSTOKF,'STOKES ARRAYS (FOLDED)',12
     &        ,'//STOKESF',1000,CHSTOK)

          ELSE !I47

            CALL hbookm(NIDSTOKF,'STOKES ARRAYS (FOLDED)',12
     &        ,'//WAVE',1000,CHSTOK)
+self,if=mhbook.
            CALL hbookm(NIDSTOKF,'STOKES ARRAYS (FOLDED)',12
     &        ,'//STOKESF',nobsv*nfreq*nsource,CHSTOK)

          ELSE !I47

            CALL hbookm(NIDSTOKF,'STOKES ARRAYS (FOLDED)',12
     &        ,'//WAVE',nobsv*nfreq*nsource,CHSTOK)
+self.
          ENDIF !I47

          DO IOBSV=1,NOBSV
            IF (IPIN.NE.0) THEN
              IOBSVY=(IOBSV-1)/NOBSVZ+1
              IOBSVZ=IOBSV-NOBSVZ*(IOBSVY-1)
            ELSE
              IOBSVY=1
              IOBSVZ=1
            ENDIF
            DO ifrq=1,NFREQ,IHFREQ
              FSPEC(1)=IOBSV
              FSPEC(2)=OBSV(1,IOBSV)
              FSPEC(3)=OBSV(2,IOBSV)
              FSPEC(4)=OBSV(3,IOBSV)
              FSPEC(5)=FREQ(ifrq)
              IOBFR=IOBSV+NOBSV*(ifrq-1)
              FSPEC(6)=STOKESF(1,IOBFR)
              FSPEC(7)=STOKESF(2,IOBFR)
              FSPEC(8)=STOKESF(3,IOBFR)
              FSPEC(9)=STOKESF(4,IOBFR)
              FSPEC(10)=IOBSVZ
              FSPEC(11)=IOBSVY
              FSPEC(12)=ifrq
              CALL hfm(NIDSTOKF,FSPEC)
            ENDDO   !NFREQ
          ENDDO   !IOBSV

          IF (I47.EQ.1) THEN

            CALL MHROUT(NIDSTOKF,ICYCLE,' ')

            if (iroottrees.ge.0) then
              CALL hrendm('STOKESF')
            endif
            CLOSE(47)

            if (iroottrees.ge.0) then
              CALL hcdirm(OLDDIR,' ')
            endif

        ENDIF !I47

        ENDIF  !ISTOKES,FOLD

        IF (ISTOKES.NE.0.AND.IEFOLD.ne.0) THEN

          IF (I47.EQ.1) THEN

            if (iroottrees.ge.0) then
              CALL hcdirm(OLDDIR,'R')
            endif

            FILE47='4702_'//FILEHB(1:123)

            if (iroottrees.ge.0) then
              CALL hropenm(47,'STOKESE',FILE47,'NQ',1024,ISTAT)
              CALL hcdirm('//STOKESE',' ')
            endif

            CALL MHROUT(IDCODE,ICYCLE,' ')

            CALL MHROUT(ICFRS0E,ICYCLE,' ')
            CALL MHROUT(ICFRS1E,ICYCLE,' ')
            CALL MHROUT(ICFRS2E,ICYCLE,' ')
            CALL MHROUT(ICFRS3E,ICYCLE,' ')

            CALL MHROUT(ICFRPE,ICYCLE,' ')
            CALL MHROUT(ICFRP1E,ICYCLE,' ')
            CALL MHROUT(ICFRP2E,ICYCLE,' ')
            CALL MHROUT(ICFRP3E,ICYCLE,' ')
            CALL MHROUT(ICFRP23E,ICYCLE,' ')

            CALL MHROUT(ICFRG3E,ICYCLE,' ')
            CALL MHROUT(ICFRG23E,ICYCLE,' ')

            IF (IBRILL.NE.0) THEN
              CALL MHROUT(ICFRB0E,ICYCLE,' ')
              CALL MHROUT(ICFRB1E,ICYCLE,' ')
              CALL MHROUT(ICFRB2E,ICYCLE,' ')
              CALL MHROUT(ICFRB3E,ICYCLE,' ')
            ENDIF

            CALL MHROUT(IDFRS0E,ICYCLE,' ')
            CALL MHROUT(IDFRS1E,ICYCLE,' ')
            CALL MHROUT(IDFRS2E,ICYCLE,' ')
            CALL MHROUT(IDFRS3E,ICYCLE,' ')

            CALL MHROUT(IDFRPE,ICYCLE,' ')
            CALL MHROUT(IDFRP1E,ICYCLE,' ')
            CALL MHROUT(IDFRP2E,ICYCLE,' ')
            CALL MHROUT(IDFRP3E,ICYCLE,' ')
            CALL MHROUT(IDFRP23E,ICYCLE,' ')

            CALL MHROUT(IDFRG3E,ICYCLE,' ')
            CALL MHROUT(IDFRG23E,ICYCLE,' ')

            CALL MHROUT(IDSPEC,ICYCLE,' ')
            CALL MHROUT(IDSPEC-1,ICYCLE,' ')
            CALL MHROUT(IDSPEC-2,ICYCLE,' ')
            call hdeletm(idspec)
            call hdeletm(idspec-1)
            call hdeletm(idspec-2)

+self,if=-mhbook.
            CALL hbookm(NIDSTOKE,'STOKES ARRAYS (E-FOLDED)',12
     &        ,'//STOKESE',1000,CHSTOK)

          ELSE !I47

            CALL hbookm(NIDSTOKE,'STOKES ARRAYS (E-FOLDED)',12
     &        ,'//WAVE',1000,CHSTOK)
+self,if=mhbook.
            CALL hbookm(NIDSTOKE,'STOKES ARRAYS (E-FOLDED)',12
     &        ,'//STOKESE',nobsv*nfreq*nsource,CHSTOK)

          ELSE !I47

            CALL hbookm(NIDSTOKE,'STOKES ARRAYS (E-FOLDED)',12
     &        ,'//WAVE',nobsv*nfreq*nsource,CHSTOK)
+self.
          ENDIF !I47

          DO IOBSV=1,NOBSV
            IF (IPIN.NE.0) THEN
              IOBSVY=(IOBSV-1)/NOBSVZ+1
              IOBSVZ=IOBSV-NOBSVZ*(IOBSVY-1)
            ELSE
              IOBSVY=1
              IOBSVZ=1
            ENDIF
            DO ifrq=1,NFREQ,IHFREQ
              FSPEC(1)=IOBSV
              FSPEC(2)=OBSV(1,IOBSV)
              FSPEC(3)=OBSV(2,IOBSV)
              FSPEC(4)=OBSV(3,IOBSV)
              FSPEC(5)=FREQ(ifrq)
              IOBFR=IOBSV+NOBSV*(ifrq-1)
              FSPEC(6)=STOKESE(1,IOBFR)
              FSPEC(7)=STOKESE(2,IOBFR)
              FSPEC(8)=STOKESE(3,IOBFR)
              FSPEC(9)=STOKESE(4,IOBFR)
              FSPEC(10)=IOBSVZ
              FSPEC(11)=IOBSVY
              FSPEC(12)=ifrq
              CALL hfm(NIDSTOKE,FSPEC)
            ENDDO   !NFREQ
          ENDDO   !IOBSV

          IF (I47.EQ.1) THEN

            CALL MHROUT(NIDSTOKE,ICYCLE,' ')

            if (iroottrees.ge.0) then
              CALL hrendm('STOKESE')
            endif
            CLOSE(47)

            if (iroottrees.ge.0) then
              CALL hcdirm(OLDDIR,' ')
            endif

          ENDIF !I47

        ENDIF  !ISTOKES,EFOLD

        IF (ISTOKES.NE.0.AND.IEFOLD.ne.0.AND.IFOLD.EQ.1) THEN

          IF (I47.EQ.1) THEN

            if (iroottrees.ge.0) then
              CALL hcdirm(OLDDIR,'R')
            endif

            FILE47='4703_'//FILEHB(1:123)

            if (iroottrees.ge.0) then
              CALL hropenm(47,'STOKESEF',FILE47,'NQ',1024,ISTAT)
              CALL hcdirm('//STOKESEF',' ')
            endif

            CALL MHROUT(IDCODE,ICYCLE,' ')

            CALL MHROUT(ICFRS0EF,ICYCLE,' ')
            CALL MHROUT(ICFRS1EF,ICYCLE,' ')
            CALL MHROUT(ICFRS2EF,ICYCLE,' ')
            CALL MHROUT(ICFRS3EF,ICYCLE,' ')

            CALL MHROUT(ICFRPEF,ICYCLE,' ')
            CALL MHROUT(ICFRP1EF,ICYCLE,' ')
            CALL MHROUT(ICFRP2EF,ICYCLE,' ')
            CALL MHROUT(ICFRP3EF,ICYCLE,' ')
            CALL MHROUT(ICFRP23EF,ICYCLE,' ')

            CALL MHROUT(ICFRG3EF,ICYCLE,' ')
            CALL MHROUT(ICFRG23EF,ICYCLE,' ')

            IF (IBRILL.NE.0) THEN
              CALL MHROUT(ICFRB0EF,ICYCLE,' ')
              CALL MHROUT(ICFRB1EF,ICYCLE,' ')
              CALL MHROUT(ICFRB2EF,ICYCLE,' ')
              CALL MHROUT(ICFRB3EF,ICYCLE,' ')
            ENDIF

            CALL MHROUT(IDFRS0EF,ICYCLE,' ')
            CALL MHROUT(IDFRS1EF,ICYCLE,' ')
            CALL MHROUT(IDFRS2EF,ICYCLE,' ')
            CALL MHROUT(IDFRS3EF,ICYCLE,' ')

            CALL MHROUT(IDFRPEF,ICYCLE,' ')
            CALL MHROUT(IDFRP1EF,ICYCLE,' ')
            CALL MHROUT(IDFRP2EF,ICYCLE,' ')
            CALL MHROUT(IDFRP3EF,ICYCLE,' ')
            CALL MHROUT(IDFRP23EF,ICYCLE,' ')

            CALL MHROUT(IDFRG3EF,ICYCLE,' ')
            CALL MHROUT(IDFRG23EF,ICYCLE,' ')

            CALL MHROUT(IDSPEC,ICYCLE,' ')
            CALL MHROUT(IDSPEC-1,ICYCLE,' ')
            CALL MHROUT(IDSPEC-2,ICYCLE,' ')
            call hdeletm(idspec)
            call hdeletm(idspec-1)
            call hdeletm(idspec-2)

+self,if=-mhbook.
            CALL hbookm(NIDSTOKEF,'STOKES ARRAYS (EMIT, E-FOLDED)',12
     &        ,'//STOKESEF',1000,CHSTOK)

          ELSE !I47

            CALL hbookm(NIDSTOKEF,'STOKES ARRAYS (EMIT, E-FOLDED)',12
     &        ,'//WAVE',1000,CHSTOK)
+self,if=mhbook.
            CALL hbookm(NIDSTOKEF,'STOKES ARRAYS (EMIT, E-FOLDED)',12
     &        ,'//STOKESEF',nobsv*nfreq*nsource,CHSTOK)

          ELSE !I47

            CALL hbookm(NIDSTOKEF,'STOKES ARRAYS (EMIT, E-FOLDED)',12
     &        ,'//WAVE',nobsv*nfreq*nsource,CHSTOK)
+self.
          ENDIF !I47

          DO IOBSV=1,NOBSV
            IF (IPIN.NE.0) THEN
              IOBSVY=(IOBSV-1)/NOBSVZ+1
              IOBSVZ=IOBSV-NOBSVZ*(IOBSVY-1)
            ELSE
              IOBSVY=1
              IOBSVZ=1
            ENDIF
            DO ifrq=1,NFREQ,IHFREQ
              FSPEC(1)=IOBSV
              FSPEC(2)=OBSV(1,IOBSV)
              FSPEC(3)=OBSV(2,IOBSV)
              FSPEC(4)=OBSV(3,IOBSV)
              FSPEC(5)=FREQ(ifrq)
              IOBFR=IOBSV+NOBSV*(ifrq-1)
              FSPEC(6)=STOKESEF(1,IOBFR)
              FSPEC(7)=STOKESEF(2,IOBFR)
              FSPEC(8)=STOKESEF(3,IOBFR)
              FSPEC(9)=STOKESEF(4,IOBFR)
              FSPEC(10)=IOBSVZ
              FSPEC(11)=IOBSVY
              FSPEC(12)=ifrq
              CALL hfm(NIDSTOKEF,FSPEC)
            ENDDO   !NFREQ
          ENDDO   !IOBSV

          IF (I47.EQ.1) THEN

            CALL MHROUT(NIDSTOKEF,ICYCLE,' ')

            if (iroottrees.ge.0) then
              CALL hrendm('STOKESEF')
            endif
            CLOSE(47)

            if (iroottrees.ge.0) then
              CALL hcdirm(OLDDIR,' ')
            endif

          ENDIF !I47

        ENDIF  !ISTOKES,EFOLD,IFOLD

        deallocate(phfill)

        if(ibunch.ne.0.and.icluster.gt.0) call wpampntup

        RETURN
      END
+DECK,hphase2.
*CMZ :          31/12/2023  11.56.26  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.13.36  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.70/00 11/12/2012  12.00.31  by  Michael Scheer
*CMZ :  2.68/05 28/09/2012  09.13.47  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  10.38.43  by  Michael Scheer
*CMZ :  2.49/00 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.16/00 08/06/2000  12.11.00  by  Michael Scheer
*CMZ :  1.03/06 23/09/98  17.08.00  by  Michael Scheer
*CMZ :  1.00/00 24/09/97  10.31.28  by  Michael Scheer
*CMZ : 00.01/06 13/02/95  13.14.40  by  Michael Scheer
*CMZ : 00.01/04 30/01/95  10.41.22  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  16.53.40  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.52.27  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.49  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE HPHASE2(ID,TIT,FILL)
+seq,gplhint.

C--- STORE RESULTS OF SPECTRUM CALCULATION ON HISTOGRAM FILE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,FREQS.
+SEq,phasef90.
+seq,whbook.
+seq,pawcmn.

      INTEGER IOB,IOBZ,IOBY,ID
      INTEGER ICYCLE,ICYCLE1

      REAL*4 ZMIN,ZMAX,YMIN,YMAX,ZFILL,YFILL,DZ,DY
      REAL*8 FILL(MPHASEZ*MPHASEY)

      CHARACTER(80) TIT,TIT1

      IF (mphaseZ.GT.1.AND.mphaseY.GT.1) THEN

        DZ=PHWID/(nphaseZ-1)
        DY=PHHIG/(nphaseY-1)
        ZMIN=PHCENZ-(mphasez-1)*dz/2.0d0
        ZMax=PHCENZ+(mphasez-1)*dz/2.0d0
        yMIN=PHCENy-(mphasey-1)*dy/2.0d0
        yMax=PHCENy+(mphasey-1)*dy/2.0d0

        call hbook2m(ID,TIT,mphaseZ,ZMIN,ZMAX,mphaseY,YMIN,YMAX,VMX)
        TIT1=TIT(1:40)//'(HORIZONTAL CUT)'
        call hbook1m(ID-1,TIT1,mphaseZ,ZMIN,ZMAX,VMX)
        TIT1=TIT(1:40)//'(VERTICAL CUT)'
        call hbook1m(ID-2,TIT1,mphaseY,YMIN,YMAX,VMX)

        IOB=0
        DO IOBY=1,mphaseY
          DO IOBZ=1,mphaseZ

            ZFILL=PHCENZ-PHWID/2.+(IOBZ-1)*DZ
            YFILL=PHCENY-PHHIG/2.+(IOBY-1)*DY
            IOB=IOB+1

            CALL hfillm(ID,ZFILL,YFILL,FILL(IOB))
            IF (IOBZ.EQ.mphaseZ/2+1) CALL hfillm(ID-2,YFILL,0.,FILL(IOB))
            IF (IOBY.EQ.mphaseY/2+1) CALL hfillm(ID-1,ZFILL,0.,FILL(IOB))

          ENDDO !IOBZ
        ENDDO !IOBY

        ICYCLE1=ICYCLE
        CALL MHROUT(ID,ICYCLE,' ')
        CALL hdeletm(ID)
        CALL MHROUT(ID-1,ICYCLE1,' ')
        ICYCLE1=ICYCLE
        CALL hdeletm(ID-1)
        CALL MHROUT(ID-2,ICYCLE1,' ')
        CALL hdeletm(ID-2)

      ELSE IF (mphaseZ.GT.1) THEN

        DZ=PHWID/(mphaseZ-1)
        ZMIN=PHCENZ-PHWID/2.-DZ/2.
        ZMAX=PHCENZ+PHWID/2.+DZ/2.

        TIT1=TIT(1:40)//'(HORIZONTAL CUT)'
        call hbook1m(ID-1,TIT1,mphaseZ,ZMIN,ZMAX,VMX)

        DO IOBZ=1,mphaseZ
          ZFILL=PHCENZ-PHWID/2.+(IOBZ-1)*DZ
          CALL hfillm(ID-1,ZFILL,0.,FILL(IOBZ))
        ENDDO !IOBZ

        CALL MHROUT(ID-1,ICYCLE,' ')
        CALL hdeletm(ID-1)

      ELSE IF (mphaseY.GT.1) THEN

        DY=PHHIG/(mphaseY-1)
        YMIN=PHCENY-PHHIG/2.-DY/2.
        YMAX=PHCENY+PHHIG/2.+DY/2.

        TIT1=TIT(1:40)//'(VERTICAL CUT)'
        call hbook1m(ID-2,TIT1,mphaseY,YMIN,YMAX,VMX)

        DO IOBY=1,mphaseY
            YFILL=PHCENY-PHHIG/2.+(IOBY-1)*DY
            CALL hfillm(ID-2,YFILL,0.,FILL(IOBY))
        ENDDO !IOBY

        CALL MHROUT(ID-2,ICYCLE,' ')
        CALL hdeletm(ID-2)

      ENDIF !mphaseZ, mphaseY

      RETURN
      END
+DECK,MYBFELD.
*CMZ :  4.01/04 27/11/2023  12.51.04  by  Michael Scheer
*CMZ :  4.00/17 04/10/2022  08.10.22  by  Michael Scheer
*CMZ :  4.00/16 22/07/2022  08.40.59  by  Michael Scheer
*CMZ :  4.00/15 28/04/2022  15.43.36  by  Michael Scheer
*CMZ :  4.00/13 09/11/2021  09.50.16  by  Michael Scheer
*CMZ :  4.00/11 17/05/2021  12.32.15  by  Michael Scheer
*CMZ :  4.00/09 12/08/2020  12.58.53  by  Michael Scheer
*CMZ :  4.00/07 09/07/2020  16.53.44  by  Michael Scheer
*CMZ :  4.00/04 17/05/2019  14.17.20  by  Michael Scheer
*CMZ :  4.00/03 07/05/2019  14.19.31  by  Michael Scheer
*CMZ :  3.07/01 29/03/2019  10.40.58  by  Michael Scheer
*CMZ :  3.05/10 13/08/2018  14.40.26  by  Michael Scheer
*CMZ :  3.05/03 16/05/2018  15.26.02  by  Michael Scheer
*CMZ :  3.05/00 26/04/2018  11.52.54  by  Michael Scheer
*CMZ :  3.03/04 29/11/2017  10.16.03  by  Michael Scheer
*CMZ :  3.03/02 08/01/2016  19.14.53  by  Michael Scheer
*CMZ :  3.02/03 04/11/2014  12.27.30  by  Michael Scheer
*CMZ :  3.01/03 07/03/2014  13.20.05  by  Michael Scheer
*CMZ :  2.70/12 18/09/2013  12.33.23  by  Michael Scheer
*CMZ :  2.68/03 03/08/2012  09.40.49  by  Michael Scheer
*CMZ :  2.68/02 31/07/2012  14.28.27  by  Michael Scheer
*CMZ :  2.67/02 03/05/2012  09.16.43  by  Michael Scheer
*CMZ :  2.66/20 22/11/2011  10.35.21  by  Michael Scheer
*CMZ :  2.66/07 09/12/2009  10.50.24  by  Michael Scheer
*CMZ :  2.66/06 26/11/2009  19.35.32  by  Michael Scheer
*CMZ :  2.64/01 20/08/2009  11.50.48  by  Michael Scheer
*CMZ :  2.63/05 22/07/2009  08.28.26  by  Michael Scheer
*CMZ :  2.63/02 07/03/2008  10.34.54  by  Michael Scheer
*CMZ :  2.61/05 11/04/2007  11.58.07  by  Michael Scheer
*CMZ :  2.59/01 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.57/05 09/01/2007  16.55.37  by  Michael Scheer
*CMZ :  2.56/02 21/10/2005  16.31.31  by  Michael Scheer
*CMZ :  2.54/05 19/05/2005  09.11.03  by  Michael Scheer
*CMZ :  2.53/05 16/02/2005  14.45.59  by  Michael Scheer
*CMZ :  2.52/13 16/12/2004  18.11.37  by  Michael Scheer
*CMZ :  2.47/23 17/02/2004  10.36.15  by  Michael Scheer
*CMZ :  2.47/08 15/05/2003  15.38.12  by  Michael Scheer
*CMZ :  2.46/01 18/12/2002  11.40.26  by  Michael Scheer
*CMZ :  2.46/00 17/12/2002  15.37.28  by  Michael Scheer
*CMZ :  2.45/03 17/12/2002  14.53.11  by  Michael Scheer
*CMZ :  2.45/02 16/12/2002  14.32.25  by  Michael Scheer
*CMZ :  2.44/01 11/12/2002  11.12.28  by  Michael Scheer
*CMZ :  2.44/00 06/11/2002  11.28.41  by  Michael Scheer
*CMZ :  2.41/05 17/04/2002  15.14.11  by  Michael Scheer
*CMZ :  2.15/00 15/05/2000  16.34.53  by  Michael Scheer
*CMZ :  2.13/08 29/02/2000  15.51.27  by  Michael Scheer
*CMZ :  2.13/00 03/12/99  16.04.43  by  Michael Scheer
*CMZ :  2.12/04 27/08/99  13.24.54  by  Michael Scheer
*CMZ :  2.11/00 12/05/99  11.47.07  by  Michael Scheer
*CMZ :  2.02/00 05/02/99  15.05.53  by  Michael Scheer
*CMZ :  1.02/03 09/01/98  19.39.53  by  Michael Scheer
*CMZ :  1.02/00 06/01/98  15.13.36  by  Michael Scheer
*CMZ :  1.00/00 26/06/97  10.31.19  by  Michael Scheer
*CMZ : 00.02/04 18/02/97  16.35.49  by  Michael Scheer
*CMZ : 00.02/03 24/01/97  14.20.47  by  Michael Scheer
*CMZ : 00.02/00 21/11/96  14.21.30  by  Michael Scheer
*CMZ : 00.01/10 04/06/96  18.05.02  by  Michael Scheer
*CMZ : 00.01/09 06/05/96  14.23.34  by  Michael Scheer
*CMZ : 00.01/08 22/06/95  09.51.54  by  Michael Scheer
*CMZ : 00.01/07 16/03/95  14.22.58  by  Michael Scheer
*CMZ : 00.01/03 28/11/94  11.33.22  by  Michael Scheer
*CMZ : 00.00/05 29/04/94  19.28.03  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.55  by  Michael Scheer
*-- Author : Michael Scheer
C*******************************************************************************
      Subroutine MYBFELD(XIII,YIII,ZIII,BX,BY,BZ,AX,AY,AZ)
C*******************************************************************************

+seq,gplhint.
      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,B0SCGLOB.
+SEQ,efield.
+SEQ,TRACK.
+seq,undumagc.
+seq,debugwave.

      DOUBLE PRECISION XII,YII,ZII,SIGX,SIGY,SIGZ,DMODFULL,DMODHALF,PERHALF
      DOUBLE PRECISION XI,YI,ZI,X,Y,Z,BX,BY,BZ,AX,AY,AZ,BZD,BYD,AZD,AYD,ZD
     &                  ,YD,BB,PERQUAD,PER3QUAD,DMODQUAD,XIII,YIII,ZIII

      DOUBLE PRECISION BXM,BYM,BZM,BXE,BYE,BZE,AXE,AYE,AZE
      DOUBLE PRECISION BXSUPER,BYSUPER,BZSUPER,AXSUPER,AYSUPER,AZSUPER
     &  ,BMASK(3,10000),BXX,dum,xr,yr,zr

      real g(3)
      INTEGER ICAL,NBMASK,I,IWARN,ifail,iwarnu

      DATA ICAL/0/,IWARN/0/,iwarnu/0/

      if (kampli.gt.0) then
        CALL BELLIP(Xiii,Yiii,Ziii,BX,BY,BZ,AX,AY,AZ)
        bx=bx*b0scglob
        by=by*b0scglob
        bz=bz*b0scglob
        return
      endif

      iwarnmyb=0

      XII=XIII
      YII=YIII
      ZII=ZIII

      if (iefield.ne.0) then
        call efield(xii,yii,zii,efieldx,efieldy,efieldz)
      endif

      IF (IMAGSPLN.EQ.-999) THEN !FIELD TO BE CALCULATED BY SPLINE INTERPOLATION
        CALL BMAGSPLN(XII,YII,ZII,BX,BY,BZ)
        if (ibmasksp.ge.0) return
      ENDIF !IMAGSPLN

      IF (ICAL.EQ.0) THEN
        PERHALF=PERIODG/2.D0
        PERQUAD=PERHALF/2.D0
        PER3QUAD=PERHALF+PERQUAD
        IF (DABS(CROTD**2+SROTD**2-1.D0).GT.1.D-10) THEN
          WRITE(LUNGFO,*)
     &      '*** ERROR IN MYBFELD: CALLED BEFORE CALL TO GFINIT'
          WRITE(6,*)
     &      '*** ERROR IN MYBFELD: CALLED BEFORE CALL TO GFINIT'
          STOP
        ENDIF
      ENDIF

      IF (IMAGSPLN.GT.0.OR.IMAGSPLN.EQ.-1111) THEN !FIELD TO BE CALCULATED BY SPLINE INTERPOLATION
        CALL BMAGSPLN(XII,YII,ZII,BX,BY,BZ)
        GOTO 1000
      ENDIF !IMAGSPLN

      XII=XIII+XSHIFT
      YII=YIII+VSHIFT
      ZII=ZIII+HSHIFT

      ZD= CROTD*ZII-SROTD*YII
      YD= SROTD*ZII+CROTD*YII
      ZII=ZD
      YII=YD

      XI=XII
      YI=YII
      ZI=ZII

      SIGX=1.D0
      SIGY=1.D0
      SIGZ=1.D0

      IF (IPERIODG.GT.0) THEN
C OLD MODE, KEPT FOR COMPATIBILITY
        DMODFULL=DMOD(XII-PEROFFG,PERIODG)
        IF (DMODFULL.LT.0.0D0) DMODFULL=DMODFULL+PERIODG
        IF(SIGNG.GE.0.D0) THEN
          SIGX=SIGNG
          SIGY=SIGNG
          SIGZ=SIGNG
          XI=PEROFFG+DMODFULL
        ELSE
          IF (DMODFULL.GT.PERHALF) THEN
            XI=PEROFFG+DMODFULL-PERHALF
            SIGX=SIGNG
            SIGY=SIGNG
            SIGZ=SIGNG
          ELSE
            SIGX=-SIGNG
            SIGY=-SIGNG
            SIGZ=-SIGNG
            XI=PEROFFG+DMODFULL
          ENDIF
        ENDIF   !SIGNG

        IF(SIGNG2.NE.0.0D0) THEN

          DMODFULL=DMOD(XII-PEROFFG,2.0d0*PERIODG)
          IF (DMODFULL.LT.0.0D0) DMODFULL=DMODFULL+2.0d0*PERIODG

          IF (DMODFULL.Ge.PERIODG) then
            SIGX=SIGX*SIGNG2
            SIGY=SIGY*SIGNG2
            SIGZ=SIGZ*SIGNG2
          else
            SIGX=-SIGX*SIGNG2
            SIGY=-SIGY*SIGNG2
            SIGZ=-SIGZ*SIGNG2
          ENDIF !(DMODFULL.GT.PERIODG) THEN

          DMODFULL=DMOD(XII-PEROFFG,PERIODG)
          IF (DMODFULL.LT.0.0D0) DMODFULL=DMODFULL+PERIODG
          XI=PEROFFG+DMODFULL

        ENDIF   !SIGN2

      ELSE IF (IPERIODG.EQ.-1) THEN
c FULL PERIOD
        IF(XII.GE.XPERWMN.AND.XII.LE.XPERWMX) THEN
          DMODFULL=DMOD(XII-PEROFFG,PERIODG)
          IF (DMODFULL.LT.0.0D0) DMODFULL=DMODFULL+PERIODG
          XI=PEROFFG+DMODFULL
        else if(XII.GT.XPERWMX) THEN
          XI=XII-(XPERWMX-XPERWMN)
        ENDIF
      else if (IPERIODG.EQ.-2) THEN
c HALF PERIOD
        IF(XII.GE.XPERWMN.AND.XII.LE.XPERWMX) THEN
          DMODFULL=DMOD(XII-PEROFFG,PERIODG)
          IF (DMODFULL.LT.0.0D0) DMODFULL=DMODFULL+PERIODG
          DMODHALF=DMOD(DMODFULL,PERHALF)
          XI=PEROFFG+DMODHALF
          IF (DMODFULL.GT.PERHALF) THEN
            SIGX=-1.D0
            SIGY=-1.D0
            SIGZ=-1.D0
          ENDIF
        else if(XII.GT.XPERWMX) THEN
          XI=XII-(XPERWMX-XPERWMN)
        ENDIF
      else if (IPERIODG.EQ.-3) THEN
c QUARTER PERIOD, COSINE-LIKE
        IF(XII.GE.XPERWMN.AND.XII.LE.XPERWMX) THEN
          DMODFULL=DMOD(XII-PEROFFG,PERIODG)
          IF (DMODFULL.LT.0.0D0) DMODFULL=DMODFULL+PERIODG
          DMODHALF=DMOD(DMODFULL,PERHALF)
          DMODQUAD=DMOD(DMODHALF,PERQUAD)
          XI=PEROFFG+DMODFULL
          IF(DMODFULL.GE.PER3QUAD) THEN
            XI=PEROFFG+PERQUAD-DMODQUAD
            SIGX=-1.D0
          else if(DMODFULL.GE.PERHALF) THEN
            XI=PEROFFG+DMODQUAD
            SIGX=-1.D0
            SIGY=-1.D0
            SIGZ=-1.D0
          else if(DMODFULL.GE.PERQUAD) THEN
            XI=PEROFFG+PERQUAD-DMODQUAD
            SIGY=-1.D0
            SIGZ=-1.D0
          ENDIF
        else if(XII.GT.XPERWMX) THEN
          XI=XII-(XPERWMX-XPERWMN)
        ENDIF
      else if (IPERIODG.EQ.-4) THEN
c QUARTER PERIOD, SINE-LIKE
        IF(XII.GE.XPERWMN.AND.XII.LE.XPERWMX) THEN
          DMODFULL=DMOD(XII-PEROFFG,PERIODG)
          IF (DMODFULL.LT.0.0D0) DMODFULL=DMODFULL+PERIODG
          DMODHALF=DMOD(DMODFULL,PERHALF)
          DMODQUAD=DMOD(DMODHALF,PERQUAD)
          XI=PEROFFG+DMODFULL
          IF(DMODFULL.GE.PER3QUAD) THEN
            XI=PEROFFG+PERQUAD-DMODQUAD
            SIGY=-1.D0
            SIGZ=-1.D0
          ELSE IF(DMODFULL.GE.PERHALF) THEN
            XI=PEROFFG+DMODQUAD
            SIGX=-1.D0
            SIGY=-1.D0
            SIGZ=-1.D0
          ELSE IF(DMODFULL.GE.PERQUAD) THEN
            XI=PEROFFG+PERQUAD-DMODQUAD
            SIGX=-1.D0
          ENDIF
        else if(XII.GT.XPERWMX) THEN
          XI=XII-(XPERWMX-XPERWMN)
        ENDIF
      ENDIF !IPERIOD

      IF(IBSYM.NE.0) THEN
        X=ABS(XI-XBSYM)
      ELSE
        X=XI
      ENDIF

      IF(IBSYMY.NE.0) THEN
        Y=ABS(YI)
      ELSE
        Y=YI
      ENDIF

      IF(IBSYMZ.NE.0) THEN
        Z=ABS(ZI)
      ELSE
        Z=ZI
      ENDIF

      BX=0.0d0
      BY=0.0d0
      BZ=0.0d0

      AX=0.0d0
      AY=0.0d0
      AZ=0.0d0

      IF (ibmasksp.lt.0) THEN
        CALL BFELD(BXM,BYM,BZM,X,Y,Z)
        bx=bx+bxm
        by=by+bym
        bz=bz+bzm
        IF (KMAGSEQ.lt.0) THEN
          CALL BMAGSEQ(X,Y,Z,BXm,BYm,BZm,dum,dum,dum)
          bx=bx+bxm
          by=by+bym
          bz=bz+bzm
        endif
        goto 100
      ENDIF !(IBMASKSP.NE.0)

      x=x+xbshift

      IF (IBSUPER.EQ.0) THEN

          IF (KHALBA.NE.0) THEN
            CALL BHALBA(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (Kundugap.NE.0) THEN
            CALL Bundugap(X,Y,Z,BX,BY,BZ,AX,AY,AZ,0)
          ELSE IF (KHALBASY.NE.0) THEN
            CALL BHALBASY(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (IRFILF.EQ.1) THEN
            CALL BFOUR(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (IFOURBTABZY.EQ.1) THEN
            CALL BFOURtabzy(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (IRBTAB.ne.0) THEN
            CALL BTAB(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (IRBTABZY.ne.0) THEN
            CALL BTABZY(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (IRBTABXYZ.ne.0) THEN
            CALL BTABXYZ(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (KBEXTERN.EQ.1) THEN
            CALL BEXTERN(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (KUCROSS.EQ.1) THEN
            CALL BUCROSS(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (KELLIP.EQ.1) THEN
            CALL BELLIP(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (KELLANA.EQ.1) THEN
            CALL BELLANA(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (KBREC.EQ.1) THEN
            CALL BREC(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (kbundumag.EQ.1.or.kbundumag.eq.3) THEN
            CALL undumagwav(X,Y,Z,BX,BY,BZ,ifail)
          ELSE IF (KBPOLYMAG.GT.0) THEN
            CALL BPOLYEDER(X,Y,Z,BX,BY,BZ)
          ELSE IF (KMAGSEQ.ne.0) THEN
            CALL BMAGSEQ(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (KBPOLYH.EQ.1) THEN
            CALL BPOLYHARM(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (KBPOLY3D.EQ.1) THEN
            CALL BPOLY3D(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (KBPOLY2DH.EQ.1) THEN
            CALL BPOLY2DH(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (KBPHARM.EQ.1) THEN
            CALL BPHARM(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (IWSECTMAGS.LT.0) THEN
            CALL BSECTMAGS(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (KBFELD.EQ.1) THEN
            CALL BFELD( BX, BY, BZ,X,Y,Z)
          ELSE IF (IRFILB0.NE.0 .OR. IRFILB.EQ.1) THEN
            CALL BMESS(X,Y,Z,BX,BY,BZ)
            if (iwarnbmap.ne.0) then
              bx=0.0d0
              by=0.0d0
              bz=0.0d0
c              iwarnmyb=1
            endif
          ELSE IF (IRFILP.EQ.1.AND.ISPLINE.EQ.1) THEN
            CALL BPAND(X,Y,Z,BX,BY,BZ)
          ELSE IF (IRFILP.EQ.1.AND.ISPLINE.NE.1) THEN
            CALL BPANDOLD(X,Y,Z,BX,BY,BZ)
          ELSE IF (KBAMWLS.NE.0) THEN
            CALL BBAMWLS(X,Y,Z,BX,BY,BZ)

+SELF,IF=BHELM.
          ELSE IF (IBHELM.EQ.1) THEN
            CALL BHELM(X,Y,Z,BX,BY,BZ)
+SELF.

          ELSE IF (KBGENESIS.NE.0) THEN
            CALL BGENESIS(X,Y,Z,BX,BY,BZ,AX,AY,AZ)

          ELSE IF (ibmasksp.NE.0) THEN

          ELSE

            STOP '*** SR MYBFELD: NO MAGNETIC FIELD DEFINED ***'

          ENDIF

        ELSE   !IBSUPER

          BXSUPER=0.D0
          BYSUPER=0.D0
          BZSUPER=0.D0

          AXSUPER=0.D0
          AYSUPER=0.D0
          AZSUPER=0.D0

          IF (KHALBA.NE.0) THEN
            CALL BHALBA(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (KHALBASY.NE.0) THEN
            CALL BHALBASY(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (kundugap.NE.0) THEN
            CALL Bundugap(X,Y,Z,BX,BY,BZ,AX,AY,AZ,0)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (IRFILF.EQ.1) THEN
            CALL BFOUR(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (IRBTAB.ne.0) THEN
            CALL BTAB(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (IRBTABZY.ne.0) THEN
            CALL BTABZY(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (IfourBTABZY.ne.0) THEN
            CALL BfourTABZY(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (IRBTABXYZ.ne.0) THEN
            CALL BTABXYZ(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (KBEXTERN.EQ.1) THEN
            CALL BEXTERN(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (KUCROSS.EQ.1) THEN
            CALL BUCROSS(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (KELLIP.EQ.1) THEN
            CALL BELLIP(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (KELLANA.EQ.1) THEN
            CALL BELLANA(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (kbundumag.EQ.1.or.kbundumag.eq.3) THEN
            CALL undumagwav(X,Y,Z,BX,BY,BZ,ifail)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
          endif

          IF (KBREC.EQ.1) THEN
            CALL BREC(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (KBPOLYMAG.GT.0) THEN
            CALL BPOLYEDER(X,Y,Z,BX,BY,BZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (KMAGSEQ.ne.0) THEN
            CALL BMAGSEQ(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (KBPOLYH.EQ.1) THEN
            CALL BPOLYHARM(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (KBPOLY3D.EQ.1) THEN
            CALL BPOLY3D(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (KBPOLY2DH.EQ.1) THEN
            CALL BPOLY2DH(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (KBPHARM.EQ.1) THEN
            CALL BPHARM(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (KBFELD.EQ.1) THEN
            CALL BFELD( BX, BY, BZ,X,Y,Z)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (KBAMWLS.NE.0) THEN
            CALL BBAMWLS(X,Y,Z,BX,BY,BZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
          ENDIF

          IF (IWSECTMAGS.LT.0) THEN
            CALL BSECTMAGS(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (IRFILB0.NE.0 .OR. IRFILB.EQ.1) THEN
            CALL BMESS(X,Y,Z,BX,BY,BZ)
            if (iwarnbmap.ne.0) then
              bx=0.0d0
              by=0.0d0
              bz=0.0d0
c              iwarnmyb=1
            endif
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (IRFILP.EQ.1.AND.ISPLINE.EQ.1) THEN
            CALL BPAND(X,Y,Z,BX,BY,BZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (IRFILP.EQ.2.AND.ISPLINE.NE.1) THEN
            CALL BPANDOLD(X,Y,Z,BX,BY,BZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

+SELF,IF=BHELM.
          IF (IBHELM.EQ.1) THEN
            CALL BHELM(X,Y,Z,BX,BY,BZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

+SELF.

          IF (KBGENESIS.NE.0) THEN
            CALL BGENESIS(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          BX=BXSUPER
          BY=BYSUPER
          BZ=BZSUPER

          AX=AXSUPER
          AY=AYSUPER
          AZ=AZSUPER

        ENDIF  !IBSUPER

        AX=SIGX*AX
        AY=SIGY*AY
        AZ=SIGZ*AZ

        BXNERR=BX
        BYNERR=BY
        BZNERR=BZ
        AXNERR=AX
        AYNERR=AY
        AZNERR=AZ

        IF (IBERROR.NE.0) THEN
          CALL BERROR(X,Y,Z,BXE,BYE,BZE,AXE,AYE,AZE)
          BX=BX+BXE
          BY=BY+BYE
          BZ=BZ+BZE
          AX=AX+AXE
          AY=AY+AYE
          AZ=AZ+AZE
        ENDIF  !IBERROR

        IF (IBMASK.EQ.100) THEN

          IF (ICAL.EQ.0) THEN
            OPEN(UNIT=99,FILE='wave.bmask',STATUS='OLD')
            NBMASK=0
1           READ(99,*,END=9)BXX
            NBMASK=NBMASK+1
            IF (NBMASK.GT.10000) STOP '*** ERROR FOR BMASK: DIMENSION EXCEEDED'
            GOTO 1
9           REWIND(99)
            DO I=1,NBMASK
              READ(99,*)BMASK(1,I),BMASK(2,I),BMASK(3,I)
            ENDDO
            CLOSE(99)
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'      BMASK:'
            WRITE(LUNGFO,*)
            DO I=1,NBMASK
              WRITE(LUNGFO,*)BMASK(1,I),BMASK(2,I),BMASK(3,I)
            ENDDO
            WRITE(LUNGFO,*)
            DO I=1,NBMASK-1
              IF(BMASK(2,I).GT.BMASK(1,I+1)) THEN
                PRINT*,'*** WARNING FOR BMASK: OVERLAPPING INTERVALS'
                WRITE(LUNGFO,*)'*** WARNING FOR BMASK: OVERLAPPING INTERVALS'
              ENDIF
            ENDDO
          ENDIF !ICAL

          DO I=1,NBMASK
            IF (X.GE.BMASK(1,I).AND.X.LE.BMASK(2,I)) THEN
              BX=BX*BMASK(3,I)
              BY=BY*BMASK(3,I)
              BZ=BZ*BMASK(3,I)
            ENDIF
          ENDDO

        ELSE IF (IBMASK.eq.-100) THEN

          call ubmask(x,y,z,bxm,bym,bzm)

          BX=BX*BxM
          BY=BY*ByM
          BZ=BZ*BzM

        ELSE IF (IBMASK.eq.-200) THEN

          call ubmask(x,y,z,bxm,bym,bzm)

          BX=BX+BxM
          BY=BY+ByM
          BZ=BZ+BzM

        ELSE IF (IBMASK.LT.0) THEN

          CALL BFELD(BXM,BYM,BZM,X,Y,Z)
C MASK IS BYM! (BXM, BZM ARE ZERO)
          BY=BY+BYM

        ELSE IF (IBMASK.eq.10) THEN

          CALL BTAP(X,Y,Z,BXm,BYm,BZm,dum,dum,dum)

          Bx=Bx*BYM
          BY=BY*BYM
          Bz=Bz*BYM

        ELSE IF (IBMASK.gt.0) THEN

          CALL BFELD(BXM,BYM,BZM,X,Y,Z)
          Bx=Bx*BYM
          BY=BY*BYM
          Bz=Bz*BYM

        ELSE IF (ibmasksp.ne.0) THEN

          CALL BFELD(BXM,BYM,BZM,X,Y,Z)
          bx=bx+bxm
          by=by+bym
          bz=bz+bzm
          IF (KMAGSEQ.lt.0) THEN
            CALL BMAGSEQ(X,Y,Z,BXm,BYm,BZm,dum,dum,dum)
            bx=bx+bxm
            by=by+bym
            bz=bz+bzm
          endif
        ENDIF  !(IBMASK.NE.0)

100     BX=SIGX*BX
        BY=SIGY*BY+BYGOFF
        BZ=SIGZ*BZ+BZGOFF

C CHANGES HERE ACCORDING TO BFOUR (TAKE CARE OF DIFFERENT COORD.SYST.){

+SELF,IF=DIPAXAZ.
        AX=AX+0.5*BYGOFF*Z
        AZ=AZ-0.5*BYGOFF*X
        IF (ICAL.EQ.0.AND.BZGOFF.NE.0.) THEN
          WRITE(LUNGFO,*)
     &      '*** WARNING IN MYBFELD: BZGOFF NOT ZERO'
          WRITE(LUNGFO,*)
     &      '*** NOT IMPLEMENTED FOR THIS VECTOR-POTENTIAL ***'
          WRITE(LUNGFO,*)
     &      '*** SEE MYBFELD FOR DETAILS'
          WRITE(6,*)
     &      '*** WARNING IN MYBFELD: BZGOFF NOT ZERO'
          WRITE(6,*)
     &      '*** NOT IMPLEMENTED FOR THIS VECTOR-POTENTIAL ***'
          WRITE(6,*)
     &      '*** SEE MYBFELD FOR DETAILS'
        ENDIF
+SELF.

+SELF,IF=DIPAZ.
        AX=AX+BYGOFF*Z
        AX=AX+BZGOFF*Y
        IF (ICAL.EQ.0.AND.BZGOFF.NE.0.) THEN
          WRITE(LUNGFO,*)
     &      '*** WARNING IN MYBFELD: BZGOFF NOT ZERO'
          WRITE(LUNGFO,*)
     &      '*** NOT YET TESTED FOR THIS VECTOR-POTENTIAL ***'
          WRITE(LUNGFO,*)
     &      '*** SEE MYBFELD FOR DETAILS'
          WRITE(6,*)
     &      '*** WARNING IN MYBFELD: BZGOFF NOT ZERO'
          WRITE(6,*)
     &      '*** NOT YET TESTED FOR THIS VECTOR-POTENTIAL ***'
          WRITE(6,*)
     &      '*** SEE MYBFELD FOR DETAILS'
        ENDIF
+SELF.

+SELF,IF=-DIPAXAZ,IF=-DIPAZ.
        AZ=AZ-BYGOFF*X
        AZ=AZ-BZGOFF*X
        IF (ICAL.EQ.0.AND.BZGOFF.NE.0.) THEN
          WRITE(LUNGFO,*)
     &      '*** WARNING IN MYBFELD: BZGOFF NOT ZERO'
          WRITE(LUNGFO,*)
     &      '*** NOT YET TESTED FOR THIS VECTOR-POTENTIAL ***'
          WRITE(LUNGFO,*)
     &      '*** SEE MYBFELD FOR DETAILS'
          WRITE(6,*)
     &      '*** WARNING IN MYBFELD: BZGOFF NOT ZERO'
          WRITE(6,*)
     &      '*** NOT YET TESTED FOR THIS VECTOR-POTENTIAL ***'
          WRITE(6,*)
     &      '*** SEE MYBFELD FOR DETAILS'
        ENDIF
+SELF.


C CHANGES HERE ACCORDING TO BFOUR }

        BX=BX*B0SCGLOB
        BY=BY*B0SCGLOB*B0SCGLOBY
        BZ=BZ*B0SCGLOB*B0SCGLOBZ

        AX=AX*A0SCGLOB
        AY=AY*A0SCGLOB*B0SCGLOBY
        AZ=AZ*A0SCGLOB*B0SCGLOBZ

        IF(IBSYM.NE.0.AND.(XI-XBSYM).LT.0.0) THEN
          AX= AX
          AY=-AY
          AZ=-AZ
          BX=-BX
          BY= BY
          BZ= BZ
        ENDIF

        IF(IBSYMY.NE.0.AND.YI.LT.0.0) THEN
          AX=-AX
          AY= AY
          AZ=-AZ
          BX= BX
          BY=-BY
          BZ= BZ
        ENDIF

        IF(IBSYMZ.NE.0.AND.ZI.LT.0.0) THEN
          AX=-AX
          AY=-AY
          AZ= AZ
          BX= BX
          BY= BY
          BZ=-BZ
        ENDIF

        IF(IBSYM.LT.0.AND.XI.LT.0.0) THEN
          AX=-AX
          AY=-AY
          AZ=-AZ
          BX=-BX
          BY=-BY
          BZ=-BZ
        ENDIF

        IF(IBSYMY.LT.0.AND.YI.LT.0.0) THEN
          AX=-AX
          AY=-AY
          AZ=-AZ
          BX=-BX
          BY=-BY
          BZ=-BZ
        ENDIF

        IF(IBSYMZ.LT.0.AND.ZI.LT.0.0) THEN
          AX=-AX
          AY=-AY
          AZ=-AZ
          BX=-BX
          BY=-BY
          BZ=-BZ
        ENDIF

1000  continue

      IF (JBMASK.EQ.100) THEN

        x=xiii

        IF (ICAL.EQ.0) THEN
          OPEN(UNIT=99,FILE='wave.bmask',STATUS='OLD')
          NBMASK=0
11        READ(99,*,END=91)BXX
          NBMASK=NBMASK+1
          IF (NBMASK.GT.10000) STOP '*** ERROR FOR BMASK: DIMENSION EXCEEDED'
          GOTO 11
91        REWIND(99)
          DO I=1,NBMASK
            READ(99,*)BMASK(1,I),BMASK(2,I),BMASK(3,I)
          ENDDO
          CLOSE(99)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'      BMASK:'
          WRITE(LUNGFO,*)
          DO I=1,NBMASK
            WRITE(LUNGFO,*)BMASK(1,I),BMASK(2,I),BMASK(3,I)
          ENDDO
          WRITE(LUNGFO,*)
          DO I=1,NBMASK-1
            IF(BMASK(2,I).GT.BMASK(1,I+1)) THEN
              PRINT*,'*** WARNING FOR BMASK: OVERLAPPING INTERVALS'
              WRITE(LUNGFO,*)'*** WARNING FOR BMASK: OVERLAPPING INTERVALS'
            ENDIF
          ENDDO
        ENDIF !ICAL

        DO I=1,NBMASK
          IF (X.GE.BMASK(1,I).AND.X.LE.BMASK(2,I)) THEN
            BX=BX*BMASK(3,I)
            BY=BY*BMASK(3,I)
            BZ=BZ*BMASK(3,I)
          ENDIF
        ENDDO

      ELSE IF (JBMASK.eq.-100) THEN

        call ubmask(x,y,z,bxm,bym,bzm)

        BX=BX*BxM
        BY=BY*ByM
        BZ=BZ*BzM

      ELSE IF (JBMASK.eq.-200) THEN

        call ubmask(x,y,z,bxm,bym,bzm)

        BX=BX+BxM
        BY=BY+ByM
        BZ=BZ+BzM

      ELSE IF (JBMASK.LT.0) THEN

        CALL BFELD(BXM,BYM,BZM,X,Y,Z)
C MASK IS BYM! (BXM, BZM ARE ZERO)
        BY=BY+BYM

      ELSE IF (ibmasksp.ne.0) THEN

        CALL BFELD(BXM,BYM,BZM,X,Y,Z)
        bx=bx+bxm
        by=by+bym
        bz=bz+bzm
        IF (KMAGSEQ.lt.0) THEN
          CALL BMAGSEQ(X,Y,Z,BXm,BYm,BZm,dum,dum,dum)
          bx=bx+bxm
          by=by+bym
          bz=bz+bzm
        endif
      ENDIF !(JBMASK.NE.0)

      ZD= CROTD*Z+SROTD*Y
      YD=-SROTD*Z+CROTD*Y
      Z=ZD
      Y=YD

      BZD= CROTD*BZ+SROTD*BY
      BYD=-SROTD*BZ+CROTD*BY
      BZ=BZD
      BY=BYD

      AZD= CROTD*AZ+SROTD*AY
      AYD=-SROTD*AZ+CROTD*AY
      AZ=AZD
      AY=AYD

      by=by*(1.0d0+btaperv*(xiii-xtaper))
      bz=bz*(1.0d0+btaperh*(xiii-xtaper))
      ay=ay*(1.0d0+btaperv*(xiii-xtaper))
      az=az*(1.0d0+btaperh*(xiii-xtaper))

      BB=BX*BX+BY*BY+BZ*BZ

      IF (BB.GT.BMAXGL2) THEN
        XBMAXGL=XIII
        YBMAXGL=YIII
        ZBMAXGL=ZIII
        BMAXGL2=BB
      ENDIF

      ICAL=1

      IF (IWARN.EQ.0) THEN
        IF (ABS(BX).GT.100.0D0
     &      .OR.
     &      ABS(BY).GT.100.0D0
     &      .OR.
     &      ABS(BZ).GT.100.0D0) THEN
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN MYBFELD:'
          WRITE(6,*)'MAGNETIC FIELD ABOVE 100 TESLA FOUND!'
          WRITE(6,*)'X:',XIII
          WRITE(6,*)'Y:',YIII
          WRITE(6,*)'Z:',ZIII
          WRITE(6,*)'BX:',BX
          WRITE(6,*)'BY:',BY
          WRITE(6,*)'BZ:',BZ
          WRITE(6,*)
          WRITE(6,*)'Tracking position and velocity vector:'
          WRITE(6,*)
          WRITE(6,*)'STEP:',ITRACK
          WRITE(6,*)'XTRACK:',XTRACK
          WRITE(6,*)'YTRACK:',YTRACK
          WRITE(6,*)'ZTRACK:',ZTRACK
          WRITE(6,*)'VXTRACK:',VXTRACK
          WRITE(6,*)'VYTRACK:',VYTRACK
          WRITE(6,*)'VZTRACK:',VZTRACK
          WRITE(6,*)'YPTRACK:',VYTRACK/VXTRACK
          WRITE(6,*)'ZPTRACK:',VZTRACK/VXTRACK
          WRITE(6,*)

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN MYBFELD:'
          WRITE(LUNGFO,*)'MAGNETIC FIELD ABOVE 100 TESLA FOUND!'
          WRITE(LUNGFO,*)'X:',XIII
          WRITE(LUNGFO,*)'Y:',YIII
          WRITE(LUNGFO,*)'Z:',ZIII
          WRITE(LUNGFO,*)'BX:',BX
          WRITE(LUNGFO,*)'BY:',BY
          WRITE(LUNGFO,*)'BZ:',BZ
          WRITE(LUNGFO,*)
          IWARN=1
        ENDIF
      ENDIF

      RETURN
      END
+DECK,SOUINTANA.
*CMZ :  4.01/04 15/11/2023  12.38.14  by  Michael Scheer
*CMZ :  4.01/03 02/06/2023  13.01.26  by  Michael Scheer
*CMZ :  4.01/02 14/05/2023  12.29.56  by  Michael Scheer
*CMZ :  4.00/17 15/11/2022  10.09.14  by  Michael Scheer
*CMZ :  4.00/15 11/04/2022  09.38.38  by  Michael Scheer
*CMZ :  4.00/14 22/12/2021  18.07.25  by  Michael Scheer
*CMZ :  4.00/13 07/11/2021  15.08.37  by  Michael Scheer
*CMZ :  4.00/07 29/04/2020  16.22.00  by  Michael Scheer
*CMZ :  4.00/04 25/11/2019  15.59.31  by  Michael Scheer
*CMZ :  3.08/01 03/04/2019  11.44.00  by  Michael Scheer
*CMZ :  3.06/00 27/02/2019  13.41.29  by  Michael Scheer
*CMZ :  3.05/06 17/07/2018  11.15.16  by  Michael Scheer
*CMZ :  3.05/04 27/06/2018  13.51.32  by  Michael Scheer
*CMZ :  3.05/03 22/05/2018  07.13.27  by  Michael Scheer
*CMZ :  3.05/02 14/05/2018  14.03.28  by  Michael Scheer
*CMZ :  3.03/03 11/07/2017  12.22.55  by  Michael Scheer
*CMZ :  3.03/02 22/03/2016  12.44.00  by  Michael Scheer
*CMZ :  3.02/06 12/06/2015  14.30.32  by  Michael Scheer
*CMZ :  3.02/05 10/04/2015  16.29.41  by  Michael Scheer
*CMZ :  3.02/04 22/01/2015  14.17.40  by  Michael Scheer
*CMZ :  3.02/03 06/11/2014  15.42.04  by  Michael Scheer
*CMZ :  3.02/00 10/09/2014  14.15.19  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/06 03/01/2013  10.16.23  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  14.04.56  by  Michael Scheer
*CMZ :  2.70/04 21/12/2012  12.27.29  by  Michael Scheer
*CMZ :  2.70/01 12/12/2012  15.52.08  by  Michael Scheer
*CMZ :  2.69/02 06/11/2012  19.26.50  by  Michael Scheer
*CMZ :  2.69/01 31/10/2012  16.59.26  by  Michael Scheer
*CMZ :  2.69/00 26/10/2012  14.09.11  by  Michael Scheer
*CMZ :  2.68/05 19/10/2012  14.08.39  by  Michael Scheer
*CMZ :  2.68/03 22/08/2012  12.57.49  by  Michael Scheer
*CMZ :  2.68/02 30/05/2012  09.18.41  by  Michael Scheer
*CMZ :  2.68/01 29/05/2012  16.26.31  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  12.54.41  by  Michael Scheer
*CMZ :  2.67/04 11/05/2012  11.18.26  by  Michael Scheer
*CMZ :  2.67/00 13/02/2012  10.58.17  by  Michael Scheer
*CMZ :  2.66/20 06/07/2011  10.04.15  by  Michael Scheer
*CMZ :  2.66/18 08/12/2010  09.41.12  by  Michael Scheer
*CMZ :  2.66/13 25/06/2010  15.12.53  by  Michael Scheer
*CMZ :  2.66/12 24/05/2010  06.45.59  by  Michael Scheer
*CMZ :  2.66/10 04/05/2010  10.01.49  by  Michael Scheer
*CMZ :  2.66/09 04/05/2010  10.01.19  by  Michael Scheer
*CMZ :  2.66/07 10/03/2010  09.23.32  by  Michael Scheer
*CMZ :  2.66/06 27/11/2009  16.13.00  by  Michael Scheer
*CMZ :  2.66/05 18/11/2009  10.22.04  by  Michael Scheer
*CMZ :  2.66/04 17/11/2009  10.09.32  by  Michael Scheer
*CMZ :  2.66/03 11/11/2009  16.56.29  by  Michael Scheer
*CMZ :  2.66/01 28/10/2009  15.52.52  by  Michael Scheer
*CMZ :  2.66/00 14/10/2009  11.40.12  by  Michael Scheer
*CMZ :  2.65/03 02/10/2009  14.50.50  by  Michael Scheer
*CMZ :  2.65/02 29/09/2009  09.25.19  by  Michael Scheer
*CMZ :  2.65/00 18/09/2009  08.33.28  by  Michael Scheer
*CMZ :  2.64/07 17/09/2009  15.35.15  by  Michael Scheer
*CMZ :  2.64/06 14/09/2009  15.19.42  by  Michael Scheer
*CMZ :  2.64/05 08/09/2009  13.24.51  by  Michael Scheer
*CMZ :  2.64/04 21/08/2009  17.39.13  by  Michael Scheer
*CMZ :  2.64/03 21/08/2009  17.32.56  by  Michael Scheer
*CMZ :  2.64/02 21/08/2009  17.25.00  by  Michael Scheer
*CMZ :  2.64/01 19/08/2009  09.03.30  by  Michael Scheer
*CMZ :  2.64/00 17/08/2009  08.23.14  by  Michael Scheer
*CMZ :  2.63/05 12/08/2009  16.16.13  by  Michael Scheer
*CMZ :  2.63/01 16/01/2008  13.13.26  by  Michael Scheer
*CMZ :  2.63/00 11/01/2008  16.35.30  by  Michael Scheer
*CMZ :  2.61/02 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.54/04 19/04/2005  08.39.39  by  Michael Scheer
*CMZ :  2.53/02 25/01/2005  12.24.49  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  13.27.56  by  Michael Scheer
*CMZ :  2.52/16 18/01/2005  19.11.04  by  Michael Scheer
*CMZ :  2.52/11 08/12/2004  13.38.02  by  Michael Scheer
*CMZ :  2.52/04 12/07/2004  09.05.41  by  Michael Scheer
*CMZ :  2.52/02 06/07/2004  12.52.18  by  Michael Scheer
*CMZ :  2.51/03 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.51/01 17/06/2004  15.54.40  by  Michael Scheer
*CMZ :  2.51/00 25/05/2004  16.11.36  by  Michael Scheer
*CMZ :  2.50/03 10/05/2004  14.35.07  by  Michael Scheer
*CMZ :  2.50/02 30/04/2004  14.42.38  by  Michael Scheer
*CMZ :  2.50/01 30/04/2004  10.51.02  by  Michael Scheer
*CMZ :  2.50/00 29/04/2004  18.32.51  by  Michael Scheer
*CMZ :  2.41/10 16/04/2004  09.24.47  by  Michael Scheer
*CMZ :  2.37/07 11/12/2001  16.39.59  by  Michael Scheer
*CMZ :  2.37/01 14/11/2001  10.46.31  by  Michael Scheer
*CMZ :  2.37/00 13/11/2001  17.04.47  by  Michael Scheer
*CMZ :  2.36/00 08/11/2001  13.57.12  by  Michael Scheer
*CMZ :  2.34/09 21/09/2001  11.57.57  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  11.10.08  by  Michael Scheer
*CMZ :  2.33/00 03/05/2001  11.31.36  by  Michael Scheer
*CMZ :  2.31/01 25/04/2001  10.54.42  by  Michael Scheer
*CMZ :  2.31/00 24/04/2001  15.51.02  by  Michael Scheer
*CMZ :  2.30/03 20/04/2001  12.19.22  by  Michael Scheer
*CMZ :  2.30/02 12/04/2001  19.10.52  by  Michael Scheer
*CMZ :  2.30/01 12/04/2001  18.17.23  by  Michael Scheer
*CMZ :  2.20/12 11/04/2001  17.02.34  by  Michael Scheer
*CMZ :  2.20/11 11/04/2001  16.11.52  by  Michael Scheer
*CMZ :  2.20/10 10/04/2001  11.26.41  by  Michael Scheer
*CMZ :  2.20/09 03/04/2001  14.23.18  by  Michael Scheer
*CMZ :  2.15/01 30/03/2001  20.02.21  by  Michael Scheer
*CMZ :  2.20/08 18/03/2001  20.48.35  by  Michael Scheer
*CMZ :  2.20/07 18/03/2001  17.08.58  by  Michael Scheer
*CMZ :  2.20/06 15/03/2001  17.20.08  by  Michael Scheer
*CMZ :  2.20/05 15/03/2001  16.57.30  by  Michael Scheer
*CMZ :  2.20/04 09/03/2001  16.47.40  by  Michael Scheer
*CMZ :  2.20/03 23/02/2001  15.04.13  by  Michael Scheer
*CMZ :  2.20/02 21/02/2001  11.30.46  by  Michael Scheer
*CMZ :  2.20/01 20/02/2001  14.18.37  by  Michael Scheer
*-- Author : Michael Scheer

      SUBROUTINE SOUINTANA(ISOUR,IOBSV,INSIDE)

+seq,gplhint.
+SEQ,TRACKF90U.
+SEQ,WORKF90U.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,AFREQF90U.
+SEQ,AMPLIF90U.
+SEQ,WFOLDF90U.

      use bunchmod
      use wbetaf90m
      use souintmod
      !use waveenv
      use clustermod

C--- EVALUATE INTEGRALES FOR A SINGLE SOURCE
C---- RESULTS ARE STORE IN AFREQ AND SPECPOW

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,PHYCON.
+SEQ,TRACK.
+seq,sourcef90.
+SEQ,COLLI.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,FREQS.
+SEQ,AMPLI.
+SEQ,B0SCGLOB.
+SEQ,PRIMKIN.
+SEq,wfoldf90.
+seq,ustep.
+SEQ,uservar.
+seq,tralin.
+seq,whbook.
+seq,pawcmn.
+seq,specdip.
+seq,datetime.
+seq,waveenv.

      REAL*8 FSPEC(31)

      double precision h2,ddist,dist0,dist02
     & ,vn,dgamma

      COMPLEX*16 ZIOM,ZI,ZIDOM,ZONE,ZICR1,ZIC,daff(3),baff(3)
      COMPLEX*16 EXPOM1,EXPOM,DEXPOMPH1,DEXPOMPH,DDEXPOMPH,DEXPOM,EXPOMV2
      COMPLEX*16 APOL,APOLH,APOLR,APOLL,APOL45
     &  ,DMODU,DMODU0,DDMODU,AX,AY,AZ,AX0,AY0,AZ0,bx0,by0,bz0,bxc,byc,bzc

      DOUBLE PRECISION T0,T1,T2,TENDSOU,X0,X1,X2,X10,Y1,Y2,Z1,Z2,XENDSOU,R0
     &  ,T,DT,DT2,DT0,DTIM00,DTIM01,VXP,VYP,VZP,TENDSOU1
     &  ,R02
c     &  ,H2,H2R2
     &  ,PHI,FREQR,CORRR0,R00,R2,POW,powpow
     &  ,X2B,Y2B,Z2B
     &  ,DGAMSUM,BETA,GAMGAM,GAMGAM0,AMPDT,sqnphsp
     &  ,xn1,slopein,slope,drn1,drn2,zn1,yn1,wi,
     &  zz,yy,zzp,yyp,zzi,yyi,yypi,zzpi,
     &  yeleco,zeleco,zpeleco,ypeleco
      double precision, save :: soura(3,4),soure(3,4)

      DOUBLE PRECISION VX1,VY1,VZ1,BX1,BY1,BZ1
      DOUBLE PRECISION VX2,VY2,VZ2,BX2,BY2,BZ2,AX2D,AY2D,AZ2D
      DOUBLE PRECISION ECDUM,BS,BSQ,ECMAXS,BS1
      DOUBLE PRECISION TS,DPHASE,DPHSOUR(2,2)
      DOUBLE PRECISION C1,OM,DOM,GAMMA

      DOUBLE PRECISION BX,BY,BZ,RX,RY,RZ,PX,PY,PZ,RNBX,RNBY,RNBZ
      DOUBLE PRECISION R1,RNX,RNY,RNZ,DOM1,DOM2,BET1N,DUM11,R,BPX,BPY,BPZ
      DOUBLE PRECISION WGANG,OPANG

      DOUBLE PRECISION RARG(5),PHASE,C

      DOUBLE PRECISION DROIX,DTPHASE,DXEXI,CENXEXI,roi(nroip)
      DOUBLE PRECISION STOK1,STOK2,STOK3,STOK4,BET1NO,sqnbunch
      double precision br2,rnr2,br4,rnr4,b3
     &  ,are(6),aim(6),yp2zp2i,robsv,phiobsv,
     &  f(3),yp(3),ypp,a(3),fdt(3),filo,fihi,dfdt,xobsv,yobsv,zobsv,speck,
     &  tfmh(2,2),tfmv(2,2),tfm1(2,2),
     &  w22(2,2),dum22(2,2),
     &  tfmhi(2,2),tfmvi(2,2),
     &  tfmdehi(2,2),tfmdevi(2,2),
     &  tfmdeh(2,2),tfmdev(2,2),
     &  tfmhc(2,2),tfmvc(2,2),
     &  tfmdehc(2,2),tfmdevc(2,2),
     &  tfmhtoti(2,2),tfmvtoti(2,2),
     &  tfmdehtoti(2,2),tfmdevtoti(2,2)
+self,if=-tralinshort.
     &  ,rq,cpsi,alpha,spsi,rm,betafun,psi
+self.
     &  ,alpha0(2),beta0(2)
+self,if=blind.
     &  ,rest
+self.

      real*8 fillb(41)
      real rnrn(2)
      INTEGER IINSIDE,JINSIDE,INSIDE,iw2(2),ifail
      INTEGER ISOUR,isourold,IOBSV,kfreq,JFREQ,IZAEHL,NZAEHL,IX10,I,ICAL,ICOMP
+self,if=-windows.
      INTEGER*8
+self,if=windows.
      INTEGER
+self.
     &  NZAEHL10,MZAEHL,KZAEHL,iizaehl
      INTEGER ICSPL,IROI,II,IZTOTS,IWARNBET1N,LSTEP,IR1,IR2
      integer nelec,jobunch,job,jfrob,norad,iwarnwi,lun10
+self,if=blind.
     &  ,isec
+self.

      INTEGER NTUPP,IC,jpin
      PARAMETER (NTUPP=38)
      REAL*8 FILLT(NTUPP)
      CHARACTER(5) CTUP(NTUPP)

      DOUBLE PRECISION wth,wta,
     &                H6,H26,A2,A21H6,A3AH26,B,B2,B21H6,B3BH26,DT10
      integer icount,mode,klo,khi,k

      common/souintc/jpin

      data ctup /'t','x','y','z','rx','ry','rz','rt','p','expr','expi','roi'
     &  ,'iob','ie','yob','zob','bet1n','om','dt','by2','isou'
     &  ,'spec','reax','imax','reay','imay','reaz','imaz','dom1',
     &  'betx','bety','betz','betxp','betyp','betzp','nx','ny','nz'/

      DATA isourold/0/
      DATA ICAL/0/
      DATA tfm1(1,1),tfm1(1,2),tfm1(2,1),tfm1(2,2)/1.0d0,0.0d0,0.0d0,1.0d0/
      DATA ZI/(0.0D0,1.0D0)/
      DATA ZONE/(1.0D0,0.0D0)/
      DATA IWARNBET1N/0/

      save

      IF (ICAL.EQ.0) THEN

c        open(unit=111,file='fort.111',recl=512)

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'       SUBROUTINE SOUINTANA:'
        WRITE(LUNGFO,*)

        IF (NFREQ.GT.NDFREQ) THEN
          WRITE(LUNGFO,*)
     &      '*** ERROR IN SOUINTANA: NUMBER OF MAXIMUM PHOTON ENERGIES EXCEEDED'
          WRITE(LUNGFO,*)
     &      'INCREASE PARAMETER NDFREQP IN CMPARA.CMN'
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED  ***'
          WRITE(6,*)
     &      '*** ERROR IN SOUINTANA: NUMBER OF MAXIMUM PHOTON ENERGIES EXCEEDED'
          WRITE(6,*)
     &      'INCREASE PARAMETER NDFREQP IN CMPARA.CMN'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED  ***'
          STOP
        ENDIF    !(NFREQ.GT.NDFREQP)

        if (icluster.lt.0.and.ibunch.ne.0.and.iubunch.eq.3) then
          soura(1:3,1:4)=sourceaclu(1:3,1:4)
          soure(1:3,1:4)=sourceeclu(1:3,1:4)
        else
          soura(1:3,1:4)=sourceao(1:3,1:4,isour)
          soure(1:3,1:4)=sourceeo(1:3,1:4,isour)
        endif

        DO II=1,NSOURCE
          DO I=1,NROIA
            IWARNROI(I,II)=0
          ENDDO
        ENDDO

        C=CLIGHT1
        C1=1.D0/CLIGHT1

        DOM=(FREQ(2)-FREQ(1))/HBAREV1
c        DOM=0.0d0
        OM=FREQ(1)/HBAREV1
        ZIDOM=ZI*DOM
        ZIOM=ZI*OM
        ZIC=ZI*CLIGHT1

        IF (IWFILINT.LT.0) THEN
+self,if=-mhbook.
          CALL hbookm(NIDSOURCE,'RADIATION INTEGRALS$',NTUPP
     &      , '//WAVE',1024,CTUP)
+self,if=mhbook.
          CALL hbookm(NIDSOURCE,'RADIATION INTEGRALS',NTUPP
     &      , '//WAVE',nlpoi/jwfilint+2*jwfilint,CTUP)
+self.
        ENDIF !(IWFILINT.LT.0)

        jobunch=icbrill
        if (iobunch.ne.-9999) then
          jobunch=iobunch
        endif

        nphsp=nbunch
        nelec=neinbunch*nphsp

c Flux density is normalized to number of electrons per bunch or bunch charge
c and dmycurr. The field is normalized such, that flux dens = ABS(field)**2
        if (ibunch.ne.0.and.bunchcharge.ne.0.0d0) then
          sqnbunch=nbunch
          sqnphsp=sqrt(bunchcharge/echarge1)
     &      *neinbunch
     &      /(bunchcharge/echarge1)
          bunnor=1.0d0/nbunch
        else
          sqnbunch=nbunch
          sqnphsp=sqrt(dble(neinbunch))
          bunnor=1.0d0/nbunch
        endif

        if (iobsv.ne.jobunch) then
          print*,'****************************************************'
          print*,
     &      '*** SEVERE ERROR IN SOUINTANA: IOBSV.NE.iobunch FOR FIRST CALL'
          print*,'*** Programm WAVE aborted ***'
          print*,'****************************************************'
          stop
        endif

      ENDIF !ICAL

      IF (ISPECMODE.EQ.1) THEN
        DTIM00=DTMCO
      ELSE
        DTIM00=DTIM0
      ENDIF

      DTIM01=1.D0/DTIM00

      ypeleco=vyelec/vxelec
      zpeleco=vzelec/vxelec
      zeleco=zelec
      yeleco=yelec

c Transfermatrices

      if (ibunch.ne.0.and.iampli.lt.0.and.isour.ne.isourold) then

        tfmh=tfm1
        tfmv=tfm1
        tfmhc=tfm1
        tfmvc=tfm1
        tfmhtoti=tfm1
        tfmvtoti=tfm1

        tfmdeh=tfm1
        tfmdev=tfm1
        tfmdehc=tfm1
        tfmdevc=tfm1
        tfmdehtoti=tfm1
        tfmdevtoti=tfm1

        x1=soura(1,1)
        y1=soura(2,1)
        z1=soura(3,1)

        x2=soure(1,1)

        alpha0(1)=-wbetasub(3,1)/2.d0
        alpha0(2)=-wbetasub(5,1)/2.d0
        beta0(1)=wbetasub(2,1)
        beta0(2)=wbetasub(4,1)

        if (alpha0(1).gt.0.001) then
          write(6,*)' '
          write(6,*)'*** Warning in SOUINTANA: Derivative of hori. beta function'
          write(6,*)'beginnning of the source is greater than 0.001!'
          write(6,*)' '
        endif

        if (alpha0(2).gt.0.001) then
          write(lungfo,*)' '
          write(lungfo,*)'*** Warning in SOUINTANA: Derivative of vert. beta function'
          write(lungfo,*)'in source center is greater than 0.001!'
          write(lungfo,*)'source center:',(x1+x2)/2.0d0
          write(lungfo,*)'beta, alpha:',beta0(2),alpha0(2)
          write(lungfo,*)'Maybe it is useful, to set IBL0CUT'
          write(lungfo,*)' '
          write(6,*)' '
          write(6,*)'*** Warning in SOUINTANA: Derivative of vert. beta function'
          write(6,*)'in source center is greater than 0.001!'
          write(6,*)'source center:',(x1+x2)/2.0d0
          write(6,*)'beta, alpha:',beta0(2),alpha0(2)
          write(6,*)'Maybe it is useful, to set IBL0CUT'
          write(6,*)' '
        endif

+self,if=-tralinshort.

        alpha=-wbetasub(3,3)/2.0d0
        betafun=  wbetasub(2,3)
        psi=   wbetasub(8,3)

        cpsi=cos(psi)
        spsi=sin(psi)
        rq=sqrt(betafun/beta0(1))
        rm=sqrt(betafun*beta0(1))

        tfmhc(1,1) = rq * (cpsi+alpha0(1)*spsi)
        tfmhc(1,2) = rm * spsi
        tfmhc(2,1)=
     &    ((alpha0(1)-alpha)*cpsi - (1.0d0+alpha0(1)*alpha)*spsi) / rm
        tfmhc(2,2)=
     &    (cpsi-alpha*spsi) / rq

        alpha=-wbetasub(5,3)/2.d0
        betafun=  wbetasub(4,3)
        psi=   wbetasub(9,3)

        cpsi=cos(psi)
        spsi=sin(psi)
        rq=sqrt(betafun/beta0(2))
        rm=sqrt(betafun*beta0(2))

        tfmvc(1,1) = rq * (cpsi+alpha0(2)*spsi)
        tfmvc(1,2) = rm * spsi
        tfmvc(2,1)=
     &    ((alpha0(2)-alpha)*cpsi - (1.0d0+alpha0(2)*alpha)*spsi) / rm
        tfmvc(2,2)=
     &    (cpsi-alpha*spsi) / rq

+self,if=tralinshort.
        call tralinshort(x1,y1,z1,0.0d0,0.0d0,(x1+x2)/2.0d0,dmygamma,
     &    tfmhc,tfmvc,tfmdehc,tfmdevc)
+self.

+self,if=-tralinshort.
        alpha=-wbetasub(3,3)/2.d0
        betafun=  wbetasub(2,3)
        psi=   wbetasub(8,3)

        cpsi=cos(psi)
        spsi=sin(psi)
        rq=sqrt(betafun/beta0(1))
        rm=sqrt(betafun*beta0(1))

        tfmh(1,1) = rq * (cpsi+alpha0(1)*spsi)
        tfmh(1,2) = rm * spsi
        tfmh(2,1)=
     &    ((alpha0(1)-alpha)*cpsi - (1.0d0+alpha0(1)*alpha)*spsi) / rm
        tfmh(2,2)=
     &    (cpsi-alpha*spsi) / rq

        alpha=-wbetasub(5,3)/2.d0
        betafun=  wbetasub(4,3)
        psi=   wbetasub(9,3)

        cpsi=cos(psi)
        spsi=sin(psi)
        rq=sqrt(betafun/beta0(2))
        rm=sqrt(betafun*beta0(2))

        tfmv(1,1) = rq * (cpsi+alpha0(2)*spsi)
        tfmv(1,2) = rm * spsi
        tfmv(2,1)=
     &    ((alpha0(2)-alpha)*cpsi - (1.0d0+alpha0(2)*alpha)*spsi) / rm
        tfmv(2,2)=
     &    (cpsi-alpha*spsi) / rq

+self,if=tralinshort.
        call tralinshort(x1,y1,z1,0.0d0,0.0d0,x2,dmygamma,
     &    tfmh,tfmv,tfmdeh,tfmdev)
+self.

        w22=tfmh

        dum22(1,1)=1.0d0
        dum22(1,2)=0.0d0
        dum22(2,1)=0.0d0
        dum22(2,2)=1.0d0

        call deqinv(2,w22,2,iw2,ifail,2,dum22)

        if (ifail.ne.0) then
          write(6,*)'*** Error in SOUINTANA: Matrix invertation failed'
          write(6,*)'Please check horizontal beta functions.'
          write(lungfo,*)'*** Error in SOUINTANA: Matrix invertation failed'
          write(lungfo,*)'Please check horizontal beta functions.'
          stop '*** Program WAVE aborted ***'
        endif

        tfmhi=w22

        w22=tfmv

        dum22(1,1)=1.0d0
        dum22(1,2)=0.0d0
        dum22(2,1)=0.0d0
        dum22(2,2)=1.0d0

        call deqinv(2,w22,2,iw2,ifail,2,dum22)

        if (ifail.ne.0) then
          write(6,*)'*** Error in SOUINTANA: Matrix invertation failed'
          write(6,*)'Please check vertical beta functions.'
          write(lungfo,*)'*** Error in SOUINTANA: Matrix invertation failed'
          write(lungfo,*)'Please check vertical beta functions.'
          stop '*** Program WAVE aborted ***'
        endif

        tfmvi=w22

        tfmdehi=tfmhi
        tfmdevi=tfmvi

+self,if=wbetdeltae.
        w22=tfmdeh

        dum22(1,1)=1.0d0
        dum22(1,2)=0.0d0
        dum22(2,1)=0.0d0
        dum22(2,2)=1.0d0

        call deqinv(2,w22,2,iw2,ifail,2,dum22)

        if (ifail.ne.0) then
          write(6,*)'*** Error in SOUINTANA: Matrix invertation failed'
          write(6,*)'Please check horizontal beta functions.'
          write(lungfo,*)'*** Error in SOUINTANA: Matrix invertation failed'
          write(lungfo,*)'Please check horizontal beta functions.'
          stop '*** Program WAVE aborted ***'
        endif

        tfmdehi=w22

        w22=tfmdev

        dum22(1,1)=1.0d0
        dum22(1,2)=0.0d0
        dum22(2,1)=0.0d0
        dum22(2,2)=1.0d0

        call deqinv(2,w22,2,iw2,ifail,2,dum22)

        if (ifail.ne.0) then
          write(6,*)'*** Error in SOUINTANA: Matrix invertation failed'
          write(6,*)'Please check vertical beta functions.'
          write(lungfo,*)'*** Error in SOUINTANA: Matrix invertation failed'
          write(lungfo,*)'Please check vertical beta functions.'
          stop '*** Program WAVE aborted ***'
        endif

        tfmdevi=w22
+self.

        tfmhtoti=tfmhi
        tfmvtoti=tfmvi

        if (iampli.lt.0) then
          do i=1,-iampli/2-1
            call util_matrix_multiplication(2,2,2,tfmhtoti,tfmhi,tfmhtoti,w22)
            call util_matrix_multiplication(2,2,2,tfmvtoti,tfmvi,tfmvtoti,w22)
+self,if=wbetdeltae.
            call util_matrix_multiplication(2,2,2,tfmdehtoti,tfmdehi,tfmdehtoti,w22)
            call util_matrix_multiplication(2,2,2,tfmdevtoti,tfmdevi,tfmdevtoti,w22)
+self.
          enddo
+self,if=-wbetdeltae.
          tfmdehtoti=tfmhtoti
          tfmdevtoti=tfmhtoti
+self.
        endif

      endif !isour

      if (jpin.eq.0.or.
     &    (inside.ne.-3.or.ielec.eq.1).and.icluster.lt.0.and.iwinstance.eq.1
     &    .or.
     &    (inside.ne.-3.or.ielec.eq.1).and.icluster.ge.0) then
        xobsv=obsv(1,iobsv)
        yobsv=obsv(2,iobsv)
        zobsv=obsv(3,iobsv)
      else
        xobsv=obsv(1,iobsv)
        call grndmm(rnrn,2)  !s. 39
        yobsv=pincen(2)-pinh/2.0d0+rnrn(1)*pinh
        zobsv=pincen(3)-pinw/2.0d0+rnrn(2)*pinw
        if (ipincirc.ne.0) then
          yobsv=1.0d30
          zobsv=1.0d30
          do while (sqrt(yobsv**2+zobsv**2).gt.pinr)
            call grndmm(rnrn,2)  !s. 39
            yobsv=(rnrn(1)-0.5)*2.0d0*pinr
            zobsv=(rnrn(2)-0.5)*2.0d0*pinr
          enddo
          yobsv=pincen(2)+yobsv
          zobsv=pincen(3)+zobsv
        endif
      endif

      IF (jpin.ne.3.and.ielec.eq.1.and.IOBSV.EQ.jobunch
     &    .or.jpin.eq.3.and.ielec.eq.1) THEN

        WRITE(LUNGFO,*)'            SOURCE NUMBER',ISOUR,':'
        WRITE(LUNGFO,*)

        do kfreq=1,nfreq
          ampzmax(kfreq)=0.0d0
          azcos(kfreq)=1.0d0
          azsin(kfreq)=0.0d0
        enddo

        X1=xelec

        IF (ISPECMODE.EQ.1) THEN
          XENDSOU=DWX(MCO)    !FINAL X
        ELSE
          XENDSOU=soure(1,1)    !FINAL X
        ENDIF

        IF (NROI.LT.0) THEN
          DROIX=(XENDSOU-X1)/(NROIA-1)
          DO IROI=1,NROIA
            ROIX(IROI)=X1+(IROI-1)*DROIX
            ROIP(IROI)=1.0D0
          ENDDO
        ENDIF   !(NROI.LT.0)

        ROIX(1)=ROIX(1)-1.0D-6
        ROIX(NROIA)=ROIX(NROIA)+1.0D-6

        DO IROI=1,NROIA
          IPOIROI(IROI)=0
          if (ical.eq.0) then
            roi(iroi)=roix(iroi)
          endif
        ENDDO

      ENDIF !IF (ielec.eq.1.and.IOBSV.EQ.jobunch) THEN

      ILIOB=ISOUR+NSOURCE*(IOBSV-1)
c?6.11.      if (jpin.ne.3.or.jpin.eq.3.and.ielec.eq.1) SPECPOW(ILIOB)=0.0D0

      LSTEP=0
      DGAMSUM=0.0D0

      gamma=egamma
      beta=dsqrt((1.d0-1.d0/gamma)*(1.d0+1.d0/gamma))

      WGANG=WGWINFC/GAMMA

      ICSPL=0

      if (inside.ne.-3) then
        INSIDE=1
        iinside=-1
      endif

      IINSIDE=0
      JINSIDE=0

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS     T=-R0*C1
      T=0.0D0 !WICHTIG HIER WEGEN TENDSOU-T WEITER UNTEN

      R0=XOBSV-soura(1,1)

      IF (ISPECMODE.EQ.1) THEN
        T0=DWT(1)
        T1=T0
        T2=DWT(MCO)
        XENDSOU=DWX(MCO)    !FINAL X
      ELSE
        T0=SOURCET(1,ISOUR)
        T1=T0
        T2=SOURCET(2,ISOUR)
        XENDSOU=soure(1,1)    !FINAL X
      ENDIF

      TENDSOU=T2-T1

      IF (X1.LT.ROIX(1).OR.XENDSOU.GT.ROIX(NROIA)) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN SOUINTANA: X OUTSIDE ROIS ***'
        WRITE(LUNGFO,*)'CHECK NAMELIST $ROIN'
        WRITE(LUNGFO,*)' *** PROGRAM WAVE ABORTED ***'
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN SOUINTANA: X OUTSIDE ROIS ***'
        WRITE(6,*)'CHECK NAMELIST $ROIN'
        WRITE(6,*)' *** PROGRAM WAVE ABORTED ***'
        STOP
      ENDIF   !IROI

      X1=xelec
      Y1=yelec
      Z1=zelec

      VX1=vxelec
      VY1=vyelec
      VZ1=vzelec

      BX1=soura(1,4)
      BY1=soura(2,4)
      BZ1=soura(3,4)
      BS1=SQRT(BX1**2+BY1**2+BZ1**2)

      IZTOTS=0

      X0=X1
      X2=X1
      X10=(XENDSOU-X0)/10.1D0

      NZAEHL=NLPOIO
      DT0=TENDSOU/NZAEHL

      DT=DT0

      if (ielec.eq.1) then

        KZAEHL=0

        IR1=-1
        DO IROI=1,NROIA
          IF (ROI(IROI).GT.X1.AND.ROI(IROI).LT.XENDSOU.AND.IR1.EQ.-1) THEN
            IR1=IROI
            GOTO 11
          ENDIF
        ENDDO

11      DO IROI=1,NROIA
          IR2=IROI
          IF (ROI(IROI).GT.XENDSOU) THEN
            ROI(IROI)=XENDSOU
            IR2=IR2-1
            IF (ROI(IR2).LT.X1) THEN
              ROI(IR2)=X1
            ENDIF
            GOTO 12
          ENDIF
        ENDDO

12      CONTINUE

        KZAEHL=KZAEHL+NZAEHL*ROIP(IR2)*(XENDSOU-ROI(IR2))/(XENDSOU-X1)

        IF (IR1.NE.-1) THEN

          KZAEHL=KZAEHL+NZAEHL*ROIP(IR1-1)*(ROI(IR1)-X1)/(XENDSOU-X1)

          DO IROI=IR1,IR2-1
            IF (ROI(IROI).GT.X1.OR.ROI(IROI)+1.LT.XENDSOU) THEN
              KZAEHL=KZAEHL+NZAEHL*ROIP(IROI)*(ROI(IROI+1)-ROI(IROI))/(XENDSOU-X1)
            ELSE IF (ROI(IROI).GT.X1.OR.ROI(IROI)+1.LT.XENDSOU) THEN
              KZAEHL=KZAEHL+NZAEHL*ROIP(IROI)*(ROI(IROI+1)-ROI(IROI))/(XENDSOU-X1)
            ENDIF
          ENDDO

        ENDIF

      endif !ibun.eq.nphsp

      X2=X1
      Y2=Y1
      Z2=Z1

      VX2=VX1
      VY2=VY1
      VZ2=VZ1

      BX2=BX1
      BY2=BY1
      BZ2=BZ1
      BS=BS1

C--- LOOP OVER STEPS

      IROI=1
      DO I=1,NROIA
        IF (X1.GE.ROIX(I)) THEN
          IROI=I
        ENDIF !(X1.GE.ROIX(I))
      ENDDO   !IROI

      DT=DT0/ROIP(IROI)

      NZAEHL=MAX(5,NINT((TENDSOU-T)/DT))
      DT=(TENDSOU-T)/NZAEHL

      TENDSOU1=TENDSOU-DT
      DT2=DT/2.D0

C- CHECK STEPS SIZE

      IF (IWARNROI(IROI,ISOUR).EQ.0) THEN
        IF (DT-DTIM00.ge.dtim00*0.001) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '*** WARNING IN SOUINTANA, SOURCE, ROI:',ISOUR,IROI
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
          WRITE(LUNGFO,*)'SIZE FOR TRAJECTORY!'
          WRITE(LUNGFO,*)
          write(lungfo,*)'Step size for source point:',dt*clight1
          write(lungfo,*)'Step size for trajectory:',dtim00*clight1
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
          WRITE(6,*)
          WRITE(6,*)
     &      '*** WARNING IN SOUINTANA, SOURCE, ROI:',ISOUR,IROI
          WRITE(6,*)
          WRITE(6,*)'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
          WRITE(6,*)'SIZE FOR TRAJECTORY!'
          WRITE(6,*)
          write(6,*)'Step size for source point:',dt*clight1
          write(6,*)'Step size for trajectory:',dtim00*clight1
          WRITE(6,*)
          WRITE(6,*)
     &      'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
          WRITE(6,*)
          IWARNROI(IROI,ISOUR)=1
        ENDIF !DT
      ENDIF !IWARNROI

      IROI=IROI+1

      IZAEHL=0 !LOOP COUNTER for each track

      nutrack=ielec
      nustep=izaehl

      if (jpin.ne.3.and.ielec.eq.1.and.iobsv.eq.jobunch
     &    .or.jpin.eq.3.and.ielec.eq.1) then
        iizaehl=0 !total number of steps in souintana
        NZAEHL10=KZAEHL*nelec*nobsv/10
        MZAEHL=NZAEHL10
c        mzaehl=0
        IX10=1
      endif

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS     T=-R0*C1

      T=-DT
      TS=-DT

      r=sqrt((xobsv-x1)**2+((yobsv-y1)**2+(zobsv-z1)**2))
      PHASE=(r-r0)*c1 ! needed for phase of field amplitude

      EXPOM1=ZONE
      DEXPOMPH1=ZONE

      IF (ifreq2p.EQ.0) THEN
        DO JFREQ=1,NFREQ
          EXPOM2P0(1,JFREQ)=ZONE
        ENDDO
      ENDIF

      yp2zp2i=0.0D0
      f=0.0d0

      powpow=0.0d0

1000  IZAEHL=IZAEHL+1

      nustep=izaehl
      IIZAEHL=IIZAEHL+1 !total step counter

      IF (ISOUR.eq.1.and.IIZAEHL.GE.MZAEHL.and.ix10.lt.11
     &    ) THEN
        CALL date_and_time(dtday,dttime,dtzone,idatetime)
        WRITE(6,*)' ',IX10,' ',dttime(1:2),':',dttime(3:4),':',dttime(5:6)
        if (icluster.lt.0) then
          open(newunit=lun10,file="wave.n10")
          WRITE(lun10,'(a)')dttime(1:2)//':'//dttime(3:4)//':'//dttime(5:6)
          write(lun10,*)ix10
          flush(lun10)
          close(lun10)
        endif
        IX10=IX10+1
        MZAEHL=MZAEHL+NZAEHL10
      ENDIF

      IF (IROI.LE.NROIA) THEN

        IF (X2.GE.ROIX(IROI)) THEN

          DT=DT0/ROIP(IROI)
          NZAEHL=NINT((TENDSOU-T)/DT)

          IF (ISPECMODE.EQ.1) THEN
            DT=(TENDSOU-T)/(NZAEHL-1)
          ELSE
            DT=(TENDSOU-T)/NZAEHL
          ENDIF

          TENDSOU1=TENDSOU-DT

          DT2=DT/2.D0

          IF (IWARNROI(IROI,ISOUR).EQ.0) THEN

            IF (DT-DTIM00.ge.dtim00*0.001) THEN

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          '*** WARNING IN SOUINTANA, SOURCE, ROI:',ISOUR,IROI
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
              WRITE(LUNGFO,*)'SIZE FOR TRAJECTORY!'
              WRITE(LUNGFO,*)
              write(lungfo,*)'Step size for source point:',dt*clight1
              write(lungfo,*)'Step size for trajectory:',dtim00*clight1
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
              WRITE(6,*)
              WRITE(6,*)
     &          '*** WARNING IN SOUINTANA, SOURCE, ROI:',ISOUR,IROI
              WRITE(6,*)
              WRITE(6,*)'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
              WRITE(6,*)'SIZE FOR TRAJECTORY!'
              WRITE(6,*)
              write(6,*)'Step size for source point:',dt*clight1
              write(6,*)'Step size for trajectory:',dtim00*clight1
              WRITE(6,*)
              WRITE(6,*)
     &          'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
              WRITE(6,*)

              IWARNROI(IROI,ISOUR)=1

            ENDIF !DT

          ENDIF !IWARNROI

          IROI=IROI+1

        ENDIF   !X2

      ENDIF   !IROI

      if (ibun.eq.1.and.isub.eq.1) IPOIROI(IROI)=IPOIROI(IROI)+1

      T=T+DT

      IF (LSTEP.EQ.1) THEN

        IF (X2.LE.XENDSOU) THEN

          DT=(MIN(XENDSOU,XIEND)-X2)/VX2
          DT2=DT/2.0D0

        ELSE

          TS=TS-DT
          T=T-DT

          DT=(MIN(XENDSOU,XIEND)-X1)/VX2
          DT2=DT/2.0D0

          X2=X1
          Y2=Y1
          Z2=Z1

          VX2=VX1
          VY2=VY1
          VZ2=VZ1

          BX2=BX1
          BY2=BY1
          BZ2=BZ1
          BS=BS1

        ENDIF !X2

      ENDIF !LSTEP

      X1=X2
      Y1=Y2
      Z1=Z2

      VX1=VX2
      VY1=VY2
      VZ1=VZ2

      BX1=BX2
      BY1=BY2
      BZ1=BZ2
      BS1=BS

      IF (ISPECMODE.NE.1) THEN

C GET MAGNETIC FIELD {

        X2B=X1+VX1*DT2
        Y2B=Y1+VY1*DT2
        Z2B=Z1+VZ1*DT2
        norad=0
        if (ibmasksp.ne.0) then
          ibmasksp=-abs(ibmasksp)
          call mybfeld(x2b,y2b,z2b,bx2,by2,bz2,ax2d,ay2d,az2d)
          if ((bx2**2+by2**2+bz2**2).ne.0.0d0) then
            norad=1
          endif
          ibmasksp=-ibmasksp
        endif

        X2=WSOU(1,1,IZAEHL)
        Y2=WSOU(2,1,IZAEHL)
        Z2=WSOU(3,1,IZAEHL)

        VX2=WSOU(1,2,IZAEHL)
        VY2=WSOU(2,2,IZAEHL)
        VZ2=WSOU(3,2,IZAEHL)

        VXP=WSOU(1,3,IZAEHL)
        VYP=WSOU(2,3,IZAEHL)
        VZP=WSOU(3,3,IZAEHL)

        DT=   WSOU(1,4,IZAEHL)
        BETA= wsou(2,4,IZAEHL)
        GAMMA=wsou(3,4,IZAEHL)

        BX2=WSOU(1,5,IZAEHL)
        BY2=WSOU(2,5,IZAEHL)
        BZ2=WSOU(3,5,IZAEHL)

        BX=VX2*C1
        BY=VY2*C1
        BZ=VZ2*C1

        BPX=VXP*C1
        BPY=VYP*C1
        BPZ=VZP*C1

C MOVE ONE STEP }

      ELSE  !ISPECMODE

c{wave_track_inter, inline

c        CALL WAVE_TRACK_INTER(TS,X2,Y2,Z2,VX2,VY2,VZ2,VXP,VYP,VZP,BS,ICSPL,
c     &    GAMMA)

        IF (ICOUNT.EQ.0) THEN
          MODE=0
          DT=(DWT(2)-DWT(1))
          DT10=DT*1.D-10
          DO I=2,MCO
         IF (ABS(DWT(I)-DWT(I-1)-DT).GT.DT10) THEN
           MODE=1
           GOTO 19
                ENDIF
          ENDDO
19        KLO=1
          KHI=MCO
          ICOUNT=1
        ENDIF

      IF (MODE.EQ.1) THEN

        IF (KLO.GE.MCO.OR.KLO.LT.1.OR.KHI.GT.MCO.OR.KHI.LT.2) THEN
          KLO=1
          KHI=MCO
        ENDIF

          IF (T.GE.DWT(KLO).AND.T.LT.DWT(KLO+1)) THEN
            KHI=KLO+1
            GOTO 2
          ELSE IF (T.LT.DWT(KLO).OR.T.GE.DWT(KHI)) THEN
            KLO=1
            KHI=MCO
          ENDIF

          K=1
111       K=K*2
          KHI=KLO+K
          IF (KHI.GE.MCO) GOTO 122
          IF (T.GT.DWT(KHI)) THEN
            KLO=KHI
            GOTO 111
          ELSE
            GOTO 1
          ENDIF

122       KHI=MCO

1         IF (KHI-KLO.GT.1) THEN
            K=(KHI+KLO)/2
            IF(DWT(K).GT.T)THEN
              KHI=K
            ELSE
              KLO=K
            ENDIF
            GOTO 1
          ENDIF

        ELSE !MODE

          IF (T.GE.DWT(1).AND.T.LT.DWT(MCO)) THEN
            KLO=T/DT+1
            KHI=KLO+1
            IF (KHI.GT.MCO) THEN
              KHI=MCO
              KLO=KHI-1
            ENDIF
          ELSE IF (T.LT.DWT(1)) THEN
            KLO=1
            KHI=2
          ELSE IF (T.GE.DWT(MCO)) THEN
            KLO=MCO-1
            KHI=MCO
          ENDIF

        ENDIF !MODE

2       wtH=DWT(KHI)-DWT(KLO)

        IF (wtH.EQ.0.) THEN
          WRITE(6,*) '*** ERROR IN WAVE_TRACK_INTER: BAD INPUT ***'
          STOP
        ENDIF

        H6=wtH/6.D0
        H26=H6*wtH
        wta=(DWT(KHI)-T)/wtH
        A2=wta*wta
        A3AH26=(A2-1.D0)*wta*H26
        A21H6=(-3.D0*A2+1.D0)*H6
        B=(T-DWT(KLO))/wtH
        B2=B*B
        B21H6=(3.D0*B2-1.D0)*H6
        B3BH26=(B2-1.D0)*B*H26

        X2=wta*DWX(KLO)+B*DWX(KHI)+A3AH26*DWX2P(KLO)+B3BH26*DWX2P(KHI)
        VX2=(-DWX(KLO)+DWX(KHI))/wtH+A21H6*DWX2P(KLO)+B21H6*DWX2P(KHI)
        VXP=wta*DWX2P(KLO)+B*DWX2P(KHI)

        Y2=wta*DWY(KLO)+B*DWY(KHI)+A3AH26*DWY2P(KLO)+B3BH26*DWY2P(KHI)
        VY2=(-DWY(KLO)+DWY(KHI))/wtH+A21H6*DWY2P(KLO)+B21H6*DWY2P(KHI)
        VYP=wta*DWY2P(KLO)+B*DWY2P(KHI)

        Z2=wta*DWZ(KLO)+B*DWZ(KHI)+A3AH26*DWZ2P(KLO)+B3BH26*DWZ2P(KHI)
        VZ2=(-DWZ(KLO)+DWZ(KHI))/wtH+A21H6*DWZ2P(KLO)+B21H6*DWZ2P(KHI)
        VZP=wta*DWZ2P(KLO)+B*DWZ2P(KHI)

        BS=wta*DWB(KLO)+B*DWB(KHI)+A3AH26*DWB2P(KLO)+B3BH26*DWB2P(KHI)

        GAMMA=(TRAGAM(KLO)+TRAGAM(KHI))/2.0D0

c}wave_track_inter, inline
        norad=0
        if (ibmasksp.ne.0) then
          ibmasksp=-abs(ibmasksp)
          call mybfeld(x2b,y2b,z2b,bx2,by2,bz2,ax2d,ay2d,az2d)
          if ((bx2**2+by2**2+bz2**2).ne.0.0d0) then
            norad=1
          endif
          ibmasksp=-ibmasksp
        endif

        IF (IENELOSS.NE.0) THEN
          BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
        ENDIF

        BSQ=BS*BS
        BY2=BSQ

        BX=VX2*C1
        BY=VY2*C1
        BZ=VZ2*C1
        BPX=VXP*C1
        BPY=VYP*C1
        BPZ=VZP*C1

      ENDIF !ISPECMODE

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION {

C REAL PART OF INTEGRAND {

      RX=XOBSV-X2
      RY=YOBSV-Y2
      RZ=ZOBSV-Z2

      R=SQRT(RX*RX+RY*RY+RZ*RZ)
      R1=1.D0/R
      ZICR1=ZIC*R1

      RNX=RX*R1
      RNY=RY*R1
      RNZ=RZ*R1

C--- THE DISTANCE R IS INTRODUCED HERE EXPLICITLY (S. PROGRAM OF CHAOEN WANG

      BET1N=(1.D0-BX*RNX)-BY*RNY-BZ*RNZ

c 20090928{
      br2=by**2+bz**2
      rnr2=rny**2+rnz**2
      b3=beta**3
      br4=br2**2
      rnr4=rnr2**2

      if(br2.lt.1.0d-4.and.rnr2.lt.1.0d-4) then
        bet1n=
     &    1.0d0/(1.0d0+beta)/gamma**2
     &    +beta*(rnr2/2.0d0
     &    +rnr4/8.0d0)
     &    +(br2/2.0d0
     &    -br2*rnr2/4.0d0
     &    -br2*rnr4/16.0d0)/beta
     &    +b3*br4*(1.0d0/8.0d0
     &    -rnr2/16.0d0
     &    -rnr4/64.0d0)
     &    -by*rny
     &    -bz*rnz
      endif
c }20090928

      OPANG=BX/BETA*RNX+BY/BETA*RNY+BZ/BETA*RNZ

      IF (ABS(OPANG).LE.1.0D0) THEN
        OPANG=ACOS(OPANG)
      ELSE IF (OPANG.GT.1.0D0) THEN
        OPANG=0.0D0
      ELSE
        OPANG=-PI1
      ENDIF

      DUM11=1.D0/BET1N
      DOM1=1.D0/(R*BET1N*BET1N)

      IF (IZAEHL.EQ.1) THEN
        BET1NO=BET1N
      ELSE IF (iundulator.eq.0
     &    .and.(BET1N-BET1NO)/BET1N.GT.0.05.AND.IWARNBET1N.EQ.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN SOUINTANA  ***'
        WRITE(LUNGFO,*)'DISCONTINUITY IN INTEGRAND'
        WRITE(LUNGFO,*)
     &    'Check results carefully, change BMOVECUT, MYINUM, NLPOI etc.'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'ISTEP,X,BET1N,BET1NO:',IZAEHL,SNGL(X1),SNGL(BET1N),SNGL(BET1NO)
        WRITE(LUNGFO,*)'FURTHER WARNINGS ARE SUPPRESSED!'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN SOUINTANA  ***'
        WRITE(6,*)'DISCONTINUITY IN INTEGRAND'
        WRITE(6,*)
     &    'Check results carefully, change BMOVECUT, MYINUM, NLPOI etc.'
        WRITE(6,*)
        WRITE(6,*)'ISTEP,X,BET1N,BET1NO:',IZAEHL,SNGL(X1),SNGL(BET1N),SNGL(BET1NO)
        WRITE(6,*)
        WRITE(6,*)'FURTHER WARNINGS ARE SUPPRESSED!'
        WRITE(6,*)
        IWARNBET1N=1
      ENDIF

      BET1NO=BET1N

      RNBX=RNX-BX
      RNBY=RNY-BY
      RNBZ=RNZ-BZ

      PX=(RNBY*BPZ-RNBZ*BPY)
      PY=(RNBZ*BPX-RNBX*BPZ)
      PZ=(RNBX*BPY-RNBY*BPX)

      IF (IVELOFIELD.EQ.0) THEN !2 WEGEN POWER
        DOM2=C*DOM1*R1/GAMMA**2
        RARG(1)=(RNY*PZ-RNZ*PY)*DOM1+(RNX-BX)*DOM2
        RARG(2)=(RNZ*PX-RNX*PZ)*DOM1+(RNY-BY)*DOM2
        RARG(3)=(RNX*PY-RNY*PX)*DOM1+(RNZ-BZ)*DOM2
      ELSE IF (IVELOFIELD.EQ.1) THEN
        RARG(1)=(RNY*PZ-RNZ*PY)*DOM1
        RARG(2)=(RNZ*PX-RNX*PZ)*DOM1
        RARG(3)=(RNX*PY-RNY*PX)*DOM1
      ELSE IF (IVELOFIELD.LT.0) THEN
        DOM2=C*DOM1*R1/GAMMA**2
        RARG(1)=(RNX-BX)*DOM2
        RARG(2)=(RNY-BY)*DOM2
        RARG(3)=(RNZ-BZ)*DOM2
      ELSE  !IVELOFIELD
        WRITE(6,*)
     &    '*** ERROR IN SOUINTANA: BAD VALUE OF IVELOFIELD  ***'
        WRITE(6,*) '*** PROGRAM WAVE ABORTED  ***'
        STOP
      ENDIF !IVELOFIELD

      IF (IINSIDE.EQ.0.AND.OPANG.LE.WGANG) THEN
        if (ibun.eq.1.and.isub.eq.neinbunch) then
          DPHSOUR(1,1)=BET1N*DT*FREQ(1)/HBAREV1
          DPHSOUR(1,2)=BET1N*DT*FREQ(NFREQ)/HBAREV1
        endif
        IINSIDE=1
        INSIDE=1
        JINSIDE=JINSIDE+1
        IF (JINSIDE.GT.1.and.ielec.eq.1) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN SOUINTANA  ***'
          WRITE(LUNGFO,*)'*** SOURCE:',ISOUR
          WRITE(LUNGFO,*)'STRANGE SOURCE, CONTAINS SEVERAL SOURCES'
          WRITE(LUNGFO,*)'SOURCE AND OBSERVATION POINT:'
          WRITE(LUNGFO,*)ISOUR,XOBSV,YOBSV,ZOBSV
          WRITE(LUNGFO,*)
     &      'RESULTS OF SPECTRUM CALCULATIONS MAY BE UNRELIABLE'
          WRITE(LUNGFO,*)'*** CHECK COLLIMATOR, PINHOLE, WGWINFC ... ***'
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN SOUINTANA  ***'
          WRITE(6,*)'*** SOURCE:',ISOUR
          WRITE(6,*)'*** STRANGE SOURCE, CONTAINS SEVERAL SOURCES'
          WRITE(6,*)'SOURCE AND OBSERVATION POINT:'
          WRITE(6,*)ISOUR,XOBSV,YOBSV,ZOBSV
          WRITE(6,*)'*** CHECK COLLIMATOR, PINHOLE, WGWINFC ... ***'
          WRITE(6,*)'WARNING OF SPECTRUM CALCULATIONS ARE UNRELIABLE'
          JINSIDE=JINSIDE-1   !SUPRESS LOTS OF WARNINGS
        ENDIF  !JINSIDE
      ELSE IF (IINSIDE.EQ.1.AND.OPANG.GT.WGANG) THEN
        IINSIDE=0
      ENDIF   !IINSIDE

      IF (IINSIDE.NE.0) THEN

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS      RARG(4)=T+R*C1

        DPHASE=BET1N*DT

        RARG(4)=PHASE
        RARG(5)=(RARG(1)*RARG(1)+RARG(2)*RARG(2)+RARG(3)*RARG(3))*DUM11/
     &    (nphsp*neinbunch)

        if (norad.ne.0) rarg=0.0d0

C REAL PART OF INTEGRAND }

C COMPLEX PART OF INTEGRAND {

C    ASSUMES FREQ(I+1)=2*FREQ(I)   FOR ifreq2p=2
C    OR FREQ(I+1)=FREQ(I)+DELTA    FOR ifreq2p>2

C--- LOOP OVER ALL FREQUENCES

        kfreq=1

        if (nelec.gt.1) then
          dexpbunch=phexp(kfreq)
        else
          dexpbunch=(1.0d0,0.0d0)
        endif

        IFROB=kfreq+NFREQ*(IOBSV-1)

        OM=FREQ(kfreq)/HBAREV1
        ZIOM=ZI*OM

        if (izaehl.eq.1) then
          EXPOM1=CDEXP(DCMPLX(0.D0,phase*OM))
        endif

        EXPOM=EXPOM1
        DEXPOMPH1=EXP(ZIOM*DPHASE)
        DEXPOMPH=DEXPOMPH1

        IF(ifreq2p.GT.2) THEN
          DEXPOM=EXP(ZIDOM*PHASE)
          DDEXPOMPH=EXP(ZIDOM*DPHASE)
        ELSE IF(ifreq2p.EQ.0) THEN
          EXPOM2P0(2,kfreq)=EXP(ZIOM*DPHASE)
          EXPOM=EXPOM2P0(1,kfreq)
        ENDIF  !ifreq2p

        IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN

          pow=rarg(5)*dt
          powpow=powpow+pow
          SPECPOW(ILIOB)=SPECPOW(ILIOB)+pow

          DO ICOMP=1,3
            daff(icomp)=
     &        RARG(ICOMP)/BET1N/OM*EXPOM*(ZONE-DEXPOMPH)*DEXPbunch/sqnphsp
            affe(icomp,ifrob)=affe(icomp,ifrob)+daff(icomp)
          ENDDO   !ICOMP

c          baff(1)=conjg(rny*daff(3)-rnz*daff(2))
c          baff(2)=conjg(rnz*daff(1)-rnx*daff(3))
c          baff(3)=conjg(rnx*daff(2)-rny*daff(1))

          baff(1)=(rny*daff(3)-rnz*daff(2))
          baff(2)=(rnz*daff(1)-rnx*daff(3))
          baff(3)=(rnx*daff(2)-rny*daff(1))

          affe(4:6,ifrob)=affe(4:6,ifrob)+baff(1:3)/clight1

        ENDIF  !XIANF

        IF (ibun.eq.1.and.isub.eq.neinbunch) THEN
          IF (IWFILINT.NE.0) THEN
            IF (MOD(IZAEHL,JWFILINT).EQ.0) THEN
              IF (IWFILINT.LT.0) THEN
                FILLT(1)=T
                FILLT(2)=X2
                FILLT(3)=Y2
                FILLT(4)=Z2
                FILLT(5)=RARG(1)
                FILLT(6)=RARG(2)
                FILLT(7)=RARG(3)
                FILLT(8)=RARG(4)
                FILLT(9)=RARG(5)
                FILLT(10)=DREAL(EXPOM*DEXPBUNCH)
                FILLT(11)=DIMAG(EXPOM*DEXPBUNCH)
                FILLT(12)=IROI-1
                FILLT(13)=IOBSV
                FILLT(14)=kfreq
                FILLT(15)=YOBSV
                FILLT(16)=ZOBSV
                FILLT(17)=BET1N
                FILLT(18)=OM
                FILLT(19)=DT
                FILLT(20)=BY2
                FILLT(21)=ISOUR
                FILLT(22)=
     &            (
     &            DREAL(affe(1,ifrob))*DREAL(affe(1,ifrob))
     &            +DIMAG(affe(1,ifrob))*DIMAG(affe(1,ifrob))
     &            +DREAL(affe(2,ifrob))*DREAL(affe(2,ifrob))
     &            +DIMAG(affe(2,ifrob))*DIMAG(affe(2,ifrob))
     &            +DREAL(affe(3,ifrob))*DREAL(affe(3,ifrob))
     &            +DIMAG(affe(3,ifrob))*DIMAG(affe(3,ifrob))
     &            )*specnor*bunnor
                FILLT(23)=DREAL(affe(4,ifrob))*specnor*bunnor
                FILLT(24)=DIMAG(affe(4,ifrob))*specnor*bunnor
                FILLT(25)=DREAL(affe(5,ifrob))*specnor*bunnor
                FILLT(26)=DIMAG(affe(5,ifrob))*specnor*bunnor
                FILLT(27)=DREAL(affe(6,ifrob))*specnor*bunnor
                FILLT(28)=DIMAG(affe(6,ifrob))*specnor*bunnor
                FILLT(29)=DOM1
                FILLT(30)=bx
                FILLT(31)=by
                FILLT(32)=bz
                FILLT(33)=bpx
                FILLT(34)=bpy
                FILLT(35)=bpz
                FILLT(36)=rnx
                FILLT(37)=rny
                FILLT(38)=rnz

                CALL hfm(NIDSOURCE,FILLT)

              ELSE IF (ISOUR.EQ.IWFILINT.AND.IOBSV.EQ.1) THEN

                WRITE(LUNINT,*) IZAEHL,kfreq,X2
                WRITE(LUNINT,*) (RARG(1),IC=1,3)
                WRITE(LUNINT,*) RARG(4)*OM,RARG(5)
                WRITE(LUNINT,*)REAL(EXPOM),IMAG(EXPOM)
                WRITE(LUNINT,*)RARG(1)*REAL(EXPOM*DEXPBUNCH),RARG(1)*IMAG(EXPOM*DEXPBUNCH)
                WRITE(LUNINT,*)RARG(2)*REAL(EXPOM*DEXPBUNCH),RARG(2)*IMAG(EXPOM*DEXPBUNCH)
                WRITE(LUNINT,*)RARG(3)*REAL(EXPOM*DEXPBUNCH),RARG(3)*IMAG(EXPOM*DEXPBUNCH)

              ENDIF !IWFILINT.LT.0
            ENDIF !JFILINT
          ENDIF !IWFILINT.NE.0
        ENDIF !ibun

        DO kfreq=2,NFREQ

          IFROB=kfreq+NFREQ*(IOBSV-1)

          IF    (ifreq2p.GT.2) THEN
            OM=OM+DOM
            EXPOM=EXPOM*DEXPOM
            DEXPOMPH=DEXPOMPH*DDEXPOMPH
          ELSE IF(ifreq2p.EQ.2) THEN
            OM=OM*2.0D0
            EXPOM=EXPOM*EXPOM
            DEXPOMPH=DEXPOMPH*DEXPOMPH
          ELSE IF(ifreq2p.EQ.0) THEN
            OM=FREQ(kfreq)/HBAREV1
            ZIOM=ZI*OM
            EXPOM2P0(2,kfreq)=EXP(ZIOM*DPHASE)
            EXPOM=EXPOM2P0(1,kfreq)
            DEXPOMPH=EXPOM2P0(2,kfreq)
          ELSE
            OM=FREQ(kfreq)/HBAREV1
            ZIOM=ZI*OM
            DEXPOMPH=EXP(ZIOM*DPHASE)
          ENDIF

          if (nelec.gt.1) then
            dexpbunch=phexp(kfreq)
          endif

          IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN

            EXPOMV2=1.0D0/BET1N/OM*EXPOM*(ZONE-DEXPOMPH)

            DO ICOMP=1,3
              daff(icomp)=RARG(ICOMP)*EXPOMV2*DEXPbunch/sqnphsp
              affe(icomp,ifrob)=affe(icomp,ifrob)+daff(icomp)
            ENDDO

c            baff(1)=conjg(rny*daff(3)-rnz*daff(2))
c            baff(2)=conjg(rnz*daff(1)-rnx*daff(3))
c            baff(3)=conjg(rnx*daff(2)-rny*daff(1))

            baff(1)=(rny*daff(3)-rnz*daff(2))
            baff(2)=(rnz*daff(1)-rnx*daff(3))
            baff(3)=(rnx*daff(2)-rny*daff(1))

            affe(4:6,ifrob)=affe(4:6,ifrob)+baff(1:3)/clight1

          ENDIF !XIEND

          IF (ibun.eq.1.and.isub.eq.neinbunch) then
            IF (IWFILINT.NE.0) THEN
              IF (MOD(IZAEHL,JWFILINT).EQ.0) THEN
                IF (IWFILINT.LT.0) THEN
                  FILLT(1)=T
                  FILLT(2)=X2
                  FILLT(3)=Y2
                  FILLT(4)=Z2
                  FILLT(5)=RARG(1)
                  FILLT(6)=RARG(2)
                  FILLT(7)=RARG(3)
                  FILLT(8)=RARG(4)
                  FILLT(9)=RARG(5)
                  FILLT(10)=DREAL(EXPOM*DEXPBUNCH)
                  FILLT(11)=DIMAG(EXPOM*DEXPBUNCH)
                  FILLT(12)=IROI-1
                  FILLT(13)=IOBSV
                  FILLT(14)=kfreq
                  FILLT(15)=YOBSV
                  FILLT(16)=ZOBSV
                  FILLT(17)=BET1N
                  FILLT(18)=OM
                  FILLT(19)=DT
                  FILLT(20)=BY2
                  FILLT(21)=ISOUR
                  FILLT(22)=
     &              (
     &              DREAL(affe(1,ifrob))*DREAL(affe(1,ifrob))
     &              +DIMAG(affe(1,ifrob))*DIMAG(affe(1,ifrob))
     &              +DREAL(affe(2,ifrob))*DREAL(affe(2,ifrob))
     &              +DIMAG(affe(2,ifrob))*DIMAG(affe(2,ifrob))
     &              +DREAL(affe(3,ifrob))*DREAL(affe(3,ifrob))
     &              +DIMAG(affe(3,ifrob))*DIMAG(affe(3,ifrob))
     &              )*specnor*bunnor
                  FILLT(23)=DREAL(affe(1,ifrob))*specnor*bunnor
                  FILLT(24)=DIMAG(affe(1,ifrob))*specnor*bunnor
                  FILLT(25)=DREAL(affe(2,ifrob))*specnor*bunnor
                  FILLT(26)=DIMAG(affe(2,ifrob))*specnor*bunnor
                  FILLT(27)=DREAL(affe(3,ifrob))*specnor*bunnor
                  FILLT(28)=DIMAG(affe(3,ifrob))*specnor*bunnor
                  FILLT(29)=DOM1
                  FILLT(30)=bx
                  FILLT(31)=by
                  FILLT(32)=bz
                  FILLT(33)=bpx
                  FILLT(34)=bpy
                  FILLT(35)=bpz
                  FILLT(36)=rnx
                  FILLT(37)=rny
                  FILLT(38)=rnz

                  CALL hfm(NIDSOURCE,FILLT)

                ELSE IF (ISOUR.EQ.IWFILINT.AND.IOBSV.EQ.1) THEN

                  WRITE(LUNINT,*) IZAEHL,kfreq,X2
                  WRITE(LUNINT,*) (RARG(1),IC=1,3)
                  WRITE(LUNINT,*) RARG(4)*OM,RARG(5)
                  WRITE(LUNINT,*)REAL(EXPOM*DEXPBUNCH),IMAG(EXPOM*DEXPBUNCH)
                  WRITE(LUNINT,*)RARG(1)*REAL(EXPOM*DEXPBUNCH),RARG(1)*IMAG(EXPOM*DEXPBUNCH)
                  WRITE(LUNINT,*)RARG(2)*REAL(EXPOM*DEXPBUNCH),RARG(2)*IMAG(EXPOM*DEXPBUNCH)
                  WRITE(LUNINT,*)RARG(3)*REAL(EXPOM*DEXPBUNCH),RARG(3)*IMAG(EXPOM*DEXPBUNCH)

                ENDIF !IWFILINT.LT.0
              ENDIF !JWFILINT
            ENDIF !IWFILINT.NE.0
          ENDIF !ibun

        ENDDO   !LOOP OVER ALL FREQUENCES

      ENDIF   !IINSIDE

C COMPLEX PART OF INTEGRAND }

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION }

      PHASE=PHASE+DPHASE
      EXPOM1=EXPOM1*DEXPOMPH1

      IF(ifreq2p.EQ.0) THEN

        DO JFREQ=1,NFREQ
          OM=FREQ(JFREQ)/HBAREV1
          ZIOM=ZI*OM
          EXPOM2P0(1,JFREQ)=EXPOM2P0(1,JFREQ)*EXPOM2P0(2,JFREQ)
        ENDDO
      ENDIF

      TS=TS+DT

C--- END OF LOOP OVER TIME STEPS

c      yp2zp2ia=yp2zp2ia
c     &  +((vy1/vx1)**2+(vy2/vx2)**2+(vz1/vx1)**2+(vz2/vx2)**2)*beta*clight1*dt2

      f(3)=((vy2/vx2)**2+(vz2/vx2)**2)
      fdt(3)=dt

      if (lstep.eq.1) then
        yp(1)=(f(2)-f(1))/fdt(2)
        yp(3)=(f(3)-f(2))/fdt(3)
        yp(2)=(yp(3)+yp(1))/2.0d0
        ypp=(yp(3)-yp(1))/(fdt(2)+fdt(3))*2.0d0
        a(3)=ypp/2.0d0
        a(2)=yp(2)-2.0d0*a(3)*fdt(2)
        a(1)=f(2)-a(2)*fdt(2)-a(3)*fdt(2)**2
        dfdt=fdt(2)+fdt(3)
        fihi=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        dfdt=0.0d0
        filo=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        yp2zp2i=yp2zp2i+fihi-filo
        yp2zp2i=yp2zp2i*beta*clight1
      else if (izaehl.ge.3) then
        yp(1)=(f(2)-f(1))/fdt(2)
        yp(3)=(f(3)-f(2))/fdt(3)
        yp(2)=(yp(3)+yp(1))/2.0d0
        ypp=(yp(3)-yp(1))/(fdt(2)+fdt(3))*2.0d0
        a(3)=ypp/2.0d0
        a(2)=yp(2)-2.0d0*a(3)*fdt(2)
        a(1)=f(2)-a(2)*fdt(2)-a(3)*fdt(2)**2
        dfdt=fdt(2)+fdt(3)
        fihi=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        dfdt=fdt(2)
        filo=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        yp2zp2i=yp2zp2i+fihi-filo
      endif

      f(1)=f(2)
      fdt(1)=fdt(2)
      f(2)=f(3)
      fdt(2)=fdt(3)

      if (ispecmode.eq.2) then
        if (izaehl.lt.ipoisou(isour)) goto 1000
      else
        IF (X2.LT.XENDSOU-VX2*DT.AND.X2.LT.(XIEND-VX2*DT).AND.LSTEP.EQ.0)
     &    GOTO 1000
        IF (LSTEP.EQ.0) THEN
          LSTEP=1
          GOTO 1000
        ENDIF
      endif

      IF (ISOUR.eq.1.and.ix10.eq.10.and.ielec.eq.nelec.and.iobsv.eq.nobsv
     &    ) THEN
        CALL date_and_time(dtday,dttime,dtzone,idatetime)
        WRITE(6,*)' ',IX10,' ',dttime(1:2),':',dttime(3:4),':',dttime(5:6)
      ENDIF

      if (ibun.eq.1.and.isub.eq.neinbunch) then

        IF (IINSIDE.NE.0) THEN
          DPHSOUR(2,1)=BET1N*DT*FREQ(1)/HBAREV1
          DPHSOUR(2,2)=BET1N*DT*FREQ(NFREQ)/HBAREV1
        ENDIF

C- STORE NUMBER OF POINTS FOR INTEGRATION

        IF (IOBSV.EQ.ICBRILL) IZTOT(ISOUR)=IZAEHL

      endif !ibun.eq.1

      IF (IAMPLI.LT.0) THEN

        DXEXI=MIN(soure(1,1),XIEND)
     &    -MAX(soura(1,1),XIANF)
        if (ampr2corr.eq.-9999.0d0) ampr2corr=dxexi
        CENXEXI=(MIN(soure(1,1),XIEND)
     &    +MAX(soura(1,1),XIANF))/2.D0
c        GAMGAM0=(SOURCEG(1,1,ISOUR))**2
c        GAMGAM=((SOURCEG(1,1,ISOUR)+SOURCEG(2,2,ISOUR)))**2
        GAMGAM0=(SOURCEG(1,1,ISOUR)*(egamma/dmygamma))**2
        GAMGAM=(
     &    (SOURCEG(1,1,ISOUR)+SOURCEG(2,2,ISOUR))*(egamma/dmygamma)
     &    )**2

c        DTPHASE=(WTRA2IS(ISOUR)+(1.0D0/GAMGAM0)*DXEXI/2.D0)/CLIGHT1
c     &    *GAMGAM0/GAMGAM

        slopein=sqrt(vyin**2+vzin**2)/vxin
        slope=sqrt(vyelec**2+vzelec**2)/vxelec

        if (myinum.gt.nlpoi/dxexi) then
          WI=(WTRA2IS(ISOUR)
     &      -DXEXI/2.0D0*slopein**2) !wi is detour for on-axis particle
     &      *(dmygamma/egamma)**2
        else
          if (iwarnwi.eq.0) then
            write(lungfo,*)
            write(lungfo,*)'*** Warning in SOUINTANA:'
            write(lungfo,*)'*** MYINUM is rather small with respect to NLPOI'
            write(lungfo,*)'*** Length of trajectories are now calculated by simple'
            write(lungfo,*)'*** integration with SOUINTANA, which might be poor'
            write(lungfo,*)
            write(lungfo,*)
            write(6,*)'*** Warning in SOUINTANA:'
            write(6,*)'*** MYINUM is rather small with respect to NLPOI'
            write(6,*)'*** Length of trajectories are now calculated by simple'
            write(6,*)'*** integration with SOUINTANA, which might be poor'
            write(6,*)
            iwarnwi=1
          endif
          wi=(yp2zp2i/2.0d0
     &      -DXEXI/2.0D0*slopein**2) !wi is detour for on-axis particle
     &      *(dmygamma/egamma)**2
        endif

        xn1=cenxexi
        yn1=(xn1-cenxexi)*vyelec/vxelec
        zn1=(xn1-cenxexi)*vzelec/vxelec

        drn2=(
     &    (yn1+dxexi*vyelec/vxelec)**2+
     &    (zn1+dxexi*vzelec/vxelec)**2
     &    )/
     &    (2.0d0*(xobsv-xn1-dxexi))

        drn1=(
     &    yn1**2+
     &    zn1**2
     &    )/
     &    (2.0d0*(xobsv-xn1))

        DTPHASE=(
     &    WI+DXEXI*(slope**2/2.0d0+1.0d0/(2.0D0*GAMGAM0))
     &    +drn2-drn1)
     &    /CLIGHT1*GAMGAM0/GAMGAM

        AMPDT=AMPSHIFT(1)/CLIGHT1/2.0D0/GAMGAM0
        FREQR=2.D0*PI1/DTPHASE*HBAREV1
        POW=SPECPOW(ILIOB)

        if (jpin.ne.3.or.jpin.eq.3.and.ielec.eq.1) SPECPOW(ILIOB)=0.0D0

        DO I=1,-IAMPLI
          R02=(XOBSV-CENXEXI)**2+YOBSV**2+ZOBSV**2
          R2=(XOBSV-CENXEXI-DXEXI*(I-ABS(IAMPLI)/2+1))**2
     &      +YOBSV**2+ZOBSV**2
          SPECPOW(ILIOB)=SPECPOW(ILIOB)+POW*R02/R2
     &      *R2/(sqrt(R2)-ampr2corr/2.0d0)**2/nelec
        ENDDO

      ENDIF  !endif iampli.lt.0

      DO kfreq=1,NFREQ

        ILIOBFR=ISOUR+NSOURCE*(IOBSV-1+NOBSV*(kfreq-1))
        IFROB=kfreq+NFREQ*(IOBSV-1)
        IOBFR=IOBSV+NOBSV*(kfreq-1)

        OM=FREQ(kfreq)/HBAREV1

        IF (IAMPLI.LT.0) THEN

          BX0=affe(4,ifrob)
          BY0=affe(5,ifrob)
          BZ0=affe(6,ifrob)

          BXc=BX0
          BYc=BY0
          BZc=BZ0

          AX0=affe(1,ifrob)
          AY0=affe(2,ifrob)
          AZ0=affe(3,ifrob)

          AX=AX0
          AY=AY0
          AZ=AZ0

          affe(1:6,ifrob)=(0.0D0,0.0D0)

          R0=OBSV(1,NOBSV/2+1)-CENXEXI
          R02=R0*R0
          R00=R0

c          H2=(YOBSV-vyelec)**2+(ZOBSV-vzelec)**2
c          H2R2=H2/R02
c
c          DTPHASE=(WTRA2IS(ISOUR)+(H2R2+1.0D0/GAMGAM0)*DXEXI/2.D0)/CLIGHT1
c     &      *GAMGAM0/GAMGAM
c     &      +AMPDT

          xn1=cenxexi
          yn1=(xn1-cenxexi)*vyelec/vxelec
          zn1=(xn1-cenxexi)*vzelec/vxelec

          drn2=(
     &      (yn1+dxexi*vyelec/vxelec-yobsv)**2+
     &      (zn1+dxexi*vzelec/vxelec-zobsv)**2
     &      )/
     &      (2.0d0*(xobsv-xn1-dxexi))

          drn1=(
     &      (yn1-yobsv)**2+
     &      (zn1-zobsv)**2
     &      )/
     &      (2.0d0*(xobsv-xn1))

          DTPHASE=(
     &      WI+DXEXI*(slope**2/2.0d0+1.0d0/(2.0D0*GAMGAM0))
     &      +drn2-drn1)
     &      /CLIGHT1*GAMGAM0/GAMGAM
     &      +AMPDT

          PHI=2.D0*PI1*FREQ(kfreq)*ECHARGE1/HPLANCK1*DTPHASE

          DMODU=EXP(ZI*PHI)
          DMODU0=DMODU
          DDMODU=ZONE

          if (ibunch.ne.0) then

            zzi=zeleco
            yyi=yeleco
            zzpi=zpeleco
            yypi=ypeleco

+self,if=notfmtot.
            zz=zzi
            zzp=zzpi
            yy=yyi
            yyp=yypi
+self,if=-notfmtot,if=wbetdeltae.
c  transform to beginning of first section
            dum22=tfmhtoti+(tfmdehtoti-tfmhtoti)*(egamma-dmygamma)
     &        /(deltae*dmygamma)
            zz=dum22(1,1)*zzi+dum22(1,2)*zzpi
            zzp=dum22(2,1)*zzi+dum22(2,2)*zzpi
            dum22=tfmvtoti+(tfmdevtoti-tfmvtoti)*(egamma-dmygamma)
     &        /(deltae*dmygamma)
            yy=dum22(1,1)*yyi+dum22(1,2)*yypi
            yyp=dum22(2,1)*yyi+dum22(2,2)*yypi
+self,if=-notfmtot,if=-wbetdeltae.
c  transform to beginning of first section
            zz=tfmhtoti(1,1)*zzi+tfmhtoti(1,2)*zzpi
            zzp=tfmhtoti(2,1)*zzi+tfmhtoti(2,2)*zzpi
            yy=tfmvtoti(1,1)*yyi+tfmvtoti(1,2)*yypi
            yyp=tfmvtoti(2,1)*yyi+tfmvtoti(2,2)*yypi
+self.

          endif !ibunch

          DO I=1,-IAMPLI

            if (ibunch.ne.0) then

+self,if=-notfmc,if=wbetdeltae.
c  transform to center of section, no closed orbit!
              dum22=tfmhci+(tfmdehci-tfmhci)*(egamma-dmygamma)
     &          /(deltae*dmygamma)
                zelec=dum22(1,1)*zz+dum22(1,2)*zzp
                zpelec=dum22(2,1)*zz+dum22(2,2)*zzp
              dum22=tfmhvi+(tfmdehvi-tfmhvi)*(egamma-dmygamma)
     &          /(deltae*dmygamma)
                yelec=dum22(1,1)*yy+dum22(1,2)*yyp
                ypelec=dum22(2,1)*yy+dum22(2,2)*yyp
+self,if=-notfmc,if=-wbetdeltae.
c  transform to center of section, no closed orbit!
                zelec=tfmhc(1,1)*zz+tfmhc(1,2)*zzp
                zpelec=tfmhc(2,1)*zz+tfmhc(2,2)*zzp
                yelec=tfmvc(1,1)*yy+tfmvc(1,2)*yyp
                ypelec=tfmvc(2,1)*yy+tfmvc(2,2)*yyp
+self,if=notfmc.
                zelec=zz
                zpelec=zzp
                yelec=yy
                ypelec=yyp
+self.

+self,if=-notfmtot,if=wbetdelate.
c  transform to beginning of next section

              zzi=zz
              yyi=yy
              zzpi=zzp
              yypi=yyp

              dum22=tfmh+(tfmdeh-tfmh)*(egamma-dmygamma)
     &          /(deltae*dmygamma)
              zz=dum22(1,1)*zzi+dum22(1,2)*zzpi
              zzp=dum22(2,1)*zzi+dum22(2,2)*zzpi
              dum22=tfmv+(tfmdev-tfmv)*(egamma-dmygamma)
     &          /(deltae*dmygamma)
              yy=dum22(1,1)*yyi+dum22(1,2)*yypi
              yyp=dum22(2,1)*yyi+dum22(2,2)*yypi

+self,if=-notfmtot,if=-wbetdelate.
c  transform to beginning of next section

              zzi=zz
              yyi=yy
              zzpi=zzp
              yypi=yyp

              zz=tfmh(1,1)*zzi+tfmh(1,2)*zzpi
              zzp=tfmh(2,1)*zzi+tfmh(2,2)*zzpi
              yy=tfmv(1,1)*yyi+tfmv(1,2)*yypi
              yyp=tfmv(2,1)*yyi+tfmv(2,2)*yypi

+self.
            endif !ibunch

            R0=OBSV(1,NOBSV/2+1)+DXEXI/2.D0*(-IAMPLI-2*(I-1)-1)-CENXEXI
            CORRR0=R00/R0
            !corrects for mistake of averaging over 1/r2, if e.g.
            !the repeated device is a long undulator
     &        *(R0/(R0-ampr2corr/2.0d0))**2

            R02=R0*R0
c            H2=(YOBSV)**2+(ZOBSV)**2
c            H2R2=H2/R02

c            DTPHASE=(WTRA2IS(ISOUR)+(H2R2+1.0D0/GAMGAM0)*DXEXI/2.D0)/CLIGHT1
c     &        *GAMGAM0/GAMGAM
c     &        +AMPDT

c            slope=sqrt(vyelec**2+vzelec**2)/vxelec

+self,if=noslopescal.
            slope=sqrt(ypelec**2+zpelec**2)
+self,if=-noslopescal.
            slope=sqrt(ypelec**2+zpelec**2)*gamgam0/gamgam
+self.

+self,if=-notralinshort.
            slope=sqrt(ypelec**2+zpelec**2)
+self.

            xn1=cenxexi-dxexi/2.d0*(-iampli-2*(i-1)-1)
     &          /(R0/(R0-ampr2corr/2.0d0))**2 !empirically
            yn1=(xn1-cenxexi)*ypelec
            zn1=(xn1-cenxexi)*zpelec

            yn1=yelec
            zn1=zelec

            drn2=(
     &        (yn1+dxexi*ypelec-yobsv)**2+
     &        (zn1+dxexi*zpelec-zobsv)**2
     &        )/
     &        (2.0d0*(xobsv-xn1-dxexi))

            drn1=(
     &        (yn1-yobsv)**2+
     &        (zn1-zobsv)**2
     &        )/
     &        (2.0d0*(xobsv-xn1))

            DTPHASE=(
     &        WI+DXEXI*(slope**2/2.0d0+1.0d0/(2.0D0*GAMGAM0))
     &        +drn2-drn1)
     &        /CLIGHT1*GAMGAM0/GAMGAM
     &        +AMPDT

            PHI=2.D0*PI1*FREQ(kfreq)*ECHARGE1/HPLANCK1*DTPHASE

            DMODU=EXP(ZI*PHI)
            DMODU0=DMODU
            DDMODU=ZONE

+self,if=blind.
            xn1=cenxexi-dxexi/2.d0*(-iampli-2*(i-1)-1)
            rest=mod(abs(xn1)+5.0196d0/2.0d0,6.1337625d0)
            if (abs(rest).le.5.0196d0) then
+self.
              affe(1,ifrob)=affe(1,ifrob)+AX
              affe(2,ifrob)=affe(2,ifrob)+AY
              affe(3,ifrob)=affe(3,ifrob)+AZ
              affe(4,ifrob)=affe(4,ifrob)+BXc
              affe(5,ifrob)=affe(5,ifrob)+BYc
              affe(6,ifrob)=affe(6,ifrob)+BZc
+self,if=blind.
c            if (kfreq.eq.1) write(77,*)i,isec,xn1,rest
            endif
+self.

            IF (AMPRAN.NE.0.0D0) THEN
              PHI=2.D0*PI1*XRANA(I)/FREQR*FREQ(kfreq)
              DDMODU=EXP(ZI*PHI)
            ENDIF   !(AMPRAN.NE.0.0D0)


            DMODU=DMODU0*DDMODU

            BX0=BX0*DMODU0
            BY0=BY0*DMODU0
            BZ0=BZ0*DMODU0

            BXc=BX0*CORRR0
            BYc=BY0*CORRR0
            BZc=BZ0*CORRR0

            BXc=BXc*DMODU
            BYc=BYc*DMODU
            BZc=BZc*DMODU

            AX0=AX0*DMODU0
            AY0=AY0*DMODU0
            AZ0=AZ0*DMODU0

            AX=AX0*CORRR0
            AY=AY0*CORRR0
            AZ=AZ0*CORRR0

            !DMODU=DMODU0*DDMODU

            AX=AX*DMODU
            AY=AY*DMODU
            AZ=AZ*DMODU

          ENDDO !IAMPLI

          zelec=zeleco
          yelec=yeleco

        ENDIF  !(IAMPLI.LT.0)

        if (jpin.eq.3) then

          FSPEC(1)=ISOUR
          FSPEC(2)=IOBSV
          FSPEC(3)=xobsv
          FSPEC(4)=yobsv
          FSPEC(5)=zobsv
          FSPEC(6)=FREQ(kfreq)
          FSPEC(7)=
     &      (
     &      DREAL(affe(1,ifrob))*DREAL(affe(1,ifrob))
     &      +DIMAG(affe(1,ifrob))*DIMAG(affe(1,ifrob))
     &      +DREAL(affe(2,ifrob))*DREAL(affe(2,ifrob))
     &      +DIMAG(affe(2,ifrob))*DIMAG(affe(2,ifrob))
     &      +DREAL(affe(3,ifrob))*DREAL(affe(3,ifrob))
     &      +DIMAG(affe(3,ifrob))*DIMAG(affe(3,ifrob))
     &      )*specnor*bunnor
          FSPEC(8)=1
          FSPEC(9)=1
          FSPEC(10)=kfreq
          FSPEC(11)=dreal(affe(1,ifrob))*sqrt(specnor*bunnor)
          FSPEC(12)=dimag(affe(1,ifrob))*sqrt(specnor*bunnor)
          FSPEC(13)=dreal(affe(2,ifrob))*sqrt(specnor*bunnor)
          FSPEC(14)=dimag(affe(2,ifrob))*sqrt(specnor*bunnor)
          FSPEC(15)=dreal(affe(3,ifrob))*sqrt(specnor*bunnor)
          FSPEC(16)=dimag(affe(3,ifrob))*sqrt(specnor*bunnor)
          FSPEC(17)=0.0d0
          FSPEC(18)=0.0d0
          FSPEC(19)=0.0d0
          FSPEC(20)=0.0d0
          FSPEC(21)=dreal(affe(4,ifrob))*sqrt(specnor*bunnor)
          FSPEC(22)=dimag(affe(4,ifrob))*sqrt(specnor*bunnor)
          FSPEC(23)=dreal(affe(5,ifrob))*sqrt(specnor*bunnor)
          FSPEC(24)=dimag(affe(5,ifrob))*sqrt(specnor*bunnor)
          FSPEC(25)=dreal(affe(6,ifrob))*sqrt(specnor*bunnor)
          FSPEC(26)=dimag(affe(6,ifrob))*sqrt(specnor*bunnor)
          FSPEC(27)=0.0d0
          FSPEC(28)=0.0d0
          FSPEC(29)=0.0d0
          FSPEC(30)=0.0d0

          if (ispecdip.le.0) then
            cenxexi=(min(soure(1,1),xiend)
     &        +max(soura(1,1),xianf))/2.d0
          else
            cenxexi=x0dip(isour)
          endif

          dist0=pincen(1)-cenxexi
          dist02=dist0**2

          h2=(yobsv**2+zobsv**2)/dist02
          if (h2.lt.0.01) then
            ddist=dist0*(h2/2.0d0-h2**2/8.0d0)
          else
            ddist=dist0*(sqrt(1.0d0+h2)-1.0d0)
          endif

          dphase=ddist/freq(kfreq)*wtoe1*1.0d9*twopi1

          FSPEC(31)=dphase

          call hfm(nidspec,fspec)

          FSPEC(1)=xobsv
          FSPEC(2)=yobsv
          FSPEC(3)=zobsv
          FSPEC(4)=powpow*pownor
          FSPEC(5)=0.0d0
          FSPEC(6)=1.0d0
          FSPEC(7)=1.0d0
          FSPEC(8)=iobsv
          FSPEC(9)=ISOUR

          call hfm(nidpow,fspec)

          if (istokes.ne.0) then

            APOLH=
     &        affe(1,IFROB)*CONJG(VSTOKES(1,1))
     &        +affe(2,IFROB)*CONJG(VSTOKES(1,2))
     &        +affe(3,IFROB)*CONJG(VSTOKES(1,3))

            APOLR=
     &        affe(1,IFROB)*CONJG(VSTOKES(2,1))
     &        +affe(2,IFROB)*CONJG(VSTOKES(2,2))
     &        +affe(3,IFROB)*CONJG(VSTOKES(2,3))

            APOLL=
     &        affe(1,IFROB)*CONJG(VSTOKES(3,1))
     &        +affe(2,IFROB)*CONJG(VSTOKES(3,2))
     &        +affe(3,IFROB)*CONJG(VSTOKES(3,3))

            APOL45=
     &        affe(1,IFROB)*CONJG(VSTOKES(4,1))
     &        +affe(2,IFROB)*CONJG(VSTOKES(4,2))
     &        +affe(3,IFROB)*CONJG(VSTOKES(4,3))

            STOK1=
     &        APOLR*CONJG(APOLR)+
     &        APOLL*CONJG(APOLL)

            STOK2=-STOK1+
     &        2.0d0*APOLH*CONJG(APOLH)

            STOK3=
     &        2.0d0*APOL45*CONJG(APOL45)-
     &        STOK1

            STOK4=
     &        APOLR*CONJG(APOLR)-
     &        APOLL*CONJG(APOLL)

            FSPEC(1)=IOBSV
            FSPEC(2)=xobsv
            FSPEC(3)=yobsv
            FSPEC(4)=zobsv
            FSPEC(5)=FREQ(kfreq)
            FSPEC(6)=STOK1*specnor*bunnor
            FSPEC(7)=STOK2*specnor*bunnor
            FSPEC(8)=STOK3*specnor*bunnor
            FSPEC(9)=STOK4*specnor*bunnor
            FSPEC(10)=1.0d0
            FSPEC(11)=1.0d0
            FSPEC(12)=kfreq

            CALL hfm(NIDSTOK,FSPEC)

          ENDIF   !ISTOKES

        endif !ipin.eq.3

        if (ihbunch.ne.0) then
          if (mod(ielec,ihbunch).eq.0.and.iobsv.eq.icbrill) then
            fillb(1)=ibun
            fillb(2)=isub
            fillb(3)=ielec
            fillb(4)=bunchx
            fillb(5)=xelec
            fillb(6)=yelec
            fillb(7)=zelec
            fillb(8)=vyelec/vxelec
            fillb(9)=vzelec/vxelec
            fillb(10)=x2
            fillb(11)=y2
            fillb(12)=z2
            fillb(13)=vy2/vx2
            fillb(14)=vz2/vx2
            fillb(15)=egamma*emassg1
            fillb(16)=gamma*emassg1
            fillb(17)=xobsv
            fillb(18)=yobsv
            fillb(19)=zobsv
            fillb(20)=kfreq
            fillb(21)=freq(kfreq)
            speck=
     &        DREAL(
     &        affe(1,IFROB)*CONJG(affe(1,IFROB))
     &        +affe(2,IFROB)*CONJG(affe(2,IFROB))
     &        +affe(3,IFROB)*CONJG(affe(3,IFROB))
     &        )*specnor*bunnor
            fillb(22)=speck*nelec

            if (istokes.ne.0) then

              APOLH=
     &          affe(1,IFROB)*CONJG(VSTOKES(1,1))
     &          +affe(2,IFROB)*CONJG(VSTOKES(1,2))
     &          +affe(3,IFROB)*CONJG(VSTOKES(1,3))

              APOLR=
     &          affe(1,IFROB)*CONJG(VSTOKES(2,1))
     &          +affe(2,IFROB)*CONJG(VSTOKES(2,2))
     &          +affe(3,IFROB)*CONJG(VSTOKES(2,3))

              APOLL=
     &          affe(1,IFROB)*CONJG(VSTOKES(3,1))
     &          +affe(2,IFROB)*CONJG(VSTOKES(3,2))
     &          +affe(3,IFROB)*CONJG(VSTOKES(3,3))

              APOL45=
     &          affe(1,IFROB)*CONJG(VSTOKES(4,1))
     &          +affe(2,IFROB)*CONJG(VSTOKES(4,2))
     &          +affe(3,IFROB)*CONJG(VSTOKES(4,3))

              STOK1=
     &          APOLR*CONJG(APOLR)+
     &          APOLL*CONJG(APOLL)

              STOK2=-STOK1+
     &          2.0d0*APOLH*CONJG(APOLH)

              STOK3=
     &          2.0d0*APOL45*CONJG(APOL45)-
     &          STOK1

              STOK4=
     &          APOLR*CONJG(APOLR)-
     &          APOLL*CONJG(APOLL)

              fillb(23)=stok1*specnor*bunnor*nelec
              fillb(24)=stok2*specnor*bunnor*nelec
              fillb(25)=stok3*specnor*bunnor*nelec
              fillb(26)=stok4*specnor*bunnor*nelec
            else
              fillb(23)=fillb(22)
              fillb(24:26)=0.0d0
            endif !istokes

            if (ielec.ne.1) then
              fillb(27)=powpow*pownor*nelec
            else
              fillb(27)=powpow*pownor*nelec
            endif
            fillb(28)=isour
            fillb(29)=t2

            call hfm(nidbunch,fillb)
          endif
        endif

        if (ibunphase.eq.1) then

          are(1:6)=dreal(affe(1:6,ifrob))
          aim(1:6)=dimag(affe(1:6,ifrob))

          if (iobunch.eq.-9999.and.ielec.eq.1) then
            ampz(kfreq)=sqrt(are(3)**2+aim(3)**2)
            if (ampz(kfreq).gt.ampzmax(kfreq)) then
              ampzmax(kfreq)=ampz(kfreq)
              kobs(kfreq)=iobsv
            endif
          else if (iobsv.eq.iobunch) then
            ampz(kfreq)=sqrt(are(3)**2+aim(3)**2)
            if (ampz(kfreq).ne.0.0d0) then
              azcos(kfreq)=are(3)/ampz(kfreq)
              azsin(kfreq)=aim(3)/ampz(kfreq)
            else
              azcos(kfreq)=1.0d0
              azsin(kfreq)=0.0d0
            endif
          endif

          if (iobsv.eq.nobsv.and.kfreq.eq.nfreq) then

            do jfreq=1,nfreq

              jfrob=jfreq+nfreq*(kobs(jfreq)-1)
              are(1:6)=dreal(affe(1:6,jfrob))
              aim(1:6)=dimag(affe(1:6,jfrob))

              ampz(jfreq)=sqrt(are(3)**2+aim(3)**2)

              if (ampz(jfreq).ne.0.0d0) then
                azcos(jfreq)=are(3)/ampz(jfreq)
                azsin(jfreq)=aim(3)/ampz(jfreq)
              else
                azcos(jfreq)=1.0d0
                azsin(jfreq)=0.0d0
              endif

            enddo !jfreq

            do job=1,nobsv
              do jfreq=1,nfreq

                jfrob=jfreq+nfreq*(job-1)

                are(1:6)=dreal(affe(1:6,jfrob))
                aim(1:6)=dimag(affe(1:6,jfrob))

                affe(1:6,jfrob)=dcmplx(
     &            azcos(jfreq)*are(1:6)+azsin(jfreq)*aim(1:6),
     &            -azsin(jfreq)*are(1:6)+azcos(jfreq)*aim(1:6)
     &            )

                AFREQ(1:6,jfrob)=AFREQ(1:6,jfrob)+affe(1:6,jfrob)

                affe(1:6,jfrob)=(0.0D0,0.0D0)

              enddo
            enddo

          endif !iobsv.eq.nobsv

        else !ibunphase

          if (iobsv.eq.nobsv.and.kfreq.eq.nfreq) then
            AFREQ=AFREQ+affe
            affe=(0.0D0,0.0D0)
          endif

        endif !ibunphase

      ENDDO !kfreq

      if (isub.eq.neinbunch.and.iobsv.eq.nobsv) then

        do job=1,nobsv
          do kfreq=1,nfreq

            ifrob=kfreq+nfreq*(job-1)
            iliobfr=isour+nsource*(job-1+nobsv*(kfreq-1))
            iobfr=job+nobsv*(kfreq-1)

            IF(SPECCUT.GT.0.0D0) THEN
              ECMAXS=ECMAX(ISOUR)
              IF(FREQ(kfreq).GT.SPECCUT*ecdipev1*DMYENERGY**2*ECMAXS) THEN
                AFREQ(1,IFROB)=(0.0D0,0.0D0)
                AFREQ(2,IFROB)=(0.0D0,0.0D0)
                AFREQ(3,IFROB)=(0.0D0,0.0D0)
              ENDIF
            ENDIF

            AFREQ(1:3,IFROB)=AFREQ(1:3,IFROB)*REFLEC(1:3)
            AFREQ(4:6,IFROB)=AFREQ(4:6,IFROB)*REFLEC(1:3)

            IF (IPOLA.EQ.0) THEN

              speck=
     &          DREAL(
     &          AFREQ(1,IFROB)*CONJG(AFREQ(1,IFROB))
     &          +AFREQ(2,IFROB)*CONJG(AFREQ(2,IFROB))
     &          +AFREQ(3,IFROB)*CONJG(AFREQ(3,IFROB))
     &          )*specnor*bunnor

              SPEC(ILIOBFR)=SPEC(ILIOBFR)+speck

              REAIMA(1:3,1,IOBFR)=REAIMA(1:3,1,IOBFR)+
     &          DREAL(AFREQ(1:3,IFROB))/sqnbunch
              REAIMA(1:3,2,IOBFR)=REAIMA(1:3,2,IOBFR)+
     &          DIMAG(AFREQ(1:3,IFROB))/sqnbunch
              REAIMA(6:8,1,IOBFR)=REAIMA(6:8,1,IOBFR)+
     &          DREAL(AFREQ(4:6,IFROB))/sqnbunch
              REAIMA(6:8,2,IOBFR)=REAIMA(6:8,2,IOBFR)+
     &          DIMAG(AFREQ(4:6,IFROB))/sqnbunch

            ELSE    !IPOLA

              APOL=
     &          AFREQ(1,IFROB)*CONJG(VPOLA(1))
     &          +AFREQ(2,IFROB)*CONJG(VPOLA(2))
     &          +AFREQ(3,IFROB)*CONJG(VPOLA(3))

              SPEC(ILIOBFR)=SPEC(ILIOBFR)+
     &          DREAL(APOL*CONJG(APOL))*specnor*bunnor


              REAIMA(1:3,1,IOBFR)=REAIMA(1:3,1,IOBFR)+
     &          DREAL(AFREQ(1:3,IFROB))/sqnbunch
              REAIMA(1:3,2,IOBFR)=REAIMA(1:3,2,IOBFR)+
     &          DIMAG(AFREQ(1:3,IFROB))/sqnbunch
              REAIMA(6:8,1,IOBFR)=REAIMA(6:8,1,IOBFR)+
     &          DREAL(AFREQ(1:3,IFROB))/sqnbunch
              REAIMA(6:8,2,IOBFR)=REAIMA(6:8,2,IOBFR)+
     &          DIMAG(AFREQ(1:3,IFROB))/sqnbunch

            ENDIF   !IPOLA

            IF (ISTOKES.NE.0) THEN

              APOLH=
     &          AFREQ(1,IFROB)*CONJG(VSTOKES(1,1))
     &          +AFREQ(2,IFROB)*CONJG(VSTOKES(1,2))
     &          +AFREQ(3,IFROB)*CONJG(VSTOKES(1,3))

              APOLR=
     &          AFREQ(1,IFROB)*CONJG(VSTOKES(2,1))
     &          +AFREQ(2,IFROB)*CONJG(VSTOKES(2,2))
     &          +AFREQ(3,IFROB)*CONJG(VSTOKES(2,3))

              APOLL=
     &          AFREQ(1,IFROB)*CONJG(VSTOKES(3,1))
     &          +AFREQ(2,IFROB)*CONJG(VSTOKES(3,2))
     &          +AFREQ(3,IFROB)*CONJG(VSTOKES(3,3))

              APOL45=
     &          AFREQ(1,IFROB)*CONJG(VSTOKES(4,1))
     &          +AFREQ(2,IFROB)*CONJG(VSTOKES(4,2))
     &          +AFREQ(3,IFROB)*CONJG(VSTOKES(4,3))

              STOK1=
     &          APOLR*CONJG(APOLR)+
     &          APOLL*CONJG(APOLL)

              STOK2=-STOK1+
     &          2.0d0*APOLH*CONJG(APOLH)

              STOK3=
     &          2.0d0*APOL45*CONJG(APOL45)-
     &          STOK1

              STOK4=
     &          APOLR*CONJG(APOLR)-
     &          APOLL*CONJG(APOLL)

              STOKES(1,IOBFR)=STOKES(1,IOBFR)+
     &          STOK1*specnor*bunnor

              STOKES(2,IOBFR)=STOKES(2,IOBFR)+
     &          STOK2*specnor*bunnor

              STOKES(3,IOBFR)=STOKES(3,IOBFR)+
     &          STOK3*specnor*bunnor

              STOKES(4,IOBFR)=STOKES(4,IOBFR)+
     &          STOK4*specnor*bunnor

            ENDIF !ISTOKES

            AFREQ(1:6,IFROB)=(0.0d0,0.0d0)

          enddo !kfreq
        enddo !job

      endif !isub.eq.neinbunch

      if (ibun.eq.nbunch.and.isub.eq.neinbunch) then
        ILIOB=ISOUR+NSOURCE*(IOBSV-1)
        SPECPOW(ILIOB)=SPECPOW(ILIOB)*POWNOR
      endif

      IF (
     &    jpin.ne.0.and.jpin.ne.3.and.IOBSV.EQ.jobunch
     &    .or.
     &    (jpin.eq.3.or.jpin.eq.0).and.ielec.eq.1
     &    ) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '       phase advance per step at beginning and end of source for'
        if (jpin.ne.3) then
          WRITE(LUNGFO,*)
     &      '       lowest and highest photon energy at selected observation point:'
        else
          WRITE(LUNGFO,*)
     &      '       lowest and highest photon energy for first electron:'
        endif
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'       beginning:',SNGL(DPHSOUR(1,1)),SNGL(DPHSOUR(1,2))
        WRITE(LUNGFO,*)'       end:      ',SNGL(DPHSOUR(2,1)),SNGL(DPHSOUR(2,2))
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'       ROIs (boundary, precision, points):'
        WRITE(LUNGFO,*)

        DO IROI=1,NROIA-1
          WRITE(LUNGFO,*)
     &      IROI,SNGL(ROIX(IROI)),SNGL(ROIP(IROI)),IPOIROI(IROI+1)
        ENDDO
        WRITE(LUNGFO,*)
     &    NROI,SNGL(ROIX(NROIA))

      ENDIF !IOBSV

      IF (
     &    jpin.ne.0.and.jpin.ne.3.and.IOBSV.EQ.NOBSV
     &    .or.
     &    (jpin.eq.0.or.jpin.eq.3).and.ielec.eq.1) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'       SOURCE, TOTAL NUMBER OF STEPS:',ISOUR,IZAEHL
        WRITE(LUNGFO,*)'       (controlled by NLPOI and namelist $ROIN)'
        WRITE(LUNGFO,*)
      ENDIF

      isourold=isour

      ICAL=1

c      print*,"souintana:",spec(25)


      RETURN
      END subroutine souintana
+DECK,SPECINT.
*CMZ :  4.01/04 27/11/2023  13.42.16  by  Michael Scheer
*CMZ :  3.05/10 13/08/2018  14.39.06  by  Michael Scheer
*CMZ :  3.05/09 10/02/2005  12.58.04  by  Michael Scheer
*CMZ :  2.52/01 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.48/04 12/03/2004  15.40.31  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.02  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.36/00 07/11/2001  14.17.58  by  Michael Scheer
*CMZ :  2.34/00 11/05/2001  17.23.02  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  14.22.45  by  Michael Scheer
*CMZ :  2.16/05 04/08/2000  11.46.38  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  2.13/03 11/01/2000  18.22.28  by  Michael Scheer
*CMZ :  2.13/02 08/12/99  18.50.05  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  13.48.27  by  Michael Scheer
*CMZ :  1.01/01 10/12/97  13.26.03  by  Michael Scheer
*CMZ :  1.00/00 30/06/97  11.25.46  by  Michael Scheer
*CMZ : 00.02/05 18/03/97  15.39.20  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  17.24.12  by  Michael Scheer
*CMZ : 00.00/07 03/06/94  10.14.21  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.54.24  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.00  by  Michael Scheer
*-- Author :
      SUBROUTINE SPECINT

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.

C     INTEGRATES POWER SPECTRA OVER ALL PHOTON ENERGIES

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,SPECT.
+SEQ,OBSERV.
+SEQ,FREQS.
+SEQ,SOURCE.
+SEQ,PHYCON.

      CHARACTER(50) CDUM
      INTEGER IY,IZ,ISOUR,IOBSV,IFREQ,IERR
      INTEGER ICAL,NMU,IMU,IWARNW,IWARNS
      DOUBLE PRECISION S2(NDFREQP),RESULT,SIMPLE
      DOUBLE PRECISION EMUDUM(1000),AMUDUM(1000),DENDUM

      DATA ICAL/0/

      IF (NFREQ0.LE.1) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING SR SPECINT ***'
        WRITE(LUNGFO,*)'INTEGRATION NOT POSSIBLE, ONLY ONE FREQUENCY'
        WRITE(LUNGFO,*)'CHANGE PARAMETER NFREQ2P IN NAMELIST CONTRL'
        WRITE(LUNGFO,*)
c        WRITE(6,*)
c        WRITE(6,*)'*** WARNING SR SPECINT ***'
c        WRITE(6,*)'INTEGRATION NOT POSSIBLE, ONLY ONE FREQUENCY'
c        WRITE(6,*)'CHANGE PARAMETER NFREQ2P IN NAMELIST CONTRL'
c        WRITE(6,*)
        ISPECINT=0
        RETURN
      ENDIF

C--- LOOP OVER ALL SOURCES

      WFLUXTI=0.0
      DO IOBSV=1,NOBSV
        SPECTOTI(IOBSV)=0.0
        ENEDOS(IOBSV)=0.0
      ENDDO !IOBSV

      IWARNS=0
      IWARNW=0
      DO ISOUR=1,NSOURCE

C--- LOOP OVER ALL OBSERVATION POINTS

        IF (IPIN.NE.0) THEN

          DO IY=1,NOBSVY
            DO IZ=1,NOBSVZ

              IOBSV=(IY-1)*NOBSVZ+IZ

C--- FILL INTEGRATION BUFFER

              DO IFREQ=NFREQ0M,NFREQ0P
                S2(IFREQ-NFREQ0M+1)=
     &            SPEC(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))
     &            /BANWID*ECHARGE1
              ENDDO !IFREQ

C--- DO INTEGRATION OF BUFFER

              CALL SPBUFINT(FREQ,S2,NFREQ0,RESULT,SIMPLE)

              IF (IWARNS.EQ.0.AND.RESULT.NE.0.0.AND.
     &              DABS((RESULT-SIMPLE)/RESULT).GT.1.D-1) THEN
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)
     &'*** WARNING SPECINT: PROBLEM WITH INTEGRATION OF SPECTUM (SPEC)'
                WRITE(LUNGFO,*)'CHECK RESULTS CAREFULLY'
                WRITE(6,*)
                WRITE(6,*)
     &'*** WARNING SPECINT: PROBLEM WITH INTEGRATION OF SPECTRUM (SPEC)'
                WRITE(6,*)'CHECK RESULTS CAREFULLY'
                IWARNS=1
              ENDIF

              ILIOB=ISOUR+NSOURCE*(IOBSV-1)
              SPECI(ILIOB)=RESULT
              SPECTOTI(IOBSV)=SPECTOTI(IOBSV)+SPECI(ILIOB)

            ENDDO !IZ
          ENDDO !IY


C--- INTEGRATION OF FLUX THROUGH PINHOLE

          DO IFREQ=NFREQ0M,NFREQ0P
            S2(IFREQ-NFREQ0M+1)=
     &        WFLUX(ISOUR+NSOURCE*(IFREQ-1))/BANWID*ECHARGE1
          ENDDO !IFREQ

          CALL SPBUFINT(FREQ,S2,NFREQ0,RESULT,SIMPLE)

          IF (IWARNW.EQ.0.AND.RESULT.NE.0.0.AND.
     &        DABS((RESULT-SIMPLE)/RESULT).GT.1.D-1) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &'*** WARNING SR SPECINT: PROBLEM WITH INTEGRATION OF SPECTRUM'
            WRITE(LUNGFO,*)
     &        '(FLUX THROUGH PINHOLE)'
            WRITE(LUNGFO,*)'CHECK RESULTS CAREFULLY'
            WRITE(6,*)
            WRITE(6,*)
     &'*** WARNING SR SPECINT: PROBLEM WITH INTEGRATION OF SPECTRUM'
            WRITE(6,*)
     &        '(FLUX THROUGH PINHOLE)'
            WRITE(6,*)'CHECK RESULTS CAREFULLY'
            IWARNW=1
          ENDIF

          WFLUXI(ISOUR)=RESULT
          WFLUXTI=WFLUXTI+WFLUXI(ISOUR)

        ELSE   !IPIN


          DO IOBSV=1,NOBSV

C--- FILL INTEGRATION BUFFER

            DO IFREQ=NFREQ0M,NFREQ0P
              S2(IFREQ-NFREQ0M+1)=
     &          SPEC(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))
     &          /BANWID*ECHARGE1
            ENDDO !IFREQ

C--- DO INTEGRATION OF BUFFER

            CALL SPBUFINT(FREQ,S2,NFREQ0,RESULT,SIMPLE)
            IF (IWARNS.EQ.0.AND.RESULT.NE.0.0.AND.
     &          DABS((RESULT-SIMPLE)/RESULT).GT.1.D-1) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &'*** WARNING SPECINT: PROBLEM WITH INTEGRATION OF SPECTRUM (SPEC)'
              WRITE(LUNGFO,*)'CHECK RESULTS CAREFULLY'
              WRITE(6,*)
              WRITE(6,*)
     &'*** WARNING SPECINT: PROBLEM WITH INTEGRATION OF SPECTRUM (SPEC)'
              WRITE(6,*)'CHECK RESULTS CAREFULLY'
              IWARNS=1
            ENDIF

            ILIOB=ISOUR+NSOURCE*(IOBSV-1)
            SPECI(ILIOB)=RESULT
            SPECTOTI(IOBSV)=SPECTOTI(IOBSV)+SPECI(ILIOB)

          ENDDO !IOBSV

        ENDIF    !IPIN

      ENDDO !ISOUR

C--- DOSE CALCULATIONS

      IF (IDOSE.NE.0) THEN

        IWARNW=0
        IWARNS=0

        IF (ICAL.EQ.0) THEN
          OPEN(UNIT=99,FILE='ABSORPDOSE.RP',STATUS='OLD')

          READ(99,'(A50)') CDUM
          READ(99,*) DENDUM
          READ(99,*) NMU
          IF (NMU.GT.1000) STOP '*** SR SPECINT: NMU EXCEEDED 1000 ***'
          DO IMU=1,NMU
            READ(99,*) EMUDUM(IMU),AMUDUM(IMU)
          ENDDO !NMU
          DO IFREQ=NFREQ0M,NFREQ0P
            CALL ABSNOSPLI
     &        (EMUDUM,AMUDUM,NMU,FREQ(IFREQ-NFREQ0M+1),
     &        ABSMUEN(IFREQ-NFREQ0M+1),IERR,IDOSE)
            IF (IERR.NE.0) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'*** ERROR IN SPECINT ***'
              WRITE(LUNGFO,*)'CALL TO SR ABSNOSPLI FAILED'
              WRITE(LUNGFO,*)
     &'CHECK PHOTONENERGIES IN NAMELIST FREQN AND FILE ABSORPDOSE.RP'
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
              WRITE(6,*)
              WRITE(6,*)'*** ERROR IN SPECINT ***'
              WRITE(6,*)'CALL TO SR ABSNOSPLI FAILED'
              WRITE(6,*)
     &'CHECK PHOTONENERGIES IN NAMELIST FREQN AND FILE ABSORPDOSE.RP'
              WRITE(6,*)
              WRITE(6,*)
              STOP
            ENDIF   !IERR
          ENDDO
          CLOSE(99)
          ICAL=1
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &'     SPECINT: MASS ENERGY ABSORPTION COEFFS READ FROM FILE'
          WRITE(LUNGFO,*)'     COMMENT ON FILE IS:'
          WRITE(LUNGFO,*)'     ',CDUM
          WRITE(LUNGFO,*)
        ENDIF !ICAL

        DO IOBSV=1,NOBSV

C--- FILL INTEGRATION BUFFER FOR ABSORBED DOSE

          DO IFREQ=NFREQ0M,NFREQ0P
            S2(IFREQ-NFREQ0M+1)=
     &        SPECTOT(IOBSV+NOBSV*(IFREQ-1))/BANWID*ECHARGE1
            S2(IFREQ-NFREQ0M+1)=
     &        S2(IFREQ-NFREQ0M+1)*ABSMUEN(IFREQ-NFREQ0M+1)
          ENDDO !IFREQ

C--- DO INTEGRATION OF BUFFER

          CALL SPBUFINT(FREQ,S2,NFREQ0,RESULT,SIMPLE)
          IF (IWARNS.EQ.0.AND.RESULT.NE.0.0.AND.
     &        DABS((RESULT-SIMPLE)/RESULT).GT.1.D-1) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &'*** WARNING SPECINT: PROBLEM WITH INTEGRATION OF SPECTRUM'
            WRITE(LUNGFO,*)
     &        '(ABSORBED DOSE)'
            WRITE(LUNGFO,*)'CHECK RESULTS CAREFULLY'
            WRITE(6,*)
            WRITE(6,*)
     &'*** WARNING SR SPECINT: PROBLEM WITH INTEGRATION OF SPECTRUM'
            WRITE(6,*)
     &        '(ABSORBED DOSE)'
            WRITE(6,*)'CHECK RESULTS CAREFULLY'
            IWARNS=1
          ENDIF

          ENEDOS(IOBSV)=ENEDOS(IOBSV)+RESULT

        ENDDO !IOBSV

        IF (IPIN.NE.0) THEN

          IWARNW=0
          DO IFREQ=NFREQ0M,NFREQ0P
            S2(IFREQ-NFREQ0M+1)=
     &        WFLUXT(IFREQ-NFREQ0M+1)/BANWID*ECHARGE1/PINW/PINH
            S2(IFREQ-NFREQ0M+1)=
     &        S2(IFREQ-NFREQ0M+1)*ABSMUEN(IFREQ-NFREQ0M+1)
          ENDDO !IFREQ

C--- DO INTEGRATION OF BUFFER

          CALL SPBUFINT(FREQ,S2,NFREQ0,PINDOS,SIMPLE)

          IF (IWARNW.EQ.0.AND.PINDOS.NE.0.0.AND.
     &        DABS((PINDOS-SIMPLE)/PINDOS).GT.1.D-1) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &'*** WARNING SPECINT: PROBLEM WITH INTEGRATION OF SPECTRUM'
            WRITE(LUNGFO,*)
     &        '(ABSORBED ENERGY DOSE THROUGH PINHOLE)'
            WRITE(LUNGFO,*)'CHECK RESULTS CAREFULLY'
            WRITE(6,*)
            WRITE(6,*)
     &'*** WARNING SPECINT: PROBLEM WITH INTEGRATION OF SPECTRUM'
            WRITE(6,*)
     &        '(ABSORBED ENERGY DOSE THROUGH PINHOLE)'
            WRITE(6,*)'CHECK RESULTS CAREFULLY'
            IWARNW=1
          ENDIF

        ENDIF !IPIN

      ENDIF !IDOSE

      IF (IPINCIRC.EQ.0) THEN
        DO ISOUR=1,NSOURCE
          DO IZ=1,NOBSVZ
            CALL BLENDSPECIV(ISOUR,IZ)
          ENDDO
        ENDDO
      ENDIF !(IPINCIRC.EQ.0)

      RETURN
      END
+DECK,spectrum.
*CMZ :  4.01/04 20/11/2023  18.32.01  by  Michael Scheer
*CMZ :  4.01/03 01/07/2023  10.08.32  by  Michael Scheer
*CMZ :  4.01/02 14/05/2023  13.25.57  by  Michael Scheer
*CMZ :  4.01/00 05/12/2022  10.23.29  by  Michael Scheer
*CMZ :  4.00/17 15/11/2022  10.09.14  by  Michael Scheer
*CMZ :  4.00/15 31/05/2022  09.04.28  by  Michael Scheer
*CMZ :  4.00/13 07/12/2021  18.47.10  by  Michael Scheer
*CMZ :  4.00/11 15/06/2021  12.33.13  by  Michael Scheer
*CMZ :  4.00/10 03/09/2020  13.24.08  by  Michael Scheer
*CMZ :  4.00/07 26/06/2020  10.05.00  by  Michael Scheer
*CMZ :  4.00/05 29/11/2019  17.42.27  by  Michael Scheer
*CMZ :  4.00/04 27/08/2019  11.49.27  by  Michael Scheer
*CMZ :  3.08/01 03/04/2019  16.22.16  by  Michael Scheer
*CMZ :  3.07/01 29/03/2019  15.08.52  by  Michael Scheer
*CMZ :  3.07/00 14/03/2019  15.32.16  by  Michael Scheer
*CMZ :  3.06/00 19/02/2019  11.45.45  by  Michael Scheer
*CMZ :  3.05/14 28/09/2018  12.28.08  by  Michael Scheer
*CMZ :  3.05/10 13/08/2018  14.40.26  by  Michael Scheer
*CMZ :  3.05/06 17/07/2018  11.15.17  by  Michael Scheer
*CMZ :  3.05/03 17/05/2018  08.46.21  by  Michael Scheer
*CMZ :  3.05/02 09/05/2018  12.55.31  by  Michael Scheer
*CMZ :  3.03/02 04/05/2018  13.55.11  by  Michael Scheer
*CMZ :  3.03/01 12/11/2015  10.13.14  by  Michael Scheer
*CMZ :  3.02/07 22/06/2015  15.01.50  by  Michael Scheer
*CMZ :  3.02/06 15/04/2015  12.01.22  by  Michael Scheer
*CMZ :  3.02/03 07/11/2014  17.09.23  by  Michael Scheer
*CMZ :  3.02/00 18/09/2014  15.43.00  by  Michael Scheer
*CMZ :  3.01/00 03/07/2013  15.42.09  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.70/11 21/02/2013  10.24.53  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  14.04.56  by  Michael Scheer
*CMZ :  2.70/04 21/12/2012  12.38.11  by  Michael Scheer
*CMZ :  2.69/00 30/10/2012  14.15.43  by  Michael Scheer
*CMZ :  2.68/05 18/10/2012  14.25.09  by  Michael Scheer
*CMZ :  2.68/02 05/07/2012  11.19.57  by  Michael Scheer
*CMZ :  2.68/01 29/05/2012  09.43.05  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  16.32.34  by  Michael Scheer
*CMZ :  2.67/04 11/05/2012  15.40.01  by  Michael Scheer
*CMZ :  2.66/18 02/12/2010  14.59.07  by  Michael Scheer
*CMZ :  2.66/16 22/11/2010  14.01.42  by  Michael Scheer
*CMZ :  2.66/13 18/06/2010  14.17.37  by  Michael Scheer
*CMZ :  2.66/09 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.66/08 15/03/2010  15.14.36  by  Michael Scheer
*CMZ :  2.66/07 10/03/2010  09.03.13  by  Michael Scheer
*CMZ :  2.66/06 24/02/2010  17.11.25  by  Michael Scheer
*CMZ :  2.66/04 18/11/2009  10.22.04  by  Michael Scheer
*CMZ :  2.66/03 12/11/2009  16.27.11  by  Michael Scheer
*CMZ :  2.66/00 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  2.65/03 02/10/2009  13.09.16  by  Michael Scheer
*CMZ :  2.65/02 29/09/2009  12.00.20  by  Michael Scheer
*CMZ :  2.64/07 17/09/2009  15.40.31  by  Michael Scheer
*CMZ :  2.64/06 15/09/2009  15.08.58  by  Michael Scheer
*CMZ :  2.64/05 14/09/2009  15.19.42  by  Michael Scheer
*CMZ :  2.64/01 19/08/2009  08.45.04  by  Michael Scheer
*CMZ :  2.64/00 14/08/2009  14.25.09  by  Michael Scheer
*CMZ :  2.63/05 12/08/2009  08.49.28  by  Michael Scheer
*CMZ :  2.62/03 16/07/2007  12.15.22  by  Michael Scheer
*CMZ :  2.62/02 16/07/2007  07.31.52  by  Michael Scheer
*CMZ :  2.61/01 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.57/04 01/02/2006  12.28.09  by  Michael Scheer
*CMZ :  2.57/01 22/11/2005  13.07.59  by  Michael Scheer
*CMZ :  2.56/01 17/10/2005  14.36.43  by  Michael Scheer
*CMZ :  2.56/00 17/10/2005  13.26.33  by  Michael Scheer
*CMZ :  2.54/05 26/05/2005  08.07.59  by  Michael Scheer
*CMZ :  2.53/05 17/02/2005  14.00.32  by  Michael Scheer
*CMZ :  2.52/16 19/01/2005  10.32.23  by  Michael Scheer
*CMZ :  2.52/13 10/12/2004  10.43.51  by  Michael Scheer
*CMZ :  2.52/11 08/12/2004  13.11.32  by  Michael Scheer
*CMZ :  2.52/10 05/11/2004  15.45.33  by  Michael Scheer
*CMZ :  2.52/01 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.52/00 29/06/2004  11.53.01  by  Michael Scheer
*CMZ :  2.51/02 22/06/2004  09.06.04  by  Michael Scheer
*CMZ :  2.51/01 17/06/2004  11.33.47  by  Michael Scheer
*CMZ :  2.51/00 26/05/2004  15.54.25  by  Michael Scheer
*CMZ :  2.50/02 30/04/2004  15.27.49  by  Michael Scheer
*CMZ :  2.50/00 29/04/2004  17.07.16  by  Michael Scheer
*CMZ :  2.49/00 22/03/2004  13.30.23  by  Michael Scheer
*CMZ :  2.47/09 20/05/2003  14.31.10  by  Michael Scheer
*CMZ :  2.47/05 25/03/2003  12.09.15  by  Michael Scheer
*CMZ :  2.47/01 10/03/2003  11.54.47  by  Michael Scheer
*CMZ :  2.46/02 07/03/2003  11.02.34  by  Michael Scheer
*CMZ :  2.44/01 21/11/2002  16.45.47  by  Michael Scheer
*CMZ :  2.44/00 15/11/2002  18.31.22  by  Michael Scheer
*CMZ :  2.41/11 21/08/2002  11.23.26  by  Michael Scheer
*CMZ :  2.41/09 14/08/2002  17.20.18  by  Michael Scheer
*CMZ :  2.41/07 31/05/2002  16.37.13  by  Michael Scheer
*CMZ :  2.38/00 12/12/2001  18.21.12  by  Michael Scheer
*CMZ :  2.35/02 30/10/2001  17.06.49  by  Michael Scheer
*CMZ :  2.34/09 26/09/2001  17.14.17  by  Michael Scheer
*CMZ :  2.34/00 11/05/2001  17.06.33  by  Michael Scheer
*CMZ :  2.33/04 04/05/2001  11.31.09  by  Michael Scheer
*CMZ :  2.33/01 03/05/2001  13.48.25  by  Michael Scheer
*CMZ :  2.33/00 03/05/2001  10.49.22  by  Michael Scheer
*CMZ :  2.31/01 25/04/2001  14.38.57  by  Michael Scheer
*CMZ :  2.31/00 24/04/2001  11.16.55  by  Michael Scheer
*CMZ :  2.30/01 12/04/2001  12.43.20  by  Michael Scheer
*CMZ :  2.20/11 11/04/2001  13.15.39  by  Michael Scheer
*CMZ :  2.20/10 04/04/2001  16.52.12  by  Michael Scheer
*CMZ :  2.20/09 03/04/2001  14.51.24  by  Michael Scheer
*CMZ :  2.20/04 09/03/2001  19.13.21  by  Michael Scheer
*CMZ :  2.20/03 23/02/2001  14.46.53  by  Michael Scheer
*CMZ :  2.20/01 19/02/2001  10.53.35  by  Michael Scheer
*CMZ :  2.17/00 06/11/2000  17.32.34  by  Michael Scheer
*CMZ :  2.16/08 01/11/2000  18.52.39  by  Michael Scheer
*CMZ :  2.16/07 17/10/2000  11.06.19  by  Michael Scheer
*CMZ :  2.16/06 28/08/2000  16.04.39  by  Michael Scheer
*CMZ :  2.16/05 02/08/2000  13.56.30  by  Michael Scheer
*CMZ :  2.16/04 20/07/2000  15.20.32  by  Michael Scheer
*CMZ :  2.16/03 16/06/2000  14.59.25  by  Michael Scheer
*CMZ :  2.16/01 15/06/2000  16.12.25  by  Michael Scheer
*CMZ :  2.16/00 13/06/2000  14.00.28  by  Michael Scheer
*CMZ :  2.15/00 06/05/2000  11.15.11  by  Michael Scheer
*CMZ :  2.13/10 06/04/2000  13.55.09  by  Michael Scheer
*CMZ :  2.13/08 28/02/2000  10.59.59  by  Michael Scheer
*CMZ :  2.13/07 17/02/2000  15.11.13  by  Michael Scheer
*CMZ :  2.13/04 21/01/2000  14.49.57  by  Michael Scheer
*CMZ :  2.13/03 18/01/2000  17.58.11  by  Michael Scheer
*CMZ :  2.13/02 14/12/99  16.47.46  by  Michael Scheer
*CMZ :  2.13/00 02/12/99  13.19.08  by  Michael Scheer
*CMZ :  2.12/04 20/08/99  11.42.59  by  Michael Scheer
*CMZ :  2.12/03 08/07/99  10.46.11  by  Michael Scheer
*CMZ :  2.12/02 15/06/99  16.10.08  by  Michael Scheer
*CMZ :  2.12/01 14/06/99  15.26.07  by  Michael Scheer
*CMZ :  2.12/00 03/06/99  15.38.11  by  Michael Scheer
*CMZ :  2.11/01 18/05/99  10.04.01  by  Michael Scheer
*CMZ :  2.11/00 12/05/99  11.35.36  by  Michael Scheer
*CMZ :  2.10/01 19/03/99  11.45.33  by  Michael Scheer
*CMZ :  2.02/00 12/02/99  16.13.41  by  Michael Scheer
*CMZ :  2.00/00 06/01/99  11.58.17  by  Michael Scheer
*CMZ :  1.04/03 11/12/98  16.35.36  by  Michael Scheer
*CMZ :  1.04/02 11/12/98  11.35.23  by  Michael Scheer
*CMZ :  1.04/01 11/12/98  11.21.18  by  Michael Scheer
*CMZ :  1.04/00 05/10/98  15.04.38  by  Michael Scheer
*CMZ :  1.03/06 25/09/98  11.00.44  by  Michael Scheer
*CMZ :  1.03/03 24/02/98  12.03.00  by  Michael Scheer
*CMZ :  1.03/02 18/02/98  16.56.26  by  Michael Scheer
*CMZ :  1.03/01 16/01/98  16.52.08  by  Michael Scheer
*CMZ :  1.02/03 16/01/98  10.58.48  by  Michael Scheer
*CMZ :  1.00/00 05/08/97  15.02.55  by  Michael Scheer
*CMZ : 00.02/05 25/03/97  13.44.31  by  Michael Scheer
*CMZ : 00.02/04 26/02/97  12.24.14  by  Michael Scheer
*CMZ : 00.02/03 16/01/97  11.07.55  by  Michael Scheer
*CMZ : 00.02/02 15/01/97  13.14.58  by  Michael Scheer
*CMZ : 00.01/12 04/11/96  11.52.18  by  Michael Scheer
*CMZ : 00.01/10 16/07/96  15.25.52  by  Michael Scheer
*CMZ : 00.01/09 01/09/95  13.05.18  by  Michael Scheer
*CMZ : 00.01/08 22/06/95  18.18.43  by  Michael Scheer
*CMZ : 00.01/07 24/02/95  11.21.39  by  Michael Scheer
*CMZ : 00.01/06 02/02/95  19.03.32  by  Michael Scheer
*CMZ : 00.01/05 31/01/95  15.35.41  by  Michael Scheer
*CMZ : 00.01/04 26/01/95  16.20.02  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  18.37.44  by  Michael Scheer
*CMZ : 00.00/07 25/05/94  16.45.07  by  Michael Scheer
*CMZ : 00.00/05 29/04/94  20.07.34  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.54.43  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.39  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE SPECTRUM
+seq,gplhint.

C--- MAIN ROUTINE TO CALCULATE SYNCHROTRON RADIATION SPECTRA

+SEQ,TRACKF90U.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,REARGF90U.
+SEQ,WFOLDF90U.
+SEQ,AFREQF90U.
+SEQ,AMPLIF90U.

      use clustermod
      use bunchmod
      use ompmod
      use uradphasemod
      !use waveenv

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,TRACK.
+SEQ,OPTIC.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,SPECDIP.
+SEQ,COLLI.
+SEq,wfoldf90.
+SEQ,DEPOLA.
+SEQ,WUSEM.
+SEQ,AMPLI.
+SEQ,USERVAR.
+SEQ,PHYCON.
+SEQ,PRIMKIN.
+seq,datetime.
+seq,debugwave.
+seq,waveenv.

      INTEGER ISOUR,IS,IFR,IO,IX,IC,JC,IZ,IY,IFREQ,IOBSV,IBUFF
      INTEGER ICEN,ISTO,MSADD,IFAIL,I,ISTOK
      INTEGER NTOTIN,NTOT2IN,IREP,ipino,ibuncho,ihbuncho,mbuncho,meinbuncho

      REAL*4 POL,rr(2)
      REAL*4 THERAY,PHIRAY,RAY,ZRAY,YRAY,DRAY,RAY1,RAY2,RAY3,RAY1N,RAY2N,RAY3N

      DOUBLE PRECISION ENEDOSMX,S1,S2,S3,S4,DUM1,DUM2,RMS
      DOUBLE PRECISION WSNOBFR1(NDFREQP),WSNOBFR2(NDFREQP),SPECBUFF(NDFREQP)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SPECTRUM'
      WRITE(LUNGFO,*)'     ==========='
      WRITE(LUNGFO,*)

      ipino=ipin
      ibuncho=ibunch
      mbuncho=nbunch
      meinbuncho=neinbunch
      ihbuncho=ihbunch
      if (kampli.ne.0) then
        ibunch=0
        ihbunch=0
      endif

      if (ispecmode.ne.3.and.ispecmode.ne.1.and.ispecmode.ne.2) then
        write(6,*)
     &    '*** ERROR IN SPECTRUM: ISPECMODE must be 1, 2, or 3***'
        write(LUNGFO,*)
     &    '*** ERROR IN SPECTRUM: ISPECMODE must be 1, 2, or 3***'
        stop '*** PROGRAM WAVE ABORTED ***'
      endif

      if (ipin.eq.3.and.ispecmode.ne.1.and.ispecmode.ne.2) then
        write(LUNGFO,*)
     &    '*** ERROR IN SPECTRUM: For IPIN=3, ISPECMODE must be 1 or 2 ***'
        write(6,*)
     &    '*** ERROR IN SPECTRUM: For IPIN=3, ISPECMODE must be 1 or 2 ***'
        stop
      endif

      IF (ISPECDIP.GT.0.and.ibrill.ne.0) THEN
        write(6,*)'*** WARNING IN SPECTRUM: ISPECDIP.gt.0 and IBRILL.ne.0'
        write(6,*)'*** IBRILL SET TO ZERO ***'
        write(LUNGFO,*)'*** WARNING IN SPECTRUM: ISPECDIP.gt.0 and IBRILL.ne.0'
        write(lungfo,*)'*** IBRILL SET TO ZERO ***'
        IBRILL=0
      endif

      IF (ISPECDIP.GT.0.and.ifold.ne.0) THEN
        write(6,*)'*** WARNING IN SPECTRUM: ISPECDIP.gt.0 and IFOLD.ne.0'
        write(6,*)'*** IFOLD SET TO ZERO ***'
        write(LUNGFO,*)'*** WARNING IN SPECTRUM: ISPECDIP.gt.0 and IFOLD.ne.0'
        write(lungfo,*)'*** IFOLD SET TO ZERO ***'
        ifold=0
        ihfold=0
      endif

      IF (ISPECDIP.GT.0.and.IEFOLD.ne.0) THEN
        write(6,*)'*** WARNING IN SPECTRUM: ISPECDIP.gt.0 and IEFOLD.ne.0'
        write(6,*)'*** IEFOLD SET TO ZERO ***'
        write(LUNGFO,*)'*** WARNING IN SPECTRUM: ISPECDIP.gt.0 and IEFOLD.ne.0'
        write(lungfo,*)'*** IEFOLD SET TO ZERO ***'
        IEFOLD=0
      endif

      IF (ISPECDIP.eq.2.and.if1dim.eq.0) THEN
        write(LUNGFO,*)'*** WARNING IN SPECTRUM: ISPECDIP.eq.2 and IF1DIM.eq.0'
        write(LUNGFO,*)'*** IF1DIM SET TO ONE ***'
        write(6,*)'*** WARNING IN SPECTRUM: ISPECDIP.eq.2 and IF1DIM.eq.0'
        write(6,*)'*** IF1DIM SET TO ONE ***'
        If1dim=1
      endif

      IF (ISPECMODE.gt.2.and.mpinr.ne.0) THEN
        WRITE(LUNGFO,*)' '
        WRITE(LUNGFO,*)
     &    '*** WARNING IN SPECTRUM: ISPECMODE .gt. 2 .and. MPINR .ne. 0'
        WRITE(LUNGFO,*)'*** MPINR will be ignored and set to zero'
        WRITE(LUNGFO,*)' '
        WRITE(6,*)' '
        WRITE(6,*)
     &    '*** WARNING IN SPECTRUM: ISPECMODE .gt. 2 .and. MPINR .ne. 0'
        WRITE(6,*)'*** MPINR will be ignored and set to zero'
        WRITE(6,*)' '
c        mpinr=0
      endif
c 20150622{
c      IF (IFREQ2P.EQ.0.AND.ISPECMODE.LT.3) THEN
c
c        WRITE(LUNGFO,*)
c     &    '*** WARNING IN SPECTRUM: Option IFREQ2P=0 NOT available for ISPECMODE<3'
c        WRITE(LUNGFO,*)
c     &    '*** ISPECMODE set to 3'
c        WRITE(LUNGFO,*)''
c
c        WRITE(6,*)
c     &    '*** WARNING IN SPECTRUM: Option IFREQ2P=0 NOT available for ISPECMODE<3'
c        WRITE(6,*)
c     &    '*** ISPECMODE set to 3'
c        WRITE(6,*)''
c
c        ISPECMODE=3
c
c 20150622}      ENDIF

      IF (ibunch.ne.0) THEN
        write(lungfo,*)'      Bunch parameters:'
        write(lungfo,*)'      mode IUBUNCH:                    ',IUBUNCH
        write(lungfo,*)'      number of bunches NBUNCH:        ',NBUNCH
        write(lungfo,*)'      number of e- per bunch NEINBUNCH:',NEINBUNCH
        write(lungfo,*)'      bunch length [m]: BUNCHLEN:      ',BUNCHLEN
        write(lungfo,*)'      bunch charge [C]: BUNCHCHARGE:   ',BUNCHCHARGE
        WRITE(lungfo,*)''
        WRITE(lungfo,*)''
      endif

      IF (ISPECDIP.LE.0) THEN

        WRITE(LUNGFO,*)
     &    '     Start and end of points [m] of integration for spectrum'
        WRITE(LUNGFO,*)'     calculations (XIANF,XIEND):'
     &    ,SNGL(XIANF),SNGL(XIEND)
        WRITE(LUNGFO,*)

        IF ((XIANF.NE.XSTART.OR.XIEND.NE.XSTOP)
     &      .AND.XIANF.NE.-1.D30.AND.XIEND.NE.1.D30) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      ' *** Start or end of points (XIANF,XIEND) of integration differ'
          WRITE(LUNGFO,*)
     &      ' *** from XSTART or XSTOP respectively'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)
     &      ' *** Start or end of points (XIANF,XIEND) of integration differ'
          WRITE(6,*)
     &      ' *** from XSTART or XSTOP respectively'
          WRITE(6,*)
          WRITE(6,*)
        ENDIF

      ENDIF !ISPECDIP.LE.0

      IF (IWFILINT.GT.0) THEN
        OPEN(UNIT=LUNINT,FILE=FILEINT)
      ENDIF !IWFILINT

C--- NEW VERSION OF TRACKS REQUIRES IMAGSPLN

      IF (ISPECMODE.EQ.3) IMAGSPLN=-999

C----   FREQUENCES TO BE TREATED

      CALL RFILFR

C--- NOW WE ARE DEALING WITH PHOTON ENERGIES

C260194  IF (IUNIT.NE.0) CALL CONVUN

C---  DEFAULTS FOR WGWINFC

      if (pinr.eq.-9999.) pinr=max(pinw,pinh)/2.0d0
      if (pinr.eq.9999.) pinr=sqrt(pinw*pinh/pi1)
      IF (WGWINFC.EQ.9999.AND.IUNDULATOR.EQ.0) CALL SETWGWIN

C---  DEFAULTS FOR PINCEN

      IOBSV_A=1
      IOBSVZ_A=1
      IOBSVY_A=1

      ALLOCATE(OBSV(3,IOBSV_A))
      ALLOCATE(OBSVY(IOBSVY_A))
      ALLOCATE(OBSVZ(IOBSVZ_A))

      IF (IPIN.NE.0) THEN
        CALL PINCENIN
      ENDIF

      IF (OBS1X.EQ.-9999.) OBS1X=PINCEN(1)
      IF (aperX.EQ.-9999.) aperx=PINCEN(1)

      if (ipin.eq.0.and.obs1x.le.xstop) then
        write(6,*)
     &    '*** Error: OBS1X (x of observation point) must be bigger than XSTOP'
        write(6,*)
     &    '*** Please check input file'
        write(6,*)
     &    '*** Program WAVE aborted ***'
        stop
      else if (ipin.ne.0.and.pincen(1).le.xstop) then
        write(6,*)
     &    '*** Error: PINCEN(1) (x of pinhole) must be bigger than XSTOP'
        write(6,*)
     &    '*** Please check input file'
        write(6,*)
     &    '*** Program WAVE aborted ***'
        stop
      endif

      IF (OBS1y.EQ.-9999.) then
        OBS1y=ySTART+VyIN/VXIN*(OBS1X-XSTART)
      else IF (obs1y.EQ.-8888.) THEN
        obs1y=yoffstr+yslopetr*obs1x
      else IF (obs1y.EQ.-9000.) THEN
        obs1y=0.0d0
        do i=1,nco
          obs1y=obs1y+
     &      wtra(2,1,i)+wtra(2,2,i)/wtra(1,2,i)*(PINCEN(1)-wtra(1,1,i))
        enddo
        obs1y=obs1y/nco
      ENDIF

      IF (OBS1Z.EQ.-9999.) then
        OBS1Z=ZSTART+VZIN/VXIN*(OBS1X-XSTART)
      else IF (obs1z.EQ.-8888.) THEN
        obs1z=zoffstr+zslopetr*obs1x
      else IF (obs1z.EQ.-9000.) THEN
        obs1z=0.0d0
        do i=1,nco
          obs1z=obs1z+
     &      wtra(3,1,i)+wtra(3,2,i)/wtra(1,2,i)*(PINCEN(1)-wtra(1,1,i))
        enddo
        obs1z=obs1z/nco
      ENDIF

      IF (IPIN.EQ.0) PINCEN(1)=OBS1X

C---  SOURCES OF LIGHT. SOURCES ARE READ OR DEFINED BY COLLIMATOR

      IF (CX1.EQ.9999.) THEN
        IF (IRFILOB.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '*** DEFAULT FOR CX1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
          WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)
     &      '*** DEFAULT FOR CX1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
          WRITE(6,*)'*** CHECK INPUT FILE ***'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF
        IF (IPIN.NE.0) THEN
          CX1=PINCEN(1)-0.00001
        ELSE
          CX1=OBS1X-0.00001
        ENDIF
      ENDIF

      IF (CX2.EQ.9999.) THEN
        IF (IRFILOB.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '*** DEFAULT FOR CX2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
          WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)
     &      '*** DEFAULT FOR CX2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
          WRITE(6,*)'*** CHECK INPUT FILE ***'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF
        IF (IPIN.NE.0) THEN
          CX2=PINCEN(1)
        ELSE
          CX2=OBS1X
        ENDIF
      ENDIF

      IF (CY1.EQ.9999.) THEN
        IF (IRFILOB.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '*** DEFAULT FOR CY1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
          WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)
     &      '*** DEFAULT FOR CY1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
          WRITE(6,*)'*** CHECK INPUT FILE ***'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF
        IF (IPIN.NE.0) THEN
          CY1=PINCEN(2)
        ELSE
          CY1=OBS1Y
        ENDIF
      ENDIF !CY1

       IF (CY2.EQ.9999.) THEN
         IF (IRFILOB.NE.0) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
     &       '*** DEFAULT FOR CY2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)
     &       '*** DEFAULT FOR CY2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(6,*)'*** CHECK INPUT FILE ***'
           WRITE(6,*)
           STOP '*** PROGRAM WAVE ABORTED ***'
         ENDIF
         IF (IPIN.NE.0) THEN
           CY2=PINCEN(2)
         ELSE
           CY2=OBS1Y
         ENDIF
       ENDIF !CY2

       IF (CZ1.EQ.9999.) THEN
         IF (IRFILOB.NE.0) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
     &       '*** DEFAULT FOR CZ1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)
     &       '*** DEFAULT FOR CZ1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(6,*)'*** CHECK INPUT FILE ***'
           WRITE(6,*)
           STOP '*** PROGRAM WAVE ABORTED ***'
         ENDIF
         IF (IPIN.NE.0) THEN
           CZ1=PINCEN(3)
         ELSE
           CZ1=OBS1Z
         ENDIF
       ENDIF !CZ1

       IF (CZ2.EQ.9999.) THEN
         IF (IRFILOB.NE.0) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
     &       '*** DEFAULT FOR CZ2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)
     &       '*** DEFAULT FOR CZ2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(6,*)'*** CHECK INPUT FILE ***'
           WRITE(6,*)
           STOP '*** PROGRAM WAVE ABORTED ***'
         ENDIF
         IF (IPIN.NE.0) THEN
           CZ2=PINCEN(3)
         ELSE
           CZ2=OBS1Z
         ENDIF
       ENDIF !CZ2

       IF (WID1.EQ.9999.) THEN
         IF (IRFILOB.NE.0) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
     &       '*** DEFAULT FOR WID1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)
     &       '*** DEFAULT FOR WID1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(6,*)'*** CHECK INPUT FILE ***'
           WRITE(6,*)
           STOP '*** PROGRAM WAVE ABORTED ***'
         ENDIF
         IF (IPIN.NE.0) THEN
           WID1=PINW+4.*PINW/MPINZ
         ELSE
           WID1=0.001
         ENDIF
       ENDIF !WID1

       IF (WID2.EQ.9999.) THEN
         IF (IRFILOB.NE.0) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
     &       '*** DEFAULT FOR WID2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)
     &       '*** DEFAULT FOR WID2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(6,*)'*** CHECK INPUT FILE ***'
           WRITE(6,*)
           STOP '*** PROGRAM WAVE ABORTED ***'
         ENDIF
         IF (IPIN.NE.0) THEN
           WID2=PINW+4.*PINW/MPINZ
         ELSE
           WID2=0.001
         ENDIF
       ENDIF !WID2

       IF (HIG1.EQ.9999.) THEN
         IF (IRFILOB.NE.0) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
     &       '*** DEFAULT FOR HIG1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)
     &       '*** DEFAULT FOR HIG1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(6,*)'*** CHECK INPUT FILE ***'
           WRITE(6,*)
           STOP '*** PROGRAM WAVE ABORTED ***'
         ENDIF
         IF (IPIN.NE.0) THEN
           HIG1=PINH+4.*PINH/MPINY
         ELSE
           HIG1=0.001
         ENDIF
       ENDIF !HIG1

       IF (HIG2.EQ.9999.) THEN
         IF (IRFILOB.NE.0) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
     &       '*** DEFAULT FOR HIG2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)
     &       '*** DEFAULT FOR HIG2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(6,*)'*** CHECK INPUT FILE ***'
           WRITE(6,*)
           STOP '*** PROGRAM WAVE ABORTED ***'
         ENDIF
         IF (IPIN.NE.0) THEN
           HIG2=PINH+4.*PINH/MPINY
         ELSE
           HIG2=0.001
         ENDIF
       ENDIF !HIG2

       IF(IRFILL0.NE.0) THEN
         CALL RFILL0
       ELSE IF (ISPECDIP.LE.0) THEN
         CALL WFILL0
       ELSE IF (ISPECDIP.GT.0) THEN
         NSOURCE=NDIP
       ENDIF

       if (nsource.gt.1.and.ibrill.ne.0) then
         write(6,*) "*** Warning: More then one source. This is not compatible with IBRILL=1"
         write(6,*) "*** IBRILL is set to zero!"
         write(LUNGFO,*) "*** Warning: More then one source. This is not compatible with IBRILL=1"
         write(LUNGFO,*) "*** IBRILL is set to zero!"
         ibrill=0
       endif

       if (nsource.gt.1.and.kampli.ne.0) then
         write(6,*) "*** Error: More then one source. This is not compatible with KAMPLI"
         stop "*** Program WAVE aborted ***"
       endif

       ALLOCATE(IPOISOU(NSOURCE))

       IF (ISPECDIP.LE.0) THEN

C        SOURCEE,SOUREA... ARE ALLOCATED IN RFILL0/WFILL0

         ALLOCATE(IWARNROI(NROIA,NSOURCE))
         ALLOCATE(IPOIROI(NROIA+1))
         ALLOCATE(IZTOT(NSOURCE))
         ALLOCATE(ECSOUR(4,NSOURCE))
         ALLOCATE(ECMAX(NSOURCE))

         DO I=1,NSOURCE
           ECSOUR(1,I)=0.0d0
           ECSOUR(2,I)=0.0d0
           ECSOUR(3,I)=0.0d0
           ECSOUR(4,I)=0.0d0
           ECMAX(I)=0.0d0
         ENDDO

C--- HISTOGRAMS OF MINITRAJECTORIES OF SOURCES

         IF (IHTRACKM.NE.0) CALL HSOURCE

C---- COHERENCE OF SOURCES

         CALL COHEREN

       ENDIF   !ISPECDIP.LE.0

C----   OBSERVATION POINTS TO BE TREATED

       IF (IPIN.NE.0) THEN

         if (ipin.eq.3) then
           call pinin3
         else
           CALL PININ
         endif

       ELSE !ipin

         MPINR=0

         IF (IFOLD.EQ.2) THEN

           CALL WSIGFOL

           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'     Horizontal emittance EPS0H [m-rad]:',EPS0H
           WRITE(LUNGFO,*)'     Vertical emittance EPS0V [m-rad]:  ',EPS0V
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'     Number of sigmas for horiz. folding:'
           WRITE(LUNGFO,*)'     ',(SNGL(DGSIGZ(IS)),IS=1,NSOURCE)
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'     Number of sigmas for vert. folding:'
           WRITE(LUNGFO,*)'     ',(SNGL(DGSIGY(IS)),IS=1,NSOURCE)
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'     Sigmas of sources for horiz. folding:'
           WRITE(LUNGFO,*)'     ',(SNGL(WSIGZ(IS)),IS=1,NSOURCE)
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'     Sigmas of sources for vert. folding:'
           WRITE(LUNGFO,*)'     ',(SNGL(WSIGY(IS)),IS=1,NSOURCE)
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'     Sigmas of horizontal beam size and divergence:'
           WRITE(LUNGFO,*)
     &       '     (if not zero, sigmas for folding are calculated from these values)'
           WRITE(LUNGFO,*)'     ',(SNGL(BSIGZ(IS)),SNGL(BSIGZP(IS)),IS=1,NSOURCE)
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'     Sigmas of vertical beam size and divergence:'
           WRITE(LUNGFO,*)
     &       '     (if not zero, sigmas for folding are calculated from these values)'
           WRITE(LUNGFO,*)'     ',(SNGL(BSIGY(IS)),SNGL(BSIGYP(IS)),IS=1,NSOURCE)
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)

           IF (ISTOKES.NE.0) THEN
             WRITE(LUNGFO,*)
     &         '     Sigmas for folding of components of STOKES vector:'
             WRITE(LUNGFO,*)
     &         '     ',SNGL(WSIGZ(ISIGSTO)),SNGL(WSIGY(ISIGSTO))
           ENDIF !ISTOKES

           WRITE(LUNGFO,*)

         ENDIF !IFOLD.EQ.2

         ICBRILL=1
         CALL RFILOB
         IF (IRFILOB.NE.0.AND.IPBRILL.NE.0) THEN
           ICBRILL=IPBRILL
           IF (ICBRILL.GT.NOBSV) THEN
             WRITE(LUNGFO,*)'*** ERROR IN SPECTRUM: BAD SELECTED POINT ***'
             WRITE(LUNGFO,*)'*** CHECK INPUT IPBRILL IN WAVE.IN'
             WRITE(6,*)'*** ERROR IN SPECTRUM: BAD SELECTED POINT ***'
             WRITE(6,*)'*** CHECK INPUT IPBRILL IN WAVE.IN'
             STOP
           ENDIF
         ENDIF
       ENDIF !ipin

       IF (NOBSVZ.GT.NDOBSVZP) THEN
         WRITE(6,*)'*** DIMENSION ERROR IN SPECTRUM FOR NDOBSVZP ***'
         WRITE(6,*)'DIMENSION IS: ',NDOBSVZP
         WRITE(6,*)'CALCULATION REQUIRES: ',NOBSVZ
         WRITE(6,*)'*** CHANGE PARAMETER NDOBSVZP IN CMPARA.CMN***'
         WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
         STOP
       ENDIF   !(NOBSVZ.GT.NDOBSVZP)

       IF (NOBSVY.GT.NDOBSVYP) THEN
         WRITE(6,*)'*** DIMENSION ERROR IN SPECTRUM FOR NDOBSVYP ***'
         WRITE(6,*)'DIMENSION IS: ',NDOBSVYP
         WRITE(6,*)'CALCULATION REQUIRES: ',NOBSVY
         WRITE(6,*)'*** CHANGE PARAMETER NDOBSVYP IN CMPARA.CMN***'
         WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
         STOP
         IF (NOBSV.GT.NDOBSVP) THEN
           WRITE(6,*)'*** DIMENSION ERROR IN SPECTRUM FOR NDOBSVP ***'
           WRITE(6,*)'DIMENSION IS: ',NDOBSVP
           WRITE(6,*)'CALCULATION REQUIRES: ',NOBSV
           WRITE(6,*)'*** CHANGE PARAMETER NDOBSVP IN CMPARA.CMN***'
           WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
           STOP
         ENDIF !(NOBSV.GT.NDOBSVP)
       ENDIF   !(NOBSVY.GT.NDOBSVYP)

       ALLOCATE(schwingercen(4,nobsv,nsource))
       ALLOCATE(SPEC(NSOURCE*NOBSV*NFREQ))
       spec=0.0d0

      IF (MPINR.NE.0) THEN
        ALLOCATE(SPECRPHI(NSOURCE*NOBSVRPHI*NFREQ))
        SPECRPHI=0.0D0
      ENDIF

      ALLOCATE(SPECI(NSOURCE*NOBSV))
      ALLOCATE(SPECIV(NSOURCE*NOBSV))
      ALLOCATE(SPECPOW(NSOURCE*NOBSV))
      if (ifold.ne.0) then
        ALLOCATE(SPECPOWF(NSOURCE*NOBSV))
        ALLOCATE(SPECPOWTF(NOBSV))
      endif
      IF (MPINR.GT.0) THEN
        ALLOCATE(SPECPOWRPHI(NSOURCE*NOBSVRPHI))
        SPECPOWRPHI=0.0D0
      ENDIF

      SPECI=0.0d0
      SPECIV=0.0d0
      SPECPOW=0.0d0

      ALLOCATE(SPECPOWV(NSOURCE*NOBSVZ))
      DO I=1,NSOURCE*NOBSVZ
        SPECPOWV(I)=0.0d0
      ENDDO

      ALLOCATE(WFLUX(NSOURCE*NFREQ))
      DO I=1,NSOURCE*NFREQ
        WFLUX(I)=0.0d0
      ENDDO

      ALLOCATE(SPECTOT(NOBSV*NFREQ))
      DO I=1,NOBSV*NFREQ
        SPECTOT(I)=0.0d0
      ENDDO

      ALLOCATE(REAIMA(14,2,NOBSV*NFREQ))
      REAIMA=0.0d0

      IF (MPINR.NE.0) THEN
        ALLOCATE(REAIMARPHI(14,2,NOBSV*NFREQ))
        REAIMARPHI=0.0d0
      ENDIF

      IF (ISTOKES.NE.0) THEN
        ALLOCATE(STOKES(4,NOBSV*NFREQ))
        STOKES=0.0D0
        IF (IEFOLD.NE.0) THEN
          ALLOCATE(STOKESE(4,NOBSV*NFREQ))
          STOKESE=0.0D0
          IF (IFOLD.NE.0) THEN
            ALLOCATE(STOKESEF(4,NOBSV*NFREQ))
            STOKESE=0.0D0
          ENDIF
        ENDIF
      ENDIF

      ALLOCATE(SPECPOWVH(NSOURCE))
      ALLOCATE(WFLUXI(NSOURCE))
      DO I=1,NSOURCE
        SPECPOWVH(I)=0.0d0
        WFLUXI(I)=0.0d0
      ENDDO

      ALLOCATE(SPECTOTI(NOBSV))
      ALLOCATE(SPECPOWT(NOBSV))
      ALLOCATE(SPECPOWTgraz(NOBSV))
      ALLOCATE(ENEDOS(NOBSV))
      ALLOCATE(SPCOEFM(NOBSV))
      ALLOCATE(WOBS1(NOBSV))
      ALLOCATE(WOBS2(NOBSV))
      ALLOCATE(WOBS3(NOBSV))
      ALLOCATE(WOBS4(NOBSV))
      ALLOCATE(WOBS5(NOBSV))
      ALLOCATE(WOBS6(NOBSV))
      ALLOCATE(WOBS7(NOBSV))
      ALLOCATE(WOBS8(NOBSV))
      ALLOCATE(SPCOEF(NOBSV))
      DO I=1,NOBSV
        SPECTOTI(I)=0.0d0
        SPECPOWT(I)=0.0d0
        SPECPOWTgraz(I)=0.0d0
        ENEDOS(I)=0.0d0
        SPCOEFM(I)=0.0d0
        WOBS1(I)=0.0d0
        WOBS2(I)=0.0d0
        WOBS3(I)=0.0d0
        WOBS4(I)=0.0d0
        WOBS5(I)=0.0d0
        WOBS6(I)=0.0d0
        WOBS7(I)=0.0d0
        WOBS8(I)=0.0d0
        SPCOEF(I)=0.0d0
      ENDDO

      ALLOCATE(SPECPOWVT(NOBSVZ))
      DO I=1,NOBSVZ
        SPECPOWVT(I)=0.0d0
      ENDDO

      ALLOCATE(WFLUXT(NFREQ))

      DO I=1,NFREQ
        WFLUXT(I)=0.0D0
      ENDDO

      IF (ISTOKES.NE.0) THEN
        ALLOCATE(WSTOKES(4,NFREQ))
        ALLOCATE(STOKEC(4,NFREQ))
        DO I=1,NFREQ
          WSTOKES(1,I)=0.0D0
          WSTOKES(2,I)=0.0D0
          WSTOKES(3,I)=0.0D0
          WSTOKES(4,I)=0.0D0
          STOKEC(1,I)=0.0D0
          STOKEC(2,I)=0.0D0
          STOKEC(3,I)=0.0D0
          STOKEC(4,I)=0.0D0
        ENDDO
      ENDIF !ISTOKES

      IF (IBRILL.NE.0) THEN
        ALLOCATE(BRILLC(4,NFREQ))
        ALLOCATE(BRILLCF(4,NFREQ))  !also for ifold.eq.0
        DO I=1,NFREQ
          BRILLC(1,I)=0.0D0
          BRILLC(2,I)=0.0D0
          BRILLC(3,I)=0.0D0
          BRILLC(4,I)=0.0D0
          BRILLCF(1,I)=0.0D0
          BRILLCF(2,I)=0.0D0
          BRILLCF(3,I)=0.0D0
          BRILLCF(4,I)=0.0D0
        ENDDO
      ENDIF !IBRILL

      IF (IEFOLD.NE.0) THEN

        IF (ISTOKES.NE.0) THEN
          ALLOCATE(WSTOKESE(4,NFREQ))
          ALLOCATE(STOKECE(4,NFREQ))
          DO I=1,NFREQ
            WSTOKESE(1,I)=0.0D0
            WSTOKESE(2,I)=0.0D0
            WSTOKESE(3,I)=0.0D0
            WSTOKESE(4,I)=0.0D0
            STOKECE(1,I)=0.0D0
            STOKECE(2,I)=0.0D0
            STOKECE(3,I)=0.0D0
            STOKECE(4,I)=0.0D0
          ENDDO
        ENDIF !ISTOKES

        IF (IBRILL.NE.0) THEN
          ALLOCATE(BRILLCE(4,NFREQ))
          ALLOCATE(BRILLCEF(4,NFREQ)) !also for ifold.eq.0
          DO I=1,NFREQ
            BRILLCE(1,I)=0.0D0
            BRILLCE(2,I)=0.0D0
            BRILLCE(3,I)=0.0D0
            BRILLCE(4,I)=0.0D0
            BRILLCEF(1,I)=0.0D0
            BRILLCEF(2,I)=0.0D0
            BRILLCEF(3,I)=0.0D0
            BRILLCEF(4,I)=0.0D0
          ENDDO
        ENDIF   !IBRILL

      ENDIF !IEFOLD

      IF (IFOLD.NE.0) THEN

        ALLOCATE(SPECF(NSOURCE*NOBSV*NFREQ))
        DO I=1,NSOURCE*NOBSV*NFREQ
          SPECF(I)=0.0d0
        ENDDO

        ALLOCATE(SPECIF(NSOURCE*NOBSV))
        DO I=1,NSOURCE*NOBSV
          SPECIF(I)=0.0d0
        ENDDO

        ALLOCATE(SPECIVF(NSOURCE*NOBSVY))
        DO I=1,NSOURCE*NOBSVY
          SPECIVF(I)=0.0d0
        ENDDO

        ALLOCATE(WFLUXF(NSOURCE*NFREQ))
        DO I=1,NSOURCE*NFREQ
          WFLUXF(I)=0.0d0
        ENDDO

        ALLOCATE(DOBUFF(NOBSV))
        ALLOCATE(DOBUFF1(NOBSV))
        ALLOCATE(DOBUFF2(NOBSV))

        ALLOCATE(SPECTOTF(NOBSV*NFREQ))
        DO I=1,NOBSV*NFREQ
          SPECTOTF(I)=0.0D0
        ENDDO

        IF (ISTOKES.NE.0) THEN
          ALLOCATE(STOKESF(4,NOBSV*NFREQ))
          DO I=1,NOBSV*NFREQ
            STOKESF(1,I)=0.0d0
            STOKESF(2,I)=0.0d0
            STOKESF(3,I)=0.0d0
            STOKESF(4,I)=0.0d0
          ENDDO
        ENDIF

        ALLOCATE(WFLUXIF(NSOURCE))
        DO I=1,NSOURCE
          WFLUXIF(I)=0.0d0
        ENDDO

        ALLOCATE(SPECTOTIF(NOBSV))
        DO I=1,NOBSV
          SPECTOTIF(I)=0.0d0
        ENDDO

        ALLOCATE(WFLUXTF(NFREQ))
        DO I=1,NFREQ
          WFLUXTF(I)=0.0D0
        ENDDO

        IF (ISTOKES.NE.0) THEN
          ALLOCATE(WSTOKESF(4,NFREQ))
          ALLOCATE(STOKECF(4,NFREQ))
          DO I=1,NFREQ
            WSTOKESF(1,I)=0.0d0
            STOKECF(1,I)=0.0d0
            WSTOKESF(2,I)=0.0d0
            STOKECF(2,I)=0.0d0
            WSTOKESF(3,I)=0.0d0
            STOKECF(3,I)=0.0d0
            WSTOKESF(4,I)=0.0d0
            STOKECF(4,I)=0.0d0
          ENDDO
        ENDIF  !ISTOKES

        IF (IEFOLD.NE.0) THEN

          IF (ISTOKES.NE.0) THEN
            ALLOCATE(WSTOKESEF(4,NFREQ))
            ALLOCATE(STOKECEF(4,NFREQ))
            DO I=1,NFREQ
              WSTOKESEF(1,I)=0.0d0
              STOKECEF(1,I)=0.0d0
              WSTOKESEF(2,I)=0.0d0
              STOKECEF(2,I)=0.0d0
              WSTOKESEF(3,I)=0.0d0
              STOKECEF(3,I)=0.0d0
              WSTOKESEF(4,I)=0.0d0
              STOKECEF(4,I)=0.0d0
            ENDDO
          ENDIF   !ISTOKES

        ENDIF  !IEFOLD
      ENDIF !IFOLD

      if (ipin.ne.3) then
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'      selected observation point:'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'      '
     &    ,SNGL(OBSV(1,ICBRILL)),SNGL(OBSV(2,ICBRILL)),SNGL(OBSV(3,ICBRILL))
        WRITE(LUNGFO,*)
      endif

      CALL CHECKOB

C--- LOOP OVER ALL SOURCES, EVALUATE INTEGRALS

      IF (IAMPSKIP.NE.0) THEN
        ALLOCATE(AFREQ(6,NOBSV*NFREQ))
        AFREQ=(0.0D0,0.0D0)
        IF (MPINR.GT.0) THEN
          ALLOCATE(AFREQRPHI(6,NOBSVRPHI*NFREQ))
          afreqrphi=(0.0d0,0.0d0)
        ENDIF
        ALLOCATE(EXPOM2P0(2,NFREQ))
      ENDIF !(IAMPSKIP.NE.0)

      IF (NLPOI.EQ.0) nlpoi=(xstop-xstart)*myinum+1

      IF (
     &    ISPECANA.EQ.0
     &    .AND.
     &    IDESYNC.EQ.0
     &    .AND.
     &    ISPECDIP.EQ.0
     &    .AND.
     &    (IRFILSP0.EQ.0.OR.IRFILSTO.EQ.0.AND.ISTOKES.NE.0)
     &    .AND.
     &    IAMPSKIP.EQ.0
     &    ) THEN

C DEFAULT FOR NLPOI

        IF (NLPOI.EQ.-9999) CALL SETNLPOI

C STORE VALUES, REINITIALIZE SOURCEE

        NDWSOU=MAX(NLPOI,NCO)+NBADDP
        NDARGU=NDWSOU
        NLPOIO=NLPOI
        NBUFF=1

        IF (ISPECMODE.EQ.3.OR.ISPECMODE.EQ.4) THEN
          ALLOCATE(REARGUM(11,NDWSOU))
        ENDIF

        IF (ISPECMODE.EQ.1.OR.ISPECMODE.EQ.3.OR.ISPECMODE.EQ.4) THEN
          ALLOCATE(WSOU(3,5,NDWSOU))
        ENDIF

C BEGIN OF RAW SPECTRUM CALCULATION

        IF (NSOURCE.GE.1.and.icluster.lt.0) THEN
          CALL date_and_time(dtday,dttime,dtzone,idatetime)
          WRITE(6,*)
          WRITE(6,*)'     Starting spectrum calculations '
     &      ,dttime(1:2),':',dttime(3:4),':',dttime(5:6)
          WRITE(6,*)
        ENDIF

        DO ISOUR=1,NSOURCE
CERR101292      DO JC=1,3

          DO JC=1,4
            DO IC=1,3
              SOURCEAO(IC,JC,ISOUR)=SOURCEA(IC,JC,ISOUR)
              SOURCEEO(IC,JC,ISOUR)=SOURCEE(IC,JC,ISOUR)
            ENDDO
          ENDDO

          DO JC=1,1
            DO IC=1,3
              SOURCEE(IC,JC,ISOUR)=SOURCEA(IC,JC,ISOUR)+
     &          (SOURCEEO(IC,JC,ISOUR)-SOURCEAO(IC,JC,ISOUR))/NBUFF
            ENDDO
          ENDDO

        ENDDO   !ISOUR

        ISOURO=0

        IF (IAMPSKIP.EQ.0) THEN
          ALLOCATE(AFREQ(6,NOBSV*NFREQ))
          AFREQ=(0.0D0,0.0D0)
          ALLOCATE(EXPOM2P0(2,NFREQ))
          IF (MPINR.GT.0) THEN
            ALLOCATE(AFREQRPHI(6,NOBSVRPHI*NFREQ))
            afreqrphi=(0.0d0,0.0d0)
          ENDIF
        ENDIF !(IAMPSKIP.EQ.0)
        ALLOCATE(TBUFF(NOBSV))
        IF (ISPECMODE.EQ.3.OR.ISPECMODE.EQ.4) THEN
          ALLOCATE(NARGUM(NOBSV,NSOURCE))
        ELSE IF (ISPECMODE.EQ.1.OR.ISPECMODE.EQ.2) THEN
          ALLOCATE(DARGEXPO(6,NOBSV))
        ENDIF

        IF (IAMPLI.LT.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'      repetition of amplitude activated:'
          WRITE(LUNGFO,*)
     &      '      A -> A * (1 + exp(i*phi) + exp(i*2*phi)...'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'      IAMPLI, AMPSHIFT(1):',IAMPLI,AMPSHIFT(1)
          WRITE(LUNGFO,*)
     &      '      Total phase-advance [nm] and corresponding photon energy [eV]:'
          WRITE(LUNGFO,*)
     &      '      ',(AMPSHIFT(1)/2.0D0/DMYGAMMAP**2+HTRA2I)*1.0D9
     &      ,CLIGHT1*HPLANCK1/ECHARGE1/(AMPSHIFT(1)/2.0D0/DMYGAMMAP**2+HTRA2I)
c          WRITE(LUNGFO,*)
c     &      '      MYINUM has to be tuned,'
c          WRITE(LUNGFO,*)
c     &      '      since phase advance is calculated form trajectory.'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'      repetition of amplitude activated:'
          WRITE(6,*)
     &      '      A -> A * (1 + exp(i*phi) + exp(i*2*phi)...'
          WRITE(6,*)
          WRITE(6,*)'      IAMPLI, AMPSHIFT(1):',IAMPLI,AMPSHIFT(1)
          WRITE(6,*)
     &      '      Total phase-advance [nm] and corresponding photon energy [eV]:'
          WRITE(6,*)
     &      '      ',(AMPSHIFT(1)/2.0D0/DMYGAMMAP**2+HTRA2I)*1.0D9
     &      ,CLIGHT1*HPLANCK1/ECHARGE1/(AMPSHIFT(1)/2.0D0/DMYGAMMAP**2+HTRA2I)
          WRITE(6,*)
c          WRITE(6,*)
c     &      '*****>>>>      MYINUM has to be tuned,'
c          WRITE(6,*)
c     &      '      since phase advance is calculated from trajectory.'
c          WRITE(6,*)
c          CALL UTIL_WAIT_1
          IF (AMPRAN.NE.0.D0) THEN
            IF (ISOUR.EQ.1) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'      phase errors for repetition activated:'
              WRITE(LUNGFO,*)
     &          '      A -> A * (1 + exp(i*phi*xran1) + exp(i*2*phi*xran2)...'
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'      IAMPSEED: ',IAMPSEED
              WRITE(LUNGFO,*)
            ENDIF !ISOUR
            ALLOCATE(XRANA(-IAMPLI))
            IF (IAMPSEED.NE.0) CALL RMARIN(IAMPSEED,NTOTIN,NTOT2IN)
            CALL RNORML(XRANA,-IAMPLI,rr)
            RMS=0.0d0
            DO IREP=1,-IAMPLI
              XRANA(IREP)=AMPRAN*XRANA(IREP)
              RMS=RMS+XRANA(IREP)**2
            ENDDO
            RMS=SQRT(RMS/(-IAMPLI))
            WRITE(LUNGFO,*)
     &        '      rel. rms phase AMPRAN (input): ',SNGL(AMPRAN)
            WRITE(LUNGFO,*)
     &        '      rel. rms phase error 1. source (from generated errors): '
     &        ,SNGL(RMS)
          ENDIF   !(AMPRAN.NE.0.D0)
        ENDIF !IAMPLI

        DO ISOUR=1,NSOURCE

          IF (ISPECMODE.EQ.1.OR.ISPECMODE.EQ.2) THEN
            if (icluster.gt.0) goto 1357
+self,if=wsou.
            IF (ISPECMODE.EQ.2) THEN
              call sourcesteps(isour,ndwsou)
              ALLOCATE(WSOU(3,5,NDWSOU))
              nsadd=1
            endif
+self,if=-wsou.
            print*,'******************************************'
            print*,'CMZ-Selection wsou not active!!'
            print*,'******************************************'
+self. if=wsou.
            if (iundulator.ne.2) then
+self,if=omp.
              if (iomp.eq.0.or.(ipin.eq.0.and.mthreads.eq.0)) then
+self.
                CALL SOUINTALL(ISOUR)
+self,if=omp.
              else
                CALL SOUINTALL_omp(ISOUR)
              endif
+self.
            endif
+self,if=wsou.
            IF (ISPECMODE.EQ.2) THEN
              deALLOCATE(WSOU)
            endif
+self. if=wsou.
            GOTO 1357
          ENDIF !ISPECMODE

          IF (ISOUR.EQ.2) THEN
            WRITE(6,*)' '
            WRITE(6,*)'     sources done and time:'
            WRITE(6,*)' '
          ENDIF !NSOURCE

          DO IOBSV=1,NOBSV
            TBUFF(IOBSV)=0.0
          ENDDO   !IOBSV

          MSADD=0
          DO IBUFF=1,NBUFF

            IF (MSADD.EQ.1) THEN
              IF (AMPRAN.NE.0.D0.AND.IAMPLI.LT.0) THEN
                DEALLOCATE(XRANA)
              ENDIF   !(AMPRAN.NE.0.D0)
              GOTO 1357 !EXIT IBUFF LOOP
            ENDIF

            IF (IBUFF.EQ.NBUFF.OR.MSADD.EQ.-1) THEN
              NSADD=1
              MSADD=1
            ELSE
              NSADD=0
            ENDIF

            IF (ISPECMODE.EQ.3) THEN
              CALL TRACKS(ISOUR)   !TRACKING OF SOURCE
            ELSE IF (ISPECMODE.EQ.4) THEN
              CALL TRACKSOLD(ISOUR)   !TRACKING OF SOURCE
            ELSE
              PRINT*, '*** ERROR IN SPECTRUM: BAD ISPECMODE: ',ISPECMODE
              STOP '*** PROGRAMM WAVE ABORTED ***'
            ENDIF

            CALL SOUINT(ISOUR,IBUFF)   !INTEGRATION

            DO JC=1,1
              DO IC=1,3
C SOURCEA IS RECALCULATED IN SR TRACKS
                SOURCEE(IC,JC,ISOUR)=SOURCEA(IC,JC,ISOUR)+
     &            (SOURCEEO(IC,JC,ISOUR)-SOURCEAO(IC,JC,ISOUR))/NBUFF
              ENDDO
            ENDDO

            IF (SOURCEE(1,1,ISOUR).GT.SOURCEEO(1,1,ISOUR)) THEN

              DO JC=1,1
                DO IC=1,3
                  SOURCEE(IC,JC,ISOUR)=SOURCEEO(IC,JC,ISOUR)
                ENDDO
              ENDDO

              IF (MSADD.EQ.0) MSADD=-1

            ENDIF !(SOURCEE(1,1,ISOUR).GT.SOURCEEO(1,1,ISOUR))

            IF (MSADD.NE.1
     &          .AND.SOURCEA(1,1,ISOUR).GE.SOURCEE(1,1,ISOUR)) THEN
              WRITE(LUNGFO,*)'*** ERROR IN SPECTRUM:'
              WRITE(LUNGFO,*)'SOMETHING WRONG WITH SOURCE BUFFER'
              WRITE(LUNGFO,*)
     &          'CHANGE INTEGRATION BUFFER OR CHECK SOURCE CODE'
              WRITE(LUNGFO,*)
     &          'IBUFF,NBUFF,SOURCEA(1,1,ISOUR),SOURCEE(1,1,ISOUR)'
              WRITE(LUNGFO,*)IBUFF,NBUFF
              WRITE(LUNGFO,*)SOURCEA(1,1,ISOUR),SOURCEE(1,1,ISOUR)
              WRITE(6,*)'*** ERROR IN SPECTRUM:'
              WRITE(6,*)'SOMETHING WRONG WITH SOURCE BUFFER'
              WRITE(6,*)
     &          'CHANGE INTEGRATION BUFFER OR CHECK SOURCE CODE'
              WRITE(6,*)
     &          'IBUFF,NBUFF,SOURCEA(1,1,ISOUR),SOURCEE(1,1,ISOUR)'
              WRITE(6,*)IBUFF,NBUFF
              WRITE(6,*)SOURCEA(1,1,ISOUR),SOURCEE(1,1,ISOUR)
              STOP
            ENDIF

            ISOURO=ISOUR

          ENDDO   !IBUFF

1357    CONTINUE

        if (kampli.ne.0) then

          if (ibunch.eq.0) then
            nbunch=mbuncho
            neinbunch=meinbuncho
            ibunch=ibuncho
            ihbunch=ihbuncho
          endif

          if (ipin.eq.0) then
            call pinin ! to get pincen etc.
            nobsv=1
            nobsvz=1
            nobsvy=1
            icbrill=1
            obsv(:,1)=pincen(:)
          endif

          call amprep_omp

          pow_u=pow_u*1.0d6
          stokes_u=stokes_u*1.0d6

          fbunch_u(4:14,:)=fbunch_u(4:14,:)/1000.0d0
          fbunch_u(17:19,:)=fbunch_u(17:19,:)/1000.0d0
          fbunch_u(22:26,:)=fbunch_u(22:26,:)*1.0d3
          fbunch_u(30:41,:)=fbunch_u(30:41,:)*1.0d3
          arad_u=arad_u*1000.0d0

          specpow=pow_u
          spec(:)=stokes_u(1,:)
          stokes=stokes_u

          do iobsv=1,nobsv
            do ifr=1,nfreq
              iobfr=iobsv+nobsv*(ifr-1)
              reaima(1:3,1,iobfr)=dreal(arad_u(1:3,iobfr))
              reaima(1:3,2,iobfr)=dimag(arad_u(1:3,iobfr))
              reaima(6:8,1,iobfr)=dreal(arad_u(4:6,iobfr))
              reaima(6:8,2,iobfr)=dimag(arad_u(4:6,iobfr))
            enddo
          enddo

          if (ibunch.ne.0) then
            do i=1,nbunch*neinbunch*nfreq
              if (fbunch_u(21,i).ne.0.0d0) then
                call hfm(nidbunch,fbunch_u(:,i))
              endif
            enddo
          endif
        endif

        if (icluster.ne.0) then
          call wpamp
        endif

        IF (ISOUR.EQ.1.and.nsource.gt.1) THEN
          WRITE(6,*)' '
          WRITE(6,*)' '
          WRITE(6,*)' sources treated so far:'
          WRITE(6,*)' '
        ENDIF

c        CALL APHASE(ISOUR)

        IF (nsource.gt.1) THEN
          CALL date_and_time(dtday,dttime,dtzone,idatetime)

          WRITE(6,2000)ISOUR,NSOURCE,dttime(1:2),dttime(3:4),dttime(5:6)
2000      FORMAT(10X,I4,' of',I4,2X,A,':',A,':',A)
        ENDIF


      ENDDO !LOOP OVER SOURCES

      if (abs(ifold).eq.1) CALL AMPFOLD

C     CALL LIB$SHOW_TIMER

C RESTORE OLD VALUES

      NLPOI=NLPOIO

      IF(ISPECDIP.EQ.0.and.ipin.eq.0) THEN
        if (iundulator.eq.0) then
          CALL SPECDIPA  ! To calculate schwingercen for powgraz
        else
          DO ISOUR=1,NSOURCE
            do jc=1,nobsv
              DO IC=1,3
                schwingercen(IC,JC,ISOUR)=(SOURCEAO(IC,1,ISOUR)+
     &            SOURCEEO(IC,1,ISOUR))/2.0d0
              enddo
            enddo
          enddo
        endif
      ENDIF

      DO ISOUR=1,NSOURCE
CERR101292      DO JC=1,3
        DO JC=1,4
          DO IC=1,3
            SOURCEA(IC,JC,ISOUR)=SOURCEAO(IC,JC,ISOUR)
            SOURCEE(IC,JC,ISOUR)=SOURCEEO(IC,JC,ISOUR)
          ENDDO
        ENDDO
        IPOISOU(ISOUR)=IZTOT(ISOUR)
      ENDDO   !ISOUR

      ELSE IF(ISPECANA.NE.0)   THEN !ISPECANA

        CALL SPECANA      !USER SUPPLIED SPECTRUM
C                  !(E.G. FOR TESTING)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** MESSAGE SR SPECTRUM ***'
        WRITE(LUNGFO,*)
     &    'FLUX OVERWRITTEN BY SR SPECANA (FLAG ISPECANA)'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)

      ELSE IF(IDESYNC.NE.0)   THEN !ISPECANA

        CALL SYNC_SPEC      !SPECTRUM FROM PROGRAM DESYNC

      ELSE IF(ISPECDIP.GT.0)   THEN !ISPECANA

        CALL SPECDIP  !DIPOL SPECTRUM ACCORDING TO BESSEL FUNCTIONS

      ELSE IF(ISPECDIP.LT.0)   THEN !ISPECANA

        CALL SPECDIPA  !DIPOL SPECTRUM ACCORDING TO BESSEL FUNCTIONS FOR
                       !GIVEN SOURCES
      ELSE

        IF (IRFILSP0.NE.0) CALL RFILSP0
        IF (IRFILSTO.NE.0) CALL RFILSTO

      ENDIF !ISPECANA

C }CHANGE FROM CYLINDRICAL TO CARTHESIAN GRID

      IF (IAMPLI.gt.0.or.iamprep.lt.0) CALL ADDAMPLI
      IF (IAMPLI.LT.0) THEN
        FACAMPLI=-IAMPLI
      ELSE
        FACAMPLI=1.D0
      ENDIF

C END OF RAW SPECTRUM CALCULATION

      IF (IABEND.EQ.6) then
        iroottrees=0
        RETURN
      endif

C--- TAKE FILTER INTO ACCOUNT

      IF (IFILTER.GT.0) THEN
        IF (IFILMUL.EQ.0) THEN
          CALL FILTER !ARRAY SPEC IS OVERWRITTEN
        ELSE
          ABSMUTOT=0.0D0
          OPEN(UNIT=LUNAM,FILE=FILEAM,STATUS='OLD')
          DO I=1,IFILMUL
            READ(LUNAM,*)ABSTHI,FILEABS
            CALL FILTER !ARRAY SPEC IS OVERWRITTEN
            ABSMUTOT=ABSMUTOT+ABSMU
          ENDDO !IFILMUL
          CLOSE(LUNAM)
        ENDIF !IFILTER

      ENDIF !IFILTER

C--- TAKE PHOTO YIELD INTO ACCOUNT

      IF (IEFFI.NE.0) THEN
        CALL EFFI !ARRAY SPEC IS OVERWRITTEN
      ENDIF !IEFFI

C--- LOOP OVER ALL SOURCES, ADD UP CONTRIBUTIONS OF EVALUATED INTEGRALS

      if (iomp.eq.0) CALL SOUADD

C--- FLUX TRHOUGH PINHOLE

      IF(IPINo.GT.0) THEN

        print*
        call zeit(6)
        print*,"     Start integration over pinhole"

+self,if=omp.
        if (iomp.eq.0) then
+self.

          DO IFREQ=1,NFREQ

            IF(IPIN.NE.2.and.ipin.ne.3) THEN !SPECTOT IN SOUADD CALCULATED

              DO IY=1,NOBSVY
                DO IZ=1,NOBSVZ
                  IOBSV=(IY-1)*NOBSVZ+IZ
                  SPECTOT(IOBSV+NOBSV*(IFREQ-1))=0.0D0
                ENDDO   !IZ
              ENDDO   !IY

            ENDIF !IPIN.NE.2

            WFLUXT(IFREQ)=0.0

            DO ISOUR=1,NSOURCE

              IF(IPIN.NE.2.and.ipin.ne.3) THEN

C--- SPLINE INTERPOLATION INSIDE PINHOLE

                IF (IUSEM.EQ.0) THEN
                  IF (IPINCIRC.EQ.0.OR.IPINCIRC*IRPHI.NE.0)
     &              CALL PSPLINE(ISOUR,IFREQ)
                ENDIF

C--- INTEGRATION OF FLUX IN PINHOLE (BLENDE)

                IF (IUSEM.EQ.0) THEN

c                if (isour.eq.1.and.ifreq.eq.1) then
c                  caLL Zeit(6)
c                  print*,"     Starting integration over pinhole"
c                endif

                  CALL BLENDE(ISOUR,IFREQ)
                  IF(ISOUR.EQ.NSOURCE.AND.ISTOKES.NE.0) then
                    CALL BLENSTO(IFREQ)
                  endif

                ELSE

                  ICONV=0
                  IF (IPINCIRC.EQ.0) THEN
                    IFLUSS=1
                  ELSE  !IPINCIRC
                    IFLUSS=2
                  ENDIF !IPINCIRC
                  CALL USMCON2

                ENDIF

                DO IY=1,NOBSVY
                  DO IZ=1,NOBSVZ
                    IOBSV=(IY-1)*NOBSVZ+IZ
                    IOBFR=IOBSV+NOBSV*(IFREQ-1)
                    SPECTOT(IOBFR)=SPECTOT(IOBFR)+
     &                SPEC(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))
                  ENDDO   !IZ
                ENDDO   !IY

              else if (ipin.eq.3) then

                CALL BLENDE(ISOUR,IFREQ)
                IF(ISOUR.EQ.NSOURCE.AND.ISTOKES.NE.0)
     &            CALL BLENSTO(IFREQ)
              ENDIF !(IPIN.GT.0)

              WFLUXT(IFREQ)=WFLUXT(IFREQ)+WFLUX(ISOUR+NSOURCE*(IFREQ-1))

            ENDDO !NSOURCE
          ENDDO !IFREQ

+self,if=omp.
        else !if (iomp.eq.0) then

c          if (ipincirc.eq.0) then
            call blendfreq_omp
c          else
c            call blendcircfreq_omp
c          endif

          if (istokes.ne.0) then
            call blenstofreq_omp
          endif

        endif !iomp
+self.

C--- FOLD INTENSITY DISTRIBUTIONS

        IF (IFOLD.NE.0.AND.IFOLD.NE.2) THEN
          print*,""
          call zeit(6)
          print*,"     Starting folding procedure"
          IF (IUSEM.EQ.0) THEN
            ALLOCATE(COFOLD(4,4,NOBSV))
c            caLL Zeit(6)
c            print*,"     Starting folding procedure"
            IF (IFOLD.EQ.-2) ALLOCATE(SPCOEFU(3,NOBSV))
            IF (ABS(IFOLD).EQ.1) then
+self,if=omp.
              if (iomp.eq.0) then
+self.
                CALL WFOLD
                IF (ISTOKES.NE.0) CALL WFOLDSTO
+self,if=omp.
              else
                call wfold_omp
                IF (ISTOKES.NE.0) then
                  CALL WFOLDSTO_omp
                endif
              endif
+self.,if=omp.
            endif
            call powfold
          ELSE !IUSEM
            ICONV=0
            IFLUSS=0
            IF (ISPECANAF.NE.0) THEN
              CALL SPECANAF
            ENDIF
            CALL USMCON2
          ENDIF !IUSEM
        ENDIF !IFOLD

      print*
      call zeit(6)
      print*,"     Finished integration over pinhole"

      ENDIF !IPIN

C--- INTEGRATE SPECTRUM OVER ALL FREQUENCIES

      IF (ISPECINT.NE.0) THEN
        CALL SPECINT
        IF (IFOLD.NE.0) CALL SPECINTF
        IF (IPIN.NE.0) THEN
          CALL CRIFREQ
        ELSE
          CALL CRIFREQS(1)
        ENDIF
      ENDIF

C--- CONVERT FREQUENCES FROM ELECTRONVOLT TO NANOMETER

C260194  IF (IUNIT.EQ.1) CALL CONVUN

      IF (ISTOKES.NE.0) THEN
        ICEN=ICBRILL
        DO IFREQ=1,NFREQ
          DO IC=1,4
            STOKEC(IC,IFREQ)=STOKES(IC,ICEN+NOBSV*(IFREQ-1))
          ENDDO !IC
        ENDDO !NFREQ
      ENDIF !ISTOKES

      IF (ISTOKES.NE.0.AND.IFOLD.NE.0) THEN
        ICEN=ICBRILL
        DO IFREQ=1,NFREQ
          DO IC=1,4
            STOKECF(IC,IFREQ)=STOKESF(IC,ICEN+NOBSV*(IFREQ-1))
          ENDDO !NOBSV
        ENDDO !NFREQ
      ENDIF !ISTOKES

C--- WRITE RESULTS TO FILE

c      print*
c      call zeit(6)
c      print*,"     Writing results to files"

      IF (ISPECDIP.EQ.0) THEN

        WRITE (LUNGFO,*)
        WRITE (LUNGFO,*)
     &'     Source number, mean mag. field (sign from By), abs. mean and rel. rms'
        WRITE (LUNGFO,*)
     &'     for sources, and critical photon energy [eV] or wavelength [nm]'
        WRITE (LUNGFO,*)
     &    '     (with respect to abs. mean):'
        WRITE (LUNGFO,*)

        DO ISOUR=1,NSOURCE
          WRITE (LUNGFO,*)ISOUR
     &      ,SNGL(ECSOUR(4,ISOUR))
     &      ,SNGL(ECSOUR(1,ISOUR))
     &      ,SNGL(ECSOUR(3,ISOUR))
     &      ,SNGL(ECSOUR(2,ISOUR))
        ENDDO !ISOUR

        WRITE (LUNGFO,*)
        WRITE (LUNGFO,*)'     Photon energy cut-off (SPECCUT):',SNGL(SPECCUT)
        WRITE (LUNGFO,*)
        WRITE (LUNGFO,*)
     &    '     Max. field and photon energy cuts for source points:'
        WRITE (LUNGFO,*)
        DO ISOUR=1,NSOURCE
          WRITE (LUNGFO,*)ISOUR
     &      ,SNGL(ECMAX(ISOUR))
     &      ,SNGL(SPECCUT*ecdipev1*DMYENERGY**2*ECMAX(ISOUR))
        ENDDO !ISOUR

      ENDIF !ISPECDIP

      IF(IPIN*ISPECINT.NE.0) THEN

        WRITE (LUNGFO,*)
        WRITE (LUNGFO,*)
     &    '     Critical photon energy or wavelength of calculated flux through'

        IF (IFOLD.NE.0) THEN

          IF (IUNIT.EQ.0)
     &      WRITE (LUNGFO,*)'     pinhole (raw and folded):'
     &      ,SNGL(FREQC),SNGL(FREQCF)
          IF (IUNIT.NE.0)
     &      WRITE (LUNGFO,*)'     pinhole (raw and folded):'
     &      ,SNGL(WELLENC),SNGL(WELLENCF)

        ELSE  !IFOLD

          IF (IUNIT.EQ.0)
     &      WRITE (LUNGFO,*)'     pinhole:',SNGL(FREQC)
          IF (IUNIT.NE.0)
     &      WRITE (LUNGFO,*)'     pinhole:',SNGL(WELLENC)
        ENDIF !IFOLD

        WRITE (LUNGFO,*)

        WRITE (LUNGFO,*)

      ENDIF !IPIN*ISPECINT

      IF(IWFILSP0.NE.0) THEN

        OPEN(UNIT=LUNSP0,FILE=FILESP0)

        WRITE(LUNSP0,*)ICODE,' ',CODE
        WRITE(LUNSP0,*)
        WRITE(LUNSP0,*)NSOURCE,NOBSV,NFREQ,IFREQ2P
        WRITE(LUNSP0,*)NOBSVZ,NOBSVY,MOBSVZ,MOBSVY
        WRITE(LUNSP0,*)MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY
        WRITE(LUNSP0,*)
        WRITE(LUNSP0,*)PINW,PINH,PINR
        WRITE(LUNSP0,*)OBSVDZ,OBSVDY
        WRITE(LUNSP0,*)

        WRITE(LUNSP0,*)(OBSVZ(IO),IO=1,NOBSVZ)
        WRITE(LUNSP0,*)
        WRITE(LUNSP0,*)(OBSVY(IO),IO=1,NOBSVY)
        WRITE(LUNSP0,*)

        DO IO=1,NOBSV
          WRITE(LUNSP0,*)(OBSV(IX,IO),IX=1,3)
          DO IFR=1,NFREQ
            IF (IUNIT.EQ.0) THEN !260194
              WRITE(LUNSP0,*)FREQ(IFR),
     &          (SPEC(IS+NSOURCE*(IO-1+NOBSV*(IFR-1))),IS=1,NSOURCE)
     &          ,SPECTOT(IO+NOBSV*(IFR-1))
            ELSE !IUNIT
              WRITE(LUNSP0,*)WELLEN(IFR),
     &          (SPEC(IS+NSOURCE*(IO-1+NOBSV*(IFR-1))),IS=1,NSOURCE)
     &          ,SPECTOT(IO+NOBSV*(IFR-1))
            ENDIF !IUNIT
          ENDDO !NFREQ
        ENDDO !NOBSV

        CLOSE(LUNSP0)

      ENDIF !IWFILSP0

      IF(IPHASEANA.NE.0) THEN
        CALL PHASEANA
      ENDIF !(IPHASEANA.NE.0)

      IF(IPHASE.NE.0) THEN
c        if (mthreads.eq.0) then
c          CALL PHASE
c        else
          CALL PHASE_omp
c        endif
      ENDIF !(IPHASE.NE.0)

      IF(IWFILRAY.NE.0) THEN

        OPEN(UNIT=LUNRAY,FILE=FILERAY,STATUS='NEW')

        WRITE(LUNRAY,*)MOBSVZ,MOBSVY,ICODE,SNGL(FREQ(1)),' WAVE'

        DRAY=PINCEN(1)
        DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
          YRAY=OBSVY(IY)
          THERAY=ATAN(YRAY/DRAY)*10000. !*10000 mm
          DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
            IO=(IY-1)*NOBSVZ+IZ
            ZRAY=OBSVZ(IZ)
            PHIRAY=ATAN(ZRAY/DRAY)*10000.

            RAY=STOKES(1,IO)
     &        /DMYCUR*0.1
     &        /BANWID*0.001
     &        *OBSVDZ*OBSVDY
            RAY1=STOKES(2,IO)
     &        /DMYCUR*0.1
     &        /BANWID*0.001
     &        *OBSVDZ*OBSVDY
            RAY2=STOKES(3,IO)
     &        /DMYCUR*0.1
     &        /BANWID*0.001
     &        *OBSVDZ*OBSVDY
            RAY3=STOKES(4,IO)
     &        /DMYCUR*0.1
     &        /BANWID*0.001
     &        *OBSVDZ*OBSVDY

            IF (RAY.NE.0.0) THEN
              RAY1N=RAY1/RAY
              RAY2N=RAY2/RAY
              RAY3N=RAY3/RAY
            ELSE
              RAY1N=0.0
              RAY2N=0.0
              RAY3N=0.0
            ENDIF   !RAY

C     RAY/PHIRAY/THERAY IS NUMBER OF PHOTONS PER mm**2 PER sec PER 0.001BW
C     PER 100mA IN 10m DISTANCE !?; COORDINATES VALUES IN mm ON FILE

C ABSPRACHE MIT FRANZ            WRITE(LUNRAY,7788) PHIRAY,THERAY,RAY,-RAY1N,RAY2N,RAY3N
      WRITE(LUNRAY,7788) PHIRAY,THERAY,RAY,RAY1N,RAY2N,RAY3N
7788        FORMAT(6(1PE12.4))

          ENDDO !IZ
        ENDDO !IY

        CLOSE(LUNRAY)

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     Data-file written for program RAY'
        WRITE(LUNGFO,*)'     File: ',FILERAY
        WRITE(LUNGFO,*)'     (Device center is assumed at (0,0,0)'
        IF (IUNIT.EQ.0) THEN !260194
          WRITE(LUNGFO,*)'     Photon energy:',SNGL(FREQ(1))
        ELSE
          WRITE(LUNGFO,*)'     Photon energy:',SNGL(WELLEN(1))
        ENDIF
        WRITE(LUNGFO,*)

        WRITE(6,*)
        WRITE(6,*)'     Data-file written for program RAY'
        WRITE(6,*)'     File: ',FILERAY
        WRITE(6,*)'     (Device center is assumed at (0,0,0)'
        IF (IUNIT.EQ.0) THEN !260194
          WRITE(6,*)'     Photon energy:',SNGL(FREQ(1))
        ELSE
          WRITE(6,*)'     Photon energy:',SNGL(WELLEN(1))
        ENDIF
        WRITE(6,*)

      ENDIF !IWFILRAY

      IF(IWFILSTO.NE.0.AND.ISTOKES.NE.0) THEN

        OPEN(UNIT=LUNSTO,FILE=FILESTO)

        WRITE(LUNSTO,*)ICODE,' ',CODE
        WRITE(LUNSTO,*)
        WRITE(LUNSTO,*)NSOURCE,NOBSV,NFREQ,IFREQ2P
        WRITE(LUNSTO,*)NOBSVZ,NOBSVY,MOBSVZ,MOBSVY
        WRITE(LUNSTO,*)MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY
        WRITE(LUNSTO,*)
        WRITE(LUNSTO,*)PINW,PINH,PINR
        WRITE(LUNSTO,*)OBSVDZ,OBSVDY
        WRITE(LUNSTO,*)

        WRITE(LUNSTO,*)(OBSVZ(IO),IO=1,NOBSVZ)
        WRITE(LUNSTO,*)
        WRITE(LUNSTO,*)(OBSVY(IO),IO=1,NOBSVY)
        WRITE(LUNSTO,*)

        DO IO=1,NOBSV
          WRITE(LUNSTO,*)(OBSV(IX,IO),IX=1,3)
          DO IFR=1,NFREQ
            IF (IUNIT.EQ.0) THEN !260194
              IOBFR=IO+NOBSV*(IFR-1)
              WRITE(LUNSTO,*)FREQ(IFR),(STOKES(IS,IOBFR),IS=1,4)
            ELSE
              WRITE(LUNSTO,*)WELLEN(IFR),(STOKES(IS,IOBFR),IS=1,4)
            ENDIF
          ENDDO !NFREQ
        ENDDO !NOBSV

        CLOSE(LUNSTO)

      ENDIF !IWFILSTO

      IF(IFOLD.NE.0 .AND. IWFILSPF.NE.0) THEN

        OPEN(UNIT=LUNSPF,FILE=FILESPF)

        WRITE(LUNSPF,*)ICODE,' ',CODE
        WRITE(LUNSPF,*)
        WRITE(LUNSPF,*)NSOURCE,NOBSV,NFREQ
        WRITE(LUNSPF,*)NOBSVZ,NOBSVY,MOBSVZ,MOBSVY
        WRITE(LUNSPF,*)MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY
        WRITE(LUNSPF,*)
        WRITE(LUNSPF,*)PINW,PINH,PINR
        WRITE(LUNSPF,*)OBSVDZ,OBSVDY
        WRITE(LUNSPF,*)

        WRITE(LUNSPF,*)(OBSVZ(IO),IO=1,NOBSVZ)
        WRITE(LUNSPF,*)
        WRITE(LUNSPF,*)(OBSVY(IO),IO=1,NOBSVY)
        WRITE(LUNSPF,*)

        DO IO=1,NOBSV
          WRITE(LUNSPF,*)(OBSV(IX,IO),IX=1,3)
          DO IFR=1,NFREQ
            IF (IUNIT.EQ.0) WRITE(LUNSPF,*)FREQ(IFR)
     &        ,(SPECF(IS+NSOURCE*(IO-1+NOBSV*(IFR-1))),IS=1,NSOURCE)
     &        ,SPECTOTF(IO+NOBSV*(IFR-1))
            IF (IUNIT.NE.0) WRITE(LUNSPF,*)WELLEN(IFR)
     &        ,(SPECF(IS+NSOURCE*(IO-1+NOBSV*(IFR-1))),IS=1,NSOURCE)
     &        ,SPECTOTF(IO+NOBSV*(IFR-1))
          ENDDO !NFREQ
        ENDDO !NOBSV

        CLOSE(LUNSPF)

      ENDIF !IWFILSPF

      IF(istokes.ne.0.and.IFOLD.NE.0 .AND. IWFLSTOF.NE.0) THEN

        OPEN(UNIT=LUNSTOF,FILE=FILESTOF)

        WRITE(LUNSTOF,*)ICODE,' ',CODE
        WRITE(LUNSTOF,*)
        WRITE(LUNSTOF,*)NSOURCE,NOBSV,NFREQ,IFREQ2P
        WRITE(LUNSTOF,*)NOBSVZ,NOBSVY,MOBSVZ,MOBSVY
        WRITE(LUNSTOF,*)MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY
        WRITE(LUNSTOF,*)
        WRITE(LUNSTOF,*)PINW,PINH,PINR
        WRITE(LUNSTOF,*)OBSVDZ,OBSVDY
        WRITE(LUNSTOF,*)

        WRITE(LUNSTOF,*)(OBSVZ(IO),IO=1,NOBSVZ)
        WRITE(LUNSTOF,*)
        WRITE(LUNSTOF,*)(OBSVY(IO),IO=1,NOBSVY)
        WRITE(LUNSTOF,*)

        DO IO=1,NOBSV
          WRITE(LUNSTOF,*)(OBSV(IX,IO),IX=1,3)
          DO IFR=1,NFREQ
            IF (IUNIT.EQ.0)  !260194
     &        WRITE(LUNSTOF,*)FREQ(IFR),(STOKESF(IS,IO+NOBSV*(IFR-1)),IS=1,4)
            IF (IUNIT.NE.0)
     &        WRITE(LUNSTOF,*)WELLEN(IFR),(STOKESF(IS,IO+NOBSV*(IFR-1)),IS=1,4)
          ENDDO !NFREQ
        ENDDO !NOBSV

        CLOSE(LUNSTOF)

      ENDIF !IWFLSTOF

C--- OUTPUT RESULTS

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Results of spectrum calculations'
      WRITE(LUNGFO,*)'     ================================'
      WRITE(LUNGFO,*)
      IF (IPOLA.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     Photons are polarized parallely to complex vector VPOLA:'
        DO IC=1,3
          WRITE(LUNGFO,*)'     ',CMPLX(VPOLA(IC))
        ENDDO
        WRITE(LUNGFO,*)
      ENDIF !IPOLA

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Reflectivity coefficients (complex):'
      WRITE(LUNGFO,*)
      DO IC=1,3
        WRITE(LUNGFO,*)'     ',CONJG(REFLEC(IC))
      ENDDO
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

      IF (ISPECMODE.EQ.3.OR.ISPECMODE.EQ.4) THEN
        WRITE(LUNGFO,*)
     &    '     Buffer size for integration (NDWSOU):',NDWSOU
        WRITE(LUNGFO,*)
      ENDIF

      IF (ISPECMODE.EQ.3.OR.ISPECMODE.EQ.4) THEN
        WRITE(LUNGFO,*)
     &    '     Provided number of integration steps for each source'
        WRITE(LUNGFO,*)
     &    '     (controlled by NLPOI)'
        WRITE(LUNGFO,*)
     &    '     (not necessarily used)'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)(IPOISOU(IS),IS=1,NSOURCE)
      ENDIF

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Bandwidth:',SNGL(BANWID)
      WRITE(LUNGFO,*)

      IF(IPIN.EQ.0) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)

        WRITE(LUNGFO,*)
     &    '     Photon energy [eV] or wavelength [nm] for all observation'
        WRITE(LUNGFO,*)
     &    '     points, flux per unit area [m**2] for each source,'
        WRITE(LUNGFO,*)
     &    '     total flux density:'
        WRITE(LUNGFO,*)

        WRITE(LUNGFO,*)

        if (iundulator.eq.0) call powgraz

        DO IO=1,NOBSV

          WRITE(LUNGFO,*)'          Observation point (x,y,z) [m]:'
          WRITE(LUNGFO,*)'          ',(SNGL(OBSV(IX,IO)),IX=1,3)

          IF ((ISPECMODE.EQ.3.OR.ISPECMODE.EQ.4).AND.ISPECDIP.EQ.0
     &        .and.ispecana.eq.0) THEN
            WRITE(LUNGFO,*)
     &        '          Number of integration steps for each source:'
            WRITE(LUNGFO,*)
     &        '                 (controlled by NLPOI)'
            WRITE(LUNGFO,*)'          ',(NARGUM(IO,IS),IS=1,NSOURCE)
          ENDIF

          WRITE(LUNGFO,*)
          DO IFR=1,NFREQ
            IF (IUNIT.EQ.0)  !260194
     &        WRITE(LUNGFO,*)'  ',SNGL(FREQ(IFR))
     &        ,(SNGL(SPEC(IS+NSOURCE*(IO-1+NOBSV*(IFR-1)))),IS=1,NSOURCE)
     &        ,SNGL(SPECTOT(IO+NOBSV*(IFR-1)))
            IF (IUNIT.NE.0)  !260194
     &        WRITE(LUNGFO,*)'  ',SNGL(WELLEN(IFR))
     &        ,(SNGL(SPEC(IS+NSOURCE*(IO-1+NOBSV*(IFR-1)))),IS=1,NSOURCE)
     &        ,SNGL(SPECTOT(IO+NOBSV*(IFR-1)))
          ENDDO !IFR


C maximum of spectot{

          IF (NFREQ.GT.1) THEN

            DO IFR=1,NFREQ
              SPECBUFF(IFR)=SPECTOT(IO+NOBSV*(IFR-1))
            ENDDO !IFR

            CALL UTIL_MAX_PARABEL
     &        (NFREQ,FREQ,SPECBUFF,SPECTOTMX(3),SPECTOTMX(4)
     &        ,WSNOBFR1,WSNOBFR2,IFAIL)

            IF (IFAIL.NE.0) THEN
              WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED'
              WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
            ENDIF

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Estimated maximum:'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     ',SNGL(SPECTOTMX(3)),SNGL(SPECTOTMX(4))
            WRITE(LUNGFO,*)

          ENDIF   !NFREQ

C maximum of spectot}

      IF (IFOLD.EQ.2) THEN

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)

          WRITE(LUNGFO,*)
     &      '     flux per unit area [m**2] for each source,'
          WRITE(LUNGFO,*)
     &      '     total flux density with emittance:'
          WRITE(LUNGFO,*)

          WRITE(LUNGFO,*)
          DO IFR=1,NFREQ
            SPECTOTF(IO+NOBSV*(IFR-1))=0.0D0
            DO IS=1,NSOURCE
              SPECTOTF(IO+NOBSV*(IFR-1))=
     &          SPECTOTF(IO+NOBSV*(IFR-1))+
     &          SPECF(IS+NSOURCE*(IO-1+NOBSV*(IFR-1)))
            ENDDO
            IF (IUNIT.EQ.0)  !260194
     &        WRITE(LUNGFO,*)'  ',SNGL(FREQ(IFR))
     &        ,(SNGL(SPECF(IS+NSOURCE*(IO-1+NOBSV*(IFR-1)))),IS=1,NSOURCE)
     &        ,SNGL(SPECTOTF(IO+NOBSV*(IFR-1)))
            IF (IUNIT.NE.0)  !260194
     &        WRITE(LUNGFO,*)'  ',SNGL(WELLEN(IFR))
     &        ,(SNGL(SPECF(IS+NSOURCE*(IO-1+NOBSV*(IFR-1)))),IS=1,NSOURCE)
     &        ,SNGL(SPECTOTF(IO+NOBSV*(IFR-1)))
          ENDDO !IFR

C maximum of spectot{

          IF (NFREQ.GT.1) THEN

            DO IFR=1,NFREQ
              SPECBUFF(IFR)=SPECTOTF(IO+NOBSV*(IFR-1))
            ENDDO !IFR

            CALL UTIL_MAX_PARABEL
     &        (NFREQ,FREQ,SPECBUFF,SPECTOTMX(3),SPECTOTMX(4)
     &        ,WSNOBFR1,WSNOBFR2,IFAIL)

            IF (IFAIL.NE.0) THEN
              WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED'
              WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
            ENDIF

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Estimated maximum:'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     ',SNGL(SPECTOTMX(3)),SNGL(SPECTOTMX(4))
            WRITE(LUNGFO,*)

          ENDIF   !NFREQ

        ENDIF !IFOLD.EQ.2

C maximum of spectot}

        WRITE(LUNGFO,*)' '

        WRITE(LUNGFO,*)' '
        WRITE(LUNGFO,*)
     &    '     Power density at selected point [W/m**2]:'
        WRITE(LUNGFO,*)

        if (nsource.le.5) then

          WRITE(LUNGFO,*)
     &      '     (for all sources,sum, and sum grazing)'
          IF (IAMPLI.GT.0) THEN
            WRITE(LUNGFO,*)
     &        '     (Option IAMPLI not taken into account!!)'
          ENDIF   !IAMPLI

          WRITE(LUNGFO,*)'   '
     &      ,(SNGL(SPECPOW(IS+NSOURCE*(IO-1))),IS=1,NSOURCE)
     &      ,SNGL(SPECPOWT(IO))
     &      ,SNGL(SPECPOWTgraz(IO))
        else

          WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'

          IF (IAMPLI.GT.0) THEN
            WRITE(LUNGFO,*)
     &        '     (Option IAMPLI not taken into account!!)'
          ENDIF   !IAMPLI

          WRITE(LUNGFO,*)'   '
     &      ,(SNGL(SPECPOW(IS+NSOURCE*(IO-1))),IS=1,2)
     &      ,SNGL(SPECPOW(IS+(NSOURCE/2+1)*(IO-1)))
     &      ,(SNGL(SPECPOW(IS+NSOURCE*(IO-1))),IS=NSOURCE-1,NSOURCE)
     &      ,SNGL(SPECPOWT(IO))
     &      ,SNGL(SPECPOWTgraz(IO))
        endif

        WRITE(LUNGFO,*)' '

        if (ifold.ne.0) then
          WRITE(LUNGFO,*)' '
          WRITE(LUNGFO,*)
     &      '     Power density with emittance at selected point [W/m**2]:'
          WRITE(LUNGFO,*)
          if (nsource.le.5) then
            WRITE(LUNGFO,*)
     &        '     (for all sources and sum)'
            IF (IAMPLI.GT.0) THEN
              WRITE(LUNGFO,*)
     &          '     (Option IAMPLI not taken into account!!)'
            ENDIF !IAMPLI

            WRITE(LUNGFO,*)'   '
     &        ,(SNGL(SPECPOWf(IS+NSOURCE*(IO-1))),IS=1,NSOURCE)
     &        ,SNGL(SPECPOWTf(IO))
          else
            WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
            IF (IAMPLI.GT.0) THEN
              WRITE(LUNGFO,*)
     &          '     (Option IAMPLI not taken into account!!)'
            ENDIF !IAMPLI

            WRITE(LUNGFO,*)'   '
     &        ,(SNGL(SPECPOWf(IS+NSOURCE*(IO-1))),IS=1,2)
     &        ,SNGL(SPECPOWf(IS+(NSOURCE/2+1)*(IO-1)))
     &        ,(SNGL(SPECPOWf(IS+NSOURCE*(IO-1))),IS=NSOURCE-1,NSOURCE)
     &        ,SNGL(SPECPOWTf(IO))
          endif
          WRITE(LUNGFO,*)' '
        endif !(ifold.ne.0) then

c          IF (IAMPLI.LT.0) THEN
c            WRITE(LUNGFO,*)'     scaled according to IAMPLI:'
c            WRITE(LUNGFO,*)'            '
c     &        ,(SNGL(SPECPOW(IS+NSOURCE*(IO-1))*(-IAMPLI)),IS=1,NSOURCE)
c     &        ,SNGL(SPECPOWT(IO)*(-IAMPLI))
c            WRITE(LUNGFO,*)' '
c          ENDIF  !IAMPLI

          IF (ISPECINT.NE.0) THEN

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '     Power density [W/m**2]:'
            WRITE(LUNGFO,*)
     &        '     (by integration over spectral range:',
     &        SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','

            if (nsource.le.5) then

              WRITE(LUNGFO,*)
     &          '     for all sources and sum)'
              WRITE(LUNGFO,*)'   '
     &          ,(SNGL(SPECI(IS+NSOURCE*(IO-1))),IS=1,NSOURCE)
     &          ,SNGL(SPECTOTI(IO))

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          '     Divided by total power density:'
              WRITE(LUNGFO,*)'   '
     &          ,(SNGL(SPECI(IS+NSOURCE*(IO-1))/SPECPOW(IS+NSOURCE*(IO-1))),
     &          IS=1,NSOURCE)
     &          ,SNGL(SPECTOTI(IO)/SPECPOWT(IO))

            else

              WRITE(LUNGFO,*)
     &    '     for the first two, the central, and the last sources and sum)'
              WRITE(LUNGFO,*)
     &          '   '
     &          ,(SNGL(SPECI(IS+NSOURCE*(IO-1))),IS=1,2)
     &          ,SNGL(SPECI(IS+(NSOURCE/2+1)*(IO-1)))
     &          ,(SNGL(SPECI(IS+NSOURCE*(IO-1))),IS=nsource-1,NSOURCE)
     &          ,SNGL(SPECTOTI(IO))

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          '     Divided by total power density:'
              WRITE(LUNGFO,*)'   '
     &          ,(SNGL(SPECI(IS+NSOURCE*(IO-1))/SPECPOW(IS+NSOURCE*(IO-1))),
     &          IS=1,2)
     &          ,SNGL(SPECI(IS+(NSOURCE/2+1)*(IO-1))/
     &          SPECPOW(IS+(NSOURCE/2+1)*(IO-1)))
     &          ,(SNGL(SPECI(IS+NSOURCE*(IO-1))/SPECPOW(IS+NSOURCE*(IO-1))),
     &          IS=nsource-1,NSOURCE)
     &          ,SNGL(SPECTOTI(IO)/SPECPOWT(IO))

            endif

            WRITE(LUNGFO,*)

            WRITE (LUNGFO,*)
            WRITE (LUNGFO,*)
     &        '     Critical photon energy or wavelength of calculated flux density'

            IF (IUNIT.EQ.0)
     &        WRITE (LUNGFO,*)'     first observation point:',SNGL(FREQC)
            IF (IUNIT.NE.0)
     &        WRITE (LUNGFO,*)'     first observation point:',SNGL(WELLENC)
            WRITE (LUNGFO,*)

            WRITE(LUNGFO,*)
     &        '     Total number of photons per second at critical energy'
            WRITE(LUNGFO,*)
     &        '     for first observation point:'
            WRITE(LUNGFO,*)'            ',
     &        SNGL(SNGL(SPECTOTI(1))/FREQC/ECHARGE1)

            IF (IDESYNC.NE.0) THEN

              WRITE(LUNGFO,*)
     &          '     Power density at selected point [W/m**2] * AREAM2:'
              WRITE(LUNGFO,*)
     &          '     (by integration over spectral range:',
     &          SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','
              if (nsource.le.5) then
                WRITE(LUNGFO,*)
     &            '     for all sources and sum)'
                WRITE(LUNGFO,*)'   '
     &            ,(SNGL(SPECI(IS+NSOURCE*(IO-1))*AREAM2),IS=1,NSOURCE)
     &            ,SNGL(SPECTOTI(IO)*AREAM2)
              else
                WRITE(LUNGFO,*)'     for the first two, the central, and the last sources and sum)'
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'   '
     &            ,(SNGL(SPECI(IS+NSOURCE*(IO-1))*AREAM2),IS=1,2)
     &            ,(SNGL(SPECI(IS+(NSOURCE/2+1)*(IO-1))*AREAM2))
     &            ,(SNGL(SPECI(IS+NSOURCE*(IO-1))*AREAM2),IS=nsource-1,NSOURCE)
     &            ,SNGL(SPECTOTI(IO)*AREAM2)
              endif
            ENDIF !IDESYNC
            WRITE(LUNGFO,*)

        IF (IDOSE.NE.0) THEN

          WRITE(LUNGFO,*)" "
          WRITE(LUNGFO,*)"     *** CAUTION: THE DOSE CALCULATIONS ARE NOT MEANT FOR RADITATION SAFETY PRUPOSES OR MEDICAL APPLICATIONS ***"
          WRITE(LUNGFO,*)" "

          WRITE(LUNGFO,*)
     &      '     Absorbed energy dose rate [Gy/sec]:',SNGL(ENEDOS(IO))
          WRITE(LUNGFO,*)
     &      '     Absorbed energy dose rate [mGy/h]:',SNGL(ENEDOS(IO)
     &      *1000.*3600)
          WRITE(LUNGFO,*)
     &      '     Absorbed energy dose rate [mGy/6000h]:',SNGL(ENEDOS(IO)
     &      *1000.*3600*6000)
           WRITE(LUNGFO,*)

          IF (IO.EQ.NOBSV) THEN
            ENEDOSMX=-1.D30
            DO IOBSV=1,NOBSV
              IF (ENEDOS(IOBSV).GT.ENEDOSMX) ENEDOSMX=ENEDOS(IOBSV)
            ENDDO
            WRITE(LUNGFO,*)
     &        '     Maximum absorbed energy dose rate [Gy/sec]:',SNGL(ENEDOSMX)
            WRITE(LUNGFO,*)
     &        '     Maximum absorbed energy dose rate [mGy/h]:',SNGL(ENEDOSMX
     &        *1000.*3600)
            WRITE(LUNGFO,*)
     &        '     Maximum absorbed energy dose rate [mGy/6000h]:',SNGL(ENEDOSMX
     &        *1000.*3600*6000)
            WRITE(LUNGFO,*)

          ENDIF   !IO=NOBSV

        ENDIF !IDOSE

      ENDIF !ISPECINT


        ENDDO !IO

      ENDIF  !IPIN.eq.0

      IF(IPIN.NE.0) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     Pinhole position (x,y,z) [m]:'
        WRITE(LUNGFO,*)'     ',(SNGL(PINCEN(IO)),IO=1,3)
        WRITE(LUNGFO,*)

        IF(IPIN.NE.2.and.ipin.ne.3) THEN

          WRITE(LUNGFO,*)
     &      '     Numbers defining inner vert. and hori. edges (MMEDGEY,MMEDGEZ): ',
     &      MMEDGEY,MMEDGEZ," (obsolete, MUST be zero)"
          if (mmedgey.ne.0.or.mmedgez.ne.0) stop "MMEDGEY OR MMEDGEZ NOT ZERO!"
          WRITE(LUNGFO,*)
     &      '     Numbers defining outerer vert. and hori. edges (MEDGEY,MEDGEZ): ',
     &      MEDGEY,MEDGEZ
          WRITE(LUNGFO,*)
     &      '     Total number of vert. and hori. points:          ',NOBSVY,NOBSVZ
          WRITE(LUNGFO,*)
     &      '     Number of vert. and horiz. points inside pinhole:',MOBSVY,MOBSVZ
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     Vertical and horizontal grid size [m]:     '
     &      ,SNGL(OBSVDY),SNGL(OBSVDZ)

        ENDIF !IPIN.NE.2

        IF (MPINR.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     IQAUDPHI, NOBSVR, NOBSVPHI: ',IQUADPHI,NOBSVR, NOBSVPHI
          WRITE(LUNGFO,*)
     &      '     OBSVDR, OBSVDPHI: ',SNGL(OBSVDR),SNGL(OBSVDPHI*RADGRA1)
          WRITE(LUNGFO,*)
        ENDIF

        IF(IPIN.NE.2.and.ipin.ne.3) THEN

          WRITE(LUNGFO,*)
     &      '     Vertical and horizontal size [m x m]:      '
     &      ,AMAX1(SNGL(OBSVDY),(MOBSVY-1)*SNGL(OBSVDY))
     &      ,AMAX1(SNGL(OBSVDZ),(MOBSVZ-1)*SNGL(OBSVDZ))

          WRITE(LUNGFO,*)
     &      '     Total vert. and horiz. size [m x m]:       '
     &      ,AMAX1(SNGL(OBSVDY),(NOBSVY-1)*SNGL(OBSVDY))
     &      ,AMAX1(SNGL(OBSVDZ),(NOBSVZ-1)*SNGL(OBSVDZ))

        else

          if (ipincirc.eq.0) then
            WRITE(LUNGFO,*)
     &        '     Vertical and horizontal size [m x m]:      ',
     &        SNGL(pinh),sngl(pinw)
          endif

        ENDIF !(IPIN.NE.2)

        IF (IPINCIRC.NE.0) THEN

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &'     Flux is calculated through circ. pinhole, radius [m] and area [m x m]:'
          WRITE(LUNGFO,*)'      ',SNGL(pinr),sngl(pi1*pinr**2)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)

        ENDIF

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     Photon energy or wavelength and flux through pinhole:'

        if (nsource.le.5) then
          WRITE(LUNGFO,*)'     (for all sources and sum)'
          WRITE(LUNGFO,*)

          DO IFR=1,NFREQ

            IF (IUNIT.EQ.0)
     &        WRITE(LUNGFO,*)'  ',SNGL(FREQ(IFR))
     &        ,(SNGL(WFLUX(IS+NSOURCE*(IFR-1))),IS=1,NSOURCE)
     &        ,SNGL(WFLUXT(IFR))

            IF (IUNIT.NE.0)
     &        WRITE(LUNGFO,*)'  ',SNGL(WELLEN(IFR))
     &        ,(SNGL(WFLUX(IS+NSOURCE*(IFR-1))),IS=1,NSOURCE)
     &        ,SNGL(WFLUXT(IFR))

          ENDDO !IFR
        else
          WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
          WRITE(LUNGFO,*)

          DO IFR=1,NFREQ

            IF (IUNIT.EQ.0)
     &        WRITE(LUNGFO,*)'  ',SNGL(FREQ(IFR))
     &        ,(SNGL(WFLUX(IS+NSOURCE*(IFR-1))),IS=1,2)
     &        ,SNGL(WFLUX(IS+(NSOURCE/2+1)*(IFR-1)))
     &        ,(SNGL(WFLUX(IS+NSOURCE*(IFR-1))),IS=nsource-1,NSOURCE)
     &        ,SNGL(WFLUXT(IFR))

            IF (IUNIT.NE.0)
     &        WRITE(LUNGFO,*)'  ',SNGL(WELLEN(IFR))
     &        ,(SNGL(WFLUX(IS+NSOURCE*(IFR-1))),IS=1,2)
     &        ,SNGL(WFLUX(IS+(NSOURCE/2+1)*(IFR-1)))
     &        ,(SNGL(WFLUX(IS+NSOURCE*(IFR-1))),IS=nsource-1,NSOURCE)
     &        ,SNGL(WFLUXT(IFR))

          ENDDO !IFR
        endif

        if (ipin.ne.0) then
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     RPINSPH:       ',RPINSPH
        ENDIF

C maximum of spectot{

        IF (NFREQ.GT.1) THEN

          DO IFR=1,NFREQ
            SPECBUFF(IFR)=WFLUXT(IFR)
          ENDDO   !IFR

          CALL UTIL_MAX_PARABEL
     &      (NFREQ,FREQ,SPECBUFF,SPECTOTMX(5),SPECTOTMX(6)
     &      ,WSNOBFR1,WSNOBFR2,IFAIL)

          IF (IFAIL.NE.0) THEN
            WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED'
            WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
          ENDIF

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Estimated maximum:'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     ',SNGL(SPECTOTMX(5)),SNGL(SPECTOTMX(6))
          WRITE(LUNGFO,*)

        ENDIF  !NFREQ

C maximum of spectot}

        IF (IPINALL.NE.0) THEN

          if (ipin.ne.3) then
            DO IFR=1,NFREQ

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'     Flux density at each grid point:'
              WRITE(LUNGFO,*)
              DO IY=1,NOBSVY
                IF (IF1DIM.EQ.0) WRITE(LUNGFO,*)
                DO IZ=1,NOBSVZ
                  IOBSV=(IY-1)*NOBSVZ+IZ
                  WRITE(LUNGFO,*)'           '
     &              ,(SNGL(SPEC(IS+NSOURCE*(IOBSV-1+NOBSV*(IFR-1)))),IS=1,NSOURCE)
     &              ,SNGL(SPECTOT(IOBSV+NOBSV*(IFR-1)))
                ENDDO   !IZ
              ENDDO   !IY
              WRITE(LUNGFO,*)

            ENDDO !NFREQ

          endif !ipin.ne.3

        ELSE !IPINALL.NE.0

          if (ipin.ne.3) then
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Flux density for selected point:'
            WRITE(LUNGFO,*)
          else
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Mean flux density:'
            WRITE(LUNGFO,*)
          endif

          DO IFR=1,NFREQ

            IOBSV=ICBRILL

            WRITE(LUNGFO,*)'           '
     &        ,SNGL(FREQ(IFR)),(SNGL(SPEC(IS+NSOURCE*(IOBSV-1+NOBSV*(IFR-1)))),IS=1,NSOURCE)
     &        ,SNGL(SPECTOT(IOBSV+NOBSV*(IFR-1)))

          ENDDO   !NFREQ

C maximum of spectot{

          IF (NFREQ.GT.1) THEN

            DO IFR=1,NFREQ
              SPECBUFF(IFR)=SPECTOT(ICBRILL+NOBSV*(IFR-1))
            ENDDO !IFR

            CALL UTIL_MAX_PARABEL
     &        (NFREQ,FREQ,SPECBUFF,SPECTOTMX(1),SPECTOTMX(2)
     &        ,WSNOBFR1,WSNOBFR2,IFAIL)

            IF (IFAIL.NE.0) THEN
              WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED'
              WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
            ENDIF

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Estimated maximum:'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     ',SNGL(SPECTOTMX(1)),SNGL(SPECTOTMX(2))
            WRITE(LUNGFO,*)

          ENDIF   !NFREQ

C maximum of spectot}

        ENDIF !IPINALL

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     Power through pinhole [W]:'
        if (nsource.le.5) then
          WRITE(LUNGFO,*)'     (for all sources and sum)'
          IF (IAMPLI.GT.0) THEN
            WRITE(LUNGFO,*)
     &        '     (Option IAMPLI not taken into account!!)'
          ENDIF   !IAMPLI
          WRITE(LUNGFO,*)'   '
     &      ,(SNGL(SPECPOWVH(IS)),IS=1,NSOURCE)
     &      ,SNGL(SPECPOWVHT)
          WRITE(LUNGFO,*)
        else
          WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
          IF (IAMPLI.GT.0) THEN
            WRITE(LUNGFO,*)
     &        '     (Option IAMPLI not taken into account!!)'
          ENDIF   !IAMPLI
          WRITE(LUNGFO,*)'   '
     &      ,(SNGL(SPECPOWVH(IS)),IS=1,2)
     &      ,SNGL(SPECPOWVH(nsource/2+1))
     &      ,(SNGL(SPECPOWVH(IS)),IS=nsource-1,NSOURCE)
     &      ,SNGL(SPECPOWVHT)
          WRITE(LUNGFO,*)
        endif
c        IF (IAMPLI.LT.0) THEN
c          WRITE(LUNGFO,*)'     scaled according to IAMPLI:'
c          WRITE(LUNGFO,*)'            '
c     &      ,(SNGL(SPECPOWVH(IS)*(-IAMPLI)),IS=1,NSOURCE)
c     &      ,SNGL(SPECPOWVHT*(-IAMPLI))
c          WRITE(LUNGFO,*)' '
c        ENDIF !IAMPLI

        WRITE(LUNGFO,*)
        if (ipin.ne.3) then
          WRITE(LUNGFO,*)
     &      '     Power density at selected point [W/m**2]:'
          IF (IAMPLI.GT.0) THEN
            WRITE(LUNGFO,*)
     &        '     (Option IAMPLI not taken into account!!)'
          ENDIF   !IAMPLI
        else
          WRITE(LUNGFO,*)
     &      '     Mean power density [W/m**2]:'
          IF (IAMPLI.GT.0) THEN
            WRITE(LUNGFO,*)
     &        '     (Option IAMPLI not taken into account!!)'
          ENDIF   !IAMPLI
        endif
        WRITE(LUNGFO,*)

        IOBSV=ICBRILL
        WRITE(LUNGFO,*)'            '
     &    ,(SNGL(SPECPOW(IS+NSOURCE*(IOBSV-1))),IS=1,NSOURCE)
     &    ,SNGL(SPECPOWT(IOBSV))
        WRITE(LUNGFO,*)

c        IF (IAMPLI.LT.0) THEN
c          WRITE(LUNGFO,*)'     scaled according to IAMPLI:'
c          WRITE(LUNGFO,*)'            '
c     &      ,(SNGL(SPECPOW(IS+NSOURCE*(IOBSV-1))*(-IAMPLI)),IS=1,NSOURCE)
c     &      ,SNGL(SPECPOWT(IOBSV)*(-IAMPLI))
c          WRITE(LUNGFO,*)' '
c        ENDIF !IAMPLI

        IF (ISPECINT.NE.0) THEN

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     Power [W] through pinhole or power density [W/m**2]:'
          WRITE(LUNGFO,*)
     &      '     (by integration over spectral range:',
     &      SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','
          if (nsource.le.5) then
            WRITE(LUNGFO,*)
     &        '     for all sources and sum)'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'   '
     &        ,(SNGL(WFLUXI(IS)),IS=1,NSOURCE)
     &        ,SNGL(WFLUXTI)
          else
            WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
            WRITE(LUNGFO,*)
     &        '     for all sources and sum)'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'   '
     &        ,(SNGL(WFLUXI(IS)),IS=1,2)
     &        ,SNGL(WFLUXI(nsource/2+1))
     &        ,(SNGL(WFLUXI(IS)),IS=nsource-1,NSOURCE)
     &        ,SNGL(WFLUXTI)
          endif
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     Corresponding total number of photons at critical energy:'
          WRITE(LUNGFO,*)'            ',SNGL(WFLUXTI/FREQC/ECHARGE1)
          WRITE(LUNGFO,*)

          IF (IPINALL.NE.0) THEN

            if (ipin.ne.3) then

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          '     Power density at each grid point [W/m**2]:'
              WRITE(LUNGFO,*)
     &          '     (by integration over spectral range:',
     &          SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','
              if (nsource.le.5) then
                WRITE(LUNGFO,*)
     &            '     for all sources and sum)'
                WRITE(LUNGFO,*)
                DO IY=1,NOBSVY
                  IF (IF1DIM.EQ.0) WRITE(LUNGFO,*)
                  DO IZ=1,NOBSVZ
                    IOBSV=(IY-1)*NOBSVZ+IZ
                    WRITE(LUNGFO,*)'   '
     &                ,(SNGL(SPECI(IS+NSOURCE*(IOBSV-1))),IS=1,NSOURCE)
     &                ,SNGL(SPECTOTI(IOBSV))
                  ENDDO   !IZ
                ENDDO   !IY
              else
                WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
                WRITE(LUNGFO,*)
                DO IY=1,NOBSVY
                  IF (IF1DIM.EQ.0) WRITE(LUNGFO,*)
                  DO IZ=1,NOBSVZ
                    IOBSV=(IY-1)*NOBSVZ+IZ
                    WRITE(LUNGFO,*)'   '
     &                ,(SNGL(SPECI(IS+NSOURCE*(IOBSV-1))),IS=1,2)
     &                ,SNGL(SPECI(IS+(NSOURCE/2+1)*(IOBSV-1)))
     &                ,(SNGL(SPECI(IS+NSOURCE*(IOBSV-1))),IS=nsource-1,NSOURCE)
     &                ,SNGL(SPECTOTI(IOBSV))
                  ENDDO   !IZ
                ENDDO   !IY
              endif
              WRITE(LUNGFO,*)

            endif !ipin.ne.3

          ELSE !(IPINALL.NE.0)

            WRITE(LUNGFO,*)
            if (ipin.ne.3) then
              WRITE(LUNGFO,*)
     &          '     Power density at selected point [W/m**2]:'
              WRITE(LUNGFO,*)
     &          '     (by integration over spectral range:',
     &          SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','
              if (nsource.le.5) then
                WRITE(LUNGFO,*)
     &            '     for all sources and sum)'
              else
                WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
              endif
            else
              WRITE(LUNGFO,*)
     &          '     Mean power density [W/m**2]:'
              WRITE(LUNGFO,*)
     &          '     (by integration over spectral range:',
     &          SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','
              if (nsource.le.5) then
                WRITE(LUNGFO,*)
     &            '     for all sources and sum)'
              else
                WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
              endif
            endif
            WRITE(LUNGFO,*)

            IOBSV=ICBRILL
            if (nsource.le.5) then
              WRITE(LUNGFO,*)'     '
     &          ,(SNGL(SPECI(IS+NSOURCE*(IOBSV-1))),IS=1,NSOURCE)
     &          ,SNGL(SPECTOTI(IOBSV))
            else
              WRITE(LUNGFO,*)'   '
     &          ,(SNGL(SPECI(IS+NSOURCE*(IOBSV-1))),IS=1,2)
     &          ,SNGL(SPECI(IS+(NSOURCE/2+1)*(IOBSV-1)))
     &          ,(SNGL(SPECI(IS+NSOURCE*(IOBSV-1))),IS=nsource-1,NSOURCE)
     &          ,SNGL(SPECTOTI(IOBSV))
              WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
            endif
            WRITE(LUNGFO,*)

          ENDIF !IPINALL

          WRITE(LUNGFO,*)

          IF (IDOSE.NE.0) THEN

            WRITE(LUNGFO,*)" "
            WRITE(LUNGFO,*)"     *** CAUTION: THE DOSE CALCULATIONS ARE NOT MEANT FOR RADITATION SAFETY PRUPOSES OR MEDICAL APPLICATIONS ***"
            WRITE(LUNGFO,*)" "

            DO IO=1,NOBSV

              IF (IPINALL.NE.0) THEN

                WRITE(LUNGFO,*)
     &            '     Z, Y:',SNGL(OBSVZ(IO)),SNGL(OBSVY(IO))
                WRITE(LUNGFO,*)
     &            '     Absorbed energy dose rate [mGy/h]:',SNGL(ENEDOS(IO)
     &            *1000.*3600)
                WRITE(LUNGFO,*)

              ENDIF  !IPINALL

              IF (IO.EQ.NOBSV) THEN
                ENEDOSMX=-1.D30
                DO IOBSV=1,NOBSV
                  IF (ENEDOS(IOBSV).GT.ENEDOSMX) ENEDOSMX=ENEDOS(IOBSV)
                ENDDO
                WRITE(LUNGFO,*)
     &            '     Maximum absorbed energy dose rate [Gy/sec]:',SNGL(ENEDOSMX)
                WRITE(LUNGFO,*)
     &            '     Maximum absorbed energy dose rate [mGy/h]:',SNGL(ENEDOSMX
     &            *1000.*3600)
                WRITE(LUNGFO,*)
     &            '     Maximum absorbed energy dose rate [mGy/a]:',SNGL(ENEDOSMX
     &            *1000.*3600*6000)
                WRITE(LUNGFO,*)

              ENDIF  !IO=NOBSV
            ENDDO !IO

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '      Dose rate averaged over pinhole [Gy/sec]:',SNGL(PINDOS)
            WRITE(LUNGFO,*)
     &        '      Dose rate averaged over pinhole [mGy/h]:',SNGL(PINDOS
     &        *1000.*3600)
            WRITE(LUNGFO,*)
     &        '      Dose rate averaged over pinhole [mGy/a]:',SNGL(PINDOS
     &        *1000.*3600*6000)
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Effective pinhole size [m**2]:'
     &        ,PINDOS*PINW*PINH/ENEDOSMX
            WRITE(LUNGFO,*)'     Effective pinhole height [m]:'
     &        ,PINDOS*PINH/ENEDOSMX

            if (ipincirc.ne.0) then
              print*,"Error in spectrum: Dose calculation require rectangular pinhole ***"
              print*,"*** Program WAVE aborted ***"
              stop
            endif

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '      The estimated scattered dose behind the filter is the averaged dose scaled to the full solid angle.'
            WRITE(LUNGFO,*)
     &        '      *** DO NOT USE THESE ESTIMATIONS FOR RADIATION SAFETY OF MEDICAL APPLICATONS ***'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '      Estimated scattered dose 1m behind the filter 1m distance [Gy/sec]',
     &        SNGL(PINDOS*(pinw*pinh/pincen(1)**2)/4./pi1)
            WRITE(LUNGFO,*)
     &        '      Estimated scattered dose 1m behind the filter in 1m distance [mGy/h]',
     &        SNGL(PINDOS*(pinw*pinh/pincen(1)**2)/4./pi1*1000.*3600)
            WRITE(LUNGFO,*)
     &        '      Estimated scattered dose behind the filter in 1m distance [mGy/a]',
     &        SNGL(PINDOS*(pinw*pinh/pincen(1)**2)/4./pi1*1000.*3600*6000)
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Effective pinhole size [m**2]:'
     &        ,PINDOS*PINW*PINH/ENEDOSMX
            WRITE(LUNGFO,*)'     Effective pinhole height [m]:'
     &        ,PINDOS*PINH/ENEDOSMX

          ENDIF !IDOSE

        ENDIF !ISPECINT
        WRITE(LUNGFO,*)

        if (ipin.eq.3) then

           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'     Horizontal emittance EPS0H [m-rad]:',EPS0H
           WRITE(LUNGFO,*)'     Vertical emittance EPS0V [m-rad]:  ',EPS0V
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Sigmas of sources for horiz. folding:'
          WRITE(LUNGFO,*)'     ',(SNGL(WSIGZ(IS)),IS=1,NSOURCE)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Sigmas of sources for vert. folding:'
          WRITE(LUNGFO,*)'     ',(SNGL(WSIGY(IS)),IS=1,NSOURCE)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Sigmas of horizontal beam size and divergence:'
          WRITE(LUNGFO,*)
     &      '     (if not zero, sigmas for folding are calculated from these values)'
          WRITE(LUNGFO,*)'     ',(SNGL(BSIGZ(IS)),SNGL(BSIGZP(IS)),IS=1,NSOURCE)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Sigmas of vertical beam size and divergence:'
          WRITE(LUNGFO,*)
     &      '     (if not zero, sigmas for folding are calculated from these values)'
          WRITE(LUNGFO,*)'     ',(SNGL(BSIGY(IS)),SNGL(BSIGYP(IS)),IS=1,NSOURCE)
          WRITE(LUNGFO,*)

        else IF (IFOLD.NE.0)   THEN

          WRITE(LUNGFO,*)

          if (ipin.ne.3) then
            IF (IFOLD.NE.2.AND.IFOLD.NE.1)
     &        WRITE(LUNGFO,*)
     &        '     Number of Fourier coefficients for folding:',NGFOURZ,NGFOURY

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Number of sigmas for horiz. folding:'
            WRITE(LUNGFO,*)'     ',(SNGL(DGSIGZ(IS)),IS=1,NSOURCE)
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Number of sigmas for vert. folding:'
            WRITE(LUNGFO,*)'     ',(SNGL(DGSIGY(IS)),IS=1,NSOURCE)
            WRITE(LUNGFO,*)
          endif
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Sigmas of sources for horiz. folding:'
          WRITE(LUNGFO,*)'     ',(SNGL(WSIGZ(IS)),IS=1,NSOURCE)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Sigmas of sources for vert. folding:'
          WRITE(LUNGFO,*)'     ',(SNGL(WSIGY(IS)),IS=1,NSOURCE)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Sigmas of horizontal beam size and divergence:'
          WRITE(LUNGFO,*)
     &      '     (if not zero, sigmas for folding are calculated from these values)'
          WRITE(LUNGFO,*)'     ',(SNGL(BSIGZ(IS)),SNGL(BSIGZP(IS)),IS=1,NSOURCE)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Sigmas of vertical beam size and divergence:'
          WRITE(LUNGFO,*)
     &      '     (if not zero, sigmas for folding are calculated from these values)'
          WRITE(LUNGFO,*)'     ',(SNGL(BSIGY(IS)),SNGL(BSIGYP(IS)),IS=1,NSOURCE)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)

          IF (ISTOKES.NE.0) THEN
            WRITE(LUNGFO,*)
     &        '     Sigmas for folding of components of STOKES vector:'
            WRITE(LUNGFO,*)
     &        '     ',SNGL(WSIGZ(ISIGSTO)),SNGL(WSIGY(ISIGSTO))
            WRITE(LUNGFO,*)
          ENDIF !ISTOKES
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     Photon energy or wavelen. and flux through pinhole with emittance effects:'
          WRITE(LUNGFO,*)

          DO IFR=1,NFREQ

            IF (IUNIT.EQ.0)
     &        WRITE(LUNGFO,*)'  ',SNGL(FREQ(IFR))
     &        ,(SNGL(WFLUXF(IS+NSOURCE*(IFR-1))),IS=1,NSOURCE)
     &        ,SNGL(WFLUXTF(IFR))
            IF (IUNIT.NE.0)
     &        WRITE(LUNGFO,*)'  ',SNGL(WELLEN(IFR))
     &        ,(SNGL(WFLUXF(IS+NSOURCE*(IFR-1))),IS=1,NSOURCE)
     &        ,SNGL(WFLUXTF(IFR))

          ENDDO !IFR

C maximum of spectot{

          IF (NFREQ.GT.1) THEN

            DO IFR=1,NFREQ
              SPECBUFF(IFR)=WFLUXTF(IFR)
            ENDDO !IFR

            CALL UTIL_MAX_PARABEL
     &        (NFREQ,FREQ,SPECBUFF,SPECTOTMX(1),SPECTOTMX(2)
     &        ,WSNOBFR1,WSNOBFR2,IFAIL)

            IF (IFAIL.NE.0) THEN
              WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED'
              WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
            ENDIF

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Estimated maximum:'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     ',SNGL(SPECTOTMX(1)),SNGL(SPECTOTMX(2))
            WRITE(LUNGFO,*)

          ENDIF   !NFREQ

C maximum of spectot}

          if (ipin.ne.3) then

            IF (IPINALL.NE.0) THEN

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'     Flux density at each grid point with emittance:'
              WRITE(LUNGFO,*)

              DO IFR=1,NFREQ

                DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
                  IF (IF1DIM.EQ.0) WRITE(LUNGFO,*)
                  DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
                    IOBSV=(IY-1)*NOBSVZ+IZ
                    WRITE(LUNGFO,*)'           '
     &                ,(SNGL(SPECF(IS+NSOURCE*(IOBSV-1+NOBSV*(IFR-1)))),IS=1,NSOURCE)
     &                ,SNGL(SPECTOTF(IOBSV+NOBSV*(IFR-1)))
                  ENDDO   !IZ
                ENDDO   !IY
                WRITE(LUNGFO,*)

              ENDDO    !IFR

            ELSE !(IPINALL.NE.0)

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          '     Flux density at selected point with emittance:'
              WRITE(LUNGFO,*)

              DO IFR=1,NFREQ

                IOBSV=ICBRILL
                WRITE(LUNGFO,*)'           '
     &            ,SNGL(FREQ(IFR))
     &            ,(SNGL(SPECF(IS+NSOURCE*(IOBSV-1+NOBSV*(IFR-1)))),IS=1,NSOURCE)
     &            ,SNGL(SPECTOTF(IOBSV+NOBSV*(IFR-1)))

              ENDDO    !IFR

C maximum of spectot{

              IF (NFREQ.GT.1) THEN

                DO IFR=1,NFREQ
                  SPECBUFF(IFR)=SPECTOTF(ICBRILL+NOBSV*(IFR-1))
                ENDDO   !IFR

                CALL UTIL_MAX_PARABEL
     &            (NFREQ,FREQ,SPECBUFF,SPECTOTMX(1),SPECTOTMX(2)
     &            ,WSNOBFR1,WSNOBFR2,IFAIL)

                IF (IFAIL.NE.0) THEN
                  WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED'
                  WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
                ENDIF

                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'     Estimated maximum:'
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'     ',SNGL(SPECTOTMX(1)),SNGL(SPECTOTMX(2))
                WRITE(LUNGFO,*)

              ENDIF  !NFREQ

C maximum of spectot}

            ENDIF !IPINALL

            IF (ISPECINT.NE.0) THEN

              WRITE(LUNGFO,*)
     &          '     Power [W] or power density [W/m**2] with emittance'
              WRITE(LUNGFO,*)
     &          '     (by integration over spectral range:',
     &          SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','
              if (nsource.le.5) then
                WRITE(LUNGFO,*)
     &            '     for all sources and sum)'
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'   '
     &            ,(SNGL(WFLUXIF(IS)),IS=1,NSOURCE)
     &            ,SNGL(WFLUXTIF)
              else
                WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'   '
     &            ,(SNGL(WFLUXIF(IS)),IS=1,2)
     &            ,SNGL(WFLUXIF(nsource/2+1))
     &            ,(SNGL(WFLUXIF(IS)),IS=nsource-1,NSOURCE)
     &            ,SNGL(WFLUXTIF)
              endif
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          '     Corresponding total number of photons at critical energy:'
              WRITE(LUNGFO,*)'     ',SNGL(WFLUXTIF/FREQCF/ECHARGE1)

              IF (IPINALL.NE.0) THEN

                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)
     &            '     Power density at each grid point [W/m**2] with emittance:'
                WRITE(LUNGFO,*)
     &            '     (by integration over spectral range:',
     &            SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','
                if (nsource.le.5) then
                  WRITE(LUNGFO,*)
     &              '     for all sources and sum)'
                  WRITE(LUNGFO,*)
                  DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
                    IF (IF1DIM.EQ.0) WRITE(LUNGFO,*)
                    DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
                      IOBSV=(IY-1)*NOBSVZ+IZ
                      WRITE(LUNGFO,*)'   '
     &                  ,(SNGL(SPECIF(IS+NSOURCE*(IOBSV-1))),IS=1,NSOURCE)
     &                  ,SNGL(SPECTOTIF(IOBSV))
                    ENDDO   !IZ
                  ENDDO   !IY
                else
                  WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
                  WRITE(LUNGFO,*)
                  DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
                    IF (IF1DIM.EQ.0) WRITE(LUNGFO,*)
                    DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
                      IOBSV=(IY-1)*NOBSVZ+IZ
                      WRITE(LUNGFO,*)'   '
     &                  ,(SNGL(SPECIF(IS+NSOURCE*(IOBSV-1))),IS=1,2)
     &                  ,SNGL(SPECIF(IS+(NSOURCE/2+1)*(IOBSV-1)))
     &                  ,(SNGL(SPECIF(IS+NSOURCE*(IOBSV-1))),IS=nsource-1,NSOURCE)
     &                  ,SNGL(SPECTOTIF(IOBSV))
                    ENDDO   !IZ
                  ENDDO   !IY
                endif
                WRITE(LUNGFO,*)

              ELSE !(IPINALL.NE.0)

                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)
     &            '     Power density at selected point [W/m**2] with emittance:'
                WRITE(LUNGFO,*)
     &            '     (by integration over spectral range:',
     &            SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','
                if (nsource.le.5) then
                  WRITE(LUNGFO,*)
     &              '     for all sources and sum)'
                  WRITE(LUNGFO,*)
                  IOBSV=ICBRILL
                  WRITE(LUNGFO,*)'   '
     &              ,(SNGL(SPECIF(IS+NSOURCE*(IOBSV-1))),IS=1,NSOURCE)
     &              ,SNGL(SPECTOTIF(IOBSV))
                else
                  WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
                  WRITE(LUNGFO,*)
     &              '     for all sources and sum)'
                  WRITE(LUNGFO,*)
                  IOBSV=ICBRILL
                  WRITE(LUNGFO,*)'   '
     &              ,(SNGL(SPECIF(IS+NSOURCE*(IOBSV-1))),IS=1,2)
     &              ,SNGL(SPECIF(IS+(NSOURCE/2+1)*(IOBSV-1)))
     &              ,(SNGL(SPECIF(IS+NSOURCE*(IOBSV-1))),IS=nsource-1,NSOURCE)
     &              ,SNGL(SPECTOTIF(IOBSV))
                endif
                WRITE(LUNGFO,*)

              ENDIF !IPINALL

            ENDIF !ISPECINT

          ENDIF !IFOLD

        endif !ipin3 and ifold

      ENDIF  !IPIN.ne.0

      IF (ISTOKES.NE.0) THEN

        IF (IPIN.EQ.0) THEN

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)

          WRITE(LUNGFO,*)
     &      '     Photon energy [eV] or wavelength [nm] for all observation'
          WRITE(LUNGFO,*)
     &      '     points, normalized components S0, S1/S0, S2/S0, S3/S0, P of'
          WRITE(LUNGFO,*)
     &      '     STOKES vector per unit area [m**2]:'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)

          DO IO=1,NOBSV

            WRITE(LUNGFO,*)'          Observation point (x,y,z) [m]:'
            WRITE(LUNGFO,*)'          ',(SNGL(OBSV(IX,IO)),IX=1,3)
            WRITE(LUNGFO,*)

            DO IFR=1,NFREQ
              IOBFR=IO+NOBSV*(IFR-1)
              IF (STOKES(1,IOBFR).EQ.0.0) STOKES(1,IOBFR)=1.E-10
              S1=STOKES(1,IOBFR)
              S2=STOKES(2,IOBFR)
              S3=STOKES(3,IOBFR)
              S4=STOKES(4,IOBFR)
              POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1
              IF (STOKES(1,IOBFR).EQ.1.E-10) POL=0.0
              IF (IUNIT.EQ.0)
     &          WRITE(LUNGFO,2584)SNGL(FREQ(IFR)),STOKES(1,IOBFR)
     &          ,(STOKES(IS,IOBFR)/STOKES(1,IOBFR),IS=2,4),POL
              IF (IUNIT.NE.0)
     &          WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &          ,(STOKES(IS,IOBFR)/STOKES(1,IOBFR),IS=2,4),POL
            ENDDO !IFR

            IF (IFOLD.EQ.2) THEN

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)

              WRITE(LUNGFO,*)
     &          '       Photon energy [eV] or wavelength [nm] for all observation'
              WRITE(LUNGFO,*)
     &          '       points, normalized components S0, S1/S0, S2/S0, S3/S0, P of'
              WRITE(LUNGFO,*)
     &          '       STOKES vector per unit area [m**2] with emittance:'
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)

              DO IFR=1,NFREQ
                IOBFR=IO+NOBSV*(IFR-1)
                IF (STOKESF(1,IOBFR).EQ.0.0) STOKESF(1,IOBFR)=1.E-10
                S1=STOKESF(1,IOBFR)
                S2=STOKESF(2,IOBFR)
                S3=STOKESF(3,IOBFR)
                S4=STOKESF(4,IOBFR)
                POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1
                IF (STOKESF(1,IOBFR).EQ.1.E-10) POL=0.0
                IF (IUNIT.EQ.0)
     &            WRITE(LUNGFO,2584)SNGL(FREQ(IFR)),STOKESF(1,IOBFR)
     &            ,(STOKESF(IS,IOBFR)/STOKESF(1,IOBFR),IS=2,4),POL
                IF (IUNIT.NE.0)
     &            WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &            ,(STOKESF(IS,IOBFR)/STOKESF(1,IOBFR),IS=2,4),POL
              ENDDO !IFR
            ENDIF !IFOLD.EQ.2

          ENDDO !NOBSV

        ELSE   !IPIN

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     Photon energy or wavelength and normalized components S0, S1/S0,'
          WRITE(LUNGFO,*)
     &      '     S2/S0, S3/S0 of STOKES vector and polarization for pinhole:'
          WRITE(LUNGFO,*)

          DO IFR=1,NFREQ

            IF (WSTOKES(1,IFR).EQ.0.0) WSTOKES(1,IFR)=1.E-10
            S1=WSTOKES(1,IFR)
            S2=WSTOKES(2,IFR)
            S3=WSTOKES(3,IFR)
            S4=WSTOKES(4,IFR)
            POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1
C         POL=SQRT(WSTOKES(2,IFR)**2+WSTOKES(3,IFR)**2+
C     &               WSTOKES(4,IFR)**2)/WSTOKES(1,IFR)

            IF (IUNIT.EQ.0)
     &        WRITE(LUNGFO,2584)SNGL(FREQ(IFR))
     &        ,WSTOKES(1,IFR)
     &        ,(WSTOKES(IS,IFR)/WSTOKES(1,IFR),IS=2,4),POL

            IF (IUNIT.NE.0)
     &        WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &        ,WSTOKES(1,IFR)
     &        ,(WSTOKES(IS,IFR)/WSTOKES(1,IFR),IS=2,4),POL
2584        FORMAT('     ',6(1PE12.4))

          ENDDO !IFR

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          if (ipin.ne.3) then
            WRITE(LUNGFO,*)
     &        '     Photon energy [eV] or wavelength [nm] for selected point'
            WRITE(LUNGFO,*)'     of pinhole, S0, S1/S0, S2/S0, S3/S0, P of'
            WRITE(LUNGFO,*)
     &        '     STOKES vector per unit area [m**2]:'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
            IO=ICBRILL
            WRITE(LUNGFO,*)'          Observation point (x,y,z) [m]:'
            WRITE(LUNGFO,*)'          ',(SNGL(OBSV(IX,IO)),IX=1,3)
            WRITE(LUNGFO,*)
          else
            WRITE(LUNGFO,*)
     &        '     Photon energy [eV] or wavelength [nm]'
            WRITE(LUNGFO,*)'     , mean densities of S0, S1/S0, S2/S0, S3/S0, P of'
            WRITE(LUNGFO,*)
     &        '     STOKES vector per unit area [m**2]:'
          endif

          DO IFR=1,NFREQ
            IF (STOKEC(1,IFR).EQ.0.0) STOKEC(1,IFR)=1.E-10
            S1=STOKEC(1,IFR)
            S2=STOKEC(2,IFR)
            S3=STOKEC(3,IFR)
            S4=STOKEC(4,IFR)
            POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1
C         POL=
C     &                   SQRT(
C     &          (STOKEC(2,IFR)**2
C     &          +STOKEC(3,IFR)**2
C     &          +STOKEC(4,IFR)**2))
C     &          /STOKEC(1,IFR)
            IF (STOKEC(1,IFR).EQ.1.E-10) POL=0.0
            IF (IUNIT.EQ.0)
     &        WRITE(LUNGFO,2584)SNGL(FREQ(IFR))
     &        ,STOKEC(1,IFR),(STOKEC(IS,IFR)/STOKEC(1,IFR),IS=2,4),POL
            IF (IUNIT.NE.0)
     &        WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &        ,STOKEC(1,IFR),(STOKEC(IS,IFR)/STOKEC(1,IFR),IS=2,4),POL
          ENDDO !IFR

          IF (IFOLD.NE.0.and.ipin.ne.3)   THEN

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '     Energy, S0, S1/S0, S2/S0, S3/S0 and P for pinhole with emittance:'
            WRITE(LUNGFO,*)

            DO IFR=1,NFREQ

              IF (WSTOKESF(1,IFR).EQ.0.0) WSTOKESF(1,IFR)=1.E-10

              S1=WSTOKESF(1,IFR)
              S2=WSTOKESF(2,IFR)
              S3=WSTOKESF(3,IFR)
              S4=WSTOKESF(4,IFR)
              POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1
C         POL=SQRT(WSTOKESF(2,IFR)**2+WSTOKESF(3,IFR)**2+
C     &               WSTOKESF(4,IFR)**2)/WSTOKESF(1,IFR)

              IF (IUNIT.EQ.0)
     &          WRITE(LUNGFO,2584)SNGL(FREQ(IFR))
     &          ,WSTOKESF(1,IFR)
     &          ,(WSTOKESF(IS,IFR)/WSTOKESF(1,IFR),IS=2,4),POL

              IF (IUNIT.NE.0)
     &          WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &          ,WSTOKESF(1,IFR)
     &          ,(WSTOKESF(IS,IFR)/WSTOKESF(1,IFR),IS=2,4),POL

            ENDDO !IFR
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '     Photon energy [eV] or wavelength [nm] for selected point'
            WRITE(LUNGFO,*)
     &        '     of pinhole, S0, S1/S0, S2/S0, S3/S0, P of with emittance'
            WRITE(LUNGFO,*)
     &        '     STOKES vector per unit area [m**2]:'
            WRITE(LUNGFO,*)

            DO IFR=1,NFREQ
              IF (STOKECF(1,IFR).EQ.0.0) STOKECF(1,IFR)=1.E-10
              S1=STOKECF(1,IFR)
              S2=STOKECF(2,IFR)
              S3=STOKECF(3,IFR)
              S4=STOKECF(4,IFR)
              POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1
C         POL=
C     &                   SQRT(
C     &          (STOKECF(2,IFR)**2
C     &          +STOKECF(3,IFR)**2
C     &          +STOKECF(4,IFR)**2))
C     &          /STOKECF(1,IFR)
              IF (STOKECF(1,IFR).EQ.1.E-10) POL=0.0
              IF (IUNIT.EQ.0)
     &          WRITE(LUNGFO,2584)SNGL(FREQ(IFR))
     &          ,STOKECF(1,IFR),(STOKECF(IS,IFR)/STOKECF(1,IFR),
     &          IS=2,4),POL
              IF (IUNIT.NE.0)
     &          WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &          ,STOKECF(1,IFR),
     &          (STOKECF(IS,IFR)/STOKECF(1,IFR),IS=2,4),POL
            ENDDO !IFR

          ENDIF !IFOLD

        ENDIF  !IPIN


      ENDIF !ISTOKES

      IF (IW_BLENF.NE.0) ISPECSUM=1

C--- USE SIMPLE SUMMATION TO EVALUATE FLUX THROUGH PINHOLE (TEST PURPOSES)

      IF (IPIN.NE.0..AND.IPIN.NE.2.and.ipin.ne.3.AND.ISPECSUM.NE.0) THEN

          IF (ISTOKES.NE.0) THEN
               CALL STOKSUM
          ELSE
               CALL SPECSUM
          ENDIF   !ISTOKES

          IF (IFOLD.NE.0.AND.IFOLD.NE.2) THEN

         IF (ISTOKES.NE.0) THEN
             CALL STOKSUMF
         ELSE
             CALL SPECSUMF
         ENDIF !ISTOKES

          ENDIF   !IFOLD

      ENDIF !IPIN AND ISPECSUM

C--- WRITE FLUX THROUGH PINHOLE TO FILE

      IF(IWFILFL0.NE.0) THEN

         OPEN(UNIT=LUNFL0,FILE=FILEFL0,STATUS='NEW')

         WRITE(LUNFL0,*)ICODE,' ',CODE
         WRITE(LUNFL0,*)NFREQ,NSOURCE

         DO IFR=1,NFREQ
            IF (IUNIT.EQ.0)
     &         WRITE(LUNFL0,*)SNGL(FREQ(IFR))
     &                        ,(SNGL(WFLUX(IS+NSOURCE*(IFR-1))),IS=1,NSOURCE)
     &                           ,SNGL(WFLUXT(IFR))
            IF (IUNIT.NE.0)
     &         WRITE(LUNFL0,*)SNGL(WELLEN(IFR))
     &                        ,(SNGL(WFLUX(IS+NSOURCE*(IFR-1))),IS=1,NSOURCE)
     &                           ,SNGL(WFLUXT(IFR))
         ENDDO

         CLOSE(LUNFL0)
      ENDIF !IWFILFL0

      IF(ipin.ne.3.and.IFOLD.NE.0.AND.IWFILFLF.NE.0) THEN

         OPEN(UNIT=LUNFLF,FILE=FILEFLF)

         WRITE(LUNFLF,*)ICODE,' ',CODE
         WRITE(LUNFLF,*)NFREQ,NSOURCE

         DO IFR=1,NFREQ
            IF (IUNIT.EQ.0)
     &         WRITE(LUNFLF,*)SNGL(FREQ(IFR))
     &        ,(SNGL(WFLUXF(IS+NSOURCE*(IFR-1))),IS=1,NSOURCE)
     &        ,SNGL(WFLUXTF(IFR))
            IF (IUNIT.NE.0)
     &         WRITE(LUNFLF,*)SNGL(WELLEN(IFR))
     &        ,(SNGL(WFLUXF(IS+NSOURCE*(IFR-1))),IS=1,NSOURCE)
     &        ,SNGL(WFLUXTF(IFR))
         ENDDO

         CLOSE(LUNFLF)
      ENDIF !IWFILFLF

      IF (IPIN.NE.0) THEN

        STOKESMAX=0.0

        IF (ISTOKES.NE.0) THEN

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '      Total absolute maxima found for Stokes-V. (z,y,Eph,fluxdens.)'
          WRITE(LUNGFO,*)

          DO ISTOK=1,4

            DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
              DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
                IO=(IY-1)*NOBSVZ+IZ
                DO IFR=1,NFREQ
                  IF (ABS(STOKES(ISTOK,IO+NOBSV*(IFR-1))).GT.
     &                STOKESMAX(4,ISTOK)) THEN
                    STOKESMAX(1,ISTOK)=OBSV(2,IO)
                    STOKESMAX(2,ISTOK)=OBSV(3,IO)
                    STOKESMAX(3,ISTOK)=FREQ(IFR)
                    STOKESMAX(4,ISTOK)=STOKES(ISTOK,IO+NOBSV*(IFR-1))
                  ENDIF
                ENDDO   !IFR
              ENDDO  !IZ
            ENDDO !IY

            WRITE(LUNGFO,'(6X,4((1PE12.4)))')STOKESMAX(1:4,ISTOK)

          ENDDO !ISTOK

        ELSE !(ISTOKES.NE.0)

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '      Total absolute maxima found for flux-density (z,y,Eph,fluxdens.)'
          WRITE(LUNGFO,*)

          DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
            DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
              IO=(IY-1)*NOBSVZ+IZ
              DO IFR=1,NFREQ
                IF (SPECTOT(IO+NOBSV*(IFR-1)).GT.STOKESMAX(4,1)) THEN
                  STOKESMAX(1,1)=OBSV(2,IO)
                  STOKESMAX(2,1)=OBSV(3,IO)
                  STOKESMAX(3,1)=FREQ(IFR)
                  STOKESMAX(4,1)=SPECTOT(IO+NOBSV*(IFR-1))
                ENDIF
              ENDDO  !IFR
            ENDDO !IZ
          ENDDO   !IY

          WRITE(LUNGFO,'(6X,4((1PE12.4)))')STOKESMAX(1:4,1)

        ENDIF !(ISTOKES.NE.0)

        STOKESMAXF=0.0

        IF (IFOLD.NE.0.and.ipin.ne.3) THEN

          IF (ISTOKES.NE.0) THEN

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '      Total absolute maxima found for Stokes-V. with emittance'
            WRITE(LUNGFO,*)
     &        '      (z,y,Eph,fluxdens.)'
            WRITE(LUNGFO,*)

            DO ISTOK=1,4

              DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
                DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
                  IO=(IY-1)*NOBSVZ+IZ
                  DO IFR=1,NFREQ
                    IF (ABS(STOKESF(ISTOK,IO+NOBSV*(IFR-1))).GT.
     &                  STOKESMAXF(4,ISTOK)) THEN
                      STOKESMAXF(1,ISTOK)=OBSV(2,IO)
                      STOKESMAXF(2,ISTOK)=OBSV(3,IO)
                      STOKESMAXF(3,ISTOK)=FREQ(IFR)
                      STOKESMAXF(4,ISTOK)=STOKESF(ISTOK,IO+NOBSV*(IFR-1))
                    ENDIF
                  ENDDO !IFR
                ENDDO   !IZ
              ENDDO  !IY

              WRITE(LUNGFO,'(6X,4((1PE12.4)))')STOKESMAXF(1:4,ISTOK)

            ENDDO !ISTOK

          ELSE !(ISTOKES.NE.0)

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '      Total absolute maxima found for flux-dens. with emit. (z,y,Eph,fluxd.)'
            WRITE(LUNGFO,*)

            DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
              DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
                IO=(IY-1)*NOBSVZ+IZ
                DO IFR=1,NFREQ
                  IF (SPECTOTF(IO+NOBSV*(IFR-1)).GT.STOKESMAXF(4,1)) THEN
                    STOKESMAXF(1,1)=OBSV(2,IO)
                    STOKESMAXF(2,1)=OBSV(3,IO)
                    STOKESMAXF(3,1)=FREQ(IFR)
                    STOKESMAXF(4,1)=SPECTOTF(IO+NOBSV*(IFR-1))
                  ENDIF
                ENDDO   !IFR
              ENDDO  !IZ
            ENDDO !IY

            WRITE(LUNGFO,'(XXXXXX,4((1PE12.4)))')STOKESMAXF(1:4,1)

          ENDIF !(ISTOKES.NE.0)

        ENDIF !IFOLD

      ENDIF !IPIN

      IF(IEFOLD.NE.0) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)

        IF (ipin.ne.3.and.IEFOLD.NE.0) THEN
          CALL EFOLD
        ELSE IF (ipin.eq.3) THEN
          WRITE(LUNGFO,*)
     &      '     Beam energy spread (ESPREAD) for energy folding:'
          WRITE(LUNGFO,*)'     ',SNGL(ESPREAD)
        ELSE IF (IEFOLD.lt.0) THEN
          WRITE(LUNGFO,*)
     &      '     Beam energy spread (ESPREAD) and number of sigmas'
          WRITE(LUNGFO,*)
     &      '     for energy folding:'
          WRITE(LUNGFO,*)'     ',SNGL(ESPREAD),NSIGE
          WRITE(LUNGFO,*)
        ENDIF

        IF (IPIN.EQ.0) THEN

          IF (NOBSV.GT.1) THEN
            WRITE(LUNGFO,*)
     &        '       Photon energy [eV] or wavelength [nm] for first observation'
            IO=1
          ELSE
            WRITE(LUNGFO,*)
     &        '       Photon energy [eV] or wavelength [nm] for selected observation'
            IO=ICBRILL
          ENDIF

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     point, normalized components S0, S1/S0, S2/S0, S3/S0, P of'
          WRITE(LUNGFO,*)
     &      '     STOKES vector per unit area [m**2] (e-folded):'
          WRITE(LUNGFO,*)

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'          Observation point (x,y,z) [m]:'
          WRITE(LUNGFO,*)'          ',(SNGL(OBSV(IX,IO)),IX=1,3)
          WRITE(LUNGFO,*)

          DO IFR=1,NFREQ
            IF (WSTOKESE(1,IFR).EQ.0.0) WSTOKESE(1,IFR)=1.E-10
            S1=WSTOKESE(1,IFR)
            S2=WSTOKESE(2,IFR)
            S3=WSTOKESE(3,IFR)
            S4=WSTOKESE(4,IFR)
            POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1
            IF (WSTOKESE(1,IFR).EQ.1.E-10) POL=0.0
            IF (IUNIT.EQ.0)
     &        WRITE(LUNGFO,2584)SNGL(FREQ(IFR)),WSTOKESE(1,IFR)
     &        ,(WSTOKESE(IS,IFR)/WSTOKESE(1,IFR),IS=2,4),POL
            IF (IUNIT.NE.0)
     &        WRITE(LUNGFO,2584)SNGL(WELLEN(IFR)),WSTOKESE(1,IFR)
     &        ,(WSTOKESE(IS,IFR)/WSTOKESE(1,IFR),IS=2,4),POL
          ENDDO !IFR

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          IF (IFOLD.EQ.2) THEN
            IF (NOBSV.GT.1) THEN
              WRITE(LUNGFO,*)
     &          '       Photon energy [eV] or wavelength [nm] for first observation'
              IO=1
            ELSE
              WRITE(LUNGFO,*)
     &          '       Photon energy [eV] or wavelength [nm] for selected observation'
              IO=ICBRILL
            ENDIF

            WRITE(LUNGFO,*)
     &        '     point, normalized components S0, S1/S0, S2/S0, S3/S0, P of'
            WRITE(LUNGFO,*)
     &        '     STOKES vector per unit area [m**2] with emittance (e-folded):'
            WRITE(LUNGFO,*)

            DO IFR=1,NFREQ
              IF (WSTOKESEF(1,IFR).EQ.0.0) WSTOKESEF(1,IFR)=1.E-10
              S1=WSTOKESEF(1,IFR)
              S2=WSTOKESEF(2,IFR)
              S3=WSTOKESEF(3,IFR)
              S4=WSTOKESEF(4,IFR)
              POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1
              IF (WSTOKESEF(1,IFR).EQ.1.E-10) POL=0.0
              IF (IUNIT.EQ.0)
     &          WRITE(LUNGFO,2584)SNGL(FREQ(IFR)),WSTOKESEF(1,IFR)
     &          ,(WSTOKESEF(IS,IFR)/WSTOKESEF(1,IFR),IS=2,4),POL
              IF (IUNIT.NE.0)
     &          WRITE(LUNGFO,2584)SNGL(WELLEN(IFR)),WSTOKESEF(1,IFR)
     &          ,(WSTOKESEF(IS,IFR)/WSTOKESEF(1,IFR),IS=2,4),POL
            ENDDO !IFR
          ENDIF !IFOLD.EQ.2

        ELSE   !IPIN

          IF(IWFLSTOE.NE.0.AND.IEFOLD.NE.0) THEN

            OPEN(UNIT=LUNSTO,FILE=FILESTOE)

            WRITE(LUNSTO,*)ICODE,' ',CODE
            WRITE(LUNSTO,*)
            WRITE(LUNSTO,*)NSOURCE,NOBSV,NFREQ,IFREQ2P
            WRITE(LUNSTO,*)NOBSVZ,NOBSVY,MOBSVZ,MOBSVY
            WRITE(LUNSTO,*)MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY
            WRITE(LUNSTO,*)
            WRITE(LUNSTO,*)PINW,PINH,PINR
            WRITE(LUNSTO,*)OBSVDZ,OBSVDY
            WRITE(LUNSTO,*)

            WRITE(LUNSTO,*)(OBSVZ(IO),IO=1,NOBSVZ)
            WRITE(LUNSTO,*)
            WRITE(LUNSTO,*)(OBSVY(IO),IO=1,NOBSVY)
            WRITE(LUNSTO,*)

            DO IO=1,NOBSV
              WRITE(LUNSTO,*)(OBSV(IX,IO),IX=1,3)
              DO IFR=1,NFREQ
                IF (IUNIT.EQ.0) THEN !260194
                  IOBFR=IO+NOBSV*(IFR-1)
                  WRITE(LUNSTO,*)FREQ(IFR),(STOKESE(IS,IOBFR),IS=1,4)
                ELSE
                  WRITE(LUNSTO,*)WELLEN(IFR),(STOKESE(IS,IOBFR),IS=1,4)
                ENDIF
              ENDDO !NFREQ
            ENDDO !NOBSV

            CLOSE(LUNSTO)

          ENDIF !IWFLSTOE

          IF(IWFLSTOEF.NE.0.AND.IEFOLD.NE.0.AND.IFOLD.NE.0) THEN

            OPEN(UNIT=LUNSTO,FILE=FILESTOEF)

            WRITE(LUNSTO,*)ICODE,' ',CODE
            WRITE(LUNSTO,*)
            WRITE(LUNSTO,*)NSOURCE,NOBSV,NFREQ,IFREQ2P
            WRITE(LUNSTO,*)NOBSVZ,NOBSVY,MOBSVZ,MOBSVY
            WRITE(LUNSTO,*)MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY
            WRITE(LUNSTO,*)
            WRITE(LUNSTO,*)PINW,PINH,PINR
            WRITE(LUNSTO,*)OBSVDZ,OBSVDY
            WRITE(LUNSTO,*)

            WRITE(LUNSTO,*)(OBSVZ(IO),IO=1,NOBSVZ)
            WRITE(LUNSTO,*)
            WRITE(LUNSTO,*)(OBSVY(IO),IO=1,NOBSVY)
            WRITE(LUNSTO,*)

            DO IO=1,NOBSV
              WRITE(LUNSTO,*)(OBSV(IX,IO),IX=1,3)
              DO IFR=1,NFREQ
                IF (IUNIT.EQ.0) THEN !260194
                  IOBFR=IO+NOBSV*(IFR-1)
                  WRITE(LUNSTO,*)FREQ(IFR),(STOKESEF(IS,IOBFR),IS=1,4)
                ELSE
                  WRITE(LUNSTO,*)WELLEN(IFR),(STOKESEF(IS,IOBFR),IS=1,4)
                ENDIF
              ENDDO !NFREQ
            ENDDO !NOBSV

            CLOSE(LUNSTO)

          ENDIF !IWFLSTOEF

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     Photon energy or wavelength and normalized components S0, S1/S0,'
          WRITE(LUNGFO,*)
     &      '     S2/S0, S3/S0 of STOKES vector and polarization for pinhole'
          WRITE(LUNGFO,*)
     &      '     (e-folded):'
          WRITE(LUNGFO,*)

          DO IFR=1,NFREQ

            IF (WSTOKESE(1,IFR).EQ.0.0) WSTOKESE(1,IFR)=1.E-10

            S1=WSTOKESE(1,IFR)
            S2=WSTOKESE(2,IFR)
            S3=WSTOKESE(3,IFR)
            S4=WSTOKESE(4,IFR)
            POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1

            IF (IUNIT.EQ.0)
     &        WRITE(LUNGFO,2584)SNGL(FREQ(IFR))
     &        ,WSTOKESE(1,IFR)
     &        ,(WSTOKESE(IS,IFR)/WSTOKESE(1,IFR),IS=2,4),POL

            IF (IUNIT.NE.0)
     &        WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &        ,WSTOKESE(1,IFR)
     &        ,(WSTOKESE(IS,IFR)/WSTOKESE(1,IFR),IS=2,4),POL

          ENDDO !IFR

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     Photon energy or wavelength and normalized components S0, S1/S0,'
          WRITE(LUNGFO,*)
     &      '     S2/S0, S3/S0 of STOKES vector and polarization for selected point of'
          WRITE(LUNGFO,*)
     &      '     pinhole (e-folded):'
          WRITE(LUNGFO,*)

          DO IFR=1,NFREQ

            IF (STOKECE(1,IFR).EQ.0.0) STOKECE(1,IFR)=1.E-10

            S1=STOKECE(1,IFR)
            S2=STOKECE(2,IFR)
            S3=STOKECE(3,IFR)
            S4=STOKECE(4,IFR)
            POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1

            IF (IUNIT.EQ.0)
     &        WRITE(LUNGFO,2584)SNGL(FREQ(IFR))
     &        ,STOKECE(1,IFR)
     &        ,(STOKECE(IS,IFR)/STOKECE(1,IFR),IS=2,4),POL

            IF (IUNIT.NE.0)
     &        WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &        ,STOKECE(1,IFR)
     &        ,(STOKECE(IS,IFR)/STOKECE(1,IFR),IS=2,4),POL

          ENDDO !IFR

          STOKESMAXE=0.0

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '      Total absolute maxima found for Stokes-V. with'
          WRITE(LUNGFO,*)
     &      '      e-spread (z,y,Eph,fluxdens.)'
          WRITE(LUNGFO,*)

          DO ISTOK=1,4

            DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
              DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
                IO=(IY-1)*NOBSVZ+IZ
                DO IFR=1,NFREQ
                  IF (ABS(STOKESE(ISTOK,IO+NOBSV*(IFR-1))).GT.
     &                STOKESMAXE(4,ISTOK)) THEN
                    STOKESMAXE(1,ISTOK)=OBSV(2,IO)
                    STOKESMAXE(2,ISTOK)=OBSV(3,IO)
                    STOKESMAXE(3,ISTOK)=FREQ(IFR)
                    STOKESMAXE(4,ISTOK)=STOKESE(ISTOK,IO+NOBSV*(IFR-1))
                  ENDIF
                ENDDO   !IFR
              ENDDO  !IZ
            ENDDO !IY

            WRITE(LUNGFO,'(6X,4((1PE12.4)))')STOKESMAXE(1:4,ISTOK)

          ENDDO !ISTOK

          IF (IFOLD.NE.0.and.ipin.ne.3)   THEN

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '     Energy, S0, S1/S0, S2/S0, S3/S0 and P for pinhole with emittance'
            WRITE(LUNGFO,*)
     &        '     (e-folded):'
            WRITE(LUNGFO,*)

            DO IFR=1,NFREQ

              IF (WSTOKESEF(1,IFR).EQ.0.0) WSTOKESEF(1,IFR)=1.E-10

              S1=WSTOKESEF(1,IFR)
              S2=WSTOKESEF(2,IFR)
              S3=WSTOKESEF(3,IFR)
              S4=WSTOKESEF(4,IFR)
              POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1

              IF (IUNIT.EQ.0)
     &          WRITE(LUNGFO,2584)SNGL(FREQ(IFR))
     &          ,WSTOKESEF(1,IFR)
     &          ,(WSTOKESEF(IS,IFR)/WSTOKESEF(1,IFR),IS=2,4),POL

              IF (IUNIT.NE.0)
     &          WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &          ,WSTOKESEF(1,IFR)
     &          ,(WSTOKESEF(IS,IFR)/WSTOKESEF(1,IFR),IS=2,4),POL

            ENDDO !IFR

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '     Energy, S0, S1/S0, S2/S0, S3/S0 and P for selected point of pinhole'
            WRITE(LUNGFO,*)
     &        '     with emittance (e-folded):'
            WRITE(LUNGFO,*)

            DO IFR=1,NFREQ

              IF (STOKECEF(1,IFR).EQ.0.0) STOKECEF(1,IFR)=1.E-10

              S1=STOKECEF(1,IFR)
              S2=STOKECEF(2,IFR)
              S3=STOKECEF(3,IFR)
              S4=STOKECEF(4,IFR)
              POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1

              IF (IUNIT.EQ.0)
     &          WRITE(LUNGFO,2584)SNGL(FREQ(IFR))
     &          ,STOKECEF(1,IFR)
     &          ,(STOKECEF(IS,IFR)/STOKECEF(1,IFR),IS=2,4),POL

              IF (IUNIT.NE.0)
     &          WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &          ,STOKECEF(1,IFR)
     &          ,(STOKECEF(IS,IFR)/STOKECEF(1,IFR),IS=2,4),POL

            ENDDO !IFR

          ENDIF !IFOLD

        ENDIF  !IPIN

        STOKESMAXEF=0.0

        IF (ipin.ne.3.and.IFOLD.NE.0) THEN

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '      Total absolute maxima found for Stokes-V. with'
          WRITE(LUNGFO,*)
     &      '      emit. and e-spread (z,y,Eph,fluxdens.)'
          WRITE(LUNGFO,*)

          DO ISTOK=1,4

            DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
              DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
                IO=(IY-1)*NOBSVZ+IZ
                DO IFR=1,NFREQ
                  IF (ABS(STOKESEF(ISTOK,IO+NOBSV*(IFR-1))).GT.
     &                STOKESMAXEF(4,ISTOK)) THEN
                    STOKESMAXEF(1,ISTOK)=OBSV(2,IO)
                    STOKESMAXEF(2,ISTOK)=OBSV(3,IO)
                    STOKESMAXEF(3,ISTOK)=FREQ(IFR)
                    STOKESMAXEF(4,ISTOK)=STOKESEF(ISTOK,IO+NOBSV*(IFR-1))
                  ENDIF
                ENDDO   !IFR
              ENDDO  !IZ
            ENDDO !IY

            WRITE(LUNGFO,'(6X,4((1PE12.4)))')STOKESMAXEF(1:4,ISTOK)

          ENDDO !ISTOK

        ENDIF !IFOLD

      ENDIF !IEFOLD

      IF(IWFILS.NE.0.AND.ISTOKES.NE.0) THEN

        OPEN(UNIT=LUNS,FILE=FILES)

        WRITE(LUNS,*)ICODE,' ',CODE
        WRITE(LUNS,*)NFREQ

        DO IFR=1,NFREQ
          IF (IUNIT.EQ.0)
     &      WRITE(LUNS,*)SNGL(FREQ(IFR))
     &      ,((WSTOKES(IS,IFR)),IS=1,4)
          IF (IUNIT.NE.0)
     &      WRITE(LUNS,*)SNGL(WELLEN(IFR))
     &      ,((WSTOKES(IS,IFR)),IS=1,4)
        ENDDO

        CLOSE(LUNS)
      ENDIF !IWFILS

      IF(IFOLD.NE.0.AND.IWFILSF.NE.0.AND.ISTOKES.NE.0) THEN

        OPEN(UNIT=LUNSF,FILE=FILESF)

        WRITE(LUNSF,*)ICODE,' ',CODE
        WRITE(LUNSF,*)NFREQ

        DO IFR=1,NFREQ
          IF (IUNIT.EQ.0)
     &      WRITE(LUNSF,*)SNGL(FREQ(IFR))
     &      ,((WSTOKESF(IS,IFR)),IS=1,4)
          IF (IUNIT.NE.0)
     &      WRITE(LUNSF,*)SNGL(WELLEN(IFR))
     &      ,((WSTOKESF(IS,IFR)),IS=1,4)
        ENDDO

        CLOSE(LUNSF)
      ENDIF !IWFILSF

      IF(IEFOLD.NE.0.AND.IWFILSE.NE.0.AND.ISTOKES.NE.0) THEN

        OPEN(UNIT=LUNSE,FILE=FILESE)

        WRITE(LUNSE,*)ICODE,' ',CODE
        WRITE(LUNSE,*)NFREQ

        DO IFR=1,NFREQ
          IF (IUNIT.EQ.0)
     &      WRITE(LUNSE,*)SNGL(FREQ(IFR))
     &      ,((WSTOKESE(IS,IFR)),IS=1,4)
          IF (IUNIT.NE.0)
     &      WRITE(LUNSE,*)SNGL(WELLEN(IFR))
     &      ,((WSTOKESE(IS,IFR)),IS=1,4)
        ENDDO

        CLOSE(LUNSE)
      ENDIF !IWFILSE

      IF(IEFOLD.NE.0.AND.IFOLD.NE.0.AND.IWFILSEF.NE.0.AND.ISTOKES.NE.0) THEN

        OPEN(UNIT=LUNSEF,FILE=FILESEF)

        WRITE(LUNSEF,*)ICODE,' ',CODE
        WRITE(LUNSEF,*)NFREQ

        DO IFR=1,NFREQ
          IF (IUNIT.EQ.0)
     &      WRITE(LUNSEF,*)SNGL(FREQ(IFR))
     &      ,((WSTOKESEF(IS,IFR)),IS=1,4)
          IF (IUNIT.NE.0)
     &      WRITE(LUNSEF,*)SNGL(WELLEN(IFR))
     &      ,((WSTOKESEF(IS,IFR)),IS=1,4)
        ENDDO

        CLOSE(LUNSEF)
      ENDIF !IWFILSEF

      IF(IWFILB.NE.0.AND.ISTOKES.NE.0) THEN

        OPEN(UNIT=LUNC,FILE=FILEC)

        WRITE(LUNC,*)ICODE,' ',CODE
        WRITE(LUNC,*)nintFREQ

        DO IFR=1,NFREQ
           if (freq(ifr).ge.freqlow-(freq(2)-freq(1))/2.0d0
     &         .and.freq(ifr).le.freqhig+(freq(2)-freq(1))/2.0d0) then
          IF (IUNIT.EQ.0)
     &      WRITE(LUNC,*)SNGL(FREQ(IFR))
     &      ,((STOKEC(IS,IFR)),IS=1,4)
          IF (IUNIT.NE.0)
     &      WRITE(LUNC,*)SNGL(WELLEN(IFR))
     &      ,((STOKEC(IS,IFR)),IS=1,4)
          endif
        ENDDO

        CLOSE(LUNC)
      ENDIF !IWFILB

      IF(IFOLD.NE.0.AND.IWFILBF.NE.0.AND.ISTOKES.NE.0) THEN

        OPEN(UNIT=LUNCF,FILE=FILECF)

        WRITE(LUNCF,*)ICODE,' ',CODE
        WRITE(LUNCF,*)NintFREQ

        DO IFR=1,NFREQ
           if (freq(ifr).ge.freqlow-(freq(2)-freq(1))/2.0d0
     &         .and.freq(ifr).le.freqhig+(freq(2)-freq(1))/2.0d0) then
          IF (IUNIT.EQ.0)
     &      WRITE(LUNCF,*)SNGL(FREQ(IFR))
     &      ,((STOKECF(IS,IFR)),IS=1,4)
          IF (IUNIT.NE.0)
     &      WRITE(LUNCF,*)SNGL(WELLEN(IFR))
     &      ,((STOKECF(IS,IFR)),IS=1,4)
          endif
        ENDDO

        CLOSE(LUNCF)
      ENDIF !IWFILBF

      IF(IEFOLD.NE.0.AND.IWFILBE.NE.0.AND.ISTOKES.NE.0) THEN

         OPEN(UNIT=LUNCE,FILE=FILECE)

         WRITE(LUNCE,*)ICODE,' ',CODE
         WRITE(LUNCE,*)nintFREQ

         DO IFR=1,NFREQ
           if (freq(ifr).ge.freqlow-(freq(2)-freq(1))/2.0d0
     &         .and.freq(ifr).le.freqhig+(freq(2)-freq(1))/2.0d0) then
           IF (IUNIT.EQ.0)
     &       WRITE(LUNCE,*)SNGL(FREQ(IFR))
     &       ,((STOKECE(IS,IFR)),IS=1,4)
           IF (IUNIT.NE.0)
     &       WRITE(LUNCE,*)SNGL(WELLEN(IFR))
     &       ,((STOKECE(IS,IFR)),IS=1,4)
           endif
         ENDDO

         CLOSE(LUNCE)
       ENDIF !IWFILBE

       IF(IEFOLD.NE.0.AND.IFOLD.NE.0.AND.IWFILBEF.NE.0.AND.ISTOKES.NE.0) THEN

         OPEN(UNIT=LUNCEF,FILE=FILECEF)

         WRITE(LUNCEF,*)ICODE,' ',CODE
         WRITE(LUNCEF,*)NintFREQ

         DO IFR=1,NFREQ
           if (freq(ifr).ge.freqlow-(freq(2)-freq(1))/2.0d0
     &         .and.freq(ifr).le.freqhig+(freq(2)-freq(1))/2.0d0) then
           IF (IUNIT.EQ.0)
     &       WRITE(LUNCEF,*)SNGL(FREQ(IFR))
     &       ,((STOKECEF(IS,IFR)),IS=1,4)
           IF (IUNIT.NE.0)
     &       WRITE(LUNCEF,*)SNGL(WELLEN(IFR))
     &       ,((STOKECEF(IS,IFR)),IS=1,4)
           endif
         ENDDO

         CLOSE(LUNCEF)
       ENDIF !IWFILBEF

       IF (ISTOKES.NE.0) THEN

         DO ISTO=1,4

           DO IFREQ=1,NFREQ
             SPECBUFF(IFREQ)=ABS(STOKEC(ISTO,IFREQ))
           ENDDO  !IFR
           CALL UTIL_MAX_PARABEL
     &       (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
           STOKCMX(ISTO,1)=DUM1
           STOKCMX(ISTO,2)=DUM2

           IF (IFAIL.NE.0) THEN
             WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S',ISTO
             WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
           ENDIF

           IF (IFOLD.NE.0) THEN
             DO IFREQ=1,NFREQ
               SPECBUFF(IFREQ)=ABS(STOKECF(ISTO,IFREQ))
             ENDDO   !IFR
             CALL UTIL_MAX_PARABEL
     &         (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
             STOKCMXF(ISTO,1)=DUM1
             STOKCMXF(ISTO,2)=DUM2
             IF (IFAIL.NE.0) THEN
               WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S',ISTO
               WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
             ENDIF
           ENDIF

           IF (IEFOLD.NE.0) THEN
             DO IFREQ=1,NFREQ
               SPECBUFF(IFREQ)=ABS(STOKECE(ISTO,IFREQ))
             ENDDO   !IFR
             CALL UTIL_MAX_PARABEL
     &         (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
             STOKCMXE(ISTO,1)=DUM1
             STOKCMXE(ISTO,2)=DUM2
             IF (IFAIL.NE.0) THEN
               WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S',ISTO
               WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
             ENDIF
           ENDIF

           IF (IFOLD.NE.0.AND.IEFOLD.NE.0) THEN
             DO IFREQ=1,NFREQ
               SPECBUFF(IFREQ)=ABS(STOKECEF(ISTO,IFREQ))
             ENDDO   !IFR
             CALL UTIL_MAX_PARABEL
     &         (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
             STOKCMXEF(ISTO,1)=DUM1
             STOKCMXEF(ISTO,2)=DUM2
             IF (IFAIL.NE.0) THEN
               WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S',ISTO
               WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
             ENDIF
           ENDIF

         ENDDO !ISTO

       ENDIF   !ISTOKES

       IF (NFREQ.GT.1) THEN

         IF (ISTOKES.NE.0) THEN

           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
          if (ipin.ne.3) then
            WRITE(LUNGFO,*)
     &        '      Estimated maxima of s0, s1, s2 ,s3 for selected point:'
          else
            WRITE(LUNGFO,*)
     &        '      Estimated maxima of mean densities of s0, s1, s2 ,s3:'
          endif
           DO ISTO=1,4
             WRITE(LUNGFO,*)'      ',STOKCMX(ISTO,1),STOKCMX(ISTO,2)
           ENDDO  !ISTO

           IF (IFOLD.NE.0) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &         '      Estimated maxima of s0, s1, s2 ,s3 for selected point with emittance:'
             DO ISTO=1,4
               WRITE(LUNGFO,*)'      ',STOKCMXF(ISTO,1),STOKCMXF(ISTO,2)
             ENDDO   !ISTO
           ENDIF  !IFOLD

           IF (IEFOLD.NE.0) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &         '      Estimated maxima of s0, s1, s2 ,s3 for selected point with energy spread:'
             DO ISTO=1,4
               WRITE(LUNGFO,*)'      ',STOKCMXE(ISTO,1),STOKCMXE(ISTO,2)
             ENDDO   !ISTO
           ENDIF  !IFOLD

           IF (IFOLD.NE.0.AND.IEFOLD.NE.0) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &         '      Estimated maxima of s0, s1, s2 ,s3 for selected point'
             WRITE(LUNGFO,*)
     &         '      with emittance and energy spread:'
             DO ISTO=1,4
               WRITE(LUNGFO,*)'      ',STOKCMXEF(ISTO,1),STOKCMXEF(ISTO,2)
             ENDDO   !ISTO
           ENDIF

           DO IFREQ=1,NFREQ
             S1=STOKEC(1,IFREQ)
             S2=STOKEC(2,IFREQ)
             S3=STOKEC(3,IFREQ)
             S4=STOKEC(4,IFREQ)
             IF (S1.NE.0.0) THEN
               POL=S4/S1*S4
             ELSE
               POL=0.0d0
             ENDIF
             SPECBUFF(IFREQ)=ABS(POL)
           ENDDO  !IFR
           CALL UTIL_MAX_PARABEL
     &       (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
           G3CMX(1)=DUM1
           G3CMX(2)=DUM2
           IF (IFAIL.NE.0) THEN
             WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S'
             WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
           ENDIF

           IF (IFOLD.NE.0) THEN
             DO IFREQ=1,NFREQ
               S1=STOKECF(1,IFREQ)
               S2=STOKECF(2,IFREQ)
               S3=STOKECF(3,IFREQ)
               S4=STOKECF(4,IFREQ)
               IF (S1.NE.0.0) THEN
                 POL=S4/S1*S4
               ELSE
                 POL=0.0d0
               ENDIF
               SPECBUFF(IFREQ)=ABS(POL)
             ENDDO   !IFR
             CALL UTIL_MAX_PARABEL
     &         (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
             G3CMXF(1)=DUM1
             G3CMXF(2)=DUM2
             IF (IFAIL.NE.0) THEN
               WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S3*S3/S0'
               WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
             ENDIF
           ENDIF

           IF (IEFOLD.NE.0) THEN
             DO IFREQ=1,NFREQ
               S1=STOKECE(1,IFREQ)
               S2=STOKECE(2,IFREQ)
               S3=STOKECE(3,IFREQ)
               S4=STOKECE(4,IFREQ)
               IF (S1.NE.0.0) THEN
                 POL=S4/S1*S4
               ELSE
                 POL=0.0d0
               ENDIF
               SPECBUFF(IFREQ)=ABS(POL)
             ENDDO   !IFR
             CALL UTIL_MAX_PARABEL
     &         (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
             G3CMXE(1)=DUM1
             G3CMXE(2)=DUM2
             IF (IFAIL.NE.0) THEN
               WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S3*S3/S0'
               WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
             ENDIF
           ENDIF

           IF (IFOLD.NE.0.AND.IEFOLD.NE.0) THEN

             DO IFREQ=1,NFREQ
               S1=STOKECEF(1,IFREQ)
               S2=STOKECEF(2,IFREQ)
               S3=STOKECEF(3,IFREQ)
               S4=STOKECEF(4,IFREQ)
               IF (S1.NE.0.0) THEN
                 POL=S4/S1*S4
               ELSE
                 POL=0.0d0
               ENDIF
               SPECBUFF(IFREQ)=ABS(POL)
             ENDDO   !IFREQ

             CALL UTIL_MAX_PARABEL
     &         (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
             G3CMXEF(1)=DUM1
             G3CMXEF(2)=DUM2
             IF (IFAIL.NE.0) THEN
               WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S3*S3/S0'
               WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
             ENDIF

           ENDIF  !IFOLD,IEFOLD

           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
           if (ipin.ne.3) then
             WRITE(LUNGFO,*)
     &         '      Estimated maximum of s3*s3/s0 for selected point:'
           else
             WRITE(LUNGFO,*)
     &         '      Estimated maximum of mean density s3*s3/s0:'
           endif
           WRITE(LUNGFO,*)'      ',G3CMX(1),G3CMX(2)

           IF (IFOLD.NE.0) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &         '      Estimated maximum of s3*s3/s0 for selected point with emittance:'
             WRITE(LUNGFO,*)'      ',G3CMXF(1),G3CMXF(2)
           ENDIF!IFOLD

           IF (IEFOLD.NE.0) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &         '      Estimated maximum of s3*s3/s0 for selected point with energy spread:'
             WRITE(LUNGFO,*)'      ',G3CMXE(1),G3CMXE(2)
           ENDIF  !IEFOLD

           IF (IFOLD.NE.0.AND.IEFOLD.NE.0) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &         '      Estimated maximum of s3*s3/s0 for selected point'
             WRITE(LUNGFO,*)
     &         '      with emittance and energy spread:'
             WRITE(LUNGFO,*)'      ',G3CMXEF(1),G3CMXEF(2)
           ENDIF !IFOLD,IEFOLD

           IF (IPIN.NE.0) THEN

             DO ISTO=1,4

               DO IFREQ=1,NFREQ
                 SPECBUFF(IFREQ)=ABS(WSTOKES(ISTO,IFREQ))
c                 print*,"spectrum:",isto,ifreq,wstokes(isto,ifreq)
               ENDDO !IFR
               CALL UTIL_MAX_PARABEL
     &           (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
               WSTOKMX(ISTO,1)=DUM1
               WSTOKMX(ISTO,2)=DUM2
               IF (IFAIL.NE.0) THEN
                 WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S',ISTO
                 WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
               ENDIF


               IF (IFOLD.NE.0) THEN
                 DO IFREQ=1,NFREQ
                   SPECBUFF(IFREQ)=ABS(WSTOKESF(ISTO,IFREQ))
                 ENDDO  !IFR
                 CALL UTIL_MAX_PARABEL
     &             (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
                 WSTOKMXF(ISTO,1)=DUM1
                 WSTOKMXF(ISTO,2)=DUM2
                 IF (IFAIL.NE.0) THEN
                   WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S',ISTO
                   WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
                 ENDIF
               ENDIF !IFOLD

               IF (IEFOLD.NE.0) THEN
                 DO IFREQ=1,NFREQ
                   SPECBUFF(IFREQ)=ABS(WSTOKESE(ISTO,IFREQ))
                 ENDDO  !IFR
                 CALL UTIL_MAX_PARABEL
     &             (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
                 WSTOKMXE(ISTO,1)=DUM1
                 WSTOKMXE(ISTO,2)=DUM2
                 IF (IFAIL.NE.0) THEN
                   WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S',ISTO
                   WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
                 ENDIF
               ENDIF !IEFOLD

               IF (IFOLD.NE.0.AND.IEFOLD.NE.0) THEN
                 DO IFREQ=1,NFREQ
                   SPECBUFF(IFREQ)=ABS(WSTOKESEF(ISTO,IFREQ))
                 ENDDO  !IFR
                 CALL UTIL_MAX_PARABEL
     &             (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
                 WSTOKMXEF(ISTO,1)=DUM1
                 WSTOKMXEF(ISTO,2)=DUM2
                 IF (IFAIL.NE.0) THEN
                   WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S',ISTO
                   WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
                 ENDIF
               ENDIF !IFOLD,IEFOLD

             ENDDO   !ISTO

             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &         '      Estimated maxima of fluxes s0, s1, s2 ,s3:'
             DO ISTO=1,4
               WRITE(LUNGFO,*)'      ',WSTOKMX(ISTO,1),WSTOKMX(ISTO,2)
             ENDDO   !ISTO

             IF (IFOLD.NE.0) THEN
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
     &           '      Estimated maxima of fluxes s0, s1, s2 ,s3 with emittance:'
               DO ISTO=1,4
                 WRITE(LUNGFO,*)'      ',WSTOKMXF(ISTO,1),WSTOKMXF(ISTO,2)
               ENDDO !ISTO
             ENDIF

             IF (IEFOLD.NE.0) THEN
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
     &           '      Estimated maxima of fluxes s0, s1, s2 ,s3 with energy spread:'
               DO ISTO=1,4
                 WRITE(LUNGFO,*)'      ',WSTOKMXE(ISTO,1),WSTOKMXE(ISTO,2)
               ENDDO !ISTO
             ENDIF

             IF (IFOLD.NE.0.AND.IEFOLD.NE.0) THEN
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
     &           '      Estimated maxima of fluxes s0, s1, s2 ,s3'
               WRITE(LUNGFO,*)
     &           '      with emittance and energy spread:'
               DO ISTO=1,4
                 WRITE(LUNGFO,*)'      ',WSTOKMXEF(ISTO,1),WSTOKMXEF(ISTO,2)
               ENDDO !ISTO
             ENDIF

             DO IFREQ=1,NFREQ
               S1=WSTOKES(1,IFREQ)
               S2=WSTOKES(2,IFREQ)
               S3=WSTOKES(3,IFREQ)
               S4=WSTOKES(4,IFREQ)
               IF (S1.NE.0.0) THEN
                 POL=S4/S1*S4
               ELSE
                 POL=0.0d0
               ENDIF
               SPECBUFF(IFREQ)=ABS(POL)
             ENDDO   !IFR
             CALL UTIL_MAX_PARABEL
     &         (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
             WG3MX(1)=DUM1
             WG3MX(2)=DUM2
             IF (IFAIL.NE.0) THEN
               WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S3*S3/S0'
               WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
             ENDIF

             IF (IEFOLD.NE.0) THEN
               DO IFREQ=1,NFREQ
                 S1=WSTOKESE(1,IFREQ)
                 S2=WSTOKESE(2,IFREQ)
                 S3=WSTOKESE(3,IFREQ)
                 S4=WSTOKESE(4,IFREQ)
                 IF (S1.NE.0.0) THEN
                   POL=S4/S1*S4
                 ELSE
                   POL=0.0d0
                 ENDIF
                 SPECBUFF(IFREQ)=ABS(POL)
               ENDDO !IFR
               CALL UTIL_MAX_PARABEL
     &           (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
               WG3MXE(1)=DUM1
               WG3MXE(2)=DUM2
               IF (IFAIL.NE.0) THEN
                 WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S3*S3/S0'
                 WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
               ENDIF
             ENDIF   !IEFOLD

             IF (IFOLD.NE.0) THEN
               DO IFREQ=1,NFREQ
                 S1=WSTOKESF(1,IFREQ)
                 S2=WSTOKESF(2,IFREQ)
                 S3=WSTOKESF(3,IFREQ)
                 S4=WSTOKESF(4,IFREQ)
                 IF (S1.NE.0.0) THEN
                   POL=S4/S1*S4
                 ELSE
                   POL=0.0d0
                 ENDIF
                 SPECBUFF(IFREQ)=ABS(POL)
               ENDDO !IFR
               CALL UTIL_MAX_PARABEL
     &           (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
               WG3MXF(1)=DUM1
               WG3MXF(2)=DUM2
               IF (IFAIL.NE.0) THEN
                 WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S3*S3/S0'
                 WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
               ENDIF
             ENDIF   !IFOLD

             IF (IFOLD.NE.0.AND.IEFOLD.NE.0) THEN
               DO IFREQ=1,NFREQ
                 S1=WSTOKESEF(1,IFREQ)
                 S2=WSTOKESEF(2,IFREQ)
                 S3=WSTOKESEF(3,IFREQ)
                 S4=WSTOKESEF(4,IFREQ)
                 IF (S1.NE.0.0) THEN
                   POL=S4/S1*S4
                 ELSE
                   POL=0.0d0
                 ENDIF
                 SPECBUFF(IFREQ)=ABS(POL)
               ENDDO !IFR
               CALL UTIL_MAX_PARABEL
     &           (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
               WG3MXEF(1)=DUM1
               WG3MXEF(2)=DUM2
               IF (IFAIL.NE.0) THEN
                 WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S3*S3/S0'
                 WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
               ENDIF
             ENDIF   !IFOLD,IEFOLD

             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &         '      Estimated maxima of fluxes s3*s3/s0:'
             WRITE(LUNGFO,*)'      ',WG3MX(1),WG3MX(2)

             IF (IFOLD.NE.0) THEN
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
     &           '      Estimated maxima of fluxes s3*s3/s0 with emittance:'
               WRITE(LUNGFO,*)'      ',WG3MXF(1),WG3MXF(2)
             ENDIF

             IF (IEFOLD.NE.0) THEN
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
     &           '      Estimated maxima of fluxes s3*s3/s0 with energy spread:'
               WRITE(LUNGFO,*)'      ',WG3MXE(1),WG3MXE(2)
             ENDIF

             IF (IFOLD.NE.0.AND.IEFOLD.NE.0) THEN
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
     &           '      Estimated maxima of fluxes s3*s3/s0'
               WRITE(LUNGFO,*)
     &           '      with emittance and energy spread:'
               WRITE(LUNGFO,*)'      ',WG3MXEF(1),WG3MXEF(2)
             ENDIF

           ENDIF  !ISTOKES

         ENDIF !IPIN

      ENDIF !NFREQ

C---BRILLIANCE


      IF (IBRILL.NE.0) CALL BRILL

C--- STORE RESULT IN HISTOGRAMS

      ALLOCATE(FILL(NOBSV))
      DO I=1,NOBSV
        FILL(I)=0.0d0
      ENDDO

      IF(IHPIN.GT.0) THEN
        CALL HSPEC
      ELSE IF (IHFOLD.NE.0) THEN
        CALL HFOLD
      ENDIF

      !{ Fold power density
      !Baustelle
      !} Fold power density

      IF(IWFILPOW.NE.0) THEN

         OPEN(UNIT=LUNPOW,FILE=FILEPOW)

         IF (IWFILPOW.GT.0) THEN
           WRITE(LUNPOW,*)ICODE,' ',CODE
         ENDIF

         if (ipin.ne.0) then
           DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
             DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
               IO=(IY-1)*NOBSVZ+IZ
               DUM1=0.0d0
               IF(IFOLD.NE.0) DUM1=SPECTOTIF(IO)
               WRITE(LUNPOW,'(7(1PE13.5))')(OBSV(IX,IO)*1.E3,IX=1,3)
     &           ,SPECPOWT(IO)/1.0E6,SPECTOTI(IO)/1.E6,DUM1/1.E6
     &           ,SPECPOWTgraz(IO)/1.0e6
             ENDDO
           ENDDO
         else
           dum1=0.0d0
           do iobsv=1,nobsv
             write(lunpow,'(7(1pe13.5))')(obsv(ix,iobsv)*1.e3,ix=1,3)
     &         ,specpowt(iobsv)/1.0e6,spectoti(iobsv)/1.e6,dum1/1.e6
     &         ,SPECPOWTgraz(iobsv)/1.0e6
           enddo
         endif

         CLOSE(LUNPOW)

      ENDIF !IWFILPOW

      if (iphoton.ne.0.and.ecphoton.gt.0.0d0) call uout_photon

      IF(IHFREQ.NE.0) CALL HFREQ

      RETURN
      END
+DECK,uout.
*CMZ :  4.01/04 17/10/2023  12.50.02  by  Michael Scheer
*CMZ :  4.01/03 15/05/2023  14.11.27  by  Michael Scheer
*CMZ :  4.00/17 15/11/2022  10.13.07  by  Michael Scheer
*CMZ :  4.00/15 01/06/2022  16.47.26  by  Michael Scheer
*CMZ :  4.00/11 28/06/2021  10.33.06  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine uout

+seq,trackf90u.
+seq,spectf90u.

      use sourcef90
      use observf90
      use afreqf90
      !use waveenv

      implicit none

+self,if=uout_scheer.
      complex*16 amp0(3),amp(3),zexp

      double precision dtelec,dtpho,t0,perlen,dph,dobs(3),drn(3),cosang,
     &  dobsn(3),r0(3),r(3),dr(3),v(3),t,dt,dist,obs(3),om,fd,dist0

      double precision :: enemax=0.0d0,s0max=-1.0d30

      integer ifreq,iobsv,nper,i,lunio,iseed
      integer, parameter :: ndimsplit=100
      integer :: nwords=0, ipos(2,ndimsplit),istat=0,mode=0,io,ifr

      character(2048) cline
+self.
+seq,contrl.
+seq,cmpara.
+seq,track.
+seq,track0.
+seq,spect.
+seq,observ.
+seq,freqs.
+seq,sourcef90.
+seq,berror.
+seq,ampli.
+seq,phycon.
+seq,waveenv.
+seq,uservar.

+self,if=uout_scheer.
      if (iuout.eq.20220601) then
        enemax=spectotmx(3)
        s0max=spectotmx(4)/1.0d6
        open(newunit=lunio,file='uout.in',status='old',iostat=iseed)
        if (iseed.eq.0) then
          read(lunio,*) iseed
        else
          iseed=0
        endif
        close(lunio)
        open(newunit=lunio,file='serie_pherror.out',access='append')
        if (iberror.ne.0) then
          if (nberror.eq.0) then
            write(lunio,*) trim(chwstage)//'-1/2_1_-1/2',iseed,b0error,resrms*360.0d0,
     &        enemax,s0max
          else if (nberror.eq.1) then
            write(lunio,*) trim(chwstage)//'_1_',iseed,b0error,resrms*360.0d0,
     &        enemax,s0max
          else if (nberror.eq.2) then
            write(lunio,*) trim(chwstage)//'-1_1_',iseed,b0error,resrms*360.0d0,
     &        enemax,s0max
          endif
        else
          if (userchar(1).eq.'b0error') then
            write(lunio,*) trim(chwstage)//"_berr",iseed,'-1',user(1),resrms*360.0d0,
     &        enemax,s0max
          else
            write(lunio,*) trim(chwstage)//'_pherr',iseed,'-2',phrerror,resrms*360.0d0,
     &        enemax,s0max
          endif
        endif
        flush(lunio)
        close(lunio)
        return
      endif

      if (iuout.eq.20220516) then
c        s0max=-1.0d30
c        do io=1,nobsv
c          do ifr=1,nfreq
c            if (spectot(io+nobsv*(ifr-1)).gt.s0max) then
c              enemax=freq(ifr)
c              s0max=spectot(io+nobsv*(ifr-1))/1.0d6
c            endif
c          enddo
c        enddo
        enemax=spectotmx(3)
        s0max=spectotmx(4)/1.0d6
        open(newunit=lunio,file='uout.in',status='old',iostat=iseed)
        if (iseed.eq.0) then
          read(lunio,*) iseed
        else
          iseed=0
        endif
        close(lunio)
        open(newunit=lunio,file='serie_b0error.out',access='append')
        write(lunio,'(2I10,4(1pe15.7))') icode,iseed,b0error,resrms*360.0d0,
     &    enemax,s0max
        flush(lunio)
        close(lunio)
        return
      endif

      if (iuout.eq.20220517) then
c        s0max=-1.0d30
c        do io=1,nobsv
c          do ifr=1,nfreq
c            if (spectot(io+nobsv*(ifr-1)).gt.s0max) then
c              enemax=freq(ifr)
c              s0max=spectot(io+nobsv*(ifr-1))/1.0d6
c            endif
c          enddo
c        enddo
        enemax=spectotmx(3)
        s0max=spectotmx(4)/1.0d6
        open(newunit=lunio,file='uout.in',status='old',iostat=iseed)
        if (iseed.eq.0) then
          read(lunio,'(a)') cline
          call util_string_split(cline,ndimsplit,nwords,ipos,istat)
        else
          cline='0 unknown'
        endif
        close(lunio)
        open(newunit=lunio,file='serie_amprep.out',access='append')
        write(lunio,'(I10," ",a," ",3(1pe15.7))') icode,trim(cline),
     &    phrerror,enemax,s0max
        flush(lunio)
        close(lunio)
        return
      endif

      afreq=(0.0d0,0.0d0)
      dtelec=tftrack-t0track

      r0=[x0,y0,z0]
      dr=[xf0-x0,yf0-y0,zf0-z0]
      drn=dr/norm2(dr)

      perlen=norm2(dr)
      dtpho=perlen/clight1

      nper=100

      do iobsv=1,nobsv
        obs=obsv(1:3,iobsv)
        dist0=norm2(obs-r0)
        do ifreq=1,nfreq
          om=freq(ifreq)/hbarev1
          ifrob=iobsv+nobsv*(ifreq-1)
          amp=(0.0d0,0.0d0)
          amp0(1:3)=dcmplx(reaima(1:3,1,ifrob),reaima(1:3,2,ifrob))
          t=-dt
          do i=1-nper/2,nper-nper/2
            r=r0+i*dr
            dobs=obs-r
            dist=norm2(obs-r)
            dobsn=dobs/dist
            cosang=dot_product(drn,dobsn)
            dt=dtelec-dtpho*cosang
            t=t+dt
            dph=om*t
            zexp=cdexp(dcmplx(0.0d0,dph))
            amp=amp+amp0*zexp*dist0/dist
          enddo
          afreq(:,ifrob)=amp
          fd=sum(real(amp)**2+imag(amp)**2)*specnor
          write(66,*)sngl(obsv(:,iobsv)),sngl(freq(ifreq)),
     &      sngl(real(amp(3))),sngl(imag(amp(3))),sngl(fd)
        enddo !ifreq
      enddo !nobsv
+self.
+self,if=ivue32,if=uout_scheer.

+seq,spectf90u.
      use sourcef90
      use observf90

      implicit none
c      include 'uservar.cmn'

+seq,cmpara.
+seq,spect.
+seq,observ.
+seq,sourcef90.

      double precision sou(3),x,y,z,dx,dy,dz,cosa,dxs,dys,dzs

      integer :: iobsv,isour,lun,lunob

      open(newunit=lunob,file='observ.in',status='old',readonly)

      open(newunit=lun,file='ivue32_uout.dat',recl=512)
      write(lun,'(a)')"* Nsour, Nobs, Xsou, Ysou, Zsou, Xobs, Yobs, Zobs, PowPerp, PowGraz ( Watt and mm)"

      do isour=1,nsource

        rewind(lunob)

        do iobsv=1,nobsv

          read(lunob,*) x,y,z,dx,dy,dz

          dxs=obsv(1,iobsv)-schwingercen(1,iobsv,isour)
          dys=obsv(2,iobsv)-schwingercen(2,iobsv,isour)
          dzs=obsv(3,iobsv)-schwingercen(3,iobsv,isour)

          cosa=(dx*dxs+dy*dys+dz*dzs)/
     &      sqrt(dx**2+dy**2+dz**2)/
     &      sqrt(dxs**2+dys**2+dzs**2)

          write(lun,'(2i5,8g15.5)') nsource,iobsv,
     &      schwingercen(1:3,iobsv,isour),obsv(1:3,iobsv)*1000.0,
     &      specpowt(iobsv)/1.0e6,
     &      specpowt(iobsv)/1.0e6*sqrt(1.0d0-min(1.0d0,cosa**2))

        enddo !nobsv

      enddo ! nsource

      flush(lun)
      close(lun)
      close(lunob)

      print*,""
      print*,"     UOUT: ivue32_uout.dat written "
      print*,""
+self.

      return
      end
+DECK,cyltocart.
*CMZ :  4.01/04 15/11/2023  12.38.14  by  Michael Scheer
*CMZ :  4.01/03 28/06/2023  13.07.07  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.66/02 26/10/2009  14.33.39  by  Michael Scheer
*CMZ :  2.65/01 08/10/2009  09.58.11  by  Michael Scheer
*CMZ :  2.65/00 18/09/2009  08.30.19  by  Michael Scheer
*CMZ :  2.64/06 15/09/2009  09.52.14  by  Michael Scheer
*CMZ :  2.64/05 14/09/2009  10.06.11  by  Michael Scheer
*-- Author :    Michael Scheer   01/09/2009
      subroutine cyltocart(isour)
+seq,gplhint.

+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,AFREQF90U.
+SEQ,SPECTF90U.
+SEQ,WFOLDF90U.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEq,observf90.
+SEQ,DEPOLA.
+SEq,wfoldf90.
+seq,sourcef90.
+SEQ,FREQS.
+SEQ,PHYCON.
+SEQ,SPECTF90.

c
c Alte Version 154 wieder  hervorgeholt, da sie besser mit MPINR=0 uebereinstimmt.
c
c

c fill AFREQ and SPECPOW by interpolating AFREQRPHI and SPECPOWRPHI

      double precision, dimension(:,:,:), allocatable :: fr,coefr
      double precision, dimension(:,:), allocatable :: phas
      double precision, dimension(:), allocatable :: w1,w2,w3,w4,
     &  fp,coefp,obsvedge,frw

      double complex af2,af3
c     &  ,expom

      double precision y,z,r,phi,pihalf,phiedge,yp12,
     &  phiy,phiz,phiy1,phiz1,
     &  dist0,dist02,ddist,h2,cenxexi,dvlen,
     &  dphase,dphi,pi2phaser2,pi2phaser3,pi2phasephi2,pi2phasephi3,
     &  af2r,af2i,af3r,af3i,
     &  af2ro,af2io,af3ro,af3io

      integer ixy,iphi,ir,ifreq,iphas,iobrp,istat,medge,
     &  ifirst,ilast,iedge,isour,jphi,nphi,ical

      data ical/0/

      if (ical.eq.0) then

        medge=3
        yp12=9999.0d0

        allocate(phas(4,nobsv))

        allocate(frw(nobsvr))
        allocate(fr(nobsvr,4,nobsvphi))
        allocate(coefr(nobsvr,4,nobsvphi))

        allocate(fp(nobsvphi+2*medge+1))
        allocate(obsvedge(nobsvphi+2*medge+1))
        allocate(coefp(nobsvphi+2*medge+1))

        allocate(w1(max(nobsvr,nobsvphi+2*medge+1)))
        allocate(w2(max(nobsvr,nobsvphi+2*medge+1)))
        allocate(w3(max(nobsvr,nobsvphi+2*medge+1)))
        allocate(w4(max(nobsvr,nobsvphi+2*medge+1)))

        pihalf=pi1/2.0d0

        ifirst=medge+1

        if (iquadphi.eq.0) then
          ilast=ifirst+nobsvphi
          obsvedge(ilast)=obsvphi(nobsvphi)+obsvdphi
        else
          ilast=ifirst+nobsvphi-1
        endif

        do iphi=1,nobsvphi
          obsvedge(ifirst+iphi-1)=obsvphi(iphi)
        enddo

        do iedge=1,medge
          obsvedge(ilast+iedge)=obsvedge(ilast+iedge-1)+obsvdphi
        enddo

        do iedge=1,medge
          obsvedge(ifirst-iedge)=obsvedge(ifirst-iedge+1)-obsvdphi
        enddo

        ical=1

      endif

        cenxexi=(min(sourceeo(1,1,isour),xiend)
     &    +max(sourceao(1,1,isour),xianf))/2.d0
        dvlen=
     &    min(sourceeo(1,1,isour),xiend)-
     &    max(sourceao(1,1,isour),xianf)
        if (iampli.lt.0) then
          dvlen=dvlen*(-iampli)
        endif
        dist0=pincen(1)-cenxexi
        dist02=dist0**2

      do ifreq=1,nfreq

        iobrp=0
        ixy=1

        pi2phasephi2=0.0d0
        pi2phasephi3=0.0d0
        do iphi=1,nobsvphi

          phiy1=-twopi1
          phiz1=-twopi1

          pi2phaser2=0.0d0
          pi2phaser3=0.0d0
          do ir=1,nobsvr

            iobrp=iobrp+1
            ifrob=ifreq+nfreq*(iobrp-1)

            h2=(obsvr(ir)/dist0)**2
            if (h2.lt.0.01) then
              ddist=dist0*(h2/2.0d0-h2**2/8.0d0)
            else
              ddist=dist0*(sqrt(1.0d0+h2)-1.0d0)
            endif

            dphase=ddist/freq(ifreq)*wtoe1*1.0d9*twopi1

            af2=afreqrphi(2,IFROB)
            af3=afreqrphi(3,IFROB)
            af2r=dreal(af2)
            af2i=dimag(af2)
            af3r=dreal(af3)
            af3i=dimag(af3)

            phiy=atan2(af2i,af2r)
            phiz=atan2(af3i,af3r)

            fr(ir,1,iphi)=abs(af2)
            fr(ir,2,iphi)=phiy-dphase
            fr(ir,3,iphi)=abs(af3)
            fr(ir,4,iphi)=phiz-dphase

c            print*,ir,iphi,phiz+dphase,phiz-dphase

            phiy1=phiy
            phiz1=phiz
            af2ro=af2r
            af2io=af2i
            af3ro=af3r
            af3io=af3i

          enddo !nobsvr

          do iphas=2,4,2
            frw(1)=fr(1,iphas,iphi)
            do ir=2,nobsvr
              frw(ir)=fr(ir,iphas,iphi)
              phiy1=frw(ir-1)
              phiy=frw(ir)
              dphi=phiy-phiy1

              if (dphi.gt.pi1) then
                dphi=dphi-twopi1
              else if (dphi.lt.-pi1) then
                dphi=dphi+twopi1
              endif
              fr(ir,iphas,iphi)=fr(ir-1,iphas,iphi)+dphi

            enddo
          enddo

          do iphas=1,4
            call util_spline_coef(obsvr,
     &        fr(1,iphas,iphi),nobsvr,yp12,yp12,coefr(1,iphas,iphi),
     &        w1,w2,w3,w4)
          enddo

        enddo !nobsvphi

        do iphas=1,4

          do ixy=1,nobsv

            y=obsv(2,ixy)
            z=obsv(3,ixy)
            r=sqrt(y**2+z**2)

            if (iquadphi.eq.0) then
              phi=atan2(y,z)
            else
              if (z.ne.0.0d0) then
                phi=atan(y/z)
              else
                phi=pi1/2.0d0
              endif
              phi=abs(phi)
            endif

            if (phi.lt.0.0d0) phi=phi+twopi1

            do iphi=1,nobsvphi

              call util_spline_inter_status(
     &          obsvr,fr(1,iphas,iphi),coefr(1,iphas,iphi),
     &          nobsvr,r,fp(iphi+medge),0,
     &          istat)

              if (istat.ne.0) then
                stop
     &            '*** Error: Bad return from util_spline_inter_status in CYLTOCART'
              endif

            enddo !iphi

            if (iquadphi.eq.0) then

              nphi=nobsvphi+1+2*medge
              ifirst=medge+1
              ilast=ifirst+nobsvphi

              fp(ilast)=fp(ifirst) !Periode vervollstaendigen

              do iedge=1,medge
                fp(ilast+iedge)=fp(ifirst+iedge)
              enddo

              do iedge=1,medge
                fp(ifirst-iedge)=fp(ilast-iedge)
              enddo

            else !if (iquadphi.eq.0)

              nphi=nobsvphi+2*medge
              ifirst=medge+1
              ilast=ifirst+nobsvphi-1

              do iedge=1,medge
                phiedge=mod(pihalf+iedge*obsvdphi,twopi1)
                if (phiedge.gt.3.0d0*pihalf) then
                  phiedge=twopi1-phiedge
                else if (phiedge.gt.pi1) then
                  phiedge=phiedge-pi1
                else if (phiedge.gt.pihalf) then
                  phiedge=pi1-phiedge
                endif
                jphi=ifirst+nint(phiedge/obsvdphi)
                fp(ilast+iedge)=fp(jphi)
              enddo

              do iedge=1,medge
                phiedge=mod(iedge*obsvdphi,twopi1)
                if (phiedge.gt.3.0d0*pihalf) then
                  phiedge=twopi1-phiedge
                else if (phiedge.gt.pi1) then
                  phiedge=phiedge-pi1
                else if (phiedge.gt.pihalf) then
                  phiedge=pi1-phiedge
                endif
                jphi=ifirst+nint(phiedge/obsvdphi)
                fp(ifirst-iedge)=fp(jphi)
              enddo

            endif !iquadphi

            call util_spline_coef(obsvedge,fp,nphi,
     &        yp12,yp12,coefp,
     &        w1,w2,w3,w4)

            call util_spline_inter_status(
     &        obsvedge,fp,coefp,nphi,phi,phas(iphas,ixy),0,istat)

            if (iphas.eq.4) then

              h2=(r/dist0)**2

              if (h2.lt.0.01) then
                ddist=dist0*(h2/2.0d0-h2**2/8.0d0)
              else
                ddist=dist0*(sqrt(1.0d0+h2)-1.0d0)
              endif

              dphase=ddist/freq(ifreq)*wtoe1*1.0d9*twopi1

              afreq(2,ifreq+nfreq*(ixy-1))=
     &          phas(1,ixy)*
     &          cmplx(cos(phas(2,ixy)+dphase),sin(phas(2,ixy)+dphase))

              afreq(3,ifreq+nfreq*(ixy-1))=
     &          phas(3,ixy)*
     &          cmplx(cos(phas(4,ixy)+dphase),sin(phas(4,ixy)+dphase))

            endif

            if (istat.ne.0) then
              stop
     &          '*** Error: Bad return from util_spline_inter_status in CYLTOCART'
            endif

          enddo !ixy

        enddo !iphas

      enddo !ifreq

c power

      iphas=1
      do ixy=1,nobsv

        y=obsv(2,ixy)
        z=obsv(3,ixy)
        r=sqrt(y**2+z**2)

        if (iquadphi.eq.0) then
          phi=atan2(y,z)
        else
          if (z.ne.0.0d0) then
            phi=atan(y/z)
          else
            phi=pi1/2.0d0
          endif
          phi=abs(phi)
        endif

        if (phi.lt.0.0d0) phi=phi+twopi1

        iobrp=0
        do iphi=1,nobsvphi

          if (ixy.eq.1) then

            do ir=1,nobsvr
              iobrp=iobrp+1
              ifrob=isour+nsource*(iobrp-1)
              fr(ir,iphas,iphi)=specpowrphi(ifrob)
            enddo

            call util_spline_coef(obsvr,fr(1,iphas,iphi),nobsvr,yp12,yp12,
     &        coefr(1,iphas,iphi),
     &        w1,w2,w3,w4)

          endif !ixy.eq.1

          call util_spline_inter_status(
     &      obsvr,fr(1,iphas,iphi),coefr(1,iphas,iphi),nobsvr,r,
     &      fp(iphi+medge),0,istat)

          if (istat.ne.0) then
            stop
     &        '*** Error: Bad return from util_spline_inter_status in CYLTOCART'
          endif

        enddo !iphi

        if (iquadphi.eq.0) then

          ifirst=medge+1
          ilast=ifirst+nobsvphi
          fp(ilast)=fp(ifirst) !Periode vervollstaendigen

          do iedge=1,medge
            fp(ilast+iedge)=fp(ifirst+iedge)
          enddo

          do iedge=1,medge
            fp(ifirst-iedge)=fp(ilast-iedge)
          enddo

        else !if (iquadphi.eq.0)

          ifirst=medge+1
          ilast=ifirst+nobsvphi-1

          do iedge=1,medge
            phiedge=mod(pihalf+iedge*obsvdphi,twopi1)
            if (phiedge.gt.3.0d0*pihalf) then
              phiedge=twopi1-phiedge
            else if (phiedge.gt.pi1) then
              phiedge=phiedge-pi1
            else if (phiedge.gt.pihalf) then
              phiedge=pi1-phiedge
            endif
            jphi=ifirst+nint(phiedge/obsvdphi)
            fp(ilast+iedge)=fp(jphi)
          enddo

          do iedge=1,medge
            phiedge=mod(iedge*obsvdphi,twopi1)
            if (phiedge.gt.3.0d0*pihalf) then
              phiedge=twopi1-phiedge
            else if (phiedge.gt.pi1) then
              phiedge=phiedge-pi1
            else if (phiedge.gt.pihalf) then
              phiedge=pi1-phiedge
            endif
            jphi=ifirst+nint(phiedge/obsvdphi)
            fp(ifirst-iedge)=fp(jphi)
          enddo

        endif !iquadphi

        call util_spline_coef(obsvedge,fp,nphi,
     &    yp12,yp12,coefp,
     &    w1,w2,w3,w4)

        call util_spline_inter_status(
     &    obsvedge,fp,coefp,nphi,phi,
     &    specpow(isour+nsource*(ixy-1)),0,istat)

        if (istat.ne.0) then
          stop
     &      '*** Error: Bad return from util_spline_inter_status in CYLTOCART'
        endif

      enddo !ixy

      if (isour.eq.nsource) then
        deallocate(phas)
        deallocate(fr)
        deallocate(fp)
        deallocate(obsvedge)
        deallocate(coefr)
        deallocate(coefp)

        deallocate(w1)
        deallocate(w2)
        deallocate(w3)
        deallocate(w4)
      endif

      call cyltocartb(isour)

      return
      end
+DECK,souintrphi.
*CMZ :  4.01/04 14/11/2023  11.43.26  by  Michael Scheer
*CMZ :  4.01/03 02/06/2023  13.04.35  by  Michael Scheer
*CMZ :  4.01/02 14/05/2023  12.29.56  by  Michael Scheer
*CMZ :  4.00/15 07/04/2022  09.03.04  by  Michael Scheer
*CMZ :  4.00/14 22/12/2021  18.07.25  by  Michael Scheer
*CMZ :  4.00/13 07/11/2021  15.12.27  by  Michael Scheer
*CMZ :  4.00/04 03/08/2019  10.03.49  by  Michael Scheer
*CMZ :  3.06/00 28/02/2019  16.55.53  by  Michael Scheer
*CMZ :  3.05/06 17/07/2018  11.15.17  by  Michael Scheer
*CMZ :  3.05/04 27/06/2018  13.51.32  by  Michael Scheer
*CMZ :  3.05/03 22/05/2018  07.39.43  by  Michael Scheer
*CMZ :  3.02/05 07/04/2015  15.54.15  by  Michael Scheer
*CMZ :  3.02/04 22/01/2015  13.26.27  by  Michael Scheer
*CMZ :  3.02/03 06/11/2014  14.51.14  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  14.04.56  by  Michael Scheer
*CMZ :  2.69/00 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.68/05 17/10/2012  13.51.54  by  Michael Scheer
*CMZ :  2.68/02 30/05/2012  09.20.31  by  Michael Scheer
*CMZ :  2.67/04 11/05/2012  11.18.26  by  Michael Scheer
*CMZ :  2.67/02 28/03/2012  08.52.46  by  Michael Scheer
*CMZ :  2.67/00 13/02/2012  10.58.17  by  Michael Scheer
*CMZ :  2.66/20 06/07/2011  10.49.00  by  Michael Scheer
*CMZ :  2.66/13 25/06/2010  15.12.53  by  Michael Scheer
*CMZ :  2.66/12 25/05/2010  06.05.46  by  Michael Scheer
*CMZ :  2.66/10 04/05/2010  10.02.54  by  Michael Scheer
*CMZ :  2.66/09 04/05/2010  10.01.19  by  Michael Scheer
*CMZ :  2.66/07 10/03/2010  09.23.32  by  Michael Scheer
*CMZ :  2.66/06 27/11/2009  16.13.00  by  Michael Scheer
*CMZ :  2.66/05 18/11/2009  10.22.04  by  Michael Scheer
*CMZ :  2.66/04 17/11/2009  10.06.11  by  Michael Scheer
*CMZ :  2.66/03 05/11/2009  12.46.46  by  Michael Scheer
*CMZ :  2.66/00 26/10/2009  14.33.39  by  Michael Scheer
*CMZ :  2.65/02 08/10/2009  09.58.11  by  Michael Scheer
*CMZ :  2.65/00 18/09/2009  09.44.26  by  Michael Scheer
*CMZ :  2.64/07 17/09/2009  16.07.45  by  Michael Scheer
*CMZ :  2.64/06 15/09/2009  11.26.04  by  Michael Scheer
*CMZ :  2.64/05 11/09/2009  15.30.45  by  Michael Scheer
*-- Author :    Michael Scheer   04/09/2009

      SUBROUTINE SOUINTRPHI(ISOUR,INSIDE)
+seq,gplhint.

+SEQ,TRACKF90U.
+SEQ,WORKF90U.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,AFREQF90U.
+SEQ,AMPLIF90U.

      use bunchmod
      use clustermod

C--- EVALUATE INTEGRALES FOR A SINGLE SOURCE
C---- RESULTS ARE STORE IN AFREQRPHI AND SPECPOWRPHI

         IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,PHYCON.
+SEQ,TRACK.
+seq,sourcef90.
+SEQ,COLLI.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,FREQS.
+SEQ,AMPLI.
+SEQ,B0SCGLOB.
+SEQ,PRIMKIN.
+seq,ustep.
+SEQ,USERVAR.
+seq,datetime.

      double precision, dimension (:), allocatable :: ampzmax
      integer, dimension (:), allocatable :: kobs,iinside,jinside

      COMPLEX*16 ZIOM,ZI,ZIDOM,ZONE,ZICR1,ZIC,daff(3),baff(3)
      COMPLEX*16 EXPOM,DEXPOMPH1,DEXPOMPH,DDEXPOMPH,DEXPOM,EXPOMV2
      COMPLEX*16 DMODU,DMODU0,DDMODU,AX,AY,AZ,AX0,AY0,AZ0,bx0,by0,bz0
      COMPLEX*16 APOL,APOLH,APOLR,APOLL,APOL45,bxc,byc,bzc

      DOUBLE PRECISION T0,T1,T2,TENDSOU,X0,X1,X2,X10,Y1,Y2,Z1,Z2,XENDSOU,R0
     &  ,T,DT,DT2,DT0,DTIM00,DTIM01,VXP,VYP,VZP,TENDSOU1
     &  ,R02
c     &  ,H2,H2R2
     &  ,PHI,FREQR,CORRR0,R00,R2,POW
     &  ,X2B,Y2B,Z2B
     &  ,DGAMMA,DGAMSUM,BETA,GAMGAM,GAMGAM0,AMPDT,sqnphsp,sqnbunch,
     &  sqbunnor
     &  ,are(6),aim(6),
     &  xn1,slopein,slope,drn1,drn2,zn1,yn1,wi
      DOUBLE PRECISION STOK1,STOK2,STOK3,STOK4

      DOUBLE PRECISION VX1,VY1,VZ1,BX1,BY1,BZ1
      DOUBLE PRECISION VX2,VY2,VZ2,BX2,BY2,BZ2,AX2D,AY2D,AZ2D
      DOUBLE PRECISION ECDUM,BS,BSQ,ECMAXS,bs1
      DOUBLE PRECISION TS,DPHASE,DPHSOUR(2,2),phase
      DOUBLE PRECISION C1,OM,DOM,GAMMA

      DOUBLE PRECISION BX,BY,BZ,RX,RY,RZ,PX,PY,PZ,RNBX,RNBY,RNBZ
      DOUBLE PRECISION R1,RNX,RNY,RNZ,DOM1,DOM2,BET1N,DUM11,R,BPX,BPY,BPZ
      DOUBLE PRECISION WGANG,OPANG
      double precision br2,rnr2,br4,rnr4,b3,yp2zp2i,
c     &  yp2zp2ia,
     &  f(3),yp(3),ypp,a(3),fdt(3),filo,fihi,dfdt

      DOUBLE PRECISION RARG(5),C

      DOUBLE PRECISION DROIX,DTPHASE,DXEXI,CENXEXI,roi(nroip)
      DOUBLE PRECISION BET1NO,XRPHI,YRPHI,ZRPHI,speck

      double precision fillb(41)
      double precision, save :: soura(3,4),soure(3,4)

      INTEGER INSIDE
      INTEGER ISOUR,IOBSV,IFREQ,JFREQ,IZAEHL,NZAEHL,IX10,I,ICAL,ICOMP
+self,if=-windows.
      INTEGER*8
+self,if=windows.
      INTEGER
+self.
     &  NZAEHL10,MZAEHL,kzaehl,iizaehl,ir1,ir2
      INTEGER ICSPL,IROI,II,IZTOTS,IWARNBET1N,LSTEP,
     &  MCOUNT,NCOUNT,NCOUNT10,N10,ICOUNT,
     &  jobsv,nelec,norad,iwarnwi

      INTEGER NTUPP,IC
      PARAMETER (NTUPP=38)
      REAL*8 FILLT(NTUPP)
      CHARACTER(5) CTUP(NTUPP)

      data ctup /'t','x','y','z','rx','ry','rz','rt','p','expr','expi','roi'
     &  ,'iob','ie','yob','zob','bet1n','om','dt','by2','isou'
     &  ,'spec','reax','imax','reay','imay','reaz','imaz','dom1',
     &  'betx','bety','betz','betxp','betyp','betzp','nx','ny','nz'/

      DATA ICAL/0/
      DATA ZI/(0.0D0,1.0D0)/
      DATA ZONE/(1.0D0,0.0D0)/
      DATA IWARNBET1N/0/

      allocate(ampzmax(nfreq),kobs(nfreq),
     &  iinside(nobsvrphi),jinside(nobsvrphi))

      IF (ICAL.EQ.0) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'       SUBROUTINE SOUINTRPHI:'
        WRITE(LUNGFO,*)'       (triggered by MPINR)'
        WRITE(LUNGFO,*)

        if (icluster.lt.0.and.ibunch.ne.0.and.iubunch.eq.3) then
          soura(1:3,1:4)=sourceaclu(1:3,1:4)
          soure(1:3,1:4)=sourceeclu(1:3,1:4)
        else
          soura(1:3,1:4)=sourceao(1:3,1:4,isour)
          soure(1:3,1:4)=sourceeo(1:3,1:4,isour)
        endif

        if(ibunch.ne.0) then
          write(lungfo,*)
          write(lungfo,*)
     &      '*** Warning in SOUINTRPHI: Use of IBUNCH may result in problems,'
          write(lungfo,*)
     &      '*** since radiation cone might be not centered and lacking cylindrical symmetry '
          write(lungfo,*)
          write(6,*)
          write(6,*)
     &      '*** Warning in SOUINTRPHI: Use of IBUNCH may result in problems,'
          write(6,*)
     &      '*** since radiation cone might be not centered and lacking cylindrical symmetry '
          write(6,*)
        endif

        IF (NFREQ.GT.NDFREQ) THEN
          WRITE(LUNGFO,*)
     &      '*** ERROR IN SOUINTRPHI: NUMBER OF MAXIMUM PHOTON ENERGIES EXCEEDED'
          WRITE(LUNGFO,*)
     &      'INCREASE PARAMETER NDFREQP IN CMPARA.CMN'
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED  ***'
          WRITE(6,*)
     &      '*** ERROR IN SOUINTRPHI: NUMBER OF MAXIMUM PHOTON ENERGIES EXCEEDED'
          WRITE(6,*)
     &      'INCREASE PARAMETER NDFREQP IN CMPARA.CMN'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED  ***'
          STOP
        ENDIF    !(NFREQ.GT.NDFREQP)

        DO II=1,NSOURCE
          DO I=1,NROIA
            IWARNROI(I,II)=0
          ENDDO
        ENDDO

        IF (ISPECMODE.EQ.1) THEN
          DTIM00=DTMCO
        ELSE
          DTIM00=DTIM0
        ENDIF

        DTIM01=1.D0/DTIM00

        C=CLIGHT1
        C1=1.D0/CLIGHT1

        DOM=(FREQ(2)-FREQ(1))/HBAREV1
        OM=FREQ(1)/HBAREV1
        ZIDOM=ZI*DOM
        ZIOM=ZI*OM
        ZIC=ZI*CLIGHT1

        IF (IWFILINT.LT.0) THEN
+self,if=-mhbook.
          CALL hbookm(NIDSOURCE,'RADIATION INTEGRALS$',NTUPP
     &      , '//WAVE',1024,CTUP)
+self,if=mhbook.
          CALL hbookm(NIDSOURCE,'RADIATION INTEGRALS',NTUPP
     &      , '//WAVE',nlpoi/jwfilint+2*jwfilint,CTUP)
+self.
        ENDIF !(IWFILINT.LT.0)

        nphsp=nbunch
        nelec=neinbunch*nphsp

c Flux density is normalized to number of electrons per bunch or bunch charge
c and dmycurr. The field is normalized such, that flux dens = ABS(field)**2
        if (ibunch.ne.0.and.bunchcharge.ne.0.0d0) then
          sqnbunch=nbunch
          sqnphsp=sqrt(bunchcharge/echarge1)
     &      *neinbunch
     &      /(bunchcharge/echarge1)
          bunnor=1.0d0/nbunch
        else
          sqnbunch=nbunch
          sqnphsp=sqrt(dble(neinbunch))
          bunnor=1.0d0/nbunch
        endif

        if (ibunphase.eq.0) then
          sqbunnor=sqrt(dfloat(neinbunch))/sqrt(dfloat(nbunch))
        else
          sqbunnor=1.0d0/sqrt(dfloat(nbunch))
        endif

      ENDIF !ICAL

      IF (ielec.eq.1) THEN

        WRITE(LUNGFO,*)'            SOURCE NUMBER',ISOUR,':'
        WRITE(LUNGFO,*)

        do ifreq=1,nfreq
          ampzmax(ifreq)=0.0d0
          azcos(ifreq)=1.0d0
          azsin(ifreq)=0.0d0
        enddo
        kobs=iobunch

        X1=xelec

        IF (NROI.LT.0) THEN
          DROIX=(XENDSOU-X1)/(NROIA-1)
          DO IROI=1,NROIA
            ROIX(IROI)=X1+(IROI-1)*DROIX
            ROIP(IROI)=1.0D0
          ENDDO
        ENDIF   !(NROI.LT.0)

        ROIX(1)=ROIX(1)-1.0D-6
        ROIX(NROIA)=ROIX(NROIA)+1.0D-6

        DO IROI=1,NROIA
          IPOIROI(IROI)=0
          if (ical.eq.0) then
            roi(iroi)=roix(iroi)
          endif
        ENDDO
      ENDIF !ielec.eq.1

      phaserphi=0.0d0
      LSTEP=0
      DGAMSUM=0.0D0

      gamma=egamma
      beta=dsqrt((1.d0-1.d0/gamma)*(1.d0+1.d0/gamma))

c error? 16feb07        WGANG2=(WGWINFC/GAMMA)**2+2.0D0/(GAMMA**2*(1.0D0+DMYBETA))
C ERROR 11jan08        WGANG2=(WGWINFC/GAMMA)**2
      WGANG=WGWINFC/GAMMA

      ICSPL=0

      INSIDE=0
      IINSIDE=0
      jinside=0

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS     T=-R0*C1
      T=0.0D0 !WICHTIG HIER WEGEN TENDSOU-T WEITER UNTEN

      R0=OBSVRPHI(1,1)-soura(1,1)

      IF (ISPECMODE.EQ.1) THEN
        T0=DWT(1)
        T1=T0
        T2=DWT(MCO)
        XENDSOU=DWX(MCO)    !FINAL X
      ELSE
        T0=SOURCET(1,ISOUR)
        T1=T0
        T2=SOURCET(2,ISOUR)
        XENDSOU=soure(1,1)    !FINAL X
      ENDIF

      TENDSOU=T2-T1

      X1=xelec
      Y1=yelec
      Z1=zelec

      VX1=vxelec
      VY1=vyelec
      VZ1=vzelec

      BX1=soura(1,4)
      BY1=soura(2,4)
      BZ1=soura(3,4)
      BS1=SQRT(BX1**2+BY1**2+BZ1**2)

      IZTOTS=0

      X0=X1
      X2=X1
      X10=(XENDSOU-X0)/10.1D0

      NZAEHL=NLPOIO
      DT0=TENDSOU/NZAEHL

      DT=DT0

      if (ielec.eq.1) then

        KZAEHL=0

        IR1=-1
        DO IROI=1,NROIA
          IF (ROIX(IROI).GT.X1.AND.ROIX(IROI).LT.XENDSOU.AND.IR1.EQ.-1) THEN
            IR1=IROI
            GOTO 11
          ENDIF
        ENDDO

11      DO IROI=1,NROIA
          IR2=IROI
          IF (roi(IROI).GT.XENDSOU) THEN
            roi(IROI)=XENDSOU
            IR2=IR2-1
            IF (roi(IR2).LT.X1) THEN
              roi(IR2)=X1
            ENDIF
            GOTO 12
          ENDIF
        ENDDO

12      CONTINUE

        KZAEHL=KZAEHL+NZAEHL*ROIP(IR2)*(XENDSOU-roi(IR2))/(XENDSOU-X1)

        IF (IR1.NE.-1) THEN

          KZAEHL=KZAEHL+NZAEHL*ROIP(IR1-1)*(roi(IR1)-X1)/(XENDSOU-X1)

          DO IROI=IR1,IR2-1
            IF (roi(IROI).GT.X1.OR.roi(IROI)+1.LT.XENDSOU) THEN
              KZAEHL=KZAEHL+NZAEHL*ROIP(IROI)*(roi(IROI+1)-roi(IROI))/(XENDSOU-X1)
            ELSE IF (roi(IROI).GT.X1.OR.roi(IROI)+1.LT.XENDSOU) THEN
              KZAEHL=KZAEHL+NZAEHL*ROIP(IROI)*(roi(IROI+1)-roi(IROI))/(XENDSOU-X1)
            ENDIF
          ENDDO

        ENDIF

      endif !ielec.eq.1

      IF (X1.LT.ROIX(1).OR.XENDSOU.GT.ROIX(NROIA)) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN SOUINTRPHI: X OUTSIDE ROIS ***'
        WRITE(LUNGFO,*)'CHECK NAMELIST $ROIN'
        WRITE(LUNGFO,*)' *** PROGRAM WAVE ABORTED ***'
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN SOUINTRPHI: X OUTSIDE ROIS ***'
        WRITE(6,*)'CHECK NAMELIST $ROIN'
        WRITE(6,*)' *** PROGRAM WAVE ABORTED ***'
        STOP
      ENDIF   !IROI

      X2=X1
      Y2=Y1
      Z2=Z1

      VX2=VX1
      VY2=VY1
      VZ2=VZ1

      BX2=BX1
      BY2=BY1
      BZ2=BZ1
      BS=BS1

C--- LOOP OVER STEPS

      DO IROI=1,NROIA
        IPOIROI(IROI)=0
      ENDDO

      IROI=1
      DO I=1,NROIA
        IF (X1.GE.ROIX(I)) THEN
          IROI=I
        ENDIF !(X1.GE.ROIX(I))
      ENDDO   !IROI

      DT=DT0/ROIP(IROI)

      NZAEHL=MAX(5,NINT((TENDSOU-T)/DT))
      DT=(TENDSOU-T)/NZAEHL

      TENDSOU1=TENDSOU-DT
      DT2=DT/2.D0

C- CHECK STEPS SIZE

      IF (IWARNROI(IROI,ISOUR).EQ.0) THEN
        IF (DT.GT.DTIM00) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '*** WARNING IN SOUINTRPHI, SOURCE, ROI:',ISOUR,IROI
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
          WRITE(LUNGFO,*)'SIZE FOR TRAJECTORY!'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
          WRITE(6,*)
          WRITE(6,*)
     &      '*** WARNING IN SOUINTRPHI, SOURCE, ROI:',ISOUR,IROI
          WRITE(6,*)
          WRITE(6,*)'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
          WRITE(6,*)'SIZE FOR TRAJECTORY!'
          WRITE(6,*)
          WRITE(6,*)
     &      'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
          WRITE(6,*)
          IWARNROI(IROI,ISOUR)=1
        ENDIF !DT
      ENDIF !IWARNROI

      IROI=IROI+1

      IZAEHL=0 !LOOP COUNTER

      nutrack=ielec
      nustep=izaehl

      if (ielec.eq.1) then
        iizaehl=0 !total number of steps in souintana
        NZAEHL10=KZAEHL*nelec*nobsvrphi/10
        MZAEHL=NZAEHL10
        IX10=1
      endif

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS     T=-R0*C1

      T=-DT
      TS=-DT

      expom1rphi=ZONE
      DEXPOMPH1=ZONE

      IF (IFREQ2P.EQ.0) THEN
        DO JFREQ=1,NFREQ
          EXPOM2P0(1,JFREQ)=ZONE
        ENDDO
      ENDIF

      afferphi=(0.0D0,0.0D0)
      yp2zp2i=0.0d0
c      yp2zp2ia=0.0d0
      f=0.0d0

1000  IZAEHL=IZAEHL+1

      nustep=izaehl

      IF (ISOUR.eq.1.and.IIZAEHL.GE.MZAEHL) THEN
        CALL date_and_time(dtday,dttime,dtzone,idatetime)
        WRITE(6,*)' ',IX10,' ',dttime(1:2),':',dttime(3:4),':',dttime(5:6)
        IX10=IX10+1
        if (ix10.eq.10) then
          mzaehl=NZAEHL10*9.9
        else
          MZAEHL=MZAEHL+NZAEHL10
        endif
      ENDIF

      IF (IROI.LE.NROIA) THEN

        IF (X2.GE.ROIX(IROI)) THEN

          DT=DT0/ROIP(IROI)
          NZAEHL=NINT((TENDSOU-T)/DT)

          IF (ISPECMODE.EQ.1) THEN
            DT=(TENDSOU-T)/(NZAEHL-1)
          ELSE
            DT=(TENDSOU-T)/NZAEHL
          ENDIF

          TENDSOU1=TENDSOU-DT

          DT2=DT/2.D0

          IF (IWARNROI(IROI,ISOUR).EQ.0) THEN

            IF (DT.GT.DTIM00) THEN

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          '*** WARNING IN SOUINTRPHI, SOURCE, ROI:',ISOUR,IROI
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
              WRITE(LUNGFO,*)'SIZE FOR TRAJECTORY!'
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
              WRITE(6,*)
              WRITE(6,*)
     &          '*** WARNING IN SOUINTRPHI, SOURCE, ROI:',ISOUR,IROI
              WRITE(6,*)
              WRITE(6,*)'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
              WRITE(6,*)'SIZE FOR TRAJECTORY!'
              WRITE(6,*)
              WRITE(6,*)
     &          'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
              WRITE(6,*)

              IWARNROI(IROI,ISOUR)=1

            ENDIF !DT

          ENDIF !IWARNROI

          IROI=IROI+1

        ENDIF   !X2

      ENDIF   !IROI

      IPOIROI(IROI)=IPOIROI(IROI)+1

      T=T+DT

      IF (LSTEP.EQ.1) THEN

        IF (X2.LE.XENDSOU) THEN

          DT=(MIN(XENDSOU,XIEND)-X2)/VX2
          DT2=DT/2.0D0

        ELSE

          TS=TS-DT
          T=T-DT

          DT=(MIN(XENDSOU,XIEND)-X1)/VX2
          DT2=DT/2.0D0

          X2=X1
          Y2=Y1
          Z2=Z1

          VX2=VX1
          VY2=VY1
          VZ2=VZ1

          BX2=BX1
          BY2=BY1
          BZ2=BZ1

        ENDIF

      ENDIF

      X1=X2
      Y1=Y2
      Z1=Z2

      VX1=VX2
      VY1=VY2
      VZ1=VZ2

      BX1=BX2
      BY1=BY2
      BZ1=BZ2
      BS1=BS

      IF (ISPECMODE.NE.1) THEN

C GET MAGNETIC FIELD {

        X2B=X1+VX1*DT2
        Y2B=Y1+VY1*DT2
        Z2B=Z1+VZ1*DT2
        norad=0
        if (ibmasksp.ne.0) then
          ibmasksp=-abs(ibmasksp)
          call mybfeld(x2b,y2b,z2b,bx2,by2,bz2,ax2d,ay2d,az2d)
          if ((bx2**2+by2**2+bz2**2).ne.0.0d0) then
            norad=1
          endif
          ibmasksp=-ibmasksp
        endif

        X2=WSOU(1,1,IZAEHL)
        Y2=WSOU(2,1,IZAEHL)
        Z2=WSOU(3,1,IZAEHL)

        VX2=WSOU(1,2,IZAEHL)
        VY2=WSOU(2,2,IZAEHL)
        VZ2=WSOU(3,2,IZAEHL)

        VXP=WSOU(1,3,IZAEHL)
        VYP=WSOU(2,3,IZAEHL)
        VZP=WSOU(3,3,IZAEHL)

        DT=   wsou(1,4,IZAEHL)
        BETA= wsou(2,4,IZAEHL)
        GAMMA=wsou(3,4,IZAEHL)

        bX2=WSOU(1,5,IZAEHL)
        bY2=WSOU(2,5,IZAEHL)
        bZ2=WSOU(3,5,IZAEHL)

        BX=VX2*C1
        BY=VY2*C1
        BZ=VZ2*C1

        BPX=VXP*C1
        BPY=VYP*C1
        BPZ=VZP*C1

C MOVE ONE STEP }

      ELSE  !ISPECMODE

        CALL WAVE_TRACK_INTER(TS,X2,Y2,Z2,VX2,VY2,VZ2,VXP,VYP,VZP,BS,ICSPL,
     &    GAMMA)

        norad=0
        if (ibmasksp.ne.0) then
          ibmasksp=-abs(ibmasksp)
          call mybfeld(x2b,y2b,z2b,bx2,by2,bz2,ax2d,ay2d,az2d)
          if ((bx2**2+by2**2+bz2**2).ne.0.0d0) then
            norad=1
          endif
          ibmasksp=-ibmasksp
        endif

        IF (IENELOSS.NE.0) THEN
          BETA=DSQRT((1.D0-1.D0/GAMMA)*(1.D0+1.D0/GAMMA))
        ENDIF

        BSQ=BS*BS
        BY2=BSQ

        BX=VX2*C1
        BY=VY2*C1
        BZ=VZ2*C1

        BPX=VXP*C1
        BPY=VYP*C1
        BPZ=VZP*C1

      ENDIF !ISPECMODE

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION {

C REAL PART OF INTEGRAND {

      DO JOBSV=1,NOBSVRPHI

        if (jobsv.eq.1.and.iobunch.ne.-9999) then
          iobsv=iobunch
        else if (jobsv.eq.iobunch) then
          iobsv=1
        else
          iobsv=jobsv
        endif

        ILIOB=ISOUR+NSOURCE*(IOBSV-1)

        XRPHI=OBSVRPHI(1,IOBSV)
        YRPHI=OBSVRPHI(2,IOBSV)*SIN(OBSVRPHI(3,IOBSV))
        ZRPHI=OBSVRPHI(2,IOBSV)*COS(OBSVRPHI(3,IOBSV))

        r=sqrt((xrphi-x1)**2+((yrphi-y1)**2+(zrphi-z1)**2))
        PHASE=(r-r0)*c1 ! needed for phase of field amplitude
        if (izaehl.eq.1) then
          phaserphi(iobsv)=phase
          expom1rphi(iobsv)=cdexp(dcmplx(0.0d0,phaserphi(iobsv)*om))
        endif

        RX=XRPHI-X2
        RY=YRPHI-Y2
        RZ=ZRPHI-Z2

        R=SQRT(RX*RX+RY*RY+RZ*RZ)
        R1=1.D0/R
        ZICR1=ZIC*R1

        RNX=RX*R1
        RNY=RY*R1
        RNZ=RZ*R1

C--- THE DISTANCE R IS INTRODUCED HERE EXPLICITLY (S. PROGRAM OF CHAOEN WANG

        BET1N=(1.0D0-BX*RNX)-BY*RNY-BZ*RNZ
c 20090928{
        br2=by**2+bz**2
        rnr2=rny**2+rnz**2
        b3=beta**3
        br4=br2**2
        rnr4=rnr2**2

        if(br2.lt.1.0d-4.and.rnr2.lt.1.0d-4) then
          bet1n=
     &      1.0d0/(1.0d0+beta)/gamma**2
     &      +beta*(rnr2/2.0d0
     &      +rnr4/8.0d0)
     &      +(br2/2.0d0
     &      -br2*rnr2/4.0d0
     &      -br2*rnr4/16.0d0)/beta
     &      +b3*br4*(1.0d0/8.0d0
     &      -rnr2/16.0d0
     &      -rnr4/64.0d0)
     &      -by*rny
     &      -bz*rnz
        endif
c }20090928

        OPANG=BX/BETA*RNX+BY/BETA*RNY+BZ/BETA*RNZ

        IF (ABS(OPANG).LE.1.0D0) THEN
          OPANG=ACOS(OPANG)
        ELSE IF (OPANG.GT.1.0D0) THEN
          OPANG=0.0D0
        ELSE
          OPANG=-PI1
        ENDIF

        DUM11=1.0D0/BET1N
        DOM1=1.0D0/(R*BET1N*BET1N)

        IF (IOBSV.EQ.1) THEN
          IF (IZAEHL.EQ.1) THEN
            BET1NO=BET1N
          ELSE IF (iundulator.eq.0
     &        .and.(BET1N-BET1NO)/BET1N.GT.0.05.AND.IWARNBET1N.EQ.0) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** WARNING IN SOUINTRPHI  ***'
            WRITE(LUNGFO,*)'DISCONTINUITY IN INTEGRAND'
            WRITE(LUNGFO,*)
     &        'Check results carefully, change BMOVECUT, MYINUM, NLPOI etc.'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'ISTEP,X,BET1N,BET1NO:',IZAEHL,SNGL(X1),SNGL(BET1N),SNGL(BET1NO)
            WRITE(LUNGFO,*)'FURTHER WARNINGS ARE SUPPRESSED!'
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)'*** WARNING IN SOUINTRPHI  ***'
            WRITE(6,*)'DISCONTINUITY IN INTEGRAND'
            WRITE(6,*)
     &        'Check results carefully, change BMOVECUT, MYINUM, NLPOI etc.'
            WRITE(6,*)
            WRITE(6,*)'ISTEP,X,BET1N,BET1NO:',IZAEHL,SNGL(X1),SNGL(BET1N),SNGL(BET1NO)
            WRITE(6,*)
            WRITE(6,*)'FURTHER WARNINGS ARE SUPPRESSED!'
            WRITE(6,*)
            IWARNBET1N=1
          ENDIF
          BET1NO=BET1N
        ENDIF

        RNBX=RNX-BX
        RNBY=RNY-BY
        RNBZ=RNZ-BZ

        PX=(RNBY*BPZ-RNBZ*BPY)
        PY=(RNBZ*BPX-RNBX*BPZ)
        PZ=(RNBX*BPY-RNBY*BPX)

        IF (IVELOFIELD.EQ.0) THEN !2 WEGEN POWER
          DOM2=C*DOM1*R1/GAMMA**2
          RARG(1)=(RNY*PZ-RNZ*PY)*DOM1+(RNX-BX)*DOM2
          RARG(2)=(RNZ*PX-RNX*PZ)*DOM1+(RNY-BY)*DOM2
          RARG(3)=(RNX*PY-RNY*PX)*DOM1+(RNZ-BZ)*DOM2
        ELSE IF (IVELOFIELD.EQ.1) THEN
          RARG(1)=(RNY*PZ-RNZ*PY)*DOM1
          RARG(2)=(RNZ*PX-RNX*PZ)*DOM1
          RARG(3)=(RNX*PY-RNY*PX)*DOM1
        ELSE IF (IVELOFIELD.LT.0) THEN
          DOM2=C*DOM1*R1/GAMMA**2
          RARG(1)=(RNX-BX)*DOM2
          RARG(2)=(RNY-BY)*DOM2
          RARG(3)=(RNZ-BZ)*DOM2
        ELSE   !IVELOFIELD
          WRITE(6,*)
     &      '*** ERROR IN SOUINTRPHI: BAD VALUE OF IVELOFIELD  ***'
          WRITE(6,*) '*** PROGRAM WAVE ABORTED  ***'
          STOP
        ENDIF  !IVELOFIELD

        IF (iinside(iobsv).EQ.0.AND.OPANG.LE.WGANG) THEN
          if (iobsv.eq.1) then
            DPHSOUR(1,1)=BET1N*DT*FREQ(1)/HBAREV1
            DPHSOUR(1,2)=BET1N*DT*FREQ(NFREQ)/HBAREV1
          endif
          iinside(iobsv)=1
          INSIDE=1
          jinside(iobsv)=jinside(iobsv)+1
          IF (jinside(iobsv).GT.1) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** WARNING IN SOUINTRPHI  ***'
            WRITE(LUNGFO,*)'*** SOURCE:',ISOUR
            WRITE(LUNGFO,*)'STRANGE SOURCE, CONTAINS SEVERAL SOURCES'
            WRITE(LUNGFO,*)'SOURCE AND OBSERVATION POINT:'
            WRITE(LUNGFO,*)
     &        ISOUR,OBSVRPHI(1,IOBSV),OBSVRPHI(2,IOBSV),OBSVRPHI(3,IOBSV)
            WRITE(LUNGFO,*)
     &        'RESULTS OF SPECTRUM CALCULATIONS MAY BE UNRELIABLE'
            WRITE(LUNGFO,*)'*** CHECK COLLIMATOR, PINHOLE, WGWINFC ... ***'
            WRITE(6,*)
            WRITE(6,*)'*** WARNING IN SOUINTRPHI  ***'
            WRITE(6,*)'*** SOURCE:',ISOUR
            WRITE(6,*)'*** STRANGE SOURCE, CONTAINS SEVERAL SOURCES'
            WRITE(6,*)'SOURCE AND OBSERVATION POINT:',
     &        ISOUR,OBSVRPHI(1,IOBSV),OBSVRPHI(2,IOBSV),OBSVRPHI(3,IOBSV)
            WRITE(6,*)
            WRITE(6,*)'*** CHECK COLLIMATOR, PINHOLE, WGWINFC ... ***'
            WRITE(6,*)'WARNING OF SPECTRUM CALCULATIONS ARE UNRELIABLE'
            jinside(iobsv)=jinside(iobsv)-1   !SUPRESS LOTS OF WARNINGS
          ENDIF   !jinside(iobsv)
        ELSE IF (iinside(iobsv).EQ.1.AND.OPANG.GT.WGANG) THEN
          iinside(iobsv)=0
        ENDIF   !iinside(iobsv)

        IF (iinside(iobsv).NE.0) THEN

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS      RARG(4)=T+R*C1

          DPHASE=BET1N*DT

          RARG(4)=phaserphi(iobsv)
          RARG(5)=(RARG(1)*RARG(1)+RARG(2)*RARG(2)+RARG(3)*RARG(3))*DUM11

          if (norad.ne.0) rarg=0.0d0

C REAL PART OF INTEGRAND }

C COMPLEX PART OF INTEGRAND {

C    ASSUMES FREQ(I+1)=2*FREQ(I)   FOR IFREQ2P=2
C    OR FREQ(I+1)=FREQ(I)+DELTA    FOR IFREQ2P>2

C--- LOOP OVER ALL FREQUENCES

          IFREQ=1
          if (nelec.gt.1) then
            dexpbunch=phexp(ifreq)
          else
            dexpbunch=(1.0d0,0.0d0)
          endif

          IFROB=IFREQ+NFREQ*(IOBSV-1)

          OM=FREQ(IFREQ)/HBAREV1
          ZIOM=ZI*OM

          EXPOM=expom1rphi(iobsv)
          DEXPOMPH1=EXP(ZIOM*DPHASE)
          DEXPOMPH=DEXPOMPH1

          IF(IFREQ2P.GT.2) THEN
            DEXPOM=EXP(ZIDOM*phaserphi(iobsv))
            DDEXPOMPH=EXP(ZIDOM*DPHASE)
          ELSE IF(IFREQ2P.EQ.0) THEN
            EXPOM2P0(2,IFREQ)=EXP(ZIOM*DPHASE)
            EXPOM=EXPOM2P0(1,IFREQ)
          ENDIF   !IFREQ2P

          IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN

            SPECPOWRPHI(ILIOB)=SPECPOWRPHI(ILIOB)+RARG(5)*DT

            DO ICOMP=1,3
              daff(icomp)=RARG(ICOMP)/BET1N/OM*EXPOM*(ZONE-DEXPOMPH)*DEXPbunch/sqnphsp
              afferphi(icomp,ifrob)=afferphi(icomp,ifrob)+daff(icomp)
            ENDDO   !ICOMP

c            baff(1)=conjg(rny*daff(3)-rnz*daff(2))
c            baff(2)=conjg(rnz*daff(1)-rnx*daff(3))
c            baff(3)=conjg(rnx*daff(2)-rny*daff(1))

            baff(1)=(rny*daff(3)-rnz*daff(2))
            baff(2)=(rnz*daff(1)-rnx*daff(3))
            baff(3)=(rnx*daff(2)-rny*daff(1))

            afferphi(4:6,ifrob)=afferphi(4:6,ifrob)+baff(1:3)/clight1

          ENDIF   !XIANF

          IF (IWFILINT.NE.0) THEN
            IF (MOD(IZAEHL,JWFILINT).EQ.0) THEN
              IF (IWFILINT.LT.0) THEN
                FILLT(1)=T
                FILLT(2)=X2
                FILLT(3)=Y2
                FILLT(4)=Z2
                FILLT(5)=RARG(1)
                FILLT(6)=RARG(2)
                FILLT(7)=RARG(3)
                FILLT(8)=RARG(4)
                FILLT(9)=RARG(5)
                FILLT(10)=dREAL(EXPOM)
                FILLT(11)=dIMAG(EXPOM)
                FILLT(12)=IROI-1
                FILLT(13)=IOBSV
                FILLT(14)=IFREQ
                FILLT(17)=BET1N
                FILLT(18)=OM
                FILLT(19)=DT
                FILLT(20)=BY2
                FILLT(21)=ISOUR
                FILLT(15)=YRPHI
                FILLT(16)=ZRPHI
                FILLT(22)=
     &            (
     &            REAL(afferphi(1,ifrob))*REAL(afferphi(1,ifrob))
     &            +IMAG(afferphi(1,ifrob))*IMAG(afferphi(1,ifrob))
     &            +REAL(afferphi(2,ifrob))*REAL(afferphi(2,ifrob))
     &            +IMAG(afferphi(2,ifrob))*IMAG(afferphi(2,ifrob))
     &            +REAL(afferphi(3,ifrob))*REAL(afferphi(3,ifrob))
     &            +IMAG(afferphi(3,ifrob))*IMAG(afferphi(3,ifrob))
     &            )*SPECNOR*bunnor
                FILLT(23)=dREAL(afferphi(1,ifrob))*SPECNOR*bunnor
                FILLT(24)=dIMAG(afferphi(1,ifrob))*SPECNOR*bunnor
                FILLT(25)=dREAL(afferphi(2,ifrob))*SPECNOR*bunnor
                FILLT(26)=dIMAG(afferphi(2,ifrob))*SPECNOR*bunnor
                FILLT(27)=dREAL(afferphi(3,ifrob))*SPECNOR*bunnor
                FILLT(28)=dIMAG(afferphi(3,ifrob))*SPECNOR*bunnor
                FILLT(29)=DOM1
                FILLT(30)=bx
                FILLT(31)=by
                FILLT(32)=bz
                FILLT(33)=bpx
                FILLT(34)=bpy
                FILLT(35)=bpz
                FILLT(36)=rnx
                FILLT(37)=rny
                FILLT(38)=rnz

                CALL hfm(NIDSOURCE,FILLT)

              ELSE IF (ISOUR.EQ.IWFILINT.AND.IOBSV.EQ.1) THEN

                WRITE(LUNINT,*) IZAEHL,IFREQ,X2
                WRITE(LUNINT,*) (RARG(1),IC=1,3)
                WRITE(LUNINT,*) RARG(4)*OM,RARG(5)
                WRITE(LUNINT,*)REAL(EXPOM),IMAG(EXPOM)
                WRITE(LUNINT,*)RARG(1)*REAL(EXPOM),RARG(1)*IMAG(EXPOM)
                WRITE(LUNINT,*)RARG(2)*REAL(EXPOM),RARG(2)*IMAG(EXPOM)
                WRITE(LUNINT,*)RARG(3)*REAL(EXPOM),RARG(3)*IMAG(EXPOM)

              ENDIF !IWFILINT.LT.0
            ENDIF !JFILINT
          ENDIF !IWFILINT.NE.0

          DO IFREQ=2,NFREQ

            IFROB=IFREQ+NFREQ*(IOBSV-1)

            IF (IFREQ2P.GT.2) THEN
              OM=OM+DOM
              EXPOM=EXPOM*DEXPOM
              DEXPOMPH=DEXPOMPH*DDEXPOMPH
            ELSE IF(IFREQ2P.EQ.2) THEN
              OM=OM*2.0D0
              EXPOM=EXPOM*EXPOM
              DEXPOMPH=DEXPOMPH*DEXPOMPH
            ELSE IF(IFREQ2P.EQ.0) THEN
              OM=FREQ(IFREQ)/HBAREV1
              ZIOM=ZI*OM
              EXPOM2P0(2,IFREQ)=EXP(ZIOM*DPHASE)
              EXPOM=EXPOM2P0(1,IFREQ)
              DEXPOMPH=EXPOM2P0(2,IFREQ)
            ELSE
              OM=FREQ(IFREQ)/HBAREV1
              ZIOM=ZI*OM
              DEXPOMPH=EXP(ZIOM*DPHASE)
            ENDIF

            if (nelec.gt.1) then
              dexpbunch=phexp(ifreq)
            endif

            IF (X2.GE.XIANF.AND.X2.LE.XIEND.and.norad.eq.0) THEN
              EXPOMV2=1.0D0/BET1N/OM*EXPOM*(ZONE-DEXPOMPH)

              DO ICOMP=1,3
                daff(icomp)=RARG(ICOMP)*EXPOMV2*DEXPbunch/sqnphsp
c                print*,izaehl,ifrob,icomp,rarg(icomp),expomv2,dexpbunch,sqnphsp
c                print*,daff
                afferphi(ICOMP,ifrob)=afferphi(ICOMP,ifrob)+daff(icomp)
              ENDDO

c              baff(1)=conjg(rny*daff(3)-rnz*daff(2))
c              baff(2)=conjg(rnz*daff(1)-rnx*daff(3))
c              baff(3)=conjg(rnx*daff(2)-rny*daff(1))

              baff(1)=(rny*daff(3)-rnz*daff(2))
              baff(2)=(rnz*daff(1)-rnx*daff(3))
              baff(3)=(rnx*daff(2)-rny*daff(1))

              afferphi(4:6,ifrob)=afferphi(4:6,ifrob)+baff(1:3)/clight1

            ENDIF !XIEND

            IF (IWFILINT.NE.0) THEN
              IF (MOD(IZAEHL,JWFILINT).EQ.0) THEN
                IF (IWFILINT.LT.0) THEN
                  FILLT(1)=T
                  FILLT(2)=X2
                  FILLT(3)=Y2
                  FILLT(4)=Z2
                  FILLT(5)=RARG(1)
                  FILLT(6)=RARG(2)
                  FILLT(7)=RARG(3)
                  FILLT(8)=RARG(4)
                  FILLT(9)=RARG(5)
                  FILLT(10)=dREAL(EXPOM)
                  FILLT(11)=dIMAG(EXPOM)
                  FILLT(12)=IROI-1
                  FILLT(13)=IOBSV
                  FILLT(14)=IFREQ
                  FILLT(17)=BET1N
                  FILLT(18)=OM
                  FILLT(19)=DT
                  FILLT(20)=BY2
                  FILLT(21)=ISOUR
                  FILLT(15)=YRPHI
                  FILLT(16)=ZRPHI
                  FILLT(22)=
     &              (
     &              REAL(afferphi(1,ifrob))*REAL(afferphi(1,ifrob))
     &              +IMAG(afferphi(1,ifrob))*IMAG(afferphi(1,ifrob))
     &              +REAL(afferphi(2,ifrob))*REAL(afferphi(2,ifrob))
     &              +IMAG(afferphi(2,ifrob))*IMAG(afferphi(2,ifrob))
     &              +REAL(afferphi(3,ifrob))*REAL(afferphi(3,ifrob))
     &              +IMAG(afferphi(3,ifrob))*IMAG(afferphi(3,ifrob))
     &              )*SPECNOR*bunnor
                  FILLT(23)=dREAL(afferphi(1,ifrob))*SPECNOR*bunnor
                  FILLT(24)=dIMAG(afferphi(1,ifrob))*SPECNOR*bunnor
                  FILLT(25)=dREAL(afferphi(2,ifrob))*SPECNOR*bunnor
                  FILLT(26)=dIMAG(afferphi(2,ifrob))*SPECNOR*bunnor
                  FILLT(27)=dREAL(afferphi(3,ifrob))*SPECNOR*bunnor
                  FILLT(28)=dIMAG(afferphi(3,ifrob))*SPECNOR*bunnor
                  FILLT(29)=DOM1
                  FILLT(30)=bx
                  FILLT(31)=by
                  FILLT(32)=bz
                  FILLT(33)=bpx
                  FILLT(34)=bpy
                  FILLT(35)=bpz
                  FILLT(36)=rnx
                  FILLT(37)=rny
                  FILLT(38)=rnz
                  CALL hfm(NIDSOURCE,FILLT)

                ELSE IF (ISOUR.EQ.IWFILINT.AND.IOBSV.EQ.1) THEN

                  WRITE(LUNINT,*) IZAEHL,IFREQ,X2
                  WRITE(LUNINT,*) (RARG(1),IC=1,3)
                  WRITE(LUNINT,*) RARG(4)*OM,RARG(5)
                  WRITE(LUNINT,*)REAL(EXPOM),IMAG(EXPOM)
                  WRITE(LUNINT,*)RARG(1)*REAL(EXPOM),RARG(1)*IMAG(EXPOM)
                  WRITE(LUNINT,*)RARG(2)*REAL(EXPOM),RARG(2)*IMAG(EXPOM)
                  WRITE(LUNINT,*)RARG(3)*REAL(EXPOM),RARG(3)*IMAG(EXPOM)

                ENDIF !IWFILINT.LT.0
              ENDIF !JWFILINT
            ENDIF !IWFILINT.NE.0

          ENDDO   !LOOP OVER ALL FREQUENCES

        ENDIF   !iinside(iobsv)

C COMPLEX PART OF INTEGRAND }

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION }

        phase=phaserphi(iobsv)
        phaserphi(iobsv)=phaserphi(iobsv)+DPHASE
        expom1rphi(iobsv)=expom1rphi(iobsv)*DEXPOMPH1

        IF(IFREQ2P.EQ.0) THEN

          DO JFREQ=1,NFREQ
            OM=FREQ(JFREQ)/HBAREV1
            ZIOM=ZI*OM
            EXPOM2P0(1,JFREQ)=EXPOM2P0(1,JFREQ)*EXPOM2P0(2,JFREQ)
          ENDDO
        ENDIF

        IF (iinside(iobsv).NE.0.and.iobsv.eq.1) THEN
          DPHSOUR(2,1)=BET1N*DT*FREQ(1)/HBAREV1
          DPHSOUR(2,2)=BET1N*DT*FREQ(NFREQ)/HBAREV1
        ENDIF

      ENDDO !IOBSV=1,NOBSVRPHI

      IIZAEHL=IIZAEHL+nobsvrphi !total step counter

      TS=TS+DT

C--- END OF LOOP OVER TIME STEPS

c      yp2zp2ia=yp2zp2ia
c     &  +((vy1/vx1)**2+(vy2/vx2)**2+(vz1/vx1)**2+(vz2/vx2)**2)*beta*clight1*dt2

      f(3)=((vy2/vx2)**2+(vz2/vx2)**2)
      fdt(3)=dt

      if (lstep.eq.1) then
        yp(1)=(f(2)-f(1))/fdt(2)
        yp(3)=(f(3)-f(2))/fdt(3)
        yp(2)=(yp(3)+yp(1))/2.0d0
        ypp=(yp(3)-yp(1))/(fdt(2)+fdt(3))*2.0d0
        a(3)=ypp/2.0d0
        a(2)=yp(2)-2.0d0*a(3)*fdt(2)
        a(1)=f(2)-a(2)*fdt(2)-a(3)*fdt(2)**2
        dfdt=fdt(2)+fdt(3)
        fihi=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        dfdt=0.0d0
        filo=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        yp2zp2i=yp2zp2i+fihi-filo
        yp2zp2i=yp2zp2i*beta*clight1
      else if (izaehl.ge.3) then
        yp(1)=(f(2)-f(1))/fdt(2)
        yp(3)=(f(3)-f(2))/fdt(3)
        yp(2)=(yp(3)+yp(1))/2.0d0
        ypp=(yp(3)-yp(1))/(fdt(2)+fdt(3))*2.0d0
        a(3)=ypp/2.0d0
        a(2)=yp(2)-2.0d0*a(3)*fdt(2)
        a(1)=f(2)-a(2)*fdt(2)-a(3)*fdt(2)**2
        dfdt=fdt(2)+fdt(3)
        fihi=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        dfdt=fdt(2)
        filo=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        yp2zp2i=yp2zp2i+fihi-filo
      endif

      f(1)=f(2)
      fdt(1)=fdt(2)
      f(2)=f(3)
      fdt(2)=fdt(3)

      if (ispecmode.eq.2) then
        if (izaehl.lt.ipoisou(isour)) goto 1000
      else
        IF (X2.LT.XENDSOU-VX2*DT.AND.X2.LT.(XIEND-VX2*DT).AND.LSTEP.EQ.0)
     &    GOTO 1000
        IF (LSTEP.EQ.0) THEN
          LSTEP=1
          GOTO 1000
        ENDIF
      endif

      IF (IAMPLI.LT.0) THEN

        if (nelec.eq.1) then
          print*,' '
          print*,'Starting phase repetition, counting from one to 10 to show progress:'
          print*,' '
        endif

        DXEXI=MIN(soure(1,1),XIEND)
     &    -MAX(soura(1,1),XIANF)
        if (ampr2corr.eq.-9999.0d0) ampr2corr=dxexi
        CENXEXI=(MIN(soure(1,1),XIEND)
     &    +MAX(soura(1,1),XIANF))/2.D0
        GAMGAM0=(SOURCEG(1,1,ISOUR)*(egamma/dmygamma))**2
        GAMGAM=(
     &    (SOURCEG(1,1,ISOUR)+SOURCEG(2,2,ISOUR))*(egamma/dmygamma)
     &    )**2

        XRPHI=OBSVRPHI(1,1)

        slopein=sqrt(vyin**2+vzin**2)/vxin
        slope=sqrt(vyelec**2+vzelec**2)/vxelec

        if (myinum.gt.nlpoi/dxexi) then
          WI=(WTRA2IS(ISOUR)
     &      -DXEXI/2.0D0*slopein**2) !wi is detour for on-axis particle
     &      *(dmygamma/egamma)**2
        else
          if (iwarnwi.eq.0) then
            write(lungfo,*)
            write(lungfo,*)'*** Warning in SOUINTANA:'
            write(lungfo,*)'*** MYINUM is rather small with respect to NLPOI'
            write(lungfo,*)'*** Length of trajectories are now calculated by simple'
            write(lungfo,*)'*** integration with SOUINTANA, which might be poor'
            write(lungfo,*)
            write(lungfo,*)
            write(6,*)'*** Warning in SOUINTANA:'
            write(6,*)'*** MYINUM is rather small with respect to NLPOI'
            write(6,*)'*** Length of trajectories are now calculated by simple'
            write(6,*)'*** integration with SOUINTANA, which might be poor'
            write(6,*)
            iwarnwi=1
          endif
          wi=(yp2zp2i/2.0d0
     &      -DXEXI/2.0D0*slopein**2) !wi is detour for on-axis particle
     &      *(dmygamma/egamma)**2
        endif

        xn1=cenxexi
        yn1=(xn1-cenxexi)*vyelec/vxelec
        zn1=(xn1-cenxexi)*vyelec/vxelec

        drn2=(
     &    (yn1+dxexi*vyelec/vxelec)**2+
     &    (zn1+dxexi*vzelec/vxelec)**2
     &    )/
     &    (2.0d0*(xrphi-xn1-dxexi))

        drn1=(
     &    yn1**2+
     &    zn1**2
     &    )/
     &    (2.0d0*(xrphi-xn1))

        DTPHASE=(
     &    WI+DXEXI*(slope**2/2.0d0+1.0d0/(2.0D0*GAMGAM0))
     &    +drn2-drn1)
     &    /CLIGHT1*GAMGAM0/GAMGAM

        AMPDT=AMPSHIFT(1)/CLIGHT1/2.0D0/GAMGAM0
        FREQR=2.0D0*PI1/DTPHASE*HBAREV1

        ICOUNT=0
        NCOUNT=NFREQ*NOBSVRPHI*ABS(IAMPLI)
        NCOUNT10=NCOUNT/10
        MCOUNT=NCOUNT10
        N10=0

      ENDIF !IAMPLI

      DO IFREQ=1,NFREQ

        DO IOBSV=1,NOBSVRPHI

          ILIOBFR=ISOUR+NSOURCE*(IOBSV-1+NOBSVRPHI*(IFREQ-1))
          IFROB=IFREQ+NFREQ*(IOBSV-1)
          IOBFR=IOBSV+NOBSVRPHI*(IFREQ-1)

          IF (IAMPLI.LT.0) THEN

            YRPHI=OBSVRPHI(2,IOBSV)*SIN(OBSVRPHI(3,IOBSV))
            ZRPHI=OBSVRPHI(2,IOBSV)*COS(OBSVRPHI(3,IOBSV))

            OM=FREQ(IFREQ)/HBAREV1

            AX0=afferphi(1,ifrob)
            AY0=afferphi(2,ifrob)
            AZ0=afferphi(3,ifrob)

            AX=AX0
            AY=AY0
            AZ=AZ0

            BX0=afferphi(4,ifrob)
            BY0=afferphi(5,ifrob)
            BZ0=afferphi(6,ifrob)

            BXc=BX0
            BYc=BY0
            BZc=BZ0

            afferphi(1:6,ifrob)=(0.0D0,0.0D0)

            R0=XRPHI-CENXEXI
            R02=R0*R0
            R00=R0

c            H2=(YRPHI-vyelec)**2+(ZRPHI-vzelec)**2
c            H2R2=H2/R02
c
c            DTPHASE=(
c     &        WTRA2IS(ISOUR)+
c     &        (
c     &        H2R2+1.0D0/GAMGAM0
c     &        )*DXEXI/2.0D0)/CLIGHT1
c     &        *GAMGAM0/GAMGAM
c     &        +AMPDT

            xn1=cenxexi
            yn1=(xn1-cenxexi)*vyelec/vxelec
            zn1=(xn1-cenxexi)*vzelec/vxelec

            drn2=(
     &        (yn1+dxexi*vyelec/vxelec-yrphi)**2+
     &        (zn1+dxexi*vzelec/vxelec-zrphi)**2
     &        )/
     &        (2.0d0*(xrphi-xn1-dxexi))

            drn1=(
     &        (yn1-yrphi)**2+
     &        (zn1-zrphi)**2
     &        )/
     &        (2.0d0*(xrphi-xn1))

          DTPHASE=(
     &      WI+DXEXI*(slope**2/2.0d0+1.0d0/(2.0D0*GAMGAM0))
     &      +drn2-drn1)
     &      /CLIGHT1*GAMGAM0/GAMGAM
     &      +AMPDT

            PHI=2.D0*PI1*FREQ(IFREQ)*ECHARGE1/HPLANCK1*DTPHASE

            DMODU=EXP(ZI*PHI)
            DMODU0=DMODU
            DDMODU=ZONE

            DO I=1,-IAMPLI

              R0=xrphi+DXEXI/2.D0*(-IAMPLI-2*(I-1)-1)-CENXEXI
              CORRR0=R00/R0
            !corrects for mistake of averaging over 1/r2, if e.g.
            !the repeated device is a long undulator
     &        *(R0/(R0-ampr2corr/2.0d0))**2
              R02=R0*R0

c              H2=(YRPHI-vyelec)**2+(ZRPHI-vzelec)**2
c              H2R2=H2/R02

c              DTPHASE=(
c     &          WTRA2IS(ISOUR)+
c     &          (
c     &          H2R2+1.0D0/GAMGAM0
c     &          )*DXEXI/2.0D0)/CLIGHT1
c     &          *GAMGAM0/GAMGAM+AMPDT

              xn1=cenxexi-dxexi/2.d0*(-iampli-2*(i-1)-1)
     &          *((R0-ampr2corr/2.0d0)/R0)**2 !empirically, due to depth of field
              yn1=(xn1-cenxexi)*vyelec/vxelec
              zn1=(xn1-cenxexi)*vzelec/vxelec

              drn2=(
     &          (yn1+dxexi*vyelec/vxelec-yrphi)**2+
     &          (zn1+dxexi*vzelec/vxelec-zrphi)**2
     &          )/
     &          (2.0d0*(xrphi-xn1-dxexi))

              drn1=(
     &          (yn1-yrphi)**2+
     &          (zn1-zrphi)**2
     &          )/
     &          (2.0d0*(xrphi-xn1))

              DTPHASE=(
     &          WI+DXEXI*(slope**2/2.0d0+1.0d0/(2.0D0*GAMGAM0))
     &          +drn2-drn1)
     &          /CLIGHT1*GAMGAM0/GAMGAM
     &          +AMPDT

              PHI=2.D0*PI1*FREQ(IFREQ)*ECHARGE1/HPLANCK1*DTPHASE

              DMODU=EXP(ZI*PHI)
              DMODU0=DMODU
              DDMODU=ZONE

              afferphi(1,ifrob)=afferphi(1,ifrob)+AX
              afferphi(2,ifrob)=afferphi(2,ifrob)+AY
              afferphi(3,ifrob)=afferphi(3,ifrob)+AZ

              afferphi(4,ifrob)=afferphi(1,ifrob)+BXc
              afferphi(5,ifrob)=afferphi(2,ifrob)+BYc
              afferphi(6,ifrob)=afferphi(3,ifrob)+BZc

              IF (AMPRAN.NE.0.D0) THEN
                PHI=2.D0*PI1*XRANA(I)/FREQR*FREQ(IFREQ)
                DDMODU=EXP(ZI*PHI)
              ENDIF   !(AMPRAN.NE.0.D0)

              DMODU=DMODU0*DDMODU

              AX0=AX0*DMODU0
              AY0=AY0*DMODU0
              AZ0=AZ0*DMODU0

              AX=AX0*CORRR0
              AY=AY0*CORRR0
              AZ=AZ0*CORRR0

              AX=AX*DMODU
              AY=AY*DMODU
              AZ=AZ*DMODU

              BX0=BX0*DMODU0
              BY0=BY0*DMODU0
              BZ0=BZ0*DMODU0

              BXc=BX0*CORRR0
              BYc=BY0*CORRR0
              BZc=BZ0*CORRR0

              BXc=BXc*DMODU
              BYc=BYc*DMODU
              BZc=BZc*DMODU

              IF (IFREQ.EQ.1) THEN
                ILIOB=ISOUR+NSOURCE*(IOBSV-1)
                IF (I.EQ.1) THEN
                  POW=SPECPOWRPHI(ILIOB)
                  SPECPOWRPHI(ILIOB)=0.0D0
                ENDIF !(I.EQ.1) THEN
                R02=(OBSVRPHI(1,IOBSV)-CENXEXI)**2
     &            +OBSVRPHI(2,IOBSV)**2+OBSVRPHI(3,IOBSV)**2
                R2=(OBSVRPHI(1,IOBSV)-CENXEXI-DXEXI*(I-ABS(IAMPLI)/2+1))**2
     &            +OBSVRPHI(2,IOBSV)**2+OBSVRPHI(3,IOBSV)**2
                SPECPOWRPHI(ILIOB)=SPECPOWRPHI(ILIOB)+POW*R02/R2
     &            *R2/(sqrt(R2)-ampr2corr/2.0d0)**2/nelec
              ENDIF !IFREQ.EQ.1

              ICOUNT=ICOUNT+1
              IF (nelec.eq.1.and.ICOUNT.EQ.MCOUNT) THEN
                N10=N10+1
                CALL date_and_time(dtday,dttime,dtzone,idatetime)
                WRITE(6,*)' ',N10,ICOUNT/(NFREQ*NOBSVRPHI),' ',
     &            dttime(1:2),':',dttime(3:4),':',dttime(5:6)
                MCOUNT=MCOUNT+NCOUNT10
                IF (N10.EQ.9) MCOUNT=NCOUNT
              ENDIF

            ENDDO !IAMPLI

          ENDIF   !(IAMPLI.LT.0)

          if (ihbunch.ne.0.and.iobsv.eq.1) then
            fillb(1)=ibun
            fillb(2)=isub
            fillb(3)=ielec
            fillb(4)=bunchx
            fillb(5)=xelec
            fillb(6)=yelec
            fillb(7)=zelec
            fillb(8)=vyelec/vxelec
            fillb(9)=vzelec/vxelec
            fillb(10)=x2
            fillb(11)=y2
            fillb(12)=z2
            fillb(13)=vy2/vx2
            fillb(14)=vz2/vx2
            fillb(15)=egamma*emassg1
            fillb(16)=gamma*emassg1
            fillb(17)=xrphi
            fillb(18)=yrphi
            fillb(19)=zrphi
            fillb(20)=ifreq
            fillb(21)=freq(ifreq)
            speck=
     &        DREAL(
     &        afferphi(1,IFROB)*CONJG(afferphi(1,IFROB))
     &        +afferphi(2,IFROB)*CONJG(afferphi(2,IFROB))
     &        +afferphi(3,IFROB)*CONJG(afferphi(3,IFROB))
     &        )*specnor*bunnor
            fillb(22)=speck*nelec

            if (istokes.ne.0) then

              APOLH=
     &          afferphi(1,IFROB)*CONJG(VSTOKES(1,1))
     &          +afferphi(2,IFROB)*CONJG(VSTOKES(1,2))
     &          +afferphi(3,IFROB)*CONJG(VSTOKES(1,3))

              APOLR=
     &          afferphi(1,IFROB)*CONJG(VSTOKES(2,1))
     &          +afferphi(2,IFROB)*CONJG(VSTOKES(2,2))
     &          +afferphi(3,IFROB)*CONJG(VSTOKES(2,3))

              APOLL=
     &          afferphi(1,IFROB)*CONJG(VSTOKES(3,1))
     &          +afferphi(2,IFROB)*CONJG(VSTOKES(3,2))
     &          +afferphi(3,IFROB)*CONJG(VSTOKES(3,3))

              APOL45=
     &          afferphi(1,IFROB)*CONJG(VSTOKES(4,1))
     &          +afferphi(2,IFROB)*CONJG(VSTOKES(4,2))
     &          +afferphi(3,IFROB)*CONJG(VSTOKES(4,3))

              STOK1=
     &          APOLR*CONJG(APOLR)+
     &          APOLL*CONJG(APOLL)

              STOK2=-STOK1+
     &          2.0d0*APOLH*CONJG(APOLH)

              STOK3=
     &          2.0d0*APOL45*CONJG(APOL45)-
     &          STOK1

              STOK4=
     &          APOLR*CONJG(APOLR)-
     &          APOLL*CONJG(APOLL)

              fillb(23)=stok1*specnor*bunnor*nelec
              fillb(24)=stok2*specnor*bunnor*nelec
              fillb(25)=stok3*specnor*bunnor*nelec
              fillb(26)=stok4*specnor*bunnor*nelec

            else
              fillb(23)=fillb(22)
              fillb(24:26)=0.0d0
            endif !istokes

            fillb(27)=specpowrphi(isour)*pownor*bunnor*nelec
            fillb(28)=isour
            fillb(29)=t2

            call hfm(nidbunch,fillb)

          endif ! iobsv=1

          if (
     &        (ibunphase.eq.1.and.ielec.eq.1.and.iobunch.eq.-9999)
     &        .or.
     &        isub.eq.neinbunch
     &        ) then
            are(1:6)=dreal(afferphi(1:6,ifrob))
            aim(1:6)=dimag(afferphi(1:6,ifrob))
            ampz(ifreq)=sqrt(are(3)**2+aim(3)**2)
            if (ampz(ifreq).gt.ampzmax(ifreq)) then
              ampzmax(ifreq)=ampz(ifreq)
              kobs(ifreq)=iobsv
            endif
          endif

        ENDDO !NOBSVRPHI

        if (ibunphase.eq.1
     &    .or.isub.eq.neinbunch
     &    ) then
          ifrob=ifreq+nfreq*(kobs(ifreq)-1)
          are(1:6)=dreal(afferphi(1:6,ifrob))
          aim(1:6)=dimag(afferphi(1:6,ifrob))
          ampz(ifreq)=sqrt(are(3)**2+aim(3)**2)
          if (ampz(ifreq).ne.0.0d0) then
            azcos(ifreq)=are(3)/ampz(ifreq)
            azsin(ifreq)=aim(3)/ampz(ifreq)
          else
            azcos(ifreq)=1.0d0
            azsin(ifreq)=0.0d0
          endif
        endif

        DO IOBSV=1,NOBSVRPHI

          ifrob=ifreq+nfreq*(iobsv-1)

          if (ibunphase.eq.1) then
            are(1:6)=dreal(afferphi(1:6,ifrob))
            aim(1:6)=dimag(afferphi(1:6,ifrob))

            afferphi(1:6,ifrob)=dcmplx(
     &        azcos(ifreq)*are+azsin(ifreq)*aim,
     &        -azsin(ifreq)*are+azcos(ifreq)*aim
     &        )
          endif

          unphrphi(1:6,ifrob)=unphrphi(1:6,ifrob)+afferphi(1:6,ifrob)

          if (isub.eq.neinbunch) then

cold *** This does not work, we really need to call cyltocart for each bunch
cold            if (ibunphase.eq.0) then
cold
coldc destroy phase information between bunches by synchronization
cold
cold
ccold if ibunphase.ne.0, we have done it already
cold              are(1:3)=dreal(unphrphi(1:3,ifrob))
cold              aim(1:3)=dimag(unphrphi(1:3,ifrob))
cold
cold              unphrphi(1:3,ifrob)=dcmplx(
cold     &          azcos(ifreq)*are+azsin(ifreq)*aim,
cold     &          -azsin(ifreq)*are+azcos(ifreq)*aim
cold     &          )
cold            endif

            afreqrphi(1:6,ifrob)=afreqrphi(1:6,ifrob)
     &        +unphrphi(1:6,ifrob)
cold     &        *sqbunnor

            unphrphi(1:6,IFROB)=(0.0d0,0.0d0)

          endif !isub.eq.neinbunch

        ENDDO !NOBSVRPHI

      ENDDO !IFREQ

cold      if (ielec.ne.nelec) return
      if (isub.ne.neinbunch) return

      call cyltocart(isour)

      do iobsv=1,nobsv

        do ifreq=1,nfreq

          iliobfr=isour+nsource*(iobsv-1+nobsv*(ifreq-1))
          ifrob=ifreq+nfreq*(iobsv-1)
          iobfr=iobsv+nobsv*(ifreq-1)

          om=freq(ifreq)/hbarev1

          if(speccut.gt.0.0d0) then
            if (ispecmode.eq.1) ecmaxs=ecmax(isour)
            if(freq(ifreq).gt.speccut*ecdipev1*dmyenergy**2*ecmaxs) then
              afreq(1:6,ifrob)=(0.0d0,0.0d0)
            endif
          endif

          afreq(1:6,ifrob)=afreq(1:6,ifrob)*reflec(1)

          if (ipola.eq.0) then

            spec(iliobfr)=spec(iliobfr)+
     &        dreal(
     &        afreq(1,ifrob)*conjg(afreq(1,ifrob))
     &        +afreq(2,ifrob)*conjg(afreq(2,ifrob))
     &        +afreq(3,ifrob)*conjg(afreq(3,ifrob))
     &        )*specnor*bunnor

            reaima(1:3,1,iobfr)=reaima(1:3,1,iobfr)+
     &        dreal(afreq(1:3,ifrob))/sqnbunch

            reaima(1:3,2,iobfr)=reaima(1:3,2,iobfr)+
     &        dimag(afreq(1:3,ifrob))/sqnbunch

            reaima(6:8,1,iobfr)=reaima(6:8,1,iobfr)+
     &        dreal(afreq(4:6,ifrob))/sqnbunch

            reaima(6:8,2,iobfr)=reaima(6:8,2,iobfr)+
     &        dimag(afreq(4:6,ifrob))/sqnbunch

          else    !ipola

            apol=
     &        afreq(1,ifrob)*conjg(vpola(1))
     &        +afreq(2,ifrob)*conjg(vpola(2))
     &        +afreq(3,ifrob)*conjg(vpola(3))

            spec(iliobfr)=spec(iliobfr)+
     &        dreal(apol*conjg(apol))*specnor*bunnor

            reaima(1:3,1,iobfr)=reaima(1:3,1,iobfr)+
     &        dreal(afreq(1:3,ifrob))/sqnbunch

            reaima(1:3,2,iobfr)=reaima(1:3,2,iobfr)+
     &        dimag(afreq(1:3,ifrob))/sqnbunch

            reaima(6:8,1,iobfr)=reaima(6:8,1,iobfr)+
     &        dreal(afreq(4:6,ifrob))/sqnbunch

            reaima(6:8,2,iobfr)=reaima(6:8,2,iobfr)+
     &        dimag(afreq(4:6,ifrob))/sqnbunch

          endif   !ipola

          if (istokes.ne.0) then

            apolh=
     &        afreq(1,ifrob)*conjg(vstokes(1,1))
     &        +afreq(2,ifrob)*conjg(vstokes(1,2))
     &        +afreq(3,ifrob)*conjg(vstokes(1,3))

            apolr=
     &        afreq(1,ifrob)*conjg(vstokes(2,1))
     &        +afreq(2,ifrob)*conjg(vstokes(2,2))
     &        +afreq(3,ifrob)*conjg(vstokes(2,3))

            apoll=
     &        afreq(1,ifrob)*conjg(vstokes(3,1))
     &        +afreq(2,ifrob)*conjg(vstokes(3,2))
     &        +afreq(3,ifrob)*conjg(vstokes(3,3))

            apol45=
     &        afreq(1,ifrob)*conjg(vstokes(4,1))
     &        +afreq(2,ifrob)*conjg(vstokes(4,2))
     &        +afreq(3,ifrob)*conjg(vstokes(4,3))

            stok1=
     &        apolr*conjg(apolr)+
     &        apoll*conjg(apoll)

            stok2=-stok1+
     &        2.*apolh*conjg(apolh)

            stok3=
     &        2.*apol45*conjg(apol45)-
     &        stok1

            stok4=
     &        apolr*conjg(apolr)-
     &        apoll*conjg(apoll)

            stokes(1,iobfr)=stokes(1,iobfr)+
     &        stok1*specnor*bunnor

            stokes(2,iobfr)=stokes(2,iobfr)+
     &        stok2*specnor*bunnor

            stokes(3,iobfr)=stokes(3,iobfr)+
     &        stok3*specnor*bunnor

            stokes(4,iobfr)=stokes(4,iobfr)+
     &        stok4*specnor*bunnor

          endif   !istokes

          afreq(1:6,ifrob)=(0.0d0,0.0d0)

        enddo !ifreq

        iliob=isour+nsource*(iobsv-1)
        specpow(iliob)=specpow(iliob)*pownor

      enddo !nobsv


      if (mpinr.ne.0) then

c only used for Ntuple 5700 so far, 28.3.2012

        do iobsv=1,nobsvrphi

          do ifreq=1,nfreq

            iliobfr=isour+nsource*(iobsv-1+nobsvrphi*(ifreq-1))
            ifrob=ifreq+nfreq*(iobsv-1)
            iobfr=iobsv+nobsvrphi*(ifreq-1)

            om=freq(ifreq)/hbarev1

            if(speccut.gt.0.0d0) then
              if(freq(ifreq).gt.speccut*ecdipev1*dmyenergy**2*ecmaxs) then
                afreqrphi(1:6,ifrob)=(0.0d0,0.0d0)
              endif
            endif

            afreqrphi(1,ifrob)=afreqrphi(1,ifrob)*reflec(1)
            afreqrphi(2,ifrob)=afreqrphi(2,ifrob)*reflec(2)
            afreqrphi(3,ifrob)=afreqrphi(3,ifrob)*reflec(3)

            afreqrphi(4,ifrob)=afreqrphi(4,ifrob)*reflec(1)
            afreqrphi(5,ifrob)=afreqrphi(5,ifrob)*reflec(2)
            afreqrphi(6,ifrob)=afreqrphi(6,ifrob)*reflec(3)

            if (ipola.eq.0) then

              specrphi(iliobfr)=specrphi(iliobfr)+
     &          dreal(
     &          afreqrphi(1,ifrob)*conjg(afreqrphi(1,ifrob))
     &          +afreqrphi(2,ifrob)*conjg(afreqrphi(2,ifrob))
     &          +afreqrphi(3,ifrob)*conjg(afreqrphi(3,ifrob))
     &          )*specnor*bunnor

              reaimarphi(1:3,1,iobfr)=reaimarphi(1:3,1,iobfr)+
     &          dreal(afreqrphi(1:3,ifrob))/sqnbunch

              reaimarphi(1:3,2,iobfr)=reaimarphi(1:3,2,iobfr)+
     &          dimag(afreqrphi(1:3,ifrob))/sqnbunch

              reaimarphi(6:8,1,iobfr)=reaimarphi(6:8,1,iobfr)+
     &          dreal(afreqrphi(4:6,ifrob))/sqnbunch

              reaimarphi(6:8,2,iobfr)=reaimarphi(6:8,2,iobfr)+
     &          dimag(afreqrphi(4:6,ifrob))/sqnbunch

            else    !ipola

              apol=
     &          afreqrphi(1,ifrob)*conjg(vpola(1))
     &          +afreqrphi(2,ifrob)*conjg(vpola(2))
     &          +afreqrphi(3,ifrob)*conjg(vpola(3))

              specrphi(iliobfr)=specrphi(iliobfr)+
     &          dreal(apol*conjg(apol))*specnor*bunnor

              reaimarphi(1:3,1,iobfr)=reaimarphi(1:3,1,iobfr)+
     &          dreal(afreqrphi(1:3,ifrob))/sqnbunch

              reaimarphi(1:3,2,iobfr)=reaimarphi(1:3,2,iobfr)+
     &          dimag(afreqrphi(1:3,ifrob))/sqnbunch

              reaimarphi(6:8,1,iobfr)=reaimarphi(6:8,1,iobfr)+
     &          dreal(afreqrphi(4:6,ifrob))/sqnbunch

              reaimarphi(6:8,2,iobfr)=reaimarphi(6:8,2,iobfr)+
     &          dimag(afreqrphi(4:6,ifrob))/sqnbunch

            endif   !ipola

            afreqrphi(1:6,ifrob)=(0.0d0,0.0d0)

          enddo !ifreq

      enddo !nobsvrphi

      endif !(mpinr.ne.0) then

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '       phase advance per step at beginning and end of source for'
      WRITE(LUNGFO,*)
     &  '       lowest and highest photon energy at selected observation point:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       beginning:',SNGL(DPHSOUR(1,1)),SNGL(DPHSOUR(1,2))
      WRITE(LUNGFO,*)'       end:      ',SNGL(DPHSOUR(2,1)),SNGL(DPHSOUR(2,2))
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       ROIs (boundary, precision, points):'
      WRITE(LUNGFO,*)

      DO IROI=1,NROIA-1
        WRITE(LUNGFO,*)
     &    IROI,SNGL(ROIX(IROI)),SNGL(ROIP(IROI)),IPOIROI(IROI+1)
      ENDDO
      WRITE(LUNGFO,*)
     &  NROI,SNGL(ROIX(NROIA))

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       SOURCE, TOTAL NUMBER OF STEPS:',ISOUR,IZAEHL
      WRITE(LUNGFO,*)'       (controlled by NLPOI and namelist $ROIN)'
      WRITE(LUNGFO,*)

      ICAL=1

      do iobsv=1,nobsvrphi
        if (iinside(iobsv).ne.0) then
          inside=1
          exit
        endif
      enddo

      deallocate(ampzmax,kobs,iinside,jinside)

      RETURN
      END
+DECK,aphase.
*CMZ :  4.01/04 15/11/2023  12.38.14  by  Michael Scheer
*CMZ :  3.02/03 03/11/2014  12.10.03  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.66/03 12/05/2010  13.34.28  by  Michael Scheer
*-- Author :    Michael Scheer   27/10/2009
      subroutine aphase(isour)
+seq,gplhint.

c calculates phase of field amplitudes afreq and afreqrphi

+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,AFREQF90U.
+SEQ,SPECTF90U.
+SEQ,WFOLDF90U.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEq,observf90.
+SEQ,DEPOLA.
+SEq,wfoldf90.
+seq,sourcef90.
+SEQ,FREQS.
+SEQ,PHYCON.
+SEQ,SPECTF90.

      double precision cenxexi,dphase,phiy,phiz,phiy1,phiz1
     &  ,ddist,h2,dist0,dist02,dphi

      integer iphi,ir,isour,ifreq,iobrp,idphi2pi

      cenxexi=(min(sourceeo(1,1,isour),xiend)
     &  +max(sourceao(1,1,isour),xianf))/2.d0

      if (ipin.ne.0) then
        dist0=pincen(1)-cenxexi
      else
        dist0=obs1x-cenxexi
      endif

      dist02=dist0**2

      do ifreq=1,nfreq

        if (mpinr.ne.0) then

          iobrp=0

          do iphi=1,nobsvphi

            phiy1=0.0d0
            phiz1=0.0d0

            do ir=1,nobsvr

              iobrp=iobrp+1
              iobfr=iobrp+nobsvrphi*(ifreq-1)

              h2=(obsvr(ir)/dist0)**2
              if (h2.lt.0.01) then
                ddist=dist0*(h2/2.0d0-h2**2/8.0d0)
              else
                ddist=dist0*(sqrt(1.0d0+h2)-1.0d0)
              endif

              dphase=ddist/freq(ifreq)*wtoe1*1.0d9*twopi1
              dphase=0.0d0

c              phiy=atan2(reaimarphi(2,2,iobfr),reaimarphi(2,1,iobfr))
c              phiz=atan2(reaimarphi(3,2,iobfr),reaimarphi(3,1,iobfr))
              if (reaimarphi(2,1,iobfr).ne.0.0d0) then
                phiy=atan(reaimarphi(2,2,iobfr)/reaimarphi(2,1,iobfr))
              else
                phiy=sign(halfpi1,reaimarphi(2,2,iobfr))
              endif

              if (reaimarphi(3,1,iobfr).ne.0.0d0) then
                phiz=atan(reaimarphi(3,2,iobfr)/reaimarphi(3,1,iobfr))
              else
                phiz=sign(halfpi1,reaimarphi(3,2,iobfr))
              endif

              reaimarphi(4,1,iobfr)=
     &          sqrt(reaimarphi(2,1,iobfr)**2+reaimarphi(2,2,iobfr)**2)
              reaimarphi(4,2,iobfr)=phiy

              reaimarphi(5,1,iobfr)=
     &          sqrt(reaimarphi(3,1,iobfr)**2+reaimarphi(3,2,iobfr)**2)
              reaimarphi(5,2,iobfr)=phiz

              phiz1=phiz

            enddo !nobsvr

          enddo !iphi

        endif !(mpinr.ne.0) then

      enddo !nfreq

      return
      end
+DECK,ampfold.
*CMZ :  4.01/04 14/11/2023  13.37.28  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.66/03 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.51/02 08/10/2009  09.58.11  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  14.22.46  by  Michael Scheer
*CMZ :  2.13/10 14/04/2000  14.26.49  by  Michael Scheer
*CMZ :  2.13/04 21/01/2000  14.54.46  by  Michael Scheer
*CMZ :  2.13/03 11/01/2000  18.22.28  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.56.38  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.16  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE ampfold
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,AFREQF90U.

C--- CALCULATES FOLDING OF FIELD AMPLITUDES WITH ELECTRON PHASE SPACE
C    DISTRIBUTIONS (GAUSSIAN DISTRIBUTION)

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEq,observf90.
+SEQ,FREQS.
+seq,sourcef90.
+SEQ,SPECT.

      INTEGER IFREQ,IZ,IY,IOBSV,ICOMP,ireim,ieb,i1,i2

C--- CALCULATE FOURIER-COEFFICIENTS OF GAUSSIAN

c      CALL WGFOUR ! already done in WFOLD

      IF (nsource.gt.1) then
        write(6,*)' '
        write(6,*)' *** Warning in AMPFOLD: More than one source.'
        write(6,*)' Sigmas for folding procedure are taken for source',nsource/2+1
        write(6,*)' '
        write(lungfo,*)' '
        write(lungfo,*)' *** Warning in AMPFOLD: More than one source.'
        write(lungfo,*)' Sigmas for folding procedure are taken for source',nsource/2+1
        write(lungfo,*)' '
      endif

      IF (IFOLD.EQ.-2) then
        write(6,*)' '
        write(6,*)' *** Warning in AMPFOLD: Modus IFOLD.EQ.-2 not available.'
        write(6,*)' '
        write(lungfo,*)' '
        write(lungfo,*)' *** Warning in AMPFOLD: Modus IFOLD.EQ.-2 not available.'
        write(lungfo,*)' '
      endif

c14.11,2023      DO icomp=2,3
      do ieb=1,2

        if (ieb.eq.1) then
          i1=1
          i2=3
        else
          i1=6
          i2=8
        endif

        DO icomp=i1,i2
          DO ireim=1,2

            DO IFREQ=1,NFREQ

C--- PERFORM FOLDING

              CALL AFOLINT(icomp,ireim,IFREQ)

C--- DELETE INTENSITY IN EDGES

              DO IY=1,NOBSVY
                DO IZ=1,NOBSVZ

                  IOBSV=NOBSVZ*(IY-1)+IZ
                  IOBFR=IOBSV+NOBSV*(IFREQ-1)

                  IF (IPINCIRC.EQ.0) THEN

                    IF (
     &                  IY.LT.(NOBSVY-MOBSVY)/2+1
     &                  .OR.IY.GT.(NOBSVY-MOBSVY)/2+MOBSVY
     &                  .OR.IZ.LT.(NOBSVZ-MOBSVZ)/2+1
     &                  .OR.IZ.GT.(NOBSVZ-MOBSVZ)/2+MOBSVZ
     &                  ) THEN
                      reaima(icomp+2,ireim,iobfr)=0.0d0
                    ENDIF

                  ELSE  !IPINCIRC

                    IF (
     &                  (OBSVZ(IZ)-PINCEN(3))**2
     &                  +(OBSVY(IY)-PINCEN(2))**2
     &                  -PINR**2
     &                  .GT.1.D-10
     &                  ) THEN
                      reaima(icomp+2,ireim,iobfr)=0.0d0
                    ENDIF

                  ENDIF !IPINCIRC

                ENDDO !IZ
              ENDDO !IY

            ENDDO !IFREQ

          ENDDO !ireim
        ENDDO !icomp

      enddo !ieb=1,2

      RETURN
      END
+DECK,afolint.
*CMZ :  4.01/04 14/11/2023  13.46.13  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.66/03 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.51/02 08/10/2009  09.58.11  by  Michael Scheer
*CMZ :  2.34/09 24/09/2001  16.48.01  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  16.27.20  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.33  by  Michael Scheer
*CMZ :  2.15/00 08/05/2000  13.33.58  by  Michael Scheer
*CMZ :  2.14/02 27/04/2000  17.54.22  by  Michael Scheer
*CMZ :  2.13/10 14/04/2000  17.10.49  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.24.36  by  Michael Scheer
*CMZ :  2.13/03 20/12/99  17.39.24  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  14.43.03  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  11.21.35  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  18.07.26  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.22  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE AFOLINT(icomp,ireim,IFREQ)
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,AFREQF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,WFOLDF90U.

C--- FOLD FIELDAMPLITUDE DENSITY IN PINHOLE

C    IFOLD.EQ.-2: not available
C    IFOLD.EQ.-1: SR UTIL_FOLD_FOURIER IS USED
C    IFOLD.EQ.1: SR UTIL_FOLD_FUNCTION_GAUSS IS USED

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEq,wfoldf90.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.

      INTEGER IZA,IZE,IYA,IYE,IFREQ,IY,IZ,IMASH
     &       ,NF,NFOLD,IFAIL,IGZY,icomp,ireim,isour

      DOUBLE PRECISION ZKZ0,YKY0,GZ(NGCOEFP*LIDIMP),GY(NGCOEFP*LIDIMP)

c14.11.2023      if (icomp.eq.1) return

      isour=nsource/2+1

      IF (IFOLD.EQ.1) THEN

        IYA=1+(NOBSVY-MOBSVY)/2
        IYE=NOBSVY-(NOBSVY-MOBSVY)/2

        IF (NOBSVZ.GT.1) THEN

          IZA=1+(NOBSVZ-MOBSVZ)/2
          IZE=NOBSVZ-(NOBSVZ-MOBSVZ)/2

          NF=NOBSV*(IFREQ-1)

          DO IY=1,NOBSVY

            DO IZ=1,NOBSVZ
              IMASH=IZ+(IY-1)*NOBSVZ
              IOBFR=imash+NOBSV*(IFREQ-1)
              wobs1(iz)=reaima(icomp,ireim,iobfr)
            ENDDO !IZ

            CALL UTIL_FOLD_FUNCTION_GAUSS(
     &        NOBSVZ,OBSVZ,WOBS1,WSIGZ(ISOUR),DGSIGZ(ISOUR),WOBS2,
     &        WOBS3,WOBS4,WOBS5,WOBS6,WOBS7)

            DO IZ=IZA,IZE
              IMASH=IZ+(IY-1)*NOBSVZ
              IOBFR=imash+NOBSV*(IFREQ-1)
              if (icomp.eq.2.or.icomp.eq.3) then
                reaima(icomp+2,ireim,iobfr)=WOBS2(IZ)
              else if (icomp.eq.1) then
                reaima(11,ireim,iobfr)=WOBS2(IZ)
              else if (icomp.gt.5) then
                reaima(icomp+6,ireim,iobfr)=WOBS2(IZ)
              endif
            ENDDO

          ENDDO   !IY

        ELSE !(NOBSVZ.GT.1)

          NF=NOBSV*(IFREQ-1)

          DO IY=1,NOBSVY
            IMASH=1+(IY-1)*NOBSVZ
            IOBFR=imash+NOBSV*(IFREQ-1)
            if (icomp.eq.2.or.icomp.eq.3) then
              reaima(icomp+2,ireim,iobfr)=reaima(icomp,ireim,iobfr)
            else if (icomp.eq.1) then
              reaima(11,ireim,iobfr)=reaima(icomp,ireim,iobfr)
            else if (icomp.gt.5) then
              reaima(icomp+6,ireim,iobfr)=reaima(icomp,ireim,iobfr)
            endif
          ENDDO

        ENDIF !(NOBSVZ.GT.1)

        DO IZ=1,NOBSVZ

          DO IY=1,NOBSVY
            IMASH=IZ+(IY-1)*NOBSVZ
            IOBFR=imash+NOBSV*(IFREQ-1)
            wobs1(iy)=reaima(icomp,ireim,iobfr)
          ENDDO   !IY

            CALL UTIL_FOLD_FUNCTION_GAUSS(
     &        NOBSVY,OBSVY,WOBS1,WSIGY(ISOUR),DGSIGY(ISOUR),WOBS2,
     &        WOBS3,WOBS4,WOBS5,WOBS6,WOBS7)

          DO IY=IYA,IYE
            IMASH=IZ+(IY-1)*NOBSVZ
            IOBFR=imash+NOBSV*(IFREQ-1)
            if (icomp.eq.2.or.icomp.eq.3) then
              reaima(icomp+2,ireim,iobfr)=WOBS2(IY)
            else if (icomp.eq.1) then
              reaima(11,ireim,iobfr)=WOBS2(IY)
            else if (icomp.gt.5) then
              reaima(icomp+6,ireim,iobfr)=WOBS2(IY)
            endif
          ENDDO

        ENDDO  !IZ

      ELSE IF(IFOLD.EQ.-1) THEN

        IYA=1+(NOBSVY-MOBSVY)/2
        IYE=NOBSVY-(NOBSVY-MOBSVY)/2

        IF (NOBSVZ.GT.1) THEN

          IZA=1+(NOBSVZ-MOBSVZ)/2
          IZE=NOBSVZ-(NOBSVZ-MOBSVZ)/2

          ZKZ0=XKGAUSS(1,ISOUR)
          NFOLD=NINT(DSIGZ(ISOUR)/OBSVDZ)

          NF=NOBSV*(IFREQ-1)
          IGZY=1+NGCOEFP*(ISOUR-1)

          DO IY=1,NOBSVY

            DO IZ=1,NOBSVZ
              IMASH=IZ+(IY-1)*NOBSVZ
              IOBFR=imash+NOBSV*(IFREQ-1)
              wobs1(iz)=reaima(icomp,ireim,iobfr)
            ENDDO !IZ

            CALL UTIL_FOLD_FOURIER(OBSVZ,WOBS1,NOBSVZ,NFOLD
     &        ,GZ(IGZY),NGFOURZ,WOBS2,WOBS3,WOBS4,WOBS5,WOBS6,WOBS7,IFAIL)

            IF (IFAIL.NE.0) WRITE(LUNGFO,*)
     &        '*** WARNING IN AFOLINT: FAILURE IN UTIL_FOLD_FOURIER ***'

            DO IZ=IZA,IZE
              IMASH=IZ+(IY-1)*NOBSVZ
              IOBFR=imash+NOBSV*(IFREQ-1)
              if (icomp.eq.2.or.icomp.eq.3) then
                reaima(icomp+2,ireim,iobfr)=WOBS2(IZ)
              else if (icomp.eq.1) then
                reaima(11,ireim,iobfr)=WOBS2(IZ)
              else if (icomp.gt.5) then
                reaima(icomp+6,ireim,iobfr)=WOBS2(IZ)
              endif
            ENDDO

          ENDDO   !IY

        ELSE !(NOBSVZ.GT.1)

          NF=NOBSV*(IFREQ-1)
          IGZY=1+NGCOEFP*(ISOUR-1)
          DO IY=1,NOBSVY
            IMASH=1+(IY-1)*NOBSVZ
            IOBFR=imash+NOBSV*(IFREQ-1)
            if (icomp.eq.2.or.icomp.eq.3) then
              reaima(icomp+2,ireim,iobfr)=reaima(icomp,ireim,iobfr)
            else if (icomp.eq.1) then
              reaima(11,ireim,iobfr)=reaima(icomp,ireim,iobfr)
            else if (icomp.gt.5) then
              reaima(icomp+6,ireim,iobfr)=reaima(icomp,ireim,iobfr)
            endif
          ENDDO

        ENDIF !(NOBSVZ.GT.1)

        YKY0=YKGAUSS(1,ISOUR)
        NFOLD=NINT(DSIGY(ISOUR)/OBSVDY)

        DO IZ=1,NOBSVZ

          DO IY=1,NOBSVY
            IMASH=IZ+(IY-1)*NOBSVZ
            IOBFR=imash+NOBSV*(IFREQ-1)
            wobs1(iy)=reaima(icomp,ireim,iobfr)
          ENDDO   !IY

          CALL UTIL_FOLD_FOURIER(OBSVY,WOBS1,NOBSVY,NFOLD
     &      ,GY(IGZY),NGFOURY,WOBS2,WOBS3,WOBS4,WOBS5,WOBS6,WOBS7,IFAIL)

          IF (IFAIL.NE.0) WRITE(LUNGFO,*)
     &      '*** WARNING IN AFOLINT: FAILURE IN UTIL_FOLD_FOURIER ***'

          DO IY=IYA,IYE
            IMASH=IZ+(IY-1)*NOBSVZ
            IOBFR=imash+NOBSV*(IFREQ-1)
            if (icomp.eq.2.or.icomp.eq.3) then
              reaima(icomp+2,ireim,iobfr)=WOBS2(IY)
            else if (icomp.eq.1) then
              reaima(11,ireim,iobfr)=WOBS2(IY)
            else if (icomp.gt.5) then
              reaima(icomp+6,ireim,iobfr)=WOBS2(IY)
            endif
          ENDDO

        ENDDO  !IZ

      ENDIF !IFOLD

      RETURN
      END
+DECK,PININ.
*CMZ :  4.01/04 22/11/2023  17.20.47  by  Michael Scheer
*CMZ :  4.00/15 12/02/2022  17.08.21  by  Michael Scheer
*CMZ :  4.00/13 04/12/2021  12.10.40  by  Michael Scheer
*CMZ :  4.00/01 05/04/2019  15.09.32  by  Michael Scheer
*CMZ :  3.06/00 25/02/2019  17.19.30  by  Michael Scheer
*CMZ :  3.02/08 24/06/2015  16.06.32  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  11.59.38  by  Michael Scheer
*CMZ :  2.67/02 28/03/2012  08.22.03  by  Michael Scheer
*CMZ :  2.66/06 22/05/2010  16.48.23  by  Michael Scheer
*CMZ :  2.64/06 15/09/2009  11.10.54  by  Michael Scheer
*CMZ :  2.64/05 14/09/2009  15.19.42  by  Michael Scheer
*CMZ :  2.62/03 16/07/2007  11.51.09  by  Michael Scheer
*CMZ :  2.62/02 16/07/2007  06.52.55  by  Michael Scheer
*CMZ :  2.54/05 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.52/10 05/11/2004  16.59.34  by  Michael Scheer
*CMZ :  2.51/00 17/05/2004  17.43.59  by  Michael Scheer
*CMZ :  2.47/16 11/09/2003  15.10.02  by  Michael Scheer
*CMZ :  2.34/09 18/09/2001  22.52.09  by  Michael Scheer
*CMZ :  2.34/00 11/05/2001  12.38.34  by  Michael Scheer
*CMZ :  2.17/00 03/11/2000  09.47.59  by  Michael Scheer
*CMZ :  2.16/08 24/10/2000  12.09.17  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.16/00 27/05/2000  14.03.56  by  Michael Scheer
*CMZ :  2.15/00 08/05/2000  13.32.10  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.24.35  by  Michael Scheer
*CMZ :  2.13/02 14/12/99  16.24.13  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  14.47.16  by  Michael Scheer
*CMZ : 00.02/04 24/02/97  12.37.49  by  Michael Scheer
*CMZ : 00.02/00 19/11/96  14.57.13  by  Michael Scheer
*CMZ : 00.01/08 22/06/95  17.29.50  by  Michael Scheer
*CMZ : 00.01/06 01/02/95  16.35.43  by  Michael Scheer
*CMZ : 00.01/04 29/11/94  10.17.51  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  17.07.25  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.52.56  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.26  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE PININ
+seq,gplhint.

+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,WFOLDF90U.

C--- INITIALIZE GRID OF OBERSERVATION POINTS OF PINHOLE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEq,observf90.
+SEQ,DEPOLA.
+SEq,wfoldf90.
+seq,sourcef90.


      INTEGER IOB,IY,IZ,INCZ,INCY,ISOUR,INCZMX,INCYMX
      INTEGER N2POWZ,N2POWY,ICDUMZ,ICDUMY

      DOUBLE PRECISION OBSVDUM(3,1),x,y,z,xn,yn,zn,r,r0,pinwo,pinho,pinro

      INTEGER IFPHIR_A,iobsv
      DATA IFPHIR_A/0/

      pinwo=pinw
      pinho=pinh
      pinro=pinr

      IF (IPINCIRC.NE.0) THEN
        PINW=2.D0*PINR
        PINH=2.D0*PINR
      ENDIF !IPINCIRC

      IF (OBSVDZ.NE.0.D0) THEN
        MPINZ=NINT(PINW/OBSVDZ)+1
        if (mpinz.lt.3) then
          write(6,*)"*** Warning in pinin: OBSVDZ > PINW/2., will be adjusted ***"
          write(lungfo,*)"*** Warning in pinin: OBSVDZ > PINW/2., will be adjusted ***"
          mpinz=3
          obsvdz=pinw/2.0d0
        endif
        PINW=OBSVDZ*(MPINZ-1)
      ENDIF !(OBSVDZ.NE.0.D0)

      IF (OBSVDY.NE.0.D0) THEN
        MPINY=NINT(PINH/OBSVDY)+1
        if (mpiny.lt.3) then
          write(6,*)"*** Warning in pinin: OBSVDY > PINH/2., will be adjusted ***"
          write(lungfo,*)"*** Warning in pinin: OBSVDY > PINH/2., will be adjusted ***"
          mpiny=3
          obsvdy=pinh/2.0d0
        endif
        PINH=OBSVDY*(MPINY-1)
      ENDIF !(OBSVDZ.NE.0.D0)

      IF (IPINCIRC.NE.0) THEN
        PINR=min(pinw,pinh)/2.0d0
      ENDIF !IPINCIRC

      if (abs(pinwo-pinw).gt.pinw/10000.0d0) then
        print*,"*** Warning in PINI: PINW is adjusted, according to MPINZ and DOBSVDZ ***"
      endif

      if (abs(pinho-pinh).gt.pinh/10000.0d0) then
        print*,"*** Warning in PINI: PINH is adjusted, according to MPINY and DOBSVDY ***"
      endif

      if (abs(pinro-pinr).gt.pinr/10000.0d0) then
        print*,"*** Warning in PINI: PINR is adjusted, according to PINW and PINH ***"
      endif

      IF (PINCEN(2).EQ.9999.) THEN
        IF     (IPBRILL.EQ.0) THEN
          PINCEN(2)=0.0
        ELSE IF (IPBRILL.EQ.1) THEN
          PINCEN(2)=PINH/2.D0
        ELSE IF (IPBRILL.EQ.2) THEN
          PINCEN(2)=PINH/2.D0
        ELSE IF (IPBRILL.EQ.3) THEN
          PINCEN(2)=-PINH/2.D0
        ELSE IF (IPBRILL.EQ.4) THEN
          PINCEN(2)=-PINH/2.D0
        ENDIF !IPBRILL
      ELSE IF (PINCEN(2).EQ.-9999.) THEN
        PINCEN(2)=YSTART+VYIN/VXIN*(PINCEN(1)-XSTART)
      ENDIF !PINCEN(2)

      IF (PINCEN(3).EQ.9999.) THEN
        IF     (IPBRILL.EQ.0) THEN
          PINCEN(3)=0.0
        ELSE IF (IPBRILL.EQ.1) THEN
          PINCEN(3)=PINW/2.D0
        ELSE IF (IPBRILL.EQ.2) THEN
          PINCEN(3)=-PINW/2.D0
        ELSE IF (IPBRILL.EQ.3) THEN
          PINCEN(3)=-PINW/2.D0
        ELSE IF (IPBRILL.EQ.4) THEN
          PINCEN(3)=PINW/2.D0
        ENDIF !IPBRILL
      ELSE IF (PINCEN(3).EQ.-9999.) THEN
        PINCEN(3)=ZSTART+VZIN/VXIN*(PINCEN(1)-XSTART)
      ENDIF !PINCEN(3)

      IF(NDOBSVZ*NDOBSVY.NE.NDOBSV) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*) '*** ERROR IN PININ ***'
        WRITE(LUNGFO,*) 'DIMENSION DECLARATIONS NOT CONSISTENT'
        WRITE(LUNGFO,*) 'NDOBSV MUST BE EQUAL TO NDOBSVZ*NDOBSVY'
        WRITE(LUNGFO,*) 'CHANGE PARAMETER IN CMPARA.CMN'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED  ***'
        WRITE(6,*)
        WRITE(6,*) '*** ERROR IN PININ ***'
        WRITE(6,*) 'DIMENSION DECLARATIONS NOT CONSISTENT'
        WRITE(6,*) 'NDOBSV MUST BE EQUAL TO NDOBSVZ*NDOBSVY'
        WRITE(6,*) 'CHANGE PARAMETER IN CMPARA.CMN'
        WRITE(6,*)
        WRITE(6,*)'*** PROGRAM WAVE ABORTED  ***'
        STOP
      ENDIF

C--- DATA OF PINHOLE ARE TAKEN FORM NAMELIST

      IF (IF1DIM.NE.0.AND.
     &    (MEDGEZ.NE.0.OR.MMEDGEZ.NE.0.OR.MPINZ.NE.1)) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN PININ ***'
        WRITE(LUNGFO,*)'FLAG IF1DIM SET BUT'
        WRITE(LUNGFO,*)
     &    'MEDGEZ OR MMEDGEZ IN NAMELIST PINHOLE NOT ZERO OR MPINZ NOT EQUAL ONE'
        WRITE(LUNGFO,*)'ADJUSTED TO APPROPRIATE VALUES'
        WRITE(LUNGFO,*)
c        WRITE(6,*)
c        WRITE(6,*)
c        WRITE(6,*)'*** WARNING IN PININ ***'
c        WRITE(6,*)'FLAG IF1DIM SET BUT'
c        WRITE(6,*)
c     &    'MEDGEZ OR MMEDGEZ IN NAMELIST PINHOLE NOT ZERO OR MPINZ NOT EQUAL ONE'
c        WRITE(6,*)'ADJUSTED TO APPROPRIATE VALUES'
c        WRITE(6,*)
        MPINZ=1
        MEDGEZ=0
        MMEDGEZ=0
      ENDIF

      IF (IUSEM.NE.0) THEN
C MAKE MPINZ AND MPINY EVEN
        MPINZ=(MPINZ+1)/2*2
        MPINY=(MPINY+1)/2*2
      ENDIF !IUSEM

      NOBSVY=MPINY
      NOBSVZ=MPINZ
      NOBSV=NOBSVY*NOBSVZ
      IF (NOBSV.LE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN PININ ***'
        WRITE(LUNGFO,*)'*** NEGATIVE NUMBER OF OBSERVATION POINTS!'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN PININ ***'
        WRITE(6,*)'*** NEGATIVE NUMBER OF OBSERVATION POINTS!'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      OBSVDUM(1,1)=PINCEN(1)

      IF (MPINZ.GT.1) THEN
        OBSVDZ=PINW/DFLOAT(MPINZ-1)
        OBSVDUM(3,1)=PINCEN(3)-PINW/2.
      ELSE
        OBSVDZ=PINW
        OBSVDUM(3,1)=PINCEN(3)
      ENDIF

      IF (MPINY.GT.1) THEN
        OBSVDY=PINH/DFLOAT(MPINY-1)
        OBSVDUM(2,1)=PINCEN(2)-PINH/2.
      ELSE
        OBSVDY=PINH
        OBSVDUM(2,1)=PINCEN(2)
      ENDIF

      IF (IF1DIM.EQ.0.AND.(MEDGEZ.LT.1.OR.MEDGEY.LT.1)) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN PININ ***'
        WRITE(LUNGFO,*)'MEDGEZ OR MEDGEY IN NAMELIST PINHOLE LOWER THAN 1'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED  ***'
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN PININ ***'
        WRITE(6,*)'MEDGEZ OR MEDGEY IN NAMELIST PINHOLE LOWER THAN 1'
        WRITE(6,*)
        WRITE(6,*)'*** PROGRAM WAVE ABORTED  ***'
        STOP
      ENDIF

      IF (MMEDGEZ.LT.0.OR.MMEDGEY.LT.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN PININ ***'
        WRITE(LUNGFO,*)'MMEDGEZ OR MMEDGEY IN NAMELIST PINHOLE LOWER THAN 0'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED  ***'
        WRITE(6,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN PININ ***'
        WRITE(6,*)'MMEDGEZ OR MMEDGEY IN NAMELIST PINHOLE LOWER THAN 0'
        WRITE(6,*)
        WRITE(6,*)'*** PROGRAM WAVE ABORTED  ***'
        STOP
      ENDIF

C- DETERMINE RMS VALUES FOR FOLDING

      IF (IFOLD.NE.0) CALL WSIGFOL

C- INCREASE PINHOLE

      MOBSVZ=NOBSVZ  !STORE VALUES
      MOBSVY=NOBSVY
      MOBSV=NOBSV

      INCZ=0
      INCY=0

      IF (IFOLD.NE.0.AND.IFOLD.NE.2) THEN

        INCZMX=-1
        INCYMX=-1
        DO ISOUR=1,NSOURCE
          INCZ=NINT(WSIGZ(ISOUR)*DGSIGZ(ISOUR)/OBSVDZ)
          IF(INCZ.GT.INCZMX) THEN
            INCZMX=INCZ
          ENDIF
          INCY=NINT(WSIGY(ISOUR)*DGSIGY(ISOUR)/OBSVDY)
          IF(INCY.GT.INCYMX) THEN
            INCYMX=INCY
          ENDIF
        ENDDO   !ISOUR

        INCZ=INCZMX
        INCY=INCYMX
        IF (IF1DIM.NE.0) INCZ=0

      ENDIF !IFOLD

C           FACTOR 2 FOR BOTH SIDES OF PINHOLE
      NOBSVZ=MOBSVZ+2*(INCZ+MEDGEZ+MMEDGEZ)
      NOBSVY=MOBSVY+2*(INCY+MEDGEY+MMEDGEY)

C--- ADJUST NUMBER OF POINTS ACCORDING TO POWERS OF IF FLAG IUSEM IS SET

      IF (IUSEM.NE.0) THEN

        N2POWZ=NINT(ALOG(FLOAT(NOBSVZ-1))/ALOG(2.))
        IF(NOBSVZ .GT. 2**N2POWZ) N2POWZ=N2POWZ+1
C150793        NOBSVZ=2**N2POWZ+1
        NOBSVZ=2**N2POWZ

        N2POWY=NINT(ALOG(FLOAT(NOBSVY-1))/ALOG(2.))
        IF(NOBSVY .GT. 2**N2POWY) N2POWY=N2POWY+1
C150793        NOBSVY=2**N2POWY+1
        NOBSVY=2**N2POWY

      ENDIF !IUSEM

      OBSVDUM(2,1)=OBSVDUM(2,1)-(NOBSVY-MOBSVY)/2*OBSVDY
      OBSVDUM(3,1)=OBSVDUM(3,1)-(NOBSVZ-MOBSVZ)/2*OBSVDZ

      NOBSV=NOBSVZ*NOBSVY
      IF (NOBSV.GT.1000000) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN PININ ***'
        WRITE(LUNGFO,*)'*** MORE THAN 1 000 0000 OBSERVATION POINTS ***'
        WRITE(LUNGFO,*)'NUMBER OF POINTS IN Y:',NOBSVY
        WRITE(LUNGFO,*)'NUMBER OF POINTS IN Z:',NOBSVZ
        IF (IFOLD.NE.0) WRITE(LUNGFO,*)'PLEASE CHECK PINHOLE SIZE AND RELATION TO BEAM EMITTANCE'
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN PININ ***'
        WRITE(6,*)'*** MORE THAN 1 000 000 OBSERVATION POINTS ***'
        WRITE(6,*)'NUMBER OF POINTS IN Y:',NOBSVY
        WRITE(6,*)'NUMBER OF POINTS IN Z:',NOBSVZ
        IF (IFOLD.NE.0) WRITE(6,*)'PLEASE CHECK PINHOLE SIZE AND RELATION TO BEAM EMITTANCE'
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IOBSV_A.NE.NOBSV) THEN
        IF (IOBSV_A.NE.0) DEALLOCATE(OBSV)
        ALLOCATE(OBSV(3,NOBSV))
        IOBSV_A=NOBSV
      ENDIF !(IOBSV_A.LT.NOBSV)

      IF (IOBSVZ_A.NE.NOBSVZ) THEN
        IF (IOBSVZ_A.NE.0) DEALLOCATE(OBSVZ)
        ALLOCATE(OBSVZ(NOBSVZ))
        IOBSVZ_A=NOBSVZ
      ENDIF !(IOBSVY_A.LT.NOBSVY)

      IF (IOBSVY_A.NE.NOBSVY) THEN
        IF (IOBSVY_A.NE.0) DEALLOCATE(OBSVY)
        ALLOCATE(OBSVY(NOBSVY))
        IOBSVY_A=NOBSVY
      ENDIF !(IOBSV_A.LT.NOBSV)

      OBSV(1,1)=OBSVDUM(1,1)
      OBSV(2,1)=OBSVDUM(2,1)
      OBSV(3,1)=OBSVDUM(3,1)

      IOB=0
      DO IY=1,NOBSVY
        DO IZ=1,NOBSVZ
          IOB=IOB+1
          OBSV(3,IOB)=OBSV(3,1)+OBSVDZ*(IZ-1)
          OBSV(2,IOB)=OBSV(2,1)+OBSVDY*(IY-1)
          OBSV(1,IOB)=OBSV(1,1)
        ENDDO
      ENDDO

      DO IZ=1,NOBSVZ
        OBSVZ(IZ)=OBSV(3,IZ)
      ENDDO

      DO IY=1,NOBSVY
        IOB=(IY-1)*NOBSVZ+1
        OBSVY(IY)=OBSV(2,IOB)
      ENDDO

      IF (IPIN.EQ.0) THEN
        ICBRILL=1
      ELSE !PIN
        IF (IPBRILL.EQ.0) THEN
          ICDUMZ=NOBSVZ/2+1
          ICDUMY=NOBSVY/2+1
          ICBRILL=ICDUMZ+NOBSVZ*(ICDUMY-1)
        ELSE IF (IPBRILL.EQ.1) THEN
          ICDUMZ=(NOBSVZ-MOBSVZ)/2+1
          ICDUMY=(NOBSVY-MOBSVY)/2+1
          ICBRILL=ICDUMZ+NOBSVZ*(ICDUMY-1)
        ELSE IF (IPBRILL.EQ.2) THEN
          ICDUMZ=(NOBSVZ-MOBSVZ)/2+MOBSVZ
          ICDUMY=(NOBSVY-MOBSVY)/2+1
          ICBRILL=ICDUMZ+NOBSVZ*(ICDUMY-1)
        ELSE IF (IPBRILL.EQ.3) THEN
          ICDUMZ=(NOBSVZ-MOBSVZ)/2+1
          ICDUMY=(NOBSVY-MOBSVY)/2+MOBSVY
          ICBRILL=ICDUMZ+NOBSVZ*(ICDUMY-1)
        ELSE IF (IPBRILL.EQ.4) THEN
          ICDUMZ=(NOBSVZ-MOBSVZ)/2+MOBSVZ
          ICDUMY=(NOBSVY-MOBSVY)/2+MOBSVY
          ICBRILL=ICDUMZ+NOBSVZ*(ICDUMY-1)
        ELSE
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN PININ: IPBRILL WRONG ***'
          WRITE(LUNGFO,*)'*** CHECK NAMELIST PINHOLE ***'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED  ***'
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN PININ: IPBRILL WRONG ***'
          WRITE(6,*)'*** CHECK NAMELIST PINHOLE ***'
          WRITE(6,*)
          WRITE(6,*)'*** PROGRAM WAVE ABORTED  ***'
          STOP
        ENDIF
      ENDIF   !IPIN

      IF (MPINR.NE.0) IRPHI=1
      IF (IPINCIRC.NE.0.AND.IFPHIR_A.NE.NOBSV) THEN
        ALLOCATE(FPHIR(NOBSV))
        IF (IRPHI.NE.0) THEN
          ALLOCATE(XC(NOBSV))
          ALLOCATE(YC(NOBSV))
        ENDIF
        IFPHIR_A=NOBSV
      ENDIF !IPINCIRC

      IF (MPINR.NE.0.AND.IPIN.EQ.0) THEN
        MPINR=0
        WRITE(6,*)
        WRITE(6,*)
     &    '*** WARNING IN PININ: IPIN.EQ.0, THEREFORE MPINR SET ZERO ***'
        WRITE(6,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '*** WARNING IN PININ: IPIN.EQ.0, THEREFORE MPINR SET ZERO ***'
        WRITE(LUNGFO,*)
      ENDIF

      IF (MPINR.NE.0.AND.IF1DIM.NE.0) THEN
        MPINR=0
        WRITE(6,*)
        WRITE(6,*)
     &    '*** WARNING IN PININ: IF1DIM.NE.0, THEREFORE MPINR SET ZERO ***'
        WRITE(6,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '*** WARNING IN PININ: IF1DIM.EQ.0, THEREFORE MPINR SET ZERO ***'
        WRITE(LUNGFO,*)
      ENDIF

      IF (MPINR.NE.0) THEN
        CALL PININR
      ENDIF

      if (rpinsph.eq.-9999.0d0) rpinsph=pincen(1)

      if (rpinsph.ne.0) then
        r0=obsv(1,1)-rpinsph
        do iobsv=1,nobsv
          x=obsv(1,iobsv)-r0
          y=obsv(2,iobsv)
          z=obsv(3,iobsv)
          r=sqrt(x*x+y*y+z*z)
          xn=x/r
          yn=y/r
          zn=z/r
          obsv(1,iobsv)=r0+xn*rpinsph
          obsv(2,iobsv)=yn*rpinsph
          obsv(3,iobsv)=zn*rpinsph
        enddo
        if (mpinr.ne.0) then
          do iobsv=1,nobsvrphi
            x=obsvrphi(1,iobsv)-r0
            y=obsvrphi(2,iobsv)
            z=obsvrphi(3,iobsv)
            r=sqrt(x*x+y*y+z*z)
            xn=x/r
            yn=y/r
            zn=z/r
            obsvrphi(1,iobsv)=xn*rpinsph
            obsvrphi(2,iobsv)=yn*rpinsph
            obsvrphi(3,iobsv)=zn*rpinsph
          enddo
        endif

        DO iob=1,nobsv
          if (abs(obsv(2,iob)).lt.1.0d-12) obsv(2,iob)=0.0d0
          if (abs(obsv(3,iob)).lt.1.0d-12) obsv(3,iob)=0.0d0
        ENDDO

        DO IZ=1,NOBSVZ
          OBSVZ(IZ)=OBSV(3,IZ)
        ENDDO

        DO IY=1,NOBSVY
          IOB=(IY-1)*NOBSVZ+1
          OBSVY(IY)=OBSV(2,IOB)
        ENDDO

      endif

      RETURN
      END
+DECK,util_break.
*CMZ :  4.01/04 17/11/2023  11.59.33  by  Michael Scheer
*CMZ :  4.00/17 04/10/2022  08.10.22  by  Michael Scheer
*CMZ :  4.00/11 27/05/2021  09.41.25  by  Michael Scheer
*CMZ :  3.02/04 03/12/2014  15.11.16  by  Michael Scheer
*-- Author :    Michael Scheer   03/12/2014
      subroutine util_break
+seq,debugwave.
      return
      end
+DECK,argsum.
*CMZ :  4.01/04 14/11/2023  11.45.54  by  Michael Scheer
*CMZ :  4.01/03 02/06/2023  13.01.26  by  Michael Scheer
*CMZ :  4.00/14 11/02/2022  10.26.56  by  Michael Scheer
*CMZ :  3.05/01 08/05/2018  16.08.32  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.10  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  15.45.11  by  Michael Scheer
*CMZ :  2.69/02 07/11/2012  13.59.21  by  Michael Scheer
*CMZ :  2.68/05 28/09/2012  12.15.44  by  Michael Scheer
*CMZ :  2.67/00 13/02/2012  10.58.17  by  Michael Scheer
*CMZ :  2.65/03 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.64/04 14/09/2009  15.19.42  by  Michael Scheer
*CMZ :  2.64/03 21/08/2009  17.32.56  by  Michael Scheer
*CMZ :  2.64/02 21/08/2009  17.24.35  by  Michael Scheer
*CMZ :  2.64/01 20/08/2009  15.20.55  by  Michael Scheer
*CMZ :  2.63/05 03/08/2009  16.11.05  by  Michael Scheer
*CMZ :  2.52/12 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.52/11 08/12/2004  13.37.55  by  Michael Scheer
*CMZ :  2.51/02 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.50/00 29/04/2004  15.29.30  by  Michael Scheer
*CMZ :  2.20/01 24/11/2000  21.15.06  by  Michael Scheer
*CMZ :  2.16/08 31/10/2000  14.40.08  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  17.26.23  by  Michael Scheer
*CMZ :  2.13/07 17/02/2000  15.11.12  by  Michael Scheer
*CMZ :  2.13/04 21/01/2000  11.57.55  by  Michael Scheer
*CMZ :  2.13/03 17/01/2000  17.27.08  by  Michael Scheer
*CMZ :  2.12/02 15/06/99  15.16.33  by  Michael Scheer
*CMZ :  2.12/00 27/05/99  10.08.55  by  Michael Scheer
*CMZ :  2.11/01 19/05/99  14.09.50  by  Michael Scheer
*CMZ :  2.10/01 19/03/99  14.13.05  by  Michael Scheer
*CMZ :  2.00/00 06/01/99  11.12.16  by  Michael Scheer
*CMZ : 00.01/02 24/11/94  15.25.26  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.46.43  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.46  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE ARGSUM(ISOUR,IOBSV,IBUFF)

+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,REARGF90U.
+SEQ,OBSERVF90U.
+SEQ,AFREQF90U.
+SEQ,AMPLIF90U.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,PHYCON.
+seq,sourcef90.
+SEQ,SPECT.
+SEQ,FREQS.
+SEQ,AMPLI.
+SEq,observf90.
+SEQ,MYFILES.

      INTEGER ISOUR,IOBSV,IFREQ,IPOI,ICOMP,IST,ICAL,JOBSV,IBUFF

      INTEGER NTUPP
      PARAMETER (NTUPP=22)
      REAL*8 FILLT(NTUPP)

      COMPLEX*16 APOL,EXPOM,DEXPOM,ZIOM,AX0,AY0,AZ0,AX,AY,AZ,ZI,ZONE,
     &  DMODU,DMODU0,DDMODU,daff(3),baff(3),bx0,by0,bz0,bx,by,bz
      COMPLEX*8 APOLH,APOLR,APOLL,APOL45

      DOUBLE PRECISION OM,DOM,DT,DT2,T,rnx,rny,rnz,rn
      DOUBLE PRECISION :: RSPECNOR=1.0d0 !11.2.2022

      DOUBLE PRECISION RARG(8),
     &  DXEXI,CENXEXI,DTPHASE,FREQR,GAMMA21,GAMGAM,R0,R02,H2,R00,H2R2,
     &  PHI,CORRR0,GAMGAM0,AMPDT,R2,POW

      REAL*4 STOK1,STOK2,STOK3,STOK4

      INTEGER I

      DATA ICAL/0/

      DATA ZI/(0.0D0,1.0D0)/
      DATA ZONE/(1.0D0,0.0D0)/

      save

      IF (ICAL.EQ.0) THEN

        print*,"*** Warning in ARGSUM: Ntuple of source not uptodate, use OMP version or ISPECMODE=2"
c11.2.2022        RSPECNOR=DSQRT(SPECNOR) to be consistent with hfreq and souintana

        DO IFREQ=1,NFREQ
          DO JOBSV=1,NOBSV

            IOBFR=JOBSV+NOBSV*(IFREQ-1)

            REAIMA=0.0d0

            IF (ISTOKES.NE.0) THEN
              DO IST=1,4  !LOOP OVER COMPONENTS OF STOKES VECTOR
                STOKES(IST,IOBFR)=0.0
              ENDDO   !IST
            ENDIF

          ENDDO   !JOBSV
        ENDDO   !IFREQ

        ICAL=1

      ENDIF   !ICAL

C--- PERFORMS INTEGRATION FOR ALL FREQUENCES

C    ASSUMES FREQ(I+1)=FREQ(I)*2   FOR IFREQ2P=2
C    OR FREQ(I+1)=FREQ(I)+DELTA    FOR IFREQ2P>2

      IF (ISOUR.NE.ISOURO) THEN

        DO IFREQ=1,NFREQ
          IFROB=IFREQ+NFREQ*(IOBSV-1)
          AFREQ(1:6,IFROB)=(0.0d0,0.0d0)
        ENDDO

        SPECPOW(ISOUR+NSOURCE*(IOBSV-1))=0.D0

      ENDIF !ISOUR

      DOM=(FREQ(2)-FREQ(1))/HBAREV1

C-- LOOP OVER TIME STEPS (ACTUAL INTEGRATION)

      IF (IBUFF.EQ.1) THEN
        T=-REARGUM(6,1)
      ENDIF

      DO IPOI=1,IARGUM

        DT=REARGUM(6,IPOI)
        DT2=DT*0.5D0

        T=T+DT

        RARG(1)=REARGUM(1,IPOI)*DT
        RARG(2)=REARGUM(2,IPOI)*DT
        RARG(3)=REARGUM(3,IPOI)*DT

        RARG(4)=REARGUM(4,IPOI)
        RARG(5)=REARGUM(5,IPOI)*DT

        RARG(6:8)=REARGUM(9:11,IPOI)

        rn=norm2(rarg(6:8))
        rnx=rarg(6)/rn
        rny=rarg(7)/rn
        rnz=rarg(8)/rn

        OM=FREQ(1)/HBAREV1
        IF (IVELOFIELD.EQ.2) THEN
          ZIOM=DCMPLX(0.0D0,OM)
        ELSE
          ZIOM=DCMPLX(1.0D0,0.0D0)
        ENDIF

        EXPOM=CDEXP(DCMPLX(0.D0,RARG(4)*OM))

        IF(IFREQ2P.GT.2) DEXPOM=CDEXP(DCMPLX(0.D0,RARG(4)*DOM))

        IFROB=1+NFREQ*(IOBSV-1)
        DO ICOMP=1,3
          daff(icomp)=ZIOM*DCMPLX(RARG(ICOMP))*EXPOM*REFLEC(ICOMP)
          AFREQ(ICOMP,IFROB)=AFREQ(ICOMP,IFROB)+daff(icomp)
        ENDDO

c        baff(1)=conjg(rny*daff(3)-rnz*daff(2))
c        baff(2)=conjg(rnz*daff(1)-rnx*daff(3))
c        baff(3)=conjg(rnx*daff(2)-rny*daff(1))

        baff(1)=(rny*daff(3)-rnz*daff(2))
        baff(2)=(rnz*daff(1)-rnx*daff(3))
        baff(3)=(rnx*daff(2)-rny*daff(1))

        afreq(4:6,IFROB)=afreq(4:6,IFROB)+baff(1:3)/clight1

C--- LOOP OVER ALL FREQUENCES

        DO IFREQ=2,NFREQ

            OM=FREQ(IFREQ)/HBAREV1
            IF (IVELOFIELD.EQ.2) THEN
              ZIOM=DCMPLX(0.0D0,OM)
            ELSE
              ZIOM=DCMPLX(1.0D0,0.0D0)
            ENDIF

            IF    (IFREQ2P.LT.2) THEN
              EXPOM=CDEXP(DCMPLX(0.D0,RARG(4)*OM))
            ELSE IF(IFREQ2P.EQ.2) THEN
              EXPOM=EXPOM*EXPOM
            ELSE
              EXPOM=EXPOM*DEXPOM
            ENDIF

            IFROB=IFREQ+NFREQ*(IOBSV-1)
            DO ICOMP=1,3
              daff(icomp)=ZIOM*DCMPLX(RARG(ICOMP))*EXPOM
     &          *REFLEC(ICOMP)
              AFREQ(ICOMP,IFROB)=AFREQ(ICOMP,IFROB)+daff(icomp)
            ENDDO

c            baff(1)=conjg(rny*daff(3)-rnz*daff(2))
c            baff(2)=conjg(rnz*daff(1)-rnx*daff(3))
c            baff(3)=conjg(rnx*daff(2)-rny*daff(1))

            baff(1)=(rny*daff(3)-rnz*daff(2))
            baff(2)=(rnz*daff(1)-rnx*daff(3))
            baff(3)=(rnx*daff(2)-rny*daff(1))

            afreq(4:6,IFROB)=afreq(4:6,IFROB)+baff(1:3)/clight1

          ENDDO   !LOOP OVER ALL FREQUENCES

        ILIOB=ISOUR+NSOURCE*(IOBSV-1)
        SPECPOW(ILIOB)=SPECPOW(ILIOB)+RARG(5)

        IF(IWFILINT.EQ.-ISOUR.AND.IOBSV.EQ.1) THEN

          IFREQ=1
          IOBSV=1

          FILLT(1)=T
          FILLT(2)=WSOU(1,1,IPOI)
          FILLT(3)=WSOU(2,1,IPOI)
          FILLT(4)=WSOU(3,1,IPOI)
          FILLT(5)=RARG(1)
          FILLT(6)=RARG(2)
          FILLT(7)=RARG(3)
          FILLT(8)=RARG(4)
          FILLT(9)=MIN(RARG(5),1.D30)
          FILLT(10)=DREAL(EXPOM)
          FILLT(11)=DIMAG(EXPOM)
          FILLT(12)=0.0d0
          FILLT(13)=IOBSV
          FILLT(14)=IFREQ
          IF (NOBSV.EQ.1) THEN
            FILLT(15)=OBS1Y
            FILLT(16)=OBS1Z
          ELSE
            FILLT(15)=OBSV(2,IOBSV)
            FILLT(16)=OBSV(3,IOBSV)
          ENDIF
          FILLT(17)=0.0d0
          FILLT(18)=0.0d0
          FILLT(19)=0.0d0
          FILLT(20)=0.0d0
          IFROB=IFREQ+NFREQ*(IOBSV-1)
          FILLT(21)=
     &      DREAL(
     &      AFREQ(1,IFROB)*CONJG(AFREQ(1,IFROB))
     &      +AFREQ(2,IFROB)*CONJG(AFREQ(2,IFROB))
     &      +AFREQ(3,IFROB)*CONJG(AFREQ(3,IFROB))
     &      )*SPECNOR
          FILLT(22)=0.0d0

          CALL hfm(NIDSOURCE,FILLT)

        ENDIF !IWFILINT.EQ.-ISOUR

      ENDDO   !LOOP OVER TIME STEPS

      IF (NSADD.NE.0) THEN

        IF (IAMPLI.LT.0) THEN

          GAMGAM0=SOURCEG(1,1,ISOUR)**2
          GAMGAM=(SOURCEG(1,1,ISOUR)+SOURCEG(2,2,ISOUR))**2
          GAMMA21=1.0D0/GAMGAM0
          DXEXI=MIN(SOURCEEO(1,1,ISOUR),XIEND)
     &      -MAX(SOURCEAO(1,1,ISOUR),XIANF)
          CENXEXI=(MIN(SOURCEEO(1,1,ISOUR),XIEND)
     &      +MAX(SOURCEAO(1,1,ISOUR),XIANF))/2.D0
          DTPHASE=(WTRA2IS(ISOUR)+GAMMA21*DXEXI/2.D0)/CLIGHT1
     &    *GAMGAM0/GAMGAM
          AMPDT=AMPSHIFT(1)/CLIGHT1/2.0D0/GAMGAM0
          DTPHASE=DTPHASE+AMPDT
          FREQR=2.D0*PI1/DTPHASE*HBAREV1
          POW=SPECPOW(ILIOB)
          SPECPOW(ILIOB)=0.0D0

          DO I=1,-IAMPLI
            R02=(OBSV(1,IOBSV)-CENXEXI)**2+OBSV(2,IOBSV)**2+OBSV(3,IOBSV)**2
            R2=(OBSV(1,IOBSV)-CENXEXI-DXEXI*(I-ABS(IAMPLI)/2+1))**2
     &        +OBSV(2,IOBSV)**2+OBSV(3,IOBSV)**2
            SPECPOW(ILIOB)=SPECPOW(ILIOB)+POW*R02/R2
          ENDDO

          DO IFREQ=1,NFREQ

            ILIOBFR=ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1))
            IFROB=IFREQ+NFREQ*(IOBSV-1)
            IOBFR=IOBSV+NOBSV*(IFREQ-1)

            OM=FREQ(IFREQ)/HBAREV1

            AX0=AFREQ(1,IFROB)
            AY0=AFREQ(2,IFROB)
            AZ0=AFREQ(3,IFROB)

            AX=AX0
            AY=AY0
            AZ=AZ0

            BX0=AFREQ(4,IFROB)
            BY0=AFREQ(5,IFROB)
            BZ0=AFREQ(6,IFROB)

            BX=AX0
            BY=AY0
            BZ=AZ0

            AFREQ(1:6,IFROB)=(0.0D0,0.0D0)

            R0=OBSV(1,NOBSV/2+1)-CENXEXI
            R02=R0*R0
            R00=R0
            H2=(OBSV(2,IOBSV))**2+(OBSV(3,IOBSV))**2
            H2R2=H2/R02

            DTPHASE=(WTRA2IS(ISOUR)+(H2R2+GAMMA21)*DXEXI/2.D0)/CLIGHT1
     &        *GAMGAM0/GAMGAM
     &        +AMPDT
            PHI=2.D0*PI1*FREQ(IFREQ)*ECHARGE1/HPLANCK1*DTPHASE

            DMODU=EXP(ZI*PHI)
            DMODU0=DMODU
            DDMODU=ZONE

            DO I=1,-IAMPLI

              R0=OBSV(1,NOBSV/2+1)+DXEXI/2.D0*(-IAMPLI-2*(I-1)-1)
              CORRR0=R00/R0
              R02=R0*R0
              H2=(OBSV(2,IOBSV))**2+(OBSV(3,IOBSV))**2
              H2R2=H2/R02

              GAMGAM=(SOURCEG(1,1,ISOUR)+(I-1)*SOURCEG(2,2,ISOUR))**2
              DTPHASE=(WTRA2IS(ISOUR)+(H2R2+GAMMA21)*DXEXI/2.D0)/CLIGHT1
     &          *GAMGAM0/GAMGAM+AMPDT
              PHI=2.D0*PI1*FREQ(IFREQ)*ECHARGE1/HPLANCK1*DTPHASE

              DMODU=EXP(ZI*PHI)
              DMODU0=DMODU
              DDMODU=ZONE

              AFREQ(1,IFROB)=AFREQ(1,IFROB)+AX
              AFREQ(2,IFROB)=AFREQ(2,IFROB)+AY
              AFREQ(3,IFROB)=AFREQ(3,IFROB)+AZ
              AFREQ(4,IFROB)=AFREQ(4,IFROB)+BX
              AFREQ(5,IFROB)=AFREQ(5,IFROB)+BY
              AFREQ(6,IFROB)=AFREQ(6,IFROB)+BZ

              IF (AMPRAN.NE.0.D0) THEN
                PHI=2.D0*PI1*XRANA(I)/FREQR*FREQ(IFREQ)
                DDMODU=EXP(ZI*PHI)
              ENDIF   !(AMPRAN.NE.0.D0)

              AX0=AX0*DMODU0
              AY0=AY0*DMODU0
              AZ0=AZ0*DMODU0

              AX=AX0*CORRR0
              AY=AY0*CORRR0
              AZ=AZ0*CORRR0

              DMODU=DMODU0*DDMODU
              AX=AX*DMODU
              AY=AY*DMODU
              AZ=AZ*DMODU

              BX0=BX0*DMODU0
              BY0=BY0*DMODU0
              BZ0=BZ0*DMODU0

              BX=BX0*CORRR0
              BY=BY0*CORRR0
              BZ=BZ0*CORRR0

              BX=BX*DMODU
              BY=BY*DMODU
              BZ=BZ*DMODU

            ENDDO !IAMPLI

          ENDDO !IFREQ

        ENDIF  !(IAMPLI.LT.0)

        DO IFREQ=1,NFREQ

          ILIOBFR=ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1))
          IOBFR=IOBSV+NOBSV*(IFREQ-1)
          IFROB=IFREQ+NFREQ*(IOBSV-1)

          IF (IPOLA.EQ.0) THEN

            SPEC(ILIOBFR)=
     &        DREAL(
     &        AFREQ(1,IFROB)*CONJG(AFREQ(1,IFROB))
     &        +AFREQ(2,IFROB)*CONJG(AFREQ(2,IFROB))
     &        +AFREQ(3,IFROB)*CONJG(AFREQ(3,IFROB))
     &        )*SPECNOR

            REAIMA(1:3,1,IOBFR)=REAIMA(1:3,1,IOBFR)+
     &        DREAL(AFREQ(1:3,IFROB))*rspecnor
            REAIMA(1:3,2,IOBFR)=REAIMA(1:3,2,IOBFR)+
     &        DIMAG(AFREQ(1:3,IFROB))*rspecnor
            REAIMA(6:8,1,IOBFR)=REAIMA(6:8,1,IOBFR)+
     &        DREAL(AFREQ(1:3,IFROB))*rspecnor
            REAIMA(6:8,2,IOBFR)=REAIMA(6:8,2,IOBFR)+
     &        DIMAG(AFREQ(1:3,IFROB))*rspecnor

          ELSE    !IPOLA

            APOL=
     &        AFREQ(1,IFROB)*CONJG(VPOLA(1))
     &        +AFREQ(2,IFROB)*CONJG(VPOLA(2))
     &        +AFREQ(3,IFROB)*CONJG(VPOLA(3))

            SPEC(ILIOBFR)=
     &        DREAL(APOL*CONJG(APOL))*SPECNOR

            REAIMA(1:3,1,IOBFR)=REAIMA(1:3,1,IOBFR)+
     &        DREAL(AFREQ(1:3,IFROB))*rspecnor
            REAIMA(1:3,2,IOBFR)=REAIMA(1:3,2,IOBFR)+
     &        DIMAG(AFREQ(1:3,IFROB))*rspecnor
            REAIMA(6:8,1,IOBFR)=REAIMA(6:8,1,IOBFR)+
     &        DREAL(AFREQ(1:3,IFROB))*rspecnor
            REAIMA(6:8,2,IOBFR)=REAIMA(6:8,2,IOBFR)+
     &        DIMAG(AFREQ(1:3,IFROB))*rspecnor

          ENDIF   !IPOLA

          IOBFR=IOBSV+NOBSV*(IFREQ-1)
          IFROB=IFREQ+NFREQ*(IOBSV-1)

          IF (ISTOKES.NE.0) THEN

            APOLH=
     &        AFREQ(1,IFROB)*CONJG(VSTOKES(1,1))
     &        +AFREQ(2,IFROB)*CONJG(VSTOKES(1,2))
     &        +AFREQ(3,IFROB)*CONJG(VSTOKES(1,3))

            APOLR=
     &        AFREQ(1,IFROB)*CONJG(VSTOKES(2,1))
     &        +AFREQ(2,IFROB)*CONJG(VSTOKES(2,2))
     &        +AFREQ(3,IFROB)*CONJG(VSTOKES(2,3))

            APOLL=
     &        AFREQ(1,IFROB)*CONJG(VSTOKES(3,1))
     &        +AFREQ(2,IFROB)*CONJG(VSTOKES(3,2))
     &        +AFREQ(3,IFROB)*CONJG(VSTOKES(3,3))

            APOL45=
     &        AFREQ(1,IFROB)*CONJG(VSTOKES(4,1))
     &        +AFREQ(2,IFROB)*CONJG(VSTOKES(4,2))
     &        +AFREQ(3,IFROB)*CONJG(VSTOKES(4,3))

            STOK1=
     &        REAL(APOLR*CONJG(APOLR))+
     &        REAL(APOLL*CONJG(APOLL))

            STOK2=-STOK1+
     &        2.*REAL(APOLH*CONJG(APOLH))

            STOK3=
     &        2.*REAL(APOL45*CONJG(APOL45))-
     &        STOK1

            STOK4=
     &        REAL(APOLR*CONJG(APOLR))-
     &        REAL(APOLL*CONJG(APOLL))


            STOKES(1,IOBFR)=STOKES(1,IOBFR)+
     &        STOK1*SPECNOR

            STOKES(2,IOBFR)=STOKES(2,IOBFR)+
     &        STOK2*SPECNOR

            STOKES(3,IOBFR)=STOKES(3,IOBFR)+
     &        STOK3*SPECNOR

            STOKES(4,IOBFR)=STOKES(4,IOBFR)+
     &        STOK4*SPECNOR
          ENDIF

        ENDDO !IFREQ

        ILIOB=ISOUR+NSOURCE*(IOBSV-1)
        SPECPOW(ILIOB)=SPECPOW(ILIOB)*pownor

      ENDIF !NSADD

      RETURN
      END
+DECK,CYLTOCARTB,T=F77.
*CMZ :  4.01/04 15/11/2023  12.38.14  by  Michael Scheer
*CMZ :  4.01/03 14/06/2023  09.25.01  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.66/02 26/10/2009  14.33.39  by  Michael Scheer
*CMZ :  2.65/01 08/10/2009  09.58.11  by  Michael Scheer
*CMZ :  2.65/00 18/09/2009  08.30.19  by  Michael Scheer
*CMZ :  2.64/06 15/09/2009  09.52.14  by  Michael Scheer
*CMZ :  2.64/05 14/09/2009  10.06.11  by  Michael Scheer
*-- Author :    Michael Scheer   01/09/2009
      subroutine cyltocartb(isour)
+seq,gplhint.

+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,AFREQF90U.
+SEQ,SPECTF90U.
+SEQ,WFOLDF90U.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEq,observf90.
+SEQ,DEPOLA.
+SEq,wfoldf90.
+seq,sourcef90.
+SEQ,FREQS.
+SEQ,PHYCON.
+SEQ,SPECTF90.

c
c Alte Version 154 wieder  hervorgeholt, da sie besser mit MPINR=0 uebereinstimmt.
c
c

c fill AFREQ(5:6) by interpolating AFREQRPHI

      double precision, dimension(:,:,:), allocatable :: fr,coefr
      double precision, dimension(:,:), allocatable :: phas
      double precision, dimension(:), allocatable :: w1,w2,w3,w4,
     &  fp,coefp,obsvedge,frw

      double complex af2,af3
c     &  ,expom

      double precision y,z,r,phi,pihalf,phiedge,yp12,
     &  phiy,phiz,phiy1,phiz1,
     &  dist0,dist02,ddist,h2,cenxexi,dvlen,
     &  dphase,dphi,pi2phaser2,pi2phaser3,pi2phasephi2,pi2phasephi3,
     &  af2r,af2i,af3r,af3i,
     &  af2ro,af2io,af3ro,af3io

      integer ixy,iphi,ir,ifreq,iphas,iobrp,istat,medge,
     &  ifirst,ilast,iedge,isour,jphi,nphi,ical

      data ical/0/

      if (ical.eq.0) then

        print*,''
        print*,'*** Warning in cyltocartb: Calculation of magnetic components of radiation field not yet tested ***'
        print*,''

        medge=3
        yp12=9999.0d0

        allocate(phas(4,nobsv))

        allocate(frw(nobsvr))
        allocate(fr(nobsvr,4,nobsvphi))
        allocate(coefr(nobsvr,4,nobsvphi))

        allocate(fp(nobsvphi+2*medge+1))
        allocate(obsvedge(nobsvphi+2*medge+1))
        allocate(coefp(nobsvphi+2*medge+1))

        allocate(w1(max(nobsvr,nobsvphi+2*medge+1)))
        allocate(w2(max(nobsvr,nobsvphi+2*medge+1)))
        allocate(w3(max(nobsvr,nobsvphi+2*medge+1)))
        allocate(w4(max(nobsvr,nobsvphi+2*medge+1)))

        pihalf=pi1/2.0d0

        ifirst=medge+1

        if (iquadphi.eq.0) then
          ilast=ifirst+nobsvphi
          obsvedge(ilast)=obsvphi(nobsvphi)+obsvdphi
        else
          ilast=ifirst+nobsvphi-1
        endif

        do iphi=1,nobsvphi
          obsvedge(ifirst+iphi-1)=obsvphi(iphi)
        enddo

        do iedge=1,medge
          obsvedge(ilast+iedge)=obsvedge(ilast+iedge-1)+obsvdphi
        enddo

        do iedge=1,medge
          obsvedge(ifirst-iedge)=obsvedge(ifirst-iedge+1)-obsvdphi
        enddo

        ical=1

      endif

        cenxexi=(min(sourceeo(1,1,isour),xiend)
     &    +max(sourceao(1,1,isour),xianf))/2.d0
        dvlen=
     &    min(sourceeo(1,1,isour),xiend)-
     &    max(sourceao(1,1,isour),xianf)
        if (iampli.lt.0) then
          dvlen=dvlen*(-iampli)
        endif
        dist0=pincen(1)-cenxexi
        dist02=dist0**2

      do ifreq=1,nfreq

        iobrp=0
        ixy=1

        pi2phasephi2=0.0d0
        pi2phasephi3=0.0d0
        do iphi=1,nobsvphi

          phiy1=-twopi1
          phiz1=-twopi1

          pi2phaser2=0.0d0
          pi2phaser3=0.0d0
          do ir=1,nobsvr

            iobrp=iobrp+1
            ifrob=ifreq+nfreq*(iobrp-1)

            h2=(obsvr(ir)/dist0)**2
            if (h2.lt.0.01) then
              ddist=dist0*(h2/2.0d0-h2**2/8.0d0)
            else
              ddist=dist0*(sqrt(1.0d0+h2)-1.0d0)
            endif

            dphase=ddist/freq(ifreq)*wtoe1*1.0d9*twopi1

            af2=afreqrphi(5,IFROB)
            af3=afreqrphi(6,IFROB)
            af2r=dreal(af2)
            af2i=dimag(af2)
            af3r=dreal(af3)
            af3i=dimag(af3)

            phiy=atan2(af2i,af2r)
            phiz=atan2(af3i,af3r)

            fr(ir,1,iphi)=abs(af2)
            fr(ir,2,iphi)=phiy-dphase
            fr(ir,3,iphi)=abs(af3)
            fr(ir,4,iphi)=phiz-dphase

c            print*,ir,iphi,phiz+dphase,phiz-dphase

            phiy1=phiy
            phiz1=phiz
            af2ro=af2r
            af2io=af2i
            af3ro=af3r
            af3io=af3i

          enddo !nobsvr

          do iphas=2,4,2
            frw(1)=fr(1,iphas,iphi)
            do ir=2,nobsvr
              frw(ir)=fr(ir,iphas,iphi)
              phiy1=frw(ir-1)
              phiy=frw(ir)
              dphi=phiy-phiy1

              if (dphi.gt.pi1) then
                dphi=dphi-twopi1
              else if (dphi.lt.-pi1) then
                dphi=dphi+twopi1
              endif
              fr(ir,iphas,iphi)=fr(ir-1,iphas,iphi)+dphi

            enddo
          enddo

          do iphas=1,4
            call util_spline_coef(obsvr,
     &        fr(1,iphas,iphi),nobsvr,yp12,yp12,coefr(1,iphas,iphi),
     &        w1,w2,w3,w4)
          enddo

        enddo !nobsvphi

        do iphas=1,4

          do ixy=1,nobsv

            y=obsv(2,ixy)
            z=obsv(3,ixy)
            r=sqrt(y**2+z**2)

            if (iquadphi.eq.0) then
              phi=atan2(y,z)
            else
              if (z.ne.0.0d0) then
                phi=atan(y/z)
              else
                phi=pi1/2.0d0
              endif
              phi=abs(phi)
            endif

            if (phi.lt.0.0d0) phi=phi+twopi1

            do iphi=1,nobsvphi

              call util_spline_inter_status(
     &          obsvr,fr(1,iphas,iphi),coefr(1,iphas,iphi),
     &          nobsvr,r,fp(iphi+medge),0,
     &          istat)

              if (istat.ne.0) then
                stop
     &            '*** Error: Bad return from util_spline_inter_status in CYLTOCART'
              endif

            enddo !iphi

            if (iquadphi.eq.0) then

              nphi=nobsvphi+1+2*medge
              ifirst=medge+1
              ilast=ifirst+nobsvphi

              fp(ilast)=fp(ifirst) !Periode vervollstaendigen

              do iedge=1,medge
                fp(ilast+iedge)=fp(ifirst+iedge)
              enddo

              do iedge=1,medge
                fp(ifirst-iedge)=fp(ilast-iedge)
              enddo

            else !if (iquadphi.eq.0)

              nphi=nobsvphi+2*medge
              ifirst=medge+1
              ilast=ifirst+nobsvphi-1

              do iedge=1,medge
                phiedge=mod(pihalf+iedge*obsvdphi,twopi1)
                if (phiedge.gt.3.0d0*pihalf) then
                  phiedge=twopi1-phiedge
                else if (phiedge.gt.pi1) then
                  phiedge=phiedge-pi1
                else if (phiedge.gt.pihalf) then
                  phiedge=pi1-phiedge
                endif
                jphi=ifirst+nint(phiedge/obsvdphi)
                fp(ilast+iedge)=fp(jphi)
              enddo

              do iedge=1,medge
                phiedge=mod(iedge*obsvdphi,twopi1)
                if (phiedge.gt.3.0d0*pihalf) then
                  phiedge=twopi1-phiedge
                else if (phiedge.gt.pi1) then
                  phiedge=phiedge-pi1
                else if (phiedge.gt.pihalf) then
                  phiedge=pi1-phiedge
                endif
                jphi=ifirst+nint(phiedge/obsvdphi)
                fp(ifirst-iedge)=fp(jphi)
              enddo

            endif !iquadphi

            call util_spline_coef(obsvedge,fp,nphi,
     &        yp12,yp12,coefp,
     &        w1,w2,w3,w4)

            call util_spline_inter_status(
     &        obsvedge,fp,coefp,nphi,phi,phas(iphas,ixy),0,istat)

            if (iphas.eq.4) then

              h2=(r/dist0)**2

              if (h2.lt.0.01) then
                ddist=dist0*(h2/2.0d0-h2**2/8.0d0)
              else
                ddist=dist0*(sqrt(1.0d0+h2)-1.0d0)
              endif

              dphase=ddist/freq(ifreq)*wtoe1*1.0d9*twopi1

              afreq(5,ifreq+nfreq*(ixy-1))=
     &          phas(1,ixy)*
     &          cmplx(cos(phas(2,ixy)+dphase),sin(phas(2,ixy)+dphase))

              afreq(6,ifreq+nfreq*(ixy-1))=
     &          phas(3,ixy)*
     &          cmplx(cos(phas(4,ixy)+dphase),sin(phas(4,ixy)+dphase))

            endif

            if (istat.ne.0) then
              stop
     &          '*** Error: Bad return from util_spline_inter_status in CYLTOCART'
            endif

          enddo !ixy

        enddo !iphas

      enddo !ifreq

      if (isour.eq.nsource) then
        deallocate(phas)
        deallocate(fr)
        deallocate(fp)
        deallocate(obsvedge)
        deallocate(coefr)
        deallocate(coefp)

        deallocate(w1)
        deallocate(w2)
        deallocate(w3)
        deallocate(w4)
      endif

      return
      end
+DECK,UOUT_PHOTON.
*CMZ :  4.01/04 17/10/2023  13.35.53  by  Michael Scheer
*CMZ :  2.15/00 15/03/2007  11.13.54  by  Michael Scheer
*CMZ : 00.02/05 19/03/97  14.10.43  by  Michael Scheer
*CMZ : 00.02/04 26/02/97  10.23.26  by  Michael Scheer
*-- Author :    Michael Scheer   25/02/97

      SUBROUTINE UOUT_photon

+seq,spectf90u.

C     INTERFACE FUER PHOTON
C     USER(1) MUSS KRITISCHE ENERGIE ENTHALTEN

C     EIGENTLICH IST DIE KRITISCHE ENERGIE UND GAMMA UNWICHTIG,
C     ABER VORERST FUER CHECKS MITAUSGEBEN.
C     PINCEN(2) MUSS NULL SEIN (FAKTOR 2)
C
C     AUSGEBEN WIRD dFLUX/dTHETA[mrad]

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,SPECT.
+SEQ,OBSERV.
+SEQ,FREQS.
+SEQ,USERVAR.


      INTEGER IFREQ
      DOUBLE PRECISION EGAMMA,PHOTONS

      WRITE(6,*)
      WRITE(6,*)'SUBROUTINE UOUT_PHOTON:'
      WRITE(6,*)'======================='
      WRITE(6,*)
      WRITE(6,*)'Writing file WAVE.PHOTON for program PHOTON'
      WRITE(6,*)'Ecrit:',ecphoton
      WRITE(6,*)


      IF (IPIN.NE.1) STOP '*** ERROR IN UOUT_PHOTON: IPIN.NE.1'
      IF (IF1DIM.NE.1) STOP '*** ERROR IN UOUT_PHOTON: IF1DIM.NE.1'
      IF (PINCEN(2).NE.0.0)STOP
     &  '*** ERROR IN UOUT_PHOTON: PINCEN(2).NE.0.0'

      OPEN(UNIT=99,FILE='WAVE.PHOTON',STATUS='NEW')

      WRITE(99,*)'WAVE.PHOTON'
      WRITE(99,*)ICODE,' ',CODE
      WRITE(99,*)ECPHOTON,DMYGAMMA
      WRITE(99,*)PINW,PINH
      WRITE(99,*)OBSVDZ,OBSVDY
      WRITE(99,*)PINCEN
      WRITE(99,*)NFREQ

      DO IFREQ=1,NFREQ
        EGAMMA=FREQ(IFREQ)/ECPHOTON
        PHOTONS=WFLUXT(IFREQ)
     &    /1.327D13 ! 1.327e13 * Ebeam**2  * Icurr * H2(y) yields flux-dens.
     &    /BANWID*0.001D0
     &    *(PINCEN(1)/PINW/1000.0D0)
     &    /(DMYCUR*1000.0D0)
     &    /DMYENERGY**2
     &    /2.D0
        WRITE(99,*)EGAMMA,PHOTONS
      ENDDO

      CLOSE(99)

      RETURN
      END
+PATCH,INPUT,T=TEXT.
*CMZ :  2.70/12 01/03/2013  12.26.02  by  Michael Scheer
+DECK,wave,T=TEXT.
*CMZ :          28/12/2023  17.36.31  by  Michael Scheer
*CMZ :  4.01/04 23/11/2023  15.29.41  by  Michael Scheer
*CMZ :  4.01/03 03/06/2023  11.02.39  by  Michael Scheer
*CMZ :  4.01/03 30/05/2023  08.18.01  by  Michael Scheer
*CMZ :  4.01/02 12/05/2023  13.31.01  by  Michael Scheer
*CMZ :  4.01/01 15/03/2023  13.25.57  by  Michael Scheer
*CMZ :  4.01/00 14/03/2023  11.17.26  by  Michael Scheer
*CMZ :  4.00/17 05/12/2022  09.05.20  by  Michael Scheer
*CMZ :  4.00/16 29/09/2022  11.26.25  by  Michael Scheer
*CMZ :  4.00/15 07/07/2022  19.48.11  by  Michael Scheer
*CMZ :  4.00/14 11/02/2022  10.51.30  by  Michael Scheer
*CMZ :  4.00/13 20/12/2021  16.35.32  by  Michael Scheer
*CMZ :  4.00/12 29/07/2021  10.03.35  by  Michael Scheer
*CMZ :  4.00/11 26/07/2021  09.37.05  by  Michael Scheer
*CMZ :  4.00/10 25/09/2020  11.25.53  by  Michael Scheer
*CMZ :  4.00/09 15/08/2020  09.03.29  by  Michael Scheer
*CMZ :  4.00/08 07/08/2020  11.10.56  by  Michael Scheer
*CMZ :  4.00/07 06/08/2020  11.14.22  by  Michael Scheer
*CMZ :  4.00/06 02/01/2020  12.16.58  by  Michael Scheer
*CMZ :  4.00/05 30/11/2019  16.49.03  by  Michael Scheer
*CMZ :  4.00/04 28/11/2019  13.58.28  by  Michael Scheer
*CMZ :  4.00/03 09/05/2019  11.05.27  by  Michael Scheer
*CMZ :  4.00/02 13/04/2019  10.06.52  by  Michael Scheer
*CMZ :  4.00/01 12/04/2019  13.43.18  by  Michael Scheer
*CMZ :  4.00/00 04/04/2019  19.42.45  by  Michael Scheer
*CMZ :  3.08/01 04/04/2019  12.02.36  by  Michael Scheer
*CMZ :  3.08/00 29/03/2019  15.51.05  by  Michael Scheer
*CMZ :  3.07/01 29/03/2019  15.50.11  by  Michael Scheer
*CMZ :  3.07/00 18/03/2019  10.37.01  by  Michael Scheer
*CMZ :  3.06/00 28/02/2019  17.26.08  by  Michael Scheer
*CMZ :  3.05/28 07/01/2019  17.16.43  by  Michael Scheer
*CMZ :  3.05/27 12/12/2018  12.20.51  by  Michael Scheer
*CMZ :  3.05/26 09/12/2018  13.47.12  by  Michael Scheer
*CMZ :  3.05/25 06/12/2018  10.32.09  by  Michael Scheer
*CMZ :  3.05/22 08/11/2018  16.06.16  by  Michael Scheer
*CMZ :  3.05/21 07/11/2018  12.38.39  by  Michael Scheer
*CMZ :  3.05/20 01/11/2018  17.21.17  by  Michael Scheer
*CMZ :  3.05/19 18/10/2018  14.59.31  by  Michael Scheer
*CMZ :  3.05/18 17/10/2018  09.19.35  by  Michael Scheer
*CMZ :  3.05/17 11/10/2018  13.22.53  by  Michael Scheer
*CMZ :  3.05/16 10/10/2018  14.54.18  by  Michael Scheer
*CMZ :  3.05/15 08/10/2018  18.46.27  by  Michael Scheer
*CMZ :  3.05/14 01/10/2018  14.05.51  by  Michael Scheer
*CMZ :  3.05/13 24/09/2018  14.47.29  by  Michael Scheer
*CMZ :  3.05/12 29/08/2018  14.01.05  by  Michael Scheer
*CMZ :  3.05/11 16/08/2018  15.24.29  by  Michael Scheer
*CMZ :  3.05/10 14/08/2018  11.02.38  by  Michael Scheer
*CMZ :  3.05/09 08/08/2018  14.26.36  by  Michael Scheer
*CMZ :  3.05/08 26/07/2018  15.29.30  by  Michael Scheer
*CMZ :  3.05/07 21/07/2018  16.40.57  by  Michael Scheer
*CMZ :  3.05/06 19/07/2018  15.14.31  by  Michael Scheer
*CMZ :  3.05/05 13/07/2018  14.31.05  by  Michael Scheer
*CMZ :  3.05/04 09/07/2018  11.39.17  by  Michael Scheer
*CMZ :  3.05/03 22/05/2018  07.40.12  by  Michael Scheer
*CMZ :  3.05/02 16/05/2018  08.36.21  by  Michael Scheer
*CMZ :  3.05/01 09/05/2018  09.26.46  by  Michael Scheer
*CMZ :  3.05/00 02/05/2018  12.31.37  by  Michael Scheer
*CMZ :  3.04/01 03/04/2018  14.27.58  by  Michael Scheer
*CMZ :  3.04/00 01/03/2018  16.59.08  by  Michael Scheer
*CMZ :  3.03/04 02/01/2018  16.27.57  by  Michael Scheer
*CMZ :  3.03/03 11/07/2017  12.44.06  by  Michael Scheer
*CMZ :  3.03/02 28/06/2017  14.10.41  by  Michael Scheer
*CMZ :  3.03/01 13/11/2015  10.19.07  by  Michael Scheer
*CMZ :  3.03/00 30/09/2015  11.38.35  by  Michael Scheer
*CMZ :  3.02/09 09/07/2015  19.31.48  by  Michael Scheer
*CMZ :  3.02/08 25/06/2015  14.22.11  by  Michael Scheer
*CMZ :  3.02/07 24/06/2015  12.52.35  by  Michael Scheer
*CMZ :  3.02/06 18/06/2015  14.16.54  by  Michael Scheer
*CMZ :  3.02/05 13/04/2015  11.56.50  by  Michael Scheer
*CMZ :  3.02/04 18/03/2015  10.20.29  by  Michael Scheer
*CMZ :  3.02/03 10/11/2014  16.22.22  by  Michael Scheer
*CMZ :  3.02/02 22/10/2014  13.35.24  by  Michael Scheer
*CMZ :  3.02/01 16/10/2014  06.18.03  by  Michael Scheer
*CMZ :  3.02/00 09/10/2014  15.07.08  by  Michael Scheer
*CMZ :  3.01/10 19/08/2014  11.32.15  by  Michael Scheer
*CMZ :  3.01/09 12/08/2014  17.20.11  by  Michael Scheer
*CMZ :  3.01/08 12/08/2014  14.40.32  by  Michael Scheer
*CMZ :  3.01/07 23/06/2014  16.16.32  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  10.16.10  by  Michael Scheer
*CMZ :  3.01/05 13/06/2014  13.17.52  by  Michael Scheer
*CMZ :  3.01/04 11/06/2014  12.53.44  by  Michael Scheer
*CMZ :  3.01/03 20/03/2014  13.34.18  by  Michael Scheer
*CMZ :  3.01/02 27/02/2014  09.44.51  by  Michael Scheer
*CMZ :  3.01/01 31/07/2013  12.25.55  by  Michael Scheer
*CMZ :  3.01/00 18/07/2013  13.41.43  by  Michael Scheer
*CMZ :  3.00/02 10/04/2013  09.29.16  by  Michael Scheer
*CMZ :  3.00/01 03/04/2013  12.14.27  by  Michael Scheer
*CMZ :  3.00/00 14/03/2013  12.31.37  by  Michael Scheer
*CMZ :  2.70/12 05/03/2013  13.35.00  by  Michael Scheer
*CMZ :  2.70/11 22/02/2013  14.47.36  by  Michael Scheer
*CMZ :  2.70/10 16/01/2013  12.43.13  by  Michael Scheer
*CMZ :  2.70/09 15/01/2013  14.58.55  by  Michael Scheer
*CMZ :  2.70/08 14/01/2013  17.51.04  by  Michael Scheer
*CMZ :  2.70/07 14/01/2013  16.57.20  by  Michael Scheer
*CMZ :  2.70/06 14/01/2013  09.57.49  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  15.37.12  by  Michael Scheer
*CMZ :  2.70/04 21/12/2012  12.44.10  by  Michael Scheer
*CMZ :  2.70/03 17/12/2012  15.04.17  by  Michael Scheer
*CMZ :  2.70/02 14/12/2012  10.52.18  by  Michael Scheer
*CMZ :  2.70/01 12/12/2012  15.53.22  by  Michael Scheer
*CMZ :  2.70/00 11/12/2012  17.12.43  by  Michael Scheer
*CMZ :  2.69/02 08/11/2012  10.18.11  by  Michael Scheer
*CMZ :  2.69/01 31/10/2012  17.01.40  by  Michael Scheer
*CMZ :  2.69/00 30/10/2012  16.26.11  by  Michael Scheer
*CMZ :  2.68/05 19/10/2012  14.10.19  by  Unknown
*CMZ :  2.68/04 04/09/2012  11.30.28  by  Michael Scheer
*CMZ :  2.68/03 01/09/2012  16.18.06  by  Michael Scheer
*CMZ :  2.68/02 01/08/2012  15.11.21  by  Michael Scheer
*CMZ :  2.68/01 29/05/2012  17.05.29  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  16.50.47  by  Michael Scheer
*CMZ :  2.67/06 24/05/2012  14.37.42  by  Michael Scheer
*CMZ :  2.67/05 16/05/2012  14.35.26  by  Michael Scheer
*CMZ :  2.67/04 15/05/2012  13.09.01  by  Michael Scheer
*CMZ :  2.67/03 09/05/2012  16.33.50  by  Michael Scheer
*CMZ :  2.67/02 09/05/2012  12.07.48  by  Michael Scheer
*CMZ :  2.67/01 16/03/2012  09.16.38  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  16.26.39  by  Michael Scheer
*CMZ :  2.66/22 16/01/2012  12.51.43  by  Michael Scheer
*CMZ :  2.66/21 22/11/2011  13.55.13  by  Michael Scheer
*CMZ :  2.66/20 22/11/2011  10.47.23  by  Michael Scheer
*CMZ :  2.66/19 07/06/2011  14.54.51  by  Michael Scheer
*CMZ :  2.66/18 16/12/2010  12.54.13  by  Michael Scheer
*CMZ :  2.66/17 23/11/2010  10.02.57  by  Michael Scheer
*CMZ :  2.66/16 22/11/2010  14.03.46  by  Michael Scheer
*CMZ :  2.66/15 09/11/2010  16.18.47  by  Michael Scheer
*CMZ :  2.66/14 09/11/2010  15.40.53  by  Michael Scheer
*CMZ :  2.66/13 02/08/2010  09.16.07  by  Michael Scheer
*CMZ :  2.66/12 27/05/2010  02.40.34  by  Michael Scheer
*CMZ :  2.66/11 05/05/2010  08.25.21  by  Michael Scheer
*CMZ :  2.66/10 04/05/2010  12.42.43  by  Michael Scheer
*CMZ :  2.66/09 03/05/2010  16.12.46  by  Michael Scheer
*CMZ :  2.66/08 17/03/2010  14.45.31  by  Michael Scheer
*CMZ :  2.66/07 11/03/2010  15.51.53  by  Michael Scheer
*CMZ :  2.66/06 27/11/2009  16.14.35  by  Michael Scheer
*CMZ :  2.66/05 17/11/2009  16.10.27  by  Michael Scheer
*CMZ :  2.66/04 17/11/2009  10.13.31  by  Michael Scheer
*CMZ :  2.66/03 11/11/2009  16.17.07  by  Michael Scheer
*CMZ :  2.66/02 26/10/2009  14.31.17  by  Michael Scheer
*CMZ :  2.66/01 21/10/2009  09.36.01  by  Michael Scheer
*CMZ :  2.66/00 14/10/2009  11.57.40  by  Michael Scheer
*CMZ :  2.65/03 02/10/2009  13.18.17  by  Michael Scheer
*CMZ :  2.65/02 29/09/2009  12.22.11  by  Michael Scheer
*CMZ :  2.65/01 21/09/2009  14.35.53  by  Michael Scheer
*CMZ :  2.65/00 18/09/2009  09.46.03  by  Michael Scheer
*CMZ :  2.64/07 17/09/2009  16.27.57  by  Michael Scheer
*CMZ :  2.64/06 15/09/2009  15.16.47  by  Michael Scheer
*CMZ :  2.64/05 14/09/2009  11.36.35  by  Michael Scheer
*CMZ :  2.64/04 21/08/2009  17.39.56  by  Michael Scheer
*CMZ :  2.64/03 21/08/2009  17.33.23  by  Michael Scheer
*CMZ :  2.64/02 21/08/2009  17.28.01  by  Michael Scheer
*CMZ :  2.64/01 20/08/2009  15.48.22  by  Michael Scheer
*CMZ :  2.64/00 17/08/2009  09.32.31  by  Michael Scheer
*CMZ :  2.63/05 14/08/2009  13.06.55  by  Michael Scheer
*CMZ :  2.63/04 22/07/2009  07.41.07  by  Michael Scheer
*CMZ :  2.63/03 02/06/2009  16.24.57  by  Michael Scheer
*CMZ :  2.63/02 08/04/2008  12.20.17  by  Michael Scheer
*CMZ :  2.63/01 16/01/2008  13.14.20  by  Michael Scheer
*CMZ :  2.63/00 11/01/2008  16.42.22  by  Michael Scheer
*CMZ :  2.62/04 03/01/2008  17.15.40  by  Michael Scheer
*CMZ :  2.62/03 17/07/2007  16.15.27  by  Michael Scheer
*CMZ :  2.62/02 16/07/2007  11.27.56  by  Michael Scheer
*CMZ :  2.62/01 24/04/2007  12.00.23  by  Michael Scheer
*CMZ :  2.62/00 17/04/2007  08.48.15  by  Michael Scheer
*CMZ :  2.61/06 12/04/2007  13.39.48  by  Michael Scheer
*CMZ :  2.61/05 12/04/2007  09.31.10  by  Michael Scheer
*CMZ :  2.61/04 29/03/2007  16.31.30  by  Michael Scheer
*CMZ :  2.61/03 27/03/2007  13.28.57  by  Michael Scheer
*CMZ :  2.61/02 26/03/2007  20.10.23  by  Michael Scheer
*CMZ :  2.61/01 15/02/2007  14.24.13  by  Michael Scheer
*CMZ :  2.61/00 30/01/2007  20.26.35  by  Michael Scheer
*CMZ :  2.60/00 26/01/2007  10.51.17  by  Michael Scheer
*CMZ :  2.59/02 25/01/2007  16.09.16  by  Michael Scheer
*CMZ :  2.59/01 24/01/2007  14.31.57  by  Michael Scheer
*CMZ :  2.59/00 23/01/2007  15.40.31  by  Michael Scheer
*CMZ :  2.58/01 23/01/2007  13.25.37  by  Michael Scheer
*CMZ :  2.58/00 16/01/2007  17.45.07  by  Michael Scheer
*CMZ :  2.57/05 10/01/2007  13.39.01  by  Michael Scheer
*CMZ :  2.57/04 01/02/2006  16.20.46  by  Michael Scheer
*CMZ :  2.57/03 23/12/2005  11.47.54  by  Michael Scheer
*CMZ :  2.57/02 09/12/2005  11.14.11  by  Michael Scheer
*CMZ :  2.57/01 22/11/2005  13.32.26  by  Michael Scheer
*CMZ :  2.57/00 22/11/2005  12.34.51  by  Michael Scheer
*CMZ :  2.56/02 21/10/2005  16.32.41  by  Michael Scheer
*CMZ :  2.56/01 21/10/2005  12.35.13  by  Michael Scheer
*CMZ :  2.56/00 17/10/2005  13.31.12  by  Michael Scheer
*CMZ :  2.55/01 10/08/2005  16.11.58  by  Michael Scheer
*CMZ :  2.55/00 10/08/2005  16.09.07  by  Michael Scheer
*CMZ :  2.54/07 16/06/2005  12.25.44  by  Michael Scheer
*CMZ :  2.54/06 02/06/2005  13.55.03  by  Michael Scheer
*CMZ :  2.54/05 02/06/2005  08.17.02  by  Michael Scheer
*CMZ :  2.54/04 19/04/2005  14.13.18  by  Michael Scheer
*CMZ :  2.54/03 18/04/2005  08.55.59  by  Michael Scheer
*CMZ :  2.54/02 13/04/2005  13.53.43  by  Michael Scheer
*CMZ :  2.54/01 13/04/2005  09.16.10  by  Michael Scheer
*CMZ :  2.54/00 28/02/2005  17.31.30  by  Michael Scheer
*CMZ :  2.53/05 25/02/2005  12.01.44  by  Michael Scheer
*CMZ :  2.53/04 10/02/2005  10.01.32  by  Michael Scheer
*CMZ :  2.53/03 26/01/2005  15.37.28  by  Michael Scheer
*CMZ :  2.53/02 25/01/2005  18.20.27  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  13.29.43  by  Michael Scheer
*CMZ :  2.53/00 21/01/2005  17.23.24  by  Michael Scheer
*CMZ :  2.52/16 20/01/2005  15.01.12  by  Michael Scheer
*CMZ :  2.52/15 05/01/2005  16.38.50  by  Michael Scheer
*CMZ :  2.52/14 22/12/2004  16.29.13  by  Michael Scheer
*CMZ :  2.52/13 16/12/2004  21.17.47  by  Michael Scheer
*CMZ :  2.52/12 08/12/2004  14.07.18  by  Michael Scheer
*CMZ :  2.52/11 08/12/2004  13.39.43  by  Michael Scheer
*CMZ :  2.52/10 05/11/2004  17.17.16  by  Michael Scheer
*CMZ :  2.52/09 29/10/2004  13.08.04  by  Michael Scheer
*CMZ :  2.52/08 14/10/2004  14.53.26  by  Michael Scheer
*CMZ :  2.52/07 14/10/2004  09.24.13  by  Michael Scheer
*CMZ :  2.52/05 17/08/2004  15.57.24  by  Michael Scheer
*CMZ :  2.52/04 13/07/2004  08.24.46  by  Michael Scheer
*CMZ :  2.52/03 08/07/2004  13.38.12  by  Michael Scheer
*CMZ :  2.52/02 08/07/2004  10.29.10  by  Michael Scheer
*CMZ :  2.52/01 30/06/2004  16.24.34  by  Michael Scheer
*CMZ :  2.52/00 30/06/2004  10.54.07  by  Michael Scheer
*CMZ :  2.51/03 23/06/2004  12.25.39  by  Michael Scheer
*CMZ :  2.51/02 22/06/2004  16.31.15  by  Michael Scheer
*CMZ :  2.51/01 17/06/2004  16.18.09  by  Michael Scheer
*CMZ :  2.51/00 26/05/2004  16.34.19  by  Michael Scheer
*CMZ :  2.50/03 10/05/2004  14.41.05  by  Michael Scheer
*CMZ :  2.50/02 30/04/2004  15.33.25  by  Michael Scheer
*CMZ :  2.50/01 30/04/2004  08.58.17  by  Michael Scheer
*CMZ :  2.50/00 29/04/2004  18.46.08  by  Michael Scheer
*CMZ :  2.49/01 23/03/2004  14.32.39  by  Michael Scheer
*CMZ :  2.49/00 19/03/2004  17.19.49  by  Michael Scheer
*CMZ :  2.48/04 17/03/2004  14.53.55  by  Michael Scheer
*CMZ :  2.48/03 10/03/2004  16.04.05  by  Michael Scheer
*CMZ :  2.48/02 03/03/2004  11.26.09  by  Michael Scheer
*CMZ :  2.48/01 02/03/2004  16.43.58  by  Michael Scheer
*CMZ :  2.48/00 01/03/2004  18.05.39  by  Michael Scheer
*CMZ :  2.47/23 17/02/2004  13.48.29  by  Michael Scheer
*CMZ :  2.47/22 03/12/2003  13.18.02  by  Michael Scheer
*CMZ :  2.47/21 03/12/2003  09.49.57  by  Michael Scheer
*CMZ :  2.47/20 01/12/2003  15.34.24  by  Michael Scheer
*CMZ :  2.47/19 01/12/2003  08.24.39  by  Michael Scheer
*CMZ :  2.47/18 27/11/2003  14.45.55  by  Michael Scheer
*CMZ :  2.47/17 12/09/2003  10.10.41  by  Michael Scheer
*CMZ :  2.47/16 11/09/2003  15.10.39  by  Michael Scheer
*CMZ :  2.47/15 04/09/2003  09.28.22  by  Michael Scheer
*CMZ :  2.47/14 07/08/2003  09.43.55  by  Michael Scheer
*CMZ :  2.47/13 03/07/2003  09.57.35  by  Michael Scheer
*CMZ :  2.47/12 03/07/2003  09.56.31  by  Michael Scheer
*CMZ :  2.47/11 30/05/2003  12.54.10  by  Michael Scheer
*CMZ :  2.47/10 30/05/2003  12.43.17  by  Michael Scheer
*CMZ :  2.47/09 27/05/2003  15.58.13  by  Michael Scheer
*CMZ :  2.47/08 20/05/2003  15.48.20  by  Michael Scheer
*CMZ :  2.47/07 15/04/2003  10.52.26  by  Michael Scheer
*CMZ :  2.47/06 28/03/2003  15.40.47  by  Michael Scheer
*CMZ :  2.47/05 27/03/2003  15.27.30  by  Michael Scheer
*CMZ :  2.47/04 13/03/2003  11.06.28  by  Michael Scheer
*CMZ :  2.47/03 12/03/2003  16.02.28  by  Michael Scheer
*CMZ :  2.47/01 10/03/2003  11.57.11  by  Michael Scheer
*CMZ :  2.47/00 07/03/2003  11.19.50  by  Michael Scheer
*CMZ :  2.46/02 07/03/2003  11.17.07  by  Michael Scheer
*CMZ :  2.46/01 18/12/2002  11.47.16  by  Michael Scheer
*CMZ :  2.46/00 17/12/2002  16.46.40  by  Michael Scheer
*CMZ :  2.45/03 17/12/2002  15.15.44  by  Michael Scheer
*CMZ :  2.45/02 16/12/2002  14.36.24  by  Michael Scheer
*CMZ :  2.45/01 13/12/2002  17.25.35  by  Michael Scheer
*CMZ :  2.45/00 13/12/2002  12.43.54  by  Michael Scheer
*CMZ :  2.44/03 13/12/2002  12.42.56  by  Michael Scheer
*CMZ :  2.44/02 13/12/2002  11.39.11  by  Michael Scheer
*CMZ :  2.44/01 12/12/2002  13.31.59  by  Michael Scheer
*CMZ :  2.44/00 15/11/2002  18.31.42  by  Michael Scheer
*CMZ :  2.43/00 29/10/2002  11.36.07  by  Michael Scheer
*CMZ :  2.42/04 29/10/2002  11.33.20  by  Michael Scheer
*CMZ :  2.42/03 13/09/2002  18.47.25  by  Michael Scheer
*CMZ :  2.42/02 12/09/2002  11.07.50  by  Michael Scheer
*CMZ :  2.42/01 09/09/2002  18.56.15  by  Michael Scheer
*CMZ :  2.42/00 09/09/2002  18.55.21  by  Michael Scheer
*CMZ :  2.41/13 03/09/2002  14.29.30  by  Michael Scheer
*CMZ :  2.41/12 22/08/2002  12.13.41  by  Michael Scheer
*CMZ :  2.41/11 21/08/2002  11.28.36  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.50.01  by  Michael Scheer
*CMZ :  2.41/09 14/08/2002  17.27.15  by  Michael Scheer
*CMZ :  2.41/08 14/08/2002  17.06.19  by  Michael Scheer
*CMZ :  2.41/07 30/07/2002  12.13.03  by  Michael Scheer
*CMZ :  2.41/06 10/05/2002  15.25.53  by  Michael Scheer
*CMZ :  2.41/05 18/04/2002  11.47.27  by  Michael Scheer
*CMZ :  2.41/04 16/04/2002  14.29.46  by  Michael Scheer
*CMZ :  2.41/03 21/03/2002  12.44.49  by  Michael Scheer
*CMZ :  2.41/02 21/03/2002  12.41.53  by  Michael Scheer
*CMZ :  2.41/01 21/03/2002  12.36.32  by  Michael Scheer
*CMZ :  2.41/00 20/03/2002  19.23.52  by  Michael Scheer
*CMZ :  2.40/04 20/03/2002  12.33.18  by  Michael Scheer
*CMZ :  2.40/03 19/03/2002  17.46.32  by  Michael Scheer
*CMZ :  2.40/02 14/03/2002  16.23.01  by  Michael Scheer
*CMZ :  2.40/01 12/03/2002  14.36.07  by  Michael Scheer
*CMZ :  2.40/00 12/03/2002  14.28.17  by  Michael Scheer
*CMZ :  2.39/02 22/01/2002  13.35.38  by  Michael Scheer
*CMZ :  2.39/01 15/01/2002  16.49.12  by  Michael Scheer
*CMZ :  2.39/00 14/01/2002  14.37.48  by  Michael Scheer
*CMZ :  2.38/03 13/12/2001  15.06.34  by  Michael Scheer
*CMZ :  2.38/02 13/12/2001  13.44.27  by  Michael Scheer
*CMZ :  2.38/01 13/12/2001  12.16.47  by  Michael Scheer
*CMZ :  2.38/00 13/12/2001  11.22.22  by  Michael Scheer
*CMZ :  2.37/07 12/12/2001  14.47.45  by  Michael Scheer
*CMZ :  2.37/06 07/12/2001  15.01.55  by  Michael Scheer
*CMZ :  2.37/05 07/12/2001  14.52.05  by  Michael Scheer
*CMZ :  2.37/04 05/12/2001  17.37.05  by  Michael Scheer
*CMZ :  2.37/03 23/11/2001  18.19.27  by  Michael Scheer
*CMZ :  2.37/02 15/11/2001  17.25.11  by  Michael Scheer
*CMZ :  2.37/01 14/11/2001  11.08.36  by  Michael Scheer
*CMZ :  2.37/00 13/11/2001  17.33.02  by  Michael Scheer
*CMZ :  2.36/01 08/11/2001  17.39.36  by  Michael Scheer
*CMZ :  2.36/00 08/11/2001  15.34.18  by  Michael Scheer
*CMZ :  2.35/02 30/10/2001  17.15.11  by  Michael Scheer
*CMZ :  2.35/01 17/10/2001  11.40.45  by  Michael Scheer
*CMZ :  2.35/00 26/09/2001  17.19.30  by  Michael Scheer
*CMZ :  2.34/09 26/09/2001  17.17.04  by  Michael Scheer
*CMZ :  2.34/08 17/09/2001  19.44.42  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  17.41.26  by  Michael Scheer
*CMZ :  2.34/04 11/07/2001  11.20.28  by  Michael Scheer
*CMZ :  2.34/02 02/07/2001  17.24.43  by  Michael Scheer
*CMZ :  2.34/01 26/06/2001  16.49.30  by  Michael Scheer
*CMZ :  2.34/00 11/05/2001  17.26.52  by  Michael Scheer
*CMZ :  2.33/09 10/05/2001  18.03.14  by  Michael Scheer
*CMZ :  2.33/08 08/05/2001  17.52.15  by  Michael Scheer
*CMZ :  2.33/07 08/05/2001  17.43.25  by  Michael Scheer
*CMZ :  2.33/06 04/05/2001  11.54.03  by  Michael Scheer
*CMZ :  2.33/03 03/05/2001  17.29.14  by  Michael Scheer
*CMZ :  2.33/02 03/05/2001  14.31.29  by  Michael Scheer
*CMZ :  2.33/00 03/05/2001  10.35.20  by  Michael Scheer
*CMZ :  2.32/04 26/04/2001  12.07.24  by  Michael Scheer
*CMZ :  2.32/02 26/04/2001  11.08.42  by  Michael Scheer
*CMZ :  2.32/01 25/04/2001  17.40.53  by  Michael Scheer
*CMZ :  2.31/01 25/04/2001  14.39.31  by  Michael Scheer
*CMZ :  2.31/00 24/04/2001  14.05.11  by  Michael Scheer
*CMZ :  2.30/03 20/04/2001  16.25.55  by  Michael Scheer
*CMZ :  2.30/02 12/04/2001  18.54.32  by  Michael Scheer
*CMZ :  2.20/11 11/04/2001  11.51.23  by  Michael Scheer
*CMZ :  2.20/10 05/04/2001  10.53.04  by  Michael Scheer
*CMZ :  2.20/09 03/04/2001  14.25.24  by  Michael Scheer
*CMZ :  2.15/01 27/03/2001  16.39.10  by  Michael Scheer
*CMZ :  2.20/05 13/03/2001  17.09.46  by  Michael Scheer
*CMZ :  2.20/04 09/03/2001  18.38.18  by  Michael Scheer
*CMZ :  2.20/02 20/02/2001  15.55.32  by  Michael Scheer
*CMZ :  2.20/01 19/02/2001  12.12.56  by  Michael Scheer
*CMZ :  2.17/00 06/11/2000  14.07.18  by  Michael Scheer
*CMZ :  2.16/08 30/10/2000  12.01.57  by  Michael Scheer
*CMZ :  2.16/07 22/09/2000  10.57.59  by  Michael Scheer
*CMZ :  2.16/06 29/08/2000  13.13.38  by  Michael Scheer
*CMZ :  2.16/05 01/08/2000  17.19.27  by  Michael Scheer
*CMZ :  2.16/04 21/07/2000  14.42.10  by  Michael Scheer
*CMZ :  2.16/01 15/06/2000  17.05.33  by  Michael Scheer
*CMZ :  2.16/00 13/06/2000  13.55.50  by  Michael Scheer
*CMZ :  2.15/00 19/05/2000  10.31.49  by  Michael Scheer
*CMZ :  2.13/12 14/04/2000  17.30.45  by  Michael Scheer
*CMZ :  2.13/11 14/04/2000  17.30.08  by  Michael Scheer
*CMZ :  2.13/10 14/04/2000  14.37.07  by  Michael Scheer
*CMZ :  2.13/11 19/03/2000  12.31.19  by  Michael Scheer
*CMZ :  2.13/08 02/03/2000  10.04.37  by  Michael Scheer
*CMZ :  2.13/02 14/12/99  16.36.32  by  Michael Scheer
*CMZ :  2.13/00 02/12/99  13.15.53  by  Michael Scheer
*CMZ :  2.12/04 27/08/99  11.46.53  by  Michael Scheer
*CMZ :  2.12/03 06/08/99  15.56.29  by  Michael Scheer
*CMZ :  2.12/02 14/06/99  16.08.06  by  Michael Scheer
*CMZ :  2.12/01 14/06/99  15.19.05  by  Michael Scheer
*CMZ :  2.12/00 03/06/99  15.46.15  by  Michael Scheer
*CMZ :  2.10/01 30/04/99  13.44.35  by  Michael Scheer
*CMZ :  2.02/00 12/02/99  17.13.24  by  Michael Scheer
*CMZ :  2.01/00 19/01/99  10.58.48  by  Michael Scheer
*CMZ :  2.00/00 11/01/99  13.40.20  by  Michael Scheer
*CMZ :  1.03/06 29/09/98  11.02.27  by  Michael Scheer
*CMZ :  1.03/05 30/03/98  17.31.01  by  Michael Scheer
*CMZ :  1.03/03 27/03/98  13.59.57  by  Michael Scheer
*CMZ :  1.02/00 06/01/98  16.06.51  by  Michael Scheer
*CMZ :  1.01/00 26/11/97  15.02.15  by  Michael Scheer
*CMZ :  1.00/01 20/10/97  14.41.17  by  Michael Scheer
*CMZ :  1.00/03 01/10/97  12.03.30  by  Michael Scheer
*-- Author : Michael Scheer
+seq,gplhint.
 !
 ! VERSION 4.01/04
 !
 $CONTRL
  !-------------------------- USER COMMENT ---------------------------

      CODE='WAVE.EXAMPLE'

  !-------------------------- MAIN MODES -----------------------------

      ! The undulator and wiggler modes should work for standard
      ! insertion devices. Reasonable settings for some parameters
      ! are taken (mainly in namelist COLLIN).
      ! Experienced users might prefere there own settings.

      IUNDULATOR=1   ! UNDULATOR MODE:

       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       !  IUNDULATOR=1   ! UNDULATOR MODE:
       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

         ! IBUNCH.EQ.0:
            ! whole trajectory is taken as source of
            ! synchroton light (ignoring input of
            ! parameters WGWINFC, collimators ...)
            ! ISPECMODE = 2
            ! NLPOI = 0
            ! WGWINFC = 45.
            ! ISPECDIP = 0
            ! ISTOKES = 1
            ! IFOLD = 1, if IFOLD.NE.0
            ! IEFOLD = 1, if IEFOLD NOT IN [-1,0,1,3]
            ! IF (IPIN.GT.0) IPIN = 1
            ! BMOVECUT = 1.E-6
            ! IHTRACKM = 0
            ! icluster = 0

         ! IBUNCH.NE.0:
            ! IBUNCH = -1
            ! ISPECMODE = 2
            ! IMAGSPLN = 0
            ! NLPOI = 0
            ! WGWINFC = 45.
            ! ISPECDIP = 0
          ! ISTOKES = 1
            ! IFOLD = 0
            ! IEFOLD = 0
            ! IPIN = 3, IF IPIN.NE.0 AND NEINBUNCH = 1
            ! BMOVECUT = 1.E-6
            ! IHTRACKM = 0

       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       !  IUNDULATOR=2   Like IUNDULATOR=1, but the radiation field is
       !                 calculated for a single period only and summed
       !                 with appropriate phase shift for the remaining
       !                 periods, s.a. KAMPLI
       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

         ! IBUNCH.EQ.0:
            ! whole trajectory is taken as source of
            ! synchroton light (ignoring input of
            ! parameters WGWINFC, collimators ...)
            ! ISPECMODE = 2
            ! IMAGSPLN = 0 for KBREC,KBUNDUMAG, etc.
            ! NLPOI = 0
            ! WGWINFC = 45.
            ! ISPECDIP = 0
            ! ISTOKES = 1
            ! IFOLD = 1, if IFOLD.NE.0
            ! IEFOLD = 1, if IEFOLD NOT IN [-1,0,1,3]
            ! IF (IPIN.GT.0) IPIN = 1
            ! BMOVECUT = 1.E-6
            ! IHTRACKM = 0
            ! icluster = 0

         ! IBUNCH.NE.0:
            ! IBUNCH = -1
            ! ISPECMODE = 2
            ! IMAGSPLN = 0
            ! NLPOI = 0
            ! WGWINFC = 45.
            ! ISPECDIP = 0
            ! ISTOKES = 1
            ! IFOLD = 0
            ! IEFOLD = 0
            ! IPIN = 3, IF IPIN.NE.0 AND NEINBUNCH = 1
            ! BMOVECUT = 1.E-6
            ! IHTRACKM = 0
          ! NBUNCH or NEINBUNCH must be 1

      IWIGGLER=0  ! WIGGLER MODE:
            !----------------------------------------------
            ! IWIGGLER = 1:
            !----------------------------------------------
            ! all poles are treated as separated sources
            ! added incoherently
            !
            ! fixed parameters
            ! (essentially in namelist COLLIN):
            ! NLPOI = -9999   (i.e. automaticly calculated)
            ! WGWINFC = 9999. (i.e. automaticly calculated)
            ! WBL0CUT = 0.1
            ! (i.e. lowest considered mag. field)
            ! WBL0HYS = 1.0
            ! (i.e. hysteresis factor of WBL0CUT)
            ! IBL0CUT = 1  (i.e. parts of the trajectory
            !      with different sign of the
            !      magnetic field are treated as
            !      separat sources)
            ! CX1,CY1,CZ1,HIG1,WID1 = 9999.
            ! (i.e. automaticly calculated)
            ! CX2,CY2,CZ2,HIG2,WID2 = 9999.
            ! (i.e. automaticly calculated)
            ! ISOUREXT = 0 (i.e. no extansion of source
            !      to check overlapping sources)
            ! SPECCUT = 20.   if considered photon energy is
            !               higher than 20 times the critical
            !     energy of the source, photon flux
            !               is set to zero
            ! ISPECMODE = 2
            ! ISPECDIP = 0
            ! ISTOKES = 1
            ! IFOLD = 1
            ! IEFOLD = 1, if IEFOLD NOT IN [-1,0,1,3]
            ! IF (IPIN.GT.0) IPIN = 1
            !
            ! IBUNCH.NE.0:
            !
              ! ISPECMODE = 2
              ! ISPECDIP = 0
              ! IFOLD = 0
              ! IEFOLD = 0
            !
            !----------------------------------------------
            ! SCHWINGER MODE:
            !----------------------------------------------
            ! (IWIGGLER > 1)
            !----------------------------------------------
            ! all poles are treated as separated sources
            ! added incoherently; spectrum is calculated
            ! according to SCHWINGER
            !
            ! fixed parameters
            ! (essentially in namelist COLLIN):
            ! *** ISPECDIP = -2
            ! WGWINFC = 10.
            ! CX1,CY1,CZ1,HIG1,WID1 = 9999.
            ! (i.e. automaticly calculated)
            ! CX2,CY2,CZ2,HIG2,WID2 = 9999.
            ! (i.e. automaticly calculated)
            ! ISOUREXT = 0 (i.e. no extansion of source
            !      to check overlapping sources)

      IEXPERT=0   ! export mode, set to null if IUNDULATOR
                  ! or IWIGGLER are set

  !-------------------------- ELECTRON -------------------------------

      NSTEPMX=-1  ! max. number of steps of electron trajectory
                  ! (array dimension, F90 only, replaces NWMAXP)
           ! if NSTEPMX<0 then NSTEPMX is set to
           ! (XSTOP-XSTART)*MYINUM*1.1*(-NSTEPMX)

      MYINUM=5000 ! number of steps per meter for the tracking
                  ! for more recent version of WAVE this parameter
           ! must be high enough for spectrum calculations
           ! (particularly for ISPECMODE =1)

      DMYENERGY=1.722   ! total electron energy [GeV]

      IENELOSS=1 ! electron energy loss due to synchrotron radiation
                 ! is taken into account.
          ! -1: Quantum fluctuations are taken into account
          !     see namelist PHOTONN
          ! For IEFIELD.ne.0 the energy
          ! gain is taken into account

      IEFIELD=0  ! take electrical field of efield.dat into account
                 ! The energy gain is only taken into account
          ! for IENELOSS.ne.0

      DMYCUR=0.1 ! current [A] of the ring

      XSTART=9999. ! initial x of the trajectory [m]
                   ! 9999. means default is used if possible
            ! i.e. entrance of the device
      XINTER=-9999.  ! if XINTER not -9999. and not missing tracking starts
                     ! at XINTER. The particle is tracked forward or
              ! backward to XSTART.
              ! XSTART,YSTART,...,VXIN,... are overwritten
              ! for restart of tracking now beginning at XSTART
              ! 9999. means default is used if possible
              ! i.e. entrance of the device
              ! XINTER = XSTART = 9999. is allowed but makes no sense
      XSTOP=9999. ! final x of the trajectory [m]
                  ! 9999. means default is used if possible
           ! i.e. exit of the device
      YSTART=0.0  ! initial y of the trajectory [m]
      ZSTART=0.0  ! initial z of the trajectory [m]

      VXIN=1.0 ! initial x-component of velocity vector (relative)
      VYIN=0.0 ! initial y-component of velocity vector (relative)
      VZIN=0.0 ! initial z-component of velocity vector (relative)

      BMOVECUT=1.E-6  ! in tracking routines, mag. fields below BMOVECUT
                      ! are treated as zero. This cuts might crucially effect
               ! spectrum calculations. In case of problems check
               ! convergence of integrations by changing MYINUM, NLPOI
               ! etc.

      IHINPUT=-3 ! this input file is stored as CWN on histogram file
                 ! 0: no storage
                 ! 1: first 32 characters of line are stored
                 ! 2: first 64 characters of line are
                 ! 3: first 96 characters of line are stored
                 ! neg. value means compression (i.e. skipping
                 ! of comment lines) is suppressed

       IHOUTP=3  ! output file WAVE.OUT is stored as CWN on histogram file

       IHISASCII=0 ! non zero flag generates ASCII-Files
                   ! of histograms
                   ! filename is histogramtitle_index.wvh
                   ! IHISASCII=1 means 1D histos only
                   ! IHISASCII=10 means 2D histos only
                   ! IHISASCII=100 means ntuples only
                   ! for combinations add numbers, e.g. 1+10=11
                   ! means 1D and 2D histos to be treated
                   ! negative values means no header on file
                   ! In addition some other files e.g. of the
                   ! trajectory are written (names: *.wva)
                   ! (IROOTREES >= 0)

       CHISASCII='*' ! Comment marker for header lines i.e. first character

       IROOTTREES=0  ! OBSOLETE. Use mhbook_to_root.exe to convert
                     ! WAVE.mhb to WAVE.root
                     ! Write histograms and NTuples to file wave.root for
                     ! analysis program root
                     ! <0: Do not write histogram file for PAW

       IROOTHDF5=0 ! Write histograms and NTuples HDF5 File wave.h5
                   ! roottohdf5_main.exe must be in search path

   !-------------------------- MAGNETIC FIELD -------------------------------

      IRFILT0=0 ! calculate Bx(x),By(x),Bz(x) from the trajectory of file FILETR

      IBSUPER=1 ! flag to allow superposition of magnetic field
                ! configurations

      IBERROR=0 ! superimpose magnetic field errors (namelist BERRORN)
                ! if IHTRACK is set, phase error analysis is given

      KBEXTERN=0  ! magnetic field is taken from user routine BEXTERN

      KBFELD=0 ! magnetic field is a sequence of hard edge dipoles
               ! parameters namelist BBFELD
               ! fring field simulation is offered
               ! fields are not MAXWELL conform
               ! magnet field routine BFELD
               ! maybe it's better to use flag KMAGSEQ

      IBGAUSS=0 ! instead of hard edge, use Gaussian field

      KMAGSEQ=0 ! sequence of different magnets and undulators
                ! the sequence is read from file FILEMG
                ! if negative, magnets to not radiate for IBMASKSP.ne.0

                ! file format: *
                ! 1th column (ASCII): dummy
                ! 2th column (ASCII): magnet type (DI or QP)
                !
                ! for dipoles (BEND),
                !(see manual of tracking code elegant for CSBEND):

                !   First line:
                !   3th column: deflection angle [rad]
                !   4th column: bending radius [m]
                !   5th column: entrance edge [rad]
                !   6th column: exit edge [rad]
                !   7th column: Integral of fringe
                !   8th column: Full gap of magnet
                !   9th order of interpolation:
                !                '1': linear
                !                '3': cubic spline
                !                '5': quintic spline
                !
                !   2nd line: x,y,z of magnet center
                !   3rd line: x,y,z of entrance point, ex,ey,ez of nor. vec.
                !   4th line: x,y,z of exit point, ex,ey,ez of normal vector

                ! for dipoles (DI):
                !   3th column: deflection angle [rad]
                !   4th column: bending radius [m]
                !   5th column: x-position of magnet center [m]
                !   6th column: parameter s of fringe field function f
                !               f = 1/(1+exp(s*...))
                !               infinit s means hard edge
                !   the field is a product of two Fermi distributions
                !
                ! for dipoles with Fourier expanded field (DIF):
                !   3th column: deflection angle [rad]
                !   4th column: bending radius [m]
                !   5th column: x-position of magnet center [m]
                !   6th column: parameter s of fringe field function f
                !               f = 1/(1+exp(s*...))
                !               infinit s means hard edge
                !   the field is a product of two Fermi distributions
                !   7th column: k-value of transversal field gradient
                !   8th column: number of Fourier coefficients
                !
                ! for dipoles with horizontal field (DH):
                !   3th column: deflection angle [rad]
                !   4th column: bending radius [m]
                !   5th column: x-position of magnet center [m]
                !   6th column: parameter s of fringe field function f
                !               f = 1/(1+exp(s*...))
                !               infinit s means hard edge
                !   the field is a product of two Fermi distributions
                !   7th column: ---
                !   THE FOURIER TRANSFORMED VARIATION IS NOT AVAILABLE
                !   I.E. IMGSQF IS IGNORED
                !
                ! for hori. dipoles  with Fourier expanded field (DHF):
                !   3th column: deflection angle [rad]
                !   4th column: bending radius [m]
                !   5th column: x-position of magnet center [m]
                !   6th column: parameter s of fringe field function f
                !               f = 1/(1+exp(s*...))
                !               infinit s means hard edge
                !   the field is a product of two Fermi distributions
                !   7th column: k-value of transversal field gradient [1/m]
                !   8th column: number of Fourier coefficients
                !
                ! for undulators (UE):
                !   3th column: K parameter, if not zero B0V and
                !               B0H are overwritten, but the
                !               ratio is kept
                !   4th column: B0 vertical [T]
                !   5th column: B0 horizontal [T]
                !   6th column: shift between hori. and vert. field [m]
                !   7th column: Long. pos. of undulator center [m]
                !   8th column: Period-length [m]
                !   9th column: Number of periods
                !   10th column: Base length l of trans. gradient [m],
                !                i.e. k=2*pi/l, ONLY useful for B0H=0!
                !   11th column: Nth harmonic to which columne 12 refers
                !   12th column: Energy of Nth harmonic
                !   13th column: Scaling factor for taper
                !   14th column: Offset in z
                !   15th column: Rotation angle in the x-z plane
                !
                ! for quadrupoles (QP):
                !   3th column: length of magnet [m]
                !   4th column: gradient g of quadrupole [1/m**2]
                !   5th column: x-position of magnet center [m]
                !   6th column: z-position of magnet center [m]
                !               to take displacement of beam into
                !               account (due to dipoles)
                !   7th column: rotation angle of magnet in the orbit
         !                      plane [rad] to take slope of trajectory into
                !               account (due to dipoles)

                ! for sextupoles (SX):
                !   3th column: length of magnet [m]
                !   4th column: gradient g of quadrupole [1/m**3]
                !   5th column: x-position of magnet center [m]
                !   6th column: z-position of magnet center [m]
                !               to take displacement of beam into
                !               account (due to dipoles)
                !   7th column: rotation angle of magnet in the
                !               orbit plane [rad]
                !               to take slope of trajectory into
                !               account (due to dipoles)

                ! for quadrupoles (QF): like QP, but with fringe field

                ! magnetic field routine BMAGSEQ

          KMAGCOR=1  ! flag to correct fringe field effects and slopes of
                     ! trajectory on the deflection angle
                     ! Be aware of side-effects
                     ! KMAGCOR<0: Only the on-axis integral is corrected

          IMGSQF=0   ! Fourier transformation used for dipole fields
                     ! makes dipole fields MAXWELL conform. Only file
              ! FILEF is used, better consider magnet models like
              ! DIF

      KHALBA=0 ! insertion device described by HALBACH's formulas
               ! parameter namelist HALBACH
               ! magnetic field routine BHALBA
               ! KHALBA.lt.0 means zero field outside device

      KHALBASY=0  ! simple WLS or undulator/wiggler model
                  ! parameter namelist HALBASY
                  ! each pole described by HALBACH's formulas

      KUNDUGAP=0  ! Undulator/wiggler model with fitted Beff(gap) dependency
                  ! parameter namelist UNDUGAPN
                  ! each pole described by HALBACH's formulas

      KUCROSS=0  ! crossed undulator with modulator
                 ! parameter namelist UCROSSN
                 ! field is not smooth nor MAXWELL conform
                 ! at pole edges
                 ! magnetic field routine BUCROSS

      KELLIP=1   ! helical undulator, parameter namelist ELLIPN

      KELLANA=0  ! analytical field for helical undulator,
                 ! parameter namelist ELLANAN, SR BELLANA

      KBREC=0    ! Magnetic field from REC-structure on file
                 ! FILEREC or according to parameter namelist RECN
                 ! SR BREC (rectangularly shaped magnets)

      KBUNDUMAG=0     !  1:  Use field of an APPLE-II undulator calculated by
                      !      UNDUMAG
                      !  2:  like 1, but run UNDUMAG first (namelist UNDUMAGN)
                      !
                      !  3:  Use field of a planar hybrid undulator calculated
                      !      by UNDUMAG (namelist UNDUHYBRIDN)
                      !  4:  like 3, but run UNDUMAG first
                      !
                      ! <0: Run UNDUMAG first, but use undumag.nam and undumag.clc
                      !     as rather their templates, and don't [over]write
                      !     undumag_mu.dat. This means, UNDUMAG runs as
                      !     externally set-up by the user
      KBUNDUVERB=1    !  1: Watch UNDUMAG working
      KBUNDUMAP=1     !  1: use undumag.map for field calculations, quad. interpolation
                      !  2: use undumag.map for field calculations, lin. interpolation
                      !

      KBPOLYMAG=0     ! >0: Read Magnetic field from REC-structure on file
                      ! FILEPM, parameter namelist POLYMAGN
                      ! SR BPOLYMAG (magnets are polyeder)
                      ! <0: Write Magnetic field from REC-structure (BREC)
                      ! to file wave_to_polymag.dat

      IRBTAB=0 ! magnetic field By on device axis is read
               ! from data file FILETB and interpolated by splines
               ! particle must move in orbit plane i.e. y=0
               ! magnetic field from routine BTAB
               ! fileformat:
               ! 1. line: user comment
               ! 2. line: scaling factors for x and By to convert to
               !          meter and Tesla
               ! 3. line: number of data points (negative means
               !          symmetric field relative to x=0
               ! following lines: x By data
               !
               ! fileformat for IRBTAB<0:
               ! x By
               ! fileformat for IRBTAB=-2:
               ! x/mm By

      IFOURBTABZY=0  ! magnetic fields By and Bz on device axis are read
                     ! from data files FILETB and FILETBZ. The FFT is
                     ! caculated for a superposition of Halbach undulators
                     ! in y and z. Namelist FBTABZYN

      IRBTABZY=0  ! magnetic fields By and Bz on device axis are read
                  ! from data files FILETB and FILETBZ and interpolated
                  ! by splines (some format as for IRBTAB>0)

      IRBTABXYZ=0 ! magnetic fields Bx,By and Bz on device axis are read
                  ! from data files FILETB, FILETBX, FILETBZ and interpolated
                  ! by splines (some format as for IRBTAB>0)

      IRFILB0=0   ! read 3D mag. field table from file FILEB0
                  ! format of routine BMESS
                  ! field is interpolated from equally spaced grid
                  ! IRFILB0=-1 means field is taken from grid point
                  ! IRFILB0=-2 means field is linearily interpolated
                  ! IRFILB0=-4 means field map is given in terms of
                  ! coefficients of polynomials
                  ! IRFILB0=nonzero else means field is fitted according to
                  ! Maxwell's equations, see NAMELIST BGRIDN
                  ! IRFILB0=6 to use 3D mag. field map in the
                  ! format of IWBMAP = 6, linear interpolation scheme
                  ! IRFILB0=-6 to use 3D mag. field map in the
                  ! format of IWBMAP = 6, quadratic interpolation scheme
                  ! See also hints under IWBMAP, where scaling options etc.
                  ! are explained

      IRFILF=0 ! magnetic field is given as a superposition
               ! of HALBACH insertion devices
               ! the coefficients of the superposition are read from
               ! file FILEF
               ! parameter namelist FOURIER
               ! magnetic field routine BFOUR

      KBAMWLS=0       ! straight section of BAM/PTB-WLS; namelist BAMWLSN

      KBPOLYH=0 ! magnetic field is given as a superposition
                ! of HALBACH insertion devices calculated by
                ! program POLYHARM
                ! the coefficients are read from file
                ! wave_bpolyharm_coef.dat
                ! the magnetic field is calculated by routine BPOLYHARM

      KBPOLY3D=0 ! magnetic field is calculated from 3D Maxwell conform
                 ! polynomial potential. Coefficients are read from file
                 ! FILE3DFIT
                 ! used coefficients are given via NAMELIST BPOLY3DN

      KBPOLY2DH=0 ! magnetic field is calculated from transversal
                  ! polynomial and longitudinal harmonical ansatz
                  ! Coefficients are read from file FILE2DHFIT

      KBPHARM=0 ! magnetic field is calculated from
                ! 3D harmonical fit according to SR BPHARMFIT
                ! Coefficients are read from file FILEPHFIT

      IRFILP=0 ! magnetic field from PANDIRA (file FILEP)
               ! magnet field routine BPAND
               ! contact M. Scheer

      IBHELM=0 ! magnetic field form Helmholtz-coils

      KBGENESIS=0 ! read lattice file FILEGEN of FEL-code GENESIS
                  ! and calculate corresponding mag. field
                  ! KBGENESIS > 0: Ntuple of trajectory and
                  !                field is created
                  ! KBGENESIS < 0: no Ntuple
                  ! KBGENESIS = +/- 2: read start conditions form
                  ! file genesis.start

 !-------------------------- OPTIONS -------------------------------


      IBFORCE=0   ! Calculation of magnetic forces
                  ! ***ATTENTION: Together with REC calculations are
                  ! wrong if considered volume inside or partially inside
                  ! magnet block.
                  ! Namelist BFORCN
                  ! Subroutine BFORCE

      IWBPOLY3D=0 ! 3D Maxwell conform polynomial field is fitted
                  ! to field map FILEBMAP.
                  ! IWBPOLY3D=1 means standard format of FILEBMAP
                  ! IWBPOLY3D=2 means column format of FILEBMAP
                  ! Output file is FILE3DFIT
                  ! Relation between coefficients are read from
                  ! file FILE3DCOE
                  ! Order of fit is given via NAMELIST BPOLY3DN

      IWBPOLY2DH=0 ! Field map FILEBMAP is fitted with polynomial
                   ! ansatz in y,z and harmonical ansatz in x.
                   ! IWBPOLY2DH=1 means standard format of FILEBMAP
                   ! IWBPOLY2DH=2 means column format of FILEBMAP
                   ! Output file is FILE2DHFIT
                   ! Periodlength of device and other parameters
                   ! are given in namelist BPOLY2DHN

       IWBPHARM=0 ! Field map FILEBMAP is fitted 3D harmonical
                  ! ansatz. Field is expanded as series of cosine-like
                  ! vertical Halbach-Fields and sine-like horizontal
                  ! Halbach-Fields plus constant offsets
                  ! Scalar potential:
                  ! VC:=-B0C/KYC(N,NXY)*COS(NXY*KXC*X)
                  !    *SINH(KYC(N,NXY)*Y)*COS(N*KZ*Z
                  ! VS:=-B0S/KXS(N,NXY)*COS(NXY*KYS*Y)
                  !    *SINH(KXS(N,NXY)*X)*SIN(N*KZ*Z)
                  ! V0:=-(B0X*X+B0Y*Y+B0Z*Z)
                  ! V:=VC+VS+V0
                  ! BX:=-DF(V,X)
                  ! BY:=-DF(V,Y)
                  ! BZ:=-DF(V,Z)
                  ! IWBPHARM = 1 means standard format of FILEBMAP
                  ! IWBPHARM = 2 means column format of FILEBMAP
                  ! Output file is FILEPHFIT
                  ! Periodlength of device and other parameters
                  ! are given in namelist BPHARMN

      IWFILF=0 ! coefficients for superposition of HALBACH
               ! insertion devices are computed for given field
               ! and written to file FILEF
               ! in later runs this file is input if flag IRFILF
               ! is set
               ! parameter namelist FOURIER

      IWSECTMAGS=0 ! approximate vertical magnetic field by IWSECTMAGS
                   !  sector magnets, and write them to files wave.smag,
                   ! wave.xmag and wave.strmag
                   ! IWSECTMAGS < 0: use sector magnets on files wave.smag
                   ! and wave.xmag as magnetic field for tracking

      IWBTAB=0 ! to write By along straight line parallel to
               ! device axis or along trajectory onto file
               ! FILEWBT
               ! for parameters and file formats see NAMELIST WBTABN
               ! first and second field integrals and integrated
               ! quadrupole and sextupole terms etc. are calculated
               ! results of integrations are step by step
               ! written to files FILEWBT and wbtab_sextupole.dat
               ! if (IWBTAB.eq. 100) then trajectory is used
               ! rather than straight line

      IWBMAP=0 ! to write 3D mag. field map to file FILEBMAP
               ! according to namelist BMAPN
               !
               ! IWBMAP = 1 means field map in standard format
               ! IWBMAP = 2 means field map in column format
               ! IWBMAP = 3 means field map in column format for
               !            BMESS etc.
               ! IWBMAP = 4 means field map is written in terms of
               !          fitted coefficients of polynomials for
               !          BMESS. The coefficients are calculated
               !          according to namelist BGRIDN
               !          IBMRADIAL must be zero
               ! IWBMAP = 5 convert map of FILEB0 from column format
               !          to format for BMESS; grid input data must
               !          match that of namelist BMAP
               ! IWBMAP = -1 means field map as Ntuple only
               ! (option IHBPOLY3D for Ntuple must be set)
               !
               ! IWBMAP = 6 means the following format:
               !          lines starting with %,*,!,#,@ are comments
               !          or discription lines, empty lines
               !          are ignored
               !          WAVE writes the run number and CODE to the
               !          first two lines, e.g.
               !          the data line must come after an
               !          scaling factor line for x,y,z,bx,by,bz,
               !          containig the key-word scaling,
               !          e.g. * scaling = 1. 1. 1. 1. 1. 1.
               !          data columns contain x,y,z,bx,by,bz
               !          z runs the fastes, then y, then x
             ! IWBMAP = 7 means suitable for spectra

      IBSYM=0  ! IBSYM .ne. 0 means symmetry of device assumed
               ! Bx(-x) is set to -Bx(x)
               ! By(-x) is set to By(x)
               ! Bz(-x) is set to Bz(x)
               ! IBSYM .lt. 0 means negative field for x.lt.0

      XBSYM=0.0 ! X of symmetry point i.e.
                ! e.g. BY(-(X-XBSYM))=BY(X-XBSYM) etc.
                !(depending on IBSYM)

      IBSYMY=0 ! IBSYMY .ne. 0 means symmetry of device assumed
               ! Bx(-y) is set to Bx(y)
               ! By(-y) is set to -By(y)
               ! Bz(-y) is set to Bz(y)
               ! IBSYMY .lt. 0 means negative field for y.lt.0

      IBSYMZ=0 ! IBSYMZ .ne. 0 means symmetry of device assumed
               ! Bx(-z) is set to Bx(z)
               ! By(-z) is set to By(z)
               ! Bz(-z) is set to -Bz(z)
               ! IBSYMZ .lt. 0 means negative field for z.lt.0

               ! HALBACH classic
               ! (note WAVE coordinate-system!!)
               ! IBSYM=1, IBSYMY=-1, IBSYMZ=1

      IWFILT0=0 ! write for each IWFILT0th step of the trajectory
                ! x,y,z,vx,vy,vz,Bx,By,Bz,Ax,Ay,Az
                ! to file FILETR using '*' Format
                ! IWFILT0 = 1 means with header:
                ! 1. line: * run number
                ! 2. line: * user comment
                ! IWFILT0 > 1 means with header:
                ! 1. line: run number
                ! 2. line: user comment
                ! IWFILT0 < 0 without header

      IHTRACK=1  !to get Ntuple of trajectory and !magnetic field
                 !every abs(IHTRSMP)th point is taken
                 !IHTRACK=abs(n) means spacing of points
                 !in 0.5xIHTRACK mm for trajectory on grid (ntuple 20)
                 !for ABS(IHTRACK)=9999 namelist WBTABN is used to
                 !define sample range and stepping size

                 !if IBERROR is set, phase error analysis is given

      IHTRSMP=1 !every IHTRSMPth point is taken for NTuple 10

      XSTARTH=9999. !lower edge of histogram (9999. XSTARTH=XSTART)
      XSTOPH =9999. !upper edge of histogram (9999. XSTOPH=XSTOP)

      IJUST=0 ! to adjust closed orbit offset to zero by shifting
              ! device horizontally, i.e. adjust variable HSHIFT
              ! in of namelist B0SCGLOBN
              ! 1. set HSHIFT=0.001(for example), IJUST=1, run WAVE
              ! 2. set IJUST=2, re-run WAVE
              ! 3. set IJUST=3, re-run WAVE
              !                 re-run WAVE (as often as necessary)
              ! 4. set IJUST=4 to use optimized value of HSHIFT
              !    which is written to file FILEJ
              !    or
              !    set IJUST=0 and set HSHIFT accordingly
              !
              ! iteration steps are written to file FILEJ

      IUNAME=0 ! to call SR UNAME
      IUSTEP=0 ! to call SR USTEP
      IUOUT=0  ! to call SR UOUT

 !-------------------------- SPECTRUM CALCULATIONS---------------------------

      ISPEC=1 ! to activate spectrum calculations
              ! parameter namelists :
              ! COLLIN
              ! SPECTN
              ! WFOLDN
              ! PINHOLE
              ! FREQN

      ISPECMODE=2 ! 0: same as 2
                  ! 1: spectrum is calculated by interpolation
                  !    from reference orbit,
                  !    i.e. no tracking of source point with high
                  !    resolution; ROIs are taken into account
                  ! 2: source is retracked with precision according to
                  !    NLPOI
                  !    ROIs are taken into account
                  !    (recommended for wigglers)
                  ! 3: use still older algorithm, no ROIs,
                  !    no bunches etc., less precise, but faster
                  ! 4: use still older tracking routine (TRACKSOLD)
                  ! (test purpose)

      IVELOFIELD=0 ! to take velocity field into account
                   ! IVELOFIELD.eq.0 add velocity field
                   ! IVELOFIELD.eq.1 do not add velocity field
                   ! IVELOFIELD.lt.0 velocity field only

      IMAGSPLN=0     ! to use spline interpolation of magnetic
                     ! field from arrays of reference orbit
                     ! (faster, but maybe less accurate)
                     ! IMAGSPLN<0 means field is stored on file
                     ! magjob.dat
                     ! -9999 means memory mode
                     ! IMAGSPLN>0 means field is read from file
                     ! magjob.dat
                     ! (out of range problems may occur if NLPOI
                     ! is of similar size as number of points
                     ! on reference orbit)
                     ! NOT COMPATIBLE WITH IWBMAP/IWBTAB/IBFORCE AND IOPTIC
                     ! is set to -9999 by IUNDULATOR and IWIGGLER

        XIANF=9999.  ! limits of X for integration and
                     ! for straight line fits through z(x) and y(x)
        XIEND=9999.  ! 9999. means whole trajectory is taken
                     ! for straight line fits through z(x) and y(x)
                     ! only available in the export mode (IEXPERT.ne.0)

        BANWID=0.001 ! bandwidth for spectrum calculations

        IWFILL0=0    ! write sources to file FILEL0

        IHTRACKM=1   ! Ntuple of mini-trajectory

        IRFILL0=0    ! read sources from file FILEL0
                     ! one and only one of these flags must be set
              ! IWFILL0=1 is recommended

        NLPOI=-9999  ! Maximal number of integration steps per source
                     ! The accuracy of the integration depends on
                     ! this number. Check results of integration by
                     ! increasing NLPOI. For dipoles, wiggler, etc., i.e.
                     ! if you have several sources, the step size of the
                     ! integration depends both on NLPOI and
                     ! WGWINFC (namelist COLLIN), since WGWINFC
                     ! influences the extension of the source.
                     ! For this sources for a rough calculations
                     ! NLPOI = 1000 should work,
                     ! for high precision calculations
                     ! 5000<NLPOI<20000 should be good.
                     ! To get a feeling compare results of WAVE with
                     ! results of Schwinger mode ISPECDIP.
                     ! Rule of thumb:
                     ! NLPOI = 500 * WGWINFC * Eph,max/Ecrit
                     !
                     ! NLPOI = 0 means NLPOI = (XSTOP-XSTART)*MYINUM+1
                     !
                     ! NLPOI = -9999 means NLPOI is estimated by
                     ! SR NLPOIWIN
                     !
                     ! For undulators, try some 50 steps per period to
                     ! start with.
                     !
                     ! WAVE knows regions of interest (ROI) with
                     ! individuell step size; see namelist ROIN
                     ! Check also MYINUM (ISPECMODE.EQ.1)

        IFREQ2P=3 ! =0 : spectrum is calculated for listed photon
                  !      energies on file FILEFR
                  ! =1 : spectrum is calculated for energy FREQLOW
                  !      in namelist FREQN
                  ! =-1: spectrum is calculated for energy
                  !       (FREQLOW+FREQHIG)/2. in namelist FREQN
                  ! =2 : spectrum is calculated for the energy range
                  !      FREQLOW -> FREQHIG (namelist FREQN)
                  !      each step increases energy by powers of 2
                  !      fast calculation due to
                  !      exp(2**N*E0)=exp(2**(N-1)*E0)**2

                  ! >2: spectrum is calculated for NINTFREQ
                  !     (namelist FREQN) equidistant
                  !     energies from FREQLOW TO FREQHIG
                  !     (namelist FREQN)
                  !     fast calculation due to
                  !     exp(N*E0)=EXP((N-1)*E0)*EXP(E0)

        IHFREQ=1  ! to get histograms of spectrum over photon energies
                  ! (if IFREQ2P > 2)
                  ! Ntuple for PAW with all information of
                  ! array SPECT is generated
                  ! every IHFREQth photon energy is considered

        ISPECINT=0   ! spectrum is integrated over photon energy range

        IPIN=1  ! to calculate spectrum in pinhole rather
                ! than for list of observation points
                ! for the parameters of the pinhole see namelist PINHOLE
                ! if negative integration over pinhole is skipped
                ! [ OBSOLETE: IPIN = 2 (for ISPECMODE = 5) allows flux calculation with
                ! only one mash point in pinhole (see ISPECMODE) ]
                !
                ! IPIN = 3, flux through pinhole by Monte-Carlo.
                ! Only useful for IBUNCH set and NEINBUNCH = 1. For each electron
                ! the observation point is chosen randomly
                ! inside the pinhole. The flux-density is calculated
                ! from the flux divided by the size of the pinhole
                ! If IBUNCH.ne.0 be careful with the interpretation
                ! of the flux-density. If e.g. the flux-density is
                ! plotted from the Ntuple of 3600 (PAW) or n3600 (root)
                ! as a profile histogram, the histogram corresponds
                ! to the complete incoherent sum of all
                ! electrons, even if they are radiation
                ! coherently. The histogram of the mean flux-density
                ! on the contrary shows the flux-density from the
                ! coherent radiation

          IHPIN=0 ! to get histograms of flux distributions inside pinhole
                  ! if negative or zero only histograms 10998,10999,11000
                  ! are booked (for KUMAC NFLUX)
                  ! will be set to zero for IPIN = 3

          IHFOLD=1 ! histograms of folding function for emittance
                   ! procedure
                   ! will be set to zero for IPIN = 3

          IUSEM=0 ! to use the subroutine CONV2 of the program
                  ! USEM for the integration over the pinhole
                  ! and the folding (obsolete, not supported)

          IPINCIRC=0 ! to calculate flux through circular pinhole
             IRPHI=0 ! OBSOLETE to use polar coordinates if IPINCIRC is set and
                     ! IUSEM is not

          ISTOKES=1   ! to calculate Stokes vector for flux through pinhole

          IBRILL=1 ! to calculate brilliance (spectral brightness)
                   ! flag ISTOKES must be set

          ISPECSUM=0 ! Integration of arrays SPEC and STOKES are additionally
                     ! performed by a simple summation (test purposes)

          IFOLD=1 ! to invoke folding procedure to take emittance into
                  ! account (namelist WFOLDN)
           ! IFOLD.EQ.1: use routine UTIL_FOLD_FUNCTION_GAUSS
           ! IFOLD.EQ.2: use Monte-Carlo techniques (ISPECMODE = 5)
           ! IFOLD.EQ.-1: use routine UTIL_FOLD_FOURIER
           ! IFOLD.LT.-2: use routine old precedure of WAVE
           ! parameter namelist WFOLDN

          ISIGUSR=1  ! if flag is set sigmas for folding are taken from
                     ! namelist WFOLDN, otherwise calculated from emittance
                     ! and beta functions BETAH, BETAHP, BETAV, BETAPV
                     ! in namelist DEPOLA (be careful, if distributions are
                     ! not Gaussians)

        IBUNCH=0     ! Take bunch structure into account.
                     ! IBUNCH = 1: First electron is also randomized
                     ! IBUNCH = -1: First electron is not randomized,
                     ! be careful with biases.
                     ! See namelist BUNCHN

        IPHASE=0     ! calculate complex amplitude in pinhole and
                     ! transform back to source plan and get
                     ! phase space distribution from geometrical
                     ! optic (namelist PHASEN)
                     ! IPHASE.LT.0 means spline-integration used
                     ! ABS(IPHASE.GT.1) means additional application of
                     ! geometrical optic

        IDOSE=0      ! To calculate absorbed energy dose
                     !IDOSE > 0: F(X)=AA*X**BB interpolation of coef.
                     !IDOSE < 0: linear interpolation of coef.

      IPHOTON=0       ! Write file WAVE.PHOTON for program PHOTON
      ECPHOTON=2.5575e3 ! Critical energy of dipole for program PHOTON [eV]

        IF1DIM=0     ! spectrum calculation and folding only in vertical direction

        IPOLA=0      ! if flag is set the flux is calculated from component
                     ! of complex amplitude parallel to complex vector VPOLA
                     ! STOKES-Vectors are not affected!!
                     ! (NAMELIST SPECTN)

        IEFOLD=1     ! =1: fold spectrum with Gaussian to take energy spread
                     ! of electrons into account (namelist WFOLDN)
              ! =-1: old algorithm
              ! of electrons into account (namelist WFOLDN)
              ! =2: take beam energy spread into account by Monte-
              ! Carlo-technique (ISPECMODE = 5) (check precision) OBSOLETE
              ! =3 like 1, but lin. interpolation rather than splinesused;
              !    needed when spectrum is not smooth enough

        IWFILSP0=0   ! write integration results (arrays SPEC,SPECT) to
                     ! file FILESP0

        IWFILPOW=0   ! write power distributions to file FILEPOW
                     ! IWFILPOW.lt.0 means no user comment on file
              ! Meaning of columns: x, y, z, total power density,
              ! power density within spectral range, power density
              ! within spectral range with emittance, total power dens. grazing
              ! *** UNITS: mm Watt/mm**2!!

        IWFILRAY=0   ! write integration results to data file for RAY
                     ! (only for first photon energy)

        IRFILSP0=0   ! read integration results (arrays SPEC,SPECT) from
                   ! file FILESP0 (test purposes)

        IRFILSTO=0   ! read integration results for Stokes vectors from
                     ! file FILESTO

        KAMPLI=0     ! Modern version of option IAMPLI to simulate undulator
                   ! of KAMPLI periods by simple phase shifting.

              ! Namelists PHASEREPN, BUNCHN
              ! From BUNCHN only NBUNCH, IHBUNCH, IUBUNCH are available
              ! IHBUNCH is adjusted to the number of threads
              ! (MTHREADS.NE.0).
              ! Only the field options KELLIP in combination with
              ! PHSHIFT are available for MTHREADS.NE.0

        IAMPLI=0   ! IAMPLI>0:
                   ! reads or writes amplitudes of integration
            ! to file FILEAMPLI (array REAIMA).
            ! Treatment of data is done in SR ADDAMPLI and
            ! controlled by namelist AMPLIN
            ! IAMPLI<0:
            ! sums up IAMPLI times the calculated
            ! amplitude such that:
            ! Asum=|A1|*(exp(i*phi1) + |A2|*exp(i*2*phi2)+...)
            ! where the amplitudes and phases are corrected for
            ! depth of field effects.
            ! To take random phase errros into account, use
            ! variables AMPRAN and IAMPSEED in namelist
            ! AMPLIN. AMPRAN referes here the length of the
            ! repeated amplitude, AMPFREQ is adjusted to 1. harm.
            ! AMPSHIFT(1) is applied in addition.
            ! Check contribution of endpoles!!!
            ! To ignore end poles use variables XIANF and XIEND.

           IAMPJIT=0    ! Jitter on phase is calculated by tracking the device
                        ! period by period (IAMPLI.LT.0)

        IWFILSPF=0   ! write folded integration results
                     ! (arrays SPECF,SPECTF) to FILESPF

        IWFILSTO=0 ! write integration results for Stokes vectors to
                   ! file FILESTO. PAW-Macros NFILS0 and HFILSTO can be used to
                   ! visualize data.

        IWFLSTOF=0 ! write integration results for folded Stokes vectors to
                   ! file FILESTOF. PAW-Macros NFILS0F and HFILSTOF can
                   ! be used to visualize data.

        IWFLSTOE=0  ! write integration results for Stokes vectors with
                    ! energy spread to file FILESTOE
                    ! PAW-Macros NFILS0E and HFILSTOE can be used to
                    ! visualize data.

        IWFLSTOEF=0  ! write integration results for folded Stokes vectors
                     ! with energy spread to file FILESTOEF
                     ! PAW-Macros NFILS0EF and HFILSTOEF can be used to
                     ! visualize data.

        IWFILFL0=0   ! write flux through pinhole to file FILEFL0

        IWFILFLF=0   ! write folded flux through pinhole to file FILEFLF

        IWFILS=0     ! write STOKES vector of flux through pinhole to file FILES

        IWFILSE=0  ! write STOKES vector of flux through pinhole to
                   ! file FILESE including beam energy spread
        IWFILSF=0  ! write STOKES vector of flux through pinhole to
                   ! file FILESF including beam emittance
        IWFILSEF=0 ! write STOKES vector of flux through pinhole to
                   ! file FILESEF including beam emittance and beam
                   ! energy spread

        IWFILB=0   ! write STOKES vector of selected point to file FILEC
        IWFILBE=0  ! write STOKES vector of selected point to file FILECE
                   ! including beam energy spread
        IWFILBF=0  ! write STOKES vector of selected point to file FILECF
                   ! including beam emittance
        IWFILBEF=0 ! write STOKES vector of selected point to file FILECEF
                   ! including beam emittance and beam energy spread

        IWFILBRILL=0   ! write brilliance of STOKES vector of selected point to
                       ! file FILEBRILL
        IWFILBRILLE=0  ! write brilliance of STOKES vector of selected point
                       ! to file FILEBRILLE
                       ! including beam energy spread
        IWFILBRILLF=0  ! write brilliance of STOKES vector of selected
                       ! point to file FILEBRILLF
                       ! including beam emittance
        IWFILBRILLEF=0 ! write brilliance of STOKES vector of selected
                       ! point to file FILEBRILLEF
                       ! including beam emittance and beam energy spread

        IWFILINT=0 ! if set to N, the integral of the Nth source for first
                   ! observation point and first photon energy is
                   ! written to file FILEINT (test purposes)
                   ! IWFILINT.LT.0 means field amplitudes are
                   ! written to Ntuple, more information, recommended
                   ! (range from XIANF to XIEND)

          JWFILINT=1 ! spacing of points for IWFILINT

        IPINALL=0 ! to print results of spectrum calculation for
                  ! all observation points to output file WAVE.OUT

        ISPECANA=0   ! spectrum is taken from user routine SPECANA
                     ! (test purposes)

        ISPECANAF=0  ! folded spectrum is taken from user routine SPECANAF
            ! (test purposes)

        IDESYNC=0 ! to calculate dose from DESYNC spectrum file
            ! IDESYNC.EQ.-9999 programs uses EGS4 spectrum file
            ! IDESYNC.lt.0 programs asks for spectrum number
            ! IDESYNC.gt.0 IDESYNC is spectrum number

        ISPECDIP=0    ! to calculate spectrum from pure dipole from
            ! Bessel functions
            ! ISPECDIP > 0: calc. according to namelist SPECDIPN
            ! ISPECDIP = 2: G1 is calculated instead of photon flux
                        ! FREQLOW and FREQHIGH are interpreted as
                        ! Egamma/Ec
            ! ISPECDIP=-1: calc. spectrum at center of found sources
            !              according to SCHWINGER (fast)
            ! ISPECDIP=-2: calc. spectrum at according to SCHWINGER
            !              the source is located where the
            !              observation angle has a mininum
            !              the angle is calculated from particle
            !              trajectory
            !         *** recommended ***
            ! ISPECDIP=-3: calc. spectrum at according to SCHWINGER
            !              the source is located where the
            !              observation angle has a mininum
            !              the angle is calculated from particle
            !              trajectory retracked within source with
            !              high resolution (slow but more precise!?)
            ! ISPECDIP=-4: SCHWINGER's formula is applied
                        ! for each step of the source points

        IUNIT=0   ! to use wavelength [nm] rather than energy [eV]
            ! to characterize photons


 !-------------------------- GENERATING FUNCTION  -------------------------

      IOPTIC=0 ! to generate a set of trajectories
               ! for fitting of generating function
               ! trajectories are written to file FILEO
               ! parameter namelist OPTIK (IOPTIC.gt.0)
               ! IOPTIC=-1: Tracks are generated according to
               ! phasespace ellipse given by
               ! EPS0H, BETAH, BETAPH, EPS0V, BETAV, BETAPV
               ! in namelist DEPOLA

      IGENFUN=0  ! trajectories are read from file FILEO
                 ! to fit generating function
                 ! parameter namelist TRANPON
                 ! if negativ not generating function but
                 ! mapping (xf,xpf,yf,ypf) of (xi,xpi,yi)
                 ! is calculated

      IERZFUN=0 ! to generate set of trajectories using
                ! given coefficients of generating function
                ! coefficients are user supplied by file
                ! wave_erzfun.in (test purposes)

                ! IERZFUN=+/-100 (subroutine IDTRMSHGF)
                ! subroutine ERZFUN else

                ! in context of phase ellipse tracking this
                ! flag controls the use of Generating Funktion
                ! IERZFUN<0: Only linear tracking, all coeffs.

                ! else

      IERZANA =0     ! set of trajectories calculated analytically
               ! by user supplied routine ERZANA.FOR
               ! (test purposes)

 !-------------------------- OTHER TASKS  -------------------------------

      IPOWER=0 ! to calculate power and photon distributions on
               ! beamline walls
               ! distributions are stored in histogramms
               ! parameter namelist SPECTN

      IEMIT=0 ! to calculate emittance change due to WLS
              ! radiation integrals I2,I4 and I5
              ! and optical functions at WLS
              ! location must be given by user in
              ! namelist DEPOLA.
              ! Additionally the trajetory with start values of
              ! namelist PHASETRACKN is tracked an written to
              ! the file FILEZZPYYP

      IHBETA=1 ! to get histograms of optical functions
               ! every IHTRSMPth point is taken for histograms
               ! IEMT must be set

      IEMIAHW=0 ! to calculate emittance effects for simple WLS
                ! model form analytical formulas
                ! device must have only one main pole
                ! flag KHALBASY must be set, derivation
                ! of external dispersion must be DDISP0=0
                ! radiation integrals I2,I4 and I5
                ! and optical functions at WLS
                ! location must be given by user in
                ! namelist DEPOLA

      IWLSOPT=0 ! seach for optimal parameter of simple
                ! WLS model (one main pole)
                ! parameter namelist WLSOPTN

      IBEAMPOL=0  ! to get information about beam polarization time
                  ! and final level of beam polarisation
                  ! parameter of ring must be given in namelist DEPOLA

      MTHREADS=-1     ! >0: Number of CPU cores to be used
                      ! <0: Use all cores

      $END

 $GSEEDN

      !***** Obsolete, see namelist RANDOMN

      IGSEED1=0   ! first seed for random generator grndm used by
                  ! various routines
                  ! to set seed, both seeds must be given
      IGSEED2=0   ! second seed for random numbers
                  ! -9999 (both): Seeds are read from file wave.gseed,
                  ! which is written before WAVE terminates
        $END

 $RANDOMN
        ! Seeds to initialize the FORTRAN random generator.
        ! Since Version 3.02/02 of WAVE all old  random functions
        ! are faked, i.e. replaced by calls to random_number routine.
        ! Twelfe seed values are require; the first four seem to have no effect
        ! under Linux and gfortran

        irnmode=1 ! 0: Seed is initialize automatically, i.e. via
                  !    call random_seed(isize) with isize=64
                  ! 1: Seeds of this namelist are taken
                  !    to have reproducible results
                  !<0: Seeds are read from file wave.seeds
                  ! This file is written is overwritten by WAVE!!

+self,if=-oldseed.
        irnseed(1)=376577121
        irnseed(2)=52147852
        irnseed(3)=-1273034815
        irnseed(4)=-1963249100
        irnseed(5)=1195262240
        irnseed(6)=-1718716574
        irnseed(7)=-224354675
        irnseed(8)=432587481
        irnseed(9)=1692325775
        irnseed(10)=1934175653
        irnseed(11)=-107106772
        irnseed(12)=648589804
        irnseed(13)=-1919014861
        irnseed(14)=-1763988460
        irnseed(15)=-1039845022
        irnseed(16)=1414926465
        irnseed(17)=-1214705659
        irnseed(18)=560082688
        irnseed(19)=527470902
        irnseed(20)=-1078636718
        irnseed(21)=272932485
        irnseed(22)=-356992740
        irnseed(23)=-2013991490
        irnseed(24)=-588501795
        irnseed(25)=-1010120436
        irnseed(26)=-1558306344
        irnseed(27)=-1116776222
        irnseed(28)=794926823
        irnseed(29)=-1157173406
        irnseed(30)=63711032
        irnseed(31)=-1870802148
        irnseed(32)=-674825931
        irnseed(33)=-690546468
        irnseed(34)=1671737514
        irnseed(35)=-224394481
        irnseed(36)=2026233226
        irnseed(37)=-1141752469
        irnseed(38)=2061158685
        irnseed(39)=-1225625467
        irnseed(40)=-147464566
        irnseed(41)=1692325775
        irnseed(42)=1934175653
        irnseed(43)=-107106772
        irnseed(44)=648589804
        irnseed(45)=-1919014861
        irnseed(46)=-1763988460
        irnseed(47)=-1039845022
        irnseed(48)=1414926465
        irnseed(49)=-1214705659
        irnseed(50)=560082688
        irnseed(51)=527470902
        irnseed(52)=-1078636718
        irnseed(53)=272932485
        irnseed(54)=-356992740
        irnseed(55)=-2013991490
        irnseed(56)=-588501795
        irnseed(57)=-1010120436
        irnseed(58)=-1558306344
        irnseed(59)=-1116776222
        irnseed(60)=794926823
        irnseed(61)=-1157173406
        irnseed(62)=63711032
        irnseed(63)=-1870802148
        irnseed(64)=-674825931

+self,if=oldseed.
         irnseed(1)= 1222957173
         irnseed(2)=  972333141
         irnseed(3)=-1558163966
         irnseed(4)= 2015003664
         irnseed(5)=  405090142
         irnseed(6)=-2139608104
         irnseed(7)=-1811865884
         irnseed(8)= -720677015
         irnseed(9)= 1692325775
         irnseed(10)= 1934175653
         irnseed(11)= -107106772
         irnseed(12)=  648589804
         irnseed(13)=-1919014861
         irnseed(14)=-1763988460
         irnseed(15)=-1039845022
         irnseed(16)= 1414926465
         irnseed(17)=-1214705659
         irnseed(18)=  560082688
         irnseed(19)=  527470902
         irnseed(20)=-1078636718
         irnseed(21)=  272932485
         irnseed(22)= -356992740
         irnseed(23)=-2013991490
         irnseed(24)= -588501795
         irnseed(25)=-1010120436
         irnseed(26)=-1558306344
         irnseed(27)=-1116776222
         irnseed(28)=  794926823
         irnseed(29)=-1157173406
         irnseed(30)=   63711032
         irnseed(31)=-1870802148
         irnseed(32)= -674825931
+self.,if=oldseed.

        $END

 !-------------------------- Parallel processing  -------------------------------

 $cluster
       !Only useful with IBUNCH set
       icluster=0 !<0: split run for parallel processing, i.e. slave mode
                  !>0: collect results of parallel processing, i.e. master mode
       iclubun=0  ! Internal flag to control wpamp
 $end

 !-------------------------- PARAMETER NAMELISTS -------------------------------

 $B0SCGLOBN

      ICHARGE=-1  ! particle charge
                  ! ICHARGE.LE.0 means e-
                  ! ICHARGE.GT.0 means e+

      IBMASK=0 ! field of namelist BBFELD is used as
               ! weight function for magnetic field, i.e.
               ! BX=BX*BMASK, BY=BY*BMASK, BZ=BZ*BMASK
               ! negative values of IBMASK means field is added, i.e.
               ! BY=BY+BMASK
             !
               ! IBMASK=10 means masks are taken from file FILEFTV
               ! Xi Xe Bmask, i.e. intervall boundary and scaling factor
               ! as spline interpolation and multiplication. File format:
               ! 1. comment
               ! 2. x-scale-factor, y-scaling-factor
               ! 3. data lines
             !
               ! IBMASK=100 means masks are read from file wave.bmask
               ! (multiplication only)
             !
               ! IBMASK=-100 a user defined function UBMASK is called
               ! (multiplication)
             !
               ! IBMASK=-200 a user defined function UBMASK is called
               ! (summation)
               ! Format of wave.bmask: x,By,Bz

        JBMASK=0  ! Like IBMASK, but it is applied after all symmetry
                  ! operations etc., i.e. at the end of MYBFELD

        IBMASKSP=0  ! field is taken into account for tracking only,
                    ! but does not contribute to radiation,
                    ! i.e. phase-shifter
                    ! works only for ispecmode = 1 or ispecmode = 2
                    ! IBMASKSP.NE.0 works only for IBMASK=0

      BYGOFF=0.0     ! global offset for magnetic field
                     ! By is set to By+BYGOFF
      BZGOFF=0.0     ! global offset for magnetic field
                     ! Bz is set to Bz+BZGOFF
      A0SCGLOB=1.0   ! global scaling factor for magnetic vector
                     ! potential
      B0SCGLOB=1.0   ! global scaling factor for magnetic field
                     ! B is set to B*B0SCGLOB
                     ! (BYGOFF is added before)
      A0SCGLOBY=1.0  ! global scal. factor for magnetic vector
                     ! potential in Y
      B0SCGLOBY=1.0  ! global scaling factor for magnetic field in Y

      A0SCGLOBZ=1.0  ! global scal. factor for magnetic vector
                     ! potential in Z
      B0SCGLOBZ=1.0  ! global scaling factor for magnetic field in Z

      XSHIFT=0.0     ! x-shift of device
                     ! (x(elect) -> x(elect)+XSHIFT) [m]

      XBSHIFT=0.0    ! x-shift of device immediately before specific
                     ! field routine is called, i.e. after all symmertry
                     ! operations etc.
                     ! (x(elect) -> x(elect)+XBSHIFT) [m]
                     ! Useful to symmtrize e.g. the fixed REC-undulators
                     ! by setting xbshift to a quarter of the periodlength
                     ! and ibsym=1

      XSHBTAB=0.0    ! x-shift for FILETBX, FILETB and  FILETBZ (option IRBTAB)
      XSHMAGSEQ=0.0  ! x-shift for option KMAGSEQ

      HSHIFT=0.0    ! horizontal shift (z(elec)->z(elec)+HSHIFT)
      VSHIFT=0.0    ! vertical (y(elec)->y(elec)+VSHIFT)

      XROTD= 0.0    ! rotation angle around x-axis [degree]
                    ! z(elec) -> z*cos(XROTD) - y*sin(XROTD)
                    ! y(elec) -> z*sin(XROTD) + y*cos(XROTD)
                    ! the rotation is performed after the
                    ! translation !!
                    ! before you use these options, please consult
                    ! the manual
      IPERIODG=0    ! *** Attention: The options are applied in
                    ! the order:
                    ! XSHIFT..., IPERIODG, IBSYM...
                    !>0: magnetic field is taken periodically
                    !    with period length PERIODG
                    !-1: magnetic field is taken periodically with
                    !    period length PERIODG, for
                    !    XPERWMN < X < XPERWMMX
                    !-2: magnetic field is taken periodically with
                    !    period length PERIODG from half period,
                    !    for XPERWMN < X < XPERWMMX
                    !-3: magnetic field is taken periodically with
                    !    period length PERIODG from quarter of
                    !    period for cosine-like fields (in X)
                    !    for XPERWMN < X < XPERWMMX
                    !-4: magnetic field is taken periodically with
                    !    period length PERIODG from quarter of
                    !    period for sine-like fields (in X) for
                    !    XPERWMN < X < XPERWMMX
             ! Example, which extenses the device by 5 periods,
             ! i.e. 1 meter:
             !    KHALBASY=1
             !    AHWPOLT=3
             !    ZLHALBASY=0.2
             !    IPERIODG=-1
             !    PERIODG=0.2
             !    PEROFFG=-0.1
             !    XPERWMN=0.0
             !    XPERWMX=1.0
             !    XSHIFT=-0.5 ! to center the device
      XPERWMN=0.    !    lower X, for which field is taken
                    !    periodically
      XPERWMX=0.    !    upper X, for which field is taken
                    !    periodically
      PERIODG=0.8   ! period length of magnetic field
      PEROFFG=-0.4  ! X-offset of magnetic field
                    ! B(X,Y,Z)=B(MOD(X-PEROFFG,PERIODG),Y,Z)
      SIGNG=1.D0    ! factor to scale or reverse (if negative)
                    ! field after half a period
      SIGNG2=0.D0   ! factor to scale or reverse (if negative)
                    ! field after a full period
                    ! is ignored if zero

      BTAPERV=0.0d0  ! global vertical rel. taper, after all other operations
                     ! not Maxwell-conform
      BTAPERH=0.0d0  ! global horizontal rel. taper, after all other operations
                     ! not Maxwell-conform
      XTAPER=0.      ! x, where the taper factor is btaperv or btaperh,
                     ! respectively. 9999. means XTAPER=XSTART

 $END

 $BBHELM
        P0HELM(1,1)=-0.000    !x-position of coil center
        P0HELM(3,1)=0.0       !z-position of coil center
        P0HELM(1,2)=0.0
        P0HELM(3,2)=0.0
        P0HELM(1,3)=0.000
        P0HELM(3,3)=0.0
        R0HELM(1)=0.883782970238297  !radius [m] of coil
        R0HELM(2)=0.2
        R0HELM(3)=0.6
        B0HELM(1)=-1.5
        B0HELM(2)=7.5
        B0HELM(3)=0.
        INTHELM=100    ! number of linear segments to form coil
        $END

 $BBFELD ! hard-edge dipoles with optional fringes
         ! field is not MAXWELL conform
         ! selected by flag KBFELD

      XM1=-1. !entrance [m]
      XP1=+1. !exit[m]
      BBY1=1. !field [T]
      YSOFT1(1)=0.1    !width of left fring field[m]
      YSOFT1(2)=0.1    !width of right fring field [m]

      XM2=2.  !entrance [m]
      XP2=3.  !exit[m]
      BBY2=1. !field [T]
      YSOFT2(1)=0.0000    !width of left fring field[m]
      YSOFT2(2)=0.0000    !width of right fring field [m]

      XM3=4.  !entrance [m]
      XP3=5.  !exit[m]
      BBY3=1. !field [T]
      YSOFT3(1)=0.0000    !width of left fring field[m]
      YSOFT3(2)=0.0000    !width of right fring field [m]

      XM4=6.  !entrance [m]
      XP4=7.  !exit[m]
      BBY4=1. !field [T]
      YSOFT4(1)=0.0000    !width of left fring field[m]
      YSOFT4(2)=0.0000    !width of right fring field [m]

      XM5=8.  !entrance [m]
      XP5=9.  !exit[m]
      BBY5=1. !field [T]
      YSOFT5(1)=0.0000    !width of left fring field[m]
      YSOFT5(2)=0.0000    !width of right fring field [m]

      XM6=10.   !entrance [m]
        XP6=11. !exit[m]
      BBY6=1.   !field [T]
      YSOFT6(1)=0.0000    !width of left fring field[m]
      YSOFT6(2)=0.0000    !width of right fring field [m]

      XM7=12. !entrance [m]
      XP7=13. !exit[m]
      BBY7=1. !field [T]
      YSOFT7(1)=0.0000    !width of left fring field[m]
      YSOFT7(2)=0.0000    !width of right fring field [m]

      $END

 $HALBACH   ! magnetic field defined by HALBACH formula
            ! coordinate system here different from the
            ! standard of WAVE, HALBACH's convention used
            ! i.e. z is longitudinal device axis
            ! the system is internally converted to WAVE standard

      B0HALBA=0.5    ! peak field [T]
      PKHALBA=0.     ! Deflection parameter K, if not zero, B0HALBA is overwritten
      XLHALBA=0.0    ! 2*pi/kx (horizontal gradient) [m]
                     ! XLHALBA=0 means YLHALBA=ZLHALBA (no gradient)
      YLHALBA=9999.  ! is calculated from the relation ky**2=kx**2+kz**2
      ZLHALBA=0.05   ! 2*pi/kz [m]
      ZLENHAL=9999.  ! total device length [m]
      PERHAL=50.     ! number of periods (NOT NECESSARYLY INTEGER)
                     ! if positive then ZLENHAL is recalculated
                     ! ZLENHAL=ZLHALBA*PERHAL
                     ! if negative then ZLHALBA is recalculated
                     ! ZLHALBA=-ZLENHAL/PERHAL
      NHHALBA=1      ! if not zero, magnetic field is calculated such, that
                     ! the energy of the NHHALBAth harmonic is HHALBA
                     ! OVERWRITES PKHALBA!
      HHALBA=-9999.   ! photon energy of considered harmonic [eV]
                     !-9999.: HHALBA=(FREQLOW+FREQHIG)/2 or
                     ! or = FREQLOW for single photon energy
                     ! other negative values: HHALBA denotes wavelength [nm]
      XCENHALBA=0.0  ! longitudinal position of undulator center [m]

      $END

 $HALBASY   ! Device consists of a HALBACH device and two endpoles
            ! endpoles are also described by HALBACH formulas
            ! the pole width is adjusted to have zero first and
            ! second field integrals. The field is
            ! not fully Maxwell conform nor continuous.
            ! coordinate system here different from the
            ! standard of WAVE, HALBACH's convention used
            ! i.e. z is longitudinal device axis
            ! the system is internally converted to WAVE standard
      B0HALBASY=2.    ! peak field [T]
      PKHALBASY=0.    ! Deflection parameter K, if not zero, B0HALBASY is overwritten

      XLHALBASY=0.    ! 2*pi/kx for global horizontal gradient [m]
                      ! XLHALBASY=0 means YLHALBASY=ZLHALBASY (no gradient)
      YLHALBASY=9999. ! calculated from ky**2=kx**2+kz**2
      ZLHALBASY=0.2   ! 2*pi/kz of main poles [m]
      FASYM=2.0       ! asymmetry parameter, i.e.
                      ! absolute value of peak field ratio of main-
               ! and endpoles
               ! for FASYM=2.0, cos(k*x)+cos(2*k*x) is used, i.e.
               ! sign changes at ZLHALBASY/6.
               ! for FASYM=2.0+eps, cos(k*x)+cos(2*k*x) is used, i.e.
               ! sign changes at ZLHALBASY/4.
      AHWPOL=21.      ! number of main poles, should be an odd number
      IAHWFOUR=0      ! use field composed by Fourier superposition of
                      ! HALBACH devices; fourier coefficients A(1)...A(NFOUR)
               ! are calculated analytically
               ! parameter NFOUR in namelist FOURIER
      NHHALBASY=0     ! if not zero, magnetic field is calculated such, that
                      ! the energy of the NHHALBASYth harmonic is HHALBASY
                      ! OVERWRITES PKHALBASY!
      HHALBASY=1000.  ! photon energy of considered harmonic [eV]
                      !-9999.: HHALBASY=(FREQLOW+FREQHIG)/2 or
               ! or = FREQLOW for single photon energy
               ! other negative values: HHALBASY denotes wavelength [nm]
      XCENHAL=0.0     ! longitudinal position of undulator center [m]

      $END

 $UNDUGAPN  ! Device consists of a HALBACH device and two endpoles
            ! endpoles are also described by HALBACH formulas
            ! the pole width is adjusted to have zero first and
            ! second field integrals.

            ! Beff = a * exp( b*gap/perlen + c *(gap/perlen)**2 )

      UNDUFULLGAP=0.0055 ! Full gap [m]

      XLUNDUGAP=0. ! 2*pi/kx for global horizontal gradient [m]
                   ! XLUNDUGAP=0 means YLUNDUGAP=ZLUNDUGAP (no gradient)

      YLUNDUGAP=9999.   ! calculated from ky**2=kx**2+kz**2
      ZLUNDUGAP=0.017   ! 2*pi/kz of main poles [m]

      UNDUGAPPOL=161.  ! number of main poles, should be an odd number

      XCENUNDUGAP=0.0 ! longitudinal position of undulator center [m]

      ! Refer to NIM A 60711, Fit parameters for Beff

      ! Cryo-undulator, fit with chamfers
      !UNDUGAPA =  3.60959
      !UNDUGAPB = -3.91248
      !UNDUGAPC =  0.415708

      ! Sm2Co17
      !UNDUGAPA =  2.43479
      !UNDUGAPB = -3.50336
      !UNDUGAPC = -0.0500684

      ! Cryo-undulator, as in NIM A 907 (2018) 149-168
      !UNDUGAPA =  3.177
      !UNDUGAPB = -3.111
      !UNDUGAPC = -0.495

      ! Cryo-undulator, as in NIM A 60711
      UNDUGAPA =  3.598
      UNDUGAPB = -3.840
      UNDUGAPC =  0.6311

      $END

 $UCROSSN               ! crossed undulator consisting of a horizontal
                        ! undulator, a modulator, and a vertical undulator
                        ! each device consists of main poles and two end poles

        B0UCROSS(1)=-0.125 ! peak field of first undulator (horizontal) [T]
        B0UCROSS(2)= 0.035 ! peak field of modulator [T]
        B0UCROSS(3)=-0.125 ! peak field of second undulator (vertical) [T]

        UASYM(1)=2.4      ! asymmetry parameter, i.e.
                          ! absolute value of peak field ratio of main-
                          ! and endpoles
        UASYM(2)=1.5
        UASYM(3)=2.4

        NMUPOL(1)=11      ! number of main poles of first undulator
        NMUPOL(2)=1       ! number of main poles of modulator
        NMUPOL(3)=13      ! number of main poles of second undulator

        ZLUHAL(1)=0.084 !period length of first undulator [m]
        ZLUHAL(2)=0.140 !period length of modulator [m]
        ZLUHAL(3)=0.084 !period length of second undulator [m]

        IUCRSAX=0       !IUCRSAX.NE.0 end pole splitting 1:3:4
                        !IUCRSAX=2 horizontal undulator is centered
                        !IUCRSAX=3 vertical undulator is centered

      $END

 $ELLIPN          ! helical undulator

      PARKELL=0.  ! if not zero, it is effective K-parameter of undulator
                  ! mag. fields B0ELLIPV and B0ELLIPH are adjusted
                  ! signs and ratio of B0ELLIPV and B0ELLIP are kept

      B0ELLIPV=0.353553390593   ! vertical peak field   [T]
      B0ELLIPH=0.353553390593   ! horizontal peak field   [T]

      XLELLIP=0.056   ! period length [m]
      PERELLIP=31.    ! number of periods
      ELLSHFT=0.25    ! shift of horiz. and vert. fields [periods]

      NHARMELL=0 ! if not zero, magnetic field is calculated such, that
                 ! the energy of the NHARMth harmonic is HARMELL
                 ! signs and ratio of B0ELLIPV and B0ELLIP are kept
                 ! OVERWRITES PARKELL!

      HARMELL=1000.  ! photon energy of considered harmonic [eV]
                     !-9999.: HARMELL=(FREQLOW+FREQHIG)/2
                     !other negative values: HARMELL denotes wavelength [nm]

      XCENELL=0.0 ! longitudinal position of undulator center [m]
      ELLTAP=0.0  ! scaling factor for taper to compansate energy loss
                  ! ELLTAP=1 means, that the field is corrected to shift the
                  ! harmonic to compensate for the energy-loss
                  ! It scales the whole device, since it is ment for a series
                  ! of undulators

      $END

 $ELLANAN ! helical undulator from anaytical field with
          ! hard edge endpoles (be careful)

      B0ELLANA=1.     ! field amplitude [T]
      NPERELLA=32     ! number of periods
      XLELLANA=0.2    ! lx [m]
      ZLELLANA=0.112  ! lz [m]
      X0ELLANA=0.0205   ! x0 [m], distance of magnet center from device axis
      GAPELL=0.024    ! full gap [m]
      REFGAPELL=0.02  ! reference gap of coefficiens [m]
      SHELLANA=0.25   ! shift in units of ZLELLANA
      ROWSHELLA=0.    ! additional row shift of lower rows
                        ! shift in units of ZLELLANA
      IELLS2S3=1      !>=0: S3-MODE; <0: S2-MODE
      IELLCOEF=0      !>0: read IELLCOEF Fourier coefficients from file
                      !    bellana.coef
                      !=<0: First and second coefficients only with C0=0.5,
                      ! and C1=1.

        $END

 $FOURIER   !to calculate FFT of magnetic field on the device
            !axis
            !coefficients are weights for superposition of
            !a series of HALBACH devices

      NFOUR=-9999 !number of coefficient taken for superposition
                  !-9999 NFOUR is read from file FILEF (IRFILF set)
      NFOURWLS=32 !number of coefficients written to file FILEF
      IFOUR0=0 ![0/1] coefficient A(0) is not/is set to zero
            !this allows one to adjust first and second
            !integral of magnetic field to zero
      XLENFOUR=0.0   !2*pi/kx (to superimpose horizontal gradient) [m]
      DBHOMF=0.0001  !x is calculated for which dB(x)/B(0) = DBHOMF [m]
      IPRNTF=0 !to print coefficients to output file WAVE.OUT

      FOUENTR=-9999.      ! Entrance of window for field calculation
                          ! Missing or equal -9999.:
                          ! Minus halve device length - XSHBFOUR
      FOUEXIT=-9999.      ! Exit of window for field calculation
                          ! Missing or equal -9999.:
                          ! Halve device length + XSHBFOUR
                          ! XSHBFOUR is applied before window cut

      SCBFOUR=1.0         ! Scaling factor for B-field
      XSHBFOUR=0.0      ! X -> X+XSHBFOUR in subroutine BFOUR


      $END

 $FBTABZYN
      FOURYSH=0.0   ! Shift for Bz, i.e. By(x+fourysh) is calculated
      FOURZSH=0.0   ! Shift for Bz, i.e. Bz(x+fourzsh) is calculated
      NFOURZY=64    ! Number of FFT coefficients
      IFOURZY0=0    ! Suppress offset:
                    ! 1:  Suppress offset of By
                    ! 10: Suppress offset of Bz
             ! 11: Both
      KLINEARFBT=0  ! Use linear interpolation rather then splines for
                    ! preparing FFT from data files
      ! Note: FFT are written to FILETB.fft and FILETBZ.fft
 $END

 $DEPOLA          ! storage ring parameters BESSY

      RDIPOL=  4.359 ! 1.3 Tesla
      UMFANG=  240.
      TAUKRIT=4.0

            ! Reference Paul Goslawki, Jul 2019:
            ! High Beta:
            !
            !           epsilon_x = 7.70E-9 m-rad
            !           epsilon_y = 1.54e-10 m-rad
            !
            !           sigma_x  = 275.e-6 m
            !           sigma_xp = 28e.1-6 rad
            !           sigma_y = 22.5e-6 m
            !           sigma_yp= 6.80e-6 rad


            ! Reference:
            ! Einige_Parameter_der_Elektronenoptik_beim_Top.doc
            ! Sigmas include dispersion

              ! natural emittance  epsilon_n = 5.34E-9 m-rad
              ! hori. emittance    epsilon_n = 5.34E-9 m-rad
              ! vert. emittance    epsilon_n = 8.01E-11 m-rad
              ! 1.5 % coupl.

            ! high beta:

               !     beta_x   = 8.71 m
               !     sigma_x  = 216.e-6 m
               !     sigma_xp = 24.8e-6 rad

               !     SIG_X_10m = 329.e-6 m

               !               beta_y  = 4.36 m
               !     sigma_y = 18.7e-6 m
               !     sigma_yp= 4.29e-6 rad

               !     SIG_Y_10m = 46.8E-6 m

            ! low beta:

               !     beta_x   = 0.96 m
               !     sigma_x  = 71.6e-6 m
               !     sigma_xp = 74.6e-6 rad

               !     SIG_X_10m = 749.4e-6 m

               !               beta_y  =  1.23 m
               !     sigma_y =  9.93e-6 m
               !     sigma_yp = 8.07e-6 rad

               !     SIG_Y_10m = 81.3e-6 m

      IBETBACK=0     ! BETAH, BETAHP, BETAV, BETAPV refere to exit rather than to entrance

      XBETFUN=9999. ! X, where BETAH,BETAV, etc. refer to
                    ! 9999: XBETFUN = XSTART or XSTOP respectively (IBETBACK)
             !       (compatibilty mode for old versions)

      BETFUN=0.0  ! hori. beta-function in the center, where the
                  ! derivative is zero
                  ! 0.: calculated from BSIGZ(1) in namelist WFOLDN
                  ! -9999.: BETAH and BETAPH are calculated as periodic
                  !        solution from lineare Transfermatrix

      BETAH=9999. ! hor. beta-function at XSTART
                  ! 9999.: calculated from BETFUN with parabolic ansatz
                  ! under the assuption, that the derivative is zero
                  ! where the hori. beta-function equals BETFUN
                  ! -9999.: calculated analytically from BETFUN
                  ! under the assuption, that the derivative is zero
                  ! where the hori. beta-function equals BETFUN

      BETAPH=9999. ! derivative of hor. beta-function at XSTART
                   ! 9999.: calculated from BETFUN with parabolic ansatz
                   ! under the assuption, that the derivative is zero
                   ! where the hor. beta-function equals BETFUN
                   ! -9999.: calculated analytically from BETFUN
                   ! under the assuption, that the derivative is zero
                   ! where the hori. beta-function equals BETFUN

      EPS0H=7.70e-9  ! horizontal emittance

      BETFUNV=0.0    ! vert. beta-function in the center
                     ! 0.: calculated from BSIGZ(1) in namelist WFOLDN
                     ! -9999.: BETAV and BETAPV are calculated as periodic
                     ! solution from lineare transfermatrix

      BETAV=9999.    ! vert. beta-function at XSTART
                     ! 9999.: calculated from BETFUNV with parabolic ansatz
                     ! under the assuption, that the derivative is zero
                     ! where the vert. beta-function equals BETFUNV
                     ! -9999.: calculated analytically from BETFUNV
                     ! under the assuption, that the derivative is zero
                     ! where the vert. beta-function equals BETFUNV
      BETAPV=9999.   ! derivative of vert. beta-function at XSTART
                     ! 9999.: calculated from BETFUNV with parabolic ansatz
                     ! under the assuption, that the derivative is zero
                     ! where the vert. beta-function equals BETFUNV
                     ! -9999.: calculated analytically from BETFUNV
                     ! under the assuption, that the derivative is zero
                     ! where the vert. beta-function equals BETFUNV

      EPS0V=15.4e-11

      DISP0=0.0   ! external dispersion [m]
      DDISP0=0.0   ! derivative of external dispersion [m]

      DI2RING=1.4414  ! radiation integral I2 of storage ring
      DI4RING=0.0 ! I4
      DI5RING=0.0020588 ! I5

      DELGAM=0.001

      $END

 $WLSOPTN   ! parameter for search of optimal WLS (simple model with
         ! one main pole and two endpoles
         ! refere to namelist HALBASY
         ! the three parameters are variated on a grid
         ! the device which meets best the boundary
         ! condition is selected

      B0MIN=6.0   ! minimum peak field of main pole
      B0MAX=6.0   ! maximum peak field of main pole
      DB0=  0.1   ! step size for variation

      XLAM0MN=0.4 ! minimum double width of main pole
      XLAM0MX=1.0 ! maximum double width of main pole
      DXLAM0=0.01 ! step size of variation

      FASYMMN=2.0 ! minimum asymmetry parameter
      FASYMMX=10.0   ! maximum asymmetry parameter
      DFASYM= 0.1 ! step size

      EMICRTMX=1.0   ! critical emittance change that can be accepted
            ! relative factor i.e. emittance of ring + wls
            ! over emittance of ring
            ! referes to actual beam energy (DMYENERGY)
      IEMICRIT=0  ! if not zero EMICRTMX referes to minimal beam energy
            ! that is acceptable from polarization time
            ! for this option must DISP0=0
      TAUCRTMX=4. ! critical beam polarization time that is acceptable [h]
      POLLEVMN=.80   ! critical final beam polarization that is required
            ! referes to lowest beam energy [POLLEVMN < 0.92]
      ZMAXMN=0.015   ! minimum required displacement of trajectory [m]
      ZMAXMX=1.0  ! maximum required displacement of trajectory [m]
      DXHOM=0.0   ! x-value for which homogenity requirements of the
            ! magnetic field are still fulfilled
            ! homogenity limit is given by DBHOMF in
            ! namelist FOURIER
      $END

 $MYFILES   ! file names and logical unit numbers of most user files
         ! all other files written or read have names beginning with
         ! WAVE_....
                ! the logical unit numbers below 50 are used by WAVE
         ! and must not be used by the user

      FILEOB=     'observ.in'    ! list of observation points
      LUNOB=      71

      FILEFR=     'freqs.in'     ! list of photon energies
      LUNFR=      72

      FILESP0= 'wave.sp0'     ! data of calculated spectrum
      LUNSP0=     73

      FILEPOW= 'wave.pow'     ! power distributions
      LUNPOW=     73

      FILEINT= 'wave_int.dat'    ! integrand of spectrum
      LUNINT=     74       ! calculations


      FILEHB=     'wave_histo.his'  ! HBOOK/PAW histogram file
      LUNHB=      75

      FILEL0=     'wave_l0.dat'     ! source points
      LUNL0=      76

      FILERAY= 'wave_ray.dat'    ! data for RAY
      LUNRAY=     80

      FILEO=      'wave_optic.dat'  ! set of trajectories for
      LUNO=    81       ! generating function fit

      FILED=      'wave_disper.dat'    ! obsolete
      LUND=    82

      FILECOD= 'WAVE_CODE.DAT'      ! program run counter (ICODE)
      LUNCOD=     83

      FILEF=      'btab.fou'     ! Fourier coefficients of
      LUNF=    84       ! magnetic field

      FILETB=     'btab.dat'
      LUNTB=      85

      FILETBZ= 'bz.dat' ! 1D table of magnetic field Bz
      LUNTBZ=     70

      FILETBX= 'bx.dat' ! 1D table of magnetic field Bz

      FILETR=     'wave_track.dat'  ! trajectory and magnetic field
      LUNTR=      86

      FILEP=      'wave_poisson.dat'   ! POISSON output data
      LUNP=    87       ! (modified version of POISSON)

      FILEJ=      'wave_adjust.dat' ! scratch file for option IJUST
      LUNJ=    88

      FILEB0=     'bmap.ntup' ! 3D table of B-field
      LUNB0=      89

      FILEBE=     'wave_beta.dat'      ! obsolete
      LUNBE=      89

      FILEWB=     'wave_wbeta.dat'  ! optical functions
      LUNWB=      90

      FILEZZPYYP= 'wave_zzpyyp.dat'       ! phase space trajectory
      LUNZZPYYP=   91

      FILESPF= 'wave_specf.dat'  ! data of folded spectrum
      LUNSPF=     92

      FILEWBT= 'wave_wbtab.dat'  ! magnetic field and integral
      LUNWBT=     93       ! multipole terms along
                     ! straight line

      FILEABS= 'sigma_tot.pb'    ! absorption coefficients
      LUNABS=     94       ! of filter

      FILEFF=     'gold.eff'     ! photo yield of gold
      LUNEFF=     94

      FILEMG=     'magseq.in'    ! sequence of magnets
      LUNMG=      95

      FILEFL0= 'wave_flux.dat'  ! flux through pinhole
      LUNFL0=     96

      FILEFLF= 'wave_fluxf.dat'  ! folded flux through pinhole
      LUNFLF=     97

      FILESTO= 'wave_stokes.dat' ! stokes dist. in  pinhole
      LUNSTO=     98

      FILESTOF=   'wave_stokesf.dat'   ! f-folded stokes dist. in  pinhole
      LUNSTOF= 99

      FILESTOE=   'wave_stokese.dat'   ! e-folded stokes in pinhole

      FILESTOEF=  'wave_stokesef.dat'  ! ef-folded stokes in  pinhole

      FILES=          'wave_stokes_flux.dat'  ! STOKES vector of flux through
      LUNS=           69

      FILESE=         'wave_stokese_flux.dat' ! STOKES vector of flux through
      LUNSE=          69                      ! with beam energy spread

      FILESF=         'wave_stokesf_flux.dat' ! STOKES vector of flux through
      LUNSF=          69                      ! with beam emittance

      FILESEF=        'wave_stokesef_flux.dat' ! STOKES vector of flux through
      LUNSEF=         69                      ! with beam energy spread and e

      FILEC=          'wave_stokes_selected.dat'  ! STOKES vector of flux-density through
      LUNC=           69

      FILECE=         'wave_stokese_selected.dat' ! STOKES vector of flux-density through
      LUNCE=          69                      ! with beam energy spread

      FILECF=         'wave_stokesf_selected.dat' ! STOKES vector of flux-density through
      LUNCF=          69                      ! with beam emittance

      FILECEF=        'wave_stokesef_selected.dat' ! STOKES vector of flux-density through
      LUNCEF=         69                      ! with beam energy spread and e

      FILEBRILL='wave_stokes_brilliance_selected.dat'  ! brilliance of STOKES vector of flux-density through


      FILEBRILLE='wave_stokes_brilliance_e_selected.dat' ! brilliance of STOKES vector of flux-density through
      ! with beam energy spread

      FILEBRILLF='wave_stokes_brilliance_f_selected.dat' ! brilliance of STOKES vector of flux-density through
      ! with beam emittance

      FILEBRILLEF='wave_stokes_brilliance_ef_selected.dat' ! brilliance of STOKES vector of flux-density through
      ! with beam energy spread and e

      FILEAM= 'abscoef_merge.in'   !List of files to be merged
      !OR input files
      !for option IFILMUL

      LUNAM= 67

      FILEAMO= 'ABSCOEF_MERGE.OUT'  !Resulting absorption coefficients
      LUNAMO= 68

      FILEREC= 'rec.par'           ! REC-structure
      LUNREC= 69

      FILEBMAP= 'bmap.dat'        ! Magnetic field map
      LUNBMAP= 67

      FILE3DCOE= 'bpoly3d.coef'          ! REDUCE coefficient file
      LUN3DCOE= 67

      FILE3DFIT= 'bpoly3d.fit'           ! fitted coefficient file

      FILE2DHFIT= 'bpoly2dh.fit'        ! fitted coefficient file
      LUN2DHFIT= 67

      FILEPHFIT= 'bpharm.fit'        ! fitted coefficient file
      LUNPHFIT= 67
+self,if=-mshhbook.
      FILEPH= 'phase.his'        ! NTUPLE-file for sr phase
      LUNPH= 67
+self.
      FILEAMPLI= 'reaima.dat'       ! File for field amplitudes
      LUNAMPLI= 67

      FILEFTH= 'htaper.dat'       ! File for field amplitudes
      FILEFTV= 'vtaper.dat'       ! File for field amplitudes
      LUNFT= 50

      FILEGENL= 'genesis.lat'      ! Lattice-File of FEL-code GENESIS
      LUNGENL= 67

      FILEGENI= 'genesis.lat'      ! Lattice-File of FEL-code GENESIS
      LUNGENI= 67

 $END

 $TRALINN ! The linear transfer matrix is estimated from four trajectories
          ! (DELTAZ,0,0,0), (0,DELTAZP,0,0), ...
          ! The matrix is written to file tralin.wav.
          ! Entrance and exit planes are perpendicular to closed orbit
          ! be careful for dipoles (are treated as sectors)

          ! For BETFUN=-9999. and BETFUNV=-9999., the periodic solution for the
          ! beta-functions and the beta matrices are calculated.

          ! Phasespace ellipses are calculated, if IPHELLIP.ne.0

          ! the transfer matrix is also applied to the variables of namelist
          ! PHASETRACKN

        DELTAZ= 0.0  !horizontal coordinate [m]
        DELTAZP=0.0  !horizontal slope [radian]
        DELTAY= 0.0  !vertical coordinate [m]
        DELTAYP=0.0  !vertical slope [radian]

        DELTAE=0.0  !rel. energy spread

        $END

 $PHASETRACKN

      PHTRZ0=0.001    !Z0 in phase with respect to closed orbit (hori.)
      PHTRZP0=0.001   !ZP0 in phase with respect to closed orbit
      PHTRY0=0.001    !Y0 in phase with respect to closed orbit (vert.)
      PHTRYP0=0.001   !YP0 in phase with respect to closed orbit
                      !the hor. ellipse is calculated for y=PHTRY0
                      !and yp=PHTRYP0, the vert. with z=PTHRZ0 etc.
                      !the results are written files
                      !wave_phase_ellipse_hori.wva and
                      !wave_phase_ellipse_vert.wva

      IPHELLIP=0      !number of angle steps for calculation of phasespace
                      !ellipses: PTHTRZ0,... are
                      !taken as half-axis of phasespace ellipses
      PHDISPH=0.0d0   !horizontal displacement
      PHBETAH=0.0d0   !horizontal beta-function
      PHDISPV=0.0d0   !vertical displacement
      PHBETAV=0.0d0   !vertical beta-function

      $END

 $OPTIK ! parameter to track set of particles through device for fitting
        ! coefficients of generating function
        ! trajectories are spaced on a grid with a mesh size of
        ! 2*DZOPT,2*DYOPT etc ...
        ! e.g. IZ=-NZOPT,...,-4,-2,0,2,4,...,NZOPT  or IZ=...,-3,-1,1,3,...
        ! ****  its a hollow beam if NZOPT etc. are odd ****
        ! the phase space is defined by a collimator
        ! trajectories are written to file FILEO

        ! for mash sizes of the grid i.e. e.g DZOPT=9999.
        ! mash is fit do aperture according to number of mash points

        NZOPT=8     !grid of horizontal displacement
        DZOPT=9999.  !grid of horizontal displacement
        NYOPT=8     !grid of vertical displacement
        DYOPT=9999.  !grid of vertical displacement

        NZPOPT=8     !grid of horizontal slope
        DZPOPT=9999. !grid of horizontal slope
        NYPOPT=8     !grid of vertical slope
        DYPOPT=9999. !grid of vertical slope

        DLAPER=5.8    ! length of collimator, if eq. 9999. then DLAPER is device
                      ! length, collimator is centered around reference orbit
        ZAPERT=0.03   ! horizontal apertur is +/- ZAPERT
        YAPERT=0.0075 ! vertical apertur is +/- YAPERT

        IPHASPAC=0   ! aperture cut takes phase space according to
                     ! subsequent beta functions into account

        IHPHSPAC=1   ! store tracks and phase space distribution in ntuple
                     ! on histogram file

        BETA0ZL=10.0  ! value of horizontal low beta function
        BETA0ZH=10.0  ! value of horizontal high beta function
        BETA0YL=10.0  ! value of vertical low beta function
        BETA0YH=10.0  ! value of vertical high beta function

        OPSTARTX=9999. ! point in starting plane for the tracking
            ! the point (OPSTARTX,OPSTARTY,OPSTARTZ)
            ! defines together with the vector (OPNX,OPNY,OPNZ)
            ! the entrance plane of the device
            ! OPSTARTX=9999. ->
            !(OPSTARTX,...Y,...Z)=(XSTART,YSTART,ZSTART)
        OPSTARTY=0.
        OPSTARTZ=0.

        OPNX=9999.  ! normal vector of starting plane
                    ! starting plane is normal to reference orbit
                    ! OPNX=9999. -> (OPNX,OPNY,OPNZ)=(VXIN,VYIN,VZIN)
        OPNY=0.0
        OPNZ=0.0

        OPENDX=9999.  ! x of point in exit plane of device
                      ! (9999. -> OPENDX=XF0, OPENDY=YF0, OPENDZ=ZF0)
        OPENDY=0.       ! y of point in exit plane of device
        OPENDZ=0.       ! z of point in exit plane of device

        OPNFX=9999. ! normal vector of end plane
                    ! OPNFX=+9999. means vector is calculated
                    ! from reference orbit where it reaches (OPENDX)
        OPNFY=0.0
        OPNFZ=0.0

        DRANDO=0.  ! start values of trajectories are modified by adding
                   ! random numbers in the range of DRANDO * mesh-size
        DSCALE=1.  ! scaling factor for linear equation system

        isnorder=0 ! 0/1 to increase precision of tracking a little bit
                   ! and slow down the program

        I2DIM=0    ! to restrict problem to orbit plane; y,y' are taken
                   ! from matrix of drift space
      $END

 $TRANPON   ! to determine coefficients of generating function
            ! reads in a set of trajectories from file FILEO

      NTRAJ=-9999 ! use only mtraj trajectories for fitting
                  ! -9999: use all trajectories
                  ! -1: use as much trajectories as number of coeffs. to fit

      ISELECT=51  ! if set to ISELECT=N, each Nth of the tracks is printed

      IKOEFF=1    ! IKOEFF.NE.0 -> coefficients are printed

      IHALBA=0    ! to get equivalent HALBACH device (I2DIM must be 0)

      NPERTRA=78  ! number of periods of equivalent HALBACH device

      IQUAD=1     ! calculate quadrupole matrix

      IA1000=0    ! IA1000.NE.0 means A1000 is not fittet
      IA0100=0    ! IA0100.NE.0 means A0100 is not fittet
      IA0010=0    ! IA0010.NE.0 means A0010 is not fittet
      IA0001=0    ! IA0001.NE.0 means A0001 is not fittet

      IA11A20=0   ! IA11A20.NE.0 means set to A1100=1 and A2000=0,
                  ! coefficients are not fitted

      IWLSHOR=0   ! IWLSHOR.NE.0 means that in the horizontal plane only
                  ! the first and second order are fitted

      ISYM=0      ! ISYM.NE.0 means symmetry is assumed with respect to the
                  ! orbit plane

      DRAUSCHX=0.  ! absolute amplitudes of the noise superimposed on the
                   ! final coordinates and slopes (standard deviation)
      DRAUSCHY=0.  ! XF(1:2,I)=XF(1:2,I)+XRAN(1:2)*DRAUSCHX
                   ! XF(3:4,I)=XF(3:4,I)+XRAN(3:4)*DRAUSCHY
                   ! XRAN is normal random number
                   ! (test purposes, to simulate noise in tracking routine)
      STRAILEN=5.8 ! full length of straigth section

      $END

 $COLLIN ! CX1,...,HIG2 form a collimator for the spectrum
       ! calculations (just two rectangular pinholes)
       ! this collimator selects the sources taken into account
       ! Once having defined the sources, the collimator is ignored
       !
       ! The aperture given by APERX,...,APERHIG, is taken into
       ! account during the spectrum calculations. All
       ! contributions to the photon flux at a given observation point
       ! are ignored if a straight line from the electron to the
       ! observer does not pass the aperture

      CX1=9999.   ! (CX1,CY1,CZ1) is center of first pinhole [m,m,m]
                        ! 9999. means according to PINCEN(1) or OBSV(1,1)
      CY1=9999.      ! 9999. means according to PINCEN(2) or OBSV(2,1)
      CZ1=9999.      ! 9999. means according to PINCEN(2) or OBSV(3,1)
      WID1=9999.  ! width of first pinhole [m]
            ! 9999. WID1=PINW+4.*PINW/MPINZ
      HIG1=9999.  ! height of first pinhole [m]
            ! 9999. HIG1=PINH+4.*PINW/MPINY

      CX2=9999.       ! datas of second pinhole
                        ! 9999. means according to PINCEN(1) or OBSV(1,1)
      CY2=9999.
      CZ2=9999.
      WID2=9999.  ! 9999. WID2=PINW+4.*PINW/MPINZ
      HIG2=9999.  ! 9999. HIG2=PINH+4.*PINW/MPINY

      WGWINFC=9999.  ! defines source points; those parts of the trajectory
            ! are taken into account for which the radiation cone of
            ! opening angle +/- WGWINFG/GAMMA passes the collimator
            ! 9999. means WGWINFC is calculated by SR SETWGWIN

      WBL0CUT=0.0 ! cut on magnetic field; source starts at
            ! B > (WBL0CUT*WBL0HYS)
            ! source ends at B < WBL0CUT

      WBL0HYS=1.0 ! hysteresis for cut on magnetic field
            ! at beginning of source WBL0CUT-->WBL0CUT*WBL0HYS
            ! at end of the source WBL0CUT-->WBL0CUT/WBL0HYS

      IBL0CUT=0   ! for IBL0CUT greater zero source is split when the
            ! sign of the vertical magnetic field changes
            ! IBL0CUT=-1 means source points are accepted
            ! even for zero field
            ! IBL0CUT=-2 means whole trajectory is single source

      ISOUREXT=0  ! program extends source by ISOUREXT points
            ! to check if neighbouring sources overlap and
            ! should be treated as coherent source
                      ! ISOUREXT.LT.0 means to ignored occured errors
                      ! due to overlapping sources


      ! The following aperture works only for old version (ISPECMODE=3)
      APERX=-9999.   ! x-position of aperture, -9999. means equal to PINCEN(1)
      APERY=0. ! y-position of aperture
      APERZ=0.0   ! z-position of aperture

      APERWID=1.0d30  ! full width of aperture
      APERHIG=1.0d30  ! full hight of aperture

    $END

 $SPECTN ! complex polarization vector
         ! intensity is calculated from amplitude projected on this
         ! vector

+SELF,IF=-NOCMPLX.
      VPOLA(1)=(0.,0.)  ! linear horizontal     [(0,0),(0, 0),(-1,0)]
      VPOLA(2)=(0.,0.)  ! right handed circular [(0,0),(0,-1),( 1,0)]
      VPOLA(3)=(-1.,0.) ! left handed circular  [(0,0),(0,-1),(-1,0)]

      REFLEC(1)=(1.,0.) ! complex reflectivity coefficients
      REFLEC(2)=(1.,0.)    ! the field amplitude is multiplied with
      REFLEC(3)=(1.,0.)    ! these coefficients
+SELF,IF=NOCMPLX.
      VPOLAR(1)=0.   ! linear horizontal     [(0,0),(0, 0),(-1,0)]
      VPOLAI(1)=0.   ! linear horizontal     [(0,0),(0, 0),(-1,0)]
      VPOLAR(2)=0.   ! linear horizontal     [(0,0),(0, 0),(-1,0)]
      VPOLAI(2)=0.   ! linear horizontal     [(0,0),(0, 0),(-1,0)]
      VPOLAR(3)=-1.  ! left handed circular  [(0,0),(0,-1),(-1,0)]
      VPOLAI(3)=0.   ! left handed circular  [(0,0),(0,-1),(-1,0)]

      REFLECR(1)=1.  ! complex reflectivity coefficients
      REFLECR(2)=1.  ! the field amplitude is multiplied with
      REFLECR(3)=1.  ! these coefficients
      REFLECI(1)=0.  ! complex reflectivity coefficients
      REFLECI(2)=0.  ! the field amplitude is multiplied with
      REFLECI(3)=0.  ! these coefficients
+SELF.

      NPOLMX=6 ! max. number of poles
            ! (array dimension for, F90 only, replaces NDPOLP)

      XWALLI=0.   ! begin of beamline for power density calculations
      XWALLE=15.  ! end of beamline for power density calculations
      WALL(1)=+0.05  ! z-positions of beamline walls
      WALL(2)=-0.05  ! (WALL(1) .GE. WALL(2))

      XABSORB=9999.  ! x-position of absorber normal to beamline
            ! =9999. means XABSORB=XWALLE
      ZABSORB(1)=2.   ! upper edge (z) of absorber
            ! =9999. means ZABSORB(1)=WALL(1)
      ZABSORB(2)=-2.   ! lower lower edge (z) of absorber
            ! =9999. means ZABSORB(2)=WALL(2)

      NPWALL=1000 ! number of points on beam line wall for plots

      POWBCUT=0.025  ! cut on magnetic field to find poles
            ! if B < POWBCUT the corresponding part of the
            ! trajectory is ignored
            ! cut should not be too small to avoid problems
            ! in subroutine BEAMPOW
            ! maybe the product MYINUM * POWCUT is a criterion
                        ! POWCUT*MYINUM .GE. 25
      $END

 $WFOLDN    ! to apply emittance folding procedure to spectrum

            ! Reference Paul Goslawki, Jul 2019:
            ! High Beta:
            !
            !
            !           epsilon_x = 7.70E-9 m-rad
            !           epsilon_y = 1.54e-10 m-rad
            !
            !           sigma_x  = 275.e-6 m
            !           sigma_xp = 28e.1-6 rad
            !           sigma_y = 22.5e-6 m
            !           sigma_yp= 6.80e-6 rad

            ! Reference:
            ! Einige_Parameter_der_Elektronenoptik_beim_Top.doc
            ! Sigmas include dispersion

            ! natural emittance  epsilon_n = 5.34E-9 m-rad
            ! hori. emittance    epsilon_n = 5.34E-9 m-rad
            ! vert. emittance    epsilon_n = 8.01E-11 m-rad
            ! 1.5 % coupl.

            ! high beta:

            !     beta_x   = 8.71 m
            !     sigma_x  = 216.e-6 m
            !     sigma_xp = 24.8e-6 rad

            !     SIG_X_10m = 329.e-6 m

            !     beta_y  = 4.36 m
            !     sigma_y = 18.7e-6 m
            !     sigma_yp= 4.29e-6 rad

            !     SIG_Y_10m = 46.8E-6 m

            ! low beta:

            !     beta_x   = 0.96 m
            !     sigma_x  = 71.6e-6 m
            !     sigma_xp = 74.6e-6 rad

            !     SIG_X_10m = 749.4e-6 m

            !     beta_y  =  1.23 m
            !     sigma_y =  9.93e-6 m
            !     sigma_yp = 8.07e-6 rad

            !     SIG_Y_10m = 81.3e-6 m

            ! if not zero WSIGZ-values are overwritten!!

      BSIGZ(1)=275.e-6  ! horizontal beam size [m]
      BSIGZP(1)=28.1e-6 ! horizontal beam divergency [rad]

                        ! if not zero WSIGY-values are overwritten!!
      BSIGY(1)=22.5e-6  ! vertical beam size [m]
      BSIGYP(1)=6.80e-6 ! vertical beam divergency [rad]

      WSIGZ(1)=329.e-6 ! sigmas of Gaussians for folding
             ! if ISIGUSR is set
             ! values are overwritten if BSIGZ or BSIGZP
             ! not zero according to
             ! WSIGZ=SQRT(BSIGZ**2+(PINCEN(1)*BSIGZP)**2)

      WSIGY(1)=46.8E-6 ! the same for the verticale direction
             ! values are overwritten if BSIGY or BSIGYP
             ! not zero according to
             ! WSIGY=SQRT(BSIGY**2+(PINCEN(1)*BSIGYP)**2)

             ! *** IF VALUES ZERO FOR FURTHER SOURCES,
             ! *** VALUES A TAKEN FROM FIRST SOURCE.

      DGSIGZ(1)=3.     ! number of sigmas taken into account for folding
      DGSIGY(1)=3.

      NGFOURZ=5    ! the Gaussians are approximated by Fourier expansion
      NGFOURY=7    ! these parameter give the number of used coefficients
                   ! (OBSOLETE, only for IFOLD=-1 OR IFOLD=-2)

      ISIGSTO=1    ! sigmas for folding of STOKES vectors are taken
                   ! form source point ISIGSTO
                   ! ISIGSTO=0 means ISIGSTO=1

      SIGRC=0.841  ! empirical correction factor for SIGR

                ! SIGR=SQRT(2*LAMBDA*L)/2/PI*SIGRC
                ! needed for brilliance estimations
                ! Walker agrees with WAVE flux, but brilliance is
                ! twice that of WAVE
                !
                ! Kim: SIGRC=1/2/SQRT(2)
                ! SIGRC=0.353553, i.e. Faktor of 8 in brilliance,
                ! for zero emittance

              ! Try 1./sqrt(sqrt(2.)) = 0.841

      SIGRPC=0.841 ! empirical correction factor SIGRP
                ! SIGRP=SQRT(LAMBDA/2/L)*SIGRPC

                ! needed for brilliance estimations
                ! Kim: SIGRC=SQRT(2)
                ! SIGRPC=1.414D0
                ! Kim: SIGRC=SQRT(2)
                ! SIGRC=1.4142136, i.e. Faktor of 2 in flux,
                ! for zero emittance, which corresponds to the real
                ! maximum of the flux, not to that, where the
                ! brilliance has its maximum

              ! Try 1./sqrt(sqrt(2.)) = 0.841

      ESPREAD=0.001  ! rel. energy spread of the beam (for energy folding)
      NSIGE=3        ! number of sigmas for energy folding

      $END

 $BUNCHN

 !*** Still experimental!! Check results carefully ***!

      NBUNCH=1        ! Number of bunches

      NEINBUNCH=1     ! NEINBUNCH particles are treated coherently

      ILINTRA=0       ! >0: read linear transfer matrices from file
                      ! wave_lintra.dat
               ! <0: write linear transfer matrices to file
               ! wave_lintra.dat
               ! Note: This matrix transforms from the
               ! beginning of the source (not necessaryly XSTART) to
               ! XLINTRA, NOT to the end
               ! ISPEC and IBUNCH must not be zero
               ! The matrix is calculated from BETAH, BETAPH,
               ! BETAV, and BETAPV, which must correspond to XLINTRA
               ! BSIGZ, BSIGZP, BSIGY, and BSIGYP must
               ! be consistant with the beta-functions at XLINTRA

      XLINTRA=-9999.  ! x [m], where the alphah and alphav are zero, i.e.
                      ! minima or maxima of the beta-functions.
                      ! -9999. means source center
                      ! XLINTRA must lay within the source

      BUNCHLEN=1000.0d-9  ! Length [m] of a  bunch.
                          ! The phase of the field amplitude of each particle
                          ! is affected by BUNCHLEN.
              ! =0: Also in this case the phase of the field
              !     is randomized for each bunch
              ! <0: No global phase randomization for bunches
              !*** Since there is a variety of
              ! combinations of IAMPLI, IMAMPLI, IBUNCH, IUBUNCH
              ! etc., there might be an unexpected behaviour.
              ! Please, be careful and watch the effects
              ! on the field amplitude and the flux-densities

      IUBUNCH=0   ! to calculate phase space distribution of electrons
                  ! *** The principle trajectory from XSTART
           ! etc. is taken as the center of the phase-space,
           ! i.e. the coordinates and velocity are added to the
           ! generated ones.
           !
           ! 0: Gaussian distribution according to BSIGZ, BSIGY
           !    etc. in namelist WFOLDN
           !
           ! 1: Gaussian distribution according to
           !    ESP0H, BETAH, BETAPH, and
           !    ESP0V, BETAV, BETAPV in namelist DEPOLA,
           !    which refer here to the beginning of the source.
           !    The might be different, depending e.g. on IAMPLI,
           !    so, please, check the source in wave.out
           !    and adjust the beta functions etc. accordingly.
           !    IFOLD must be zero, IBUNCH must be non-zero.
           !
           ! -1: user routine UBUNCH(x,y,z,yp,zp,gamma,dt),
           !     where x referes to the center of the bunch
           !
           ! 2: routine BUNCH(dt) for longitudinale
           !    distribution according to Saldin,
           !    NIM A 539 (2005) 499-526
           !    with parameters BUNCHP0, BUNCHR56, NBUNCHHARM
           !    and AMPFREQ in namelist AMPLIN
           !
           ! 3: read phasespace distribution
           !    gamma,xbunch,x,y,z,dpy/p,dpz/p from
           !    file wave_phasespace.dat  (LUN=21)
           !
           ! 4: longitudinale distribution within bunch is read in
           !    terms of FOURIER-coefficients from file
           !    fourier-bunch.dat
           !
           !    Format:
           !    Lines starting with * in first column or empty
           !    lines are comments
           !    other lines give coefficients c1...cn for harmonics
           !    first nbunchharm coefficients are used

      BUNCHP0=250.d-6 ![GeV]
      BUNCHR56=30.d-6 !R56 [m]
      NBUNCHHARM=1   !number of harmonics of microbunching (IUBUNCH = 2)

      BUNCHCHARGE=-9999.   !charge per bunch [C]
                           !-9999.: BUNCHCHARGE is 1.60218E-19 * NEINBUNCH

      IBUNPHASE=0       ! Treatment of overall phase of single electron in
                        ! a bunch.
                        ! 1: For each photon energy the field is  phase-shifted
                        !    such, that the imaginary part of the amplitude Az
                        !    vanishes for observation point IOBUNCH.
                        !    THIS IS A FULLY COHERENT BEAM (within each bunch)

      IOBUNCH=-9999     ! number of reference observation point for IBUNPHASE=1
                        ! 0: IOBUNCH=ICBRILL, i.e. selected point according to
                        ! IPBRILL
                        ! -9999: IOBUNCH is taken, where flux-density is highest

      IHBUNCH=1       ! to get N-tuple of beam IHBUNCHth electrons
                      ! for KAMPLI > 0, only first thread is considered
               ! if AMPREP_OMP is called

      IWBUNCH=0       ! write distribution of iwbunch electrons to file
                      ! wave_phasespace_bunch.dat (LUN=22)
                      ! (gamma,xbunch,x,y,z,dpy/p,dpz/p)

      $END

 $PINHOLE   ! rectangular pinhole for spectrum calculations
            ! or single observation points are defined here

      RPINSPH=0.0d0  ! use part of a sphere rather than plain pinhole
                     !-9999.: RPINSPH=PINCEN(1)

      PINCEN(1)=10.  ! x-center of pinhole [m]

      PINCEN(2)=9999.   !y-center of pinhole [m]
            !9999. means centered according to IPBRILL, such
            !that corner or center is on-axis
            !-8888. means centered according to
            !set according to straight line fit of trajectory
            !between XIANF and XIEND
            !-9999. means centered according to
            !YSTART+VYIN/VXIN*(PINCEN(1)-XSTART)
            !-9000. means estimate position by averaging
            ! y(x)+vy(x)/vx(x)*(x-pincen(1))

      PINCEN(3)=9999. !z-center of pinhole [m]
            !9999. means centered according to IPBRILL, such
            !that corner or center is on-axis
            !-8888. means centered according to
            !set according to straight line fit of trajectory
            !between XIANF and XIEND
            !-9999. means centered according to
            !ZSTART+VZIN/VXIN*(PINCEN(1)-XSTART)
            !-9000. means estimate position by averaging
            ! z(x)+vz(x)/vx(x)*(x-pincen(1))

      IPBRILL=0 ! observation point inside pinhole for brilliance calculations
            ! =0 center of pinhole
            ! =1 lower left corner
            ! =2 lower right corner
            ! =3 upper right corner
            ! =4 upper left corner
                      ! if no pinhole specified first (IPBRILL=0)
                      ! or observation point IPBRILL is taken

      MPINZ=21  ! number of horizontal grid points, if OBSVDZ is zero,
                ! otherwize calculated from PINW and OBSVDZ
      MPINY=21  ! number of vertical grid points, if OBSVDY is zero,
                ! otherwize calculated from PINH and OBSVDY

       ! for undulator radiation it might be useful to use
       ! cylindrical grid for observation points.
       ! If MPINR is not zero, this option is assumed

      MPINR=0 ! number of radial grid points, if OBSVDR is zero,
            ! otherwize calculated from PINRAD and OBSVDR
            ! if 9999, MPINR is set to max(MPINZ,MPINY)*sqrt(2)


      MPINPHI=16   ! number of azimuthal grid points, if OBSVDPHI is zero

      MEDGEZ=1 ! outer edge outside of pinhole to avoid edge effects
      MEDGEY=1 ! must be at least 1

      MMEDGEZ=0   ! inner edge outside of pinhole to avoid edge effects
      MMEDGEY=0   ! may be 0

      OBSVDZ=0.   ! horizontal mesh width in pinhole
                  ! (is calculated from PINW and MPINZ if zero)
      OBSVDY=0.   ! vertical mesh width in pinhole
                  ! (is calculated from PINH and MPINY if zero)

      PINW=0.003   ! width of pinhole [m]
                   ! 9999. means automatic calculation if flag
                   ! IUNDULATOR is not zero
      PINWSC=1.    ! to scale PINW

      PINH=0.003   ! height of pinhole [m]
                   ! 9999. means automatic calculation if flag
                   ! IUNDULATOR is not zero
      PINHSC=1.    ! to scale PINH

      PINR=-9999.  ! radius of circular pinhole [m]
                   ! if PINR=-9999., PINR is set to max(PINW/2.,PINH/2.)
                   ! if PINR=9999., PINR is set to sqrt(PINW*PINH/PI)

      PINRAD=9999. ! radius of circular pinhole for routine SOUINTRPHI [m]
                   ! triggered by MPINR.NE.0
                   ! if 0., PINRAD is set to PINR
                   ! if 9999., PINRAD is set to
                   ! sqrt(obsvy(nobsv)**2+obsvz(nobsv)**2)

      OBSVDR=0.   ! radial mesh width in pinhole
                  ! (is calculated from PINRAD and MPINR if zero)
                  ! OBSVDR=9999. means OBSVDR=min(OBSVDZ,OBSVDY)

      OBSVDPHI=0. ! angle steps [degree]
                  ! (is calculated from MPINR if zero)

        IQUADPHI=0   ! if not zero, phi is limited to 90 degree, i.e.
                     ! first quadrant of pinhole, and 4-fold symmetry is
                     ! assumed

      IRFILOB=0   ! =1 to read list of observation points
                  ! from file FILEOB (IPIN must not be set)

      OBS1X=-9999. ! x-coordinate of single observation point [m]
                   ! -9999. means value from PINCEN(1)
      OBS1Y=0.0    ! y-coordinate of single observation point [m]
                   ! if IPIN and IRFILOB are not set
            !-9999. means centered according to
            !YSTART+VYIN/VXIN*(PINCEN(1)-XSTART)
            !-8888. means centered according to
            !set according to straight line fit of trajectory
            !between XIANF and XIEND
            !-9000. means estimate position by averaging
            ! y(x)+vy(x)/vx(x)*(x-pincen(1))
      OBS1Z=0.0    ! z-coordinate of single observation point [m]
                   !-9999. means centered according to
            !ZSTART+VZIN/VXIN*(PINCEN(1)-XSTART)
            !-8888. means centered according to
            !set according to straight line fit of trajectory
            !between XIANF and XIEND
            !-9000. means estimate position by averaging
            ! z(x)+vz(x)/vx(x)*(x-pincen(1))

    $END

 $FREQN     !photon energies in eV for spectrum calcualtions

      FREQLOW=105. !lowest photon energy for spectrum calculations
            ! -9999. means automatic calculation if flag
            ! IUNDULATOR is not zero (estimation might fail,
            ! if mag. field is not strictly periodic)

      FREQHIG=117. !highest photon energy for spectrum calculations
            ! -9999. means automatic calculation if flag
            ! IUNDULATOR is not zero (estimation might fail,
            ! if mag. field is not strictly periodic)
            ! for IFREQ2P=1, FREQHIG-FREQLOW is the bin size of
            ! the spectrum histograms

      NINTFREQ=13  !number of photon energies for IFREQ2P>2 (namelist CONTRL)

      FRSCALE=1.   !scaling factor for window [FREQLOW,FREQHIG]
                   !i.e. center and width are scaled to get higher
                   !harmonics
                   !<0: FREQLOW, FREQHIG, and NINTFREQ are scaled

      IFILTER=0    !absorbing filter is applied to spectrum
                   !absorption coefficients on file FILEABS
                   !IFILTER = 1: F(X)=AA*X**BB interpolation of coef.
                   !IFILTER > 1: linear interpolation of coef.
                   !IFILTER < 0 means files of list FILEAM are merged
                   !IFILTER = -1: F(X)=AA*X**BB interpolation of coef.
                   !IFILTER < -1: linear interpolation of coef.
                   !by SR ABSCOEF_MERGE and written to file FILEAMO

      IFILMUL=0    !IFILMUL = N:  N absorbing filters are applied to
                   !spectrum. Filter thicknesses and filenames
                   !of coefficient files are read from FILEAM

      IEFFI=0      !detector efficiency filter is applied to spectrum
                   !factors are read from file FILEFF
                   !IEFFI > 0: spline interpolation of yield function
                   !IEFFI = -1: F(X)=AA*X**BB interpolation
                   !IEFFI < -1: linear interpolation

      IHFIL=0     !Ntuples of absorption coefficients

      SPECCUT=0.  !if the photon energy exceeds SPECCUT times the critical
                  !energy belonging to the maximal field strength of the
                  !source point, the flux is set to zero in SR SOUADD
                  !SPECCUT=0. means option is ignored.

      ABSTHI=0.002   !thickness of absorber [m]
      AREAM2=628.D-6 !area of probe [m**2] for program DESYNC (flag IDESYNC)

      $END

 $WBTABN    ! to write magnetic field By and some integrals
            ! along straight line parallel to the x-axis
            ! of the device or along trajectory to file FILEWBT
            !
            ! File format FILEWBT:
            ! 1. line: Run number and CODE
            ! 2. line: Scaling factors vor X and BY
            ! 3. line: Number of following data lines
            ! Data lines: x By y z 1.Int(By) 2.Int(By) Int(
            !   1. Col.: x
            !   2. Col.: By
            !   3. Col.: y
            !   4. Col.: z
            !   5. Col.: first integral of By, i.e. Int(By,dx)
            !   6. Col.: second integral of By,
            !            i.e Int(Int(By,dx),dx)
            !   7. Col.: Int(dBy/dz,dx)
            !   8. Col.: Int(d2By/dz**2,dx)
            !   9. Col.: Int(d2Bz/dz**2,dx)
            !  10. Col.: Int(d2By/dy**2,dx)
            !  11. Col.: Int(d2Bz/dy**2,dx)
            !  12. Col.: Int(Int(d2By/dz**2,dx),dx)
            !  13. Col.: Int(Int(d2Bz/dz**2,dx),dx)
            !  14. Col.: Int(Int(d2By/dy**2,dx),dx)
            !  15. Col.: Int(Int(d2Bz/dy**2,dx),dx)
            !  16. Col.: Int(Ay,dx)
            !  17. Col.: Int(Az,dx)

            ! File format wbtab_sextupole.dat:
            ! 1. line: Run number and CODE
            ! 2. line: Number of data
            ! Data lines:
            !   1. Col.: x
            !   2. Col.: By
            !   3. Col.: y
            !   4. Col.: z
            !   5. Col.: d2By/dy**2
            !   6. Col.: d2By/dz**2
            !   7. Col.: d2Bz/dy**2
            !   8. Col.: d2Bz/dz**2

      BTABS=9999. ! x of first point (9999. means XSTART)
      BTABE=9999. ! x of last point (9999. MEANS XSTOP)
      BTABY=0.0   ! y of first point
      BTABZ=0.0   ! z of first point

      NPWBTAB=9999   ! number of points
                     ! (the trajectory is recalculated with this number)
                     ! 9999 means number of points of main  trajectory taken

      BTABEPS=0.1E-3 ! epsilon for numerical differentiations
      $END

 $RECN

      BCRAN=0.0 ! sigma of rel. random noise on BC(IMAG)
                ! BCRAN.lt.0 means 1.+BCRAN is scaling factor without
                ! random noise (see also NURANMOD)

      BCRANSIG=1000.0 ! allowed max. for BCRAN (in multiple of rms-value)
                      ! if generated error exceeds BCRANSIG*BCRAN it's
                      ! generated once again

      IRECSEED=1  !seed for generation of random errors
                  ! *** obsolete, see, $RANDOMN ***

      K90270=0  ! K90270.ne.0 means BCRAN acts only on theta=90,270
                ! (only for NURANMOD.EQ.0)

      BCSTART=9999.   ! begin of random error region (9999. means no limit)
                      ! [mm]

      BCEND=9999. ! end of random error region (9999. means no limit)
                  ! [mm]

      WINREC=1.0  ! Window for calculation of magnetic field
                  ! of REC-structure (SR REC_BFELD) [m]

      RANGREC=1.0 ! Tracking starts and stops at distance RANGREC
                  ! from beginning and end of structure [m]
                  ! (only if XSTART, XSTOP = 9999.)

      SCALADD=0.  ! to scale strength of additional magnets on FILEREC
      SCALKL=0.   ! to scale strength of all but additional magnets

      IPLREC=1    ! write plotfile rec_plotm.eps

      RPLXMN=9999.   ! plotting range [mm]
      RPLXMX=9999.   ! 9999. means defaults used,
      !RPLXMN=-100.  ! plotting range [mm]
      !RPLXMX=100.   ! 9999. means defaults used,
      !RPLXMN=-2100. ! plotting range [mm]
      !RPLXMX=-2020. ! 9999. means defaults used,
      RPLYMN=9999.   ! minima and maxima
      RPLYMX=9999.   ! (or XSTART, XSTOP if -9999. in x)
      RPLZMN=9999.
      RPLZMX=9999.

      RECGAP=7.5  ! half gap [mm]
      USHIFT= 0.0 ! shift parameter [mm]

      DSHIFT=0.0  ! additional row shift [mm]

      IRECMODU=0  ! call to special modulator routine

      IHTAPER=0   ! to apply horizontal taper function to pos. of mags.
                  ! function is given as two columns table in file
                  ! FILEFTH
                  ! Format:
                  ! 1. comment
                  ! 2. x-scale-factor, y-scaling-factor
                  ! 3. data lines

      IVTAPER=0 ! to apply vertical taper function to pos. of mags.
                ! function is given as two columns table in file
                ! FILEFTV
                ! Format:
                ! 1. comment
                ! 2. x-scale-factor, y-scaling-factor
                ! 3. data lines

      IRECU=0   ! IRECU is number of additional simple undulator

      NURANMOD=1  ! modus for field error generation:
                  ! 0: BCRAN is applied as explained above, no special
                  !    treatment of additional undulators
                  ! 1: BCRAN is applied for additional undulators
                  !    in a -B/2,+B,-B/2 scheme
                  ! 2: BCRAN is applied for additional undulators
                  !    in a +B,-B scheme
                  ! 3: BCRAN is applied for additional undulators,
                  !    for each pole errors are generated,
                  !    kick is compensated by endpoles
                  !    (planar devices only, so far)
                  ! 4: same as 3, but in addition offset is
                  !    compensated by first endpole

      KRECPER(1)=30   ! number of periods

      URECLX(1)=14.   ! length of magnets [mm]
      URECLY(1)=40.   ! height of magnets [mm]
      URECLZ(1)=40.   ! width of magnets [mm]
      URECGAP(1)=11.6 ! half gap of undulator [mm]
      UTAPER(1)=0.    ! taper (dy/dx of half gap)
      URECCX(1)=0.    ! center in x of undulator [mm]
      URECCZ(1)=0.    ! center in z of undulator [mm]
      URECBC(1)=1.22  ! remanence of magnets [T]
      UBANGERR(1)=0.0 ! angle error of magnets [degree]
      UBANSIG(1)=1000.0  ! allowed max. for UBANGERR (in multiple of rms-value)
                         ! if generated error exceeds UBANSIG*UBANGERR it's
                         ! generated once again
      USIGOFFY(1)=0.0 ! allowed offset for accumulated errors
                      ! if the sum of the accumulated Gaussian random numbers
                      ! exceeds UBANGERR, the center of the Gaussian errors
                      ! will be shifted such that the trajectory comes back
                      ! to the orbit plane.
                      ! Set to 1.e30 if zero

      IUHELI(1)=1     ! helical undulator
                      ! positive value means S3 mode
                      ! negative value means S2 mode
      URSPLIT(1)=0.8  ! horizontal distance of rows for helical undulator [mm]
      URSHIFT(1)=10.  ! rowshift for helical undulator [mm]
                      ! lower-left (+URSHIFT) and upper-right (-URSHIFT)
                      ! rows are shifted
      URSHADD(1)=0.   ! additional shift for lower rows [mm]

      IKRESTOR=0      ! <0 means magnet strukture is stored on
                        ! rec.store
                        ! >0 means magnet strukture is read form
                        ! rec.restore
                        ! The file format looks like:
                        ! First line: Run number and comment of the
                        ! writing WAVE run
                        ! Second line: Number of blocks
                        ! Then follow three lines for each block:
                        !   1: dimensions in x,y,z in mm
                        !   2: the polar and azimuthal angles of the mag. axis
                        !   with respect to the vertical and the remanence
                        !   3: position x,y,z
    $END

 $MODUN

      SCALMOD=1.      ! scaling factor for modulator field
      SCALRAD=1.      ! scaling factor for radii of magnets
      SCALTHE=1.      ! scaling factor for theta of magnets

      NMAGMOD=16  ! number of modulator magnets
      NSLICE=51   ! number of slices per magnet

      RADIMOD(1) =6.3   ! radius of magnet [mm]
      RADIMOD(2) =6.3   ! radius of magnet [mm]
      RADIMOD(3) =6.3   ! radius of magnet [mm]
      RADIMOD(4) =6.3   ! radius of magnet [mm]
      RADIMOD(5) =11.   ! radius of magnet [mm]
      RADIMOD(6) =11.   ! radius of magnet [mm]
      RADIMOD(7) =11.   ! radius of magnet [mm]
      RADIMOD(8) =11.   ! radius of magnet [mm]
      RADIMOD(9) =11.   ! radius of magnet [mm]
      RADIMOD(10)=11.   ! radius of magnet [mm]
      RADIMOD(11)=11.   ! radius of magnet [mm]
      RADIMOD(12)=11.   ! radius of magnet [mm]
      RADIMOD(13)=6.3   ! radius of magnet [mm]
      RADIMOD(14)=6.3   ! radius of magnet [mm]
      RADIMOD(15)=6.3   ! radius of magnet [mm]
      RADIMOD(16)=6.3   ! radius of magnet [mm]

      ZLENMOD(1)=90. ! length in z of magnet [mm]
      ZLENMOD(2)=90. ! length in z of magnet [mm]
      ZLENMOD(3)=90. ! length in z of magnet [mm]
      ZLENMOD(4)=90. ! length in z of magnet [mm]
      ZLENMOD(5)=90. ! length in z of magnet [mm]
      ZLENMOD(6)=90. ! length in z of magnet [mm]
      ZLENMOD(7)=90. ! length in z of magnet [mm]
      ZLENMOD(8)=90. ! length in z of magnet [mm]
      ZLENMOD(9)=90. ! length in z of magnet [mm]
      ZLENMOD(10)=90.   ! length in z of magnet [mm]
      ZLENMOD(11)=90.   ! length in z of magnet [mm]
      ZLENMOD(12)=90.   ! length in z of magnet [mm]
      ZLENMOD(13)=90.   ! length in z of magnet [mm]
      ZLENMOD(14)=90.   ! length in z of magnet [mm]
      ZLENMOD(15)=90.   ! length in z of magnet [mm]
      ZLENMOD(16)=90.   ! length in z of magnet [mm]

      CENMODX(1) =-2086.   ! x of magnet center [mm]
      CENMODY(1) =+30.00       ! y of magnet center [mm]
      CENMODX(2) =-2086.   ! x of magnet center [mm]
      CENMODY(2) =-30.00       ! y of magnet center [mm]
      CENMODX(3) =-2046.   ! x of magnet center [mm]
      CENMODY(3) =+30.00       ! y of magnet center [mm]
      CENMODX(4) =-2046.   ! x of magnet center [mm]
      CENMODY(4) =-30.00       ! y of magnet center [mm]

      CENMODX(5) =-90.   ! x of magnet center [mm]
      CENMODY(5) =+30.00       ! y of magnet center [mm]
      CENMODX(6) =-90.   ! x of magnet center [mm]
      CENMODY(6) =-30.00       ! y of magnet center [mm]
      CENMODX(7) =-30.0   ! x of magnet center [mm]
      CENMODY(7) =+30.00       ! y of magnet center [mm]
      CENMODX(8) =-30.0   ! x of magnet center [mm]
      CENMODY(8) =-30.00       ! y of magnet center [mm]
      CENMODX(9) =30.0   ! x of magnet center [mm]
      CENMODY(9) =+30.00       ! y of magnet center [mm]
      CENMODX(10) =30.0   ! x of magnet center [mm]
      CENMODY(10) =-30.00      ! y of magnet center [mm]
      CENMODX(11) =+90.   ! x of magnet center [mm]
      CENMODY(11) =+30.00      ! y of magnet center [mm]
      CENMODX(12)=+90.   ! x of magnet center [mm]
      CENMODY(12)=-30.00       ! y of magnet center [mm]

      CENMODX(13) =2046.   ! x of magnet center [mm]
      CENMODY(13) =+30.00      ! y of magnet center [mm]
      CENMODX(14) =2046.   ! x of magnet center [mm]
      CENMODY(14) =-30.00      ! y of magnet center [mm]
      CENMODX(15) =2086.   ! x of magnet center [mm]
      CENMODY(15) =+30.00      ! y of magnet center [mm]
      CENMODX(16) =2086.   ! x of magnet center [mm]
      CENMODY(16) =-30.00      ! y of magnet center [mm]

      THEROT(1) =90.     ! rotation angle of magnet [degree]
      THEROT(2) =-90.       ! rotation angle of magnet [degree]
      THEROT(3) =-90.       ! rotation angle of magnet [degree]
      THEROT(4) =90.     ! rotation angle of magnet [degree]

        THEROT(5) =-90.00     ! rotation angle of magnet [degree]
      THEROT(6) =90.00      ! rotation angle of magnet [degree]
      THEROT(7) =90.00      ! rotation angle of magnet [degree]
      THEROT(8) =-90.00     ! rotation angle of magnet [degree]
      THEROT(9) =-90.00     ! rotation angle of magnet [degree]
      THEROT(10)=90.00      ! rotation angle of magnet [degree]
      THEROT(11)=90.00      ! rotation angle of magnet [degree]
      THEROT(12)=-90.00     ! rotation angle of magnet [degree]

      THEROT(13) =90.       ! rotation angle of magnet [degree]
      THEROT(14) =-90.      ! rotation angle of magnet [degree]
      THEROT(15) =-90.      ! rotation angle of magnet [degree]
      THEROT(16) =90.       ! rotation angle of magnet [degree]

      BCMOD(1) =1.22877642516581265e+00       ! strength of magnet [T]
      BCMOD(2) =1.22877642516581265e+00       ! strength of magnet [T]
      BCMOD(3) =1.22877642516581265e+00       ! strength of magnet [T]
      BCMOD(4) =1.22877642516581265e+00       ! strength of magnet [T]

      BCMOD(5) =1.22877642516581265e+00       ! strength of magnet [T]
      BCMOD(6) =1.22877642516581265e+00       ! strength of magnet [T]
      BCMOD(7) =1.22877642516581265e+00       ! strength of magnet [T]
      BCMOD(8) =1.22877642516581265e+00       ! strength of magnet [T]
      BCMOD(9) =1.22877642516581265e+00       ! strength of magnet [T]
      BCMOD(10)=1.22877642516581265e+00       ! strength of magnet [T]
      BCMOD(11)=1.22877642516581265e+00       ! strength of magnet [T]
      BCMOD(12)=1.22877642516581265e+00       ! strength of magnet [T]

      BCMOD(13)=1.22877642516581265e+00       ! strength of magnet [T]
      BCMOD(14)=1.22877642516581265e+00       ! strength of magnet [T]
      BCMOD(15)=1.22877642516581265e+00       ! strength of magnet [T]
      BCMOD(16)=1.22877642516581265e+00       ! strength of magnet [T]

      $END

 $UNDUHYBRIDN

    ! *** Please, also check variables in undumag.nam ***

    UNDUGAP_H=10.  ! full gap of undulator [mm]
    NPERIOD_H=4    ! number of periods
    NPERIODW_H=0   ! number of periods for WAVE,
                   ! i.e. if NPERIODW_H > NPERIOD_H, field is expanded

    UPERLEN_H=0.0    ! Period-length, calculated if <= 0  [mm]
    UMAGLX_H=13.9    ! length of main magnets [mm]
                     ! WILL BE OVERWRITTEN INF UPERLEN_H > 0
    UMAGLY_H=40.     ! height of main magnets [mm]
    UMAGLZ_H=40.     ! width of main magnets [mm]
    UMAGSPAC_H=0.1   ! spacer to next downstream pole [mm]
    UMAGCH_H=0.3     ! chamfer [mm]
    UCOATING_H=0.014 ! coating and dead layer of magnets

    UMAGBC_H=1.62   ! remanence of magnets [T]
    UMUPAR_H=1.03   ! mu parallel for linear REC material
    UKSIPER_H=0.17  ! ksi perpendicular for linear REC material

    NUMDIVX_H=3 ! number of divisions of magnets in X
    NUMDIVY_H=3 ! number of divisions of magnets in Y
    NUMDIVZ_H=3 ! number of divisions of magnets in Z, consider z-symmetry

    UPOLLX_H=6.9   ! length of main poles [mm]
    UPOLLY_H=35.   ! height of main poles [mm]
    UPOLLZ_H=30.   ! width of main poles [mm]
    UPOLCH_H=0.1   ! chamfer [mm]
    UPOLSPAC_H=0.1 ! spacer to next downstream magnet [mm]

    NUPDIVX_H=6 ! number of divisions of poles in X, consider x-symmetry
    NUPDIVY_H=5 ! number of divisions of poles in Y
    NUPDIVZ_H=12 ! number of divisions of poles in Z, consider z-symmetry

    FRACDIVFE_H=2.  ! factor for exponential vertical segmentation of poles
    FRACDIVFEZ_H=2. ! factor for exponential horizontal segmentation of poles

    IXSYM_H=1 ! x-symmetry
    IYSYM_H=1 ! y-symmetry
    IZSYM_H=1 ! z-symmetry

    ! List of special, non-periodic magnets and poles
    ! the easy axis of magnets is parallel or antiparallel
    ! to the x-axis, according to the sign of the material index

    NSPEC_H=1     ! number of special items

    USMAGLX_H(1)=13.9  ! length [mm]
    USMAGLY_H(1)=5.865898402796422   ! height [mm]
    USMAGLZ_H(1)=40.   ! width [mm]
    USMAGCH_H(1)=0.3   ! chamfer [mm]
    MSMAG_H(1)=1       ! material index (sign controls easy axis for magnets)
    USMAGSPAC_H(1)=0.1 ! spacer from to previous item  [mm]
    USMAGDY_H(1)=0.0   ! vertical offset [mm]

    USMAGLX_H(2)=6.9   ! length [mm]
    USMAGLY_H(2)=35.   ! height [mm]
    USMAGLZ_H(2)=30.   ! width [mm]
    USMAGCH_H(2)=0.1   ! chamfer [mm]
    MSMAG_H(2)=2       ! material index (sign controls easy axis for magnets)
    USMAGSPAC_H(2)=0.1 ! spacer to previous item  [mm]
    USMAGDY_H(2)=0.    ! vertical offset [mm]

    KXSTART_H=-1 ! 1: Use XELEC of UNDUMAG for XSTART (if XSTART =9999.)
                 !-1: Use xMapMin of UNDUMAG for XSTART (if XSTART =9999.)
    KXSTOP_H=-1  ! 1: Use XF of UNDUMAG for XSTOP (if XSTOP =9999.)
                 !-1: Use xMapMax of UNDUMAG for XSTART (if XSTART =9999.)

    UCORRTINY_H=0.001 ! x,y,z-shift for corrections of boundary errors [mm]

    URANDOX_H=0.0005  ! smear x for field calculations [mm]
    URANDOY_H=0.0     ! smear y for field calculations [mm]
    URANDOZ_H=0.0005  ! smear z for field calculations [mm]

    UWWINDOW_H=1000.  ! Only items with x-uwwindow <= x <= x+uwwindow contribute
                    ! to field at x [mm]

    ! The following files are expected in $WAVE/undumag

    CHUNDUMAG_H='undumag.exe'     ! Executable of UNDUMAG
    CHUNDUNAM_H='undumag_nam.tmp' ! template for namlist file undumag.nam
    CHUNDUIRON_H='Vanadium_Permendur_Radia.dat' ! Magnetization curve of iron

    ! Field map, check also IWBMAP and namelist BMAPN

    ! NOTE: XMAPMINU and XMAPMAXU can overwrite XSTART/XSTOP, see. KSTART below
    XMAPMINU_H=9999. ! xmin for field map [mm]
                   ! 9999.: Auto scaling
    XMAPMAXU_H=9999. ! xmax for field map [mm]
                   ! 9999.: Auto scaling
    DXMAPU_H=1.      ! Step size of field map in x [mm]
                   ! 9999.: Same as for Beff calculations, i.e. perlen/(nxbeff-1)
    NXMAPU_H=0       ! Number of steps in x, if dxmap is zero

    YMAPMINU_H=-3.0  ! ymin for field map [mm]
    YMAPMAXU_H= 3.0  ! ymax for field map [mm]
    NYMAPU_H=1       ! Number of steps for field map in y.
                   ! nymapu_H=1 means y=(ymapmax+ymapmin)/2 is used

    ZMAPMINU_H=-20.0 ! zmin for field map [mm]
    ZMAPMAXU_H= 20.0 ! zmax for field map [mm]
    NZMAPU_H=1       ! Number of steps for field map in z
                     ! nzmapu=1 means z=(zmapmax+zmapmin)/2 is used

    $END

 $UNDUMAGN

    ! *** Please, also check variables in undumag.nam ***

    NUNDUPER=7     ! number of periods of undulator
    NUNDUPERW=0    ! number of periods for WAVE,
                   ! i.e. if NUNDUPERW > NUNDUPER, field is expanded

    UNDUGAP=10.  ! full gap of undulator [mm]

    US2SHIFT=0. ! S2 shift [mm]
    US3SHIFT=10. ! S3 shift [mm]

    ! Field map, check also IWBMAP and namelist BMAPN

    ! NOTE: XMAPMINU and XMAPMAXU can overwrite XSTART/XSTOP, see. KSTART below
    XMAPMINU=9999. ! xmin for field map [mm]
                   ! 9999.: Auto scaling
    XMAPMAXU=9999. ! xmax for field map [mm]
                   ! 9999.: Auto scaling
    DXMAPU=1.      ! Step size of field map in x [mm]
                   ! 9999.: Same as for Beff calculations, i.e. perlen/(nxbeff-1)
    NXMAPU=0       ! Number of steps in x, if dxmap is zero

    YMAPMINU=-3.0  ! ymin for field map [mm]
    YMAPMAXU= 3.0  ! ymax for field map [mm]
    NYMAPU=1       ! Number of steps for field map in y.
                   ! nymapu=1 means y=(ymapmax+ymapmin)/2 is used

    ZMAPMINU=-20.0 ! zmin for field map [mm]
    ZMAPMAXU= 20.0 ! zmax for field map [mm]
    NZMAPU=1       ! Number of steps for field map in z
                   ! nzmapu=1 means z=(zmapmax+zmapmin)/2 is used

    UMAGLX=14.     ! length of magnets [mm]
    UMAGLY=40.     ! height of magnets [mm]
    UMAGLZ=40.     ! width of magnets [mm]

    UAIRGAP=0.1    ! airgap between magnets [mm]
                   ! period-length = 4 * (UMAGLX+AIRGAP)
    UCOATING=0.014 ! coating and dead layer of magnets

    UMAGBC=1.62    ! remanence of magnets [T]
    UMUPAR=1.03    ! mu parallel for linear REC material
    UKSIPER=0.17   ! ksi perpendicular for linear REC material
    UNDUSPLIT=0.8  ! horizontal distance of rows for helical undulator [mm]

    NUDIVX=1  ! number of divisions of magnets in X
    NUHDIVX=1 ! number of divisions of half magnets in X
    NUDIVY=3  ! number of divisions of magnets in Y
    NUDIVZ=3  ! number of divisions of magnets in Z

    KXSTART=-1 ! 1: Use XELEC of UNDUMAG for XSTART (if XSTART =9999.)
               !-1: Use xMapMin of UNDUMAG for XSTART (if XSTART =9999.)
    KXSTOP=-1  ! 1: Use XELEC of UNDUMAG for XSTOP (if XSTOP =9999.)
               !-1: Use xMapMax of UNDUMAG for XSTART (if XSTART =9999.)

    UCORRTINY=0.001   ! x,y,z-shift for corrections of boundary errors [mm]

    URANDOX=0.00002   ! smear x for field calculations [mm]
    URANDOY=0.0       ! smear y for field calculations [mm]
    URANDOZ=0.00005   ! smear z for field calculations [mm]

    UWWINDOW=1000.   ! Only items with x-uwwindow <= x <= x-uwwindow contribute
                     ! to field at x [mm]

    ! The following files are expected in $WAVE/undumag
    CHUNDUMAG='undumag.exe'     ! Executable of UNDUMAG
    CHUNDUNAM='undumag_nam.tmp' ! template for namlist file undumag.nam

    $END

 $POLYMAGN

       BSCALEPM=1.         ! Scaling factor for mag. field
       WINPM=1.0           ! Window in x for calculation of magnetic field [m]
       RANGPM=0.5          ! Tracking starts and stops at distance RANGPM
                           ! from beginning and end of structure [m]
                           ! (only if XSTART, XSTOP = 9999.)

               ! all sift values are added to those of polymag.in
       SHIFTLL=0.    ! shift of lower-left magnets
       SHIFTLR=0.    ! shift of lower-right magnets
       SHIFTUL=0.    ! shift of upper-left magnets
       SHIFTUR=0.    ! shift of upper-right magnets

       GAPPM=20.     ! full gap [mm]; value is added to y-pos. of magnets

       FILEPM='polymag.in' ! input file for POLYMAG routines

       IBPNOWARN=0         ! to suppress annoying warnings
 $END

 $BMAPN

   IBMAPX=1      ! x-component
                 ! 1 means written
          ! 0 means not written i.e. set to -9999.
   IBMAPY=1      ! y-component
   IBMAPZ=1      ! z-component

   IBMRADIAL=0
                 ! X is taken as radial coordinate [m]
          ! Y is taken as azimuth angle [degree]
          ! IBMRADIAL=2:
          ! Z is taken as radial coordinate [m]
          ! Y is taken as azimuth angle [degree]

   BMRADX0=0.0   ! X/Z center of radial map
   BMRADY0=0.0   ! Y center of radial map

   XMAPMN=9999.  ! xmin of map (9999. means XSTART taken)
   XMAPMX=9999.  ! xmax of map (9999. means XSTOP taken)
   NMAPX=-9999   ! number of data points in x
                 ! -9999 means: NMAXP=(XSTOP-XSTART)*MYINUM
                         !
   YMAPMN=-0.007 ! ymin of map
   YMAPMX=+0.007 ! ymax of map
   NMAPY=3       ! number of data points in y
                         !
   ZMAPMN=-0.03  ! zmin of map
   ZMAPMX=+0.03  ! zmax of map
   NMAPZ=31      ! number of data points in z

   IWBMAPEXT=0   ! to extend fitted field map for IWBMAP = 4

   $END

 $BAMWLSN

        MBAMWLS=0       ! mode:
                        ! 0: field map
                        ! 1: btab

        CORRMS=1.       ! scaling for side poles
        CORRMM=1.       ! scaling for main pole

        CURRL=97.6585   ! current of upstream corrector [A]
        CURRR=13.22435  ! current of downstream corrector [A]

        CORRL=1.0      ! field correction factor of upstream corrector [A]
        CORRR=1.03264  ! field correction factor of downstream corrector [A]

        XCORRL=-1.035  ! X-position of upstream steerer [m]
        XCORRR=1.735   ! X-position of downstream steerer [m]

        XLCORRL=0.0     ! transversal fundamental length [m]
        XLCORRR=0.0     ! transversal fundamental length [m]

        $END

 $BPOLY3DN

           X3DMIN=-0.02 ! Xmin of fitted region (9999. lowest x taken)
           X3DMAX=0.02  ! Xmax of fitted region (9999. largest x taken)
           Y3DMIN=-0.007 ! Ymin of fitted region (9999. lowest y taken)
           Y3DMAX=0.007 ! Ymax of fitted region (9999. largest y taken)
           Z3DMIN=0.02 ! Zmin of fitted region (9999. lowest z taken)
           Z3DMAX=0.03 ! Zmax of fitted region (9999. largest z taken)

           XYZ3DSC=100.D0 ! scaling factor for x,y, and z

           LORD3D=1     ! lowest used order of polynomial potential
           MORD3D=10     ! highest used order of polynomial potential
           NDORD3D=1    ! step of used orders of polynomial potential

           IHBPOLY3D=0  ! Ntuple of fitted field or field map of SR WBMAP

           $END

 $BPOLY2DHN

           NORD2DH=13    !harmonical order of fit

         PERLEN2DH=0.212 !period length [m]
         PHASE2DH=0.25  !long. shift:
             !X is set to X+PERIODLENGTH*X2DHSHIFT for
             !the fitting and field calculations
             !this is done before scaling with XYZ2DH

           X2DHMIN=9999. ! Xmin of fitted region (9999. lowest x taken)
           X2DHMAX=9999. ! Xmax of fitted region (9999. largest x taken)
           Y2DHMIN=9999. ! Ymin of fitted region (9999. lowest y taken)
           Y2DHMAX=9999. ! Ymax of fitted region (9999. largest y taken)
           Z2DHMIN=-0.02 ! Zmin of fitted region (9999. lowest z taken)
           Z2DHMAX=0.02 ! Zmax of fitted region (9999. largest z taken)
             ! this values refere to the unshifted data!!

           XYZ2DH=100.D0  ! scaling factor for x,y, and z

           IHBPOLY2DH=0  !Ntuple of fitted field or field map of SR WBMAP

           $END

 $BPHARMN

         NTRANS0=1   !lowest transversal order of fit
         NTRANS=21   !highest transversal order of fit
         NTRANSD=2   !increment of transversal order of fit

         NHARM0=1 !lowest longitudinal order of fit
         NHARM=21 !highest longitudinal order of fit
         NHARMD=2 !increment of longitudinal order of fit
            !even orders correspond to horizontal sine-like fields??
            ! VS:=-B0S/KXS(N,NXY)*COS(NXY*KYS*Y)
                        !    *SINH(KXS(N,NXY)*X)*SIN(N*KZ*Z)

           PERLENPH=0.212 !period length [m]
           PHASEPH=0.    !long. shift:
                         !X is set to X+PERIODLENGTH*XPHSHIFT for
                         !the fitting and field calculations

           XPHMIN=9999. ! Xmin of fitted region (9999. lowest x taken)
           XPHMAX=9999. ! Xmax of fitted region (9999. largest x taken)
           YPHMIN=9999. ! Ymin of fitted region (9999. lowest y taken)
           YPHMAX=9999. ! Ymax of fitted region (9999. largest y taken)
           ZPHMIN=-0.03 ! Zmin of fitted region (9999. lowest z taken)
           ZPHMAX=0.03 ! Zmax of fitted region (9999. largest z taken)
                         ! this values refere to the unshifted data!!

           XLENCPH=9999.  !Lambda_x of cos-like device [m]
            !x here horizontal coordinate
            !9999. means horizontal fit-range
           YLENSPH=9999.  !Lambda_y of sin-like device [m]
            !9999. means vertical fit-range

           IHBPHARM=0  !Ntuple of fitted field

           $END

 $BGRIDN
+self,if=-mshhbook.
            NTUPGRID=0  ! NTUPGRID greater than zero means read field from
                        ! Ntuple on file FILEB0
                        ! NTUPGRID equal zero otherwise column format is
                        ! assumed for file
                        ! NTUPGRID lower zero creates Ntuple of read map
+self.
            MORD3DG=3   ! polynomial order in potential of fit coefficients
            NBMDATX=4   ! number of data points in x-direction for fit
            NBMDATY=4   ! number of data points in y-direction for fit
            NBMDATZ=4   ! number of data points in z-direction for fit

            $END

 $SPECDIPN !(option ISPECDIP)

            NDIP=1      ! number of dipoles (limited to 100)
            BXDIP(1)=0.0   ! field strength of dipoles [T]
            BYDIP(1)=1.3   ! field strength of dipoles [T]
            BZDIP(1)=0.0   ! field strength of dipoles [T]
                           ! *** only the field perpendicular to
               ! (VXDIP,VYDIP,VZDIP) is used
            X0DIP(1)=0.0   ! x-position of source i.e. tangent point [m]
            Y0DIP(1)=0.0   ! Y-position of source [m]
            Z0DIP(1)=0.0   ! Z-position of source [m]
            VXDIP(1)=1.0   ! velocity vector of electron at source (a.u)
            VYDIP(1)=0.0   ! velocity vector of electron at source (a.u)
            VZDIP(1)=0.0   ! velocity vector of electron at source (a.u)

            APERTHICK=0.0  ! thickness of aperture pinhole [m]
            APERHANG=0.0   ! horizontal angle of aperture pinhole [rad]
            APERVANG=0.0   ! vertical angle of aperture pinhole [rad]
                           ! option is only valid for small angles, i.e.
               ! cos(x) approximatly 1

            $END

 $BFORCN

      BFCENX=0.0  !x-position of volume center
      BFCENY=0.0  !y-position of volume center
      BFCENZ=0.0  !z-position of volume center

      BFLENX=1.   !Length of volume [m]
      BFLENY=1.   !height of volume [m]
      BFLENZ=1.   !width of volume

      TORQCENX=0.0 !x-position of reference point for torques
      TORQCENY=0.0 !y-position of reference point for torques
      TORQCENZ=0.0 !z-position of reference point for torques

      NBFORCX=1   !number of longitudinal intervalls
      NBFORCY=1   !number of vertical intervalls
      NBFORCZ=1   !number of intervalls in z

      $END

 $PHASEN

        PHCENX=0.0      !x of source plan center
        PHCENY=0.0      !y of source plan center
                        !-9999: PHCENY=YSTART+VYIN/VXIN*(PHCENX-XSTART)
        PHCENZ=0.0      !z of source plan center
                        !-9999: PHCENZ=ZSTART+VZIN/VXIN*(PHCENX-XSTART)

        PHWID=-9999.    !full width of source plan
                        !-9999.: Estimated from device length and photon energy
        PHHIG=-9999.    !full heigth of source plan
                        !-9999.: Estimated from device length and photon energy

                        !The fields calculated for the NPHASEZ x NPHASEY
                        !points. The other points given be MPHASEZ, MPHASEY
                        !serve as edge for the folding procedure

        NPHASEZ=51      !number of horizontal mesh points
        NPHASEY=51      !number of vertical mesh points
        MPHASEZ=-9999   !total number of horizontal mesh points
                        !-9999: MPHASEZ according to dgsigz(1) and the
                        ! sigma of the Gaussian
        MPHASEY=-9999   !total number of vertical mesh points
                        !-9999: MPHASEY according to dgsigy(1) and the
                        ! sigma of the Gaussian

        IPHFOLD=1       !Folding of flux-density distribution according
                        !to beta functions PHBETH and PBETV, and the
                        !emittances EPS0H and ESP0V of namelist DEPOLA
                        !>0: use util_function_fold_gauss(...)
                        !<0: use util_function_fold_gauss_lin(...)
        PHBETH=-9999.   !Hori. beta-function at PHCENX
                        ! -9999.: Calculate via option IEMIT=1
        PHBETV=-9999.   !vert. beta-function at PHCENX
                        ! -9999.: Calculate via option IEMIT=1

        PHAPERZM=-1.   !neg. hor. phasespace cut (geom. optic)
        PHAPERZP=+1.   !pos. hor. phasespace cut (geom. optic)
        PHAPERZPM=-1.  !neg. hor. slope phasespace cut (geom. optic)
        PHAPERZPP=+1.  !pos. hor. slope phasespace cut (geom. optic)
        PHAPERYM=-1.   !neg. vert. phasespace cut (geom. optic)
        PHAPERYP=+1.   !pos. vert. phasespace cut (geom. optic)
        PHAPERYPM=-1.  !neg. vert. slope phasespace cut (geom. optic)
        PHAPERYPP=+1.  !pos. vert. slope phasespace cut (geom. optic)

        NPHELEM=0      !number of optical elements in beamline
                       ! phase space cuts PHAPER... are applied first
                       ! PHELEM(1:4,1:4,n) is matrix of optical
                       ! element n
                       ! PHELEM(5,1:4,n) is phase space aperture of
                       ! optical element n
        PHELEM(1,1,1)=1.
        PHELEM(2,2,1)=1.
        PHELEM(3,3,1)=1.
        PHELEM(4,4,1)=1.
        PHELEM(5,1,1)=1.   !low aperture in z
        PHELEM(5,2,1)=1.   !high aperture in z
        PHELEM(5,3,1)=1.   !low aperture in y
        PHELEM(5,4,1)=1.   !high aperture in y

        IHSEL=0     !to get histograms of integrated phasespace

      $END

 $PHASEREPN

      NOEMITPH=0       ! Emittance is ignored
      NOESPREADPH=0    ! E-spread is ignored

      PHRPERL=9999.0d0  ! period-length  [m]
                       ! 9999: Value of namelist ELLIPN is taken
      PHRB0H=9999.0d0   ! horizontal field amplitude [T]
                       ! 9999: Value of namelist ELLIPN is taken
      PHRB0V=9999.0d0   ! vertical field amplitude [T]
                       ! 9999: Value of namelist ELLIPN is taken
      PHRSHIFT=9999.0D0 ! Shift for elliptical undulator (fraction of the period-length)
                       ! 9999: Value of namelist ELLIPN is taken
+self,if=phdx.
                    ! [PHDX,PHDY,PHDZ] will be normalized to one
      PHDX=9999.0D0 ! x of normal vector for spacing of periods
                    ! 9999.: phdx=vx at entrance of amprep or amprep_omp
      PHDY=9999.0D0 ! y of normal vector for spacing of periods
                    ! 9999.: phdy=vy at entrance of amprep or amprep_omp
      PHDZ=9999.0D0 ! z of normal vector for spacing of periods
                    ! 9999.: phdz=vz at entrance of amprep or amprep_omp
+self.
      PHRXBETA=-9999.   ! X where the beta-function are given
                        ! 9999.: XSTART
                        ! -9999: XBETFUN of namelist DEPOLA
      PHRBETAH=-9999.   ! Hori. beta-function [m]
                        ! 9999: BETAH of namelist DEPOLA
                        ! -9999: Calcuted from sigmas of namelist WFOLDN
      PHRALPHAH=-9999.  ! Hori. alpha [m]
                        ! 9999: from BETAPH of namelist DEPOLA
                        ! -9999: 0.0
      PHRBETAV=-9999.   ! Vert. beta-function [m]
                        ! 9999: BETAV of namelist DEPOLA
                        ! -9999: Calcuted from sigmas of namelist WFOLDN
      PHRALPHAV=-9999.  ! Vert. alpha [m]
                        ! 9999: from BETAPV of namelist DEPOLA
      PHRDISPH=-9999.   ! Hori. dispersion [m]
                        ! 9999: DISP0 of namelist DEPOLA
                        ! -9999: 0.0
      PHRDISPPH=-9999.  ! Hori. alpha [m]
                        ! 9999: DDISP0 of namelist DEPOLA
                        ! -9999: 0.0
      PHRDISPV=0.0      ! Vert. dispersion [m]
      PHRDISPPV=0.0     ! Vert. alpha [m]

      PHREMITH=-9999.   ! Hori. emittance [m]
                        ! 9999: BETAH of namelist DEPOLA
                        ! -9999: Calcuted from sigmas of namelist WFOLDN

      PHREMITV=-9999.   ! Vert. emittance [m]
                        ! 9999: BETAH of namelist DEPOLA
                        ! -9999: Calcuted from sigmas of namelist WFOLDN

      PHRESPREAD=-9999. ! Rel. energy-spread
                        ! -9999: Taken from namelist DEPOLA
                        ! -9999: Taken from namelist WFOLDN

      PHRBUNLEN=0.0     ! Rel. energy-spread
                        !  9999: Taken from namelist AMPLIN
                        ! -9999: Taken from namelist BUNCHN

      MODEPH=0          ! Mode of phase error
                        ! 0: PHRERROR is RMS of phase error
                 ! 1: PHRERROR applies to K-parameter
                 ! 2: PHRERROR applies to K-parameter by -B +B +B -B scheme

      PHRERROR=0.0D0    ! RMS of phase error of first harmonic [deg.]

      $END

 $AMPLIN

      IAMPSKIP=0  ! if not zero, spectrum calculation is skipped and
                  ! SR ADDAMPLI is called immediately

      IAMPTERM=0  ! if not zero program terminates after call
                  ! to SR ADDAMPLI

      IAMPCOMP=3  !component of field to adjust phase

      IMAMPLI=1   ! mode flag
                  !  1:   write amplitude array REAIMA to new file
                  !  2:   append amplitude array REAIMA to file
                  !  3:   same as 1, but in addition
                  !       write amplitude array REAIMA to files
                  !       eyre*.dat, eyim*.dat, ezre*.dat, ezim*.dat, ey2*.dat
                  !       for program PHASE of Johannes Bahrdt
                  !     (one photon energy per file)
                  ! -1:   read amplitude array REAIMA from file,
                  !     fill arrays for spectrum calculations, i.e.
                  !     SPEC, STOKES ...
                  !     sum up all spectra on file applying
                  !     phaseshifts AMPSHIFT
                  !        *** Be careful, if the field was written
                  !       under for IBUNCH.ne.0. The flux-density and the
                  !       field might differ with respect to the
                  !       phase, especially if BUNCHLEN was lower
                  !       then zero, while writing the file
                  ! -3:   same as -1, but in addition
                  !       write amplitude array REAIMA to files for
                  !       program PHASE of Johannes Bahrdt
                  !     (one photon energy per file)

      IAMPSUP=0   ! write resulting field amplitude to file
                  ! FILEAMPLI"_SUPER"

      AMPSHIFT(1)=0. ! From distance AMPSHIFT [m] a phaseshift for the
                     ! amplitude is calculated for each photon energy
                     ! before the amplitude is added to the spectrum.
                     ! The index referes to the spectrum on the file.
                     ! The phaseshift corresponds to the phase advance
                     ! of a photon with respect to an electron in a
                     ! drift space (phi=L/c/2g**2*w). In an undulator
                     ! field the phase advance is given by
                     ! phi=L*(1+K**2/2)/c/2g**2*w

      AMPSCALE(1)=1. ! the scaling factor AMPSCALE is applied to
                     ! amplitude before adding amplitude
                     ! the index referes to the spectrum on the file

      IAMPREP=0   ! number of superpositions of field
                  ! *** no correction for depth of field effects
                  ! (option IAMPLI<0 is recommended instead)

                  ! IAMPREP<0: Superposition is done according to
                  ! longitudinal density of electrons as defined by
                  ! IAMPCOH. In this case, the spectra are normlized to
                  ! AMPBUNCHCHARGE if AMPBUNCHCHARGE not zero

       IAMPCOH=0   ! mode to calculate longitudinale
                   ! distribution of electrons
                   ! the first 10000 phase shifts [nm] are
                   ! written to file wave_bunch.dat
                   !
                   ! 0: Gaussian distribution with sigma=AMPCOHSIG
                   !
                   ! -1: user routine UBUNCH(x,y,z,yp,zp,gamma,dt),
                   !     where x referes to the center of the bunch
                   !
                   ! 2: routine BUNCH(dt,weight) according to Saldin,
                   !    NIM A 539 (2005) 499-526
                   !    with parameters BUNCHP0, BUNCHR56, NBUNCHHARM
                   !    and AMPFREQ
                   !
                   ! 3: read phasespace distribution
                   !    x,y,z,dpx/p,dpy/p,dpz/p,weight from
                   !    file wave_phasespace.dat (LUN=21)
                   !
                   ! 4: density distribution within bunch is read in
                   !    terms of FOURIER-coefficients from file
                   !    fourier-bunch.dat (LUN=21)
                   !
                   !    Format:
                   !    Lines starting with * in first column or empty
                   !    lines are comments
                   !    other lines give coefficients c1...cn for harmonics
                   !    first NAMPBUNCHHARM are used

      IAMPINCOH=0 !    suppress incoherent background
                  !    use with care!!

      AMPCOHSIG=264.e-9 ! sigma of Gaussian [m] for IAMPCOH=0.and.IAMPREP<0

      AMPBUNCHLEN=20.E-9 ! length [m] of the whole bunch
      AMPBUNCHCHARGE=20.E-9 ! charge [C] of the whole bunch
                              ! if zero, normalization is done according
                              ! to number of electron, i.e. -IAMPREP

      AMPBUNCHP0=250.d-6 ![GeV]
      AMPBUNCHR56=30.d-6 !R56 [m]
      NAMPBUNCHHARM=1   !number of harmonics of microbunching (IAMPCOH=2)

      AMPRAN=0.   !rel. rms of gaussian random phaseshift error
                  !(referes to AMPFREQ)

      IAMPSEED=0  ! seed for random numbers [1...900000]
            ! -9999: Current job runnumber is used as seed
            ! *** obsolete, see, $RANDOMN ***

      AMPFREQ=-9999.  ! photonenergy [eV] to which AMPPHI referes
                      !-9999. means is taken from 1. harm. of considered device
                      !*** Be careful: Only correct for one period devices, since
                      !*** it scales with number of periods
                      !0: Is allowed and avoids check of AMPFREQ (useful for
                      !   IAMPSKIP=1),

      AMPR2CORR=-9999. !effective length of repeated section [m]
               !if the repeated is long, e.g. a whole undulator,
               !this is the length of the undulator without the
               !zero field section between repeated undulators.
               !-9999. means full length of repeated section, which
               !       is a good approximation

      AMPPHI(1)=1. !
             !----------------
             !  AMPPHI.GT.0:
             !----------------
             ! phaseshift for superpositions in fractions of 2*pi
             ! *** Attention: AMPPHI corresponds to phase advance
             ! due to the length of the trajectory through the
             ! phase-shifting device.
             ! Hence AMPPHI + 1 is not the same as AMPPHI!!
             !----------------
             !  AMPPHI.LT.0:
             !----------------
             ! AMPPHI is detour of trajectory [m] through phase-shifting
             ! device, i.e. total length of trajectory minus AMPSHIFT

      $END

 $ROIN

      NROI=0      !number of ROI-boundaries for spectrum calculation
            !ROI are regions between the boundaries, i.e.
            !e.g. third ROI is between ROIX(3) and ROIX(4)
            !zero values means: NROI set to 2, roi is whole source,
            !relative precision is set to one
            !negative values means equally spaced ROIs within
            !source, i.e. values of ROIX are ignored
            !IF ROIS ARE USED, THE RANGE  XSTART->XSTOP MUST
            !BE COVERED.
      ROIX(1)=0.  !x-value of ROI-boundary
      ROIP(1)=1.  !relative precision i.e. number of integration steps
            !per unitlength is multiplied with this factor
            !within the ROI
            !zero-value is set to one
      ROIX(2)=0.  !x-value of ROI-boundary
      ROIP(2)=1.  !relative precision i.e. number of integration steps
      ROIX(3)=0.  !x-value of ROI-boundary
      ROIP(3)=1.  !relative precision i.e. number of integration steps
      ROIX(4)=0.  !x-value of ROI-boundary
      ROIP(4)=1.  !relative precision i.e. number of integration steps
      ROIX(5)=0.  !x-value of ROI-boundary
      ROIP(5)=1.  !relative precision i.e. number of integration steps
      ROIX(6)=0.  !x-value of ROI-boundary
      $END

 $BERRORN

        !*** CHECK ERROR FIELD BY PLOTTING TO AVOID CONFUSION

        B0ERROR=0.      ! amplitude of field error

        IBERRSEED=0     ! seed for random numbers [1...900000]
                      ! *** obsolete, see, $RANDOMN ***

        NBERRMOD=0      ! mode of error treatment:
                      !
            ! 0: error applies for three poles with -B/2,+B,-B/2
            ! 1: error applies for two poles with +B,-B
            ! 2: error applies for single pole with +B
            ! 3: error applies for four poles with -B +B +B -B
            ! 10,11,12 or 13: like 0,1,2,3 respectively, but errors
            ! are read from file wave_berror.dat

        XLENERR=0.      ! 2*pi/kx for global horizontal gradient [m]
                      ! XLERROR=0 means YLERROR=ZLERROR (no gradient)
            ! *** NEGATIVE: BELLANA is used to calculate error
                 ! ***           field, B0ERROR is taken for B0ELLANA

        ZLENERR=0.032   ! 2*pi/kz of poles [m]

        NBERROR=-9999   !  number of poles

            !  for NBERRMOD=0 one error affects three poles
            !  for NBERRMOD=1 one error affects two poles
            !  for NBERRMOD=2 one error affects one pole
            !
            !  for NBERRMOD=10 errors are read from file wave_berror.dat
            !  and  affects three poles
            !  for NBERRMOD=11 errors are read from file wave_berror.dat
            !  and  affects two poles
            !  for NBERRMOD=12 errors are read from file wave_berror.dat
            !  and  affects one pole
            !
            !  for NBERRMOD=-1 poles from Fibonacci series,
            !  error is B0ERROR=const
            !  file fibonacci_used_cut.dat contains used cut
            !  file fibonacci_available_cuts.dat contains
            !  available cuts of series

            ! -9999 means number of poles are calculated from
            ! XSTART and XSTOP

        XCENERR=0.      ! center of error field in X [m]

        ETAFIBO=4.05177 ! eta for Fibonacci-series
        ICUTFIBO=1      ! use cut with icut .gt. ICUTOFIBO of series

        $END

 $PHOTONN

      IHPHOTONS=1 ! to get Ntuple with photons generated for IENELOSS = -1

      EECMAXG1=5.0 ! max. energy of generated photons in units of Ec
      NBING1=1000  ! number of bins for histogram of probability
                   ! distribution

      IPHMODE=0    !0: use WAVE routine to generate photons
                   !1: use HRNDM1 from CERN to generate photons
                   !<0: use WAVE routine to generate photons
                   ! addionally with transversal momentum

 $END

 $USERN

 !The first 10 values are also stored as Ntuple 223
 !or n223 for PAW or root respectively

        USER(1)=0.       !USER REAL*8 ARRAY (1000)
        USERCHAR(1)=''   !USER CHARACTER(128) ARRAY (1000)

      $END

 $WAVES
   INULL=0
   IONE=1
   ITWO=2
   ITHREE=3
   IFOUR=4
   IFIVE=5
   ISIX=6
   ISEVEN=7
   IEIGHT=8
   ININE=9
   DWAVES=0.0E0      !DUMMY
   RWAVES=0.  !DUMMY
   IWAVES=0   !DUMMY
   CWAVES=(0.,0.)   !DUMMY
   IAMPW=0
   IAMPNW=1
   IAMPNP=1
   IAMPLI11=0
   IAMPLI21=0
   IAMPLI12=0
   IAMPLI22=0
   INURAN=0
   IRBMAP=0
   IRBMAP2=0
   IWBMAPT=0
   TROTCHIC0=0.
   TROTCHIC=0.
   TROTMODU0=0.
   TROTMODU=86.76
   T180=180.
   TROT=86.76
   TROTEND=90.
   TROT900=90.
   TROT90=90.
   TROTM=0.
   TROT1800=180.
   TROT180=180.
   UE112SH=0.
   UE112SH=0.
   SHLL=0.0
   SHLR=+1.0
   SHUL=-1.0
   SHUR=0.0
   UESHIFTLL=0.0
   UESHIFTUL=0.
   UESHIFTLR=0.
   UESHIFTUR=0.0
   SHIFTLLM=0.0
   SHIFTULM=0.
   SHIFTLRM=0.
   SHIFTURM=0.0
   UESHIFTLLM=0.0
   UESHIFTULM=0.
   UESHIFTLRM=0.
   UESHIFTURM=0.0
   IUE112MOD=1
   NUE112MOD=0
   IUE46=0
   IUE56=0
   IUE112=0
   IWORK1=0
   IWORK2=0
   IWORK3=0
   IBEAMFOLD=0
   IBEAMEFOLD=0
   IAMPREPP=0
   MPINRT=0
   IBUNCHT=1
   R9999=9999.
   IPINHV=0
   IPINWV=0
   IPINRV=1
   IPIN3=0
   KBUNDUMAG1=0
   KBUNDUMAG2=0
   KBUNDUMAG3=0
   KBUNDUMAG4=0
   KAPPLE=0
   KHYBRID=0
   KUNDUWAV=0
   IRMAP2=0
   KHYBRID=0
   KAPPLE=0
   IUNDU2=0
 $end
+DECK,urad_phase,T=TEXT.
*CMZ :  4.01/04 07/11/2023  11.07.37  by  Michael Scheer
*-- Author :    Michael Scheer   07/11/2023
 $uradphasen

  Mthreads=-1                  !Number of threads (<0: Use all cores)
  Ebeam=1.722                  !Beam energy [GeV]
  Curr=0.1                     !Current [A]
  Step=0.2                     !Tracking step size [mm]
  Nelec=1                      !Nelec
  Noranone=1                   !No random change for first e-
  Icohere=0                    !
  Ihbunch=100                  !Each Ihbunch_th bunch is recorded
  Bunchlen=0.0                 !Not yet
  BunchCharge=0.0              !Not yet
  Modebunch=0                  !Not yet
  PinX=10000.0                 !X of PinHole [mm]
  PinY=0.0                     !Y of PinHole [mm]
  PinZ=0.0                     !Z of PinHole [mm]
  PinW=1.0                     !Width of PinHole [mm]
  PinH=1.0                     !Height of PinHole [mm]
  NpinY=1                      !Number of vert. points
  NpinZ=1                      !Number of hori. points
  Modepin=0                    !Monte-Carlo mode [0,1]
  Modesphere=0                 !Observation points are on a sphere
  Perlen=50.0                  !Period-length [mm]
  Shift=12.5                   !Shift [mm] (for spectra only)
  Nper=51                      !Number of periods
  Nharm=5                      !Nharm (>0: overwrites Beff)
  Harm=1000.0                  !Harm [eV]
  Beffv=1.0                    !B0 vert. [T]
  Beffh=0.32                   !B0 hori.. [T]
  Nepho=21                     !Number of Photon Energies
  EphMin=595.0                 !Min. Photon Energy [eV]
  EphMax=605.0                 !Max. Photon Energy [eV]
  Espread=0.001                !Rel. energy spread
  BetaH=14.0                   !Hori. Beta function
  BetaV=3.4                    !Vert. Beta function
  EmitH=4.4                    !Hor. Emit. [nm-rad]
  EmitV=0.066                  !Ver. Emit. [nm-rad]
  Disph=0.0                    !Horizontal dispersion [mm]
  Dispph=0.0                   !Derivative of hori. dispersion [mrad]
  Dispv=0.0                    !Vertical dispersion [mm]
  Disppv=0.0                   !Derivative of vert. dispersion [mrad]
  Modeph=0                     !Mode for phase-error
  Pherror=0.0                  !Phase errors

 $end

 $seedn

  Ifixseed=1                   !Fix Seeds [0,1]
  irnseed(1)=376577121
  irnseed(2)=52147852
  irnseed(3)=-1273034815
  irnseed(4)=-1963249100
  irnseed(5)=1195262240
  irnseed(6)=-1718716574
  irnseed(7)=-224354675
  irnseed(8)=432587481
  irnseed(9)=1692325775
  irnseed(10)=1934175653
  irnseed(11)=-107106772
  irnseed(12)=648589804
  irnseed(13)=-1919014861
  irnseed(14)=-1763988460
  irnseed(15)=-1039845022
  irnseed(16)=1414926465
  irnseed(17)=-1214705659
  irnseed(18)=560082688
  irnseed(19)=527470902
  irnseed(20)=-1078636718
  irnseed(21)=272932485
  irnseed(22)=-356992740
  irnseed(23)=-2013991490
  irnseed(24)=-588501795
  irnseed(25)=-1010120436
  irnseed(26)=-1558306344
  irnseed(27)=-1116776222
  irnseed(28)=794926823
  irnseed(29)=-1157173406
  irnseed(30)=63711032
  irnseed(31)=-1870802148
  irnseed(32)=-674825931
  irnseed(33)=-690546468
  irnseed(34)=1671737514
  irnseed(35)=-224394481
  irnseed(36)=2026233226
  irnseed(37)=-1141752469
  irnseed(38)=2061158685
  irnseed(39)=-1225625467
  irnseed(40)=-147464566
  irnseed(41)=1692325775
  irnseed(42)=1934175653
  irnseed(43)=-107106772
  irnseed(44)=648589804
  irnseed(45)=-1919014861
  irnseed(46)=-1763988460
  irnseed(47)=-1039845022
  irnseed(48)=1414926465
  irnseed(49)=-1214705659
  irnseed(50)=560082688
  irnseed(51)=527470902
  irnseed(52)=-1078636718
  irnseed(53)=272932485
  irnseed(54)=-356992740
  irnseed(55)=-2013991490
  irnseed(56)=-588501795
  irnseed(57)=-1010120436
  irnseed(58)=-1558306344
  irnseed(59)=-1116776222
  irnseed(60)=794926823
  irnseed(61)=-1157173406
  irnseed(62)=63711032
  irnseed(63)=-1870802148
  irnseed(64)=-674825931

 $end
+PATCH,WKUMAC,T=KUMAC.
*CMZ :  2.37/05 05/12/2001  18.20.16  by  Michael Scheer
+DECK,WAVE_VERSION.
*CMZ :          28/12/2023  17.40.28  by  Michael Scheer
*CMZ :  4.01/04 07/11/2023  17.45.37  by  Michael Scheer
*CMZ :  3.05/09 08/08/2018  14.26.07  by  Michael Scheer
*CMZ :  3.00/01 14/03/2013  12.41.45  by  Michael Scheer
*CMZ :  2.70/06 14/01/2013  09.57.27  by  Michael Scheer
*CMZ :  2.52/07 14/10/2004  09.23.32  by  Michael Scheer
*CMZ :  2.37/03 22/11/2001  16.08.21  by  Michael Scheer
*CMZ :  2.20/02 21/02/2001  11.40.28  by  Michael Scheer
*-- Author :    Michael Scheer   21/02/2001

macro wave_version chopt=+

mess 'current version:'
vers
exec dinput
edi wave
exec dfor
cd cmn

edi $wversion
cop $wversion /cmnn
cop $wversion /incln
cop $wversion /incl
cop $wversion /seqver

vers [chopt]

edi /mrad/$mrad_version

set f77 -lan
cd seqver
seq .
seq /seqver
set ~/wav/cmz/wversdum.f -f
cx wversdum
seq -f $WAVE_INCL/nomp/*.cmn

seq .
exec dgfor

+DECK,dgfor,T=KUMAC.
*CMZ :  4.01/04 17/11/2023  11.14.36  by  Michael Scheer
*CMZ :  4.01/03 15/05/2023  16.37.10  by  Michael Scheer
*CMZ :  4.01/02 14/05/2023  13.28.50  by  Michael Scheer
*CMZ :  3.08/01 03/04/2019  15.52.16  by  Michael Scheer
*CMZ :  3.06/00 18/02/2019  10.33.53  by  Michael Scheer
*CMZ :  3.05/02 15/05/2018  16.26.25  by  Michael Scheer
*CMZ :  3.05/01 04/05/2018  12.17.31  by  Michael Scheer
*CMZ :  3.03/02 08/01/2016  15.47.23  by  Michael Scheer
*CMZ :  3.01/08 06/08/2014  12.44.45  by  Michael Scheer
*CMZ :  3.01/00 15/07/2013  08.11.49  by  Michael Scheer
*CMZ :  3.00/00 08/03/2013  16.39.23  by  Michael Scheer
*CMZ :  2.70/06 03/01/2013  13.19.38  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  10.18.21  by  Michael Scheer
*CMZ :  2.63/05 22/07/2009  13.08.29  by  Michael Scheer
*CMZ :  2.63/04 22/07/2009  07.32.38  by  Michael Scheer
*CMZ :  2.61/02 15/03/2007  13.16.43  by  Michael Scheer
*CMZ :  2.58/00 11/01/2007  16.25.07  by  Michael Scheer
*CMZ :  2.57/05 05/01/2007  11.51.44  by  Michael Scheer
*CMZ :  2.54/06 02/06/2005  08.35.51  by  Michael Scheer
*CMZ :  2.52/06 04/10/2004  12.46.36  by  Michael Scheer
*CMZ :  2.52/05 11/08/2004  10.13.48  by  Michael Scheer
*CMZ :  2.47/21 03/12/2003  09.32.38  by  Michael Scheer
*CMZ :  2.47/12 03/07/2003  09.40.45  by  Michael Scheer
*CMZ :  2.47/08 16/05/2003  09.45.09  by  Michael Scheer
*CMZ :  2.41/07 29/07/2002  16.51.00  by  Michael Scheer
*-- Author :    Michael Scheer   29/07/2002
macro dgfor

* +PATCH,//WAVE/WKUMAC
* +DECK,dgfor,T=KUMAC.

tabs -f
sel omp

cd //wave/for

sel gfortran
seq .
seq CMNn

set f77 -lan
set cmzeditfor.f -E

+self,if=linux,if=-wavevm.
she cp ~/cmz/cmzlan.f77 .cmzlan
+self.

+self,if=linux.

ali/cre ef 'exec fedit' c
ali/cre efb 'exec feditb' c
ali/cre efbt 'exec feditbt' c
*alias/create out 'exec waveout.kumac' c
*alias/create out 'exec wave_export_standalone_omp.kumac' c

+self,if=-wavevm.
set $WAVE_INCL/nomp/*.f -f
set ../lib/libwave_gfortran.a -L
+self,if=wavevm.
set ~/wave/cmz/*.f -f
set ../lib/libwave_gfortran.a -L
+self.

+self,if=vms.
set WAVE_ROOT:[STAGE]CMZ_*.FOR -f
+self.

+self,if=-wavevm.
set '~/wav/shell/wgfor.sh $compfile' -C F77
+self,if=wavevm.
set '~/wave/shell/wgfor.sh $compfile' -C F77
+self.

seq .
*seq CMNn
seq inclcmn

exec lastdir for

exitm
+DECK,dwav,T=KUMAC.
*CMZ :  4.01/04 17/11/2023  11.13.55  by  Michael Scheer
*CMZ :  3.08/01 03/04/2019  16.06.05  by  Michael Scheer
*CMZ :  3.05/01 07/05/2018  13.52.28  by  Michael Scheer
*CMZ :  3.04/00 26/02/2018  14.09.59  by  Michael Scheer
*CMZ :  3.03/01 30/10/2015  15.53.12  by  Michael Scheer
*CMZ :  3.02/07 19/06/2015  09.14.54  by  Michael Scheer
*CMZ :  3.02/06 22/05/2015  14.49.16  by  Michael Scheer
*CMZ :  3.01/10 19/08/2014  11.14.46  by  Michael Scheer
*-- Author :    Michael Scheer   19/08/2014
macro dwav
*alias/del out
*alias/cre out 'exec waveout.kumac' c
*alias/create out 'exec wave_export_standalone_omp.kumac' c
alias/del elib
alias/cre elib 'exec emshwaveroot' c
alias/del dtex
alias/cre dtex 'exec ddoc.kumac' c
*alias/del r
*alias/cre r 'she ~/wav/run-wave-xterm.sh' c
cd //wave
exec dgfor
exitm
+DECK,dgforwall,T=KUMAC.
*CMZ :  4.01/04 17/11/2023  11.15.56  by  Michael Scheer
*CMZ :  4.00/08 06/08/2020  15.51.36  by  Michael Scheer
*CMZ :  3.05/08 23/07/2018  10.24.29  by  Michael Scheer
*CMZ :  3.05/02 15/05/2018  16.26.25  by  Michael Scheer
*CMZ :  3.05/01 04/05/2018  12.17.31  by  Michael Scheer
*CMZ :  3.03/02 08/01/2016  15.47.23  by  Michael Scheer
*CMZ :  3.01/08 06/08/2014  12.44.45  by  Michael Scheer
*CMZ :  3.01/00 15/07/2013  08.11.49  by  Michael Scheer
*CMZ :  3.00/00 08/03/2013  16.39.23  by  Michael Scheer
*CMZ :  2.70/06 03/01/2013  13.19.38  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  10.18.21  by  Michael Scheer
*CMZ :  2.63/05 22/07/2009  13.08.29  by  Michael Scheer
*CMZ :  2.63/04 22/07/2009  07.32.38  by  Michael Scheer
*CMZ :  2.61/02 15/03/2007  13.16.43  by  Michael Scheer
*CMZ :  2.58/00 11/01/2007  16.25.07  by  Michael Scheer
*CMZ :  2.57/05 05/01/2007  11.51.44  by  Michael Scheer
*CMZ :  2.54/06 02/06/2005  08.35.51  by  Michael Scheer
*CMZ :  2.52/06 04/10/2004  12.46.36  by  Michael Scheer
*CMZ :  2.52/05 11/08/2004  10.13.48  by  Michael Scheer
*CMZ :  2.47/21 03/12/2003  09.32.38  by  Michael Scheer
*CMZ :  2.47/12 03/07/2003  09.40.45  by  Michael Scheer
*CMZ :  2.47/08 16/05/2003  09.45.09  by  Michael Scheer
*CMZ :  2.41/07 29/07/2002  16.51.00  by  Michael Scheer
*-- Author :    Michael Scheer   29/07/2002
macro dgforwall

* +PATCH,//WAVE/WKUMAC
* +DECK,dgforwall,T=KUMAC.

cd //wave/for

sel gfortran
seq .
seq CMNn

set f77 -lan
set cmzeditfor.f -E

+self,if=linux,if=-wavevm.
she cp ~/cmz/cmzlan.f77 .cmzlan
+self.

+self,if=linux.

ali/cre ef 'exec fedit' c
ali/cre efb 'exec feditb' c
ali/cre efbt 'exec feditbt' c
*alias/create out 'exec wave_export_standalone_omp.kumac' c

+self,if=-wavevm.
set ~/wav/cmz/*.f -f
set ../lib/libwave_gfortran.a -L
+self,if=wavevm.
set ~/wave/cmz/*.f -f
set ../lib/libwave_gfortran.a -L
+self.

+self,if=vms.
set WAVE_ROOT:[STAGE]CMZ_*.FOR -f
+self.

+self,if=-wavevm.
set '~/wav/shell/wgforwall.sh $compfile' -C F77
+self,if=wavevm.
set '~/wave/shell/wgforwall.sh $compfile' -C F77
+self.

seq .
seq CMNn

exec lastdir for

exitm
+DECK,dgfor_omp,T=KUMAC.
*CMZ :  4.01/04 17/11/2023  11.15.03  by  Michael Scheer
*CMZ :  4.01/03 15/05/2023  16.38.04  by  Michael Scheer
*CMZ :  4.01/02 07/05/2023  10.37.22  by  Michael Scheer
*CMZ :  3.08/01 03/04/2019  16.05.40  by  Michael Scheer
*CMZ :  3.07/01 21/03/2019  10.24.26  by  Michael Scheer
*CMZ :  3.05/01 07/05/2018  12.10.18  by  Michael Scheer
*CMZ :  3.03/02 08/01/2016  15.47.23  by  Michael Scheer
*CMZ :  3.01/08 06/08/2014  12.44.45  by  Michael Scheer
*CMZ :  3.01/00 15/07/2013  08.11.49  by  Michael Scheer
*CMZ :  3.00/00 08/03/2013  16.39.23  by  Michael Scheer
*CMZ :  2.70/06 03/01/2013  13.19.38  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  10.18.21  by  Michael Scheer
*CMZ :  2.63/05 22/07/2009  13.08.29  by  Michael Scheer
*CMZ :  2.63/04 22/07/2009  07.32.38  by  Michael Scheer
*CMZ :  2.61/02 15/03/2007  13.16.43  by  Michael Scheer
*CMZ :  2.58/00 11/01/2007  16.25.07  by  Michael Scheer
*CMZ :  2.57/05 05/01/2007  11.51.44  by  Michael Scheer
*CMZ :  2.54/06 02/06/2005  08.35.51  by  Michael Scheer
*CMZ :  2.52/06 04/10/2004  12.46.36  by  Michael Scheer
*CMZ :  2.52/05 11/08/2004  10.13.48  by  Michael Scheer
*CMZ :  2.47/21 03/12/2003  09.32.38  by  Michael Scheer
*CMZ :  2.47/12 03/07/2003  09.40.45  by  Michael Scheer
*CMZ :  2.47/08 16/05/2003  09.45.09  by  Michael Scheer
*CMZ :  2.41/07 29/07/2002  16.51.00  by  Michael Scheer
*-- Author :    Michael Scheer   29/07/2002
macro dgfor_omp

* +PATCH,//WAVE/WKUMAC
* +DECK,dgfor_omp,T=KUMAC.

cd //wave/omp

sel gfortran
sel omp
seq .
seq CMNn
seq mod

set f77 -lan
set cmzeditfor.f -E

+self,if=linux,if=-wavevm.
she cp ~/cmz/cmzlan.f77 .cmzlan
+self.

+self,if=linux.

ali/cre ef 'exec fedit' c
ali/cre efb 'exec feditb' c
ali/cre efbt 'exec feditbt' c
*alias/create out 'exec waveout.kumac' c
*alias/create out 'exec wave_export_standalone_omp.kumac' c

+self,if=-wavevm.
set $WAVE_INCL/omp/*.f -f
set ../lib/libwave_omp.a -L
+self,if=wavevm.
set ~/wave/cmz/*.f -f
set ../lib/libwave_omp.a -L
+self.

+self,if=vms.
set WAVE_ROOT:[STAGE]CMZ_*.FOR -f
+self.

+self,if=-wavevm.
set '~/wav/shell/wgfor_omp.sh $compfile' -C F77
+self,if=wavevm.
set '~/wave/shell/wgfor_omp.sh $compfile' -C F77
+self.

seq .
*seq CMNn
seq inclcmn

exec lastdir omp

exitm
+DECK,DURADPHASE,T=KUMAC.
*CMZ :  4.01/04 22/11/2023  12.06.44  by  Michael Scheer
*CMZ :  4.01/02 25/03/2023  10.50.37  by  Michael Scheer
*CMZ :  4.01/00 15/01/2023  16.23.28  by  Michael Scheer
*CMZ :  4.00/13 28/10/2021  11.52.55  by  Michael Scheer
*CMZ :  3.01/04 21/05/2014  09.28.27  by  Michael Scheer
*CMZ :  2.68/05 10/09/2012  11.26.45  by  Michael Scheer
*CMZ :  2.68/03 23/08/2012  12.23.10  by  Michael Scheer
*CMZ :  2.41/07 29/07/2002  16.49.54  by  Michael Scheer
*-- Author :    Michael Scheer   29/07/2002
macro duradphase_incl

ali/cre cclu 'exec compilelasturadphase' c

cd //wave
exec dgfor_omp

cd uradphase
*seq .

*set ../urad_phase/for/*.f -f

set ~/wav/urad_phase/lib/liburad_gfortran_debug.a -L
set '~/wav/urad_phase/shell/gford.sh $compfile' -C F77

exec lastdir uradphase

exitm
+DECK,outuradphase,T=KUMAC.
*CMZ :          29/12/2023  11.46.34  by  Michael Scheer
*CMZ :  4.01/04 28/12/2023  15.28.49  by  Michael Scheer
*CMZ :  4.01/03 18/05/2023  14.49.41  by  Michael Scheer
*CMZ :  4.01/02 12/05/2023  11.50.25  by  Michael Scheer
*CMZ :  4.01/00 10/02/2023  13.39.11  by  Michael Scheer
*-- Author :    Michael Scheer   14/01/2023
macro outuradphase
exec duradphase

seq .
buff .
seq /inclcmn

set ../urad_phase/for/*.f -f
cx urad_modules

set ../urad_phase/for/urad_util.f -f
cx /omp/util_random_gauss_omp /for/util_random _
/for/util_spline_inter /for/util_spline_coef /for/util_parabel _
/for/util_spline_running_integral /for/util_g1_static /for/util_sort_func _
/for/util_get_electron _
/for/util_beta_function_drift _
/for/util_random_gauss _
/for/util_spline_integral_2d _
/for/util_spline_integral_stat _
/for/util_spline_coef_status _
/for/util_random_set_seed _
/for/util_zeit_kommentar _
/util/util_break _
/for/util_random_get_seed /for/util_random_init

set ../urad_phase/for/urad_phase_main.f -f
cx urad_phase_main _
urad_phase urad_amprep urad_field_ini urad_e_b_field urad_phase_prop _
/omp/urad?* /omp/bhalba_omp _
/urad/uradphoton /urad/uradstep /urad/uradestep /urad/uradrndm

exec duradphase
exitm
+DECK,dmodu,T=KUMAC.
*CMZ :  4.01/04 11/12/2023  11.25.45  by  Michael Scheer
*CMZ :  4.01/00 13/03/2023  12.42.08  by  Michael Scheer
*CMZ :  3.05/09 27/07/2018  09.03.31  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  12.54.47  by  Michael Scheer
*-- Author :    Michael Scheer   29/07/2002
macro dmodu

* +PATCH,//WAVE/WKUMAC
* +DECK,dmodu,T=KUMAC.

+self,if=-wavevm.
exec dfor
+self,if=wavevm.
exec dgfor
+self.

seq .
cd uradmod
set /home/scheer/wav/for_incl/omp/mod/*.f -f

exitm
+DECK,out_contrl_cmn,T=KUMAC.
*CMZ :  4.01/04 17/10/2023  13.15.19  by  Michael Scheer
*-- Author :    Michael Scheer   17/10/2023
macro load_contrl_cmn

exec dfor
seq .
cd test
cc load_contrl_cmn
seq -f ~/wav/for/*.cmn

exitm
+DECK,out_wave_incl,T=KUMAC.
*CMZ :  4.01/04 17/11/2023  13.59.30  by  Michael Scheer
*CMZ :  4.01/03 28/06/2023  15.05.43  by  Michael Scheer
*CMZ :  4.01/02 11/05/2023  13.51.53  by  Michael Scheer
*CMZ :  4.01/00 13/03/2023  22.19.49  by  Michael Scheer
*-- Author :

* +PATCH,//WAVE/WKUMAC
* +DECK,out_wave_incl,T=KUMAC.

macro out_wave_incl

mess ''
mess ''
mess ''
mess ''
mess ''
mess ''
mess ''
mess ''
mess ''
mess ''
mess ''
mess ''
mess ''
mess ''
mess ''
mess ''
mess ''
mess ''
mess ''
mess ''
mess ''
mess ''
mess ''
mess ''
mess ''
mess ''
mess ''

sel windows
sel -windows
sel linux

exec dwav

sel omp
sel newbunch

sel nocern
sel noroot
sel nohbook
sel mshplt

sel gplhint

set F77 -lan
tabs -f

buff .
seq .

she rm $WAVE_INCL/bin/wave_debug.exe
she rm $WAVE_INCL/bin/wave.exe

she rm $WAVE_INCL/lib/libwave*
she rm $WAVE_INCL/lib/libuser*

she rm $WAVE_INCL/user/mod/*.f
she rm $WAVE_INCL/user/mod/*.o

set $WAVE_INCL/user/mod/*.f -f
cx /usermod/usermodtmpl

buff .
seq .

buff //WAVE/USER

she rm $WAVE_INCL/user/*.f
she rm $WAVE_INCL/user/*.o
she rm $WAVE_INCL/user/*.mod

set $WAVE_INCL/user/*.f -f
cx -b

seq -f $WAVE_INCL/user/*.cmn

seq .
seq /inclcmn
cx -b

*********

seq .

she rm $WAVE_INCL/omp/mod/*.f
she rm $WAVE_INCL/omp/mod/*.o

set $WAVE_INCL/omp/mod/*.f -f
cx //wave/modomp //wave/uradmod/uradphasemod _
//wave/modules/phasef90m //wave/modules/phasewsf90m

she rm $WAVE_INCL/omp/*.f
she rm $WAVE_INCL/omp/*.o
she rm $WAVE_INCL/omp/*.mod

set $WAVE_INCL/omp/*.f -f

cx //wave/omp _
//wave/uradphase/urad_field_ini _
//wave/uradphase/urad_amprep _
//wave/uradphase/urad_e_b_field _
//wave/urad/uradphoton _
//wave/urad/uradestep _
//wave/urad/uradrndm _
//wave/uradphase/urad_phase

seq -f $WAVE_INCL/omp/*.cmn

seq .
seq /inclcmn

cx //wave/omp _
//wave/uradphase/urad_field_ini _
//wave/uradphase/urad_amprep _
//wave/uradphase/urad_e_b_field _
//wave/urad/uradphoton _
//wave/urad/uradestep _
//wave/urad/uradrndm _
//wave/uradphase/urad_phase

*********

exec dwav
exec dgfor

she rm $WAVE_INCL/nomp/mod/*.f
she rm $WAVE_INCL/nomp/mod/*.o

set $WAVE_INCL/nomp/mod/*.f -f
cx //wave/modules //wave/uradmod/uradphasemod

buff .

buff //wave/for

buff -//WAVE/FOR/aaaaaa
buff -//WAVE/FOR/aaaaab
buff -//WAVE/FOR/modules
buff -//WAVE/FOR/bextern
buff -//WAVE/FOR/uname
buff -//WAVE/FOR/ustep
buff -//WAVE/FOR/uout

seq .

she rm $WAVE_INCL/nomp/*.f
she rm $WAVE_INCL/nomp/*.o
she rm $WAVE_INCL/nomp/*.mod

set $WAVE_INCL/nomp/*.f -f
cx -b

seq -f $WAVE_INCL/nomp/*.cmn

seq .
seq /cmnn
seq -f $WAVE_INCL/nomp/*.cmn

seq .
seq /inclcmn
cx -b

exec dwav
exec dgfor
exec dmain

she rm $WAVE_INCL/main/mod/*.f
she rm $WAVE_INCL/main/mod/*.o

set $WAVE_INCL/main/mod/*.f -f
cx /modules/clustermod

she rm $WAVE_INCL/main/*.f
she rm $WAVE_INCL/main/*.o
she rm $WAVE_INCL/main/*.mod

seq .
set $WAVE_INCL/main/*.f -f
cx wave_main
seq -f $WAVE_INCL/main/*.cmn

seq .
seq /inclcmn
set $WAVE_INCL/main/*.f -f
cx wave_main

exec dkumac

exitm
+DECK,duradphase_incl,T=KUMAC.
*CMZ :  4.01/04 16/12/2023  15.29.45  by  Michael Scheer
*CMZ :  4.01/02 25/03/2023  10.50.37  by  Michael Scheer
*CMZ :  4.01/00 15/01/2023  16.23.28  by  Michael Scheer
*CMZ :  4.00/13 28/10/2021  11.52.55  by  Michael Scheer
*CMZ :  3.01/04 21/05/2014  09.28.27  by  Michael Scheer
*CMZ :  2.68/05 10/09/2012  11.26.45  by  Michael Scheer
*CMZ :  2.68/03 23/08/2012  12.23.10  by  Michael Scheer
*CMZ :  2.41/07 29/07/2002  16.49.54  by  Michael Scheer
*-- Author :    Michael Scheer   29/07/2002
macro duradphase_incl

ali/cre cclu 'exec compilelasturadphase' c

cd //wave
exec dgfor_omp

cd uradphase
*seq .

*set ../urad_phase/for/*.f -f

set ~/wav/urad_phase/lib/liburad_gfortran_debug.a -L
set '~/wav/urad_phase/shell/gford.sh $compfile' -C F77

exec lastdir uradphase_incl

exitm
+DECK,ktine,T=KUMAC.
*CMZ :  4.01/04 11/12/2023  10.15.28  by  Michael Scheer
*CMZ :  2.04/06 08/07/2023  10.05.24  by  Michael Scheer
*-- Author :    Michael Scheer   08/07/2023
grep subroutine -b
buff
+DECK,dforgh,T=KUMAC.
*CMZ :          28/12/2023  18.29.21  by  Michael Scheer
*CMZ :  4.01/04 17/11/2023  11.14.36  by  Michael Scheer
*CMZ :  4.01/03 15/05/2023  16.37.10  by  Michael Scheer
*CMZ :  4.01/02 14/05/2023  13.28.50  by  Michael Scheer
*CMZ :  3.08/01 03/04/2019  15.52.16  by  Michael Scheer
*CMZ :  3.06/00 18/02/2019  10.33.53  by  Michael Scheer
*CMZ :  3.05/02 15/05/2018  16.26.25  by  Michael Scheer
*CMZ :  3.05/01 04/05/2018  12.17.31  by  Michael Scheer
*CMZ :  3.03/02 08/01/2016  15.47.23  by  Michael Scheer
*CMZ :  3.01/08 06/08/2014  12.44.45  by  Michael Scheer
*CMZ :  3.01/00 15/07/2013  08.11.49  by  Michael Scheer
*CMZ :  3.00/00 08/03/2013  16.39.23  by  Michael Scheer
*CMZ :  2.70/06 03/01/2013  13.19.38  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  10.18.21  by  Michael Scheer
*CMZ :  2.63/05 22/07/2009  13.08.29  by  Michael Scheer
*CMZ :  2.63/04 22/07/2009  07.32.38  by  Michael Scheer
*CMZ :  2.61/02 15/03/2007  13.16.43  by  Michael Scheer
*CMZ :  2.58/00 11/01/2007  16.25.07  by  Michael Scheer
*CMZ :  2.57/05 05/01/2007  11.51.44  by  Michael Scheer
*CMZ :  2.54/06 02/06/2005  08.35.51  by  Michael Scheer
*CMZ :  2.52/06 04/10/2004  12.46.36  by  Michael Scheer
*CMZ :  2.52/05 11/08/2004  10.13.48  by  Michael Scheer
*CMZ :  2.47/21 03/12/2003  09.32.38  by  Michael Scheer
*CMZ :  2.47/12 03/07/2003  09.40.45  by  Michael Scheer
*CMZ :  2.47/08 16/05/2003  09.45.09  by  Michael Scheer
*CMZ :  2.41/07 29/07/2002  16.51.00  by  Michael Scheer
*-- Author :    Michael Scheer   29/07/2002
macro dgforgh

* +PATCH,//WAVE/WKUMAC
* +DECK,dgfor,T=KUMAC.

tabs -f
sel omp
sel gplhint

cd //wave/for

sel gfortran
seq .
seq CMNn

set f77 -lan
set cmzeditfor.f -E

+self,if=linux,if=-wavevm.
she cp ~/cmz/cmzlan.f77 .cmzlan
+self.

+self,if=linux.

ali/cre ef 'exec fedit' c
ali/cre efb 'exec feditb' c
ali/cre efbt 'exec feditbt' c
*alias/create out 'exec waveout.kumac' c
*alias/create out 'exec wave_export_standalone_omp.kumac' c

+self,if=-wavevm.
set $WAVE_GITHUB/nomp/*.f -f
set ../lib/libwave_gfortran.a -L
+self,if=wavevm.
set ~/wave/cmz/*.f -f
set ../lib/libwave_gfortran.a -L
+self.

+self,if=vms.
set WAVE_ROOT:[STAGE]CMZ_*.FOR -f
+self.

+self,if=-wavevm.
set '~/wav/shell/wgfor.sh $compfile' -C F77
+self,if=wavevm.
set '~/wave/shell/wgfor.sh $compfile' -C F77
+self.

seq .
*seq CMNn
seq inclcmn

exec lastdir for

exitm
+DECK,dgfor_omp_gh,T=KUMAC.
*CMZ :          28/12/2023  18.32.42  by  Michael Scheer
*CMZ :  4.01/04 17/11/2023  11.15.03  by  Michael Scheer
*CMZ :  4.01/03 15/05/2023  16.38.04  by  Michael Scheer
*CMZ :  4.01/02 07/05/2023  10.37.22  by  Michael Scheer
*CMZ :  3.08/01 03/04/2019  16.05.40  by  Michael Scheer
*CMZ :  3.07/01 21/03/2019  10.24.26  by  Michael Scheer
*CMZ :  3.05/01 07/05/2018  12.10.18  by  Michael Scheer
*CMZ :  3.03/02 08/01/2016  15.47.23  by  Michael Scheer
*CMZ :  3.01/08 06/08/2014  12.44.45  by  Michael Scheer
*CMZ :  3.01/00 15/07/2013  08.11.49  by  Michael Scheer
*CMZ :  3.00/00 08/03/2013  16.39.23  by  Michael Scheer
*CMZ :  2.70/06 03/01/2013  13.19.38  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  10.18.21  by  Michael Scheer
*CMZ :  2.63/05 22/07/2009  13.08.29  by  Michael Scheer
*CMZ :  2.63/04 22/07/2009  07.32.38  by  Michael Scheer
*CMZ :  2.61/02 15/03/2007  13.16.43  by  Michael Scheer
*CMZ :  2.58/00 11/01/2007  16.25.07  by  Michael Scheer
*CMZ :  2.57/05 05/01/2007  11.51.44  by  Michael Scheer
*CMZ :  2.54/06 02/06/2005  08.35.51  by  Michael Scheer
*CMZ :  2.52/06 04/10/2004  12.46.36  by  Michael Scheer
*CMZ :  2.52/05 11/08/2004  10.13.48  by  Michael Scheer
*CMZ :  2.47/21 03/12/2003  09.32.38  by  Michael Scheer
*CMZ :  2.47/12 03/07/2003  09.40.45  by  Michael Scheer
*CMZ :  2.47/08 16/05/2003  09.45.09  by  Michael Scheer
*CMZ :  2.41/07 29/07/2002  16.51.00  by  Michael Scheer
*-- Author :    Michael Scheer   29/07/2002
macro dgfor_omp

* +PATCH,//WAVE/WKUMAC
* +DECK,dgfor_omp_gh,T=KUMAC.

cd //wave/omp

sel gfortran
sel omp
seq .
seq CMNn
seq mod

set f77 -lan
set cmzeditfor.f -E

+self,if=linux,if=-wavevm.
she cp ~/cmz/cmzlan.f77 .cmzlan
+self.

+self,if=linux.

ali/cre ef 'exec fedit' c
ali/cre efb 'exec feditb' c
ali/cre efbt 'exec feditbt' c
*alias/create out 'exec waveout.kumac' c
*alias/create out 'exec wave_export_standalone_omp.kumac' c

+self,if=-wavevm.
set $WAVE_GITHUB/omp/*.f -f
set ../lib/libwave_omp.a -L
+self,if=wavevm.
set ~/wave/cmz/*.f -f
set ../lib/libwave_omp.a -L
+self.

+self,if=vms.
set WAVE_ROOT:[STAGE]CMZ_*.FOR -f
+self.

+self,if=-wavevm.
set '~/wav/shell/wgfor_omp.sh $compfile' -C F77
+self,if=wavevm.
set '~/wave/shell/wgfor_omp.sh $compfile' -C F77
+self.

seq .
*seq CMNn
seq inclcmn

exec lastdir omp

exitm
+DECK,dbuff,T=KUMAC.
*CMZ :          29/12/2023  12.05.02  by  Michael Scheer
*CMZ :  2.04/06 08/07/2023  10.05.24  by  Michael Scheer
*-- Author :    Michael Scheer   08/07/2023
grep +DECK, -b
buff
+PATCH,UFOR.
*CMZ :  1.00/00 01/10/97  17.57.14  by  Michael Scheer
+DECK,UOUT_PHOTON.
*CMZ :  4.01/04 17/10/2023  12.43.22  by  Michael Scheer
*CMZ :  2.15/00 15/03/2007  11.13.54  by  Michael Scheer
*CMZ : 00.02/05 19/03/97  14.10.43  by  Michael Scheer
*CMZ : 00.02/04 26/02/97  10.23.26  by  Michael Scheer
*-- Author :    Michael Scheer   25/02/97

      SUBROUTINE UOUT

C     INTERFACE FUER PHOTON
C     USER(1) MUSS KRITISCHE ENERGIE ENTHALTEN

C     EIGENTLICH IST DIE KRITISCHE ENERGIE UND GAMMA UNWICHTIG,
C     ABER VORERST FUER CHECKS MITAUSGEBEN.
C     PINCEN(2) MUSS NULL SEIN (FAKTOR 2)
C
C     AUSGEBEN WIRD dFLUX/dTHETA[mrad]

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,SPECT.
+SEQ,OBSERV.
+SEQ,FREQS.
+SEQ,USERVAR.


      INTEGER IFREQ
      DOUBLE PRECISION EGAMMA,PHOTONS

      WRITE(6,*)
      WRITE(6,*)'SUBROUTINE UOUT_PHOTON:'
      WRITE(6,*)'======================='
      WRITE(6,*)
      WRITE(6,*)'WRITING FILE FOR PHOTON'
      WRITE(6,*)'Ekrit (USER(1)):',USER(1)
      WRITE(6,*)


      IF (IPIN.NE.1) STOP '*** ERROR IN UOUT_PHOTON: IPIN.NE.1'
      IF (IF1DIM.NE.1) STOP '*** ERROR IN UOUT_PHOTON: IF1DIM.NE.1'
      IF (PINCEN(2).NE.0.0)STOP
     &  '*** ERROR IN UOUT_PHOTON: PINCEN(2).NE.0.0'

      OPEN(UNIT=99,FILE='WAVE.PHOTON',STATUS='NEW')

      WRITE(99,*)'WAVE.PHOTON'
      WRITE(99,*)ICODE,' ',CODE
      WRITE(99,*)USER(1),DMYGAMMA
      WRITE(99,*)PINW,PINH
      WRITE(99,*)OBSVDZ,OBSVDY
      WRITE(99,*)PINCEN
      WRITE(99,*)NFREQ

      DO IFREQ=1,NFREQ
        EGAMMA=FREQ(IFREQ)/USER(1)
        PHOTONS=WFLUXT(IFREQ)
     &    /1.327D13 ! 1.327e13 * Ebeam**2  * Icurr * H2(y) yields flux-dens.
     &    /BANWID*0.001D0
     &    *(PINCEN(1)/PINW/1000.0D0)
     &    /(DMYCUR*1000.0D0)
     &    /DMYENERGY**2
     &    /2.D0
        WRITE(99,*)EGAMMA,PHOTONS
      ENDDO

      CLOSE(99)

      RETURN
      END
+PATCH,$VERSION.
*CMZ :  1.00/00 01/10/97  18.09.06  by  Michael Scheer
+DECK,V4_01.
*CMZ :  4.01/04 28/12/2023  17.35.14  by  Michael Scheer
*CMZ :  4.01/03 04/07/2023  09.17.36  by  Michael Scheer
*CMZ :  4.01/02 14/05/2023  13.50.01  by  Michael Scheer
*CMZ :  4.01/01 15/03/2023  13.26.08  by  Michael Scheer
*CMZ :  4.01/00 14/03/2023  11.18.26  by  Michael Scheer
*-- Author :    Michael Scheer   14/03/2023
*________________________________________________________________________
*
*::>          VERSION  4.01/04   28/12/2023 17.35.14
*
* IUNDULATOR=2, bug removed from phase calculations
*________________________________________________________________________
*
*::>          VERSION  4.01/03   04/07/2023 09.17.36
*
* First Version for GITHUB
*________________________________________________________________________
*
*::>          VERSION  4.01/02   14/05/2023 13.50.01
*
* SPECTRUM now with AMPREP_OMP, i.e. call to URAD_PHASE
*________________________________________________________________________
*
*::>          VERSION  4.01/01   15/03/2023 13.26.08
*
*________________________________________________________________________
* Scripts for GITLAB improved
*
*::>          VERSION  4.01/00   14/03/2023 11.18.26
*
* First Version for GITLAB
*

+PATCH,SHELL,T=SHELL.
*CMZ :  2.57/05 10/04/2006  16.42.30  by  Michael Scheer
+DECK,compile_urad_phase  ,T=SHELL.
*CMZ :  4.01/04 07/11/2023  09.02.40  by  Michael Scheer
*CMZ :  4.01/02 04/04/2023  12.46.55  by  Michael Scheer
*CMZ :  4.01/00 13/02/2023  11.36.12  by  Michael Scheer
*-- Author : Michael Scheer
# +PATCH,//WAVE/SHELL
# +DECK,compile_urad_phase  ,T=SHELL.
rm -f b/urad_phase.exe

c f

echo
echo
echo

gfortran -c -O3 -cpp \
-ffpe-summary=invalid,zero,overflow \
-fopenmp \
-fcheck=all \
-fdec -fd-lines-as-comments \
-Wno-align-commons \
-ffixed-line-length-none \
-finit-local-zero -funroll-loops \
urad_modules.f

gfortran -c -O3 -cpp \
-ffpe-summary=invalid,zero,overflow \
-fopenmp \
-fcheck=all \
-fdec -fd-lines-as-comments \
-Wno-align-commons \
-ffixed-line-length-none \
-finit-local-zero -funroll-loops \
urad_util.f

gfortran -O3 -cpp \
-ffpe-summary=invalid,zero,overflow \
-fcheck=all \
-fopenmp \
-fdec -fd-lines-as-comments \
-Wno-align-commons \
-ffixed-line-length-none \
-finit-local-zero -funroll-loops \
urad_modules.o urad_util.o \
-o ../bin/urad_phase.exe \
urad_phase_main.f

c ..
+PATCH,CMNN,T=F77.
*CMZ :  3.03/02 09/12/2015  09.12.49  by  Michael Scheer
+KEEP,wversion.
*CMZ :  4.01/04 28/12/2023  17.35.14  by  Michael Scheer
*CMZ :  4.01/03 04/07/2023  09.17.35  by  Michael Scheer
*CMZ :  4.01/01 15/03/2023  13.26.08  by  Michael Scheer
*CMZ :  4.01/00 14/03/2023  11.18.26  by  Michael Scheer
*CMZ :  4.00/17 05/12/2022  09.05.41  by  Michael Scheer
*CMZ :  4.00/16 29/09/2022  11.26.43  by  Michael Scheer
*CMZ :  4.00/15 07/07/2022  19.48.27  by  Michael Scheer
*CMZ :  4.00/14 11/02/2022  10.51.49  by  Michael Scheer
*CMZ :  4.00/13 20/12/2021  16.35.59  by  Michael Scheer
*CMZ :  4.00/12 29/07/2021  10.04.11  by  Michael Scheer
*CMZ :  4.00/10 25/09/2020  11.26.26  by  Michael Scheer
*CMZ :  4.00/09 15/08/2020  09.03.43  by  Michael Scheer
*CMZ :  4.00/08 07/08/2020  11.11.08  by  Michael Scheer
*CMZ :  4.00/07 06/08/2020  11.15.07  by  Michael Scheer
*CMZ :  4.00/06 02/01/2020  12.17.28  by  Michael Scheer
*CMZ :  4.00/05 30/11/2019  16.49.12  by  Michael Scheer
*CMZ :  4.00/04 28/11/2019  13.59.11  by  Michael Scheer
*CMZ :  4.00/03 09/05/2019  11.05.46  by  Michael Scheer
*CMZ :  4.00/02 13/04/2019  10.07.02  by  Michael Scheer
*CMZ :  4.00/01 12/04/2019  13.43.35  by  Michael Scheer
*CMZ :  4.00/00 04/04/2019  19.42.59  by  Michael Scheer
*CMZ :  3.08/01 04/04/2019  12.02.56  by  Michael Scheer
*CMZ :  3.08/00 29/03/2019  15.51.16  by  Michael Scheer
*CMZ :  3.07/01 29/03/2019  15.50.21  by  Michael Scheer
*CMZ :  3.07/00 18/03/2019  10.37.17  by  Michael Scheer
*CMZ :  3.06/00 28/02/2019  17.26.47  by  Michael Scheer
*CMZ :  3.05/28 07/01/2019  17.17.16  by  Michael Scheer
*CMZ :  3.05/27 12/12/2018  12.21.10  by  Michael Scheer
*CMZ :  3.05/26 09/12/2018  13.47.24  by  Michael Scheer
*CMZ :  3.05/25 06/12/2018  10.32.29  by  Michael Scheer
*CMZ :  3.05/24 05/12/2018  10.15.05  by  Michael Scheer
*CMZ :  3.05/23 03/12/2018  18.36.19  by  Michael Scheer
*CMZ :  3.05/22 08/11/2018  16.06.25  by  Michael Scheer
*CMZ :  3.05/21 07/11/2018  12.38.51  by  Michael Scheer
*CMZ :  3.05/20 01/11/2018  17.21.41  by  Michael Scheer
*CMZ :  3.05/19 18/10/2018  14.59.42  by  Michael Scheer
*CMZ :  3.05/18 17/10/2018  09.19.45  by  Michael Scheer
*CMZ :  3.05/17 11/10/2018  13.23.03  by  Michael Scheer
*CMZ :  3.05/16 10/10/2018  14.54.29  by  Michael Scheer
*CMZ :  3.05/15 08/10/2018  18.46.43  by  Michael Scheer
*CMZ :  3.05/14 01/10/2018  14.06.12  by  Michael Scheer
*CMZ :  3.05/13 24/09/2018  14.47.49  by  Michael Scheer
*CMZ :  3.05/12 29/08/2018  14.01.19  by  Michael Scheer
*CMZ :  3.05/11 16/08/2018  15.24.39  by  Michael Scheer
*CMZ :  3.05/10 14/08/2018  11.03.03  by  Michael Scheer
*CMZ :  3.05/09 08/08/2018  14.26.55  by  Michael Scheer
*CMZ :  3.05/08 26/07/2018  15.29.40  by  Michael Scheer
*CMZ :  3.05/07 21/07/2018  16.41.09  by  Michael Scheer
*CMZ :  3.05/06 19/07/2018  15.14.45  by  Michael Scheer
*CMZ :  3.05/05 13/07/2018  14.31.21  by  Michael Scheer
*CMZ :  3.05/04 09/07/2018  11.39.31  by  Michael Scheer
*CMZ :  3.05/03 22/05/2018  07.40.41  by  Michael Scheer
*CMZ :  3.05/02 16/05/2018  08.36.56  by  Michael Scheer
*CMZ :  3.05/01 09/05/2018  09.27.05  by  Michael Scheer
*CMZ :  3.05/00 02/05/2018  12.32.13  by  Michael Scheer
*CMZ :  3.04/01 03/04/2018  14.28.15  by  Michael Scheer
*CMZ :  3.04/00 01/03/2018  16.59.23  by  Michael Scheer
*CMZ :  3.03/04 02/01/2018  16.28.17  by  Michael Scheer
*CMZ :  3.03/03 11/07/2017  12.45.21  by  Michael Scheer
*CMZ :  3.03/02 28/06/2017  14.11.13  by  Michael Scheer
*CMZ :  3.03/01 13/11/2015  10.19.29  by  Michael Scheer
*CMZ :  3.03/00 30/09/2015  11.38.55  by  Michael Scheer
*CMZ :  3.02/09 09/07/2015  19.32.06  by  Michael Scheer
*CMZ :  3.02/08 25/06/2015  14.22.19  by  Michael Scheer
*CMZ :  3.02/07 24/06/2015  12.52.52  by  Michael Scheer
*CMZ :  3.02/06 18/06/2015  14.17.17  by  Michael Scheer
*CMZ :  3.02/05 13/04/2015  11.57.01  by  Michael Scheer
*CMZ :  3.02/04 18/03/2015  10.20.54  by  Michael Scheer
*CMZ :  3.02/03 10/11/2014  16.22.36  by  Michael Scheer
*CMZ :  3.02/02 22/10/2014  13.35.55  by  Michael Scheer
*CMZ :  3.02/01 16/10/2014  06.18.22  by  Michael Scheer
*CMZ :  3.01/10 19/08/2014  11.32.39  by  Michael Scheer
*CMZ :  3.01/09 12/08/2014  17.20.23  by  Michael Scheer
*CMZ :  3.01/08 12/08/2014  14.40.52  by  Michael Scheer
*CMZ :  3.01/07 23/06/2014  16.16.40  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  10.16.23  by  Michael Scheer
*CMZ :  3.01/05 13/06/2014  13.18.08  by  Michael Scheer
*CMZ :  3.01/04 11/06/2014  12.53.59  by  Michael Scheer
*CMZ :  3.01/03 20/03/2014  13.34.33  by  Michael Scheer
*CMZ :  3.01/02 27/02/2014  09.45.16  by  Michael Scheer
*CMZ :  3.01/01 31/07/2013  12.26.07  by  Michael Scheer
*CMZ :  3.01/00 18/07/2013  13.42.01  by  Michael Scheer
*CMZ :  3.00/02 10/04/2013  09.29.30  by  Michael Scheer
*CMZ :  3.00/01 03/04/2013  12.14.49  by  Michael Scheer
*CMZ :  3.00/00 14/03/2013  12.32.44  by  Michael Scheer
*CMZ :  2.70/12 05/03/2013  13.35.20  by  Michael Scheer
*CMZ :  2.70/11 22/02/2013  14.47.51  by  Michael Scheer
*CMZ :  2.70/10 16/01/2013  12.43.34  by  Michael Scheer
*CMZ :  2.70/09 15/01/2013  14.59.06  by  Michael Scheer
*CMZ :  2.70/08 14/01/2013  17.51.12  by  Michael Scheer
*CMZ :  2.70/07 14/01/2013  16.57.30  by  Michael Scheer
*CMZ :  2.70/06 14/01/2013  09.58.06  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  15.37.35  by  Michael Scheer
*CMZ :  2.70/04 21/12/2012  12.44.21  by  Michael Scheer
*CMZ :  2.70/03 17/12/2012  15.04.27  by  Michael Scheer
*CMZ :  2.70/02 14/12/2012  10.52.28  by  Michael Scheer
*CMZ :  2.70/01 12/12/2012  15.53.33  by  Michael Scheer
*CMZ :  2.70/00 11/12/2012  17.13.12  by  Michael Scheer
*CMZ :  2.69/02 08/11/2012  10.18.22  by  Michael Scheer
*CMZ :  2.69/01 31/10/2012  17.01.49  by  Michael Scheer
*CMZ :  2.69/00 30/10/2012  16.26.26  by  Michael Scheer
*CMZ :  2.68/05 19/10/2012  14.10.43  by  Unknown
*CMZ :  2.68/04 04/09/2012  11.30.37  by  Michael Scheer
*CMZ :  2.68/03 01/09/2012  16.18.21  by  Michael Scheer
*CMZ :  2.68/02 01/08/2012  15.11.42  by  Michael Scheer
*CMZ :  2.68/01 29/05/2012  17.05.39  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  16.51.01  by  Michael Scheer
*CMZ :  2.67/06 24/05/2012  14.37.50  by  Michael Scheer
*CMZ :  2.67/05 16/05/2012  14.35.39  by  Michael Scheer
*CMZ :  2.67/04 15/05/2012  13.09.47  by  Michael Scheer
*CMZ :  2.67/03 09/05/2012  16.33.57  by  Michael Scheer
*CMZ :  2.67/02 09/05/2012  12.08.14  by  Michael Scheer
*CMZ :  2.67/01 16/03/2012  09.17.00  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  16.27.31  by  Michael Scheer
*CMZ :  2.66/22 16/01/2012  12.52.11  by  Michael Scheer
*CMZ :  2.66/21 22/11/2011  13.55.20  by  Michael Scheer
*CMZ :  2.66/20 22/11/2011  10.47.52  by  Michael Scheer
*CMZ :  2.66/19 07/06/2011  14.55.12  by  Michael Scheer
*CMZ :  2.66/18 16/12/2010  12.54.41  by  Michael Scheer
*CMZ :  2.66/17 23/11/2010  10.03.05  by  Michael Scheer
*CMZ :  2.66/16 22/11/2010  14.04.02  by  Michael Scheer
*CMZ :  2.66/15 09/11/2010  16.18.55  by  Michael Scheer
*CMZ :  2.66/14 09/11/2010  15.41.06  by  Michael Scheer
*CMZ :  2.66/13 02/08/2010  09.16.32  by  Michael Scheer
*CMZ :  2.66/12 27/05/2010  02.41.06  by  Michael Scheer
*CMZ :  2.66/11 05/05/2010  08.25.31  by  Michael Scheer
*CMZ :  2.66/10 04/05/2010  12.42.54  by  Michael Scheer
*CMZ :  2.66/09 03/05/2010  16.13.02  by  Michael Scheer
*CMZ :  2.66/08 17/03/2010  14.47.26  by  Michael Scheer
*CMZ :  2.66/07 11/03/2010  15.52.20  by  Michael Scheer
*CMZ :  2.66/06 27/11/2009  16.15.00  by  Michael Scheer
*CMZ :  2.66/05 17/11/2009  16.10.37  by  Michael Scheer
*CMZ :  2.66/04 17/11/2009  10.13.48  by  Michael Scheer
*CMZ :  2.66/03 11/11/2009  16.17.18  by  Michael Scheer
*CMZ :  2.66/02 26/10/2009  14.31.27  by  Michael Scheer
*CMZ :  2.66/01 21/10/2009  09.36.11  by  Michael Scheer
*CMZ :  2.66/00 14/10/2009  11.57.53  by  Michael Scheer
*CMZ :  2.65/03 02/10/2009  13.22.43  by  Michael Scheer
*CMZ :  2.65/02 29/09/2009  12.22.19  by  Michael Scheer
*CMZ :  2.65/01 21/09/2009  14.36.00  by  Michael Scheer
*CMZ :  2.65/00 18/09/2009  09.46.14  by  Michael Scheer
*CMZ :  2.64/07 17/09/2009  16.28.06  by  Michael Scheer
*CMZ :  2.64/06 15/09/2009  15.17.17  by  Michael Scheer
*CMZ :  2.64/05 14/09/2009  11.36.46  by  Michael Scheer
*CMZ :  2.64/04 21/08/2009  17.40.03  by  Michael Scheer
*CMZ :  2.64/03 21/08/2009  17.33.33  by  Michael Scheer
*CMZ :  2.64/02 21/08/2009  17.28.12  by  Michael Scheer
*CMZ :  2.64/01 20/08/2009  15.48.35  by  Michael Scheer
*CMZ :  2.64/00 17/08/2009  09.32.48  by  Michael Scheer
*CMZ :  2.63/05 14/08/2009  13.07.07  by  Michael Scheer
*CMZ :  2.63/04 22/07/2009  07.41.27  by  Michael Scheer
*CMZ :  2.63/03 02/06/2009  16.25.15  by  Michael Scheer
*CMZ :  2.63/02 08/04/2008  12.21.25  by  Michael Scheer
*CMZ :  2.63/01 16/01/2008  13.14.36  by  Michael Scheer
*CMZ :  2.63/00 11/01/2008  16.42.42  by  Michael Scheer
*CMZ :  2.62/04 03/01/2008  17.16.00  by  Michael Scheer
*CMZ :  2.62/03 17/07/2007  16.15.46  by  Michael Scheer
*CMZ :  2.62/02 16/07/2007  11.28.09  by  Michael Scheer
*CMZ :  2.62/01 24/04/2007  12.00.53  by  Michael Scheer
*CMZ :  2.62/00 17/04/2007  08.49.12  by  Michael Scheer
*CMZ :  2.61/06 12/04/2007  13.39.57  by  Michael Scheer
*CMZ :  2.61/05 12/04/2007  09.31.22  by  Michael Scheer
*CMZ :  2.61/04 29/03/2007  16.31.37  by  Michael Scheer
*CMZ :  2.61/03 27/03/2007  13.29.11  by  Michael Scheer
*CMZ :  2.61/02 26/03/2007  20.10.31  by  Michael Scheer
*CMZ :  2.61/01 15/02/2007  14.24.24  by  Michael Scheer
*CMZ :  2.61/00 30/01/2007  20.26.41  by  Michael Scheer
*CMZ :  2.60/00 26/01/2007  10.51.28  by  Michael Scheer
*CMZ :  2.59/02 25/01/2007  16.09.23  by  Michael Scheer
*CMZ :  2.59/01 24/01/2007  14.32.08  by  Michael Scheer
*CMZ :  2.59/00 23/01/2007  15.40.42  by  Michael Scheer
*CMZ :  2.58/01 23/01/2007  13.25.42  by  Michael Scheer
*CMZ :  2.58/00 16/01/2007  17.45.21  by  Michael Scheer
*CMZ :  2.57/05 10/01/2007  13.39.09  by  Michael Scheer
*CMZ :  2.57/04 01/02/2006  16.20.51  by  Michael Scheer
*CMZ :  2.57/03 23/12/2005  11.48.02  by  Michael Scheer
*CMZ :  2.57/02 09/12/2005  11.14.20  by  Michael Scheer
*CMZ :  2.57/01 22/11/2005  13.32.35  by  Michael Scheer
*CMZ :  2.57/00 22/11/2005  12.35.13  by  Michael Scheer
*CMZ :  2.56/02 21/10/2005  16.32.46  by  Michael Scheer
*CMZ :  2.56/01 21/10/2005  12.35.26  by  Michael Scheer
*CMZ :  2.56/00 17/10/2005  13.31.23  by  Michael Scheer
*CMZ :  2.55/01 10/08/2005  16.12.03  by  Michael Scheer
*CMZ :  2.55/00 10/08/2005  16.09.23  by  Michael Scheer
*CMZ :  2.54/07 16/06/2005  12.25.52  by  Michael Scheer
*CMZ :  2.54/06 02/06/2005  13.55.14  by  Michael Scheer
*CMZ :  2.54/05 02/06/2005  08.17.11  by  Michael Scheer
*CMZ :  2.54/04 19/04/2005  14.13.30  by  Michael Scheer
*CMZ :  2.54/03 18/04/2005  08.56.03  by  Michael Scheer
*CMZ :  2.54/02 13/04/2005  13.53.54  by  Michael Scheer
*CMZ :  2.54/01 13/04/2005  09.16.21  by  Michael Scheer
*CMZ :  2.54/00 28/02/2005  17.31.43  by  Michael Scheer
*CMZ :  2.53/05 25/02/2005  12.01.49  by  Michael Scheer
*CMZ :  2.53/04 10/02/2005  10.01.45  by  Michael Scheer
*CMZ :  2.53/03 26/01/2005  15.37.37  by  Michael Scheer
*CMZ :  2.53/02 25/01/2005  18.20.37  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  13.29.48  by  Michael Scheer
*CMZ :  2.53/00 21/01/2005  17.24.28  by  Michael Scheer
*CMZ :  2.52/15 05/01/2005  16.38.59  by  Michael Scheer
*CMZ :  2.52/14 22/12/2004  16.29.18  by  Michael Scheer
*CMZ :  2.52/13 16/12/2004  21.17.54  by  Michael Scheer
*CMZ :  2.52/12 08/12/2004  14.07.27  by  Michael Scheer
*CMZ :  2.52/11 08/12/2004  13.39.53  by  Michael Scheer
*CMZ :  2.52/10 05/11/2004  17.17.40  by  Michael Scheer
*CMZ :  2.52/09 29/10/2004  13.08.10  by  Michael Scheer
*CMZ :  2.52/08 14/10/2004  14.53.32  by  Michael Scheer
*CMZ :  2.52/07 14/10/2004  09.24.22  by  Michael Scheer
*CMZ :  2.52/05 17/08/2004  15.57.30  by  Michael Scheer
*CMZ :  2.52/04 13/07/2004  08.24.53  by  Michael Scheer
*CMZ :  2.52/03 08/07/2004  13.38.16  by  Michael Scheer
*CMZ :  2.52/02 08/07/2004  10.29.14  by  Michael Scheer
*CMZ :  2.52/01 30/06/2004  16.24.39  by  Michael Scheer
*CMZ :  2.52/00 30/06/2004  10.54.14  by  Michael Scheer
*CMZ :  2.51/03 23/06/2004  12.25.44  by  Michael Scheer
*CMZ :  2.51/02 22/06/2004  16.31.28  by  Michael Scheer
*CMZ :  2.51/01 17/06/2004  16.18.20  by  Michael Scheer
*CMZ :  2.51/00 26/05/2004  16.34.25  by  Michael Scheer
*CMZ :  2.50/03 10/05/2004  14.41.11  by  Michael Scheer
*CMZ :  2.50/02 30/04/2004  15.33.31  by  Michael Scheer
*CMZ :  2.50/01 30/04/2004  08.58.23  by  Michael Scheer
*CMZ :  2.50/00 29/04/2004  18.46.23  by  Michael Scheer
*CMZ :  2.49/01 23/03/2004  14.32.47  by  Michael Scheer
*CMZ :  2.48/04 17/03/2004  14.54.00  by  Michael Scheer
*CMZ :  2.48/03 10/03/2004  16.04.11  by  Michael Scheer
*CMZ :  2.48/02 03/03/2004  11.26.16  by  Michael Scheer
*CMZ :  2.48/01 02/03/2004  16.44.04  by  Michael Scheer
*CMZ :  2.48/00 01/03/2004  18.05.54  by  Michael Scheer
*CMZ :  2.47/23 17/02/2004  13.48.36  by  Michael Scheer
*CMZ :  2.47/22 03/12/2003  13.18.07  by  Michael Scheer
*CMZ :  2.47/21 03/12/2003  09.50.02  by  Michael Scheer
*CMZ :  2.47/20 01/12/2003  15.35.07  by  Michael Scheer
*CMZ :  2.47/19 01/12/2003  08.24.44  by  Michael Scheer
*CMZ :  2.47/18 27/11/2003  14.46.01  by  Michael Scheer
*CMZ :  2.47/17 12/09/2003  10.10.52  by  Michael Scheer
*CMZ :  2.47/16 11/09/2003  15.10.44  by  Michael Scheer
*CMZ :  2.47/15 04/09/2003  09.28.29  by  Michael Scheer
*CMZ :  2.47/14 07/08/2003  09.44.02  by  Michael Scheer
*CMZ :  2.47/13 03/07/2003  09.57.40  by  Michael Scheer
*CMZ :  2.47/12 03/07/2003  09.56.41  by  Michael Scheer
*CMZ :  2.47/11 30/05/2003  12.54.22  by  Michael Scheer
*CMZ :  2.47/10 30/05/2003  12.43.23  by  Michael Scheer
*CMZ :  2.47/09 27/05/2003  15.58.18  by  Michael Scheer
*CMZ :  2.47/08 20/05/2003  15.48.28  by  Michael Scheer
*CMZ :  2.47/07 15/04/2003  10.52.36  by  Michael Scheer
*CMZ :  2.47/06 28/03/2003  15.40.56  by  Michael Scheer
*CMZ :  2.47/05 27/03/2003  15.27.38  by  Michael Scheer
*CMZ :  2.47/04 13/03/2003  11.06.38  by  Michael Scheer
*CMZ :  2.47/03 12/03/2003  16.02.35  by  Michael Scheer
*CMZ :  2.47/02 12/03/2003  10.54.25  by  Michael Scheer
*CMZ :  2.47/01 10/03/2003  11.57.24  by  Michael Scheer
*CMZ :  2.46/02 07/03/2003  11.17.22  by  Michael Scheer
*CMZ :  2.46/01 18/12/2002  11.47.23  by  Michael Scheer
*CMZ :  2.46/00 17/12/2002  16.46.49  by  Michael Scheer
*CMZ :  2.45/03 17/12/2002  15.15.55  by  Michael Scheer
*CMZ :  2.45/02 16/12/2002  14.36.34  by  Michael Scheer
*CMZ :  2.45/01 13/12/2002  17.25.42  by  Michael Scheer
*CMZ :  2.44/03 13/12/2002  12.43.06  by  Michael Scheer
*CMZ :  2.44/02 13/12/2002  11.39.21  by  Michael Scheer
*CMZ :  2.44/01 12/12/2002  13.32.07  by  Michael Scheer
*CMZ :  2.44/00 15/11/2002  18.31.49  by  Michael Scheer
*CMZ :  2.42/04 29/10/2002  11.33.36  by  Michael Scheer
*CMZ :  2.42/03 13/09/2002  18.47.33  by  Michael Scheer
*CMZ :  2.42/02 12/09/2002  11.07.58  by  Michael Scheer
*CMZ :  2.42/01 09/09/2002  18.56.25  by  Michael Scheer
*CMZ :  2.41/13 03/09/2002  14.29.39  by  Michael Scheer
*CMZ :  2.41/12 22/08/2002  12.13.49  by  Michael Scheer
*CMZ :  2.41/11 21/08/2002  11.28.45  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.50.10  by  Michael Scheer
*CMZ :  2.41/09 14/08/2002  17.27.24  by  Michael Scheer
*CMZ :  2.41/08 14/08/2002  17.06.27  by  Michael Scheer
*CMZ :  2.41/07 30/07/2002  12.13.11  by  Michael Scheer
*CMZ :  2.41/06 10/05/2002  15.26.01  by  Michael Scheer
*CMZ :  2.41/05 18/04/2002  11.47.34  by  Michael Scheer
*CMZ :  2.41/04 16/04/2002  14.29.54  by  Michael Scheer
*CMZ :  2.41/03 21/03/2002  12.44.56  by  Michael Scheer
*CMZ :  2.41/01 21/03/2002  12.36.42  by  Michael Scheer
*CMZ :  2.41/00 20/03/2002  19.24.01  by  Michael Scheer
*CMZ :  2.40/04 20/03/2002  12.33.26  by  Michael Scheer
*CMZ :  2.40/02 14/03/2002  16.23.09  by  Michael Scheer
*CMZ :  2.40/01 12/03/2002  14.36.49  by  Michael Scheer
*CMZ :  2.40/00 12/03/2002  14.28.59  by  Michael Scheer
*CMZ :  2.39/02 22/01/2002  13.35.44  by  Michael Scheer
*CMZ :  2.39/01 15/01/2002  16.49.21  by  Michael Scheer
*CMZ :  2.39/00 14/01/2002  14.37.58  by  Michael Scheer
*CMZ :  2.38/03 13/12/2001  15.06.40  by  Michael Scheer
*CMZ :  2.38/02 13/12/2001  13.44.34  by  Michael Scheer
*CMZ :  2.38/01 13/12/2001  12.16.53  by  Michael Scheer
*CMZ :  2.37/07 12/12/2001  14.47.52  by  Michael Scheer
*CMZ :  2.37/06 07/12/2001  15.02.02  by  Michael Scheer
*CMZ :  2.37/05 07/12/2001  14.52.16  by  Michael Scheer
*CMZ :  2.37/04 05/12/2001  17.37.12  by  Michael Scheer
*CMZ :  2.37/03 23/11/2001  18.19.34  by  Michael Scheer
*CMZ :  2.37/02 15/11/2001  17.25.18  by  Michael Scheer
*CMZ :  2.37/01 14/11/2001  11.08.43  by  Michael Scheer
*CMZ :  2.37/00 13/11/2001  17.33.11  by  Michael Scheer
*CMZ :  2.36/01 08/11/2001  17.39.47  by  Michael Scheer
*CMZ :  2.36/00 08/11/2001  15.34.30  by  Michael Scheer
*CMZ :  2.35/02 30/10/2001  17.15.18  by  Michael Scheer
*CMZ :  2.35/01 17/10/2001  11.40.54  by  Michael Scheer
*CMZ :  2.35/00 26/09/2001  17.19.48  by  Michael Scheer
*CMZ :  2.34/09 26/09/2001  17.17.20  by  Michael Scheer
*CMZ :  2.34/08 17/09/2001  19.44.50  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  17.41.49  by  Michael Scheer
*CMZ :  2.34/06 23/08/2001  17.38.11  by  Michael Scheer
*CMZ :  2.34/04 11/07/2001  11.20.36  by  Michael Scheer
*CMZ :  2.34/02 02/07/2001  17.25.12  by  Michael Scheer
*CMZ :  2.34/00 11/05/2001  17.27.00  by  Michael Scheer
*CMZ :  2.33/09 10/05/2001  18.03.20  by  Michael Scheer
*CMZ :  2.33/08 08/05/2001  17.52.21  by  Michael Scheer
*CMZ :  2.33/07 08/05/2001  17.43.33  by  Michael Scheer
*CMZ :  2.33/06 04/05/2001  13.56.57  by  Michael Scheer
*CMZ :  2.33/05 04/05/2001  11.42.46  by  Michael Scheer
*CMZ :  2.33/04 04/05/2001  11.37.04  by  Michael Scheer
*CMZ :  2.33/03 04/05/2001  11.15.03  by  Michael Scheer
*CMZ :  2.33/02 03/05/2001  17.23.54  by  Michael Scheer
*CMZ :  2.33/01 03/05/2001  14.01.01  by  Michael Scheer
*CMZ :  2.32/04 26/04/2001  12.37.02  by  Michael Scheer
*CMZ :  2.32/03 26/04/2001  11.12.11  by  Michael Scheer
*CMZ :  2.32/02 26/04/2001  11.09.43  by  Michael Scheer
*CMZ :  2.32/01 25/04/2001  19.09.17  by  Michael Scheer
*CMZ :  2.32/00 25/04/2001  17.14.54  by  Michael Scheer
*CMZ :  2.31/01 25/04/2001  17.13.47  by  Michael Scheer
*CMZ :  2.31/00 24/04/2001  16.07.58  by  Michael Scheer
*CMZ :  2.30/04 23/04/2001  12.34.39  by  Michael Scheer
*CMZ :  2.30/03 20/04/2001  16.32.24  by  Michael Scheer
*CMZ :  2.30/02 12/04/2001  19.12.58  by  Michael Scheer
*CMZ :  2.30/01 12/04/2001  18.24.05  by  Michael Scheer
*CMZ :  2.30/00 11/04/2001  19.35.18  by  Michael Scheer
*CMZ :  2.20/12 11/04/2001  19.33.04  by  Michael Scheer
*CMZ :  2.20/11 11/04/2001  16.16.37  by  Michael Scheer
*CMZ :  2.20/10 10/04/2001  12.26.28  by  Michael Scheer
*CMZ :  2.20/09 03/04/2001  14.52.40  by  Michael Scheer
*CMZ :  2.20/08 18/03/2001  22.18.21  by  Michael Scheer
*CMZ :  2.20/07 18/03/2001  17.09.21  by  Michael Scheer
*CMZ :  2.20/06 15/03/2001  17.20.43  by  Michael Scheer
*CMZ :  2.20/04 09/03/2001  19.55.49  by  Michael Scheer
*CMZ :  2.20/03 23/02/2001  15.16.41  by  Michael Scheer
*CMZ :  2.20/02 21/02/2001  11.41.58  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.33.29  by  Michael Scheer
*CMZ : 00.01/04 28/11/94  17.27.56  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  15.13.26  by  Michael Scheer
*-- Author :Michael Scheer
     &  '          *       VERSION 4.01/04   28.12.2023        *'
+self,if=versdum.
Maszstab           ********VERSION 1.23/45 *********************
+self.

+KEEP,CONTRL.
*CMZ :  4.01/04 17/10/2023  13.03.54  by  Michael Scheer
*CMZ :  4.01/02 04/05/2023  09.42.54  by  Michael Scheer
*CMZ :  4.00/15 04/04/2022  10.24.47  by  Michael Scheer
*CMZ :  4.00/11 16/05/2021  15.27.36  by  Michael Scheer
*CMZ :  4.00/07 05/05/2020  18.12.57  by  Michael Scheer
*CMZ :  4.00/06 02/12/2019  12.04.53  by  Michael Scheer
*CMZ :  3.05/01 03/05/2018  11.26.16  by  Michael Scheer
*CMZ :  3.05/00 25/04/2018  15.20.02  by  Michael Scheer
*CMZ :  3.03/04 27/11/2017  14.31.32  by  Michael Scheer
*CMZ :  3.03/02 11/12/2015  12.41.59  by  Michael Scheer
*CMZ :  3.02/03 10/11/2014  10.54.59  by  Michael Scheer
*CMZ :  3.02/00 10/09/2014  11.58.23  by  Michael Scheer
*CMZ :  3.01/00 23/05/2013  12.58.00  by  Michael Scheer
*CMZ :  2.68/02 18/06/2012  08.32.21  by  Michael Scheer
*CMZ :  2.67/02 30/04/2012  15.32.33  by  Michael Scheer
*CMZ :  2.67/00 10/02/2012  09.32.25  by  Michael Scheer
*CMZ :  2.66/20 22/11/2011  10.02.36  by  Michael Scheer
*CMZ :  2.66/03 03/11/2009  10.36.14  by  Michael Scheer
*CMZ :  2.66/02 25/10/2009  18.51.21  by  Michael Scheer
*CMZ :  2.66/00 03/10/2009  10.41.16  by  Michael Scheer
*CMZ :  2.63/05 22/09/2009  09.52.39  by  Michael Scheer
*CMZ :  2.61/02 15/03/2007  11.13.25  by  Michael Scheer
*CMZ :  2.54/05 19/05/2005  08.16.19  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  10.35.00  by  Michael Scheer
*CMZ :  2.52/16 17/01/2005  12.51.54  by  Michael Scheer
*CMZ :  2.52/13 15/12/2004  10.22.51  by  Michael Scheer
*CMZ :  2.50/02 30/04/2004  15.30.01  by  Michael Scheer
*CMZ :  2.48/04 12/03/2004  14.29.11  by  Michael Scheer
*CMZ :  2.47/23 17/02/2004  09.32.25  by  Michael Scheer
*CMZ :  2.47/08 15/05/2003  16.10.09  by  Michael Scheer
*CMZ :  2.46/00 17/12/2002  15.37.06  by  Michael Scheer
*CMZ :  2.44/00 15/11/2002  15.38.11  by  Michael Scheer
*CMZ :  2.41/13 22/08/2002  13.33.58  by  Michael Scheer
*CMZ :  2.40/00 04/03/2002  12.22.17  by  Michael Scheer
*CMZ :  2.37/06 07/12/2001  14.56.59  by  Michael Scheer
*CMZ :  2.31/01 25/04/2001  11.16.16  by  Michael Scheer
*CMZ :  2.30/03 20/04/2001  14.55.56  by  Michael Scheer
*CMZ :  2.16/08 25/10/2000  12.03.15  by  Michael Scheer
*CMZ :  2.16/00 09/06/2000  10.38.39  by  Michael Scheer
*CMZ :  2.15/00 15/05/2000  16.29.51  by  Michael Scheer
*CMZ :  2.14/02 27/04/2000  09.34.00  by  Michael Scheer
*CMZ :  2.13/02 14/12/99  16.34.53  by  Michael Scheer
*CMZ :  2.12/04 27/08/99  11.47.41  by  Michael Scheer
*CMZ :  2.12/00 03/06/99  15.39.28  by  Michael Scheer
*CMZ :  2.10/01 18/02/99  11.12.35  by  Michael Scheer
*CMZ :  2.02/00 12/02/99  16.38.34  by  Michael Scheer
*CMZ :  2.01/00 19/01/99  11.00.55  by  Michael Scheer
*CMZ :  2.00/00 06/01/99  15.44.04  by  Michael Scheer
*CMZ :  1.03/06 25/09/98  11.15.49  by  Michael Scheer
*CMZ :  1.02/00 06/01/98  15.19.43  by  Michael Scheer
*CMZ :  1.01/00 26/11/97  17.27.50  by  Michael Scheer
*CMZ :  1.00/00 23/09/97  12.28.25  by  Michael Scheer
*CMZ : 00.02/04 14/02/97  12.24.12  by  Michael Scheer
*CMZ : 00.02/03 22/01/97  12.17.34  by  Michael Scheer
*CMZ : 00.02/02 15/01/97  10.44.29  by  Michael Scheer
*CMZ : 00.02/00 25/11/96  14.48.54  by  Michael Scheer
*CMZ : 00.01/08 18/07/95  10.10.22  by  Michael Scheer
*CMZ : 00.01/07 08/03/95  16.44.52  by  Michael Scheer
*CMZ : 00.01/04 09/12/94  11.23.19  by  Michael Scheer
*CMZ : 00.01/03 28/11/94  11.34.21  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  13.43.54  by  Michael Scheer
*CMZ : 00.01/01 23/06/94  13.23.42  by  Michael Scheer
*CMZ : 00.00/07 25/05/94  16.27.38  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  15.11.40  by  Michael Scheer
*-- Author : Michael Scheer
+SELF,IF=HPUX,TRUE64.
      DOUBLE PRECISION DABS

+SELF.
      DOUBLE PRECISION ECPHOTON,XSTART,XINTER,XSTOP,XIANF,XIEND,GWINFC,BL0CUT,BL0HYS
     &  ,DMYGAMMA,DMYBETA,VXIN,VYIN,DMYCUR,BANWID,D1MBETA
     &  ,VZIN,YSTART,ZSTART,DEVLEN,DEVLEN2,DMYENERGY,GMOM,EMOM
     &  ,XSTARTH,XSTOPH,DBRHO,BMOVECUT
     &  ,BXSTART,BYSTART,BZSTART,AXSTART,AYSTART,AZSTART
     &  ,BXSTOP,BYSTOP,BZSTOP,AXSTOP,AYSTOP,AZSTOP,XBSYM

      INTEGER       LIDIM,NBDIM,NOMDIM,IBFDIM4,IBFDIM2,IANZPL,LUNGFI,
     &  LUNGFO,IWFILSP0,IWFILSPF,IWFILPOW,
     &  NXPAN,NYPAN,
     &  ICODE,KOUT,KBFELD,KHALBA,KHALBASY,KUNDUGAP,KBEXTERN,KBAMWLS,
     &  IRFILF,IBGAUSS,KCIRC,
     &  KSIGN,ICHECK,KBETAX,IFORM0,IFORM,
     &  IWFILB0,IRFILB0,IWFILF,IWSECTMAGS,IRFILP,IRFILB,ITRAKT,
     &  IWFILT0,IRFILT0,IWFILL0,IRFILL0,
     &  IEXPL0,NLPOI,IWFILL,IWFILA,IRFILA,ISAVLO,
     &  IOPTIC,IGENFUN,IDISPER,IEMIT,IERZANA,IEMIAHW,
     &  IBHARD,IERZFUN,IRANDO,IBHTRACK,IBHELM,KBGENESIS,ISPLINE,
     &  IBSYM,IWLSOPT,IKBFORM,IRBTAB,NBTAB,IJUST,MYINUM,NSTEPMX,
     &  ICTEST ,IHFOLD,IBSYMY,IBSYMZ,
     &  NWMAX,ISPEC,IVELOFIELD,NDFREQ,NDOBSV,IFREQ2P,IWFILINT,JWFILINT,
     &  IHPIN,
     &  NDPAWC,IPIN,IPOLA,ifold,ibunch,ISPECANA,NGCOEF,ISPECMODE,
     &  NDMASHZ,NDMASHY,NDOBSVZ,NDOBSVY,ISIGUSR,ISPECINT,
     &  IPINALL,IHBOOK,IHINDEX,
     &  IHTRACK,IHTRSMP,IHTRACKM,IHBETA,IUNIT,IUNITS,IF1DIM,IHFREQ,
     &  IPOWER,NDPOL,IBEAMPOL,KUCROSS,KMAGSEQ,IMGSQF,KMAGCOR,
     &  IWBTAB,IABEND,irbmap6,iwbmap,
     &  IWFILFL0,IWFILFLF,IRPHI,
     &  IUSEM,IPINCIRC,ISTOKES,irbtabzy,ifourbtabzy,IRBTABXYZ,ISPECANAF,IBRILL,
     &  IWFILSTO,IWFLSTOF,IWFLSTOE,IWFLSTOEF,IRFILSP0,IRFILSTO,ISPECSUM,
     &  IWFILS,IWFILSF,IWFILSE,IWFILSEF,
     &  IWFILB,IWFILBF,IWFILBE,IWFILBEF,
     &  IWFILBRILL,IWFILBRILLF,IWFILBRILLE,IWFILBRILLEF,
     &  KELLIP,IWFILRAY,KELLANA,
     &  IPHASE,IDOSE,IPHOTON,IEFOLD,IDESYNC,ISPECDIP,
     &  IUOUT,IUNAME,IUSTEP,IPHASEANA,
     &  KBPOLYH,IGFLOAT
     &  ,KBPOLY3D,IWBPOLY3D
     &  ,KBPOLY2DH,IWBPOLY2DH
     &  ,KBPharm,IWBpharm
     &  ,KBREC,KBPOLYMAG,IBATCH,kbundumag,kbundumap,kbunduverb
     &  ,IMAGSPLN,IHINPUT,IHOUTP,IMHBCOM,IMAGJOB
     &  ,IW_BLEN,IW_BLENF,IW_CIRC
     &  ,IHLIMIT_C,IHISINI_C,ihisascii,iroottrees,IBFORCE
     &  ,iampli,kampli,IAMPJIT,IUNDULATOR,IWIGGLER,IEXPERT,IBSUPER,IBERROR
     &  ,ieneloss,iefield,iroothdf5,nocern,iadjust,iwarnbmap,iwarnmyb,mthreads

      CHARACTER(65) CODE
      CHARACTER     CHISASCII

      COMMON/CONTRL/ECPHOTON,
     &  XSTART,XINTER,XSTOP,XIANF,XIEND,GWINFC,BL0CUT,BL0HYS
     &  ,DMYGAMMA,DMYBETA,VXIN,VYIN,DMYCUR,BANWID,D1MBETA
     &  ,VZIN,YSTART,ZSTART,DEVLEN,DEVLEN2,DMYENERGY,GMOM,EMOM
     &  ,XSTARTH,XSTOPH,DBRHO,BMOVECUT
     &  ,BXSTART,BYSTART,BZSTART,AXSTART,AYSTART,AZSTART
     &  ,BXSTOP,BYSTOP,BZSTOP,AXSTOP,AYSTOP,AZSTOP,XBSYM
     &  ,LIDIM,NBDIM,NOMDIM,IBFDIM4,IBFDIM2,IANZPL,LUNGFI,
     &  LUNGFO,IWFILSP0,IWFILSPF,IWFILPOW,
     &  NXPAN,NYPAN,
     &  ICODE,KOUT,KBFELD,KHALBA,KHALBASY,KUNDUGAP,KBEXTERN,KBAMWLS,
     &  IRFILF,IBGAUSS,KCIRC,
     &  KSIGN,ICHECK,KBETAX,IFORM0,IFORM,
     &  IWFILB0,IRFILB0,IWFILF,IWSECTMAGS,IRFILP,IRFILB,ITRAKT,
     &  IWFILT0,IRFILT0,IWFILL0,IRFILL0,
     &  IEXPL0,NLPOI,IWFILL,IWFILA,IRFILA,ISAVLO,
     &  IOPTIC,IGENFUN,IDISPER,IEMIT,IERZANA,IEMIAHW,
     &  IBHARD,IERZFUN,IRANDO,IBHTRACK,IBHELM,KBGENESIS,ISPLINE,
     &  IBSYM,IWLSOPT,IKBFORM,IRBTAB,NBTAB,IJUST,MYINUM,NSTEPMX,
     &  ICTEST ,IHFOLD,IBSYMY,IBSYMZ,
     &  NWMAX,ISPEC,IVELOFIELD,NDFREQ,NDOBSV,IFREQ2P,IWFILINT,JWFILINT,
     &  IHPIN,
     &  NDPAWC,IPIN,IPOLA,ifold,ibunch,ISPECANA,NGCOEF,ISPECMODE,
     &  NDMASHZ,NDMASHY,NDOBSVZ,NDOBSVY,ISIGUSR,ISPECINT,
     &  IPINALL,IHBOOK,IHINDEX,
     &  IHTRACK,IHTRSMP,IHTRACKM,IHBETA,IUNIT,IUNITS,IF1DIM,IHFREQ,
     &  IPOWER,NDPOL,IBEAMPOL,KUCROSS,KMAGSEQ,KMAGCOR,IMGSQF,
     &  IWBTAB,IABEND,irbmap6,iwbmap,
     &  IWFILFL0,IWFILFLF,IRPHI,
     &  IUSEM,IPINCIRC,ISTOKES,irbtabzy,ifourbtabzy,IRBTABXYZ,ISPECANAF,IBRILL,
     &  IWFILSTO,IWFLSTOF,IWFLSTOE,IWFLSTOEF,IRFILSP0,IRFILSTO,ISPECSUM,
     &  KELLIP,IWFILRAY,KELLANA,
     &  IPHASE,IDOSE,IPHOTON,IEFOLD,IDESYNC,ISPECDIP,IPHASEANA,
     &  IUOUT,IUNAME,IUSTEP,
     &  KBPOLYH,IGFLOAT
     &  ,KBPOLY3D,IWBPOLY3D
     &  ,KBPOLY2DH,IWBPOLY2DH,
     &  KBPharm,IWBpharm,
     &  IWFILS,IWFILSF,IWFILSE,IWFILSEF,
     &  IWFILB,IWFILBF,IWFILBE,IWFILBEF,
     &  IWFILBRILL,IWFILBRILLF,IWFILBRILLE,IWFILBRILLEF
     &  ,KBREC,KBPOLYMAG,IBATCH,kbundumag,kbundumap,kbunduverb
     &  ,IMAGSPLN,IHINPUT,IHOUTP,IMHBCOM, IMAGJOB
     &  ,IW_BLEN,IW_BLENF,IW_CIRC
     &  ,IHLIMIT_C,IHISINI_C,ihisascii,iroottrees,IBFORCE
     &  ,iampli,kampli,IAMPJIT,IUNDULATOR,IWIGGLER,IEXPERT,IBSUPER,IBERROR
     &  ,ieneloss,iefield,iroothdf5,iwarnbmap,iwarnmyb,mthreads
     &  ,CODE,CHISASCII


      NAMELIST/CONTRL/CODE,ECPHOTON,MYINUM,NSTEPMX,DMYENERGY,VXIN,VYIN,VZIN,BMOVECUT
     &  ,KBFELD,KHALBA,KHALBASY,KUNDUGAP,IRFILF,IRBTAB,
     &  KBEXTERN,KBAMWLS,IBGAUSS,KCIRC,IRPHI,
     &  xstart,XINTER,xstop,xianf,xiend,
     &  KSIGN,ICHECK,KBETAX,IFORM0,IFORM,
     &  IWFILB0,IRFILB0,IWFILF,IWSECTMAGS,IRFILP,IRFILB,ITRAKT,
     &  IWFILT0,IRFILT0,IWFILL0,GWINFC,BL0CUT,BL0HYS,
     &  IRFILL0,
     &  IEXPL0,NLPOI,IWFILL,IWFILA,IRFILA,ISAVLO,IOPTIC,
     &  IBHARD,IERZFUN,IERZANA,IGENFUN,
     &  IRANDO,IBHTRACK,IBHELM,KBGENESIS,ISPLINE,IDISPER,
     &  IBSYM,XBSYM,IWLSOPT,IKBFORM,IJUST,IBSYMY,IBSYMZ
     &  ,YSTART,ZSTART,DMYCUR,BANWID
     &  ,ICTEST,IEMIT,IEMIAHW,IHFOLD
     &  ,ISPEC,IVELOFIELD,IWFILSP0,IFREQ2P,IWFILINT,JWFILINT,IWFILSPF
     &  ,IWFILPOW
     &  ,IHPIN,IPOLA,ifold,ibunch,IPIN,ISPECANA,ISIGUSR,ISPECINT,ISPECMODE
     &  ,IPINALL,IHINDEX
     &  ,IHTRACK,IHTRSMP,IHTRACKM,IHBETA,IUNIT,IUNITS,IF1DIM,IHFREQ
     &  ,XSTARTH,XSTOPH,IPOWER,IBEAMPOL,KUCROSS,KMAGSEQ,KMAGCOR,IMGSQF,
     &  IWBTAB,irbmap6,iwbmap
     &  ,IWFILFL0,IWFILFLF
     &  ,IUSEM,IPINCIRC,ISTOKES,irbtabzy,ifourbtabzy,IRBTABXYZ,ISPECANAF,IBRILL
     &  ,IWFILSTO,IWFLSTOF,IWFLSTOE,IWFLSTOEF,IRFILSP0,IRFILSTO,ISPECSUM
     &  ,KELLIP,IWFILRAY,KELLANA
     &  ,IPHASE,IDOSE,IPHOTON,IEFOLD,IDESYNC,ISPECDIP,IPHASEANA
     &  ,IUOUT,IUNAME,IUSTEP
     &  ,KBPOLYH
     &  ,KBPOLY3D,IWBPOLY3D
     &  ,KBPOLY2DH,IWBPOLY2DH,
     &  KBPharm,IWBpharm,
     &  IWFILS,IWFILSF,IWFILSE,IWFILSEF,
     &  IWFILB,IWFILBF,IWFILBE,IWFILBEF,
     &  IWFILBRILL,IWFILBRILLF,IWFILBRILLE,IWFILBRILLEF
     &  ,KBREC,KBPOLYMAG,kbundumag,kbundumap,kbunduverb
     &  ,IMAGSPLN,IHINPUT,IHOUTP,IMHBCOM, ihisascii,iroottrees,
     &  ieneloss,iefield,iroothdf5,
     &  iampli,kampli,IAMPJIT,IUNDULATOR,IWIGGLER,IEXPERT,IBSUPER,IBERROR,ibforce,
     &  nocern,iadjust,mthreads,
     &  CHISASCII
+PATCH,CMN.
*CMZ :  1.00/00 01/10/97  17.56.52  by  Michael Scheer
+KEEP,wversion.
*CMZ :  4.01/04 28/12/2023  17.35.14  by  Michael Scheer
*CMZ :  4.01/03 04/07/2023  09.17.35  by  Michael Scheer
*CMZ :  4.01/01 15/03/2023  13.26.08  by  Michael Scheer
*CMZ :  4.01/00 14/03/2023  11.18.26  by  Michael Scheer
*CMZ :  4.00/17 05/12/2022  09.05.41  by  Michael Scheer
*CMZ :  4.00/16 29/09/2022  11.26.43  by  Michael Scheer
*CMZ :  4.00/15 07/07/2022  19.48.27  by  Michael Scheer
*CMZ :  4.00/14 11/02/2022  10.51.49  by  Michael Scheer
*CMZ :  4.00/13 20/12/2021  16.35.59  by  Michael Scheer
*CMZ :  4.00/12 29/07/2021  10.04.11  by  Michael Scheer
*CMZ :  4.00/10 25/09/2020  11.26.26  by  Michael Scheer
*CMZ :  4.00/09 15/08/2020  09.03.43  by  Michael Scheer
*CMZ :  4.00/08 07/08/2020  11.11.08  by  Michael Scheer
*CMZ :  4.00/07 06/08/2020  11.15.07  by  Michael Scheer
*CMZ :  4.00/06 02/01/2020  12.17.28  by  Michael Scheer
*CMZ :  4.00/05 30/11/2019  16.49.12  by  Michael Scheer
*CMZ :  4.00/04 28/11/2019  13.59.11  by  Michael Scheer
*CMZ :  4.00/03 09/05/2019  11.05.46  by  Michael Scheer
*CMZ :  4.00/02 13/04/2019  10.07.02  by  Michael Scheer
*CMZ :  4.00/01 12/04/2019  13.43.35  by  Michael Scheer
*CMZ :  4.00/00 04/04/2019  19.42.59  by  Michael Scheer
*CMZ :  3.08/01 04/04/2019  12.02.56  by  Michael Scheer
*CMZ :  3.08/00 29/03/2019  15.51.16  by  Michael Scheer
*CMZ :  3.07/01 29/03/2019  15.50.21  by  Michael Scheer
*CMZ :  3.07/00 18/03/2019  10.37.17  by  Michael Scheer
*CMZ :  3.06/00 28/02/2019  17.26.47  by  Michael Scheer
*CMZ :  3.05/28 07/01/2019  17.17.16  by  Michael Scheer
*CMZ :  3.05/27 12/12/2018  12.21.10  by  Michael Scheer
*CMZ :  3.05/26 09/12/2018  13.47.24  by  Michael Scheer
*CMZ :  3.05/25 06/12/2018  10.32.29  by  Michael Scheer
*CMZ :  3.05/24 05/12/2018  10.15.05  by  Michael Scheer
*CMZ :  3.05/23 03/12/2018  18.36.19  by  Michael Scheer
*CMZ :  3.05/22 08/11/2018  16.06.25  by  Michael Scheer
*CMZ :  3.05/21 07/11/2018  12.38.51  by  Michael Scheer
*CMZ :  3.05/20 01/11/2018  17.21.41  by  Michael Scheer
*CMZ :  3.05/19 18/10/2018  14.59.42  by  Michael Scheer
*CMZ :  3.05/18 17/10/2018  09.19.45  by  Michael Scheer
*CMZ :  3.05/17 11/10/2018  13.23.03  by  Michael Scheer
*CMZ :  3.05/16 10/10/2018  14.54.29  by  Michael Scheer
*CMZ :  3.05/15 08/10/2018  18.46.43  by  Michael Scheer
*CMZ :  3.05/14 01/10/2018  14.06.12  by  Michael Scheer
*CMZ :  3.05/13 24/09/2018  14.47.49  by  Michael Scheer
*CMZ :  3.05/12 29/08/2018  14.01.19  by  Michael Scheer
*CMZ :  3.05/11 16/08/2018  15.24.39  by  Michael Scheer
*CMZ :  3.05/10 14/08/2018  11.03.03  by  Michael Scheer
*CMZ :  3.05/09 08/08/2018  14.26.55  by  Michael Scheer
*CMZ :  3.05/08 26/07/2018  15.29.40  by  Michael Scheer
*CMZ :  3.05/07 21/07/2018  16.41.09  by  Michael Scheer
*CMZ :  3.05/06 19/07/2018  15.14.45  by  Michael Scheer
*CMZ :  3.05/05 13/07/2018  14.31.21  by  Michael Scheer
*CMZ :  3.05/04 09/07/2018  11.39.31  by  Michael Scheer
*CMZ :  3.05/03 22/05/2018  07.40.41  by  Michael Scheer
*CMZ :  3.05/02 16/05/2018  08.36.56  by  Michael Scheer
*CMZ :  3.05/01 09/05/2018  09.27.05  by  Michael Scheer
*CMZ :  3.05/00 02/05/2018  12.32.13  by  Michael Scheer
*CMZ :  3.04/01 03/04/2018  14.28.15  by  Michael Scheer
*CMZ :  3.04/00 01/03/2018  16.59.23  by  Michael Scheer
*CMZ :  3.03/04 02/01/2018  16.28.17  by  Michael Scheer
*CMZ :  3.03/03 11/07/2017  12.45.21  by  Michael Scheer
*CMZ :  3.03/02 28/06/2017  14.11.13  by  Michael Scheer
*CMZ :  3.03/01 13/11/2015  10.19.29  by  Michael Scheer
*CMZ :  3.03/00 30/09/2015  11.38.55  by  Michael Scheer
*CMZ :  3.02/09 09/07/2015  19.32.06  by  Michael Scheer
*CMZ :  3.02/08 25/06/2015  14.22.19  by  Michael Scheer
*CMZ :  3.02/07 24/06/2015  12.52.52  by  Michael Scheer
*CMZ :  3.02/06 18/06/2015  14.17.17  by  Michael Scheer
*CMZ :  3.02/05 13/04/2015  11.57.01  by  Michael Scheer
*CMZ :  3.02/04 18/03/2015  10.20.54  by  Michael Scheer
*CMZ :  3.02/03 10/11/2014  16.22.36  by  Michael Scheer
*CMZ :  3.02/02 22/10/2014  13.35.55  by  Michael Scheer
*CMZ :  3.02/01 16/10/2014  06.18.22  by  Michael Scheer
*CMZ :  3.01/10 19/08/2014  11.32.39  by  Michael Scheer
*CMZ :  3.01/09 12/08/2014  17.20.23  by  Michael Scheer
*CMZ :  3.01/08 12/08/2014  14.40.52  by  Michael Scheer
*CMZ :  3.01/07 23/06/2014  16.16.40  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  10.16.23  by  Michael Scheer
*CMZ :  3.01/05 13/06/2014  13.18.08  by  Michael Scheer
*CMZ :  3.01/04 11/06/2014  12.53.59  by  Michael Scheer
*CMZ :  3.01/03 20/03/2014  13.34.33  by  Michael Scheer
*CMZ :  3.01/02 27/02/2014  09.45.16  by  Michael Scheer
*CMZ :  3.01/01 31/07/2013  12.26.07  by  Michael Scheer
*CMZ :  3.01/00 18/07/2013  13.42.01  by  Michael Scheer
*CMZ :  3.00/02 10/04/2013  09.29.30  by  Michael Scheer
*CMZ :  3.00/01 03/04/2013  12.14.49  by  Michael Scheer
*CMZ :  3.00/00 14/03/2013  12.32.44  by  Michael Scheer
*CMZ :  2.70/12 05/03/2013  13.35.20  by  Michael Scheer
*CMZ :  2.70/11 22/02/2013  14.47.51  by  Michael Scheer
*CMZ :  2.70/10 16/01/2013  12.43.34  by  Michael Scheer
*CMZ :  2.70/09 15/01/2013  14.59.06  by  Michael Scheer
*CMZ :  2.70/08 14/01/2013  17.51.12  by  Michael Scheer
*CMZ :  2.70/07 14/01/2013  16.57.30  by  Michael Scheer
*CMZ :  2.70/06 14/01/2013  09.58.06  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  15.37.35  by  Michael Scheer
*CMZ :  2.70/04 21/12/2012  12.44.21  by  Michael Scheer
*CMZ :  2.70/03 17/12/2012  15.04.27  by  Michael Scheer
*CMZ :  2.70/02 14/12/2012  10.52.28  by  Michael Scheer
*CMZ :  2.70/01 12/12/2012  15.53.33  by  Michael Scheer
*CMZ :  2.70/00 11/12/2012  17.13.12  by  Michael Scheer
*CMZ :  2.69/02 08/11/2012  10.18.22  by  Michael Scheer
*CMZ :  2.69/01 31/10/2012  17.01.49  by  Michael Scheer
*CMZ :  2.69/00 30/10/2012  16.26.26  by  Michael Scheer
*CMZ :  2.68/05 19/10/2012  14.10.43  by  Unknown
*CMZ :  2.68/04 04/09/2012  11.30.37  by  Michael Scheer
*CMZ :  2.68/03 01/09/2012  16.18.21  by  Michael Scheer
*CMZ :  2.68/02 01/08/2012  15.11.42  by  Michael Scheer
*CMZ :  2.68/01 29/05/2012  17.05.39  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  16.51.01  by  Michael Scheer
*CMZ :  2.67/06 24/05/2012  14.37.50  by  Michael Scheer
*CMZ :  2.67/05 16/05/2012  14.35.39  by  Michael Scheer
*CMZ :  2.67/04 15/05/2012  13.09.47  by  Michael Scheer
*CMZ :  2.67/03 09/05/2012  16.33.57  by  Michael Scheer
*CMZ :  2.67/02 09/05/2012  12.08.14  by  Michael Scheer
*CMZ :  2.67/01 16/03/2012  09.17.00  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  16.27.31  by  Michael Scheer
*CMZ :  2.66/22 16/01/2012  12.52.11  by  Michael Scheer
*CMZ :  2.66/21 22/11/2011  13.55.20  by  Michael Scheer
*CMZ :  2.66/20 22/11/2011  10.47.52  by  Michael Scheer
*CMZ :  2.66/19 07/06/2011  14.55.12  by  Michael Scheer
*CMZ :  2.66/18 16/12/2010  12.54.41  by  Michael Scheer
*CMZ :  2.66/17 23/11/2010  10.03.05  by  Michael Scheer
*CMZ :  2.66/16 22/11/2010  14.04.02  by  Michael Scheer
*CMZ :  2.66/15 09/11/2010  16.18.55  by  Michael Scheer
*CMZ :  2.66/14 09/11/2010  15.41.06  by  Michael Scheer
*CMZ :  2.66/13 02/08/2010  09.16.32  by  Michael Scheer
*CMZ :  2.66/12 27/05/2010  02.41.06  by  Michael Scheer
*CMZ :  2.66/11 05/05/2010  08.25.31  by  Michael Scheer
*CMZ :  2.66/10 04/05/2010  12.42.54  by  Michael Scheer
*CMZ :  2.66/09 03/05/2010  16.13.02  by  Michael Scheer
*CMZ :  2.66/08 17/03/2010  14.47.26  by  Michael Scheer
*CMZ :  2.66/07 11/03/2010  15.52.20  by  Michael Scheer
*CMZ :  2.66/06 27/11/2009  16.15.00  by  Michael Scheer
*CMZ :  2.66/05 17/11/2009  16.10.37  by  Michael Scheer
*CMZ :  2.66/04 17/11/2009  10.13.48  by  Michael Scheer
*CMZ :  2.66/03 11/11/2009  16.17.18  by  Michael Scheer
*CMZ :  2.66/02 26/10/2009  14.31.27  by  Michael Scheer
*CMZ :  2.66/01 21/10/2009  09.36.11  by  Michael Scheer
*CMZ :  2.66/00 14/10/2009  11.57.53  by  Michael Scheer
*CMZ :  2.65/03 02/10/2009  13.22.43  by  Michael Scheer
*CMZ :  2.65/02 29/09/2009  12.22.19  by  Michael Scheer
*CMZ :  2.65/01 21/09/2009  14.36.00  by  Michael Scheer
*CMZ :  2.65/00 18/09/2009  09.46.14  by  Michael Scheer
*CMZ :  2.64/07 17/09/2009  16.28.06  by  Michael Scheer
*CMZ :  2.64/06 15/09/2009  15.17.17  by  Michael Scheer
*CMZ :  2.64/05 14/09/2009  11.36.46  by  Michael Scheer
*CMZ :  2.64/04 21/08/2009  17.40.03  by  Michael Scheer
*CMZ :  2.64/03 21/08/2009  17.33.33  by  Michael Scheer
*CMZ :  2.64/02 21/08/2009  17.28.12  by  Michael Scheer
*CMZ :  2.64/01 20/08/2009  15.48.35  by  Michael Scheer
*CMZ :  2.64/00 17/08/2009  09.32.48  by  Michael Scheer
*CMZ :  2.63/05 14/08/2009  13.07.07  by  Michael Scheer
*CMZ :  2.63/04 22/07/2009  07.41.27  by  Michael Scheer
*CMZ :  2.63/03 02/06/2009  16.25.15  by  Michael Scheer
*CMZ :  2.63/02 08/04/2008  12.21.25  by  Michael Scheer
*CMZ :  2.63/01 16/01/2008  13.14.36  by  Michael Scheer
*CMZ :  2.63/00 11/01/2008  16.42.42  by  Michael Scheer
*CMZ :  2.62/04 03/01/2008  17.16.00  by  Michael Scheer
*CMZ :  2.62/03 17/07/2007  16.15.46  by  Michael Scheer
*CMZ :  2.62/02 16/07/2007  11.28.09  by  Michael Scheer
*CMZ :  2.62/01 24/04/2007  12.00.53  by  Michael Scheer
*CMZ :  2.62/00 17/04/2007  08.49.12  by  Michael Scheer
*CMZ :  2.61/06 12/04/2007  13.39.57  by  Michael Scheer
*CMZ :  2.61/05 12/04/2007  09.31.22  by  Michael Scheer
*CMZ :  2.61/04 29/03/2007  16.31.37  by  Michael Scheer
*CMZ :  2.61/03 27/03/2007  13.29.11  by  Michael Scheer
*CMZ :  2.61/02 26/03/2007  20.10.31  by  Michael Scheer
*CMZ :  2.61/01 15/02/2007  14.24.24  by  Michael Scheer
*CMZ :  2.61/00 30/01/2007  20.26.41  by  Michael Scheer
*CMZ :  2.60/00 26/01/2007  10.51.28  by  Michael Scheer
*CMZ :  2.59/02 25/01/2007  16.09.23  by  Michael Scheer
*CMZ :  2.59/01 24/01/2007  14.32.08  by  Michael Scheer
*CMZ :  2.59/00 23/01/2007  15.40.42  by  Michael Scheer
*CMZ :  2.58/01 23/01/2007  13.25.42  by  Michael Scheer
*CMZ :  2.58/00 16/01/2007  17.45.21  by  Michael Scheer
*CMZ :  2.57/05 10/01/2007  13.39.09  by  Michael Scheer
*CMZ :  2.57/04 01/02/2006  16.20.51  by  Michael Scheer
*CMZ :  2.57/03 23/12/2005  11.48.02  by  Michael Scheer
*CMZ :  2.57/02 09/12/2005  11.14.20  by  Michael Scheer
*CMZ :  2.57/01 22/11/2005  13.32.35  by  Michael Scheer
*CMZ :  2.57/00 22/11/2005  12.35.13  by  Michael Scheer
*CMZ :  2.56/02 21/10/2005  16.32.46  by  Michael Scheer
*CMZ :  2.56/01 21/10/2005  12.35.26  by  Michael Scheer
*CMZ :  2.56/00 17/10/2005  13.31.23  by  Michael Scheer
*CMZ :  2.55/01 10/08/2005  16.12.03  by  Michael Scheer
*CMZ :  2.55/00 10/08/2005  16.09.23  by  Michael Scheer
*CMZ :  2.54/07 16/06/2005  12.25.52  by  Michael Scheer
*CMZ :  2.54/06 02/06/2005  13.55.14  by  Michael Scheer
*CMZ :  2.54/05 02/06/2005  08.17.11  by  Michael Scheer
*CMZ :  2.54/04 19/04/2005  14.13.30  by  Michael Scheer
*CMZ :  2.54/03 18/04/2005  08.56.03  by  Michael Scheer
*CMZ :  2.54/02 13/04/2005  13.53.54  by  Michael Scheer
*CMZ :  2.54/01 13/04/2005  09.16.21  by  Michael Scheer
*CMZ :  2.54/00 28/02/2005  17.31.43  by  Michael Scheer
*CMZ :  2.53/05 25/02/2005  12.01.49  by  Michael Scheer
*CMZ :  2.53/04 10/02/2005  10.01.45  by  Michael Scheer
*CMZ :  2.53/03 26/01/2005  15.37.37  by  Michael Scheer
*CMZ :  2.53/02 25/01/2005  18.20.37  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  13.29.48  by  Michael Scheer
*CMZ :  2.53/00 21/01/2005  17.24.28  by  Michael Scheer
*CMZ :  2.52/15 05/01/2005  16.38.59  by  Michael Scheer
*CMZ :  2.52/14 22/12/2004  16.29.18  by  Michael Scheer
*CMZ :  2.52/13 16/12/2004  21.17.54  by  Michael Scheer
*CMZ :  2.52/12 08/12/2004  14.07.27  by  Michael Scheer
*CMZ :  2.52/11 08/12/2004  13.39.53  by  Michael Scheer
*CMZ :  2.52/10 05/11/2004  17.17.40  by  Michael Scheer
*CMZ :  2.52/09 29/10/2004  13.08.10  by  Michael Scheer
*CMZ :  2.52/08 14/10/2004  14.53.32  by  Michael Scheer
*CMZ :  2.52/07 14/10/2004  09.24.22  by  Michael Scheer
*CMZ :  2.52/05 17/08/2004  15.57.30  by  Michael Scheer
*CMZ :  2.52/04 13/07/2004  08.24.53  by  Michael Scheer
*CMZ :  2.52/03 08/07/2004  13.38.16  by  Michael Scheer
*CMZ :  2.52/02 08/07/2004  10.29.14  by  Michael Scheer
*CMZ :  2.52/01 30/06/2004  16.24.39  by  Michael Scheer
*CMZ :  2.52/00 30/06/2004  10.54.14  by  Michael Scheer
*CMZ :  2.51/03 23/06/2004  12.25.44  by  Michael Scheer
*CMZ :  2.51/02 22/06/2004  16.31.28  by  Michael Scheer
*CMZ :  2.51/01 17/06/2004  16.18.20  by  Michael Scheer
*CMZ :  2.51/00 26/05/2004  16.34.25  by  Michael Scheer
*CMZ :  2.50/03 10/05/2004  14.41.11  by  Michael Scheer
*CMZ :  2.50/02 30/04/2004  15.33.31  by  Michael Scheer
*CMZ :  2.50/01 30/04/2004  08.58.23  by  Michael Scheer
*CMZ :  2.50/00 29/04/2004  18.46.23  by  Michael Scheer
*CMZ :  2.49/01 23/03/2004  14.32.47  by  Michael Scheer
*CMZ :  2.48/04 17/03/2004  14.54.00  by  Michael Scheer
*CMZ :  2.48/03 10/03/2004  16.04.11  by  Michael Scheer
*CMZ :  2.48/02 03/03/2004  11.26.16  by  Michael Scheer
*CMZ :  2.48/01 02/03/2004  16.44.04  by  Michael Scheer
*CMZ :  2.48/00 01/03/2004  18.05.54  by  Michael Scheer
*CMZ :  2.47/23 17/02/2004  13.48.36  by  Michael Scheer
*CMZ :  2.47/22 03/12/2003  13.18.07  by  Michael Scheer
*CMZ :  2.47/21 03/12/2003  09.50.02  by  Michael Scheer
*CMZ :  2.47/20 01/12/2003  15.35.07  by  Michael Scheer
*CMZ :  2.47/19 01/12/2003  08.24.44  by  Michael Scheer
*CMZ :  2.47/18 27/11/2003  14.46.01  by  Michael Scheer
*CMZ :  2.47/17 12/09/2003  10.10.52  by  Michael Scheer
*CMZ :  2.47/16 11/09/2003  15.10.44  by  Michael Scheer
*CMZ :  2.47/15 04/09/2003  09.28.29  by  Michael Scheer
*CMZ :  2.47/14 07/08/2003  09.44.02  by  Michael Scheer
*CMZ :  2.47/13 03/07/2003  09.57.40  by  Michael Scheer
*CMZ :  2.47/12 03/07/2003  09.56.41  by  Michael Scheer
*CMZ :  2.47/11 30/05/2003  12.54.22  by  Michael Scheer
*CMZ :  2.47/10 30/05/2003  12.43.23  by  Michael Scheer
*CMZ :  2.47/09 27/05/2003  15.58.18  by  Michael Scheer
*CMZ :  2.47/08 20/05/2003  15.48.28  by  Michael Scheer
*CMZ :  2.47/07 15/04/2003  10.52.36  by  Michael Scheer
*CMZ :  2.47/06 28/03/2003  15.40.56  by  Michael Scheer
*CMZ :  2.47/05 27/03/2003  15.27.38  by  Michael Scheer
*CMZ :  2.47/04 13/03/2003  11.06.38  by  Michael Scheer
*CMZ :  2.47/03 12/03/2003  16.02.35  by  Michael Scheer
*CMZ :  2.47/02 12/03/2003  10.54.25  by  Michael Scheer
*CMZ :  2.47/01 10/03/2003  11.57.24  by  Michael Scheer
*CMZ :  2.46/02 07/03/2003  11.17.22  by  Michael Scheer
*CMZ :  2.46/01 18/12/2002  11.47.23  by  Michael Scheer
*CMZ :  2.46/00 17/12/2002  16.46.49  by  Michael Scheer
*CMZ :  2.45/03 17/12/2002  15.15.55  by  Michael Scheer
*CMZ :  2.45/02 16/12/2002  14.36.34  by  Michael Scheer
*CMZ :  2.45/01 13/12/2002  17.25.42  by  Michael Scheer
*CMZ :  2.44/03 13/12/2002  12.43.06  by  Michael Scheer
*CMZ :  2.44/02 13/12/2002  11.39.21  by  Michael Scheer
*CMZ :  2.44/01 12/12/2002  13.32.07  by  Michael Scheer
*CMZ :  2.44/00 15/11/2002  18.31.49  by  Michael Scheer
*CMZ :  2.42/04 29/10/2002  11.33.36  by  Michael Scheer
*CMZ :  2.42/03 13/09/2002  18.47.33  by  Michael Scheer
*CMZ :  2.42/02 12/09/2002  11.07.58  by  Michael Scheer
*CMZ :  2.42/01 09/09/2002  18.56.25  by  Michael Scheer
*CMZ :  2.41/13 03/09/2002  14.29.39  by  Michael Scheer
*CMZ :  2.41/12 22/08/2002  12.13.49  by  Michael Scheer
*CMZ :  2.41/11 21/08/2002  11.28.45  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.50.10  by  Michael Scheer
*CMZ :  2.41/09 14/08/2002  17.27.24  by  Michael Scheer
*CMZ :  2.41/08 14/08/2002  17.06.27  by  Michael Scheer
*CMZ :  2.41/07 30/07/2002  12.13.11  by  Michael Scheer
*CMZ :  2.41/06 10/05/2002  15.26.01  by  Michael Scheer
*CMZ :  2.41/05 18/04/2002  11.47.34  by  Michael Scheer
*CMZ :  2.41/04 16/04/2002  14.29.54  by  Michael Scheer
*CMZ :  2.41/03 21/03/2002  12.44.56  by  Michael Scheer
*CMZ :  2.41/01 21/03/2002  12.36.42  by  Michael Scheer
*CMZ :  2.41/00 20/03/2002  19.24.01  by  Michael Scheer
*CMZ :  2.40/04 20/03/2002  12.33.26  by  Michael Scheer
*CMZ :  2.40/02 14/03/2002  16.23.09  by  Michael Scheer
*CMZ :  2.40/01 12/03/2002  14.36.49  by  Michael Scheer
*CMZ :  2.40/00 12/03/2002  14.28.59  by  Michael Scheer
*CMZ :  2.39/02 22/01/2002  13.35.44  by  Michael Scheer
*CMZ :  2.39/01 15/01/2002  16.49.21  by  Michael Scheer
*CMZ :  2.39/00 14/01/2002  14.37.58  by  Michael Scheer
*CMZ :  2.38/03 13/12/2001  15.06.40  by  Michael Scheer
*CMZ :  2.38/02 13/12/2001  13.44.34  by  Michael Scheer
*CMZ :  2.38/01 13/12/2001  12.16.53  by  Michael Scheer
*CMZ :  2.37/07 12/12/2001  14.47.52  by  Michael Scheer
*CMZ :  2.37/06 07/12/2001  15.02.02  by  Michael Scheer
*CMZ :  2.37/05 07/12/2001  14.52.16  by  Michael Scheer
*CMZ :  2.37/04 05/12/2001  17.37.12  by  Michael Scheer
*CMZ :  2.37/03 23/11/2001  18.19.34  by  Michael Scheer
*CMZ :  2.37/02 15/11/2001  17.25.18  by  Michael Scheer
*CMZ :  2.37/01 14/11/2001  11.08.43  by  Michael Scheer
*CMZ :  2.37/00 13/11/2001  17.33.11  by  Michael Scheer
*CMZ :  2.36/01 08/11/2001  17.39.47  by  Michael Scheer
*CMZ :  2.36/00 08/11/2001  15.34.30  by  Michael Scheer
*CMZ :  2.35/02 30/10/2001  17.15.18  by  Michael Scheer
*CMZ :  2.35/01 17/10/2001  11.40.54  by  Michael Scheer
*CMZ :  2.35/00 26/09/2001  17.19.48  by  Michael Scheer
*CMZ :  2.34/09 26/09/2001  17.17.20  by  Michael Scheer
*CMZ :  2.34/08 17/09/2001  19.44.50  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  17.41.49  by  Michael Scheer
*CMZ :  2.34/06 23/08/2001  17.38.11  by  Michael Scheer
*CMZ :  2.34/04 11/07/2001  11.20.36  by  Michael Scheer
*CMZ :  2.34/02 02/07/2001  17.25.12  by  Michael Scheer
*CMZ :  2.34/00 11/05/2001  17.27.00  by  Michael Scheer
*CMZ :  2.33/09 10/05/2001  18.03.20  by  Michael Scheer
*CMZ :  2.33/08 08/05/2001  17.52.21  by  Michael Scheer
*CMZ :  2.33/07 08/05/2001  17.43.33  by  Michael Scheer
*CMZ :  2.33/06 04/05/2001  13.56.57  by  Michael Scheer
*CMZ :  2.33/05 04/05/2001  11.42.46  by  Michael Scheer
*CMZ :  2.33/04 04/05/2001  11.37.04  by  Michael Scheer
*CMZ :  2.33/03 04/05/2001  11.15.03  by  Michael Scheer
*CMZ :  2.33/02 03/05/2001  17.23.54  by  Michael Scheer
*CMZ :  2.33/01 03/05/2001  14.01.01  by  Michael Scheer
*CMZ :  2.32/04 26/04/2001  12.37.02  by  Michael Scheer
*CMZ :  2.32/03 26/04/2001  11.12.11  by  Michael Scheer
*CMZ :  2.32/02 26/04/2001  11.09.43  by  Michael Scheer
*CMZ :  2.32/01 25/04/2001  19.09.17  by  Michael Scheer
*CMZ :  2.32/00 25/04/2001  17.14.54  by  Michael Scheer
*CMZ :  2.31/01 25/04/2001  17.13.47  by  Michael Scheer
*CMZ :  2.31/00 24/04/2001  16.07.58  by  Michael Scheer
*CMZ :  2.30/04 23/04/2001  12.34.39  by  Michael Scheer
*CMZ :  2.30/03 20/04/2001  16.32.24  by  Michael Scheer
*CMZ :  2.30/02 12/04/2001  19.12.58  by  Michael Scheer
*CMZ :  2.30/01 12/04/2001  18.24.05  by  Michael Scheer
*CMZ :  2.30/00 11/04/2001  19.35.18  by  Michael Scheer
*CMZ :  2.20/12 11/04/2001  19.33.04  by  Michael Scheer
*CMZ :  2.20/11 11/04/2001  16.16.37  by  Michael Scheer
*CMZ :  2.20/10 10/04/2001  12.26.28  by  Michael Scheer
*CMZ :  2.20/09 03/04/2001  14.52.40  by  Michael Scheer
*CMZ :  2.20/08 18/03/2001  22.18.21  by  Michael Scheer
*CMZ :  2.20/07 18/03/2001  17.09.21  by  Michael Scheer
*CMZ :  2.20/06 15/03/2001  17.20.43  by  Michael Scheer
*CMZ :  2.20/04 09/03/2001  19.55.49  by  Michael Scheer
*CMZ :  2.20/03 23/02/2001  15.16.41  by  Michael Scheer
*CMZ :  2.20/02 21/02/2001  11.41.58  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.33.29  by  Michael Scheer
*CMZ : 00.01/04 28/11/94  17.27.56  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  15.13.26  by  Michael Scheer
*-- Author :Michael Scheer
     &  '          *       VERSION 4.01/04   28.12.2023        *'
+self,if=versdum.
Maszstab           ********VERSION 1.23/45 *********************
+self.

+PATCH,INCL.
*CMZ :  1.00/00 01/10/97  17.56.58  by  Michael Scheer
+KEEP,wversion.
*CMZ :  4.01/04 28/12/2023  17.35.14  by  Michael Scheer
*CMZ :  4.01/03 04/07/2023  09.17.35  by  Michael Scheer
*CMZ :  4.01/01 15/03/2023  13.26.08  by  Michael Scheer
*CMZ :  4.01/00 14/03/2023  11.18.26  by  Michael Scheer
*CMZ :  4.00/17 05/12/2022  09.05.41  by  Michael Scheer
*CMZ :  4.00/16 29/09/2022  11.26.43  by  Michael Scheer
*CMZ :  4.00/15 07/07/2022  19.48.27  by  Michael Scheer
*CMZ :  4.00/14 11/02/2022  10.51.49  by  Michael Scheer
*CMZ :  4.00/13 20/12/2021  16.35.59  by  Michael Scheer
*CMZ :  4.00/12 29/07/2021  10.04.11  by  Michael Scheer
*CMZ :  4.00/10 25/09/2020  11.26.26  by  Michael Scheer
*CMZ :  4.00/09 15/08/2020  09.03.43  by  Michael Scheer
*CMZ :  4.00/08 07/08/2020  11.11.08  by  Michael Scheer
*CMZ :  4.00/07 06/08/2020  11.15.07  by  Michael Scheer
*CMZ :  4.00/06 02/01/2020  12.17.28  by  Michael Scheer
*CMZ :  4.00/05 30/11/2019  16.49.12  by  Michael Scheer
*CMZ :  4.00/04 28/11/2019  13.59.11  by  Michael Scheer
*CMZ :  4.00/03 09/05/2019  11.05.46  by  Michael Scheer
*CMZ :  4.00/02 13/04/2019  10.07.02  by  Michael Scheer
*CMZ :  4.00/01 12/04/2019  13.43.35  by  Michael Scheer
*CMZ :  4.00/00 04/04/2019  19.42.59  by  Michael Scheer
*CMZ :  3.08/01 04/04/2019  12.02.56  by  Michael Scheer
*CMZ :  3.08/00 29/03/2019  15.51.16  by  Michael Scheer
*CMZ :  3.07/01 29/03/2019  15.50.21  by  Michael Scheer
*CMZ :  3.07/00 18/03/2019  10.37.17  by  Michael Scheer
*CMZ :  3.06/00 28/02/2019  17.26.47  by  Michael Scheer
*CMZ :  3.05/28 07/01/2019  17.17.16  by  Michael Scheer
*CMZ :  3.05/27 12/12/2018  12.21.10  by  Michael Scheer
*CMZ :  3.05/26 09/12/2018  13.47.24  by  Michael Scheer
*CMZ :  3.05/25 06/12/2018  10.32.29  by  Michael Scheer
*CMZ :  3.05/24 05/12/2018  10.15.05  by  Michael Scheer
*CMZ :  3.05/23 03/12/2018  18.36.19  by  Michael Scheer
*CMZ :  3.05/22 08/11/2018  16.06.25  by  Michael Scheer
*CMZ :  3.05/21 07/11/2018  12.38.51  by  Michael Scheer
*CMZ :  3.05/20 01/11/2018  17.21.41  by  Michael Scheer
*CMZ :  3.05/19 18/10/2018  14.59.42  by  Michael Scheer
*CMZ :  3.05/18 17/10/2018  09.19.45  by  Michael Scheer
*CMZ :  3.05/17 11/10/2018  13.23.03  by  Michael Scheer
*CMZ :  3.05/16 10/10/2018  14.54.29  by  Michael Scheer
*CMZ :  3.05/15 08/10/2018  18.46.43  by  Michael Scheer
*CMZ :  3.05/14 01/10/2018  14.06.12  by  Michael Scheer
*CMZ :  3.05/13 24/09/2018  14.47.49  by  Michael Scheer
*CMZ :  3.05/12 29/08/2018  14.01.19  by  Michael Scheer
*CMZ :  3.05/11 16/08/2018  15.24.39  by  Michael Scheer
*CMZ :  3.05/10 14/08/2018  11.03.03  by  Michael Scheer
*CMZ :  3.05/09 08/08/2018  14.26.55  by  Michael Scheer
*CMZ :  3.05/08 26/07/2018  15.29.40  by  Michael Scheer
*CMZ :  3.05/07 21/07/2018  16.41.09  by  Michael Scheer
*CMZ :  3.05/06 19/07/2018  15.14.45  by  Michael Scheer
*CMZ :  3.05/05 13/07/2018  14.31.21  by  Michael Scheer
*CMZ :  3.05/04 09/07/2018  11.39.31  by  Michael Scheer
*CMZ :  3.05/03 22/05/2018  07.40.41  by  Michael Scheer
*CMZ :  3.05/02 16/05/2018  08.36.56  by  Michael Scheer
*CMZ :  3.05/01 09/05/2018  09.27.05  by  Michael Scheer
*CMZ :  3.05/00 02/05/2018  12.32.13  by  Michael Scheer
*CMZ :  3.04/01 03/04/2018  14.28.15  by  Michael Scheer
*CMZ :  3.04/00 01/03/2018  16.59.23  by  Michael Scheer
*CMZ :  3.03/04 02/01/2018  16.28.17  by  Michael Scheer
*CMZ :  3.03/03 11/07/2017  12.45.21  by  Michael Scheer
*CMZ :  3.03/02 28/06/2017  14.11.13  by  Michael Scheer
*CMZ :  3.03/01 13/11/2015  10.19.29  by  Michael Scheer
*CMZ :  3.03/00 30/09/2015  11.38.55  by  Michael Scheer
*CMZ :  3.02/09 09/07/2015  19.32.06  by  Michael Scheer
*CMZ :  3.02/08 25/06/2015  14.22.19  by  Michael Scheer
*CMZ :  3.02/07 24/06/2015  12.52.52  by  Michael Scheer
*CMZ :  3.02/06 18/06/2015  14.17.17  by  Michael Scheer
*CMZ :  3.02/05 13/04/2015  11.57.01  by  Michael Scheer
*CMZ :  3.02/04 18/03/2015  10.20.54  by  Michael Scheer
*CMZ :  3.02/03 10/11/2014  16.22.36  by  Michael Scheer
*CMZ :  3.02/02 22/10/2014  13.35.55  by  Michael Scheer
*CMZ :  3.02/01 16/10/2014  06.18.22  by  Michael Scheer
*CMZ :  3.01/10 19/08/2014  11.32.39  by  Michael Scheer
*CMZ :  3.01/09 12/08/2014  17.20.23  by  Michael Scheer
*CMZ :  3.01/08 12/08/2014  14.40.52  by  Michael Scheer
*CMZ :  3.01/07 23/06/2014  16.16.40  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  10.16.23  by  Michael Scheer
*CMZ :  3.01/05 13/06/2014  13.18.08  by  Michael Scheer
*CMZ :  3.01/04 11/06/2014  12.53.59  by  Michael Scheer
*CMZ :  3.01/03 20/03/2014  13.34.33  by  Michael Scheer
*CMZ :  3.01/02 27/02/2014  09.45.16  by  Michael Scheer
*CMZ :  3.01/01 31/07/2013  12.26.07  by  Michael Scheer
*CMZ :  3.01/00 18/07/2013  13.42.01  by  Michael Scheer
*CMZ :  3.00/02 10/04/2013  09.29.30  by  Michael Scheer
*CMZ :  3.00/01 03/04/2013  12.14.49  by  Michael Scheer
*CMZ :  3.00/00 14/03/2013  12.32.44  by  Michael Scheer
*CMZ :  2.70/12 05/03/2013  13.35.20  by  Michael Scheer
*CMZ :  2.70/11 22/02/2013  14.47.51  by  Michael Scheer
*CMZ :  2.70/10 16/01/2013  12.43.34  by  Michael Scheer
*CMZ :  2.70/09 15/01/2013  14.59.06  by  Michael Scheer
*CMZ :  2.70/08 14/01/2013  17.51.12  by  Michael Scheer
*CMZ :  2.70/07 14/01/2013  16.57.30  by  Michael Scheer
*CMZ :  2.70/06 14/01/2013  09.58.06  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  15.37.35  by  Michael Scheer
*CMZ :  2.70/04 21/12/2012  12.44.21  by  Michael Scheer
*CMZ :  2.70/03 17/12/2012  15.04.27  by  Michael Scheer
*CMZ :  2.70/02 14/12/2012  10.52.28  by  Michael Scheer
*CMZ :  2.70/01 12/12/2012  15.53.33  by  Michael Scheer
*CMZ :  2.70/00 11/12/2012  17.13.12  by  Michael Scheer
*CMZ :  2.69/02 08/11/2012  10.18.22  by  Michael Scheer
*CMZ :  2.69/01 31/10/2012  17.01.49  by  Michael Scheer
*CMZ :  2.69/00 30/10/2012  16.26.26  by  Michael Scheer
*CMZ :  2.68/05 19/10/2012  14.10.43  by  Unknown
*CMZ :  2.68/04 04/09/2012  11.30.37  by  Michael Scheer
*CMZ :  2.68/03 01/09/2012  16.18.21  by  Michael Scheer
*CMZ :  2.68/02 01/08/2012  15.11.42  by  Michael Scheer
*CMZ :  2.68/01 29/05/2012  17.05.39  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  16.51.01  by  Michael Scheer
*CMZ :  2.67/06 24/05/2012  14.37.50  by  Michael Scheer
*CMZ :  2.67/05 16/05/2012  14.35.39  by  Michael Scheer
*CMZ :  2.67/04 15/05/2012  13.09.47  by  Michael Scheer
*CMZ :  2.67/03 09/05/2012  16.33.57  by  Michael Scheer
*CMZ :  2.67/02 09/05/2012  12.08.14  by  Michael Scheer
*CMZ :  2.67/01 16/03/2012  09.17.00  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  16.27.31  by  Michael Scheer
*CMZ :  2.66/22 16/01/2012  12.52.11  by  Michael Scheer
*CMZ :  2.66/21 22/11/2011  13.55.20  by  Michael Scheer
*CMZ :  2.66/20 22/11/2011  10.47.52  by  Michael Scheer
*CMZ :  2.66/19 07/06/2011  14.55.12  by  Michael Scheer
*CMZ :  2.66/18 16/12/2010  12.54.41  by  Michael Scheer
*CMZ :  2.66/17 23/11/2010  10.03.05  by  Michael Scheer
*CMZ :  2.66/16 22/11/2010  14.04.02  by  Michael Scheer
*CMZ :  2.66/15 09/11/2010  16.18.55  by  Michael Scheer
*CMZ :  2.66/14 09/11/2010  15.41.06  by  Michael Scheer
*CMZ :  2.66/13 02/08/2010  09.16.32  by  Michael Scheer
*CMZ :  2.66/12 27/05/2010  02.41.06  by  Michael Scheer
*CMZ :  2.66/11 05/05/2010  08.25.31  by  Michael Scheer
*CMZ :  2.66/10 04/05/2010  12.42.54  by  Michael Scheer
*CMZ :  2.66/09 03/05/2010  16.13.02  by  Michael Scheer
*CMZ :  2.66/08 17/03/2010  14.47.26  by  Michael Scheer
*CMZ :  2.66/07 11/03/2010  15.52.20  by  Michael Scheer
*CMZ :  2.66/06 27/11/2009  16.15.00  by  Michael Scheer
*CMZ :  2.66/05 17/11/2009  16.10.37  by  Michael Scheer
*CMZ :  2.66/04 17/11/2009  10.13.48  by  Michael Scheer
*CMZ :  2.66/03 11/11/2009  16.17.18  by  Michael Scheer
*CMZ :  2.66/02 26/10/2009  14.31.27  by  Michael Scheer
*CMZ :  2.66/01 21/10/2009  09.36.11  by  Michael Scheer
*CMZ :  2.66/00 14/10/2009  11.57.53  by  Michael Scheer
*CMZ :  2.65/03 02/10/2009  13.22.43  by  Michael Scheer
*CMZ :  2.65/02 29/09/2009  12.22.19  by  Michael Scheer
*CMZ :  2.65/01 21/09/2009  14.36.00  by  Michael Scheer
*CMZ :  2.65/00 18/09/2009  09.46.14  by  Michael Scheer
*CMZ :  2.64/07 17/09/2009  16.28.06  by  Michael Scheer
*CMZ :  2.64/06 15/09/2009  15.17.17  by  Michael Scheer
*CMZ :  2.64/05 14/09/2009  11.36.46  by  Michael Scheer
*CMZ :  2.64/04 21/08/2009  17.40.03  by  Michael Scheer
*CMZ :  2.64/03 21/08/2009  17.33.33  by  Michael Scheer
*CMZ :  2.64/02 21/08/2009  17.28.12  by  Michael Scheer
*CMZ :  2.64/01 20/08/2009  15.48.35  by  Michael Scheer
*CMZ :  2.64/00 17/08/2009  09.32.48  by  Michael Scheer
*CMZ :  2.63/05 14/08/2009  13.07.07  by  Michael Scheer
*CMZ :  2.63/04 22/07/2009  07.41.27  by  Michael Scheer
*CMZ :  2.63/03 02/06/2009  16.25.15  by  Michael Scheer
*CMZ :  2.63/02 08/04/2008  12.21.25  by  Michael Scheer
*CMZ :  2.63/01 16/01/2008  13.14.36  by  Michael Scheer
*CMZ :  2.63/00 11/01/2008  16.42.42  by  Michael Scheer
*CMZ :  2.62/04 03/01/2008  17.16.00  by  Michael Scheer
*CMZ :  2.62/03 17/07/2007  16.15.46  by  Michael Scheer
*CMZ :  2.62/02 16/07/2007  11.28.09  by  Michael Scheer
*CMZ :  2.62/01 24/04/2007  12.00.53  by  Michael Scheer
*CMZ :  2.62/00 17/04/2007  08.49.12  by  Michael Scheer
*CMZ :  2.61/06 12/04/2007  13.39.57  by  Michael Scheer
*CMZ :  2.61/05 12/04/2007  09.31.22  by  Michael Scheer
*CMZ :  2.61/04 29/03/2007  16.31.37  by  Michael Scheer
*CMZ :  2.61/03 27/03/2007  13.29.11  by  Michael Scheer
*CMZ :  2.61/02 26/03/2007  20.10.31  by  Michael Scheer
*CMZ :  2.61/01 15/02/2007  14.24.24  by  Michael Scheer
*CMZ :  2.61/00 30/01/2007  20.26.41  by  Michael Scheer
*CMZ :  2.60/00 26/01/2007  10.51.28  by  Michael Scheer
*CMZ :  2.59/02 25/01/2007  16.09.23  by  Michael Scheer
*CMZ :  2.59/01 24/01/2007  14.32.08  by  Michael Scheer
*CMZ :  2.59/00 23/01/2007  15.40.42  by  Michael Scheer
*CMZ :  2.58/01 23/01/2007  13.25.42  by  Michael Scheer
*CMZ :  2.58/00 16/01/2007  17.45.21  by  Michael Scheer
*CMZ :  2.57/05 10/01/2007  13.39.09  by  Michael Scheer
*CMZ :  2.57/04 01/02/2006  16.20.51  by  Michael Scheer
*CMZ :  2.57/03 23/12/2005  11.48.02  by  Michael Scheer
*CMZ :  2.57/02 09/12/2005  11.14.20  by  Michael Scheer
*CMZ :  2.57/01 22/11/2005  13.32.35  by  Michael Scheer
*CMZ :  2.57/00 22/11/2005  12.35.13  by  Michael Scheer
*CMZ :  2.56/02 21/10/2005  16.32.46  by  Michael Scheer
*CMZ :  2.56/01 21/10/2005  12.35.26  by  Michael Scheer
*CMZ :  2.56/00 17/10/2005  13.31.23  by  Michael Scheer
*CMZ :  2.55/01 10/08/2005  16.12.03  by  Michael Scheer
*CMZ :  2.55/00 10/08/2005  16.09.23  by  Michael Scheer
*CMZ :  2.54/07 16/06/2005  12.25.52  by  Michael Scheer
*CMZ :  2.54/06 02/06/2005  13.55.14  by  Michael Scheer
*CMZ :  2.54/05 02/06/2005  08.17.11  by  Michael Scheer
*CMZ :  2.54/04 19/04/2005  14.13.30  by  Michael Scheer
*CMZ :  2.54/03 18/04/2005  08.56.03  by  Michael Scheer
*CMZ :  2.54/02 13/04/2005  13.53.54  by  Michael Scheer
*CMZ :  2.54/01 13/04/2005  09.16.21  by  Michael Scheer
*CMZ :  2.54/00 28/02/2005  17.31.43  by  Michael Scheer
*CMZ :  2.53/05 25/02/2005  12.01.49  by  Michael Scheer
*CMZ :  2.53/04 10/02/2005  10.01.45  by  Michael Scheer
*CMZ :  2.53/03 26/01/2005  15.37.37  by  Michael Scheer
*CMZ :  2.53/02 25/01/2005  18.20.37  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  13.29.48  by  Michael Scheer
*CMZ :  2.53/00 21/01/2005  17.24.28  by  Michael Scheer
*CMZ :  2.52/15 05/01/2005  16.38.59  by  Michael Scheer
*CMZ :  2.52/14 22/12/2004  16.29.18  by  Michael Scheer
*CMZ :  2.52/13 16/12/2004  21.17.54  by  Michael Scheer
*CMZ :  2.52/12 08/12/2004  14.07.27  by  Michael Scheer
*CMZ :  2.52/11 08/12/2004  13.39.53  by  Michael Scheer
*CMZ :  2.52/10 05/11/2004  17.17.40  by  Michael Scheer
*CMZ :  2.52/09 29/10/2004  13.08.10  by  Michael Scheer
*CMZ :  2.52/08 14/10/2004  14.53.32  by  Michael Scheer
*CMZ :  2.52/07 14/10/2004  09.24.22  by  Michael Scheer
*CMZ :  2.52/05 17/08/2004  15.57.30  by  Michael Scheer
*CMZ :  2.52/04 13/07/2004  08.24.53  by  Michael Scheer
*CMZ :  2.52/03 08/07/2004  13.38.16  by  Michael Scheer
*CMZ :  2.52/02 08/07/2004  10.29.14  by  Michael Scheer
*CMZ :  2.52/01 30/06/2004  16.24.39  by  Michael Scheer
*CMZ :  2.52/00 30/06/2004  10.54.14  by  Michael Scheer
*CMZ :  2.51/03 23/06/2004  12.25.44  by  Michael Scheer
*CMZ :  2.51/02 22/06/2004  16.31.28  by  Michael Scheer
*CMZ :  2.51/01 17/06/2004  16.18.20  by  Michael Scheer
*CMZ :  2.51/00 26/05/2004  16.34.25  by  Michael Scheer
*CMZ :  2.50/03 10/05/2004  14.41.11  by  Michael Scheer
*CMZ :  2.50/02 30/04/2004  15.33.31  by  Michael Scheer
*CMZ :  2.50/01 30/04/2004  08.58.23  by  Michael Scheer
*CMZ :  2.50/00 29/04/2004  18.46.23  by  Michael Scheer
*CMZ :  2.49/01 23/03/2004  14.32.47  by  Michael Scheer
*CMZ :  2.48/04 17/03/2004  14.54.00  by  Michael Scheer
*CMZ :  2.48/03 10/03/2004  16.04.11  by  Michael Scheer
*CMZ :  2.48/02 03/03/2004  11.26.16  by  Michael Scheer
*CMZ :  2.48/01 02/03/2004  16.44.04  by  Michael Scheer
*CMZ :  2.48/00 01/03/2004  18.05.54  by  Michael Scheer
*CMZ :  2.47/23 17/02/2004  13.48.36  by  Michael Scheer
*CMZ :  2.47/22 03/12/2003  13.18.07  by  Michael Scheer
*CMZ :  2.47/21 03/12/2003  09.50.02  by  Michael Scheer
*CMZ :  2.47/20 01/12/2003  15.35.07  by  Michael Scheer
*CMZ :  2.47/19 01/12/2003  08.24.44  by  Michael Scheer
*CMZ :  2.47/18 27/11/2003  14.46.01  by  Michael Scheer
*CMZ :  2.47/17 12/09/2003  10.10.52  by  Michael Scheer
*CMZ :  2.47/16 11/09/2003  15.10.44  by  Michael Scheer
*CMZ :  2.47/15 04/09/2003  09.28.29  by  Michael Scheer
*CMZ :  2.47/14 07/08/2003  09.44.02  by  Michael Scheer
*CMZ :  2.47/13 03/07/2003  09.57.40  by  Michael Scheer
*CMZ :  2.47/12 03/07/2003  09.56.41  by  Michael Scheer
*CMZ :  2.47/11 30/05/2003  12.54.22  by  Michael Scheer
*CMZ :  2.47/10 30/05/2003  12.43.23  by  Michael Scheer
*CMZ :  2.47/09 27/05/2003  15.58.18  by  Michael Scheer
*CMZ :  2.47/08 20/05/2003  15.48.28  by  Michael Scheer
*CMZ :  2.47/07 15/04/2003  10.52.36  by  Michael Scheer
*CMZ :  2.47/06 28/03/2003  15.40.56  by  Michael Scheer
*CMZ :  2.47/05 27/03/2003  15.27.38  by  Michael Scheer
*CMZ :  2.47/04 13/03/2003  11.06.38  by  Michael Scheer
*CMZ :  2.47/03 12/03/2003  16.02.35  by  Michael Scheer
*CMZ :  2.47/02 12/03/2003  10.54.25  by  Michael Scheer
*CMZ :  2.47/01 10/03/2003  11.57.24  by  Michael Scheer
*CMZ :  2.46/02 07/03/2003  11.17.22  by  Michael Scheer
*CMZ :  2.46/01 18/12/2002  11.47.23  by  Michael Scheer
*CMZ :  2.46/00 17/12/2002  16.46.49  by  Michael Scheer
*CMZ :  2.45/03 17/12/2002  15.15.55  by  Michael Scheer
*CMZ :  2.45/02 16/12/2002  14.36.34  by  Michael Scheer
*CMZ :  2.45/01 13/12/2002  17.25.42  by  Michael Scheer
*CMZ :  2.44/03 13/12/2002  12.43.06  by  Michael Scheer
*CMZ :  2.44/02 13/12/2002  11.39.21  by  Michael Scheer
*CMZ :  2.44/01 12/12/2002  13.32.07  by  Michael Scheer
*CMZ :  2.44/00 15/11/2002  18.31.49  by  Michael Scheer
*CMZ :  2.42/04 29/10/2002  11.33.36  by  Michael Scheer
*CMZ :  2.42/03 13/09/2002  18.47.33  by  Michael Scheer
*CMZ :  2.42/02 12/09/2002  11.07.58  by  Michael Scheer
*CMZ :  2.42/01 09/09/2002  18.56.25  by  Michael Scheer
*CMZ :  2.41/13 03/09/2002  14.29.39  by  Michael Scheer
*CMZ :  2.41/12 22/08/2002  12.13.49  by  Michael Scheer
*CMZ :  2.41/11 21/08/2002  11.28.45  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.50.10  by  Michael Scheer
*CMZ :  2.41/09 14/08/2002  17.27.24  by  Michael Scheer
*CMZ :  2.41/08 14/08/2002  17.06.27  by  Michael Scheer
*CMZ :  2.41/07 30/07/2002  12.13.11  by  Michael Scheer
*CMZ :  2.41/06 10/05/2002  15.26.01  by  Michael Scheer
*CMZ :  2.41/05 18/04/2002  11.47.34  by  Michael Scheer
*CMZ :  2.41/04 16/04/2002  14.29.54  by  Michael Scheer
*CMZ :  2.41/03 21/03/2002  12.44.56  by  Michael Scheer
*CMZ :  2.41/01 21/03/2002  12.36.42  by  Michael Scheer
*CMZ :  2.41/00 20/03/2002  19.24.01  by  Michael Scheer
*CMZ :  2.40/04 20/03/2002  12.33.26  by  Michael Scheer
*CMZ :  2.40/02 14/03/2002  16.23.09  by  Michael Scheer
*CMZ :  2.40/01 12/03/2002  14.36.49  by  Michael Scheer
*CMZ :  2.40/00 12/03/2002  14.28.59  by  Michael Scheer
*CMZ :  2.39/02 22/01/2002  13.35.44  by  Michael Scheer
*CMZ :  2.39/01 15/01/2002  16.49.21  by  Michael Scheer
*CMZ :  2.39/00 14/01/2002  14.37.58  by  Michael Scheer
*CMZ :  2.38/03 13/12/2001  15.06.40  by  Michael Scheer
*CMZ :  2.38/02 13/12/2001  13.44.34  by  Michael Scheer
*CMZ :  2.38/01 13/12/2001  12.16.53  by  Michael Scheer
*CMZ :  2.37/07 12/12/2001  14.47.52  by  Michael Scheer
*CMZ :  2.37/06 07/12/2001  15.02.02  by  Michael Scheer
*CMZ :  2.37/05 07/12/2001  14.52.16  by  Michael Scheer
*CMZ :  2.37/04 05/12/2001  17.37.12  by  Michael Scheer
*CMZ :  2.37/03 23/11/2001  18.19.34  by  Michael Scheer
*CMZ :  2.37/02 15/11/2001  17.25.18  by  Michael Scheer
*CMZ :  2.37/01 14/11/2001  11.08.43  by  Michael Scheer
*CMZ :  2.37/00 13/11/2001  17.33.11  by  Michael Scheer
*CMZ :  2.36/01 08/11/2001  17.39.47  by  Michael Scheer
*CMZ :  2.36/00 08/11/2001  15.34.30  by  Michael Scheer
*CMZ :  2.35/02 30/10/2001  17.15.18  by  Michael Scheer
*CMZ :  2.35/01 17/10/2001  11.40.54  by  Michael Scheer
*CMZ :  2.35/00 26/09/2001  17.19.48  by  Michael Scheer
*CMZ :  2.34/09 26/09/2001  17.17.20  by  Michael Scheer
*CMZ :  2.34/08 17/09/2001  19.44.50  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  17.41.49  by  Michael Scheer
*CMZ :  2.34/06 23/08/2001  17.38.11  by  Michael Scheer
*CMZ :  2.34/04 11/07/2001  11.20.36  by  Michael Scheer
*CMZ :  2.34/02 02/07/2001  17.25.12  by  Michael Scheer
*CMZ :  2.34/00 11/05/2001  17.27.00  by  Michael Scheer
*CMZ :  2.33/09 10/05/2001  18.03.20  by  Michael Scheer
*CMZ :  2.33/08 08/05/2001  17.52.21  by  Michael Scheer
*CMZ :  2.33/07 08/05/2001  17.43.33  by  Michael Scheer
*CMZ :  2.33/06 04/05/2001  13.56.57  by  Michael Scheer
*CMZ :  2.33/05 04/05/2001  11.42.46  by  Michael Scheer
*CMZ :  2.33/04 04/05/2001  11.37.04  by  Michael Scheer
*CMZ :  2.33/03 04/05/2001  11.15.03  by  Michael Scheer
*CMZ :  2.33/02 03/05/2001  17.23.54  by  Michael Scheer
*CMZ :  2.33/01 03/05/2001  14.01.01  by  Michael Scheer
*CMZ :  2.32/04 26/04/2001  12.37.02  by  Michael Scheer
*CMZ :  2.32/03 26/04/2001  11.12.11  by  Michael Scheer
*CMZ :  2.32/02 26/04/2001  11.09.43  by  Michael Scheer
*CMZ :  2.32/01 25/04/2001  19.09.17  by  Michael Scheer
*CMZ :  2.32/00 25/04/2001  17.14.54  by  Michael Scheer
*CMZ :  2.31/01 25/04/2001  17.13.47  by  Michael Scheer
*CMZ :  2.31/00 24/04/2001  16.07.58  by  Michael Scheer
*CMZ :  2.30/04 23/04/2001  12.34.39  by  Michael Scheer
*CMZ :  2.30/03 20/04/2001  16.32.24  by  Michael Scheer
*CMZ :  2.30/02 12/04/2001  19.12.58  by  Michael Scheer
*CMZ :  2.30/01 12/04/2001  18.24.05  by  Michael Scheer
*CMZ :  2.30/00 11/04/2001  19.35.18  by  Michael Scheer
*CMZ :  2.20/12 11/04/2001  19.33.04  by  Michael Scheer
*CMZ :  2.20/11 11/04/2001  16.16.37  by  Michael Scheer
*CMZ :  2.20/10 10/04/2001  12.26.28  by  Michael Scheer
*CMZ :  2.20/09 03/04/2001  14.52.40  by  Michael Scheer
*CMZ :  2.20/08 18/03/2001  22.18.21  by  Michael Scheer
*CMZ :  2.20/07 18/03/2001  17.09.21  by  Michael Scheer
*CMZ :  2.20/06 15/03/2001  17.20.43  by  Michael Scheer
*CMZ :  2.20/04 09/03/2001  19.55.49  by  Michael Scheer
*CMZ :  2.20/03 23/02/2001  15.16.41  by  Michael Scheer
*CMZ :  2.20/02 21/02/2001  11.41.58  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.33.29  by  Michael Scheer
*CMZ : 00.01/04 28/11/94  17.27.56  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  15.13.26  by  Michael Scheer
*-- Author :Michael Scheer
     &  '          *       VERSION 4.01/04   28.12.2023        *'
+self,if=versdum.
Maszstab           ********VERSION 1.23/45 *********************
+self.

+PATCH,INCLN.
*CMZ :  3.00/00 11/03/2013  13.33.40  by  Michael Scheer
+KEEP,wversion.
*CMZ :  4.01/04 28/12/2023  17.35.14  by  Michael Scheer
*CMZ :  4.01/03 04/07/2023  09.17.35  by  Michael Scheer
*CMZ :  4.01/01 15/03/2023  13.26.08  by  Michael Scheer
*CMZ :  4.01/00 14/03/2023  11.18.26  by  Michael Scheer
*CMZ :  4.00/17 05/12/2022  09.05.41  by  Michael Scheer
*CMZ :  4.00/16 29/09/2022  11.26.43  by  Michael Scheer
*CMZ :  4.00/15 07/07/2022  19.48.27  by  Michael Scheer
*CMZ :  4.00/14 11/02/2022  10.51.49  by  Michael Scheer
*CMZ :  4.00/13 20/12/2021  16.35.59  by  Michael Scheer
*CMZ :  4.00/12 29/07/2021  10.04.11  by  Michael Scheer
*CMZ :  4.00/10 25/09/2020  11.26.26  by  Michael Scheer
*CMZ :  4.00/09 15/08/2020  09.03.43  by  Michael Scheer
*CMZ :  4.00/08 07/08/2020  11.11.08  by  Michael Scheer
*CMZ :  4.00/07 06/08/2020  11.15.07  by  Michael Scheer
*CMZ :  4.00/06 02/01/2020  12.17.28  by  Michael Scheer
*CMZ :  4.00/05 30/11/2019  16.49.12  by  Michael Scheer
*CMZ :  4.00/04 28/11/2019  13.59.11  by  Michael Scheer
*CMZ :  4.00/03 09/05/2019  11.05.46  by  Michael Scheer
*CMZ :  4.00/02 13/04/2019  10.07.02  by  Michael Scheer
*CMZ :  4.00/01 12/04/2019  13.43.35  by  Michael Scheer
*CMZ :  4.00/00 04/04/2019  19.42.59  by  Michael Scheer
*CMZ :  3.08/01 04/04/2019  12.02.56  by  Michael Scheer
*CMZ :  3.08/00 29/03/2019  15.51.16  by  Michael Scheer
*CMZ :  3.07/01 29/03/2019  15.50.21  by  Michael Scheer
*CMZ :  3.07/00 18/03/2019  10.37.17  by  Michael Scheer
*CMZ :  3.06/00 28/02/2019  17.26.47  by  Michael Scheer
*CMZ :  3.05/28 07/01/2019  17.17.16  by  Michael Scheer
*CMZ :  3.05/27 12/12/2018  12.21.10  by  Michael Scheer
*CMZ :  3.05/26 09/12/2018  13.47.24  by  Michael Scheer
*CMZ :  3.05/25 06/12/2018  10.32.29  by  Michael Scheer
*CMZ :  3.05/24 05/12/2018  10.15.05  by  Michael Scheer
*CMZ :  3.05/23 03/12/2018  18.36.19  by  Michael Scheer
*CMZ :  3.05/22 08/11/2018  16.06.25  by  Michael Scheer
*CMZ :  3.05/21 07/11/2018  12.38.51  by  Michael Scheer
*CMZ :  3.05/20 01/11/2018  17.21.41  by  Michael Scheer
*CMZ :  3.05/19 18/10/2018  14.59.42  by  Michael Scheer
*CMZ :  3.05/18 17/10/2018  09.19.45  by  Michael Scheer
*CMZ :  3.05/17 11/10/2018  13.23.03  by  Michael Scheer
*CMZ :  3.05/16 10/10/2018  14.54.29  by  Michael Scheer
*CMZ :  3.05/15 08/10/2018  18.46.43  by  Michael Scheer
*CMZ :  3.05/14 01/10/2018  14.06.12  by  Michael Scheer
*CMZ :  3.05/13 24/09/2018  14.47.49  by  Michael Scheer
*CMZ :  3.05/12 29/08/2018  14.01.19  by  Michael Scheer
*CMZ :  3.05/11 16/08/2018  15.24.39  by  Michael Scheer
*CMZ :  3.05/10 14/08/2018  11.03.03  by  Michael Scheer
*CMZ :  3.05/09 08/08/2018  14.26.55  by  Michael Scheer
*CMZ :  3.05/08 26/07/2018  15.29.40  by  Michael Scheer
*CMZ :  3.05/07 21/07/2018  16.41.09  by  Michael Scheer
*CMZ :  3.05/06 19/07/2018  15.14.45  by  Michael Scheer
*CMZ :  3.05/05 13/07/2018  14.31.21  by  Michael Scheer
*CMZ :  3.05/04 09/07/2018  11.39.31  by  Michael Scheer
*CMZ :  3.05/03 22/05/2018  07.40.41  by  Michael Scheer
*CMZ :  3.05/02 16/05/2018  08.36.56  by  Michael Scheer
*CMZ :  3.05/01 09/05/2018  09.27.05  by  Michael Scheer
*CMZ :  3.05/00 02/05/2018  12.32.13  by  Michael Scheer
*CMZ :  3.04/01 03/04/2018  14.28.15  by  Michael Scheer
*CMZ :  3.04/00 01/03/2018  16.59.23  by  Michael Scheer
*CMZ :  3.03/04 02/01/2018  16.28.17  by  Michael Scheer
*CMZ :  3.03/03 11/07/2017  12.45.21  by  Michael Scheer
*CMZ :  3.03/02 28/06/2017  14.11.13  by  Michael Scheer
*CMZ :  3.03/01 13/11/2015  10.19.29  by  Michael Scheer
*CMZ :  3.03/00 30/09/2015  11.38.55  by  Michael Scheer
*CMZ :  3.02/09 09/07/2015  19.32.06  by  Michael Scheer
*CMZ :  3.02/08 25/06/2015  14.22.19  by  Michael Scheer
*CMZ :  3.02/07 24/06/2015  12.52.52  by  Michael Scheer
*CMZ :  3.02/06 18/06/2015  14.17.17  by  Michael Scheer
*CMZ :  3.02/05 13/04/2015  11.57.01  by  Michael Scheer
*CMZ :  3.02/04 18/03/2015  10.20.54  by  Michael Scheer
*CMZ :  3.02/03 10/11/2014  16.22.36  by  Michael Scheer
*CMZ :  3.02/02 22/10/2014  13.35.55  by  Michael Scheer
*CMZ :  3.02/01 16/10/2014  06.18.22  by  Michael Scheer
*CMZ :  3.01/10 19/08/2014  11.32.39  by  Michael Scheer
*CMZ :  3.01/09 12/08/2014  17.20.23  by  Michael Scheer
*CMZ :  3.01/08 12/08/2014  14.40.52  by  Michael Scheer
*CMZ :  3.01/07 23/06/2014  16.16.40  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  10.16.23  by  Michael Scheer
*CMZ :  3.01/05 13/06/2014  13.18.08  by  Michael Scheer
*CMZ :  3.01/04 11/06/2014  12.53.59  by  Michael Scheer
*CMZ :  3.01/03 20/03/2014  13.34.33  by  Michael Scheer
*CMZ :  3.01/02 27/02/2014  09.45.16  by  Michael Scheer
*CMZ :  3.01/01 31/07/2013  12.26.07  by  Michael Scheer
*CMZ :  3.01/00 18/07/2013  13.42.01  by  Michael Scheer
*CMZ :  3.00/02 10/04/2013  09.29.30  by  Michael Scheer
*CMZ :  3.00/01 03/04/2013  12.14.49  by  Michael Scheer
*CMZ :  3.00/00 14/03/2013  12.32.44  by  Michael Scheer
*CMZ :  2.70/12 05/03/2013  13.35.20  by  Michael Scheer
*CMZ :  2.70/11 22/02/2013  14.47.51  by  Michael Scheer
*CMZ :  2.70/10 16/01/2013  12.43.34  by  Michael Scheer
*CMZ :  2.70/09 15/01/2013  14.59.06  by  Michael Scheer
*CMZ :  2.70/08 14/01/2013  17.51.12  by  Michael Scheer
*CMZ :  2.70/07 14/01/2013  16.57.30  by  Michael Scheer
*CMZ :  2.70/06 14/01/2013  09.58.06  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  15.37.35  by  Michael Scheer
*CMZ :  2.70/04 21/12/2012  12.44.21  by  Michael Scheer
*CMZ :  2.70/03 17/12/2012  15.04.27  by  Michael Scheer
*CMZ :  2.70/02 14/12/2012  10.52.28  by  Michael Scheer
*CMZ :  2.70/01 12/12/2012  15.53.33  by  Michael Scheer
*CMZ :  2.70/00 11/12/2012  17.13.12  by  Michael Scheer
*CMZ :  2.69/02 08/11/2012  10.18.22  by  Michael Scheer
*CMZ :  2.69/01 31/10/2012  17.01.49  by  Michael Scheer
*CMZ :  2.69/00 30/10/2012  16.26.26  by  Michael Scheer
*CMZ :  2.68/05 19/10/2012  14.10.43  by  Unknown
*CMZ :  2.68/04 04/09/2012  11.30.37  by  Michael Scheer
*CMZ :  2.68/03 01/09/2012  16.18.21  by  Michael Scheer
*CMZ :  2.68/02 01/08/2012  15.11.42  by  Michael Scheer
*CMZ :  2.68/01 29/05/2012  17.05.39  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  16.51.01  by  Michael Scheer
*CMZ :  2.67/06 24/05/2012  14.37.50  by  Michael Scheer
*CMZ :  2.67/05 16/05/2012  14.35.39  by  Michael Scheer
*CMZ :  2.67/04 15/05/2012  13.09.47  by  Michael Scheer
*CMZ :  2.67/03 09/05/2012  16.33.57  by  Michael Scheer
*CMZ :  2.67/02 09/05/2012  12.08.14  by  Michael Scheer
*CMZ :  2.67/01 16/03/2012  09.17.00  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  16.27.31  by  Michael Scheer
*CMZ :  2.66/22 16/01/2012  12.52.11  by  Michael Scheer
*CMZ :  2.66/21 22/11/2011  13.55.20  by  Michael Scheer
*CMZ :  2.66/20 22/11/2011  10.47.52  by  Michael Scheer
*CMZ :  2.66/19 07/06/2011  14.55.12  by  Michael Scheer
*CMZ :  2.66/18 16/12/2010  12.54.41  by  Michael Scheer
*CMZ :  2.66/17 23/11/2010  10.03.05  by  Michael Scheer
*CMZ :  2.66/16 22/11/2010  14.04.02  by  Michael Scheer
*CMZ :  2.66/15 09/11/2010  16.18.55  by  Michael Scheer
*CMZ :  2.66/14 09/11/2010  15.41.06  by  Michael Scheer
*CMZ :  2.66/13 02/08/2010  09.16.32  by  Michael Scheer
*CMZ :  2.66/12 27/05/2010  02.41.06  by  Michael Scheer
*CMZ :  2.66/11 05/05/2010  08.25.31  by  Michael Scheer
*CMZ :  2.66/10 04/05/2010  12.42.54  by  Michael Scheer
*CMZ :  2.66/09 03/05/2010  16.13.02  by  Michael Scheer
*CMZ :  2.66/08 17/03/2010  14.47.26  by  Michael Scheer
*CMZ :  2.66/07 11/03/2010  15.52.20  by  Michael Scheer
*CMZ :  2.66/06 27/11/2009  16.15.00  by  Michael Scheer
*CMZ :  2.66/05 17/11/2009  16.10.37  by  Michael Scheer
*CMZ :  2.66/04 17/11/2009  10.13.48  by  Michael Scheer
*CMZ :  2.66/03 11/11/2009  16.17.18  by  Michael Scheer
*CMZ :  2.66/02 26/10/2009  14.31.27  by  Michael Scheer
*CMZ :  2.66/01 21/10/2009  09.36.11  by  Michael Scheer
*CMZ :  2.66/00 14/10/2009  11.57.53  by  Michael Scheer
*CMZ :  2.65/03 02/10/2009  13.22.43  by  Michael Scheer
*CMZ :  2.65/02 29/09/2009  12.22.19  by  Michael Scheer
*CMZ :  2.65/01 21/09/2009  14.36.00  by  Michael Scheer
*CMZ :  2.65/00 18/09/2009  09.46.14  by  Michael Scheer
*CMZ :  2.64/07 17/09/2009  16.28.06  by  Michael Scheer
*CMZ :  2.64/06 15/09/2009  15.17.17  by  Michael Scheer
*CMZ :  2.64/05 14/09/2009  11.36.46  by  Michael Scheer
*CMZ :  2.64/04 21/08/2009  17.40.03  by  Michael Scheer
*CMZ :  2.64/03 21/08/2009  17.33.33  by  Michael Scheer
*CMZ :  2.64/02 21/08/2009  17.28.12  by  Michael Scheer
*CMZ :  2.64/01 20/08/2009  15.48.35  by  Michael Scheer
*CMZ :  2.64/00 17/08/2009  09.32.48  by  Michael Scheer
*CMZ :  2.63/05 14/08/2009  13.07.07  by  Michael Scheer
*CMZ :  2.63/04 22/07/2009  07.41.27  by  Michael Scheer
*CMZ :  2.63/03 02/06/2009  16.25.15  by  Michael Scheer
*CMZ :  2.63/02 08/04/2008  12.21.25  by  Michael Scheer
*CMZ :  2.63/01 16/01/2008  13.14.36  by  Michael Scheer
*CMZ :  2.63/00 11/01/2008  16.42.42  by  Michael Scheer
*CMZ :  2.62/04 03/01/2008  17.16.00  by  Michael Scheer
*CMZ :  2.62/03 17/07/2007  16.15.46  by  Michael Scheer
*CMZ :  2.62/02 16/07/2007  11.28.09  by  Michael Scheer
*CMZ :  2.62/01 24/04/2007  12.00.53  by  Michael Scheer
*CMZ :  2.62/00 17/04/2007  08.49.12  by  Michael Scheer
*CMZ :  2.61/06 12/04/2007  13.39.57  by  Michael Scheer
*CMZ :  2.61/05 12/04/2007  09.31.22  by  Michael Scheer
*CMZ :  2.61/04 29/03/2007  16.31.37  by  Michael Scheer
*CMZ :  2.61/03 27/03/2007  13.29.11  by  Michael Scheer
*CMZ :  2.61/02 26/03/2007  20.10.31  by  Michael Scheer
*CMZ :  2.61/01 15/02/2007  14.24.24  by  Michael Scheer
*CMZ :  2.61/00 30/01/2007  20.26.41  by  Michael Scheer
*CMZ :  2.60/00 26/01/2007  10.51.28  by  Michael Scheer
*CMZ :  2.59/02 25/01/2007  16.09.23  by  Michael Scheer
*CMZ :  2.59/01 24/01/2007  14.32.08  by  Michael Scheer
*CMZ :  2.59/00 23/01/2007  15.40.42  by  Michael Scheer
*CMZ :  2.58/01 23/01/2007  13.25.42  by  Michael Scheer
*CMZ :  2.58/00 16/01/2007  17.45.21  by  Michael Scheer
*CMZ :  2.57/05 10/01/2007  13.39.09  by  Michael Scheer
*CMZ :  2.57/04 01/02/2006  16.20.51  by  Michael Scheer
*CMZ :  2.57/03 23/12/2005  11.48.02  by  Michael Scheer
*CMZ :  2.57/02 09/12/2005  11.14.20  by  Michael Scheer
*CMZ :  2.57/01 22/11/2005  13.32.35  by  Michael Scheer
*CMZ :  2.57/00 22/11/2005  12.35.13  by  Michael Scheer
*CMZ :  2.56/02 21/10/2005  16.32.46  by  Michael Scheer
*CMZ :  2.56/01 21/10/2005  12.35.26  by  Michael Scheer
*CMZ :  2.56/00 17/10/2005  13.31.23  by  Michael Scheer
*CMZ :  2.55/01 10/08/2005  16.12.03  by  Michael Scheer
*CMZ :  2.55/00 10/08/2005  16.09.23  by  Michael Scheer
*CMZ :  2.54/07 16/06/2005  12.25.52  by  Michael Scheer
*CMZ :  2.54/06 02/06/2005  13.55.14  by  Michael Scheer
*CMZ :  2.54/05 02/06/2005  08.17.11  by  Michael Scheer
*CMZ :  2.54/04 19/04/2005  14.13.30  by  Michael Scheer
*CMZ :  2.54/03 18/04/2005  08.56.03  by  Michael Scheer
*CMZ :  2.54/02 13/04/2005  13.53.54  by  Michael Scheer
*CMZ :  2.54/01 13/04/2005  09.16.21  by  Michael Scheer
*CMZ :  2.54/00 28/02/2005  17.31.43  by  Michael Scheer
*CMZ :  2.53/05 25/02/2005  12.01.49  by  Michael Scheer
*CMZ :  2.53/04 10/02/2005  10.01.45  by  Michael Scheer
*CMZ :  2.53/03 26/01/2005  15.37.37  by  Michael Scheer
*CMZ :  2.53/02 25/01/2005  18.20.37  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  13.29.48  by  Michael Scheer
*CMZ :  2.53/00 21/01/2005  17.24.28  by  Michael Scheer
*CMZ :  2.52/15 05/01/2005  16.38.59  by  Michael Scheer
*CMZ :  2.52/14 22/12/2004  16.29.18  by  Michael Scheer
*CMZ :  2.52/13 16/12/2004  21.17.54  by  Michael Scheer
*CMZ :  2.52/12 08/12/2004  14.07.27  by  Michael Scheer
*CMZ :  2.52/11 08/12/2004  13.39.53  by  Michael Scheer
*CMZ :  2.52/10 05/11/2004  17.17.40  by  Michael Scheer
*CMZ :  2.52/09 29/10/2004  13.08.10  by  Michael Scheer
*CMZ :  2.52/08 14/10/2004  14.53.32  by  Michael Scheer
*CMZ :  2.52/07 14/10/2004  09.24.22  by  Michael Scheer
*CMZ :  2.52/05 17/08/2004  15.57.30  by  Michael Scheer
*CMZ :  2.52/04 13/07/2004  08.24.53  by  Michael Scheer
*CMZ :  2.52/03 08/07/2004  13.38.16  by  Michael Scheer
*CMZ :  2.52/02 08/07/2004  10.29.14  by  Michael Scheer
*CMZ :  2.52/01 30/06/2004  16.24.39  by  Michael Scheer
*CMZ :  2.52/00 30/06/2004  10.54.14  by  Michael Scheer
*CMZ :  2.51/03 23/06/2004  12.25.44  by  Michael Scheer
*CMZ :  2.51/02 22/06/2004  16.31.28  by  Michael Scheer
*CMZ :  2.51/01 17/06/2004  16.18.20  by  Michael Scheer
*CMZ :  2.51/00 26/05/2004  16.34.25  by  Michael Scheer
*CMZ :  2.50/03 10/05/2004  14.41.11  by  Michael Scheer
*CMZ :  2.50/02 30/04/2004  15.33.31  by  Michael Scheer
*CMZ :  2.50/01 30/04/2004  08.58.23  by  Michael Scheer
*CMZ :  2.50/00 29/04/2004  18.46.23  by  Michael Scheer
*CMZ :  2.49/01 23/03/2004  14.32.47  by  Michael Scheer
*CMZ :  2.48/04 17/03/2004  14.54.00  by  Michael Scheer
*CMZ :  2.48/03 10/03/2004  16.04.11  by  Michael Scheer
*CMZ :  2.48/02 03/03/2004  11.26.16  by  Michael Scheer
*CMZ :  2.48/01 02/03/2004  16.44.04  by  Michael Scheer
*CMZ :  2.48/00 01/03/2004  18.05.54  by  Michael Scheer
*CMZ :  2.47/23 17/02/2004  13.48.36  by  Michael Scheer
*CMZ :  2.47/22 03/12/2003  13.18.07  by  Michael Scheer
*CMZ :  2.47/21 03/12/2003  09.50.02  by  Michael Scheer
*CMZ :  2.47/20 01/12/2003  15.35.07  by  Michael Scheer
*CMZ :  2.47/19 01/12/2003  08.24.44  by  Michael Scheer
*CMZ :  2.47/18 27/11/2003  14.46.01  by  Michael Scheer
*CMZ :  2.47/17 12/09/2003  10.10.52  by  Michael Scheer
*CMZ :  2.47/16 11/09/2003  15.10.44  by  Michael Scheer
*CMZ :  2.47/15 04/09/2003  09.28.29  by  Michael Scheer
*CMZ :  2.47/14 07/08/2003  09.44.02  by  Michael Scheer
*CMZ :  2.47/13 03/07/2003  09.57.40  by  Michael Scheer
*CMZ :  2.47/12 03/07/2003  09.56.41  by  Michael Scheer
*CMZ :  2.47/11 30/05/2003  12.54.22  by  Michael Scheer
*CMZ :  2.47/10 30/05/2003  12.43.23  by  Michael Scheer
*CMZ :  2.47/09 27/05/2003  15.58.18  by  Michael Scheer
*CMZ :  2.47/08 20/05/2003  15.48.28  by  Michael Scheer
*CMZ :  2.47/07 15/04/2003  10.52.36  by  Michael Scheer
*CMZ :  2.47/06 28/03/2003  15.40.56  by  Michael Scheer
*CMZ :  2.47/05 27/03/2003  15.27.38  by  Michael Scheer
*CMZ :  2.47/04 13/03/2003  11.06.38  by  Michael Scheer
*CMZ :  2.47/03 12/03/2003  16.02.35  by  Michael Scheer
*CMZ :  2.47/02 12/03/2003  10.54.25  by  Michael Scheer
*CMZ :  2.47/01 10/03/2003  11.57.24  by  Michael Scheer
*CMZ :  2.46/02 07/03/2003  11.17.22  by  Michael Scheer
*CMZ :  2.46/01 18/12/2002  11.47.23  by  Michael Scheer
*CMZ :  2.46/00 17/12/2002  16.46.49  by  Michael Scheer
*CMZ :  2.45/03 17/12/2002  15.15.55  by  Michael Scheer
*CMZ :  2.45/02 16/12/2002  14.36.34  by  Michael Scheer
*CMZ :  2.45/01 13/12/2002  17.25.42  by  Michael Scheer
*CMZ :  2.44/03 13/12/2002  12.43.06  by  Michael Scheer
*CMZ :  2.44/02 13/12/2002  11.39.21  by  Michael Scheer
*CMZ :  2.44/01 12/12/2002  13.32.07  by  Michael Scheer
*CMZ :  2.44/00 15/11/2002  18.31.49  by  Michael Scheer
*CMZ :  2.42/04 29/10/2002  11.33.36  by  Michael Scheer
*CMZ :  2.42/03 13/09/2002  18.47.33  by  Michael Scheer
*CMZ :  2.42/02 12/09/2002  11.07.58  by  Michael Scheer
*CMZ :  2.42/01 09/09/2002  18.56.25  by  Michael Scheer
*CMZ :  2.41/13 03/09/2002  14.29.39  by  Michael Scheer
*CMZ :  2.41/12 22/08/2002  12.13.49  by  Michael Scheer
*CMZ :  2.41/11 21/08/2002  11.28.45  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.50.10  by  Michael Scheer
*CMZ :  2.41/09 14/08/2002  17.27.24  by  Michael Scheer
*CMZ :  2.41/08 14/08/2002  17.06.27  by  Michael Scheer
*CMZ :  2.41/07 30/07/2002  12.13.11  by  Michael Scheer
*CMZ :  2.41/06 10/05/2002  15.26.01  by  Michael Scheer
*CMZ :  2.41/05 18/04/2002  11.47.34  by  Michael Scheer
*CMZ :  2.41/04 16/04/2002  14.29.54  by  Michael Scheer
*CMZ :  2.41/03 21/03/2002  12.44.56  by  Michael Scheer
*CMZ :  2.41/01 21/03/2002  12.36.42  by  Michael Scheer
*CMZ :  2.41/00 20/03/2002  19.24.01  by  Michael Scheer
*CMZ :  2.40/04 20/03/2002  12.33.26  by  Michael Scheer
*CMZ :  2.40/02 14/03/2002  16.23.09  by  Michael Scheer
*CMZ :  2.40/01 12/03/2002  14.36.49  by  Michael Scheer
*CMZ :  2.40/00 12/03/2002  14.28.59  by  Michael Scheer
*CMZ :  2.39/02 22/01/2002  13.35.44  by  Michael Scheer
*CMZ :  2.39/01 15/01/2002  16.49.21  by  Michael Scheer
*CMZ :  2.39/00 14/01/2002  14.37.58  by  Michael Scheer
*CMZ :  2.38/03 13/12/2001  15.06.40  by  Michael Scheer
*CMZ :  2.38/02 13/12/2001  13.44.34  by  Michael Scheer
*CMZ :  2.38/01 13/12/2001  12.16.53  by  Michael Scheer
*CMZ :  2.37/07 12/12/2001  14.47.52  by  Michael Scheer
*CMZ :  2.37/06 07/12/2001  15.02.02  by  Michael Scheer
*CMZ :  2.37/05 07/12/2001  14.52.16  by  Michael Scheer
*CMZ :  2.37/04 05/12/2001  17.37.12  by  Michael Scheer
*CMZ :  2.37/03 23/11/2001  18.19.34  by  Michael Scheer
*CMZ :  2.37/02 15/11/2001  17.25.18  by  Michael Scheer
*CMZ :  2.37/01 14/11/2001  11.08.43  by  Michael Scheer
*CMZ :  2.37/00 13/11/2001  17.33.11  by  Michael Scheer
*CMZ :  2.36/01 08/11/2001  17.39.47  by  Michael Scheer
*CMZ :  2.36/00 08/11/2001  15.34.30  by  Michael Scheer
*CMZ :  2.35/02 30/10/2001  17.15.18  by  Michael Scheer
*CMZ :  2.35/01 17/10/2001  11.40.54  by  Michael Scheer
*CMZ :  2.35/00 26/09/2001  17.19.48  by  Michael Scheer
*CMZ :  2.34/09 26/09/2001  17.17.20  by  Michael Scheer
*CMZ :  2.34/08 17/09/2001  19.44.50  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  17.41.49  by  Michael Scheer
*CMZ :  2.34/06 23/08/2001  17.38.11  by  Michael Scheer
*CMZ :  2.34/04 11/07/2001  11.20.36  by  Michael Scheer
*CMZ :  2.34/02 02/07/2001  17.25.12  by  Michael Scheer
*CMZ :  2.34/00 11/05/2001  17.27.00  by  Michael Scheer
*CMZ :  2.33/09 10/05/2001  18.03.20  by  Michael Scheer
*CMZ :  2.33/08 08/05/2001  17.52.21  by  Michael Scheer
*CMZ :  2.33/07 08/05/2001  17.43.33  by  Michael Scheer
*CMZ :  2.33/06 04/05/2001  13.56.57  by  Michael Scheer
*CMZ :  2.33/05 04/05/2001  11.42.46  by  Michael Scheer
*CMZ :  2.33/04 04/05/2001  11.37.04  by  Michael Scheer
*CMZ :  2.33/03 04/05/2001  11.15.03  by  Michael Scheer
*CMZ :  2.33/02 03/05/2001  17.23.54  by  Michael Scheer
*CMZ :  2.33/01 03/05/2001  14.01.01  by  Michael Scheer
*CMZ :  2.32/04 26/04/2001  12.37.02  by  Michael Scheer
*CMZ :  2.32/03 26/04/2001  11.12.11  by  Michael Scheer
*CMZ :  2.32/02 26/04/2001  11.09.43  by  Michael Scheer
*CMZ :  2.32/01 25/04/2001  19.09.17  by  Michael Scheer
*CMZ :  2.32/00 25/04/2001  17.14.54  by  Michael Scheer
*CMZ :  2.31/01 25/04/2001  17.13.47  by  Michael Scheer
*CMZ :  2.31/00 24/04/2001  16.07.58  by  Michael Scheer
*CMZ :  2.30/04 23/04/2001  12.34.39  by  Michael Scheer
*CMZ :  2.30/03 20/04/2001  16.32.24  by  Michael Scheer
*CMZ :  2.30/02 12/04/2001  19.12.58  by  Michael Scheer
*CMZ :  2.30/01 12/04/2001  18.24.05  by  Michael Scheer
*CMZ :  2.30/00 11/04/2001  19.35.18  by  Michael Scheer
*CMZ :  2.20/12 11/04/2001  19.33.04  by  Michael Scheer
*CMZ :  2.20/11 11/04/2001  16.16.37  by  Michael Scheer
*CMZ :  2.20/10 10/04/2001  12.26.28  by  Michael Scheer
*CMZ :  2.20/09 03/04/2001  14.52.40  by  Michael Scheer
*CMZ :  2.20/08 18/03/2001  22.18.21  by  Michael Scheer
*CMZ :  2.20/07 18/03/2001  17.09.21  by  Michael Scheer
*CMZ :  2.20/06 15/03/2001  17.20.43  by  Michael Scheer
*CMZ :  2.20/04 09/03/2001  19.55.49  by  Michael Scheer
*CMZ :  2.20/03 23/02/2001  15.16.41  by  Michael Scheer
*CMZ :  2.20/02 21/02/2001  11.41.58  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.33.29  by  Michael Scheer
*CMZ : 00.01/04 28/11/94  17.27.56  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  15.13.26  by  Michael Scheer
*-- Author :Michael Scheer
     &  '          *       VERSION 4.01/04   28.12.2023        *'
+self,if=versdum.
Maszstab           ********VERSION 1.23/45 *********************
+self.

+PATCH,UTIL.
*CMZ :  3.02/03 31/10/2014  12.56.18  by  Michael Scheer
+DECK,util_root_taylor.
*CMZ :  4.01/04 21/11/2023  07.38.22  by  Michael Scheer
*-- Author :    Michael Scheer   21/11/2023
      subroutine util_root_taylor(x,eps,r)

      implicit none
      double precision x,eps,r

      if (eps.lt.0.01) then
        r=abs(x)*(1.0d0+(((((-0.0205078125D0*eps+0.02734375D0)*eps
     &    -0.0390625D0)*eps+0.0625D0)*eps-0.125D0)*eps+0.5D0)*eps)
      else
        r=sqrt(x**2+r)
      endif

      return
      end
+PATCH,OMP.
*CMZ :  3.05/01 04/05/2018  15.06.07  by  Michael Scheer
+DECK,argsum_omp.
*CMZ :  4.01/04 14/11/2023  11.36.12  by  Michael Scheer
*CMZ :  4.01/03 02/06/2023  09.03.03  by  Michael Scheer
*CMZ :  4.00/14 11/02/2022  10.28.53  by  Michael Scheer
*CMZ :  3.07/00 15/03/2019  12.15.25  by  Michael Scheer
*CMZ :  3.05/01 09/05/2018  08.36.06  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.10  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  15.45.11  by  Michael Scheer
*CMZ :  2.69/02 07/11/2012  13.59.21  by  Michael Scheer
*CMZ :  2.68/05 28/09/2012  12.15.44  by  Michael Scheer
*CMZ :  2.67/00 13/02/2012  10.58.17  by  Michael Scheer
*CMZ :  2.65/03 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.64/04 14/09/2009  15.19.42  by  Michael Scheer
*CMZ :  2.64/03 21/08/2009  17.32.56  by  Michael Scheer
*CMZ :  2.64/02 21/08/2009  17.24.35  by  Michael Scheer
*CMZ :  2.64/01 20/08/2009  15.20.55  by  Michael Scheer
*CMZ :  2.63/05 03/08/2009  16.11.05  by  Michael Scheer
*CMZ :  2.52/12 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.52/11 08/12/2004  13.37.55  by  Michael Scheer
*CMZ :  2.51/02 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.50/00 29/04/2004  15.29.30  by  Michael Scheer
*CMZ :  2.20/01 24/11/2000  21.15.06  by  Michael Scheer
*CMZ :  2.16/08 31/10/2000  14.40.08  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  17.26.23  by  Michael Scheer
*CMZ :  2.13/07 17/02/2000  15.11.12  by  Michael Scheer
*CMZ :  2.13/04 21/01/2000  11.57.55  by  Michael Scheer
*CMZ :  2.13/03 17/01/2000  17.27.08  by  Michael Scheer
*CMZ :  2.12/02 15/06/99  15.16.33  by  Michael Scheer
*CMZ :  2.12/00 27/05/99  10.08.55  by  Michael Scheer
*CMZ :  2.11/01 19/05/99  14.09.50  by  Michael Scheer
*CMZ :  2.10/01 19/03/99  14.13.05  by  Michael Scheer
*CMZ :  2.00/00 06/01/99  11.12.16  by  Michael Scheer
*CMZ : 00.01/02 24/11/94  15.25.26  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.46.43  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.46  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE ARGSUM_omp(ISOUR,IOBSV,IBUFF,nreromp,reromp)

+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,REARGF90U.
+SEQ,OBSERVF90U.
+SEQ,AFREQF90U.
+SEQ,AMPLIF90U.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,PHYCON.
+seq,sourcef90.
+SEQ,SPECT.
+SEQ,FREQS.
+SEQ,AMPLI.
+SEq,observf90.
+SEQ,MYFILES.

      INTEGER ISOUR,IOBSV,kfreq,IPOI,ICOMP,IST,ICAL,JOBSV,IBUFF

      integer nreromp
      double precision reromp(11,nreromp)

      INTEGER NTUPP
      PARAMETER (NTUPP=38)
      REAL*8 FILLT(NTUPP)

      COMPLEX*16 APOL,EXPOM,DEXPOM,ZIOM,AX0,AY0,AZ0,AX,AY,AZ,ZI,ZONE,
     &  DMODU,DMODU0,DDMODU,baff(3),daff(3),bx0,by0,bz0,bxc,byc,bzc
      COMPLEX*8 APOLH,APOLR,APOLL,APOL45

      DOUBLE PRECISION :: OM,DOM,RSPECNOR=1.0d0,DT,DT2,T

      DOUBLE PRECISION RARG(8),rn,rnx,rny,rnz,
     &  DXEXI,CENXEXI,DTPHASE,FREQR,GAMMA21,GAMGAM,R0,R02,H2,R00,H2R2,
     &  PHI,CORRR0,GAMGAM0,AMPDT,R2,POW

      REAL*4 STOK1,STOK2,STOK3,STOK4

      INTEGER I

      DATA ICAL/0/

      DATA ZI/(0.0D0,1.0D0)/
      DATA ZONE/(1.0D0,0.0D0)/

      save ical

      if (ical.eq.0) then
        print*,'*** Warning in argsum_omp: Histogram of sources not completly filled'
        print*,'Please, consider ISPECMODE=2'
        ical=1
      endif

c11.2.2022      RSPECNOR=DSQRT(SPECNOR) !to be consistent with hfreq, souintana etc.

C--- PERFORMS INTEGRATION FOR ALL FREQUENCES

C    ASSUMES FREQ(I+1)=FREQ(I)*2   FOR IFREQ2P=2
C    OR FREQ(I+1)=FREQ(I)+DELTA    FOR IFREQ2P>2

      DOM=(FREQ(2)-FREQ(1))/HBAREV1

C-- LOOP OVER TIME STEPS (ACTUAL INTEGRATION)

      IF (IBUFF.EQ.1) THEN
        T=-reromp(6,1)
      ENDIF

      DO IPOI=1,IARGUM

        DT=reromp(6,IPOI)
        DT2=DT*0.5D0

        T=T+DT

        RARG(1)=reromp(1,IPOI)*DT
        RARG(2)=reromp(2,IPOI)*DT
        RARG(3)=reromp(3,IPOI)*DT

        RARG(4)=reromp(4,IPOI)
        RARG(5)=reromp(5,IPOI)*DT

        rarg(6:8)=reromp(9:11,ipoi)
        rn=norm2(rarg(6:8))
        rnx=rarg(6)/rn
        rny=rarg(7)/rn
        rnz=rarg(8)/rn

        OM=FREQ(1)/HBAREV1
        IF (IVELOFIELD.EQ.2) THEN
          ZIOM=DCMPLX(0.0D0,OM)
        ELSE
          ZIOM=DCMPLX(1.0D0,0.0D0)
        ENDIF

        EXPOM=CDEXP(DCMPLX(0.D0,RARG(4)*OM))

        IF(IFREQ2P.GT.2) DEXPOM=CDEXP(DCMPLX(0.D0,RARG(4)*DOM))

        ifrob=1+NFREQ*(IOBSV-1)
        DO ICOMP=1,3
          daff(icomp)=ZIOM*DCMPLX(RARG(ICOMP))*EXPOM*REFLEC(ICOMP)
          afreq(ICOMP,ifrob)=afreq(ICOMP,ifrob)+daff(icomp)
        ENDDO

c        baff(1)=conjg(rny*daff(3)-rnz*daff(2))
c        baff(2)=conjg(rnz*daff(1)-rnx*daff(3))
c        baff(3)=conjg(rnx*daff(2)-rny*daff(1))

        baff(1)=(rny*daff(3)-rnz*daff(2))
        baff(2)=(rnz*daff(1)-rnx*daff(3))
        baff(3)=(rnx*daff(2)-rny*daff(1))

        afreq(4:6,IFROB)=afreq(4:6,IFROB)+baff(1:3)/clight1

C--- LOOP OVER ALL FREQUENCES

        DO kfreq=2,NFREQ

            OM=FREQ(kfreq)/HBAREV1
            IF (IVELOFIELD.EQ.2) THEN
              ZIOM=DCMPLX(0.0D0,OM)
            ELSE
              ZIOM=DCMPLX(1.0D0,0.0D0)
            ENDIF

            IF    (IFREQ2P.LT.2) THEN
              EXPOM=CDEXP(DCMPLX(0.D0,RARG(4)*OM))
            ELSE IF(ifreq2p.EQ.2) THEN
              EXPOM=EXPOM*EXPOM
            ELSE
              EXPOM=EXPOM*DEXPOM
            ENDIF

            ifrob=kfreq+NFREQ*(IOBSV-1)
            DO ICOMP=1,3
c              ifrob=kfreq
              daff(icomp)=ZIOM*DCMPLX(RARG(ICOMP))*EXPOM*REFLEC(ICOMP)
              afreq(ICOMP,ifrob)=afreq(ICOMP,ifrob)+daff(icomp)
            ENDDO

c            baff(1)=conjg(rny*daff(3)-rnz*daff(2))
c            baff(2)=conjg(rnz*daff(1)-rnx*daff(3))
c            baff(3)=conjg(rnx*daff(2)-rny*daff(1))

            baff(1)=(rny*daff(3)-rnz*daff(2))
            baff(2)=(rnz*daff(1)-rnx*daff(3))
            baff(3)=(rnx*daff(2)-rny*daff(1))

            afreq(4:6,IFROB)=afreq(4:6,IFROB)+baff(1:3)/clight1

          ENDDO   !LOOP OVER ALL FREQUENCES

        iliob=ISOUR+NSOURCE*(IOBSV-1)
        SPECPOW(iliob)=SPECPOW(iliob)+RARG(5)
        IF(IWFILINT.EQ.-ISOUR.AND.IOBSV.EQ.1) THEN

          kfreq=1
          IOBSV=1

          FILLT(1)=T
          FILLT(2)=WSOU(1,1,IPOI)
          FILLT(3)=WSOU(2,1,IPOI)
          FILLT(4)=WSOU(3,1,IPOI)
          FILLT(5)=RARG(1)
          FILLT(6)=RARG(2)
          FILLT(7)=RARG(3)
          FILLT(8)=RARG(4)
          FILLT(9)=MIN(RARG(5),1.D30)
          FILLT(10)=DREAL(EXPOM)
          FILLT(11)=DIMAG(EXPOM)
          FILLT(12)=0.0d0
          FILLT(13)=IOBSV
          FILLT(14)=kfreq
          IF (NOBSV.EQ.1) THEN
            FILLT(15)=OBS1Y
            FILLT(16)=OBS1Z
          ELSE
            FILLT(15)=OBSV(2,IOBSV)
            FILLT(16)=OBSV(3,IOBSV)
          ENDIF
          FILLT(17)=0.0d0
          FILLT(18)=0.0d0
          FILLT(19)=0.0d0
          FILLT(20)=0.0d0
          FILLT(21)=dble(isour)
          ifrob=kfreq+NFREQ*(IOBSV-1)
c              ifrob=kfreq
          FILLT(22)=
     &      DREAL(
     &      afreq(1,ifrob)*CONJG(afreq(1,ifrob))
     &      +afreq(2,ifrob)*CONJG(afreq(2,ifrob))
     &      +afreq(3,ifrob)*CONJG(afreq(3,ifrob))
     &      )*SPECNOR

          FILLT(23)=DREAL(afreq(1,ifrob))
          FILLT(24)=DIMAG(afreq(1,ifrob))
          FILLT(25)=DREAL(afreq(2,ifrob))
          FILLT(26)=DIMAG(afreq(2,ifrob))
          FILLT(27)=DREAL(afreq(3,ifrob))
          FILLT(28)=DIMAG(afreq(3,ifrob))
          FILLT(29)=0.0d0
          FILLT(30)=0.0d0
          FILLT(31)=0.0d0
          FILLT(32)=0.0d0
          FILLT(33)=0.0d0
          FILLT(34)=0.0d0
          FILLT(35)=0.0d0
c                ef(1:3)=real(afreq(1:3,ifrob))
c                bf(1:3)=real(afreq(4:6,ifrob))
c                rnx=ef(2)*bf(3)-ef(3)*bf(2)
c                rny=ef(3)*bf(1)-ef(1)*bf(3)
c                rnz=ef(1)*bf(2)-ef(2)*bf(1)
          rnx=real(
     &      afreq(2,ifrob)*conjg(afreq(6,ifrob))-
     &      afreq(3,ifrob)*conjg(afreq(5,ifrob)))
          rny=real(
     &      afreq(3,ifrob)*conjg(afreq(4,ifrob))-
     &      afreq(1,ifrob)*conjg(afreq(6,ifrob)))
          rnz=real(
     &      afreq(1,ifrob)*conjg(afreq(5,ifrob))-
     &      afreq(2,ifrob)*conjg(afreq(4,ifrob)))
          rn=sqrt(rnx**2+rny**2+rnz**2)

          FILLT(36)=rnx/rn
          FILLT(37)=rny/rn
          FILLT(38)=rnz/rn

          CALL hfm(NIDSOURCE,FILLT)

        ENDIF !IWFILINT.EQ.-ISOUR

      ENDDO   !LOOP OVER TIME STEPS

      IF (NSADD.NE.0) THEN

        IF (IAMPLI.LT.0) THEN

          GAMGAM0=SOURCEG(1,1,ISOUR)**2
          GAMGAM=(SOURCEG(1,1,ISOUR)+SOURCEG(2,2,ISOUR))**2
          GAMMA21=1.0D0/GAMGAM0
          DXEXI=MIN(SOURCEEO(1,1,ISOUR),XIEND)
     &      -MAX(SOURCEAO(1,1,ISOUR),XIANF)
          CENXEXI=(MIN(SOURCEEO(1,1,ISOUR),XIEND)
     &      +MAX(SOURCEAO(1,1,ISOUR),XIANF))/2.D0
          DTPHASE=(WTRA2IS(ISOUR)+GAMMA21*DXEXI/2.D0)/CLIGHT1
     &    *GAMGAM0/GAMGAM
          AMPDT=AMPSHIFT(1)/CLIGHT1/2.0D0/GAMGAM0
          DTPHASE=DTPHASE+AMPDT
          FREQR=2.D0*PI1/DTPHASE*HBAREV1
          POW=SPECPOW(iliob)
          SPECPOW(iliob)=0.0D0

          DO I=1,-IAMPLI
            R02=(OBSV(1,IOBSV)-CENXEXI)**2+OBSV(2,IOBSV)**2+OBSV(3,IOBSV)**2
            R2=(OBSV(1,IOBSV)-CENXEXI-DXEXI*(I-ABS(IAMPLI)/2+1))**2
     &        +OBSV(2,IOBSV)**2+OBSV(3,IOBSV)**2
            SPECPOW(iliob)=SPECPOW(iliob)+POW*R02/R2
          ENDDO

          DO kfreq=1,NFREQ

            ILiobfr=ISOUR+NSOURCE*(IOBSV-1+NOBSV*(kfreq-1))
            ifrob=kfreq+NFREQ*(IOBSV-1)
c          ifrob=kfreq
            iobfr=IOBSV+NOBSV*(kfreq-1)

            OM=FREQ(kfreq)/HBAREV1

            AX0=afreq(1,ifrob)
            AY0=afreq(2,ifrob)
            AZ0=afreq(3,ifrob)

            AX=AX0
            AY=AY0
            AZ=AZ0

            BX0=afreq(1,ifrob)
            BY0=afreq(2,ifrob)
            BZ0=afreq(3,ifrob)

            BXc=BX0
            BYc=BY0
            BZc=BZ0

            afreq(1:6,ifrob)=(0.0D0,0.0D0)

            R0=OBSV(1,NOBSV/2+1)-CENXEXI
            R02=R0*R0
            R00=R0
            H2=(OBSV(2,IOBSV))**2+(OBSV(3,IOBSV))**2
            H2R2=H2/R02

            DTPHASE=(WTRA2IS(ISOUR)+(H2R2+GAMMA21)*DXEXI/2.D0)/CLIGHT1
     &        *GAMGAM0/GAMGAM
     &        +AMPDT
            PHI=2.D0*PI1*FREQ(kfreq)*ECHARGE1/HPLANCK1*DTPHASE

            DMODU=EXP(ZI*PHI)
            DMODU0=DMODU
            DDMODU=ZONE

            DO I=1,-IAMPLI

              R0=OBSV(1,NOBSV/2+1)+DXEXI/2.D0*(-IAMPLI-2*(I-1)-1)
              CORRR0=R00/R0
              R02=R0*R0
              H2=(OBSV(2,IOBSV))**2+(OBSV(3,IOBSV))**2
              H2R2=H2/R02

              GAMGAM=(SOURCEG(1,1,ISOUR)+(I-1)*SOURCEG(2,2,ISOUR))**2
              DTPHASE=(WTRA2IS(ISOUR)+(H2R2+GAMMA21)*DXEXI/2.D0)/CLIGHT1
     &          *GAMGAM0/GAMGAM+AMPDT
              PHI=2.D0*PI1*FREQ(kfreq)*ECHARGE1/HPLANCK1*DTPHASE

              DMODU=EXP(ZI*PHI)
              DMODU0=DMODU
              DDMODU=ZONE

              afreq(1,ifrob)=afreq(1,ifrob)+AX
              afreq(2,ifrob)=afreq(2,ifrob)+AY
              afreq(3,ifrob)=afreq(3,ifrob)+AZ

              afreq(4,ifrob)=afreq(4,ifrob)+BXc
              afreq(5,ifrob)=afreq(5,ifrob)+BYc
              afreq(6,ifrob)=afreq(6,ifrob)+BZc

              IF (AMPRAN.NE.0.D0) THEN
                PHI=2.D0*PI1*XRANA(I)/FREQR*FREQ(kfreq)
                DDMODU=EXP(ZI*PHI)
              ENDIF   !(AMPRAN.NE.0.D0)

              AX0=AX0*DMODU0
              AY0=AY0*DMODU0
              AZ0=AZ0*DMODU0

              AX=AX0*CORRR0
              AY=AY0*CORRR0
              AZ=AZ0*CORRR0

              DMODU=DMODU0*DDMODU
              AX=AX*DMODU
              AY=AY*DMODU
              AZ=AZ*DMODU

              BX0=BX0*DMODU0
              BY0=BY0*DMODU0
              BZ0=BZ0*DMODU0

              BXc=BX0*CORRR0
              BYc=BY0*CORRR0
              BZc=BZ0*CORRR0

              BXc=BXc*DMODU
              BYc=BYc*DMODU
              BZc=BZc*DMODU

            ENDDO !IAMPLI

          ENDDO !kfreq

        ENDIF  !(IAMPLI.LT.0)

        DO kfreq=1,NFREQ

          ILiobfr=ISOUR+NSOURCE*(IOBSV-1+NOBSV*(kfreq-1))
          iobfr=IOBSV+NOBSV*(kfreq-1)
          ifrob=kfreq+NFREQ*(IOBSV-1)
c              ifrob=kfreq

          IF (IPOLA.EQ.0) THEN

            SPEC(ILiobfr)=
     &        DREAL(
     &        afreq(1,ifrob)*CONJG(afreq(1,ifrob))
     &        +afreq(2,ifrob)*CONJG(afreq(2,ifrob))
     &        +afreq(3,ifrob)*CONJG(afreq(3,ifrob))
     &        )*SPECNOR

            REAIMA(1:3,1,iobfr)=REAIMA(1:3,1,iobfr)+
     &        DREAL(afreq(1:3,ifrob))*RSPECNOR
            REAIMA(1:3,2,iobfr)=REAIMA(1:3,2,iobfr)+
     &        DIMAG(afreq(1:3,ifrob))*RSPECNOR

            REAIMA(8:10,1,iobfr)=REAIMA(8:10,1,iobfr)+
     &        DREAL(afreq(4:6,ifrob))*RSPECNOR
            REAIMA(8:10,2,iobfr)=REAIMA(8:10,2,iobfr)+
     &        DIMAG(afreq(4:6,ifrob))*RSPECNOR

          ELSE    !IPOLA

            APOL=
     &        afreq(1,ifrob)*CONJG(VPOLA(1))
     &        +afreq(2,ifrob)*CONJG(VPOLA(2))
     &        +afreq(3,ifrob)*CONJG(VPOLA(3))

            SPEC(ILiobfr)=
     &        DREAL(APOL*CONJG(APOL))*SPECNOR

            REAIMA(1,1,iobfr)=REAIMA(1,1,iobfr)+
     &        DREAL(afreq(1,ifrob))*RSPECNOR
            REAIMA(2,1,iobfr)=REAIMA(2,1,iobfr)+
     &        DREAL(afreq(2,ifrob))*RSPECNOR
            REAIMA(3,1,iobfr)=REAIMA(3,1,iobfr)+
     &        DREAL(afreq(3,ifrob))*RSPECNOR

            REAIMA(1,2,iobfr)=REAIMA(1,2,iobfr)+
     &        DIMAG(afreq(1,ifrob))*RSPECNOR
            REAIMA(2,2,iobfr)=REAIMA(2,2,iobfr)+
     &        DIMAG(afreq(2,ifrob))*RSPECNOR
            REAIMA(3,2,iobfr)=REAIMA(3,2,iobfr)+
     &        DIMAG(afreq(3,ifrob))*RSPECNOR

          ENDIF   !IPOLA

          iobfr=IOBSV+NOBSV*(kfreq-1)
          ifrob=kfreq+NFREQ*(IOBSV-1)
c              ifrob=kfreq

          IF (ISTOKES.NE.0) THEN

            APOLH=
     &        afreq(1,ifrob)*CONJG(VSTOKES(1,1))
     &        +afreq(2,ifrob)*CONJG(VSTOKES(1,2))
     &        +afreq(3,ifrob)*CONJG(VSTOKES(1,3))

            APOLR=
     &        afreq(1,ifrob)*CONJG(VSTOKES(2,1))
     &        +afreq(2,ifrob)*CONJG(VSTOKES(2,2))
     &        +afreq(3,ifrob)*CONJG(VSTOKES(2,3))

            APOLL=
     &        afreq(1,ifrob)*CONJG(VSTOKES(3,1))
     &        +afreq(2,ifrob)*CONJG(VSTOKES(3,2))
     &        +afreq(3,ifrob)*CONJG(VSTOKES(3,3))

            APOL45=
     &        afreq(1,ifrob)*CONJG(VSTOKES(4,1))
     &        +afreq(2,ifrob)*CONJG(VSTOKES(4,2))
     &        +afreq(3,ifrob)*CONJG(VSTOKES(4,3))

            STOK1=
     &        REAL(APOLR*CONJG(APOLR))+
     &        REAL(APOLL*CONJG(APOLL))

            STOK2=-STOK1+
     &        2.*REAL(APOLH*CONJG(APOLH))

            STOK3=
     &        2.*REAL(APOL45*CONJG(APOL45))-
     &        STOK1

            STOK4=
     &        REAL(APOLR*CONJG(APOLR))-
     &        REAL(APOLL*CONJG(APOLL))


            STOKES(1,iobfr)=STOKES(1,iobfr)+
     &        STOK1*SPECNOR

            STOKES(2,iobfr)=STOKES(2,iobfr)+
     &        STOK2*SPECNOR

            STOKES(3,iobfr)=STOKES(3,iobfr)+
     &        STOK3*SPECNOR

            STOKES(4,iobfr)=STOKES(4,iobfr)+
     &        STOK4*SPECNOR
          ENDIF

        ENDDO !kfreq

        iliob=ISOUR+NSOURCE*(IOBSV-1)
        SPECPOW(iliob)=SPECPOW(iliob)*pownor

      ENDIF !NSADD

      RETURN
      END
+DECK,souintana_omp.
*CMZ :  4.01/04 26/11/2023  16.52.38  by  Michael Scheer
*CMZ :  4.01/03 11/06/2023  11.04.36  by  Michael Scheer
*CMZ :  4.00/17 28/11/2022  17.48.39  by  Michael Scheer
*CMZ :  4.00/15 13/03/2022  19.00.20  by  Michael Scheer
*CMZ :  4.00/13 06/12/2021  13.18.24  by  Michael Scheer
*CMZ :  3.08/01 03/04/2019  15.40.06  by  Michael Scheer
*CMZ :  3.07/00 15/03/2019  12.15.25  by  Michael Scheer
*CMZ :  3.06/00 26/02/2019  10.53.54  by  Michael Scheer
*CMZ :  3.05/13 19/09/2018  13.46.31  by  Michael Scheer
*CMZ :  3.05/06 17/07/2018  11.12.29  by  Michael Scheer
*CMZ :  3.05/04 27/06/2018  13.51.56  by  Michael Scheer
*CMZ :  3.05/03 22/05/2018  07.12.30  by  Michael Scheer
*CMZ :  3.05/02 15/05/2018  15.27.15  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE souintana_omp(ISOUR,IOBSV,INSIDE)

+seq,gplhint.
+SEQ,TRACKF90U.
+SEQ,WORKF90U.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,AFREQF90U.
+SEQ,AMPLIF90U.
+SEQ,WFOLDF90U.

      use bunchmod
      use wbetaf90m
      use souintmod

C--- EVALUATE INTEGRALES FOR A SINGLE SOURCE
C---- RESULTS ARE STORE IN AFREQ AND SPECPOW

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,PHYCON.
+SEQ,TRACK.
+seq,sourcef90.
+SEQ,COLLI.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,FREQS.
+SEQ,AMPLI.
+SEQ,B0SCGLOB.
+SEQ,PRIMKIN.
+SEq,wfoldf90.
+seq,ustep.
+SEQ,uservar.
+seq,tralin.
+seq,whbook.
+seq,pawcmn.
+seq,specdip.
+seq,datetime.
+seq,souintanac.

c      double precision ampzmax(ndfreqp)
c      integer kobs(ndfreqp)
c      common/kobsc/ampzmax,kobs

      REAL*8 FSPEC(31)

      double precision rn_cross_beta(3), rn_cross_rn_cross_beta(3)
      double precision h2,ddist,dist0,dist02
     & ,vn,dgamma

c      COMPLEX*16 ZIOM,ZI,ZIDOM,ZONE,ZICR1,ZIC
      COMPLEX*16 EXPOM1,EXPOM,DEXPOMPH1,DEXPOMPH,DDEXPOMPH,DEXPOM,EXPOMV2,
     &  zicr1,baff(3),daff(3)
      COMPLEX*16 APOL,APOLH,APOLR,APOLL,APOL45
     &  ,DMODU,DMODU0,DDMODU,AX,AY,AZ,AX0,AY0,AZ0,bx0,by0,bz0,bxc,byc,bzc

      double precision apz(nfreq),azc(nfreq),azs(nfreq)

      DOUBLE PRECISION T0,T1,T2,TENDSOU,X0,X1,X2,X10,Y1,Y2,Z1,Z2,R0
     &  ,T,DT,DT2,DT0,VXP,VYP,VZP,TENDSOU1
     &  ,R02
c     &  ,H2,H2R2
     &  ,PHI,FREQR,CORRR0,R00,R2,POW,powpow
     &  ,X2B,Y2B,Z2B
     &  ,DGAMSUM,BETA,GAMGAM,GAMGAM0,AMPDT
     &  ,xn1,slopein,slope,drn1,drn2,zn1,yn1,wi,
     &  zz,yy,zzp,yyp,zzi,yyi,yypi,zzpi,
     &  yeleco,zeleco,zpeleco,ypeleco
c     &  ,ef(3),bf(3)

      DOUBLE PRECISION VX1,VY1,VZ1,BX1,BY1,BZ1
      DOUBLE PRECISION VX2,VY2,VZ2,BX2,BY2,BZ2,AX2D,AY2D,AZ2D
      DOUBLE PRECISION ECDUM,BS,BSQ,BS1
      DOUBLE PRECISION TS,DPHASE,DPHSOUR(2,2)
      DOUBLE PRECISION GAMMA

      DOUBLE PRECISION BX,BY,BZ,RX,RY,RZ,PX,PY,PZ,rn,RNBX,RNBY,RNBZ
      DOUBLE PRECISION R1,RNX,RNY,RNZ,DOM1,DOM2,BET1N,DUM11,R,BPX,BPY,BPZ
      DOUBLE PRECISION WGANG,OPANG

      DOUBLE PRECISION RARG(5),PHASE,t0ph

      DOUBLE PRECISION DROIX,DTPHASE,DXEXI,CENXEXI
      DOUBLE PRECISION STOK1,STOK2,STOK3,STOK4,BET1NO
      double precision br2,rnr2,br4,rnr4,b3
     &  ,are(6),aim(6),yp2zp2i,robsv,phiobsv,
     &  f(3),yp(3),ypp,a(3),fdt(3),filo,fihi,dfdt,xobsv,yobsv,zobsv,speck,
     &  tfmh(2,2),tfmv(2,2),tfm1(2,2),
     &  w22(2,2),dum22(2,2),
     &  tfmhi(2,2),tfmvi(2,2),
     &  tfmdehi(2,2),tfmdevi(2,2),
     &  tfmdeh(2,2),tfmdev(2,2),
     &  tfmhc(2,2),tfmvc(2,2),
     &  tfmdehc(2,2),tfmdevc(2,2),
     &  tfmhtoti(2,2),tfmvtoti(2,2),
     &  tfmdehtoti(2,2),tfmdevtoti(2,2)
     &  ,rq,cpsi,alpha,spsi,rm,betafun,psi
     &  ,alpha0(2),beta0(2)

      real*8 fillb(29)
      real rnrn(2)
      INTEGER IINSIDE,JINSIDE,INSIDE,iw2(2),ifail
      INTEGER ISOUR,isourold,IOBSV,kfreq,JFREQ,IZAEHL,NZAEHL,I,ICAL,ICOMP
      INTEGER ICSPL,IROI,II,IZTOTS,LSTEP,IR1,IR2
      integer job,jfrob,norad,iwarnwi,kfrob,jliobfr,jliob,jobfr

      INTEGER IC
      INTEGER jpin
      common /souintc/ jpin

      REAL*8 FILLT(NTUPP)
      CHARACTER(5) CTUP(NTUPP)

      DOUBLE PRECISION wth,wta,
     &                H6,H26,A2,A21H6,A3AH26,B,B2,B21H6,B3BH26,DT10
      integer icount,mode,klo,khi,k
+self,if=kmode.
      integer :: kmode=0
+self.
      data ctup /'t','x','y','z','rx','ry','rz','rt','p','expr','expi','roi'
     &  ,'iob','ie','yob','zob','bet1n','om','dt','by2','isou'
     &  ,'spec','reax','imax','reay','imay','reaz','imaz','dom1',
     &  'betx','bety','betz','betxp','betyp','betzp','nx','ny','nz'/

      DATA isourold/0/
      DATA ICAL/0/
      DATA tfm1(1,1),tfm1(1,2),tfm1(2,1),tfm1(2,2)/1.0d0,0.0d0,0.0d0,1.0d0/
c      DATA ZI/(0.0D0,1.0D0)/
c      DATA ZONE/(1.0D0,0.0D0)/
c      DATA IWARNBET1N/0/
+self,if=kmode.
      if (kmode.eq.0.and.user(1).ne.0.0d0) then
        print*,"*** kmode gem uservar(1) ***"
        kmode=1
      endif
+self.
      ypeleco=vyelec/vxelec
      zpeleco=vzelec/vxelec
      zeleco=zelec
      yeleco=yelec

c Transfermatrices

      if (ibunch.ne.0.and.iampli.lt.0.and.isour.ne.isourold) then

        tfmh=tfm1
        tfmv=tfm1
        tfmhc=tfm1
        tfmvc=tfm1
        tfmhtoti=tfm1
        tfmvtoti=tfm1

        tfmdeh=tfm1
        tfmdev=tfm1
        tfmdehc=tfm1
        tfmdevc=tfm1
        tfmdehtoti=tfm1
        tfmdevtoti=tfm1

        x1=sourceao(1,1,isour)
        y1=sourceao(2,1,isour)
        z1=sourceao(3,1,isour)

        x2=sourceeo(1,1,isour)

        alpha0(1)=-wbetasub(3,1)/2.d0
        alpha0(2)=-wbetasub(5,1)/2.d0
        beta0(1)=wbetasub(2,1)
        beta0(2)=wbetasub(4,1)

        if (alpha0(1).gt.0.001) then
          write(6,*)' '
          write(6,*)'*** Warning in souintana_omp: Derivative of hori. beta function'
          write(6,*)'beginnning of the source is greater than 0.001!'
          write(6,*)' '
        endif

        if (alpha0(2).gt.0.001) then
          write(lungfo,*)' '
          write(lungfo,*)'*** Warning in souintana_omp: Derivative of vert. beta function'
          write(lungfo,*)'in source center is greater than 0.001!'
          write(lungfo,*)'source center:',(x1+x2)/2.0d0
          write(lungfo,*)'beta, alpha:',beta0(2),alpha0(2)
          write(lungfo,*)'Maybe it is useful, to set IBL0CUT'
          write(lungfo,*)' '
          write(6,*)' '
          write(6,*)'*** Warning in souintana_omp: Derivative of vert. beta function'
          write(6,*)'in source center is greater than 0.001!'
          write(6,*)'source center:',(x1+x2)/2.0d0
          write(6,*)'beta, alpha:',beta0(2),alpha0(2)
          write(6,*)'Maybe it is useful, to set IBL0CUT'
          write(6,*)' '
        endif

        alpha=-wbetasub(3,3)/2.0d0
        betafun=  wbetasub(2,3)
        psi=   wbetasub(8,3)

        cpsi=cos(psi)
        spsi=sin(psi)
        rq=sqrt(betafun/beta0(1))
        rm=sqrt(betafun*beta0(1))

        tfmhc(1,1) = rq * (cpsi+alpha0(1)*spsi)
        tfmhc(1,2) = rm * spsi
        tfmhc(2,1)=
     &    ((alpha0(1)-alpha)*cpsi - (1.0d0+alpha0(1)*alpha)*spsi) / rm
        tfmhc(2,2)=
     &    (cpsi-alpha*spsi) / rq

        alpha=-wbetasub(5,3)/2.d0
        betafun=  wbetasub(4,3)
        psi=   wbetasub(9,3)

        cpsi=cos(psi)
        spsi=sin(psi)
        rq=sqrt(betafun/beta0(2))
        rm=sqrt(betafun*beta0(2))

        tfmvc(1,1) = rq * (cpsi+alpha0(2)*spsi)
        tfmvc(1,2) = rm * spsi
        tfmvc(2,1)=
     &    ((alpha0(2)-alpha)*cpsi - (1.0d0+alpha0(2)*alpha)*spsi) / rm
        tfmvc(2,2)=
     &    (cpsi-alpha*spsi) / rq

        alpha=-wbetasub(3,3)/2.d0
        betafun=  wbetasub(2,3)
        psi=   wbetasub(8,3)

        cpsi=cos(psi)
        spsi=sin(psi)
        rq=sqrt(betafun/beta0(1))
        rm=sqrt(betafun*beta0(1))

        tfmh(1,1) = rq * (cpsi+alpha0(1)*spsi)
        tfmh(1,2) = rm * spsi
        tfmh(2,1)=
     &    ((alpha0(1)-alpha)*cpsi - (1.0d0+alpha0(1)*alpha)*spsi) / rm
        tfmh(2,2)=
     &    (cpsi-alpha*spsi) / rq

        alpha=-wbetasub(5,3)/2.d0
        betafun=  wbetasub(4,3)
        psi=   wbetasub(9,3)

        cpsi=cos(psi)
        spsi=sin(psi)
        rq=sqrt(betafun/beta0(2))
        rm=sqrt(betafun*beta0(2))

        tfmv(1,1) = rq * (cpsi+alpha0(2)*spsi)
        tfmv(1,2) = rm * spsi
        tfmv(2,1)=
     &    ((alpha0(2)-alpha)*cpsi - (1.0d0+alpha0(2)*alpha)*spsi) / rm
        tfmv(2,2)=
     &    (cpsi-alpha*spsi) / rq

        w22=tfmh

        dum22(1,1)=1.0d0
        dum22(1,2)=0.0d0
        dum22(2,1)=0.0d0
        dum22(2,2)=1.0d0

        call deqinv(2,w22,2,iw2,ifail,2,dum22)

        if (ifail.ne.0) then
          write(6,*)'*** Error in souintana_omp: Matrix invertation failed'
          write(6,*)'Please check horizontal beta functions.'
          write(lungfo,*)'*** Error in souintana_omp: Matrix invertation failed'
          write(lungfo,*)'Please check horizontal beta functions.'
          stop '*** Program WAVE aborted ***'
        endif

        tfmhi=w22

        w22=tfmv

        dum22(1,1)=1.0d0
        dum22(1,2)=0.0d0
        dum22(2,1)=0.0d0
        dum22(2,2)=1.0d0

        call deqinv(2,w22,2,iw2,ifail,2,dum22)

        if (ifail.ne.0) then
          write(6,*)'*** Error in souintana_omp: Matrix invertation failed'
          write(6,*)'Please check vertical beta functions.'
          write(lungfo,*)'*** Error in souintana_omp: Matrix invertation failed'
          write(lungfo,*)'Please check vertical beta functions.'
          stop '*** Program WAVE aborted ***'
        endif

        tfmvi=w22

        tfmdehi=tfmhi
        tfmdevi=tfmvi

        tfmhtoti=tfmhi
        tfmvtoti=tfmvi

        if (iampli.lt.0) then
          do i=1,-iampli/2-1
            call util_matrix_multiplication(2,2,2,tfmhtoti,tfmhi,tfmhtoti,w22)
            call util_matrix_multiplication(2,2,2,tfmvtoti,tfmvi,tfmvtoti,w22)
          enddo
          tfmdehtoti=tfmhtoti
          tfmdevtoti=tfmhtoti
        endif

      endif !isour

      if (inside.ne.-3.or.ielec.eq.1) then
        xobsv=obsv(1,iobsv)
        yobsv=obsv(2,iobsv)
        zobsv=obsv(3,iobsv)
      else
        call grndmm(rnrn,2)  !s. 39
        xobsv=obsv(1,iobsv)
        yobsv=pincen(2)-pinh/2.0d0+rnrn(1)*pinh
        zobsv=pincen(3)-pinw/2.0d0+rnrn(2)*pinw
        if (ipincirc.ne.0) then
          yobsv=1.0d30
          zobsv=1.0d30
          do while (sqrt(yobsv**2+zobsv**2).gt.pinr)
            call grndmm(rnrn,2)  !s. 39
            yobsv=(rnrn(1)-0.5)*2.0d0*pinr
            zobsv=(rnrn(2)-0.5)*2.0d0*pinr
          enddo
          yobsv=pincen(2)+yobsv
          zobsv=pincen(3)+zobsv
        endif
      endif

      IF (jpin.ne.3.and.ielec.eq.1.and.IOBSV.EQ.jobunch
     &    .or.jpin.eq.3.and.ielec.eq.1) THEN

        WRITE(LUNGFO,*)'            SOURCE NUMBER',ISOUR,':'
        WRITE(LUNGFO,*)

        ampzmax(1:nfreq)=0.0d0
        azcos(1:nfreq)=1.0d0
        azsin(1:nfreq)=0.0d0

        X1=xelec

      ENDIF !IF (ielec.eq.1.and.IOBSV.EQ.jobunch) THEN

      jliob=ISOUR+NSOURCE*(IOBSV-1)
c?6.11.      if (jpin.ne.3.or.jpin.eq.3.and.ielec.eq.1) SPECPOW(jliob)=0.0D0

      LSTEP=0
      DGAMSUM=0.0D0

      gamma=egamma
      beta=dsqrt((1.d0-1.d0/gamma)*(1.d0+1.d0/gamma))

      WGANG=WGWINFC/GAMMA

      ICSPL=0

      if (inside.ne.-3) then
        INSIDE=1
        iinside=-1
      endif
      IINSIDE=0
      JINSIDE=0

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS     T=-R0*C1
      T=0.0D0 !WICHTIG HIER WEGEN TENDSOU-T WEITER UNTEN

      IF (ISPECMODE.EQ.1) THEN
        T0=DWT(1)
        T1=T0
        T2=DWT(MCO)
c        XENDSOU=DWX(MCO)    !FINAL X
      ELSE
        T0=SOURCET(1,ISOUR)
        T1=T0
        T2=SOURCET(2,ISOUR)
c        XENDSOU=SOURCEEO(1,1,ISOUR)    !FINAL X
      ENDIF

      TENDSOU=T2-T1

      IF (X1.LT.roi(1,1).OR.XENDSOU.GT.roi(1,NROIA)) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN souintana_omp: X OUTSIDE ROIS ***'
        WRITE(LUNGFO,*)'CHECK NAMELIST $ROIN'
        WRITE(LUNGFO,*)' *** PROGRAM WAVE ABORTED ***'
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN souintana_omp: X OUTSIDE ROIS ***'
        WRITE(6,*)'CHECK NAMELIST $ROIN'
        WRITE(6,*)' *** PROGRAM WAVE ABORTED ***'
        STOP
      ENDIF   !IROI

      X1=xelec
      Y1=yelec
      Z1=zelec

      VX1=vxelec
      VY1=vyelec
      VZ1=vzelec

      BX1=SOURCEAO(1,4,ISOUR)
      BY1=SOURCEAO(2,4,ISOUR)
      BZ1=SOURCEAO(3,4,ISOUR)
      BS1=SQRT(BX1**2+BY1**2+BZ1**2)

      IZTOTS=0

      X0=X1
      X2=X1
      X10=(XENDSOU-X0)/10.1D0

      NZAEHL=NLPOIO
c      DT0=TENDSOU/NZAEHL
      DT0=TENDSOU/dble(NZAEHL-1)

      DT=DT0
      ical=ical+1
      if (ical.gt.1.and.iobsv.gt.nobsvz/2+1) call util_break
+self,if=kzaehl.
      if (ielec.eq.1) then

        KZAEHL=0

        IR1=-1
        DO IROI=1,NROIA
          IF (ROI(IROI).GT.X1.AND.ROI(IROI).LT.XENDSOU.AND.IR1.EQ.-1) THEN
            IR1=IROI
            GOTO 11
          ENDIF
        ENDDO

11      DO IROI=1,NROIA
          IR2=IROI
          IF (ROI(IROI).GT.XENDSOU) THEN
            ROI(IROI)=XENDSOU
            IR2=IR2-1
            IF (ROI(IR2).LT.X1) THEN
              ROI(IR2)=X1
            ENDIF
            GOTO 12
          ENDIF
        ENDDO

12      CONTINUE

        KZAEHL=KZAEHL+NZAEHL*roi(2,IR2)*(XENDSOU-ROI(IR2))/(XENDSOU-X1)

        IF (IR1.NE.-1) THEN

          KZAEHL=KZAEHL+NZAEHL*roi(2,IR1-1)*(ROI(IR1)-X1)/(XENDSOU-X1)

          DO IROI=IR1,IR2-1
            IF (ROI(IROI).GT.X1.OR.ROI(IROI)+1.LT.XENDSOU) THEN
              KZAEHL=KZAEHL+NZAEHL*roi(2,IROI)*(ROI(IROI+1)-ROI(IROI))/(XENDSOU-X1)
            ELSE IF (ROI(IROI).GT.X1.OR.ROI(IROI)+1.LT.XENDSOU) THEN
              KZAEHL=KZAEHL+NZAEHL*roi(2,IROI)*(ROI(IROI+1)-ROI(IROI))/(XENDSOU-X1)
            ENDIF
          ENDDO

        ENDIF

      endif !ibun.eq.nphsp
+self.,if=kzaehl.

      X2=X1
      Y2=Y1
      Z2=Z1

      VX2=VX1
      VY2=VY1
      VZ2=VZ1

      BX2=BX1
      BY2=BY1
      BZ2=BZ1
      BS=BS1

C--- LOOP OVER STEPS

      IROI=1
      DO I=1,NROIA
        IF (X1.GE.roi(1,I)) THEN
          IROI=I
        ENDIF !(X1.GE.roi(1,I))
      ENDDO   !IROI

      DT=DT0/roi(2,IROI)

      NZAEHL=MAX(5,NINT((TENDSOU-T)/DT))
      DT=(TENDSOU-T)/NZAEHL

      TENDSOU1=TENDSOU-DT
      DT2=DT/2.D0

C- CHECK STEPS SIZE

      IF (IWARNROI(IROI,ISOUR).EQ.0) THEN
        IF (DT-DTIM00.ge.dtim00*0.001) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '*** WARNING IN souintana_omp, SOURCE, ROI:',ISOUR,IROI
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
          WRITE(LUNGFO,*)'SIZE FOR TRAJECTORY!'
          WRITE(LUNGFO,*)
          write(lungfo,*)'Step size for source point:',dt*clight1
          write(lungfo,*)'Step size for trajectory:',dtim00*clight1
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
          WRITE(6,*)
          WRITE(6,*)
     &      '*** WARNING IN souintana_omp, SOURCE, ROI:',ISOUR,IROI
          WRITE(6,*)
          WRITE(6,*)'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
          WRITE(6,*)'SIZE FOR TRAJECTORY!'
          WRITE(6,*)
          write(6,*)'Step size for source point:',dt*clight1
          write(6,*)'Step size for trajectory:',dtim00*clight1
          WRITE(6,*)
          WRITE(6,*)
     &      'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
          WRITE(6,*)
          IWARNROI(IROI,ISOUR)=1
        ENDIF !DT
      ENDIF !IWARNROI

      IROI=IROI+1

      IZAEHL=0 !LOOP COUNTER for each track

      nutrack=ielec
      nustep=izaehl

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS     T=-R0*C1

      T=-DT
      TS=-DT

c20.11.2023
c20.11.2023      R0=XOBSV-SOURCEAO(1,1,ISOUR)
      R0=obsv(1,icbrill)-SOURCEAO(1,1,ISOUR)
      h2=((yobsv-y1)**2+(zobsv-z1)**2)/(xobsv-x1)**2
      if (h2.lt.0.01) then
        r=abs(xobsv-x1)*(1.0d0+(((((-0.0205078125D0*h2+0.02734375D0)*h2
     &    -0.0390625D0)*h2+0.0625D0)*h2-0.125D0)*h2+0.5D0)*h2)
      else
        r=sqrt((xobsv-x1)**2+((yobsv-y1)**2+(zobsv-z1)**2))
      endif
c      phase=(obsv(1,icbrill)-x1)*c1
c20.11.2023
      PHASE=(r-r0)*c1 ! needed for phase of field amplitude
      t0ph=phase

      EXPOM1=ZONE
      DEXPOMPH1=ZONE

      IF (ifreq2p.EQ.0) THEN
        DO JFREQ=1,NFREQ
          EXPOM2P0(1,JFREQ)=ZONE
        ENDDO
      ENDIF

      yp2zp2i=0.0D0
      f=0.0d0

      powpow=0.0d0

1000  IZAEHL=IZAEHL+1
      !all util_break
      nustep=izaehl
c      IIZAEHL=IIZAEHL+1 !total step counter

      IF (IROI.LE.NROIA) THEN

        IF (X2.GE.roi(1,IROI)) THEN

          DT=DT0/roi(2,IROI)
          NZAEHL=NINT((TENDSOU-T)/DT)

          IF (ISPECMODE.EQ.1) THEN
            DT=(TENDSOU-T)/(NZAEHL-1)
          ELSE
            DT=(TENDSOU-T)/NZAEHL
          ENDIF

          TENDSOU1=TENDSOU-DT

          DT2=DT/2.D0

          IF (IWARNROI(IROI,ISOUR).EQ.0) THEN

            IF (DT-DTIM00.ge.dtim00*0.001) THEN

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          '*** WARNING IN souintana_omp, SOURCE, ROI:',ISOUR,IROI
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
              WRITE(LUNGFO,*)'SIZE FOR TRAJECTORY!'
              WRITE(LUNGFO,*)
              write(lungfo,*)'Step size for source point:',dt*clight1
              write(lungfo,*)'Step size for trajectory:',dtim00*clight1
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
              WRITE(6,*)
              WRITE(6,*)
     &          '*** WARNING IN souintana_omp, SOURCE, ROI:',ISOUR,IROI
              WRITE(6,*)
              WRITE(6,*)'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
              WRITE(6,*)'SIZE FOR TRAJECTORY!'
              WRITE(6,*)
              write(6,*)'Step size for source point:',dt*clight1
              write(6,*)'Step size for trajectory:',dtim00*clight1
              WRITE(6,*)
              WRITE(6,*)
     &          'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
              WRITE(6,*)

              IWARNROI(IROI,ISOUR)=1

            ENDIF !DT

          ENDIF !IWARNROI

          IROI=IROI+1

        ENDIF   !X2

      ENDIF   !IROI

      if (ibun.eq.1.and.isub.eq.1) IPOIROI(IROI)=IPOIROI(IROI)+1

      T=T+DT

      IF (LSTEP.EQ.1) THEN

        IF (X2.LE.XENDSOU) THEN

          DT=(MIN(XENDSOU,XIEND)-X2)/VX2
          DT2=DT/2.0D0

        ELSE

          TS=TS-DT
          T=T-DT

          DT=(MIN(XENDSOU,XIEND)-X1)/VX2
          DT2=DT/2.0D0

          X2=X1
          Y2=Y1
          Z2=Z1

          VX2=VX1
          VY2=VY1
          VZ2=VZ1

          BX2=BX1
          BY2=BY1
          BZ2=BZ1
          BS=BS1

        ENDIF !X2

      ENDIF !LSTEP

      X1=X2
      Y1=Y2
      Z1=Z2

      VX1=VX2
      VY1=VY2
      VZ1=VZ2

      BX1=BX2
      BY1=BY2
      BZ1=BZ2
      BS1=BS

      IF (ISPECMODE.NE.1) THEN

C GET MAGNETIC FIELD {

        X2B=X1+VX1*DT2
        Y2B=Y1+VY1*DT2
        Z2B=Z1+VZ1*DT2
        norad=0
        if (ibmasksp.ne.0) then
          ibmasksp=-abs(ibmasksp)
          call mybfeld(x2b,y2b,z2b,bx2,by2,bz2,ax2d,ay2d,az2d)
          if ((bx2**2+by2**2+bz2**2).ne.0.0d0) then
            norad=1
          endif
          ibmasksp=-ibmasksp
        endif

        X2=WSOU(1,1,IZAEHL)
        Y2=WSOU(2,1,IZAEHL)
        Z2=WSOU(3,1,IZAEHL)

        VX2=WSOU(1,2,IZAEHL)
        VY2=WSOU(2,2,IZAEHL)
        VZ2=WSOU(3,2,IZAEHL)

        VXP=WSOU(1,3,IZAEHL)
        VYP=WSOU(2,3,IZAEHL)
        VZP=WSOU(3,3,IZAEHL)

        DT=   wsou(1,4,IZAEHL)
        BETA= wsou(2,4,IZAEHL)
        GAMMA=wsou(3,4,IZAEHL)

        bX2=WSOU(1,5,IZAEHL)
        bY2=WSOU(2,5,IZAEHL)
        bZ2=WSOU(3,5,IZAEHL)

        BX=VX2*C1
        BY=VY2*C1
        BZ=VZ2*C1

        BPX=VXP*C1
        BPY=VYP*C1
        BPZ=VZP*C1

C MOVE ONE STEP }

      ELSE  !ISPECMODE

c{wave_track_inter, inline

c        CALL WAVE_TRACK_INTER(TS,X2,Y2,Z2,VX2,VY2,VZ2,VXP,VYP,VZP,BS,ICSPL,
c     &    GAMMA)

        IF (ICOUNT.EQ.0) THEN
          MODE=0
          DT=(DWT(2)-DWT(1))
          DT10=DT*1.D-10
          DO I=2,MCO
         IF (ABS(DWT(I)-DWT(I-1)-DT).GT.DT10) THEN
           MODE=1
           GOTO 19
                ENDIF
          ENDDO
19        KLO=1
          KHI=MCO
          ICOUNT=1
        ENDIF

      IF (MODE.EQ.1) THEN

        IF (KLO.GE.MCO.OR.KLO.LT.1.OR.KHI.GT.MCO.OR.KHI.LT.2) THEN
          KLO=1
          KHI=MCO
        ENDIF

          IF (T.GE.DWT(KLO).AND.T.LT.DWT(KLO+1)) THEN
            KHI=KLO+1
            GOTO 2
          ELSE IF (T.LT.DWT(KLO).OR.T.GE.DWT(KHI)) THEN
            KLO=1
            KHI=MCO
          ENDIF

          K=1
111       K=K*2
          KHI=KLO+K
          IF (KHI.GE.MCO) GOTO 122
          IF (T.GT.DWT(KHI)) THEN
            KLO=KHI
            GOTO 111
          ELSE
            GOTO 1
          ENDIF

122       KHI=MCO

1         IF (KHI-KLO.GT.1) THEN
            K=(KHI+KLO)/2
            IF(DWT(K).GT.T)THEN
              KHI=K
            ELSE
              KLO=K
            ENDIF
            GOTO 1
          ENDIF

        ELSE !MODE

          IF (T.GE.DWT(1).AND.T.LT.DWT(MCO)) THEN
            KLO=T/DT+1
            KHI=KLO+1
            IF (KHI.GT.MCO) THEN
              KHI=MCO
              KLO=KHI-1
            ENDIF
          ELSE IF (T.LT.DWT(1)) THEN
            KLO=1
            KHI=2
          ELSE IF (T.GE.DWT(MCO)) THEN
            KLO=MCO-1
            KHI=MCO
          ENDIF

        ENDIF !MODE

2       wtH=DWT(KHI)-DWT(KLO)

        IF (wtH.EQ.0.) THEN
          WRITE(6,*) '*** ERROR IN WAVE_TRACK_INTER: BAD INPUT ***'
          STOP
        ENDIF

        H6=wtH/6.D0
        H26=H6*wtH
        wta=(DWT(KHI)-T)/wtH
        A2=wta*wta
        A3AH26=(A2-1.D0)*wta*H26
        A21H6=(-3.D0*A2+1.D0)*H6
        B=(T-DWT(KLO))/wtH
        B2=B*B
        B21H6=(3.D0*B2-1.D0)*H6
        B3BH26=(B2-1.D0)*B*H26

        X2=wta*DWX(KLO)+B*DWX(KHI)+A3AH26*DWX2P(KLO)+B3BH26*DWX2P(KHI)
        VX2=(-DWX(KLO)+DWX(KHI))/wtH+A21H6*DWX2P(KLO)+B21H6*DWX2P(KHI)
        VXP=wta*DWX2P(KLO)+B*DWX2P(KHI)

        Y2=wta*DWY(KLO)+B*DWY(KHI)+A3AH26*DWY2P(KLO)+B3BH26*DWY2P(KHI)
        VY2=(-DWY(KLO)+DWY(KHI))/wtH+A21H6*DWY2P(KLO)+B21H6*DWY2P(KHI)
        VYP=wta*DWY2P(KLO)+B*DWY2P(KHI)

        Z2=wta*DWZ(KLO)+B*DWZ(KHI)+A3AH26*DWZ2P(KLO)+B3BH26*DWZ2P(KHI)
        VZ2=(-DWZ(KLO)+DWZ(KHI))/wtH+A21H6*DWZ2P(KLO)+B21H6*DWZ2P(KHI)
        VZP=wta*DWZ2P(KLO)+B*DWZ2P(KHI)

        BS=wta*DWB(KLO)+B*DWB(KHI)+A3AH26*DWB2P(KLO)+B3BH26*DWB2P(KHI)

        GAMMA=(TRAGAM(KLO)+TRAGAM(KHI))/2.0D0

c}wave_track_inter, inline
        norad=0
        if (ibmasksp.ne.0) then
          ibmasksp=-abs(ibmasksp)
          call mybfeld(x2b,y2b,z2b,bx2,by2,bz2,ax2d,ay2d,az2d)
          if ((bx2**2+by2**2+bz2**2).ne.0.0d0) then
            norad=1
          endif
          ibmasksp=-ibmasksp
        endif

        IF (IENELOSS.NE.0) THEN
          BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
        ENDIF

        BSQ=BS*BS
        BY2=BSQ

        BX=VX2*C1
        BY=VY2*C1
        BZ=VZ2*C1

        BPX=VXP*C1
        BPY=VYP*C1
        BPZ=VZP*C1

      ENDIF !ISPECMODE

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION {

C REAL PART OF INTEGRAND {

      RX=XOBSV-X2
      RY=YOBSV-Y2
      RZ=ZOBSV-Z2

      R=SQRT(RX*RX+RY*RY+RZ*RZ)

      R1=1.0D0/R
      ZICR1=ZIC*R1

      RNX=RX*R1
      RNY=RY*R1
      RNZ=RZ*R1

C--- THE DISTANCE R IS INTRODUCED HERE EXPLICITLY (S. PROGRAM OF CHAOEN WANG

      BET1N=(1.0D0-BX*RNX)-BY*RNY-BZ*RNZ

c 20090928{
      br2=by**2+bz**2
      rnr2=rny**2+rnz**2
      b3=beta**3
      br4=br2**2
      rnr4=rnr2**2

      if(br2.lt.1.0d-4.and.rnr2.lt.1.0d-4) then
        bet1n=
     &    1.0d0/(1.0+beta)/gamma**2
     &    +beta*(rnr2/2.0d0
     &    +rnr4/8.0d0)
     &    +(br2/2.0d0
     &    -br2*rnr2/4.0d0
     &    -br2*rnr4/16.0d0)/beta
     &    +b3*br4*(1.0d0/8.0d0
     &    -rnr2/16.0d0
     &    -rnr4/64.0d0)
     &    -by*rny
     &    -bz*rnz
      endif
c }20090928

      OPANG=BX/BETA*RNX+BY/BETA*RNY+BZ/BETA*RNZ

      IF (ABS(OPANG).LE.1.0D0) THEN
        OPANG=ACOS(OPANG)
      ELSE IF (OPANG.GT.1.0D0) THEN
        OPANG=0.0D0
      ELSE
        OPANG=-PI1
      ENDIF

      DUM11=1.D0/BET1N
      DOM1=1.D0/(R*BET1N*BET1N)

      IF (IZAEHL.EQ.1) THEN
        BET1NO=BET1N
      ELSE IF (iundulator.eq.0.and.(BET1N-BET1NO)/BET1N.GT.0.05.AND.IWARNBET1N.EQ.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN souintana_omp  ***'
        WRITE(LUNGFO,*)'DISCONTINUITY IN INTEGRAND'
        WRITE(LUNGFO,*)
     &    'Check results carefully, change BMOVECUT, MYINUM, NLPOI etc.'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'IELEC,ISTEP,X,BET1N,BET1NO:',IELEC,IZAEHL,SNGL(X1),SNGL(BET1N),SNGL(BET1NO)
        WRITE(LUNGFO,*)'FURTHER WARNINGS ARE SUPPRESSED!'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN souintana_omp  ***'
        WRITE(6,*)'DISCONTINUITY IN INTEGRAND'
        WRITE(6,*)
     &    'Check results carefully, change BMOVECUT, MYINUM, NLPOI etc.'
        WRITE(6,*)
        WRITE(6,*)'IELEC,ISTEP,X,BET1N,BET1NO:',IELEC,IZAEHL,SNGL(X1),SNGL(BET1N),SNGL(BET1NO)
        WRITE(6,*)
        WRITE(6,*)'FURTHER WARNINGS ARE SUPPRESSED!'
        WRITE(6,*)
        IWARNBET1N=1
      ENDIF

      BET1NO=BET1N

      RNBX=RNX-BX
      RNBY=RNY-BY
      RNBZ=RNZ-BZ

      PX=(RNBY*BPZ-RNBZ*BPY)
      PY=(RNBZ*BPX-RNBX*BPZ)
      PZ=(RNBX*BPY-RNBY*BPX)

      IF (IVELOFIELD.EQ.0) THEN !2 WEGEN POWER
        DOM2=C*DOM1*R1/GAMMA**2
        RARG(1)=(RNY*PZ-RNZ*PY)*DOM1+(RNX-BX)*DOM2
        RARG(2)=(RNZ*PX-RNX*PZ)*DOM1+(RNY-BY)*DOM2
        RARG(3)=(RNX*PY-RNY*PX)*DOM1+(RNZ-BZ)*DOM2
      ELSE IF (IVELOFIELD.EQ.1) THEN
        RARG(1)=(RNY*PZ-RNZ*PY)*DOM1
        RARG(2)=(RNZ*PX-RNX*PZ)*DOM1
        RARG(3)=(RNX*PY-RNY*PX)*DOM1
      ELSE IF (IVELOFIELD.LT.0) THEN
        DOM2=C*DOM1*R1/GAMMA**2
        RARG(1)=(RNX-BX)*DOM2
        RARG(2)=(RNY-BY)*DOM2
        RARG(3)=(RNZ-BZ)*DOM2
      ELSE  !IVELOFIELD
        WRITE(6,*)
     &    '*** ERROR IN souintana_omp: BAD VALUE OF IVELOFIELD  ***'
        WRITE(6,*) '*** PROGRAM WAVE ABORTED  ***'
        STOP
      ENDIF !IVELOFIELD

+self,if=kmode.
      if (kmode.eq.1) then
        rn_cross_beta(1)=rny*bz-rnz*by
        rn_cross_beta(2)=rnz*bx-rnx*bz
        rn_cross_beta(3)=rnx*by-rny*bx
c        rn_cross_beta(1)=0.0d0
c        rn_cross_beta(2)=-bz
c        rn_cross_beta(3)=by
        call util_vcross([rnx,rny,rnz],rn_cross_beta,rn_cross_rn_cross_beta)
        rarg(1:3)=rn_cross_rn_cross_beta(1:3)*r1*dt
c        rarg(1)=0.0d0
c        rarg(2)=-by*r1*dt
c        rarg(3)=-bz*r1*dt
c        rarg(1)=0.0d0
c        rarg(2)=-by/(xobsv-x2)*dt
c        rarg(3)=-bz/(xobsv-x2)*dt
c        rarg(2)=-by/(xobsv-(wsou(1,1,1)+clight1*t))*dt
c        rarg(3)=-bz/(xobsv-(wsou(1,1,1)+clight1*t))*dt
      endif

+self.
      IF (IINSIDE.EQ.0.AND.OPANG.LE.WGANG) THEN
        if (ibun.eq.1.and.isub.eq.neinbunch) then
          DPHSOUR(1,1)=BET1N*DT*FREQ(1)/HBAREV1
          DPHSOUR(1,2)=BET1N*DT*FREQ(NFREQ)/HBAREV1
        endif
        IINSIDE=1
        INSIDE=1
        JINSIDE=JINSIDE+1
        IF (JINSIDE.GT.1.and.ielec.eq.1) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN souintana_omp  ***'
          WRITE(LUNGFO,*)'*** SOURCE:',ISOUR
          WRITE(LUNGFO,*)'STRANGE SOURCE, CONTAINS SEVERAL SOURCES'
          WRITE(LUNGFO,*)'SOURCE AND OBSERVATION POINT:'
          WRITE(LUNGFO,*)ISOUR,XOBSV,YOBSV,ZOBSV
          WRITE(LUNGFO,*)
     &      'RESULTS OF SPECTRUM CALCULATIONS MAY BE UNRELIABLE'
          WRITE(LUNGFO,*)'*** CHECK COLLIMATOR, PINHOLE, WGWINFC ... ***'
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN souintana_omp  ***'
          WRITE(6,*)'*** SOURCE:',ISOUR
          WRITE(6,*)'*** STRANGE SOURCE, CONTAINS SEVERAL SOURCES'
          WRITE(6,*)'SOURCE AND OBSERVATION POINT:'
          WRITE(6,*)ISOUR,XOBSV,YOBSV,ZOBSV
          WRITE(6,*)'*** CHECK COLLIMATOR, PINHOLE, WGWINFC ... ***'
          WRITE(6,*)'WARNING OF SPECTRUM CALCULATIONS ARE UNRELIABLE'
          JINSIDE=JINSIDE-1   !SUPRESS LOTS OF WARNINGS
        ENDIF  !JINSIDE
      ELSE IF (IINSIDE.EQ.1.AND.OPANG.GT.WGANG) THEN
        IINSIDE=0
      ENDIF   !IINSIDE

      IF (IINSIDE.NE.0) THEN

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS      RARG(4)=T+R*C1

        DPHASE=BET1N*DT

        RARG(4)=PHASE
        RARG(5)=(RARG(1)*RARG(1)+RARG(2)*RARG(2)+RARG(3)*RARG(3))*DUM11/
     &    (nphsp*neinbunch)

        if (norad.ne.0) rarg=0.0d0

C REAL PART OF INTEGRAND }

C COMPLEX PART OF INTEGRAND {

C    ASSUMES FREQ(I+1)=2*FREQ(I)   FOR ifreq2p=2
C    OR FREQ(I+1)=FREQ(I)+DELTA    FOR ifreq2p>2

C--- LOOP OVER ALL FREQUENCES

        kfreq=1

        if (nelec.gt.1) then
          dexpbunch=phexp(kfreq)
        else
          dexpbunch=(1.0d0,0.0d0)
        endif

        kfrob=kfreq+NFREQ*(IOBSV-1)

        OM=FREQ(kfreq)/HBAREV1
        ZIOM=ZI*OM

        if (izaehl.eq.1) then
          EXPOM1=CDEXP(DCMPLX(0.D0,phase*OM))
        endif

        EXPOM=EXPOM1
        DEXPOMPH1=EXP(ZIOM*DPHASE)
        DEXPOMPH=DEXPOMPH1

        IF(ifreq2p.GT.2) THEN
          DEXPOM=EXP(ZIDOM*PHASE)
          DDEXPOMPH=EXP(ZIDOM*DPHASE)
        ELSE IF(ifreq2p.EQ.0) THEN
          EXPOM2P0(2,kfreq)=EXP(ZIOM*DPHASE)
          EXPOM=EXPOM2P0(1,kfreq)
        ENDIF  !ifreq2p

        !all util_break
        !expom=exp(zidom*)

        IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN

          IF (ECMAXS.LT.BS) ECMAXS=BS

          pow=rarg(5)*dt
          powpow=powpow+pow
          SPECPOW(jliob)=SPECPOW(jliob)+pow

          DO ICOMP=1,3
            daff(icomp)=
     &        RARG(ICOMP)/BET1N/OM*EXPOM*(ZONE-DEXPOMPH)*DEXPbunch/sqnphsp
+self,if=kmode.
            if (kmode.eq.1) then
              daff(icomp)=
     &          om*RARG(ICOMP)*cdexp(zi*om*( t0ph+t - (rnx*x2+rny*y2+rnz*z2)*c1 ) )
            endif
+self.
            affe(icomp,kfrob)=affe(icomp,kfrob)+daff(icomp)
c            if (iobsv.eq.icbrill.and.kmode.eq.1.and.icomp.eq.3) then
c              print*,izaehl,t,affe(3,kfrob)*conjg(affe(3,kfrob))
c            endif
          ENDDO   !ICOMP

c          baff(1)=conjg(rny*daff(3)-rnz*daff(2))
c          baff(2)=conjg(rnz*daff(1)-rnx*daff(3))
c          baff(3)=conjg(rnx*daff(2)-rny*daff(1))

          baff(1)=(rny*daff(3)-rnz*daff(2))
          baff(2)=(rnz*daff(1)-rnx*daff(3))
          baff(3)=(rnx*daff(2)-rny*daff(1))

          !baff(1)=dcmplx(rny*dreal(daff(3))-rnz*dreal(daff(2)),0.0d0)
          !baff(2)=dcmplx(rnz*dreal(daff(1))-rny*dreal(daff(3)),0.0d0)
          !baff(3)=dcmplx(rnx*dreal(daff(2))-rnx*dreal(daff(1)),0.0d0)

          affe(4:6,kfrob)=affe(4:6,kfrob)+baff(1:3)/clight1

        ENDIF  !XIANF

        IF (ibun.eq.1.and.isub.eq.neinbunch) THEN
          IF (IWFILINT.NE.0) THEN
            IF (MOD(IZAEHL,JWFILINT).EQ.0) THEN
              IF (IWFILINT.LT.0) THEN
                FILLT(1)=T+DT
                FILLT(2)=X2
                FILLT(3)=Y2
                FILLT(4)=Z2
                FILLT(5)=RARG(1)
                FILLT(6)=RARG(2)
                FILLT(7)=RARG(3)
                FILLT(8)=RARG(4)
                FILLT(9)=RARG(5)
                FILLT(10)=DREAL(EXPOM*DEXPBUNCH)
                FILLT(11)=DIMAG(EXPOM*DEXPBUNCH)
                FILLT(12)=IROI-1
                FILLT(13)=IOBSV
                FILLT(14)=kfreq
                FILLT(15)=YOBSV
                FILLT(16)=ZOBSV
                FILLT(17)=BET1N
                FILLT(18)=OM
                FILLT(19)=DT
                FILLT(20)=BY2
                FILLT(21)=ISOUR
                FILLT(22)=
     &            (
     &            DREAL(affe(1,kfrob))*DREAL(affe(1,kfrob))
     &            +DIMAG(affe(1,kfrob))*DIMAG(affe(1,kfrob))
     &            +DREAL(affe(2,kfrob))*DREAL(affe(2,kfrob))
     &            +DIMAG(affe(2,kfrob))*DIMAG(affe(2,kfrob))
     &            +DREAL(affe(3,kfrob))*DREAL(affe(3,kfrob))
     &            +DIMAG(affe(3,kfrob))*DIMAG(affe(3,kfrob))
     &            )*specnor*bunnor
                FILLT(23)=DREAL(affe(1,kfrob))*specnor*bunnor
                FILLT(24)=DIMAG(affe(1,kfrob))*specnor*bunnor
                FILLT(25)=DREAL(affe(2,kfrob))*specnor*bunnor
                FILLT(26)=DIMAG(affe(2,kfrob))*specnor*bunnor
                FILLT(27)=DREAL(affe(3,kfrob))*specnor*bunnor
                FILLT(28)=DIMAG(affe(3,kfrob))*specnor*bunnor
                FILLT(29)=DOM1
                FILLT(30)=bx
                FILLT(31)=by
                FILLT(32)=bz
                FILLT(33)=bpx
                FILLT(34)=bpy
                FILLT(35)=bpz
c                ef(1:3)=real(affe(1:3,kfrob))
c                bf(1:3)=real(affe(4:6,kfrob))
c                rnx=ef(2)*bf(3)-ef(3)*bf(2)
c                rny=ef(3)*bf(1)-ef(1)*bf(3)
c                rnz=ef(1)*bf(2)-ef(2)*bf(1)
                rnx=real(
     &            affe(2,kfrob)*conjg(affe(6,kfrob))-
     &            affe(3,kfrob)*conjg(affe(5,kfrob)))
                rny=real(
     &            affe(3,kfrob)*conjg(affe(4,kfrob))-
     &            affe(1,kfrob)*conjg(affe(6,kfrob)))
                rnz=real(
     &            affe(1,kfrob)*conjg(affe(5,kfrob))-
     &            affe(2,kfrob)*conjg(affe(4,kfrob)))
                rn=sqrt(rnx**2+rny**2+rnz**2)
                FILLT(36)=rnx/rn
                FILLT(37)=rny/rn
                FILLT(38)=rnz/rn

                CALL hfm(NIDSOURCE,FILLT)

              ELSE IF (ISOUR.EQ.IWFILINT.AND.IOBSV.EQ.1) THEN

                WRITE(LUNINT,*) IZAEHL,kfreq,X2
                WRITE(LUNINT,*) (RARG(1),IC=1,3)
                WRITE(LUNINT,*) RARG(4)*OM,RARG(5)
                WRITE(LUNINT,*)REAL(EXPOM),IMAG(EXPOM)
                WRITE(LUNINT,*)RARG(1)*REAL(EXPOM*DEXPBUNCH),RARG(1)*IMAG(EXPOM*DEXPBUNCH)
                WRITE(LUNINT,*)RARG(2)*REAL(EXPOM*DEXPBUNCH),RARG(2)*IMAG(EXPOM*DEXPBUNCH)
                WRITE(LUNINT,*)RARG(3)*REAL(EXPOM*DEXPBUNCH),RARG(3)*IMAG(EXPOM*DEXPBUNCH)

              ENDIF !IWFILINT.LT.0
            ENDIF !JFILINT
          ENDIF !IWFILINT.NE.0
        ENDIF !ibun

        DO kfreq=2,NFREQ

          kfrob=kfreq+NFREQ*(IOBSV-1)

          IF    (ifreq2p.GT.2) THEN
            OM=OM+DOM
            EXPOM=EXPOM*DEXPOM
            DEXPOMPH=DEXPOMPH*DDEXPOMPH
          ELSE IF(ifreq2p.EQ.2) THEN
            OM=OM*2.0D0
            EXPOM=EXPOM*EXPOM
            DEXPOMPH=DEXPOMPH*DEXPOMPH
          ELSE IF(ifreq2p.EQ.0) THEN
            OM=FREQ(kfreq)/HBAREV1
            ZIOM=ZI*OM
            EXPOM2P0(2,kfreq)=EXP(ZIOM*DPHASE)
            EXPOM=EXPOM2P0(1,kfreq)
            DEXPOMPH=EXPOM2P0(2,kfreq)
          ELSE
            OM=FREQ(kfreq)/HBAREV1
            ZIOM=ZI*OM
            DEXPOMPH=EXP(ZIOM*DPHASE)
          ENDIF

          if (nelec.gt.1) then
            dexpbunch=phexp(kfreq)
          endif

          IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN

            EXPOMV2=1.0D0/BET1N/OM*EXPOM*(ZONE-DEXPOMPH)

            DO ICOMP=1,3
              daff(icomp)=RARG(ICOMP)*EXPOMV2*DEXPbunch/sqnphsp
+self,if=kmode.
              if (kmode.eq.1) then
                daff(icomp)=
     &            om*RARG(ICOMP)*cdexp(zi*om*( t0ph+t - (rnx*x2+rny*y2+rnz*z2)*c1 ) )
              endif
+self.
              affe(icomp,kfrob)=affe(icomp,kfrob)+daff(icomp)
            ENDDO

c            baff(1)=conjg(rny*daff(3)-rnz*daff(2))
c            baff(2)=conjg(rnz*daff(1)-rnx*daff(3))
c            baff(3)=conjg(rnx*daff(2)-rny*daff(1))

            baff(1)=(rny*daff(3)-rnz*daff(2))
            baff(2)=(rnz*daff(1)-rnx*daff(3))
            baff(3)=(rnx*daff(2)-rny*daff(1))

          !baff(1)=dcmplx(rny*dreal(daff(3))-rnz*dreal(daff(2)),0.0d0)
          !baff(2)=dcmplx(rnz*dreal(daff(1))-rny*dreal(daff(3)),0.0d0)
          !baff(3)=dcmplx(rnx*dreal(daff(2))-rnx*dreal(daff(1)),0.0d0)

            affe(4:6,kfrob)=affe(4:6,kfrob)+baff(1:3)/clight1

          ENDIF !XIEND

          IF (ibun.eq.1.and.isub.eq.neinbunch) then
            IF (IWFILINT.NE.0) THEN
              IF (MOD(IZAEHL,JWFILINT).EQ.0) THEN
                IF (IWFILINT.LT.0) THEN
                  FILLT(1)=T+DT
                  FILLT(2)=X2
                  FILLT(3)=Y2
                  FILLT(4)=Z2
                  FILLT(5)=RARG(1)
                  FILLT(6)=RARG(2)
                  FILLT(7)=RARG(3)
                  FILLT(8)=RARG(4)
                  FILLT(9)=RARG(5)
                  FILLT(10)=DREAL(EXPOM*DEXPBUNCH)
                  FILLT(11)=DIMAG(EXPOM*DEXPBUNCH)
                  FILLT(12)=IROI-1
                  FILLT(13)=IOBSV
                  FILLT(14)=kfreq
                  FILLT(15)=YOBSV
                  FILLT(16)=ZOBSV
                  FILLT(17)=BET1N
                  FILLT(18)=OM
                  FILLT(19)=DT
                  FILLT(20)=BY2
                  FILLT(21)=ISOUR
                  FILLT(22)=
     &              (
     &              DREAL(affe(1,kfrob))*DREAL(affe(1,kfrob))
     &              +DIMAG(affe(1,kfrob))*DIMAG(affe(1,kfrob))
     &              +DREAL(affe(2,kfrob))*DREAL(affe(2,kfrob))
     &              +DIMAG(affe(2,kfrob))*DIMAG(affe(2,kfrob))
     &              +DREAL(affe(3,kfrob))*DREAL(affe(3,kfrob))
     &              +DIMAG(affe(3,kfrob))*DIMAG(affe(3,kfrob))
     &              )*specnor*bunnor
                  FILLT(23)=DREAL(affe(1,kfrob))*specnor*bunnor
                  FILLT(24)=DIMAG(affe(1,kfrob))*specnor*bunnor
                  FILLT(25)=DREAL(affe(2,kfrob))*specnor*bunnor
                  FILLT(26)=DIMAG(affe(2,kfrob))*specnor*bunnor
                  FILLT(27)=DREAL(affe(3,kfrob))*specnor*bunnor
                  FILLT(28)=DIMAG(affe(3,kfrob))*specnor*bunnor
                  FILLT(29)=DOM1
                  FILLT(30)=bx
                  FILLT(31)=by
                  FILLT(32)=bz
                  FILLT(33)=bpx
                  FILLT(34)=bpy
                  FILLT(35)=bpz
c                ef(1:3)=real(affe(1:3,kfrob))
c                bf(1:3)=real(affe(4:6,kfrob))
c                rnx=ef(2)*bf(3)-ef(3)*bf(2)
c                rny=ef(3)*bf(1)-ef(1)*bf(3)
c                rnz=ef(1)*bf(2)-ef(2)*bf(1)
                  rnx=real(
     &              affe(2,kfrob)*conjg(affe(6,kfrob))-
     &              affe(3,kfrob)*conjg(affe(5,kfrob)))
                  rny=real(
     &              affe(3,kfrob)*conjg(affe(4,kfrob))-
     &              affe(1,kfrob)*conjg(affe(6,kfrob)))
                  rnz=real(
     &              affe(1,kfrob)*conjg(affe(5,kfrob))-
     &              affe(2,kfrob)*conjg(affe(4,kfrob)))
                  rn=sqrt(rnx**2+rny**2+rnz**2)
                  FILLT(36)=rnx/rn
                  FILLT(37)=rny/rn
                  FILLT(38)=rnz/rn

                  CALL hfm(NIDSOURCE,FILLT)

                ELSE IF (ISOUR.EQ.IWFILINT.AND.IOBSV.EQ.1) THEN

                  WRITE(LUNINT,*) IZAEHL,kfreq,X2
                  WRITE(LUNINT,*) (RARG(1),IC=1,3)
                  WRITE(LUNINT,*) RARG(4)*OM,RARG(5)
                  WRITE(LUNINT,*)REAL(EXPOM*DEXPBUNCH),IMAG(EXPOM*DEXPBUNCH)
                  WRITE(LUNINT,*)RARG(1)*REAL(EXPOM*DEXPBUNCH),RARG(1)*IMAG(EXPOM*DEXPBUNCH)
                  WRITE(LUNINT,*)RARG(2)*REAL(EXPOM*DEXPBUNCH),RARG(2)*IMAG(EXPOM*DEXPBUNCH)
                  WRITE(LUNINT,*)RARG(3)*REAL(EXPOM*DEXPBUNCH),RARG(3)*IMAG(EXPOM*DEXPBUNCH)

                ENDIF !IWFILINT.LT.0
              ENDIF !JWFILINT
            ENDIF !IWFILINT.NE.0
          ENDIF !ibun

        ENDDO   !LOOP OVER ALL FREQUENCES

      ENDIF   !IINSIDE

C COMPLEX PART OF INTEGRAND }

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION }

      PHASE=PHASE+DPHASE
      EXPOM1=EXPOM1*DEXPOMPH1

      IF(ifreq2p.EQ.0) THEN

        DO JFREQ=1,NFREQ
          OM=FREQ(JFREQ)/HBAREV1
          ZIOM=ZI*OM
          EXPOM2P0(1,JFREQ)=EXPOM2P0(1,JFREQ)*EXPOM2P0(2,JFREQ)
        ENDDO
      ENDIF

      TS=TS+DT

C--- END OF LOOP OVER TIME STEPS

c      yp2zp2ia=yp2zp2ia
c     &  +((vy1/vx1)**2+(vy2/vx2)**2+(vz1/vx1)**2+(vz2/vx2)**2)*beta*clight1*dt2

      f(3)=((vy2/vx2)**2+(vz2/vx2)**2)
      fdt(3)=dt

      if (lstep.eq.1) then
        yp(1)=(f(2)-f(1))/fdt(2)
        yp(3)=(f(3)-f(2))/fdt(3)
        yp(2)=(yp(3)+yp(1))/2.0d0
        ypp=(yp(3)-yp(1))/(fdt(2)+fdt(3))*2.0d0
        a(3)=ypp/2.0d0
        a(2)=yp(2)-2.0d0*a(3)*fdt(2)
        a(1)=f(2)-a(2)*fdt(2)-a(3)*fdt(2)**2
        dfdt=fdt(2)+fdt(3)
        fihi=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        dfdt=0.0d0
        filo=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        yp2zp2i=yp2zp2i+fihi-filo
        yp2zp2i=yp2zp2i*beta*clight1
      else if (izaehl.ge.3) then
        yp(1)=(f(2)-f(1))/fdt(2)
        yp(3)=(f(3)-f(2))/fdt(3)
        yp(2)=(yp(3)+yp(1))/2.0d0
        ypp=(yp(3)-yp(1))/(fdt(2)+fdt(3))*2.0d0
        a(3)=ypp/2.0d0
        a(2)=yp(2)-2.0d0*a(3)*fdt(2)
        a(1)=f(2)-a(2)*fdt(2)-a(3)*fdt(2)**2
        dfdt=fdt(2)+fdt(3)
        fihi=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        dfdt=fdt(2)
        filo=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        yp2zp2i=yp2zp2i+fihi-filo
      endif

      f(1)=f(2)
      fdt(1)=fdt(2)
      f(2)=f(3)
      fdt(2)=fdt(3)

      if (ispecmode.eq.2) then
        if (izaehl.lt.ipoisou(isour)) goto 1000
      else
        IF (X2.LT.XENDSOU-VX2*DT.AND.X2.LT.(XIEND-VX2*DT).AND.LSTEP.EQ.0)
     &    GOTO 1000
        IF (LSTEP.EQ.0) THEN
          LSTEP=1
          GOTO 1000
        ENDIF
      endif

      if (ibun.eq.1.and.isub.eq.neinbunch) then

        IF (IINSIDE.NE.0) THEN
          DPHSOUR(2,1)=BET1N*DT*FREQ(1)/HBAREV1
          DPHSOUR(2,2)=BET1N*DT*FREQ(NFREQ)/HBAREV1
        ENDIF

C- STORE NUMBER OF POINTS FOR INTEGRATION

        IF (IOBSV.EQ.ICBRILL) IZTOT(ISOUR)=IZAEHL

      endif !ibun.eq.1

      IF (IAMPLI.LT.0) THEN

        DXEXI=MIN(SOURCEEO(1,1,ISOUR),XIEND)
     &    -MAX(SOURCEAO(1,1,ISOUR),XIANF)
        if (ampr2corr.eq.-9999.0d0) ampr2corr=dxexi
        CENXEXI=(MIN(SOURCEEO(1,1,ISOUR),XIEND)
     &    +MAX(SOURCEAO(1,1,ISOUR),XIANF))/2.D0
c        GAMGAM0=(SOURCEG(1,1,ISOUR))**2
c        GAMGAM=((SOURCEG(1,1,ISOUR)+SOURCEG(2,2,ISOUR)))**2
        GAMGAM0=(SOURCEG(1,1,ISOUR)*(egamma/dmygamma))**2
        GAMGAM=(
     &    (SOURCEG(1,1,ISOUR)+SOURCEG(2,2,ISOUR))*(egamma/dmygamma)
     &    )**2

c        DTPHASE=(WTRA2IS(ISOUR)+(1.0D0/GAMGAM0)*DXEXI/2.D0)/CLIGHT1
c     &    *GAMGAM0/GAMGAM

        slopein=sqrt(vyin**2+vzin**2)/vxin
        slope=sqrt(vyelec**2+vzelec**2)/vxelec

        if (myinum.gt.nlpoi/dxexi) then
          WI=(WTRA2IS(ISOUR)
     &      -DXEXI/2.0D0*slopein**2) !wi is detour for on-axis particle
     &      *(dmygamma/egamma)**2
        else
          if (iwarnwi.eq.0) then
            write(lungfo,*)
            write(lungfo,*)'*** Warning in souintana_omp:'
            write(lungfo,*)'*** MYINUM is rather small with respect to NLPOI'
            write(lungfo,*)'*** Length of trajectories are now calculated by simple'
            write(lungfo,*)'*** integration with souintana_omp, which might be poor'
            write(lungfo,*)
            write(lungfo,*)
            write(6,*)'*** Warning in souintana_omp:'
            write(6,*)'*** MYINUM is rather small with respect to NLPOI'
            write(6,*)'*** Length of trajectories are now calculated by simple'
            write(6,*)'*** integration with souintana_omp, which might be poor'
            write(6,*)
            iwarnwi=1
          endif
          wi=(yp2zp2i/2.0d0
     &      -DXEXI/2.0D0*slopein**2) !wi is detour for on-axis particle
     &      *(dmygamma/egamma)**2
        endif

        xn1=cenxexi
        yn1=(xn1-cenxexi)*vyelec/vxelec
        zn1=(xn1-cenxexi)*vzelec/vxelec

        drn2=(
     &    (yn1+dxexi*vyelec/vxelec)**2+
     &    (zn1+dxexi*vzelec/vxelec)**2
     &    )/
     &    (2.0d0*(xobsv-xn1-dxexi))

        drn1=(
     &    yn1**2+
     &    zn1**2
     &    )/
     &    (2.0d0*(xobsv-xn1))

        DTPHASE=(
     &    WI+DXEXI*(slope**2/2.0d0+1.0d0/(2.0D0*GAMGAM0))
     &    +drn2-drn1)
     &    /CLIGHT1*GAMGAM0/GAMGAM

        AMPDT=AMPSHIFT(1)/CLIGHT1/2.0D0/GAMGAM0
        FREQR=2.D0*PI1/DTPHASE*HBAREV1
        POW=SPECPOW(jliob)

        if (jpin.ne.3.or.jpin.eq.3.and.ielec.eq.1) SPECPOW(jliob)=0.0D0

        DO I=1,-IAMPLI
          R02=(XOBSV-CENXEXI)**2+YOBSV**2+ZOBSV**2
          R2=(XOBSV-CENXEXI-DXEXI*(I-ABS(IAMPLI)/2+1))**2
     &      +YOBSV**2+ZOBSV**2
          SPECPOW(jliob)=SPECPOW(jliob)+POW*R02/R2
     &      *R2/(sqrt(R2)-ampr2corr/2.0d0)**2/nelec
        ENDDO

      ENDIF  !endif iampli.lt.0

      DO kfreq=1,NFREQ

        jliobfr=ISOUR+NSOURCE*(IOBSV-1+NOBSV*(kfreq-1))
        kfrob=kfreq+NFREQ*(IOBSV-1)
        jobfr=IOBSV+NOBSV*(kfreq-1)

        OM=FREQ(kfreq)/HBAREV1

        IF (IAMPLI.LT.0) THEN

          AX0=affe(1,kfrob)
          AY0=affe(2,kfrob)
          AZ0=affe(3,kfrob)

          AX=AX0
          AY=AY0
          AZ=AZ0

          BX0=affe(4,kfrob)
          BY0=affe(5,kfrob)
          BZ0=affe(6,kfrob)

          BXc=BX0
          BYc=BY0
          BZc=BZ0

          affe(1:6,kfrob)=(0.0D0,0.0D0)

          R0=OBSV(1,NOBSV/2+1)-CENXEXI
          R02=R0*R0
          R00=R0

c          H2=(YOBSV-vyelec)**2+(ZOBSV-vzelec)**2
c          H2R2=H2/R02
c
c          DTPHASE=(WTRA2IS(ISOUR)+(H2R2+1.0D0/GAMGAM0)*DXEXI/2.D0)/CLIGHT1
c     &      *GAMGAM0/GAMGAM
c     &      +AMPDT

          xn1=cenxexi
          yn1=(xn1-cenxexi)*vyelec/vxelec
          zn1=(xn1-cenxexi)*vzelec/vxelec

          drn2=(
     &      (yn1+dxexi*vyelec/vxelec-yobsv)**2+
     &      (zn1+dxexi*vzelec/vxelec-zobsv)**2
     &      )/
     &      (2.0d0*(xobsv-xn1-dxexi))

          drn1=(
     &      (yn1-yobsv)**2+
     &      (zn1-zobsv)**2
     &      )/
     &      (2.0d0*(xobsv-xn1))

          DTPHASE=(
     &      WI+DXEXI*(slope**2/2.0d0+1.0d0/(2.0D0*GAMGAM0))
     &      +drn2-drn1)
     &      /CLIGHT1*GAMGAM0/GAMGAM
     &      +AMPDT

          PHI=2.D0*PI1*FREQ(kfreq)*ECHARGE1/HPLANCK1*DTPHASE

          DMODU=EXP(ZI*PHI)
          DMODU0=DMODU
          DDMODU=ZONE

          if (ibunch.ne.0) then

            zzi=zeleco
            yyi=yeleco
            zzpi=zpeleco
            yypi=ypeleco

c  transform to beginning of first section
            zz=tfmhtoti(1,1)*zzi+tfmhtoti(1,2)*zzpi
            zzp=tfmhtoti(2,1)*zzi+tfmhtoti(2,2)*zzpi
            yy=tfmvtoti(1,1)*yyi+tfmvtoti(1,2)*yypi
            yyp=tfmvtoti(2,1)*yyi+tfmvtoti(2,2)*yypi

          endif !ibunch

          DO I=1,-IAMPLI

            if (ibunch.ne.0) then

c  transform to center of section, no closed orbit!
                zelec=tfmhc(1,1)*zz+tfmhc(1,2)*zzp
                zpelec=tfmhc(2,1)*zz+tfmhc(2,2)*zzp
                yelec=tfmvc(1,1)*yy+tfmvc(1,2)*yyp
                ypelec=tfmvc(2,1)*yy+tfmvc(2,2)*yyp

c  transform to beginning of next section

              zzi=zz
              yyi=yy
              zzpi=zzp
              yypi=yyp

              zz=tfmh(1,1)*zzi+tfmh(1,2)*zzpi
              zzp=tfmh(2,1)*zzi+tfmh(2,2)*zzpi
              yy=tfmv(1,1)*yyi+tfmv(1,2)*yypi
              yyp=tfmv(2,1)*yyi+tfmv(2,2)*yypi

            endif !ibunch

            R0=OBSV(1,NOBSV/2+1)+DXEXI/2.D0*(-IAMPLI-2*(I-1)-1)-CENXEXI
            CORRR0=R00/R0
            !corrects for mistake of averaging over 1/r2, if e.g.
            !the repeated device is a long undulator
     &        *(R0/(R0-ampr2corr/2.0d0))**2

            R02=R0*R0
c            H2=(YOBSV)**2+(ZOBSV)**2
c            H2R2=H2/R02

c            DTPHASE=(WTRA2IS(ISOUR)+(H2R2+1.0D0/GAMGAM0)*DXEXI/2.D0)/CLIGHT1
c     &        *GAMGAM0/GAMGAM
c     &        +AMPDT

c            slope=sqrt(vyelec**2+vzelec**2)/vxelec

            slope=sqrt(ypelec**2+zpelec**2)*gamgam0/gamgam

            slope=sqrt(ypelec**2+zpelec**2)

            xn1=cenxexi-dxexi/2.d0*(-iampli-2*(i-1)-1)
     &          /(R0/(R0-ampr2corr/2.0d0))**2 !empirically
            yn1=(xn1-cenxexi)*ypelec
            zn1=(xn1-cenxexi)*zpelec

            yn1=yelec
            zn1=zelec

            drn2=(
     &        (yn1+dxexi*ypelec-yobsv)**2+
     &        (zn1+dxexi*zpelec-zobsv)**2
     &        )/
     &        (2.0d0*(xobsv-xn1-dxexi))

            drn1=(
     &        (yn1-yobsv)**2+
     &        (zn1-zobsv)**2
     &        )/
     &        (2.0d0*(xobsv-xn1))

            DTPHASE=(
     &        WI+DXEXI*(slope**2/2.0d0+1.0d0/(2.0D0*GAMGAM0))
     &        +drn2-drn1)
     &        /CLIGHT1*GAMGAM0/GAMGAM
     &        +AMPDT

            PHI=2.D0*PI1*FREQ(kfreq)*ECHARGE1/HPLANCK1*DTPHASE

            DMODU=EXP(ZI*PHI)
            DMODU0=DMODU
            DDMODU=ZONE

              affe(1,kfrob)=affe(1,kfrob)+AX
              affe(2,kfrob)=affe(2,kfrob)+AY
              affe(3,kfrob)=affe(3,kfrob)+AZ

              affe(4,kfrob)=affe(4,kfrob)+bXc
              affe(5,kfrob)=affe(5,kfrob)+bYc
              affe(6,kfrob)=affe(6,kfrob)+bZc

            IF (AMPRAN.NE.0.0D0) THEN
              PHI=2.D0*PI1*XRANA(I)/FREQR*FREQ(kfreq)
              DDMODU=EXP(ZI*PHI)
            ENDIF   !(AMPRAN.NE.0.0D0)

            AX0=AX0*DMODU0
            AY0=AY0*DMODU0
            AZ0=AZ0*DMODU0

            AX=AX0*CORRR0
            AY=AY0*CORRR0
            AZ=AZ0*CORRR0

            DMODU=DMODU0*DDMODU
            AX=AX*DMODU
            AY=AY*DMODU
            AZ=AZ*DMODU

            BX0=BX0*DMODU0
            BY0=BY0*DMODU0
            BZ0=BZ0*DMODU0

            BXc=BX0*CORRR0
            BYc=BY0*CORRR0
            BZc=BZ0*CORRR0

            BXc=BXc*DMODU
            BYc=BYc*DMODU
            BZc=BZc*DMODU

          ENDDO !IAMPLI

          zelec=zeleco
          yelec=yeleco

        ENDIF  !(IAMPLI.LT.0)

        if (jpin.eq.3) then

          FSPEC(1)=ISOUR
          FSPEC(2)=IOBSV
          FSPEC(3)=xobsv
          FSPEC(4)=yobsv
          FSPEC(5)=zobsv
          FSPEC(6)=FREQ(kfreq)
          FSPEC(7)=
     &      (
     &      DREAL(affe(1,kfrob))*DREAL(affe(1,kfrob))
     &      +DIMAG(affe(1,kfrob))*DIMAG(affe(1,kfrob))
     &      +DREAL(affe(2,kfrob))*DREAL(affe(2,kfrob))
     &      +DIMAG(affe(2,kfrob))*DIMAG(affe(2,kfrob))
     &      +DREAL(affe(3,kfrob))*DREAL(affe(3,kfrob))
     &      +DIMAG(affe(3,kfrob))*DIMAG(affe(3,kfrob))
     &      )*specnor*bunnor
          FSPEC(8)=1
          FSPEC(9)=1
          FSPEC(10)=kfreq
          FSPEC(11)=dreal(affe(1,kfrob))*sqrt(specnor*bunnor)
          FSPEC(12)=dimag(affe(1,kfrob))*sqrt(specnor*bunnor)
          FSPEC(13)=dreal(affe(2,kfrob))*sqrt(specnor*bunnor)
          FSPEC(14)=dimag(affe(2,kfrob))*sqrt(specnor*bunnor)
          FSPEC(15)=dreal(affe(3,kfrob))*sqrt(specnor*bunnor)
          FSPEC(16)=dimag(affe(3,kfrob))*sqrt(specnor*bunnor)
          FSPEC(17)=0.0d0
          FSPEC(18)=0.0d0
          FSPEC(19)=0.0d0
          FSPEC(20)=0.0d0

          FSPEC(21)=dreal(affe(4,kfrob))*sqrt(specnor*bunnor)
          FSPEC(22)=dimag(affe(4,kfrob))*sqrt(specnor*bunnor)
          FSPEC(23)=dreal(affe(5,kfrob))*sqrt(specnor*bunnor)
          FSPEC(24)=dimag(affe(5,kfrob))*sqrt(specnor*bunnor)
          FSPEC(25)=dreal(affe(6,kfrob))*sqrt(specnor*bunnor)
          FSPEC(26)=dimag(affe(6,kfrob))*sqrt(specnor*bunnor)
          FSPEC(27)=0.0d0
          FSPEC(28)=0.0d0
          FSPEC(29)=0.0d0
          FSPEC(30)=0.0d0

          if (ispecdip.le.0) then
            cenxexi=(min(sourceeo(1,1,isour),xiend)
     &        +max(sourceao(1,1,isour),xianf))/2.d0
          else
            cenxexi=x0dip(isour)
          endif

          dist0=pincen(1)-cenxexi
          dist02=dist0**2

          h2=(yobsv**2+zobsv**2)/dist02
          if (h2.lt.0.01) then
            ddist=dist0*(h2/2.0d0-h2**2/8.0d0)
          else
            ddist=dist0*(sqrt(1.0d0+h2)-1.0d0)
          endif

          dphase=ddist/freq(kfreq)*wtoe1*1.0d9*twopi1

          FSPEC(31)=dphase

          call hfm(nidspec,fspec)

          FSPEC(1)=xobsv
          FSPEC(2)=yobsv
          FSPEC(3)=zobsv
          FSPEC(4)=powpow*pownor
          FSPEC(5)=0.0d0
          FSPEC(6)=1.0d0
          FSPEC(7)=1.0d0
          FSPEC(8)=iobsv
          FSPEC(9)=ISOUR

          call hfm(nidpow,fspec)

          if (istokes.ne.0) then

            APOLH=
     &        affe(1,kfrob)*CONJG(VSTOKES(1,1))
     &        +affe(2,kfrob)*CONJG(VSTOKES(1,2))
     &        +affe(3,kfrob)*CONJG(VSTOKES(1,3))

            APOLR=
     &        affe(1,kfrob)*CONJG(VSTOKES(2,1))
     &        +affe(2,kfrob)*CONJG(VSTOKES(2,2))
     &        +affe(3,kfrob)*CONJG(VSTOKES(2,3))

            APOLL=
     &        affe(1,kfrob)*CONJG(VSTOKES(3,1))
     &        +affe(2,kfrob)*CONJG(VSTOKES(3,2))
     &        +affe(3,kfrob)*CONJG(VSTOKES(3,3))

            APOL45=
     &        affe(1,kfrob)*CONJG(VSTOKES(4,1))
     &        +affe(2,kfrob)*CONJG(VSTOKES(4,2))
     &        +affe(3,kfrob)*CONJG(VSTOKES(4,3))

            STOK1=
     &        APOLR*CONJG(APOLR)+
     &        APOLL*CONJG(APOLL)

            STOK2=-STOK1+
     &        2.0d0*APOLH*CONJG(APOLH)

            STOK3=
     &        2.0d0*APOL45*CONJG(APOL45)-
     &        STOK1

            STOK4=
     &        APOLR*CONJG(APOLR)-
     &        APOLL*CONJG(APOLL)

            FSPEC(1)=IOBSV
            FSPEC(2)=xobsv
            FSPEC(3)=yobsv
            FSPEC(4)=zobsv
            FSPEC(5)=FREQ(kfreq)
            FSPEC(6)=STOK1*specnor*bunnor
            FSPEC(7)=STOK2*specnor*bunnor
            FSPEC(8)=STOK3*specnor*bunnor
            FSPEC(9)=STOK4*specnor*bunnor
            FSPEC(10)=1.0d0
            FSPEC(11)=1.0d0
            FSPEC(12)=kfreq

            CALL hfm(NIDSTOK,FSPEC)

          ENDIF   !ISTOKES

        endif !ipin.eq.3

        if (ihbunch.ne.0.and.iobsv.eq.icbrill) then
            fillb(1)=ibun
            fillb(2)=isub
            fillb(3)=ielec
            fillb(4)=bunchx
            fillb(5)=xelec
            fillb(6)=yelec
            fillb(7)=zelec
            fillb(8)=vyelec/vxelec
            fillb(9)=vzelec/vxelec
            fillb(10)=x2
            fillb(11)=y2
            fillb(12)=z2
            fillb(13)=vy2/vx2
            fillb(14)=vz2/vx2
            fillb(15)=egamma*emassg1
            fillb(16)=gamma*emassg1
            fillb(17)=xobsv
            fillb(18)=yobsv
            fillb(19)=zobsv
            fillb(20)=kfreq
            fillb(21)=freq(kfreq)
            speck=
     &        DREAL(
     &        affe(1,kfrob)*CONJG(affe(1,kfrob))
     &        +affe(2,kfrob)*CONJG(affe(2,kfrob))
     &        +affe(3,kfrob)*CONJG(affe(3,kfrob))
     &        )*specnor*bunnor
            fillb(22)=speck*nelec

            if (istokes.ne.0) then

              APOLH=
     &          affe(1,kfrob)*CONJG(VSTOKES(1,1))
     &          +affe(2,kfrob)*CONJG(VSTOKES(1,2))
     &          +affe(3,kfrob)*CONJG(VSTOKES(1,3))

              APOLR=
     &          affe(1,kfrob)*CONJG(VSTOKES(2,1))
     &          +affe(2,kfrob)*CONJG(VSTOKES(2,2))
     &          +affe(3,kfrob)*CONJG(VSTOKES(2,3))

              APOLL=
     &          affe(1,kfrob)*CONJG(VSTOKES(3,1))
     &          +affe(2,kfrob)*CONJG(VSTOKES(3,2))
     &          +affe(3,kfrob)*CONJG(VSTOKES(3,3))

              APOL45=
     &          affe(1,kfrob)*CONJG(VSTOKES(4,1))
     &          +affe(2,kfrob)*CONJG(VSTOKES(4,2))
     &          +affe(3,kfrob)*CONJG(VSTOKES(4,3))

              STOK1=
     &          APOLR*CONJG(APOLR)+
     &          APOLL*CONJG(APOLL)

              STOK2=-STOK1+
     &          2.0d0*APOLH*CONJG(APOLH)

              STOK3=
     &          2.0d0*APOL45*CONJG(APOL45)-
     &          STOK1

              STOK4=
     &          APOLR*CONJG(APOLR)-
     &          APOLL*CONJG(APOLL)

              fillb(23)=stok1*specnor*bunnor*nelec
              fillb(24)=stok2*specnor*bunnor*nelec
              fillb(25)=stok3*specnor*bunnor*nelec
              fillb(26)=stok4*specnor*bunnor*nelec

            else
              fillb(23)=fillb(22)
              fillb(24:26)=0.0d0
            endif !istokes

          fillb(27)=powpow*pownor*nelec
          fillb(28)=isour
          fillb(29)=t2

          call hfm(nidbunch,fillb)
        endif

        if (ibunphase.eq.1) then

          are(1:6)=dreal(affe(1:6,kfrob))
          aim(1:6)=dimag(affe(1:6,kfrob))

          if (iobunch.eq.-9999.and.ielec.eq.1) then
            ampz(kfreq)=sqrt(are(3)**2+aim(3)**2)
            if (ampz(kfreq).gt.ampzmax(kfreq)) then
              ampzmax(kfreq)=ampz(kfreq)
              kobs(kfreq)=iobsv
            endif
          else if (iobsv.eq.iobunch) then
            ampz(kfreq)=sqrt(are(3)**2+aim(3)**2)
            if (ampz(kfreq).ne.0.0d0) then
              azcos(kfreq)=are(3)/ampz(kfreq)
              azsin(kfreq)=aim(3)/ampz(kfreq)
            else
              azcos(kfreq)=1.0d0
              azsin(kfreq)=0.0d0
            endif
          endif

          if (iobsv.eq.nobsv.and.kfreq.eq.nfreq) then

            do jfreq=1,nfreq

              jfrob=jfreq+nfreq*(kobs(jfreq)-1)
              are(1:6)=dreal(affe(1:6,jfrob))
              aim(1:6)=dimag(affe(1:6,jfrob))

              ampz(jfreq)=sqrt(are(3)**2+aim(3)**2)
              if (ampz(jfreq).ne.0.0d0) then
                azcos(jfreq)=are(3)/ampz(jfreq)
                azsin(jfreq)=aim(3)/ampz(jfreq)
              else
                azcos(jfreq)=1.0d0
                azsin(jfreq)=0.0d0
              endif

            enddo !jfreq

            do job=1,nobsv
              do jfreq=1,nfreq

                jfrob=jfreq+nfreq*(job-1)

                are(1:6)=dreal(affe(1:6,jfrob))
                aim(1:6)=dimag(affe(1:6,jfrob))

                affe(1:6,jfrob)=dcmplx(
     &            azcos(jfreq)*are+azsin(jfreq)*aim,
     &            -azsin(jfreq)*are+azcos(jfreq)*aim
     &            )

                AFREQ(1:6,jfrob)=AFREQ(1:6,jfrob)+affe(1:6,jfrob)

                affe(1:6,jfrob)=(0.0D0,0.0D0)

              enddo
            enddo

          endif !iobsv.eq.nobsv

        else !ibunphase

          if (iobsv.eq.nobsv.and.kfreq.eq.nfreq) then
            AFREQ=AFREQ+affe
            affe=(0.0D0,0.0D0)
          endif

        endif !ibunphase

      ENDDO !kfreq

      if (isub.eq.neinbunch.and.iobsv.eq.nobsv) then

        do job=1,nobsv
          do kfreq=1,nfreq

            kfrob=kfreq+nfreq*(job-1)
            jliobfr=isour+nsource*(job-1+nobsv*(kfreq-1))
            jobfr=job+nobsv*(kfreq-1)

            IF(SPECCUT.GT.0.0D0) THEN
              ECMAXS=ECMAX(ISOUR)
              IF(FREQ(kfreq).GT.SPECCUT*ecdipev1*DMYENERGY**2*ECMAXS) THEN
                AFREQ(1:6,kfrob)=(0.0D0,0.0D0)
              ENDIF
            ENDIF

            AFREQ(1:3,kfrob)=AFREQ(1:3,kfrob)*REFLEC(1:3)
            AFREQ(4:6,kfrob)=AFREQ(4:6,kfrob)*REFLEC(1:3)

            IF (IPOLA.EQ.0) THEN

              speck=
     &          DREAL(
     &          AFREQ(1,kfrob)*CONJG(AFREQ(1,kfrob))
     &          +AFREQ(2,kfrob)*CONJG(AFREQ(2,kfrob))
     &          +AFREQ(3,kfrob)*CONJG(AFREQ(3,kfrob))
     &          )*specnor*bunnor

              SPEC(jliobfr)=SPEC(jliobfr)+speck

              REAIMA(1:3,1,jobfr)=REAIMA(1:3,1,jobfr)+
     &          DREAL(AFREQ(1:3,kfrob))/sqnbunch
              REAIMA(1:3,2,jobfr)=REAIMA(1:3,2,jobfr)+
     &          DIMAG(AFREQ(1:3,kfrob))/sqnbunch

              REAIMA(6:8,1,jobfr)=REAIMA(6:8,1,jobfr)+
     &          DREAL(AFREQ(4:6,kfrob))/sqnbunch
              REAIMA(6:8,2,jobfr)=REAIMA(6:8,2,jobfr)+
     &          DIMAG(AFREQ(4:6,kfrob))/sqnbunch

            ELSE    !IPOLA

              APOL=
     &          AFREQ(1,kfrob)*CONJG(VPOLA(1))
     &          +AFREQ(2,kfrob)*CONJG(VPOLA(2))
     &          +AFREQ(3,kfrob)*CONJG(VPOLA(3))

              SPEC(jliobfr)=SPEC(jliobfr)+
     &          DREAL(APOL*CONJG(APOL))*specnor*bunnor

              REAIMA(1:3,1,jobfr)=REAIMA(1:3,1,jobfr)+
     &          DREAL(AFREQ(1:3,kfrob))/sqnbunch
              REAIMA(1:3,2,jobfr)=REAIMA(1:3,2,jobfr)+
     &          DIMAG(AFREQ(1:3,kfrob))/sqnbunch

              REAIMA(6:8,1,jobfr)=REAIMA(6:8,1,jobfr)+
     &          DREAL(AFREQ(4:6,kfrob))/sqnbunch
              REAIMA(6:8,2,jobfr)=REAIMA(6:8,2,jobfr)+
     &          DIMAG(AFREQ(4:6,kfrob))/sqnbunch

            ENDIF   !IPOLA

            IF (ISTOKES.NE.0) THEN

              APOLH=
     &          AFREQ(1,kfrob)*CONJG(VSTOKES(1,1))
     &          +AFREQ(2,kfrob)*CONJG(VSTOKES(1,2))
     &          +AFREQ(3,kfrob)*CONJG(VSTOKES(1,3))

              APOLR=
     &          AFREQ(1,kfrob)*CONJG(VSTOKES(2,1))
     &          +AFREQ(2,kfrob)*CONJG(VSTOKES(2,2))
     &          +AFREQ(3,kfrob)*CONJG(VSTOKES(2,3))

              APOLL=
     &          AFREQ(1,kfrob)*CONJG(VSTOKES(3,1))
     &          +AFREQ(2,kfrob)*CONJG(VSTOKES(3,2))
     &          +AFREQ(3,kfrob)*CONJG(VSTOKES(3,3))

              APOL45=
     &          AFREQ(1,kfrob)*CONJG(VSTOKES(4,1))
     &          +AFREQ(2,kfrob)*CONJG(VSTOKES(4,2))
     &          +AFREQ(3,kfrob)*CONJG(VSTOKES(4,3))

              STOK1=
     &          APOLR*CONJG(APOLR)+
     &          APOLL*CONJG(APOLL)

              STOK2=-STOK1+
     &          2.0d0*APOLH*CONJG(APOLH)

              STOK3=
     &          2.0d0*APOL45*CONJG(APOL45)-
     &          STOK1

              STOK4=
     &          APOLR*CONJG(APOLR)-
     &          APOLL*CONJG(APOLL)

              STOKES(1,jobfr)=STOKES(1,jobfr)+
     &          STOK1*specnor*bunnor

              STOKES(2,jobfr)=STOKES(2,jobfr)+
     &          STOK2*specnor*bunnor

              STOKES(3,jobfr)=STOKES(3,jobfr)+
     &          STOK3*specnor*bunnor

              STOKES(4,jobfr)=STOKES(4,jobfr)+
     &          STOK4*specnor*bunnor

            ENDIF !ISTOKES

            AFREQ(1,kfrob)=(0.0d0,0.0d0)
            AFREQ(2,kfrob)=(0.0d0,0.0d0)
            AFREQ(3,kfrob)=(0.0d0,0.0d0)

          enddo !kfreq
        enddo !job

      endif !isub.eq.neinbunch

      if (ibun.eq.nbunch.and.isub.eq.neinbunch) then
        jliob=ISOUR+NSOURCE*(IOBSV-1)
        SPECPOW(jliob)=SPECPOW(jliob)*POWNOR
      endif

      IF (
     &    jpin.ne.0.and.jpin.ne.3.and.IOBSV.EQ.jobunch
     &    .or.
     &    (jpin.eq.3.or.jpin.eq.0).and.ielec.eq.1
     &    ) THEN


        WRITE(LUNGFO,*)
     &    '       phase advance per step at beginning and end of source for'
        if (jpin.ne.3) then
          WRITE(LUNGFO,*)
     &      '       lowest and highest photon energy at selected observation point:'
        else
          WRITE(LUNGFO,*)
     &      '       lowest and highest photon energy for first electron:'
        endif
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'       beginning:',SNGL(DPHSOUR(1,1)),SNGL(DPHSOUR(1,2))
        WRITE(LUNGFO,*)'       end:      ',SNGL(DPHSOUR(2,1)),SNGL(DPHSOUR(2,2))
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'       ROIs (boundary, precision, points):'
        WRITE(LUNGFO,*)

        DO IROI=1,NROIA-1
          WRITE(LUNGFO,*)
     &      IROI,SNGL(roi(1,IROI)),SNGL(roi(2,IROI)),IPOIROI(IROI+1)
        ENDDO
        WRITE(LUNGFO,*)
     &    NROI,SNGL(roi(1,NROIA))

      ENDIF !IOBSV

      IF (
     &    jpin.ne.0.and.jpin.ne.3.and.IOBSV.EQ.NOBSV
     &    .or.
     &    (jpin.eq.0.or.jpin.eq.3).and.ielec.eq.1) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'       SOURCE, TOTAL NUMBER OF STEPS:',ISOUR,IZAEHL
        WRITE(LUNGFO,*)'       (controlled by NLPOI and namelist $ROIN)'
        WRITE(LUNGFO,*)
      ENDIF

      isourold=isour

      RETURN
      END
+DECK,souintrphi_omp.
*CMZ :  4.01/04 14/11/2023  11.33.48  by  Michael Scheer
*CMZ :  4.01/03 02/06/2023  08.38.01  by  Michael Scheer
*CMZ :  4.00/17 28/11/2022  17.49.12  by  Michael Scheer
*CMZ :  4.00/13 07/11/2021  17.22.27  by  Michael Scheer
*CMZ :  3.07/01 21/03/2019  12.26.41  by  Michael Scheer
*CMZ :  3.07/00 15/03/2019  12.15.26  by  Michael Scheer
*CMZ :  3.06/00 28/02/2019  17.18.16  by  Michael Scheer
*CMZ :  3.05/06 17/07/2018  11.12.29  by  Michael Scheer
*CMZ :  3.05/04 27/06/2018  14.00.13  by  Michael Scheer
*CMZ :  3.05/03 22/05/2018  07.27.47  by  Michael Scheer
*-- Author :    Michael Scheer   04/09/2009
      SUBROUTINE SOUINTRPHI_OMP(ISOUR,INSIDE)
+seq,gplhint.

+SEQ,TRACKF90U.
+SEQ,WORKF90U.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,AFREQF90U.
+SEQ,AMPLIF90U.

      use bunchmod
      use souintmod
      use omp_lib

C--- EVALUATE INTEGRALES FOR A SINGLE SOURCE
C---- RESULTS ARE STORE IN AFREQRPHI AND SPECPOWRPHI

         IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,PHYCON.
+SEQ,TRACK.
+seq,sourcef90.
+SEQ,COLLI.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,FREQS.
+SEQ,AMPLI.
+SEQ,B0SCGLOB.
+SEQ,PRIMKIN.
+seq,ustep.
+SEQ,USERVAR.
+seq,datetime.

      double precision, dimension (:,:,:), allocatable :: dphsou
      double precision, dimension (:), allocatable :: frq
      integer, dimension (:), allocatable :: iinside,kinside,linside

      COMPLEX*16 ZIOM,ZI,ZIDOM,ZONE,ZICR1,ZIC,baff(3),daff(3)
      COMPLEX*16 EXPOM,DEXPOMPH1,DEXPOMPH,DDEXPOMPH,DEXPOM,EXPOMV2
      COMPLEX*16 DMODU,DMODU0,DDMODU,AX,AY,AZ,AX0,AY0,AZ0,
     &  bx0,by0,bz0
      COMPLEX*16 APOL,APOLH,APOLR,APOLL,APOL45

      DOUBLE PRECISION T0,T1,T2,TENDSOU,X0,X1,X2,X10,Y1,Y2,Z1,Z2,XENDSOU,R0
     &  ,T,DT,DT2,DT0,DTIM00,DTIM01,VXP,VYP,VZP,TENDSOU1
     &  ,R02
c     &  ,H2,H2R2
     &  ,PHI,FREQR,CORRR0,R00,R2,POW
     &  ,X2B,Y2B,Z2B
     &  ,DGAMMA,DGAMSUM,BETA,GAMGAM,GAMGAM0,AMPDT,sqnphsp,sqnbunch,
     &  sqbunnor
     &  ,are(6),aim(6),
     &  xn1,slopein,slope,drn1,drn2,zn1,yn1,wi

      DOUBLE PRECISION STOK1,STOK2,STOK3,STOK4

      DOUBLE PRECISION VX1,VY1,VZ1,BX1,BY1,BZ1
      DOUBLE PRECISION VX2,VY2,VZ2,BX2,BY2,BZ2,AX2D,AY2D,AZ2D
      DOUBLE PRECISION ECDUM,BS,BSQ,ECMAXS,bs1
      DOUBLE PRECISION TS,DPHASE,DPHSOUR(2,2),phase
      DOUBLE PRECISION C1,OM,DOM,GAMMA

      DOUBLE PRECISION BX,BY,BZ,RX,RY,RZ,PX,PY,PZ,RNBX,RNBY,RNBZ
      DOUBLE PRECISION R1,RNX,RNY,RNZ,DOM1,DOM2,BET1N,DUM11,R,BPX,BPY,BPZ
      DOUBLE PRECISION WGANG,OPANG,rn
      double precision br2,rnr2,br4,rnr4,b3,yp2zp2i,
c     &  yp2zp2ia,
     &  f(3),yp(3),ypp,a(3),fdt(3),filo,fihi,dfdt

      DOUBLE PRECISION RARG(5),C

      DOUBLE PRECISION DROIX,DTPHASE,DXEXI,CENXEXI,roi(nroip)
      DOUBLE PRECISION BET1NO,XRPHI,YRPHI,ZRPHI,speck

      double precision fillb(29)

      INTEGER INSIDE
      INTEGER ISOUR,IOBSV,kfreq,JFREQ,IZAEHL,NZAEHL,IX10,I,ICAL,ICOMP
      INTEGER*8
     &  NZAEHL10,MZAEHL,kzaehl,iizaehl,ir1,ir2
      INTEGER ICSPL,IROI,II,IZTOTS,IWARNBET1N,LSTEP,
     &  MCOUNT,NCOUNT,NCOUNT10,N10,ICOUNT,
     &  jobsv,nelec,norad,iwarnwi,jliob,jliobfr,jobfr,
     &  jvelofield,nfrq,ith,kungfo

      INTEGER NTUPP,IC
      PARAMETER (NTUPP=38)
      REAL*8 FILLT(NTUPP)
      CHARACTER(5) CTUP(NTUPP)

      data ctup /'t','x','y','z','rx','ry','rz','rt','p','expr','expi','roi'
     &  ,'iob','ie','yob','zob','bet1n','om','dt','by2','isou'
     &  ,'spec','reax','imax','reay','imay','reaz','imaz','dom1',
     &  'betx','bety','betz','betxp','betyp','betzp','nx','ny','nz'/
     &
      DATA ICAL/0/
      DATA ZI/(0.0D0,1.0D0)/
      DATA ZONE/(1.0D0,0.0D0)/
      DATA IWARNBET1N/0/

      save ical

      allocate(frq(nfreq))
      allocate(kinside(nobsvrphi),linside(nobsvrphi),iinside(nobsvrphi),
     &  dphsou(2,2,max(1,mthreads)))

      linside=0
      iinside=0
      kinside=0

      IF (ICAL.EQ.0) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'       SUBROUTINE SOUINTRPHI_OMP:'
        WRITE(LUNGFO,*)'       (triggered by MPINR)'
        WRITE(LUNGFO,*)

        if(ibunch.ne.0) then
          write(lungfo,*)
          write(lungfo,*)
     &      '*** Warning in SOUINTRPHI_OMP: Use of IBUNCH may result in problems,'
          write(lungfo,*)
     &      '*** since radiation cone might be not centered and lacking cylindrical symmetry '
          write(lungfo,*)
          write(6,*)
          write(6,*)
     &      '*** Warning in SOUINTRPHI_OMP: Use of IBUNCH may result in problems,'
          write(6,*)
     &      '*** since radiation cone might be not centered and lacking cylindrical symmetry '
          write(6,*)
        endif

        IF (NFREQ.GT.NDFREQ) THEN
          WRITE(LUNGFO,*)
     &      '*** ERROR IN SOUINTRPHI_OMP: NUMBER OF MAXIMUM PHOTON ENERGIES EXCEEDED'
          WRITE(LUNGFO,*)
     &      'INCREASE PARAMETER NDFREQP IN CMPARA.CMN'
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED  ***'
          WRITE(6,*)
     &      '*** ERROR IN SOUINTRPHI_OMP: NUMBER OF MAXIMUM PHOTON ENERGIES EXCEEDED'
          WRITE(6,*)
     &      'INCREASE PARAMETER NDFREQP IN CMPARA.CMN'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED  ***'
          STOP
        ENDIF    !(NFREQ.GT.NDFREQP)

        DO II=1,NSOURCE
          DO I=1,NROIA
            IWARNROI(I,II)=0
          ENDDO
        ENDDO

        IF (ISPECMODE.EQ.1) THEN
          DTIM00=DTMCO
        ELSE
          DTIM00=DTIM0
        ENDIF

        DTIM01=1.D0/DTIM00

        C=CLIGHT1
        C1=1.D0/CLIGHT1

        DOM=(FREQ(2)-FREQ(1))/HBAREV1
        OM=FREQ(1)/HBAREV1
        ZIDOM=ZI*DOM
        ZIOM=ZI*OM
        ZIC=ZI*CLIGHT1

        IF (IWFILINT.LT.0) THEN
          CALL hbookm(NIDSOURCE,'RADIATION INTEGRALS$',NTUPP
     &      , '//WAVE',1024,CTUP)
        ENDIF !(IWFILINT.LT.0)

        nphsp=nbunch
        nelec=neinbunch*nphsp

c Flux density is normalized to number of electrons per bunch or bunch charge
c and dmycurr. The field is normalized such, that flux dens = ABS(field)**2
        if (ibunch.ne.0.and.bunchcharge.ne.0.0d0) then
          sqnbunch=nbunch
          sqnphsp=sqrt(bunchcharge/echarge1)
     &      *neinbunch
     &      /(bunchcharge/echarge1)
          bunnor=1.0d0/nbunch
        else
          sqnbunch=nbunch
          sqnphsp=sqrt(dble(neinbunch))
          bunnor=1.0d0/nbunch
        endif

        if (ibunphase.eq.0) then
          sqbunnor=sqrt(dfloat(neinbunch))/sqrt(dfloat(nbunch))
        else
          sqbunnor=1.0d0/sqrt(dfloat(nbunch))
        endif

      ENDIF !ICAL

      IF (ielec.eq.1) THEN

        WRITE(LUNGFO,*)'            SOURCE NUMBER',ISOUR,':'
        WRITE(LUNGFO,*)

        do kfreq=1,nfreq
          ampzmax(kfreq)=0.0d0
          azcos(kfreq)=1.0d0
          azsin(kfreq)=0.0d0
        enddo
        kobs=iobunch

        X1=xelec

        IF (NROI.LT.0) THEN
          DROIX=(XENDSOU-X1)/(NROIA-1)
          DO IROI=1,NROIA
            ROIX(IROI)=X1+(IROI-1)*DROIX
            ROIP(IROI)=1.0D0
          ENDDO
        ENDIF   !(NROI.LT.0)

        ROIX(1)=ROIX(1)-1.0D-6
        ROIX(NROIA)=ROIX(NROIA)+1.0D-6

        DO IROI=1,NROIA
          IPOIROI(IROI)=0
          if (ical.eq.0) then
            roi(iroi)=roix(iroi)
          endif
        ENDDO
      ENDIF !ielec.eq.1

      phaserphi=0.0d0
      LSTEP=0
      DGAMSUM=0.0D0

      gamma=egamma
      beta=dsqrt((1.0d0-1.0d0/gamma)*(1.0d0+1.0d0/gamma))

c error? 16feb07        WGANG2=(WGWINFC/GAMMA)**2+2.0D0/(GAMMA**2*(1.0D0+DMYBETA))
C ERROR 11jan08        WGANG2=(WGWINFC/GAMMA)**2
      WGANG=WGWINFC/GAMMA

      ICSPL=0

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS     T=-R0*C1
      T=0.0D0 !WICHTIG HIER WEGEN TENDSOU-T WEITER UNTEN

      R0=OBSVRPHI(1,1)-SOURCEAO(1,1,ISOUR)

      IF (ISPECMODE.EQ.1) THEN
        T0=DWT(1)
        T1=T0
        T2=DWT(MCO)
        XENDSOU=DWX(MCO)    !FINAL X
      ELSE
        T0=SOURCET(1,ISOUR)
        T1=T0
        T2=SOURCET(2,ISOUR)
        XENDSOU=SOURCEEO(1,1,ISOUR)    !FINAL X
      ENDIF

      TENDSOU=T2-T1

      X1=xelec
      Y1=yelec
      Z1=zelec

      VX1=vxelec
      VY1=vyelec
      VZ1=vzelec

      BX1=SOURCEAO(1,4,ISOUR)
      BY1=SOURCEAO(2,4,ISOUR)
      BZ1=SOURCEAO(3,4,ISOUR)
      BS1=SQRT(BX1**2+BY1**2+BZ1**2)

      IZTOTS=0

      X0=X1
      X2=X1
      X10=(XENDSOU-X0)/10.1D0

      NZAEHL=NLPOIO
      DT0=TENDSOU/NZAEHL

      DT=DT0

      if (ielec.eq.1) then

        KZAEHL=0

        IR1=-1
        DO IROI=1,NROIA
          IF (ROIX(IROI).GT.X1.AND.ROIX(IROI).LT.XENDSOU.AND.IR1.EQ.-1) THEN
            IR1=IROI
            GOTO 11
          ENDIF
        ENDDO

11      DO IROI=1,NROIA
          IR2=IROI
          IF (roi(IROI).GT.XENDSOU) THEN
            roi(IROI)=XENDSOU
            IR2=IR2-1
            IF (roi(IR2).LT.X1) THEN
              roi(IR2)=X1
            ENDIF
            GOTO 12
          ENDIF
        ENDDO

12      CONTINUE

        KZAEHL=KZAEHL+NZAEHL*ROIP(IR2)*(XENDSOU-roi(IR2))/(XENDSOU-X1)

        IF (IR1.NE.-1) THEN

          KZAEHL=KZAEHL+NZAEHL*ROIP(IR1-1)*(roi(IR1)-X1)/(XENDSOU-X1)

          DO IROI=IR1,IR2-1
            IF (roi(IROI).GT.X1.OR.roi(IROI)+1.LT.XENDSOU) THEN
              KZAEHL=KZAEHL+NZAEHL*ROIP(IROI)*(roi(IROI+1)-roi(IROI))/(XENDSOU-X1)
            ELSE IF (roi(IROI).GT.X1.OR.roi(IROI)+1.LT.XENDSOU) THEN
              KZAEHL=KZAEHL+NZAEHL*ROIP(IROI)*(roi(IROI+1)-roi(IROI))/(XENDSOU-X1)
            ENDIF
          ENDDO

        ENDIF

      endif !ielec.eq.1

      IF (X1.LT.ROIX(1).OR.XENDSOU.GT.ROIX(NROIA)) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN SOUINTRPHI_OMP: X OUTSIDE ROIS ***'
        WRITE(LUNGFO,*)'CHECK NAMELIST $ROIN'
        WRITE(LUNGFO,*)' *** PROGRAM WAVE ABORTED ***'
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN SOUINTRPHI_OMP: X OUTSIDE ROIS ***'
        WRITE(6,*)'CHECK NAMELIST $ROIN'
        WRITE(6,*)' *** PROGRAM WAVE ABORTED ***'
        STOP
      ENDIF   !IROI

      X2=X1
      Y2=Y1
      Z2=Z1

      VX2=VX1
      VY2=VY1
      VZ2=VZ1

      BX2=BX1
      BY2=BY1
      BZ2=BZ1
      BS=BS1

C--- LOOP OVER STEPS

      DO IROI=1,NROIA
        IPOIROI(IROI)=0
      ENDDO

      IROI=1
      DO I=1,NROIA
        IF (X1.GE.ROIX(I)) THEN
          IROI=I
        ENDIF !(X1.GE.ROIX(I))
      ENDDO   !IROI

      DT=DT0/ROIP(IROI)

      NZAEHL=MAX(5,NINT((TENDSOU-T)/DT))
      DT=(TENDSOU-T)/NZAEHL

      TENDSOU1=TENDSOU-DT
      DT2=DT/2.D0

C- CHECK STEPS SIZE

      IF (IWARNROI(IROI,ISOUR).EQ.0) THEN
        IF (DT.GT.DTIM00) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '*** WARNING IN SOUINTRPHI_OMP, SOURCE, ROI:',ISOUR,IROI
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
          WRITE(LUNGFO,*)'SIZE FOR TRAJECTORY!'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
          WRITE(6,*)
          WRITE(6,*)
     &      '*** WARNING IN SOUINTRPHI_OMP, SOURCE, ROI:',ISOUR,IROI
          WRITE(6,*)
          WRITE(6,*)'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
          WRITE(6,*)'SIZE FOR TRAJECTORY!'
          WRITE(6,*)
          WRITE(6,*)
     &      'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
          WRITE(6,*)
          IWARNROI(IROI,ISOUR)=1
        ENDIF !DT
      ENDIF !IWARNROI

      IROI=IROI+1

      IZAEHL=0 !LOOP COUNTER

      nutrack=ielec
      nustep=izaehl

      if (ielec.eq.1) then
        iizaehl=0 !total number of steps in souintana
        NZAEHL10=KZAEHL*nelec*nobsvrphi/10
        MZAEHL=NZAEHL10
        IX10=1
      endif

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS     T=-R0*C1

      T=-DT
      TS=-DT

      expom1rphi=ZONE
      DEXPOMPH1=ZONE

      IF (ifreq2p.EQ.0) THEN
        DO JFREQ=1,NFREQ
          EXPOM2P0(1,JFREQ)=ZONE
        ENDDO
      ENDIF

      afferphi=(0.0D0,0.0D0)
      yp2zp2i=0.0d0
c      yp2zp2ia=0.0d0
      f=0.0d0

1000  IZAEHL=IZAEHL+1

      nustep=izaehl

      IF (ISOUR.eq.1.and.IIZAEHL.GE.MZAEHL) THEN
        CALL date_and_time(dtday,dttime,dtzone,idatetime)
        WRITE(6,*)' ',IX10,' ',dttime(1:2),':',dttime(3:4),':',dttime(5:6)
        IX10=IX10+1
        if (ix10.eq.10) then
          mzaehl=NZAEHL10*9.9
        else
          MZAEHL=MZAEHL+NZAEHL10
        endif
      ENDIF

      IF (IROI.LE.NROIA) THEN

        IF (X2.GE.ROIX(IROI)) THEN

          DT=DT0/ROIP(IROI)
          NZAEHL=NINT((TENDSOU-T)/DT)

          IF (ISPECMODE.EQ.1) THEN
            DT=(TENDSOU-T)/(NZAEHL-1)
          ELSE
            DT=(TENDSOU-T)/NZAEHL
          ENDIF

          TENDSOU1=TENDSOU-DT

          DT2=DT/2.D0

          IF (IWARNROI(IROI,ISOUR).EQ.0) THEN

            IF (DT.GT.DTIM00) THEN

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          '*** WARNING IN SOUINTWIGS, SOURCE, ROI:',ISOUR,IROI
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
              WRITE(LUNGFO,*)'SIZE FOR TRAJECTORY!'
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
              WRITE(6,*)
              WRITE(6,*)
     &          '*** WARNING IN SOUINTWIGS, SOURCE, ROI:',ISOUR,IROI
              WRITE(6,*)
              WRITE(6,*)'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
              WRITE(6,*)'SIZE FOR TRAJECTORY!'
              WRITE(6,*)
              WRITE(6,*)
     &          'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
              WRITE(6,*)

              IWARNROI(IROI,ISOUR)=1

            ENDIF !DT

          ENDIF !IWARNROI

          IROI=IROI+1

        ENDIF   !X2

      ENDIF   !IROI

      IPOIROI(IROI)=IPOIROI(IROI)+1

      T=T+DT

      IF (LSTEP.EQ.1) THEN

        IF (X2.LE.XENDSOU) THEN

          DT=(MIN(XENDSOU,XIEND)-X2)/VX2
          DT2=DT/2.0D0

        ELSE

          TS=TS-DT
          T=T-DT

          DT=(MIN(XENDSOU,XIEND)-X1)/VX2
          DT2=DT/2.0D0

          X2=X1
          Y2=Y1
          Z2=Z1

          VX2=VX1
          VY2=VY1
          VZ2=VZ1

          BX2=BX1
          BY2=BY1
          BZ2=BZ1

        ENDIF

      ENDIF

      X1=X2
      Y1=Y2
      Z1=Z2

      VX1=VX2
      VY1=VY2
      VZ1=VZ2

      BX1=BX2
      BY1=BY2
      BZ1=BZ2
      BS1=BS

      IF (ISPECMODE.NE.1) THEN

C GET MAGNETIC FIELD {

        X2B=X1+VX1*DT2
        Y2B=Y1+VY1*DT2
        Z2B=Z1+VZ1*DT2
        norad=0
        if (ibmasksp.ne.0) then
          ibmasksp=-abs(ibmasksp)
          call mybfeld(x2b,y2b,z2b,bx2,by2,bz2,ax2d,ay2d,az2d)
          if ((bx2**2+by2**2+bz2**2).ne.0.0d0) then
            norad=1
          endif
          ibmasksp=-ibmasksp
        endif

        X2=WSOU(1,1,IZAEHL)
        Y2=WSOU(2,1,IZAEHL)
        Z2=WSOU(3,1,IZAEHL)

        VX2=WSOU(1,2,IZAEHL)
        VY2=WSOU(2,2,IZAEHL)
        VZ2=WSOU(3,2,IZAEHL)

        VXP=WSOU(1,3,IZAEHL)
        VYP=WSOU(2,3,IZAEHL)
        VZP=WSOU(3,3,IZAEHL)

        DT=   wsou(1,4,IZAEHL)
        BETA= wsou(2,4,IZAEHL)
        GAMMA=wsou(3,4,IZAEHL)

        bX2=WSOU(1,5,IZAEHL)
        bY2=WSOU(2,5,IZAEHL)
        bZ2=WSOU(3,5,IZAEHL)

        BX=VX2*C1
        BY=VY2*C1
        BZ=VZ2*C1

        BPX=VXP*C1
        BPY=VYP*C1
        BPZ=VZP*C1

C MOVE ONE STEP }

      ELSE  !ISPECMODE

        CALL WAVE_TRACK_INTER(TS,X2,Y2,Z2,VX2,VY2,VZ2,VXP,VYP,VZP,BS,ICSPL,
     &    GAMMA)

        norad=0
        if (ibmasksp.ne.0) then
          ibmasksp=-abs(ibmasksp)
          call mybfeld(x2b,y2b,z2b,bx2,by2,bz2,ax2d,ay2d,az2d)
          if ((bx2**2+by2**2+bz2**2).ne.0.0d0) then
            norad=1
          endif
          ibmasksp=-ibmasksp
        endif

        IF (IENELOSS.NE.0) THEN
          BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.D0+1.0D0/GAMMA))
        ENDIF

        BSQ=BS*BS
        BY2=BSQ

        BX=VX2*C1
        BY=VY2*C1
        BZ=VZ2*C1

        BPX=VXP*C1
        BPY=VYP*C1
        BPZ=VZP*C1

      ENDIF !ISPECMODE

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION {

C REAL PART OF INTEGRAND {

      jvelofield=ivelofield
      nfrq=nfreq
      frq=freq(1:nfreq)
      kungfo=lungfo

!$OMP PARALLEL NUM_THREADS(mthreads) DEFAULT(PRIVATE)
!$OMP& firstprivate(r0,x1,y1,z1,c,c1,om,dom,x2,y2,z2,t,zic,beta,gamma,pi1)
!$OMP& firstprivate(bx,by,bz,bpx,bpy,bpz)
!$OMP& firstprivate(WGANG,nelec,zone,zi,HBAREV1,ZIDOM)
!$OMP& firstprivate(specnor,bunnor,sqnphsp,dexpbunch)
!$OMP& firstprivate(dt,iroi,nidsource,jvelofield,nfrq,kungfo)
!$OMP& SHARED(nobsvrphi,iobunch,isour,ielec,izaehl,nsource)
!$OMP& SHARED(iinside,linside,kinside)
!$OMP& SHARED(phaserphi,expom1rphi,SPECPOWRPHI,afferphi,dphsou)
!$OMP& SHARED(norad,frq,ifreq2p,JWFILINT,IWFILINT,xiend,xianf)
!$OMP& SHARED(IWARNBET1N,BET1NO,obsvrphi)

      ith=OMP_GET_THREAD_NUM()+1

!$OMP DO

      DO JOBSV=1,NOBSVRPHI

        if (jobsv.eq.1.and.iobunch.ne.-9999) then
          iobsv=iobunch
        else if (jobsv.eq.iobunch) then
          iobsv=1
        else
          iobsv=jobsv
        endif

        jliob=ISOUR+NSOURCE*(IOBSV-1)

        XRPHI=OBSVRPHI(1,IOBSV)
        YRPHI=OBSVRPHI(2,IOBSV)*SIN(OBSVRPHI(3,IOBSV))
        ZRPHI=OBSVRPHI(2,IOBSV)*COS(OBSVRPHI(3,IOBSV))

        r=sqrt((xrphi-x1)**2+((yrphi-y1)**2+(zrphi-z1)**2))
        PHASE=(r-r0)*c1 ! needed for phase of field amplitude

        if (izaehl.eq.1) then
          phaserphi(iobsv)=phase
          expom1rphi(iobsv)=cdexp(dcmplx(0.0d0,phaserphi(iobsv)*om))
        endif

        RX=XRPHI-X2
        RY=YRPHI-Y2
        RZ=ZRPHI-Z2

        R=SQRT(RX*RX+RY*RY+RZ*RZ)
        R1=1.D0/R
        ZICR1=ZIC*R1

        RNX=RX*R1
        RNY=RY*R1
        RNZ=RZ*R1

C--- THE DISTANCE R IS INTRODUCED HERE EXPLICITLY (S. PROGRAM OF CHAOEN WANG

        BET1N=(1.0D0-BX*RNX)-BY*RNY-BZ*RNZ
c 20090928{
        br2=by**2+bz**2
        rnr2=rny**2+rnz**2
        b3=beta**3
        br4=br2**2
        rnr4=rnr2**2

        if(br2.lt.1.0d-4.and.rnr2.lt.1.0d-4) then
          bet1n=
     &      1.0d0/(1.0+beta)/gamma**2
     &      +beta*(rnr2/2.0d0
     &      +rnr4/8.0d0)
     &      +(br2/2.0d0
     &      -br2*rnr2/4.0d0
     &      -br2*rnr4/16.0d0)/beta
     &      +b3*br4*(1.0d0/8.0d0
     &      -rnr2/16.0d0
     &      -rnr4/64.0d0)
     &      -by*rny
     &      -bz*rnz
        endif
c }20090928

        OPANG=BX/BETA*RNX+BY/BETA*RNY+BZ/BETA*RNZ

        IF (ABS(OPANG).LE.1.0D0) THEN
          OPANG=ACOS(OPANG)
        ELSE IF (OPANG.GT.1.0D0) THEN
          OPANG=0.0D0
        ELSE
          OPANG=-PI1
        ENDIF

        DUM11=1.0D0/BET1N
        DOM1=1.0D0/(R*BET1N*BET1N)

        IF (IOBSV.EQ.1) THEN
          IF (IZAEHL.EQ.1) THEN
            BET1NO=BET1N
          ELSE IF (iundulator.eq.0.and.(BET1N-BET1NO)/BET1N.GT.0.05.AND.IWARNBET1N.EQ.0) THEN
            WRITE(kungfo,*)
            WRITE(kungfo,*)'*** WARNING IN SOUINTRPHI_OMP  ***'
            WRITE(kungfo,*)'DISCONTINUITY IN INTEGRAND'
            WRITE(kungfo,*)
     &        'Check results carefully, change BMOVECUT, MYINUM, NLPOI etc.'
            WRITE(kungfo,*)
            WRITE(kungfo,*)'ISTEP,X,BET1N,BET1NO:',IZAEHL,SNGL(X1),SNGL(BET1N),SNGL(BET1NO)
            WRITE(kungfo,*)'FURTHER WARNINGS ARE SUPPRESSED!'
            WRITE(kungfo,*)
            WRITE(6,*)
            WRITE(6,*)'*** WARNING IN SOUINTRPHI_OMP  ***'
            WRITE(6,*)'DISCONTINUITY IN INTEGRAND'
            WRITE(6,*)
     &        'Check results carefully, change BMOVECUT, MYINUM, NLPOI etc.'
            WRITE(6,*)
            WRITE(6,*)'ISTEP,X,BET1N,BET1NO:',IZAEHL,SNGL(X1),SNGL(BET1N),SNGL(BET1NO)
            WRITE(6,*)
            WRITE(6,*)'FURTHER WARNINGS ARE SUPPRESSED!'
            WRITE(6,*)
            IWARNBET1N=1
          ENDIF
          BET1NO=BET1N
        ENDIF

        RNBX=RNX-BX
        RNBY=RNY-BY
        RNBZ=RNZ-BZ

        PX=(RNBY*BPZ-RNBZ*BPY)
        PY=(RNBZ*BPX-RNBX*BPZ)
        PZ=(RNBX*BPY-RNBY*BPX)

        IF (jvelofield.EQ.0) THEN !2 WEGEN POWER
          DOM2=C*DOM1*R1/GAMMA**2
          RARG(1)=(RNY*PZ-RNZ*PY)*DOM1+(RNX-BX)*DOM2
          RARG(2)=(RNZ*PX-RNX*PZ)*DOM1+(RNY-BY)*DOM2
          RARG(3)=(RNX*PY-RNY*PX)*DOM1+(RNZ-BZ)*DOM2
        ELSE IF (jvelofield.EQ.1) THEN
          RARG(1)=(RNY*PZ-RNZ*PY)*DOM1
          RARG(2)=(RNZ*PX-RNX*PZ)*DOM1
          RARG(3)=(RNX*PY-RNY*PX)*DOM1
        ELSE IF (jvelofield.LT.0) THEN
          DOM2=C*DOM1*R1/GAMMA**2
          RARG(1)=(RNX-BX)*DOM2
          RARG(2)=(RNY-BY)*DOM2
          RARG(3)=(RNZ-BZ)*DOM2
        ELSE   !jvelofield
          WRITE(6,*)
     &      '*** ERROR IN SOUINTRPHI_OMP: BAD VALUE OF jvelofield  ***'
          WRITE(6,*) '*** PROGRAM WAVE ABORTED  ***'
          STOP
        ENDIF  !jvelofield

        IF (iinside(iobsv).EQ.0.AND.OPANG.LE.WGANG) THEN

          if (iobsv.eq.1) then
            DPHSOU(1,1,ith)=BET1N*DT*frq(1)/HBAREV1
            DPHSOU(1,2,ith)=BET1N*DT*frq(nfrq)/HBAREV1
          endif

          iinside(iobsv)=1
          kinside(iobsv)=1
          linside(iobsv)=linside(iobsv)+1

          IF (linside(iobsv).GT.1) THEN
            WRITE(kungfo,*)
            WRITE(kungfo,*)'*** WARNING IN SOUINTRPHI_OMP  ***'
            WRITE(kungfo,*)'*** SOURCE:',ISOUR
            WRITE(kungfo,*)'STRANGE SOURCE, CONTAINS SEVERAL SOURCES'
            WRITE(kungfo,*)'SOURCE AND OBSERVATION POINT:'
            WRITE(kungfo,*)
     &        ISOUR,OBSVRPHI(1,IOBSV),OBSVRPHI(2,IOBSV),OBSVRPHI(3,IOBSV)
            WRITE(kungfo,*)
     &        'RESULTS OF SPECTRUM CALCULATIONS MAY BE UNRELIABLE'
            WRITE(kungfo,*)'*** CHECK COLLIMATOR, PINHOLE, WGWINFC ... ***'
            WRITE(6,*)
            WRITE(6,*)'*** WARNING IN SOUINTRPHI_OMP  ***'
            WRITE(6,*)'*** SOURCE:',ISOUR
            WRITE(6,*)'*** STRANGE SOURCE, CONTAINS SEVERAL SOURCES'
            WRITE(6,*)'SOURCE AND OBSERVATION POINT:',
     &        ISOUR,OBSVRPHI(1,IOBSV),OBSVRPHI(2,IOBSV),OBSVRPHI(3,IOBSV)
            WRITE(6,*)
            WRITE(6,*)'*** CHECK COLLIMATOR, PINHOLE, WGWINFC ... ***'
            WRITE(6,*)'WARNING OF SPECTRUM CALCULATIONS ARE UNRELIABLE'
            linside(iobsv)=linside(iobsv)-1   !SUPRESS LOTS OF WARNINGS
          ENDIF   !linside(ith)
        ELSE IF (iinside(iobsv).EQ.1.AND.OPANG.GT.WGANG) THEN
          iinside(iobsv)=0
        ENDIF   !iinside(iobsv)

        IF (iinside(iobsv).NE.0) THEN

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS      RARG(4)=T+R*C1

          DPHASE=BET1N*DT

          RARG(4)=phaserphi(iobsv)
          RARG(5)=(RARG(1)*RARG(1)+RARG(2)*RARG(2)+RARG(3)*RARG(3))*DUM11

          if (norad.ne.0) rarg=0.0d0

C REAL PART OF INTEGRAND }

C COMPLEX PART OF INTEGRAND {

C    ASSUMES FREQ(I+1)=2*FREQ(I)   FOR ifreq2p=2
C    OR FREQ(I+1)=FREQ(I)+DELTA    FOR ifreq2p>2

C--- LOOP OVER ALL FREQUENCES

          kfreq=1
          if (nelec.gt.1) then
            dexpbunch=phexp(kfreq)
          else
            dexpbunch=(1.0d0,0.0d0)
          endif

          IFROB=kfreq+nfrq*(IOBSV-1)

          OM=frq(kfreq)/HBAREV1
          ZIOM=ZI*OM

          EXPOM=expom1rphi(iobsv)
          DEXPOMPH1=EXP(ZIOM*DPHASE)
          DEXPOMPH=DEXPOMPH1

          IF(ifreq2p.GT.2) THEN
            DEXPOM=EXP(ZIDOM*phaserphi(iobsv))
            DDEXPOMPH=EXP(ZIDOM*DPHASE)
          ELSE IF(ifreq2p.EQ.0) THEN
            EXPOM2P0(2,kfreq)=EXP(ZIOM*DPHASE)
            EXPOM=EXPOM2P0(1,kfreq)
          ENDIF   !ifreq2p

          IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN

            SPECPOWRPHI(jliob)=SPECPOWRPHI(jliob)+RARG(5)*DT

            DO ICOMP=1,3
              daff(icomp)=RARG(ICOMP)/BET1N/OM*EXPOM*(ZONE-DEXPOMPH)*DEXPbunch/sqnphsp
              afferphi(icomp,ifrob)=afferphi(icomp,ifrob)+daff(icomp)
            ENDDO   !ICOMP

            baff(1)=(rny*daff(3)-rnz*daff(2))
            baff(2)=(rnz*daff(1)-rnx*daff(3))
            baff(3)=(rnx*daff(2)-rny*daff(1))

            afferphi(4:6,ifrob)=afferphi(4:6,ifrob)+baff(1:3)/clight1

          ENDIF   !XIANF

          IF (IWFILINT.NE.0) THEN
            IF (MOD(IZAEHL,JWFILINT).EQ.0) THEN
              IF (IWFILINT.LT.0) THEN
                FILLT(1)=T
                FILLT(2)=X2
                FILLT(3)=Y2
                FILLT(4)=Z2
                FILLT(5)=RARG(1)
                FILLT(6)=RARG(2)
                FILLT(7)=RARG(3)
                FILLT(8)=RARG(4)
                FILLT(9)=RARG(5)
                FILLT(10)=dREAL(EXPOM)
                FILLT(11)=dIMAG(EXPOM)
                FILLT(12)=IROI-1
                FILLT(13)=IOBSV
                FILLT(14)=kfreq
                FILLT(17)=BET1N
                FILLT(18)=OM
                FILLT(19)=DT
                FILLT(20)=BY2
                FILLT(21)=ISOUR
                FILLT(15)=YRPHI
                FILLT(16)=ZRPHI
                FILLT(22)=
     &            (
     &            REAL(afferphi(1,ifrob))*REAL(afferphi(1,ifrob))
     &            +IMAG(afferphi(1,ifrob))*IMAG(afferphi(1,ifrob))
     &            +REAL(afferphi(2,ifrob))*REAL(afferphi(2,ifrob))
     &            +IMAG(afferphi(2,ifrob))*IMAG(afferphi(2,ifrob))
     &            +REAL(afferphi(3,ifrob))*REAL(afferphi(3,ifrob))
     &            +IMAG(afferphi(3,ifrob))*IMAG(afferphi(3,ifrob))
     &            )*SPECNOR*bunnor
                FILLT(23)=dREAL(afferphi(1,ifrob))*SPECNOR*bunnor
                FILLT(24)=dIMAG(afferphi(1,ifrob))*SPECNOR*bunnor
                FILLT(25)=dREAL(afferphi(2,ifrob))*SPECNOR*bunnor
                FILLT(26)=dIMAG(afferphi(2,ifrob))*SPECNOR*bunnor
                FILLT(27)=dREAL(afferphi(3,ifrob))*SPECNOR*bunnor
                FILLT(28)=dIMAG(afferphi(3,ifrob))*SPECNOR*bunnor
                FILLT(29)=DOM1

                FILLT(30)=bx
                FILLT(31)=by
                FILLT(32)=bz
                FILLT(33)=bpx
                FILLT(34)=bpy
                FILLT(35)=bpz
c                ef(1:3)=real(afferphi(1:3,ifrob))
c                bf(1:3)=real(afferphi(4:6,ifrob))
c                rnx=ef(2)*bf(3)-ef(3)*bf(2)
c                rny=ef(3)*bf(1)-ef(1)*bf(3)
c                rnz=ef(1)*bf(2)-ef(2)*bf(1)
                rnx=real(
     &            afferphi(2,ifrob)*conjg(afferphi(6,ifrob))-
     &            afferphi(3,ifrob)*conjg(afferphi(5,ifrob)))
                rny=real(
     &            afferphi(3,ifrob)*conjg(afferphi(4,ifrob))-
     &            afferphi(1,ifrob)*conjg(afferphi(6,ifrob)))
                rnz=real(
     &            afferphi(1,ifrob)*conjg(afferphi(5,ifrob))-
     &            afferphi(2,ifrob)*conjg(afferphi(4,ifrob)))
                rn=sqrt(rnx**2+rny**2+rnz**2)
                FILLT(36)=rnx/rn
                FILLT(37)=rny/rn
                FILLT(38)=rnz/rn

                CALL hfm(NIDSOURCE,FILLT)

              ELSE IF (ISOUR.EQ.IWFILINT.AND.IOBSV.EQ.1) THEN

                WRITE(LUNINT,*) IZAEHL,kfreq,X2
                WRITE(LUNINT,*) (RARG(1),IC=1,3)
                WRITE(LUNINT,*) RARG(4)*OM,RARG(5)
                WRITE(LUNINT,*)REAL(EXPOM),IMAG(EXPOM)
                WRITE(LUNINT,*)RARG(1)*REAL(EXPOM),RARG(1)*IMAG(EXPOM)
                WRITE(LUNINT,*)RARG(2)*REAL(EXPOM),RARG(2)*IMAG(EXPOM)
                WRITE(LUNINT,*)RARG(3)*REAL(EXPOM),RARG(3)*IMAG(EXPOM)

              ENDIF !IWFILINT.LT.0
            ENDIF !JFILINT
          ENDIF !IWFILINT.NE.0

          DO kfreq=2,nfrq

            IFROB=kfreq+nfrq*(IOBSV-1)

            IF (ifreq2p.GT.2) THEN
              OM=OM+DOM
              EXPOM=EXPOM*DEXPOM
              DEXPOMPH=DEXPOMPH*DDEXPOMPH
            ELSE IF(ifreq2p.EQ.2) THEN
              OM=OM*2.0D0
              EXPOM=EXPOM*EXPOM
              DEXPOMPH=DEXPOMPH*DEXPOMPH
            ELSE IF(ifreq2p.EQ.0) THEN
              OM=frq(kfreq)/HBAREV1
              ZIOM=ZI*OM
              EXPOM2P0(2,kfreq)=EXP(ZIOM*DPHASE)
              EXPOM=EXPOM2P0(1,kfreq)
              DEXPOMPH=EXPOM2P0(2,kfreq)
            ELSE
              OM=frq(kfreq)/HBAREV1
              ZIOM=ZI*OM
              DEXPOMPH=EXP(ZIOM*DPHASE)
            ENDIF

            if (nelec.gt.1) then
              dexpbunch=phexp(kfreq)
            endif

            IF (X2.GE.XIANF.AND.X2.LE.XIEND.and.norad.eq.0) THEN
              EXPOMV2=1.0D0/BET1N/OM*EXPOM*(ZONE-DEXPOMPH)

              DO ICOMP=1,3
                daff(icomp)=RARG(ICOMP)*EXPOMV2*DEXPbunch/sqnphsp
c                print*,izaehl,ifrob,icomp,RARG(ICOMP),EXPOMV2,DEXPbunch,sqnphsp
c                print*,daff
                afferphi(ICOMP,ifrob)=afferphi(ICOMP,ifrob)+daff(icomp)
              ENDDO

              baff(1)=(rny*daff(3)-rnz*daff(2))
              baff(2)=(rnz*daff(1)-rnx*daff(3))
              baff(3)=(rnx*daff(2)-rny*daff(1))

              afferphi(4:6,ifrob)=afferphi(4:6,ifrob)+baff(1:3)/clight1

            ENDIF !XIEND

            IF (IWFILINT.NE.0) THEN
              IF (MOD(IZAEHL,JWFILINT).EQ.0) THEN
                IF (IWFILINT.LT.0) THEN
                  FILLT(1)=T
                  FILLT(2)=X2
                  FILLT(3)=Y2
                  FILLT(4)=Z2
                  FILLT(5)=RARG(1)
                  FILLT(6)=RARG(2)
                  FILLT(7)=RARG(3)
                  FILLT(8)=RARG(4)
                  FILLT(9)=RARG(5)
                  FILLT(10)=dREAL(EXPOM)
                  FILLT(11)=dIMAG(EXPOM)
                  FILLT(12)=IROI-1
                  FILLT(13)=IOBSV
                  FILLT(14)=kfreq
                  FILLT(17)=BET1N
                  FILLT(18)=OM
                  FILLT(19)=DT
                  FILLT(20)=BY2
                  FILLT(21)=ISOUR
                  FILLT(15)=YRPHI
                  FILLT(16)=ZRPHI
                  FILLT(22)=
     &              (
     &              REAL(afferphi(1,ifrob))*REAL(afferphi(1,ifrob))
     &              +IMAG(afferphi(1,ifrob))*IMAG(afferphi(1,ifrob))
     &              +REAL(afferphi(2,ifrob))*REAL(afferphi(2,ifrob))
     &              +IMAG(afferphi(2,ifrob))*IMAG(afferphi(2,ifrob))
     &              +REAL(afferphi(3,ifrob))*REAL(afferphi(3,ifrob))
     &              +IMAG(afferphi(3,ifrob))*IMAG(afferphi(3,ifrob))
     &              )*SPECNOR*bunnor
                  FILLT(23)=dREAL(afferphi(1,ifrob))*SPECNOR*bunnor
                  FILLT(24)=dIMAG(afferphi(1,ifrob))*SPECNOR*bunnor
                  FILLT(25)=dREAL(afferphi(2,ifrob))*SPECNOR*bunnor
                  FILLT(26)=dIMAG(afferphi(2,ifrob))*SPECNOR*bunnor
                  FILLT(27)=dREAL(afferphi(3,ifrob))*SPECNOR*bunnor
                  FILLT(28)=dIMAG(afferphi(3,ifrob))*SPECNOR*bunnor
                  FILLT(29)=DOM1
                  FILLT(30)=bx
                  FILLT(31)=by
                  FILLT(32)=bz
                  FILLT(33)=bpx
                  FILLT(34)=bpy
                  FILLT(35)=bpz
c                ef(1:3)=real(afferphi(1:3,ifrob))
c                bf(1:3)=real(afferphi(4:6,ifrob))
c                rnx=ef(2)*bf(3)-ef(3)*bf(2)
c                rny=ef(3)*bf(1)-ef(1)*bf(3)
c                rnz=ef(1)*bf(2)-ef(2)*bf(1)
                  rnx=real(
     &              afferphi(2,ifrob)*conjg(afferphi(6,ifrob))-
     &              afferphi(3,ifrob)*conjg(afferphi(5,ifrob)))
                  rny=real(
     &              afferphi(3,ifrob)*conjg(afferphi(4,ifrob))-
     &              afferphi(1,ifrob)*conjg(afferphi(6,ifrob)))
                  rnz=real(
     &              afferphi(1,ifrob)*conjg(afferphi(5,ifrob))-
     &              afferphi(2,ifrob)*conjg(afferphi(4,ifrob)))
                  rn=sqrt(rnx**2+rny**2+rnz**2)
                  FILLT(36)=rnx/rn
                  FILLT(37)=rny/rn
                  FILLT(38)=rnz/rn

                  CALL hfm(NIDSOURCE,FILLT)

                ELSE IF (ISOUR.EQ.IWFILINT.AND.IOBSV.EQ.1) THEN

                  WRITE(LUNINT,*) IZAEHL,kfreq,X2
                  WRITE(LUNINT,*) (RARG(1),IC=1,3)
                  WRITE(LUNINT,*) RARG(4)*OM,RARG(5)
                  WRITE(LUNINT,*)REAL(EXPOM),IMAG(EXPOM)
                  WRITE(LUNINT,*)RARG(1)*REAL(EXPOM),RARG(1)*IMAG(EXPOM)
                  WRITE(LUNINT,*)RARG(2)*REAL(EXPOM),RARG(2)*IMAG(EXPOM)
                  WRITE(LUNINT,*)RARG(3)*REAL(EXPOM),RARG(3)*IMAG(EXPOM)

                ENDIF !IWFILINT.LT.0
              ENDIF !JWFILINT
            ENDIF !IWFILINT.NE.0

          ENDDO   !LOOP OVER ALL FREQUENCES
        ENDIF   !iinside(iobsv)

C COMPLEX PART OF INTEGRAND }

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION }

        phase=phaserphi(iobsv)
        phaserphi(iobsv)=phaserphi(iobsv)+DPHASE
        expom1rphi(iobsv)=expom1rphi(iobsv)*DEXPOMPH1

        IF(ifreq2p.EQ.0) THEN

          DO JFREQ=1,nfrq
            OM=frq(JFREQ)/HBAREV1
            ZIOM=ZI*OM
            EXPOM2P0(1,JFREQ)=EXPOM2P0(1,JFREQ)*EXPOM2P0(2,JFREQ)
          ENDDO
        ENDIF

        IF (iinside(iobsv).NE.0.and.iobsv.eq.1) THEN
          DPHSOU(2,1,ith)=BET1N*DT*frq(1)/HBAREV1
          DPHSOU(2,2,ith)=BET1N*DT*frq(nfrq)/HBAREV1
        ENDIF

      ENDDO !IOBSV=1,NOBSVRPHI

!$OMP END DO
!$OMP END PARALLEL

      IIZAEHL=IIZAEHL+nobsvrphi !total step counter

      TS=TS+DT

C--- END OF LOOP OVER TIME STEPS

c      yp2zp2ia=yp2zp2ia
c     &  +((vy1/vx1)**2+(vy2/vx2)**2+(vz1/vx1)**2+(vz2/vx2)**2)*beta*clight1*dt2

      f(3)=((vy2/vx2)**2+(vz2/vx2)**2)
      fdt(3)=dt

      if (lstep.eq.1) then
        yp(1)=(f(2)-f(1))/fdt(2)
        yp(3)=(f(3)-f(2))/fdt(3)
        yp(2)=(yp(3)+yp(1))/2.0d0
        ypp=(yp(3)-yp(1))/(fdt(2)+fdt(3))*2.0d0
        a(3)=ypp/2.0d0
        a(2)=yp(2)-2.0d0*a(3)*fdt(2)
        a(1)=f(2)-a(2)*fdt(2)-a(3)*fdt(2)**2
        dfdt=fdt(2)+fdt(3)
        fihi=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        dfdt=0.0d0
        filo=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        yp2zp2i=yp2zp2i+fihi-filo
        yp2zp2i=yp2zp2i*beta*clight1
      else if (izaehl.ge.3) then
        yp(1)=(f(2)-f(1))/fdt(2)
        yp(3)=(f(3)-f(2))/fdt(3)
        yp(2)=(yp(3)+yp(1))/2.0d0
        ypp=(yp(3)-yp(1))/(fdt(2)+fdt(3))*2.0d0
        a(3)=ypp/2.0d0
        a(2)=yp(2)-2.0d0*a(3)*fdt(2)
        a(1)=f(2)-a(2)*fdt(2)-a(3)*fdt(2)**2
        dfdt=fdt(2)+fdt(3)
        fihi=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        dfdt=fdt(2)
        filo=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        yp2zp2i=yp2zp2i+fihi-filo
      endif

      f(1)=f(2)
      fdt(1)=fdt(2)
      f(2)=f(3)
      fdt(2)=fdt(3)

c      stop "Ende"
      if (ispecmode.eq.2) then
        if (izaehl.lt.ipoisou(isour)) goto 1000
      else
        IF (X2.LT.XENDSOU-VX2*DT.AND.X2.LT.(XIEND-VX2*DT).AND.LSTEP.EQ.0)
     &    GOTO 1000
        IF (LSTEP.EQ.0) THEN
          LSTEP=1
          GOTO 1000
        ENDIF
      endif

      IF (IAMPLI.LT.0) THEN

        if (nelec.eq.1) then
          print*,' '
          print*,'Starting phase repetition, counting from one to 10 to show progress:'
          print*,' '
        endif

        DXEXI=MIN(SOURCEEO(1,1,ISOUR),XIEND)
     &    -MAX(SOURCEAO(1,1,ISOUR),XIANF)
        if (ampr2corr.eq.-9999.0d0) ampr2corr=dxexi
        CENXEXI=(MIN(SOURCEEO(1,1,ISOUR),XIEND)
     &    +MAX(SOURCEAO(1,1,ISOUR),XIANF))/2.D0
        GAMGAM0=(SOURCEG(1,1,ISOUR)*(egamma/dmygamma))**2
        GAMGAM=(
     &    (SOURCEG(1,1,ISOUR)+SOURCEG(2,2,ISOUR))*(egamma/dmygamma)
     &    )**2

        XRPHI=OBSVRPHI(1,1)

        slopein=sqrt(vyin**2+vzin**2)/vxin
        slope=sqrt(vyelec**2+vzelec**2)/vxelec

        if (myinum.gt.nlpoi/dxexi) then
          WI=(WTRA2IS(ISOUR)
     &      -DXEXI/2.0D0*slopein**2) !wi is detour for on-axis particle
     &      *(dmygamma/egamma)**2
        else
          if (iwarnwi.eq.0) then
            write(lungfo,*)
            write(lungfo,*)'*** Warning in SOUINTANA:'
            write(lungfo,*)'*** MYINUM is rather small with respect to NLPOI'
            write(lungfo,*)'*** Length of trajectories are now calculated by simple'
            write(lungfo,*)'*** integration with SOUINTANA, which might be poor'
            write(lungfo,*)
            write(lungfo,*)
            write(6,*)'*** Warning in SOUINTANA:'
            write(6,*)'*** MYINUM is rather small with respect to NLPOI'
            write(6,*)'*** Length of trajectories are now calculated by simple'
            write(6,*)'*** integration with SOUINTANA, which might be poor'
            write(6,*)
            iwarnwi=1
          endif
          wi=(yp2zp2i/2.0d0
     &      -DXEXI/2.0D0*slopein**2) !wi is detour for on-axis particle
     &      *(dmygamma/egamma)**2
        endif

        xn1=cenxexi
        yn1=(xn1-cenxexi)*vyelec/vxelec
        zn1=(xn1-cenxexi)*vyelec/vxelec

        drn2=(
     &    (yn1+dxexi*vyelec/vxelec)**2+
     &    (zn1+dxexi*vzelec/vxelec)**2
     &    )/
     &    (2.0d0*(xrphi-xn1-dxexi))

        drn1=(
     &    yn1**2+
     &    zn1**2
     &    )/
     &    (2.0d0*(xrphi-xn1))

        DTPHASE=(
     &    WI+DXEXI*(slope**2/2.0d0+1.0d0/(2.0D0*GAMGAM0))
     &    +drn2-drn1)
     &    /CLIGHT1*GAMGAM0/GAMGAM

        AMPDT=AMPSHIFT(1)/CLIGHT1/2.0D0/GAMGAM0
        FREQR=2.0D0*PI1/DTPHASE*HBAREV1

        ICOUNT=0
        NCOUNT=NFREQ*NOBSVRPHI*ABS(IAMPLI)
        NCOUNT10=NCOUNT/10
        MCOUNT=NCOUNT10
        N10=0

      ENDIF !IAMPLI

      DO kfreq=1,NFREQ

        DO IOBSV=1,NOBSVRPHI

          jliobfr=ISOUR+NSOURCE*(IOBSV-1+NOBSVRPHI*(kfreq-1))
          IFROB=kfreq+NFREQ*(IOBSV-1)
          jobfr=IOBSV+NOBSVRPHI*(kfreq-1)

          IF (IAMPLI.LT.0) THEN

            YRPHI=OBSVRPHI(2,IOBSV)*SIN(OBSVRPHI(3,IOBSV))
            ZRPHI=OBSVRPHI(2,IOBSV)*COS(OBSVRPHI(3,IOBSV))

            OM=frq(kfreq)/HBAREV1

            AX0=afferphi(1,ifrob)
            AY0=afferphi(2,ifrob)
            AZ0=afferphi(3,ifrob)

            AX=AX0
            AY=AY0
            AZ=AZ0

            BX0=afferphi(4,ifrob)
            BY0=afferphi(5,ifrob)
            BZ0=afferphi(6,ifrob)

            BX=BX0
            BY=BY0
            BZ=BZ0

            afferphi(1:6,ifrob)=(0.0D0,0.0D0)

            R0=XRPHI-CENXEXI
            R02=R0*R0
            R00=R0

            xn1=cenxexi
            yn1=(xn1-cenxexi)*vyelec/vxelec
            zn1=(xn1-cenxexi)*vzelec/vxelec

            drn2=(
     &        (yn1+dxexi*vyelec/vxelec-yrphi)**2+
     &        (zn1+dxexi*vzelec/vxelec-zrphi)**2
     &        )/
     &        (2.0d0*(xrphi-xn1-dxexi))

            drn1=(
     &        (yn1-yrphi)**2+
     &        (zn1-zrphi)**2
     &        )/
     &        (2.0d0*(xrphi-xn1))

          DTPHASE=(
     &      WI+DXEXI*(slope**2/2.0d0+1.0d0/(2.0D0*GAMGAM0))
     &      +drn2-drn1)
     &      /CLIGHT1*GAMGAM0/GAMGAM
     &      +AMPDT

            PHI=2.D0*PI1*frq(kfreq)*ECHARGE1/HPLANCK1*DTPHASE

            DMODU=EXP(ZI*PHI)
            DMODU0=DMODU
            DDMODU=ZONE

            DO I=1,-IAMPLI

              R0=xrphi+DXEXI/2.D0*(-IAMPLI-2*(I-1)-1)-CENXEXI
              CORRR0=R00/R0
            !corrects for mistake of averaging over 1/r2, if e.g.
            !the repeated device is a long undulator
     &        *(R0/(R0-ampr2corr/2.0d0))**2
              R02=R0*R0

              xn1=cenxexi-dxexi/2.d0*(-iampli-2*(i-1)-1)
     &          *((R0-ampr2corr/2.0d0)/R0)**2 !empirically, due to depth of field
              yn1=(xn1-cenxexi)*vyelec/vxelec
              zn1=(xn1-cenxexi)*vzelec/vxelec

              drn2=(
     &          (yn1+dxexi*vyelec/vxelec-yrphi)**2+
     &          (zn1+dxexi*vzelec/vxelec-zrphi)**2
     &          )/
     &          (2.0d0*(xrphi-xn1-dxexi))

              drn1=(
     &          (yn1-yrphi)**2+
     &          (zn1-zrphi)**2
     &          )/
     &          (2.0d0*(xrphi-xn1))

              DTPHASE=(
     &          WI+DXEXI*(slope**2/2.0d0+1.0d0/(2.0D0*GAMGAM0))
     &          +drn2-drn1)
     &          /CLIGHT1*GAMGAM0/GAMGAM
     &          +AMPDT

              PHI=2.D0*PI1*frq(kfreq)*ECHARGE1/HPLANCK1*DTPHASE

              DMODU=EXP(ZI*PHI)
              DMODU0=DMODU
              DDMODU=ZONE

              afferphi(1,ifrob)=afferphi(1,ifrob)+AX
              afferphi(2,ifrob)=afferphi(2,ifrob)+AY
              afferphi(3,ifrob)=afferphi(3,ifrob)+AZ

              afferphi(4,ifrob)=afferphi(1,ifrob)+BX
              afferphi(5,ifrob)=afferphi(2,ifrob)+BY
              afferphi(6,ifrob)=afferphi(3,ifrob)+BZ

              IF (AMPRAN.NE.0.D0) THEN
                PHI=2.D0*PI1*XRANA(I)/FREQR*frq(kfreq)
                DDMODU=EXP(ZI*PHI)
              ENDIF   !(AMPRAN.NE.0.D0)

              AX0=AX0*DMODU0
              AY0=AY0*DMODU0
              AZ0=AZ0*DMODU0

              AX=AX0*CORRR0
              AY=AY0*CORRR0
              AZ=AZ0*CORRR0

              DMODU=DMODU0*DDMODU
              AX=AX*DMODU
              AY=AY*DMODU
              AZ=AZ*DMODU

              BX0=BX0*DMODU0
              BY0=BY0*DMODU0
              BZ0=BZ0*DMODU0

              BX=BX0*CORRR0
              BY=BY0*CORRR0
              BZ=BZ0*CORRR0

              BX=BX*DMODU
              BY=BY*DMODU
              BZ=BZ*DMODU

              IF (kfreq.EQ.1) THEN
                jliob=ISOUR+NSOURCE*(IOBSV-1)
                IF (I.EQ.1) THEN
                  POW=SPECPOWRPHI(jliob)
                  SPECPOWRPHI(jliob)=0.0D0
                ENDIF !(I.EQ.1) THEN
                R02=(OBSVRPHI(1,IOBSV)-CENXEXI)**2
     &            +OBSVRPHI(2,IOBSV)**2+OBSVRPHI(3,IOBSV)**2
                R2=(OBSVRPHI(1,IOBSV)-CENXEXI-DXEXI*(I-ABS(IAMPLI)/2+1))**2
     &            +OBSVRPHI(2,IOBSV)**2+OBSVRPHI(3,IOBSV)**2
                SPECPOWRPHI(jliob)=SPECPOWRPHI(jliob)+POW*R02/R2
     &            *R2/(sqrt(R2)-ampr2corr/2.0d0)**2/nelec
              ENDIF !kfreq.EQ.1

              ICOUNT=ICOUNT+1
              IF (nelec.eq.1.and.ICOUNT.EQ.MCOUNT) THEN
                N10=N10+1
                CALL date_and_time(dtday,dttime,dtzone,idatetime)
                WRITE(6,*)' ',N10,ICOUNT/(NFREQ*NOBSVRPHI),' ',
     &            dttime(1:2),':',dttime(3:4),':',dttime(5:6)
                MCOUNT=MCOUNT+NCOUNT10
                IF (N10.EQ.9) MCOUNT=NCOUNT
              ENDIF

            ENDDO !IAMPLI

          ENDIF   !(IAMPLI.LT.0)

          if (ihbunch.ne.0.and.iobsv.eq.1) then
            fillb(1)=ibun
            fillb(2)=isub
            fillb(3)=ielec
            fillb(4)=bunchx
            fillb(5)=xelec
            fillb(6)=yelec
            fillb(7)=zelec
            fillb(8)=vyelec/vxelec
            fillb(9)=vzelec/vxelec
            fillb(10)=x2
            fillb(11)=y2
            fillb(12)=z2
            fillb(13)=vy2/vx2
            fillb(14)=vz2/vx2
            fillb(15)=egamma*emassg1
            fillb(16)=gamma*emassg1
            fillb(17)=OBSVRPHI(1,IOBSV)
            fillb(18)=OBSVRPHI(2,IOBSV)*SIN(OBSVRPHI(3,IOBSV))
            fillb(19)=OBSVRPHI(2,IOBSV)*COS(OBSVRPHI(3,IOBSV))
            fillb(20)=kfreq
            fillb(21)=frq(kfreq)
            speck=
     &        DREAL(
     &        afferphi(1,IFROB)*CONJG(afferphi(1,IFROB))
     &        +afferphi(2,IFROB)*CONJG(afferphi(2,IFROB))
     &        +afferphi(3,IFROB)*CONJG(afferphi(3,IFROB))
     &        )*specnor*bunnor
            fillb(22)=speck*nelec

            if (istokes.ne.0) then

              APOLH=
     &          afferphi(1,IFROB)*CONJG(VSTOKES(1,1))
     &          +afferphi(2,IFROB)*CONJG(VSTOKES(1,2))
     &          +afferphi(3,IFROB)*CONJG(VSTOKES(1,3))

              APOLR=
     &          afferphi(1,IFROB)*CONJG(VSTOKES(2,1))
     &          +afferphi(2,IFROB)*CONJG(VSTOKES(2,2))
     &          +afferphi(3,IFROB)*CONJG(VSTOKES(2,3))

              APOLL=
     &          afferphi(1,IFROB)*CONJG(VSTOKES(3,1))
     &          +afferphi(2,IFROB)*CONJG(VSTOKES(3,2))
     &          +afferphi(3,IFROB)*CONJG(VSTOKES(3,3))

              APOL45=
     &          afferphi(1,IFROB)*CONJG(VSTOKES(4,1))
     &          +afferphi(2,IFROB)*CONJG(VSTOKES(4,2))
     &          +afferphi(3,IFROB)*CONJG(VSTOKES(4,3))

              STOK1=
     &          APOLR*CONJG(APOLR)+
     &          APOLL*CONJG(APOLL)

              STOK2=-STOK1+
     &          2.0d0*APOLH*CONJG(APOLH)

              STOK3=
     &          2.0d0*APOL45*CONJG(APOL45)-
     &          STOK1

              STOK4=
     &          APOLR*CONJG(APOLR)-
     &          APOLL*CONJG(APOLL)

              fillb(23)=stok1*specnor*bunnor*nelec
              fillb(24)=stok2*specnor*bunnor*nelec
              fillb(25)=stok3*specnor*bunnor*nelec
              fillb(26)=stok4*specnor*bunnor*nelec

            else
              fillb(23)=fillb(22)
              fillb(24:26)=0.0d0
            endif !istokes

            call hfm(nidbunch,fillb)
            fillb(27)=specpowrphi(isour)*pownor*bunnor*nelec
            fillb(28)=isour
            fillb(29)=t2
          endif ! iobsv=1

          if (
     &        (ibunphase.eq.1.and.ielec.eq.1.and.iobunch.eq.-9999)
     &        .or.
     &        isub.eq.neinbunch
     &        ) then
            are(1:6)=dreal(afferphi(1:6,ifrob))
            aim(1:6)=dimag(afferphi(1:6,ifrob))
            ampz(kfreq)=sqrt(are(3)**2+aim(3)**2)
            if (ampz(kfreq).gt.ampzmax(kfreq)) then
              ampzmax(kfreq)=ampz(kfreq)
              kobs(kfreq)=iobsv
            endif
          endif

        ENDDO !NOBSVRPHI

        if (ibunphase.eq.1
     &    .or.isub.eq.neinbunch
     &    ) then
          ifrob=kfreq+nfreq*(kobs(kfreq)-1)
          are(1:6)=dreal(afferphi(1:6,ifrob))
          aim(1:6)=dimag(afferphi(1:6,ifrob))
          ampz(kfreq)=sqrt(are(3)**2+aim(3)**2)
          if (ampz(kfreq).ne.0.0d0) then
            azcos(kfreq)=are(3)/ampz(kfreq)
            azsin(kfreq)=aim(3)/ampz(kfreq)
          else
            azcos(kfreq)=1.0d0
            azsin(kfreq)=0.0d0
          endif
        endif

        DO IOBSV=1,NOBSVRPHI

          ifrob=kfreq+nfreq*(iobsv-1)

          if (ibunphase.eq.1) then
            are(1:6)=dreal(afferphi(1:6,ifrob))
            aim(1:6)=dimag(afferphi(1:6,ifrob))

            afferphi(1:6,ifrob)=dcmplx(
     &        azcos(kfreq)*are+azsin(kfreq)*aim,
     &        -azsin(kfreq)*are+azcos(kfreq)*aim
     &        )
          endif

          unphrphi(1:6,ifrob)=unphrphi(1:6,ifrob)+afferphi(1:6,ifrob)

          if (isub.eq.neinbunch) then

cold *** This does not work, we really need to call cyltocart for each bunch
cold            if (ibunphase.eq.0) then
cold
coldc destroy phase information between bunches by synchronization
cold
cold
ccold if ibunphase.ne.0, we have done it already
cold              are(1:3)=dreal(unphrphi(1:3,ifrob))
cold              aim(1:3)=dimag(unphrphi(1:3,ifrob))
cold
cold              unphrphi(1:3,ifrob)=dcmplx(
cold     &          azcos(kfreq)*are+azsin(kfreq)*aim,
cold     &          -azsin(kfreq)*are+azcos(kfreq)*aim
cold     &          )
cold            endif

            afreqrphi(1:6,ifrob)=afreqrphi(1:6,ifrob)
     &        +unphrphi(1:6,ifrob)
cold     &        *sqbunnor

            unphrphi(1,IFROB)=(0.0d0,0.0d0)
            unphrphi(2,IFROB)=(0.0d0,0.0d0)
            unphrphi(3,IFROB)=(0.0d0,0.0d0)

          endif !isub.eq.neinbunch

        ENDDO !NOBSVRPHI

      ENDDO !kfreq

cold      if (ielec.ne.nelec) return
      if (isub.ne.neinbunch) return

      call cyltocart(isour)

      do iobsv=1,nobsv

        do kfreq=1,nfreq

          jliobfr=isour+nsource*(iobsv-1+nobsv*(kfreq-1))
          ifrob=kfreq+nfreq*(iobsv-1)
          jobfr=iobsv+nobsv*(kfreq-1)

          om=frq(kfreq)/hbarev1

          if(speccut.gt.0.0d0) then
            if (ispecmode.eq.1) ecmaxs=ecmax(isour)
            if(frq(kfreq).gt.speccut*ecdipev1*dmyenergy**2*ecmaxs) then
              afreq(1:6,ifrob)=(0.0d0,0.0d0)
            endif
          endif

          afreq(1:3,ifrob)=afreq(1:3,ifrob)*reflec(1:3)
          afreq(4:6,ifrob)=afreq(4:6,ifrob)*reflec(1:3)

          if (ipola.eq.0) then

            spec(jliobfr)=spec(jliobfr)+
     &        dreal(
     &        afreq(1,ifrob)*conjg(afreq(1,ifrob))
     &        +afreq(2,ifrob)*conjg(afreq(2,ifrob))
     &        +afreq(3,ifrob)*conjg(afreq(3,ifrob))
     &        )*specnor*bunnor

            reaima(1:3,1,jobfr)=reaima(1:3,1,jobfr)+
     &        dreal(afreq(1:3,ifrob))/sqnbunch
            reaima(1:3,2,jobfr)=reaima(1:3,2,jobfr)+
     &        dimag(afreq(1:3,ifrob))/sqnbunch

            reaima(8:10,1,jobfr)=reaima(8:10,1,jobfr)+
     &        dreal(afreq(4:6,ifrob))/sqnbunch
            reaima(8:10,2,jobfr)=reaima(8:10,2,jobfr)+
     &        dimag(afreq(4:6,ifrob))/sqnbunch

          else    !ipola

            apol=
     &        afreq(1,ifrob)*conjg(vpola(1))
     &        +afreq(2,ifrob)*conjg(vpola(2))
     &        +afreq(3,ifrob)*conjg(vpola(3))

            spec(jliobfr)=spec(jliobfr)+
     &        dreal(apol*conjg(apol))*specnor*bunnor

            reaima(1:3,1,jobfr)=reaima(1:3,1,jobfr)+
     &        dreal(afreq(1:3,ifrob))/sqnbunch
            reaima(1:3,2,jobfr)=reaima(1:3,2,jobfr)+
     &        dimag(afreq(1:3,ifrob))/sqnbunch

            reaima(8:10,1,jobfr)=reaima(8:10,1,jobfr)+
     &        dreal(afreq(4:6,ifrob))/sqnbunch
            reaima(8:10,2,jobfr)=reaima(8:10,2,jobfr)+
     &        dimag(afreq(4:6,ifrob))/sqnbunch

          endif   !ipola

          if (istokes.ne.0) then

            apolh=
     &        afreq(1,ifrob)*conjg(vstokes(1,1))
     &        +afreq(2,ifrob)*conjg(vstokes(1,2))
     &        +afreq(3,ifrob)*conjg(vstokes(1,3))

            apolr=
     &        afreq(1,ifrob)*conjg(vstokes(2,1))
     &        +afreq(2,ifrob)*conjg(vstokes(2,2))
     &        +afreq(3,ifrob)*conjg(vstokes(2,3))

            apoll=
     &        afreq(1,ifrob)*conjg(vstokes(3,1))
     &        +afreq(2,ifrob)*conjg(vstokes(3,2))
     &        +afreq(3,ifrob)*conjg(vstokes(3,3))

            apol45=
     &        afreq(1,ifrob)*conjg(vstokes(4,1))
     &        +afreq(2,ifrob)*conjg(vstokes(4,2))
     &        +afreq(3,ifrob)*conjg(vstokes(4,3))

            stok1=
     &        apolr*conjg(apolr)+
     &        apoll*conjg(apoll)

            stok2=-stok1+
     &        2.*apolh*conjg(apolh)

            stok3=
     &        2.*apol45*conjg(apol45)-
     &        stok1

            stok4=
     &        apolr*conjg(apolr)-
     &        apoll*conjg(apoll)

            stokes(1,jobfr)=stokes(1,jobfr)+
     &        stok1*specnor*bunnor

            stokes(2,jobfr)=stokes(2,jobfr)+
     &        stok2*specnor*bunnor

            stokes(3,jobfr)=stokes(3,jobfr)+
     &        stok3*specnor*bunnor

            stokes(4,jobfr)=stokes(4,jobfr)+
     &        stok4*specnor*bunnor

          endif   !istokes

          afreq(1:6,ifrob)=(0.0d0,0.0d0)

        enddo !kfreq

        jliob=isour+nsource*(iobsv-1)
        specpow(jliob)=specpow(jliob)*pownor

      enddo !nobsv


      if (mpinr.ne.0) then

c only used for Ntuple 5700 so far, 28.3.2012

        do iobsv=1,nobsvrphi

          do kfreq=1,nfreq

            jliobfr=isour+nsource*(iobsv-1+nobsvrphi*(kfreq-1))
            ifrob=kfreq+nfreq*(iobsv-1)
            jobfr=iobsv+nobsvrphi*(kfreq-1)

            om=frq(kfreq)/hbarev1

            if(speccut.gt.0.0d0) then
              if(frq(kfreq).gt.speccut*ecdipev1*dmyenergy**2*ecmaxs) then
                afreqrphi(1:6,ifrob)=(0.0d0,0.0d0)
              endif
            endif

            afreqrphi(1:3,ifrob)=afreqrphi(1,ifrob)*reflec(1:3)
            afreqrphi(4:6,ifrob)=afreqrphi(4:6,ifrob)*reflec(1:3)

            if (ipola.eq.0) then

              specrphi(jliobfr)=specrphi(jliobfr)+
     &          dreal(
     &          afreqrphi(1,ifrob)*conjg(afreqrphi(1,ifrob))
     &          +afreqrphi(2,ifrob)*conjg(afreqrphi(2,ifrob))
     &          +afreqrphi(3,ifrob)*conjg(afreqrphi(3,ifrob))
     &          )*specnor*bunnor

              reaimarphi(1:3,1,jobfr)=reaimarphi(1:3,1,jobfr)+
     &          dreal(afreq(1:3,ifrob))/sqnbunch
              reaimarphi(1:3,2,jobfr)=reaimarphi(1:3,2,jobfr)+
     &          dimag(afreq(1:3,ifrob))/sqnbunch

              reaimarphi(8:10,1,jobfr)=reaimarphi(8:10,1,jobfr)+
     &          dreal(afreq(4:6,ifrob))/sqnbunch
              reaimarphi(8:10,2,jobfr)=reaimarphi(8:10,2,jobfr)+
     &          dimag(afreq(4:6,ifrob))/sqnbunch

            else    !ipola

              apol=
     &          afreqrphi(1,ifrob)*conjg(vpola(1))
     &          +afreqrphi(2,ifrob)*conjg(vpola(2))
     &          +afreqrphi(3,ifrob)*conjg(vpola(3))

              specrphi(jliobfr)=specrphi(jliobfr)+
     &          dreal(apol*conjg(apol))*specnor*bunnor

              reaimarphi(1:3,1,jobfr)=reaimarphi(1:3,1,jobfr)+
     &          dreal(afreq(1:3,ifrob))/sqnbunch
              reaimarphi(1:3,2,jobfr)=reaimarphi(1:3,2,jobfr)+
     &          dimag(afreq(1:3,ifrob))/sqnbunch

              reaimarphi(8:10,1,jobfr)=reaimarphi(8:10,1,jobfr)+
     &          dreal(afreq(4:6,ifrob))/sqnbunch
              reaimarphi(8:10,2,jobfr)=reaimarphi(8:10,2,jobfr)+
     &          dimag(afreq(4:6,ifrob))/sqnbunch

            endif   !ipola

            afreqrphi(1:6,ifrob)=(0.0d0,0.0d0)

          enddo !kfreq

      enddo !nobsvrphi

      endif !(mpinr.ne.0) then

      dphsour=0.0d0
      do ith=1,max(1,mthreads)
        dphsour(:,:)=dphsour(:,:)+dphsou(:,:,ith)
      enddo

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '       phase advance per step at beginning and end of source for'
      WRITE(LUNGFO,*)
     &  '       lowest and highest photon energy at selected observation point:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       beginning:',SNGL(DPHSOUR(1,1)),SNGL(DPHSOUR(1,2))
      WRITE(LUNGFO,*)'       end:      ',SNGL(DPHSOUR(2,1)),SNGL(DPHSOUR(2,2))
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       ROIs (boundary, precision, points):'
      WRITE(LUNGFO,*)

      DO IROI=1,NROIA-1
        WRITE(LUNGFO,*)
     &    IROI,SNGL(ROIX(IROI)),SNGL(ROIP(IROI)),IPOIROI(IROI+1)
      ENDDO
      WRITE(LUNGFO,*)
     &  NROI,SNGL(ROIX(NROIA))

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       SOURCE, TOTAL NUMBER OF STEPS:',ISOUR,IZAEHL
      WRITE(LUNGFO,*)'       (controlled by NLPOI and namelist $ROIN)'
      WRITE(LUNGFO,*)

      inside=0
      do iobsv=1,nobsvrphi
        if (iinside(iobsv).ne.0.0d0) then
          inside=1
          exit
        endif
      enddo

      deallocate(frq,kinside,dphsou,linside)

      ICAL=1

      RETURN
      END
+DECK,amprep_omp.
*CMZ :  4.01/04 28/12/2023  13.26.19  by  Michael Scheer
*CMZ :  4.01/02 12/05/2023  15.12.26  by  Michael Scheer
*CMZ :  4.01/00 11/02/2023  16.38.29  by  Michael Scheer
*CMZ :  4.00/17 05/12/2022  10.30.41  by  Michael Scheer
*CMZ :  4.00/16 17/09/2022  15.46.32  by  Michael Scheer
*CMZ :  4.00/15 02/06/2022  09.45.10  by  Michael Scheer
*CMZ :  4.00/11 28/06/2021  10.33.06  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine amprep_omp

! Interface WAVE -> urad_phase

+seq,trackf90u.
+seq,spectf90u.

      use sourcef90
      use observf90
      use afreqf90
      use bunchmod
      use uradphasemod
      use omp_lib

      implicit none

+seq,datetime.
+seq,contrl.
+seq,cmpara.
+seq,track.
+seq,track0.
+seq,spect.
+seq,observ.
+seq,sourcef90.
+seq,freqs.
+seq,ampli.
+seq,ellip.
+seq,wfoldf90.
+seq,optic.
+seq,b0scglob.
+seq,depola.
+seq,phycon.
+seq,uservar.

      double precision step,sigzp,sigz,sigyp,sigy,perlen,shift,ephmin,ephmax,
     &  ebeam,disp,dispp,curr,beffh,beffv,pherror,pw,ph,xbeta,
     &  beth,alphh,betv,alphv,de,disph,dispph,dispv,disppv

      integer :: modewave=1,icohere,nelec,noranone,modebunch,npinz,npiny,
     &  modepin,modesphere,nper,nepho

c      if (user(2).ne.0) then
c        modewave=user(2)
c        print*,"modewave = USER(2)",modewave
c      else
        modewave=1
c      endif

      step=1.0d0/dble(myinum)*1000.0d0

      perlen=phrperl*1000.0d0
      shift=phrshift*1000.0d0
      beffv=phrb0v
      beffh=phrb0h
      nper=kampli

      nepho=nfreq
      ephmin=freq(1)
      ephmax=freq(nfreq)

      if (rpinsph.gt.0.0d0) modesphere=1

      if (ipin.ne.0) then
        npiny=nobsvy
        npinz=nobsvz
      else
        npiny=1
        npinz=1
      endif

      if (ipin.eq.3) then
        ph=pinh*1000.0d0
        pw=pinw*1000.0d0
      else
        ph=(obsv(2,nobsv)-obsv(2,1))*1000.0d0
        pw=(obsv(3,nobsv)-obsv(3,1))*1000.0d0
      endif

      xbeta=phrxbeta
      beth=phrbetah
      alphh=phralphah
      disph=phrdisph
      dispph=phrdispph

      betv=phrbetav
      alphv=phralphav
      dispv=phrdispv
      disppv=phrdisppv

      de=phrespread
      pherror=phrerror

      bunchlen=phrbunlen
      modebunch=iubunch

      if (ibunch.eq.0) then

        icohere=0
        nelec=1
        noranone=1
        modepin=0

        if (ifold.ne.0) then
          if (ifold.ne.1) then
            print*,''
            print*,'--- Warning in ampre_omp: IFOLD set, but not 1, setting it to 1 ---'
            write(lungfo,*)''
            write(lungfo,*)'--- Warning in ampre_omp: IFOLD set, but not 1, setting it to 1 ---'
            ifold=1
          endif

        endif

      else

        if (nbunch.gt.1.and.neinbunch.gt.1) then
          print*,'*** Error in ampre_omp: Both, NBUNCH and NEINBUNCH > 1. This is not allowed here.'
          print*
          write(lungfo,*)'*** Error in ampre_omp: Both, NBUNCH and NEINBUNCH > 1. This is not allowed here.'
          stop "*** Program WAVE terminated ***"
        endif

        if (neinbunch.gt.1) then
          icohere=1
        else
          icohere=0
        endif

        nelec=max(nbunch,nelec)

        if (ibunch.eq.-1) then
          noranone=1
        else
          noranone=0
        endif

        if (ipin.eq.0.or.ipin.eq.1) then
          modepin=0
        else
          modepin=1
        endif

      endif !ibunch

      call urad_phase(
     &  mthreads,nelec,noranone,icohere,modebunch,bunchlen,bunchcharge,ihbunch,
     &  perlen,shift,nper,beffv,beffh,
     &  dmyenergy,dmycur,step,nlpoi,
     &  pincen*1000.0d0,pw,ph,npiny,npinz,modepin,modesphere,
     &  nepho,ephmin,ephmax,banwid,
     &  xbeta,beth,alphh,betv,alphv,de,phremith,phremitv,
     &  disph,dispph,dispv,disppv,
     &  modeph,pherror,modewave
     &  )

      return
      end
+DECK,urad_omp,T=F77.
*CMZ :  4.01/04 17/12/2023  11.45.19  by  Michael Scheer
*CMZ :  4.01/02 08/05/2023  13.06.52  by  Michael Scheer
*CMZ :  4.01/00 10/02/2023  13.27.16  by  Michael Scheer
*CMZ :  4.00/15 28/04/2022  15.32.20  by  Michael Scheer
*CMZ :  4.00/13 16/11/2021  17.32.24  by  Michael Scheer
*CMZ :  4.00/09 15/08/2020  08.51.05  by  Michael Scheer
*CMZ :  3.05/05 10/07/2018  09.19.31  by  Michael Scheer
*CMZ :  3.05/04 05/07/2018  11.10.09  by  Michael Scheer
*CMZ :  3.05/00 27/04/2018  15.22.16  by  Michael Scheer
*CMZ :  3.03/04 13/10/2017  09.16.28  by  Michael Scheer
*CMZ :  3.03/02 19/11/2015  13.32.35  by  Michael Scheer
*CMZ :  3.02/04 13/03/2015  10.38.25  by  Michael Scheer
*CMZ :  2.69/02 02/11/2012  16.40.18  by  Michael Scheer
*CMZ :  2.68/05 04/09/2012  13.30.58  by  Michael Scheer
*CMZ :  2.68/04 03/09/2012  11.52.24  by  Michael Scheer
*CMZ :  2.68/03 31/08/2012  09.45.28  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine urad_omp(icharge,
     &  gammai,dgamtot,
     &  xelec,yelec,zelec,vxelec,vyelec,vzelec,
     &  xf,yf,zf,efxn,efyn,efzn,
     &  xexit,yexit,zexit,vnxex,vnyex,vnzex,texit,ds,
     &  nthstep,nstep,ndim,traxyz,
     &  xobsv,yobsv,zobsv,phelow,phehig,
     &  nphener,phener,aradx,arady,aradz,stokes,powden,
     &  ieneloss,ivelofield
     &  ,istatus,ith,modewave)
c123456789123456789_123456789_123456789_123456789_123456789_123456789_12
c Author: Michael Scheer, Michael.Scheer@Helmholtz-Berlin.de

c NO WARRANTY

+seq,gplhint.

c This subroutine calculates the trajectory and the synchrotron radiation
c of an electron passing a magnetic and electric field. The electric field
c part is very preliminary and not yet fully tested. The FORTRAN random
c generator is used in uradrndm. It should be replaced by a better one
c provided by the user.

c The fields B=(bx,by,bz) and E=(ex,ey,ez) are calculated in the routine
c uradfield_omp(x,y,z,bx,by,bz,ex,ey,ez,gamma,istatus) provided by the user.
c As an example uradbmap.f may be used, which reads a 3D map of the mag. field

c Coordinate system (right handed):
c -----------------------------------

c      x: longitudinal direction
c      y: transversal vertical direction
c      z: transversal horizontal direction

c Units:
c ------

c SI-units: m, Tesla, sec, V etc., but eV for the photon energy
c The flux-density is given in Nph/s/mm**2/0.1%BW, the power-density in W/mm**2

c Input:
c --------

c integer icharge: Particle charge ( +/- 1)
c real*8 gammai: Gamma factor of the e-

c real*8 xelec:  Initial x of e-
c real*8 yelec:  Initial y of e-
c real*8 zelec:  Initial z of e-

c real*8 vxelec:  Initial velocity in x of e-
c real*8 vyelec:  Initial velocity in y of e-
c real*8 vzelec:  Initial velocity in z of e-
c The velocity is internally normalized, so the input norm does not matter

c real*8 xf: x of point in exit plane
c real*8 yf: y of point in exit plane
c real*8 zf: z of point in exit plane

c real*8 [efxn,efyn,efzn]: Normal vector of exit plane

c real*8 vnxex: x component of normal vector of exit plane
c real*8 vnyex: y component of normal vector of exit plane
c real*8 vnzex: z component of normal vector of exit plane

c real*8 ds : step size for tracking

c The tracking stops, when the electron hits the exit plane. The size of the last
c step is corrected such that the plane is hit.

c integer nthstep: If nstep > 0, the trajectory array traxyz is filled,
c                  see below
c integer ndim: Dimension of traxyz, see below

c real*8 phelow: Lowest photon energy / eV
c real*8 phehig: Higest photon energy / eV

c integer nphener: Number of equidistant photon energies

c integer ieneloss:  0: no energy loss due to synchotron radiation
c                    1: continous energy loss due to synchotron radiation
c integer ieneloss: -1: no energy loss due to synchotron radiation with quantum
c                       fluctuations

c integer ivelofield: Contral flag for the calculation of the velocity field:
c                    0: the spectrum includes the velocity field
c                    1: the specrum does not include the velocity field
c                    2: the spectrum includes only the velocity field

c Output:
c -------

c integer: istatus: Status flag:
c  0: no error found
c -1: initial gamma or velocity zero
c -2: dimension ndim of traxyz exceeded
c -3: bad value of ivelofield
c  else: status of uradfield_omp

c real*8 xexit: x of last point of the trajectory
c real*8 yexit: y of last point of the trajectory
c real*8 zexit: z of last point of the trajectory
c real*8 texit: t of last point of the trajectory

c real*8 vnxex: x component of norm. velocity vector of last point
c real*8 vnyex: y component of norm. velocity vector of last point
c real*8 vnzex: z component of norm. velocity vector of last point

c real*8 phener(nphener): Array of equidistant photon energies

c integer nstep: Number of tracking steps done, i.e. used length of traxyz

c real*8 traxyz(1:14,i): Array:
c        traxyz(1,i):  x
c        traxyz(2,i):  y
c        traxyz(3,i):  z
c        traxyz(4,i):  tracking time
c        traxyz(5,i):  x-comp. of norm. velocity vector
c        traxyz(6,i):  y-comp. of norm. velocity vector
c        traxyz(7,i):  z-comp. of norm. velocity vector
c        traxyz(8,i):  x-comp. of mag. field in the center of the step
c        traxyz(9,i):  y-comp. of mag. field in the center of the step
c        traxyz(10,i): z-comp. of mag. field in the center of the step
c        traxyz(11,i): gamma
c        traxyz(12,i): x-comp. of elec. field in the center of the step
c        traxyz(13,i): y-comp. of elec. field in the center of the step
c        traxyz(14,i): z-comp. of elec. field in the center of the step

c The phase is calculated by phase=phase0+n*dt*dphase,
c where dphase is the phase difference of the nth step dt. Phase0=
c (xobsv-xelec)/clight. The phase factor of the integrand is
c exp(i*omega*phase),where omega referes to the considered photon energy.
c complex*16 aradx(i): x-comp. of amplitude of radiation field of phener(i)
c complex*16 arady(i): y-comp. of amplitude of radiation field of phener(i)
c complex*16 aradz(i): z-comp. of amplitude of radiation field of phener(i)

c real*8 array of Stokes parameters of ith photon energy:
c        stokes(1,i): S0, i.e. total intensity
c        stokes(2,i): S1, Stokes parameter of linear +/- 90 degree polarisation
c        stokes(3,i): S2, Stokes parameter of linear +/- 45 degree polarisation
c        stokes(4,i): S3, Stokes parameter of circular polarisation
c        S0 = sqrt(S1**2+S2**2+S3**2)

c Compilation:
c ------------

c For uradbmap at least F90 is required.
c The line length exceeds 72 characters, please use an appropriate
c compiler option. It is recommended to use compiler options to initialize all
c variables to zero and to treat them as ,,saved''

      implicit none

      complex*16 aradx(nphener),arady(nphener),aradz(nphener),
     &  ziom,zi,zidom,zone,ziomr1,zicr1,zic,
     &  expom1,expom,dexpomph1,dexpomph,ddexpomph,dexpom,
     &  expomv2,vstokes(4,3),
     &  apolh,apolr,apoll,apol45,dum3

      double precision
     &  gammai,dgamtot,dt2,powden,t,phase,
     &  xelec,yelec,zelec,vxelec,vyelec,vzelec,
     &  xexit,yexit,zexit,vnxex,vnyex,vnzex,texit,
     &  xobsv,yobsv,zobsv,phelow,phehig,
     &  phener(nphener),dom2,c,rspn
     &  ,traxyz(14,ndim),stokes(4,nphener),x1,y1,z1,vx1,vy1,
     &  vz1,x2,y2,z2,vx2,vy2,vz2
     &  ,ds,dtim,bshift,x2b,y2b,z2b,bx1,by1,bz1,bx2,by2,bz2
     &  ,dgamsum,gamma,dt
     &  ,x2int,y2int,z2int,ddt,dddt,ddt2,dddt2
     &  ,vx2int,vy2int,vz2int,vxpint,vypint,vzpint
     &  ,vxp,vyp,vzp
     &  ,x3int,y3int,z3int,vx3int,vy3int,vz3int,ddddt,ddddt2
     &  ,efx,efy,efz,xf,yf,zf,dist1,dist2,disti
     &  ,dtim0,beta,vn,efx2,efy2,efz2,t1,t2,clight,c1,
     &  dgamma,vxsign,bx,by,bz,bpx,bpy,bpz,rarg(5),px,py,pz,
     &  dphase,r,rx,ry,rz
     &  ,dom1,rnbx,rnby,rnbz,dum11,rnr4,br4,b3,rnr2,br2,bet1n,
     &  rnx,rny,rnz,r1,banwid,specnor,pownor,current,
     &  stok1,stok2,stok3,stok4,om,dom,hbarev,echarge,eps0,pi,vsto,dph,
     &  r0,efxn,efyn,efzn

      integer ieneloss,istatus,icharge,nphener,ivelofield,
     &  nthstep,izaehl,nstep,ndim,kstep,lstep,ifreq,isto,ifail,ith
      integer :: kcount=1,modewave

c      integer,save :: ical=0
+seq,uservar.


      data bshift/0.5d0/
      data clight/2.99792458d8/
      data hbarev/6.58211889D-16/
      data banwid/1.0d-3/
      data current/0.10d0/ ! Be care, so also ucur in URADBUE etc.
      data eps0/8.854187817D-12/
      data echarge/1.602176462D-19/
      data pi/3.14159265358979d0/

      data zi/(0.0d0,1.0d0)/
      data zone/(1.0d0,0.0d0)/

      dph=0.0d0
c      ical=ical+1

      if (nphener.gt.0) phener(1)=phelow
      if (nphener.gt.1) dph=(phehig-phelow)/(nphener-1)

      do ifreq=2,nphener
        phener(ifreq)=phener(ifreq-1)+dph
      enddo

      istatus=0
      ifail=0
      if (icharge.le.0) icharge=-1
      if (icharge.gt.0) icharge=1

      vn=norm2([efxn,efyn,efzn])
      efx=efxn/vn
      efy=efyn/vn
      efz=efzn/vn

      x1=xelec
      y1=yelec
      z1=zelec
      vx1=vxelec
      vy1=vyelec
      vz1=vzelec
      t1=0.0d0

      gamma=gammai
      beta=dsqrt((1.d0-1.d0/gamma)*(1.d0+1.d0/gamma))
      vn=sqrt(vx1*vx1+vy1*vy1+vz1*vz1)
      vx1=vx1/vn*clight*beta
      vy1=vy1/vn*clight*beta
      vz1=vz1/vn*clight*beta
      vn=beta*clight

c vxsign takes care for the direction of flight, since particle must gain
c energy if tracked back

      if (vx1.lt.0) then
        vxsign=-1.0d0
      else
        vxsign=1.0d0
      endif

      dgamsum=0.0d0
      dgamtot=0.0d0
      powden=0.0d0
      aradx=(0.0d0,0.0d0)
      arady=(0.0d0,0.0d0)
      aradz=(0.0d0,0.0d0)

      dtim=ds/vn
      dt=dtim
      dt2=dtim*bshift
      dtim0=dtim

      x2=x1
      y2=y1
      z2=z1
      t2=t1

      vx2=vx1
      vy2=vy1
      vz2=vz1

      x2b=x1+vx1*dt2
      y2b=y1+vy1*dt2
      z2b=z1+vz1*dt2

      call uradfield_omp(x2b,y2b,z2b,bx2,by2,bz2,efx2,efy2,efz2,gamma,istatus,
     &  modewave)
      if (istatus.ne.0) ifail=ifail+abs(istatus)
      istatus=0

      nstep=0
      vn=sqrt(vx2*vx2+vy2*vy2+vz2*vz2)

      if (gamma.le.0.0d0.or.vn.le.0.0d0) then
        istatus=-1
        return
      endif

      kstep=-1
      nstep=0

      if(nthstep.gt.0) then

        nstep=nstep+1
        if (nstep.gt.ndim) then
          nstep=nstep-1
          istatus=-2
          goto 9000
        endif

        kstep=kstep+1
        if (kstep.eq.nthstep) kstep=0

        traxyz(1,nstep)=x2
        traxyz(2,nstep)=y2
        traxyz(3,nstep)=z2
        traxyz(4,nstep)=t2
        traxyz(5,nstep)=vx2/vn
        traxyz(6,nstep)=vy2/vn
        traxyz(7,nstep)=vz2/vn
        traxyz(8,nstep)=bx2
        traxyz(9,nstep)=by2
        traxyz(10,nstep)=bz2
        traxyz(11,nstep)=gamma
        traxyz(12,nstep)=efx2
        traxyz(13,nstep)=efy2
        traxyz(14,nstep)=efz2

      endif !nthstep.gt.0

      dom=0.0d0
      om=0.0d0
      if (nphener.gt.1) then
        om=phener(1)/hbarev
        dom=(phener(2)-phener(1))/hbarev
      else if (nphener.eq.1) then
        om=phener(1)/hbarev
      endif

      c=clight
      c1=1.0d0/clight

      zidom=zi*dom
      ziom=zi*om
      zic=zi*c

      lstep=0
      t=-dt
      r0=xobsv-xelec
      r=sqrt((xobsv-x1)**2+((yobsv-y1)**2+(zobsv-z1)**2))
      PHASE=(r-r0)*c1
      expom1=zone
      dexpomph1=zone

c--- Loop der Trajektorie

      izaehl=0
1000  continue

      izaehl=izaehl+1
c      print*,ith,izaehl,x2
      if (x2.ne.x2) then
        istatus=-99
        return
      endif

      if (lstep.eq.1) then
        dtim=abs(dist2)/vn
        dt=dtim
        dt2=dtim/2.0d0
      endif

      x1=x2
      y1=y2
      z1=z2

      t1=t2

      vx1=vx2
      vy1=vy2
      vz1=vz2

      bx1=bx2
      by1=by2
      bz1=bz2

      x2b=x1+vx1*dt2
      y2b=y1+vy1*dt2
      z2b=z1+vz1*dt2

      call uradfield_omp(x2b,y2b,z2b,bx2,by2,bz2,efx2,efy2,efz2,gamma,istatus,
     &  modewave)
      if (istatus.ne.0) ifail=ifail+abs(istatus)
      istatus=0

      call uradstep_omp(x1,y1,z1,vx1,vy1,vz1,bx2,by2,bz2,efx2,efy2,efz2,
     &  dtim,x2,y2,z2,vx2,vy2,vz2,vxp,vyp,vzp,gamma,icharge,ieneloss,
     &  dgamma)

      if (ieneloss.ne.0) then
        dgamsum=dgamsum+vxsign*dgamma
        if (abs(dgamsum).gt.gamma*1.0d-8) then
          gamma=gamma+dgamsum
          dgamtot=dgamtot+dgamsum
          dgamsum=0.0d0
        endif
        beta=dsqrt((1.d0-1.d0/gamma)*(1.d0+1.d0/gamma))
        vn=sqrt(vx2*vx2+vy2*vy2+vz2*vz2)
        vx2=vx2/vn*clight*beta
        vy2=vy2/vn*clight*beta
        vz2=vz2/vn*clight*beta
      endif

      BX=VX2*C1
      BY=VY2*C1
      BZ=VZ2*C1

      BPX=VXP*C1
      BPY=VYP*C1
      BPZ=VZP*C1

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION {

C REAL PART OF INTEGRAND {

      RX=XOBSV-X2
      RY=YOBSV-Y2
      RZ=ZOBSV-Z2

      R=SQRT(RX*RX+RY*RY+RZ*RZ)
      R1=1.D0/R
      ZICR1=ZIC*R1

      RNX=RX*R1
      RNY=RY*R1
      RNZ=RZ*R1

C--- THE DISTANCE R IS INTRODUCED HERE EXPLICITLY (S. PROGRAM OF CHAOEN WANG

      BET1N=(1.0D0-BX*RNX)-BY*RNY-BZ*RNZ

      br2=by**2+bz**2
      rnr2=rny**2+rnz**2
      b3=beta**3
      br4=br2**2
      rnr4=rnr2**2

      if(br2.lt.1.0d-4.and.rnr2.lt.1.0d-4) then
        bet1n=
     &    1.0d0/(1.0d0+beta)/gamma**2
     &    +beta*(rnr2/2.0d0
     &    +rnr4/8.0d0)
     &    +(br2/2.0d0
     &    -br2*rnr2/4.0d0
     &    -br2*rnr4/16.0d0)/beta
     &    +b3*br4*(1.0d0/8.0d0
     &    -rnr2/16.0d0
     &    -rnr4/64.0d0)
     &    -by*rny
     &    -bz*rnz
      endif

      DUM11=1.D0/BET1N
      DOM1=1.D0/(R*BET1N*BET1N)

      RNBX=RNX-BX
      RNBY=RNY-BY
      RNBZ=RNZ-BZ

      PX=(RNBY*BPZ-RNBZ*BPY)
      PY=(RNBZ*BPX-RNBX*BPZ)
      PZ=(RNBX*BPY-RNBY*BPX)

      IF (IVELOFIELD.EQ.0.OR.IVELOFIELD.EQ.2) THEN !2 WEGEN POWER
        DOM2=C*DOM1*R1/GAMMA**2
        RARG(1)=(RNY*PZ-RNZ*PY)*DOM1+(RNX-BX)*DOM2
        RARG(2)=(RNZ*PX-RNX*PZ)*DOM1+(RNY-BY)*DOM2
        RARG(3)=(RNX*PY-RNY*PX)*DOM1+(RNZ-BZ)*DOM2
      ELSE IF (IVELOFIELD.EQ.1) THEN
        RARG(1)=(RNY*PZ-RNZ*PY)*DOM1
        RARG(2)=(RNZ*PX-RNX*PZ)*DOM1
        RARG(3)=(RNX*PY-RNY*PX)*DOM1
      ELSE IF (IVELOFIELD.LT.0) THEN
        DOM2=C*DOM1*R1/GAMMA**2
        RARG(1)=(RNX-BX)*DOM2
        RARG(2)=(RNY-BY)*DOM2
        RARG(3)=(RNZ-BZ)*DOM2
      ELSE  !IVELOFIELD
        istatus=-3
        return
      ENDIF !IVELOFIELD

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS      RARG(4)=T+R*C1

      DPHASE=BET1N*DT

      RARG(5)=(RARG(1)*RARG(1)+RARG(2)*RARG(2)+RARG(3)*RARG(3))*DUM11

      powden=powden+rarg(5)*dt

C REAL PART OF INTEGRAND }

C COMPLEX PART OF INTEGRAND {

C    ASSUMES phener(I+1)=2*phener(I)   FOR IFREQ2P=2
C    OR phener(I+1)=phener(I)+DELTA    FOR IFREQ2P>2

C--- LOOP OVER ALL FREQUENCES

      if (nphener.gt.0) then

        IFREQ=1

        OM=phener(IFREQ)/hbarev
        ZIOM=ZI*OM

        EXPOM=EXPOM1
        DEXPOMPH1=EXP(ZIOM*DPHASE)
        DEXPOMPH=DEXPOMPH1

        IF(nphener.GT.1) THEN
          DEXPOM=EXP(ZIDOM*PHASE)
          DDEXPOMPH=EXP(ZIDOM*DPHASE)
        ENDIF  !IFREQ2P

        IF (IVELOFIELD.NE.2) THEN

          dum3=expom*(zone-dexpomph)/om/bet1n

          aradx(ifreq)=aradx(ifreq)+rarg(1)*dum3
          arady(ifreq)=arady(ifreq)+rarg(2)*dum3
          aradz(ifreq)=aradz(ifreq)+rarg(3)*dum3

        ELSE !IVELOFIELD

          EXPOMV2=R1/BET1N*EXPOM*(ZONE-DEXPOMPH)
          ZIOMR1=ZONE+ZICR1/OM

          aradx(ifreq)=aradx(ifreq)+EXPOMV2*(BX-RNX*ZIOMR1)
          arady(ifreq)=arady(ifreq)+EXPOMV2*(BX-RNX*ZIOMR1)
          aradz(ifreq)=aradz(ifreq)+EXPOMV2*(BX-RNX*ZIOMR1)

        ENDIF !IVELOFIELD

        IF (IVELOFIELD.NE.2) THEN

          DO IFREQ=2,nphener

            OM=OM+DOM
            EXPOM=EXPOM*DEXPOM
            DEXPOMPH=DEXPOMPH*DDEXPOMPH

            EXPOMV2=1.0D0/BET1N/OM*EXPOM*(ZONE-DEXPOMPH)

            aradx(ifreq)=aradx(ifreq)+RARG(1)*EXPOMV2
            arady(ifreq)=arady(ifreq)+RARG(2)*EXPOMV2
            aradz(ifreq)=aradz(ifreq)+RARG(3)*EXPOMV2

c            if (ifreq.eq.nphener/2) then
c              if (user(1).eq.0) then
c                write(56,*)ical,izaehl,x2,dphase,phase,real(aradz(ifreq)),real(RARG(3)*EXPOMV2)
c              else
c                write(57,*)ical,izaehl,x2,dphase,phase,real(aradz(ifreq)),real(RARG(3)*EXPOMV2)
c              endif
c            endif

          ENDDO   !LOOP OVER ALL FREQUENCES

        else

          DO IFREQ=2,nphener

            OM=OM+DOM
            EXPOM=EXPOM*DEXPOM
            DEXPOMPH=DEXPOMPH*DDEXPOMPH

            EXPOMV2=R1/BET1N*EXPOM*(ZONE-DEXPOMPH)
            ZIOMR1=ZONE+ZICR1/OM

            aradx(ifreq)=aradx(ifreq)+EXPOMV2*(BX-RNX*ZIOMR1)
            arady(ifreq)=aradx(ifreq)+EXPOMV2*(BX-RNX*ZIOMR1)
            aradz(ifreq)=aradx(ifreq)+EXPOMV2*(BX-RNX*ZIOMR1)

          ENDDO   !LOOP OVER ALL FREQUENCES

        ENDIF !IVELOFIELD


C COMPLEX PART OF INTEGRAND }

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION }

        PHASE=PHASE+DPHASE
        EXPOM1=EXPOM1*DEXPOMPH1

      endif !(nphener.gt.0) then

      t2=t1+dtim

c ef is normal vector of perpendiculare plane at the end of the reference orbit
c dist is distance of electron to this plane
c tracking stops if trajectory hits this plane

      dist2=(x2-xf)*efx+(y2-yf)*efy+(z2-zf)*efz

      if (lstep.eq.0.and.dist2.lt.0.0d0.and.dist2.gt.-2.0d0*ds)  then

        lstep=1
        goto 1000

      else

        kstep=kstep+1
        if (kstep.eq.nthstep) kstep=0

        if(kstep.eq.0) then

          nstep=nstep+1

          if (nstep.gt.ndim) then
            nstep=nstep-1
            istatus=-2
            goto 9000
          endif

          traxyz(1,nstep)=x2
          traxyz(2,nstep)=y2
          traxyz(3,nstep)=z2
          traxyz(4,nstep)=t2
          traxyz(5,nstep)=vx2/vn
          traxyz(6,nstep)=vy2/vn
          traxyz(7,nstep)=vz2/vn
          traxyz(8,nstep)=bx2
          traxyz(9,nstep)=by2
          traxyz(10,nstep)=bz2
          traxyz(11,nstep)=gamma
          traxyz(12,nstep)=efx2
          traxyz(13,nstep)=efy2
          traxyz(14,nstep)=efz2

        endif

        if (lstep.eq.1) goto 9000
        goto 1000

      endif !lstep and dist2

9000  continue

      xexit=x2
      yexit=y2
      zexit=z2

      vn=sqrt(vx2*vx2+vy2*vy2+vz2*vz2)
      vnxex=vx2/vn
      vnyex=vy2/vn
      vnzex=vz2/vn

      texit=t2

      specnor=
     &  banwid
     & /(4.0d0*pi**2*clight*hbarev)
     & /(4.0d0*pi*eps0)
     &  *current/1.0d6 !per mm**2

      pownor=echarge/16.0d0/pi/pi/eps0/clight*current/1.0d6 !W/mm**2

      rspn=sqrt(specnor)

      vstokes(1,1)=( 0.0d0,        0.0d0)      !horizontal polarization
      vstokes(1,2)=( 0.0d0,        0.0d0)
      vstokes(1,3)=(-1.0d0,       -1.0d0)

      vstokes(2,1)=( 0.0d0,        0.0d0)      !right handed polarization
      vstokes(2,2)=( 0.0d0,       -1.0d0)
      vstokes(2,3)=(+1.0d0,        0.0d0)

      vstokes(3,1)=( 0.0d0,        0.0d0)      !left handed polarization
      vstokes(3,2)=( 0.0d0,       -1.0d0)
      vstokes(3,3)=(-1.0d0,        0.0d0)

      vstokes(4,1)=( 0.0d0,        0.0d0)      !45 degree linear polarization
      vstokes(4,2)=( 1.0d0,        0.0d0)
      vstokes(4,3)=(-1.0d0,        0.0d0)

      do isto=1,4
        vsto=dsqrt
     &    (cdabs(vstokes(isto,1))**2
     &    +cdabs(vstokes(isto,2))**2
     &    +cdabs(vstokes(isto,3))**2)
        vstokes(isto,1)=vstokes(isto,1)/vsto
        vstokes(isto,2)=vstokes(isto,2)/vsto
        vstokes(isto,3)=vstokes(isto,3)/vsto

      enddo

      do ifreq=1,nphener

        aradx(ifreq)=aradx(ifreq)*rspn
        arady(ifreq)=arady(ifreq)*rspn
        aradz(ifreq)=aradz(ifreq)*rspn

        apolh=
     &    aradx(ifreq)*conjg(vstokes(1,1))
     &    +arady(ifreq)*conjg(vstokes(1,2))
     &    +aradz(ifreq)*conjg(vstokes(1,3))

        apolr=
     &    aradx(ifreq)*conjg(vstokes(2,1))
     &    +arady(ifreq)*conjg(vstokes(2,2))
     &    +aradz(ifreq)*conjg(vstokes(2,3))

        apoll=
     &    aradx(ifreq)*conjg(vstokes(3,1))
     &    +arady(ifreq)*conjg(vstokes(3,2))
     &    +aradz(ifreq)*conjg(vstokes(3,3))

        apol45=
     &    aradx(ifreq)*conjg(vstokes(4,1))
     &    +arady(ifreq)*conjg(vstokes(4,2))
     &    +aradz(ifreq)*conjg(vstokes(4,3))

        stok1=
     &    apolr*conjg(apolr)+
     &    apoll*conjg(apoll)

        stok2=-stok1+
     &    2.*apolh*conjg(apolh)

        stok3=
     &    2.*apol45*conjg(apol45)-
     &    stok1

        stok4=
     &    apolr*conjg(apolr)-
     &    apoll*conjg(apoll)

        stokes(1,ifreq)=stok1
        stokes(2,ifreq)=stok2
        stokes(3,ifreq)=stok3
        stokes(4,ifreq)=stok4

      enddo !nphener

      powden=powden*pownor

      if (istatus.ge.0.and.ifail.ne.0) istatus=ifail

      return
      end
+DECK,uradfield_omp.
*CMZ :  4.01/04 25/11/2023  13.39.02  by  Michael Scheer
*CMZ :  4.01/02 09/05/2023  13.15.30  by  Michael Scheer
*CMZ :  4.00/15 28/04/2022  11.45.17  by  Michael Scheer
*CMZ :  4.00/13 16/11/2021  17.18.53  by  Michael Scheer
*CMZ :  3.05/05 09/07/2018  15.22.23  by  Michael Scheer
*CMZ :  3.05/04 05/07/2018  08.56.42  by  Michael Scheer
*CMZ :  3.04/00 23/01/2018  17.17.28  by  Michael Scheer
*CMZ :  3.03/04 04/12/2017  15.56.53  by  Michael Scheer
*CMZ :  3.03/02 18/11/2015  12.56.22  by  Michael Scheer
*CMZ :  3.02/04 13/03/2015  10.36.11  by  Michael Scheer
*CMZ :  2.70/00 12/11/2012  11.53.09  by  Michael Scheer
*CMZ :  2.68/04 04/09/2012  09.38.42  by  Michael Scheer
*CMZ :  2.68/03 29/08/2012  12.25.27  by  Michael Scheer
*-- Author :    Michael Scheer   22/08/2012
      subroutine uradfield_omp(x,y,z,bxout,byout,bzout,ex,ey,ez,gamma,istatus,
     &  modewave)

      implicit none

+seq,ampli.

      double precision :: x,y,z,bx,by,bz,ex,ey,ez,
     &  bxout,byout,bzout,gamma,axout,ayout,azout

      integer :: istatus,modewave

      ex=0.0d0
      ey=0.0d0
      ez=0.0d0

      bxout=0.0d0
      byout=0.0d0
      bzout=0.0d0

      if (phrb0v.ne.0.0d0) then

        call bhalba_omp(phrb0v,phrperl,x+phrshift/2.0d0,y,z,bx,by,bz)

        bxout=bxout+bx
        byout=byout+by
        bzout=bzout+bz

      endif

      if (phrb0h.ne.0.0d0) then

        call bhalba_omp(phrb0h,phrperl,x-phrshift/2.0d0,y,z,bx,by,bz)

        bxout=bxout+bx
        byout=byout+bz
        bzout=bzout-by

      endif

      istatus=0

      return
      end
+DECK,phase_omp.
*CMZ :          29/12/2023  14.56.39  by  Michael Scheer
*CMZ :  4.01/04 28/11/2023  14.20.34  by  Michael Scheer
*CMZ :  4.01/03 12/06/2023  10.59.52  by  Michael Scheer
*CMZ :  4.00/14 07/02/2022  16.17.00  by  Michael Scheer
*CMZ :  3.02/05 22/03/2015  19.55.19  by  Michael Scheer
*CMZ :  3.02/03 23/10/2014  13.43.13  by  Michael Scheer
*CMZ :  3.02/00 15/10/2014  09.29.12  by  Michael Scheer
*CMZ :  3.01/05 12/06/2014  08.52.10  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.13.36  by  Michael Scheer
*CMZ :  2.70/09 15/01/2013  14.58.32  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  15.34.39  by  Michael Scheer
*CMZ :  2.70/03 14/12/2012  14.29.48  by  Michael Scheer
*CMZ :  2.70/02 14/12/2012  10.34.16  by  Michael Scheer
*CMZ :  2.70/01 12/12/2012  15.50.01  by  Michael Scheer
*CMZ :  2.70/00 11/12/2012  17.05.31  by  Michael Scheer
*CMZ :  2.68/05 28/09/2012  12.06.21  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  09.55.57  by  Michael Scheer
*CMZ :  2.63/05 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.49/00 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.48/04 12/03/2004  15.40.31  by  Michael Scheer
*CMZ :  2.47/21 03/12/2003  09.40.09  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.41/07 13/06/2002  15.07.39  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.20/01 03/01/2001  13.40.19  by  Michael Scheer
*CMZ :  2.16/08 27/10/2000  14.30.15  by  Michael Scheer
*CMZ :  2.16/04 24/06/2000  17.20.05  by  Michael Scheer
*CMZ :  2.16/00 07/06/2000  23.23.42  by  Michael Scheer
*CMZ :  2.15/00 02/05/2000  18.08.47  by  Michael Scheer
*CMZ :  2.13/07 10/02/2000  16.43.36  by  Michael Scheer
*CMZ :  2.13/04 21/01/2000  12.37.13  by  Michael Scheer
*CMZ :  2.13/03 18/01/2000  18.06.22  by  Michael Scheer
*CMZ :  2.13/00 01/12/99  17.14.49  by  Michael Scheer
*CMZ :  2.10/01 30/04/99  13.59.54  by  Michael Scheer
*CMZ :  1.04/00 27/11/98  12.44.48  by  Michael Scheer
*CMZ :  1.03/06 29/09/98  14.43.55  by  Michael Scheer
*-- Author :    Michael Scheer   18/09/98
      SUBROUTINE PHASE_omp
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,PHASEF90U.
+SEQ,PHASEWSF90U.
+SEQ,WBETAF90U.
+SEQ,WBETAF90U.

      use ompmod
      use omp_lib
      use wobsvmod

* ROUTINE TO PROPAGATE COMPLEXE AMPLITUDE FROM PINHOLE BACK TO
* LOCATION OF EFFECTIVE SOURCE AT (PHCENX,PHCENY,PHCENZ)


      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+seq,reargf90.
+SEQ,PHYCON.
+seq,sourcef90.
+SEQ,SPECT.
+SEQ,FREQS.
+SEq,observf90.
+SEq,phasef90.
+seq,track.
+SEQ,depola.
+SEQ,wfoldf90.
+seq,wbetaf90.
+seq,ampli.
+seq,whbook.
+seq,pawcmn.
+seq,uservar.

      CHARACTER(8) OLDDIR

      integer :: idebug=1

      INTEGER ICYCLE,NTUP_P,IOBS,IPHZ,iy,iz,iy1,iz1,IPHY,ifrq,IEPS,I,NGEO_P,ISOUR
      INTEGER NIDGEO1,ISTAT,NIDGEO2,NBEAM_P,J,IELEM,NSIZE_P
      INTEGER IOBSY,IOBSZ,K,ix,is,mthreadso

      complex*16 efc(3),bfc(3)

      integer
     &  mphasey_omp,mphasez_omp,nphasey_omp,nphasez_omp,iphfold_omp,
     &  nphelem_omp,ihsel_omp,ith,nfreq_omp,iphase_omp
      integer ic,kobs

      double precision reanor,dum,
     &  phaperzm_omp,phaperzp_omp,phaperzpm_omp,phaperzpp_omp,
     &  phaperym_omp,phaperyp_omp,phaperypm_omp,phaperypp_omp,
     &  phelem_omp(5,4,nphelemp),dgsigz_omp,dgsigy_omp,r(3),ef(3) !,bf(3)

      PARAMETER(NTUP_P=24,NGEO_P=16,NBEAM_P=16,NSIZE_P=4)

      CHARACTER(5) CHTAGS(NTUP_P),CHGEO(NGEO_P),CHBEAM(NBEAM_P)
      CHARACTER(5) CHSIZE(NSIZE_P)

      REAL*8 TUP(NTUP_P),TGEO(NGEO_P),SELGEO,TBEAM(NGEO_P),TSIZ(NSIZE_P)
      REAL*4 FLOW,FHIG,DF

      DOUBLE PRECISION XPH,YPH,ZPH,XOBS,YOBS,ZOBS,DX,DY,DZ,DZY2,ANS
     &  ,OMC,DOMC,DR,DRRED,DX2,DMASHZ,DMASHY,PHLOWZ,PHLOWY,EPS(6)
     &  ,FOCUS,RLAMBDA1,smax,sfmax

      DOUBLE PRECISION XSOUR,YSOUR,ZSOUR,DR2PH,DR2SOUR,THETA,PHI,TANTHE,TANPHI
     &  ,DXPH,DA,EPSBEAM
     &  ,XBEAM,YBEAM,ZBEAM,TANTHEB,TANPHIB,OPTMAT(4,4),BEAM(4)
     &  ,TOTMAT(4,4),DUMMAT(4,4)

      DOUBLE PRECISION W
      DOUBLE PRECISION XA(NDOBSVZP)
     &  ,YAR1(NDOBSVZP)
     &  ,YAR2(NDOBSVZP)
     &  ,YAR3(NDOBSVZP)
     &  ,YAI1(NDOBSVZP)
     &  ,YAI2(NDOBSVZP)
     &  ,YAI3(NDOBSVZP)
     &  ,RESULT(6,2)

      DOUBLE PRECISION xay(ndobsvzp)
     &  ,YAR4(NDOBSVZP)
     &  ,YAR5(NDOBSVZP)
     &  ,YAR6(NDOBSVZP)
     &  ,YAI4(NDOBSVZP)
     &  ,YAI5(NDOBSVZP)
     &  ,YAI6(NDOBSVZP)
     &  ,RESULTY(6,2)

      DOUBLE PRECISION
     &  YAR1Y(NDOBSVYP)
     &  ,YAR2Y(NDOBSVYP)
     &  ,YAR3Y(NDOBSVYP)
     &  ,YAI1Y(NDOBSVYP)
     &  ,YAI2Y(NDOBSVYP)
     &  ,YAI3Y(NDOBSVYP)
     &  ,YAR4Y(NDOBSVYP)
     &  ,YAR5Y(NDOBSVYP)
     &  ,YAR6Y(NDOBSVYP)
     &  ,YAI4Y(NDOBSVYP)
     &  ,YAI5Y(NDOBSVYP)
     &  ,YAI6Y(NDOBSVYP)

      double precision, dimension (:,:,:), allocatable :: phspec3,phspec3f,
     &  phspec3fy

      double precision, dimension (:), allocatable :: zphw,yphw,freq_omp,
     &  specwz,specwy,specfwz,specfwy,phws1,phws2,phcoef,phws3,phws4

      double precision phgsigz,phgsigy,wlen,sigrp,sigr,rn,rnx,rny,rnz

      integer is0

      character(8) chphase
      integer lenchphase

      DATA CHTAGS
     &  /'x','y','z','e','ie','iy','iz',
     &  're_x','im_x','re_y','im_y','re_z','im_z','spec','specf',
     &  'rb_x','ib_x','rb_y','ib_y','rb_z','ib_z',
     &  'nx','ny','nz'
     &  /

      data chgeo
     &  /'x','y','z','yp','zp','e','ie','is','xs','ys','zs','spec'
     &  ,'xo','yo','zo','speco'/
      data chbeam
     &  /'x','y','z','yp','zp','e','ie','is','xs','ys','zs','spec'
     &  ,'xo','yo','zo','speco'/
      data chsize /'ie','is','zrms','yrms'/

      DATA EPSBEAM/0.001D0/

      call zeit(6)
      write(6,*)"     Performing field propagation"

c      print*,"************** kein OMP ************"
c      print*,"*** Vorzeichen von Imag(B) noch korrekt??"

      mthreadso=mthreads
      mthreads=max(1,mthreads)

      if (mhbookp.eq.0) then
        chphase='//PHASE'
        lenchphase=7
      else
        chphase='//WAVE'
        lenchphase=6
      endif

      if (iemit.eq.1) then
        do ix=1,nco-1
          if (wbeta(1,ix).le.phcenx.and.wbeta(1,ix+1).gt.phcenx) then
            is0=ix
          endif
        enddo
      endif

      if (iphfold.ne.0) then
        if (phbeth.eq.-9999.0d0) then
          phbeth=wbeta(2,is0)
        endif
        if (phbetv.eq.-9999.0d0) then
          phbetv=wbeta(4,is0)
        endif
      endif

      wlen=wtoe1/freqlow/1.0d9
      if (iundulator.ne.2) then
        sigrp=sqrt(wlen/(sourceeo(1,1,1)-sourceao(1,1,1)))
      else
        sigrp=sqrt(wlen/(dble(kampli)*phrperl))
      endif
      sigr=wlen/twopi1/sigrp
      call util_break
      if (phwid.eq.-9999.0d0) then
        phwid=10.0d0*sqrt(sigr**2+
     &    ((phcenx-sourcen(1,1,1))*sigrp)**2)
      endif
      if (phhig.eq.-9999.0d0) then
        phhig=10.0d0*sqrt(sigr**2+
     &    ((phcenx-sourcen(1,1,1))*sigrp)**2)
      endif

      nphasez=(nphasez/2)*2+1
      nphasey=(nphasey/2)*2+1

      IF (NPHASEZ.GT.1) THEN
        DMASHZ=PHWID/(NPHASEZ-1)
      ELSE
        PHWID=0.D0
        DMASHZ=0.D0
      ENDIF
      IF (NPHASEY.GT.1) THEN
        DMASHY=PHHIG/(NPHASEY-1)
      ELSE
        PHHIG=0.D0
        DMASHY=0.D0
      ENDIF

      DA=PINW/max(1,(MOBSVZ-1))*PINH/max(1,(MOBSVY-1))

      if (phceny.eq.-9999.) phceny=ystart+vyin/vxin*(phcenx-xstart)
      if (phcenz.eq.-9999.) phcenz=zstart+vzin/vxin*(phcenx-xstart)

      if (iphfold.ne.0) then

        if (phbeth.le.0.0d0.or.phbetv.le.0.0d0) then
          write(lungfo,*)' '
          write(lungfo,*)
     &      '*** PHBETH or PHBETV lower or equal zero, WAVE aborted ***'
          write(lungfo,*)' '
          write(6,*)' '
          write(6,*)
     &      '*** PHBETH or PHBETV lower or equal zero, WAVE aborted ***'
          write(6,*)' '
        endif

        phgsigz=eps0h*phbeth
        phgsigy=eps0v*phbetv

        if (phgsigz.gt.0.0d0) then
          phgsigz=sqrt(phgsigz)
        else
          phgsigz=0.0d0
        endif

        if (phgsigy.gt.0.0d0) then
          phgsigy=sqrt(phgsigy)
        else
          phgsigy=0.0d0
        endif

      endif

      if (mphasez.eq.-9999) then
        if (dmashz.gt.0.0d0) then
          mphasez=nphasez+(dgsigz(1)*phgsigz/dmashz+1)*4
        else
          mphasez=0
        endif
      endif

      if (mphasey.eq.-9999) then
        if (dmashy.gt.0.0d0) then
          mphasey=nphasey+(dgsigy(1)*phgsigy/dmashy+1)*4
        else
          mphasey=0
        endif
      endif

      if (mphasez.lt.nphasez) mphasez=nphasez
      if (mphasey.lt.nphasey) mphasey=nphasey

      mphasez=(mphasez/2)*2+1
      mphasey=(mphasey/2)*2+1

      ALLOCATE(WSUM(NSOURCE*NFREQ))
      ALLOCATE(PHMEANZ(NSOURCE*NFREQ))
      ALLOCATE(PHMEANY(NSOURCE*NFREQ))
      ALLOCATE(PHSIGZ(NSOURCE*NFREQ))
      ALLOCATE(PHSIGY(NSOURCE*NFREQ))
      ALLOCATE(PHSHIFT(NOBSV))
      ALLOCATE(AMPLI(6,mphasez,mphasey,NFREQ))
      ALLOCATE(phspec3(mphasez,mphasey,nfreq))
      ALLOCATE(phspec3f(mphasez,mphasey,nfreq))
      ALLOCATE(phspec3fy(mphasez,mphasey,nfreq))
      ALLOCATE(zphw(mphasez))
      ALLOCATE(specwz(mphasez))
      ALLOCATE(specfwz(mphasez))
      ALLOCATE(yphw(mphasey))
      ALLOCATE(specwy(mphasey))
      ALLOCATE(specfwy(mphasey))
      allocate(phcoef(max(mphasez,mphasey)))
      allocate(phws1(max(mphasez,mphasey)))
      allocate(phws2(max(mphasez,mphasey)))
      allocate(phws3(max(mphasez,mphasey)))
      allocate(phws4(max(mphasez,mphasey)))
      ALLOCATE(EXPOM(NOBSV*NFREQ))
      ALLOCATE(DEXPOM(NOBSV))
      allocate(freq_omp(nfreq))

      ampli=(0.0d0,0.0d0)
      expom=(0.0d0,0.0d0)
      dexpom=(0.0d0,0.0d0)
      phshift=(0.0d0,0.0d0)
      specwz=0.0d0
      specwy=0.0d0
      phspec3=0.0d0
      phspec3f=0.0d0
      phspec3fy=0.0d0

      if (mhbookp.eq.0 .and. iroottrees.ge.0) then
        CALL hcdirm(OLDDIR,'R')
        CALL hropenm(LUNPH,'PHASE',FILEPH,'N',1024,ISTAT)
        CALL hcdirm(chphase(1:lenchphase),' ')
        IF (ISTAT.NE.0) THEN
          WRITE(6,*)'*** ERROR IN hropenm (PHASE_OMP) ***'
          WRITE(LUNGFO,*)'*** ERROR IN hropenm (PHASE_OMP) ***'
          STOP
        ENDIF
        CALL MHROUT(IDCODE,ICYCLE,' ')
      endif

      PHGEOSUM=0.0d0
      PHGEOSEL=0.0d0
      PHBEAM=0.0d0
      WSUM=0.0d0
      PHMEANZ=0.0d0
      PHMEANY=0.0d0
      PHSIGZ=0.0d0
      PHSIGY=0.0d0

      CALL hbookm(NIDPHASE,'PHASE',NTUP_P,chphase(1:lenchphase),
     &  mphasez*mphasey*nfreq,CHTAGS)

      if (nsource.gt.1) then
      CALL hbookm(NIDPHASE+1,'Field in pinhole (first source)',NTUP_P,chphase(1:lenchphase),
     &  nobsv*nfreq,CHTAGS)
      else
        CALL hbookm(NIDPHASE+1,'Field in pinhole',NTUP_P,chphase(1:lenchphase),
     &    nobsv*nfreq,CHTAGS)
      endif

      isour=1
      smax=0.0d0
      do ifrq=1,nfreq
        DO iobs=1,nobsv
          iobfr=iobs+nobsv*(ifrq-1)
          if (spec(iobfr).gt.smax) then
            smax=spec(iobfr)
            reanor=
     &        reaima(1,1,iobfr)**2+reaima(1,2,iobfr)**2+
     &        reaima(2,1,iobfr)**2+reaima(2,2,iobfr)**2+
     &        reaima(3,1,iobfr)**2+reaima(3,2,iobfr)**2
          endif
        enddo
      enddo

      reanor=sqrt(smax/reanor)

      do ifrq=1,nfreq
        DO iobs=1,nobsv
          iobfr=iobs+nobsv*(ifrq-1)
          iphy=(iobs-1)/nobsvz+1
          iphz=iobs-(iphy-1)*nobsvz
c          if (idebug.ne.0.and.iphy.eq.nobsvy/2+1.and.ifrq.eq.2) then
c            write(99,*)iundulator,iphz,obsv(3,iobs),reaima(3,1,iobfr)*reanor
c          endif
          TUP(1:3)=obsv(1:3,iobs)
          TUP(4)=FREQ(ifrq)
          TUP(5)=ifrq
          TUP(6)=IPHY
          TUP(7)=IPHZ
          ef(1:3)=reanor*reaima(1:3,1,iobfr)
c          bf(1:3)=reanor*reaima(6:8,1,iobfr)
          efc(1:3)=dcmplx(reaima(1:3,1,iobfr),reaima(1:3,2,iobfr))
          bfc(1:3)=dcmplx(reaima(6:8,1,iobfr),reaima(6:8,2,iobfr))
          TUP(8)=ef(1)
          TUP(9)=reanor*reaima(1,2,iobfr)
          TUP(10)=ef(2)
          TUP(11)=reanor*reaima(2,2,iobfr)
          TUP(12)=ef(3)
          TUP(13)=reanor*reaima(3,2,iobfr)
          TUP(14)=spec(iobfr)
          if (ifold.ne.0) then
            TUP(15)=specf(iobfr)
          else
            tup(15)=0.0d0
          endif
          TUP(16)=reanor*reaima(6,1,iobfr)
          TUP(17)=reanor*reaima(6,2,iobfr)
          TUP(18)=reanor*reaima(7,1,iobfr)
          TUP(19)=reanor*reaima(7,2,iobfr)
          TUP(20)=reanor*reaima(8,1,iobfr)
          TUP(21)=reanor*reaima(8,2,iobfr)
c          rnx=ef(2)*bf(3)-ef(3)*bf(2)
c          rny=ef(3)*bf(1)-ef(1)*bf(3)
c          rnz=ef(1)*bf(2)-ef(2)*bf(1)
          rnx=real(efc(2)*conjg(bfc(3))-efc(3)*conjg(bfc(2)))
          rny=real(efc(3)*conjg(bfc(1))-efc(1)*conjg(bfc(3)))
          rnz=real(efc(1)*conjg(bfc(2))-efc(2)*conjg(bfc(1)))
          rn=sqrt(rnx**2+rny**2+rnz**2)
          if (rn.eq.0.0d0) rn=1.0d0
          tup(22)=rnx/rn
          tup(23)=rny/rn
          tup(24)=rnz/rn
          CALL hfm(NIDPHASE+1,TUP)
        ENDDO !iobs
      enddo !nfreq

      XPH=PHCENX
      XOBS=PINCEN(1)
      DX=XOBS-XPH
      DX2=DX*DX

      IF (DX.EQ.0.0D0) THEN
        WRITE(LUNGFO,*)'*** ERROR IN PHASE_OMP: PHCENX=PINCEN(1)  ***'
        WRITE(LUNGFO,*)'CHECK INPUT FILE'
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
        WRITE(6,*)'*** ERROR IN PHASE_OMP: PHCENX=PINCEN(1)  ***'
        WRITE(6,*)'CHECK INPUT FILE'
        WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
        STOP
      ENDIF

      PHLOWZ=PHCENZ-PHWID/2.D0
      PHLOWY=PHCENY-PHHIG/2.D0
      YPH=PHLOWY-DMASHY

      OMC=FREQ(1)/(HBAREV1*CLIGHT1)
      IF (ifreq2P.GT.2) THEN
        DOMC=(FREQ(2)-FREQ(1))/(HBAREV1*CLIGHT1)
      ELSE
        DOMC=OMC
      ENDIF !(ifrq2P.GT.2)

      mphasey_omp=mphasey
      mphasez_omp=mphasez
      nphasey_omp=nphasey
      nphasez_omp=nphasez
      iphfold_omp=iphfold
      nphelem_omp=nphelem
      ihsel_omp=ihsel
      nfreq_omp=nfreq
      iphase_omp=iphase
      iphfold_omp=iphfold

      phaperzm_omp=phaperzm
      phaperzp_omp=phaperzp
      phaperzpm_omp=phaperzpm
      phaperzpp_omp=phaperzpp
      phaperym_omp=phaperym
      phaperyp_omp=phaperyp
      phaperypm_omp=phaperypm
      phaperypp_omp=phaperypp
      phelem_omp=phelem
      freq_omp(1:nfreq)=freq(1:nfreq)

      iy1=(mphasey_omp-nphasey_omp)/2
      iz1=(mphasez_omp-nphasez_omp)/2

      dgsigy_omp=dgsigy(1)
      dgsigz_omp=dgsigz(1)

!$OMP PARALLEL NUM_THREADS(mthreads) DEFAULT(PRIVATE)
!$OMp& SHARED(mphasey_omp,mphasez_omp,nphasey_omp,nphasez_omp,iphfold_omp)
!$OMp& SHARED(nphelem_omp,ihsel_omp,nfreq_omp,freq_omp,wtoe1,iphase_omp)
!$OMP& SHARED(phaperzm_omp,phaperzp_omp,phaperzpm_omp,phaperzpp_omp)
!$OMP& SHARED(phaperym_omp,phaperyp_omp,phaperypm_omp,phaperypp_omp)
!$OMP& SHARED(phelem_omp,dmashy,dmashz,obsv,phlowy,phlowz,dx,dx2)
!$OMP& SHARED(ampli,reaima,domc,omc,da,obsvz,obsvy,yphw,zphw)

!$OMP& FIRSTPRIVATE(phshift,expom,dexpom,nobsvz,nobsvy,nobsv,iy1,iz1)
!$OMP& FIRSTPRIVATE(yai1y,yai2y,yai3y,yai4y,yai5y,yai6y)
!$OMP& FIRSTPRIVATE(yar1y,yar2y,yar3y,yar4y,yar5y,yar6y)
!$OMP& FIRSTPRIVATE(yai1,yai2,yai3,yai4,yai5,yai6)
!$OMP& FIRSTPRIVATE(yar1,yar2,yar3,yar4,yar5,yar6)
!$OMP& FIRSTPRIVATE(XA,xay,RESULT,RESULTY)

      allocate(
     &  x_th(max(nobsvy,nobsvz)),
     &  wobsv1_th(max(nobsvy,nobsvz)),wobsv2_th(max(nobsvy,nobsvz)),
     &  wobsv3_th(max(nobsvy,nobsvz)),wobsv4_th(max(nobsvy,nobsvz)),
     &  wobsv5_th(max(nobsvy,nobsvz)),wobsv6_th(max(nobsvy,nobsvz)),
     &  wobsv7_th(max(nobsvy,nobsvz)))

!$OMP DO

      DO iy=1,nphasey_omp

        iphy=iy+iy1

        ith=OMP_GET_THREAD_NUM()+1
        yph=phlowy+dble(iy-1)*dmashy

        DO iz=1,nphasez_omp

          iphz=iz+iz1

          zph=phlowz+dble(iz-1)*dmashz

          DO IOBS=1,NOBSV

            XOBS=OBSV(1,IOBS)
            YOBS=OBSV(2,IOBS)
            ZOBS=OBSV(3,IOBS)

            DY=YOBS-YPH
            DZ=ZOBS-ZPH
            DZY2=DZ*DZ+DY*DY

C     TO MAKE SURE THAT TAYLOR-EXPANSION IS VALID

            IF (DZY2.GT.0.01D0*DX2) THEN
              WRITE(LUNGFO,*)'*** ERROR IN PHASE_OMP: DZY2.GT.0.01D0*DX2  ***'
              WRITE(LUNGFO,*)'CHECK INPUT FILE AND INCREASE PINCEN(1)'
              WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
              WRITE(6,*)'*** ERROR IN PHASE_OMP: PHCENX=PINCEN(1)  ***'
              WRITE(6,*)'CHECK INPUT FILE AND INCREASE PINCEN(1)'
              WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
              STOP
            ENDIF

            EPS(1)=DZY2/DX2
            DO IEPS=2,6
              EPS(IEPS)=EPS(IEPS-1)*EPS(1)
            ENDDO !IEPS

c      TAYLOR-EXPANSION DONE WITH REDUCE
c     IN "WTAY1.RED";
c     on rounded;
c     on numval;
c     precision 13;
c     F:=SQRT(1+EPS);
c     DR:=TAY1(F,EPS,6);
c     ON FORT;
c     OUT "RED.FOR";
c     DR;
c     SHUT "RED.FOR";
C ans is actually reduce by 1.0 to avoid large overall phase

            ans=-0.0205078125D0*eps(6)+0.02734375D0*eps(5)
     &        -0.0390625D0*eps(4)+
     &        0.0625D0*eps(3)-0.125D0*eps(2)+0.5D0*eps(1)

            DR=DABS(DX*(ANS+1.D0))
            DRRED=-DABS(DX*ANS)

            IF (DR.NE.0.0d0) THEN
              EXPOM(IOBS)=CDEXP(DCMPLX(0.0d0,DRRED*OMC))/DR
            ELSE
              EXPOM(IOBS)=1.0D0
            ENDIF

            DEXPOM(IOBS)=CDEXP(DCMPLX(0.0d0,DRRED*DOMC))
c            print*,ith,iobs,expom(iobs)
c+seq,dum2.
          ENDDO   !NOBS

          DO ifrq=1,NFREQ_omp

            RLAMBDA1=FREQ_omp(ifrq)/WTOE1*1.0D9   !1/lambda[m]=1/(wtoe1/freq*1.e-9)

            IF (IPHASE_omp.GT.0) THEN

              DO IOBS=1,NOBSV

                IOBFR=IOBS+NOBSV*(ifrq-1)

                IF (ifrq.EQ.1) THEN
                  PHSHIFT(IOBS)=EXPOM(IOBFR)
                ELSE
                  PHSHIFT(IOBS)=PHSHIFT(IOBS)*DEXPOM(IOBS)
                ENDIF   !(ifrq.EQ.1)
c                print*,iobfr,iobs,expom(iobfr),phshift(iobs)
c                stop
                IF (DX.GE.0) THEN

                  ampli(1,iphz,iphy,ifrq)=ampli(1,iphz,iphy,ifrq)+
     &              DCMPLX(REAIMA(1,1,IOBFR),REAIMA(1,2,IOBFR))
     &              *PHSHIFT(IOBS)
                  ampli(2,iphz,iphy,ifrq)=ampli(2,iphz,iphy,ifrq)+
     &              DCMPLX(REAIMA(2,1,IOBFR),REAIMA(2,2,IOBFR))
     &              *PHSHIFT(IOBS)
                  ampli(3,iphz,iphy,ifrq)=ampli(3,iphz,iphy,ifrq)+
     &              DCMPLX(REAIMA(3,1,IOBFR),REAIMA(3,2,IOBFR))
     &              *PHSHIFT(IOBS)

                  ampli(4,iphz,iphy,ifrq)=ampli(4,iphz,iphy,ifrq)+
     &              DCMPLX(reaima(6,1,IOBFR),-reaima(6,2,IOBFR))
     &              *PHSHIFT(IOBS)
                  ampli(5,iphz,iphy,ifrq)=ampli(5,iphz,iphy,ifrq)+
     &              DCMPLX(reaima(7,1,IOBFR),-reaima(7,2,IOBFR))
     &              *PHSHIFT(IOBS)
                  ampli(6,iphz,iphy,ifrq)=ampli(6,iphz,iphy,ifrq)+
     &              DCMPLX(reaima(8,1,IOBFR),-reaima(8,2,IOBFR))
     &              *PHSHIFT(IOBS)

                ELSE

                  ampli(1,iphz,iphy,ifrq)=ampli(1,iphz,iphy,ifrq)+
     &              DCMPLX(REAIMA(1,1,IOBFR),-REAIMA(1,2,IOBFR))
     &              *PHSHIFT(IOBS)
                  ampli(2,iphz,iphy,ifrq)=ampli(2,iphz,iphy,ifrq)+
     &              DCMPLX(REAIMA(2,1,IOBFR),-REAIMA(2,2,IOBFR))
     &              *PHSHIFT(IOBS)
                  ampli(3,iphz,iphy,ifrq)=ampli(3,iphz,iphy,ifrq)+
     &              DCMPLX(REAIMA(3,1,IOBFR),-REAIMA(3,2,IOBFR))
     &              *PHSHIFT(IOBS)

                  ampli(4,iphz,iphy,ifrq)=ampli(4,iphz,iphy,ifrq)+
     &              DCMPLX(reaima(6,1,IOBFR),+REAIMA(6,2,IOBFR))
     &              *PHSHIFT(IOBS)
                  ampli(5,iphz,iphy,ifrq)=ampli(5,iphz,iphy,ifrq)+
     &              DCMPLX(reaima(7,1,IOBFR),+reaima(7,2,IOBFR))
     &              *PHSHIFT(IOBS)
                  ampli(6,iphz,iphy,ifrq)=ampli(6,iphz,iphy,ifrq)+
     &              DCMPLX(reaima(8,1,IOBFR),+reaima(8,2,IOBFR))
     &              *PHSHIFT(IOBS)

                ENDIF !(DX.GE.0)

              ENDDO  !NOBSV

              ampli(1:6,iphz,iphy,ifrq)=ampli(1:6,iphz,iphy,ifrq)*DA*RLAMBDA1

            ELSE  !IPHASE_omp.GT.0

              DO IOBSY=1,NOBSVY
                DO IOBSZ=1,NOBSVZ

                  iobs=(iobsy-1)*nobsvz+iobsz

                  IF (ifrq.EQ.1) THEN
                    PHSHIFT(IOBS)=EXPOM(IOBS+NOBSV*(ifrq-1))
                  ELSE
                    PHSHIFT(IOBS)=PHSHIFT(IOBS)*DEXPOM(IOBS)
                  ENDIF !(ifrq.EQ.1)

                  IOBFR=IOBS+NOBSV*(ifrq-1)
c+seq,dummy.
                  IF (DX.GE.0) THEN

                    ampli(1,iphz,iphy,ifrq)=
     &                DCMPLX(REAIMA(1,1,IOBFR),REAIMA(1,2,IOBFR))
     &                *PHSHIFT(IOBS)
                    ampli(2,iphz,iphy,ifrq)=
     &                DCMPLX(REAIMA(2,1,IOBFR),REAIMA(2,2,IOBFR))
     &                *PHSHIFT(IOBS)
                    ampli(3,iphz,iphy,ifrq)=
     &                DCMPLX(REAIMA(3,1,IOBFR),REAIMA(3,2,IOBFR))
     &                *PHSHIFT(IOBS)

                    ampli(4,iphz,iphy,ifrq)=
     &                DCMPLX(reaima(6,1,IOBFR),-reaima(6,2,IOBFR))
     &                *PHSHIFT(IOBS)
                    ampli(5,iphz,iphy,ifrq)=
     &                DCMPLX(reaima(7,1,IOBFR),-reaima(7,2,IOBFR))
     &                *PHSHIFT(IOBS)
                    ampli(6,iphz,iphy,ifrq)=
     &                DCMPLX(reaima(8,1,IOBFR),-reaima(8,2,IOBFR))
     &                *PHSHIFT(IOBS)

                  ELSE

                    ampli(1,iphz,iphy,ifrq)=
     &                DCMPLX(REAIMA(1,1,IOBFR),-REAIMA(1,2,IOBFR))
     &                *PHSHIFT(IOBS)
                    ampli(2,iphz,iphy,ifrq)=
     &                DCMPLX(REAIMA(2,1,IOBFR),-REAIMA(2,2,IOBFR))
     &                *PHSHIFT(IOBS)
                    ampli(3,iphz,iphy,ifrq)=
     &                DCMPLX(REAIMA(3,1,IOBFR),-REAIMA(3,2,IOBFR))
     &                *PHSHIFT(IOBS)

                    ampli(4,iphz,iphy,ifrq)=
     &                DCMPLX(reaima(6,1,IOBFR),+reaima(6,2,IOBFR))
     &                *PHSHIFT(IOBS)
                    ampli(5,iphz,iphy,ifrq)=
     &                DCMPLX(reaima(7,1,IOBFR),+reaima(7,2,IOBFR))
     &                *PHSHIFT(IOBS)
                    ampli(6,iphz,iphy,ifrq)=
     &                DCMPLX(reaima(8,1,IOBFR),+reaima(8,2,IOBFR))
     &                *PHSHIFT(IOBS)

                  ENDIF !(DX.GE.0)

                  X_th(IOBSZ)=OBSVZ(IOBSZ)

                  YAR1(IOBSZ)=DREAL(ampli(1,iphz,iphy,ifrq))
                  YAR2(IOBSZ)=DREAL(ampli(2,iphz,iphy,ifrq))
                  YAR3(IOBSZ)=DREAL(ampli(3,iphz,iphy,ifrq))

                  YAI1(IOBSZ)=DIMAG(ampli(1,iphz,iphy,ifrq))
                  YAI2(IOBSZ)=DIMAG(ampli(2,iphz,iphy,ifrq))
                  YAI3(IOBSZ)=DIMAG(ampli(3,iphz,iphy,ifrq))

                  YAR4(IOBSZ)=DREAL(ampli(4,iphz,iphy,ifrq))
                  YAR5(IOBSZ)=DREAL(ampli(5,iphz,iphy,ifrq))
                  YAR6(IOBSZ)=DREAL(ampli(6,iphz,iphy,ifrq))

                  YAI4(IOBSZ)=DIMAG(ampli(4,iphz,iphy,ifrq))
                  YAI5(IOBSZ)=DIMAG(ampli(5,iphz,iphy,ifrq))
                  YAI6(IOBSZ)=DIMAG(ampli(6,iphz,iphy,ifrq))

                ENDDO   !NOBSVZ

                wobsv1_th(1:nobsvz)=yar1(1:nobsvz)
                CALL UTIL_SPLINE_integral_omp(nobsvz,RESULT(1,1))
                wobsv1_th(1:nobsvz)=yai1(1:nobsvz)
                CALL UTIL_SPLINE_integral_omp(nobsvz,RESULT(1,2))

                wobsv1_th(1:nobsvz)=yar2(1:nobsvz)
                CALL UTIL_SPLINE_integral_omp(nobsvz,RESULT(2,1))
                wobsv1_th(1:nobsvz)=yai2(1:nobsvz)
                CALL UTIL_SPLINE_integral_omp(nobsvz,RESULT(2,2))

                wobsv1_th(1:nobsvz)=yar3(1:nobsvz)
                CALL UTIL_SPLINE_integral_omp(nobsvz,RESULT(3,1))
                wobsv1_th(1:nobsvz)=yai3(1:nobsvz)
                CALL UTIL_SPLINE_integral_omp(nobsvz,RESULT(3,2))

                wobsv1_th(1:nobsvz)=yar4(1:nobsvz)
                CALL UTIL_SPLINE_integral_omp(nobsvz,RESULT(4,1))
                wobsv1_th(1:nobsvz)=yai4(1:nobsvz)
                CALL UTIL_SPLINE_integral_omp(nobsvz,RESULT(4,2))

                wobsv1_th(1:nobsvz)=yar5(1:nobsvz)
                CALL UTIL_SPLINE_integral_omp(nobsvz,RESULT(5,1))
                wobsv1_th(1:nobsvz)=yai5(1:nobsvz)
                CALL UTIL_SPLINE_integral_omp(nobsvz,RESULT(5,2))

                wobsv1_th(1:nobsvz)=yar6(1:nobsvz)
                CALL UTIL_SPLINE_integral_omp(nobsvz,RESULT(6,1))
                wobsv1_th(1:nobsvz)=yai6(1:nobsvz)
                CALL UTIL_SPLINE_integral_omp(nobsvz,RESULT(6,2))

                XAY(IOBSY)=OBSVY(IOBSY)

                YAR1Y(IOBSY)=RESULT(1,1)
                YAI1Y(IOBSY)=RESULT(1,2)
                YAR2Y(IOBSY)=RESULT(2,1)
                YAI2Y(IOBSY)=RESULT(2,2)
                YAR3Y(IOBSY)=RESULT(3,1)
                YAI3Y(IOBSY)=RESULT(3,2)
                YAR4Y(IOBSY)=RESULT(4,1)
                YAI4Y(IOBSY)=RESULT(4,2)
                YAR5Y(IOBSY)=RESULT(5,1)
                YAI5Y(IOBSY)=RESULT(5,2)
                YAR6Y(IOBSY)=RESULT(6,1)
                YAI6Y(IOBSY)=RESULT(6,2)

              ENDDO !NOBSVY

              x_th(1:nobsvy)=xay(1:nobsvy)

              wobsv1_th(1:nobsvy)=yar1y(1:nobsvy)
              CALL UTIL_SPLINE_integral_omp(NOBSVY,RESULTY(1,1))
              wobsv1_th(1:nobsvy)=yai1y(1:nobsvy)
              CALL UTIL_SPLINE_integral_omp(NOBSVY,RESULTY(1,2))

              wobsv1_th(1:nobsvy)=yar2y(1:nobsvy)
              CALL UTIL_SPLINE_integral_omp(NOBSVY,RESULTY(2,1))
              wobsv1_th(1:nobsvy)=yai2y(1:nobsvy)
              CALL UTIL_SPLINE_integral_omp(NOBSVY,RESULTY(2,2))

              wobsv1_th(1:nobsvy)=yar3y(1:nobsvy)
              CALL UTIL_SPLINE_integral_omp(NOBSVY,RESULTY(3,1))
              wobsv1_th(1:nobsvy)=yai3y(1:nobsvy)
              CALL UTIL_SPLINE_integral_omp(NOBSVY,RESULTY(3,2))

              wobsv1_th(1:nobsvy)=yar4y(1:nobsvy)
              CALL UTIL_SPLINE_integral_omp(NOBSVY,RESULTY(4,1))
              wobsv1_th(1:nobsvy)=yai4y(1:nobsvy)
              CALL UTIL_SPLINE_integral_omp(NOBSVY,RESULTY(4,2))

              wobsv1_th(1:nobsvy)=yar5y(1:nobsvy)
              CALL UTIL_SPLINE_integral_omp(NOBSVY,RESULTY(5,1))
              wobsv1_th(1:nobsvy)=yai5y(1:nobsvy)
              CALL UTIL_SPLINE_integral_omp(NOBSVY,RESULTY(5,2))

              wobsv1_th(1:nobsvy)=yar6y(1:nobsvy)
              CALL UTIL_SPLINE_integral_omp(NOBSVY,RESULTY(6,1))
              wobsv1_th(1:nobsvy)=yai6y(1:nobsvy)
              CALL UTIL_SPLINE_integral_omp(NOBSVY,RESULTY(6,2))

              ampli(1,iphz,iphy,ifrq)=DCMPLX(RESULTY(1,1),RESULTY(1,2))*RLAMBDA1
              ampli(2,iphz,iphy,ifrq)=DCMPLX(RESULTY(2,1),RESULTY(2,2))*RLAMBDA1
              ampli(3,iphz,iphy,ifrq)=DCMPLX(RESULTY(3,1),RESULTY(3,2))*RLAMBDA1

              ampli(4,iphz,iphy,ifrq)=DCMPLX(RESULTY(4,1),RESULTY(4,2))*RLAMBDA1
              ampli(5,iphz,iphy,ifrq)=DCMPLX(RESULTY(5,1),RESULTY(5,2))*RLAMBDA1
              ampli(6,iphz,iphy,ifrq)=DCMPLX(RESULTY(6,1),RESULTY(6,2))*RLAMBDA1

            ENDIF !IPHASE.GT.0

          ENDDO   !NFREQ

        ENDDO  !NPHASEZ

      ENDDO !NPHAZEY

!$OMP END DO

      deallocate(x_th,
     &  wobsv1_th,wobsv2_th,wobsv3_th,wobsv4_th,wobsv5_th,
     &  wobsv6_th,wobsv7_th)

!$OMP END PARALLEL

      do iphz=1,mphasez
        zphw(iphz)=-(mphasez-1)*dmashz/2.0+(iphz-1)*dmashz
      enddo

      do iphy=1,mphasey
        yphw(iphy)=-(mphasey-1)*dmashy/2.0+(iphy-1)*dmashy
      enddo

      !print*,iz1,iy1,dgsigz_omp,dgsigy_omp

      smax=-1.0d30

!$OMP PARALLEL NUM_THREADS(mthreads) DEFAULT(PRIVATE)
!$OMp& SHARED(mphasey_omp,mphasez_omp,nphasey_omp,nphasez_omp,iphfold_omp)
!$OMp& SHARED(nphelem_omp,ihsel_omp,nfreq_omp,freq_omp,wtoe1,iphase_omp)
!$OMP& SHARED(phaperzm_omp,phaperzp_omp,phaperzpm_omp,phaperzpp_omp)
!$OMP& SHARED(phaperym_omp,phaperyp_omp,phaperypm_omp,phaperypp_omp)
!$OMP& SHARED(phelem_omp,dmashy,dmashz,obsv,phlowy,phlowz,dx,dx2)
!$OMP& SHARED(ampli,reaima,phshift,domc,omc,da,obsvz,obsvy,yphw,zphw)
!$OMP& SHARED(smax,phspec3,sfmax,phspec3fy,phspec3f,dgsigz_omp,dgsigy_omp,phgsigz,phgsigy)

!$OMP& FIRSTPRIVATE(nobsvz,nobsvy,nobsv,nidphase,xph,iy1,iz1)
!$OMP& FIRSTPRIVATE(specwy,specfwy,specwz,specfwz)

      allocate(
     &  x_th(max(mphasez_omp,mphasey_omp)),
     &  wobsv1_th(max(mphasez_omp,mphasey_omp)),wobsv2_th(max(mphasez_omp,mphasey_omp)),
     &  wobsv3_th(max(mphasez_omp,mphasey_omp)),wobsv4_th(max(mphasez_omp,mphasey_omp)),
     &  wobsv5_th(max(mphasez_omp,mphasey_omp)),wobsv6_th(max(mphasez_omp,mphasey_omp)),
     &  wobsv7_th(max(mphasez_omp,mphasey_omp)))

!$OMP DO

      do ifrq=1,nfreq_omp

        DO iy=1,nphasey_omp
          iphy=iy+iy1
          DO iz=1,nphasez_omp
            iphz=iz+iz1
            phspec3(iphz,iphy,ifrq)=
     &        DREAL(ampli(1,iphz,iphy,ifrq))*DREAL(ampli(1,iphz,iphy,ifrq))+
     &        DIMAG(ampli(1,iphz,iphy,ifrq))*DIMAG(ampli(1,iphz,iphy,ifrq))+
     &        DREAL(ampli(2,iphz,iphy,ifrq))*DREAL(ampli(2,iphz,iphy,ifrq))+
     &        DIMAG(ampli(2,iphz,iphy,ifrq))*DIMAG(ampli(2,iphz,iphy,ifrq))+
     &        DREAL(ampli(3,iphz,iphy,ifrq))*DREAL(ampli(3,iphz,iphy,ifrq))+
     &        DIMAG(ampli(3,iphz,iphy,ifrq))*DIMAG(ampli(3,iphz,iphy,ifrq))
            if (phspec3(iphz,iphy,ifrq).gt.smax) smax=phspec3(iphz,iphy,ifrq)
          ENDDO   !NPHASez_omp
        ENDDO  !NPHAZey_omp

        if (iphfold_omp.ne.0) then

          do iphy=(mphasey_omp-nphasey_omp)/2+1,(mphasey_omp-nphasey_omp)/2+nphasey_omp

            specwz=phspec3(1:mphasez_omp,iphy,ifrq)

            if (dgsigz_omp.gt.0.0d0.and.phgsigz.gt.0.0d0) then
              if (iphfold_omp.lt.0) then
                x_th(1:mphasez_omp)=zphw(1:mphasez_omp)
                wobsv1_th(1:mphasez_omp)=specwz(1:mphasez_omp)
                call util_fold_function_gauss_lin_omp(
     &            mphasez_omp,phgsigz,dgsigz_omp)
                specfwz(1:mphasez_omp)=wobsv2_th(1:mphasez_omp)
              else
                x_th(1:mphasez_omp)=zphw(1:mphasez_omp)
                wobsv1_th(1:mphasez_omp)=specwz(1:mphasez_omp)
                call util_fold_function_gauss_omp(
     &            mphasez_omp,phgsigz,dgsigz_omp)
                specfwz(1:mphasez_omp)=wobsv2_th(1:mphasez_omp)
              endif
            else
              specfwz=specwz
            endif

            phspec3fy(1:mphasez_omp,iphy,ifrq)=specfwz(1:mphasez_omp)

          enddo !iphy

          do iphz=1,mphasez_omp
            specwy=phspec3fy(iphz,1:mphasey_omp,ifrq)
            if (dgsigy_omp.gt.0.0d0.and.phgsigy.gt.0.0d0) then
              if (iphfold_omp.lt.0) then
c               call util_fold_function_gauss_lin(
c     &            mphasey_omp,yphw,specwy,phgsigy,dgsigy_omp,specfwy,phws1,phws2)
                x_th(1:mphasey_omp)=yphw(1:mphasey_omp)
                wobsv1_th(1:mphasey_omp)=specwy(1:mphasey_omp)
                call util_fold_function_gauss_lin_omp(
     &            mphasey_omp,phgsigy,dgsigy_omp)
                specfwy(1:mphasey_omp)=wobsv2_th(1:mphasey_omp)
              else
c                call util_fold_function_gauss(
c     &            mphasey_omp,yphw,specwy,phgsigy,dgsigy_omp,specfwy,phcoef,
c     &            phws1,phws2,phws3,phws4)
                x_th(1:mphasey_omp)=yphw(1:mphasey_omp)
                wobsv1_th(1:mphasey_omp)=specwy(1:mphasey_omp)
                call util_fold_function_gauss_omp(
     &            mphasey_omp,phgsigy,dgsigy_omp)
                specfwy(1:mphasey_omp)=wobsv2_th(1:mphasey_omp)
              endif
            else
              specfwy=specwy
            endif
            phspec3f(iphz,1:mphasey_omp,ifrq)=specfwy
          enddo !iphz

        endif !iphfold_omp

      enddo !nfreq

!$OMP END DO

      deallocate(x_th,
     &  wobsv1_th,wobsv2_th,wobsv3_th,wobsv4_th,wobsv5_th,
     &  wobsv6_th,wobsv7_th)

!$OMP END PARALLEL

      sfmax=-1.0d30

      do ifrq=1,nfreq
        DO iphy=1,mphasey_omp
          DO IPHZ=1,mphasez_omp
            TUP(1)=XPH
            TUP(2)=YPHw(iphy)
            TUP(3)=ZPHw(iphz)
            TUP(4)=FREQ_omp(ifrq)
            TUP(5)=ifrq
            TUP(6)=IPHY
            TUP(7)=IPHZ
            ef(1:3)=DREAL(reanor*ampli(1:3,iphz,iphy,ifrq))
c            bf(1:3)=DREAL(reanor*ampli(4:6,iphz,iphy,ifrq))
            efc(1:3)=ampli(1:3,iphz,iphy,ifrq)
            bfc(1:3)=ampli(4:6,iphz,iphy,ifrq)
            TUP(8)=ef(1)
            TUP(9)=DIMAG(reanor*ampli(1,iphz,iphy,ifrq))
            TUP(10)=ef(2)
            TUP(11)=DIMAG(reanor*ampli(2,iphz,iphy,ifrq))
            TUP(12)=ef(3)
            TUP(13)=DIMAG(reanor*ampli(3,iphz,iphy,ifrq))
            TUP(14)=phspec3(iphz,iphy,ifrq)*reanor**2
            TUP(15)=phspec3f(iphz,iphy,ifrq)*reanor**2
            TUP(16)=DREAL(reanor*ampli(4,iphz,iphy,ifrq))
            TUP(17)=DIMAG(reanor*ampli(4,iphz,iphy,ifrq))
            TUP(18)=DREAL(reanor*ampli(5,iphz,iphy,ifrq))
            TUP(19)=DIMAG(reanor*ampli(5,iphz,iphy,ifrq))
            TUP(20)=DREAL(reanor*ampli(6,iphz,iphy,ifrq))
            TUP(21)=DIMAG(reanor*ampli(6,iphz,iphy,ifrq))
c            rnx=ef(2)*bf(3)-ef(3)*bf(2)
c            rny=ef(3)*bf(1)-ef(1)*bf(3)
c            rnz=ef(1)*bf(2)-ef(2)*bf(1)
            rnx=real(efc(2)*conjg(bfc(3))-efc(3)*conjg(bfc(2)))
            rny=real(efc(3)*conjg(bfc(1))-efc(1)*conjg(bfc(3)))
            rnz=real(efc(1)*conjg(bfc(2))-efc(2)*conjg(bfc(1)))
            rn=sqrt(rnx**2+rny**2+rnz**2)
            if (rn.eq.0.0d0) rn=1.0d0
            tup(22)=rnx/rn
            tup(23)=rny/rn
            tup(24)=rnz/rn
            if (phspec3f(iphz,iphy,ifrq).gt.sfmax) sfmax=phspec3f(iphz,iphy,ifrq)
            CALL hfm(NIDPHASE,TUP)
          ENDDO   !mPHASez_omp
        ENDDO  !MPHASey_omp
      enddo !nfreq

      if (iphfold.ne.0.and.sfmax.ge.smax) then
        write(lungfo,*)' '
        write(lungfo,*)
     &    '*** Warning in PHASE: Max. of folded intensity higher than unfolded one!'
        write(lungfo,*)'   Be careful with results, they are probably wrong'
        write(lungfo,*)'   Try different parameters of tiny beam current to investigate the problem.'
        write(lungfo,*)'   Max. of raw and folded intensities:'
        write(lungfo,*)'   ',smax,sfmax
        write(lungfo,*)' '
        write(6,*)' '
        write(6,*)
     &    '*** Warning in PHASE: Max. of folded intensity higher than unfolded one!'
        write(6,*)'   Be careful with results, they are probably wrong'
        write(6,*)'   Try different parameters of tiny beam current to investigate the problem.'
        write(6,*)'   Max. of raw and folded intensities:'
        write(6,*)'   ',smax,sfmax
        write(6,*)' '
      endif

      CALL MHROUT(NIDPHASE,ICYCLE,' ')
      CALL hdeletm(NIDPHASE)

      IF (mPHASEZ.GT.1.AND.mPHASEY.GT.1) THEN

        call hbook2m(NIDPHASE-1,'PHASE',
     &    mPHASEZ,
     &    SNGL(PHCENZ-(mphasez-1)*dmashz/2.-PHWID/(NPHASEZ-1)/2.),
     &    SNGL(PHCENZ+(mphasez-1)*dmashz/2.+PHWID/(NPHASEZ-1)/2.),
     &    mPHASEY,
     &    SNGL(PHCENY-(mphasey-1)*dmashy/2.-PHHIG/(NPHASEY-1)/2.),
     &    SNGL(PHCENY+(mphasey-1)*dmashy/2.+PHHIG/(NPHASEY-1)/2.),
     &    0.0)
        CALL MHROUT(NIDPHASE-1,ICYCLE,' ')
        CALL hdeletm(NIDPHASE-1)

        call hbook1m(NIDPHASE-2,'PHASE (HORIZONTAL CUT)',
     &    mPHASEZ,
     &    SNGL(PHCENZ-(mphasez-1)*dmashz/2.-PHWID/(NPHASEZ-1)/2.),
     &    SNGL(PHCENZ+(mphasez-1)*dmashz/2.+PHWID/(NPHASEZ-1)/2.),
     &    0.0)
        CALL MHROUT(NIDPHASE-2,ICYCLE,' ')
        CALL hdeletm(NIDPHASE-2)

        call hbook1m(NIDPHASE-3,'PHASE (VERTICAL CUT)',
     &    mPHASEY,
     &    SNGL(PHCENY-(mphasey-1)*dmashy/2.-PHHIG/(NPHASEY-1)/2.),
     &    SNGL(PHCENY+(mphasey-1)*dmashy/2.+PHHIG/(NPHASEY-1)/2.),
     &    0.0)
        CALL MHROUT(NIDPHASE-3,ICYCLE,' ')
        CALL hdeletm(NIDPHASE-3)

      ELSE IF (NPHASEZ.GT.1) THEN

        call hbook1m(NIDPHASE-2,'PHASE (HORIZONTAL CUT)',
     &    mPHASEZ,
     &    SNGL(PHCENZ-(mphasez-1)*dmashz/2.-PHWID/(NPHASEZ-1)/2.),
     &    SNGL(PHCENZ+(mphasez-1)*dmashz/2.+PHWID/(NPHASEZ-1)/2.),
     &    0.0)
        CALL MHROUT(NIDPHASE-2,ICYCLE,' ')
        CALL hdeletm(NIDPHASE-2)

      ELSE IF (NPHASEY.GT.1) THEN

        call hbook1m(NIDPHASE-3,'PHASE (VERTICAL CUT)',
     &    mPHASEY,
     &    SNGL(PHCENY-(mphasey-1)*dmashy/2.-PHHIG/(NPHASEY-1)/2.),
     &    SNGL(PHCENY+(mphasey-1)*dmashy/2.+PHHIG/(NPHASEY-1)/2.),
     &    0.0)
        CALL MHROUT(NIDPHASE-3,ICYCLE,' ')
        CALL hdeletm(NIDPHASE-3)

      ENDIF !(NPHASEZ.GT.1.AND.NPHASEY.GT.1) THEN

      if (mhbookp.eq.0.and.iroottrees.ge.0) then
        CALL hrendm('PHASE')
        CLOSE(LUNPH)
      endif

      if (mhbookp.eq.0.and.iroottrees.ge.0) then
        CALL hropenm(LUNPH,'PHASE','GEO_'//FILEPH,'N',1024,ISTAT)
        CALL hcdirm(chphase(1:lenchphase),' ')
        IF (ISTAT.NE.0) THEN
          WRITE(6,*)'*** ERROR IN hropenm (PHASE_OMP) ***'
          WRITE(LUNGFO,*)'*** ERROR IN hropenm (PHASE_OMP) ***'
          STOP
        ENDIF
        CALL MHROUT(IDCODE,ICYCLE,' ')
      endif

      IF (ABS(IPHASE).GT.1) THEN

C PHASE SPACE FORM GEOMETRICAL OPTIC. ONLY CORRECT IF DIFFRACTION IS
C NEGLIGIBLE (TO BE CHECKED BY TRANSFORMED PHASE)
+self,if=-mhbook.
        CALL hbookm(NIDGEO,'PHASE SPACE DIST. (GEO. OPTIC)'
     &    ,NGEO_P,chphase(1:lenchphase),1024,CHGEO)

        NIDGEO1=NIDGEO+1
        CALL hbookm(NIDGEO1,'SEL. PHASE SPACE DIST. (GEO. OPTIC)'
     &    ,NGEO_P,chphase(1:lenchphase),1024,CHGEO)

        NIDGEO2=NIDGEO+2
        CALL hbookm(NIDGEO2,
     &    'SELECTED PHASE SPACE DIST. AT END OF BEAMLINE'
     &    ,NBEAM_P,chphase(1:lenchphase),1024,CHBEAM)

        CALL hbookm(NIDGEO+3,'SOURCE SIZE (GEO. OPTIC THROUGH APERTURE)'
     &    ,NSIZE_P,chphase(1:lenchphase),1024,CHSIZE)
+self,if=mhbook.
        CALL hbookm(NIDGEO,'PHASE SPACE DIST. (GEO. OPTIC)'
     &    ,NGEO_P,chphase(1:lenchphase),nphelem*nsource*nobsv,CHGEO)

        NIDGEO1=NIDGEO+1
        CALL hbookm(NIDGEO1,'SEL. PHASE SPACE DIST. (GEO. OPTIC)'
     &    ,NGEO_P,chphase(1:lenchphase),nphelem*nsource*nobsv*nfreq,CHGEO)

        NIDGEO2=NIDGEO+2
        CALL hbookm(NIDGEO2,
     &    'SELECTED PHASE SPACE DIST. AT END OF BEAMLINE'
     &    ,NBEAM_P,chphase(1:lenchphase),nphelem*nsource*nobsv*nfreq,CHBEAM)

        CALL hbookm(NIDGEO+3,'SOURCE SIZE (GEO. OPTIC THROUGH APERTURE)'
     &    ,NSIZE_P,chphase(1:lenchphase),nphelem*nsource*nobsv*nfreq,CHSIZE)
+self.
C--- GET FOCUSSING

        DO J=1,4
          DO I=1,4
            TOTMAT(I,J)=0.0D0
            DUMMAT(I,J)=0.0D0
          ENDDO
        ENDDO

        TOTMAT(1,1)=1.0D0
        TOTMAT(2,2)=1.0D0
        TOTMAT(3,3)=1.0D0
        TOTMAT(4,4)=1.0D0

        DO IELEM=1,NPHELEM
          DO J=1,4
            DO I=1,4
              DO K=1,4
                DUMMAT(I,J)=DUMMAT(I,J)+TOTMAT(I,K)*PHELEM(K,J,IELEM)
              ENDDO
            ENDDO
          ENDDO
          DO J=1,4
            DO I=1,4
              TOTMAT(I,J)=DUMMAT(I,J)
              DUMMAT(I,J)=0.0D0
            ENDDO
          ENDDO
        ENDDO   !IELEM

        ZBEAM=EPSBEAM
        TANPHIB=0.0
        YBEAM=EPSBEAM
        TANTHEB=0.0

        DO IELEM=1,NPHELEM

          BEAM(1)=ZBEAM
          BEAM(2)=TANPHIB
          BEAM(3)=YBEAM
          BEAM(4)=TANTHEB

          DO J=1,4
            DO I=1,4
              OPTMAT(I,J)=PHELEM(I,J,IELEM)
            ENDDO
          ENDDO

          IF (OPTMAT(2,1).GT.0.0) THEN
            WRITE(6,*)'*** WARNING IN PHASE: PHELEM(2,1,N).GT.0'
            WRITE(6,*)'PHELEM(2,1,N) IS -1/fx !'
            WRITE(6,*)'CHECK ELEMENT ',IELEM
            WRITE(LUNGFO,*)'*** WARNING IN PHASE: PHELEM(2,1,N).GT.0'
            WRITE(LUNGFO,*)'PHELEM(2,1,N) IS -1/fx !'
            WRITE(LUNGFO,*)'CHECK ELEMENT ',IELEM
          ENDIF

          IF (OPTMAT(4,3).GT.0.0) THEN
            WRITE(6,*)'*** WARNING IN PHASE: PHELEM(4,3,N).GT.0'
            WRITE(6,*)'PHELEM(4,3,N) IS -1/fx !'
            WRITE(6,*)'CHECK ELEMENT ',IELEM
            WRITE(LUNGFO,*)'*** WARNING IN PHASE: PHELEM(2,1,N).GT.0'
            WRITE(LUNGFO,*)'PHELEM(4,3,N) IS -1/fy !'
            WRITE(LUNGFO,*)'CHECK ELEMENT ',IELEM
          ENDIF

          ZBEAM=
     &      OPTMAT(1,1)*BEAM(1)
     &      +OPTMAT(1,2)*BEAM(2)
     &      +OPTMAT(1,3)*BEAM(3)
     &      +OPTMAT(1,4)*BEAM(4)

          TANPHIB=
     &      OPTMAT(2,1)*BEAM(1)
     &      +OPTMAT(2,2)*BEAM(2)
     &      +OPTMAT(2,3)*BEAM(3)
     &      +OPTMAT(2,4)*BEAM(4)

          YBEAM=
     &      OPTMAT(3,1)*BEAM(1)
     &      +OPTMAT(3,2)*BEAM(2)
     &      +OPTMAT(3,3)*BEAM(3)
     &      +OPTMAT(3,4)*BEAM(4)

          TANTHEB=
     &      OPTMAT(4,1)*BEAM(1)
     &      +OPTMAT(4,2)*BEAM(2)
     &      +OPTMAT(4,3)*BEAM(3)
     &      +OPTMAT(4,4)*BEAM(4)

        ENDDO   !NELEM

        IF (ZBEAM*YBEAM.NE.0.0d0) THEN
          FOCUS=(EPSBEAM*EPSBEAM)/DABS(ZBEAM*YBEAM)
        ELSE
          WRITE(6,*)
     &      '*** ERROR IN PHASE_OMP: IMAGE IS IN FOCAL PLANE, CHECK INPUT ***'
          WRITE(LUNGFO,*)
     &      '*** ERROR IN PHASE_OMP: IMAGE IS IN FOCAL PLANE, CHECK INPUT ***'
          STOP
        ENDIF

        DO IOBS=1,NOBSV

          XOBS=OBSV(1,IOBS)
          YOBS=OBSV(2,IOBS)
          ZOBS=OBSV(3,IOBS)

          DO ISOUR=1,NSOURCE

            XSOUR=SOURCEN(1,1,ISOUR)
            IF (XOBS.LE.XSOUR) THEN
              WRITE(LUNGFO,*)'*** ERROR IN PHASE_OMP: Bad PINCEN(1)   ***'
              WRITE(LUNGFO,*)'CHECK INPUT FILE'
              WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
              WRITE(6,*)'*** ERROR IN PHASE_OMP: Bad PINCEN(1)  ***'
              WRITE(6,*)'CHECK INPUT FILE'
              WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
              STOP
            ENDIF

            YSOUR=SOURCEN(2,1,ISOUR)
            ZSOUR=SOURCEN(3,1,ISOUR)

            DX=(XSOUR-XOBS)
            DY=(YSOUR-YOBS)
            DZ=(ZSOUR-ZOBS)

            TANPHI=DZ/DX
            TANTHE=DY/DX

            PHI=ATAN2(DZ,DX)
            THETA=ATAN2(DY,DX)

            XPH=PHCENX
            DXPH=(XPH-XOBS)
            YPH=YOBS+TANTHE*DXPH
            ZPH=ZOBS+TANPHI*DXPH

            DR2PH=(XSOUR-XPH)**2+(YSOUR-YPH)**2+(ZSOUR-ZPH)**2
            DR2SOUR=DX**2+DY**2+DZ**2

            DO ifrq=1,NFREQ

              TGEO(1)=XPH
              TGEO(2)=YPH
              TGEO(3)=ZPH
              TGEO(4)=-TANTHE
              TGEO(5)=-TANPHI
              TGEO(6)=FREQ(ifrq)
              TGEO(7)=ifrq
              TGEO(8)=ISOUR
              TGEO(9)=XSOUR
              TGEO(10)=YSOUR
              TGEO(11)=ZSOUR
              ILIOBFR=ISOUR+NSOURCE*(IOBS-1+NOBSV*(ifrq-1))
              TGEO(12)=SPEC(ILIOBFR)
     &          *DR2SOUR/DR2PH
              TGEO(13)=XOBS
              TGEO(14)=YOBS
              TGEO(15)=ZOBS
              TGEO(16)=SPEC(ILIOBFR)
              CALL hfm(NIDGEO,TGEO)

              PHGEOSUM(ifrq)=PHGEOSUM(ifrq)+SPEC(ILIOBFR)*DA
            ENDDO !ifrq=1,NFREQ

            IF (
     &          TANTHE.LE.PHAPERYPP
     &          .AND.
     &          TANTHE.GE.PHAPERYPM
     &          .AND.
     &          TANPHI.LE.PHAPERZPP
     &          .AND.
     &          TANPHI.GE.PHAPERZPM
     &          .AND.
     &          YPH.LE.PHAPERYP
     &          .AND.
     &          YPH.GE.PHAPERYM
     &          .AND.
     &          ZPH.LE.PHAPERZP
     &          .AND.
     &          ZPH.GE.PHAPERZM
     &          ) THEN

              DO ifrq=1,NFREQ

                TGEO(1)=XPH
                TGEO(2)=YPH
                TGEO(3)=ZPH
                TGEO(4)=-TANTHE
                TGEO(5)=-TANPHI
                TGEO(6)=FREQ(ifrq)
                TGEO(7)=ifrq
                TGEO(8)=ISOUR
                TGEO(9)=XSOUR
                TGEO(10)=YSOUR
                TGEO(11)=ZSOUR
                ILIOBFR=ISOUR+NSOURCE*(IOBS-1+NOBSV*(ifrq-1))
                TGEO(12)=SPEC(ILIOBFR)
     &            *DR2SOUR/DR2PH
                TGEO(13)=XOBS
                TGEO(14)=YOBS
                TGEO(15)=ZOBS
                TGEO(16)=SPEC(ILIOBFR)
                CALL hfm(NIDGEO1,TGEO)

                PHGEOSEL(ifrq)=PHGEOSEL(ifrq)+SPEC(ILIOBFR)*DA
                ILIFR=ISOUR+NSOURCE*(ifrq-1)
                W=SPEC(ILIOBFR)
                PHMEANZ(ILIFR)=PHMEANZ(ILIFR)
     &            +ZPH*W
                PHSIGZ(ILIFR)=PHSIGZ(ILIFR)
     &            +ZPH*ZPH*W
                PHMEANY(ILIFR)=PHMEANY(ILIFR)
     &            +YPH*W
                PHSIGY(ILIFR)=PHSIGY(ILIFR)
     &            +YPH*YPH*W
                WSUM(ILIFR)=WSUM(ILIFR)+W

              ENDDO   !ifrq

C--- APPLY MATRICES OF BEAMLINE

              XBEAM=XPH
              YBEAM=YPH
              ZBEAM=ZPH
              TANTHEB=-TANTHE
              TANPHIB=-TANPHI

              DO J=1,4
                DO I=1,4
                  OPTMAT(I,J)=0.
                ENDDO
              ENDDO

              DO IELEM=1,NPHELEM

                BEAM(1)=ZBEAM
                BEAM(2)=TANPHIB
                BEAM(3)=YBEAM
                BEAM(4)=TANTHEB
                DO J=1,4
                  DO I=1,4
                    OPTMAT(I,J)=PHELEM(I,J,IELEM)
                  ENDDO
                ENDDO

                IF (
     &              BEAM(1).LT.PHELEM(5,1,IELEM)
     &              .OR.
     &              BEAM(1).GT.PHELEM(5,2,IELEM)
     &              .OR.
     &              BEAM(2).LT.PHELEM(5,3,IELEM)
     &              .OR.
     &              BEAM(2).GT.PHELEM(5,4,IELEM)
     &              ) THEN
                  GOTO 90   !OUT OF APERTURE, SKIP BEAM
                ELSE    !APERTURE CUT

                  ZBEAM=
     &              OPTMAT(1,1)*BEAM(1)
     &              +OPTMAT(1,2)*BEAM(2)
     &              +OPTMAT(1,3)*BEAM(3)
     &              +OPTMAT(1,4)*BEAM(4)

                  TANPHIB=
     &              OPTMAT(2,1)*BEAM(1)
     &              +OPTMAT(2,2)*BEAM(2)
     &              +OPTMAT(2,3)*BEAM(3)
     &              +OPTMAT(2,4)*BEAM(4)

                  YBEAM=
     &              OPTMAT(3,1)*BEAM(1)
     &              +OPTMAT(3,2)*BEAM(2)
     &              +OPTMAT(3,3)*BEAM(3)
     &              +OPTMAT(3,4)*BEAM(4)

                  TANTHEB=
     &              OPTMAT(4,1)*BEAM(1)
     &              +OPTMAT(4,2)*BEAM(2)
     &              +OPTMAT(4,3)*BEAM(3)
     &              +OPTMAT(4,4)*BEAM(4)

                  XBEAM=XBEAM+PHELEM(1,2,IELEM)

                ENDIF   !APERTURE CUT

              ENDDO   !NELEM

              DO ifrq=1,NFREQ

                TBEAM(1)=XBEAM
                TBEAM(2)=YBEAM
                TBEAM(3)=ZBEAM
                TBEAM(4)=TANTHEB
                TBEAM(5)=TANPHIB
                TBEAM(6)=FREQ(ifrq)
                TBEAM(7)=ifrq
                TBEAM(8)=ISOUR
                TBEAM(9)=XSOUR
                TBEAM(10)=YSOUR
                TBEAM(11)=ZSOUR
                ILIOBFR=ISOUR+NSOURCE*(IOBS-1+NOBSV*(ifrq-1))
                TBEAM(12)=SPEC(ILIOBFR)*DR2SOUR/DR2PH*FOCUS
                TBEAM(13)=XOBS
                TBEAM(14)=YOBS
                TBEAM(15)=ZOBS
                TBEAM(16)=SPEC(ILIOBFR)
                CALL hfm(NIDGEO2,TBEAM)
                PHBEAM(ifrq)=PHBEAM(ifrq)+SPEC(ILIOBFR)*DA
              ENDDO   !ifrq

90            CONTINUE

            ENDIF   !CUTS

          ENDDO  !ISOUR=1,NSOURCE

        ENDDO !IOBS=1,NOBSV

        CALL MHROUT(NIDGEO,ICYCLE,' ')
        CALL hdeletm(NIDGEO)
        CALL MHROUT(NIDGEO1,ICYCLE,' ')
        CALL hdeletm(NIDGEO1)
        CALL MHROUT(NIDGEO2,ICYCLE,' ')
        CALL hdeletm(NIDGEO2)

        DO ifrq=1,NFREQ
          DO ISOUR=1,NSOURCE
            ILIFR=ISOUR+NSOURCE*(ifrq-1)
            IF (WSUM(ILIFR).NE.0.0d0) THEN
              W=1.D0/WSUM(ILIFR)
              PHMEANZ(ILIFR)=PHMEANZ(ILIFR)*W
              PHMEANY(ILIFR)=PHMEANY(ILIFR)*W
              PHSIGZ(ILIFR)=DSQRT(DABS(
     &          PHSIGZ(ILIFR)*W
     &          -PHMEANZ(ILIFR)*PHMEANZ(ILIFR)))
              PHSIGY(ILIFR)=DSQRT(DABS(
     &          PHSIGY(ILIFR)*W
     &          -PHMEANY(ILIFR)*PHMEANY(ILIFR)))
            ENDIF   !(WSUM(ILIFR))
          ENDDO
        ENDDO

      ENDIF !ABS(IPHASE.GT.1)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'      PHASE_OMP:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'      PHCENX, PHCENY, PHCENZ:'
      WRITE(LUNGFO,*)'      ', PHCENX, PHCENY, PHCENZ
      WRITE(LUNGFO,*)'       PHWID, PHHIG:'
      WRITE(LUNGFO,*)'      ', PHWID, PHHIG
      WRITE(LUNGFO,*)'      NPHASEZ, NPHASEY:', NPHASEZ, NPHASEY
      WRITE(LUNGFO,*)'      MPHASEZ, MPHASEY:', MPHASEZ, MPHASEY
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'      PHAPERZM,  PHAPERZP: ',PHAPERZM, PHAPERZP
      WRITE(LUNGFO,*)'      PHAPERYM,  PHAPERYP: ',PHAPERYM, PHAPERYP
      WRITE(LUNGFO,*)'      PHAPERZPM, PHAPERZPP:',PHAPERZPM, PHAPERZPP
      WRITE(LUNGFO,*)'      PHAPERYPM, PHAPERYPP:',PHAPERYPM, PHAPERYPP
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'      IPHFOLD:         ',iphfold
      WRITE(LUNGFO,*)'      PHBETH, PHBETV:  ',PHBETH,PHBETV
      WRITE(LUNGFO,*)'      PHGSIGZ, PHGSIGY:',PHGSIGZ,PHGSIGY
      WRITE(LUNGFO,*)

      IF (ABS(IPHASE).GT.1) THEN

        WRITE(LUNGFO,*)'      NPHELEM: ',NPHELEM
        DO IELEM=1,NPHELEM
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'      ',(SNGL(PHELEM(1,I,IELEM)),I=1,4)
          WRITE(LUNGFO,*)'      ',(SNGL(PHELEM(2,I,IELEM)),I=1,4)
          WRITE(LUNGFO,*)'      ',(SNGL(PHELEM(3,I,IELEM)),I=1,4)
          WRITE(LUNGFO,*)'      ',(SNGL(PHELEM(4,I,IELEM)),I=1,4)
          WRITE(LUNGFO,*)'      ',(SNGL(PHELEM(5,I,IELEM)),I=1,4)
        ENDDO  !NPHELEM

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'      focus factor:',SNGL(FOCUS)
        WRITE(LUNGFO,*)

        WRITE(LUNGFO,*)'      resulting matrix:'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'      ',(SNGL(TOTMAT(1,I)),I=1,4)
        WRITE(LUNGFO,*)'      ',(SNGL(TOTMAT(2,I)),I=1,4)
        WRITE(LUNGFO,*)'      ',(SNGL(TOTMAT(3,I)),I=1,4)
        WRITE(LUNGFO,*)'      ',(SNGL(TOTMAT(4,I)),I=1,4)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '         photon energy, total intensity, selected intensity, ratio'
        WRITE(LUNGFO,*)
     &    '         (values refere to observation plane):'
        WRITE(LUNGFO,*)
        DO ifrq=1,NFREQ

          IF (PHGEOSUM(ifrq).NE.0.0d0) THEN
            SELGEO=PHGEOSEL(ifrq)/PHGEOSUM(ifrq)
          ELSE
            SELGEO=0.
          ENDIF
          WRITE(LUNGFO,*)'      ',SNGL(FREQ(ifrq))
     &      ,SNGL(PHGEOSUM(ifrq))
     &      ,SNGL(PHGEOSEL(ifrq))
     &      ,SELGEO
        ENDDO

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '         photon energy, selected intensity, beamline intensity, ratio'
        WRITE(LUNGFO,*)
     &    '         (values refere to image plane):'
        WRITE(LUNGFO,*)
        DO ifrq=1,NFREQ

          IF (PHGEOSEL(ifrq).NE.0.0d0) THEN
            SELGEO=PHBEAM(ifrq)/PHGEOSEL(ifrq)
          ELSE
            SELGEO=0.
          ENDIF
          WRITE(LUNGFO,*)'      ',SNGL(FREQ(ifrq))
     &      ,SNGL(PHGEOSEL(ifrq))
     &      ,SNGL(PHBEAM(ifrq))
     &      ,SELGEO
        ENDDO
        WRITE(LUNGFO,*)

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'      Effective source size in phase plane:'
        WRITE(LUNGFO,*)'      ifrq     ISOURCE     Zrms     Yrms'
        WRITE(LUNGFO,*)
        DO ifrq=1,NFREQ
          DO ISOUR=1,NSOURCE
            ILIFR=ISOUR+NSOURCE*(ifrq-1)
            WRITE(LUNGFO,*)'      ',ifrq,ISOUR
     &        ,SNGL(PHSIGZ(ILIFR))
     &        ,SNGL(PHSIGY(ILIFR))
            TSIZ(1)=ifrq
            TSIZ(2)=ISOUR
            TSIZ(3)=PHSIGZ(ILIFR)
            TSIZ(4)=PHSIGY(ILIFR)
            CALL hfm(NIDGEO+3,TSIZ)
          ENDDO
        ENDDO
        CALL MHROUT(NIDGEO+3,ICYCLE,' ')
        CALL hdeletm(NIDGEO+3)

      ENDIF !ABS(IPHASE.GT.1)

      WRITE(LUNGFO,*)

      IF (IHSEL.NE.0) THEN

        IF (ifreq2P.EQ.2) THEN

          FLOW=DLOG10(FREQ(1)/1.5)
          FHIG=DLOG10(FREQ(NFREQ)*1.5)

          call hbook1m(IDSEL,'INTEGRATED PHASESPACE (GEOM. OPTIC)',
     &      NFREQ,FLOW,FHIG,0.)
          call hbook1m(IDSEL+1,
     &      'INTEGRATED ACCEPTED PHASESPACE (GEOM. OPTIC)',
     &      NFREQ,FLOW,FHIG,0.)
          call hbook1m(IDSEL+2,
     &      'RATIO OF INTEGRATED AND ACCEPTED PHASESPACE',
     &      NFREQ,FLOW,FHIG,0.)
          call hbook1m(IDSEL+10,
     &      'INTEGRATED ACCEPTED PHASESPACE AT END OF BEAMLINE',
     &      NFREQ,FLOW,FHIG,0.)
          call hbook1m(IDSEL+11,
     &      'RATIO OF INTEGRATED AND PHASESPACE AFTER BEAMLINE',
     &      NFREQ,FLOW,FHIG,0.)

          DO ifrq=1,NFREQ
            IF (PHGEOSUM(ifrq).GT.0.0d0)
     &        CALL hfillm
     &        (IDSEL,SNGL(FREQ(ifrq)),0.,DLOG10(PHGEOSUM(ifrq)))
            IF (PHGEOSEL(ifrq).GT.0.0d0)
     &        CALL hfillm
     &        (IDSEL+1,SNGL(FREQ(ifrq)),0.,DLOG10(PHGEOSEL(ifrq)))
            IF (PHBEAM(ifrq).GT.0.0d0)
     &        CALL hfillm
     &        (IDSEL+10,SNGL(FREQ(ifrq)),0.,DLOG10(PHBEAM(ifrq)))
          ENDDO

        ELSE

          DF=FREQ(2)-FREQ(1)
          IF (DF.EQ.0.) DF=1.

          FLOW=FREQ(1)-DF/2.
          FHIG=FREQ(NFREQ)+DF/2.

          call hbook1m(IDSEL,'INTEGRATED PHASESPACE (GEOM. OPTIC)',
     &      NFREQ,FLOW,FHIG,0.)
          call hbook1m(IDSEL+1,
     &      'INTEGRATED ACCEPTED PHASESPACE (GEOM. OPTIC)',
     &      NFREQ,FLOW,FHIG,0.)
          call hbook1m(IDSEL+2,
     &      'RATIO OF INTEGRATED AND ACCEPTED PHASESPACE',
     &      NFREQ,FLOW,FHIG,0.)
          call hbook1m(IDSEL+10,
     &      'INTEGRATED ACCEPTED PHASESPACE AT END OF BEAMLINE',
     &      NFREQ,FLOW,FHIG,0.)
          call hbook1m(IDSEL+11,
     &      'RATIO OF INTEGRATED AND PHASESPACE AFTER BEAMLINE',
     &      NFREQ,FLOW,FHIG,0.)

          DO ifrq=1,NFREQ
            CALL hfillm
     &        (IDSEL,SNGL(FREQ(ifrq)),0.,PHGEOSUM(ifrq))
            CALL hfillm
     &        (IDSEL+1,SNGL(FREQ(ifrq)),0.,PHGEOSEL(ifrq))
            CALL hfillm
     &        (IDSEL+10,SNGL(FREQ(ifrq)),0.,PHBEAM(ifrq))
          ENDDO

        ENDIF  !ifreq2P

        CALL hoperam(IDSEL+1,'/',IDSEL,IDSEL+2,1.,1.)
        CALL hoperam(IDSEL+10,'/',IDSEL,IDSEL+11,1.,1.)

        CALL MHROUT(IDSEL,ICYCLE,' ')
        CALL MHROUT(IDSEL+1,ICYCLE,' ')
        CALL MHROUT(IDSEL+2,ICYCLE,' ')
        CALL MHROUT(IDSEL+10,ICYCLE,' ')
        CALL MHROUT(IDSEL+11,ICYCLE,' ')
        CALL hdeletm(IDSEL)
        CALL hdeletm(IDSEL+1)
        CALL hdeletm(IDSEL+2)
        CALL hdeletm(IDSEL+10)
        CALL hdeletm(IDSEL+11)

      ENDIF !IHSEL.NE.0

      if (mhbookp.eq.0.and.iroottrees.ge.0) then
        CALL hrendm('PHASE')
        CLOSE(LUNPH)
        CALL hcdirm(OLDDIR,' ')
      endif

      DEALLOCATE(WSUM)
      DEALLOCATE(PHMEANZ)
      DEALLOCATE(PHMEANY)
      DEALLOCATE(PHSIGZ)
      DEALLOCATE(PHSIGY)
      DEALLOCATE(PHSHIFT)
      DEALLOCATE(AMPLI)
      DEALLOCATE(phspec3)
      DEALLOCATE(phspec3f,phspec3fy)
      deALLOCATE(specwz)
      deALLOCATE(specfwz)
      deALLOCATE(yphw)
      deALLOCATE(specwy)
      deALLOCATE(specfwy)
      DEALLOCATE(EXPOM)
      DEALLOCATE(DEXPOM)
      DEALLOCATE(phws1)
      DEALLOCATE(phws2)
      DEALLOCATE(phws3)
      DEALLOCATE(phws4)
      DEALLOCATE(phcoef)
      DEALLOCATE(freq_omp)

      mthreads=mthreadso

      RETURN
      END
+PATCH,PYTHON,T=PYTHON.
*CMZ :  3.05/04 05/07/2018  14.52.56  by  Michael Scheer
+DECK,make_wave,T=PYTHON.
*CMZ :  4.01/04 11/12/2023  17.18.27  by  Michael Scheer
*CMZ :  4.01/03 29/06/2023  09.29.02  by  Michael Scheer
*CMZ :  4.01/02 07/05/2023  09.12.43  by  Michael Scheer
*-- Author :    Michael Scheer   17/03/2023

# +PATCH,//WAVE/PYTHON
# +DECK,wave_make,T=PYTHON.

import os
import sys
import platform
import glob

def Quit(*args, delay=0):
  #reakpoint()
  nargs =  len(args)

  text = ''
  for i in range(nargs):
    text += str(args[i]) + " "
  #endif

  if delay > 0:

    if len(text):
      print("\n",text, "\nWaiting",delay," seconds before kill")
      #time.sleep(delay)
    else:
      print("\nWaiting",delay," seconds before kill")
      #time.sleep(delay)
    #endif len(text):

    if platform.system() == 'Windows':
      os.system("sleep " + str(delay) + " && taskkill /F /PID " + str(os.getpid()) + " &")
    else:
      os.system("sleep " + str(delay) + " && kill " + str(os.getpid()) + " &")
    #endif platform.system() == 'Windows'

  elif delay < 0:
    return
  else:
    print("\n",text)
    if platform.system() == 'Windows':
      os.system("taskkill /F /PID " + str(os.getpid()))
    else:
      os.system("kill " + str(os.getpid()))
    #endif platform.system() == 'Windows'

#enddef Quit(text = '', delay=0)

global Iverbose,Idry,Idebug,WI

args=sys.argv; nargs = len(args)

try:
  WI = os.environ['WAVE_INCL'] + "/"
except:
  WI = ''
  path = args[0].split("/")
  l = len(path)
  if l == 1:
    path = os.getcwd().split("/")
    path.append(args[0])
  elif l == 2:
    path = os.getcwd().split("/")
    pp = args[0].split("/")
    path.append(pp[0])
    path.append(pp[1])
  #endif
  for i in range(len(path)-2):
    WI += path[i] + "/"
  #endfor
  print("\n*** Warning: Shell variable WAVE_INCL not defined ***")
  print("*** Assuming: ",WI," ***")
  os.system('sleep 3')
#endtry


Iverbose = 0
Idebug = 0
Idry = 0

if nargs > 1:
  try:
    Iverbose = int(args[1])
  except:
    n = '\n'
    print(n)
    print("Usage: python3 " + WI + args[0] + " [verbose level]",n)
    print("To force total recompilation delete ",n,WI + "bin/wave.exe",n)
    Quit()
  #end try
#endif

if nargs > 2: Idebug = int(args[2])

global Wave_tree,Scomp_all,Scomp_omp,Scomp,Texe,Tlib,Scomp_nowarn

Scomp = "gfortran -std=legacy -c -O2 -cpp -fbacktrace -ffpe-summary=invalid,zero,overflow -fdec -fd-lines-as-comments -Wno-align-commons -fno-automatic -ffixed-line-length-none -finit-local-zero -funroll-loops "
Scomp_nowarn = "gfortran -w -std=legacy -c -O2 -cpp -fbacktrace -ffpe-summary=invalid,zero,overflow -fdec -fd-lines-as-comments -Wno-align-commons -fno-automatic -ffixed-line-length-none -finit-local-zero -funroll-loops "
Scomp_all = "gfortran -std=legacy -c -O2 -cpp -fcheck=all -fbacktrace -ffpe-summary=invalid,zero,overflow -fdec -fd-lines-as-comments -Wno-align-commons -fno-automatic -ffixed-line-length-none -finit-local-zero -funroll-loops "
Scomp_omp = "gfortran -std=legacy -c -O2 -cpp -finit-local-zero -fcheck=all -fopenmp -fbacktrace -ffpe-summary=invalid,zero,overflow -fdec -fd-lines-as-comments -Wno-align-commons -ffixed-line-length-none -funroll-loops "

def print_wave_tree():
  global Wave_tree

  ftree = open('wave.tre','w')
  itop = 0

  for topd in Wave_tree:

    itop+=1
    ftree.write('\n' + '---- Directory ' + str(itop) + ' ' + topd[0] + ' ' + str(topd[1]) + '\n\n')

    modfor = topd[2]
    imodfor = 0
    for mf in modfor:
      imodfor+=1
      slin = str(imodfor) + ' mod/' + mf[0] + ' ' + str(mf[1])
      #print(slin)
      ftree.write(slin + '\n')
    #endfor

    ftree.write('\n')
    modmod = topd[3]
    imodmod = 0
    for mm in modmod:
      imodmod+=1
      slin = str(imodmod) + ' ' + mm[0] + ' ' + str(mm[1])
      #print(slin)
      ftree.write(slin + '\n')
    #endfor

    ftree.write('\n')
    cmn = topd[4]
    icmn = 0
    for cm in cmn:
      icmn+=1
      slin = str(icmn) + ' ' + cm[0] + ' ' + str(cm[1])
      #print(slin)
      ftree.write(slin + '\n')
    #endfor

    ftree.write('\n')
    ff = topd[5]
    iff = 0
    for f in ff:
      iff+=1
      slin = str(iff) + ' ' + f[0] + ' ' + str(f[1])
      #print(slin)
      ftree.write(slin + '\n')
    #endfor

  #endfor

  ftree.close()
#    Wave_tree.append([topd,t,modfor,modmod,cmn,fort])
#enddef print_wave_tree()

def get_wave_tree():

  global WI,Wave_tree,Iverbose,Idry,Idebug,Texe,Tlib

  try:
    Texe = os.stat(WI + '/bin/wave.exe').st_mtime_ns
  except:
    Texe = 0
  #endtry

  top = glob.glob(WI+"/*")

  Wave_tree = []
  #reakpoint()

  for topd in top:

    dd = topd.split("/")[-1]

    if dd == 'cmz' or dd == 'doc' or dd == 'check_system' or dd == 'bin' \
    or dd == 'python' or dd == 'main' or dd == 'lib': continue

    t = os.stat(topd).st_mtime_ns

    modf = glob.glob(topd+"/mod/*.f")

    modfor = []
    for ff in modf:
      f = ff.split("/")[-1]
      tf = os.stat(ff).st_mtime_ns
      modfor.append([f,tf])
    #endfor

    modm = glob.glob(topd+"/*.mod")
    modmod = []
    for ff in modm:
      f = ff.split("/")[-1]
      tf = os.stat(ff).st_mtime_ns
      modmod.append([f,tf])
    #endfor

    cm = glob.glob(topd+"/*.cmn")
    cmn = []
    for ff in cm:
      f = ff.split("/")[-1]
      tf = os.stat(ff).st_mtime_ns
      cmn.append([f,tf])
    #endfor

    ff = glob.glob(topd+"/*.f")
    fort = []
    for fff in ff:
      f = fff.split("/")[-1]
      tf = os.stat(fff).st_mtime_ns
      fort.append([f,tf])
    #endfor

    Wave_tree.append([topd,t,modfor,modmod,cmn,fort])

  #endfor get_wave_tree

  #print_wave_tree()

#enddef get_wave_tree

def wave_update():

  global WI,Wave_tree,Texe,Scomp_all,Scomp_omp,Scomp,Iverbose,Idry,Idebug,Scomp_nowarn

  kmain = 0

  get_wave_tree()

  for td in Wave_tree:

    dd = td[0]
    ds = dd + "/"
    dsm = dd + "/mod/"
    t = td[1]
    modfor = td[2]
    cmn = td[4]
    fort = td[5]

    scomp = Scomp

    lib = ''
    libm = ''
    ranl = 0
    ranlm = 0
    slibm = ''
    slib = ''

    ddd = dd.split("/")[-1]

    #reakpoint()

    if ddd == 'mhbook':
      if Iverbose >= 0: print("\nProcessing",dd)
      lib = WI + 'lib/libmhbook.a'
      libm = WI + 'lib/libmhbook_modules.a'
    elif ddd == 'mshcern':
      if Iverbose >= 0: print("\nProcessing",dd)
      lib = WI + 'lib/libmshcern.a'
      libm = WI + 'lib/libmshcern_modules.a'
      scomp = Scomp_nowarn
    elif ddd == 'mshplt':
      if Iverbose >= 0: print("\nProcessing",dd)
      lib = WI + 'lib/libmshplt.a'
      libm = WI + 'lib/libmshplt_modules.a'
    elif ddd == 'nomp':
      if Iverbose >= 0: print("\nProcessing",dd)
      lib = WI + 'lib/libwave.a'
      libm = WI + 'lib/libwave_modules.a'
      scomp = Scomp_all
    elif ddd == 'omp':
      if Iverbose >= 0: print("\nProcessing",dd)
      lib = WI + 'lib/libwave_omp.a'
      libm = WI + 'lib/libwave_omp_modules.a'
      scomp = Scomp_omp
    elif ddd == 'urad':
      if Iverbose >= 0: print("\nProcessing",dd)
      lib = WI + 'lib/liburad.a'
      libm = WI + 'lib/liburad_modules.a'
      scomp = Scomp_all  # uradcfft does boundary tricks
    elif ddd == 'user':
      if Iverbose >= 0: print("\nProcessing",dd)
      lib = WI + 'lib/libuser.a'
      libm = WI + 'lib/libuser_modules.a'
      scomp = Scomp_omp
    #endif

    klib = 0
    try:
      Tlib = os.stat(lib).st_mtime_ns
      if Tlib > Texe: klib = 1
    except:
      klib = 1
    #endtry

    klibm = 0
    try:
      Tlib = os.stat(libm).st_mtime_ns
      if Tlib > Texe: klibm = 1
    except:
      klibm = 1
    #endtry

    scompmod = "cd " + dd + "/mod && " + scomp
    scomp = "cd " + dd + " && " + scomp

    for f in modfor: # Compile modules

      ff = f[0]
      t = f[1]

      if t < Texe and klibm == 0: continue

      if Iverbose > 0: print(ff)

      fo = ff[:-1] + "o"
      fm = ff[:-1] + "mod"

      Flines = open(ds+"mod/"+ff,'r')

      while True:
        l = Flines.readline()
        if not l: break
        sl = l.split()
        if len(sl) == 0: continue
        key = sl[0].lower()
        if key== 'module':
          m = sl[1].lower()
          break
        #endif
      #end while
      Flines.close()

      if Iverbose > 0: print("\nModule:",m)

      scom = scompmod + "-o " + fo + " " + ff
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)

      scom = 'mv ' + dsm + m + ".mod " + dd
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)

      slibm += " " + dsm + fo
      ranlm = 1

      # Search use of module in *.cmn
      for ft in cmn:

        f = ft[0]
        t = ft[1]

        if t < Texe and klibm == 0: continue

        Flines = open(ds+f,'r')
        if Idebug > 1: print("\n",ds+f)

        while True:
          l = Flines.readline()
          if Idebug > 1: print(l)
          if not l: break
          #if len(l) < 10: break
          sl = l.split()
          if len(sl) > 1:
            key = sl[0].lower()
            if key== 'use':
              if sl[1].lower() == m:
                scom = 'touch ' + ds+f
                if Iverbose > 0: print("\n",scom,"\n")
                if Idry == 0: os.system(scom)
                break
              #endif
            #endif
          #endif
        #end while
        Flines.close()

      #endfor

      # Search use of module in *.f
      for ft in fort:

        f = ft[0]
        t = ft[1]

        if Idebug > 1: print(f)

        Flines = open(ds+f,'r')
        while True:
          l = Flines.readline()
          if not l: break
          #if len(l) < 10: break
          sl = l.split()
          if len(sl) > 1:
            key = sl[0].lower()
            if key== 'implicit':
              if sl[1].lower() == 'none': break
            elif key== 'use':
              if sl[1].lower() == m:
                scom = 'touch ' + ds+f
                if Iverbose > 0: print("\n",scom,"\n")
                if Idry == 0: os.system(scom)
                break
              #endif
            #endif
          #endif
        #end while
        Flines.close()

      #endfor

    #endfor modfor

    if ranlm:
      scom = 'ar rc ' + libm + " " + slibm
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)
      scom = 'ranlib ' + libm
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)
      ranlm = 0
      slibm = ''
      kmain = 1
    #endif

    # Check *.cmn

    for ft in cmn:

      f = ft[0]
      #print(f)
      #if f == 'genfun.cmn': debug()
      t = os.stat(ds+f).st_mtime_ns

      if t < Texe and klib == 0: continue

      fcmn = f.split("/")[-1]

      for fft in fort:

        #if fft[0] == 'erzfun.f': debug('erzfun')

        Flines = open(ds+fft[0],'r')
        #Flines = open(ds+fft[0],'r',errors='ignore')
        #Flines = open(ds+fft[0],'r',encoding='latin1') #, errors='ignore')
#        nlin = 0
        while True:
          l = Flines.readline()
          if not l: break
          #if len(l) < 10: break
          sl = l.split()
          #if fft[0] == 'erzfun.f':
#            nlin += 1
#            print(nlin,l)
#            if nlin > 80: debug(nlin)
          if len(sl) < 2: continue
          #print(sl)
          if sl[0][0] == '*' or sl[0][0] == '!' or len(sl[0]) < 7: continue
          key = sl[0].lower()
          #if fft[0] == 'erzfun.f': print(sl)
          if key== 'include':
#            if fft[0] == 'erzfun.f': debug('include')
            if sl[1].lower() == "'" + fcmn + "'" or sl[1].lower() == '"' + fcmn + '"':
              scom = 'touch ' + ds+fft[0]
              if Iverbose > 0: print("\n",scom,"\n")
              if Idry == 0: os.system(scom)
              break
            #endif
          #endif
        #end while
        Flines.close()
#        if fft[0] == 'erzfun.f': Quit()
      #endfor fort

    #endfor cmn

    # Compile *.f if neccessary

    for ft in fort:

      f = ft[0]
#      print(f)
      t = os.stat(ds+f).st_mtime_ns

      if t < Texe and klib == 0: continue

      fo = f[:-1] + "o"

      scom = scomp + "-o " + fo + " " + f
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)

      slib += " " + ds + fo
      ranl = 1

    #endfor

    if ranl:
      scom = 'ar rc ' + lib + " " + slib
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)
      scom = 'ranlib ' + lib
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)
      kmain = 1
      ranl = 0
      slib = ''
    #endif

  #endfor dir

  if kmain:
    scom = WI + "/shell/compile_wave_incl.sh"
    if Iverbose > 0: print("\n",scom,"\n")
    if Idry == 0: os.system(scom)
    if Iverbose >=0: print("\n--- " + WI  + "bin/wave.exe updated ---\n")
  else:
    if Iverbose >=0: print("\n--- No need to update " + WI  + "bin/wave.exe ---\n")
  #endif


#enddef wave_update

def debug(key='debug'):
  print("debug:",key)
#endif

wave_update()
+DECK,make_wave_debug,T=PYTHON.
*CMZ :  4.01/04 11/12/2023  16.29.22  by  Michael Scheer
*CMZ :  4.01/03 28/06/2023  16.38.14  by  Michael Scheer
*CMZ :  4.01/02 07/05/2023  09.58.31  by  Michael Scheer
*-- Author :    Michael Scheer   17/03/2023

# +PATCH,//WAVE/PYTHON
# +DECK,wave_make_debug,T=PYTHON.

import os
import sys
import platform
import glob

def Quit(*args, delay=0):
  #reakpoint()
  nargs =  len(args)

  text = ''
  for i in range(nargs):
    text += str(args[i]) + " "
  #endif

  if delay > 0:

    if len(text):
      print("\n",text, "\nWaiting",delay," seconds before kill")
      #time.sleep(delay)
    else:
      print("\nWaiting",delay," seconds before kill")
      #time.sleep(delay)
    #endif len(text):

    if platform.system() == 'Windows':
      os.system("sleep " + str(delay) + " && taskkill /F /PID " + str(os.getpid()) + " &")
    else:
      os.system("sleep " + str(delay) + " && kill " + str(os.getpid()) + " &")
    #endif platform.system() == 'Windows'

  elif delay < 0:
    return
  else:
    print("\n",text)
    if platform.system() == 'Windows':
      os.system("taskkill /F /PID " + str(os.getpid()))
    else:
      os.system("kill " + str(os.getpid()))
    #endif platform.system() == 'Windows'

#enddef Quit(text = '', delay=0)

global Iverbose,Idry,Idebug,WI

args=sys.argv; nargs = len(args)

try:
  WI = os.environ['WAVE_INCL'] + "/"
except:
  WI = ''
  path = args[0].split("/")
  l = len(path)
  if l == 1:
    path = os.getcwd().split("/")
    path.append(args[0])
  elif l == 2:
    path = os.getcwd().split("/")
    pp = args[0].split("/")
    path.append(pp[0])
    path.append(pp[1])
  #endif
  for i in range(len(path)-2):
    WI += path[i] + "/"
  #endfor
  print("\n*** Warning: Shell variable WAVE_INCL not defined ***")
  print("*** Assuming: ",WI," ***")
  os.system('sleep 3')
#endtry


Iverbose = 0
Idebug = 0
Idry = 0

if nargs > 1:
  try:
    Iverbose = int(args[1])
  except:
    n = '\n'
    print(n)
    print("Usage: python3 " + WI + args[0] + " [verbose level]",n)
    print("To force total recompilation delete ",n,WI + "bin/wave_debug.exe",n)
    Quit()
  #end try
#endif

if nargs > 2: Idebug = int(args[2])

global Wave_tree,Scomp_all,Scomp_omp,Scomp,Texe,Tlib,Scomp_nowarn

Scomp = "gfortran -std=legacy -c -g -cpp -fbacktrace -ffpe-summary=invalid,zero,overflow -fdec -fd-lines-as-comments -Wno-align-commons -fno-automatic -ffixed-line-length-none -finit-local-zero -funroll-loops "
Scomp_nowarn = "gfortran -w -std=legacy -c -g -cpp -fbacktrace -ffpe-summary=invalid,zero,overflow -fdec -fd-lines-as-comments -Wno-align-commons -fno-automatic -ffixed-line-length-none -finit-local-zero -funroll-loops "
Scomp_all = "gfortran -std=legacy -c -g -cpp -fcheck=all -fbacktrace -ffpe-summary=invalid,zero,overflow -fdec -fd-lines-as-comments -Wno-align-commons -fno-automatic -ffixed-line-length-none -finit-local-zero -funroll-loops "
Scomp_omp = "gfortran -std=legacy -c -g -cpp -finit-local-zero -fcheck=all -fopenmp -fbacktrace -ffpe-summary=invalid,zero,overflow -fdec -fd-lines-as-comments -Wno-align-commons -ffixed-line-length-none -funroll-loops "

def get_wave_tree():

  global WI,Wave_tree,Iverbose,Idry,Idebug,Texe,Tlib

  try:
    Texe = os.stat(WI + '/bin/wave_debug.exe').st_mtime_ns
  except:
    Texe = 0
  #endtry

  top = glob.glob(WI+"/*")

  Wave_tree = []
  #reakpoint()

  for topd in top:

    dd = topd.split("/")[-1]

    if dd == 'cmz' or dd == 'doc' or dd == 'check_system' or dd == 'bin' \
    or dd == 'python' or dd == 'main' or dd == 'lib': continue

    t = os.stat(topd).st_mtime_ns

    modf = glob.glob(topd+"/mod/*.f")

    modfor = []
    for ff in modf:
      f = ff.split("/")[-1]
      tf = os.stat(ff).st_mtime_ns
      modfor.append([f,tf])
    #endfor

    modm = glob.glob(topd+"/*.mod")
    modmod = []
    for ff in modm:
      f = ff.split("/")[-1]
      tf = os.stat(ff).st_mtime_ns
      modmod.append([f,tf])
    #endfor

    cm = glob.glob(topd+"/*.cmn")
    cmn = []
    for ff in cm:
      f = ff.split("/")[-1]
      tf = os.stat(ff).st_mtime_ns
      cmn.append([f,tf])
    #endfor

    ff = glob.glob(topd+"/*.f")
    fort = []
    for fff in ff:
      f = fff.split("/")[-1]
      tf = os.stat(fff).st_mtime_ns
      fort.append([f,tf])
    #endfor

    Wave_tree.append([topd,t,modfor,modmod,cmn,fort])

  #endfor get_wave_tree

#enddef get_wave_tree

def wave_update():

  global WI,Wave_tree,Texe,Scomp_all,Scomp_omp,Scomp,Iverbose,Idry,Idebug,Scomp_nowarn

  kmain = 0

  get_wave_tree()

  for td in Wave_tree:

    dd = td[0]
    ds = dd + "/"
    dsm = dd + "/mod/"
    t = td[1]
    modfor = td[2]
    cmn = td[4]
    fort = td[5]

    scomp = Scomp

    lib = ''
    libm = ''
    ranl = 0
    ranlm = 0
    slibm = ''
    slib = ''

    ddd = dd.split("/")[-1]

    if Iverbose >= 0: print("\nProcessing",dd)
    #reakpoint()

    if ddd == 'mhbook':
      lib = WI + 'lib/libmhbook_debug.a'
      libm = WI + 'lib/libmhbook_modules_debug.a'
    elif ddd == 'mshcern':
      lib = WI + 'lib/libmshcern_debug.a'
      libm = WI + 'lib/libmshcern_modules_debug.a'
      scomp = Scomp_nowarn
      #breakpoint()
    elif ddd == 'mshplt':
      lib = WI + 'lib/libmshplt_debug.a'
      libm = WI + 'lib/libmshplt_modules.a'
    elif ddd == 'nomp':
      lib = WI + 'lib/libwave_debug.a'
      libm = WI + 'lib/libwave_modules_debug.a'
      scomp = Scomp_all
    elif ddd == 'omp':
      lib = WI + 'lib/libwave_omp_debug.a'
      libm = WI + 'lib/libwave_omp_modules_debug.a'
      scomp = Scomp_omp
    elif ddd == 'urad':
      lib = WI + 'lib/liburad_debug.a'
      libm = WI + 'lib/liburad_modules_debug.a'
      scomp = Scomp_all  # uradcfft does boundary tricks
    elif ddd == 'user':
      lib = WI + 'lib/libuser_debug.a'
      libm = WI + 'lib/libuser_modules_debug.a'
      scomp = Scomp_omp
    #endif

    klib = 0
    try:
      Tlib = os.stat(lib).st_mtime_ns
      if Tlib > Texe: klib = 1
    except:
      klib = 1
    #endtry

    klibm = 0
    try:
      Tlib = os.stat(libm).st_mtime_ns
      if Tlib > Texe: klibm = 1
    except:
      klibm = 1
    #endtry

    scompmod = "cd " + dd + "/mod && " + scomp
    scomp = "cd " + dd + " && " + scomp

    for f in modfor: # Compile modules

      ff = f[0]
      t = f[1]

      if t < Texe and klibm == 0: continue

      if Iverbose > 0: print(ff)

      fo = ff[:-1] + "o"
      fm = ff[:-1] + "mod"

      Flines = open(ds+"mod/"+ff,'r')

      while True:
        l = Flines.readline()
        if not l: break
        sl = l.split()
        if len(sl) == 0: continue
        key = sl[0].lower()
        if key== 'module':
          m = sl[1].lower()
          break
        #endif
      #end while
      Flines.close()

      if Iverbose > 0: print("\nModule:",m)

      scom = scompmod + "-o " + fo + " " + ff
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)

      scom = 'mv ' + dsm + m + ".mod " + dd
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)

      slibm += " " + dsm + fo
      ranlm = 1

      # Search use of module in *.cmn
      for ft in cmn:

        f = ft[0]
        t = ft[1]

        if t < Texe and klibm == 0: continue

        Flines = open(ds+f,'r')
        while True:
          l = Flines.readline()
          if Idebug > 1: print(l)
          if not l: break
          #if len(l) < 10: break
          sl = l.split()
          if len(sl) > 1:
            key = sl[0].lower()
            if key== 'use':
              if sl[1].lower() == m:
                scom = 'touch ' + ds+f
                if Iverbose > 0: print("\n",scom,"\n")
                if Idry == 0: os.system(scom)
                break
              #endif
            #endif
          #endif
        #end while
        Flines.close()

      #endfor

      # Search use of module in *.f
      for ft in fort:

        f = ft[0]
        t = ft[1]

        if Idebug > 1: print(f)

        Flines = open(ds+f,'r')
        while True:
          l = Flines.readline()
          if not l: break
          #if len(l) < 10: break
          sl = l.split()
          if len(sl) > 1:
            key = sl[0].lower()
            if key== 'implicit':
              if sl[1].lower() == 'none': break
            elif key== 'use':
              if sl[1].lower() == m:
                scom = 'touch ' + ds+f
                if Iverbose > 0: print("\n",scom,"\n")
                if Idry == 0: os.system(scom)
                break
              #endif
            #endif
          #endif
        #end while
        Flines.close()

      #endfor

    #endfor modfor

    if ranlm:
      scom = 'ar rc ' + libm + " " + slibm
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)
      scom = 'ranlib ' + libm
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)
      ranlm = 0
      slibm = ''
      kmain = 1
    #endif

    # Check *.cmn

    for ft in cmn:

      f = ft[0]
      t = os.stat(ds+f).st_mtime_ns

      if t < Texe and klib == 0: continue

      fcmn = f.split("/")[-1]

      for fft in fort:

        Flines = open(ds+fft[0],'r')
        while True:
          l = Flines.readline()
          if not l: break
          #if len(l) < 10: break
          sl = l.split()
          if len(sl) < 2: continue
          if sl[0][0] == '*' or sl[0][0] == '!' or len(sl[0]) < 7: continue
          key = sl[0].lower()
          if key== 'include':
            if sl[1].lower() == "'" + fcmn + "'" or sl[1].lower() == '"' + fcmn + '"':
              scom = 'touch ' + ds+fft[0]
              if Iverbose > 0: print("\n",scom,"\n")
              if Idry == 0: os.system(scom)
              break
            #endif
          #endif
        #end while
        Flines.close()
      #endfor fort

    #endfor cmn

    # Compile *.f if neccessary

    for ft in fort:

      f = ft[0]
      t = os.stat(ds+f).st_mtime_ns

      if t < Texe and klib == 0: continue

      fo = f[:-1] + "o"

      scom = scomp + "-o " + fo + " " + f
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)

      slib += " " + ds + fo
      ranl = 1

    #endfor

    if ranl:
      scom = 'ar rc ' + lib + " " + slib
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)
      scom = 'ranlib ' + lib
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)
      kmain = 1
      ranl = 0
      slib = ''
    #endif

  #endfor dir

  if kmain:
    scom = WI + "/shell/compile_wave_incl_debug.sh"
    if Iverbose > 0: print("\n",scom,"\n")
    if Idry == 0: os.system(scom)
    if Iverbose >=0: print("\n--- " + WI  + "bin/wave_debug.exe updated ---\n")
  else:
    if Iverbose >=0: print("\n--- No need to update " + WI  + "bin/wave_debug.exe ---\n")
  #endif


#enddef wave_update

wave_update()
+DECK,make_wave_win,T=PYTHON.
*CMZ :  4.01/04 07/11/2023  16.09.41  by  Michael Scheer
*CMZ :  4.01/03 18/05/2023  16.35.28  by  Michael Scheer
*CMZ :  4.01/02 07/05/2023  09.12.43  by  Michael Scheer
*-- Author :    Michael Scheer   17/03/2023

# +PATCH,//WAVE/PYTHON
# +DECK,wave_make,T=PYTHON.

import os
import sys
import platform
import glob

def Quit(*args, delay=0):
  #reakpoint()
  nargs =  len(args)

  text = ''
  for i in range(nargs):
    text += str(args[i]) + " "
  #endif

  if delay > 0:

    if len(text):
      print("\n",text, "\nWaiting",delay," seconds before kill")
      #time.sleep(delay)
    else:
      print("\nWaiting",delay," seconds before kill")
      #time.sleep(delay)
    #endif len(text):

    if platform.system() == 'Windows':
      os.system("sleep " + str(delay) + " && taskkill /F /PID " + str(os.getpid()) + " &")
    else:
      os.system("sleep " + str(delay) + " && kill " + str(os.getpid()) + " &")
    #endif platform.system() == 'Windows'

  elif delay < 0:
    return
  else:
    print("\n",text)
    if platform.system() == 'Windows':
      os.system("taskkill /F /PID " + str(os.getpid()))
    else:
      os.system("kill " + str(os.getpid()))
    #endif platform.system() == 'Windows'

#enddef Quit(text = '', delay=0)

global Iverbose,Idry,Idebug,WI

args=sys.argv; nargs = len(args)

try:
  WI = os.environ['WAVE_INCL_WIN'] + "/"
except:
  WI = ''
  path = args[0].split("/")
  l = len(path)
  if l == 1:
    path = os.getcwd().split("/")
    path.append(args[0])
  elif l == 2:
    path = os.getcwd().split("/")
    pp = args[0].split("/")
    path.append(pp[0])
    path.append(pp[1])
  #endif
  for i in range(len(path)-2):
    WI += path[i] + "/"
  #endfor
  print("\n*** Warning: Shell variable WAVE_INCL_WIN not defined ***")
  print("*** Assuming: ",WI," ***")
  os.system('sleep 3')
#endtry


Iverbose = 0
Idebug = 0
Idry = 0

if nargs > 1:
  try:
    Iverbose = int(args[1])
  except:
    n = '\n'
    print(n)
    print("Usage: python3 " + WI + args[0] + " [verbose level]",n)
    print("To force total recompilation delete ",n,WI + "bin/wave_win32.exe",n)
    Quit()
  #end try
#endif

if nargs > 2: Idebug = int(args[2])

global Wave_tree,Scomp_all,Scomp_omp,Scomp,Texe,Tlib,Scomp_nowarn

fort = "x86_64-w64-mingw32-gfortran-win32 "

Scomp =fort + "-std=legacy -c -O2 -cpp -fbacktrace -ffpe-summary=invalid,zero,overflow -fdec -fd-lines-as-comments -Wno-align-commons -fno-automatic -ffixed-line-length-none -finit-local-zero -funroll-loops "
Scomp_nowarn =fort + "-w -std=legacy -c -O2 -cpp -fbacktrace -ffpe-summary=invalid,zero,overflow -fdec -fd-lines-as-comments -Wno-align-commons -fno-automatic -ffixed-line-length-none -finit-local-zero -funroll-loops "
Scomp_all =fort + "-std=legacy -c -O2 -cpp -fcheck=all -fbacktrace -ffpe-summary=invalid,zero,overflow -fdec -fd-lines-as-comments -Wno-align-commons -fno-automatic -ffixed-line-length-none -finit-local-zero -funroll-loops "
Scomp_omp =fort + "-std=legacy -c -O2 -cpp -finit-local-zero -fcheck=all -fopenmp -fbacktrace -ffpe-summary=invalid,zero,overflow -fdec -fd-lines-as-comments -Wno-align-commons -ffixed-line-length-none -funroll-loops "

def get_wave_tree():

  global WI,Wave_tree,Iverbose,Idry,Idebug,Texe,Tlib

  try:
    Texe = os.stat(WI + '/bin/wave_win32.exe').st_mtime_ns
  except:
    Texe = 0
  #endtry

  top = glob.glob(WI+"/*")

  Wave_tree = []
  #reakpoint()

  for topd in top:

    dd = topd.split("/")[-1]

    if dd == 'cmz' or dd == 'doc' or dd == 'check_system' or dd == 'bin' \
    or dd == 'python' or dd == 'main' or dd == 'lib': continue

    t = os.stat(topd).st_mtime_ns

    modf = glob.glob(topd+"/mod/*.f")

    modfor = []
    for ff in modf:
      f = ff.split("/")[-1]
      tf = os.stat(ff).st_mtime_ns
      modfor.append([f,tf])
    #endfor

    modm = glob.glob(topd+"/*.mod")
    modmod = []
    for ff in modm:
      f = ff.split("/")[-1]
      tf = os.stat(ff).st_mtime_ns
      modmod.append([f,tf])
    #endfor

    cm = glob.glob(topd+"/*.cmn")
    cmn = []
    for ff in cm:
      f = ff.split("/")[-1]
      tf = os.stat(ff).st_mtime_ns
      cmn.append([f,tf])
    #endfor

    ff = glob.glob(topd+"/*.f")
    fort = []
    for fff in ff:
      f = fff.split("/")[-1]
      tf = os.stat(fff).st_mtime_ns
      fort.append([f,tf])
    #endfor

    Wave_tree.append([topd,t,modfor,modmod,cmn,fort])

  #endfor get_wave_tree

#enddef get_wave_tree

def wave_update():

  global WI,Wave_tree,Texe,Scomp_all,Scomp_omp,Scomp,Iverbose,Idry,Idebug,Scomp_nowarn

  kmain = 0

  get_wave_tree()

  for td in Wave_tree:

    dd = td[0]
    ds = dd + "/"
    dsm = dd + "/mod/"
    t = td[1]
    modfor = td[2]
    cmn = td[4]
    fort = td[5]

    scomp = Scomp

    lib = ''
    libm = ''
    ranl = 0
    ranlm = 0
    slibm = ''
    slib = ''

    ddd = dd.split("/")[-1]

    if Iverbose >= 0: print("\nProcessing",dd)
    #reakpoint()

    if ddd == 'mhbook':
      lib = WI + 'lib/libmhbook.a'
      libm = WI + 'lib/libmhbook_modules.a'
    elif ddd == 'mshcern':
      lib = WI + 'lib/libmshcern.a'
      libm = WI + 'lib/libmshcern_modules.a'
      scomp = Scomp_nowarn
    elif ddd == 'mshplt':
      lib = WI + 'lib/libmshplt.a'
      libm = WI + 'lib/libmshplt_modules.a'
    elif ddd == 'nomp':
      lib = WI + 'lib/libwave.a'
      libm = WI + 'lib/libwave_modules.a'
      scomp = Scomp_all
    elif ddd == 'omp':
      lib = WI + 'lib/libwave_omp.a'
      libm = WI + 'lib/libwave_omp_modules.a'
      scomp = Scomp_omp
    elif ddd == 'urad':
      lib = WI + 'lib/liburad.a'
      libm = WI + 'lib/liburad_modules.a'
      scomp = Scomp_all  # uradcfft does boundary tricks
    elif ddd == 'user':
      lib = WI + 'lib/libuser.a'
      libm = WI + 'lib/libuser_modules.a'
      scomp = Scomp_omp
    #endif

    try:
      Tlib = os.stat(lib).st_mtime_ns
      if Tlib > Texe: kmain = 1
    except:
      pass
    #endtry
    try:
      Tlib = os.stat(libm).st_mtime_ns
      if Tlib > Texe: kmain = 1
    except:
      pass
    #endtry

    scompmod = "cd " + dd + "/mod && " + scomp
    scomp = "cd " + dd + " && " + scomp

    for f in modfor: # Compile modules

      ff = f[0]
      t = f[1]

      if t < Texe: continue

      if Iverbose > 0: print(ff)

      fo = ff[:-1] + "o"
      fm = ff[:-1] + "mod"

      Flines = open(ds+"mod/"+ff,'r')

      while True:
        l = Flines.readline()
        if not l: break
        sl = l.split()
        if len(sl) == 0: continue
        key = sl[0].lower()
        if key== 'module':
          m = sl[1].lower()
          break
        #endif
      #end while
      Flines.close()

      if Iverbose > 0: print("\nModule:",m)

      scom = scompmod + "-o " + fo + " " + ff
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)

      scom = 'mv ' + dsm + m + ".mod " + dd
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)

      slibm += " " + dsm + fo
      ranlm = 1

      # Search use of module in *.cmn
      for ft in cmn:

        f = ft[0]
        t = ft[1]

        if t < Texe: continue

        Flines = open(ds+f,'r')
        while True:
          l = Flines.readline()
          if Idebug > 1: print(l)
          if not l: break
          if len(l) < 10: break
          sl = l.split()
          if len(sl) > 1:
            key = sl[0].lower()
            if key== 'use':
              if sl[1].lower() == m:
                scom = 'touch ' + ds+f
                if Iverbose > 0: print("\n",scom,"\n")
                if Idry == 0: os.system(scom)
                break
              #endif
            #endif
          #endif
        #end while
        Flines.close()

      #endfor

      # Search use of module in *.f
      for ft in fort:

        f = ft[0]
        t = ft[1]

        if Idebug > 1: print(f)

        Flines = open(ds+f,'r')
        while True:
          l = Flines.readline()
          if not l: break
          if len(l) < 10: break
          sl = l.split()
          if len(sl) > 1:
            key = sl[0].lower()
            if key== 'implicit':
              if sl[1].lower() == 'none': break
            elif key== 'use':
              if sl[1].lower() == m:
                scom = 'touch ' + ds+f
                if Iverbose > 0: print("\n",scom,"\n")
                if Idry == 0: os.system(scom)
                break
              #endif
            #endif
          #endif
        #end while
        Flines.close()

      #endfor

    #endfor modfor

    if ranlm:
      scom = 'ar rc ' + libm + " " + slibm
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)
      scom = 'ranlib ' + libm
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)
      ranlm = 0
      slibm = ''
      kmain = 1
    #endif

    # Check *.cmn

    for ft in cmn:

      f = ft[0]
      t = os.stat(ds+f).st_mtime_ns

      if t < Texe: continue

      fcmn = f.split("/")[-1]

      for fft in fort:

        Flines = open(ds+fft[0],'r')
        while True:
          l = Flines.readline()
          if not l: break
          if len(l) < 10: break
          sl = l.split()
          if sl[0][0] == '*' or sl[0][0] == '!' or len(sl) < 6: continue
          key = sl[0].lower()
          if key== 'include':
            if sl[1].lower() == "'" + fcmn + "'" or sl[1].lower() == '"' + fcmn + '"':
              scom = 'touch ' + ds+fft[0]
              if Iverbose > 0: print("\n",scom,"\n")
              if Idry == 0: os.system(scom)
              break
            #endif
          #endif
        #end while
        Flines.close()
      #endfor fort

    #endfor cmn

    # Compile *.f if neccessary

    for ft in fort:

      f = ft[0]
      t = os.stat(ds+f).st_mtime_ns

      if t < Texe: continue

      fo = f[:-1] + "o"

      scom = scomp + "-o " + fo + " " + f
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)

      slib += " " + ds + fo
      ranl = 1

    #endfor

    if ranl:
      scom = 'ar rc ' + lib + " " + slib
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)
      scom = 'ranlib ' + lib
      if Iverbose > 0: print("\n",scom,"\n")
      if Idry == 0: os.system(scom)
      kmain = 1
      ranl = 0
      slib = ''
    #endif

  #endfor dir

  if kmain:
    scom = WI + "/shell/compile_wave_incl_cross_win32.sh"
    if Iverbose > 0: print("\n",scom,"\n")
    if Idry == 0: os.system(scom)
    if Iverbose >=0: print("\n--- " + WI  + "bin/wave_win32.exe updated ---\n")
  else:
    if Iverbose >=0: print("\n--- No need to update " + WI  + "bin/wave_win32.exe ---\n")
  #endif


#enddef wave_update

wave_update()
+DECK,msh_ipylogon_neu,T=PYTHON.
*CMZ :  4.01/04 08/11/2023  10.45.27  by  Michael Scheer
*-- Author :    Michael Scheer   08/11/2023
# +PATCH,//WAVE/PYTHON
# +DECK,msh_ipylogon_neu,T=PYTHON.

print("\n--- wave msh_pylogon.py ---\n")
#plt.style.use('seaborn-dark')

import sys,os

args=sys.argv; nargs = len(args)
pwd = os.getcwd()

import m_hbook as m
from m_hbook import *
from numpy import *

args=sys.argv; nargs = len(args)
seed(0)

NL = '\n'
BL = ' '

ntuples = 0
histos = 1

global Irunmin,Irunmax

def get_phase_error(run):
  Fout = open("a/wave.out." + run,"r")
  fout = Fout.readlines()
  ifound = 0
  for line in fout:
    if ifound:
      phwav = float(line.split()[0])
      phdeg = float(line.split()[1])
      Fout.close()
      return phwav,phdeg
    #endif
    if re.search('deg.\)',line):
      ifound = 1
    #endif
  #endfor
#enddef

def ns0peak(nt):

  iemax = -1
  emax = 0.0
  s0max = -1.0

  res = npeaks(nt,"e:s0/1.0e6",isilent=1,iretval=1)

  try:
    s0list = res[2]
    s0max = 0.0
    for i in range(len(s0list)):
      s0 = s0list[i]
      if s0 > s0max:
        s0max = s0
        is0 = i
      #endif
    #endfor
    iemax = res[0][i]
    emax = res[1][i]
  except:
    print("*** Warning in ns0peak: Bad return from npeaks ***\n")
#    ninfo(nt)
#    Quit("\n*** Aborted in ns0peak(nt)")
  #endtry
  return iemax,emax,s0max
#enddef

def phase_error( key = "stokes", \
fs0="wave_stokes_selected.dat",\
fs0f="wave_stokesf_selected.dat", \
fs0e="wave_stokese_selected.dat", \
fs0ef="wave_stokesef_selected.dat", \
fs0ref="/home/scheer/spectra/wav/a/wave_halbach_pencil_on-axis.dat.1060", \
fs0reff="/home/scheer/spectra/wav/a/wave_halbach_emit_on-axis.dat.949", \
fs0refe="/home/scheer/spectra/wav/a/wave_halbach_espread_on-axis.dat.950", \
fs0refef="/home/scheer/spectra/wav/a/wave_halbach_emit_espread_on-axis.dat.951", \
fall="SRI22_phase-errors.dat"
):

#fs0ref="/home/scheer/spectra/wav/a/wave_halbach_pencil_on-axis.dat.476", \
#fs0reff="/home/scheer/spectra/wav/a/wave_halbach_emit_on-axis.dat.477", \
#fs0refe="/home/scheer/spectra/wav/a/wave_halbach_espread_on-axis.dat.478", \
#fs0refef="/home/scheer/spectra/wav/a/wave_halbach_emit_espread_on-axis.dat.479", \

  global Nhead,Ntup,Nind,Nntup,Irunmin,Irunmax

  nl = "\n"
  print("Ref:",nl,fs0ref,nl,fs0refe,nl,fs0reff,nl,fs0refef,nl)
  print(key,nl,fs0,nl,fs0e,nl,fs0f,nl,fs0ef)

  Irunmin = 1e20
  Irunmax = -1e20

  iruns0 = 0
  iruns0e = 0
  iruns0f = 0
  iruns0ef = 0
  iruns0ref = 0

  vs0ene = None
  vs0 = None
  vs0f = None
  vs0e = None
  vs0ef = None

  optnstat()

  if nexist("ns0"): ndelete("ns0")
  if nexist("ns0e"): ndelete("ns0e")
  if nexist("ns0f"): ndelete("ns0f")
  if nexist("ns0ef"): ndelete("ns0ef")

  if nexist("ns0ref"): ndelete("ns0ref")
  if nexist("ns0refe"): ndelete("ns0refe")
  if nexist("ns0reff"): ndelete("ns0reff")
  if nexist("ns0refef"): ndelete("ns0refef")

  ns0ref = ncread("ns0ref","e:s0:s1:s2:s3",fs0ref,silent=1,skiphead=2)
  iemaxr,emaxr,s0ref = ns0peak(ns0ref)
  vs0refene = ns0ref['e']
  vs0ref = ns0ref['s0']/1.e6
  nener = len(vs0ref)

  ns0reff = ncread("ns0reff","e:s0:s1:s2:s3",fs0reff,silent=1,skiphead=2)
  iemaxrf,emaxrf,s0reff = ns0peak(ns0reff)
  vs0refenef = ns0reff['e']
  vs0reff = ns0reff['s0']/1.e6

  ns0refe = ncread("ns0refe","e:s0:s1:s2:s3",fs0refe,silent=1,skiphead=2)
  iemaxre,emaxre,s0refe = ns0peak(ns0refe)
  vs0refenee = ns0refe['e']
  vs0refe = ns0refe['s0']/1.e6

  ns0refef = ncread("ns0refef","e:s0:s1:s2:s3",fs0refef,silent=1,skiphead=2)
  iemaxref,emaxref,s0refef = ns0peak(ns0refef)
  vs0refeneef = ns0refef['e']
  vs0refef = ns0refef['s0']/1.e6

  phwav = -9999.
  phdeg = -9999.

  try:
    F = open(fs0,"r")
    runs0 = F.readline().strip().split()[0].strip()
    F.close()
    iruns0 = int(runs0)
    phwav,phdeg = get_phase_error(runs0)
    if iruns0 < Irunmin: Irunmin = iruns0
    if iruns0 > Irunmax: Irunmax = iruns0
    ns0 = ncread("ns0","e:s0:s1:s2:s3",fs0,silent=1,skiphead=2)
    if len(ns0) != nener: print("\n*** Warning: Strange number of energies for ns0 ***")
  except:
    print("*** File",fs0,"not found ***")
    Quit("Schlecht")
    return iruns0,iruns0e,iruns0f,iruns0ef,iruns0ef
  #endtry

  try:
    F = open(fs0e,"r")
    runs0e = F.readline().strip().split()[0].strip()
    F.close()
    iruns0e = int(runs0e)
    if iruns0e < Irunmin: Irunmin = iruns0e
    if iruns0e > Irunmax: Irunmax = iruns0e
    ns0e = ncread("ns0e","e:s0:s1:s2:s3",fs0e,silent=1,skiphead=2)
    if len(ns0e) != nener: print("\n*** Warning: Strange number of energies for ns0e ***")
  except: pass

  try:
    F = open(fs0f,"r")
    runs0f = F.readline().strip().split()[0].strip()
    F.close()
    iruns0f = int(runs0f)
    if iruns0f < Irunmin: Irunmin = iruns0f
    if iruns0f > Irunmax: Irunmax = iruns0f
    ns0f = ncread("ns0f","e:s0:s1:s2:s3",fs0f,silent=1,skiphead=2)
    if len(ns0f) != nener: print("\n*** Warning: Strange number of energies for ns0f ***")
  except: pass

  try:
    F = open(fs0ef,"r")
    runs0ef = F.readline().strip().split()[0].strip()
    iruns0ef = int(runs0ef)
    F.close()
    if iruns0ef < Irunmin: Irunmin = iruns0ef
    if iruns0ef > Irunmax: Irunmax = iruns0ef
    ns0ef = ncread("ns0ef","e:s0:s1:s2:s3",fs0ef,silent=1,skiphead=2)
    if len(ns0ef) != nener: print("\n*** Warning: Strange number of energies for ns0ef ***")
  except: pass

  nplc(ns0,"e:s0/1.0e6")

  iemax,emax,s0max = ns0peak(ns0)
  if iemax < 0: s0max = -1.

  vs0ene = ns0['e']
  vs0 = ns0['s0']/1.e6
  vs0e = vs0 * 0.0
  vs0f = vs0 * 0.0
  vs0ef = vs0 * 0.0

  eharmf = 0.0
  eharme = 0.0
  eharmef = 0.0
  s0harmf  =  1.0
  s0harme  =  1.0
  s0harmef =  1.0

  legend("S0max, rref   " + g3(s0max) + "   " + g5(s0max/s0ref))

  cruns = str(Irunmin) + "-" + str(Irunmax)
  tit = "On-axis flux-density for " + key + " (Runs " + cruns + ")"
  txyz(tit,"E$_{ph}$ [eV]","N$_{ph}$/s/mm$^{2}$/100mA/0.1%BW")

  Fred = open("a/real_beam_" + key.strip() + "_" + cruns + ".dat","w")

  print("\nS0ref:   " + g5(s0ref))
  print("S0max:   " + g5(s0max) + "   " + g5(s0max/s0ref))
  Fred.write("S0ref: " + g5(s0ref) + "\n")
  Fred.write("S0max: " + g5(s0max) + "   " + g5(s0max/s0max)  + "   " + g5(s0max/s0ref) + "\n")

  if nexist("ns0f"):
    optnstat()
    nplcgs(ns0f,"e:s0/1.0e6")
    iemaxf,emaxf,s0maxf = ns0peak(ns0f)
    if iemax > 0:
      s0harmf = ns0f.s0[iemax]/1.e6
      eharmf = ns0f.e[iemax]
    vs0enef = ns0f['e']
    vs0f = ns0f['s0']/1.e6
    rdf = s0maxf/s0max
    rdhf = s0harmf/s0max
    line1 = "S0max_f,  Emax_f, rdf  : " + g3(s0maxf)  + BL + g5(emaxf)  \
    + BL + g3(rdf)
    line2 = "S0harm_f, Emax_p,  rdhf : " + g3(s0harmf) + BL + g5(eharmf) \
    + BL + g3(rdhf)
    legend(line1 + "\n" + line2 + "   " + g5(s0max/s0ref))
    print("\n" + line1 + "\n" + line2 + "   " + g5(s0max/s0ref))
    Fred.write("\n" + line1 + "\n" + line2 + "\n")
  #endif

  if nexist("ns0e"):
    optnstat()
    nplcbs(ns0e,"e:s0/1.0e6")
    iemaxe,emaxe,s0maxe = ns0peak(ns0e)
    if iemax > 0:
      s0harme = ns0e.s0[iemax]/1.e6
      eharme = ns0e.e[iemax]
    vs0enee = ns0e['e']
    vs0e = ns0e['s0']/1.e6
    rde = s0maxe/s0max
    rdhe = s0harme/s0max
    line1 = "S0max_e,  Emax_e, rde  : " + g3(s0maxe)  + BL + g5(emaxe)  \
    + BL + g3(rde)
    line2 = "S0harm_e, Emax_p,  rdhe : " + g3(s0harme) + BL + g5(eharme) \
    + BL + g3(rdhe)
    legend(line1 + "\n" + line2 + "   " + g5(s0max/s0ref))
    print("\n" + line1 + "\n" + line2 + "   " + g5(s0max/s0ref))
    Fred.write("\n" + line1 + "\n" + line2 + "\n")
  #endif

  if nexist("ns0ef"):
    optnstat()
    nplccs(ns0ef,"e:s0/1.0e6")
    iemaxef,emaxef,s0maxef = ns0peak(ns0ef)
    if iemax > 0:
      s0harmef = ns0ef.s0[iemax]/1.e6
      eharmef = ns0ef.e[iemax]
    vs0eneef = ns0ef['e']
    vs0ef = ns0ef['s0']/1.e6
    rdef = s0maxef/s0max
    rdhef = s0harmef/s0max
    line1 = "S0max_ef,  Emax_ef, rdef  : " + g3(s0maxef)  + BL + g5(emaxef)  \
    + BL + g3(rdef)
    line2 = "S0harm_ef, Emax_p,  rdhef : " + g3(s0harmef) + BL + g5(eharmef) \
    + BL + g3(rdhef)
    legend(line1 + "\n" + line2 + "   " + g5(s0max/s0ref))
    print("\n" + line1 + "\n" + line2 + "   " + g5(s0max/s0ref))
    Fred.write("\n" + line1 + "\n" + line2 + "\n")
  #endif

  Fred.close()

  pp("a/real_beam_" + key.strip() + "_" + cruns + ".pdf")
  legend()
  pp("a/real_beam_" + key.strip() + "_" + cruns + "_legend.pdf")

  nsig = nget("nsig")

  Fall = open(fall,"a")

  s0maxp =s0max
  s0refp =s0ref

  ksig = int(key.split("_")[1]) - 1
  phsig = nsig.phsig[ksig]

  #  Type beam  run  S0p  S0_pen S0H_pen S0H S0p/S0_pen S0p/S0H_pen S0p/S0H
  res = key + " pencil  " + runs0 + BL + g5(phsig) + BL + g5(phwav)  + BL + g5(phdeg) + BL \
  + g5(s0maxp) + BL + g5(s0maxp) + BL \
  + g5(s0refp) + BL + g5(s0refp) + BL \
  + g5(s0maxp/s0maxp) + BL + g5(s0maxp/s0refp) + BL + g5(s0maxp/s0refp)

  print(res)
  Fall.write(res+nl)

  #  Type beam  run  S0f  S0_pen S0H_en S0H S0f/S0_pen S0f/S0H_pen S0f/S0H
  res = key + " emit    " + runs0f + BL + g5(phsig) + BL + g5(phwav)  + BL + g5(phdeg) + BL \
  + g5(s0maxf) + BL + g5(s0maxp) + BL \
  + g5(s0refp) + BL + g5(s0reff) + BL \
  + g5(s0maxf/s0maxp) + BL + g5(s0maxf/s0refp) + BL + g5(s0maxf/s0reff)

  print(res)
  Fall.write(res+nl)

  #  Type beam  run  S0e  S0_pen S0H_pen S0H S0e/S0_pen S0e/S0H_pen S0e/S0H
  res = key + " espread " + runs0e + BL + g5(phsig) + BL + g5(phwav)  + BL + g5(phdeg) + BL \
  + g5(s0maxe) + BL + g5(s0maxp) + BL \
  + g5(s0refp) + BL + g5(s0refe) + BL \
  + g5(s0maxe/s0maxp) + BL + g5(s0maxe/s0refp) + BL + g5(s0maxe/s0refe)

  print(res)
  Fall.write(res+nl)

  #  Type beam  run  S0ef  S0_pen S0H_pen S0H S0ef/S0_pen S0ef/S0H_pen S0ef/S0H
  res = key + " em+esp  " + runs0ef + BL + g5(phsig) + BL + g5(phwav)  + BL + g5(phdeg) + BL \
  + g5(s0maxef) + BL + g5(s0maxp) + BL \
  + g5(s0refp) + BL + g5(s0refef) + BL \
  + g5(s0maxef/s0maxp) + BL + g5(s0maxef/s0refp) + BL + g5(s0maxef/s0refef)

  print(res)

  Fall.write(res+nl)

  Fall.close()

  optnstat()

  return vs0ene,vs0,vs0f,vs0e,vs0ef

#enddef

if args[1] == "last":
  try:
    Farg = open("ipylogon.arg","r")
    argl = Farg.readlines()
    Farg.close()
    args = []
    for arg in argl: args.append(arg.strip())
    #print(args[1:])
  except: pass
#endif

if not args[1] == "last" and nargs > 1:
  Farg = open("ipylogon.arg","w")
  for arg in args: Farg.write(arg + "\n")
  Farg.close()
#endif

if nargs > 1:

  if args[1] == "last":
    try:
      Farg = open("ipylogon.arg","r")
      argl = Farg.readlines()
      Farg.close()
      args = []
      for arg in argl: args.append(arg.strip())
      #print(args[1:])
    except: pass
  #endif

  if not args[1] == "last" and nargs > 1:
    Farg = open("ipylogon.arg","w")
    for arg in args: Farg.write(arg + "\n")
    Farg.close()
  #endif

  if args[1] == "none":

    pass

  elif args[1] == "default":

    idefault = 0

    if idefault == 1:

      nphi = 6
      rin = 10.0000
      rout = 20.
      h = 50.
      dphi = 180.
      xcen = 0.0
      ycen = 0.
      zcen = 0.0

      ncyl = ncylinder('ncyl_1',
                       xcen,ycen,zcen,rout-rin,rin,rin,h,0.0,90.,dphi,nphi,1)

      #nc = ncylinder(phi=90,dphi=dphi,n=nphi)
      poly = plotncylinder(ncyl)

  elif args[1] == "hull3d":

    n=ncread("n","x:y:z","hull.dat")
    vert,ifaces,faces,bounds = hull3d(n.x,n.y,n.z)

    iplot = 4

    if iplot == 1: vplothull3d(n.x,n.y.n.z)
    elif iplot == 2: vplothull3d(n.x,n.y,n.z,mode='volume')
    elif iplot == 3:vert,ifaces,faces,bounds=nhull3d(n,"x:y:z",iretval=1)
    elif iplot == 3:vert,ifaces,faces,bounds=nhull3d(n,"x:y:z",iretval=1)
    elif iplot == 4: plotfaces(faces)

  elif args[1] == "look":

    if nargs > 2: fdat = args[2]
    else: fdat = 'look.dat'
    Nlook = nlook("Nlook",fdat)
    # consider mlook(fdat) to get m.Nlook

  elif args[1] == "gui":

    import waveplot as w
    from waveplot import *
    set_console_title("wavesPython")
    optconsole()

  elif args[1] == "old":

    import old as w
    from old import *
    set_console_title("wavesPython")
    optconsole()

  elif args[1] == "urad":

    import waveplot as w
    from waveplot import *

    set_console_title("Plot urad_phase")
    optconsole()

    fnam = open("urad_phase.nam","r")
    flines = fnam.readlines()
    fnam.close()

    fpin = open("urad_phase.pin",'r')
    pin = fpin.readline().strip().split()
    pincen = fpin.readline().strip().split()
    fpin.close()

    npinz = int(pin[0])
    npiny = int(pin[1])
    pinw = float(pin[2])
    pinh = float(pin[3])

    pinx = float(pincen[0])
    piny = float(pincen[1])
    pinz = float(pincen[2])

    ymin = piny - pinh/2.
    ymax = piny + pinh/2.

    zmin = pinz - pinw/2.
    zmax = pinz + pinw/2.

    if npiny > 1:
      dy = (ymax-ymin)/(npiny-1)
    else:
      dy = pinh
    #endif

    if npinz > 1:
      dz = (zmax-zmin)/(npinz-1)
    else:
      dz = pinw
    #endif

    nfld = ncread("nfld","x:y:z:iegam:egam:s0:s1:s2:s3:p:exr:exi:eyr:eyi:ezr:ezi:bxr:bxi:byr:byi:bzr:bzi:nx:ny:nz","urad_phase.fld")
    nbun = ncread("nbun","jbun:isub:ibu:bunchx:rxi1:ryi1:rzi1:ypi1:zpi1:rxin:ryin:rzin:ypin:zpin:eel:deel:x:y:z:iegam:egam:spec:s0:s1:s2:s3:p:fb28:dt:axr:axi:ayr:ayr:azr:azi","urad_phase.bun")

    s0max = nfld.s0.max()
    s3max = nfld.s3.max()
    print(pg5(s0max))
    #if not isnan(s0max): kplot = 1

    if nargs > 2:

      if args[2] == 's0pin':

        s0max = nfld.s0.max()
        emax = nfld.query("s0=="+str(s0max)).egam.max()
        selgam = "abs(egam-" + str(emax) + ")<1.0e-10"

        if npinz > 1 and npiny > 1:
          hbook2('Hpin','distribution in pinhole',npinz,zmin,zmax,npiny,ymin,ymax)
          nproj2(nfld,"z:y","s0",selgam,idh='Hpin',ioverwrite=0)
        elif npinz > 1:
          hbook1('Hpin','distribution in pinhole',npinz,zmin,zmax)
          nproj1(nfld,"z","s0",selgam,idh='Hpin',ioverwrite=0)
        elif npiny > 1:
          hbook1('Hpin','distribution in pinhole',npiny,ymin,ymax)
          nproj1(nfld,"y","s0",selgam,idh='Hpin',ioverwrite=0)
        elif len(nbun) > 0:
          hbook2('Hpin','distribution in pinhole',npinz,zmin,zmax,npiny,ymin,ymax)
          nproj2( nbun,"z:y","s0",selgam,idh='Hpin',ioverwrite=0)
        #endif

        hplave('Hpin')
        txyz("nfld,z:y:fd (" + selgam +")")

      #endif

    else:

      kplot = 1

      #nsto = ncread("nsto","x:y:z:iegam:egam:s0:s1:s2:s3","urad_phase.sto")
      nflx = ncread("nflx","iegam:egam:s0:s1:s2:s3","urad_phase.flx")
      nfld = ncread("nfld","x:y:z:iegam:egam:s0:s1:s2:s3:p:exr:exi:eyr:eyi:ezr:ezi:bxr:bxi:byr:byi:bzr:bzi:nx:ny:nz","urad_phase.fld")
      nbun = ncread("nbun","jbun:isub:ibu:bunchx:rxi1:ryi1:rzi1:ypi1:zpi1:rxin:ryin:rzin:ypin:zpin:eel:deel:x:y:z:iegam:egam:spec:s0:s1:s2:s3:p:fb28:dt:axr:axi:ayr:ayr:azr:azi","urad_phase.bun")

      #ninfo(nsto)
      #ninfo(nfld)
      #ninfo(nflx)
      #ninfo(nbun)
      #Quit(pg5(nfld.s0.max()))

      if kplot == 2:
        npll(nfld,"egam:s0")
        setxstat(0.8)
        npllgs(nfld,"egam:s3")
        #nplmgs(nbun,"egam:s0","egam>0")
      #endif

      if kplot == 1:

        s0max = nfld.s0.max()
        emax = nfld.query("s0=="+str(s0max)).egam.max()
        selgam = "abs(egam-" + str(emax) + ")<1.0e-10"

        if npinz > 1 and npiny > 1:
          hbook2('Hpin','distribution in pinhole',npinz,zmin,zmax,npiny,ymin,ymax)
          nproj2(nfld,"z:y","s0",selgam,idh='Hpin',ioverwrite=0)
        elif npinz > 1:
          hbook1('Hpin','distribution in pinhole',npinz,zmin,zmax)
          nproj1(nfld,"z","s0",selgam,idh='Hpin',ioverwrite=0)
        elif npiny > 1:
          hbook1('Hpin','distribution in pinhole',npiny,ymin,ymax)
          nproj1(nfld,"y","s0",selgam,idh='Hpin',ioverwrite=0)
        elif len(nbun) > 0:
          hbook2('Hpin','distribution in pinhole',npinz,zmin,zmax,npiny,ymin,ymax)
          nproj2( nbun,"z:y","s0",selgam,idh='Hpin',ioverwrite=0)
        #endif

        if nfld.iegam.max() == 1:
          if npinz > 1 and npiny > 1:
            hbook2('HpinEzR','Ez_real in pinhole',npinz,zmin,zmax,npiny,ymin,ymax)
            nproj2(nfld,"z:y","ezr",selgam,idh='HpinEzR',ioverwrite=0)
          elif npinz > 1:
            hbook1('HpinEzR','Ez_real in pinhole',npinz,zmin,zmax)
            nproj1(nfld,"z","ezr",selgam,idh='HpinEzR',ioverwrite=0)
          elif npiny > 1:
            hbook1('HpinEzR','Ez_real in pinhole',npiny,ymin,ymax)
            nproj1(nfld,"y","ezr",selgam,idh='HpinEzR',ioverwrite=0)
          elif len(nbun) > 0:
            hbook2('HpinEzR','Ez_real in pinhole',npinz,zmin,zmax,npiny,ymin,ymax)
            nproj2( nbun,"z:y","ezr",selgam,idh='HpinEzR',ioverwrite=0)
          #endif
          if npinz > 1 and npiny > 1:
            hbook2('HpinEyR','Ey_real in pinhole',npinz,zmin,zmax,npiny,ymin,ymax)
            nproj2(nfld,"z:y","eyr",selgam,idh='HpinEyR',ioverwrite=0)
          elif npinz > 1:
            hbook1('HpinEyR','Ey_real in pinhole',npinz,zmin,zmax)
            nproj1(nfld,"z","eyr",selgam,idh='HpinEyR',ioverwrite=0)
          elif npiny > 1:
            hbook1('HpinEyR','Ey_real in pinhole',npiny,ymin,ymax)
            nproj1(nfld,"y","eyr",selgam,idh='HpinEyR',ioverwrite=0)
          elif len(nbun) > 0:
            hbook2('HpinEyR','Ey_real in pinhole',npinz,zmin,zmax,npiny,ymin,ymax)
            nproj2( nbun,"z:y","eyr",selgam,idh='HpinEyR',ioverwrite=0)
          #endif
        #endif

        print("\n","Eg:",emax, " eV")

        if kplot > 0 and npinz*npiny > 1:
          if nfld.iegam.max() > 1:
            zone(2,2)
            nprof(nfld,"egam:s0")
            txyz('nsto,"egam:s0"')
            nextzone()
            npl(nfld,"egam:s0","abs(y)<1.0e-6 and abs(z)<1.0e-6")
            txyz('nsto,"egam:s0","abs(y)<1.0e-6 and abs(z)<1.0e-6"')
            nextzone()
            npl(nflx,"egam:s0")
            txyz("nflx,'egam:s0'")
            nextzone()
            hplave('Hpin')
            txyz("nfld,z:y:fd (" + selgam +")")
          else:
            zone(2,1)
            hplave('HpinEzR')
            txyz("Ez_Real")
            nextzone()
            hplave('HpinEyR')
            txyz("Ey_Real")
            #            nextzone()
            #            hplave('Hpin')
            #            txyz("Flux_dens.")
          #endif
        elif kplot > 0:
          if len(nbun):
            optnstat()
            npl(nbun,"egam:s0",plopt='prof')
            optstat()
            nplmgs(nbun,"egam:s0","ibu==1")
          else:
            npl(nfld,"egam:s0")
          #endif
        #endif

      #endif kplot > 0

    #endif nargs > 2

  elif args[1] == "overview" or args[1] == "over" or args[1] == "ov":
    if os.path.exists("WAVE.mhb"):
      import waveplot as w
      from waveplot import *
      WaveOverview()
    #endif os.path.exists("WAVE.mhb"):

  elif args[1] == "ndistpin" or args[1] == "pin":

    if os.path.exists("WAVE.mhb"):
      import waveplot as w
      from waveplot import *
      ndistpin()
    #endif os.path.exists("WAVE.mhb"):

  elif args[1] == "ndistpinv" or args[1] == "pinv" or args[1] == "vcut":

    if os.path.exists("WAVE.mhb"):
      import waveplot as w
      from waveplot import *
      ndistpinv()
    #endif os.path.exists("WAVE.mhb"):

  elif args[1] == "ndistpinh" or args[1] == "pinh" or args[1] == "hcut":

    if os.path.exists("WAVE.mhb"):
      import waveplot as w
      from waveplot import *
      ndistpinh()
    #endif os.path.exists("WAVE.mhb"):

  elif args[1] == "serie":

    #if os.path.exists("WAVE.mhb"):

    #import waveplot as w
    #from waveplot import *

    fil = "wave_serie_pencil_selected.dat"
    F = open(fil,"r")
    runs0 = F.readline().strip().split()[0].strip()
    ns0 = ncread("ns0","e:s0:s1:s2:s3",fil,silent=1,skiphead=2)
    F.close()

    fil = "wave_serie_espread_selected.dat"
    F = open(fil,"r")
    runs0e = F.readline().strip().split()[0].strip()
    ns0e = ncread("ns0e","e:s0:s1:s2:s3",fil,silent=1,skiphead=2)
    F.close()

    fil = "wave_serie_emit_selected.dat"
    F = open(fil,"r")
    runs0f = F.readline().strip().split()[0].strip()
    ns0f = ncread("ns0f","e:s0:s1:s2:s3",fil,silent=1,skiphead=2)
    F.close()

    fil = "wave_serie_emit_espread_selected.dat"
    F = open(fil,"r")
    runs0ef = F.readline().strip().split()[0].strip()
    ns0ef = ncread("ns0ef","e:s0:s1:s2:s3",fil,silent=1,skiphead=2)
    F.close()

    optnstat()

    nplc(ns0,"e:s0/1.0e6")
    #s0max = ns0.s0.max()/1.0e6
    iemax,emax,s0max = ns0peak(ns0)

    legend("S0,      " + g3(s0max))

    tit = "Ideal Undulator, Real Beam, (" + runs0 + "-" + runs0ef + ")"
    txyz(tit,"E$_{ph}$ [eV]","N$_{ph}$/s/mm$^{2}$/100mA/0.1%BW")

    Fred = open("real_beam_serie_selected.dat","w")

    print("S0max:   " + g5(s0max))
    Fred.write("S0max: " + g5(s0max) + "\n")

    if nexist("ns0e"):
      nplcbs(ns0e,"e:s0/1.0e6")
      iemaxe,emaxe,s0maxe = ns0peak(ns0e)
      if iemax > 0: s0harme = ns0e.s0[iemax]/1.e6
      rde = s0maxe/s0max
      rdhe = s0harme/s0max
      line1 = "S0max_e, rde  : " + g3(s0maxe) + BL + g3(rde)
      line2 = "S0harm_e, rdhe: " + g3(s0harme) + BL + g3(rdhe)
      legend(line1 + "\n" + line2)
      print("\n" + line1 + "\n" + line2)
      Fred.write("\n" + line1 + "\n" + line2 + "\n")
    #endif

    if nexist("ns0f"):
      nplcgs(ns0f,"e:s0/1.0e6")
      iemaxf,emaxf,s0maxf = ns0peak(ns0f)
      if iemax > 0: s0harmf = ns0f.s0[iemax]/1.e6
      rdf = s0maxf/s0max
      rdhf = s0harmf/s0max
      line1 = "S0max_f, rdf  : " + g3(s0maxf) + BL + g3(rdf)
      line2 = "S0harm_f, rdhf: " + g3(s0harmf) + BL + g3(rdhf)
      legend(line1 + "\n" + line2)
      print("\n" + line1 + "\n" + line2)
      Fred.write("\n" + line1 + "\n" + line2 + "\n")
    #endif

    if nexist("ns0ef"):
      nplccs(ns0ef,"e:s0/1.0e6")
      iemaxef,emaxef,s0maxef = ns0peak(ns0ef)
      if iemax > 0: s0harmef = ns0ef.s0[iemax]/1.e6
      rdef = s0maxef/s0max
      rdhef = s0harmef/s0max
      line1 = "S0max_ef, rdef  : " + g3(s0maxef) + BL + g3(rdef)
      line2 = "S0harm_ef, rdhef: " + g3(s0harmef) + BL + g3(rdhef)
      legend(line1 + "\n" + line2)
      print("\n" + line1 + "\n" + line2)
      Fred.write("\n" + line1 + "\n" + line2 + "\n")
    #endif

    legend()
    Fred.close()

    pp("real_beam_serie_selected.pdf")

  elif args[1] == "ErnteAlt" or args[1] == "EA" :

    fall = "SRI22_phase-errors_Johannes.dat"
    nph = ncread("nph","key:beam:run:phsig:phwav:phdeg:s0:s0p:s0hp:s0h:rdp:rdhp:rdb",fall)

    ninfo(nph)

    optnstat()

    for btype in ['emit','espread','em+esp']:

      circ()
      phpl = "phsig:s0/s0hp"
      npl(nph,phpl,"beam=='pencil' and key=='bend_01'",legend='bend, single e-')
      nplmbs(nph,phpl,"beam=='pencil' and key=='cos_01'",legend='cos, single e-')
      nplmgs(nph,phpl,"beam=='pencil' and key=='sin_01'",legend='sin, single e-')
      nplmcs(nph,phpl,"beam=='pencil' and key=='taper_01'",legend='taper, single e-')

      bull()
      phpl = "phsig:rdb"
      sel = "beam=='" + btype + "' and key=='bend_01'"

      nplmrs(nph,phpl,sel + " and key=='bend_01'",legend='bend, beam')
      nplmbs(nph,phpl,sel + " and key=='cos_01'",legend='cos, beam')
      nplmgs(nph,phpl,sel + " and key=='sin_01'",legend='sin, beam')
      nplmcs(nph,phpl,sel + " and key=='taper_01'",legend='taper, beam')
      legend()
      txyz("Effect of Field Errors (" + btype + ")","phase error","Normalized of flux-density")

      for key in ['bend','cos','sin','taper']:
        for beam in ['pencil',btype]:

          bull()
          if beam == 'pencil': circle()

          for n in range(1,14):

            phpl = "phsig:rdb"
            if beam == 'pencil': phpl = "phsig:s0p/s0hp"

            if n < 10: keyn = key + "_0" + str(n)
            else: keyn = key + "_" + str(n)

            sel = "beam=='" + beam + "'  and key=='" + keyn + "'"

            if key == 'bend':
              nplmrs(nph,phpl,sel)
            elif key == 'cos':
              nplmbs(nph,phpl,sel)
            elif key == 'sin':
              nplmgs(nph,phpl,sel)
            elif key == 'taper':
              nplmcs(nph,phpl,sel)
            #endif

          #endfor
        #endfor
      #endfor

      fs = fall.split(".")
      fpdf = ""
      for f in fs[:-1]: fpdf += f

      pp(fpdf+"_"+btype+".pdf")
      pp(fpdf+"_"+btype+".png")

    #endfor

  elif args[1] == "Ernte" or args[1] == "E" :

    fall = "SRI22_phase-errors_Johannes.dat"
    nph = ncread("nph","key:beam:run:phsig:phwav:phdeg:s0:s0p:s0hp:s0h:rdp:rdhp:rdb",fall)

    ninfo(nph)

    optnstat()

    for btype in ['emit','espread','em+esp']:

      circ()
      phpl = "phwav*7.:s0/s0hp"
      npl(nph,phpl,"beam=='pencil' and key=='bend_01'",legend='bend, single e-')
      nplmbs(nph,phpl,"beam=='pencil' and key=='cos_01'",legend='cos, single e-')
      nplmgs(nph,phpl,"beam=='pencil' and key=='sin_01'",legend='sin, single e-')
      nplmcs(nph,phpl,"beam=='pencil' and key=='taper_01'",legend='taper, single e-')

      bull()
      phpl = "phwav*7.:rdb"
      sel = "beam=='" + btype + "' and key=='bend_01'"

      nplmrs(nph,phpl,sel + " and key=='bend_01'",legend='bend, beam')
      nplmbs(nph,phpl,sel + " and key=='cos_01'",legend='cos, beam')
      nplmgs(nph,phpl,sel + " and key=='sin_01'",legend='sin, beam')
      nplmcs(nph,phpl,sel + " and key=='taper_01'",legend='taper, beam')
      legend()
      txyz("IVUE32, 7th Harmonic, 2500 keV, Effect of Field Errors (" + btype + ")","n x phase error [rad]","Normalized of flux-density")

      for key in ['bend','cos','sin','taper']:
        for beam in ['pencil',btype]:

          bull()
          if beam == 'pencil': circle()

          for n in range(1,14):

            phpl = "phwav*7.:rdb"
            if beam == 'pencil': phpl = "phwav*7.:s0p/s0hp"

            if n < 10: keyn = key + "_0" + str(n)
            else: keyn = key + "_" + str(n)

            sel = "beam=='" + beam + "'  and key=='" + keyn + "'"

            if key == 'bend':
              nplmrs(nph,phpl,sel)
            elif key == 'cos':
              nplmbs(nph,phpl,sel)
            elif key == 'sin':
              nplmgs(nph,phpl,sel)
            elif key == 'taper':
              nplmcs(nph,phpl,sel)
            #endif

          #endfor
        #endfor
      #endfor

      fs = fall.split(".")
      fpdf = ""
      for f in fs[:-1]: fpdf += f

      pp(fpdf+"_"+btype+".pdf")
      pp(fpdf+"_"+btype+".png")

      ndump(nph,"phwav*7.:s0/s0hp:phsig:key","beam=='pencil'","SRI22_phase-errors_Johannes_pencil.dat")
      ndump(nph,"phwav*7.:rdb:phsig:key","beam=='emit'","SRI22_phase-errors_Johannes_emit.dat")
      ndump(nph,"phwav*7.:rdb:phsig:key","beam=='espread'","SRI22_phase-errors_Johannes_espread.dat")
      ndump(nph,"phwav*7.:rdb:phsig:key","beam=='em+esp'","SRI22_phase-errors_Johannes_emit_espread.dat")

    #endfor

  elif args[1] == "Johannes" or args[1] == "J":

    nsig = ncread("nsig","phsig","n_sigma_phi-corrected.dat")

    fall = "SRI22_phase-errors_Johannes.dat"
    Fall = open(fall,"w")
    Fall.write("* Type beam  run  PhSig PhErr_r PhErr_d S0  S0_pen S0H_pen S0H S0/S0_pen S0/S0H_pen S0/S0H\n")
    date = time.asctime(time.localtime(time.time()))
    Fall.write("* " + date + "\n")
    Fall.close()

    Fprot = open("serie_Johannes.pro","w")

    for key in ['bend','cos','sin','taper']:
      for n in range(1,14):

        if n < 10: keyn = key + "_0" + str(n)
        else: keyn = key + "_" + str(n)

        print(NL,keyn,NL)

        flis = key + ".lis"
        stat = os.system("rm " + flis + " 2>/dev/null")
        stat = os.system("ls -1 a/wave_*" + keyn + "* >> " + flis)
        os.system("cat " + flis)
        sleep(1)
        Flis = open(flis,"r")
        fdo = Flis.readlines()
        Flis.close()

        if len(fdo) == 4:
          nf = 0
          for f in fdo:
            nf += 1
            f = f.strip()
            for i in range(5):
              if re.search("pencil",f):
                fs0p = f
                runp = f.split(".")[-1]
              elif re.search("emit_espread",f):
                fs0ef =f
                runef = f.split(".")[-1]
              elif re.search("emit",f):
                fs0f =f
                runf = f.split(".")[-1]
              elif re.search("espread",f):
                fs0e =f
                rune = f.split(".")[-1]
              else: Quit("*** Bad key-word in " + f)
            #endif
          #endfor
        #endfor

        vs0ene,vs0p,vs0f,vs0e,vs0ef = phase_error(keyn,fs0p,fs0f,fs0e,fs0ef,fall=fall)

        phdeg,phwav = get_phase_error(runp)
        write(Fprot,keyn,phdeg,phwav)

      #endif 4 files
    #endfor key

    Fprot.close()
    Quit()

  elif args[1] == "b0erroramprep":

    fserie = "/home/scheer/wav/stage/serie_amprep.out"
    namp = ncread("namp","run:iseed:key:pherr:e:s0",fserie)
    ninfo(namp)

    fserie = "/home/scheer/wav/work/serie_b0error_pencil.out"
    nb00 = ncread("nb00","run:iseed:b0err:pherr:e:s0",fserie)
    ninfo(nb00)

    fserie = "/home/scheer/wav/work/serie_b0error.out"
    nb0 = ncread("nb0","run:iseed:b0err:pherr:e:s0",fserie)
    ninfo(nb0)

    smpencil = nstat(namp,"s0","key=='pencil' and pherr==0",isilent=1)
    smemit = nstat(namp,"s0","key=='emit' and pherr==0",isilent=1)
    smespread = nstat(namp,"s0","key=='espread' and pherr==0",isilent=1)
    smemiesp = nstat(namp,"s0","key=='emiesp' and pherr==0",isilent=1)

    smbunch = nstat(nb0,"s0","b0err==0",isilent=1)
    smb00= nstat(nb00,"s0","b0err==0",isilent=1)

    optnstat()

    nharm=7
    sharmrad = str(nharm * pi/180.)

    verror=ncopv(namp,"pherr","iseed==1 and key=='pencil'")
    vwalker = exp(-(verror/180.*pi*nharm)**2)
    verrscl = verror * nharm * pi/180.
    vplxy(verrscl,vwalker,"spline",color='black',label='Walker')

    key = 'all'

    if key == 'pencil':
      circ()
      sm=str(smpencil[2])
      nplmrs(namp,sharmrad + "*pherr:s0/"+sm,"key=='pencil'",legend="s0")
      bull()
      npl(namp,sharmrad + "*pherr:s0/"+sm,"","","sameprof",legend="s0_mean + sig_mean",color='g')
    #endif

    if key == 'all':

      sm=str(smb00[2])
      bull()
      npl(nb00,sharmrad + "*pherr:s0/"+sm,"","","same",legend="pencil",color='black')

      sm=str(smbunch[2])
      npl(nb0,sharmrad + "*pherr:s0/"+sm,"","","same",legend="bunch",color='magenta')

      sm=str(smpencil[2])
      npl(namp,sharmrad + "*pherr:s0/"+sm,"key=='pencil'","","sameprof",legend="pencil",color='r')
      sm=str(smemit[2])
      circ()
      npl(namp,sharmrad + "*pherr:s0/"+sm,"key=='emit'","","sameprof",legend="emit",color='g')
      sm=str(smespread[2])
      npl(namp,sharmrad + "*pherr:s0/"+sm,"key=='espread'","","sameprof",legend="espread",color='b')
      sm=str(smemiesp[2])
      bull()
      npl(namp,sharmrad + "*pherr:s0/"+sm,"key=='emiesp'","","sameprof",legend="emit + espread",color='c')

    #endif

    legend()
    txyz("Effects of Phase Errors on the 7th Harmonic","n x PhErr [rad]","Rel. on-axis Flux-density")

  elif args[1] == "b0error":

    fserie = "serie_b0error.out"

    nb0 = ncread("nb0","run:iseed:b0err:pherr:e:s0",fserie)
    ninfo(nb0)

    optnstat()
    #nplt(nb0,"b0err:pherr","","","prof")
    nplt(nb0,"pherr:s0","","","prof")

  elif args[1] == "amprep":

    fserie = "serie_amprep.out"

    namp = ncread("namp","run:iseed:key:pherr:e:s0",fserie)
    ninfo(namp)

    smpencil = nstat(namp,"s0","key=='pencil' and pherr==0",isilent=1)
    smemit = nstat(namp,"s0","key=='emit' and pherr==0",isilent=1)
    smespread = nstat(namp,"s0","key=='espread' and pherr==0",isilent=1)
    smemiesp = nstat(namp,"s0","key=='emiesp' and pherr==0",isilent=1)

    optnstat()

    nharm=7
    sharmrad = str(nharm * pi/180.)

    verror=ncopv(namp,"pherr","iseed==1 and key=='pencil'")
    vwalker = exp(-(verror/180.*pi*nharm)**2)
    verrscl = verror * nharm * pi/180.
    vplxy(verrscl,vwalker,"spline",color='black',label='Walker')

    key = 'all'

    if key == 'pencil':
      circ()
      sm=str(smpencil[2])
      nplmrs(namp,sharmrad + "*pherr:s0/"+sm,"key=='pencil'",legend="s0")
      bull()
      npl(namp,sharmrad + "*pherr:s0/"+sm,"","","sameprof",legend="s0_mean + sig_mean",color='g')
    #endif

    if key == 'all':
      sm=str(smpencil[2])
      npl(namp,sharmrad + "*pherr:s0/"+sm,"key=='pencil'","","sameprof",legend="pencil",color='r')
      sm=str(smemit[2])
      circ()
      npl(namp,sharmrad + "*pherr:s0/"+sm,"key=='emit'","","sameprof",legend="emit",color='g')
      sm=str(smespread[2])
      npl(namp,sharmrad + "*pherr:s0/"+sm,"key=='espread'","","sameprof",legend="espread",color='b')
      sm=str(smemiesp[2])
      bull()
      npl(namp,sharmrad + "*pherr:s0/"+sm,"key=='emiesp'","","sameprof",legend="emit + espread",color='c')
    #endif

    legend()
    txyz("Effects of Phase Errors on the 7th Harmonic","n x PhErr [rad]","Rel. on-axis Flux-density")

  elif args[1] == "amprep_alt":

    fall = "amprep/amprep.dat"
    famp = open(fall,"w")

    nfiles = 0
    nkeys = 0

    for fkey in ["pencil","emit","espread","emiesp"]:

      nkeys += 1
      files = glob.glob("amprep/*" + fkey + "*selected*")
      nfiles += len(files)

      for af in files:
        #          print(af)
        ff = af.split("/")[1]
        try:
          fs = ff.split("_")
          key = fs[1]
          pherr = fs[2]
          seed = fs[4].split(".")[0]
        except:
          Quit(af)
        #endtry
        #          if key == 'pencil': pheall.append(float(pherr))
        fdat = open(af,"r")
        lines = fdat.readlines()
        fdat.close()
        il=0
        for l in lines:
          il += 1
          if il <= 2: continue
          famp.write(key + " " + pherr + " " + seed + " " + l)
        #endfor

      #endfor files

    #endfor fkey

    famp.close()

    namp=ncread("namp","key:phe:seed:e:s0:s1:s2:s3",fall)
    ninfo(namp)

    nseeds = int(namp.seed.max())
    emin = namp.e.min()
    pheall = ncopv(namp,"phe","e == " + str(emin) + " and seed == 1 " + " and key == 'pencil'")
    nerr = len(pheall)

    ierr0 = -1
    for ierr in range(nerr):
      if pheall[ierr] == 0:
        ierr0 = ierr
        break
      #endif
    #endfor

    if ierr0 == -1: Quit("*** Fehler: Zero error case is missing ***")

    s0maxpencil = np.zeros([nerr,nseeds])
    s0maxemit = np.zeros([nerr,nseeds])
    s0maxespread = np.zeros([nerr,nseeds])
    s0maxemiesp = np.zeros([nerr,nseeds])

    iplot = 1
    if iplot > 1:
      optnstat()
      zone(2,1)
    #endif

    iph = 0

    for ierr in range(nerr):

      spherr = str(pheall[ierr])

      for kseed in range(nseeds):

        iseed = kseed + 1
        seed = str(iseed)

        sel = "seed == " + seed + " and phe == " + spherr + " and key == 'pencil'"
        s0maxpencil[ierr,kseed] = namp.query(sel).s0.max()
        if iplot > 1:
          nplls(namp,"e:s0/1.e6",sel)
          if iph == 0: legend('pencil')
        #endif

        sel = "seed == " + seed + " and phe == " + spherr + " and key == 'emit'"
        s0maxemit[ierr,kseed] = namp.query(sel).s0.max()

        if iplot > 1:
          npllgs(namp,"e:s0/1.e6",sel)
          if iph == 0: legend('emit')
        #endif

        sel = "seed == " + seed + " and phe == " + spherr + " and key == 'espread'"
        s0maxespread[ierr,kseed] = namp.query(sel).s0.max()

        if iplot > 1:
          npllbs(namp,"e:s0/1.e6",sel)
          if iph == 0: legend('espread')
        #endif

        sel = "seed == " + seed + " and phe == " + spherr + " and key == 'emiesp'"
        s0maxemiesp[ierr,kseed] = namp.query(sel).s0.max()
        #          if spherr == '0.0' or spherr == '1.0':
        #            print(ierr,seed,kseed,spherr,s0maxemiesp[ierr,kseed])
        if iplot > 1:
          npllcs(namp,"e:s0/1.e6",sel)
          if iph == 0:
            legend('emit + espread')
            legend()
          #endif
        #endif

        iph += 1
        #if iph > 5: break

      #endfor iseed

    #endfor pherr

    if iplot > 1: nextzone()

    fv = open("amprep/recover.dat","w")

    if iplot:

      circ()

      verror = vcre(nerr)
      vpencil = vcre(nerr)
      vemit = vcre(nerr)
      vespread = vcre(nerr)
      vemiesp = vcre(nerr)

      iph = 0

      #        print("\n")
      for iseed in range(nseeds):

        for ierr in range(nerr):

          verror[ierr] = pheall[ierr]

          vpencil[ierr] = s0maxpencil[ierr,iseed] / s0maxpencil[ierr0,iseed]
          vemit[ierr] = s0maxemit[ierr,iseed] / s0maxemit[ierr0,iseed]
          vespread[ierr] = s0maxespread[ierr,iseed] / s0maxespread[ierr0,iseed]
          vemiesp[ierr] = s0maxemiesp[ierr,iseed] / s0maxemiesp[ierr0,iseed]

          fwrite(fv,iseed,ierr,verror[ierr], \
          vpencil[ierr],vemit[ierr],vespread[ierr],vemiesp[ierr])

          if vemiesp[ierr] > 1: print(ierr,iseed,verror[ierr], \
          s0maxemiesp[ierr,iseed], \
          s0maxemiesp[ierr0,iseed])

        #endfor pherr

        if iph == 0:
          vplxy(verror,vpencil,label='pencil')
        #endif

        vplxy(verror+0.2,vemit,'same',color='g')
        if iph == 0: legend('emit')
        vplxy(verror-0.2,vespread,'same',color='b')
        if iph == 0: legend('espread')
        vplxy(verror,vemiesp,'same',color='c')
        if iph == 0:
          legend('emit + espread')
          legend()
          txyz("Effects of Phase Errors on Brilliance","phase error [degree]","rel. reduction")
        #endif

        vplxy(verror,vpencil,'same',color='r')

        iph += 1
        #if iph > 3: break
        #break

      #endfor iseed

      fv.close()
      ns0 = ncread("ns0","is:ie:err:pen:emi:esp:emiesp","amprep/recover.dat")
      ninfo(ns0)

      winr()
      optnstat()
      bull()

      verrsort=vsortx(verror)
      vwalker = exp(-(verrsort/180.*pi*7)**2)
      vplxy(verrsort,vwalker,"spline",color='black',label='Walker')

      npl(ns0,"err:pen","","","sameprof",legend='pencil')
      npl(ns0,"err:emi","","","sameprof",color='g',legend='emit')
      npl(ns0,"err:esp","","","sameprof",color='b',legend='espread')
      npl(ns0,"err:emiesp","","","sameprof",color='c',legend='emit + espread')

      legend()

      txyz("Effects of Phase Errors on Brilliance","phase error [degree]","rel. reduction")

    #endif iplot


    #      sel = "phe == 0 and key == 'espread'"
    #      npllb(namp,"e:s0/1.e6",sel,legend='espread')

  elif args[1] == "bend_01":

    ipencil = 567
    iemit = ipencil + 1
    iespread = ipencil + 2
    ief = ipencil + 3

    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error("bend_01",
                "a/wave_bend_01_pencil_on-axis.dat." + str(ipencil),
                "a/wave_bend_01_emit_on-axis.dat." + str(iemit),
                "a/wave_bend_01_espread_on-axis.dat." + str(iespread),
                "a/wave_bend_01_emit_espread_on-axis.dat." + str(ief),
                fall="real_beam_bend_01.dat")

  elif args[1] == "phase_bend":

    ipencil = 340
    ipencil = 482
    iemit = ipencil + 1
    iespread = ipencil + 2
    ief = ipencil + 3

    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error("bend",
                "a/wave_bend_pencil_on-axis.dat." + str(ipencil),
                "a/wave_bend_emit_on-axis.dat." + str(iemit),
                "a/wave_bend_espread_on-axis.dat." + str(iespread),
                "a/wave_bend_emit_espread_on-axis.dat." + str(ief),
                fall="real_beam_bend.dat")

  elif args[1] == "phase_bold":

    #if os.path.exists("WAVE.mhb"):

    try: nb = ncread("nb","e:s0:s1:s2:s3", \
    "a/wave_bend_pencil_on-axis.dat.340",skiphead=2)
    except: pass

    try: nbf = ncread("nbf","e:s0:s1:s2:s3", \
    "a/wave_bend_emit_on-axis.dat.341",skiphead=2)
    except: pass

    try: nbe = ncread("nbe","e:s0:s1:s2:s3", \
    "a/wave_bend_espread_on-axis.dat.342",skiphead=2)
    except: pass

    try: nbef = ncread("nbef","e:s0:s1:s2:s3", \
    "a/wave_bend_emit_espread_on-axis.dat.343",skiphead=2)
    except: pass

    optnstat()

    try: nplc(nb,"e:s0/1.0e6")
    except: pass

    try: nplcbs(nbe,"e:s0/1.0e6")
    except: pass

    try: nplcgs(nbf,"e:s0/1.0e6")
    except: pass

    try: nplccs(nbef,"e:s0/1.0e6")
    except: pass

    try: s0max = nb.s0.max()/1.0e6
    except: pass

    try: s0maxe = nbe.s0.max()/1.0e6
    except: pass

    try: s0maxf = nbf.s0.max()/1.0e6
    except: pass

    try: s0maxef = nbef.s0.max()/1.0e6
    except: pass

    try: text(0.6,0.9,"S0 Maximum: "+g3(s0max),halign='left')
    except: pass

    try:
      rde = s0maxe/s0max
      text(0.6,0.8,"Reduction e-spread: "+g3(rde),halign='left')
    except: pass

    try:
      rdf = s0maxf/s0max
      text(0.6,0.7,"Reduction emit.: "+g3(rdf),halign='left')
    except: pass

    try:
      rdef = s0maxef/s0max
      text(0.6,0.6,"Reduction both: "+g3(rdef),halign='left')
    except: pass

    txyz("Phase Error (bend.dat), Real Beam, 7th Harm.","E$_{ph}$ [eV]","N$_{ph}$/s/mm$^{2}$/100mA/0.1%BW")

    Fred = open("real_beam_bend_340-343.dat","w")

    try:
      print("S0max: " + g5(s0max))
      Fred.write("S0max: " + g5(s0max) + "\n")
    except: pass

    try:
      print("S0max_f, rdf: " + g5(s0maxf) + BL + g5(rdf))
      Fred.write("S0max_f, rdf: " + g5(s0maxf) + BL + g5(rdf) + "\n")
    except: pass

    try:
      print("S0max_e, rde: " + g5(s0maxe) + BL + g5(rde))
      Fred.write("S0max_e, rde: " + g5(s0maxe) + BL + g5(rde) + "\n")
    except: pass

    try:
      print("S0max_ef, rdef: " + g5(s0maxef) + BL + g5(rdef))
      Fred.write("S0max_ef, rdef: " + g5(s0maxef) + BL + g5(rdef) + "\n")
    except: pass

    Fred.close()

    pp("real_beam_bend_340-343.pdf")

  elif args[1] == "phase_s":

    #if os.path.exists("WAVE.mhb"):

    try: nsi = ncread("nsi","e:s0:s1:s2:s3", \
    "a/wave_sin_pencil_selected.dat.432",skiphead=2)
    except: pass

    try: nsie = ncread("nsie","e:s0:s1:s2:s3", \
    "a/wave_sin_espread_selected.dat.343",skiphead=2)
    except: pass

    try: nsif = ncread("nsif","e:s0:s1:s2:s3", \
    "a/wave_sin_emit_selected.dat.342",skiphead=2)
    except: pass

    try: nsief = ncread("nsief","e:s0:s1:s2:s3", \
    "a/wave_sin_emit_espread_selected.dat.435",skiphead=2)
    except: pass

    optnstat()

    try: nplc(nsi,"e:s0/1.0e6")
    except: pass

    try: nplcbs(nsie,"e:s0/1.0e6")
    except: pass

    try: nplcgs(nsif,"e:s0/1.0e6")
    except: pass

    try: nplccs(nsief,"e:s0/1.0e6")
    except: pass

    try: s0max = nsi.s0.max()/1.0e6
    except: pass

    try: s0maxe = nsie.s0.max()/1.0e6
    except: pass

    try: s0maxf = nsif.s0.max()/1.0e6
    except: pass

    try: s0maxef = nsief.s0.max()/1.0e6
    except: pass

    try: text(0.6,0.9,"S0 Maximum: "+g3(s0max),halign='left')
    except: pass

    try:
      rde = s0maxe/s0max
      text(0.6,0.8,"Reduction e-spread: "+g3(rde),halign='left')
    except: pass

    try:
      rdf = s0maxf/s0max
      text(0.6,0.7,"Reduction emit.: "+g3(rdf),halign='left')
    except: pass

    try:
      rdef = s0maxef/s0max
      text(0.6,0.6,"Reduction both: "+g3(rdef),halign='left')
    except: pass

    txyz("Phase Error (sin.dat), Real Beam, 7th Harm.","E$_{ph}$ [eV]","N$_{ph}$/s/mm$^{2}$/100mA/0.1%BW")

    Fred = open("real_beam_sin_432-435.dat","w")

    try:
      print("S0max: " + g5(s0max))
      Fred.write("S0max: " + g5(s0max) + "\n")
    except: pass

    try:
      print("S0max_f, rdf: " + g5(s0maxf) + BL + g5(rdf))
      Fred.write("S0max_f, rdf: " + g5(s0maxf) + BL + g5(rdf) + "\n")
    except: pass
    try:
      print("S0max_e, rde: " + g5(s0maxe) + BL + g5(rde))
      Fred.write("S0max_e, rde: " + g5(s0maxe) + BL + g5(rde) + "\n")
    except: pass

    try:
      print("S0max_ef, rdef: " + g5(s0maxef) + BL + g5(rdef))
      Fred.write("S0max_ef, rdef: " + g5(s0maxef) + BL + g5(rdef) + "\n")
    except: pass

    Fred.close()

    pp("real_beam_342-345sin.pdf")

  elif args[1] == "phase_c":

    #if os.path.exists("WAVE.mhb"):

    try: nsi = ncread("nsi","e:s0:s1:s2:s3", \
    "a/wave_cos_pencil_selected.dat.336",skiphead=2)
    except: pass
    try: nsie = ncread("nsie","e:s0:s1:s2:s3", \
    "a/wave_cos_espread_selected.dat.338",skiphead=2)
    except: pass
    try: nsif = ncread("nsif","e:s0:s1:s2:s3", \
    "a/wave_cos_emit_selected.dat.337",skiphead=2)
    except: pass
    try: nsief = ncread("nsief","e:s0:s1:s2:s3", \
    "a/wave_cos_emit_espread_selected_339.dat",skiphead=2)
    except: pass

    optnstat()

    try: nplc(nsi,"e:s0/1.0e6")
    except: pass
    try: nplcbs(nsie,"e:s0/1.0e6")
    except: pass
    try: nplcgs(nsif,"e:s0/1.0e6")
    except: pass
    try: nplccs(nsief,"e:s0/1.0e6")
    except: pass

    try: s0max = nsi.s0.max()/1.0e6
    except: pass
    try: s0maxe = nsie.s0.max()/1.0e6
    except: pass
    try: s0maxf = nsif.s0.max()/1.0e6
    except: pass
    try: s0maxef = nsief.s0.max()/1.0e6
    except: pass

    try: text(0.6,0.9,"S0 Maximum: "+g3(s0max),halign='left')
    except: pass
    try:
      rde = s0maxe/s0max
      text(0.6,0.8,"Reduction e-spread: "+g3(rde),halign='left')
    except: pass
    try:
      rdf = s0maxf/s0max
      text(0.6,0.7,"Reduction emit.: "+g3(rdf),halign='left')
    except: pass
    try:
      rdef = s0maxef/s0max
      text(0.6,0.6,"Reduction both: "+g3(rdef),halign='left')
    except: pass

    txyz("Phase Error (cos.dat), Real Beam, 7th Harm.","E$_{ph}$ [eV]","N$_{ph}$/s/mm$^{2}$/100mA/0.1%BW")

    Fred = open("real_beam_cos_336-339.dat","w")

    try:
      print("S0max: " + g5(s0max))
      Fred.write("S0max: " + g5(s0max) + "\n")
    except: pass
    try:
      print("S0max_f, rdf: " + g5(s0maxf) + BL + g5(rdf))
      Fred.write("S0max_f, rdf: " + g5(s0maxf) + BL + g5(rdf) + "\n")
    except: pass
    try:
      print("S0max_e, rde: " + g5(s0maxe) + BL + g5(rde))
      Fred.write("S0max_e, rde: " + g5(s0maxe) + BL + g5(rde) + "\n")
    except: pass
    try:
      print("S0max_ef, rdef: " + g5(s0maxef) + BL + g5(rdef))
      Fred.write("S0max_ef, rdef: " + g5(s0maxef) + BL + g5(rdef) + "\n")
    except: pass

    Fred.close()

    pp("real_beam_cos-336-339.pdf")

  elif args[1] == "phase_h":

    #if os.path.exists("WAVE.mhb"):

    nh = ncread("nh","e:s0:s1:s2:s3", \
    "a/wave_halbach_pencil_selected.dat.347",silent=1,skiphead=2)
    nhf = ncread("nhf","e:s0:s1:s2:s3", \
    "a/wave_halbach_emit_selected.dat.348",silent=1,skiphead=2)
    nhe = ncread("nhe","e:s0:s1:s2:s3", \
    "a/wave_halbach_espread_selected.dat.349",silent=1,skiphead=2)
    nhef = ncread("nhef","e:s0:s1:s2:s3", \
    "a/wave_halbach_emit_espread_selected.dat.350",silent=1,skiphead=2)

    optnstat()
    nplc(nh,"e:s0/1.0e6")
    s0max = nh.s0.max()/1.0e6
    legend("S0,      " + g3(s0max) + ", 1.000")
    txyz("Ideal Undulator, Real Beam, 7th Harm.","E$_{ph}$ [eV]","N$_{ph}$/s/mm$^{2}$/100mA/0.1%BW")

    Fred = open("real_beam_halbach_347-350.dat","w")
    #Fred = open("real_beam_halbach_347-350.dat","w")

    print("S0max:   " + g5(s0max))
    Fred.write("S0max: " + g5(s0max) + "\n")

    if nexist("nhe"):
      nplcbs(nhe,"e:s0/1.0e6")
      s0maxe = nhe.s0.max()/1.0e6
      rde = s0maxe/s0max
      legend("S0_e,   " + g3(s0maxe) + ", " + g3(s0maxe/s0max))
      print("S0max_e, rde: " + g5(s0maxe) + BL + g5(rde))
      Fred.write("S0max_e, rde: " + g5(s0maxe) + BL + g5(rde) + "\n")
    #endif

    if nexist("nhf"):
      nplcgs(nhf,"e:s0/1.0e6")
      s0maxf = nhf.s0.max()/1.0e6
      rdf = s0maxf/s0max
      legend("S0_f ,   " + g3(s0maxf) + ", " + g3(s0maxf/s0max))
      print("S0max_f, rdf: " + g5(s0maxf) + BL + g5(rdf))
      Fred.write("S0max_f, rdf: " + g5(s0maxf) + BL + g5(rdf) + "\n")
    #endif

    if nexist("nhef"):
      nplccs(nhef,"e:s0/1.0e6")
      s0maxef = nhef.s0.max()/1.0e6
      rdef = s0maxef/s0max
      legend("S0_ef,   " + g3(s0maxef) + ", " + g3(s0maxef/s0max))
      Fred.write("S0max_ef, rdef: " + g5(s0maxef) + BL + g5(rdef) + "\n")
      print("Test:",rde*rdf/rdef)
    #endif

    legend()
    Fred.close()

    pp("real_beam_halbach_347-350.pdf")

  elif args[1] == "phase_ht":

    #if os.path.exists("WAVE.mhb"):

    nh = ncread("nh","e:s0:s1:s2:s3", \
    "wave_halba_tab_pencil_selected.dat.437",silent=1,skiphead=2)
    nhf = ncread("nhf","e:s0:s1:s2:s3", \
    "wave_halba_tab_emit_selected.dat.438",silent=1,skiphead=2)
    nhe = ncread("nhe","e:s0:s1:s2:s3", \
    "wave_halba_tab_espread_selected.dat.439",silent=1,skiphead=2)
    nhef = ncread("nhef","e:s0:s1:s2:s3", \
    "wave_halba_tab_emit_espread_selected.dat.340",silent=1,skiphead=2)

    optnstat()
    nplc(nh,"e:s0/1.0e6")
    s0max = nh.s0.max()/1.0e6
    text(0.6,0.9,"S0 Maximum: "+g3(s0max),halign='left')
    txyz("Ideal Undulator, Real Beam, 7th Harm.","E$_{ph}$ [eV]","N$_{ph}$/s/mm$^{2}$/100mA/0.1%BW")

    Fred = open("real_beam_halba_tab_437-440.dat","w")
    #Fred = open("real_beam_halbach_347-350.dat","w")

    print("S0max: " + g5(s0max))
    Fred.write("S0max: " + g5(s0max) + "\n")

    if nexist("nhe"):
      nplcbs(nhe,"e:s0/1.0e6")
      s0maxe = nhe.s0.max()/1.0e6
      rde = s0maxe/s0max
      text(0.6,0.8,"Reduction e-spread: "+g3(rde),halign='left')
      print("S0max_e, rde: " + g5(s0maxe) + BL + g5(rde))
      Fred.write("S0max_e, rde: " + g5(s0maxe) + BL + g5(rde) + "\n")
    #endif

    if nexist("nhf"):
      nplcgs(nhf,"e:s0/1.0e6")
      s0maxf = nhf.s0.max()/1.0e6
      rdf = s0maxf/s0max
      text(0.6,0.7,"Reduction emit.: "+g3(rdf),halign='left')
      print("S0max_f, rdf: " + g5(s0maxf) + BL + g5(rdf))
      Fred.write("S0max_f, rdf: " + g5(s0maxf) + BL + g5(rdf) + "\n")
    #endif

    if nexist("nhef"):
      nplccs(nhef,"e:s0/1.0e6")
      s0maxef = nhef.s0.max()/1.0e6
      rdef = s0maxef/s0max
      text(0.6,0.6,"Reduction both: "+g3(rdef),halign='left')
      print("S0max_ef, rdef: " + g5(s0maxef) + BL + g5(rdef))
      Fred.write("S0max_ef, rdef: " + g5(s0maxef) + BL + g5(rdef) + "\n")
    #endif

    Fred.close()

    pp("real_beam_halba_tab_347-340.pdf")

  elif args[1] == "phase_stokes":

    optnstat()
    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error(fall = args[1] + ".dat")

  elif args[1] == "phase_berror":

    set_y_stat(0.2)

    fall = args[1] + ".dat"
    os.system("rm " + fall)

    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error("berror",
                "wave_berror_pencil_selected.dat",
                "wave_berror_emit_selected.dat",
                "wave_berror_espread_selected.dat",
                "wave_berror_emit_espread_selected.dat",
                fall=fall)

    print("berror runs",iruns0, iruns0e, iruns0f, iruns0ef, iruns0ref)

  elif args[1] == "phase_taper":

    optnstat()
    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error("taper",
                "wave_taper_pencil_selected.dat",
                "wave_taper_emit_selected.dat",
                "wave_taper_espread_selected.dat",
                "wave_taper_emit_espread_selected.dat",
                fall = args[1] + ".dat")

    print("taper runs",iruns0, iruns0e, iruns0f, iruns0ef, iruns0ref)

  elif args[1] == "phase_told":

    nt = ncread("nt","e:s0:s1:s2:s3", \
    "a/wave_taper_pencil_selected.dat.418",silent=1,skiphead=2)
    ntf = ncread("ntf","e:s0:s1:s2:s3", \
    "a/wave_taper_emit_selected.dat.419",silent=1,skiphead=2)
    nte = ncread("nte","e:s0:s1:s2:s3", \
    "a/wave_taper_espread_selected.dat.420",silent=1,skiphead=2)
    ntef = ncread("ntef","e:s0:s1:s2:s3", \
    "a/wave_taper_emit_espread_selected.dat.421",silent=1,skiphead=2)

    optnstat()
    nplc(nt,"e:s0/1.0e6")
    s0max = nt.s0.max()/1.0e6
    text(0.6,0.9,"S0 Maximum: "+g3(s0max),halign='left')
    txyz("Taper, Real Beam, 7th Harm.","E$_{ph}$ [eV]","N$_{ph}$/s/mm$^{2}$/100mA/0.1%BW")

    Fred = open("real_beam_taper_418-421.dat","w")
    #Fred = open("real_beam_taper_347-350.dat","w")

    print("S0max: " + g5(s0max))
    Fred.write("S0max: " + g5(s0max) + "\n")

    if nexist("nte"):
      nplcbs(nte,"e:s0/1.0e6")
      s0maxe = nte.s0.max()/1.0e6
      rde = s0maxe/s0max
      text(0.6,0.8,"Reduction e-spread: "+g3(rde),halign='left')
      print("S0max_e, rde: " + g5(s0maxe) + BL + g5(rde))
      Fred.write("S0max_e, rde: " + g5(s0maxe) + BL + g5(rde) + "\n")
    #endif

    if nexist("ntf"):
      nplcgs(ntf,"e:s0/1.0e6")
      s0maxf = ntf.s0.max()/1.0e6
      rdf = s0maxf/s0max
      text(0.6,0.7,"Reduction emit.: "+g3(rdf),halign='left')
      print("S0max_f, rdf: " + g5(s0maxf) + BL + g5(rdf))
      Fred.write("S0max_f, rdf: " + g5(s0maxf) + BL + g5(rdf) + "\n")
    #endif

    if nexist("ntef"):
      nplccs(ntef,"e:s0/1.0e6")
      s0maxef = ntef.s0.max()/1.0e6
      rdef = s0maxef/s0max
      text(0.6,0.6,"Reduction both: "+g3(rdef),halign='left')
      print("S0max_ef, rdef: " + g5(s0maxef) + BL + g5(rdef))
      Fred.write("S0max_ef, rdef: " + g5(s0maxef) + BL + g5(rdef) + "\n")
    #endif

    Fred.close()

    pp("real_beam_taper_418-421.pdf")

  elif args[1] == "bunch_h":

    if os.path.exists("WAVE.mhb"):
      nb = ncread("nb","e:s0:s1:s2:s3","wave_halbach_bunch_selected.dat",skiphead=2)
      nplc(nb,"e:s0")
      pp("real_beam_halbach_bunch.pdf")
    #endif

  elif args[1] == "phase_err":

    nh = ncread("nh","e:s0:s1:s2:s3","wave_halbach__selected.dat",skiphead=2)
    if type(nh) == int: Quit()
    nhe = ncread("nhe","e:s0:s1:s2:s3","wave_halbach_e_selected.dat",skiphead=2)
    if type(nhe) == int: Quit()
    nhf = ncread("nhf","e:s0:s1:s2:s3","wave_halbach_f_selected.dat",skiphead=2)
    if type(nhf) == int: Quit()
    nhef = ncread("nhef","e:s0:s1:s2:s3","wave_halbach_ef_selected.dat",skiphead=2)
    if type(nhef) == int: Quit()

    nb = ncread("nb","e:s0:s1:s2:s3","wave_bend__selected.dat",skiphead=2)
    if type(nb) == int: Quit()
    nbe = ncread("nbe","e:s0:s1:s2:s3","wave_bend_e_selected.dat",skiphead=2)
    if type(nbe) == int: Quit()
    nbf = ncread("nbf","e:s0:s1:s2:s3","wave_bend_f_selected.dat",skiphead=2)
    if type(nbf) == int: Quit()
    nbef = ncread("nbef","e:s0:s1:s2:s3","wave_bend_ef_selected.dat",skiphead=2)
    if type(nbef) == int: Quit()

    optnstat()
    Fr = open("reduction.dat","w")

    nplc(nh,"e:s0","s0>1")
    nplcbs(nb,"e:s0","s0>1")
    text(0.6,0.8,"Max. Halbach:"+g4(nh.s0.max()),halign='left')
    text(0.6,0.75,"Max. bend.dat:"+g4(nb.s0.max()),halign='left')
    r = nb.s0.max()/nh.s0.max()
    text(0.6,0.7,"Reduction:"+g3(r),halign='left')
    print("single e: " + g5(r))
    Fr.write("single e: " + g5(r)+"\n")
    pp("reduction_single_e.pdf")

    nplc(nhe,"e:s0","s0>1")
    nplcbs(nbe,"e:s0","s0>1")
    text(0.6,0.8,"Max. Halbach:"+g4(nhe.s0.max()),halign='left')
    text(0.6,0.75,"Max. bend.dat:"+g4(nbe.s0.max()),halign='left')
    r = nbe.s0.max()/nhe.s0.max()
    text(0.6,0.7,"Reduction:"+g3(r),halign='left')
    print("espread: " + g5(r))
    Fr.write("espread: " + g5(r)+"\n")
    pp("reduction_espread.pdf")

    nplc(nhef,"e:s0","s0>1")
    nplcbs(nbef,"e:s0","s0>1")
    text(0.6,0.8,"Max. Halbach:"+g4(nhef.s0.max()),halign='left')
    text(0.6,0.75,"Max. bend.dat:"+g4(nbef.s0.max()),halign='left')
    r = nbef.s0.max()/nhef.s0.max()
    text(0.6,0.7,"Reduction:"+g3(r),halign='left')
    print("emit., espread: " + g5(r))
    Fr.write("emit. + espread: " + g5(r)+"\n")
    pp("reduction_emit_espread.pdf")
    Fr.close()

  elif args[1] == "wbmap":
    if nargs > 2:  fbm = args[2]
    else:          fbm = "wave_bmap.dat"
    nwb = ncread("nwb","x:y:z:bx:by:bz",fbm,skiphead=6)
    ninfo(nwb)

  elif args[1] == "umap":
    numap = ncread("numap","x:y:z:bx:by:bz:ifail:kfail","undumag.map",skiphead=4)
    ninfo(numap)

  elif args[1] == "s0dat":

    if nargs > 2:  fall = args[2]
    else:          fall = "wave_stokes_selected.dat"

    ns0 = ncread("ns0","e:s0:s1:s2:s3",fall)
    iemax,emax,s0max = ns0peak(ns0)
    npll(ns0,"e:s0/1.e6")

  elif args[1] == "s0datold":

    Irunmin = 1e20
    Irunmax = -1e20

    optstat()

    fil = "wave_stokes_selected.dat"
    F = open(fil,"r")
    runs0 = F.readline().strip().split()[0].strip()
    iruns0 = int(runs0)
    if iruns0 < Irunmin: Irunmin = iruns0
    if iruns0 > Irunmax: Irunmax = iruns0
    ns0 = ncread("ns0","e:s0:s1:s2:s3",fil,silent=1,skiphead=2)
    F.close()

    try:
      fil = "wave_stokese_selected.dat"
      F = open(fil,"r")
      runs0e = F.readline().strip().split()[0].strip()
      iruns0e = int(runs0e)
      if iruns0e < Irunmin: Irunmin = iruns0e
      if iruns0e > Irunmax: Irunmax = iruns0e
      ns0e = ncread("ns0e","e:s0:s1:s2:s3",fil,silent=1,skiphead=2)
      F.close()
    except: pass

    try:
      fil = "wave_stokesf_selected.dat"
      F = open(fil,"r")
      runs0f = F.readline().strip().split()[0].strip()
      iruns0f = int(runs0f)
      if iruns0f < Irunmin: Irunmin = iruns0f
      if iruns0f > Irunmax: Irunmax = iruns0f
      ns0f = ncread("ns0f","e:s0:s1:s2:s3",fil,silent=1,skiphead=2)
      F.close()
    except: pass

    try:
      fil = "wave_stokesef_selected.dat"
      F = open(fil,"r")
      runs0ef = F.readline().strip().split()[0].strip()
      iruns0ef = int(runs0ef)
      if iruns0ef < Irunmin: Irunmin = iruns0ef
      if iruns0ef > Irunmax: Irunmax = iruns0ef
      ns0ef = ncread("ns0ef","e:s0:s1:s2:s3",fil,silent=1,skiphead=2)
      F.close()
    except: pass

    nplc(ns0,"e:s0/1.0e6")
    #s0max = ns0.s0.max()/1.0e6
    iemax,emax,s0max = ns0peak(ns0)

    legend("S0,      " + g3(s0max))

    tit = "Ideal Undulator, Real Beam, (" + str(Irunmin) + "-" + str(Irunmax) + ")"
    txyz(tit,"E$_{ph}$ [eV]","N$_{ph}$/s/mm$^{2}$/100mA/0.1%BW")

    Fred = open("real_beam_folded_selected.dat","w")
    #Fred = open("real_beam_halbach_347-350.dat","w")

    print("S0max:   " + g5(s0max))
    Fred.write("S0max: " + g5(s0max) + "\n")

    if nexist("ns0e"):
      optnstat()
      nplcbs(ns0e,"e:s0/1.0e6")
      iemaxe,emaxe,s0maxe = ns0peak(ns0e)
      if iemax > 0: s0harme = ns0e.s0[iemax]/1.e6
      rde = s0maxe/s0max
      rdhe = s0harme/s0max
      line1 = "S0max_e, rde  : " + g3(s0maxe) + BL + g3(rde)
      line2 = "S0harm_e, rdhe: " + g3(s0harme) + BL + g3(rdhe)
      legend(line1 + "\n" + line2)
      print("\n" + line1 + "\n" + line2)
      Fred.write("\n" + line1 + "\n" + line2 + "\n")
    #endif

    if nexist("ns0f"):
      optnstat()
      nplcgs(ns0f,"e:s0/1.0e6")
      iemaxf,emaxf,s0maxf = ns0peak(ns0f)
      if iemax > 0: s0harmf = ns0f.s0[iemax]/1.e6
      rdf = s0maxf/s0max
      rdhf = s0harmf/s0max
      line1 = "S0max_f, rdf  : " + g3(s0maxf) + BL + g3(rdf)
      line2 = "S0harm_f, rdhf: " + g3(s0harmf) + BL + g3(rdhf)
      legend(line1 + "\n" + line2)
      print("\n" + line1 + "\n" + line2)
      Fred.write("\n" + line1 + "\n" + line2 + "\n")
    #endif

    if nexist("ns0ef"):
      optnstat()
      nplccs(ns0ef,"e:s0/1.0e6")
      iemaxef,emaxef,s0maxef = ns0peak(ns0ef)
      if iemax > 0: s0harmef = ns0ef.s0[iemax]/1.e6
      rdef = s0maxef/s0max
      rdhef = s0harmef/s0max
      line1 = "S0max_ef, rdef  : " + g3(s0maxef) + BL + g3(rdef)
      line2 = "S0harm_ef, rdhef: " + g3(s0harmef) + BL + g3(rdhef)
      legend(line1 + "\n" + line2)
      print("\n" + line1 + "\n" + line2)
      Fred.write("\n" + line1 + "\n" + line2 + "\n")
    #endif

    legend()
    Fred.close()

    pp("real_beam_folded.selected.pdf")

    optstat()

  elif args[1] == "phase_halbach":

    Fall = open("SRI22_phase-errors.dat","w")
    #  Type beam  run  S0*  S0_pen S0H_pen S0H S0*/S0_pen S0*/S0H_pen S0*/S0H
    Fall.close()

    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error("halbach",
                "a/wave_halbach_pencil_on-axis.dat.347",
                "a/wave_halbach_emit_on-axis.dat.348",
                "a/wave_halbach_espread_on-axis.dat.349",
                "a/wave_halbach_emit_espread_on-axis.dat.350")
    Quit()

  elif args[1] == "phase_all":

    set_y_stat(0.2)

    fall = "a/SRI22_phase-errors.dat"
    Fall = open(fall,"w")
    Fall.write("* Type beam  run  S0  S0_pen S0H_pen S0H S0/S0_pen S0/S0H_pen S0/S0H\n")
    Fall.close()

    ipencil = 347
    ipencil = 476
    iemit = ipencil + 1
    iespread = ipencil + 2
    ief = ipencil + 3

    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error("halbach",
                "a/wave_halbach_pencil_on-axis.dat." + str(ipencil),
                "a/wave_halbach_emit_on-axis.dat." + str(iemit),
                "a/wave_halbach_espread_on-axis.dat." + str(iespread),
                "a/wave_halbach_emit_espread_on-axis.dat." + str(ief),fall=fall)

    runs = str(Irunmin) + "-" + str(Irunmax)
    Fs0 = open("a/wave_halbach_S0_on-axis.dat." + runs,"w")
    for i in range(len(vs0)):
      Fs0.write(g5(vs0ene[i]) + BL + g5(vs0[i]) + BL \
      + g5(vs0f[i]) + BL + g5(vs0e[i]) + BL + g5(vs0ef[i]) + BL + "\n")
    #endfor
    Fs0.close()

    ipencil = 340
    ipencil = 482
    iemit = ipencil + 1
    iespread = ipencil + 2
    ief = ipencil + 3

    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error("bend",
                "a/wave_bend_pencil_on-axis.dat." + str(ipencil),
                "a/wave_bend_emit_on-axis.dat." + str(iemit),
                "a/wave_bend_espread_on-axis.dat." + str(iespread),
                "a/wave_bend_emit_espread_on-axis.dat." + str(ief),fall=fall)

    runs = str(Irunmin) + "-" + str(Irunmax)
    Fs0 = open("a/wave_bend_S0_on-axis.dat." + runs,"w")
    for i in range(len(vs0)):
      Fs0.write(g5(vs0ene[i]) + BL + g5(vs0[i]) + BL \
      + g5(vs0f[i]) + BL + g5(vs0e[i]) + BL + g5(vs0ef[i]) + BL + "\n")
    #endfor
    Fs0.close()

    ipencil = 418
    ipencil = 486
    iemit = ipencil + 1
    iespread = ipencil + 2
    ief = ipencil + 3

    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error("taper",
                "a/wave_taper_pencil_on-axis.dat." + str(ipencil),
                "a/wave_taper_emit_on-axis.dat." + str(iemit),
                "a/wave_taper_espread_on-axis.dat." + str(iespread),
                "a/wave_taper_emit_espread_on-axis.dat." + str(ief),fall=fall)

    runs = str(Irunmin) + "-" + str(Irunmax)
    Fs0 = open("a/wave_taper_S0_on-axis.dat." + runs,"w")
    for i in range(len(vs0)):
      Fs0.write(g5(vs0ene[i]) + BL + g5(vs0[i]) + BL \
      + g5(vs0f[i]) + BL + g5(vs0e[i]) + BL + g5(vs0ef[i]) + BL + "\n")
    #endfor
    Fs0.close()

    ipencil = 336
    ipencil = 491
    iemit = ipencil + 1
    iespread = ipencil + 2
    ief = ipencil + 3

    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error("cos",
                "a/wave_cos_pencil_on-axis.dat." + str(ipencil),
                "a/wave_cos_emit_on-axis.dat." + str(iemit),
                "a/wave_cos_espread_on-axis.dat." + str(iespread),
                "a/wave_cos_emit_espread_on-axis.dat." + str(ief),fall=fall)

    runs = str(Irunmin) + "-" + str(Irunmax)
    Fs0 = open("a/wave_cos_S0_on-axis.dat." + runs,"w")
    for i in range(len(vs0)):
      Fs0.write(g5(vs0ene[i]) + BL + g5(vs0[i]) + BL \
      + g5(vs0f[i]) + BL + g5(vs0e[i]) + BL + g5(vs0ef[i]) + BL + "\n")
    #endfor
    Fs0.close()

    ipencil = 432
    ipencil = 495
    iemit = ipencil + 1
    iespread = ipencil + 2
    ief = ipencil + 3

    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error("sin",
                "a/wave_sin_pencil_on-axis.dat." + str(ipencil),
                "a/wave_sin_emit_on-axis.dat." + str(iemit),
                "a/wave_sin_espread_on-axis.dat." + str(iespread),
                "a/wave_sin_emit_espread_on-axis.dat." + str(ief),fall=fall)

    runs = str(Irunmin) + "-" + str(Irunmax)
    Fs0 = open("a/wave_sin_S0_on-axis.dat." + runs,"w")
    for i in range(len(vs0)):
      Fs0.write(g5(vs0ene[i]) + BL + g5(vs0[i]) + BL \
      + g5(vs0f[i]) + BL + g5(vs0e[i]) + BL + g5(vs0ef[i]) + BL + "\n")
    #endfor
    Fs0.close()

    ipencil = 468
    ipencil = 499
    iemit = ipencil + 1
    iespread = ipencil + 2
    ief = ipencil + 3

    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error("berror",
                "a/wave_berror_pencil_on-axis.dat." + str(ipencil),
                "a/wave_berror_emit_on-axis.dat." + str(iemit),
                "a/wave_berror_espread_on-axis.dat." + str(iespread),
                "a/wave_berror_emit_espread_on-axis.dat." + str(ief),fall=fall)

    runs = str(Irunmin) + "-" + str(Irunmax)
    Fs0 = open("a/wave_berror_S0_on-axis.dat." + runs,"w")
    for i in range(len(vs0)):
      Fs0.write(g5(vs0ene[i]) + BL + g5(vs0[i]) + BL \
      + g5(vs0f[i]) + BL + g5(vs0e[i]) + BL + g5(vs0ef[i]) + BL + "\n")
    #endfor
    Fs0.close()

    ipencil = 472
    ipencil = 503
    iemit = ipencil + 1
    iespread = ipencil + 2
    ief = ipencil + 3

    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error("pherr5",
                "a/wave_pherr5_pencil_on-axis.dat." + str(ipencil),
                "a/wave_pherr5_emit_on-axis.dat." + str(iemit),
                "a/wave_pherr5_espread_on-axis.dat." + str(iespread),
                "a/wave_pherr5_emit_espread_on-axis.dat." + str(ief),fall=fall)

    runs = str(Irunmin) + "-" + str(Irunmax)
    Fs0 = open("a/wave_pherr5_S0_on-axis.dat." + runs,"w")
    for i in range(len(vs0)):
      Fs0.write(g5(vs0ene[i]) + BL + g5(vs0[i]) + BL \
      + g5(vs0f[i]) + BL + g5(vs0e[i]) + BL + g5(vs0ef[i]) + BL + "\n")
    #endfor
    Fs0.close()

    ipencil = 507
    iemit = ipencil + 1
    iespread = ipencil + 2
    ief = ipencil + 3

    vs0ene,vs0,vs0f,vs0e,vs0ef = \
    phase_error("berror_12deg",
                "a/wave_berror_12deg_pencil_on-axis.dat." + str(ipencil),
                "a/wave_berror_12deg_emit_on-axis.dat." + str(iemit),
                "a/wave_berror_12deg_espread_on-axis.dat." + str(iespread),
                "a/wave_berror_12deg_emit_espread_on-axis.dat." + str(ief),fall=fall)

    runs = str(Irunmin) + "-" + str(Irunmax)
    Fs0 = open("a/wave_berror_12deg_S0_on-axis.dat." + runs,"w")
    for i in range(len(vs0)):
      Fs0.write(g5(vs0ene[i]) + BL + g5(vs0[i]) + BL \
      + g5(vs0f[i]) + BL + g5(vs0e[i]) + BL + g5(vs0ef[i]) + BL + "\n")
    #endfor
    Fs0.close()

    Quit()

  elif args[1] == "66":

    n66=ncread("n66","iel:yi:zi:ypi:zpi:i:t:dph:r0x:r0y:r0z:x:y:z:ox:oy:oz:dox:doy:doz:ie:rex:iex:rda:ida","fort.66")
    n56=ncread("n56","ical:i:x:dph:ph:az:daz","fort.56")
    n67=ncread("n67","iel:yi:zi:ypi:zpi:i:t:dph:r0x:r0y:r0z:x:y:z:ox:oy:oz:dox:doy:doz:ie:rex:iex:rda:ida","~/wav/work/fort.67")
    n57=ncread("n57","ical:i:x:dph:ph:az:daz","~/wav/work/fort.57")

  elif args[1] == "stokes" or args[1] == "st":

    import waveplot as w
    from waveplot import *

    nsts = ncread("nsts","e:s0:s1:s2:s3","wave_stokes_selected.dat",skiphead=2)
    nst = ncread("nst","e:s0:s1:s2:s3","wave_stokes_flux.dat",skiphead=2)
    nstse = ncread("nstse","e:s0:s1:s2:s3","wave_stokese_selected.dat",skiphead=2)
    nste = ncread("nste","e:s0:s1:s2:s3","wave_stokese_flux.dat",skiphead=2)
    nstsf = ncread("nstsf","e:s0:s1:s2:s3","wave_stokesf_selected.dat",skiphead=2)
    nstf = ncread("nstf","e:s0:s1:s2:s3","wave_stokesf_flux.dat",skiphead=2)
    nstsef = ncread("nstsef","e:s0:s1:s2:s3","wave_stokesef_selected.dat",skiphead=2)
    nstef = ncread("nstef","e:s0:s1:s2:s3","wave_stokesef_flux.dat",skiphead=2)

    nlist()

    optnstat()
    sel = "e > " + str(Wflow) + " and e < " + str(Wfhig)
    #print(sel)

    #lilo()

    if nexist(nst):
      npllb(nst,"e:s0",sel)
      s0max = nst.s0.max()
      legend("S0,     " + g3(s0max) + ", 1.000")
    #endif

    #if nexist(nstf):
    # npllcs(nstf,"e:s0",sel)
    #s0fmax = nstf.s0.max()
    #legend("S0_f,  " + g3(s0fmax) + ", " + g3(s0fmax/s0max))
    #endif

    #if nexist(nste):
    # npllgs(nste,"e:s0",sel)
    # s0emax = nste.s0.max()
    # legend("S0_e,  " + g3(s0emax) + ", " + g3(s0emax/s0max))
    #endif

    if nexist(nstef):
      nplls(nstef,"e:s0",sel)
      s0efmax = nstef.s0.max()
      legend("S0_ef,  " + g3(s0efmax) + ", " + g3(s0efmax/s0max))
    #endif

    legend()

    wave_title()

    xTit="photon energy [eV]"
    yTit = 'N$_{\gamma}$' + '/s/' + str(Wbw) + ' %BW/' + str(int(Wcurr*1000.+0.5)) + "mA"
    txyz(tpinhole(),xTit,yTit)

    pp("wave_stokesf_flux.pdf")

  elif args[1] == "hflux" or args[1] == "f":

    if os.path.exists("WAVE.mhb"):

      import waveplot as w
      from waveplot import *

      for n in range(len(Nhead)):
        snam = Nhead[n][1]
        exec(snam + ' = nget("' + snam + '")')
      #endfor

      hflux(clipe='no')
      optnstat()

      hs0=hget("h48000")

      s0max = hs0.y.max()
      legend("S0,     " + g3(s0max) + ", 1.000")

      #vwritexy(hs0.x,hs0.y,"s0.dat")

      if Wiefo:
        sethistcolor('g')
        hflux('s0e','same')
        hs0e=hget("h70000")
        s0emax = hs0e.y.max()
        legend("S0_e,  " + g3(s0emax) + ", " + g3(s0emax/s0max))
      #endif

      if Wifol:
        sethistcolor('cyan')
        if Wisto:
          hflux('s0f','same')
          hs0f=hget("h60000")
        else:
          hflux('ff','same')
          hs0f=hget("h49000")
        #endif
        s0fmax = hs0f.y.max()
        legend("S0_f,  " + g3(s0fmax)  + ", " + g3(s0fmax/s0max))
      #endif

      if Wifol*Wiefo:
        sethistcolor('r')
        hflux('s0ef','same')
        hs0ef=hget("h80000")
        s0efmax = hs0ef.y.max()
        legend("S0_ef, " + g3(s0efmax)  + ", " + g3(s0efmax/s0max))
      #endif

      legend()
      pp("wave_flux.pdf")

    #endif mhb

  elif args[1] == "hcfluxden" or args[1] == "fd":

    if os.path.exists("WAVE.mhb"):

      import waveplot as w
      from waveplot import *

      for n in range(len(Nhead)):
        snam = Nhead[n][1]
        exec(snam + ' = nget("' + snam + '")')
      #endfor

      if Wif2p == 3.0:

        if Wispe:

          hcfluxden(clipe='no')
          optnstat()

          hs0=hget("h148000")

          s0max = hs0.y.max()
          legend("S0,     " + g3(s0max) + ", 1.000")

          #vwritexy(hs0.x,hs0.y,"s0.dat")

        else:
          print("*** No spectral data, check ISPEC in wave.in ***")
        #endif

        if Wiefo:
          hplot1d('h170000','same')
          hcfluxden('s0e','same')
          hs0e=hget("h170000")
          s0emax = hs0e.y.max()
          legend("S0_e,  " + g3(s0emax) + ", " + g3(s0emax/s0max))
        #endif

        if Wifol:
          if Wisto:
            #                hcfluxden('s0f','same')
            hs0f=hget("h160000")
          else:
            #                hcfluxden('fdf','same')
            hs0f=hget("h149000")
          #endif
          s0fmax = hs0f.y.max()
          legend("S0_f,  " + g3(s0fmax)  + ", " + g3(s0fmax/s0max))
        #endif

        if Wifol*Wiefo:
          # hcfluxden('s0ef','same')
          hs0ef=hget("h180000")
          s0efmax = hs0ef.y.max()
          legend("S0_ef, " + g3(s0efmax)  + ", " + g3(s0efmax/s0max))
        #endif

        #legend()
        #pp("wave_s0.pdf")

      elif Wif2p == 2.0:

        #lolo()

        npl(n3700,"ener:spec/1.e6","abs(y)<1.0e-6 and abs(z)<1.0e-6")

        xTit="photon energy [eV]"
        yTit = 'N$_{\gamma}$' + '/s/' + str(Wbw) + ' %BW/' + str(int(Wcurr*1000.+0.5)) + "mA"
        txyz(tpinhole(),xTit,yTit)

      #endif wif2p

    #endif WAVE.mhb

    ibck = 0
    icomp = 0
    if os.getcwd().split("/")[-1] == 'stage': icomp = 3

    if icomp == 4:
      nj=ncread("nj","e:fd","../job/waveplot_1.dat")
      print(n3700.spec.max()/1.e6/nj.fd.max())
      npllgs(nj)
    #endif

    icomp=0
    if icomp == 3:
      np00=ncread("np00","e:s0","pencil_00_100.dat")
      npllcs(np00,"e:s0")
      print("pencil_00: ",g5(n3700.spec.max()/1.e6/np00.s0.max()))
      text(0.85,0.9,"pencil_00: " + g5(n3700.spec.max()/1.e6/np00.s0.max()))
      np=ncread("np","e:s0","pencil_00005_100.dat")
      npllms(np,"e:s0")
      text(0.85,0.8,"pencil: " + g5(n3700.spec.max()/1.e6/np.s0.max()))
      print("pencil: ",g5(n3700.spec.max()/1.e6/np.s0.max()))
      text(0.85,0.8,"pencil: " + g5(n3700.spec.max()/1.e6/np.s0.max()))
      print("pencil_00: ",g5(n3700.spec.max()/1.e6/np.s0.max()))
      ne=ncread("ne","e:s0","emit_00_100.dat")
      npllbs(ne,"e:s0")
      text(0.85,0.7,"emit: " + g5(n3700.spec.max()/1.e6/ne.s0.max()))
      print("emit: ",g5(n3700.spec.max()/1.e6/ne.s0.max()))
      nb=ncread("nb","e:s0","beam_00_100.dat")
      npllgs(nb,"e:s0")
      text(0.85,0.6,"beam: " + g5(n3700.spec.max()/1.e6/nb.s0.max()))
      print("beam: ",g5(n3700.spec.max()/1.e6/nb.s0.max()))
    elif icomp > 0:

      if icomp == 2:
        #nbad=ncread("nbad","iel:yi:zi:ypi:zpi:i:t:dph:r0x:r0y:r0z:x:y:z:ox:oy:oz:dox:doy:doz:ie:rex:iex:rda:ida","bad.66")
        n66=ncread("n66","iel:yi:zi:ypi:zpi:i:t:dph:r0x:r0y:r0z:x:y:z:ox:oy:oz:dox:doy:doz:ie:rex:iex:rda:ida","fort.66")
        nsi=ncread("nsi","ie:t:x:z:reaz:imaz:spec:nx:nz","../job/n12.dat")
        ninfo(n66)
        ninfo(nsi)
      #endif

      nje=ncread("nje","e:s0","../job/emit_195-201.dat")
      #nje=ncread("nje","e:s0","../job/emit_195-201_1000m.dat")
      npllls(nje)
      text(0.8,0.8,g5(n3700.spec.max()/1.e6/nje.s0.max()))

      njb=ncread("njb","e:s0","../job/beam_195-201.dat")
      #njb=ncread("njb","e:s0","../job/beam_195-201_1000m.dat")
      npllgs(njb)
      text(0.8,0.7,g5(n3700.spec.max()/1.e6/njb.s0.max()))

      print("emit: ",g5(n3700.spec.max()/1.e6/nje.s0.max()))
      print("beam: ",g5(n3700.spec.max()/1.e6/njb.s0.max()))

      if ibck:
        eh = hs0.x
        s0h = hs0.y
        nbck=ncread("nbck","e:s0:s1:s2:s3","wave_stokes_selected.dat.bck")
        npllbs(nbck,"e:s0/1.e6")
        ebck = nbck.e
        s0bck = nbck.s0/1.e6
        vm = (s0bck+s0h)/2.0
        vplxy(eh,vm,"sameline",color='c')
      #endif bck

    #endif

  elif args[1] == "ray":

    if nargs > 2:  fray = args[2]
    else:          fray = "wave_ray.dat"

    waveray("hray",fray)
    Quit()

  elif args[1] == "stokesveraltet":

    #        optconsole()
    #        set_console_title("wavesDefault")

    if os.path.exists("WAVE.mhb"):
      import waveplot as w
      from waveplot import *
      n222=nget("n222")
      ncs0=ncread("ncs0","ener:s0:s1:s2:s3","wave_stokes__selected.dat",skiphead=2)
      ncs0f=ncread("ncs0f","ener:s0:s1:s2:s3","wave_stokesf__selected.dat",skiphead=2)
      ncs0e=ncread("ncs0e","ener:s0:s1:s2:s3","wave_stokese__selected.dat",skiphead=2)
      ncs0ef=ncread("ncs0ef","ener:s0:s1:s2:s3","wave_stokesef__selected.dat",skiphead=2)
      ns0=ncread("ns0","ener:s0:s1:s2:s3","wave_stokes_flux.dat",skiphead=2)
      ns0f=ncread("ns0f","ener:s0:s1:s2:s3","wave_stokesf_flux.dat",skiphead=2)
      ns0e=ncread("ns0e","ener:s0:s1:s2:s3","wave_stokese_flux.dat",skiphead=2)
      ns0ef=ncread("ns0ef","ener:s0:s1:s2:s3","wave_stokesef_flux.dat",skiphead=2)
      iflux=1
      if iflux == 1:
        #                zone(1,2)
        #                npl(ns0,"ener:s0")
        nnpl(ns0ef,"ener:s0","s0>1.")
        ene=(Wfhig+Wflow)/2.
        pp("wave_stokesef_flux_" + str(Wpinw*1000.) + "mm_x_" + str(Wpinh*1000) + "mm_" + str(ene) + "eV.pdf")
        #endif iflux == 1:
        Quit()
      #endif
    #endif

  elif args[1] == "by":

    #        optconsole()
    #        set_console_title("wavesDefault")

    try:
      if os.path.exists("WAVE.mhb"):
        import waveplot as w
        from waveplot import *
        n222=nget("n222")
        nby()
      #endif
    except: Quit()

  elif args[1] == "b" or args[1] == "byz":

    #        optconsole()
    #        set_console_title("wavesDefault")

    import waveplot as w
    from waveplot import *

    try:
      if os.path.exists("WAVE.mhb"):
        n222=nget("n222")
        nbybz()
      #endif
    except:
      nlist()
    #endtry

  elif args[1] == "zy" or args[1] == "yz":

    #        optconsole()
    #        set_console_title("wavesDefault")

    try:
      if os.path.exists("WAVE.mhb"):
        import waveplot as w
        from waveplot import *
        n222=nget("n222")
        nzy()
      #endif
    except: Quit()

  elif args[1] == "zby" or args[1] == "zb":

    # optconsole()
    set_console_title("wavesDefault")

    import waveplot as w
    from waveplot import *
    n222=nget("n222")
    zone(1,2)
    nby()
    nextzone()
    nz()

  elif args[1] == "z":

    #        optconsole()
    #        set_console_title("wavesDefault")

    if os.path.exists("WAVE.mhb"):
      import waveplot as w
      from waveplot import *
      n222=nget("n222")
      nz()
    #endif

  elif args[1] == "y":

    #        optconsole()
    #        set_console_title("wavesDefault")

    if os.path.exists("WAVE.mhb"):
      import waveplot as w
      from waveplot import *
      n222=nget("n222")
      ny()
    #endif

  elif args[1] == "zp":

    #        optconsole()
    #        set_console_title("wavesDefault")

    if os.path.exists("WAVE.mhb"):
      import waveplot as w
      from waveplot import *
      n222=nget("n222")
      nzp()
    #endif

  elif args[1] == "messmodel":

    optconsole()
    set_console_title("wavesDefault")

    if os.path.exists("WAVE.mhb"):
      import waveplot as w
      from waveplot import *
      nhal=ncread("nhal","x:z:zp:by","model.dat",skiphead=1)
      nmess=ncread("nmess","x:z:zp:by","mess.dat",skiphead=1)
      #            zone(1,2)
      #            sel = 'abs(x+0.5)<0.1'
      #            nplc(nhal,"x:by",sel)
      #            nplcgs("n10","x:by",sel)
      #            sel = 'abs(x+1.9)<0.1'
      zone(1,3)
      sel = 'abs(x+1.832)<0.01'
      nplc("n10","x:by",sel)
      nplcgs(nmess,"x:by",sel)
      sel = 'abs(x+1.218)<0.01'
      nnplc("n10","x:by",sel)
      nplcgs(nmess,"x:by",sel)
      sel = 'abs(x+0.535)<0.01'
      nnplc("n10","x:by",sel)
      nplcgs(nmess,"x:by",sel)
      #            sel = 'abs(x+1.9)<0.1'
    #endif

  elif args[1] == "n9988":

    optconsole()
    set_console_title("wavesDefault")

    if os.path.exists("WAVE.mhb"):
      import waveplot as w
      from waveplot import *

      n99=ncread("n99","l:x:y:z:s:vx:vy:vz:b","fort.99")
      n88m=ncread("n88m","x:z:b:ang","mrad.88")
      n88w=ncread("n88w","x:z:b:ang","wave.88")
      n10=nget("n10")

      zone(1,3)

      sel="abs(x-0.55)<1."
      sell="l==9 and " + sel

      dot()
      npl(n10,"x:by",sel)
      #nplmls(n88m,"x:b","abs(x-0.6)<0.1")
      nplmls(n99,"x:b",sell)
      #nplmls(n88w,"x:b",sel)

      nextzone()
      #nplmls(n88m,"x:ang*0.017453292519943295e3","abs(x-0.6)<0.1")
      npl(n10,"x:atand(vz/vx)",sel)
      nplmgs(n99,"x:atand(vz/vx)",sell)
      #nplmgs(n88w,"x:ang*0.017453292519943295e3","abs(x-0.6)<0.1")
      #nplmgs(n99,"x:z*1000")            nextzone()

      nextzone()
      npl(n10,"x:z",sel)
      nplmgs(n99,"x:z",sell)

    else:
      print("*** WAVE.mhb not found, nothing to plot ***")
    #endif

    get_console("wavesDefault")
    wans('Hit Q or q to quit:')

  elif args[1] == "Byz":

    optconsole()
    set_console_title("wavesDefault")

    if os.path.exists("WAVE.mhb"):
      import waveplot as w
      from waveplot import *
      zone(1,2)
      nbybz()
      nextzone()
      nyz()
    else:
      print("*** WAVE.mhb not found, nothing to plot ***")
    #endif

    get_console("wavesDefault")
    wans('Hit Q or q to quit:')

  elif args[1] == "maus":
    set_console_title("wavesPython")
    nmd= ncread("nmd","x:z","maus_disp.dat")
    nms= ncread("nms","x:zp","maus_slope.dat")

  elif args[1] == "tribs_UE52":
    import waveplot as w
    from waveplot import *
    ntribs=ncread("ntribs","i:elem:s:z1:z2:z3:zp1:zp2:zp3","tribs_separation_displacement_angle.dat",skiphead=3)
    #nplc("n10","x:by","abs(x)<4.5")
    #        zone(2,1)
    nplm("n10","x:z*1000.","abs(x)<4.5",color='black')
    #        nplcs(ntribs,"s-75.:z3*1000.","abs(s-75.)<5") #IVUE32
    nplcrs(ntribs,"s-120.:z1*1000.","abs(s-120.)<5") #UE52
    nplcbs(ntribs,"s-120.:z2*1000.","abs(s-120.)<5") #UE52
    nplcgs(ntribs,"s-120.:z3*1000.","abs(s-120.)<5") #UE52
    txyz("UE52, TRIBS","x [m]","z [mm]")
    pp("ue52_tribs_z_vs_x.pdf")
    #        nextzone()
    #        ndistpow()
    #        os.system("cp waveplot_3.dat ivue32_power_upstream_dipole_island-3.dat")
    #        pp("ivue32_power_upstream_dipole_island-3.pdf")
  elif args[1] == "tribs_CPMU17":

    import waveplot as w
    from waveplot import *

    ntribs=ncread("ntribs","i:elem:s:z1:z2:z3:zp1:zp2:zp3","tribs_separation_displacement_angle.dat",skiphead=3)

    n10 = nget("n10")
    xmin = max(n10.x.min(),-4.6)
    xmax = n10.x.max()

    selx = "x >= " + str(xmin)
    sels = "s-165. >= " + str(xmin) + " and s-165. <= " + str(xmax)

    ms()
    nplm("n10","x:z*1000.",selx,color='black',legend='WAVE')

    nplcrs(ntribs,"s-165.:z1*1000.",sels,legend='Turn 1') #CPMU17
    nplcbs(ntribs,"s-165.:z2*1000.",sels,legend='Turn 2') #CPMU17
    nplcgs(ntribs,"s-165.:z3*1000.",sels,legend='Turn 3') #CPMU17

    legend()

    txyz("CPMU17, TRIBS","x [m]","z [mm]")
    pp("cpmu17_tribs_z_vs_x_"+ str(w.Wrun) + ".pdf")

  elif args[1] == "beta":
    import waveplot as w
    from waveplot import *
    optnstat()
    hbeta()
    #nbs=ncread("nbs","x:bx:by","~/spectra/betas.dat",skiphead=1)
    #setlinestyle("dashed")
    #nplcgs(nbs,"x:bx")
    #nplccs(nbs,"x:by")

  elif args[1] == "u41":
    nf81 = ncread("nf81","z:byi:bzi","sw2281_fit.dat")
    nw=ncread("nw","m:z:byi:bzi","fort.99")
    zone(2,1)
    nplc(nf81,"z:byi")
    nplms(nw,"z:byi","m==1")
    nextzone()
    nplc(nf81,"z:bzi")
    wans()

  elif args[1] == "u41fit":

    for i in range(9):
      com='n228'+str(i+1)+' = ncread("n228'+str(i+1)+'","z:byi:bzi","u41_field_integrals/Daten/sw228'+str(i+1)+'.yz1",skiphead=1)'
      exec(com)
    #endfor
    for i in range(2):
      com='n229'+str(i)+' = ncread("n229'+str(i)+'","z:byi:bzi","u41_field_integrals/Daten/sw229'+str(i)+'.yz1",skiphead=1)'
      exec(com)
    #endfor
    nlist()
    zone(2,1)

    nfitxy(n2282,"z/1000.:byi/1000.","",6)
    nf2282y=ncopn("Nfitxy","nf2282y")
    nf2282y.columns = ['z','byi','ey','fit']

    nfitxy(n2282,"z/1000.:bzi/1000.","",6)
    nf2282z=ncopn("Nfitxy","nf2282z")
    nf2282z.columns = ['z','bzi','ey','fit']

    n2282f = nmerge("nf2282y","nf2282z","n2282f","z:byi:fit","bzi:fit","z:byi:fy:bzi:fz")

    npl(n2282f,"z:byi")
    nplcs(n2282f,"z:fy")
    txyz("sw2282.yz1","z/m","ByInt1/Tm")

    nextzone()

    npl(n2282f,"z:bzi")
    nplcs(n2282f,"z:fz")
    txyz("sw2282.yz1","z/m","BzInt1/Tm")

    ndump(n2282f,"z:fy:fz","","sw2282_fit.dat")
    pp("sw2282_yz1.pdf")

    nextzone()
    npl(n2281,"z:byi")
    nplmbs(n2282,"z:byi")
    nplmgs(n2283,"z:byi")
    txyz("sw228-1/2/3.yz1","z/m","ByInt1/Tm")

    nextzone()
    npl(n2281,"z:bzi")
    nplmbs(n2282,"z:bzi")
    nplmgs(n2283,"z:bzi")
    txyz("sw228-1/2/3.yz1","z/m","BzInt1/Tm")
    pp("sw228_1_2_3_yz1.pdf")

  elif args[1] == "power_cpmu17":
    import waveplot as w
    from waveplot import *
    import cpmu17_power
    from cpmu17_power import *
    cpmu17_power()
  elif args[1] == "power":
    import waveplot as w
    from waveplot import *
    #        null()
    #        w,h=getplotsize()
    #        print(w,h)
    #        setplotsize(plt.gcf(),w,h)

    ndistpow()
  elif args[1] == "trib":
    #import waveplot as w
    #from waveplot import *
    set_console_title("wavesPython")
    nref = ncread('nref',"xr:yr:zr:ypr:zpr","traj_ref.dat")
    ntra = ncread('ntra',"x:y:z:yp:zp","traj_trib.dat")
    ntrib = nmerge(ntra,nref,"ntrib")
    nmd= ncread("nmd","x:z","./res_SepOrbitAngle_T6EMIL_1-turn_displacement_maus.dat")
    nms= ncread("nms","x:zp","res_SepOrbitAngle_T6EMIL_1-turn_slope_maus.dat")
    zone(1,2)
    null(nref.xr.min(),nref.xr.max(),-10.,10.)
    nplcbs(nmd,"x-165.:z")
    nplcs(ntrib,"x:z-zr")
    txyz("CPMU17 - TRIBS","x [m]","z [mm]")
    nextzone()
    null(nref.xr.min(),nref.xr.max(),-8.,8)
    nplcbs(nms,"x-165.:zp")
    nplcs(ntrib,"x:zp-zpr","x>-5.2 and x<=0")
    txyz("","x [m]","zp [mm]")
    pp("cpmu17_trib_vergleich.pdf")
    get_console()
    wans('Hit Q or q to quit:')

  elif args[1] == "track":
    import waveplot as w
    from waveplot import *
    set_console_title("wavesPython")
    optconsole()
    ndump("n20","x:by","x<0.0","traj.dat")
    Quit()
    get_console()
    wans('Hit Q or q to quit:')
  #endif arg1

  get_console()
  wans('Hit Q or q to quit:')
#endif nargs > 1

if not ntuples:
    for n in range(len(Nhead)):
        snam = Nhead[n][1]
        exec(snam + ' = nget("' + snam + '")')
    #endfor
#endif

if histos:
  for hh in H1head:
    snam = hh[0]
    exec(snam + ' = hget("' + snam + '")')
  #endfor
  for hh in H2head:
    snam = hh[0]
    exec(snam + ' = hget("' + snam + '")')
  #endfor
#endif
+PATCH,URADPHASE.
*CMZ :  4.01/00 15/01/2023  16.23.59  by  Michael Scheer
+KEEP,uradphasemod.
*CMZ :          31/12/2023  14.39.50  by  Michael Scheer
*CMZ :  4.01/04 11/12/2023  10.12.16  by  Michael Scheer
*CMZ :  4.01/02 12/05/2023  13.39.18  by  Michael Scheer
*CMZ :  4.01/00 13/02/2023  10.56.51  by  Michael Scheer
*-- Author :    Michael Scheer   14/01/2023
      module uradphasemod

      double precision, dimension(:,:), allocatable :: obsv_u, stokes_u,
     &  track_u, fbunch_u, obsvprop_u,stokesprop_u
      double precision, dimension(:), allocatable ::  epho_u,specpow_u,pow_u

      double complex, dimension(:,:), allocatable :: arad_u,aradprop_u

      double precision
     &  ebeam_u,gamma_u,curr_u,banwid_u,
     &  xi_u,xe_u,yi_u,ye_u,zi_u,ze_u,step_u,
     &  pincen_u(3),pinw_u,pinh_u,
     &  ephmin_u,ephmax_u,emith_u,emitv_u,
     &  perlen_u,shift_u,beffv_u,beffh_u,pherror_u,
     &  xbeta_u,betah_u,alphah_u,betav_u,alphav_u,espread_u,
     &  disph_u,dispph_u,dispv_u,disppv_u,bunchlen_u,bunchcharge_u,
     &  pinxprop_u,pinwprop_u,pinhprop_u

      integer nstep_u,nepho_u,nobsv_u,nbunch_u,npiny_u,npinz_u,
     &  nper_u,modeph_u,modepin_u,modesphere_u,noranone_u,nlpoi_u,
     &  nobsvprop_u,npinyprop_u,npinzprop_u

      integer
     &  ibunch_u,ihbunch_u,mthreads_u,nelec_u,icohere_u,modebunch_u

      end module uradphasemod
+DECK,urad_phase_main,T=F77.
*CMZ :          31/12/2023  14.41.16  by  Michael Scheer
*CMZ :  4.01/04 28/12/2023  15.32.18  by  Michael Scheer
*CMZ :  4.01/03 17/05/2023  10.57.05  by  Michael Scheer
*CMZ :  4.01/02 12/05/2023  13.32.32  by  Michael Scheer
*CMZ :  4.01/00 22/02/2023  14.57.49  by  Michael Scheer
*-- Author : Michael Scheer
+seq,gplhint.
      program urad_phase_main

      use omp_lib
      use uradphasemod

      implicit none

+seq,phyconparam.

      double precision, dimension(:), allocatable :: z,y
      double precision, dimension(:,:), allocatable :: s

      double precision :: banwid=0.001,xbeta=0.0d0,
     &  perlen,shift,ebeam,curr,step,perl,
     &  pincen(3),pinw,pinh,park,wlen1,gamma,
     &  ephmin,ephmax,beffv,beffh,pherror,stosum(4),
     &  alphah,alphav,espread,harm,b0eff,rhv,
     &  betah,betav,eps0h,eps0v,pinx,piny,pinz,
     &  disph,dispph,dispv,disppv,bunchcharge,bunchlen,efi(3),bfi(3),rn(3),
     &  emith,emitv,pinxprop,pinwprop,pinhprop

      real xran(1),rr(2),axr,axi,ayr,ayi,azr,azi

      integer :: idebug=0,noranone,i,
     &  npiny,npinz,nper,nepho,modeph,modepin,modesphere,nharm,iy,iz,iobs,
     &  mthreads,nelec,icohere,ihbunch,ipho,iobph,iel,modebunch,ifieldprop,
     &  modewave=0,isto,nlpoi=0,nobsvprop,npinyprop,npinzprop

      namelist/uradphasen/
     &  perlen,shift,nper,beffv,beffh,
     &  ebeam,curr,step,noranone,nobsvprop,npinyprop,npinzprop,
     &  pinx,piny,pinz,pinw,pinh,npiny,npinz,modepin,modesphere,nharm,harm,
     &  nepho,ephmin,ephmax,pherror,pinxprop,pinwprop,pinhprop,
     &  mthreads,nelec,icohere,ihbunch,modeph,modebunch,ifieldprop,
     &  betah,betav,alphah,alphav,emith,emitv,espread,
     &  disph,dispph,dispv,disppv,bunchcharge,bunchlen

      integer :: irnsize=64,irnseed(64),ifixseed
      namelist/seedn/irnseed,ifixseed

      integer :: luna,istat,kalloc=1

      open(newunit=luna,file='urad_phase.nam',status='old',iostat=istat)
      if (istat.ne.0) then
        stop "*** Error: Could not open urad_phase.nam"
      endif

      read(luna,uradphasen)
      read(luna,seedn)

      close(luna)

      if(nelec.eq.1.and.noranone.eq.0) then
        noranone=1
        print*
        print*,'*** Changed NORANONE=0 to NORANONE=1, since NELEC=1'
        print*
      endif

      pincen=[pinx,piny,pinz]
      eps0h=emith*1.0d-9
      eps0v=emitv*1.0d-9

      bunchlen=bunchlen/1.0d9 !nm->m

      !print*,"sigz, sizp:",sigz/1000.0d0,sigzp/1000.0d0
      !print*,"sigy, siyp:",sigy/1000.0d0,sigyp/1000.0d0

      if (ifixseed.ne.0) then
        ifixseed=1
        call util_random_set_seed(irnsize,irnseed)
      endif

      if (nharm.gt.0.and.harm.gt.0.0d0) then

        gamma=ebeam/emassg1
        wlen1=wtoe1/abs(harm/nharm)
        perl=perlen/1000.0d0
        park=2.0d0*(wlen1/(perl*1.0d9/2.0d0/gamma**2)-1.0d0)

        if (park.lt.0.0d0) then
          write(6,*)
     &      '*** Error in urad_phase_main:'
          write(6,*)
     &      'Inconsistent values of nharm, harm, and perlen'
          write(6,*)' '
          stop
        endif

        park=sqrt(park)
        b0eff=park/(echarge1*perl/(2.*pi1*emasskg1*clight1))

        if (beffh.eq.0.0d0.and.beffv.ne.0d0) then
          beffv=beffv/abs(beffv)*b0eff
        else if (beffv.eq.0.0d0.and.beffh.ne.0d0) then
          beffh=beffh/abs(beffh)*b0eff
        else
          rhv=beffh/beffv
          beffh=b0eff/sqrt(1.0d0+1.0d0/rhv**2)*beffh/abs(beffh)
          beffv=beffh/rhv
        endif

      endif

      npiny=max(1,npiny)
      npinz=max(1,npinz)

      open(newunit=luna,file='urad_phase.pin')
      write(luna,*)npinz,npiny,pinw,pinh
      write(luna,*)pincen
      close(luna)

      if (mthreads.lt.0) then
        mthreads=OMP_GET_MAX_THREADS()
      else if (mthreads.eq.0) then
        mthreads=1
      endif

      call urad_phase(
     &  mthreads,nelec,noranone,icohere,modebunch,bunchlen,bunchcharge,ihbunch,
     &  perlen,shift,nper,beffv,beffh,
     &  ebeam,curr,step,nlpoi,
     &  pincen,pinw,pinh,npiny,npinz,modepin,modesphere,
     &  nepho,ephmin,ephmax,banwid,
     &  xbeta,betah,alphah,betav,alphav,espread,emith,emitv,
     &  disph,dispph,dispv,disppv,
     &  modeph,pherror,modewave
     &  )

      open(newunit=luna,file='urad_phase.fld')

      do iobs=1,nobsv_u
        do ipho=1,nepho_u
          iobph=iobs+nobsv_u*(ipho-1)

          rn(1)=real(arad_u(2,iobph)*conjg(arad_u(6,iobph))-arad_u(3,iobph)*conjg(arad_u(5,iobph)))
          rn(2)=real(arad_u(3,iobph)*conjg(arad_u(4,iobph))-arad_u(1,iobph)*conjg(arad_u(6,iobph)))
          rn(3)=real(arad_u(1,iobph)*conjg(arad_u(5,iobph))-arad_u(2,iobph)*conjg(arad_u(4,iobph)))
          rn=rn/norm2(rn)

          axr=real(arad_u(1,iobph))
          axi=imag(arad_u(1,iobph))
          ayr=real(arad_u(2,iobph))
          ayi=imag(arad_u(2,iobph))
          azr=real(arad_u(3,iobph))
          azi=imag(arad_u(3,iobph))

          write(luna,'(3(1pe15.6e3),i10,21(1pe15.6e3))')
     &      obsv_u(1:3,iobs),ipho,epho_u(ipho),stokes_u(1:4,iobph),pow_u(iobs),
     &      real(arad_u(1,iobph)),imag(arad_u(1,iobph)),
     &      real(arad_u(2,iobph)),imag(arad_u(2,iobph)),
     &      real(arad_u(3,iobph)),imag(arad_u(3,iobph)),
     &      real(arad_u(4,iobph)),imag(arad_u(4,iobph)),
     &      real(arad_u(5,iobph)),imag(arad_u(5,iobph)),
     &      real(arad_u(6,iobph)),imag(arad_u(6,iobph)),
     &      rn

        enddo
      enddo
      close(luna)

      allocate(z(nobsv_u),y(nobsv_u),s(npinz_u,npiny_u))

      open(newunit=luna,file='urad_phase.flx')

      z=obsv_u(3,1:npinz_u)

      do iy=1,npiny_u
        iobs=npinz_u*(iy-1)+iy
        y(iy)=obsv_u(2,iobs)
      enddo

      do ipho=1,nepho_u
        if (modepin.eq.0.and.npinz_u.ge.3.and.npiny_u.ge.3) then
          do isto=1,4
            iobs=0
            do iz=1,npinz_u
              do iy=1,npiny_u
                iobs=iobs+1
                iobph=iobs+nobsv_u*(ipho-1)
                s(iz,iy)=stokes_u(isto,iobph)
              enddo
            enddo
            call util_spline_integral_2d(npinz_u,npiny_u,z,y,s,stosum(isto),
     &        istat,kalloc)
            kalloc=0
          enddo !isto
          write(luna,*)ipho,epho_u(ipho),stosum
        else
          iobs=0
          stosum=0.0d0
          do iz=1,npinz_u
            do iy=1,npiny_u
              iobs=iobs+1
              iobph=iobs+nobsv_u*(ipho-1)
              stosum=stosum+stokes_u(1:4,iobph)
            enddo
          enddo
          write(luna,*)ipho,epho_u(ipho),stosum/nobsv_u*pinw*pinh
        endif
      enddo
      close(luna)

      open(newunit=luna,file='urad_phase.bun')
      if (ihbunch.le.0) then
        write(luna,*)
      else
        do iel=1,nelec_u/ihbunch_u*nepho_u
          if(fbunch_u(21,iel).ne.0.0d0) then
            write(luna,*)fbunch_u(:,iel)
          endif
        enddo
      endif
      close(luna)

      call  util_random_get_seed(irnsize,irnseed)

      open(newunit=luna,file='urad_phase.seeds',status='unknown')
      write(luna,*)irnsize
      do i=1,irnsize
        write(luna,*)i,irnseed(i)
      enddo
      flush(luna)
      close(luna)

      if (ifieldprop.ne.0) then
        pinxprop_u=pinxprop
        pinwprop_u=pinwprop
        pinhprop_u=pinhprop
        npinyprop_u=max(1,npinyprop)
        npinzprop_u=max(1,npinzprop)

        call urad_phase_prop(mthreads)

        open(newunit=luna,file='urad_phase.fdp')

        do iobs=1,nobsvprop_u
          do ipho=1,nepho_u
            iobph=iobs+nobsvprop_u*(ipho-1)

            rn(1)=real(aradprop_u(2,iobph)*conjg(aradprop_u(6,iobph))-aradprop_u(3,iobph)*conjg(aradprop_u(5,iobph)))
            rn(2)=real(aradprop_u(3,iobph)*conjg(aradprop_u(4,iobph))-aradprop_u(1,iobph)*conjg(aradprop_u(6,iobph)))
            rn(3)=real(aradprop_u(1,iobph)*conjg(aradprop_u(5,iobph))-aradprop_u(2,iobph)*conjg(aradprop_u(4,iobph)))
            rn=rn/norm2(rn)

            axr=real(aradprop_u(1,iobph))
            axi=imag(aradprop_u(1,iobph))
            ayr=real(aradprop_u(2,iobph))
            ayi=imag(aradprop_u(2,iobph))
            azr=real(aradprop_u(3,iobph))
            azi=imag(aradprop_u(3,iobph))

            write(luna,'(3(1pe15.6e3),i10,20(1pe15.6e3))')
     &        obsvprop_u(1:3,iobs),ipho,epho_u(ipho),stokesprop_u(1:4,iobph),
     &        real(aradprop_u(1,iobph)),imag(aradprop_u(1,iobph)),
     &        real(aradprop_u(2,iobph)),imag(aradprop_u(2,iobph)),
     &        real(aradprop_u(3,iobph)),imag(aradprop_u(3,iobph)),
     &        real(aradprop_u(4,iobph)),imag(aradprop_u(4,iobph)),
     &        real(aradprop_u(5,iobph)),imag(aradprop_u(5,iobph)),
     &        real(aradprop_u(6,iobph)),imag(aradprop_u(6,iobph)),
     &        rn

          enddo
        enddo

        close(luna)

      endif

      end
+DECK,urad_phase,T=F77.
*CMZ :  4.01/04 28/12/2023  15.30.57  by  Michael Scheer
*CMZ :  4.01/02 12/05/2023  17.13.05  by  Michael Scheer
*CMZ :  4.01/00 21/02/2023  16.51.29  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine urad_phase(
     &  mthreads,nelec,noranone,icohere,modebunch,bunchlen,bunchcharge,ihbunch,
     &  perlen,shift,nper,beffv,beffh,
     &  ebeam,curr,step,nlpoi,
     &  pincen,pinw,pinh,npiny,npinz,modepin,modesphere,
     &  nepho,ephmin,ephmax,banwid,
     &  xbeta,betah,alphah,betav,alphav,espread,emith,emitv,
     &  disph,dispph,dispv,disppv,
     &  modeph,pherror,modewave
     &  )

      use omp_lib
      use uradphasemod

      implicit none

+seq,phyconparam.
+seq,uservar.

      double precision
     &  perlen,shift,ebeam,curr,step,banwid,
     &  pincen(3),pinw,pinh,betah,alphah,betav,alphav,
     &  ephmin,ephmax,beffv,beffh,pherror,espread,emith,emitv,
     &  disph,dispph,dispv,disppv,y,z,dy,dz,ymin,zmin,bunchlen,bunchcharge,
     &  xbeta,df,xx,yy,zz,r,xn,yn,zn,h2

      integer
     &  npiny,npinz,nper,nepho,mthreads,nelec,icohere,ihbunch,i,nlpoi,
     &  modeph,modepin,modesphere,modebunch,iy,iz,iobsv,noranone,modewave

      if (modewave.ne.0) call util_zeit_kommentar(6,'Entered urad_phase')

      mthreads_u=mthreads

      nelec_u=nelec
      noranone_u=noranone
      icohere_u=icohere
      modebunch=modebunch_u
      bunchlen_u=bunchlen
      bunchcharge_u=bunchcharge
      ihbunch_u=ihbunch

      perlen_u=perlen/1000.0d0
      shift_u=shift/1000.0d0
      nper_u=nper
      beffv_u=beffv
      beffh_u=beffh

      ebeam_u=ebeam
      gamma_u=ebeam_u/emassg1
      step_u=step/1000.0d0
      nstep_u=max(1,nint(perlen_u/step_u))

      curr_u=curr

      pincen_u=pincen/1000.0d0
      pinw_u=pinw/1000.0d0
      pinh_u=pinh/1000.0d0
      npiny_u=npiny
      npinz_u=npinz
      modepin_u=modepin

      ephmin_u=ephmin_u
      ephmax_u=ephmax_u
      banwid_u=banwid
      nepho_u=nepho

      npiny_u=max(1,npiny_u)
      npinz_u=max(1,npinz_u)

      nlpoi_u=nlpoi
c      nlpoi_u=user(12)*nper_u
      nlpoi_u=user(12)

      if (modepin.eq.0) then
        nobsv_u=npiny_u*npinz_u
      else
        npinz_u=1
        npiny_u=1
        nobsv_u=1
      endif

      allocate(epho_u(nepho),obsv_u(3,nobsv_u),
     &  arad_u(6,nobsv_u*nepho_u),
     &  specpow_u(nobsv_u),
     &  fbunch_u(41,nelec_u/max(1,ihbunch_u)*nepho_u),
     &  stokes_u(4,nobsv_u*nepho_u),pow_u(nobsv_u)
     &  )

      stokes_u=0.0d0
      specpow_u=0.0d0
      fbunch_u=0.0d0
      arad_u=(0.0d0,0.0d0)
      pow_u=0.0d0

      if (npiny_u.eq.1) then
        dy=0.0d0
        ymin=pincen_u(2)
      else
        dy=pinh_u/(npiny_u-1)
        ymin=pincen_u(2)-pinh_u/2.0d0
      endif

      if (npinz_u.eq.1) then
        dz=0.0d0
        zmin=pincen_u(3)
      else
        dz=pinw_u/(npinz_u-1)
        zmin=pincen_u(3)-pinw_u/2.0d0
      endif

      iobsv=0
      y=ymin-dy
      do iy=1,npiny_u
        y=y+dy
        z=zmin-dz
        do iz=1,npinz_u
          iobsv=iobsv+1
          z=z+dz
          obsv_u(1,iobsv)=pincen_u(1)
          obsv_u(2,iobsv)=y
          obsv_u(3,iobsv)=z
          if (modesphere.ne.0) then
            !all util_break
            xx=obsv_u(1,iobsv)
            yy=obsv_u(2,iobsv)
            zz=obsv_u(3,iobsv)
c            r=sqrt(xx*xx+yy*yy+zz*zz)
            h2=(zz**2+yy**2)/xx**2
            if (h2.lt.0.01) then
c              r=xx*(1.0d0+h2/2.0d0-h2**2/8.0d0)
              r=xx*(1.0d0+(((((-0.0205078125D0*h2+0.02734375D0)*h2
     &      -0.0390625D0)*h2+0.0625D0)*h2-0.125D0)*h2+0.5D0)*h2)
            else
              r=xx*(1.0d0+sqrt(1.0d0+h2))
            endif
            xn=xx/r
            yn=yy/r
            zn=zz/r
            obsv_u(1,iobsv)=xn*xx
            obsv_u(2,iobsv)=yn*xx
            obsv_u(3,iobsv)=zn*xx
          endif
        enddo
      enddo

      nepho_u=max(1,nepho_u)
      if (nepho_u.gt.1) then
        df=(ephmax-ephmin)/(nepho_u-1)
        do i=1,nepho_u
          epho_u(i)=ephmin+(i-1)*df
        enddo
      else
        epho_u(1)=(ephmin+ephmax)/2.0d0
      endif

      xbeta_u=xbeta
      betah_u=betah
      alphah_u=alphah
      betav_u=betav
      alphav_u=alphav
      emith_u=emith
      emitv_u=emitv
      disph_u=disph
      dispph_u=dispph
      dispv_u=dispv
      dispph_u=disppv
      espread_u=espread

      modeph=modeph_u
      pherror_u=pherror

c      call urad_spline(modewave)
c      stop
c      if (modewave.eq.2) then
c        call urad_nnb(modewave)
c      else if (modewave.eq.3) then
c        call urad_spline(modewave)
c      else
        call urad_amprep(modewave)
c      endif

      stokes_u=stokes_u/1.0d6 ! photons/mm**2
      fbunch_u(4:14,:)=fbunch_u(4:14,:)*1000.0d0 ! mm
      fbunch_u(17:19,:)=fbunch_u(17:19,:)*1000.0d0 ! mm
      fbunch_u(22:26,:)=fbunch_u(22:26,:)/1.0d6 ! 1/mm**2
      arad_u=arad_u/1.0d3

      obsv_u=obsv_u*1000.0d0

      if (modewave.ne.0) call util_zeit_kommentar(6,'Leaving urad_phase')

      end
+DECK,urad_amprep.
*CMZ :          30/12/2023  18.27.14  by  Michael Scheer
*CMZ :  4.01/04 28/12/2023  13.39.24  by  Michael Scheer
*CMZ :  4.01/02 14/05/2023  11.47.49  by  Michael Scheer
*CMZ :  4.01/00 22/02/2023  14.34.04  by  Michael Scheer
*CMZ :  4.00/17 05/12/2022  10.30.41  by  Michael Scheer
*CMZ :  4.00/16 17/09/2022  15.46.32  by  Michael Scheer
*CMZ :  4.00/15 02/06/2022  09.45.10  by  Michael Scheer
*CMZ :  4.00/11 28/06/2021  10.33.06  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine urad_amprep(modewave)

      use omp_lib
      use uradphasemod

      implicit none

+seq,phyconparam.
+seq,track.
c+seq,uservar.

      complex*16 cde
      double precision :: h2,ddist,wlen,dphi,phase0

      double complex , dimension (:,:), allocatable :: aradbuff
      double complex , dimension (:,:,:), allocatable :: arad

      double precision, dimension (:), allocatable :: frq
      double precision, dimension (:,:), allocatable :: wsstokes,pow
      double precision, dimension (:,:,:), allocatable :: fbunch,stokes

      real, dimension (:), allocatable :: pherr,pherrc,phiran
      real, dimension(:,:), allocatable :: pranall,eall

      real eran(6),pran(2),rr(2)

      double complex :: apol,amp0(6),damp(6),amp(6),zexp,
     &  apolh,apolr,apoll,apol45,stokesv(4,3)

      double precision :: t,udgamtot,upow,vf0,vn,vx0,vx2,vxf0,vxi,vy0,vy2,vyf0,
     &  vyi,vz0,vz2,vzf0,vzi,wlen1,x0,x2,xf0,xi,xlell,y0,y2,yf0,yi,ypi,yy,yyp,
     &  z0,z2,zf0,zi,zpi,zz,zzp,fillb(41),stok1,stok2,stok3,stok4,speknor,
     &  sqnbunch,sqnphsp,specnor,sbnor,rpin,r00(3),xph0,
     &  r(3),r0(3),pw,ph,phsum,pkerr,pherror,ppin,parke,pc(3),pcbrill(3),om1,
     &  park,pr,hbarev,obs(3),om,fhigh,flow,gamma,eix,eiy,eiz,emassg,
     &  efx,efy,efz,eharm1,ecdipev,ebeam,dtpho,dt,dtelec,dd0,debeam,
     &  drn0(3),drn00(3),ds,dr0(3),dr00(3),drn(3),dpp,dph,dist,dist0,dobs(3),
     &  bunnor,clight,bunchx,beta,beff,spow,
     &  zp0,yp0,rph,anor,
     &  xkellip,zampell,yampell,parkv,parkh,zpampell,ypampell,emom

      double complex, dimension (:), allocatable ::
     &  uampex,uampey,uampez,uampbx,uampby,uampbz
      double precision, dimension (:,:), allocatable :: utraxyz,ustokes

      integer :: kfreq,iobsv,i,np2,nelec,mbunch,meinbunch,ibu,jbun,
     &  kran=6,icbrill,ilo,kobsv,i1,i2,n,
     &  ifail,ndimu,nstepu,ith,noespread,noemit,jbunch,jubunch,jhbunch,
     &  jcharge=-1,lmodeph,nclo,jeneloss=0,iamppin,
     &  iamppincirc=0,ifrob,iobfr,isub,jvelofield=0,nlbu=0,nepho,ielo,
     &  modewave

      integer, dimension (:), allocatable :: lnbunch

      integer :: idebug=0, lbunch=0, ierr=0, ielec=0
      integer ibunch,ihbunch,mthreads,nobsv,iemit,noranone,iz,iy,nobsvz,nobsvy
      integer iobm,iobp,iobfrm,iobfrp

c      integer iuser
c      iuser=user(3)

      nelec_u=max(1,nelec_u)
      mthreads_u=max(1,mthreads_u)
      nelec=nelec_u

      nobsvy=npiny_u
      nobsvz=npinz_u

      if (nelec_u.gt.1) then
        if (nelec_u.lt.mthreads_u.and.nelec_u.gt.1) then
          mthreads_u=nelec_u
        else
          nelec_u=max(mthreads_u,nelec_u/mthreads_u*mthreads_u)
        endif
      endif

      noranone=noranone_u

      if (nelec_u.ne.nelec) then
        print*,''
        print*,'--- Warning in urad_amprep: Nelec adjusted to multiple of number of threads:',nelec_u
        print*,''
      endif

      if (nelec_u.eq.1) then
        ibunch=0
      else
        ibunch=1
      endif

      ihbunch=ihbunch_u
      mthreads=mthreads_u

      if (modepin_u.eq.1) then
        iamppin=3
        nobsv=1
      else
        iamppin=1
        nobsv=npiny_u*npinz_u
      endif

      icbrill=nobsv/2+1

      jhbunch=max(0,ihbunch)
      meinbunch=nelec_u

      lbunch=0

      if (jhbunch.ne.0) then
        jhbunch=max(1,jhbunch)
      endif

      nepho=nepho_u

      nlbu=0
      if (ihbunch.gt.0) then
        lbunch=nelec_u/ihbunch
        nlbu=lbunch*nepho_u
        allocate(fbunch(41,nlbu,mthreads_u),stat=ierr)
        if (ierr.ne.0) then
          lbunch=0
          print*,""
          print*,"*** Warning in urad_amprep: Could not allocate buffer for beam Ntuple ***"
          print*,"*** Maybe increase IHBUNCH ***"
          print*,""
          return
        endif
        fbunch=0.0d0
        allocate(lnbunch(mthreads_u), stat=ierr)
        if (ierr.ne.0) then
          print*,""
          print*,"*** Warning in urad_amprep: Could not allocate buffer for nlbunch ***"
          print*,""
          return
        endif
        lnbunch=0
      endif

      call urad_field_ini(perlen_u,shift_u,beffv_u,beffh_u,modewave)

      if (perlen_u.ne.0.0d0) then
        emom=emasse1*dsqrt((gamma_u-1.0d0)*(gamma_u+1.0d0))
c*** OBSOLITE, SEE z0= further down
        xkellip=twopi1/perlen_u
        zampell=beffv_u*clight1/emom/xkellip**2
        yampell=beffh_u*clight1/emom/xkellip**2
c        zampell=zmx
c        yampell=ymx
        parkh=echarge1*dabs(beffh_u)*perlen_u/(twopi1*emasskg1*clight1)
        parkv=echarge1*dabs(beffv_u)*perlen_u/(twopi1*emasskg1*clight1)
        zpampell=parkv/gamma_u
c        print*,zpampell
c        ypampell=parkh/gamma_u
c        zpampell=tan(phimx)
c        print*,zpampell
c        stop
      else
        print*,''
        print*,'*** Error in urad_amprep: Zero period-length of undulator ***'
        print*,''
        stop
      endif

      dr00=[1.0d0,0.0d0,0.0d0]
      drn00=dr00/norm2(dr00)
      dr00=drn00*perlen_u
      r00=[0.0d0,0.0d0,0.0d0]

      x0=-perlen_u/2.0d0
      y0=0.0d0
      z0=0.0d0

      beta=dsqrt((1.0d0-1.0d0/gamma_u)*(1.0d0+1.0d0/gamma_u))

      clight=clight1
      hbarev=hbarev1
      ecdipev=ecdipev1
      emassg=emassg1

      if (modewave.eq.0) then
        z0=-zampell*cos(shift_u/2.0d0/perlen_u*twopi1)
        zp0=zpampell*sin(shift_u/2.0d0/perlen_u*twopi1)
        y0=-yampell*cos(shift_u/2.0d0/perlen_u*twopi1)
        yp0=-ypampell*sin(shift_u/2.0d0/perlen_u*twopi1)
      else
        y0=ytrack
        z0=ztrack
        zp0=vztrack/vxtrack
        yp0=vytrack/vxtrack
      endif

      xf0=-x0
      yf0=y0
      zf0=z0

      vn=clight*beta

      vx0=vn/sqrt(1.0d0+(zp0**2+yp0**2))
      vy0=vn*yp0
      vz0=vn*zp0

      vxf0=vx0
      vyf0=vy0
      vzf0=vz0

      vxi=vx0
      vyi=vy0
      vzi=vz0

      r0=r00
      dr0=dr00
      drn0=drn00
      r=r0
      drn=drn0

      vf0=norm2([vxf0,vyf0,vzf0])
      efx=vxf0/vf0
      efy=vyf0/vf0
      efz=vzf0/vf0

      nclo=nint(perlen_u/step_u)+1

      ds=step_u
c      dtim0=ds/beta

      ndimu=nint(nclo*1.1)

      r0=[x0,y0,z0]
      dr0=[xf0-x0,yf0-y0,zf0-z0]
      dr0=[efx,efy,efz]*perlen_u
      r0=r0+dr0/2.0d0

      allocate(frq(nepho_u),
     &  uampex(nepho_u),uampey(nepho_u),uampez(nepho_u),
     &  uampbx(nepho_u),uampby(nepho_u),uampbz(nepho_u),pow(nobsv,mthreads),
     &  utraxyz(14,ndimu),ustokes(4,nepho_u))

      pow=0.0d0
      frq=epho_u

      flow=frq(1)
      fhigh=frq(nepho_u)

      beff=sqrt(beffv_u**2+beffh_u**2)
      park=echarge1*beff*perlen_u/(2.*pi1*emasskg1*clight)
      wlen1=(1+park**2/2.)/2./gamma_u**2*perlen_u*1.0d9

      if (wlen1.ne.0.0) then
        eharm1=wtoe1/wlen1
      else
        eharm1=0.0d0
      endif

      dtpho=perlen_u/clight

      allocate(pherrc(nper_u),pherr(nper_u),arad(6,nepho_u*nobsv,mthreads),
     &  phiran(max(1,nelec_u)))

      allocate(pranall(2,nelec_u))
      do i=1,nelec_u
        call util_random(2,pran)
        pranall(:,i)=pran
      enddo

      if (ibunch.eq.0.or.
     &    emith_u.eq.0.0d0.and.emitv_u.eq.0.0d0.and.espread_u.eq.0.0d0) then
        iemit=0
      else
        iemit=1
      endif

      if (iemit.ne.0) then
        allocate(eall(6,nelec_u))
        do i=1,nelec_u
          xi=x0
          call util_get_electron(xbeta_u,betah_u,alphah_u,betav_u,alphav_u,
     &      emith_u,emitv_u,
     &      disph_u,dispph_u,dispv_u,disppv_u,
     &      espread_u,bunchlen_u,xi,yi,zi,ypi,zpi,dpp,modebunch_u)
          eall(1,i)=xi-x0
          eall(2,i)=yi
          eall(3,i)=zi
          eall(4,i)=ypi
          eall(5,i)=zpi
          eall(6,i)=dpp
        enddo
        if (noranone.ne.0) eall(:,1)=0.0
      endif

      !allocate(affe(6,nepho_u*nobsv))

      allocate(wsstokes(4,nepho_u*nobsv),stokes(4,nepho_u*nobsv,mthreads))
      stokes=0.0d0
      arad=(0.0d0,0.0d0)

      np2=nper_u/2

      call util_random_gauss_omp(nper_u,pherr,rr)
      pherrc=pherr

      lmodeph=modeph_u

      if (pherror.ne.0.0d0.and.(lmodeph.lt.0.or.lmodeph.gt.2)) then
        write(6,*) ""
        write(6,*) "*** Error in urad_amprep: MODEPH must be 0,1, or 2 ***"
        write(6,*) "*** Program aborted ***"
      endif

      if (lmodeph.eq.0.and.eharm1.ne.0.0d0) then
        om1=eharm1/hbarev
        pherr=sngl(pherrc*pherror/360.0d0*twopi1/om1)
      else if (lmodeph.eq.1) then
        pherr=sngl(pherr*pherror)
      else if (lmodeph.eq.2) then
        pherr(nper_u)=0.0
        phsum=0.0d0
        do i=1,nper_u-1
          pherr(i)=pherr(i)+pherrc(i)
          pherr(i+1)=pherr(i+1)-pherrc(i)
          phsum=phsum+pherr(i)
        enddo
        phsum=phsum+pherr(nper_u)
      else
        pherr=0.0d0
      endif !(lmodeph.eq.0)

      mbunch=max(1,nelec_u)
      nelec=nelec_u

      if (ibunch.ne.0.and.bunchcharge_u.ne.0.0d0) then
        sqnbunch=mbunch
        sqnphsp=sqrt(bunchcharge_u/echarge1)
     &    *meinbunch
     &    /(bunchcharge_u/echarge1)
        bunnor=1.0d0/mbunch
      else
        sqnbunch=mbunch
        sqnphsp=sqrt(dble(nelec_u))
        bunnor=1.0d0/mbunch
      endif

      beff=sqrt(beffv_u**2+beffh_u**2)
      parke=echarge1*beff*perlen_u/(2.*pi1*emasskg1*clight)
      xlell=perlen_u

      ielec=0

      pow=0.0d0
      noemit=0
      noespread=0
      jbunch=ibunch
      jubunch=0
      ebeam=ebeam_u
      debeam=espread_u
      stokesv=vstokes
      specnor=
     &  banwid_u
     &  /(4.0d0*pi1**2*clight*hbarev)
     &  /(4.0d0*pi1*eps01)
     &  *curr_u
      sbnor=specnor*bunnor
      speknor=specnor
      jeneloss=0
      pw=pinw_u
      ph=pinh_u
      !pr=pinr
      pc=pincen_u
      do iobsv=1,nobsv
        if (abs(obsv_u(2,iobsv)).lt.1.0d-9) obsv_u(2,iobsv)=0.0d0
        if (abs(obsv_u(3,iobsv)).lt.1.0d-9) obsv_u(3,iobsv)=0.0d0
      enddo
      pcbrill=obsv_u(:,icbrill)

!$OMP PARALLEL NUM_THREADS(mthreads) DEFAULT(PRIVATE)
!$OMP& FIRSTPRIVATE(nepho,nobsvz,nobsvy,nobsv,nelec,frq,nper_u,np2,perlen_u,clight,hbarev,flow,fhigh,
!$OMP& x0,y0,z0,xf0,yf0,zf0,vx0,vy0,vz0,vxf0,vyf0,vzf0,gamma_u,sbnor,speknor,
!$OMP& efx,efy,efz,ds,ndimu,curr_u,xlell,parke,amp,amp0,
!$OMP& uampex,uampey,uampez,uampbx,uampby,uampbz,
!$OMP& lmodeph,zp0,yp0,modewave,
!$OMP& jbunch,jubunch,jhbunch,noespread,noemit,ebeam,
!$OMP& stokesv,icbrill,obsv_u,emassg,debeam,dispv_u,disppv_u,
!$OMP& betah_u,alphah_u,betav_u,alphav_u,emith_u,emitv_u,disph_u,dispph_u,
!$OMP& pran,pranall,eall,fillb,r0,dr0,iamppin,iamppincirc,pc,phase0,pr,banwid_u,
!$OMP& pw,ph,idebug,pcbrill,wsstokes,vn,bunchlen_u,modebunch_u,icohere_u)
!$OMP& SHARED(mthreads,stokes,pherr,lbunch,lnbunch,
!$OMP& fbunch,jcharge,jeneloss,jvelofield,iemit,noranone,arad,pow)

      jbun=1
      isub=0
      iobsv=0
      ielo=0
      xph0=-perlen_u*dble(nper_u)/2.0d0

!$OMP DO

      do ilo=1,nelec*nobsv

        wsstokes=0.0d0
        !affe=(0.0D0,0.0D0)
        spow=0.0d0

        ith=OMP_GET_THREAD_NUM()+1

        iobsv=mod(ilo-1,nobsv)+1
        ibu=(ilo-1)/nobsv+1
        jbun=ibu

        iy=(iobsv-1)/nobsvz+1
        iz=mod(iobsv-1,nobsvz)+1

        !if (iz.gt.nobsvz/2+1) call til_break

        ielec=ibu

        xi=x0
        yi=y0
        zi=z0

        zpi=vz0/vx0
        ypi=vy0/vx0

        x2=xf0
        y2=yf0
        z2=zf0

        vx2=vxf0
        vy2=vyf0
        vz2=vzf0

        gamma=gamma_u

        dpp=0.0d0

        if (iemit.ne.0) then

          if (noranone.eq.0.or.ielec.ne.1) then

            bunchx=eall(1,ielec)

            xi=xi+bunchx
            yy=eall(2,ielec)
            zz=eall(3,ielec)

            yyp=eall(4,ielec)
            zzp=eall(5,ielec)

            dpp=eall(6,ielec)
            gamma=(1.0d0+dpp)*gamma_u

            ! assume beta(s)=beta0(s)+s**2/beta(0) and alpha0=-s/beta(0)
            ! and a drift transfer-matrix ((1,s),(1,0))

            zi=zz-x0*zzp !inverse transformation
            zpi=zzp

            yi=yy-x0*yyp
            ypi=yyp

            ! simple treatment of closed orbit, assume small angles

            zi=zi+z0
            zpi=zpi+zp0

            yi=yi+y0
            ypi=ypi+yp0

          else

            xi=x0
            yi=y0
            zi=z0
            ypi=yp0
            zpi=zp0

            bunchx=0.0d0

          endif

        else

          xi=x0
          yi=y0
          zi=z0
          ypi=yp0
          zpi=zp0

          bunchx=0.0d0

        endif !iemit

        t=bunchx/vn

c+self,if=old.
c        zi=zi+dpp*di0
c        zpi=zpi+dpp*dd0
c+self.
        vn=clight*dsqrt((1.0d0-1.0d0/gamma)*(1.0d0+1.0d0/gamma))

        vxi=vn/sqrt(1.0d0+ypi**2+zpi**2)
        vyi=vxi*ypi
        vzi=vxi*zpi

        obs=obsv_u(1:3,iobsv)

        if (noranone.eq.0.or.ielec.ne.1.or.iobsv.ne.icbrill) then
          if (iamppin.eq.3) then
            !call util_random(2,pran)
            pran(:)=pranall(:,ielec)
            if (iamppincirc.eq.0) then
              obs(2)=pc(2)+(pran(1)-0.5)*pw
              obs(3)=pc(3)+(pran(2)-0.5)*ph
            else
              rpin=(pran(1)-0.5)*pr
              ppin=pran(2)*twopi1
              obs(2)=pc(2)+rpin*cos(ppin)
              obs(3)=pc(3)+rpin*sin(ppin)
            endif
          endif
        endif

        vn=norm2([vxi,vyi,vzi])
        eix=vxi/vn
        eiy=vyi/vn
        eiz=vzi/vn

        h2=((obs(2)-yi)**2+(obs(3)-zi)**2)/(obs(1)-xph0)**2
        if (h2.lt.0.01) then
          rph=abs(obs(1)-xph0)*(1.0d0+(((((-0.0205078125D0*h2+0.02734375D0)*h2
     &      -0.0390625D0)*h2+0.0625D0)*h2-0.125D0)*h2+0.5D0)*h2)
        else
          rph=sqrt((obs(1)-xph0)**2+((obs(2)-yi)**2+(obs(3)-zi)**2))
        endif

        phase0=(rph-(obsv_u(1,icbrill)-xph0))/clight

        call urad_e_b_field(
     &    jcharge,curr_u,
     &    gamma,udgamtot,
     &    xi,yi,zi,vxi,vyi,vzi,
     &    xf0,yf0,zf0,efx,efy,efz,
     &    x2,y2,z2,vx2,vy2,vz2,dtelec,ds,
     &      0,nstepu,ndimu,utraxyz,phase0,
     &    obs(1),obs(2),obs(3),flow,fhigh,
     &    nepho,frq,uampex,uampey,uampez,uampbx,uampby,uampbz,
     &    ustokes,upow,
     &    jeneloss,jvelofield,ifail,ith,banwid_u,modewave)

        r0=[xi,yi,zi]
        dr0=[x2-xi,y2-yi,z2-zi]
        r0=r0+dr0/2.0d0

        do kfreq=1,nepho

          iobfr=iobsv+nobsv*(kfreq-1)

          om=frq(kfreq)/hbarev

          if (modewave.eq.0) then
            amp0=[
     &        uampex(kfreq),uampey(kfreq),uampez(kfreq),
     &        uampbx(kfreq),uampby(kfreq),uampbz(kfreq)
     &        ]*1.0d3/sqrt(speknor/curr_u*0.10d0) !urad
          else
            amp0=[
     &        uampex(kfreq),uampey(kfreq),uampez(kfreq),
     &        uampbx(kfreq),uampby(kfreq),uampbz(kfreq)
     &        ]*1.0d3/sqrt(speknor) !urad
          endif

          amp=(0.0d0,0.0d0)

          do i=1,nper_u

            r=r0+(i-np2-1)*dr0
            dobs=obs-r
            dist0=norm2(obs-r0)
            dist=norm2(dobs)

            if (kfreq.eq.1) then
              spow=spow+upow*(dist0/dist)**2
              pow(iobsv,ith)=pow(iobsv,ith)+upow*(dist0/dist)**2
            endif

            if (lmodeph.eq.0) then
!!!!!                dt=xlell/clight*((1.0d0+parke**2/2.0d0)/2.0d0/gamma**2+
!!!!!     &            (((ypi-dobs(2)/dobs(1))**2+(zpi-dobs(3)/dobs(1))**2))/2.0d0)
              h2=
     &          ((ypi-yp0-dobs(2))/dobs(1))**2 +
     &          ((zpi-zp0-dobs(3))/dobs(1))**2

c              dt=xlell/clight*
c     &          (
c     &          (1.0d0+parke**2/2.0d0)/2.0d0/gamma**2+h2/2.0d0-h2**2/8.0d0
c     &          )

              dph=om*(t+pherr(i))

              dt=xlell/clight*
     &          (
     &          (1.0d0+parke**2/2.0d0)/2.0d0/gamma**2+
     &          (((((-0.0205078125D0*h2+0.02734375D0)*h2
     &          -0.0390625D0)*h2+0.0625D0)*h2-0.125D0)*h2+0.5D0)*h2
     &          )

              t=t+dt
            else if (lmodeph.eq.1.or.lmodeph.eq.2) then
              dph=om*t
              pkerr=parke*(1.0d0+pherr(i))
!!!!!                dt=xlell/clight*((1.0d0+pkerr**2/2.0d0)/2.0d0/gamma**2+
!!!!!     &            (((ypi-dobs(2)/dobs(1))**2+(zpi-dobs(3)/dobs(1))**2))/2.0d0)
              h2=((ypi-yp0-dobs(2))**2+(zpi-zp0-dobs(3))**2)/dobs(1)**2
              dt=xlell/clight*
     &          (
     &          (1.0d0+parke**2/2.0d0)/2.0d0/gamma**2+
     &          (((((-0.0205078125D0*h2+0.02734375D0)*h2
     &          -0.0390625D0)*h2+0.0625D0)*h2-0.125D0)*h2+0.5D0)*h2
     &          )
              t=t+dt
            endif !lmodeph

            zexp=cdexp(dcmplx(0.0d0,dph))
            damp=amp0*zexp*dist0/dist
            amp=amp+damp

            if (jhbunch.ne.0) then

              if (
     &            (iamppin.eq.3.or.iobsv.eq.icbrill)
     &          .and.mod(ielec,jhbunch).eq.0) then

                if (i.eq.1) then
                  fillb(5)=r(1)
                  fillb(6)=r(2)
                  fillb(7)=r(3)
                  fillb(8)=ypi
                  fillb(9)=zpi
                else if (i.eq.nper_u) then
                  fillb(10:12)=r
                  fillb(13)=ypi
                  fillb(14)=zpi
                  fillb(30)=dreal(amp(1))
                  fillb(31)=dimag(amp(1))
                  fillb(32)=dreal(amp(2))
                  fillb(33)=dimag(amp(2))
                  fillb(34)=dreal(amp(3))
                  fillb(35)=dimag(amp(3))
                  fillb(36)=dreal(amp(4))
                  fillb(37)=dimag(amp(4))
                  fillb(38)=dreal(amp(5))
                  fillb(39)=dimag(amp(5))
                  fillb(40)=dreal(amp(6))
                  fillb(41)=dimag(amp(6))
                endif

              endif

            endif

          enddo !nper_u

          apolh=
     &      amp(1)*conjg(stokesv(1,1))
     &      +amp(2)*conjg(stokesv(1,2))
     &      +amp(3)*conjg(stokesv(1,3))

          apolr=
     &      amp(1)*conjg(stokesv(2,1))
     &      +amp(2)*conjg(stokesv(2,2))
     &      +amp(3)*conjg(stokesv(2,3))

          apoll=
     &      amp(1)*conjg(stokesv(3,1))
     &      +amp(2)*conjg(stokesv(3,2))
     &      +amp(3)*conjg(stokesv(3,3))

          apol45=
     &      amp(1)*conjg(stokesv(4,1))
     &      +amp(2)*conjg(stokesv(4,2))
     &      +amp(3)*conjg(stokesv(4,3))

          stok1=dreal(apolr*conjg(apolr)+apoll*conjg(apoll))
          stok2=dreal(-stok1+2.0d0*apolh*conjg(apolh))
          stok3=dreal(2.0d0*apol45*conjg(apol45)-stok1)
          stok4=dreal(apolr*conjg(apolr)-apoll*conjg(apoll))

          wsstokes(1,iobfr)=wsstokes(1,iobfr)+stok1*sbnor
          wsstokes(2,iobfr)=wsstokes(2,iobfr)+stok2*sbnor
          wsstokes(3,iobfr)=wsstokes(3,iobfr)+stok3*sbnor
          wsstokes(4,iobfr)=wsstokes(4,iobfr)+stok4*sbnor

          stokes(1:4,iobfr,ith)=stokes(1:4,iobfr,ith)+wsstokes(1:4,iobfr)

          !affe(:,iobfr)=affe(:,iobfr)+amp
          !arad(:,iobfr,ith)=arad(:,iobfr,ith)+affe(:,iobfr)
          arad(:,iobfr,ith)=arad(:,iobfr,ith)+amp

          if (jhbunch.ne.0) then

            if (
     &          (iamppin.eq.3.or.iobsv.eq.icbrill)
     &          .and.mod(ielec,jhbunch).eq.0) then

              fillb(1)=jbun
              fillb(2)=isub
              fillb(3)=ibu
              fillb(4)=bunchx
              fillb(15)=gamma*emassg
              fillb(16)=udgamtot*emassg
              fillb(17)=obs(1)
              fillb(18)=obs(2)
              fillb(19)=obs(3)
              fillb(20)=kfreq
              fillb(21)=frq(kfreq)

              fillb(22)=wsstokes(1,iobfr)*nelec

              fillb(23)=wsstokes(1,iobfr)*nelec
              fillb(24)=wsstokes(2,iobfr)*nelec
              fillb(25)=wsstokes(3,iobfr)*nelec
              fillb(26)=wsstokes(4,iobfr)*nelec

              fillb(27)=spow
              fillb(28)=1
              fillb(29)=dtelec

              fillb(30)=dreal(amp(1))
              fillb(31)=dimag(amp(1))
              fillb(32)=dreal(amp(2))
              fillb(33)=dimag(amp(2))
              fillb(34)=dreal(amp(3))
              fillb(35)=dimag(amp(3))
              fillb(36)=dreal(amp(4))
              fillb(37)=dimag(amp(4))
              fillb(38)=dreal(amp(5))
              fillb(39)=dimag(amp(5))
              fillb(40)=dreal(amp(6))
              fillb(41)=dimag(amp(6))

              if (lbunch.ne.0) then
                lnbunch(ith)=lnbunch(ith)+1
                fbunch(:,lnbunch(ith),ith)=fillb(:)
              endif

            endif !fill

          endif !jhbunch

        enddo !kfreq

      enddo !nbunch

!$OMP END DO
!$OMP END PARALLEL

      do ith=1,mthreads
        pow_u(:)=pow_u(:)+pow(:,ith)
        arad_u(:,:)=arad_u(:,:)+arad(:,:,ith)
      enddo
+self,if=p.
      allocate(aradbuff(6,nepho_u*nobsv))
      aradbuff=arad_u
      !all util_break
      do iz=1,nobsvz/2
        do iy=1,nobsvy
          do kfreq=1,nepho
            iobm=nobsvz*(iy-1)+iz
            iobp=nobsvz*(iy-1)+(nobsvz-iz+1)
            iobfrm=iobm+nobsv*(kfreq-1)
            iobfrp=iobp+nobsv*(kfreq-1)
            arad_u(:,iobfrm)=aradbuff(:,iobfrp)
c            arad_u(:,iobfrm)=(aradbuff(:,iobm)+aradbuff(:,iobp))/2.0d0
c            arad_u(:,iobfrp)=(aradbuff(:,iobm)+aradbuff(:,iobp))/2.0d0
          enddo
        enddo
      enddo
      deallocate(aradbuff)
+self.
      pow_u=pow_u/sqnbunch

      if (icohere_u.eq.0) then

        arad_u=arad_u/sqnbunch

        do ith=1,mthreads
          stokes_u(:,:)=stokes_u(:,:)+stokes(:,:,ith)
        enddo

      else

        do iobsv=1,nobsv
          do kfreq=1,nepho

            iobfr=iobsv+nobsv*(kfreq-1)

            amp(1:3)=arad_u(1:3,iobfr) !/sqnphsp

            apolh=
     &        amp(1)*conjg(stokesv(1,1))
     &        +amp(2)*conjg(stokesv(1,2))
     &        +amp(3)*conjg(stokesv(1,3))

            apolr=
     &        amp(1)*conjg(stokesv(2,1))
     &        +amp(2)*conjg(stokesv(2,2))
     &        +amp(3)*conjg(stokesv(2,3))

            apoll=
     &        amp(1)*conjg(stokesv(3,1))
     &        +amp(2)*conjg(stokesv(3,2))
     &        +amp(3)*conjg(stokesv(3,3))

            apol45=
     &        amp(1)*conjg(stokesv(4,1))
     &        +amp(2)*conjg(stokesv(4,2))
     &        +amp(3)*conjg(stokesv(4,3))

            stok1=dreal(apolr*conjg(apolr)+apoll*conjg(apoll))
            stok2=dreal(-stok1+2.0d0*apolh*conjg(apolh))
            stok3=dreal(2.0d0*apol45*conjg(apol45)-stok1)
            stok4=dreal(apolr*conjg(apolr)-apoll*conjg(apoll))

            stokes_u(1,iobfr)=stok1*sbnor
            stokes_u(2,iobfr)=stok2*sbnor
            stokes_u(3,iobfr)=stok3*sbnor
            stokes_u(4,iobfr)=stok4*sbnor

          enddo
        enddo

      endif !icohere_u

      if (ihbunch.ne.0) then
        n=0
        do i=1,nlbu
          do ith=1,mthreads_u
            if (fbunch(21,i,ith).ne.0.0d0) then
              n=n+1
              fbunch_u(:,n)=fbunch(:,i,ith)
            endif
          enddo
        enddo
        deallocate(fbunch)
      endif

      !deallocate(affe)
      deallocate(frq,uampex,uampey,uampez,uampbx,uampby,uampbz,utraxyz,
     &  pherrc,pherr,phiran,arad,pow,pranall,wsstokes,stokes)

      if (iemit.ne.0) deallocate(eall)

      iobfr=nobsv_u*nepho_u/2+1
      amp(1:3)=arad_u(1:3,iobfr)

      anor=sqrt(stokes_u(1,iobfr)/
     &  (amp(1)*dconjg(amp(1))+amp(2)*dconjg(amp(2))+amp(3)*dconjg(amp(3))))
      arad_u=arad_u*anor

      return
      end
+DECK,urad_e_b_field,T=F77.
*CMZ :          30/12/2023  16.09.34  by  Michael Scheer
*CMZ :  4.01/04 28/12/2023  15.35.56  by  Michael Scheer
*CMZ :  4.01/02 12/05/2023  09.04.01  by  Michael Scheer
*CMZ :  4.01/00 22/02/2023  15.28.31  by  Michael Scheer
*CMZ :  4.00/15 28/04/2022  15.32.20  by  Michael Scheer
*CMZ :  4.00/13 16/11/2021  17.32.24  by  Michael Scheer
*CMZ :  4.00/09 15/08/2020  08.51.05  by  Michael Scheer
*CMZ :  3.05/05 10/07/2018  09.19.31  by  Michael Scheer
*CMZ :  3.05/04 05/07/2018  11.10.09  by  Michael Scheer
*CMZ :  3.05/00 27/04/2018  15.22.16  by  Michael Scheer
*CMZ :  3.03/04 13/10/2017  09.16.28  by  Michael Scheer
*CMZ :  3.03/02 19/11/2015  13.32.35  by  Michael Scheer
*CMZ :  3.02/04 13/03/2015  10.38.25  by  Michael Scheer
*CMZ :  2.69/02 02/11/2012  16.40.18  by  Michael Scheer
*CMZ :  2.68/05 04/09/2012  13.30.58  by  Michael Scheer
*CMZ :  2.68/04 03/09/2012  11.52.24  by  Michael Scheer
*CMZ :  2.68/03 31/08/2012  09.45.28  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine urad_e_b_field(
     &  icharge,current,
     &  gammai,dgamtot,
     &  xelec,yelec,zelec,vxelec,vyelec,vzelec,
     &  xf,yf,zf,efxn,efyn,efzn,
     &  xexit,yexit,zexit,vnxex,vnyex,vnzex,texit,ds,
     &  nthstep,nstep,ndim,traxyz,phase0,
     &  xobsv,yobsv,zobsv,phelow,phehig,
     &  nphener,phener,aradex,aradey,aradez,aradbx,aradby,aradbz,stokes,powden,
     &  ieneloss,ivelofield,
     &  istatus,ith,banwid,modewave
     &  )
c123456789123456789_123456789_123456789_123456789_123456789_123456789_12
c Author: Michael Scheer, Michael.Scheer@Helmholtz-Berlin.de

c NO WARRANTY

+seq,gplhint.

c This subroutine calculates the trajectory and the synchrotron radiation
c of an electron passing a magnetic and electric field. The electric field
c part is very preliminary and not yet fully tested. The FORTRAN random
c generator is used in uradrndm. It should be replaced by a better one
c provided by the user.

c The fields B=(bx,by,bz) and E=(ex,ey,ez) are calculated in the routine
c uradfield_omp(x,y,z,bx,by,bz,ex,ey,ez,gamma,istatus) provided by the user.
c As an example uradbmap.f may be used, which reads a 3D map of the mag. field

c Coordinate system (right handed):
c -----------------------------------

c      x: longitudinal direction
c      y: transversal vertical direction
c      z: transversal horizontal direction

c Units:
c ------

c SI-units: m, Tesla, sec, V etc., but eV for the photon energy
c The flux-density is given in Nph/s/mm**2/0.1%BW, the power-density in W/mm**2

c Input:
c --------

c integer icharge: Particle charge ( +/- 1)
c real*8 gammai: Gamma factor of the e-

c real*8 xelec:  Initial x of e-
c real*8 yelec:  Initial y of e-
c real*8 zelec:  Initial z of e-

c real*8 vxelec:  Initial velocity in x of e-
c real*8 vyelec:  Initial velocity in y of e-
c real*8 vzelec:  Initial velocity in z of e-
c The velocity is internally normalized, so the input norm does not matter

c real*8 xf: x of point in exit plane
c real*8 yf: y of point in exit plane
c real*8 zf: z of point in exit plane

c real*8 [efxn,efyn,efzn]: Normal vector of exit plane

c real*8 vnxex: x component of normal vector of exit plane
c real*8 vnyex: y component of normal vector of exit plane
c real*8 vnzex: z component of normal vector of exit plane

c real*8 ds : step size for tracking

c The tracking stops, when the electron hits the exit plane. The size of the last
c step is corrected such that the plane is hit.

c integer nthstep: If nstep > 0, the trajectory array traxyz is filled,
c                  see below
c integer ndim: Dimension of traxyz, see below

c real*8 phelow: Lowest photon energy / eV
c real*8 phehig: Higest photon energy / eV

c integer nphener: Number of equidistant photon energies

c integer ieneloss:  0: no energy loss due to synchotron radiation
c                    1: continous energy loss due to synchotron radiation
c integer ieneloss: -1: no energy loss due to synchotron radiation with quantum
c                       fluctuations

c integer ivelofield: Contral flag for the calculation of the velocity field:
c                    0: the spectrum includes the velocity field
c                    1: the specrum does not include the velocity field
c                    2: the spectrum includes only the velocity field

c Output:
c -------

c integer: istatus: Status flag:
c  0: no error found
c -1: initial gamma or velocity zero
c -2: dimension ndim of traxyz exceeded
c -3: bad value of ivelofield
c  else: status of uradfield_omp

c real*8 xexit: x of last point of the trajectory
c real*8 yexit: y of last point of the trajectory
c real*8 zexit: z of last point of the trajectory
c real*8 texit: t of last point of the trajectory

c real*8 vnxex: x component of norm. velocity vector of last point
c real*8 vnyex: y component of norm. velocity vector of last point
c real*8 vnzex: z component of norm. velocity vector of last point

c real*8 phener(nphener): Array of equidistant photon energies

c integer nstep: Number of tracking steps done, i.e. used length of traxyz

c real*8 traxyz(1:14,i): Array:
c        traxyz(1,i):  x
c        traxyz(2,i):  y
c        traxyz(3,i):  z
c        traxyz(4,i):  tracking time
c        traxyz(5,i):  x-comp. of norm. velocity vector
c        traxyz(6,i):  y-comp. of norm. velocity vector
c        traxyz(7,i):  z-comp. of norm. velocity vector
c        traxyz(8,i):  x-comp. of mag. field in the center of the step
c        traxyz(9,i):  y-comp. of mag. field in the center of the step
c        traxyz(10,i): z-comp. of mag. field in the center of the step
c        traxyz(11,i): gamma
c        traxyz(12,i): x-comp. of elec. field in the center of the step
c        traxyz(13,i): y-comp. of elec. field in the center of the step
c        traxyz(14,i): z-comp. of elec. field in the center of the step

c real* phase0
c The phase is calculated by phase=phase0+n*dt*dphase,
c where dphase is the phase difference of the nth step dt. Phase0=
c (xobsv-xelec)/clight. The phase factor of the integrand is
c exp(i*omega*phase),where omega referes to the considered photon energy.
c complex*16 aradex(i): x-comp. of amplitude of radiation e-field of phener(i)
c complex*16 aradey(i): y-comp. of amplitude of radiation e-field of phener(i)
c complex*16 aradez(i): z-comp. of amplitude of radiation e-field of phener(i)
c complex*16 aradbx(i): x-comp. of amplitude of radiation b-field of phener(i)
c complex*16 aradby(i): y-comp. of amplitude of radiation b-field of phener(i)
c complex*16 aradbz(i): z-comp. of amplitude of radiation b-field of phener(i)

c real*8 array of Stokes parameters of ith photon energy:
c        stokes(1,i): S0, i.e. total intensity
c        stokes(2,i): S1, Stokes parameter of linear +/- 90 degree polarisation
c        stokes(3,i): S2, Stokes parameter of linear +/- 45 degree polarisation
c        stokes(4,i): S3, Stokes parameter of circular polarisation
c        S0 = sqrt(S1**2+S2**2+S3**2)

c Compilation:
c ------------

c For uradbmap at least F90 is required.
c The line length exceeds 72 characters, please use an appropriate
c compiler option. It is recommended to use compiler options to initialize all
c variables to zero and to treat them as saved''

      implicit none

      complex*16
     &  aradex(nphener),aradey(nphener),aradez(nphener),
     &  aradbx(nphener),aradby(nphener),aradbz(nphener),
     &  ziom,zi,zidom,zone,ziomr1,zicr1,zic,
     &  expom1,expom,dexpomph1,dexpomph,ddexpomph,dexpom,
     &  expomv2,vstokes(4,3),
     &  apolh,apolr,apoll,apol45,dum3,ampex,ampey,ampez,ampbx,ampby,ampbz

      double precision
     &  gammai,dgamtot,dt2,powden,t,phase,phase0,
     &  xelec,yelec,zelec,vxelec,vyelec,vzelec,
     &  xexit,yexit,zexit,vnxex,vnyex,vnzex,texit,
     &  xobsv,yobsv,zobsv,phelow,phehig,
     &  phener(nphener),dom2,c,rspn
     &  ,traxyz(14,ndim),stokes(4,nphener),x1,y1,z1,vx1,vy1,
     &  vz1,x2,y2,z2,vx2,vy2,vz2
     &  ,ds,dtim,bshift,x2b,y2b,z2b,bx1,by1,bz1,bx2,by2,bz2
     &  ,dgamsum,gamma,dt
     &  ,vxp,vyp,vzp
     &  ,efx,efy,efz,xf,yf,zf,dist2
     &  ,dtim0,beta,vn,efx2,efy2,efz2,t1,t2,clight,c1,
     &  dgamma,vxsign,bx,by,bz,bpx,bpy,bpz,rarg(5),px,py,pz,
     &  dphase,r,rx,ry,rz
     &  ,dom1,rnbx,rnby,rnbz,dum11,rnr4,br4,b3,rnr2,br2,bet1n,
     &  rnx,rny,rnz,r1,banwid,specnor,pownor,current,
     &  stok1,stok2,stok3,stok4,om,dom,hbarev,echarge,eps0,pi,vsto,dph,
     &  r0,efxn,efyn,efzn

      integer ieneloss,istatus,icharge,nphener,ivelofield,
     &  nthstep,izaehl,nstep,ndim,kstep,lstep,kfreq,isto,ifail,ith,
     &  modewave

      integer :: idebug=0

c      integer,save :: ical=0
+seq,uservar.

      data bshift/0.5d0/
      data clight/2.99792458d8/
      data hbarev/6.58211889D-16/
      data eps0/8.854187817D-12/
      data echarge/1.602176462D-19/
      data pi/3.14159265358979d0/

      data zi/(0.0d0,1.0d0)/
      data zone/(1.0d0,0.0d0)/

      dph=0.0d0
      ith=ith
c      ical=ical+1

      if (nphener.gt.0) phener(1)=phelow
      if (nphener.gt.1) dph=(phehig-phelow)/(nphener-1)

      do kfreq=2,nphener
        phener(kfreq)=phener(kfreq-1)+dph
      enddo

      istatus=0
      ifail=0
      if (icharge.le.0) icharge=-1
      if (icharge.gt.0) icharge=1

      vn=norm2([efxn,efyn,efzn])
      efx=efxn/vn
      efy=efyn/vn
      efz=efzn/vn

      x1=xelec
      y1=yelec
      z1=zelec
      vx1=vxelec
      vy1=vyelec
      vz1=vzelec
      t1=0.0d0

      gamma=gammai
      beta=dsqrt((1.d0-1.d0/gamma)*(1.d0+1.d0/gamma))
      vn=sqrt(vx1*vx1+vy1*vy1+vz1*vz1)
      vx1=vx1/vn*clight*beta
      vy1=vy1/vn*clight*beta
      vz1=vz1/vn*clight*beta
      vn=beta*clight

c vxsign takes care for the direction of flight, since particle must gain
c energy if tracked back

      if (vx1.lt.0) then
        vxsign=-1.0d0
      else
        vxsign=1.0d0
      endif

      dgamsum=0.0d0
      dgamtot=0.0d0
      powden=0.0d0

      aradex=(0.0d0,0.0d0)
      aradey=(0.0d0,0.0d0)
      aradez=(0.0d0,0.0d0)

      aradbx=(0.0d0,0.0d0)
      aradby=(0.0d0,0.0d0)
      aradbz=(0.0d0,0.0d0)

      dtim=ds/vn
      dt=dtim
      dt2=dtim*bshift
      dtim0=dtim

      x2=x1
      y2=y1
      z2=z1
      t2=t1

      vx2=vx1
      vy2=vy1
      vz2=vz1

      x2b=x1+vx1*dt2
      y2b=y1+vy1*dt2
      z2b=z1+vz1*dt2

      call uradfield_omp(x2b,y2b,z2b,bx2,by2,bz2,efx2,efy2,efz2,gamma,istatus,
     &  modewave)
      if (istatus.ne.0) ifail=ifail+abs(istatus)
      istatus=0

      nstep=0
      vn=sqrt(vx2*vx2+vy2*vy2+vz2*vz2)

      if (gamma.le.0.0d0.or.vn.le.0.0d0) then
        istatus=-1
        return
      endif

      kstep=-1
      nstep=0

      if(nthstep.gt.0) then

        nstep=nstep+1
        if (nstep.gt.ndim) then
          nstep=nstep-1
          istatus=-2
          goto 9000
        endif

        kstep=kstep+1
        if (kstep.eq.nthstep) kstep=0

        traxyz(1,nstep)=x2
        traxyz(2,nstep)=y2
        traxyz(3,nstep)=z2
        traxyz(4,nstep)=t2
        traxyz(5,nstep)=vx2/vn
        traxyz(6,nstep)=vy2/vn
        traxyz(7,nstep)=vz2/vn
        traxyz(8,nstep)=bx2
        traxyz(9,nstep)=by2
        traxyz(10,nstep)=bz2
        traxyz(11,nstep)=gamma
        traxyz(12,nstep)=efx2
        traxyz(13,nstep)=efy2
        traxyz(14,nstep)=efz2

      endif !nthstep.gt.0

      dom=0.0d0
      om=0.0d0
      if (nphener.gt.1) then
        om=phener(1)/hbarev
        dom=(phener(2)-phener(1))/hbarev
      else if (nphener.eq.1) then
        om=phener(1)/hbarev
      endif

      c=clight
      c1=1.0d0/clight

      zidom=zi*dom
      ziom=zi*om
      zic=zi*c

      lstep=0
      t=-dt
      r0=xobsv-xelec
      r=sqrt((xobsv-x1)**2+((yobsv-y1)**2+(zobsv-z1)**2))
c      PHASE=(r-r0)*c1
      phase=phase0
      expom1=zone
      dexpomph1=zone

c--- Loop der Trajektorie

      izaehl=0
1000  continue
      !all util_break
      izaehl=izaehl+1
c      print*,ith,izaehl,x2
      if (x2.ne.x2) then
        istatus=-99
        return
      endif

      if (lstep.eq.1) then
        dtim=abs(dist2)/vn
        dt=dtim
        dt2=dtim/2.0d0
      endif

      x1=x2
      y1=y2
      z1=z2

      t1=t2

      vx1=vx2
      vy1=vy2
      vz1=vz2

      bx1=bx2
      by1=by2
      bz1=bz2

      x2b=x1+vx1*dt2
      y2b=y1+vy1*dt2
      z2b=z1+vz1*dt2

      call uradfield_omp(x2b,y2b,z2b,bx2,by2,bz2,efx2,efy2,efz2,gamma,istatus,
     &  modewave)
      if (istatus.ne.0) ifail=ifail+abs(istatus)
      istatus=0

      call uradstep_omp(x1,y1,z1,vx1,vy1,vz1,bx2,by2,bz2,efx2,efy2,efz2,
     &  dtim,x2,y2,z2,vx2,vy2,vz2,vxp,vyp,vzp,gamma,icharge,ieneloss,
     &  dgamma)

      t2=t1+dtim

      if (ieneloss.ne.0) then
        dgamsum=dgamsum+vxsign*dgamma
        if (abs(dgamsum).gt.gamma*1.0d-8) then
          gamma=gamma+dgamsum
          dgamtot=dgamtot+dgamsum
          dgamsum=0.0d0
        endif
        beta=dsqrt((1.0d0-1.0d0/gamma)*(1.0d0+1.0d0/gamma))
        vn=sqrt(vx2*vx2+vy2*vy2+vz2*vz2)
        vx2=vx2/vn*clight*beta
        vy2=vy2/vn*clight*beta
        vz2=vz2/vn*clight*beta
      endif

      BX=VX2*C1
      BY=VY2*C1
      BZ=VZ2*C1

      BPX=VXP*C1
      BPY=VYP*C1
      BPZ=VZP*C1

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION {

C REAL PART OF INTEGRAND {

      RX=XOBSV-X2
      RY=YOBSV-Y2
      RZ=ZOBSV-Z2

      R=SQRT(RX*RX+RY*RY+RZ*RZ)
      R1=1.0D0/R
      ZICR1=ZIC*R1

      RNX=RX*R1
      RNY=RY*R1
      RNZ=RZ*R1

C--- THE DISTANCE R IS INTRODUCED HERE EXPLICITLY (S. PROGRAM OF CHAOEN WANG

      BET1N=(1.0D0-BX*RNX)-BY*RNY-BZ*RNZ

      br2=by**2+bz**2
      rnr2=rny**2+rnz**2
      b3=beta**3
      br4=br2**2
      rnr4=rnr2**2

      if(br2.lt.1.0d-4.and.rnr2.lt.1.0d-4) then
        bet1n=
     &    1.0d0/(1.0d0+beta)/gamma**2
     &    +beta*(rnr2/2.0d0
     &    +rnr4/8.0d0)
     &    +(br2/2.0d0
     &    -br2*rnr2/4.0d0
     &    -br2*rnr4/16.0d0)/beta
     &    +b3*br4*(1.0d0/8.0d0
     &    -rnr2/16.0d0
     &    -rnr4/64.0d0)
     &    -by*rny
     &    -bz*rnz
      endif

      DUM11=1.0D0/BET1N
      DOM1=1.0D0/(R*BET1N*BET1N)

      RNBX=RNX-BX
      RNBY=RNY-BY
      RNBZ=RNZ-BZ

      PX=(RNBY*BPZ-RNBZ*BPY)
      PY=(RNBZ*BPX-RNBX*BPZ)
      PZ=(RNBX*BPY-RNBY*BPX)

      IF (IVELOFIELD.EQ.0.OR.IVELOFIELD.EQ.2) THEN !2 WEGEN POWER
        DOM2=C*DOM1*R1/GAMMA**2
        RARG(1)=(RNY*PZ-RNZ*PY)*DOM1+(RNX-BX)*DOM2
        RARG(2)=(RNZ*PX-RNX*PZ)*DOM1+(RNY-BY)*DOM2
        RARG(3)=(RNX*PY-RNY*PX)*DOM1+(RNZ-BZ)*DOM2
      ELSE IF (IVELOFIELD.EQ.1) THEN
        RARG(1)=(RNY*PZ-RNZ*PY)*DOM1
        RARG(2)=(RNZ*PX-RNX*PZ)*DOM1
        RARG(3)=(RNX*PY-RNY*PX)*DOM1
      ELSE IF (IVELOFIELD.LT.0) THEN
        DOM2=C*DOM1*R1/GAMMA**2
        RARG(1)=(RNX-BX)*DOM2
        RARG(2)=(RNY-BY)*DOM2
        RARG(3)=(RNZ-BZ)*DOM2
      ELSE  !IVELOFIELD
        istatus=-3
        return
      ENDIF !IVELOFIELD

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS      RARG(4)=T+R*C1

      DPHASE=BET1N*DT

      RARG(5)=(RARG(1)*RARG(1)+RARG(2)*RARG(2)+RARG(3)*RARG(3))*DUM11

      powden=powden+rarg(5)*dt

C REAL PART OF INTEGRAND }

C COMPLEX PART OF INTEGRAND {

C    ASSUMES phener(I+1)=2*phener(I)   FOR kfreq2P=2
C    OR phener(I+1)=phener(I)+DELTA    FOR kfreq2P>2

C--- LOOP OVER ALL FREQUENCES

      if (nphener.gt.0) then

        kfreq=1

        OM=phener(kfreq)/hbarev
        ZIOM=ZI*OM

        if (izaehl.eq.1) then
          EXPOM1=CDEXP(DCMPLX(0.D0,phase*OM))
        endif

        EXPOM=EXPOM1
        DEXPOMPH1=EXP(ZIOM*DPHASE)
        DEXPOMPH=DEXPOMPH1

        IF(nphener.GT.1) THEN
          DEXPOM=EXP(ZIDOM*PHASE)
          DDEXPOMPH=EXP(ZIDOM*DPHASE)
        ENDIF  !kfreq2P

        IF (IVELOFIELD.NE.2) THEN

          dum3=expom*(zone-dexpomph)/om/bet1n

          ampex=rarg(1)*dum3
          ampey=rarg(2)*dum3
          ampez=rarg(3)*dum3

c          if (idebug.ne.0.and.yobsv.eq.0.0d0.and.zobsv.eq.0.0d0) then
c            write(77,*)izaehl,kfreq,x2,t2,rarg,dreal(ampez),dimag(ampez)
c          endif

          aradex(kfreq)=aradex(kfreq)+ampex
          aradey(kfreq)=aradey(kfreq)+ampey
          aradez(kfreq)=aradez(kfreq)+ampez

c          ampbx=conjg(rny*ampez-rnz*ampey)/clight
c          ampby=conjg(rnz*ampex-rnx*ampez)/clight
c          ampbz=conjg(rnx*ampey-rny*ampex)/clight
          ampbx=(rny*ampez-rnz*ampey)/clight
          ampby=(rnz*ampex-rnx*ampez)/clight
          ampbz=(rnx*ampey-rny*ampex)/clight

          aradbx(kfreq)=aradbx(kfreq)+ampbx
          aradby(kfreq)=aradby(kfreq)+ampby
          aradbz(kfreq)=aradbz(kfreq)+ampbz

        ELSE !IVELOFIELD

          EXPOMV2=R1/BET1N*EXPOM*(ZONE-DEXPOMPH)
          ZIOMR1=ZONE+ZICR1/OM

          ampex=EXPOMV2*(BX-RNX*ZIOMR1)
          ampey=EXPOMV2*(BX-RNX*ZIOMR1)
          ampez=EXPOMV2*(BX-RNX*ZIOMR1)

          aradex(kfreq)=aradex(kfreq)+ampex
          aradey(kfreq)=aradey(kfreq)+ampey
          aradez(kfreq)=aradez(kfreq)+ampez

c          ampbx=conjg(rny*ampez-rnz*ampey)/clight
c          ampby=conjg(rnz*ampex-rnx*ampez)/clight
c          ampbz=conjg(rnx*ampey-rny*ampex)/clight

          ampbx=(rny*ampez-rnz*ampey)/clight
          ampby=(rnz*ampex-rnx*ampez)/clight
          ampbz=(rnx*ampey-rny*ampex)/clight

          aradbx(kfreq)=aradbx(kfreq)+ampbx
          aradby(kfreq)=aradby(kfreq)+ampby
          aradbz(kfreq)=aradbz(kfreq)+ampbz

        ENDIF !IVELOFIELD

        IF (IVELOFIELD.NE.2) THEN

          DO kfreq=2,nphener

            OM=OM+DOM
            EXPOM=EXPOM*DEXPOM
            DEXPOMPH=DEXPOMPH*DDEXPOMPH

            EXPOMV2=1.0D0/BET1N/OM*EXPOM*(ZONE-DEXPOMPH)

            ampex=RARG(1)*EXPOMV2
            ampey=RARG(2)*EXPOMV2
            ampez=RARG(3)*EXPOMV2

            aradex(kfreq)=aradex(kfreq)+ampex
            aradey(kfreq)=aradey(kfreq)+ampey
            aradez(kfreq)=aradez(kfreq)+ampez

c            ampbx=conjg(rny*ampez-rnz*ampey)/clight
c            ampby=conjg(rnz*ampex-rnx*ampez)/clight
c            ampbz=conjg(rnx*ampey-rny*ampex)/clight

            ampbx=(rny*ampez-rnz*ampey)/clight
            ampby=(rnz*ampex-rnx*ampez)/clight
            ampbz=(rnx*ampey-rny*ampex)/clight

            aradbx(kfreq)=aradbx(kfreq)+ampbx
            aradby(kfreq)=aradby(kfreq)+ampby
            aradbz(kfreq)=aradbz(kfreq)+ampbz

c            if (kfreq.eq.nphener/2) then
c              if (user(1).eq.0) then
c                write(56,*)ical,izaehl,x2,dphase,phase,real(aradez(kfreq)),real(RARG(3)*EXPOMV2)
c              else
c                write(57,*)ical,izaehl,x2,dphase,phase,real(aradez(kfreq)),real(RARG(3)*EXPOMV2)
c              endif
c            endif

          ENDDO   !LOOP OVER ALL FREQUENCES

        else

          DO kfreq=2,nphener

            OM=OM+DOM
            EXPOM=EXPOM*DEXPOM
            DEXPOMPH=DEXPOMPH*DDEXPOMPH

            EXPOMV2=R1/BET1N*EXPOM*(ZONE-DEXPOMPH)
            ZIOMR1=ZONE+ZICR1/OM

            ampex=EXPOMV2*(BX-RNX*ZIOMR1)
            ampey=EXPOMV2*(BX-RNX*ZIOMR1)
            ampez=EXPOMV2*(BX-RNX*ZIOMR1)

            aradex(kfreq)=aradex(kfreq)+ampex
            aradey(kfreq)=aradey(kfreq)+ampey
            aradez(kfreq)=aradez(kfreq)+ampez

c            ampbx=conjg(rny*ampez-rnz*ampey)/clight
c            ampby=conjg(rnz*ampex-rnx*ampez)/clight
c            ampbz=conjg(rnx*ampey-rny*ampex)/clight

            ampbx=(rny*ampez-rnz*ampey)/clight
            ampby=(rnz*ampex-rnx*ampez)/clight
            ampbz=(rnx*ampey-rny*ampex)/clight

            aradbx(kfreq)=aradbx(kfreq)+ampbx
            aradby(kfreq)=aradby(kfreq)+ampby
            aradbz(kfreq)=aradbz(kfreq)+ampbz

          ENDDO   !LOOP OVER ALL FREQUENCES

        ENDIF !IVELOFIELD


C COMPLEX PART OF INTEGRAND }

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION }

        PHASE=PHASE+DPHASE
        EXPOM1=EXPOM1*DEXPOMPH1

      endif !(nphener.gt.0) then

c ef is normal vector of perpendiculare plane at the end of the reference orbit
c dist is distance of electron to this plane
c tracking stops if trajectory hits this plane

      dist2=(x2-xf)*efx+(y2-yf)*efy+(z2-zf)*efz

      if (lstep.eq.0.and.dist2.lt.0.0d0.and.dist2.gt.-2.0d0*ds)  then

        lstep=1
        goto 1000

      else

        kstep=kstep+1
        if (kstep.eq.nthstep) kstep=0

        if(kstep.eq.0) then

          nstep=nstep+1

          if (nstep.gt.ndim) then
            nstep=nstep-1
            istatus=-2
            goto 9000
          endif

          traxyz(1,nstep)=x2
          traxyz(2,nstep)=y2
          traxyz(3,nstep)=z2
          traxyz(4,nstep)=t2
          traxyz(5,nstep)=vx2/vn
          traxyz(6,nstep)=vy2/vn
          traxyz(7,nstep)=vz2/vn
          traxyz(8,nstep)=bx2
          traxyz(9,nstep)=by2
          traxyz(10,nstep)=bz2
          traxyz(11,nstep)=gamma
          traxyz(12,nstep)=efx2
          traxyz(13,nstep)=efy2
          traxyz(14,nstep)=efz2

        endif

        if (lstep.eq.1) goto 9000
        goto 1000

      endif !lstep and dist2

9000  continue

      xexit=x2
      yexit=y2
      zexit=z2

      vn=sqrt(vx2*vx2+vy2*vy2+vz2*vz2)
      vnxex=vx2/vn
      vnyex=vy2/vn
      vnzex=vz2/vn

      texit=t2

      specnor=
     &  banwid
     & /(4.0d0*pi**2*clight*hbarev)
     & /(4.0d0*pi*eps0)
     &  *current/1.0d6 !per mm**2

      pownor=echarge/16.0d0/pi/pi/eps0/clight*current/1.0d6 !W/mm**2

      rspn=sqrt(specnor)

      vstokes(1,1)=( 0.0d0,        0.0d0)      !horizontal polarization
      vstokes(1,2)=( 0.0d0,        0.0d0)
      vstokes(1,3)=(-1.0d0,       -1.0d0)

      vstokes(2,1)=( 0.0d0,        0.0d0)      !right handed polarization
      vstokes(2,2)=( 0.0d0,       -1.0d0)
      vstokes(2,3)=(+1.0d0,        0.0d0)

      vstokes(3,1)=( 0.0d0,        0.0d0)      !left handed polarization
      vstokes(3,2)=( 0.0d0,       -1.0d0)
      vstokes(3,3)=(-1.0d0,        0.0d0)

      vstokes(4,1)=( 0.0d0,        0.0d0)      !45 degree linear polarization
      vstokes(4,2)=( 1.0d0,        0.0d0)
      vstokes(4,3)=(-1.0d0,        0.0d0)

      do isto=1,4
        vsto=dsqrt
     &    (cdabs(vstokes(isto,1))**2
     &    +cdabs(vstokes(isto,2))**2
     &    +cdabs(vstokes(isto,3))**2)
        vstokes(isto,1)=vstokes(isto,1)/vsto
        vstokes(isto,2)=vstokes(isto,2)/vsto
        vstokes(isto,3)=vstokes(isto,3)/vsto

      enddo

      do kfreq=1,nphener

        aradex(kfreq)=aradex(kfreq)*rspn
        aradey(kfreq)=aradey(kfreq)*rspn
        aradez(kfreq)=aradez(kfreq)*rspn

        apolh=
     &    aradex(kfreq)*conjg(vstokes(1,1))
     &    +aradey(kfreq)*conjg(vstokes(1,2))
     &    +aradez(kfreq)*conjg(vstokes(1,3))

        apolr=
     &    aradex(kfreq)*conjg(vstokes(2,1))
     &    +aradey(kfreq)*conjg(vstokes(2,2))
     &    +aradez(kfreq)*conjg(vstokes(2,3))

        apoll=
     &    aradex(kfreq)*conjg(vstokes(3,1))
     &    +aradey(kfreq)*conjg(vstokes(3,2))
     &    +aradez(kfreq)*conjg(vstokes(3,3))

        apol45=
     &    aradex(kfreq)*conjg(vstokes(4,1))
     &    +aradey(kfreq)*conjg(vstokes(4,2))
     &    +aradez(kfreq)*conjg(vstokes(4,3))

        stok1=real(
     &    apolr*conjg(apolr)+
     &    apoll*conjg(apoll))

        stok2=-stok1+
     &    real(2.*apolh*conjg(apolh))

        stok3=
     &    real(2.*apol45*conjg(apol45))-
     &    stok1

        stok4=real(
     &    apolr*conjg(apolr)-
     &    apoll*conjg(apoll))

        stokes(1,kfreq)=stok1
        stokes(2,kfreq)=stok2
        stokes(3,kfreq)=stok3
        stokes(4,kfreq)=stok4

      enddo !nphener

      powden=powden*pownor

      if (istatus.ge.0.and.ifail.ne.0) istatus=ifail

      return
      end
+DECK,urad_nnb.
*CMZ :  4.01/04 28/12/2023  10.37.34  by  Michael Scheer
*CMZ :  4.01/02 14/05/2023  11.47.49  by  Michael Scheer
*CMZ :  4.01/00 22/02/2023  14.34.04  by  Michael Scheer
*CMZ :  4.00/17 05/12/2022  10.30.41  by  Michael Scheer
*CMZ :  4.00/16 17/09/2022  15.46.32  by  Michael Scheer
*CMZ :  4.00/15 02/06/2022  09.45.10  by  Michael Scheer
*CMZ :  4.00/11 28/06/2021  10.33.06  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine urad_nnb(modewave)

      use omp_lib
      use uradphasemod

      implicit none

+seq,phyconparam.
+seq,track.

      complex*16 cde
      double precision :: h2,ddist,wlen,dphi,phase0

      double complex , dimension (:,:), allocatable :: aradbuff
      double complex , dimension (:,:,:), allocatable :: arad

      double precision, dimension (:), allocatable :: frq
      double precision, dimension (:,:), allocatable :: wsstokes,pow
      double precision, dimension (:,:,:), allocatable :: fbunch,stokes

      real, dimension (:), allocatable :: pherr,pherrc,phiran
      real, dimension(:,:), allocatable :: pranall,eall

      real eran(6),pran(2),rr(2)

      double complex :: apol,amp0(6),damp(6),amp(6),zexp,
     &  apolh,apolr,apoll,apol45,stokesv(4,3)

      double precision :: t,udgamtot,upow,vf0,vn,vx0,vx2,vxf0,vxi,vy0,vy2,vyf0,
     &  vyi,vz0,vz2,vzf0,vzi,wlen1,x0,x2,xf0,xi,xlell,y0,y2,yf0,yi,ypi,yy,yyp,
     &  z0,z2,zf0,zi,zpi,zz,zzp,fillb(41),stok1,stok2,stok3,stok4,speknor,
     &  sqnbunch,sqnphsp,specnor,sbnor,rpin,r00(3),
     &  r(3),r0(3),pw,ph,phsum,pkerr,pherror,ppin,parke,pc(3),pcbrill(3),om1,
     &  park,pr,hbarev,obs(3),om,fhigh,flow,gamma,eix,eiy,eiz,emassg,
     &  efx,efy,efz,eharm1,ecdipev,ebeam,dtpho,dt,dtelec,dd0,debeam,
     &  drn0(3),drn00(3),ds,dr0(3),dr00(3),drn(3),dpp,dph,dist,dist0,dobs(3),
     &  bunnor,clight,bunchx,beta,beff,spow,
     &  zp0,yp0,rph,
     &  xkellip,zampell,yampell,parkv,parkh,zpampell,ypampell,emom

      double complex, dimension (:), allocatable ::
     &  uampex,uampey,uampez,uampbx,uampby,uampbz
      double precision, dimension (:,:), allocatable :: utraxyz,ustokes

      integer :: kfreq,iobsv,i,np2,nelec,mbunch,meinbunch,ibu,jbun,
     &  kran=6,icbrill,ilo,kobsv,i1,i2,n,
     &  ifail,ndimu,nstepu,ith,noespread,noemit,jbunch,jubunch,jhbunch,
     &  jcharge=-1,lmodeph,nclo,jeneloss=0,iamppin,
     &  iamppincirc=0,ifrob,iobfr,isub,jvelofield=0,nlbu=0,nepho,ielo,
     &  modewave,nper

      integer, dimension (:), allocatable :: lnbunch

      integer :: idebug=0, lbunch=0, ierr=0, ielec=0
      integer ibunch,ihbunch,mthreads,nobsv,iemit,noranone,iz,iy,nobsvz,nobsvy
      integer iobm,iobp,iobfrm,iobfrp

      nper=nper_u
      nper_u=1

      nelec_u=max(1,nelec_u)
      mthreads_u=max(1,mthreads_u)
      nelec=nelec_u

      nobsvy=npiny_u
      nobsvz=npinz_u

      if (nelec_u.gt.1) then
        if (nelec_u.lt.mthreads_u.and.nelec_u.gt.1) then
          mthreads_u=nelec_u
        else
          nelec_u=max(mthreads_u,nelec_u/mthreads_u*mthreads_u)
        endif
      endif

      noranone=noranone_u

      if (nelec_u.ne.nelec) then
        print*,''
        print*,'--- Warning in urad_nnb: Nelec adjusted to multiple of number of threads:',nelec_u
        print*,''
      endif

      if (nelec_u.eq.1) then
        ibunch=0
      else
        ibunch=1
      endif

      ihbunch=ihbunch_u
      mthreads=mthreads_u

      if (modepin_u.eq.1) then
        iamppin=3
        nobsv=1
      else
        iamppin=1
        nobsv=npiny_u*npinz_u
      endif

      icbrill=nobsv/2+1

      jhbunch=max(0,ihbunch)
      meinbunch=nelec_u

      lbunch=0

      if (jhbunch.ne.0) then
        jhbunch=max(1,jhbunch)
      endif

      nepho=nepho_u

      nlbu=0
      if (ihbunch.gt.0) then
        lbunch=nelec_u/ihbunch
        nlbu=lbunch*nepho_u
        allocate(fbunch(41,nlbu,mthreads_u),stat=ierr)
        if (ierr.ne.0) then
          lbunch=0
          print*,""
          print*,"*** Warning in urad_nnb: Could not allocate buffer for beam Ntuple ***"
          print*,"*** Maybe increase IHBUNCH ***"
          print*,""
          nper_u=nper
          return
        endif
        fbunch=0.0d0
        allocate(lnbunch(mthreads_u), stat=ierr)
        if (ierr.ne.0) then
          print*,""
          print*,"*** Warning in urad_nnb: Could not allocate buffer for nlbunch ***"
          print*,""
          nper_u=nper
          return
        endif
        lnbunch=0
      endif

      call urad_field_ini(perlen_u,shift_u,beffv_u,beffh_u,modewave)

      if (perlen_u.ne.0.0d0) then
        emom=emasse1*dsqrt((gamma_u-1.0d0)*(gamma_u+1.0d0))
c*** OBSOLITE, SEE z0= further down
        xkellip=twopi1/perlen_u
        zampell=beffv_u*clight1/emom/xkellip**2
        yampell=beffh_u*clight1/emom/xkellip**2
        parkh=echarge1*dabs(beffh_u)*perlen_u/(twopi1*emasskg1*clight1)
        parkv=echarge1*dabs(beffv_u)*perlen_u/(twopi1*emasskg1*clight1)
        zpampell=parkv/gamma_u
      else
        print*,''
        print*,'*** Error in urad_nnb: Zero period-length of undulator ***'
        print*,''
        stop
      endif

      if (modewave.eq.3) then
        call urad_spline(parkv,perlen_u,nper,gamma_u)
      endif

      dr00=[1.0d0,0.0d0,0.0d0]
      drn00=dr00/norm2(dr00)
      dr00=drn00*perlen_u
      r00=[0.0d0,0.0d0,0.0d0]

      x0=-perlen_u/2.0d0*dble(nper)

      y0=0.0d0
      z0=0.0d0

      beta=dsqrt((1.0d0-1.0d0/gamma_u)*(1.0d0+1.0d0/gamma_u))

      clight=clight1
      hbarev=hbarev1
      ecdipev=ecdipev1
      emassg=emassg1

      if (modewave.eq.0) then
        z0=-zampell*cos(shift_u/2.0d0/perlen_u*twopi1)
        zp0=zpampell*sin(shift_u/2.0d0/perlen_u*twopi1)
        y0=-yampell*cos(shift_u/2.0d0/perlen_u*twopi1)
        yp0=-ypampell*sin(shift_u/2.0d0/perlen_u*twopi1)
      else
        y0=ytrack
        z0=ztrack
        zp0=vztrack/vxtrack
        yp0=vytrack/vxtrack
      endif

      xf0=-x0
      yf0=y0
      zf0=z0

      vn=clight*beta

      vx0=vn/sqrt(1.0d0+(zp0**2+yp0**2))
      vy0=vn*yp0
      vz0=vn*zp0

      vxf0=vx0
      vyf0=vy0
      vzf0=vz0

      vxi=vx0
      vyi=vy0
      vzi=vz0

      r0=r00
      dr0=dr00
      drn0=drn00
      r=r0
      drn=drn0

      vf0=norm2([vxf0,vyf0,vzf0])
      efx=vxf0/vf0
      efy=vyf0/vf0
      efz=vzf0/vf0

      nclo=nint(perlen_u/step_u)+1

      ds=step_u

      ndimu=nint(nclo*1.1)

      r0=[x0,y0,z0]
      dr0=[xf0-x0,yf0-y0,zf0-z0]
      dr0=[efx,efy,efz]*perlen_u
      r0=r0+dr0/2.0d0

      allocate(frq(nepho_u),
     &  uampex(nepho_u),uampey(nepho_u),uampez(nepho_u),
     &  uampbx(nepho_u),uampby(nepho_u),uampbz(nepho_u),pow(nobsv,mthreads),
     &  utraxyz(14,ndimu),ustokes(4,nepho_u))

      pow=0.0d0
      frq=epho_u

      flow=frq(1)
      fhigh=frq(nepho_u)

      beff=sqrt(beffv_u**2+beffh_u**2)
      park=echarge1*beff*perlen_u/(2.*pi1*emasskg1*clight)
      wlen1=(1+park**2/2.)/2./gamma_u**2*perlen_u*1.0d9

      if (wlen1.ne.0.0) then
        eharm1=wtoe1/wlen1
      else
        eharm1=0.0d0
      endif

      dtpho=perlen_u/clight

      allocate(pherrc(nper_u),pherr(nper_u),arad(6,nepho_u*nobsv,mthreads),
     &  phiran(max(1,nelec_u)))

      allocate(pranall(2,nelec_u))
      do i=1,nelec_u
        call util_random(2,pran)
        pranall(:,i)=pran
      enddo

      if (ibunch.eq.0.or.
     &    emith_u.eq.0.0d0.and.emitv_u.eq.0.0d0.and.espread_u.eq.0.0d0) then
        iemit=0
      else
        iemit=1
      endif

      if (iemit.ne.0) then
        allocate(eall(6,nelec_u))
        do i=1,nelec_u
          xi=x0
          call util_get_electron(xbeta_u,betah_u,alphah_u,betav_u,alphav_u,
     &      emith_u,emitv_u,
     &      disph_u,dispph_u,dispv_u,disppv_u,
     &      espread_u,bunchlen_u,xi,yi,zi,ypi,zpi,dpp,modebunch_u)
          eall(1,i)=xi-x0
          eall(2,i)=yi
          eall(3,i)=zi
          eall(4,i)=ypi
          eall(5,i)=zpi
          eall(6,i)=dpp
        enddo
        if (noranone.ne.0) eall(:,1)=0.0
      endif

      allocate(wsstokes(4,nepho_u*nobsv),stokes(4,nepho_u*nobsv,mthreads))
      stokes=0.0d0
      arad=(0.0d0,0.0d0)

      np2=nper_u/2

      call util_random_gauss_omp(nper_u,pherr,rr)
      pherrc=pherr

      lmodeph=modeph_u

      if (pherror.ne.0.0d0.and.(lmodeph.lt.0.or.lmodeph.gt.2)) then
        write(6,*) ""
        write(6,*) "*** Error in urad_nnb: MODEPH must be 0,1, or 2 ***"
        write(6,*) "*** Program aborted ***"
      endif

      if (lmodeph.eq.0.and.eharm1.ne.0.0d0) then
        om1=eharm1/hbarev
        pherr=sngl(pherrc*pherror/360.0d0*twopi1/om1)
      else if (lmodeph.eq.1) then
        pherr=sngl(pherr*pherror)
      else if (lmodeph.eq.2) then
        pherr(nper_u)=0.0
        phsum=0.0d0
        do i=1,nper_u-1
          pherr(i)=pherr(i)+pherrc(i)
          pherr(i+1)=pherr(i+1)-pherrc(i)
          phsum=phsum+pherr(i)
        enddo
        phsum=phsum+pherr(nper_u)
      else
        pherr=0.0d0
      endif !(lmodeph.eq.0)

      mbunch=max(1,nelec_u)
      nelec=nelec_u

      if (ibunch.ne.0.and.bunchcharge_u.ne.0.0d0) then
        sqnbunch=mbunch
        sqnphsp=sqrt(bunchcharge_u/echarge1)
     &    *meinbunch
     &    /(bunchcharge_u/echarge1)
        bunnor=1.0d0/mbunch
      else
        sqnbunch=mbunch
        sqnphsp=sqrt(dble(nelec_u))
        bunnor=1.0d0/mbunch
      endif

      beff=sqrt(beffv_u**2+beffh_u**2)
      parke=echarge1*beff*perlen_u/(2.*pi1*emasskg1*clight)
      xlell=perlen_u

      ielec=0

      pow=0.0d0
      noemit=0
      noespread=0
      jbunch=ibunch
      jubunch=0
      ebeam=ebeam_u
      debeam=espread_u
      stokesv=vstokes
      specnor=
     &  banwid_u
     &  /(4.0d0*pi1**2*clight*hbarev)
     &  /(4.0d0*pi1*eps01)
     &  *curr_u
      sbnor=specnor*bunnor
      speknor=specnor
      jeneloss=0
      pw=pinw_u
      ph=pinh_u
      !pr=pinr
      pc=pincen_u
      do iobsv=1,nobsv
        if (abs(obsv_u(2,iobsv)).lt.1.0d-9) obsv_u(2,iobsv)=0.0d0
        if (abs(obsv_u(3,iobsv)).lt.1.0d-9) obsv_u(3,iobsv)=0.0d0
      enddo
      pcbrill=obsv_u(:,icbrill)

!$OMP PARALLEL NUM_THREADS(mthreads) DEFAULT(PRIVATE)
!$OMP& FIRSTPRIVATE(nepho,nobsvz,nobsvy,nobsv,nelec,frq,nper_u,np2,perlen_u,clight,hbarev,flow,fhigh,
!$OMP& x0,y0,z0,xf0,yf0,zf0,vx0,vy0,vz0,vxf0,vyf0,vzf0,gamma_u,sbnor,speknor,
!$OMP& efx,efy,efz,ds,ndimu,curr_u,xlell,parke,amp,amp0,
!$OMP& uampex,uampey,uampez,uampbx,uampby,uampbz,
!$OMP& lmodeph,zp0,yp0,modewave,
!$OMP& jbunch,jubunch,jhbunch,noespread,noemit,ebeam,
!$OMP& stokesv,icbrill,obsv_u,emassg,debeam,dispv_u,disppv_u,
!$OMP& betah_u,alphah_u,betav_u,alphav_u,emith_u,emitv_u,disph_u,dispph_u,
!$OMP& pran,pranall,eall,fillb,r0,dr0,iamppin,iamppincirc,pc,phase0,pr,banwid_u,
!$OMP& pw,ph,idebug,pcbrill,wsstokes,vn,bunchlen_u,modebunch_u,icohere_u)
!$OMP& SHARED(mthreads,stokes,pherr,lbunch,lnbunch,
!$OMP& fbunch,jcharge,jeneloss,jvelofield,iemit,noranone,arad,pow)

      jbun=1
      isub=0
      iobsv=0
      ielo=0

!$OMP DO

      do ilo=1,nelec*nobsv

        wsstokes=0.0d0
        !affe=(0.0D0,0.0D0)
        spow=0.0d0

        ith=OMP_GET_THREAD_NUM()+1

        iobsv=mod(ilo-1,nobsv)+1
        ibu=(ilo-1)/nobsv+1
        jbun=ibu

        iy=(iobsv-1)/nobsvz+1
        iz=mod(iobsv-1,nobsvz)+1

        !call til_break

        ielec=ibu

        xi=x0
        yi=y0
        zi=z0

        zpi=vz0/vx0
        ypi=vy0/vx0

        x2=xf0
        y2=yf0
        z2=zf0

        vx2=vxf0
        vy2=vyf0
        vz2=vzf0

        gamma=gamma_u

        dpp=0.0d0

        if (iemit.ne.0) then

          if (noranone.eq.0.or.ielec.ne.1) then

            bunchx=eall(1,ielec)

            xi=xi+bunchx
            yy=eall(2,ielec)
            zz=eall(3,ielec)

            yyp=eall(4,ielec)
            zzp=eall(5,ielec)

            dpp=eall(6,ielec)
            gamma=(1.0d0+dpp)*gamma_u

            ! assume beta(s)=beta0(s)+s**2/beta(0) and alpha0=-s/beta(0)
            ! and a drift transfer-matrix ((1,s),(1,0))

            zi=zz-x0*zzp !inverse transformation
            zpi=zzp

            yi=yy-x0*yyp
            ypi=yyp

            ! simple treatment of closed orbit, assume small angles

            zi=zi+z0
            zpi=zpi+zp0

            yi=yi+y0
            ypi=ypi+yp0

          else

            xi=x0
            yi=y0
            zi=z0
            ypi=yp0
            zpi=zp0

            bunchx=0.0d0

          endif

        else

          xi=x0
          yi=y0
          zi=z0
          ypi=yp0
          zpi=zp0

          bunchx=0.0d0

        endif !iemit

        t=bunchx/vn

        vn=clight*dsqrt((1.0d0-1.0d0/gamma)*(1.0d0+1.0d0/gamma))

        vxi=vn/sqrt(1.0d0+ypi**2+zpi**2)
        vyi=vxi*ypi
        vzi=vxi*zpi

        obs=obsv_u(1:3,iobsv)

        if (noranone.eq.0.or.ielec.ne.1.or.iobsv.ne.icbrill) then
          if (iamppin.eq.3) then
            !call util_random(2,pran)
            pran(:)=pranall(:,ielec)
            if (iamppincirc.eq.0) then
              obs(2)=pc(2)+(pran(1)-0.5)*pw
              obs(3)=pc(3)+(pran(2)-0.5)*ph
            else
              rpin=(pran(1)-0.5)*pr
              ppin=pran(2)*twopi1
              obs(2)=pc(2)+rpin*cos(ppin)
              obs(3)=pc(3)+rpin*sin(ppin)
            endif
          endif
        endif

        vn=norm2([vxi,vyi,vzi])
        eix=vxi/vn
        eiy=vyi/vn
        eiz=vzi/vn

        h2=((obs(2)-yi)**2+(obs(3)-zi)**2)/(obs(1)-xi)**2
        if (h2.lt.0.01) then
          rph=abs(obs(1)-xi)*(1.0d0+(((((-0.0205078125D0*h2+0.02734375D0)*h2
     &      -0.0390625D0)*h2+0.0625D0)*h2-0.125D0)*h2+0.5D0)*h2)
        else
          rph=sqrt((obs(1)-xi)**2+((obs(2)-yi)**2+(obs(3)-zi)**2))
        endif

        phase0=(rph-(obsv_u(1,icbrill)-xi))/clight

        call urad_e_b_nnb(
     &    jcharge,curr_u,
     &    gamma,udgamtot,
     &    xi,yi,zi,vxi,vyi,vzi,
     &    xf0,yf0,zf0,efx,efy,efz,
     &    x2,y2,z2,vx2,vy2,vz2,dtelec,ds,
     &      0,nstepu,ndimu,utraxyz,phase0,
     &    obs(1),obs(2),obs(3),flow,fhigh,
     &    nepho,frq,uampex,uampey,uampez,uampbx,uampby,uampbz,
     &    ustokes,upow,
     &    jeneloss,jvelofield,ifail,ith,banwid_u,modewave)

        r0=[xi,yi,zi]
        dr0=[x2-xi,y2-yi,z2-zi]
        r0=r0+dr0/2.0d0

        do kfreq=1,nepho

          iobfr=iobsv+nobsv*(kfreq-1)

          om=frq(kfreq)/hbarev

          if (modewave.eq.0) then
            amp0=[
     &        uampex(kfreq),uampey(kfreq),uampez(kfreq),
     &        uampbx(kfreq),uampby(kfreq),uampbz(kfreq)
     &        ]*1.0d3/sqrt(speknor/curr_u*0.10d0) !urad
          else
            amp0=[
     &        uampex(kfreq),uampey(kfreq),uampez(kfreq),
     &        uampbx(kfreq),uampby(kfreq),uampbz(kfreq)
     &        ]*1.0d3/sqrt(speknor) !urad
          endif
          ! global phase


          amp=(0.0d0,0.0d0)

          do i=1,nper_u

            r=r0+(i-np2-1)*dr0
            dobs=obs-r
            dist0=norm2(obs-r0)
            dist=norm2(dobs)

            if (kfreq.eq.1) then
              spow=spow+upow*(dist0/dist)**2
              pow(iobsv,ith)=pow(iobsv,ith)+upow*(dist0/dist)**2
            endif

            if (lmodeph.eq.0) then
              h2=
     &          ((ypi-yp0-dobs(2))/dobs(1))**2 +
     &          ((zpi-zp0-dobs(3))/dobs(1))**2

              dph=om*(t+pherr(i))

              dt=xlell/clight*
     &          (
     &          (1.0d0+parke**2/2.0d0)/2.0d0/gamma**2+
     &          (((((-0.0205078125D0*h2+0.02734375D0)*h2
     &          -0.0390625D0)*h2+0.0625D0)*h2-0.125D0)*h2+0.5D0)*h2
     &          )

              t=t+dt
            else if (lmodeph.eq.1.or.lmodeph.eq.2) then
              dph=om*t
              pkerr=parke*(1.0d0+pherr(i))
              h2=((ypi-yp0-dobs(2))**2+(zpi-zp0-dobs(3))**2)/dobs(1)**2
              dt=xlell/clight*
     &          (
     &          (1.0d0+parke**2/2.0d0)/2.0d0/gamma**2+
     &          (((((-0.0205078125D0*h2+0.02734375D0)*h2
     &          -0.0390625D0)*h2+0.0625D0)*h2-0.125D0)*h2+0.5D0)*h2
     &          )
              t=t+dt

            endif !lmodeph

            zexp=cdexp(dcmplx(0.0d0,dph))
            damp=amp0*zexp*dist0/dist
            amp=amp+damp

            if (jhbunch.ne.0) then

              if (
     &            (iamppin.eq.3.or.iobsv.eq.icbrill)
     &          .and.mod(ielec,jhbunch).eq.0) then

                if (i.eq.1) then
                  fillb(5)=r(1)
                  fillb(6)=r(2)
                  fillb(7)=r(3)
                  fillb(8)=ypi
                  fillb(9)=zpi
                else if (i.eq.nper_u) then
                  fillb(10:12)=r
                  fillb(13)=ypi
                  fillb(14)=zpi
                  fillb(30)=dreal(amp(1))
                  fillb(31)=dimag(amp(1))
                  fillb(32)=dreal(amp(2))
                  fillb(33)=dimag(amp(2))
                  fillb(34)=dreal(amp(3))
                  fillb(35)=dimag(amp(3))
                  fillb(36)=dreal(amp(4))
                  fillb(37)=dimag(amp(4))
                  fillb(38)=dreal(amp(5))
                  fillb(39)=dimag(amp(5))
                  fillb(40)=dreal(amp(6))
                  fillb(41)=dimag(amp(6))
                endif

              endif

            endif

          enddo !nper_u

          apolh=
     &      amp(1)*conjg(stokesv(1,1))
     &      +amp(2)*conjg(stokesv(1,2))
     &      +amp(3)*conjg(stokesv(1,3))

          apolr=
     &      amp(1)*conjg(stokesv(2,1))
     &      +amp(2)*conjg(stokesv(2,2))
     &      +amp(3)*conjg(stokesv(2,3))

          apoll=
     &      amp(1)*conjg(stokesv(3,1))
     &      +amp(2)*conjg(stokesv(3,2))
     &      +amp(3)*conjg(stokesv(3,3))

          apol45=
     &      amp(1)*conjg(stokesv(4,1))
     &      +amp(2)*conjg(stokesv(4,2))
     &      +amp(3)*conjg(stokesv(4,3))

          stok1=dreal(apolr*conjg(apolr)+apoll*conjg(apoll))
          stok2=dreal(-stok1+2.0d0*apolh*conjg(apolh))
          stok3=dreal(2.0d0*apol45*conjg(apol45)-stok1)
          stok4=dreal(apolr*conjg(apolr)-apoll*conjg(apoll))

          wsstokes(1,iobfr)=wsstokes(1,iobfr)+stok1*sbnor
          wsstokes(2,iobfr)=wsstokes(2,iobfr)+stok2*sbnor
          wsstokes(3,iobfr)=wsstokes(3,iobfr)+stok3*sbnor
          wsstokes(4,iobfr)=wsstokes(4,iobfr)+stok4*sbnor

          stokes(1:4,iobfr,ith)=stokes(1:4,iobfr,ith)+wsstokes(1:4,iobfr)

          !affe(:,iobfr)=affe(:,iobfr)+amp
          !arad(:,iobfr,ith)=arad(:,iobfr,ith)+affe(:,iobfr)
          arad(:,iobfr,ith)=arad(:,iobfr,ith)+amp

          if (jhbunch.ne.0) then

            if (
     &          (iamppin.eq.3.or.iobsv.eq.icbrill)
     &          .and.mod(ielec,jhbunch).eq.0) then

              fillb(1)=jbun
              fillb(2)=isub
              fillb(3)=ibu
              fillb(4)=bunchx
              fillb(15)=gamma*emassg
              fillb(16)=udgamtot*emassg
              fillb(17)=obs(1)
              fillb(18)=obs(2)
              fillb(19)=obs(3)
              fillb(20)=kfreq
              fillb(21)=frq(kfreq)

              fillb(22)=wsstokes(1,iobfr)*nelec

              fillb(23)=wsstokes(1,iobfr)*nelec
              fillb(24)=wsstokes(2,iobfr)*nelec
              fillb(25)=wsstokes(3,iobfr)*nelec
              fillb(26)=wsstokes(4,iobfr)*nelec

              fillb(27)=spow
              fillb(28)=1
              fillb(29)=dtelec

              fillb(30)=dreal(amp(1))
              fillb(31)=dimag(amp(1))
              fillb(32)=dreal(amp(2))
              fillb(33)=dimag(amp(2))
              fillb(34)=dreal(amp(3))
              fillb(35)=dimag(amp(3))
              fillb(36)=dreal(amp(4))
              fillb(37)=dimag(amp(4))
              fillb(38)=dreal(amp(5))
              fillb(39)=dimag(amp(5))
              fillb(40)=dreal(amp(6))
              fillb(41)=dimag(amp(6))

              if (lbunch.ne.0) then
                lnbunch(ith)=lnbunch(ith)+1
                fbunch(:,lnbunch(ith),ith)=fillb(:)
              endif

            endif !fill

          endif !jhbunch

        enddo !kfreq

      enddo !nbunch

!$OMP END DO
!$OMP END PARALLEL

      do ith=1,mthreads
        pow_u(:)=pow_u(:)+pow(:,ith)
        arad_u(:,:)=arad_u(:,:)+arad(:,:,ith)
      enddo
+self,if=p.
      allocate(aradbuff(6,nepho_u*nobsv))
      aradbuff=arad_u
      !all util_break
      do iz=1,nobsvz/2
        do iy=1,nobsvy
          do kfreq=1,nepho
            iobm=nobsvz*(iy-1)+iz
            iobp=nobsvz*(iy-1)+(nobsvz-iz+1)
            iobfrm=iobm+nobsv*(kfreq-1)
            iobfrp=iobp+nobsv*(kfreq-1)
            arad_u(:,iobfrm)=aradbuff(:,iobfrp)
c            arad_u(:,iobfrm)=(aradbuff(:,iobm)+aradbuff(:,iobp))/2.0d0
c            arad_u(:,iobfrp)=(aradbuff(:,iobm)+aradbuff(:,iobp))/2.0d0
          enddo
        enddo
      enddo
      deallocate(aradbuff)
+self.
      pow_u=pow_u/sqnbunch

      if (icohere_u.eq.0) then

        arad_u=arad_u/sqnbunch

        do ith=1,mthreads
          stokes_u(:,:)=stokes_u(:,:)+stokes(:,:,ith)
        enddo

      else

        do iobsv=1,nobsv
          do kfreq=1,nepho

            iobfr=iobsv+nobsv*(kfreq-1)

            amp(1:3)=arad_u(1:3,iobfr) !/sqnphsp

            apolh=
     &        amp(1)*conjg(stokesv(1,1))
     &        +amp(2)*conjg(stokesv(1,2))
     &        +amp(3)*conjg(stokesv(1,3))

            apolr=
     &        amp(1)*conjg(stokesv(2,1))
     &        +amp(2)*conjg(stokesv(2,2))
     &        +amp(3)*conjg(stokesv(2,3))

            apoll=
     &        amp(1)*conjg(stokesv(3,1))
     &        +amp(2)*conjg(stokesv(3,2))
     &        +amp(3)*conjg(stokesv(3,3))

            apol45=
     &        amp(1)*conjg(stokesv(4,1))
     &        +amp(2)*conjg(stokesv(4,2))
     &        +amp(3)*conjg(stokesv(4,3))

            stok1=dreal(apolr*conjg(apolr)+apoll*conjg(apoll))
            stok2=dreal(-stok1+2.0d0*apolh*conjg(apolh))
            stok3=dreal(2.0d0*apol45*conjg(apol45)-stok1)
            stok4=dreal(apolr*conjg(apolr)-apoll*conjg(apoll))

            stokes_u(1,iobfr)=stok1*sbnor
            stokes_u(2,iobfr)=stok2*sbnor
            stokes_u(3,iobfr)=stok3*sbnor
            stokes_u(4,iobfr)=stok4*sbnor

          enddo
        enddo

      endif !icohere_u

      if (ihbunch.ne.0) then
        n=0
        do i=1,nlbu
          do ith=1,mthreads_u
            if (fbunch(21,i,ith).ne.0.0d0) then
              n=n+1
              fbunch_u(:,n)=fbunch(:,i,ith)
            endif
          enddo
        enddo
        deallocate(fbunch)
      endif

      !deallocate(affe)
      deallocate(frq,uampex,uampey,uampez,uampbx,uampby,uampbz,utraxyz,
     &  pherrc,pherr,phiran,arad,pow,pranall,wsstokes,stokes)

      if (iemit.ne.0) deallocate(eall)

      nper_u=nper

      return
      end
+DECK,urad_e_b_nnb,T=F77.
*CMZ :          30/12/2023  16.11.21  by  Michael Scheer
*CMZ :  4.01/04 17/12/2023  11.44.52  by  Michael Scheer
*CMZ :  4.01/02 12/05/2023  09.04.01  by  Michael Scheer
*CMZ :  4.01/00 22/02/2023  15.28.31  by  Michael Scheer
*CMZ :  4.00/15 28/04/2022  15.32.20  by  Michael Scheer
*CMZ :  4.00/13 16/11/2021  17.32.24  by  Michael Scheer
*CMZ :  4.00/09 15/08/2020  08.51.05  by  Michael Scheer
*CMZ :  3.05/05 10/07/2018  09.19.31  by  Michael Scheer
*CMZ :  3.05/04 05/07/2018  11.10.09  by  Michael Scheer
*CMZ :  3.05/00 27/04/2018  15.22.16  by  Michael Scheer
*CMZ :  3.03/04 13/10/2017  09.16.28  by  Michael Scheer
*CMZ :  3.03/02 19/11/2015  13.32.35  by  Michael Scheer
*CMZ :  3.02/04 13/03/2015  10.38.25  by  Michael Scheer
*CMZ :  2.69/02 02/11/2012  16.40.18  by  Michael Scheer
*CMZ :  2.68/05 04/09/2012  13.30.58  by  Michael Scheer
*CMZ :  2.68/04 03/09/2012  11.52.24  by  Michael Scheer
*CMZ :  2.68/03 31/08/2012  09.45.28  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine urad_e_b_nnb(
     &  icharge,current,
     &  gammai,dgamtot,
     &  xelec,yelec,zelec,vxelec,vyelec,vzelec,
     &  xf,yf,zf,efxn,efyn,efzn,
     &  xexit,yexit,zexit,vnxex,vnyex,vnzex,texit,ds,
     &  nthstep,nstep,ndim,traxyz,t0ph,
     &  xobsv,yobsv,zobsv,phelow,phehig,
     &  nphener,phener,aradex,aradey,aradez,aradbx,aradby,aradbz,stokes,powden,
     &  ieneloss,ivelofield,
     &  istatus,ith,banwid,modewave
     &  )
c123456789123456789_123456789_123456789_123456789_123456789_123456789_12
c Author: Michael Scheer, Michael.Scheer@Helmholtz-Berlin.de

c NO WARRANTY

+seq,gplhint.

c This subroutine calculates the trajectory and the synchrotron radiation
c of an electron passing a magnetic and electric field. The electric field
c part is very preliminary and not yet fully tested. The FORTRAN random
c generator is used in uradrndm. It should be replaced by a better one
c provided by the user.

c The fields B=(bx,by,bz) and E=(ex,ey,ez) are calculated in the routine
c uradfield_omp(x,y,z,bx,by,bz,ex,ey,ez,gamma,istatus) provided by the user.
c As an example uradbmap.f may be used, which reads a 3D map of the mag. field

c Coordinate system (right handed):
c -----------------------------------

c      x: longitudinal direction
c      y: transversal vertical direction
c      z: transversal horizontal direction

c Units:
c ------

c SI-units: m, Tesla, sec, V etc., but eV for the photon energy
c The flux-density is given in Nph/s/mm**2/0.1%BW, the power-density in W/mm**2

c Input:
c --------

c integer icharge: Particle charge ( +/- 1)
c real*8 gammai: Gamma factor of the e-

c real*8 xelec:  Initial x of e-
c real*8 yelec:  Initial y of e-
c real*8 zelec:  Initial z of e-

c real*8 vxelec:  Initial velocity in x of e-
c real*8 vyelec:  Initial velocity in y of e-
c real*8 vzelec:  Initial velocity in z of e-
c The velocity is internally normalized, so the input norm does not matter

c real*8 xf: x of point in exit plane
c real*8 yf: y of point in exit plane
c real*8 zf: z of point in exit plane

c real*8 [efxn,efyn,efzn]: Normal vector of exit plane

c real*8 vnxex: x component of normal vector of exit plane
c real*8 vnyex: y component of normal vector of exit plane
c real*8 vnzex: z component of normal vector of exit plane

c real*8 ds : step size for tracking

c The tracking stops, when the electron hits the exit plane. The size of the last
c step is corrected such that the plane is hit.

c integer nthstep: If nstep > 0, the trajectory array traxyz is filled,
c                  see below
c integer ndim: Dimension of traxyz, see below

c real*8 phelow: Lowest photon energy / eV
c real*8 phehig: Higest photon energy / eV

c integer nphener: Number of equidistant photon energies

c integer ieneloss:  0: no energy loss due to synchotron radiation
c                    1: continous energy loss due to synchotron radiation
c integer ieneloss: -1: no energy loss due to synchotron radiation with quantum
c                       fluctuations

c integer ivelofield: Contral flag for the calculation of the velocity field:
c                    0: the spectrum includes the velocity field
c                    1: the specrum does not include the velocity field
c                    2: the spectrum includes only the velocity field

c Output:
c -------

c integer: istatus: Status flag:
c  0: no error found
c -1: initial gamma or velocity zero
c -2: dimension ndim of traxyz exceeded
c -3: bad value of ivelofield
c  else: status of uradfield_omp

c real*8 xexit: x of last point of the trajectory
c real*8 yexit: y of last point of the trajectory
c real*8 zexit: z of last point of the trajectory
c real*8 texit: t of last point of the trajectory

c real*8 vnxex: x component of norm. velocity vector of last point
c real*8 vnyex: y component of norm. velocity vector of last point
c real*8 vnzex: z component of norm. velocity vector of last point

c real*8 phener(nphener): Array of equidistant photon energies

c integer nstep: Number of tracking steps done, i.e. used length of traxyz

c real*8 traxyz(1:14,i): Array:
c        traxyz(1,i):  x
c        traxyz(2,i):  y
c        traxyz(3,i):  z
c        traxyz(4,i):  tracking time
c        traxyz(5,i):  x-comp. of norm. velocity vector
c        traxyz(6,i):  y-comp. of norm. velocity vector
c        traxyz(7,i):  z-comp. of norm. velocity vector
c        traxyz(8,i):  x-comp. of mag. field in the center of the step
c        traxyz(9,i):  y-comp. of mag. field in the center of the step
c        traxyz(10,i): z-comp. of mag. field in the center of the step
c        traxyz(11,i): gamma
c        traxyz(12,i): x-comp. of elec. field in the center of the step
c        traxyz(13,i): y-comp. of elec. field in the center of the step
c        traxyz(14,i): z-comp. of elec. field in the center of the step

c real* t0ph
c The phase is calculated by phase=t0ph+n*dt*dphase,
c where dphase is the phase difference of the nth step dt. t0ph=
c (xobsv-xelec)/clight. The phase factor of the integrand is
c exp(i*omega*phase),where omega referes to the considered photon energy.
c complex*16 aradex(i): x-comp. of amplitude of radiation e-field of phener(i)
c complex*16 aradey(i): y-comp. of amplitude of radiation e-field of phener(i)
c complex*16 aradez(i): z-comp. of amplitude of radiation e-field of phener(i)
c complex*16 aradbx(i): x-comp. of amplitude of radiation b-field of phener(i)
c complex*16 aradby(i): y-comp. of amplitude of radiation b-field of phener(i)
c complex*16 aradbz(i): z-comp. of amplitude of radiation b-field of phener(i)

c real*8 array of Stokes parameters of ith photon energy:
c        stokes(1,i): S0, i.e. total intensity
c        stokes(2,i): S1, Stokes parameter of linear +/- 90 degree polarisation
c        stokes(3,i): S2, Stokes parameter of linear +/- 45 degree polarisation
c        stokes(4,i): S3, Stokes parameter of circular polarisation
c        S0 = sqrt(S1**2+S2**2+S3**2)

c Compilation:
c ------------

c For uradbmap at least F90 is required.
c The line length exceeds 72 characters, please use an appropriate
c compiler option. It is recommended to use compiler options to initialize all
c variables to zero and to treat them as saved''

      implicit none

      complex*16
     &  aradex(nphener),aradey(nphener),aradez(nphener),
     &  aradbx(nphener),aradby(nphener),aradbz(nphener),
     &  ziom,zi,zidom,zone,ziomr1,zicr1,zic,
     &  expom1,expom,dexpomph1,dexpomph,ddexpomph,dexpom,
     &  expomv2,vstokes(4,3),
     &  apolh,apolr,apoll,apol45,cdum,cdum3,ampex,ampey,ampez,ampbx,ampby,ampbz

      double precision
     &  gammai,dgamtot,dt2,powden,t,phase,t0ph,
     &  xelec,yelec,zelec,vxelec,vyelec,vzelec,
     &  xexit,yexit,zexit,vnxex,vnyex,vnzex,texit,
     &  xobsv,yobsv,zobsv,phelow,phehig,
     &  phener(nphener),dom2,c,rspn
     &  ,traxyz(14,ndim),stokes(4,nphener),x1,y1,z1,vx1,vy1,
     &  vz1,x2,y2,z2,vx2,vy2,vz2
     &  ,ds,dtim,bshift,x2b,y2b,z2b,bx1,by1,bz1,bx2,by2,bz2
     &  ,dgamsum,gamma,dt
     &  ,vxp,vyp,vzp,phi,phir
     &  ,efx,efy,efz,xf,yf,zf,dist2
     &  ,dtim0,beta,vn,efx2,efy2,efz2,t1,t2,clight,c1,
     &  dgamma,vxsign,bx,by,bz,bpx,bpy,bpz,rarg(5),px,py,pz,
     &  dphase,r,rx,ry,rz
     &  ,dom1,rnbx,rnby,rnbz,dum11,rnr4,br4,b3,rnr2,br2,bet1n,
     &  rnx,rny,rnz,r1,banwid,specnor,pownor,current,
     &  stok1,stok2,stok3,stok4,om,dom,hbarev,echarge,eps0,pi,vsto,dph,
     &  r0,efxn,efyn,efzn,h2,rn_cross_rn_cross_beta(3)

      integer ieneloss,istatus,icharge,nphener,ivelofield,
     &  nthstep,izaehl,nstep,ndim,kstep,lstep,kfreq,isto,ifail,ith,
     &  modewave,luna

      integer :: idebug=0

c      integer,save :: ical=0
+seq,uservar.


      data bshift/0.5d0/
      data clight/2.99792458d8/
      data hbarev/6.58211889D-16/
      data eps0/8.854187817D-12/
      data echarge/1.602176462D-19/
      data pi/3.14159265358979d0/

      data zi/(0.0d0,1.0d0)/
      data zone/(1.0d0,0.0d0)/

      dph=0.0d0
      ith=ith
c      ical=ical+1

      if (idebug.eq.1.and.yobsv.eq.0.0d0.and.zobsv.eq.0.0d0) then
        open(newunit=luna,file='urad_nnb.dat',recl=1024)
        idebug=2
      endif

      if (nphener.gt.0) phener(1)=phelow
      if (nphener.gt.1) dph=(phehig-phelow)/(nphener-1)

      do kfreq=2,nphener
        phener(kfreq)=phener(kfreq-1)+dph
      enddo

      istatus=0
      ifail=0
      if (icharge.le.0) icharge=-1
      if (icharge.gt.0) icharge=1

      vn=norm2([efxn,efyn,efzn])
      efx=efxn/vn
      efy=efyn/vn
      efz=efzn/vn

      x1=xelec
      y1=yelec
      z1=zelec
      vx1=vxelec
      vy1=vyelec
      vz1=vzelec
      t1=0.0d0

      gamma=gammai
      beta=dsqrt((1.d0-1.d0/gamma)*(1.d0+1.d0/gamma))
      vn=sqrt(vx1*vx1+vy1*vy1+vz1*vz1)
      vx1=vx1/vn*clight*beta
      vy1=vy1/vn*clight*beta
      vz1=vz1/vn*clight*beta
      vn=beta*clight

c vxsign takes care for the direction of flight, since particle must gain
c energy if tracked back

      if (vx1.lt.0) then
        vxsign=-1.0d0
      else
        vxsign=1.0d0
      endif

      dgamsum=0.0d0
      dgamtot=0.0d0
      powden=0.0d0

      aradex=(0.0d0,0.0d0)
      aradey=(0.0d0,0.0d0)
      aradez=(0.0d0,0.0d0)

      aradbx=(0.0d0,0.0d0)
      aradby=(0.0d0,0.0d0)
      aradbz=(0.0d0,0.0d0)

      dtim=ds/vn
      dt=dtim
      dt2=dtim*bshift
      dtim0=dtim

      x2=x1
      y2=y1
      z2=z1
      t2=t1

      vx2=vx1
      vy2=vy1
      vz2=vz1

      x2b=x1+vx1*dt2
      y2b=y1+vy1*dt2
      z2b=z1+vz1*dt2

      call uradfield_omp(x2b,y2b,z2b,bx2,by2,bz2,efx2,efy2,efz2,gamma,istatus,
     &  modewave)
      if (istatus.ne.0) ifail=ifail+abs(istatus)
      istatus=0

      nstep=0
      vn=sqrt(vx2*vx2+vy2*vy2+vz2*vz2)

      if (gamma.le.0.0d0.or.vn.le.0.0d0) then
        istatus=-1
        return
      endif

      kstep=-1
      nstep=0

      if(nthstep.gt.0) then

        nstep=nstep+1
        if (nstep.gt.ndim) then
          nstep=nstep-1
          istatus=-2
          goto 9000
        endif

        kstep=kstep+1
        if (kstep.eq.nthstep) kstep=0

        traxyz(1,nstep)=x2
        traxyz(2,nstep)=y2
        traxyz(3,nstep)=z2
        traxyz(4,nstep)=t2
        traxyz(5,nstep)=vx2/vn
        traxyz(6,nstep)=vy2/vn
        traxyz(7,nstep)=vz2/vn
        traxyz(8,nstep)=bx2
        traxyz(9,nstep)=by2
        traxyz(10,nstep)=bz2
        traxyz(11,nstep)=gamma
        traxyz(12,nstep)=efx2
        traxyz(13,nstep)=efy2
        traxyz(14,nstep)=efz2

      endif !nthstep.gt.0

      dom=0.0d0
      om=0.0d0
      if (nphener.gt.1) then
        om=phener(1)/hbarev
        dom=(phener(2)-phener(1))/hbarev
      else if (nphener.eq.1) then
        om=phener(1)/hbarev
      endif

      c=clight
      c1=1.0d0/clight

      zidom=zi*dom
      ziom=zi*om
      zic=zi*c

      lstep=0
      t=-dt
      r0=xobsv-xelec
      r=sqrt((xobsv-x1)**2+((yobsv-y1)**2+(zobsv-z1)**2))
c      PHASE=(r-r0)*c1
      phase=t0ph
      expom1=zone
      dexpomph1=zone

c--- Loop der Trajektorie

      izaehl=0
1000  continue
      !all util_break
      izaehl=izaehl+1
c      print*,ith,izaehl,x2
      if (x2.ne.x2) then
        istatus=-99
        return
      endif

      if (lstep.eq.1) then
        dtim=abs(dist2)/vn
        dt=dtim
        dt2=dtim/2.0d0
      endif

      x1=x2
      y1=y2
      z1=z2

      t1=t2

      vx1=vx2
      vy1=vy2
      vz1=vz2

      bx1=bx2
      by1=by2
      bz1=bz2

      x2b=x1+vx1*dt2
      y2b=y1+vy1*dt2
      z2b=z1+vz1*dt2

      call uradfield_omp(x2b,y2b,z2b,bx2,by2,bz2,efx2,efy2,efz2,gamma,istatus,
     &  modewave)
      if (istatus.ne.0) ifail=ifail+abs(istatus)
      istatus=0

      call uradstep_omp(x1,y1,z1,vx1,vy1,vz1,bx2,by2,bz2,efx2,efy2,efz2,
     &  dtim,x2,y2,z2,vx2,vy2,vz2,vxp,vyp,vzp,gamma,icharge,ieneloss,
     &  dgamma)

      t2=t1+dtim
      t=t2

      if (ieneloss.ne.0) then
        dgamsum=dgamsum+vxsign*dgamma
        if (abs(dgamsum).gt.gamma*1.0d-8) then
          gamma=gamma+dgamsum
          dgamtot=dgamtot+dgamsum
          dgamsum=0.0d0
        endif
        beta=dsqrt((1.d0-1.d0/gamma)*(1.d0+1.d0/gamma))
        vn=sqrt(vx2*vx2+vy2*vy2+vz2*vz2)
        vx2=vx2/vn*clight*beta
        vy2=vy2/vn*clight*beta
        vz2=vz2/vn*clight*beta
      endif

      BX=VX2*C1
      BY=VY2*C1
      BZ=VZ2*C1

      BPX=VXP*C1
      BPY=VYP*C1
      BPZ=VZP*C1

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION {

C REAL PART OF INTEGRAND {

      RX=XOBSV-X2
      RY=YOBSV-Y2
      RZ=ZOBSV-Z2

      h2=(ry*ry+rz*rz)/(rx*rx)
      if(h2.lt.0.01) then
        r=rx*(1.0d0+(((((-0.0205078125D0*h2+0.02734375D0)*h2
     &      -0.0390625D0)*h2+0.0625D0)*h2-0.125D0)*h2+0.5D0)*h2)
      else
        R=SQRT(RX*RX+RY*RY+RZ*RZ)
      endif

      R1=1.0D0/R
      ZICR1=ZIC*R1

      RNX=RX*R1
      RNY=RY*R1
      RNZ=RZ*R1

      BET1N=(1.0D0-BX*RNX)-BY*RNY-BZ*RNZ

      br2=by**2+bz**2
      rnr2=rny**2+rnz**2
      b3=beta**3
      br4=br2**2
      rnr4=rnr2**2

      if(br2.lt.1.0d-4.and.rnr2.lt.1.0d-4) then
        bet1n=
     &    1.0d0/(1.0d0+beta)/gamma**2
     &    +beta*(rnr2/2.0d0
     &    +rnr4/8.0d0)
     &    +(br2/2.0d0
     &    -br2*rnr2/4.0d0
     &    -br2*rnr4/16.0d0)/beta
     &    +b3*br4*(1.0d0/8.0d0
     &    -rnr2/16.0d0
     &    -rnr4/64.0d0)
     &    -by*rny
     &    -bz*rnz
      endif

      DUM11=1.0D0/BET1N
      DOM1=1.0D0/(R*BET1N*BET1N)

      RNBX=RNX-BX
      RNBY=RNY-BY
      RNBZ=RNZ-BZ

      rn_cross_rn_cross_beta(1)=rny*(rnx*by-rny*bx)-rnz*(rnz*bx-rnx*bz)
      rn_cross_rn_cross_beta(2)=rnz*(rny*bz-rnz*by)-rnx*(rnx*by-rny*bx)
      rn_cross_rn_cross_beta(3)=rnx*(rnz*bx-rnx*bz)-rny*(rny*bz-rnz*by)

      rarg(1:3)=rn_cross_rn_cross_beta(1:3)*r1

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS      RARG(4)=T+R*C1

      DPHASE=BET1N*DT

      RARG(5)=(RARG(1)*RARG(1)+RARG(2)*RARG(2)+RARG(3)*RARG(3))*DUM11

      powden=powden+rarg(5)*dt

C REAL PART OF INTEGRAND }

C COMPLEX PART OF INTEGRAND {

C    ASSUMES phener(I+1)=2*phener(I)   FOR kfreq2P=2
C    OR phener(I+1)=phener(I)+DELTA    FOR kfreq2P>2

C--- LOOP OVER ALL FREQUENCES

      if (nphener.gt.0) then

        kfreq=1

        OM=phener(kfreq)/hbarev
        ZIOM=ZI*OM

        if (izaehl.eq.1) then
          EXPOM1=CDEXP(DCMPLX(0.D0,phase*OM))
        endif

        EXPOM=EXPOM1
        DEXPOMPH1=EXP(ZIOM*DPHASE)
        DEXPOMPH=DEXPOMPH1

        IF(nphener.GT.1) THEN
          DEXPOM=EXP(ZIDOM*PHASE)
          DDEXPOMPH=EXP(ZIDOM*DPHASE)
        ENDIF  !kfreq2P

c        cdum3=cdexp(zi*om*(t0ph+t2-(rnx*x2+rny*y2+rnz*z2)*c1))*dt

        phi=t0ph+t2-(rnx*x2+rny*y2+rnz*z2)*c1
        phir=t0ph+t2-r*c1
        cdum=zi*phi
        dexpom=cdexp(dom*cdum)
        cdum3=cdexp(om*cdum)

        ampex=RARG(1)*cdum3*om*dt
        ampey=RARG(2)*cdum3*om*dt
        ampez=RARG(3)*cdum3*om*dt

        PHASE=PHASE+DPHASE

        if (idebug.eq.2) then
          write(luna,*)t2,x2,z2,rnx,rny,rnz,bx,by,bz,rn_cross_rn_cross_beta(1:3),
     &      t0ph,dimag(cdum),rarg(1:3),dreal(cdum3),dimag(cdum3),phase,om,
     &      dreal(ampez)/dt,dimag(ampez)/dt,phi,phir,r
          flush(luna)
        endif

        aradex(kfreq)=aradex(kfreq)+ampex
        aradey(kfreq)=aradey(kfreq)+ampey
        aradez(kfreq)=aradez(kfreq)+ampez

c        print*,izaehl,t2,aradez(kfreq)*conjg(aradez(kfreq))

        ampbx=(rny*ampez-rnz*ampey)/clight
        ampby=(rnz*ampex-rnx*ampez)/clight
        ampbz=(rnx*ampey-rny*ampex)/clight

        aradbx(kfreq)=aradbx(kfreq)+ampbx
        aradby(kfreq)=aradby(kfreq)+ampby
        aradbz(kfreq)=aradbz(kfreq)+ampbz

        DO kfreq=2,nphener

          OM=OM+DOM

c          cdum3=om*cdexp(zi*om*(t0ph+t2-(rnx*x2+rny*y2+rnz*z2)*c1))*dt
          cdum3=cdum3*dexpom

          ampex=RARG(1)*cdum3*om*dt
          ampey=RARG(2)*cdum3*om*dt
          ampez=RARG(3)*cdum3*om*dt

          aradex(kfreq)=aradex(kfreq)+ampex
          aradey(kfreq)=aradey(kfreq)+ampey
          aradez(kfreq)=aradez(kfreq)+ampez

          ampbx=(rny*ampez-rnz*ampey)/clight
          ampby=(rnz*ampex-rnx*ampez)/clight
          ampbz=(rnx*ampey-rny*ampex)/clight

          aradbx(kfreq)=aradbx(kfreq)+ampbx
          aradby(kfreq)=aradby(kfreq)+ampby
          aradbz(kfreq)=aradbz(kfreq)+ampbz

        ENDDO   !LOOP OVER ALL FREQUENCES

C COMPLEX PART OF INTEGRAND }

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION }

        EXPOM1=EXPOM1*DEXPOMPH1

      endif !(nphener.gt.0) then

c ef is normal vector of perpendiculare plane at the end of the reference orbit
c dist is distance of electron to this plane
c tracking stops if trajectory hits this plane

      dist2=(x2-xf)*efx+(y2-yf)*efy+(z2-zf)*efz

      if (lstep.eq.0.and.dist2.lt.0.0d0.and.dist2.gt.-2.0d0*ds)  then

        if (idebug.ne.0) call util_break

        lstep=1
        goto 1000

      else

        kstep=kstep+1
        if (kstep.eq.nthstep) kstep=0

        if(kstep.eq.0) then

          nstep=nstep+1

          if (nstep.gt.ndim) then
            nstep=nstep-1
            istatus=-2
            goto 9000
          endif

          traxyz(1,nstep)=x2
          traxyz(2,nstep)=y2
          traxyz(3,nstep)=z2
          traxyz(4,nstep)=t2
          traxyz(5,nstep)=vx2/vn
          traxyz(6,nstep)=vy2/vn
          traxyz(7,nstep)=vz2/vn
          traxyz(8,nstep)=bx2
          traxyz(9,nstep)=by2
          traxyz(10,nstep)=bz2
          traxyz(11,nstep)=gamma
          traxyz(12,nstep)=efx2
          traxyz(13,nstep)=efy2
          traxyz(14,nstep)=efz2

        endif

        if (lstep.eq.1) goto 9000
        goto 1000

      endif !lstep and dist2

9000  continue

      xexit=x2
      yexit=y2
      zexit=z2

      vn=sqrt(vx2*vx2+vy2*vy2+vz2*vz2)
      vnxex=vx2/vn
      vnyex=vy2/vn
      vnzex=vz2/vn

      texit=t2

      specnor=
     &  banwid
     & /(4.0d0*pi**2*clight*hbarev)
     & /(4.0d0*pi*eps0)
     &  *current/1.0d6 !per mm**2

      pownor=echarge/16.0d0/pi/pi/eps0/clight*current/1.0d6 !W/mm**2

      rspn=sqrt(specnor)

      vstokes(1,1)=( 0.0d0,        0.0d0)      !horizontal polarization
      vstokes(1,2)=( 0.0d0,        0.0d0)
      vstokes(1,3)=(-1.0d0,       -1.0d0)

      vstokes(2,1)=( 0.0d0,        0.0d0)      !right handed polarization
      vstokes(2,2)=( 0.0d0,       -1.0d0)
      vstokes(2,3)=(+1.0d0,        0.0d0)

      vstokes(3,1)=( 0.0d0,        0.0d0)      !left handed polarization
      vstokes(3,2)=( 0.0d0,       -1.0d0)
      vstokes(3,3)=(-1.0d0,        0.0d0)

      vstokes(4,1)=( 0.0d0,        0.0d0)      !45 degree linear polarization
      vstokes(4,2)=( 1.0d0,        0.0d0)
      vstokes(4,3)=(-1.0d0,        0.0d0)

      do isto=1,4
        vsto=dsqrt
     &    (cdabs(vstokes(isto,1))**2
     &    +cdabs(vstokes(isto,2))**2
     &    +cdabs(vstokes(isto,3))**2)
        vstokes(isto,1)=vstokes(isto,1)/vsto
        vstokes(isto,2)=vstokes(isto,2)/vsto
        vstokes(isto,3)=vstokes(isto,3)/vsto

      enddo

      do kfreq=1,nphener

        aradex(kfreq)=aradex(kfreq)*rspn
        aradey(kfreq)=aradey(kfreq)*rspn
        aradez(kfreq)=aradez(kfreq)*rspn

        apolh=
     &    aradex(kfreq)*conjg(vstokes(1,1))
     &    +aradey(kfreq)*conjg(vstokes(1,2))
     &    +aradez(kfreq)*conjg(vstokes(1,3))

        apolr=
     &    aradex(kfreq)*conjg(vstokes(2,1))
     &    +aradey(kfreq)*conjg(vstokes(2,2))
     &    +aradez(kfreq)*conjg(vstokes(2,3))

        apoll=
     &    aradex(kfreq)*conjg(vstokes(3,1))
     &    +aradey(kfreq)*conjg(vstokes(3,2))
     &    +aradez(kfreq)*conjg(vstokes(3,3))

        apol45=
     &    aradex(kfreq)*conjg(vstokes(4,1))
     &    +aradey(kfreq)*conjg(vstokes(4,2))
     &    +aradez(kfreq)*conjg(vstokes(4,3))

        stok1=real(
     &    apolr*conjg(apolr)+
     &    apoll*conjg(apoll))

        stok2=-stok1+
     &    real(2.*apolh*conjg(apolh))

        stok3=
     &    real(2.*apol45*conjg(apol45))-
     &    stok1

        stok4=real(
     &    apolr*conjg(apolr)-
     &    apoll*conjg(apoll))

        stokes(1,kfreq)=stok1
        stokes(2,kfreq)=stok2
        stokes(3,kfreq)=stok3
        stokes(4,kfreq)=stok4

      enddo !nphener

      powden=powden*pownor

      if (istatus.ge.0.and.ifail.ne.0) istatus=ifail

      if (idebug.eq.2) then
        idebug=0
        close(luna)
      endif

      return
      end
+DECK,urad_e_b_sym,T=F77.
*CMZ :  4.01/04 27/11/2023  23.07.23  by  Michael Scheer
*CMZ :  4.01/02 12/05/2023  09.04.01  by  Michael Scheer
*CMZ :  4.01/00 22/02/2023  15.28.31  by  Michael Scheer
*CMZ :  4.00/15 28/04/2022  15.32.20  by  Michael Scheer
*CMZ :  4.00/13 16/11/2021  17.32.24  by  Michael Scheer
*CMZ :  4.00/09 15/08/2020  08.51.05  by  Michael Scheer
*CMZ :  3.05/05 10/07/2018  09.19.31  by  Michael Scheer
*CMZ :  3.05/04 05/07/2018  11.10.09  by  Michael Scheer
*CMZ :  3.05/00 27/04/2018  15.22.16  by  Michael Scheer
*CMZ :  3.03/04 13/10/2017  09.16.28  by  Michael Scheer
*CMZ :  3.03/02 19/11/2015  13.32.35  by  Michael Scheer
*CMZ :  3.02/04 13/03/2015  10.38.25  by  Michael Scheer
*CMZ :  2.69/02 02/11/2012  16.40.18  by  Michael Scheer
*CMZ :  2.68/05 04/09/2012  13.30.58  by  Michael Scheer
*CMZ :  2.68/04 03/09/2012  11.52.24  by  Michael Scheer
*CMZ :  2.68/03 31/08/2012  09.45.28  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine urad_e_b_sym(
     &  icharge,current,
     &  gammai,dgamtot,
     &  xelec,yelec,zelec,vxelec,vyelec,vzelec,
     &  xf,yf,zf,efxn,efyn,efzn,
     &  xexit,yexit,zexit,vnxex,vnyex,vnzex,texit,ds,
     &  nthstep,nstep,ndim,traxyz,phase0,
     &  xobsv,yobsv,zobsv,phelow,phehig,
     &  nphener,phener,aradex,aradey,aradez,aradbx,aradby,aradbz,stokes,powden,
     &  ieneloss,ivelofield,
     &  istatus,ith,banwid,modewave
     &  )

c123456789123456789_123456789_123456789_123456789_123456789_123456789_12
c Author: Michael Scheer, Michael.Scheer@Helmholtz-Berlin.de

c NO WARRANTY

+seq,gplhint.

c This subroutine calculates the trajectory and the synchrotron radiation
c of an electron passing a magnetic and electric field. The electric field
c part is very preliminary and not yet fully tested. The FORTRAN random
c generator is used in uradrndm. It should be replaced by a better one
c provided by the user.

c The fields B=(bx,by,bz) and E=(ex,ey,ez) are calculated in the routine
c uradfield_omp(x,y,z,bx,by,bz,ex,ey,ez,gamma,istatus) provided by the user.
c As an example uradbmap.f may be used, which reads a 3D map of the mag. field

c Coordinate system (right handed):
c -----------------------------------

c      x: longitudinal direction
c      y: transversal vertical direction
c      z: transversal horizontal direction

c Units:
c ------

c SI-units: m, Tesla, sec, V etc., but eV for the photon energy
c The flux-density is given in Nph/s/mm**2/0.1%BW, the power-density in W/mm**2

c Input:
c --------

c integer icharge: Particle charge ( +/- 1)
c real*8 gammai: Gamma factor of the e-

c real*8 xelec:  Initial x of e-
c real*8 yelec:  Initial y of e-
c real*8 zelec:  Initial z of e-

c real*8 vxelec:  Initial velocity in x of e-
c real*8 vyelec:  Initial velocity in y of e-
c real*8 vzelec:  Initial velocity in z of e-
c The velocity is internally normalized, so the input norm does not matter

c real*8 xf: x of point in exit plane
c real*8 yf: y of point in exit plane
c real*8 zf: z of point in exit plane

c real*8 [efxn,efyn,efzn]: Normal vector of exit plane

c real*8 vnxex: x component of normal vector of exit plane
c real*8 vnyex: y component of normal vector of exit plane
c real*8 vnzex: z component of normal vector of exit plane

c real*8 ds : step size for tracking

c The tracking stops, when the electron hits the exit plane. The size of the last
c step is corrected such that the plane is hit.

c integer nthstep: If nstep > 0, the trajectory array traxyz is filled,
c                  see below
c integer ndim: Dimension of traxyz, see below

c real*8 phelow: Lowest photon energy / eV
c real*8 phehig: Higest photon energy / eV

c integer nphener: Number of equidistant photon energies

c integer ieneloss:  0: no energy loss due to synchotron radiation
c                    1: continous energy loss due to synchotron radiation
c integer ieneloss: -1: no energy loss due to synchotron radiation with quantum
c                       fluctuations

c integer ivelofield: Contral flag for the calculation of the velocity field:
c                    0: the spectrum includes the velocity field
c                    1: the specrum does not include the velocity field
c                    2: the spectrum includes only the velocity field

c Output:
c -------

c integer: istatus: Status flag:
c  0: no error found
c -1: initial gamma or velocity zero
c -2: dimension ndim of traxyz exceeded
c -3: bad value of ivelofield
c  else: status of uradfield_omp

c real*8 xexit: x of last point of the trajectory
c real*8 yexit: y of last point of the trajectory
c real*8 zexit: z of last point of the trajectory
c real*8 texit: t of last point of the trajectory

c real*8 vnxex: x component of norm. velocity vector of last point
c real*8 vnyex: y component of norm. velocity vector of last point
c real*8 vnzex: z component of norm. velocity vector of last point

c real*8 phener(nphener): Array of equidistant photon energies

c integer nstep: Number of tracking steps done, i.e. used length of traxyz

c real*8 traxyz(1:14,i): Array:
c        traxyz(1,i):  x
c        traxyz(2,i):  y
c        traxyz(3,i):  z
c        traxyz(4,i):  tracking time
c        traxyz(5,i):  x-comp. of norm. velocity vector
c        traxyz(6,i):  y-comp. of norm. velocity vector
c        traxyz(7,i):  z-comp. of norm. velocity vector
c        traxyz(8,i):  x-comp. of mag. field in the center of the step
c        traxyz(9,i):  y-comp. of mag. field in the center of the step
c        traxyz(10,i): z-comp. of mag. field in the center of the step
c        traxyz(11,i): gamma
c        traxyz(12,i): x-comp. of elec. field in the center of the step
c        traxyz(13,i): y-comp. of elec. field in the center of the step
c        traxyz(14,i): z-comp. of elec. field in the center of the step

c real* phase0
c The phase is calculated by phase=phase0+n*dt*dphase,
c where dphase is the phase difference of the nth step dt. Phase0=
c (xobsv-xelec)/clight. The phase factor of the integrand is
c exp(i*omega*phase),where omega referes to the considered photon energy.
c complex*16 aradex(i): x-comp. of amplitude of radiation e-field of phener(i)
c complex*16 aradey(i): y-comp. of amplitude of radiation e-field of phener(i)
c complex*16 aradez(i): z-comp. of amplitude of radiation e-field of phener(i)
c complex*16 aradbx(i): x-comp. of amplitude of radiation b-field of phener(i)
c complex*16 aradby(i): y-comp. of amplitude of radiation b-field of phener(i)
c complex*16 aradbz(i): z-comp. of amplitude of radiation b-field of phener(i)

c real*8 array of Stokes parameters of ith photon energy:
c        stokes(1,i): S0, i.e. total intensity
c        stokes(2,i): S1, Stokes parameter of linear +/- 90 degree polarisation
c        stokes(3,i): S2, Stokes parameter of linear +/- 45 degree polarisation
c        stokes(4,i): S3, Stokes parameter of circular polarisation
c        S0 = sqrt(S1**2+S2**2+S3**2)

c Compilation:
c ------------

c For uradbmap at least F90 is required.
c The line length exceeds 72 characters, please use an appropriate
c compiler option. It is recommended to use compiler options to initialize all
c variables to zero and to treat them as saved''

      implicit none

      complex*16, dimension(:), allocatable ::
     &  caradex,caradey,caradez,
     &  caradbx,caradby,caradbz

      complex*16
     &  aradex(nphener),aradey(nphener),aradez(nphener),
     &  aradbx(nphener),aradby(nphener),aradbz(nphener),
     &  ziom,zi,zidom,zone,ziomr1,zicr1,zic,
     &  expom1,expom,dexpomph1,dexpomph,ddexpomph,dexpom,
     &  expomv2,vstokes(4,3),
     &  apolh,apolr,apoll,apol45,dum3,ampex,ampey,ampez,ampbx,ampby,ampbz

      double precision
     &  gammai,dgamtot,dt2,powden,t,phase,phase0,
     &  xelec,yelec,zelec,vxelec,vyelec,vzelec,
     &  xexit,yexit,zexit,vnxex,vnyex,vnzex,texit,
     &  xobsv,yobsv,zobsv,phelow,phehig,
     &  phener(nphener),dom2,c,rspn
     &  ,traxyz(14,ndim),stokes(4,nphener),x1,y1,z1,vx1,vy1,
     &  vz1,x2,y2,z2,vx2,vy2,vz2
     &  ,ds,dtim,bshift,x2b,y2b,z2b,bx1,by1,bz1,bx2,by2,bz2
     &  ,dgamsum,gamma,dt
     &  ,vxp,vyp,vzp
     &  ,efx,efy,efz,xf,yf,zf,dist2
     &  ,dtim0,beta,vn,efx2,efy2,efz2,t1,t2,clight,c1,
     &  dgamma,vxsign,bx,by,bz,bpx,bpy,bpz,rarg(5),px,py,pz,
     &  dphase,r,rx,ry,rz
     &  ,dom1,rnbx,rnby,rnbz,dum11,rnr4,br4,b3,rnr2,br2,bet1n,
     &  rnx,rny,rnz,r1,banwid,specnor,pownor,current,
     &  stok1,stok2,stok3,stok4,om,dom,hbarev,echarge,eps0,pi,vsto,dph,
     &  r0,efxn,efyn,efzn

      integer ieneloss,istatus,icharge,nphener,ivelofield,
     &  nthstep,izaehl,nstep,ndim,kstep,lstep,kfreq,isto,ifail,ith,
     &  modewave

      integer :: idebug=0

      integer :: ical=0

      save

c+seq,b0scglob.
+seq,uservar.

      data bshift/0.5d0/
      data clight/2.99792458d8/
      data hbarev/6.58211889D-16/
      data eps0/8.854187817D-12/
      data echarge/1.602176462D-19/
      data pi/3.14159265358979d0/

      data zi/(0.0d0,1.0d0)/
      data zone/(1.0d0,0.0d0)/

      call urad_e_b_field(
     &  icharge,current,
     &  gammai,dgamtot,
     &  xelec,yelec,zelec,vxelec,vyelec,vzelec,
     &  xf,yf,zf,efxn,efyn,efzn,
     &  xexit,yexit,zexit,vnxex,vnyex,vnzex,texit,ds,
     &  nthstep,nstep,ndim,traxyz,phase0,
     &  xobsv,yobsv,zobsv,phelow,phehig,
     &  nphener,phener,aradex,aradey,aradez,aradbx,aradby,aradbz,stokes,powden,
     &  ieneloss,ivelofield,
     &  istatus,ith,banwid,modewave
     &  )

      if (ical.eq.0) then
        ical=ical+1
        allocate(
     &    caradex(nphener),caradey(nphener),caradez(nphener),
     &    caradbx(nphener),caradby(nphener),caradbz(nphener))
      endif

      caradex=aradex
      caradey=aradey
      caradez=aradez
      caradbx=aradbx
      caradby=aradby
      caradbz=aradbz

      call urad_e_b_field(
     &  -icharge,current,
     &  gammai,dgamtot,
     &  xelec,yelec,-zelec,vxelec,-vyelec,-vzelec,
     &  xf,-yf,-zf,efxn,-efyn,-efzn,
     &  xexit,yexit,zexit,vnxex,vnyex,vnzex,texit,ds,
     &  nthstep,nstep,ndim,traxyz,phase0,
     &  xobsv,yobsv,zobsv,phelow,phehig,
     &  nphener,phener,aradex,aradey,aradez,aradbx,aradby,aradbz,stokes,powden,
     &  ieneloss,ivelofield,
     &  istatus,ith,banwid,modewave
     &  )

      aradex=(caradex-aradex)/2.0d0
      aradey=(caradey-aradey)/2.0d0
      aradez=(caradez-aradez)/2.0d0

      return
      end
+DECK,urad_spline.
*CMZ :  4.01/04 23/12/2023  13.32.47  by  Michael Scheer
*CMZ :  4.01/02 14/05/2023  11.47.49  by  Michael Scheer
*CMZ :  4.01/00 22/02/2023  14.34.04  by  Michael Scheer
*CMZ :  4.00/17 05/12/2022  10.30.41  by  Michael Scheer
*CMZ :  4.00/16 17/09/2022  15.46.32  by  Michael Scheer
*CMZ :  4.00/15 02/06/2022  09.45.10  by  Michael Scheer
*CMZ :  4.00/11 28/06/2021  10.33.06  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine urad_spline(modewave)

      use omp_lib
      use uradphasemod

      implicit none

+seq,phyconparam.
+seq,track.
+seq,uservar.

      complex*16 cde
      double precision :: h2,ddist,wlen,dphi,phase0

      double complex , dimension (:,:,:), allocatable :: arad

      double precision, dimension (:), allocatable :: frq
      double precision, dimension (:,:), allocatable :: wsstokes,pow
      double precision, dimension (:,:,:), allocatable :: fbunch,stokes

      real, dimension (:), allocatable :: pherr,pherrc,phiran
      real, dimension(:,:), allocatable :: pranall,eall

      real eran(6),pran(2),rr(2)

      double complex :: apol,amp0(6),damp(6),amp(6),zexp,
     &  apolh,apolr,apoll,apol45,stokesv(4,3)

      double precision :: t,udgamtot,upow,vf0,vn,vx0,vx2,vxf0,vxi,vy0,vy2,vyf0,
     &  vyi,vz0,vz2,vzf0,vzi,wlen1,x0,x2,xf0,xi,xlell,y0,y2,yf0,yi,ypi,yy,yyp,
     &  z0,z2,zf0,zi,zpi,zz,zzp,fillb(41),stok1,stok2,stok3,stok4,speknor,
     &  sqnbunch,sqnphsp,specnor,sbnor,rpin,r00(3),
     &  r(3),r0(3),pw,ph,phsum,pkerr,pherror,ppin,parke,pc(3),pcbrill(3),om1,
     &  park,pr,hbarev,obs(3),om,fhigh,flow,gamma,eix,eiy,eiz,emassg,
     &  efx,efy,efz,eharm1,ecdipev,ebeam,dtpho,dt,dtelec,dd0,debeam,
     &  drn0(3),drn00(3),ds,dr0(3),dr00(3),drn(3),dpp,dph,dist,dist0,dobs(3),
     &  bunnor,clight,bunchx,beta,beff,spow,
     &  zp0,yp0,rph,
     &  xkellip,zampell,yampell,parkv,parkh,zpampell,ypampell,emom

      double complex, dimension (:), allocatable ::
     &  uampex,uampey,uampez,uampbx,uampby,uampbz
      double precision, dimension (:,:), allocatable :: utraxyz,ustokes

      integer :: kfreq,iobsv,i,np2,nelec,mbunch,meinbunch,ibu,jbun,
     &  kran=6,icbrill,ilo,kobsv,i1,i2,n,
     &  ifail,ndimu,nstepu,ith,noespread,noemit,jbunch,jubunch,jhbunch,
     &  jcharge=-1,lmodeph,nclo,jeneloss=0,iamppin,
     &  iamppincirc=0,ifrob,iobfr,isub,jvelofield=0,nlbu=0,nepho,ielo,
     &  modewave,nlpoiu

      integer, dimension (:), allocatable :: lnbunch

      integer :: idebug=0, lbunch=0, ierr=0, ielec=0
      integer ibunch,ihbunch,mthreads,nobsv,iemit,noranone,iz,iy,nobsvz,nobsvy
      integer iobm,iobp,iobfrm,iobfrp,iuser

      iuser=user(3)

      nelec_u=max(1,nelec_u)
      mthreads_u=max(1,mthreads_u)
      nelec=nelec_u

      nobsvy=npiny_u
      nobsvz=npinz_u

      if (nelec_u.gt.1) then
        if (nelec_u.lt.mthreads_u.and.nelec_u.gt.1) then
          mthreads_u=nelec_u
        else
          nelec_u=max(mthreads_u,nelec_u/mthreads_u*mthreads_u)
        endif
      endif

      noranone=noranone_u

      if (nelec_u.ne.nelec) then
        print*,''
        print*,'--- Warning in urad_spline: Nelec adjusted to multiple of number of threads:',nelec_u
        print*,''
      endif

      if (nelec_u.eq.1) then
        ibunch=0
      else
        ibunch=1
      endif

      ihbunch=ihbunch_u
      mthreads=mthreads_u

      if (modepin_u.eq.1) then
        iamppin=3
        nobsv=1
      else
        iamppin=1
        nobsv=npiny_u*npinz_u
      endif

      icbrill=nobsv/2+1

      jhbunch=max(0,ihbunch)
      meinbunch=nelec_u

      lbunch=0

      if (jhbunch.ne.0) then
        jhbunch=max(1,jhbunch)
      endif

      nepho=nepho_u

      nlbu=0
      if (ihbunch.gt.0) then
        lbunch=nelec_u/ihbunch
        nlbu=lbunch*nepho_u
        allocate(fbunch(41,nlbu,mthreads_u),stat=ierr)
        if (ierr.ne.0) then
          lbunch=0
          print*,""
          print*,"*** Warning in urad_spline: Could not allocate buffer for beam Ntuple ***"
          print*,"*** Maybe increase IHBUNCH ***"
          print*,""
          return
        endif
        fbunch=0.0d0
        allocate(lnbunch(mthreads_u), stat=ierr)
        if (ierr.ne.0) then
          print*,""
          print*,"*** Warning in urad_spline: Could not allocate buffer for nlbunch ***"
          print*,""
          return
        endif
        lnbunch=0
      endif

      call urad_field_ini(perlen_u,shift_u,beffv_u,beffh_u,modewave)

      if (perlen_u.ne.0.0d0) then
        emom=emasse1*dsqrt((gamma_u-1.0d0)*(gamma_u+1.0d0))
c*** OBSOLITE, SEE z0= further down
        xkellip=twopi1/perlen_u
        zampell=beffv_u*clight1/emom/xkellip**2
        yampell=beffh_u*clight1/emom/xkellip**2
c        zampell=zmx
c        yampell=ymx
        parkh=echarge1*dabs(beffh_u)*perlen_u/(twopi1*emasskg1*clight1)
        parkv=echarge1*dabs(beffv_u)*perlen_u/(twopi1*emasskg1*clight1)
        zpampell=parkv/gamma_u
c        print*,zpampell
c        ypampell=parkh/gamma_u
c        zpampell=tan(phimx)
c        print*,zpampell
c        stop
      else
        print*,''
        print*,'*** Error in urad_spline: Zero period-length of undulator ***'
        print*,''
        stop
      endif

      x0=-perlen_u*dble(nper_u)/2.0d0

      beta=dsqrt((1.0d0-1.0d0/gamma_u)*(1.0d0+1.0d0/gamma_u))

      clight=clight1
      hbarev=hbarev1
      ecdipev=ecdipev1
      emassg=emassg1

      if (modewave.eq.0) then
        z0=-zampell*cos(shift_u/2.0d0/perlen_u*twopi1)
        zp0=zpampell*sin(shift_u/2.0d0/perlen_u*twopi1)
        y0=-yampell*cos(shift_u/2.0d0/perlen_u*twopi1)
        yp0=-ypampell*sin(shift_u/2.0d0/perlen_u*twopi1)
      else
        y0=ytrack
        z0=ztrack
        zp0=vztrack/vxtrack
        yp0=vytrack/vxtrack
      endif

      xf0=-x0
      yf0=y0
      zf0=z0

      vn=clight*beta

      vx0=vn/sqrt(1.0d0+(zp0**2+yp0**2))
      vy0=vn*yp0
      vz0=vn*zp0

      vxf0=vx0
      vyf0=vy0
      vzf0=vz0

      vxi=vx0
      vyi=vy0
      vzi=vz0

      vf0=norm2([vxf0,vyf0,vzf0])
      efx=vxf0/vf0
      efy=vyf0/vf0
      efz=vzf0/vf0

      nclo=nint(2.0d0*x0/step_u)+1

      ds=step_u
c      dtim0=ds/beta

      ndimu=nclo
      nlpoiu=nlpoi_u

      allocate(frq(nepho_u),
     &  uampex(nepho_u),uampey(nepho_u),uampez(nepho_u),
     &  uampbx(nepho_u),uampby(nepho_u),uampbz(nepho_u),pow(nobsv,mthreads),
     &  utraxyz(14,nlpoiu),ustokes(4,nepho_u))

      pow=0.0d0
      frq=epho_u

      flow=frq(1)
      fhigh=frq(nepho_u)

      beff=sqrt(beffv_u**2+beffh_u**2)
      park=echarge1*beff*perlen_u/(2.*pi1*emasskg1*clight)
      wlen1=(1+park**2/2.)/2./gamma_u**2*perlen_u*1.0d9

      if (wlen1.ne.0.0) then
        eharm1=wtoe1/wlen1
      else
        eharm1=0.0d0
      endif

      allocate(pherrc(nper_u),pherr(nper_u),arad(6,nepho_u*nobsv,mthreads),
     &  phiran(max(1,nelec_u)))

      allocate(pranall(2,nelec_u))
      do i=1,nelec_u
        call util_random(2,pran)
        pranall(:,i)=pran
      enddo

      if (ibunch.eq.0.or.
     &    emith_u.eq.0.0d0.and.emitv_u.eq.0.0d0.and.espread_u.eq.0.0d0) then
        iemit=0
      else
        iemit=1
      endif

      if (iemit.ne.0) then
        allocate(eall(6,nelec_u))
        do i=1,nelec_u
          xi=x0
          call util_get_electron(xbeta_u,betah_u,alphah_u,betav_u,alphav_u,
     &      emith_u,emitv_u,
     &      disph_u,dispph_u,dispv_u,disppv_u,
     &      espread_u,bunchlen_u,xi,yi,zi,ypi,zpi,dpp,modebunch_u)
          eall(1,i)=xi-x0
          eall(2,i)=yi
          eall(3,i)=zi
          eall(4,i)=ypi
          eall(5,i)=zpi
          eall(6,i)=dpp
        enddo
        if (noranone.ne.0) eall(:,1)=0.0
      endif

      !allocate(affe(6,nepho_u*nobsv))

      allocate(wsstokes(4,nepho_u*nobsv),stokes(4,nepho_u*nobsv,mthreads))
      stokes=0.0d0
      arad=(0.0d0,0.0d0)

      np2=nper_u/2

      call util_random_gauss_omp(nper_u,pherr,rr)
      pherrc=pherr

      lmodeph=modeph_u

      if (pherror.ne.0.0d0.and.(lmodeph.lt.0.or.lmodeph.gt.2)) then
        write(6,*) ""
        write(6,*) "*** Error in urad_spline: MODEPH must be 0,1, or 2 ***"
        write(6,*) "*** Program aborted ***"
      endif

      if (lmodeph.eq.0.and.eharm1.ne.0.0d0) then
        om1=eharm1/hbarev
        pherr=sngl(pherrc*pherror/360.0d0*twopi1/om1)
      else if (lmodeph.eq.1) then
        pherr=sngl(pherr*pherror)
      else if (lmodeph.eq.2) then
        pherr(nper_u)=0.0
        phsum=0.0d0
        do i=1,nper_u-1
          pherr(i)=pherr(i)+pherrc(i)
          pherr(i+1)=pherr(i+1)-pherrc(i)
          phsum=phsum+pherr(i)
        enddo
        phsum=phsum+pherr(nper_u)
      else
        pherr=0.0d0
      endif !(lmodeph.eq.0)

      mbunch=max(1,nelec_u)
      nelec=nelec_u

      if (ibunch.ne.0.and.bunchcharge_u.ne.0.0d0) then
        sqnbunch=mbunch
        sqnphsp=sqrt(bunchcharge_u/echarge1)
     &    *meinbunch
     &    /(bunchcharge_u/echarge1)
        bunnor=1.0d0/mbunch
      else
        sqnbunch=mbunch
        sqnphsp=sqrt(dble(nelec_u))
        bunnor=1.0d0/mbunch
      endif

      beff=sqrt(beffv_u**2+beffh_u**2)
      parke=echarge1*beff*perlen_u/(2.*pi1*emasskg1*clight)
      xlell=perlen_u

      ielec=0

      pow=0.0d0
      noemit=0
      noespread=0
      jbunch=ibunch
      jubunch=0
      ebeam=ebeam_u
      debeam=espread_u
      stokesv=vstokes
      specnor=
     &  banwid_u
     &  /(4.0d0*pi1**2*clight*hbarev)
     &  /(4.0d0*pi1*eps01)
     &  *curr_u
      sbnor=specnor*bunnor
      speknor=specnor
      jeneloss=0
      pw=pinw_u
      ph=pinh_u
      !pr=pinr
      pc=pincen_u
      do iobsv=1,nobsv
        if (abs(obsv_u(2,iobsv)).lt.1.0d-9) obsv_u(2,iobsv)=0.0d0
        if (abs(obsv_u(3,iobsv)).lt.1.0d-9) obsv_u(3,iobsv)=0.0d0
      enddo
      pcbrill=obsv_u(:,icbrill)

!$OMP PARALLEL NUM_THREADS(mthreads) DEFAULT(PRIVATE)
!$OMP& FIRSTPRIVATE(nepho,nobsvz,nobsvy,nobsv,nelec,frq,nper_u,np2,perlen_u,clight,hbarev,flow,fhigh,
!$OMP& x0,y0,z0,xf0,yf0,zf0,vx0,vy0,vz0,vxf0,vyf0,vzf0,gamma_u,sbnor,speknor,
!$OMP& efx,efy,efz,ds,ndimu,nlpoiu,curr_u,xlell,parke,amp,amp0,
!$OMP& uampex,uampey,uampez,uampbx,uampby,uampbz,
!$OMP& lmodeph,zp0,yp0,modewave,iuser,
!$OMP& jbunch,jubunch,jhbunch,noespread,noemit,ebeam,
!$OMP& stokesv,icbrill,obsv_u,emassg,debeam,dispv_u,disppv_u,
!$OMP& betah_u,alphah_u,betav_u,alphav_u,emith_u,emitv_u,disph_u,dispph_u,
!$OMP& pran,pranall,eall,fillb,r0,dr0,iamppin,iamppincirc,pc,phase0,pr,banwid_u,
!$OMP& pw,ph,idebug,pcbrill,wsstokes,vn,bunchlen_u,modebunch_u,icohere_u)
!$OMP& SHARED(mthreads,stokes,pherr,lbunch,lnbunch,
!$OMP& fbunch,jcharge,jeneloss,jvelofield,iemit,noranone,arad,pow)

      jbun=1
      isub=0
      iobsv=0
      ielo=0

!$OMP DO

      do ilo=1,nelec*nobsv

        wsstokes=0.0d0
        spow=0.0d0

        ith=OMP_GET_THREAD_NUM()+1

        iobsv=mod(ilo-1,nobsv)+1
        ibu=(ilo-1)/nobsv+1
        jbun=ibu

        iy=(iobsv-1)/nobsvz+1
        iz=mod(iobsv-1,nobsvz)+1

        !if (iz.gt.nobsvz/2+1) call til_break

        ielec=ibu

        xi=x0
        yi=y0
        zi=z0

        zpi=vz0/vx0
        ypi=vy0/vx0

        x2=xf0
        y2=yf0
        z2=zf0

        vx2=vxf0
        vy2=vyf0
        vz2=vzf0

        gamma=gamma_u

        dpp=0.0d0

        if (iemit.ne.0) then

          if (noranone.eq.0.or.ielec.ne.1) then

            bunchx=eall(1,ielec)

            xi=xi+bunchx
            yy=eall(2,ielec)
            zz=eall(3,ielec)

            yyp=eall(4,ielec)
            zzp=eall(5,ielec)

            dpp=eall(6,ielec)
            gamma=(1.0d0+dpp)*gamma_u

            ! assume beta(s)=beta0(s)+s**2/beta(0) and alpha0=-s/beta(0)
            ! and a drift transfer-matrix ((1,s),(1,0))

            zi=zz-x0*zzp !inverse transformation
            zpi=zzp

            yi=yy-x0*yyp
            ypi=yyp

            ! simple treatment of closed orbit, assume small angles

            zi=zi+z0
            zpi=zpi+zp0

            yi=yi+y0
            ypi=ypi+yp0

          else

            xi=x0
            yi=y0
            zi=z0
            ypi=yp0
            zpi=zp0

            bunchx=0.0d0

          endif

        else

          xi=x0
          yi=y0
          zi=z0
          ypi=yp0
          zpi=zp0

          bunchx=0.0d0

        endif !iemit

        t=bunchx/vn

        vn=clight*dsqrt((1.0d0-1.0d0/gamma)*(1.0d0+1.0d0/gamma))

        vxi=vn/sqrt(1.0d0+ypi**2+zpi**2)
        vyi=vxi*ypi
        vzi=vxi*zpi

        obs=obsv_u(1:3,iobsv)

        if (noranone.eq.0.or.ielec.ne.1.or.iobsv.ne.icbrill) then
          if (iamppin.eq.3) then
            !call util_random(2,pran)
            pran(:)=pranall(:,ielec)
            if (iamppincirc.eq.0) then
              obs(2)=pc(2)+(pran(1)-0.5)*pw
              obs(3)=pc(3)+(pran(2)-0.5)*ph
            else
              rpin=(pran(1)-0.5)*pr
              ppin=pran(2)*twopi1
              obs(2)=pc(2)+rpin*cos(ppin)
              obs(3)=pc(3)+rpin*sin(ppin)
            endif
          endif
        endif

        vn=norm2([vxi,vyi,vzi])
        eix=vxi/vn
        eiy=vyi/vn
        eiz=vzi/vn

        h2=((obs(2)-yi)**2+(obs(3)-zi)**2)/(obs(1)-xi)**2
        if (h2.lt.0.01) then
          rph=abs(obs(1)-xi)*(1.0d0+(((((-0.0205078125D0*h2+0.02734375D0)*h2
     &      -0.0390625D0)*h2+0.0625D0)*h2-0.125D0)*h2+0.5D0)*h2)
        else
          rph=sqrt((obs(1)-xi)**2+((obs(2)-yi)**2+(obs(3)-zi)**2))
        endif

        phase0=(rph-(obsv_u(1,icbrill)-xi))/clight

        call urad_spline_obspoi(
     &    jcharge,curr_u,parke,nper_u,perlen_u,
     &    gamma,udgamtot,
     &    xi,yi,zi,vxi,vyi,vzi,
     &    xf0,yf0,zf0,efx,efy,efz,
     &    x2,y2,z2,vx2,vy2,vz2,dtelec,ds,
     &    nlpoiu,utraxyz,phase0,
     &    obs(1),obs(2),obs(3),flow,fhigh,
     &    nepho,frq,uampex,uampey,uampez,uampbx,uampby,uampbz,
     &    ustokes,upow,
     &    jeneloss,jvelofield,ifail,ith,banwid_u,modewave,iobsv)

        do kfreq=1,nepho

          iobfr=iobsv+nobsv*(kfreq-1)

          amp(1)=uampex(kfreq)*1.0d3/sqrt(speknor)
          amp(2)=uampey(kfreq)*1.0d3/sqrt(speknor)
          amp(3)=uampez(kfreq)*1.0d3/sqrt(speknor)
          amp(4)=uampbx(kfreq)*1.0d3/sqrt(speknor)
          amp(5)=uampby(kfreq)*1.0d3/sqrt(speknor)
          amp(6)=uampbz(kfreq)*1.0d3/sqrt(speknor)

          pow(iobsv,ith)=pow(iobsv,ith)+upow

          if (jhbunch.ne.0) then

            if (
     &          (iamppin.eq.3.or.iobsv.eq.icbrill)
     &          .and.mod(ielec,jhbunch).eq.0) then

              fillb(5)=r(1)
              fillb(6)=r(2)
              fillb(7)=r(3)
              fillb(8)=ypi
              fillb(9)=zpi
              fillb(10:12)=r
              fillb(13)=ypi
              fillb(14)=zpi
              fillb(30)=dreal(amp(1))
              fillb(31)=dimag(amp(1))
              fillb(32)=dreal(amp(2))
              fillb(33)=dimag(amp(2))
              fillb(34)=dreal(amp(3))
              fillb(35)=dimag(amp(3))
              fillb(36)=dreal(amp(4))
              fillb(37)=dimag(amp(4))
              fillb(38)=dreal(amp(5))
              fillb(39)=dimag(amp(5))
              fillb(40)=dreal(amp(6))
              fillb(41)=dimag(amp(6))

            endif

          endif

          apolh=
     &      amp(1)*conjg(stokesv(1,1))
     &      +amp(2)*conjg(stokesv(1,2))
     &      +amp(3)*conjg(stokesv(1,3))

          apolr=
     &      amp(1)*conjg(stokesv(2,1))
     &      +amp(2)*conjg(stokesv(2,2))
     &      +amp(3)*conjg(stokesv(2,3))

          apoll=
     &      amp(1)*conjg(stokesv(3,1))
     &      +amp(2)*conjg(stokesv(3,2))
     &      +amp(3)*conjg(stokesv(3,3))

          apol45=
     &      amp(1)*conjg(stokesv(4,1))
     &      +amp(2)*conjg(stokesv(4,2))
     &      +amp(3)*conjg(stokesv(4,3))

          stok1=dreal(apolr*conjg(apolr)+apoll*conjg(apoll))
          stok2=dreal(-stok1+2.0d0*apolh*conjg(apolh))
          stok3=dreal(2.0d0*apol45*conjg(apol45)-stok1)
          stok4=dreal(apolr*conjg(apolr)-apoll*conjg(apoll))

          wsstokes(1,iobfr)=wsstokes(1,iobfr)+stok1*sbnor
          wsstokes(2,iobfr)=wsstokes(2,iobfr)+stok2*sbnor
          wsstokes(3,iobfr)=wsstokes(3,iobfr)+stok3*sbnor
          wsstokes(4,iobfr)=wsstokes(4,iobfr)+stok4*sbnor

          stokes(1:4,iobfr,ith)=stokes(1:4,iobfr,ith)+wsstokes(1:4,iobfr)

          arad(:,iobfr,ith)=arad(:,iobfr,ith)+amp

          if (jhbunch.ne.0) then

            if (
     &          (iamppin.eq.3.or.iobsv.eq.icbrill)
     &          .and.mod(ielec,jhbunch).eq.0) then

              fillb(1)=jbun
              fillb(2)=isub
              fillb(3)=ibu
              fillb(4)=bunchx
              fillb(15)=gamma*emassg
              fillb(16)=udgamtot*emassg
              fillb(17)=obs(1)
              fillb(18)=obs(2)
              fillb(19)=obs(3)
              fillb(20)=kfreq
              fillb(21)=frq(kfreq)

              fillb(22)=wsstokes(1,iobfr)*nelec

              fillb(23)=wsstokes(1,iobfr)*nelec
              fillb(24)=wsstokes(2,iobfr)*nelec
              fillb(25)=wsstokes(3,iobfr)*nelec
              fillb(26)=wsstokes(4,iobfr)*nelec

              fillb(27)=spow
              fillb(28)=1
              fillb(29)=dtelec

              fillb(30)=dreal(amp(1))
              fillb(31)=dimag(amp(1))
              fillb(32)=dreal(amp(2))
              fillb(33)=dimag(amp(2))
              fillb(34)=dreal(amp(3))
              fillb(35)=dimag(amp(3))
              fillb(36)=dreal(amp(4))
              fillb(37)=dimag(amp(4))
              fillb(38)=dreal(amp(5))
              fillb(39)=dimag(amp(5))
              fillb(40)=dreal(amp(6))
              fillb(41)=dimag(amp(6))

              if (lbunch.ne.0) then
                lnbunch(ith)=lnbunch(ith)+1
                fbunch(:,lnbunch(ith),ith)=fillb(:)
              endif

            endif !fill

          endif !jhbunch

        enddo !nfreq

      enddo !nbunch

!$OMP END DO
!$OMP END PARALLEL

      do ith=1,mthreads
        pow_u(:)=pow_u(:)+pow(:,ith)
        arad_u(:,:)=arad_u(:,:)+arad(:,:,ith)
      enddo

      pow_u=pow_u/sqnbunch

      if (icohere_u.eq.0) then

        arad_u=arad_u/sqnbunch

        do ith=1,mthreads
          stokes_u(:,:)=stokes_u(:,:)+stokes(:,:,ith)
        enddo

      else

        do iobsv=1,nobsv
          do kfreq=1,nepho

            iobfr=iobsv+nobsv*(kfreq-1)

            amp(1:3)=arad_u(1:3,iobfr) !/sqnphsp

            apolh=
     &        amp(1)*conjg(stokesv(1,1))
     &        +amp(2)*conjg(stokesv(1,2))
     &        +amp(3)*conjg(stokesv(1,3))

            apolr=
     &        amp(1)*conjg(stokesv(2,1))
     &        +amp(2)*conjg(stokesv(2,2))
     &        +amp(3)*conjg(stokesv(2,3))

            apoll=
     &        amp(1)*conjg(stokesv(3,1))
     &        +amp(2)*conjg(stokesv(3,2))
     &        +amp(3)*conjg(stokesv(3,3))

            apol45=
     &        amp(1)*conjg(stokesv(4,1))
     &        +amp(2)*conjg(stokesv(4,2))
     &        +amp(3)*conjg(stokesv(4,3))

            stok1=dreal(apolr*conjg(apolr)+apoll*conjg(apoll))
            stok2=dreal(-stok1+2.0d0*apolh*conjg(apolh))
            stok3=dreal(2.0d0*apol45*conjg(apol45)-stok1)
            stok4=dreal(apolr*conjg(apolr)-apoll*conjg(apoll))

            stokes_u(1,iobfr)=stok1*sbnor
            stokes_u(2,iobfr)=stok2*sbnor
            stokes_u(3,iobfr)=stok3*sbnor
            stokes_u(4,iobfr)=stok4*sbnor

          enddo
        enddo

      endif !icohere_u

      if (ihbunch.ne.0) then
        n=0
        do i=1,nlbu
          do ith=1,mthreads_u
            if (fbunch(21,i,ith).ne.0.0d0) then
              n=n+1
              fbunch_u(:,n)=fbunch(:,i,ith)
            endif
          enddo
        enddo
        deallocate(fbunch)
      endif

      !deallocate(affe)
      deallocate(frq,uampex,uampey,uampez,uampbx,uampby,uampbz,utraxyz,
     &  pherrc,pherr,phiran,arad,pow,pranall,wsstokes,stokes)

      if (iemit.ne.0) deallocate(eall)

      return
      end
+DECK,urad_spline_alt.
*CMZ :  4.01/04 09/12/2023  14.20.32  by  Michael Scheer
*-- Author :    Michael Scheer   02/12/2023
      subroutine urad_spline_alt(park,perl,nper,gam)
      implicit none

+seq,cmpara.
+seq,observ.
+seq,freqs.
+seq,uservar.
+seq,phycon.

      double complex :: ay,az,zi=(0.0d0,1.0d0),expom

      double precision park,perl,gam,beta0,betx,bety,betz,om,wlen1,eharm1,
     &  tharm1,tperl,Tu,zp,t,dt,tk,x,y,z,s,xk,xkx,x0,dx,v0,obs(3),yp,
     &  rnnb(3),rnx,rny,rnz,r,azr,azi,ayr,ayi,eyr,eyi,ezr,ezi,h2

      double precision amp(5,10000),dtdx(10000),
     &  tspl(10000),aspl(10000),y2p(10000),
     &  w1(10000),
     &  w2(10000),
     &  w3(10000),
     &  w5(10000),
     &  w4(10000)

      integer nper,nx,ix,luno,luna,ifr,ifail,k

      open(newunit=luno,file='urad_spline.out',recl=1024)
      open(newunit=luna,file='urad_spline.amp',recl=1024)

      nx=max(4,int(user(10)))
      x0=user(11)
      !iobsv=max(1,int(user(12)))
      obs(1)=100.0d0
      obs(2)=0.0d0
      obs(3)=0.0d0

      beta0=dsqrt((1.0d0-1.0d0/gam)*(1.0d0+1.0d0/gam))
      v0=beta0*clight1

      wlen1=(1.0d0+park**2/2.0d0)/2.0d0/gam**2*perl*1.0d9
      eharm1=wtoe1/wlen1
      tharm1=wlen1/clight1

      Tu=(perl+wlen1)/clight1
      tk=twopi1/Tu

      xk=twopi1/perl

      dt=Tu/(nx-1)
      t=-dt
      dx=perl/(nx-1)
      yp=0.0d0

      do ifr=1,nfreq
        om=freq(ifr)/hbarev1
        do k=1,4
          x=x0-dx
          do ix=1,nx

            x=x+dx
            xkx=xk*x

            z=park/gam/xk*cos(xkx)
            zp=-park/gam*sin(xkx)

            s=(4.0d0*gam**2*xk*(x-x0)+park**2*xk*(x-x0)-park**2*sin(2.0d0*xk*(x-x0)))/(4.0d0*gam**2*xk)

            t=s/v0
            dtdx(ix)=(1.0d0+zp**2/2.0d0)/v0

            betx=1.0d0/dtdx(ix)/clight1
            bety=beta0*yp
            betz=beta0*zp

            rnx=obs(1)-x
            rny=0.0d0
            rnz=obs(3)-z

            h2=(rny*rny+rnz*rnz)/(rnx*rnx)

            if(h2.lt.0.01) then
              r=rnx*(1.0d0+(((((-0.0205078125D0*h2+0.02734375D0)*h2
     &          -0.0390625D0)*h2+0.0625D0)*h2-0.125D0)*h2+0.5D0)*h2)
            else
              r=sqrt(rnx**2+rny**2+rnz**2)
            endif

            rnx=rnx/r
            rny=rny/r
            rnz=rnz/r

            rnnb(1)=rny*(rnx*bety-rny*betx)-rnz*(rnz*betx-rnx*betz)
            rnnb(2)=rnz*(rny*betz-rnz*bety)-rnx*(rnx*bety-rny*betx)
            rnnb(3)=rnx*(rnz*betx-rnx*betz)-rny*(rny*betz-rnz*bety)

            amp(1:3,ix)=rnnb(1:3)
            amp(4,ix)=t-(rnx*x+rny*y+rnz*z)/clight1
            amp(5,ix)=t

            expom=cdexp(zi*om*amp(4,ix))

            ayr=dreal(rnnb(2)*expom)/r*om
            ayi=dimag(rnnb(2)*expom)/r*om
            azr=dreal(rnnb(3)*expom)/r*om
            azi=dimag(rnnb(3)*expom)/r*om

            if (ifr.eq.1.and.k.eq.3) then
              write(luno,*)ix,x,z,zp,s,t,dtdx(ix),betx,betz,r,rnx,rny,rnz,
     &          amp(1:4,ix),om,azr,azi
c              write(6,*)ix,x,z,zp,s,t,dtdx(ix),betx,betz,r,rnx,rny,rnz,
c    &          amp(1:4,ix),om
c              stop
            endif

            tspl(ix)=amp(5,ix)
            if (k.eq.1) then
              aspl(ix)=ayr
            else if (k.eq.2) then
              aspl(ix)=ayi
            else if (k.eq.3) then
              aspl(ix)=azr
            else if (k.eq.4) then
              aspl(ix)=azi
            endif
          enddo !nx

          call util_spline_coef_periodic(tspl,aspl,nx,y2p,w1,w2,w3,w4,w5,ifail)

          if (k.eq.1) then
            call util_spline_integral(tspl,aspl,nx,eyr,y2p,w1,w2,w3,w4)
          else if (k.eq.2) then
            call util_spline_integral(tspl,aspl,nx,eyi,y2p,w1,w2,w3,w4)
          else if (k.eq.3) then
            call util_spline_integral(tspl,aspl,nx,ezr,y2p,w1,w2,w3,w4)
          else if (k.eq.4) then
            call util_spline_integral(tspl,aspl,nx,ezi,y2p,w1,w2,w3,w4)
          endif
        enddo !k
        write(luna,*)ifr,freq(ifr),eyr,eyi,ezr,ezi,eyr**2+eyi**2+ezr**2+ezi**2

      enddo !nfreq

      flush(luno)
      close(luno)

      flush(luna)
      close(luna)

      stop '*** Ende in urad_spline ***'
      end
+DECK,urad_track,T=F77.
*CMZ :  4.01/04 12/12/2023  13.42.25  by  Michael Scheer
*CMZ :  4.01/02 12/05/2023  09.04.01  by  Michael Scheer
*CMZ :  4.01/00 22/02/2023  15.28.31  by  Michael Scheer
*CMZ :  4.00/15 28/04/2022  15.32.20  by  Michael Scheer
*CMZ :  4.00/13 16/11/2021  17.32.24  by  Michael Scheer
*CMZ :  4.00/09 15/08/2020  08.51.05  by  Michael Scheer
*CMZ :  3.05/05 10/07/2018  09.19.31  by  Michael Scheer
*CMZ :  3.05/04 05/07/2018  11.10.09  by  Michael Scheer
*CMZ :  3.05/00 27/04/2018  15.22.16  by  Michael Scheer
*CMZ :  3.03/04 13/10/2017  09.16.28  by  Michael Scheer
*CMZ :  3.03/02 19/11/2015  13.32.35  by  Michael Scheer
*CMZ :  3.02/04 13/03/2015  10.38.25  by  Michael Scheer
*CMZ :  2.69/02 02/11/2012  16.40.18  by  Michael Scheer
*CMZ :  2.68/05 04/09/2012  13.30.58  by  Michael Scheer
*CMZ :  2.68/04 03/09/2012  11.52.24  by  Michael Scheer
*CMZ :  2.68/03 31/08/2012  09.45.28  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine urad_track(
     &  icharge,
     &  gammai,dgamtot,
     &  xelec,yelec,zelec,vxelec,vyelec,vzelec,
     &  xf,yf,zf,efxn,efyn,efzn,
     &  xexit,yexit,zexit,vnxex,vnyex,vnzex,texit,ds,
     &  nstep,ndim,nthstep,traxyz,
     &  ieneloss,ivelofield,
     &  istatus,ith
     &  )
c123456789123456789_123456789_123456789_123456789_123456789_123456789_12
c Author: Michael Scheer, Michael.Scheer@Helmholtz-Berlin.de

c NO WARRANTY

+seq,gplhint.

      implicit none

      double precision
     &  gammai,dgamtot,dt2,powden,t,phase,phase0,
     &  xelec,yelec,zelec,vxelec,vyelec,vzelec,
     &  xexit,yexit,zexit,vnxex,vnyex,vnzex,texit,
     &  c,rspn
     &  ,traxyz(14,ndim),x1,y1,z1,vx1,vy1,
     &  vz1,x2,y2,z2,vx2,vy2,vz2
     &  ,ds,dtim,bshift,x2b,y2b,z2b,bx1,by1,bz1,bx2,by2,bz2
     &  ,dgamsum,gamma,dt
     &  ,vxp,vyp,vzp
     &  ,efx,efy,efz,xf,yf,zf,dist2
     &  ,dtim0,beta,vn,efx2,efy2,efz2,t1,t2,clight,c1,
     &  dgamma,vxsign,bx,by,bz,bpx,bpy,bpz,rarg(5),px,py,pz,
     &  dphase,r,rx,ry,rz,
     &  hbarev,echarge,eps0,pi,vsto,dph,
     &  r0,efxn,efyn,efzn

      integer ieneloss,istatus,icharge,nphener,ivelofield,
     &  nthstep,izaehl,nstep,ndim,kstep,lstep,kfreq,isto,ifail,ith,
     &  modewave

      integer :: idebug=0

      integer,save :: ical=0
+seq,uservar.


      data bshift/0.5d0/
      data clight/2.99792458d8/
      data hbarev/6.58211889D-16/
      data eps0/8.854187817D-12/
      data echarge/1.602176462D-19/
      data pi/3.14159265358979d0/

      ith=ith
      ical=ical+1

      if (idebug.ne.0) then
        print*,"Entered urad_track entered, ical:",ical
      endif

      istatus=0
      ifail=0
      if (icharge.le.0) icharge=-1
      if (icharge.gt.0) icharge=1

      vn=norm2([efxn,efyn,efzn])
      efx=efxn/vn
      efy=efyn/vn
      efz=efzn/vn

      x1=xelec
      y1=yelec
      z1=zelec
      vx1=vxelec
      vy1=vyelec
      vz1=vzelec
      t1=0.0d0

      gamma=gammai
      beta=dsqrt((1.d0-1.d0/gamma)*(1.d0+1.d0/gamma))
      vn=sqrt(vx1*vx1+vy1*vy1+vz1*vz1)
      vx1=vx1/vn*clight*beta
      vy1=vy1/vn*clight*beta
      vz1=vz1/vn*clight*beta
      vn=beta*clight

c vxsign takes care for the direction of flight, since particle must gain
c energy if tracked back

      if (vx1.lt.0) then
        vxsign=-1.0d0
      else
        vxsign=1.0d0
      endif

      dgamsum=0.0d0
      dgamtot=0.0d0

      dtim=ds/vn
      dt=dtim
      dt2=dtim*bshift
      dtim0=dtim

      x2=x1
      y2=y1
      z2=z1
      t2=t1

      vx2=vx1
      vy2=vy1
      vz2=vz1

      x2b=x1+vx1*dt2
      y2b=y1+vy1*dt2
      z2b=z1+vz1*dt2

      call uradfield_omp(x2b,y2b,z2b,bx2,by2,bz2,efx2,efy2,efz2,gamma,istatus,
     &  modewave)
      if (istatus.ne.0) ifail=ifail+abs(istatus)
      istatus=0

      vn=sqrt(vx2*vx2+vy2*vy2+vz2*vz2)

      if (gamma.le.0.0d0.or.vn.le.0.0d0) then
        istatus=-1
        return
      endif

      nstep=1
      kstep=1

      traxyz(1,kstep)=x2
      traxyz(2,kstep)=y2
      traxyz(3,kstep)=z2
      traxyz(4,kstep)=t2
      traxyz(5,kstep)=vx2/vn
      traxyz(6,kstep)=vy2/vn
      traxyz(7,kstep)=vz2/vn
      traxyz(8,kstep)=bx2
      traxyz(9,kstep)=by2
      traxyz(10,kstep)=bz2
      traxyz(11,kstep)=gamma
      traxyz(12,kstep)=efx2
      traxyz(13,kstep)=efy2
      traxyz(14,kstep)=efz2

      c=clight
      c1=1.0d0/clight

      lstep=0
      t=-dt

c--- Loop der Trajektorie

      izaehl=0
1000  continue

      izaehl=izaehl+1

      if (x2.ne.x2) then
        istatus=-99
        return
      endif

      if (lstep.eq.1) then
        dtim=abs(dist2)/vn
        dt=dtim
        dt2=dtim/2.0d0
      endif

      x1=x2
      y1=y2
      z1=z2

      t1=t2

      vx1=vx2
      vy1=vy2
      vz1=vz2

      bx1=bx2
      by1=by2
      bz1=bz2

      x2b=x1+vx1*dt2
      y2b=y1+vy1*dt2
      z2b=z1+vz1*dt2

      call uradfield_omp(x2b,y2b,z2b,bx2,by2,bz2,efx2,efy2,efz2,gamma,istatus,
     &  modewave)
      if (istatus.ne.0) ifail=ifail+abs(istatus)
      istatus=0

      call uradstep_omp(x1,y1,z1,vx1,vy1,vz1,bx2,by2,bz2,efx2,efy2,efz2,
     &  dtim,x2,y2,z2,vx2,vy2,vz2,vxp,vyp,vzp,gamma,icharge,ieneloss,
     &  dgamma)

      t2=t1+dtim

      if (ieneloss.ne.0) then
        dgamsum=dgamsum+vxsign*dgamma
        if (abs(dgamsum).gt.gamma*1.0d-8) then
          gamma=gamma+dgamsum
          dgamtot=dgamtot+dgamsum
          dgamsum=0.0d0
        endif
        beta=dsqrt((1.d0-1.d0/gamma)*(1.d0+1.d0/gamma))
        vn=sqrt(vx2*vx2+vy2*vy2+vz2*vz2)
        vx2=vx2/vn*clight*beta
        vy2=vy2/vn*clight*beta
        vz2=vz2/vn*clight*beta
      endif

c ef is normal vector of perpendiculare plane at the end of the reference orbit
c dist is distance of electron to this plane
c tracking stops if trajectory hits this plane

      dist2=(x2-xf)*efx+(y2-yf)*efy+(z2-zf)*efz

      if (lstep.eq.0.and.dist2.lt.0.0d0.and.dist2.gt.-2.0d0*ds)  then

        lstep=1
        goto 1000

      else

        nstep=nstep+1

        if (mod(nstep,nthstep).eq.1.or.lstep.eq.1.or.nthstep.eq.1) then

          kstep=kstep+1

          if (kstep.gt.ndim) then
            nstep=nstep-1
            istatus=-2
            goto 9000
          endif

          traxyz(1,kstep)=x2
          traxyz(2,kstep)=y2
          traxyz(3,kstep)=z2
          traxyz(4,kstep)=t2
          traxyz(5,kstep)=vx2/vn
          traxyz(6,kstep)=vy2/vn
          traxyz(7,kstep)=vz2/vn
          traxyz(8,kstep)=bx2
          traxyz(9,kstep)=by2
          traxyz(10,kstep)=bz2
          traxyz(11,kstep)=gamma
          traxyz(12,kstep)=efx2
          traxyz(13,kstep)=efy2
          traxyz(14,kstep)=efz2

        endif

        if (lstep.eq.1) goto 9000
        goto 1000

      endif !lstep and dist2

9000  continue

      xexit=x2
      yexit=y2
      zexit=z2

      vn=sqrt(vx2*vx2+vy2*vy2+vz2*vz2)
      vnxex=vx2/vn
      vnyex=vy2/vn
      vnzex=vz2/vn

      texit=t2

      if (idebug.ne.0) then
        print*,"Leaving urad_track"
      endif

      return
      end
+DECK,urad_spline_obspoi.
*CMZ :          30/12/2023  16.11.21  by  Michael Scheer
*CMZ :  4.01/04 28/12/2023  09.53.09  by  Michael Scheer
*-- Author :    Michael Scheer   02/12/2023
      subroutine urad_spline_obspoi(
     &  icharge,current,park,nper,perl,
     &  gammai,dgamtot,
     &  xelec,yelec,zelec,vxelec,vyelec,vzelec,
     &  xf,yf,zf,efxn,efyn,efzn,
     &  xexit,yexit,zexit,vnxex,vnyex,vnzex,texit,dsi,
     &  nlpoi,traxyz,phase0,
     &  xobsv,yobsv,zobsv,phelow,phehig,
     &  nphener,phener,aradex,aradey,aradez,aradbx,aradby,aradbz,stokes,powden,
     &  ieneloss,ivelofield,
     &  istatus,ith,banwid,modewave,iobsv
     &  )
      implicit none

      double complex :: ay,az,zi=(0.0d0,1.0d0),expom,
     &  aradex(nphener),aradey(nphener),aradez(nphener),
     &  aradbx(nphener),aradby(nphener),aradbz(nphener),
     &  apolh,apolr,apoll,apol45,
     &  ampex,ampey,ampez,ampbx,ampby,ampbz,
     &  zone=(1.0d0,0.0d0)

      double precision
     &  current,gammai,dgamtot,charge,
     &  xelec,yelec,zelec,vxelec,vyelec,vzelec,
     &  xf,yf,zf,efxn,efyn,efzn,
     &  xexit,yexit,zexit,vnxex,vnyex,vnzex,texit,ds,dsi,
     &  phase0,xobsv,yobsv,zobsv,phelow,phehig,
     &  phener(nphener),stok1,stok2,stok3,stok4,
     &  stokes(4,nphener),powden,
     &  banwid,pownor,rspn,specnor,yp1,ypn,
     &  b3,bet1n,bpx,bpy,bpz,br2,br4,dom1,dom2,dphase,dum11,dum3,gamma,perl

      integer :: modewave,kfreq,nlpoi,nallo=0,iobsv,i,
     &  icharge,nthstep,nstep,ieneloss,ivelofield,istatus,ith,nphener

      double precision :: park,xlen,beta,betx,bety,betz,om,wlen1,eharm1,
     &  tharm1,txlen,Tu,tdev,zp,t,dt,dt2,tk,x,y,z,s,xk,xkx,dx,v0,yp,dom,
     &  rnnb(3),rnx,rny,rnz,r,azr,azi,ayr,ayi,eyr,eyi,ezr,ezi,h2,dum,phase,
     &  px,py,pz,r1,rnbx,rnby,rnbz,rn2,rn4,rx,ry,rz,vx2,vy2,vz2,vxp,vyp,vzp,
     &  x2,y2,z2,rarg5(5),rnr2,rnr4,vx12,vy12,vz12,acc,bx,by,bz,
     &  ct,st,betz0,zamp

      double precision traxyz(14,nlpoi)
      double complex, dimension (:,:), allocatable :: expo
      double precision, dimension (:,:), allocatable :: amp
      double precision, dimension (:,:), allocatable :: rarg
      double precision, dimension (:), allocatable ::
     &  tspl,ayrspl,ayispl,azrspl,azispl,w1,w2,w3,w4,w5,y2p

      integer :: nper,nx,ix,kx,luno,luna,ifr,ifail,k,idebug=0,ical=0

      save

+seq,cmpara.
+seq,observ.
c+seq,freqs.
+seq,uservar.
+seq,phyconparam.

      ical=ical+1

      if (idebug.ne.0) then
c        print*,"Entered urad_spline_obspoi, ical:",ical,idebug
      endif

      if (idebug.gt.1.and.yobsv.eq.0.0d0.and.zobsv.eq.0.0d0) then
        open(newunit=luno,file='urad_spline.out',recl=1024)
        open(newunit=luna,file='urad_spline.amp',recl=1024)
      endif

      aradex=dcmplx((0.0d0,0.0d0))

      gamma=gammai
      beta=dsqrt((1.0d0-1.0d0/gammai)*(1.0d0+1.0d0/gammai))
      v0=beta*clight1

      xlen=xf-xelec
      wlen1=(1.0d0+park**2/2.0d0)/2.0d0/gammai**2*xlen
      eharm1=wtoe1/(wlen1*1.0d9)
      tharm1=wlen1/clight1

      tdev=(xlen+wlen1)/clight1
      tu=tdev/dble(nper)

      tk=twopi1/tu
      xk=twopi1/perl

      k=int(tdev/(dsi/v0))+1
      nthstep=k/(nlpoi-1)
      nx=nthstep*(nlpoi-1)
      nx=max(nx,nlpoi)

      if (mod(nx,nper).eq.0) then
        nlpoi=nlpoi-1
        nthstep=k/(nlpoi-1)
        nx=nthstep*(nlpoi-1)
        nx=max(nx,nlpoi)
      endif

      ds=xlen/dble(nx)
      dt=tdev/dble(nx)
      ds=dt*v0
      dx=xlen/dble(nx)

      yp=0.0d0

c      print*,nlpoi,nallo
      if (nlpoi.gt.nallo) then
        if (nallo.gt.0) then
          deallocate(tspl,ayrspl,ayispl,azrspl,azispl,w1,w2,w3,w4,w5,y2p,
     &      rarg,expo)
        endif
        allocate(amp(5,nlpoi),tspl(nlpoi),rarg(5,nlpoi),expo(2,nlpoi),
     &    ayrspl(nlpoi),ayispl(nlpoi),azrspl(nlpoi),azispl(nlpoi),
     &    w1(nlpoi),w2(nlpoi),w3(nlpoi),w4(nlpoi),w5(nlpoi),y2p(nlpoi))
        nallo=nlpoi
      endif

c      print*,'zmax:',za

      specnor=
     &  banwid
     &  /(4.0d0*pi1**2*clight1*hbarev1)
     &  /(4.0d0*pi1*eps01)
     &  *current/1.0d6 !per mm**2

      pownor=echarge1/16.0d0/pi1/pi1/eps01/clight1*current/1.0d6 !W/mm**2

      rspn=sqrt(specnor)

      if (idebug.ne.0) then
c        print*,"Calling urad_track"
      endif

      if (iobsv.eq.1) then
c        if (userchar(1).ne.'Ana') then
          call urad_track(
     &      icharge,
     &      gammai,dgamtot,
     &      xelec,yelec,zelec,vxelec,vyelec,vzelec,
     &      xf,yf,zf,efxn,efyn,efzn,
     &      xexit,yexit,zexit,vnxex,vnyex,vnzex,texit,ds,
     &      nstep,nlpoi,nthstep,traxyz,
     &      ieneloss,ivelofield,
     &      ifail,ith
     &      )
c        else
          dt=tdev/(nlpoi-1)
          dx=xlen/dble(nlpoi-1)
          betz0=park/gamma
          charge=dble(icharge)
c        endif
        if (nphener.gt.1) then
          dom=(phener(2)-phener(1))/hbarev1
        else
          dom=0.0d0
        endif
      endif !iobsv.eq.1

      ifr=0
      do ix=1,nlpoi

        if (userchar(1).ne.'Ana') then

          x=traxyz(1,ix)
          y=traxyz(2,ix)
          z=traxyz(3,ix)

          t=traxyz(4,ix)

          betx=traxyz(5,ix)*beta
          bety=traxyz(6,ix)*beta
          betz=traxyz(7,ix)*beta

        else

          dt=tdev/(nlpoi-1)
          t=dble(ix-1)*dt
c          t=traxyz(4,ix)
          st=sin(tk*t)
          ct=cos(tk*t)

          bety=0.0d0
          betz0=park/gamma*charge
          betz=betz0*st
          betx=beta*(1.0d0 - (betz/beta)**2/2.0d0 * (1.0d0+(betz/beta)**2/4.0d0))
          betx=beta*(1.0d0 - (betz/beta)**2/2.0d0)

          x=xelec+clight1*(
     &      2.0d0*ct*st*betz0**2*pi1*tu +
     &      4.0d0*beta**2*t-betz0**2*t)/4.0d0/beta
c          x=xelec+clight1*(
c     &      (4.0d0*ct*st**3*betz0**4*pi1*tu +
c     &      32.0d0*ct*st*beta**2*betz0**2*pi1*tu +
c     &      6.0d0*ct*st*betz0**4*pi1*tu +
c     &      64.0d0*beta**4*t-16.0d0*beta**2*betz0**2*t-3.0d0*betz0**4*t)/64.0d0/beta**3)
c          x=x*clight1+xelec
c          x=(x+xelec+t/tu*perl)/2.0d0
          y=0.0d0
          zamp=-betz0/tk*clight1
          z=zelec-zamp*ct
+self,if=p.
          x=dx*(ix-1)

          t=(xk**2*x*zamp**2+4.0d0*x+cos(xk*x)*sin(xk*x)*xk*zamp**2)/4.0d0/v0

          st=sin(tk*t)
          ct=cos(tk*t)

          x=xelec+x
          z=zelec-zamp*ct

          bety=0.0d0
          betz0=park/gamma*charge
          betz=betz0*st
c          betx=beta*(1.0d0 - (betz/beta)**2/2.0d0 * (1.0d0+(betz/beta)**2/4.0d0))
          betx=beta*(1.0d0 - (betz/beta)**2/2.0d0)
+self.
c          write(66,*)iobsv,ix,t,x,z,betx,betz,traxyz(1:4,ix),traxyz(5:7,ix)*beta

c          x=traxyz(1,ix)
c          y=traxyz(2,ix)
c          z=traxyz(3,ix)

c          t=traxyz(4,ix)

c          betx=traxyz(5,ix)*beta
c          bety=traxyz(6,ix)*beta
c          betz=traxyz(7,ix)*beta
        endif

        rnx=xobsv-x
        rny=yobsv-y
        rnz=zobsv-z

        h2=(rny*rny+rnz*rnz)/(rnx*rnx)

        if(h2.lt.0.01) then
          r=rnx*(1.0d0+(((((-0.0205078125D0*h2+0.02734375D0)*h2
     &      -0.0390625D0)*h2+0.0625D0)*h2-0.125D0)*h2+0.5D0)*h2)
        else
          r=sqrt(rnx**2+rny**2+rnz**2)
        endif

        rnx=rnx/r
        rny=rny/r
        rnz=rnz/r

        rarg(1,ix)=(rny*(rnx*bety-rny*betx)-rnz*(rnz*betx-rnx*betz))/r
        rarg(2,ix)=(rnz*(rny*betz-rnz*bety)-rnx*(rnx*bety-rny*betx))/r
        rarg(3,ix)=(rnx*(rnz*betx-rnx*betz)-rny*(rny*betz-rnz*bety))/r
        !phase0 noch unklar
        rarg(4,ix)=phase0+t-(rnx*x+rny*y+rnz*z)/clight1
        rarg(5,ix)=t

        tspl(ix)=t

      enddo !ix

      om=phener(1)/hbarev1-dom
      do ifr=1,nphener

        om=om+dom
        !om=phener(ifr)/hbarev1

        do ix=1,nlpoi

          rnnb(2:3)=rarg(2:3,ix)

          if (ifr.eq.1) then
            expo(1,ix)=cdexp(zi*om*rarg(4,ix))
            expo(2,ix)=cdexp(zi*dom*rarg(4,ix))
          else
            expo(1,ix)=expo(1,ix)*expo(2,ix)
          endif

          expom=expo(1,ix)
c          expom=cdexp(zi*om*rarg(4,ix))

          ayr=rnnb(2)*dreal(expom)
          ayi=rnnb(2)*dimag(expom)
          azr=rnnb(3)*dreal(expom)
          azi=rnnb(3)*dimag(expom)

          ayrspl(ix)=ayr
          ayispl(ix)=ayi
          azrspl(ix)=azr
          azispl(ix)=azi

          if (idebug.gt.1.and.yobsv.eq.0.0d0.and.zobsv.eq.0.0d0) then
            write(luno,*)ix,ifr,rarg(1:4,ix),om,tspl(ix),x,z,azr,azi
          endif

        enddo !nx

        eyr=0.0D0
        eyi=0.0D0
        ezr=0.0D0
        ezi=0.0D0

        if (user(7).eq.1) then

          do i=1,nlpoi-1
            dt2=(tspl(i+1)-tspl(i))/2.0d0
            eyr=eyr+dt2*(ayrspl(i)+ayrspl(i+1))
            eyi=eyi+dt2*(ayispl(i)+ayispl(i+1))
            ezr=ezr+dt2*(azrspl(i)+azrspl(i+1))
            ezi=ezi+dt2*(azispl(i)+azispl(i+1))
          enddo

        else if (user(7).eq.2) then

          yp1=9999.0d0
          ypn=9999.0d0

c          call util_spline_coef(tspl,ayrspl,nlpoi,yp1,ypn,y2p,w1,w2,w3,w4)
          do i=1,nlpoi-1
            dt=(tspl(i+1)-tspl(i))
            eyr=eyr
     &        +dt*0.5d0
     &        *(ayrspl(I)+ayrspl(I+1))
c     &        -dt**3/24.0d0
c     &        *(y2p(I)+y2p(I+1))
          enddo
c          call util_spline_coef(tspl,ayispl,nlpoi,yp1,ypn,y2p,w1,w2,w3,w4)
          do i=1,nlpoi-1
            dt=(tspl(i+1)-tspl(i))
            eyi=eyi
     &        +dt*0.5d0
     &        *(ayispl(I)+ayispl(I+1))
c     &        -dt**3/24.0d0
c     &        *(y2p(I)+y2p(I+1))
          enddo
c          call util_spline_coef(tspl,azrspl,nlpoi,yp1,ypn,y2p,w1,w2,w3,w4)
          do i=1,nlpoi-1
            dt=(tspl(i+1)-tspl(i))
            ezr=ezr
     &        +dt*0.5d0
     &        *(azrspl(I)+azrspl(I+1))
c     &        -dt**3/24.0d0
c     &        *(y2p(I)+y2p(I+1))
          enddo
c          call util_spline_coef(tspl,azispl,nlpoi,yp1,ypn,y2p,w1,w2,w3,w4)
          do i=1,nlpoi-1
            dt=(tspl(i+1)-tspl(i))
            ezi=ezi
     &        +dt*0.5d0
     &        *(azispl(I)+azispl(I+1))
c     &        -dt**3/24.0d0
c     &        *(y2p(I)+y2p(I+1))
          enddo

        else

          call util_spline_integral(tspl,ayrspl,nlpoi,eyr,y2p,w1,w2,w3,w4)
          call util_spline_integral(tspl,ayispl,nlpoi,eyi,y2p,w1,w2,w3,w4)
          call util_spline_integral(tspl,azrspl,nlpoi,ezr,y2p,w1,w2,w3,w4)
          call util_spline_integral(tspl,azispl,nlpoi,ezi,y2p,w1,w2,w3,w4)

        endif

        if (idebug.gt.1.and.yobsv.eq.0.0d0.and.zobsv.eq.0.0d0) then
          write(luna,*)ifr,phener(ifr),eyr,eyi,ezr,ezi,
     &      eyr**2+eyi**2+ezr**2+ezi**2
        endif

        aradey(ifr)=dcmplx((eyr),(eyi))*om
        aradez(ifr)=dcmplx((ezr),(ezi))*om

        enddo !nphener

      if (idebug.gt.1.and.yobsv.eq.0.0d0.and.zobsv.eq.0.0d0) then
        flush(luno)
        close(luno)
        flush(luna)
        close(luna)
      endif

      do kfreq=1,nphener

        aradex(kfreq)=aradex(kfreq)*rspn
        aradey(kfreq)=aradey(kfreq)*rspn
        aradez(kfreq)=aradez(kfreq)*rspn

        apolh=
     &    aradex(kfreq)*conjg(vstokes(1,1))
     &    +aradey(kfreq)*conjg(vstokes(1,2))
     &    +aradez(kfreq)*conjg(vstokes(1,3))

        apolr=
     &    aradex(kfreq)*conjg(vstokes(2,1))
     &    +aradey(kfreq)*conjg(vstokes(2,2))
     &    +aradez(kfreq)*conjg(vstokes(2,3))

        apoll=
     &    aradex(kfreq)*conjg(vstokes(3,1))
     &    +aradey(kfreq)*conjg(vstokes(3,2))
     &    +aradez(kfreq)*conjg(vstokes(3,3))

        apol45=
     &    aradex(kfreq)*conjg(vstokes(4,1))
     &    +aradey(kfreq)*conjg(vstokes(4,2))
     &    +aradez(kfreq)*conjg(vstokes(4,3))

        stok1=real(
     &    apolr*conjg(apolr)+
     &    apoll*conjg(apoll))

        stok2=-stok1+
     &    real(2.*apolh*conjg(apolh))

        stok3=
     &    real(2.*apol45*conjg(apol45))-
     &    stok1

        stok4=real(
     &    apolr*conjg(apolr)-
     &    apoll*conjg(apoll))

        stokes(1,kfreq)=stok1
        stokes(2,kfreq)=stok2
        stokes(3,kfreq)=stok3
        stokes(4,kfreq)=stok4

      enddo !nphener

      powden=powden*pownor

      if (idebug.ne.0) then
c        print*,"Leaving urad_spline_obspoi"
      endif
c+self.
      return
      end
+DECK,urad_phase_prop,T=F77.
*CMZ :          31/12/2023  14.57.58  by  Michael Scheer
*CMZ :  4.01/04 28/12/2023  15.30.57  by  Michael Scheer
*CMZ :  4.01/02 12/05/2023  17.13.05  by  Michael Scheer
*CMZ :  4.01/00 21/02/2023  16.51.29  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine urad_phase_prop(mthreads)

      use omp_lib
      use uradphasemod

      implicit none

      double complex, dimension(:), allocatable :: expom,dexpom,phshift

      double complex :: apolh,apolr,apoll,apol45

      double precision dx,dx2,dy,dyph,dzph,dz,y,z,omc,domc,phlowz,phlowy,dzy2,eps(6),
     &  dr,drred,da,x,xobs,yobs,zobs,rlambda1,ans,stok1,stok2,stok3,stok4

      integer mthreads,iy,iz,n,jy,jz,iobs,ieps,ifrq,iobfr,jobs,jobfr

+seq,phyconparam.
+seq,uservar.

      nobsvprop_u=npinyprop_u*npinzprop_u

      allocate(
     &  obsvprop_u(3,nobsvprop_u),stokesprop_u(4,nobsvprop_u*nepho_u),
     &  aradprop_u(6,nobsvprop_u*nepho_u),
     &  expom(nobsv_u*nepho_u),dexpom(nobsv_u*nepho_u),
     &  phshift(nobsv_u))

      aradprop_u=(0.0d0,0.0d0)

      if (npinyprop_u.gt.1) then
        dyph=pinhprop_u/1000.0d0/dble(npinyprop_u-1)
        phlowy=-pinhprop_u/2000.0d0
      else
        dyph=pinhprop_u/1000.0d0
        phlowy=-pinhprop_u/1000.0d0
      endif

      if (npinzprop_u.gt.1) then
        dzph=pinwprop_u/1000.0d0/dble(npinzprop_u-1)
        phlowz=-pinwprop_u/2000.0d0
      else
        dzph=pinwprop_u/1000.0d0
        phlowz=-pinwprop_u/1000.0d0
      endif

      da=pinw_u*pinh_u/dble(max(1,npinz_u-1)*max(1,npiny_u-1))

      n=0

      x=pinxprop_u/1000.0d0
      y=phlowy-dyph
      do iy=1,npinyprop_u
        y=y+dyph
        if (abs(y).lt.1.0d-12) y=0.0d0
        z=phlowz-dzph
        do iz=1,npinzprop_u
          n=n+1
          z=z+dzph
          if (abs(z).lt.1.0d-12) z=0.0d0
          obsvprop_u(1:3,n)=[x,y,z]
        enddo
      enddo

      omc=epho_u(1)/(hbarev1*clight1)
      if(nepho_u.gt.1) then
        domc=(epho_u(2)-epho_u(1))/(hbarev1*clight1)
      endif

!$OMP PARALLEL NUM_THREADS(mthreads) DEFAULT(PRIVATE)
!$OMP& SHARED(domc,omc,da,obsvprop_u,obsv_u,nobsv_u,nobsvprop_u,epho_u,nepho_u,aradprop_u,arad_u)

!$OMP DO

      do jobs=1,nobsvprop_u
c        ith=OMP_GET_THREAD_NUM()+1

        x=obsvprop_u(1,jobs)
        y=obsvprop_u(2,jobs)
        z=obsvprop_u(3,jobs)

        DO IOBS=1,NOBSV_u

          XOBS=OBSV_u(1,IOBS)/1000.0d0
          YOBS=OBSV_u(2,IOBS)/1000.0d0
          ZOBS=OBSV_u(3,IOBS)/1000.0d0

          dx=xobs-x
          dx2=dx*dx
          DY=YOBS-y
          DZ=ZOBS-z
          DZY2=DZ*DZ+DY*DY

C     TO MAKE SURE THAT TAYLOR-EXPANSION IS VALID

          IF (DZY2.GT.0.01D0*dx2) THEN
            WRITE(6,*)'*** ERROR IN URAD_PHASE_PROP ***'
            WRITE(6,*)'CHECK INPUT FILE AND INCREASE PinX'
            WRITE(6,*)'*** PROGRAM ABORTED ***'
            STOP
          ENDIF

          EPS(1)=DZY2/dx2
          DO IEPS=2,6
            EPS(IEPS)=EPS(IEPS-1)*EPS(1)
          ENDDO !IEPS

c      TAYLOR-EXPANSION DONE WITH REDUCE
c     IN "WTAY1.RED";
c     on rounded;
c     on numval;
c     precision 13;
c     F:=SQRT(1+EPS);
c     DR:=TAY1(F,EPS,6);
c     ON FORT;
c     OUT "RED.FOR";
c     DR;
c     SHUT "RED.FOR";
C ans is actually reduce by 1.0 to avoid large overall phase

          ans=-0.0205078125D0*eps(6)+0.02734375D0*eps(5)
     &      -0.0390625D0*eps(4)+
     &      0.0625D0*eps(3)-0.125D0*eps(2)+0.5D0*eps(1)

          DR=DABS(dx*(ANS+1.0D0))
          DRRED=-DABS(dx*ANS)

          IF (DR.NE.0.0d0) THEN
            EXPOM(IOBS)=CDEXP(DCMPLX(0.0d0,DRRED*OMC))/DR
          ELSE
            EXPOM(IOBS)=1.0D0
          ENDIF

          DEXPOM(IOBS)=CDEXP(DCMPLX(0.0d0,DRRED*DOMC))
c            print*,ith,iobs,expom(iobs)
c+seq,dum2.
        ENDDO   !NOBS

        DO ifrq=1,nepho_u

          jOBFR=jOBS+NOBSVprop_u*(ifrq-1)

          RLAMBDA1=epho_u(ifrq)/WTOE1*1.0D9   !1/lambda[m]=1/(wtoe1/freq*1.e-9)

          DO IOBS=1,NOBSV_u

            IOBFR=IOBS+NOBSV_u*(ifrq-1)

            IF (ifrq.EQ.1) THEN
              PHSHIFT(IOBS)=EXPOM(IOBFR)
            ELSE
              PHSHIFT(IOBS)=PHSHIFT(IOBS)*DEXPOM(IOBS)
            ENDIF   !(ifrq.EQ.1)

            if (dx.gt.0.0d0) then
              aradprop_u(1:3,jobfr)=aradprop_u(1:3,jobfr)+
     &          arad_u(1:3,iobfr)*PHSHIFT(IOBS)*da*rlambda1
              aradprop_u(4:6,jobfr)=aradprop_u(4:6,jobfr)+
     &          dconjg(arad_u(4:6,iobfr))*PHSHIFT(IOBS)*da*rlambda1
            else
              aradprop_u(1:3,jobfr)=aradprop_u(1:3,jobfr)+
     &          dconjg(arad_u(1:3,iobfr))*PHSHIFT(IOBS)*da*rlambda1
              aradprop_u(4:6,jobfr)=aradprop_u(4:6,jobfr)+
     &          arad_u(4:6,iobfr)*PHSHIFT(IOBS)*da*rlambda1
            endif
          ENDDO   !NFREQ

        ENDDO  !NOBSV

      ENDDO !nobsvprop_u

!$OMP END DO

!$OMP END PARALLEL

      do ifrq=1,nepho_u
        do jobs=1,nobsvprop_u

          jobfr=jobs+nobsvprop_u*(ifrq-1)

          apolh=
     &      aradprop_u(1,jobfr)*dconjg(vstokes(1,1))+
     &      aradprop_u(2,jobfr)*dconjg(vstokes(1,2))+
     &      aradprop_u(3,jobfr)*dconjg(vstokes(1,3))

          apolr=
     &      aradprop_u(1,jobfr)*dconjg(vstokes(2,1))+
     &      aradprop_u(2,jobfr)*dconjg(vstokes(2,2))+
     &      aradprop_u(3,jobfr)*dconjg(vstokes(2,3))

          apoll=
     &      aradprop_u(1,jobfr)*dconjg(vstokes(3,1))+
     &      aradprop_u(2,jobfr)*dconjg(vstokes(3,2))+
     &      aradprop_u(3,jobfr)*dconjg(vstokes(3,3))

          apol45=
     &      aradprop_u(1,jobfr)*dconjg(vstokes(4,1))+
     &      aradprop_u(2,jobfr)*dconjg(vstokes(4,2))+
     &      aradprop_u(3,jobfr)*dconjg(vstokes(4,3))

          stok1=dreal(
     &      apolr*conjg(apolr)+
     &      apoll*conjg(apoll))

          stok2=-stok1+
     &      dreal(2.*apolh*conjg(apolh))

          stok3=
     &      dreal(2.*apol45*conjg(apol45))-
     &      stok1

          stok4=dreal(
     &      apolr*conjg(apolr)-
     &      apoll*conjg(apoll))

          stokesprop_u(1,jobfr)=stok1
          stokesprop_u(2,jobfr)=stok2
          stokesprop_u(3,jobfr)=stok3
          stokesprop_u(4,jobfr)=stok4

        enddo
      enddo

      obsvprop_u=obsvprop_u*1000.0d0

      return
      end
+PATCH,TEST.
*CMZ :  4.01/00 22/02/2023  15.14.45  by  Michael Scheer
+DECK,load_contrl_cmn,T=F77.
*CMZ :  4.01/04 17/10/2023  13.14.01  by  Michael Scheer
*-- Author :    Michael Scheer   17/10/2023
      subroutine load_contrl_cmn
+seq,contrl.
      end
+PATCH,SEQVER.
*CMZ :  4.01/04 07/11/2023  17.41.48  by  Michael Scheer
+KEEP,wversion.
*CMZ :  4.01/04 28/12/2023  17.35.14  by  Michael Scheer
*CMZ :  4.01/03 04/07/2023  09.17.35  by  Michael Scheer
*CMZ :  4.01/01 15/03/2023  13.26.08  by  Michael Scheer
*CMZ :  4.01/00 14/03/2023  11.18.26  by  Michael Scheer
*CMZ :  4.00/17 05/12/2022  09.05.41  by  Michael Scheer
*CMZ :  4.00/16 29/09/2022  11.26.43  by  Michael Scheer
*CMZ :  4.00/15 07/07/2022  19.48.27  by  Michael Scheer
*CMZ :  4.00/14 11/02/2022  10.51.49  by  Michael Scheer
*CMZ :  4.00/13 20/12/2021  16.35.59  by  Michael Scheer
*CMZ :  4.00/12 29/07/2021  10.04.11  by  Michael Scheer
*CMZ :  4.00/10 25/09/2020  11.26.26  by  Michael Scheer
*CMZ :  4.00/09 15/08/2020  09.03.43  by  Michael Scheer
*CMZ :  4.00/08 07/08/2020  11.11.08  by  Michael Scheer
*CMZ :  4.00/07 06/08/2020  11.15.07  by  Michael Scheer
*CMZ :  4.00/06 02/01/2020  12.17.28  by  Michael Scheer
*CMZ :  4.00/05 30/11/2019  16.49.12  by  Michael Scheer
*CMZ :  4.00/04 28/11/2019  13.59.11  by  Michael Scheer
*CMZ :  4.00/03 09/05/2019  11.05.46  by  Michael Scheer
*CMZ :  4.00/02 13/04/2019  10.07.02  by  Michael Scheer
*CMZ :  4.00/01 12/04/2019  13.43.35  by  Michael Scheer
*CMZ :  4.00/00 04/04/2019  19.42.59  by  Michael Scheer
*CMZ :  3.08/01 04/04/2019  12.02.56  by  Michael Scheer
*CMZ :  3.08/00 29/03/2019  15.51.16  by  Michael Scheer
*CMZ :  3.07/01 29/03/2019  15.50.21  by  Michael Scheer
*CMZ :  3.07/00 18/03/2019  10.37.17  by  Michael Scheer
*CMZ :  3.06/00 28/02/2019  17.26.47  by  Michael Scheer
*CMZ :  3.05/28 07/01/2019  17.17.16  by  Michael Scheer
*CMZ :  3.05/27 12/12/2018  12.21.10  by  Michael Scheer
*CMZ :  3.05/26 09/12/2018  13.47.24  by  Michael Scheer
*CMZ :  3.05/25 06/12/2018  10.32.29  by  Michael Scheer
*CMZ :  3.05/24 05/12/2018  10.15.05  by  Michael Scheer
*CMZ :  3.05/23 03/12/2018  18.36.19  by  Michael Scheer
*CMZ :  3.05/22 08/11/2018  16.06.25  by  Michael Scheer
*CMZ :  3.05/21 07/11/2018  12.38.51  by  Michael Scheer
*CMZ :  3.05/20 01/11/2018  17.21.41  by  Michael Scheer
*CMZ :  3.05/19 18/10/2018  14.59.42  by  Michael Scheer
*CMZ :  3.05/18 17/10/2018  09.19.45  by  Michael Scheer
*CMZ :  3.05/17 11/10/2018  13.23.03  by  Michael Scheer
*CMZ :  3.05/16 10/10/2018  14.54.29  by  Michael Scheer
*CMZ :  3.05/15 08/10/2018  18.46.43  by  Michael Scheer
*CMZ :  3.05/14 01/10/2018  14.06.12  by  Michael Scheer
*CMZ :  3.05/13 24/09/2018  14.47.49  by  Michael Scheer
*CMZ :  3.05/12 29/08/2018  14.01.19  by  Michael Scheer
*CMZ :  3.05/11 16/08/2018  15.24.39  by  Michael Scheer
*CMZ :  3.05/10 14/08/2018  11.03.03  by  Michael Scheer
*CMZ :  3.05/09 08/08/2018  14.26.55  by  Michael Scheer
*CMZ :  3.05/08 26/07/2018  15.29.40  by  Michael Scheer
*CMZ :  3.05/07 21/07/2018  16.41.09  by  Michael Scheer
*CMZ :  3.05/06 19/07/2018  15.14.45  by  Michael Scheer
*CMZ :  3.05/05 13/07/2018  14.31.21  by  Michael Scheer
*CMZ :  3.05/04 09/07/2018  11.39.31  by  Michael Scheer
*CMZ :  3.05/03 22/05/2018  07.40.41  by  Michael Scheer
*CMZ :  3.05/02 16/05/2018  08.36.56  by  Michael Scheer
*CMZ :  3.05/01 09/05/2018  09.27.05  by  Michael Scheer
*CMZ :  3.05/00 02/05/2018  12.32.13  by  Michael Scheer
*CMZ :  3.04/01 03/04/2018  14.28.15  by  Michael Scheer
*CMZ :  3.04/00 01/03/2018  16.59.23  by  Michael Scheer
*CMZ :  3.03/04 02/01/2018  16.28.17  by  Michael Scheer
*CMZ :  3.03/03 11/07/2017  12.45.21  by  Michael Scheer
*CMZ :  3.03/02 28/06/2017  14.11.13  by  Michael Scheer
*CMZ :  3.03/01 13/11/2015  10.19.29  by  Michael Scheer
*CMZ :  3.03/00 30/09/2015  11.38.55  by  Michael Scheer
*CMZ :  3.02/09 09/07/2015  19.32.06  by  Michael Scheer
*CMZ :  3.02/08 25/06/2015  14.22.19  by  Michael Scheer
*CMZ :  3.02/07 24/06/2015  12.52.52  by  Michael Scheer
*CMZ :  3.02/06 18/06/2015  14.17.17  by  Michael Scheer
*CMZ :  3.02/05 13/04/2015  11.57.01  by  Michael Scheer
*CMZ :  3.02/04 18/03/2015  10.20.54  by  Michael Scheer
*CMZ :  3.02/03 10/11/2014  16.22.36  by  Michael Scheer
*CMZ :  3.02/02 22/10/2014  13.35.55  by  Michael Scheer
*CMZ :  3.02/01 16/10/2014  06.18.22  by  Michael Scheer
*CMZ :  3.01/10 19/08/2014  11.32.39  by  Michael Scheer
*CMZ :  3.01/09 12/08/2014  17.20.23  by  Michael Scheer
*CMZ :  3.01/08 12/08/2014  14.40.52  by  Michael Scheer
*CMZ :  3.01/07 23/06/2014  16.16.40  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  10.16.23  by  Michael Scheer
*CMZ :  3.01/05 13/06/2014  13.18.08  by  Michael Scheer
*CMZ :  3.01/04 11/06/2014  12.53.59  by  Michael Scheer
*CMZ :  3.01/03 20/03/2014  13.34.33  by  Michael Scheer
*CMZ :  3.01/02 27/02/2014  09.45.16  by  Michael Scheer
*CMZ :  3.01/01 31/07/2013  12.26.07  by  Michael Scheer
*CMZ :  3.01/00 18/07/2013  13.42.01  by  Michael Scheer
*CMZ :  3.00/02 10/04/2013  09.29.30  by  Michael Scheer
*CMZ :  3.00/01 03/04/2013  12.14.49  by  Michael Scheer
*CMZ :  3.00/00 14/03/2013  12.32.44  by  Michael Scheer
*CMZ :  2.70/12 05/03/2013  13.35.20  by  Michael Scheer
*CMZ :  2.70/11 22/02/2013  14.47.51  by  Michael Scheer
*CMZ :  2.70/10 16/01/2013  12.43.34  by  Michael Scheer
*CMZ :  2.70/09 15/01/2013  14.59.06  by  Michael Scheer
*CMZ :  2.70/08 14/01/2013  17.51.12  by  Michael Scheer
*CMZ :  2.70/07 14/01/2013  16.57.30  by  Michael Scheer
*CMZ :  2.70/06 14/01/2013  09.58.06  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  15.37.35  by  Michael Scheer
*CMZ :  2.70/04 21/12/2012  12.44.21  by  Michael Scheer
*CMZ :  2.70/03 17/12/2012  15.04.27  by  Michael Scheer
*CMZ :  2.70/02 14/12/2012  10.52.28  by  Michael Scheer
*CMZ :  2.70/01 12/12/2012  15.53.33  by  Michael Scheer
*CMZ :  2.70/00 11/12/2012  17.13.12  by  Michael Scheer
*CMZ :  2.69/02 08/11/2012  10.18.22  by  Michael Scheer
*CMZ :  2.69/01 31/10/2012  17.01.49  by  Michael Scheer
*CMZ :  2.69/00 30/10/2012  16.26.26  by  Michael Scheer
*CMZ :  2.68/05 19/10/2012  14.10.43  by  Unknown
*CMZ :  2.68/04 04/09/2012  11.30.37  by  Michael Scheer
*CMZ :  2.68/03 01/09/2012  16.18.21  by  Michael Scheer
*CMZ :  2.68/02 01/08/2012  15.11.42  by  Michael Scheer
*CMZ :  2.68/01 29/05/2012  17.05.39  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  16.51.01  by  Michael Scheer
*CMZ :  2.67/06 24/05/2012  14.37.50  by  Michael Scheer
*CMZ :  2.67/05 16/05/2012  14.35.39  by  Michael Scheer
*CMZ :  2.67/04 15/05/2012  13.09.47  by  Michael Scheer
*CMZ :  2.67/03 09/05/2012  16.33.57  by  Michael Scheer
*CMZ :  2.67/02 09/05/2012  12.08.14  by  Michael Scheer
*CMZ :  2.67/01 16/03/2012  09.17.00  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  16.27.31  by  Michael Scheer
*CMZ :  2.66/22 16/01/2012  12.52.11  by  Michael Scheer
*CMZ :  2.66/21 22/11/2011  13.55.20  by  Michael Scheer
*CMZ :  2.66/20 22/11/2011  10.47.52  by  Michael Scheer
*CMZ :  2.66/19 07/06/2011  14.55.12  by  Michael Scheer
*CMZ :  2.66/18 16/12/2010  12.54.41  by  Michael Scheer
*CMZ :  2.66/17 23/11/2010  10.03.05  by  Michael Scheer
*CMZ :  2.66/16 22/11/2010  14.04.02  by  Michael Scheer
*CMZ :  2.66/15 09/11/2010  16.18.55  by  Michael Scheer
*CMZ :  2.66/14 09/11/2010  15.41.06  by  Michael Scheer
*CMZ :  2.66/13 02/08/2010  09.16.32  by  Michael Scheer
*CMZ :  2.66/12 27/05/2010  02.41.06  by  Michael Scheer
*CMZ :  2.66/11 05/05/2010  08.25.31  by  Michael Scheer
*CMZ :  2.66/10 04/05/2010  12.42.54  by  Michael Scheer
*CMZ :  2.66/09 03/05/2010  16.13.02  by  Michael Scheer
*CMZ :  2.66/08 17/03/2010  14.47.26  by  Michael Scheer
*CMZ :  2.66/07 11/03/2010  15.52.20  by  Michael Scheer
*CMZ :  2.66/06 27/11/2009  16.15.00  by  Michael Scheer
*CMZ :  2.66/05 17/11/2009  16.10.37  by  Michael Scheer
*CMZ :  2.66/04 17/11/2009  10.13.48  by  Michael Scheer
*CMZ :  2.66/03 11/11/2009  16.17.18  by  Michael Scheer
*CMZ :  2.66/02 26/10/2009  14.31.27  by  Michael Scheer
*CMZ :  2.66/01 21/10/2009  09.36.11  by  Michael Scheer
*CMZ :  2.66/00 14/10/2009  11.57.53  by  Michael Scheer
*CMZ :  2.65/03 02/10/2009  13.22.43  by  Michael Scheer
*CMZ :  2.65/02 29/09/2009  12.22.19  by  Michael Scheer
*CMZ :  2.65/01 21/09/2009  14.36.00  by  Michael Scheer
*CMZ :  2.65/00 18/09/2009  09.46.14  by  Michael Scheer
*CMZ :  2.64/07 17/09/2009  16.28.06  by  Michael Scheer
*CMZ :  2.64/06 15/09/2009  15.17.17  by  Michael Scheer
*CMZ :  2.64/05 14/09/2009  11.36.46  by  Michael Scheer
*CMZ :  2.64/04 21/08/2009  17.40.03  by  Michael Scheer
*CMZ :  2.64/03 21/08/2009  17.33.33  by  Michael Scheer
*CMZ :  2.64/02 21/08/2009  17.28.12  by  Michael Scheer
*CMZ :  2.64/01 20/08/2009  15.48.35  by  Michael Scheer
*CMZ :  2.64/00 17/08/2009  09.32.48  by  Michael Scheer
*CMZ :  2.63/05 14/08/2009  13.07.07  by  Michael Scheer
*CMZ :  2.63/04 22/07/2009  07.41.27  by  Michael Scheer
*CMZ :  2.63/03 02/06/2009  16.25.15  by  Michael Scheer
*CMZ :  2.63/02 08/04/2008  12.21.25  by  Michael Scheer
*CMZ :  2.63/01 16/01/2008  13.14.36  by  Michael Scheer
*CMZ :  2.63/00 11/01/2008  16.42.42  by  Michael Scheer
*CMZ :  2.62/04 03/01/2008  17.16.00  by  Michael Scheer
*CMZ :  2.62/03 17/07/2007  16.15.46  by  Michael Scheer
*CMZ :  2.62/02 16/07/2007  11.28.09  by  Michael Scheer
*CMZ :  2.62/01 24/04/2007  12.00.53  by  Michael Scheer
*CMZ :  2.62/00 17/04/2007  08.49.12  by  Michael Scheer
*CMZ :  2.61/06 12/04/2007  13.39.57  by  Michael Scheer
*CMZ :  2.61/05 12/04/2007  09.31.22  by  Michael Scheer
*CMZ :  2.61/04 29/03/2007  16.31.37  by  Michael Scheer
*CMZ :  2.61/03 27/03/2007  13.29.11  by  Michael Scheer
*CMZ :  2.61/02 26/03/2007  20.10.31  by  Michael Scheer
*CMZ :  2.61/01 15/02/2007  14.24.24  by  Michael Scheer
*CMZ :  2.61/00 30/01/2007  20.26.41  by  Michael Scheer
*CMZ :  2.60/00 26/01/2007  10.51.28  by  Michael Scheer
*CMZ :  2.59/02 25/01/2007  16.09.23  by  Michael Scheer
*CMZ :  2.59/01 24/01/2007  14.32.08  by  Michael Scheer
*CMZ :  2.59/00 23/01/2007  15.40.42  by  Michael Scheer
*CMZ :  2.58/01 23/01/2007  13.25.42  by  Michael Scheer
*CMZ :  2.58/00 16/01/2007  17.45.21  by  Michael Scheer
*CMZ :  2.57/05 10/01/2007  13.39.09  by  Michael Scheer
*CMZ :  2.57/04 01/02/2006  16.20.51  by  Michael Scheer
*CMZ :  2.57/03 23/12/2005  11.48.02  by  Michael Scheer
*CMZ :  2.57/02 09/12/2005  11.14.20  by  Michael Scheer
*CMZ :  2.57/01 22/11/2005  13.32.35  by  Michael Scheer
*CMZ :  2.57/00 22/11/2005  12.35.13  by  Michael Scheer
*CMZ :  2.56/02 21/10/2005  16.32.46  by  Michael Scheer
*CMZ :  2.56/01 21/10/2005  12.35.26  by  Michael Scheer
*CMZ :  2.56/00 17/10/2005  13.31.23  by  Michael Scheer
*CMZ :  2.55/01 10/08/2005  16.12.03  by  Michael Scheer
*CMZ :  2.55/00 10/08/2005  16.09.23  by  Michael Scheer
*CMZ :  2.54/07 16/06/2005  12.25.52  by  Michael Scheer
*CMZ :  2.54/06 02/06/2005  13.55.14  by  Michael Scheer
*CMZ :  2.54/05 02/06/2005  08.17.11  by  Michael Scheer
*CMZ :  2.54/04 19/04/2005  14.13.30  by  Michael Scheer
*CMZ :  2.54/03 18/04/2005  08.56.03  by  Michael Scheer
*CMZ :  2.54/02 13/04/2005  13.53.54  by  Michael Scheer
*CMZ :  2.54/01 13/04/2005  09.16.21  by  Michael Scheer
*CMZ :  2.54/00 28/02/2005  17.31.43  by  Michael Scheer
*CMZ :  2.53/05 25/02/2005  12.01.49  by  Michael Scheer
*CMZ :  2.53/04 10/02/2005  10.01.45  by  Michael Scheer
*CMZ :  2.53/03 26/01/2005  15.37.37  by  Michael Scheer
*CMZ :  2.53/02 25/01/2005  18.20.37  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  13.29.48  by  Michael Scheer
*CMZ :  2.53/00 21/01/2005  17.24.28  by  Michael Scheer
*CMZ :  2.52/15 05/01/2005  16.38.59  by  Michael Scheer
*CMZ :  2.52/14 22/12/2004  16.29.18  by  Michael Scheer
*CMZ :  2.52/13 16/12/2004  21.17.54  by  Michael Scheer
*CMZ :  2.52/12 08/12/2004  14.07.27  by  Michael Scheer
*CMZ :  2.52/11 08/12/2004  13.39.53  by  Michael Scheer
*CMZ :  2.52/10 05/11/2004  17.17.40  by  Michael Scheer
*CMZ :  2.52/09 29/10/2004  13.08.10  by  Michael Scheer
*CMZ :  2.52/08 14/10/2004  14.53.32  by  Michael Scheer
*CMZ :  2.52/07 14/10/2004  09.24.22  by  Michael Scheer
*CMZ :  2.52/05 17/08/2004  15.57.30  by  Michael Scheer
*CMZ :  2.52/04 13/07/2004  08.24.53  by  Michael Scheer
*CMZ :  2.52/03 08/07/2004  13.38.16  by  Michael Scheer
*CMZ :  2.52/02 08/07/2004  10.29.14  by  Michael Scheer
*CMZ :  2.52/01 30/06/2004  16.24.39  by  Michael Scheer
*CMZ :  2.52/00 30/06/2004  10.54.14  by  Michael Scheer
*CMZ :  2.51/03 23/06/2004  12.25.44  by  Michael Scheer
*CMZ :  2.51/02 22/06/2004  16.31.28  by  Michael Scheer
*CMZ :  2.51/01 17/06/2004  16.18.20  by  Michael Scheer
*CMZ :  2.51/00 26/05/2004  16.34.25  by  Michael Scheer
*CMZ :  2.50/03 10/05/2004  14.41.11  by  Michael Scheer
*CMZ :  2.50/02 30/04/2004  15.33.31  by  Michael Scheer
*CMZ :  2.50/01 30/04/2004  08.58.23  by  Michael Scheer
*CMZ :  2.50/00 29/04/2004  18.46.23  by  Michael Scheer
*CMZ :  2.49/01 23/03/2004  14.32.47  by  Michael Scheer
*CMZ :  2.48/04 17/03/2004  14.54.00  by  Michael Scheer
*CMZ :  2.48/03 10/03/2004  16.04.11  by  Michael Scheer
*CMZ :  2.48/02 03/03/2004  11.26.16  by  Michael Scheer
*CMZ :  2.48/01 02/03/2004  16.44.04  by  Michael Scheer
*CMZ :  2.48/00 01/03/2004  18.05.54  by  Michael Scheer
*CMZ :  2.47/23 17/02/2004  13.48.36  by  Michael Scheer
*CMZ :  2.47/22 03/12/2003  13.18.07  by  Michael Scheer
*CMZ :  2.47/21 03/12/2003  09.50.02  by  Michael Scheer
*CMZ :  2.47/20 01/12/2003  15.35.07  by  Michael Scheer
*CMZ :  2.47/19 01/12/2003  08.24.44  by  Michael Scheer
*CMZ :  2.47/18 27/11/2003  14.46.01  by  Michael Scheer
*CMZ :  2.47/17 12/09/2003  10.10.52  by  Michael Scheer
*CMZ :  2.47/16 11/09/2003  15.10.44  by  Michael Scheer
*CMZ :  2.47/15 04/09/2003  09.28.29  by  Michael Scheer
*CMZ :  2.47/14 07/08/2003  09.44.02  by  Michael Scheer
*CMZ :  2.47/13 03/07/2003  09.57.40  by  Michael Scheer
*CMZ :  2.47/12 03/07/2003  09.56.41  by  Michael Scheer
*CMZ :  2.47/11 30/05/2003  12.54.22  by  Michael Scheer
*CMZ :  2.47/10 30/05/2003  12.43.23  by  Michael Scheer
*CMZ :  2.47/09 27/05/2003  15.58.18  by  Michael Scheer
*CMZ :  2.47/08 20/05/2003  15.48.28  by  Michael Scheer
*CMZ :  2.47/07 15/04/2003  10.52.36  by  Michael Scheer
*CMZ :  2.47/06 28/03/2003  15.40.56  by  Michael Scheer
*CMZ :  2.47/05 27/03/2003  15.27.38  by  Michael Scheer
*CMZ :  2.47/04 13/03/2003  11.06.38  by  Michael Scheer
*CMZ :  2.47/03 12/03/2003  16.02.35  by  Michael Scheer
*CMZ :  2.47/02 12/03/2003  10.54.25  by  Michael Scheer
*CMZ :  2.47/01 10/03/2003  11.57.24  by  Michael Scheer
*CMZ :  2.46/02 07/03/2003  11.17.22  by  Michael Scheer
*CMZ :  2.46/01 18/12/2002  11.47.23  by  Michael Scheer
*CMZ :  2.46/00 17/12/2002  16.46.49  by  Michael Scheer
*CMZ :  2.45/03 17/12/2002  15.15.55  by  Michael Scheer
*CMZ :  2.45/02 16/12/2002  14.36.34  by  Michael Scheer
*CMZ :  2.45/01 13/12/2002  17.25.42  by  Michael Scheer
*CMZ :  2.44/03 13/12/2002  12.43.06  by  Michael Scheer
*CMZ :  2.44/02 13/12/2002  11.39.21  by  Michael Scheer
*CMZ :  2.44/01 12/12/2002  13.32.07  by  Michael Scheer
*CMZ :  2.44/00 15/11/2002  18.31.49  by  Michael Scheer
*CMZ :  2.42/04 29/10/2002  11.33.36  by  Michael Scheer
*CMZ :  2.42/03 13/09/2002  18.47.33  by  Michael Scheer
*CMZ :  2.42/02 12/09/2002  11.07.58  by  Michael Scheer
*CMZ :  2.42/01 09/09/2002  18.56.25  by  Michael Scheer
*CMZ :  2.41/13 03/09/2002  14.29.39  by  Michael Scheer
*CMZ :  2.41/12 22/08/2002  12.13.49  by  Michael Scheer
*CMZ :  2.41/11 21/08/2002  11.28.45  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.50.10  by  Michael Scheer
*CMZ :  2.41/09 14/08/2002  17.27.24  by  Michael Scheer
*CMZ :  2.41/08 14/08/2002  17.06.27  by  Michael Scheer
*CMZ :  2.41/07 30/07/2002  12.13.11  by  Michael Scheer
*CMZ :  2.41/06 10/05/2002  15.26.01  by  Michael Scheer
*CMZ :  2.41/05 18/04/2002  11.47.34  by  Michael Scheer
*CMZ :  2.41/04 16/04/2002  14.29.54  by  Michael Scheer
*CMZ :  2.41/03 21/03/2002  12.44.56  by  Michael Scheer
*CMZ :  2.41/01 21/03/2002  12.36.42  by  Michael Scheer
*CMZ :  2.41/00 20/03/2002  19.24.01  by  Michael Scheer
*CMZ :  2.40/04 20/03/2002  12.33.26  by  Michael Scheer
*CMZ :  2.40/02 14/03/2002  16.23.09  by  Michael Scheer
*CMZ :  2.40/01 12/03/2002  14.36.49  by  Michael Scheer
*CMZ :  2.40/00 12/03/2002  14.28.59  by  Michael Scheer
*CMZ :  2.39/02 22/01/2002  13.35.44  by  Michael Scheer
*CMZ :  2.39/01 15/01/2002  16.49.21  by  Michael Scheer
*CMZ :  2.39/00 14/01/2002  14.37.58  by  Michael Scheer
*CMZ :  2.38/03 13/12/2001  15.06.40  by  Michael Scheer
*CMZ :  2.38/02 13/12/2001  13.44.34  by  Michael Scheer
*CMZ :  2.38/01 13/12/2001  12.16.53  by  Michael Scheer
*CMZ :  2.37/07 12/12/2001  14.47.52  by  Michael Scheer
*CMZ :  2.37/06 07/12/2001  15.02.02  by  Michael Scheer
*CMZ :  2.37/05 07/12/2001  14.52.16  by  Michael Scheer
*CMZ :  2.37/04 05/12/2001  17.37.12  by  Michael Scheer
*CMZ :  2.37/03 23/11/2001  18.19.34  by  Michael Scheer
*CMZ :  2.37/02 15/11/2001  17.25.18  by  Michael Scheer
*CMZ :  2.37/01 14/11/2001  11.08.43  by  Michael Scheer
*CMZ :  2.37/00 13/11/2001  17.33.11  by  Michael Scheer
*CMZ :  2.36/01 08/11/2001  17.39.47  by  Michael Scheer
*CMZ :  2.36/00 08/11/2001  15.34.30  by  Michael Scheer
*CMZ :  2.35/02 30/10/2001  17.15.18  by  Michael Scheer
*CMZ :  2.35/01 17/10/2001  11.40.54  by  Michael Scheer
*CMZ :  2.35/00 26/09/2001  17.19.48  by  Michael Scheer
*CMZ :  2.34/09 26/09/2001  17.17.20  by  Michael Scheer
*CMZ :  2.34/08 17/09/2001  19.44.50  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  17.41.49  by  Michael Scheer
*CMZ :  2.34/06 23/08/2001  17.38.11  by  Michael Scheer
*CMZ :  2.34/04 11/07/2001  11.20.36  by  Michael Scheer
*CMZ :  2.34/02 02/07/2001  17.25.12  by  Michael Scheer
*CMZ :  2.34/00 11/05/2001  17.27.00  by  Michael Scheer
*CMZ :  2.33/09 10/05/2001  18.03.20  by  Michael Scheer
*CMZ :  2.33/08 08/05/2001  17.52.21  by  Michael Scheer
*CMZ :  2.33/07 08/05/2001  17.43.33  by  Michael Scheer
*CMZ :  2.33/06 04/05/2001  13.56.57  by  Michael Scheer
*CMZ :  2.33/05 04/05/2001  11.42.46  by  Michael Scheer
*CMZ :  2.33/04 04/05/2001  11.37.04  by  Michael Scheer
*CMZ :  2.33/03 04/05/2001  11.15.03  by  Michael Scheer
*CMZ :  2.33/02 03/05/2001  17.23.54  by  Michael Scheer
*CMZ :  2.33/01 03/05/2001  14.01.01  by  Michael Scheer
*CMZ :  2.32/04 26/04/2001  12.37.02  by  Michael Scheer
*CMZ :  2.32/03 26/04/2001  11.12.11  by  Michael Scheer
*CMZ :  2.32/02 26/04/2001  11.09.43  by  Michael Scheer
*CMZ :  2.32/01 25/04/2001  19.09.17  by  Michael Scheer
*CMZ :  2.32/00 25/04/2001  17.14.54  by  Michael Scheer
*CMZ :  2.31/01 25/04/2001  17.13.47  by  Michael Scheer
*CMZ :  2.31/00 24/04/2001  16.07.58  by  Michael Scheer
*CMZ :  2.30/04 23/04/2001  12.34.39  by  Michael Scheer
*CMZ :  2.30/03 20/04/2001  16.32.24  by  Michael Scheer
*CMZ :  2.30/02 12/04/2001  19.12.58  by  Michael Scheer
*CMZ :  2.30/01 12/04/2001  18.24.05  by  Michael Scheer
*CMZ :  2.30/00 11/04/2001  19.35.18  by  Michael Scheer
*CMZ :  2.20/12 11/04/2001  19.33.04  by  Michael Scheer
*CMZ :  2.20/11 11/04/2001  16.16.37  by  Michael Scheer
*CMZ :  2.20/10 10/04/2001  12.26.28  by  Michael Scheer
*CMZ :  2.20/09 03/04/2001  14.52.40  by  Michael Scheer
*CMZ :  2.20/08 18/03/2001  22.18.21  by  Michael Scheer
*CMZ :  2.20/07 18/03/2001  17.09.21  by  Michael Scheer
*CMZ :  2.20/06 15/03/2001  17.20.43  by  Michael Scheer
*CMZ :  2.20/04 09/03/2001  19.55.49  by  Michael Scheer
*CMZ :  2.20/03 23/02/2001  15.16.41  by  Michael Scheer
*CMZ :  2.20/02 21/02/2001  11.41.58  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.33.29  by  Michael Scheer
*CMZ : 00.01/04 28/11/94  17.27.56  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  15.13.26  by  Michael Scheer
*-- Author :Michael Scheer
     &  '          *       VERSION 4.01/04   28.12.2023        *'
+self,if=versdum.
Maszstab           ********VERSION 1.23/45 *********************
+self.

+DECK,wversdum,T=F77.
*CMZ :  4.01/04 07/11/2023  17.45.05  by  Michael Scheer
*-- Author :    Michael Scheer   07/11/2023
      subroutine wversdum
+seq,wversion.
      return
      end
