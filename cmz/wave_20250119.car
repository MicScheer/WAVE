+PATCH,FOR.
*CMZ : 00.00/00 10/01/95  15.22.39  by  Michael Scheer
+KEEP,seqdebug.
*CMZ :  1.10/02 30/11/2016  09.52.53  by  Michael Scheer
*-- Author :    Michael Scheer   30/11/2016
      integer iseqdebug
      common/seqdebugc/iseqdebug
+DECK,aaaaaa.
*CMZ :  4.00/07 27/04/2020  16.23.04  by  Michael Scheer
*CMZ :  3.07/01 21/03/2019  12.56.48  by  Michael Scheer
*CMZ :  3.06/00 26/02/2019  13.44.59  by  Michael Scheer
*CMZ :  3.05/03 17/05/2018  15.20.07  by  Michael Scheer
*CMZ :  3.05/01 04/05/2018  15.45.28  by  Michael Scheer
*CMZ :  3.05/00 25/04/2018  14.52.43  by  Michael Scheer
*CMZ :  3.02/00 01/09/2014  12.19.54  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.17.36  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  15.45.11  by  Michael Scheer
*CMZ :  2.70/04 18/12/2012  10.57.04  by  Michael Scheer
*CMZ :  2.20/01 09/11/2009  13.07.19  by  Michael Scheer
*CMZ :  2.16/08 01/11/2000  17.02.50  by  Michael Scheer
*-- Author :    Michael Scheer   01/11/2000
+seq,gplhint.
+SEQ,MODULESF90,IF=F90,IF=-wtotal.
+seq,f1k.
+seq,waveg1.
+seq,souintmod.
      SUBROUTINE AAAAAA

      RETURN
      END
+DECK,ABSCOEF.
*CMZ :  2.70/12 01/03/2013  15.45.11  by  Michael Scheer
*CMZ :  2.56/01 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.41/10 29/04/2004  15.29.30  by  Michael Scheer
*CMZ :  2.36/00 07/11/2001  14.23.12  by  Michael Scheer
*CMZ :  2.16/08 01/11/2000  18.41.44  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  2.12/03 07/07/99  16.16.04  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  15.36.14  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.46.17  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.49  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE ABSCOEF(FREQ,ABSMU,ABSDEN,ABSCOM,IFILTER,ICAL)
+seq,gplhint.

C--- READS ABSORPTION COEFFICIENT FROM FILE CALCULATES COEFFICIENT FOR
C    GIVEN FREQUENCY

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.

      INTEGER I,ICAL,ICALO,NCOEF,NDAFRQP,IERR,IFILTER

      PARAMETER(NDAFRQP=10000)

      CHARACTER(65) ABSCOM
      DOUBLE PRECISION ABSDEN,AFREQ(NDAFRQP),ABSCO(NDAFRQP),FREQ,ABSMU

      DATA ICALO/-1/

C--- READ DATA FILE

      IF (ICAL.NE.ICALO) THEN

        OPEN(UNIT=LUNABS,FILE=FILEABS,STATUS='OLD',FORM='FORMATTED')

        READ(LUNABS,'(A65)') ABSCOM
        READ(LUNABS,*) ABSDEN
        READ(LUNABS,*) NCOEF

        IF (NCOEF.GT.NDAFRQP) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN ABSCOEF ***'
          WRITE(LUNGFO,*)'DIMENSION EXCEEDED'
          WRITE(LUNGFO,*)'INCREASE PARAMETER NDAFRQP IN THIS ROUTINE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN ABSCOEF ***'
          WRITE(6,*)'DIMENSION EXCEEDED'
          WRITE(6,*)'INCREASE PARAMETER NDAFRQP IN THIS ROUTINE'
          WRITE(6,*)
          STOP

        ENDIF !NCOEF

        DO I=1,NCOEF
          READ(LUNABS,*) AFREQ(I),ABSCO(I)
        ENDDO !I

        CLOSE(LUNABS)

        ICALO=ICAL

      ENDIF !ICAL

      IF (IFILTER.EQ.1) THEN
        CALL ABSNOSPLI(AFREQ,ABSCO,NCOEF,FREQ,ABSMU,IERR,1)
      ELSE
        CALL ABSNOSPLI(AFREQ,ABSCO,NCOEF,FREQ,ABSMU,IERR,-1)
      ENDIF

      IF (IERR.NE.0) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN ABSCOEF ***'
        WRITE(LUNGFO,*)'CALL TO SR ABSNOSPLI FAILED'
        WRITE(LUNGFO,*)'CHECK PHOTONENERGIES IN NAMELIST FREQN AND FILE'
        WRITE(LUNGFO,*)FILEABS
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)

        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN ABSCOEF ***'
        WRITE(6,*)'CALL TO SR ABSNOSPLI FAILED'
        WRITE(6,*)'CHECK PHOTONENERGIES IN NAMELIST FREQN AND FILE'
        WRITE(6,*)FILEABS
        WRITE(6,*)
        WRITE(6,*)

        STOP

      ENDIF   !IERR

      RETURN
      END
+DECK,ABSCOEF_MERGE.
*CMZ :  2.70/12 01/03/2013  15.45.11  by  Michael Scheer
*CMZ :  2.41/10 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.37/03 23/11/2001  18.02.57  by  Michael Scheer
*CMZ :  2.36/00 07/11/2001  14.24.11  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ : 00.01/04 28/11/94  18.52.29  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  13.57.04  by  Michael Scheer
*CMZ : 00.01/01 21/06/94  15.22.20  by  Michael Scheer
*-- Author :    Michael Scheer   20/06/94

      SUBROUTINE ABSCOEF_MERGE

+seq,gplhint.

C Merges files with different absorption coefficients
C The routine reads a list of file names given in the
C the file FILEAM and writes the results to FILEAMO.
C ABSTHI (namelist $FREQN) and FILESP0 (namelist $MYFILES) are
C superseded by THICKTOT and FILEAMO

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,FREQS.

      CHARACTER(65) CDUM,CFILE

      INTEGER NFILES,IFILES,LUNDUM,IERR,IEDGE
      INTEGER IETOT,NETOT,METOT,NENE,IENE,IKNOWN

      INTEGER NEBUFFP
      PARAMETER(NEBUFFP=1000)
      DOUBLE PRECISION EBUFF(NEBUFFP),ABUFF(NEBUFFP),EPHOT
      DOUBLE PRECISION EBUFFT(NEBUFFP)
      DOUBLE PRECISION THICK,DENS,COEFTOT(NEBUFFP),THICKTOT,DENSTOT,DENTHIT
      DOUBLE PRECISION AMU

      DATA LUNDUM /10/

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SR ABSCOEF_MERGE:'
      WRITE(LUNGFO,*)'     ================='
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     List of files to be merged:'
      WRITE(LUNGFO,*)

C--- Open list of files to be merged

      OPEN(UNIT=LUNAM,FILE=FILEAM,STATUS='OLD')

      NFILES=0
100   CONTINUE

      READ(LUNAM,*,END=99) THICK,CFILE
      NFILES=NFILES+1
      WRITE(LUNGFO,*)'     ',CFILE
      WRITE(LUNGFO,*)'     Thickness [m]:',THICK
      WRITE(LUNGFO,*)
      GOTO 100

99    CONTINUE
      REWIND(LUNAM)


      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

C--  Read files and merge photon energies

         READ(LUNAM,*) THICK,CFILE
         OPEN(UNIT=LUNDUM,FILE=CFILE,STATUS='OLD')
            READ(LUNDUM,'(A65)')CDUM
            READ(LUNDUM,*)DENS
            READ(LUNDUM,*)NENE
            DO IENE=1,NENE
                READ(LUNDUM,*)EBUFFT(IENE)
            ENDDO !NENE
         CLOSE(LUNDUM)
         NETOT=NENE
         METOT=NETOT

      DO IFILES=2,NFILES

         READ(LUNAM,*) THICK,CFILE
         OPEN(UNIT=LUNDUM,FILE=CFILE,STATUS='OLD')
            READ(LUNDUM,'(A65)')CDUM
            READ(LUNDUM,*)DENS
            READ(LUNDUM,*)NENE
          DO IENE=1,NENE

                READ(LUNDUM,*)EPHOT

C-   Check if energy is already in buffer
C    Be careful with absorption edges;
c    edges are defined by two identical photon energies.
c    Check carefully if files contain identical elements


               IKNOWN=0
               DO IETOT=1,NETOT
                 IF (EBUFFT(IETOT).EQ.EPHOT) THEN
                   IKNOWN=1
                   GOTO 200
                 ENDIF
               ENDDO !NETOT
200            CONTINUE

               IF (IKNOWN.EQ.0) THEN

                   METOT=METOT+1  !DO NOT UPDATE NETOT HERE, BECAUSE OF EDGES

                   IF (METOT.GT.NEBUFFP) THEN
                     WRITE(6,*)
                     WRITE(6,*)
     & '*** ERROR IN ABSCOEF_MERGE: DIMENSION EXCEEDED, INCREASE NEBUFFP IN THIS ROUTINE ***'
                     WRITE(6,*)
                     WRITE(LUNGFO,*)
                     WRITE(LUNGFO,*)
     & '*** ERROR IN ABSCOEF_MERGE: DIMENSION EXCEEDED, INCREASE NEBUFFP IN THIS ROUTINE ***'
                     WRITE(LUNGFO,*)
                     STOP
                   ENDIF   !METOT
                   EBUFFT(METOT)=EPHOT
                 ENDIF    !IKNOWN

               ENDDO   !IETOT

            NETOT=METOT

         CLOSE(LUNDUM)

      ENDDO !IFILES
      REWIND(LUNAM)

C-  Sort buffer EBUF

            CALL UTIL_SORT(NETOT,EBUFFT)

C--- Do the merging

      THICKTOT=0.0
      DENSTOT=0.0
      DENTHIT=0.0
      DO IETOT=1,NETOT
             COEFTOT(IETOT)=0.0
      ENDDO   !NETOT

      DO IFILES=1,NFILES

      READ(LUNAM,*) THICK,CFILE

      OPEN(UNIT=LUNDUM,FILE=CFILE,STATUS='OLD')
         READ(LUNDUM,'(A65)')CDUM
         READ(LUNDUM,*)DENS
         READ(LUNDUM,*)NENE
         THICKTOT=THICKTOT+THICK
         DENTHIT=DENTHIT+DENS*THICK
         DO IENE=1,NENE
             READ(LUNDUM,*)EBUFF(IENE),ABUFF(IENE)
         ENDDO !IENE
      CLOSE(LUNDUM)

C    Be careful with absorption edges;
c    edges are defined by two identical photon energies.
c    Check carefully if files contain identical elements

         DO IETOT=1,NETOT
             EPHOT=EBUFFT(IETOT)
           IF (IFILTER.EQ.-1) THEN
               CALL ABSNOSPLI(EBUFF,ABUFF,NENE,EPHOT,AMU,IERR,1)
           ELSE
               CALL ABSNOSPLI(EBUFF,ABUFF,NENE,EPHOT,AMU,IERR,-1)
           ENDIF
             IF (IERR.NE.0) THEN
               WRITE(6,*)
               WRITE(6,*)'*** ERROR IN ABSCOEF_MERGE ***'
               WRITE(6,*)'INTERPOLATION OF COEFFICIENT FAILED'
               WRITE(6,*)'FOR PHOTON ENERGY:',EPHOT
               WRITE(6,*)'AND FILE:',CFILE
               WRITE(6,*)'CHECK THIS FILE'
               WRITE(6,*)
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)'*** ERROR IN ABSCOEF_MERGE ***'
               WRITE(LUNGFO,*)'INTERPOLATION OF COEFFICIENT FAILED'
               WRITE(LUNGFO,*)'FOR PHOTON ENERGY:',EPHOT
               WRITE(LUNGFO,*)'AND FILE:',CFILE
               WRITE(LUNGFO,*)'CHECK THIS FILE'
               WRITE(LUNGFO,*)
               STOP
             ENDIF
C- Edge
            IEDGE=0

            IF (IETOT.LT.NETOT) THEN
               IF (EBUFFT(IETOT).EQ.EBUFFT(IETOT+1)) THEN
               DO IENE=1,NENE
            IF (EBUFF(IENE).EQ.EPHOT) IEDGE=IEDGE+1
               ENDDO
               IF (IEDGE.EQ.2) THEN
                       IEDGE=0
                  DO IENE=1,NENE
               IF (EBUFF(IENE).EQ.EPHOT) THEN
                   IEDGE=IENE
                   GOTO 17
               ENDIF
                  ENDDO
17                     AMU=ABUFF(IENE)
                    ENDIF !(IEDGE.EQ.2)
               ENDIF   !EDGE
               ENDIF   !IETOT.LT.NETOT

            IF (IETOT.GT.1) THEN
               IF (EBUFFT(IETOT).EQ.EBUFFT(IETOT-1)) THEN
               DO IENE=1,NENE
            IF (EBUFF(IENE).EQ.EPHOT) IEDGE=IEDGE+1
               ENDDO
               IF (IEDGE.EQ.2) THEN
                       IEDGE=0
                  DO IENE=1,NENE
               IF (EBUFF(IENE).EQ.EPHOT) THEN
                   IEDGE=IENE
                   GOTO 18
               ENDIF
                  ENDDO
18                AMU=ABUFF(IENE+1)
                    ENDIF !(IEDGE.EQ.2)
               ENDIF   !EDGE
               ENDIF   !IETOT.GT.1

C             IF (IETOT.LT.NENE.AND.
C     &           EBUFF(IETOT+1).EQ.EBUFF(IETOT)) THEN
C               AMU=ABUFF(IETOT)
C             ENDIF   !EDGE

             COEFTOT(IETOT)=COEFTOT(IETOT)+DENS*THICK*AMU
         ENDDO   !NETOT

      ENDDO !IFILES

      IF (THICKTOT.GT.0.0) THEN
          DENSTOT=DENTHIT/THICKTOT
        IF (DENTHIT.GT.0.0) THEN
          DO IETOT=1,NETOT
             COEFTOT(IETOT)=COEFTOT(IETOT)/DENTHIT
          ENDDO
        ENDIF
      ENDIF

      CLOSE(LUNAM)

      OPEN(UNIT=LUNAMO,FILE=FILEAMO,STATUS='NEW')
        WRITE(LUNAMO,*)CODE
        WRITE(LUNAMO,*)DENSTOT,THICKTOT
        WRITE(LUNAMO,*)NETOT
        DO IETOT=1,NETOT
          WRITE(LUNAMO,*) EBUFFT(IETOT),COEFTOT(IETOT)
        ENDDO
      CLOSE(LUNAMO)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &'     Merged absorption coefficients written to file:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     ',FILEAMO
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Total thickness [m]        :',THICKTOT
      WRITE(LUNGFO,*)'     Effective density [kg/m**3]:',DENSTOT
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)'     Result of merging:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)CODE
      WRITE(LUNGFO,*)DENSTOT,THICKTOT
      WRITE(LUNGFO,*)NETOT
      DO IETOT=1,NETOT
        WRITE(LUNGFO,*) EBUFFT(IETOT),COEFTOT(IETOT)
      ENDDO

      ABSTHI=THICKTOT
      FILEABS=FILEAMO

      RETURN
      END
+DECK,ABSINT.
*CMZ :  3.02/00 24/09/2014  13.51.08  by  Michael Scheer
*CMZ :  3.01/03 19/03/2014  12.24.14  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  15.45.11  by  Michael Scheer
*CMZ :  2.66/19 07/06/2011  14.08.31  by  Michael Scheer
*CMZ :  2.63/03 07/05/2008  14.17.54  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  15.14.32  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  13.53.05  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.49  by  Michael Scheer
*-- Author : Michael Scheer
C************************************************************************
      SUBROUTINE ABSINT(XA,YA,Y2A,N,X,Y)

+seq,gplhint.

      IMPLICIT NONE
      INTEGER NOLD,N,KLO,KHI,KLOLD,K
      DOUBLE PRECISION Y,X,XA1OLD,XANOLD,H,A,B

      DOUBLE PRECISION XA(*),YA(*),Y2A(*)

      save klold,nold,xa1old,xanold

      DATA KLOLD/1/,NOLD/-99/
      DATA XA1OLD/-9999.D0/,XANOLD/-9999./

      IF(     XA(1).LT.XA(N).AND.(X.LT.XA(1).OR.X.GT.XA(N))
     &    .OR.
     &    XA(N).LT.XA(1).AND.(X.LT.XA(N).OR.X.GT.XA(1))) THEN
        STOP '***SR ABSINT: X OUT OF RANGE ***'
      ENDIF

      IF (NOLD.NE.N) THEN
        KLO=1
      ELSE IF (
     &    XA(1).EQ.XA1OLD
     &    .AND. XA(N).EQ.XANOLD
     &    .AND. X.GT.XA(KLOLD)
     &    ) THEN
        KLO=KLOLD
      ELSE
        KLO=1
      ENDIF

      IF (X.LT.XA(KLO+1)) THEN
      KHI=KLO+1
      GOTO 2
      ENDIF

      KHI=N
1     IF (KHI-KLO.GT.1) THEN
        K=(KHI+KLO)/2
        IF(XA(K).GT.X)THEN
          KHI=K
        ELSE
          KLO=K
        ENDIF
      GOTO 1
      ENDIF

2     H=XA(KHI)-XA(KLO)
      IF (H.LE.0.) THEN
      WRITE(6,*) 'Bad XA input.'
      STOP
      ENDIF
      A=(XA(KHI)-X)/H
      B=(X-XA(KLO))/H
      Y=A*YA(KLO)+B*YA(KHI)+
     *      ((A**3-A)*Y2A(KLO)+(B**3-B)*Y2A(KHI))*(H**2)/6.

      KLOLD=KLO
      NOLD=N
      XA1OLD=XA(1)
      XANOLD=XA(N)

      RETURN
      END
+DECK,ABSNOSPLI.
*CMZ :  3.02/00 24/09/2014  13.51.08  by  Michael Scheer
*CMZ :  3.01/03 19/03/2014  12.24.14  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  15.45.11  by  Michael Scheer
*CMZ :  2.66/19 07/06/2011  14.08.31  by  Michael Scheer
*CMZ :  2.36/00 07/11/2001  14.33.03  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ : 00.01/02 24/11/94  15.21.38  by  Michael Scheer
*CMZ : 00.01/01 21/06/94  20.13.12  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.46.24  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.34  by  Michael Scheer
*-- Author : Michael Scheer

      SUBROUTINE ABSNOSPLI(XA,YA,N,X,Y,IERR,IMODE)

+seq,gplhint.

      IMPLICIT NONE
      INTEGER NOLD,N,KLO,KHI,KLOLD,K,IERR,IMODE
      DOUBLE PRECISION Y,X,XA1OLD,XANOLD,H,YA1OLD,YANOLD

      DOUBLE PRECISION XA(*),YA(*),BB

      save klold,nold,xa1old,xanold,ya1old,yanold

      DATA KLOLD/1/,NOLD/-99/
      DATA XA1OLD/-9999.D0/,XANOLD/-9999./
      DATA YA1OLD/-9999.D0/,YANOLD/-9999./

      IF( XA(1).GE.XA(N)) THEN
        WRITE(6,*)
        WRITE(6,*) '***ERROR IN ABSNOSPLI: X NOT INCREASING ***'
        WRITE(6,*)
        IERR=1
        RETURN
      ENDIF

      IF( XA(1).LT.XA(N).AND.(X.LT.XA(1).OR.X.GT.XA(N))
     &    .OR.
     &    XA(N).LT.XA(1).AND.(X.LT.XA(N).OR.X.GT.XA(1))) THEN
        WRITE(6,*)
        WRITE(6,*) '***ERROR IN ABSNOSPLI: X OUT OF RANGE ***'
        WRITE(6,*)
        WRITE(6,*) 'X-RANGE:',XA(1),'-',XA(N)
        WRITE(6,*) 'X:      ',X
        WRITE(6,*)
        IERR=1
        RETURN
      ENDIF

      IF (NOLD.EQ.N) THEN
        IF (
     &      XA(1).EQ.XA1OLD
     &     .AND. XA(N).EQ.XANOLD
     &     .AND. YA(1).EQ.YA1OLD
     &     .AND. YA(N).EQ.YANOLD
     &     .AND. X.GT.XA(KLOLD)
     &   ) THEN
           KLO=KLOLD
        ELSE
           KLO=1
        ENDIF
      ELSE
        KLO=1
      ENDIF


      IF (X.LT.XA(KLO+1)) THEN
      KHI=KLO+1
      GOTO 2
      ENDIF

      KHI=N
1     IF (KHI-KLO.GT.1) THEN
        K=(KHI+KLO)/2
        IF(XA(K).GT.X)THEN
          KHI=K
        ELSE
          KLO=K
        ENDIF
      GOTO 1
      ENDIF

2     H=XA(KHI)-XA(KLO)

      IF (IMODE.GT.0) THEN

C INTERPOLATION OF Y BY Y=AA*X**BB

        IF (H.NE.0.) THEN
          BB=DLOG(YA(KHI)/YA(KLO))/DLOG(XA(KHI)/XA(KLO))
          Y=YA(KLO)*DEXP(BB*(DLOG(X/XA(KLO))))
        ELSE
C           IF (YA(KLO).NE.YA(KHI)) STOP '*** SR ABSNOSPLI: Bad Input ***'
          Y=YA(KLO)
        ENDIF

      ELSE !(IMODE)

C LINEAR INTERPOLATION

        IF (H.NE.0.) THEN
          Y=YA(KLO)+(X-XA(KLO))/H*(YA(KHI)-YA(KLO))
        ELSE
          Y=YA(KLO)
        ENDIF

      ENDIF !(IMODE)

      KLOLD=KLO
      NOLD=N
      XA1OLD=XA(1)
      XANOLD=XA(N)
      YA1OLD=YA(1)
      YANOLD=YA(N)

      RETURN
      END
+DECK,ABSSPLI.
*CMZ :  2.70/12 01/03/2013  15.45.11  by  Michael Scheer
*CMZ :  2.47/07 14/04/2003  15.17.05  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.49  by  Michael Scheer
*-- Author : Michael Scheer
C**********************************************************************
      SUBROUTINE ABSSPLI(X,Y,N,YP1,YPN,Y2,AA,BB,CC,C)

+seq,gplhint.


      IMPLICIT NONE

+SEQ,CMPARA.

      INTEGER N,J
      DOUBLE PRECISION X(N),Y(N),Y2(N)
      DOUBLE PRECISION AA(N),BB(N),CC(N),C(N)

      DOUBLE PRECISION YP1,YPN

      Y2(1)=YP1
      Y2(N)=YPN

      IF (N.LT.3) RETURN

      C(1)=YP1
      C(N)=YPN

      BB(1)=1.D0
      CC(1)=0.D0

      DO J=2,N-1
          AA(J)=(X(J  )-X(J-1))/6.D0
          BB(J)=(X(J+1)-X(J-1))/3.D0
          CC(J)=(X(J+1)-X(J  ))/6.D0
          C(J)=(Y(J+1)-Y(J  ))/(X(J+1)-X(J  ))
     &          -(Y(J  )-Y(J-1))/(X(J  )-X(J-1))
      ENDDO !J

      DO J=2,N-1

          BB(J)=BB(J)-AA(J)*CC(J-1)
           C(J)= C(J)-AA(J)* C(J-1)
C030414      AA(J)=AA(J)-AA(J)*BB(J-1)

          CC(J)=CC(J)/BB(J)
           C(J)= C(J)/BB(J)
          BB(J)=1.D0

      ENDDO !J

      DO J=N-1,2,-1
         Y2(J)=C(J)-CC(J)*Y2(J+1)
      ENDDO

      RETURN
      END
+DECK,ADDAMPLI.
*CMZ :  4.00/15 27/04/2022  08.29.38  by  Michael Scheer
*CMZ :  3.02/03 03/11/2014  10.39.59  by  Michael Scheer
*CMZ :  3.01/00 17/06/2013  08.45.46  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.10  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  15.45.11  by  Michael Scheer
*CMZ :  2.69/02 08/11/2012  09.57.15  by  Michael Scheer
*CMZ :  2.68/05 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.66/20 06/07/2011  11.58.46  by  Michael Scheer
*CMZ :  2.66/12 24/06/2010  12.50.52  by  Michael Scheer
*CMZ :  2.66/08 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.66/07 10/03/2010  09.23.32  by  Michael Scheer
*CMZ :  2.54/07 27/11/2009  15.57.31  by  Michael Scheer
*CMZ :  2.41/10 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.36/00 08/11/2001  14.44.28  by  Michael Scheer
*CMZ :  2.20/01 19/02/2001  12.17.18  by  Michael Scheer
*CMZ :  2.16/08 31/10/2000  14.40.08  by  Michael Scheer
*CMZ :  2.16/04 19/06/2000  12.30.42  by  Michael Scheer
*CMZ :  2.15/00 18/05/2000  11.40.29  by  Michael Scheer
*CMZ :  2.13/04 21/01/2000  11.45.20  by  Michael Scheer
*CMZ :  2.13/03 17/01/2000  16.17.57  by  Michael Scheer
*CMZ :  2.10/01 22/03/99  10.04.12  by  Michael Scheer
*CMZ :  2.00/02 12/01/99  16.57.12  by  Michael Scheer
*CMZ :  2.00/00 11/01/99  13.31.50  by  Michael Scheer
*-- Author :    Michael Scheer   05/01/99
      SUBROUTINE ADDAMPLI

+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,AFREQF90U.
+SEQ,TRACKF90U.
+SELF.

      use bunchmod

C--- SUBROUTINE ADDAMPLI TO READ, WRITE AND TREAT ARRAY REAIMA OF
C--- COMPLEXE FIELD AMPLITUDES.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,TRACK.
+SEQ,AMPLI.
+SEQ,PHYCON.
+SEQ,CMZSEL.

      CHARACTER(80) CODEAMP,C80
      CHARACTER(134) FILESUPER
      CHARACTER CLAST

      INTEGER IO,IFR,IXYZ,IERROR,IREP,NTOTIN,NTOT2IN
      INTEGER IREPMXP,JCMZNOCMPLX,nelec
      PARAMETER (IREPMXP=1000)

      COMPLEX*16 DPHASE,DMODU,AX,AY,AZ,DDMODU(IREPMXP),DMODU0
     &  ,AX0,AY0,AZ0
      COMPLEX*8 APOLH,APOLR,APOLL,APOL45

      DOUBLE PRECISION AXR,AXI,AYR,AYI,AZR,AZI,PHI0,PHI,TPHASE,OMEGA,RANRMS,
     &  R0,R02,H2,H2R2,GAMMA21,TWOPI,OMEGAR,TMODULATOR,DTMOD
     &  ,DTPHASE,FREQR

      double precision xub,yub,zub,ypub,zpub,gammaub

      REAL STOK1,STOK2,STOK3,STOK4
      REAL XRAN(IREPMXP),xranmar(1),wbuff(10000),rr(2)

      INTEGER IOBSV

      INTEGER IGETLASTCHAR,ILAST
      EXTERNAL IGETLASTCHAR

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'      SUBROUTINE ADDAMPLI:'
      WRITE(LUNGFO,*)

      iampobsv=icbrill
      codeamp=code

      DTPHASE=(WTRA2I+(1.D0/(DMYGAMMA*DMYGAMMA))
     &  *(XSTOP-XSTART)/2.D0)/CLIGHT1
      FREQR=2.D0*PI1/DTPHASE*HBAREV1

      IF (IMAMPLI.GT.0.AND.AMPFREQ.EQ.-9999.D0) THEN
        AMPFREQ=FREQR
      ENDIF !(IMAMPLI.GT.0.AND.AMPFREQ.EQ.-9999.D0)

      if (iamprep.ge.0) then

        IF (ABS(FREQR-AMPFREQ)/FREQR.GT.1.E-6) THEN
          WRITE(LUNGFO,*)'*** WARNING IN ADDAMPLI:'
          WRITE(LUNGFO,*)'1. harmonical and AMPFREQ differ.'
          WRITE(LUNGFO,*)SNGL(FREQR),SNGL(AMPFREQ)
          WRITE(6,*)'*** WARNING IN ADDAMPLI:'
          WRITE(6,*)'1. harmonical and AMPFREQ differ.'
          WRITE(6,*)SNGL(FREQR),SNGL(AMPFREQ)
        ENDIF  !(ABS(FREQR-AMPFREQ)/FREQR.GT.1.E-6)

C CURRENT SETTING MUST AGREE TO SETTING ON FILE WITH AMPLITUDES
C TO HAVE CORRECTLY DEFINED ALLOCATABLE ARRAYS

        nelec=0

      else

        nelec=-iamprep

      endif !iamprep.ge.0

      CALL AMPCHECK(
     &  NSOURCE,NOBSV,NFREQ,IFREQ2P,
     &  NOBSVZ,NOBSVY,MOBSVZ,MOBSVY,
     &  MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY,
     &  PINW,PINH,PINR,IPIN,IF1DIM,IPINCIRC,AMPFREQ,iamprep,
     &  ibunch,iubunch,bunchlen,
     &  IERROR)

      IF (iamprep.ge.0.and.IAMPREP.LT.2
     &    .AND.(AMPPHI(1).NE.0.D0.OR.AMPSHIFT(1).NE.0.D0)) THEN
        C80=
     &    '*** WARNING IN ADDAMPLI: AMPPHI(1) or AMPHSHIFT(1) not zero'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)C80
        WRITE(6,*)
        WRITE(6,*)C80
      ENDIF !(AMPPHI(1).NE.0.D0.OR.AMPHSHIFT(1).NE.0.D0)

      GAMMA21=1.D0/DMYGAMMA/DMYGAMMA
      TWOPI=2.D0*PI1
      OMEGAR=AMPFREQ/HBAREV1

      IAMPREAD=1

      IF (NSOURCE.NE.1) THEN

        WRITE(LUNGFO,*)
     &    ' *** ERROR IN ADDAMPLI: NUMBER OF SOURCES MUST BE ONE!! ***'

        WRITE(6,*)
     &    ' *** ERROR IN ADDAMPLI: NUMBER OF SOURCES MUST BE ONE!! ***'

        STOP '--- PROGRAM ABORTED ---'

      ENDIF !(NSOURCE.NE.1)

      IF (IMAMPLI.GT.0.AND.IAMPSKIP.NE.0) THEN

        WRITE(LUNGFO,*)
     &    ' *** WARNING IN ADDAMPLI: IAMPSKIP.NE.0 .AND. IMAMPLI.GT.0 ***'
        WRITE(LUNGFO,*)
     &    ' *** CHECK NAMELIST $AMPLIN IN INPUT FILE WAVE.IN ***'

        WRITE(6,*)
     &    ' *** WARNING IN ADDAMPLI: IAMPSKIP.NE.0 .AND. IMAMPLI.GT.0 ***'
        WRITE(6,*)
     &    ' *** CHECK NAMELIST $AMPLIN IN INPUT FILE WAVE.IN ***'

      ENDIF !(IAMPSKIP.NE.0)

      IF (IMAMPLI.LT.0.AND.IAMPSKIP.EQ.0) THEN

        WRITE(LUNGFO,*)
     &    ' *** WARNING IN ADDAMPLI: IAMPSKIP.EQ.0 .AND. IMAMPLI.LT.0 ***'
        WRITE(LUNGFO,*)
     &    ' *** CHECK NAMELIST $AMPLIN IN INPUT FILE WAVE.IN ***'

        WRITE(6,*)
     &    ' *** WARNING IN ADDAMPLI: IAMPSKIP.EQ.0 .AND. IMAMPLI.LT.0 ***'
        WRITE(6,*)
     &    ' *** CHECK NAMELIST $AMPLIN IN INPUT FILE WAVE.IN ***'

      ENDIF !(IMAMPLI.LT.0.AND.IAMPSKIP.EQ.0)

      IF (IMAMPLI.EQ.1.OR.IMAMPLI.EQ.3) THEN

C--- CREATE NEW FILE AND WRITE TO IT

        OPEN(UNIT=LUNAMPLI,FILE=FILEAMPLI,STATUS='unknown'
     &    ,FORM='FORMATTED')

        WRITE(LUNAMPLI,*)ICODE,' ',CODE
        WRITE(LUNAMPLI,*)ICMZNOCMPLX
        WRITE(LUNAMPLI,*)
        WRITE(LUNAMPLI,*)NSOURCE,NOBSV,NFREQ,IFREQ2P
        WRITE(LUNAMPLI,*)NOBSVZ,NOBSVY,MOBSVZ,MOBSVY
        WRITE(LUNAMPLI,*)MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY
        WRITE(LUNAMPLI,*)IPIN,IF1DIM,IPINCIRC
        WRITE(LUNAMPLI,*)IBUNCH,IUBUNCH,BUNCHLEN
        WRITE(LUNAMPLI,*)
        WRITE(LUNAMPLI,*)PINCEN
        WRITE(LUNAMPLI,*)PINW,PINH,PINR
        WRITE(LUNAMPLI,*)OBSVDZ,OBSVDY
        WRITE(LUNAMPLI,*)
        WRITE(LUNAMPLI,*)SPECNOR
        WRITE(LUNAMPLI,*)VPOLA(1)
        WRITE(LUNAMPLI,*)VPOLA(2)
        WRITE(LUNAMPLI,*)VPOLA(3)
        WRITE(LUNAMPLI,*)VSTOKES(1,1)
        WRITE(LUNAMPLI,*)VSTOKES(1,2)
        WRITE(LUNAMPLI,*)VSTOKES(1,3)
        WRITE(LUNAMPLI,*)VSTOKES(2,1)
        WRITE(LUNAMPLI,*)VSTOKES(2,2)
        WRITE(LUNAMPLI,*)VSTOKES(2,3)
        WRITE(LUNAMPLI,*)VSTOKES(3,1)
        WRITE(LUNAMPLI,*)VSTOKES(3,2)
        WRITE(LUNAMPLI,*)VSTOKES(3,3)
        WRITE(LUNAMPLI,*)VSTOKES(4,1)
        WRITE(LUNAMPLI,*)VSTOKES(4,2)
        WRITE(LUNAMPLI,*)VSTOKES(4,3)
        WRITE(LUNAMPLI,*)

        WRITE(LUNAMPLI,*)(OBSVZ(IO),IO=1,NOBSVZ)
        WRITE(LUNAMPLI,*)
        WRITE(LUNAMPLI,*)(OBSVY(IO),IO=1,NOBSVY)
        WRITE(LUNAMPLI,*)

        DO IO=1,NOBSV
          WRITE(LUNAMPLI,*)(OBSV(IXYZ,IO),IXYZ=1,3)
        ENDDO

        WRITE(LUNAMPLI,*)AMPFREQ
        WRITE(LUNAMPLI,*)

        DO IFR=1,NFREQ
          WRITE(LUNAMPLI,*)
          WRITE(LUNAMPLI,*)FREQ(IFR)
          DO IO=1,NOBSV
            IOBFR=IO+NOBSV*(IFR-1)
            WRITE(LUNAMPLI,*)
     &        REAIMA(1,1,IOBFR),REAIMA(1,2,IOBFR)
            WRITE(LUNAMPLI,*)
     &        REAIMA(2,1,IOBFR),REAIMA(2,2,IOBFR)
            WRITE(LUNAMPLI,*)
     &        REAIMA(3,1,IOBFR),REAIMA(3,2,IOBFR)
          ENDDO
        ENDDO
        WRITE(LUNAMPLI,*)

        WRITE(LUNGFO,*)'      array REAIMA written to file'
        WRITE(LUNGFO,*)'      ',FILEAMPLI
        WRITE(LUNGFO,*)

        CLOSE(LUNAMPLI)

        IF (IMAMPLI.EQ.3) THEN
C--- WRITE FILES FOR PROGRAM PHASE OF JOHANNES BAHRDT
          CALL PHASE_BAHRDT
        ENDIF

      ELSE IF (IMAMPLI.EQ.2) THEN

C--- WRITE TO END OF EXISTING FILE

        OPEN(UNIT=LUNAMPLI,FILE=FILEAMPLI,STATUS='OLD'
     &    ,FORM='FORMATTED',ACCESS='APPEND')

        WRITE(LUNAMPLI,*)ICODE,' ',CODE
        WRITE(LUNAMPLI,*)ICMZNOCMPLX
        WRITE(LUNAMPLI,*)
        WRITE(LUNAMPLI,*)NSOURCE,NOBSV,NFREQ,IFREQ2P
        WRITE(LUNAMPLI,*)NOBSVZ,NOBSVY,MOBSVZ,MOBSVY
        WRITE(LUNAMPLI,*)MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY
        WRITE(LUNAMPLI,*)IPIN,IF1DIM,IPINCIRC
        WRITE(LUNAMPLI,*)
        WRITE(LUNAMPLI,*)PINCEN
        WRITE(LUNAMPLI,*)PINW,PINH,PINR
        WRITE(LUNAMPLI,*)OBSVDZ,OBSVDY
        WRITE(LUNAMPLI,*)
        WRITE(LUNAMPLI,*)SPECNOR
        WRITE(LUNAMPLI,*)VPOLA(1)
        WRITE(LUNAMPLI,*)VPOLA(2)
        WRITE(LUNAMPLI,*)VPOLA(3)
        WRITE(LUNAMPLI,*)VSTOKES(1,1)
        WRITE(LUNAMPLI,*)VSTOKES(1,2)
        WRITE(LUNAMPLI,*)VSTOKES(1,3)
        WRITE(LUNAMPLI,*)VSTOKES(2,1)
        WRITE(LUNAMPLI,*)VSTOKES(2,2)
        WRITE(LUNAMPLI,*)VSTOKES(2,3)
        WRITE(LUNAMPLI,*)VSTOKES(3,1)
        WRITE(LUNAMPLI,*)VSTOKES(3,2)
        WRITE(LUNAMPLI,*)VSTOKES(3,3)
        WRITE(LUNAMPLI,*)VSTOKES(4,1)
        WRITE(LUNAMPLI,*)VSTOKES(4,2)
        WRITE(LUNAMPLI,*)VSTOKES(4,3)
        WRITE(LUNAMPLI,*)

        WRITE(LUNAMPLI,*)(OBSVZ(IO),IO=1,NOBSVZ)
        WRITE(LUNAMPLI,*)
        WRITE(LUNAMPLI,*)(OBSVY(IO),IO=1,NOBSVY)
        WRITE(LUNAMPLI,*)

        DO IO=1,NOBSV
          WRITE(LUNAMPLI,*)(OBSV(IXYZ,IO),IXYZ=1,3)
        ENDDO

        WRITE(LUNAMPLI,*)AMPFREQ
        WRITE(LUNAMPLI,*)

        DO IFR=1,NFREQ
          WRITE(LUNAMPLI,*)
          WRITE(LUNAMPLI,*)FREQ(IFR)
          DO IO=1,NOBSV
            IOBFR=IO+NOBSV*(IFR-1)
            WRITE(LUNAMPLI,*)
     &        REAIMA(1,1,IOBFR),REAIMA(1,2,IOBFR)
            WRITE(LUNAMPLI,*)
     &        REAIMA(2,1,IOBFR),REAIMA(2,2,IOBFR)
            WRITE(LUNAMPLI,*)
     &        REAIMA(3,1,IOBFR),REAIMA(3,2,IOBFR)
          ENDDO
        ENDDO

        WRITE(LUNAMPLI,*)

        WRITE(LUNGFO,*)'      array REAIMA written to file'
        WRITE(LUNGFO,*)'      ',FILEAMPLI
        WRITE(LUNGFO,*)

        CLOSE(LUNAMPLI)

      ELSE IF (IMAMPLI.EQ.-1.OR.IMAMPLI.EQ.-3
     &    .or.
     &    imampli.eq.0.and.iampskip.eq.0.and.iamprep.lt.0) THEN

C--- READ REAIMA FROM FILE, OVERWRITTING ARRAY

        IF (IMAMPLI.EQ.-1.OR.IMAMPLI.EQ.-3) then

          OPEN(UNIT=LUNAMPLI,FILE=FILEAMPLI,STATUS='OLD'
     &      ,FORM='FORMATTED')

          WRITE(LUNGFO,*)'      reading spectra from file'
          WRITE(LUNGFO,*)'      ',FILEAMPLI
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '      length for phaseshifts [m], scaling factors, '//
     &      'jobnumbers and comments:'
          WRITE(LUNGFO,*)

          IAMPREAD=0

          AXR=0.0D0
          AYR=0.0D0
          AZR=0.0D0

          AXI=0.0D0
          AYI=0.0D0
          AZI=0.0D0

          DO IFR=1,NFREQ
            DO IO=1,NOBSV

              IOBFR=IO+NOBSV*(IFR-1)
              AFREQ(1,IOBFR)=(0.D0,0.D0)
              AFREQ(2,IOBFR)=(0.D0,0.D0)
              AFREQ(3,IOBFR)=(0.D0,0.D0)

            ENDDO !NOBSV
          ENDDO   !NFREQ

        end IF !(IMAMPLI.EQ.-1.OR.IMAMPLI.EQ.-3) then

10      CONTINUE

        IF (IMAMPLI.EQ.-1.OR.IMAMPLI.EQ.-3) then

          READ(LUNAMPLI,'(A80)',END=90)CODEAMP
          READ(LUNAMPLI,*)JCMZNOCMPLX
          IF (JCMZNOCMPLX.NE.ICMZNOCMPLX) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*) '*** ERROR IN ADDAMPLI ***'
            WRITE(LUNGFO,*)
     &        'DIFFERENT WAVE VERSION CONCERNING COMPLEX NUMBERS'
            WRITE(LUNGFO,*) 'USED FOR WRITING AND READING FILEAMPLI'
            WRITE(LUNGFO,*) '*** PROGRAM WAVE ABORTED ***'
            STOP
          ENDIF
          READ(LUNAMPLI,*)
          READ(LUNAMPLI,*)NSOURCE,NOBSV,NFREQ,IFREQ2P
          READ(LUNAMPLI,*)NOBSVZ,NOBSVY,MOBSVZ,MOBSVY
          READ(LUNAMPLI,*)MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY
          READ(LUNAMPLI,*)IPIN,IF1DIM,IPINCIRC
          read(LUNAMPLI,*)IBUNCH,IUBUNCH,BUNCHLEN
          READ(LUNAMPLI,*)
          READ(LUNAMPLI,*)PINCEN
          READ(LUNAMPLI,*)PINW,PINH,PINR

          IAMPOBSV=0
          DO IOBSV=1,NOBSV
            IF (ABS(OBSV(2,IOBSV)).LT.1.D-15
     &          .AND.ABS(OBSV(3,IOBSV)).LT.1.D-15) THEN
              IF (IAMPOBSV.NE.0) THEN
                WRITE(LUNGFO,*)
     &            ' *** ERROR IN ADDAMPLI: on-axis observation '//
     &            'point not unique ***'
                WRITE(6,*)
     &            ' *** ERROR IN ADDAMPLI: on-axis observation '//
     &            'point not unique ***'
                STOP '--- PROGRAM ABORTED ---'
              ENDIF  !IAMPOBSV.NE.0
              IAMPOBSV=IOBSV
            ENDIF !ABS(OBSV(3,IOBSV)).LT.1.D-15
          ENDDO   !NOBSV

          IF (IAMPOBSV.EQ.0) THEN
            WRITE(LUNGFO,*)
     &        ' *** ERROR IN ADDAMPLI: no on-axis observation point found ***'
            WRITE(6,*)
     &        ' *** ERROR IN ADDAMPLI: no on-axis observation point found ***'
            STOP '--- PROGRAM ABORTED ---'
          ENDIF   !IAMPOBSV.NE.0

          READ(LUNAMPLI,*)OBSVDZ,OBSVDY
          READ(LUNAMPLI,*)
          READ(LUNAMPLI,*)SPECNOR
          READ(LUNAMPLI,*)VPOLA(1)
          READ(LUNAMPLI,*)VPOLA(2)
          READ(LUNAMPLI,*)VPOLA(3)
          READ(LUNAMPLI,*)VSTOKES(1,1)
          READ(LUNAMPLI,*)VSTOKES(1,2)
          READ(LUNAMPLI,*)VSTOKES(1,3)
          READ(LUNAMPLI,*)VSTOKES(2,1)
          READ(LUNAMPLI,*)VSTOKES(2,2)
          READ(LUNAMPLI,*)VSTOKES(2,3)
          READ(LUNAMPLI,*)VSTOKES(3,1)
          READ(LUNAMPLI,*)VSTOKES(3,2)
          READ(LUNAMPLI,*)VSTOKES(3,3)
          READ(LUNAMPLI,*)VSTOKES(4,1)
          READ(LUNAMPLI,*)VSTOKES(4,2)
          READ(LUNAMPLI,*)VSTOKES(4,3)
          READ(LUNAMPLI,*)
          READ(LUNAMPLI,*)(OBSVZ(IO),IO=1,NOBSVZ)
          READ(LUNAMPLI,*)
          READ(LUNAMPLI,*)(OBSVY(IO),IO=1,NOBSVY)
          READ(LUNAMPLI,*)

          DO IO=1,NOBSV
            READ(LUNAMPLI,*)(OBSV(IXYZ,IO),IXYZ=1,3)
          ENDDO

          READ(LUNAMPLI,*)AMPFREQ
          READ(LUNAMPLI,*)

          DO IFR=1,NFREQ
            READ(LUNAMPLI,*)
            READ(LUNAMPLI,*)FREQ(IFR)
            DO IO=1,NOBSV
              IOBFR=IO+NOBSV*(IFR-1)
              READ(LUNAMPLI,*)
     &          REAIMA(1,1,IOBFR),REAIMA(1,2,IOBFR)
              READ(LUNAMPLI,*)
     &          REAIMA(2,1,IOBFR),REAIMA(2,2,IOBFR)
              READ(LUNAMPLI,*)
     &          REAIMA(3,1,IOBFR),REAIMA(3,2,IOBFR)
            ENDDO !NOBSV
          ENDDO   !NFREQ

          READ(LUNAMPLI,*)

          CALL AMPCHECK(
     &      NSOURCE,NOBSV,NFREQ,IFREQ2P,
     &      NOBSVZ,NOBSVY,MOBSVZ,MOBSVY,
     &      MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY,
     &      PINW,PINH,PINR,IPIN,IF1DIM,IPINCIRC,AMPFREQ,iamprep,
     &      ibunch,iubunch,bunchlen,
     &      IERROR)

          IF (IERROR.NE.0) THEN
            WRITE(LUNGFO,*)
     &        ' *** ERROR IN ADDAMPLI: data on file incompatible ***'
            WRITE(6,*)
     &        ' *** ERROR IN ADDAMPLI: data on file incompatible ***'
            STOP '--- PROGRAM ABORTED ---'
          ENDIF   !IERROR

          IAMPREAD=IAMPREAD+1

        end if !(IMAMPLI.EQ.-1.OR.IMAMPLI.EQ.-3

        IF (IAMPREP.GT.1.AND.IAMPREAD.GT.1) THEN
          WRITE(LUNGFO,*)
     &      ' *** ERROR IN ADDAMPLI: IAMPREP > 1, but more than ***'
          WRITE(LUNGFO,*)
     &      ' *** one device on amplitude file ***'
          WRITE(6,*)
     &      ' *** ERROR IN ADDAMPLI: IAMPREP > 1, but more than ***'
          WRITE(6,*)
     &      ' *** one device on amplitude file ***'
          STOP '--- PROGRAM ABORTED ---'
        ENDIF  !(IAMPREP.GT.0.AND.IAMPREAD.GT.1)

        IF ((IAMPREAD.GT.1.OR.IAMPREP.GT.1).AND.
     &      (AMPPHI(IAMPREAD).EQ.0.D0
     &      .OR.AMPSHIFT(IAMPREAD).EQ.0.D0)) THEN
          C80=
     &      '*** WARNING IN ADDAMPLI: AMPPHI(N) or AMPHSHIFT(N) zero'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)C80
          WRITE(LUNGFO,*)'N=',IAMPREAD
          WRITE(6,*)
          WRITE(6,*)C80
          WRITE(6,*)'N=',IAMPREAD
        ENDIF  !(AMPPHI(N).EQ.0.D0

        IF (IAMPREAD.GT.IAMPDIMP) THEN

          WRITE(LUNGFO,*)
     &      ' *** ERROR IN ADDAMPLI: DIMENSION IAMPDIMP EXCEEDED ***'
          WRITE(6,*)
     &      ' *** ERROR IN ADDAMPLI: INCREASE IAMPDIMP IN AMPLI.CMN ***'

          STOP '--- PROGRAM ABORTED ---'

        ENDIF  !(IAMPREAD.GT.IAMPDIMP)

        WRITE(LUNGFO,*)
     &    '      ',IAMPREAD,AMPSHIFT(IAMPREAD),AMPSCALE(IAMPREAD)
        WRITE(LUNGFO,*)'      ',CODEAMP
        WRITE(LUNGFO,*)

C PHASE ADVANCE OF MODULATOR IN TIME

        dtmod=0.0d0
        IF (AMPPHI(IAMPREAD).LT.0.D0) THEN
          DTMOD=-AMPPHI(IAMPREAD)/CLIGHT1
        ELSE if (omegar.ne.0.0d0) then !(AMPPHI(IAMPREAD).LT.0.D0)
          DTMOD=TWOPI*AMPPHI(IAMPREAD)/OMEGAR
        ENDIF  !(AMPPHI(IAMPREAD).LT.0.D0)

        TMODULATOR=DTMOD-AMPSHIFT(IAMPREAD)/2.D0/CLIGHT1*GAMMA21

        IF (TMODULATOR.LT.0.D0) THEN
          WRITE(LUNGFO,*)
     &      '*** ERROR IN ADDAMPLI: phaseshift lower than zero for device ',IAMPREAD
          WRITE(6,*)
     &      '*** ERROR IN ADDAMPLI: phaseshift lower than zero for device ',IAMPREAD
          STOP '--- PROGRAM ABORTED ---'
        ENDIF  !(TMODULATOR.LT.0.D0)

        R0=OBSV(1,IAMPOBSV)
        R02=R0*R0

        DO IFR=1,NFREQ

C--- ADJUST PHASE TO GIVEN OBSERVATION POINT AND COMPONENT

          IOBFR=IAMPOBSV+NOBSV*(IFR-1)

          if (iamprep.gt.0) then

            IF (REAIMA(IAMPCOMP,1,IOBFR).EQ.0.D0
     &          .AND.REAIMA(IAMPCOMP,2,IOBFR).EQ.0.D0) THEN
              PHI0=-9999.
            ELSE
              PHI0=ATAN2
     &          (REAIMA(IAMPCOMP,2,IOBFR)
     &          ,REAIMA(IAMPCOMP,1,IOBFR))
            ENDIF

            IF (PHI0.EQ.-9999.) THEN

              WRITE(LUNGFO,*)
     &          ' *** ERROR IN ADDAMPLI: PHASE ADJUSTMENT FAILED ***'
              WRITE(LUNGFO,*)
     &          ' TRY DIFFERENT IAMPCOMP IN NAMELIST AMPLIN'
              WRITE(LUNGFO,*)'IAMPCOMP NOW:',IAMPCOMP
              WRITE(LUNGFO,*)'IFREQ, IOBSV:',IFR,IAMPOBSV
              WRITE(LUNGFO,*)'REAIMA(IAMPCOMP,1,IOBFR):',
     &          REAIMA(IAMPCOMP,1,IOBFR)
              WRITE(LUNGFO,*)'REAIMA(IAMPCOMP,2,IOBFR):',
     &          REAIMA(IAMPCOMP,2,IOBFR)

              WRITE(6,*)
     &          ' *** ERROR IN ADDAMPLI: PHASE ADJUSTMENT FAILED ***'
              WRITE(6,*)
     &          ' TRY DIFFERENT IAMPCOMP IN NAMELIST AMPLIN'
              WRITE(6,*)'IAMPCOMP NOW:',IAMPCOMP
              WRITE(6,*)'IFREQ, IOBSV:',IFR,IAMPOBSV
              WRITE(6,*)'REAIMA(IAMPCOMP,1,IOBFR):',
     &          REAIMA(IAMPCOMP,1,IOBFR)
              WRITE(6,*)'REAIMA(IAMPCOMP,2,IOBFR):',
     &          REAIMA(IAMPCOMP,2,IOBFR)

              WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
              WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
              STOP

            ENDIF !(PHI0.EQ.0.D0)

          else ! iamprep>0
            phi0=0.0d0
          ENDIF   ! iamprep>0

          DO IO=1,NOBSV

            if (iamprep.gt.0) then
              H2= OBSV(2,IO)**2+OBSV(3,IO)**2
              H2R2=H2/R02
              TPHASE=TMODULATOR+AMPSHIFT(IAMPREAD)*(H2R2+GAMMA21)
     &          /2.D0/CLIGHT1
            else
              tphase=0.0d0
            endif

            OMEGA=FREQ(IFR)/HBAREV1
            PHI=TPHASE*OMEGA

            DPHASE=CDEXP (DCMPLX(0.D0,PHI-PHI0))
            DMODU=DCMPLX(AMPSCALE(IAMPREAD),0.D0)*DPHASE

            IOBFR=IO+NOBSV*(IFR-1)

            AXR=REAIMA(1,1,IOBFR)
            AYR=REAIMA(2,1,IOBFR)
            AZR=REAIMA(3,1,IOBFR)
            AXI=REAIMA(1,2,IOBFR)
            AYI=REAIMA(2,2,IOBFR)
            AZI=REAIMA(3,2,IOBFR)

            AX=DCMPLX(AXR,AXI)*DMODU
            AY=DCMPLX(AYR,AYI)*DMODU
            AZ=DCMPLX(AZR,AZI)*DMODU

            IOBFR=IO+NOBSV*(IFR-1)
            AFREQ(1,IOBFR)=AFREQ(1,IOBFR)+AX
            AFREQ(2,IOBFR)=AFREQ(2,IOBFR)+AY
            AFREQ(3,IOBFR)=AFREQ(3,IOBFR)+AZ

          ENDDO   !NOBSV
        ENDDO  !NFREQ

        IF (IMAMPLI.EQ.-1.OR.IMAMPLI.EQ.-3) then
          GOTO 10
        ENDIF

90      continue
        IF (IMAMPLI.EQ.-1.OR.IMAMPLI.EQ.-3) then
          CLOSE(LUNAMPLI)
        endif

C--- SPECTRUM ARRAYS{

        IF (IAMPREP.NE.0) THEN

          IF (IAMPREP.GT.IREPMXP) THEN
            WRITE(LUNGFO,*)
     &        ' *** ERROR IN ADDAMPLI: DIMENSION IAMPMXP EXCEEDED ***'
            WRITE(6,*)
     &        ' *** ERROR IN ADDAMPLI: DIMENSION IAMPMXP EXCEEDED ***'
            STOP '--- PROGRAM ABORTED ---'
          ENDIF

          if (iampseed.gt.0) then

            IF (IAMPSEED.NE.0) THEN
              CALL RMARIN(IAMPSEED,NTOTIN,NTOT2IN) !CERN V113
            ENDIF

            CALL RNORML(XRAN,IAMPREP,rr)

            DO IREP=1,IAMPREP
              XRAN(IREP)=AMPRAN*XRAN(IREP)
              RANRMS=RANRMS+XRAN(IREP)**2
            ENDDO
            RANRMS=SQRT(RANRMS/IAMPREP)

          end if !(iampseed.gt.0) then

          DO IFR=1,NFREQ
            DO IO=1,NOBSV

              IOBFR=IO+NOBSV*(IFR-1)
              REAIMA(1,1,IOBFR)=0.D0
              REAIMA(2,1,IOBFR)=0.D0
              REAIMA(3,1,IOBFR)=0.D0
              REAIMA(1,2,IOBFR)=0.D0
              REAIMA(2,2,IOBFR)=0.D0
              REAIMA(3,2,IOBFR)=0.D0

            ENDDO !NOBSV
          ENDDO   !NFREQ

          R0=OBSV(1,IAMPOBSV)
          R02=R0*R0

          if (iamprep.gt.0) then

            DO IFR=1,NFREQ
              DO IO=1,NOBSV

cerror? 10.3.2010              if (iampseed.gt.0) then
                if (iampread.gt.0) then

                  H2= OBSV(2,IO)**2+OBSV(3,IO)**2
                  H2R2=H2/R02

                  TPHASE=TMODULATOR+AMPSHIFT(IAMPREAD)*(H2R2+GAMMA21)
     &              /2.D0/CLIGHT1

                  OMEGA=FREQ(IFR)/HBAREV1
                  PHI=TPHASE*OMEGA

                  DMODU=CDEXP(DCMPLX(0.D0,PHI))
                  DMODU0=DMODU

                endif !iampread.gt.0

                IOBFR=IO+NOBSV*(IFR-1)

                AX=AFREQ(1,IOBFR)
                AY=AFREQ(2,IOBFR)
                AZ=AFREQ(3,IOBFR)
                AX0=AX
                AY0=AY
                AZ0=AZ

                DO IREP=1,IAMPREP

                  IF (AMPRAN.NE.0.D0) THEN
                    PHI=XRAN(IREP)*TWOPI/OMEGAR*OMEGA
                    DDMODU(IREP)=CDEXP(DCMPLX(0.D0,PHI))
                  ENDIF   !AMPRAN

                  IOBFR=IO+NOBSV*(IFR-1)
                  REAIMA(1,1,IOBFR)=REAIMA(1,1,IOBFR)+DREAL(AX)
                  REAIMA(2,1,IOBFR)=REAIMA(2,1,IOBFR)+DREAL(AY)
                  REAIMA(3,1,IOBFR)=REAIMA(3,1,IOBFR)+DREAL(AZ)
                  REAIMA(1,2,IOBFR)=REAIMA(1,2,IOBFR)+DIMAG(AX)
                  REAIMA(2,2,IOBFR)=REAIMA(2,2,IOBFR)+DIMAG(AY)
                  REAIMA(3,2,IOBFR)=REAIMA(3,2,IOBFR)+DIMAG(AZ)

                  IF (AMPRAN.NE.0.D0) THEN

                    DMODU=DMODU0*DDMODU(IREP)

                    AX0=AX0*DMODU0
                    AY0=AY0*DMODU0
                    AZ0=AZ0*DMODU0
                    AX=AX0*DDMODU(IREP)
                    AY=AY0*DDMODU(IREP)
                    AZ=AZ0*DDMODU(IREP)

                  ELSE    !(AMPRAN.NE.0.D0)

                    AX=AX*DMODU
                    AY=AY*DMODU
                    AZ=AZ*DMODU

                  ENDIF   !(AMPRAN.NE.0.D0)

                ENDDO   !IAMPREP

              ENDDO !IFR=1,NFREQ
            ENDDO !IO=1,NOBSV

          else !if (iamprep.gt.0) then

            DO IREP=1,nelec

              if (iampcoh.eq.0) then
                CALL RNORML(xranmar,1,rr)
c                call ranmar(xranmar,1)
                tphase=ampcohsig*xranmar(1)/clight1
              else if (iampcoh.eq.2.or.iampcoh.eq.3.or.iampcoh.eq.4) then
                call bunch(tphase)
              else if (iampcoh.eq.-1) then
                call ubunch(xub,yub,zub,ypub,zpub,gammaub,tphase)
              else
                write(lungfo,*)' *** Error in ADDAMPLI: Bad value for IAMPCOH!'
                write(6,*)' *** Error in ADDAMPLI: Bad value for IAMPCOH!'
                stop '*** Program WAVE aborted ***'
              endif

              if (irep.le.10000) then
                wbuff(irep)=tphase*clight1*1.0e9
              endif

              DO IFR=1,NFREQ
                DO IO=1,NOBSV

                  IOBFR=IO+NOBSV*(IFR-1)

                  AX0=AFREQ(1,IOBFR)
                  AY0=AFREQ(2,IOBFR)
                  AZ0=AFREQ(3,IOBFR)

                  OMEGA=FREQ(IFR)/HBAREV1
                  PHI=TPHASE*OMEGA

                  DMODU=CDEXP(DCMPLX(0.D0,PHI))

                  !(AX0,AY0,AZ0)*DMODU since we deal with absolute phases here
                  AX=AX0*DMODU
                  AY=AY0*DMODU
                  AZ=AZ0*DMODU

                  IOBFR=IO+NOBSV*(IFR-1)

                  REAIMA(1,1,IOBFR)=REAIMA(1,1,IOBFR)+DREAL(AX)
                  REAIMA(2,1,IOBFR)=REAIMA(2,1,IOBFR)+DREAL(AY)
                  REAIMA(3,1,IOBFR)=REAIMA(3,1,IOBFR)+DREAL(AZ)
                  REAIMA(1,2,IOBFR)=REAIMA(1,2,IOBFR)+DIMAG(AX)
                  REAIMA(2,2,IOBFR)=REAIMA(2,2,IOBFR)+DIMAG(AY)
                  REAIMA(3,2,IOBFR)=REAIMA(3,2,IOBFR)+DIMAG(AZ)

                ENDDO !IFR=1,NFREQ
              ENDDO !IO=1,NOBSV

            ENDDO   !IAMPREP

            if (ampbunchcharge.ne.0.0d0) then
              reaima=reaima*sqrt(abs(AMPBUNCHCHARGE)/echarge1/nelec**2)
            else
              reaima=reaima/sqrt(dble(nelec))
            endif

            open(unit=99,file='wave_bunch.dat')
            do irep=1,min(nelec,10000)
              write(99,*)wbuff(irep)
            enddo
            close(99)

          end if !(iamprep.gt.0) then

          DO IFR=1,NFREQ
            DO IO=1,NOBSV

              IOBFR=IO+NOBSV*(IFR-1)
              AXR=REAIMA(1,1,IOBFR)
              AYR=REAIMA(2,1,IOBFR)
              AZR=REAIMA(3,1,IOBFR)
              AXI=REAIMA(1,2,IOBFR)
              AYI=REAIMA(2,2,IOBFR)
              AZI=REAIMA(3,2,IOBFR)


              AX=DCMPLX(AXR,AXI)
              AY=DCMPLX(AYR,AYI)
              AZ=DCMPLX(AZR,AZI)

              IOBFR=IO+NOBSV*(IFR-1)
              AFREQ(1,IOBFR)=AX
              AFREQ(2,IOBFR)=AY
              AFREQ(3,IOBFR)=AZ

            ENDDO   !NOBSV
          ENDDO   !NFREQ

        ENDIF   !(IAMPREP.NE.0)

        DO IFR=1,NFREQ
          DO IO=1,NOBSV

            IOBFR=IO+NOBSV*(IFR-1)

            AXR=DREAL(AFREQ(1,IOBFR))
            AYR=DREAL(AFREQ(2,IOBFR))
            AZR=DREAL(AFREQ(3,IOBFR))

            AXI=DIMAG(AFREQ(1,IOBFR))
            AYI=DIMAG(AFREQ(2,IOBFR))
            AZI=DIMAG(AFREQ(3,IOBFR))

            REAIMA(1,1,IOBFR)=AXR
            REAIMA(2,1,IOBFR)=AYR
            REAIMA(3,1,IOBFR)=AZR
            REAIMA(1,2,IOBFR)=AXI
            REAIMA(2,2,IOBFR)=AYI
            REAIMA(3,2,IOBFR)=AZI


            SPEC(1+NSOURCE*(IO-1+NOBSV*(IFR-1)))=
     &        (AXR*AXR+AXI*AXI
     &        +AYR*AYR+AYI*AYI
     &        +AZR*AZR+AZI*AZI
     &        )*SPECNOR

            IF (ISTOKES.NE.0) THEN

              AX=DCMPLX(AXR,AXI)
              AY=DCMPLX(AYR,AYI)
              AZ=DCMPLX(AZR,AZI)

              APOLH=
     &          AX*CONJG(VSTOKES(1,1))
     &          +AY*CONJG(VSTOKES(1,2))
     &          +AZ*CONJG(VSTOKES(1,3))

              APOLR=
     &          AX*CONJG(VSTOKES(2,1))
     &          +AY*CONJG(VSTOKES(2,2))
     &          +AZ*CONJG(VSTOKES(2,3))

              APOLL=
     &          AX*CONJG(VSTOKES(3,1))
     &          +AY*CONJG(VSTOKES(3,2))
     &          +AZ*CONJG(VSTOKES(3,3))

              APOL45=
     &          AX*CONJG(VSTOKES(4,1))
     &          +AY*CONJG(VSTOKES(4,2))
     &          +AZ*CONJG(VSTOKES(4,3))

              STOK1=
     &          REAL(APOLR*CONJG(APOLR))+
     &          REAL(APOLL*CONJG(APOLL))

              STOK2=-STOK1+
     &          2.*REAL(APOLH*CONJG(APOLH))

              STOK3=
     &          2.*REAL(APOL45*CONJG(APOL45))-
     &          STOK1

              STOK4=
     &          REAL(APOLR*CONJG(APOLR))-
     &          REAL(APOLL*CONJG(APOLL))


              IOBFR=IO+NOBSV*(IFR-1)
              STOKES(1,IOBFR)=STOK1*SPECNOR
              STOKES(2,IOBFR)=STOK2*SPECNOR
              STOKES(3,IOBFR)=STOK3*SPECNOR
              STOKES(4,IOBFR)=STOK4*SPECNOR

            ENDIF !ISTOKES

          ENDDO   !NOBSV
        ENDDO  !NFREQ

        IF (IMAMPLI.EQ.-3) THEN
C--- WRITE FILES FOR PROGRAM PHASE OF JOHANNES BAHRDT
          CALL PHASE_BAHRDT
        ENDIF

C--- SPECTRUM ARRAYS}

      ELSE  !IMAMPLI

        WRITE(LUNGFO,*)
     &    ' *** ERROR IN ADDAMPLI: UNDEFINED MODE REQUESTED ***'
        WRITE(LUNGFO,*)
     &    ' CHECK IMAMPLI IN NAMELIST $AMPLIN IN INPUT FILE'
        WRITE(6,*)
     &    ' *** ERROR IN ADDAMPLI: UNDEFINED MODE REQUESTED ***'
        WRITE(6,*)
     &    ' CHECK IMAMPLI IN NAMELIST $AMPLIN IN INPUT FILE'

        STOP '--- PROGRAM ABORTED ---'

      ENDIF !IMAMPLI

      IF (NSOURCE.NE.1) THEN

        WRITE(LUNGFO,*)
     &    ' *** ERROR IN ADDAMPLI: NUMBER OF SOURCES MUST BE ONE!! ***'

        WRITE(6,*)
     &    ' *** ERROR IN ADDAMPLI: NUMBER OF SOURCES MUST BE ONE!! ***'

        STOP '--- PROGRAM ABORTED ---'

      ENDIF !(NSOURCE.NE.1)

      WRITE(LUNGFO,*)
     &  '      MODE (IMAMPLI, IAMPTERM): ',IMAMPLI,IAMPTERM
      WRITE(LUNGFO,*)
     &  '             IAMPCOMP: ',IAMPCOMP
      WRITE(LUNGFO,*)
     &  '             IAMPREP,IAMPSUP:   ',IAMPREP,IAMPSUP
      WRITE(LUNGFO,*)
     &  '             AMPRAN, IAMPSEED:  '
     &  ,SNGL(AMPRAN),IAMPSEED
      WRITE(LUNGFO,*)
     &  '             AMPFREQ,AMPPHI:    ',SNGL(AMPFREQ),AMPPHI(IAMPREAD)
      WRITE(LUNGFO,*)
     &  '             DETOUR OF e- [m]:  ',DTMOD*CLIGHT1
      WRITE(LUNGFO,*)

      IF (IAMPSUP.EQ.1) THEN

C--- CREATE NEW FILE AND WRITE RESULTING REAIMA TO IT

        ILAST=IGETLASTCHAR(1,128,FILEAMPLI,CLAST)
        FILESUPER=FILEAMPLI(1:ILAST)//'_SUPER'

        OPEN(UNIT=LUNAMPLI,FILE=FILESUPER,STATUS='unknown'
     &    ,FORM='FORMATTED')

        WRITE(LUNAMPLI,*)ICODE,' ',CODE
        WRITE(LUNAMPLI,*)ICMZNOCMPLX
        WRITE(LUNAMPLI,*)
        WRITE(LUNAMPLI,*)NSOURCE,NOBSV,NFREQ,IFREQ2P
        WRITE(LUNAMPLI,*)NOBSVZ,NOBSVY,MOBSVZ,MOBSVY
        WRITE(LUNAMPLI,*)MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY
        WRITE(LUNAMPLI,*)IPIN,IF1DIM,IPINCIRC
        WRITE(LUNAMPLI,*)
        WRITE(LUNAMPLI,*)PINCEN
        WRITE(LUNAMPLI,*)PINW,PINH,PINR
        WRITE(LUNAMPLI,*)OBSVDZ,OBSVDY
        WRITE(LUNAMPLI,*)
        WRITE(LUNAMPLI,*)SPECNOR
        WRITE(LUNAMPLI,*)VPOLA(1)
        WRITE(LUNAMPLI,*)VPOLA(2)
        WRITE(LUNAMPLI,*)VPOLA(3)
        WRITE(LUNAMPLI,*)VSTOKES(1,1)
        WRITE(LUNAMPLI,*)VSTOKES(1,2)
        WRITE(LUNAMPLI,*)VSTOKES(1,3)
        WRITE(LUNAMPLI,*)VSTOKES(2,1)
        WRITE(LUNAMPLI,*)VSTOKES(2,2)
        WRITE(LUNAMPLI,*)VSTOKES(2,3)
        WRITE(LUNAMPLI,*)VSTOKES(3,1)
        WRITE(LUNAMPLI,*)VSTOKES(3,2)
        WRITE(LUNAMPLI,*)VSTOKES(3,3)
        WRITE(LUNAMPLI,*)VSTOKES(4,1)
        WRITE(LUNAMPLI,*)VSTOKES(4,2)
        WRITE(LUNAMPLI,*)VSTOKES(4,3)
        WRITE(LUNAMPLI,*)

        WRITE(LUNAMPLI,*)(OBSVZ(IO),IO=1,NOBSVZ)
        WRITE(LUNAMPLI,*)
        WRITE(LUNAMPLI,*)(OBSVY(IO),IO=1,NOBSVY)
        WRITE(LUNAMPLI,*)

        DO IO=1,NOBSV
          WRITE(LUNAMPLI,*)(OBSV(IXYZ,IO),IXYZ=1,3)
        ENDDO

        WRITE(LUNAMPLI,*)AMPFREQ
        WRITE(LUNAMPLI,*)

        DO IFR=1,NFREQ
          WRITE(LUNAMPLI,*)
          WRITE(LUNAMPLI,*)FREQ(IFR)
          DO IO=1,NOBSV
            IOBFR=IO+NOBSV*(IFR-1)
            WRITE(LUNAMPLI,*)
     &        REAIMA(1,1,IOBFR),REAIMA(1,2,IOBFR)
            WRITE(LUNAMPLI,*)
     &        REAIMA(2,1,IOBFR),REAIMA(2,2,IOBFR)
            WRITE(LUNAMPLI,*)
     &        REAIMA(3,1,IOBFR),REAIMA(3,2,IOBFR)
          ENDDO
        ENDDO
        WRITE(LUNAMPLI,*)

        WRITE(LUNGFO,*)'      array REAIMA written to file'
        WRITE(LUNGFO,*)'      ',FILEAMPLI//'_SUPER'
        WRITE(LUNGFO,*)

        CLOSE(LUNAMPLI)

      ENDIF !IAMPSUP

      IF (IAMPTERM.NE.0) THEN
        IABEND=6
        iroottrees=0
        WRITE(LUNGFO,*)
     &    '*** SR ADDAMPLI: GOING TO TERMINATE WAVE DUE TO FLAG IAMPTERM ***'
        WRITE(6,*)
     &    '*** SR ADDAMPLI: GOING TO TERMINATE WAVE DUE TO FLAG IAMPTERM ***'
      ENDIF

      IF (AMPRAN.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'      Rel. rms phase error (from generated errors): '
     &    ,RANRMS
      ENDIF

      RETURN
      END
+DECK,ADI.
*CMZ :  2.70/12 01/03/2013  15.45.11  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.02.51  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  14.58.51  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  14.02.13  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.46.30  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.22  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE ADI(GAMMA,B0,XLAM0,FASYM,F0,DI2AHW,DI5AHW,BETAHW,
     &                 B0PK,XLPK,BETADIK,FB0M,F0P,FBETP,
     &                 DI2ADIK,DI5ADIK,CHI2MIN)

+seq,gplhint.

C--- BERECHENET FUER DEN ASYM. HALBACH-WLS EIN ASYM. DIPOLAEQUIVALENT
C    MIT GLEICHER ASYMMETRIE FB0M=FB0M(FASYM)
C    FORMFAKTOREN WERDEN AUS NUMERISCHEN BERECHNETEN TABELLEN INTERPOLIERT
      IMPLICIT NONE

      INTEGER IX,IB,NB0P,NXLP
      DOUBLE PRECISION B0,XLAM0,FASYM,F0,B0P,XLP,FB0M,FB0MFUN,FBETP,F0P,FM,F0PFUN,
     &         FBETPFUN
      DOUBLE PRECISION E,GAMMA,CHI2,CHI2MIN
      DOUBLE PRECISION B0PMX,B0PMN,DB0P,RHOP,B0PK,PHIP
      DOUBLE PRECISION XLPMX,XLPMN,DXLP,XLPK
      DOUBLE PRECISION FN,BETADI,BETADIK,BETAHW
      DOUBLE PRECISION DI2AHW,DI5AHW,DI2ADI,DI5ADI,DI2ADIK,DI5ADIK

C     DATA NB0P/100/
C     DATA NXLP/100/

      F0=F0

      E=GAMMA*511003.3732832001D-9

      B0PMX=2.*B0
      B0PMN=0.
      DB0P=0.05

      XLPMX=3.*XLAM0
      XLPMN=0.
      DXLP=0.01

      FB0M=FB0MFUN(FASYM) !EMPIRISCHER FIT BZW INTERPOLATION
      FM=DSQRT(1+1./FB0M**2)**3
      FN=DSQRT(((1.+FASYM)**2/(8.*FASYM)))**3
      F0P=F0PFUN(FASYM)
      FBETP=FBETPFUN(FASYM)

      NB0P=NINT((B0PMX-B0PMN)/DB0P)
      NXLP=NINT((B0PMX-B0PMN)/DXLP)

      CHI2MIN=1.D30
      DO IB=1,NB0P
      DO IX=1,NXLP

          B0P=B0PMN+DB0P*IB
          RHOP=E/B0P/0.3
          XLP=XLPMN+DXLP*IX
          PHIP=XLP/RHOP

          DI2ADI=XLP/(4.*RHOP**2)*(1.+1./FB0M**2)*(1.+1./FASYM)
          DI5ADI=DI2ADI*F0P*FM*FN*PHIP**3
          BETADI=FBETP*XLP*(1.+FASYM)/2.

C         CHI2=((BETAHW-BETADI)/BETAHW)**2+
C     &           ((DI2AHW-DI2ADI)/DI2AHW)**2+
C     &      ((DI5AHW-DI5ADI)/DI5AHW)**2

          CHI2=((BETAHW-BETADI)/BETAHW)**2+
     &            ((DI2AHW-DI2ADI)/DI2AHW)**2+
     &       ((DI5AHW/DI2AHW-DI5ADI/DI2ADI)/(DI5AHW/DI2AHW))**2


          IF (CHI2.LT.CHI2MIN) THEN

         B0PK=B0P
         XLPK=XLP
         DI2ADIK=DI2ADI
         DI5ADIK=DI5ADI
         BETADIK=BETADI
         CHI2MIN=CHI2

          ENDIF


      ENDDO
      ENDDO

      IF(B0PK.EQ.B0PMN.OR.B0PK.EQ.B0PMX)
     &     STOP'*** S/R ADI: B0P-BOUNDARY TOUCHED'
      IF(XLPK.EQ.XLPMN.OR.XLPK.EQ.XLPMX)
     &     STOP'*** S/R ADI: XLP-BOUNDARY TOUCHED'

      CALL ADIBETA(GAMMA,B0PK,XLPK,FASYM,FB0M)

      RETURN
      END
+DECK,ADIBETA.
*CMZ :  2.70/12 01/03/2013  15.45.11  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ : 00.01/02 24/11/94  15.24.18  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.46.35  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.31  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE ADIBETA(GAMMA,B0,XLP,FB0N,FB0M)

+seq,gplhint.

C--- BERECHNET AUS DEN DATEN DES ADI DIE DATEN, DIE IN BETA EINGEGEBEN WERDEN
C    GERAET WIRD IN ZWEI HAELFTEN EINGEGEBEN, ALSO ZWEIMAL FUENF MAGNETE

      IMPLICIT NONE

      DOUBLE PRECISION B0,XLP,FB0N,FB0M,E,GAMMA
      DOUBLE PRECISION RHOPP,RHOPM,RHOMP1,RHOMP2,RHOMM
      DOUBLE PRECISION XLPP,XLPM,XLMP1,XLMP2,XLMM
      DOUBLE PRECISION PHIPP,PHIPM,PHIMM,PHIMP1,PHIMP2
      DOUBLE PRECISION PHI0,PHI1,PHI2,PHI3,PHI4,PHI5
      DOUBLE PRECISION PHIELMP1,PHIELMM,PHIELMP2,PHIELPM,PHIELPP
      DOUBLE PRECISION PHIERMP1,PHIERMM,PHIERMP2,PHIERPM,PHIERPP
      DOUBLE PRECISION XSTRAIGHT,XDRIFT,XLTOT,CLIGHT,EMASSGEV,PELEV

      DATA XSTRAIGHT/5.8D0/ !LAENGE DES GERADEN STUECKES IM RING
      DATA CLIGHT/2.99792458D8/
      DATA EMASSGEV/511003.3732832001D-9/

      E=GAMMA*511003.3732832001D-9  !GEV
      PELEV=DSQRT(  (E-EMASSGEV)*(E+EMASSGEV)  )*1.D9

      RHOPP = PELEV/(CLIGHT*B0)
      RHOPM =-RHOPP*FB0M
      RHOMM =-RHOPP*FB0N
      RHOMP1=-RHOMM*FB0M
      RHOMP2=-RHOMM*FB0M

      XLPP =XLP/8. !NUR HALBER WLS SOLL BETRACHTET WERDEN
      XLPM =XLPP
      XLMM =XLPP*FB0N
      XLMP1=XLMM/2.
      XLMP2=XLMM/2.
      XLTOT=XLPP+XLPM+XLMM+XLMP1+XLMP2
      XDRIFT=(XSTRAIGHT-2.*XLTOT)/2.

C     PHIMP1= 0.D0 -DASIN (DSIN( 0.D0 )-XLMP1/RHOMP1)  !1. MAGNET
C     PHIMM =PHIMP1-DASIN (DSIN(PHIMP1)- XLMM/ RHOMM)  !2. MAGNET
C     PHIMP2=PHIMM -DASIN (DSIN( PHIMM)-XLMP2/RHOMP2)  !3. MAGNET
C     PHIPM =PHIMP2-DASIN (DSIN(PHIMP2)- XLPM/ RHOPM)  !4. MAGNET
C     PHIPP =PHIPM -DASIN (DSIN( PHIPM)- XLPP/ RHOPP)  !5. MAGNET

      PHIMP1= XLMP1/RHOMP1 !1. MAGNET      !MAGNET SONST NICHT ABGEGLICHEN
      PHIMM =  XLMM/ RHOMM !2. MAGNET
      PHIMP2= XLMP2/RHOMP2 !3. MAGNET
      PHIPM = XLPM/ RHOPM  !4. MAGNET
      PHIPP = XLPP/ RHOPP  !5. MAGNET

      PHI0=0.0
      PHI1=PHI0+PHIMP1
      PHI2=PHI1+PHIMM
      PHI3=PHI2+PHIMP2
      PHI4=PHI3+PHIPM
      PHI5=PHI4+PHIPP


      PHIELMP1=DSIGN(PHI0,RHOMP1)
      PHIERMP1=PHIMP1-PHIELMP1

      PHIELMM =-PHIERMP1
      PHIERMM =PHIMM -PHIELMM
      PHIELMP2=-PHIERMM
      PHIERMP2=PHIMP2-PHIELMP2
      PHIELPM =-PHIERMP2
      PHIERPM =PHIPM -PHIELPM

      PHIELPP =-PHIERPM
      PHIERPP =PHIPP-PHIELPP

      OPEN(UNIT=10,FILE='ADI.STR',
     &       STATUS='NEW',FORM='FORMATTED')

      WRITE(10,*)'E, LAENGE DES GERADEN STUECKES:',SNGL(E),SNGL(XSTRAIGHT)
      WRITE(10,*)'B0, XLP:',SNGL(B0),SNGL(XLP)
      WRITE(10,*)'n, m:   ',SNGL(FB0N),SNGL(FB0M)

      WRITE(10,1001)PHIELMP1,RHOMP1
1001  FORMAT(' EL1  CO',E14.6,E14.6,'  0.000000E+00  0.000000E+00')
      WRITE(10,2001) PHIMP1,RHOMP1
2001  FORMAT(' BB1  DI',E14.6,E14.6,'  0.000000E+00  0.000000E+00')
      WRITE(10,3001) PHIERMP1,RHOMP1
3001  FORMAT(' ER1  CO',E14.6,E14.6,'  0.000000E+00  0.000000E+00')

      WRITE(10,1002)PHIELMM,RHOMM
1002  FORMAT(' EL2  CO',E14.6,E14.6,'  0.000000E+00  0.000000E+00')
      WRITE(10,2002) PHIMM,RHOMM
2002  FORMAT(' BB2  DI',E14.6,E14.6,'  0.000000E+00  0.000000E+00')
      WRITE(10,3002) PHIERMM,RHOMM
3002  FORMAT(' ER2  CO',E14.6,E14.6,'  0.000000E+00  0.000000E+00')

      WRITE(10,1003)PHIELMP2,RHOMP2
1003  FORMAT(' EL3  CO',E14.6,E14.6,'  0.000000E+00  0.000000E+00')
      WRITE(10,2003) PHIMP2,RHOMP2
2003  FORMAT(' BB3  DI',E14.6,E14.6,'  0.000000E+00  0.000000E+00')
      WRITE(10,3003) PHIERMP2,RHOMP2
3003  FORMAT(' ER3  CO',E14.6,E14.6,'  0.000000E+00  0.000000E+00')

      WRITE(10,1004)PHIELPM,RHOPM
1004  FORMAT(' EL4  CO',E14.6,E14.6,'  0.000000E+00  0.000000E+00')
      WRITE(10,2004) PHIPM,RHOPM
2004  FORMAT(' BB4  DI',E14.6,E14.6,'  0.000000E+00  0.000000E+00')
      WRITE(10,3004) PHIERPM,RHOPM
3004  FORMAT(' ER4  CO',E14.6,E14.6,'  0.000000E+00  0.000000E+00')

      WRITE(10,1005)PHIELPP,RHOPP
1005  FORMAT(' EL5  CO',E14.6,E14.6,'  0.000000E+00  0.000000E+00')
      WRITE(10,2005) PHIPP,RHOPP
2005  FORMAT(' BB5  DI',E14.6,E14.6,'  0.000000E+00  0.000000E+00')
      WRITE(10,3005) PHIERPP,RHOPP
3005  FORMAT(' ER5  CO',E14.6,E14.6,'  0.000000E+00  0.000000E+00')
      WRITE(10,4000)XDRIFT
4000  FORMAT('   ## SD',E14.6)

      WRITE(10,*)
     &  '*** ACHTUNG: KANTENWINKEL GRAPHISCH KONTROLLIEREN ! ***'

      RETURN
      END
+DECK,AMPCHECK.
*CMZ :  2.70/12 01/03/2013  15.45.11  by  Michael Scheer
*CMZ :  2.70/00 08/11/2012  11.33.18  by  Michael Scheer
*CMZ :  2.69/02 08/11/2012  10.17.41  by  Michael Scheer
*CMZ :  2.66/07 24/02/2010  17.18.39  by  Michael Scheer
*CMZ :  2.37/07 11/12/2001  17.50.58  by  Michael Scheer
*CMZ :  2.36/00 08/11/2001  14.16.25  by  Michael Scheer
*CMZ :  2.15/00 02/11/2001  14.21.12  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.16.24  by  Michael Scheer
*CMZ :  2.00/02 12/01/99  15.53.04  by  Michael Scheer
*CMZ :  2.00/00 07/01/99  11.21.39  by  Michael Scheer
*-- Author :    Michael Scheer   06/01/99

      SUBROUTINE AMPCHECK(
     &  NSOURCE,NOBSV,NFREQ,IFREQ2P,
     &  NOBSVZ,NOBSVY,MOBSVZ,MOBSVY,
     &  MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY,
     &  PINW,PINH,PINR,IPIN,IF1DIM,IPINCIRC,AMPFREQ,IAMPREP,
     &  ibunch,iubunch,bunchlen,
     &  IERROR)

+seq,gplhint.

      IMPLICIT NONE

      INTEGER ICAL,IERROR ,ICHECK,IAMPREP

      INTEGER
     &  NSOURCE,NOBSV,NFREQ,IFREQ2P,
     &  NOBSVZ,NOBSVY,MOBSVZ,MOBSVY,
     &  MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY,
     &  IF1DIM,IPIN,IPINO,IPINCIRC,
     &  ibunch,iubunch

      DOUBLE PRECISION
     &  PINW,PINH,PINR,AMPFREQ,AMPFREQO,bunchlen

      INTEGER
     &  NSOURCEO,NOBSVO,NFREQO,IFREQ2PO,
     &  NOBSVZO,NOBSVYO,MOBSVZO,MOBSVYO,
     &  MEDGEZO,MEDGEYO,MMEDGEZO,MMEDGEYO,
     &  IF1DIMO,IPINCIRCO,
     &  iubuncho,ibuncho

      DOUBLE PRECISION
     &  PINWO,PINHO,PINRO,RCHECK,ACHECK,bunchleno


      DATA ICAL/0/

      IF (ICAL.EQ.0) THEN

        NSOURCEO=NSOURCE
        NOBSVO=NOBSV
        NFREQO=NFREQ
        IFREQ2PO=IFREQ2P
        NOBSVZO=NOBSVZ
        NOBSVYO=NOBSVY
        MOBSVZO=MOBSVZ
        MOBSVYO=MOBSVY
        MEDGEZO=MEDGEZ
        MEDGEYO=MEDGEY
        MMEDGEZO=MMEDGEZ
        MMEDGEYO=MMEDGEY
        IF1DIMO=IF1DIM
        IPINCIRCO=IPINCIRC
        IPINO=IPIN
        ibuncho=ibunch
        iubuncho=iubunch
        bunchleno=bunchlen

        PINWO=PINW
        PINHO=PINH
        PINRO=PINR

        AMPFREQO=AMPFREQ

        ICAL=1
        IERROR=0

      ELSE  !ICAL


        ICHECK=
     &    +ABS(       NSOURCEO-NSOURCE
     &    )+ABS(      NOBSVO-NOBSV
     &    )+ABS(      NFREQO-NFREQ
     &    )+ABS(      IFREQ2PO-IFREQ2P
     &    )+ABS(      NOBSVZO-NOBSVZ
     &    )+ABS(      NOBSVYO-NOBSVY
     &    )+ABS(      MOBSVZO-MOBSVZ
     &    )+ABS(      MOBSVYO-MOBSVY
     &    )+ABS(      MEDGEZO-MEDGEZ
     &    )+ABS(      MEDGEYO-MEDGEY
     &    )+ABS(      MMEDGEZO-MMEDGEZ
     &    )+ABS(      MMEDGEYO-MMEDGEY
     &    )+ABS(      IF1DIMO-IF1DIM
     &    )+ABS(      IPINO-IPIN
     &    )+ABS(      IPINCIRCO-IPINCIRC)

        RCHECK=
     &    +DABS(      PINWO-PINW
     &    )+DABS(     PINHO-PINH
     &    )+DABS(     PINRO-PINR)

        IF (IAMPREP.GE.0.and.ampfreqo.ne.0d0) THEN
          ACHECK=DABS(AMPFREQO-AMPFREQ)/AMPFREQO
        ELSE
          ACHECK=0.0D0
        ENDIF

        IF (ICHECK.NE.0.OR.RCHECK.NE.0.D0.OR.ACHECK.GT.1.D-6) IERROR=-1

        if (ibuncho.ne.0.and.bunchleno.le.0.0d0) then
          write(16,*)' '
          write(16,*)'      *** Warning in AMPCHECK:'
          write(16,*)' '
          write(16,*)
     &      '      IBUNCH has not been zero on the file read. '
          write(16,*)'      Be careful, especially if BUNCHLEN has not been zero.'
          write(16,*)'      IBUNCH, IUBUNCH and BUNCHLEN read from file:'
          write(16,*)'      ',ibunch, iubunch, bunchlen
          write(16,*)' '
          write(6,*)' '
          write(6,*)'      *** Warning in AMPCHECK:'
          write(6,*)' '
          write(6,*)
     &      '      IBUNCH has not been zero on the file read. '
          write(6,*)'      Be careful, especially if BUNCHLEN has not been zero.'
          write(6,*)'      IBUNCH, IUBUNCH and BUNCHLEN read from file:'
          write(6,*)'      ',ibunch, iubunch, bunchlen
        endif

      ENDIF !ICAL

      RETURN
      END
+DECK,areim.
*CMZ :  2.70/12 01/03/2013  15.45.11  by  Michael Scheer
*CMZ :  0.99/00 16/02/2004  17.22.39  by  Michael Scheer
*CMZ :  0.00/08 21/01/2004  17.45.18  by  Michael Scheer
*CMZ :  0.00/06 14/01/2004  16.32.20  by  Michael Scheer
*CMZ :  0.00/05 23/12/2003  16.08.27  by  Michael Scheer
*CMZ :  0.00/04 19/12/2003  18.32.08  by  Michael Scheer
*-- Author :    Michael Scheer   19/12/2003
      subroutine areim(x,a,b,z,are,aim)

+seq,gplhint.

      implicit none

      double precision x,a,b,z,are,aim,arg1,x2,z2,a2,b2,y,az2,y2,b3

      x2=x*x
      z2=z*z
      a2=a*a
      b2=b*b
      b3=b2*b
      az2=a2*z2
      y=a*x+b
      y2=y*y

      arg1=sqrt(y2+x2+z2)

      are=2.0d0*z2*(
     &  arg1*((a*x-b)*(az2+b2))
     &  +(((a2+1.d0)*x2-b2+z2)*a2-b2)*z2
     &  +(( a2-1.d0)*x2-b2)*b2)

      aim=2.0d0*z*(
     &  arg1*((az2+b*y)*a*z2+b3*x)
     &  + ((y*a2+2.0d0*b)*z2 + b*(y2+2.d0*x2))*a*z2
     &  +y*b3*x)

      return
      end
+DECK,ARESI.
*CMZ :  3.00/00 11/03/2013  10.37.07  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  15.45.11  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ : 00.01/04 28/11/94  18.08.30  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.46.39  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.54  by  Michael Scheer
*-- Author :
C****************************************************************
      SUBROUTINE ARESI(AIN,MAXTRAP,NORDNGP,
     &                   RESXM,RESXAVE,RESX,
     &                   RESYM,RESYAVE,RESY,
     &                   RESPXM,RESPXAVE,RESPX,
     &                   RESPYM,RESPYAVE,RESPY,RESALL)
C****************************************************************

+seq,gplhint.

C--- RECALCULATES TRACK USING THE GENERATING FUNCTION AND COMPARES WITH
C    TRACKING RESULTS

      IMPLICIT NONE

      INTEGER MAXTRAP,NORDNGP,NKOEF,I,J,K,L,M

+SEQ,GENFUN.

      DOUBLE PRECISION AIN(NORDNG,NORDNG,NORDNG,NORDNG)
      DOUBLE PRECISION RESX2,RESY2,RESPX2,RESPY2,RESALL2

      DOUBLE PRECISION
     &                   RESXM,RESXAVE,RESX,
     &                   RESYM,RESYAVE,RESY,
     &                   RESPXM,RESPXAVE,RESPX,
     &                   RESPYM,RESPYAVE,RESPY,RESALL

+SEQ,TTRACKS.

      IF(MAXTRA.NE.MAXTRAP) STOP '*** SR ARESI: MAXTRA FALSCH ***'
      IF(NORDNGP.NE.NORDNG) STOP '*** SR ARESI: NORDNG FALSCH ***'

      RESXAVE=0.D0
      RESX2=0.D0
      RESXM=0.D0
      RESPXAVE=0.D0
      RESPX2=0.D0
      RESPXM=0.D0
      RESYAVE=0.D0
      RESY2=0.D0
      RESYM=0.D0
      RESPYAVE=0.D0
      RESPY2=0.D0
      RESPYM=0.D0
      RESALL2=0.D0

      DO L=1,NORDNG
        DO K=1,NORDNG
          DO J=1,NORDNG
            DO I=1,NORDNG

              ADUM(I,J,K,L)=AIN(I,J,K,L)

            ENDDO
          ENDDO
        ENDDO
      ENDDO

      DO M=1,MTRAJ

          CALL ERZTRA    (XIC(M),PXF(M),YIC(M),PYF(M),
     &           XFN(M),PXIN(M),YFN(M),PYIN(M))

          RESXF(M)=XFN(M)-XFC(M)
          RESYF(M)=YFN(M)-YFC(M)
          RESPXI(M)=PXIN(M)-PXI(M)
          RESPYI(M)=PYIN(M)-PYI(M)

          RESALL2=RESALL2+RESXF(M)**2+RESYF(M)**2+RESPXI(M)**2+RESPYI(M)**2

          RESXAVE=RESXAVE+RESXF(M)
          RESX2=RESX2+RESXF(M)*RESXF(M)
          IF(DABS(RESXF(M)).GT.DABS(RESXM)) RESXM=RESXF(M)

          RESPXAVE=RESPXAVE+RESPXI(M)
          RESPX2=RESPX2+RESPXI(M)*RESPXI(M)
          IF(DABS(RESPXI(M)).GT.DABS(RESPXM)) RESPXM=RESPXI(M)

          RESYAVE=RESYAVE+RESYF(M)
          RESY2=RESY2+RESYF(M)*RESYF(M)
          IF(DABS(RESYF(M)).GT.RESYM) RESYM=RESYF(M)

          RESPYAVE=RESPYAVE+RESPYI(M)
          RESPY2=RESPY2+RESPYI(M)*RESPYI(M)
          IF(DABS(RESPYI(M)).GT.RESPYM) RESPYM=RESPYI(M)

      ENDDO

      RESXAVE=RESXAVE/MTRAJ
      RESX=DSQRT(RESX2/MTRAJ)
      RESPXAVE=RESPXAVE/MTRAJ
      RESPX=DSQRT(RESPX2/MTRAJ)

      RESYAVE=RESYAVE/MTRAJ
      RESY=DSQRT(RESY2/MTRAJ)
      RESPYAVE=RESPYAVE/MTRAJ
      RESPY=DSQRT(RESPY2/MTRAJ)

      RESALL=DSQRT(RESALL2/MTRAJ)

      RETURN
      END
+DECK,ARESIMAP.
*CMZ :  3.00/00 11/03/2013  10.37.07  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  15.45.11  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ : 00.01/10 29/05/96  10.44.23  by  Michael Scheer
*-- Author :    Michael Scheer   29/05/96

C****************************************************************
      SUBROUTINE ARESIMAP(AIN,MAXTRAP,NORDNGP,
     &                   RESXM,RESXAVE,RESX,
     &                   RESYM,RESYAVE,RESY,
     &                   RESPXM,RESPXAVE,RESPX,
     &                   RESPYM,RESPYAVE,RESPY,RESALL)
C****************************************************************

+seq,gplhint.

C--- RECALCULATES TRACK USING THE MAPPING AND COMPARES WITH
C    TRACKING RESULTS

      IMPLICIT NONE

      INTEGER MAXTRAP,NORDNGP,NKOEF,I,J,K,L,M

+SEQ,GENFUN.

      DOUBLE PRECISION AIN(NORDNG,NORDNG,NORDNG,NORDNG)
      DOUBLE PRECISION RESX2,RESY2,RESPX2,RESPY2,RESALL2

      DOUBLE PRECISION
     &                   RESXM,RESXAVE,RESX,
     &                   RESYM,RESYAVE,RESY,
     &                   RESPXM,RESPXAVE,RESPX,
     &                   RESPYM,RESPYAVE,RESPY,RESALL

+SEQ,TTRACKS.

      IF(MAXTRA.NE.MAXTRAP) STOP '*** SR ARESIMAP: MAXTRA FALSCH ***'
      IF(NORDNGP.NE.NORDNG) STOP '*** SR ARESIMAP: NORDNG FALSCH ***'

      RESXAVE=0.D0
      RESX2=0.D0
      RESXM=0.D0
      RESPXAVE=0.D0
      RESPX2=0.D0
      RESPXM=0.D0
      RESYAVE=0.D0
      RESY2=0.D0
      RESYM=0.D0
      RESPYAVE=0.D0
      RESPY2=0.D0
      RESPYM=0.D0
      RESALL2=0.D0

      DO I=1,NORDNG
      DO J=1,NORDNG
      DO K=1,NORDNG
      DO L=1,NORDNG

      ADUM(I,J,K,L)=AIN(I,J,K,L)

      ENDDO
      ENDDO
      ENDDO
      ENDDO

      DO M=1,MTRAJ

          CALL ERZTRA    (XIC(M),PXI(M),YIC(M),PYI(M),
     &           XFN(M),PXFN(M),YFN(M),PYFN(M))

          RESXF(M)=XFN(M)-XFC(M)
          RESYF(M)=YFN(M)-YFC(M)
          RESPXF(M)=PXFN(M)-PXF(M)
          RESPYF(M)=PYFN(M)-PYF(M)

          RESALL2=RESALL2+RESXF(M)**2+RESYF(M)**2+RESPXF(M)**2+RESPYF(M)**2

          RESXAVE=RESXAVE+RESXF(M)
          RESX2=RESX2+RESXF(M)*RESXF(M)
          IF(DABS(RESXF(M)).GT.DABS(RESXM)) RESXM=RESXF(M)

          RESPXAVE=RESPXAVE+RESPXF(M)
          RESPX2=RESPX2+RESPXF(M)*RESPXF(M)
          IF(DABS(RESPXF(M)).GT.DABS(RESPXM)) RESPXM=RESPXF(M)

          RESYAVE=RESYAVE+RESYF(M)
          RESY2=RESY2+RESYF(M)*RESYF(M)
          IF(DABS(RESYF(M)).GT.RESYM) RESYM=RESYF(M)

          RESPYAVE=RESPYAVE+RESPYF(M)
          RESPY2=RESPY2+RESPYF(M)*RESPYF(M)
          IF(DABS(RESPYF(M)).GT.RESPYM) RESPYM=RESPYF(M)

      ENDDO

      RESXAVE=RESXAVE/MTRAJ
      RESX=DSQRT(RESX2/MTRAJ)
      RESPXAVE=RESPXAVE/MTRAJ
      RESPX=DSQRT(RESPX2/MTRAJ)

      RESYAVE=RESYAVE/MTRAJ
      RESY=DSQRT(RESY2/MTRAJ)
      RESPYAVE=RESPYAVE/MTRAJ
      RESPY=DSQRT(RESPY2/MTRAJ)

      RESALL=DSQRT(RESALL2/MTRAJ)

      RETURN
      END

+DECK,ARROW.
*CMZ :  3.01/09 12/08/2014  15.00.42  by  Michael Scheer
*CMZ :  3.01/08 12/08/2014  11.36.16  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  15.45.11  by  Michael Scheer
*CMZ :  2.13/09 08/03/2000  17.22.30  by  Michael Scheer
*CMZ : 00.01/08 22/06/95  14.25.26  by  Michael Scheer
*-- Author :    Michael Scheer   21/06/95
      SUBROUTINE ARROW(XL,XR,YU,YD,ANG)

+seq,gplhint.

      IMPLICIT NONE

      REAL*4 X(2),Y(2),XC,YC,XL,XR,YU,YD,Y1,Y2,Y3,Y4,X1,X2,X3,X4,ANG,DX,DY
      real xmin_ps,xmax_ps,ymin_ps,ymax_ps

      call mshplt_get_frame(xmin_ps,xmax_ps,ymin_ps,ymax_ps)

      XC=(XR+XL)/2.
      YC=(YU+YD)/2.
      DX=XR-XL
      DY=YU-YD

      if (yc.lt.ymin_ps) return

      IF (ANG.EQ.270..OR.ANG.EQ.-90.) THEN
        X1=XC+DX/10.
        X2=XC
        X3=XC-DX/10.
        X4=X2
        Y1=YC+DY/10.
        Y2=YU-DY/10.
        Y3=Y1
        Y4=YD+DY/10.
        X(1)=X2
        Y(1)=Y2
        X(2)=X1
        Y(2)=Y1

        call mshplt_pline(2,x,y)
        X(2)=X3
        Y(2)=Y3
        call mshplt_pline(2,x,y)
        X(2)=X4
        Y(2)=Y4
        call mshplt_pline(2,x,y)
      ELSE IF (ANG.EQ.90..OR.ANG.EQ.-270.) THEN
        X1=XC+DX/10.
        X2=XC
        X3=XC-DX/10.
        X4=X2
        Y1=YC-DY/10.
        Y2=YU-DY/10.
        Y3=Y1
        Y4=YD+DY/10.
        X(1)=X4
        Y(1)=Y4
        X(2)=X1
        Y(2)=Y1
        call mshplt_pline(2,x,y)
        X(2)=X3
        Y(2)=Y3
        call mshplt_pline(2,x,y)
        X(2)=X2
        Y(2)=Y2
        call mshplt_pline(2,x,y)
      ELSE IF (ANG.EQ.0.0 .OR. ANG.EQ.360.) THEN
        X1=XL+DX/5.
        X2=XR-DX*2./5.
        X3=XR-DX/5.
        X4=X2
        Y1=YC
        Y2=YC-DY/5.
        Y3=Y1
        Y4=YC+DY/5.
        X(1)=X3
        Y(1)=Y3
        X(2)=X1
        Y(2)=Y1
        call mshplt_pline(2,x,y)
        X(2)=X2
        Y(2)=Y2
        call mshplt_pline(2,x,y)
        X(2)=X4
        Y(2)=Y4
        call mshplt_pline(2,x,y)
      ELSE IF (ANG.EQ.180..OR.ANG.EQ.-180.) THEN
        X1=XL+DX/5.
        X2=XL+DX*2./5.
        X3=XR-DX/5.
        X4=X2
        Y1=YC
        Y2=YC-DY/5.
        Y3=Y1
        Y4=YC+DY/5.
        X(1)=X1
        Y(1)=Y1
        X(2)=X3
        Y(2)=Y3
        call mshplt_pline(2,x,y)
        X(2)=X2
        Y(2)=Y2
        call mshplt_pline(2,x,y)
        X(2)=X4
        Y(2)=Y4
        call mshplt_pline(2,x,y)
      ELSE
        WRITE(6,*)'*** WARNING SR ARROW: STRANGE ANGLE',ANG,'***'
        RETURN
      ENDIF

      RETURN
      END
+DECK,BCHARGE.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  1.01/00 27/11/97  16.20.29  by  Michael Scheer
*-- Author :    Michael Scheer   27/11/97

      SUBROUTINE BCHARGE(X,Y,Z,BX,BY,BZ,AX,AY,AZ)

+seq,gplhint.

      IMPLICIT NONE

      INTEGER NCHARP,LUNGFO
      PARAMETER (NCHARP=10)

      INTEGER LUNCHAR,NREAD,ICAL,I

      DOUBLE PRECISION X,Y,Z,BX,BY,BZ,AX,AY,AZ
      DOUBLE PRECISION X0(NCHARP),Y0(NCHARP),Z0(NCHARP),Q(NCHARP),QSUM
      DOUBLE PRECISION XX0,YY0,ZZ0,QQ,RX,RY,RZ,R,R31

      CHARACTER(80) FILE

      DATA LUNCHAR/99/,LUNGFO/16/,ICAL/0/
      DATA FILE/'WI:BCHARGE.DAT'/

      IF (ICAL.EQ.0) THEN

      NREAD=0
      QSUM=0.D0
      OPEN(UNIT=LUNCHAR,FILE=FILE,STATUS='OLD')

11        READ(LUNCHAR,*,END=99)XX0,YY0,ZZ0,QQ
          NREAD=NREAD+1
          X0(NREAD)=XX0
          Y0(NREAD)=YY0
          Z0(NREAD)=ZZ0
          Q(NREAD)=QQ

          QSUM=QSUM+QQ

          GOTO 11

99    CLOSE(LUNCHAR)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SUBROUTINE BCHARGE:'
      WRITE(LUNGFO,*)

      DO I=1,NREAD
         WRITE(LUNGFO,*)'     ',
     &          SNGL(X0(I)),SNGL(Y0(I)),SNGL(Z0(I)),SNGL(Q(I))
      ENDDO
      WRITE(LUNGFO,*)'     QSUM:',QSUM
      WRITE(LUNGFO,*)

      ICAL=1

      ENDIF !ICAL

      BX=0.D0
      BY=0.D0
      BZ=0.D0
      AX=0.D0
      AY=0.D0
      AZ=0.D0
      DO I=1,NREAD

          RX=X-X0(I)
          RY=Y-Y0(I)
          RZ=Z-Z0(I)

          R=DSQRT(RX*RX+RY*RY+RZ*RZ)
          IF (R.EQ.0.D0) THEN
         WRITE(LUNGFO,*)'*** ERROR IN BCHARGE:'
         WRITE(LUNGFO,*)'X,Y,Z COINCIDES WITH POINT CHARGE',I
         WRITE(LUNGFO,*)'X,Y,Z:',X,Y,Z
         WRITE(6,*)'*** ERROR IN BCHARGE:'
         WRITE(6,*)'X,Y,Z COINCIDES WITH POINT CHARGE',I
         WRITE(6,*)'X,Y,Z:',X,Y,Z
         STOP
          ENDIF
          R31=1.D0/(R*R*R)

          BX=BX+Q(I)*RX*R31
          BY=BY+Q(I)*RY*R31
          BZ=BZ+Q(I)*RZ*R31


      ENDDO !NREAD

      RETURN
      END
+DECK,BDI.
*CMZ :  4.01/07 18/11/2024  10.51.09  by  Michael Scheer
*CMZ :  3.04/00 05/01/2018  16.13.44  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.65/03 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.63/02 25/03/2008  09.35.21  by  Michael Scheer
*CMZ :  2.52/11 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  1.02/00 19/12/97  17.58.18  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  14.07.41  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.46.47  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.43  by  Michael Scheer
*-- Author : Michael Scheer
C***********************************************************************
      SUBROUTINE BDI(XI,YI,ZI,BX,BY,BZ,IMAGI)

+seq,gplhint.

      IMPLICIT NONE

      INTEGER IMAG,imagi

+SEQ,MGSQC.

      DOUBLE PRECISION X,Y,Z,BX,BY,BZ,BY0,BY1,BY2,XLEN2,XI,YI,ZI,AY1,AY2

+SEQ,CONTRL.
+SEQ,PHYCON.

c pmag(1,imag): deflection angle (rad)
c pmag(2,imag): bending radius (T)
c pmag(3,imag): Center of magnet (m)
c pmag(4,imag): Width of edge

c 'DI' type (imagi>0)
c pmag(5,imag): cos(rotation angle)
c pmag(6,imag): sin(rotation angle)

c 'DIF' type (imagi<0)
c pmag(7,imag): cos(rotation angle)
c pmag(8,imag): sin(rotation angle)

      imag=iabs(imagi)

      IF (
     &    (IWFILF.EQ.99. .OR. IMGSQF.EQ.0)
     &    .AND.
     &    PMAG(1,IMAG)*PMAG(2,IMAG).NE.0.
     &    ) THEN

        if (imagi.gt.0) then
          X=pmag(5,imag)*(XI-PMAG(3,IMAG))+pmag(6,imag)*zi
          Y=YI
          z=-pmag(6,imag)*(XI-PMAG(3,IMAG))+pmag(5,imag)*zi
        else
          X=pmag(7,imag)*(XI-PMAG(3,IMAG))+pmag(7,imag)*zi
          Y=YI
          z=-pmag(8,imag)*(XI-PMAG(3,IMAG))+pmag(8,imag)*zi
        endif

        BX=0.
        BZ=0.

        BY0=EMOM/CLIGHT1/PMAG(2,IMAG)
        XLEN2=DABS(PMAG(2,IMAG)*sin(pmag(1,imag)/2.0d0))


        AY1=(+X-XLEN2)*PMAG(4,IMAG)
        AY2=(-X-XLEN2)*PMAG(4,IMAG)

        IF (AY1.GT.70.0D0) THEN
          BY1=0.0d0
        ELSE IF (AY1.LT.-70.) THEN
          BY1=1.0D0
        ELSE
          BY1=1.0D0/(1.0D0+DEXP(AY1))
        ENDIF

        IF (AY2.GT.70.0D0) THEN
          BY2=0.0D0
        ELSE IF (AY2.LT.-70.0D0) THEN
          BY2=1.0D0
        ELSE
          BY2=1.0D0/(1.0D0+DEXP(AY2))
        ENDIF

        BY=BY0*BY1*BY2*CORR(IMAG)

      ELSE

        BX=0.0d0
        BY=0.0d0
        BZ=0.0d0

      ENDIF

      RETURN
      END
+DECK,BEAMPOW.
*CMZ :  4.00/14 30/12/2021  15.41.22  by  Michael Scheer
*CMZ :  4.00/13 07/12/2021  18.47.10  by  Michael Scheer
*CMZ :  3.05/06 17/07/2018  11.15.16  by  Michael Scheer
*CMZ :  3.02/04 23/01/2015  16.14.38  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  10.40.59  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.68/05 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.67/04 11/05/2012  11.18.26  by  Michael Scheer
*CMZ :  2.67/01 13/03/2012  12.31.13  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  15.15.38  by  Michael Scheer
*CMZ :  2.56/00 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.51/00 24/05/2004  15.02.20  by  Michael Scheer
*CMZ :  2.35/02 16/04/2004  09.24.47  by  Michael Scheer
*CMZ :  2.16/08 25/10/2000  16.44.25  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  1.03/01 10/02/98  17.32.59  by  Michael Scheer
*CMZ :  1.00/00 24/09/97  10.31.27  by  Michael Scheer
*CMZ : 00.01/06 13/02/95  10.20.34  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  14.13.58  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.46.53  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.26  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BEAMPOW(NPOL)

+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,TRACKF90U.
+SELF.

C--- CALCULATES POWER DISTRIBUTION ALONG THE WALLS OF THE BEAMLINE
C    STORES RESULTS IN RADPOW(19,NDPOLP,NWMAXP)
C
C     RADPOW(1:2,..)   X-COORDINATE 1. AND 2. WALL
C     RADPOW(3:4,..)   POWER DENSITY
C     RADPOW(5:6,..)   POWER DENSITY NORMAL TO BEAM
C     RADPOW(7:8,..)   NUMBER OF PHOTONS
C     RADPOW(9:10,..)  NUMBER OF PHOTONS NORMAL TO BEAM
C     RADPOW(11:12,..) 1D POWER DISTRIBUTION
C
C     RADPOW(13,..)    Z-COORDINATE ON ABSORBER
C     RADPOW(14,..)   DUMMY
C     RADPOW(15,..)    POWER DENSITY ON ABSORBER
C     RADPOW(16,..)   DUMMY
C     RADPOW(17,..)    NUMBER OF PHOTONS ON ABSORBER
C     RADPOW(18,..)   DUMMY
C     RADPOW(19,..)   1D POWER DENSITY ON ABSORBER
C LOGBUCH SEITE 23

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,whbook.
+seq,pawcmn.
+SEQ,TRACK.
+SEQ,SPECT.
+SEQ,PHYCON.

+SELF,IF=-F90.
      INTEGER IPOLLIM(2,NDPOLP)
+SELF.
      INTEGER IPOL,NPOL,IPOI,INSIDE,IWALL,ID,IBIN,NBIN
      INTEGER IMODE,NN,IEND,ISTART,ITEST,IWARN1,IWARN2,IWARN3,IWARN4
      INTEGER ICYCLE
      DOUBLE PRECISION BYA,BY,Z,X,ZP,PX,PZ,DIS2,DXBIN,ZPSIGN,D2POW,SINPHI,COSPHI
      DOUBLE PRECISION D1POW,ECGAM,DNGAM,DZBIN,DISMIN,DIS1,DISMINA
      REAL*4 XI,XE,X1,X2,BYOLD
+self,if=-mshhbook,if=-mhbook.
      real hmaxm,hsumm
+self,if=mshhbook,mhbook.
      real*8 hmaxm,hsumm
+self.
      REAL*4 XFILL,YFILL

C21.9.92     DOUBLE PRECISION CONS

      IF (POWBCUT.GE.0.0D0.AND.POWBCUT.LE.1.E-4) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'*** WARNING BEAMPOW ***'
           WRITE(LUNGFO,*)'POWBCUT.GE.0.0D0 .AND. POWBCUT.LE.1.E-4'
           WRITE(LUNGFO,*)'CHECK RESULTS CAREFULLY'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)'*** WARNING EAMPOW ***'
           WRITE(6,*)'POWBCUT.GE.0.0D0 .AND. POWBCUT.LE.1.E-4'
           WRITE(6,*)'CHECK RESULTS CAREFULLY'
           WRITE(6,*)
      ENDIF

      IF (IAMPLI.NE.0) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'*** WARNING IN BEAMPOW ***'
         WRITE(LUNGFO,*)'IAMPLI.NE.0, BUT IAMPLI NOT TAKEN INTO ACCOUNT'
         WRITE(LUNGFO,*)'FOR POWER CALCULATIONS WITH OPTION IPOWER'
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)'*** WARNING IN BEAMPOW ***'
         WRITE(6,*)'IAMPLI.NE.0, BUT IAMPLI NOT TAKEN INTO ACCOUNT'
         WRITE(6,*)'FOR POWER CALCULATIONS WITH OPTION IPOWER'
         WRITE(6,*)
      ENDIF !IAMPLI

+SELF,IF=F90.
      ALLOCATE(POWS2(NCO))
      ALLOCATE(RADPOW(19,2*NPOLMX,NCO))
      ALLOCATE(IPOLLIM(2,2*NPOLMX))
+SELF.

      POWCOR=1.   !3.5.93

      DISMIN=1.D30
      DISMINA=1.D30

      IF (XABSORB   .EQ.9999.) XABSORB=XWALLE
      IF (ZABSORB(1).EQ.9999.) ZABSORB(1)=WALL(1)
      IF (ZABSORB(2).EQ.9999.) ZABSORB(2)=WALL(2)

      IF (ZABSORB(1).LE.ZABSORB(2)) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'*** ERROR IN BEAMPOW ***'
           WRITE(LUNGFO,*)'Z-POSITION OF ABSORBER MEANINGLESS'
           WRITE(LUNGFO,*)'CHECK ZABSORB IN NAMELIST SPECTN'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)'*** ERROR IN BEAMPOW ***'
           WRITE(6,*)'Z-POSITION OF ABSORBER MEANINGLESS'
           WRITE(6,*)'CHECK ZABSORB IN NAMELIST SPECTN'
           WRITE(6,*)
           STOP
      ENDIF

      IF (XABSORB.LE.WTRA(1,1,NCO)) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'*** WARNING SR BEAMPOW ***'
           WRITE(LUNGFO,*)'ABSORBER BEFORE END OF TRAJECTORY'
           WRITE(LUNGFO,*)'CHECK RESULTS CAREFULLY'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)'*** WARNING SR BEAMPOW ***'
           WRITE(6,*)'ABSORBER BEFORE END OF TRAJECTORY'
           WRITE(6,*)'CHECK RESULTS CAREFULLY'
           WRITE(6,*)
      ENDIF

      IF (WALL(1).LE.WALL(2)) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'*** ERROR IN BEAMPOW ***'
           WRITE(LUNGFO,*)'BEAMLINE MEANINGLESS'
           WRITE(LUNGFO,*)'CHECK WALL IN NAMELIST SPECTN'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)'*** ERROR IN BEAMPOW ***'
           WRITE(6,*)'BEAMLINE MEANINGLESS'
           WRITE(6,*)'CHECK WALL IN NAMELIST SPECTN'
           WRITE(6,*)
           STOP
      ENDIF

      IF (XWALLE.LE.XWALLI) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'*** ERROR IN BEAMPOW ***'
           WRITE(LUNGFO,*)'BEAMLINE MEANINGLESS'
           WRITE(LUNGFO,*)'CHECK XWALLI,XWALLE IN NAMELIST SPECTN'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)'*** ERROR IN BEAMPOW ***'
           WRITE(6,*)'BEAMLINE MEANINGLESS'
           WRITE(6,*)'CHECK XWALLI,XWALLE IN NAMELIST SPECTN'
           WRITE(6,*)
           STOP
      ENDIF

      IF (WALL(1).LT.ZMX.OR.WALL(2).GT.ZMN) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'*** WARNING SR BEAMPOW ***'
           WRITE(LUNGFO,*)'WALLS OF BEAMLINE INCOMPATIBLE WITH TRAJECTORY'
           WRITE(LUNGFO,*)'CHECK RESULTS CAREFULLY'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)'*** WARNING SR BEAMPOW ***'
           WRITE(6,*)'WALLS OF BEAMLINE INCOMPATIBLE WITH TRAJECTORY'
           WRITE(6,*)
      ENDIF

C--- FIND POLES OF WLS

      NPOL=0
      INSIDE=0

C21.9.92  CONS=8.85D-5*CLIGHT1/(4.*PI1*EMASSG1)

      POWCOR=1.0  !C21.9.92

      DO IPOI=1,NCO

      BY=WTRA(2,3,IPOI)
      BYA=DABS(BY)
      ZP=WTRA(3,2,IPOI)/WTRA(1,2,IPOI)

      IF (INSIDE.EQ.0) THEN

          IF (BYA.GT.POWBCUT.AND.DABS(ZP).GT.1.D-10) THEN
         INSIDE=1
         NPOL=NPOL+1
         IF (NPOL.GT.NDPOL) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'*** ERROR IN BEAMPOW ***'
           WRITE(LUNGFO,*)'DIMENSION EXCEEDED NDPOLP'
           WRITE(LUNGFO,*)'CHECK NPOLMX AND POWBCUT IN NAMELIST SPECTN'
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'POLE NUMBER, (SLOPE ZP,X,BY) AT START, (SLOPE ZP,X,BY) AT END OF POLES ALREADY DETECTED:'
           DO IPOL=1,NPOL-1
             WRITE(LUNGFO,*)'POLES:',IPOL
             WRITE(LUNGFO,*)
     &              SNGL(WTRA(3,2,IPOLLIM(1,IPOL))
     &              /WTRA(1,2,IPOLLIM(1,IPOL)))
     &              ,SNGL(WTRA(1,1,IPOLLIM(1,IPOL)))
     &              ,SNGL(WTRA(2,3,IPOLLIM(1,IPOL)))
             WRITE(LUNGFO,*)
     &              SNGL(WTRA(3,2,IPOLLIM(2,IPOL))
     &              /WTRA(1,2,IPOLLIM(2,IPOL)))
     &              ,SNGL(WTRA(1,1,IPOLLIM(2,IPOL)))
     &              ,SNGL(WTRA(2,3,IPOLLIM(2,IPOL)))
           ENDDO  !NPOL
           WRITE(LUNGFO,*)'POLE NUMBER, (SLOPE ZP,X,BY) AT START OF CURRENT POLE:'
             WRITE(LUNGFO,*)'POLES:',NPOL
             WRITE(LUNGFO,*)
     &              SNGL(WTRA(3,2,IPOI)
     &              /WTRA(1,2,IPOI))
     &              ,SNGL(WTRA(1,1,IPOI))
     &              ,SNGL(WTRA(2,3,IPOI))
           WRITE(6,*)
           WRITE(6,*)'*** ERROR IN BEAMPOW ***'
           WRITE(6,*)'DIMENSION EXCEEDED NDPOLP'
           WRITE(6,*)'CHECK NPOLMX AND POWBCUT IN NAMELIST SPECTN'
           WRITE(6,*)
           WRITE(6,*)'POLE NUMBER, (SLOPE ZP,X,BY) AT START, (SLOPE ZP,X,BY) AT END OF POLES ALREADY DETECTED:'
           DO IPOL=1,NPOL-1
             WRITE(6,*)'POLES:',IPOL
             WRITE(6,*)
     &              SNGL(WTRA(3,2,IPOLLIM(1,IPOL))
     &              /WTRA(1,2,IPOLLIM(1,IPOL)))
     &              ,SNGL(WTRA(1,1,IPOLLIM(1,IPOL)))
     &              ,SNGL(WTRA(2,3,IPOLLIM(1,IPOL)))
             WRITE(6,*)
     &              SNGL(WTRA(3,2,IPOLLIM(2,IPOL))
     &              /WTRA(1,2,IPOLLIM(2,IPOL)))
     &              ,SNGL(WTRA(1,1,IPOLLIM(2,IPOL)))
     &              ,SNGL(WTRA(2,3,IPOLLIM(2,IPOL)))
           ENDDO  !NPOL
           WRITE(6,*)'POLE NUMBER, (SLOPE ZP,X,BY) AT START OF CURRENT POLE:'
             WRITE(6,*)'POLES:',NPOL
             WRITE(6,*)
     &              SNGL(WTRA(3,2,IPOI)
     &              /WTRA(1,2,IPOI))
     &              ,SNGL(WTRA(1,1,IPOI))
     &              ,SNGL(WTRA(2,3,IPOI))
           STOP
         ENDIF !NPOL
         ZPSIGN=DSIGN(1.D0,ZP)
         IPOLLIM(1,NPOL)=IPOI
          ENDIF   !POWBCUT

      ELSE  !INSIDE

          IF (BYOLD*BY.LE.0..OR.BYA.LT.POWBCUT) THEN
         INSIDE=0
C20.10.92      IPOLLIM(2,NPOL)=IPOI
         IPOLLIM(2,NPOL)=IPOI-1
          ENDIF   !POWBCUT)

C--- TRAJECTORY REACHES MAXIMAL DISPLACEMENT, I.E. LIGHT HITS OPPOSITE WALL

          IF(DSIGN(1.D0,ZP).NE.ZPSIGN) THEN
C20.10.92      IPOLLIM(2,NPOL)=IPOI
         IPOLLIM(2,NPOL)=IPOI-1
            IF (BYA.GT.POWBCUT.AND.DABS(ZP).GT.1.D-10) THEN
         NPOL=NPOL+1
         IF (NPOL.GT.NDPOL) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'*** ERROR IN BEAMPOW ***'
           WRITE(LUNGFO,*)'DIMENSION EXCEEDED NDPOLP'
           WRITE(LUNGFO,*)'CHECK NPOLMX AND POWBCUT IN NAMELIST SPECTN'
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'POLE NUMBER, (SLOPE ZP,X,BY) AT START, (SLOPE ZP,X,BY) AT END OF POLES ALREADY DETECTED:'
           DO IPOL=1,NPOL-1
             WRITE(LUNGFO,*)'POLES:',IPOL
             WRITE(LUNGFO,*)
     &              SNGL(WTRA(3,2,IPOLLIM(1,IPOL))
     &              /WTRA(1,2,IPOLLIM(1,IPOL)))
     &              ,SNGL(WTRA(1,1,IPOLLIM(1,IPOL)))
     &              ,SNGL(WTRA(2,3,IPOLLIM(1,IPOL)))
             WRITE(LUNGFO,*)
     &              SNGL(WTRA(3,2,IPOLLIM(2,IPOL))
     &              /WTRA(1,2,IPOLLIM(2,IPOL)))
     &              ,SNGL(WTRA(1,1,IPOLLIM(2,IPOL)))
     &              ,SNGL(WTRA(2,3,IPOLLIM(2,IPOL)))
           ENDDO  !IPOL
           WRITE(LUNGFO,*)'POLE NUMBER, (SLOPE ZP,X,BY) AT START OF CURRENT POLE:'
             WRITE(LUNGFO,*)'POLES:',NPOL
             WRITE(LUNGFO,*)
     &              SNGL(WTRA(3,2,IPOI)
     &              /WTRA(1,2,IPOI))
     &              ,SNGL(WTRA(1,1,IPOI))
     &              ,SNGL(WTRA(2,3,IPOI))
           WRITE(6,*)
           WRITE(6,*)'*** ERROR IN BEAMPOW ***'
           WRITE(6,*)'DIMENSION EXCEEDED NDPOLP'
           WRITE(6,*)'CHECK NPOLMX AND POWBCUT IN NAMELIST SPECTN'
           WRITE(6,*)
           WRITE(6,*)'POL NUMBER, (SLOPE ZP,X,BY) AT START, (SLOPE ZP,X,BY) AT END OF POLES ALREADY DETECTED:'
           DO IPOL=1,NPOL-1
             WRITE(6,*)'POLES:',IPOL
             WRITE(6,*)
     &              SNGL(WTRA(3,2,IPOLLIM(1,IPOL))
     &              /WTRA(1,2,IPOLLIM(1,IPOL)))
     &              ,SNGL(WTRA(1,1,IPOLLIM(1,IPOL)))
     &              ,SNGL(WTRA(2,3,IPOLLIM(1,IPOL)))
             WRITE(6,*)
     &              SNGL(WTRA(3,2,IPOLLIM(2,IPOL))
     &              /WTRA(1,2,IPOLLIM(2,IPOL)))
     &              ,SNGL(WTRA(1,1,IPOLLIM(2,IPOL)))
     &              ,SNGL(WTRA(2,3,IPOLLIM(2,IPOL)))
           ENDDO  !IPOL
           WRITE(6,*)'POLE NUMBER, (SLOPE ZP,X,BY) AT START OF CURRENT POLE:'
             WRITE(6,*)'POLES:',NPOL
             WRITE(6,*)
     &              SNGL(WTRA(3,2,IPOI)
     &              /WTRA(1,2,IPOI))
     &              ,SNGL(WTRA(1,1,IPOI))
     &              ,SNGL(WTRA(2,3,IPOI))
           STOP
         ENDIF !NPOL
              IPOLLIM(1,NPOL)=IPOI
         ZPSIGN=DSIGN(1.D0,ZP)
            ELSE  !POWCUT
         INSIDE=0
            ENDIF !POWCUT
          ENDIF   !DSIGN(1.D0,ZP)

      ENDIF !INSIDE

      BYOLD=BY
      ENDDO !IPOI

      IF (INSIDE.EQ.1) IPOLLIM(2,NPOL)=NCO


C--- LOOP OVER ALL POLES

      DO IPOL=1,NPOL

C--- LOOP OVER POINTS OF REFERENCE ORBIT

      DO IPOI=IPOLLIM(1,IPOL),IPOLLIM(2,IPOL)

C--- FIND POINT P WHERE RADIATION HITS THE WALL (LOGBOOK S.21)
C    AND CALCULATE POWER DENSITY

      X=WTRA(1,1,IPOI)
      Z=WTRA(3,1,IPOI)
      ZP=WTRA(3,2,IPOI)/WTRA(1,2,IPOI)
      BYA=DABS(WTRA(2,3,IPOI))
      SINPHI=DSQRT(ZP**2/(1.+ZP**2))
      COSPHI=DSQRT(1./(1.+ZP**2))

C--- POWER ON BEAMLINE WALL AND NORMAL TO BEAM

      DO IWALL=1,2

          PZ=WALL(IWALL)
          PX=(PZ-Z)/ZP+X
          DIS2=(X-PX)**2+(Z-PZ)**2
          DIS1=DSQRT(DIS2)
            IF (PX.LT.X) THEN
         D2POW=0.0
          ELSE
C21.9.92         D2POW=CONS*DMYENERGY**4*DMYCUR*BYA/DIS2*POWCOR
              D2POW=10.84/2.*1.D6*DMYENERGY**4*DMYCUR*BYA/DIS2
            ENDIF
            IF (IWALL.EQ.1.AND.Z.GT.WALL(IWALL))D2POW=0.0
            IF (IWALL.EQ.2.AND.Z.LT.WALL(IWALL))D2POW=0.0
          IF (D2POW.GT.0.0.AND.DIS1.LT.DISMIN
     &         .AND.PX.GE.XWALLI.AND.PX.LE.XWALLE) DISMIN=DIS1
C21.9.92     D1POW=D2POW*2.*DIS1/DMYGAMMA !D2POW INTEGRATED OVER Y
          IF(D2POW.NE.0.) THEN
             D1POW=(CGAM1*CLIGHT1/(2.D0*PI1))
     &               *DMYENERGY**3*DMYCUR*BYA/DIS1 !D2POW INTEGRATED OVER Y
          ELSE
             D1POW=0.0
          ENDIF
          ECGAM=ecdipev1*DMYENERGY**2*BYA*ECHARGE1 !CRITICAL PHOTONENERGY (JOULE)
          IF(ECGAM.NE.0.0) THEN
C240593     DNGAM=3.25*D1POW/ECGAM/POWCOR
C           RATE OF PHOTONS PER UNIT LENGTH
         DNGAM=15.*DSQRT(3.D0)/8.*D1POW/ECGAM/POWCOR
          ELSE
         DNGAM=0.0
          ENDIF   !ECGAM
          RADPOW(IWALL,IPOL,IPOI)=PX
          RADPOW(IWALL+ 2,IPOL,IPOI)=D2POW*SINPHI
          RADPOW(IWALL+ 4,IPOL,IPOI)=D2POW
          RADPOW(IWALL+ 6,IPOL,IPOI)=DNGAM*SINPHI
          RADPOW(IWALL+ 8,IPOL,IPOI)=DNGAM
          RADPOW(IWALL+10,IPOL,IPOI)=D1POW*SINPHI/POWCOR

      ENDDO !IWALL

      ENDDO !IPOI
      ENDDO !NPOL

C--- ASCENDING ORDER IN ARRAY

      DO IWALL=1,2
      DO IPOL=1,NPOL

          ISTART=IPOLLIM(1,IPOL)
C20.10.92       IEND=IPOLLIM(2,IPOL)-1
          IEND=IPOLLIM(2,IPOL)
          ITEST=ISTART+(IEND-ISTART)/2

          IF (RADPOW(IWALL,IPOL,ITEST).GT.RADPOW(IWALL,IPOL,ITEST+1)) THEN

         DO IMODE=0,5
           DO IPOI=ISTART,IEND
             RADPOW(14,IPOL,IPOI)=
     &              RADPOW(IWALL+2*IMODE,IPOL,IEND-IPOI+ISTART)
           ENDDO  !IPOI
           DO IPOI=ISTART,IEND
             RADPOW(IWALL+2*IMODE,IPOL,IPOI)=
     &              RADPOW(14,IPOL,IPOI)
           ENDDO  !IPOI
         ENDDO !IMODE

          ENDIF

      ENDDO !IPOL
      ENDDO !IWALL

C--- CHECK SPACING

      DO IWALL=1,2
      DO IPOL=1,NPOL
      DO IPOI=IPOLLIM(1,IPOL),IPOLLIM(2,IPOL)-1
          X1=RADPOW(IWALL,IPOL,IPOI)
          X2=RADPOW(IWALL,IPOL,IPOI+1)
          IF(X1.GE.X2) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'*** WARNING SR BEAMPOW ***'
         WRITE(LUNGFO,*)'BAD SPACING OF POINTS ON BEAMLINE WALL OCCURED'
           WRITE(LUNGFO,*)'CHECK RESULTS CAREFULLY'
         WRITE(LUNGFO,*)'TRY OTHER VALUES OF MYINUM OR OTHER BEAMLIME'
         WRITE(LUNGFO,*)'OR OTHER FIELD CONFIGURATION OR ...'
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)'*** WARNING SR BEAMPOW ***'
         WRITE(6,*)'BAD SPACING OF POINTS ON BEAMLINE WALL OCCURED'
           WRITE(6,*)'CHECK RESULTS CAREFULLY'
         WRITE(6,*)'TRY OTHER VALUES OF MYINUM OR OTHER BEAMLIME'
         WRITE(6,*)'OR OTHER FIELD CONFIGURATION OR ...'
         WRITE(6,*)
C20.10.92      STOP
          ENDIF
      ENDDO   !IPOI
      ENDDO !IPOL
      ENDDO !IWALL

C--- INTERPOLATE POWER DENSITY DISTRIBUTION BY SPLINES AND SUM UP
C    CONTRIBUTIONS OF ALL POLES, STORE INFORMATION IN HISTOGRAMS

      NBIN=NPWALL
      DXBIN=(XWALLE-XWALLI)/(NBIN-1)
      XI=XWALLI-DXBIN/2.
      XE=XI+NBIN*DXBIN

      ID=IDPOWER+1
      call hbook1m(ID,'2D POW. DENS. ON 1. WALL',
     &              NBIN,XI,XE,VMX)
      ID=IDPOWER+2
      call hbook1m(ID,'2D POW. DENS. ON 2. WALL',
     &              NBIN,XI,XE,VMX)

      ID=IDPOWER+1001
      call hbook1m(ID,'2D POW. DENS. ON 1. WALL, NORMAL',
     &              NBIN,XI,XE,VMX)
      ID=IDPOWER+1002
      call hbook1m(ID,
     &       '2D POW. DENS. ON 2. WALL, NORMAL',
     &        NBIN,XI,XE,VMX)

      ID=IDPOWER+2001
      call hbook1m(ID,'PHOTON RATE ON 1. WALL',
     &              NBIN,XI,XE,VMX)
      ID=IDPOWER+2002
      call hbook1m(ID,'PHOTON RATE ON 2. WALL',
     &              NBIN,XI,XE,VMX)

      ID=IDPOWER+3001
      call hbook1m(ID,'PHOTON RATE ON 1. WALL, NORMAL',
     &              NBIN,XI,XE,VMX)
      ID=IDPOWER+3002
      call hbook1m(ID,
     &       'PHOTON RATE ON 2. WALL, NORMAL',
     &        NBIN,XI,XE,VMX)

      ID=IDPOWER+4001
      call hbook1m(ID,'1D POW. DENS.,1. WALL',
     &              NBIN,XI,XE,VMX)
      ID=IDPOWER+4002
      call hbook1m(ID,'1D POW. DENS.,2. WALL',
     &              NBIN,XI,XE,VMX)


      DO IWALL=1,2
      DO IMODE=0,4

      ID=IDPOWER+1000*IMODE+IWALL

      DO IPOL=1,NPOL
C20.10.92       NN=IPOLLIM(2,IPOL)-IPOLLIM(1,IPOL)
          NN=IPOLLIM(2,IPOL)-IPOLLIM(1,IPOL)+1
      DO IBIN=1,NBIN

          XFILL=XI-DXBIN/2.+IBIN*DXBIN
          CALL POWINT(XFILL,YFILL,IWALL,IMODE,IPOL,
     &           IPOLLIM(1,IPOL),NN) !INTERPOLATION OF POWERDENSITY
          IF (YFILL.LT.0.AND.IWARN1.NE.1) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'*** WARNING SR BEAMPOW ***'
         WRITE(LUNGFO,*)'PROBLEMS WITH SPLINE-INTERPOLATION'
         WRITE(LUNGFO,*)'CHANGE SPACING'
         WRITE(LUNGFO,*)'NEGATIVE INTERPOLATION RESULT SET TO ZERO'
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)'*** WARNING SR BEAMPOW ***'
         WRITE(6,*)'PROBLEMS WITH SPLINE-INTERPOLATION'
         WRITE(6,*)'CHANGE SPACING'
         WRITE(6,*)'NEGATIVE INTERPOLATION RESULT SET TO ZERO'
         WRITE(6,*)
         IWARN1=1
          ENDIF !YFILL
          IF (YFILL.LT.0.) THEN
         YFILL=0.
          ENDIF !YFILL

          CALL hfillm(ID,XFILL,0.,dble(YFILL))

      ENDDO !IBIN
      ENDDO !IPOL
      ENDDO !IMODE
      ENDDO !IWALL

C--- TOTAL PHOTO DESORPTION

C DONT SUM UP NORMAL FLUX. RESULT WOULD BE WRONG SINCE
C INTEGRATION IS PERFORM ALONG THE BEAMLINE WHILE FLUX IS
C CALCULATED NORMAL TO BEAM

      DO IWALL=1,2
          TOTGAM(IWALL)  =HSUMM(IDPOWER+2000+IWALL)*DXBIN
          TOTGAM(IWALL+2)=HSUMM(IDPOWER+4000+IWALL)*DXBIN

          TOTMAX(IWALL)  =hmaxm(IDPOWER+0000+IWALL)
          TOTMAX(IWALL+2)=hmaxm(IDPOWER+3000+IWALL)
          TOTMAX(IWALL+4)=hmaxm(IDPOWER+4000+IWALL)
      ENDDO !IWALL

          TOTMAX(11)=DISMIN

C****************************************************************
C     NOW EVERYTHING FOR NORMAL ABSORBER
C****************************************************************

C--- FIND POLES OF WLS

      NPOL=0
      INSIDE=0

C21.9.92  CONS=8.85D-5*CLIGHT1/(4.*PI1*EMASSG1)

      POWCOR=1.0  !C21.9.92

      DO IPOI=1,NCO

      IF (WTRA(1,1,IPOI).GE.XIANF.AND.WTRA(1,1,IPOI).LE.XIEND) THEN
           BY=WTRA(2,3,IPOI)
      ELSE
           BY=0.0
      ENDIF


      BYA=DABS(BY)
      ZP=WTRA(3,2,IPOI)/WTRA(1,2,IPOI)

      IF (INSIDE.EQ.0) THEN

          IF (BYA.GT.POWBCUT) THEN
         INSIDE=1
         NPOL=NPOL+1
         IF (NPOL.GT.NDPOL) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'*** ERROR IN BEAMPOW ***'
           WRITE(LUNGFO,*)'DIMENSION EXCEEDED NDPOLP'
           WRITE(LUNGFO,*)'CHECK NPOLMX AND POWBCUT IN NAMELIST SPECTN'
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'POLE NUMBER, (SLOPE ZP,X,BY) AT START, (SLOPE ZP,X,BY) AT END OF POLES ALREADY DETECTED:'
           DO IPOL=1,NPOL-1
             WRITE(LUNGFO,*)'POLES:',IPOL
             WRITE(LUNGFO,*)
     &              SNGL(WTRA(3,2,IPOLLIM(1,IPOL))
     &              /WTRA(1,2,IPOLLIM(1,IPOL)))
     &              ,SNGL(WTRA(1,1,IPOLLIM(1,IPOL)))
     &              ,SNGL(WTRA(2,3,IPOLLIM(1,IPOL)))
             WRITE(LUNGFO,*)
     &              SNGL(WTRA(3,2,IPOLLIM(2,IPOL))
     &              /WTRA(1,2,IPOLLIM(2,IPOL)))
     &              ,SNGL(WTRA(1,1,IPOLLIM(2,IPOL)))
     &              ,SNGL(WTRA(2,3,IPOLLIM(2,IPOL)))
           ENDDO  !NPOL
           WRITE(LUNGFO,*)'POLE NUMBER, (SLOPE ZP,X,BY) AT START OF CURRENT POLE:'
             WRITE(LUNGFO,*)'POLES:',NPOL
             WRITE(LUNGFO,*)
     &              SNGL(WTRA(3,2,IPOI)
     &              /WTRA(1,2,IPOI))
     &              ,SNGL(WTRA(1,1,IPOI))
     &              ,SNGL(WTRA(2,3,IPOI))
           WRITE(6,*)
           WRITE(6,*)'*** ERROR IN BEAMPOW ***'
           WRITE(6,*)'DIMENSION EXCEEDED NDPOLP'
           WRITE(6,*)'CHECK NPOLMX AND POWBCUT IN NAMELIST SPECTN'
           WRITE(6,*)
           WRITE(6,*)'POLE NUMBER, (SLOPE ZP,X,BY) AT START, (SLOPE ZP,X,BY) AT END OF POLES ALREADY DETECTED:'
           DO IPOL=1,NPOL-1
             WRITE(6,*)'POLES:',IPOL
             WRITE(6,*)
     &              SNGL(WTRA(3,2,IPOLLIM(1,IPOL))
     &              /WTRA(1,2,IPOLLIM(1,IPOL)))
     &              ,SNGL(WTRA(1,1,IPOLLIM(1,IPOL)))
     &              ,SNGL(WTRA(2,3,IPOLLIM(1,IPOL)))
             WRITE(6,*)
     &              SNGL(WTRA(3,2,IPOLLIM(2,IPOL))
     &              /WTRA(1,2,IPOLLIM(2,IPOL)))
     &              ,SNGL(WTRA(1,1,IPOLLIM(2,IPOL)))
     &              ,SNGL(WTRA(2,3,IPOLLIM(2,IPOL)))
           ENDDO  !NPOL
           WRITE(6,*)'POLE NUMBER, (SLOPE ZP,X,BY) AT START OF CURRENT POLE:'
             WRITE(6,*)'POLES:',NPOL
             WRITE(6,*)
     &              SNGL(WTRA(3,2,IPOI)
     &              /WTRA(1,2,IPOI))
     &              ,SNGL(WTRA(1,1,IPOI))
     &              ,SNGL(WTRA(2,3,IPOI))
           STOP
         ENDIF !NPOL
         IPOLLIM(1,NPOL)=IPOI
          ENDIF   !POWBCUT

      ELSE  !INSIDE

          IF (BYOLD*BY.LE.0..OR.BYA.LT.POWBCUT) THEN
         INSIDE=0
C20.10.92      IPOLLIM(2,NPOL)=IPOI
         IPOLLIM(2,NPOL)=IPOI-1
          ENDIF   !POWBCUT

      ENDIF !INSIDE

      BYOLD=BY
      ENDDO !IPOI

      IF (INSIDE.EQ.1) IPOLLIM(2,NPOL)=NCO

C--- LOOP OVER ALL POLES

      DO IPOL=1,NPOL

C--- LOOP OVER POINTS OF REFERENCE ORBIT

      DO IPOI=IPOLLIM(1,IPOL),IPOLLIM(2,IPOL)

C--- FIND POINT P WHERE RADIATION HITS THE WALL (LOGBOOK S.21)
C    AND CALCULATE POWER DENSITY

      X=WTRA(1,1,IPOI)
      Z=WTRA(3,1,IPOI)
      ZP=WTRA(3,2,IPOI)/WTRA(1,2,IPOI)
      BYA=DABS(WTRA(2,3,IPOI))
      SINPHI=DSQRT(ZP**2/(1.+ZP**2))
      COSPHI=DSQRT(1./(1.+ZP**2))

C--- POWER

          PZ=Z+ZP*(XABSORB-X)
          PX=XABSORB
          DIS2=(X-PX)**2+(Z-PZ)**2
          DIS1=DSQRT(DIS2)
            IF (PX.LT.X) THEN
         D2POW=0.0
          ELSE
C21.9.92         D2POW=CONS*DMYENERGY**4*DMYCUR*BYA/DIS2*POWCOR
              D2POW=10.84/2.*1.D6*DMYENERGY**4*DMYCUR*BYA/DIS2
            ENDIF
          IF (D2POW.GT.0.0.AND.DIS1.LT.DISMINA) DISMINA=DIS1
C21.9.92     D1POW=D2POW*2.*DIS1/DMYGAMMA !D2POW INTEGRATED OVER Y
          IF(D2POW.NE.0.) THEN
            D1POW=(CGAM1*CLIGHT1/(2.D0*PI1))
     &              *DMYENERGY**3*DMYCUR*BYA/DIS1  !D2POW INTEGRATED OVER Y
          ELSE
            D1POW=0.0
          ENDIF
          ECGAM=ecdipev1*DMYENERGY**2*BYA*ECHARGE1 !CRITICAL PHOTONENERGY (JOULE)
          IF(ECGAM.NE.0.0) THEN
C240593     DNGAM=3.25*D1POW/ECGAM/POWCOR
C           RATE OF PHOTONS PER UNIT LENGTH
         DNGAM=15.*DSQRT(3.D0)/8.*D1POW/ECGAM/POWCOR
          ELSE
         DNGAM=0.0
          ENDIF   !ECGAM
          RADPOW(13,IPOL,IPOI)=PZ
          RADPOW(15,IPOL,IPOI)=D2POW*COSPHI
          RADPOW(17,IPOL,IPOI)=DNGAM*COSPHI
          RADPOW(19,IPOL,IPOI)=D1POW*COSPHI/POWCOR

      ENDDO !IPOI
      ENDDO !NPOL

C- ASCENDING ORDER

      DO IPOL=1,NPOL

          ISTART=IPOLLIM(1,IPOL)
          IEND=IPOLLIM(2,IPOL)

          IF (RADPOW(13,IPOL,ISTART).GT.RADPOW(13,IPOL,IEND)) THEN

         DO IMODE=0,3
           DO IPOI=ISTART,IEND
             RADPOW(14,IPOL,IPOI)=
     &              RADPOW(13+2*IMODE,IPOL,IEND-IPOI+ISTART)
           ENDDO  !IPOI
           DO IPOI=ISTART,IEND
             RADPOW(13+2*IMODE,IPOL,IPOI)=
     &              RADPOW(14,IPOL,IPOI)
           ENDDO  !IPOI
         ENDDO !IMODE

          ENDIF

      ENDDO !IPOL

C--- CHECK SPACING

      DO IPOL=1,NPOL
      DO IPOI=IPOLLIM(1,IPOL),IPOLLIM(2,IPOL)-1
          X1=RADPOW(13,IPOL,IPOI)
          X2=RADPOW(13,IPOL,IPOI+1)
          IF(X1.GE.X2) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'*** WARNING SR BEAMPOW ***'
         WRITE(LUNGFO,*)'BAD SPACING OF POINTS ON ABSORBER OCCURED'
           WRITE(LUNGFO,*)'CHECK RESULTS CAREFULLY'
         WRITE(LUNGFO,*)'TRY OTHER VALUES OF MYINUM OR ABSORBER'
         WRITE(LUNGFO,*)'OR OTHER FIELD CONFIGURATION OR ...'
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)'*** WARNING SR BEAMPOW ***'
         WRITE(6,*)'BAD SPACING OF POINTS ON ABSORBER OCCURED'
           WRITE(6,*)'CHECK RESULTS CAREFULLY'
         WRITE(6,*)'TRY OTHER VALUES OF MYINUM OR OTHER ABSORBER'
         WRITE(6,*)'OR OTHER FIELD CONFIGURATION OR ...'
         WRITE(6,*)
C20.10.92      STOP
          ENDIF
      ENDDO   !IPOI
      ENDDO !IPOL

C--- INTERPOLATE POWER DENSITY DISTRIBUTION BY SPLINES AND SUM UP
C    CONTRIBUTIONS OF ALL POLES, STORE INFORMATION IN HISTOGRAMS

      DZBIN=(ZABSORB(1)-ZABSORB(2))/(NBIN-1)
      XI=ZABSORB(2)-DZBIN/2.
      XE=XI+NBIN*DZBIN

      ID=IDPOWER+5001
      call hbook1m(ID,'2D POW. DENS. ON ABSORBER',
     &              NBIN,XI,XE,VMX)

      ID=IDPOWER+5002
      call hbook1m(ID,'PHOTON RATE ON ABSORBER',
     &              NBIN,XI,XE,VMX)

      ID=IDPOWER+5003
      call hbook1m(ID,'1D POW. DENS.,ABSORBER',
     &              NBIN,XI,XE,VMX)

      DO IPOL=1,NPOL
          NN=IPOLLIM(2,IPOL)-IPOLLIM(1,IPOL)+1
      DO IBIN=1,NBIN

          ID=IDPOWER+5001
          XFILL=XI-DZBIN/2.+IBIN*DZBIN
          CALL POWINT(XFILL,YFILL,13,0,IPOL,
     &           IPOLLIM(1,IPOL),NN) !INTERPOLATION OF POWERDENSITY
          IF (YFILL.LT.0.AND.IWARN2.NE.1) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'*** WARNING SR BEAMPOW ***'
         WRITE(LUNGFO,*)'PROBLEMS WITH SPLINE-INTERPOLATION'
         WRITE(LUNGFO,*)'CHANGE SPACING'
         WRITE(LUNGFO,*)'NEGATIVE INTERPOLATION RESULT SET TO ZERO'
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)'*** WARNING SR BEAMPOW ***'
         WRITE(6,*)'PROBLEMS WITH SPLINE-INTERPOLATION'
         WRITE(6,*)'CHANGE SPACING'
         WRITE(6,*)'NEGATIVE INTERPOLATION RESULT SET TO ZERO'
         WRITE(6,*)
         IWARN2=1
          ENDIF !YFILL
          IF (YFILL.LT.0.) THEN
         YFILL=0.
          ENDIF !YFILL

          CALL hfillm(ID,XFILL,0.,dble(YFILL))

          ID=IDPOWER+5002
          CALL POWINT(XFILL,YFILL,13,1,IPOL,
     &           IPOLLIM(1,IPOL),NN)
          IF (YFILL.LT.0.AND.IWARN3.NE.1) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'*** WARNING SR BEAMPOW ***'
         WRITE(LUNGFO,*)'PROBLEMS WITH SPLINE-INTERPOLATION'
         WRITE(LUNGFO,*)'CHANGE SPACING'
         WRITE(LUNGFO,*)'NEGATIVE INTERPOLATION RESULT SET TO ZERO'
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)'*** WARNING SR BEAMPOW ***'
         WRITE(6,*)'PROBLEMS WITH SPLINE-INTERPOLATION'
         WRITE(6,*)'CHANGE SPACING'
         WRITE(6,*)'NEGATIVE INTERPOLATION RESULT SET TO ZERO'
         WRITE(6,*)
         IWARN3=1
          ENDIF !YFILL
          IF (YFILL.LT.0.) THEN
         YFILL=0.
          ENDIF !YFILL

          CALL hfillm(ID,XFILL,0.,dble(yfill))

          ID=IDPOWER+5003
          CALL POWINT(XFILL,YFILL,13,2,IPOL,
     &           IPOLLIM(1,IPOL),NN)
          IF (YFILL.LT.0.AND.IWARN4.NE.1) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'*** WARNING SR BEAMPOW ***'
         WRITE(LUNGFO,*)'PROBLEMS WITH SPLINE-INTERPOLATION'
         WRITE(LUNGFO,*)'CHANGE SPACING'
         WRITE(LUNGFO,*)'NEGATIVE INTERPOLATION RESULT SET TO ZERO'
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)'*** WARNING SR BEAMPOW ***'
         WRITE(6,*)'PROBLEMS WITH SPLINE-INTERPOLATION'
         WRITE(6,*)'CHANGE SPACING'
         WRITE(6,*)'NEGATIVE INTERPOLATION RESULT SET TO ZERO'
         WRITE(6,*)
         IWARN4=1
          ENDIF !YFILL
          IF (YFILL.LT.0.) THEN
         YFILL=0.
          ENDIF !YFILL

          CALL hfillm(ID,XFILL,0.,dble(yfill))

      ENDDO !IBIN
      ENDDO !IPOL

      TOTGAM(5)=HSUMM(IDPOWER+5002)*DZBIN
      TOTGAM(6)=HSUMM(IDPOWER+5003)*DZBIN

      TOTMAX(7)=hmaxm(IDPOWER+5001)
      TOTMAX(8)=hmaxm(IDPOWER+5002)
      TOTMAX(9)=hmaxm(IDPOWER+5003)

      TOTMAX(12)=DISMINA

      CALL MHROUT(IDPOWER+1,ICYCLE,' ')
      CALL MHROUT(IDPOWER+2,ICYCLE,' ')
      CALL MHROUT(IDPOWER+1001,ICYCLE,' ')
      CALL MHROUT(IDPOWER+1002,ICYCLE,' ')
      CALL MHROUT(IDPOWER+2001,ICYCLE,' ')
      CALL MHROUT(IDPOWER+2002,ICYCLE,' ')
      CALL MHROUT(IDPOWER+3001,ICYCLE,' ')
      CALL MHROUT(IDPOWER+3002,ICYCLE,' ')
      CALL MHROUT(IDPOWER+4001,ICYCLE,' ')
      CALL MHROUT(IDPOWER+4002,ICYCLE,' ')
      CALL MHROUT(IDPOWER+5001,ICYCLE,' ')
      CALL MHROUT(IDPOWER+5002,ICYCLE,' ')
      CALL MHROUT(IDPOWER+5003,ICYCLE,' ')

      CALL hdeletm(IDPOWER+1)
      CALL hdeletm(IDPOWER+2)
      CALL hdeletm(IDPOWER+1001)
      CALL hdeletm(IDPOWER+1002)
      CALL hdeletm(IDPOWER+2001)
      CALL hdeletm(IDPOWER+2002)
      CALL hdeletm(IDPOWER+3001)
      CALL hdeletm(IDPOWER+3002)
      CALL hdeletm(IDPOWER+4001)
      CALL hdeletm(IDPOWER+4002)
      CALL hdeletm(IDPOWER+5001)
      CALL hdeletm(IDPOWER+5002)
      CALL hdeletm(IDPOWER+5003)

+SELF,IF=F90.
      DEALLOCATE(POWS2)
+SELF.

      RETURN
      END
+DECK,BELLANA.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.66/09 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.63/05 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  2.63/02 06/03/2008  15.55.08  by  Michael Scheer
*CMZ :  2.62/04 20/11/2007  09.47.54  by  Michael Scheer
*CMZ :  2.62/02 04/06/2007  13.30.31  by  Michael Scheer
*CMZ :  2.61/06 12/04/2007  09.54.44  by  Michael Scheer
*CMZ :  2.61/02 19/03/2007  15.22.59  by  Michael Scheer
*CMZ :  2.61/01 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.61/00 29/01/2007  14.25.16  by  Michael Scheer
*CMZ :  2.60/00 26/01/2007  10.42.26  by  Michael Scheer
*CMZ :  2.59/02 25/01/2007  14.58.31  by  Michael Scheer
*CMZ :  2.59/00 23/01/2007  15.38.35  by  Michael Scheer
*CMZ :  2.58/01 23/01/2007  13.16.29  by  Michael Scheer
*CMZ :  2.16/08 31/10/2000  11.26.00  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ : 00.01/12 04/10/96  17.37.39  by  Michael Scheer
*CMZ : 00.01/10 31/05/96  14.14.47  by  Michael Scheer
*CMZ : 00.01/09 20/05/96  14.42.08  by  Michael Scheer
*-- Author :    Michael Scheer   06/05/96

      SUBROUTINE BELLANA(XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT)

+seq,gplhint.

c{ 7.4.2010:
c Adapted to version of POLYMAG
C NOT CLEAR, IF ALL COMMENTS ARE STILL CORRECT...
c} 7.4.2010:


C     V1=
C         Bi/2/4/KY * COS(KX*(X-X0)) * EXP(KY*Y) *  COS(KZ*Z-PHI/2)
C        +B0/1/4/KZ *                  EXP(KZ*Y) *  COS(KZ*Z-PHI/2)
C     V2=
C         Bi/2/4/KY * COS(KX*(X+X0)) * EXP(KY*Y) *  COS(KZ*Z+PHI/2)
C        +B0/1/4/KZ *                  EXP(KZ*Y) *  COS(KZ*Z+PHI/2)
C     V3=
C        -Bi/2/4/KY * COS(KX*(X+X0)) * EXP(-KY*Y) *  COS(KZ*Z-PHI/2)
C        -B0/1/4/KZ *                  EXP(-KZ*Y) *  COS(KZ*Z-PHI/2)
C     V4=
C        -Bi/2/4/KY * COS(KX*(X-X0)) * EXP(-KY*Y) *  COS(KZ*Z+PHI/2)
C        -B0/1/4/KZ *                  EXP(-KZ*Y) *  COS(KZ*Z+PHI/2)
C
C      X0 is distance of magnet center from device axis

C     V=V1+V2+V3+V4
C
C Noch berichtigen (Gode)
C     AX=-INT(DF(V,Y),Z)=INT(BY,Z)
C     AY=+INT(DF(V,X),Z)=-INT(BX,Z)
C     AZ=0
C
C
C     KY=SQRT(KX**2+KZ**2)
C
C     BX=-DF(V,X)
C     BY=-DF(V,Y)
C     BZ=-DF(V,Z)
C
C     BX1=
C        +KX/KY*Bi/2/4 * SIN(KX*(X-X0)) * EXP(KY*Y) *  COS(KZ*Z-PHI/2)
C     BY1=
C        -   Bi/2/4 * COS(KX*(X-X0)) * EXP(KY*Y) *  COS(KZ*Z-PHI/2)
C        -   B0/1/4 *                  EXP(KZ*Y) *  COS(KZ*Z-PHI/2)
C     BZ1=
C        +KZ/KY*Bi/2/4 * COS(KX*(X-X0)) * EXP(KY*Y) *  SIN(KZ*Z-PHI/2)
C        +      B0/1/4 *                  EXP(KZ*Y) *  SIN(KZ*Z-PHI/2)
C
C     BX2=
C        +KX/KY*Bi/2/4 * SIN(KX*(X+X0)) * EXP(KY*Y) *  COS(KZ*Z+PHI/2)
C     BY2=
C        -      Bi/2/4 * COS(KX*(X+X0)) * EXP(KY*Y) *  COS(KZ*Z+PHI/2)
C        -      B0/1/4 *                  EXP(KZ*Y) *  COS(KZ*Z+PHI/2)
C     BZ2=
C        +KZ/KY*Bi/2/4 * COS(KX*(X+X0)) * EXP(KY*Y) *  SIN(KZ*Z+PHI/2)
C        +      B0/1/4 *                  EXP(KZ*Y) *  SIN(KZ*Z+PHI/2)
C
C     BX3=
C        -KX/KY*Bi/2/4 * SIN(KX*(X+X0)) * EXP(-KY*Y) *  COS(KZ*Z-PHI/2)
C     BY3=
C        -      Bi/2/4 * COS(KX*(X+X0)) * EXP(-KY*Y) *  COS(KZ*Z-PHI/2)
C        -      B0/1/4 *                  EXP(-KZ*Y) *  COS(KZ*Z-PHI/2)
C     BZ3=
C        -KZ/KY*Bi/2/4 * COS(KX*(X+X0)) * EXP(-KY*Y) *  SIN(KZ*Z-PHI/2)
C        -      B0/1/4 *                  EXP(-KZ*Y) *  SIN(KZ*Z-PHI/2)
C
C     BX4=
C        -KX/KY*Bi/2/4 * SIN(KX*(X-X0)) * EXP(-KY*Y) *  COS(KZ*Z+PHI/2)
C     BY4=
C        -      Bi/2/4 * COS(KX*(X-X0)) * EXP(-KY*Y) *  COS(KZ*Z+PHI/2)
C        -      B0/1/4 *                  EXP(-KZ*Y) *  COS(KZ*Z+PHI/2)
C     BZ4=
C        -KZ/KY*Bi/2/4 * COS(KX*(X-X0)) * EXP(-KY*Y) *  SIN(KZ*Z+PHI/2)
C        -      B0/1/4 *                  EXP(-KZ*Y) *  SIN(KZ*Z+PHI/2)
C
C     AY1=
C        +KX/KY*Bi/2/4 * SIN(KX*(X-X0)) * EXP(KY*Y) * - SIN(KZ*Z-PHI/2)/KZ
C     AX1=
C        -   Bi/2/4 * COS(KX*(X-X0)) * EXP(KY*Y) *  SIN(KZ*Z-PHI/2)/KZ
C        -   B0/1/4 *                  EXP(KZ*Y) *  SIN(KZ*Z-PHI/2)/KZ
C
C     AY2=
C        +KX/KY*Bi/2/4 * SIN(KX*(X+X0)) * EXP(KY*Y) * - SIN(KZ*Z+PHI/2)/KZ
C     AX2=
C        -      Bi/2/4 * COS(KX*(X+X0)) * EXP(KY*Y) *  SIN(KZ*Z+PHI/2)/KZ
C        -      B0/1/4 *                  EXP(KZ*Y) *  SIN(KZ*Z+PHI/2)/KZ
C
C     AY3=
C        -KX/KY*Bi/2/4 * SIN(KX*(X+X0)) * EXP(-KY*Y) * - SIN(KZ*Z-PHI/2)/KZ
C
C     AX3=
C        -      Bi/2/4 * COS(KX*(X+X0)) * EXP(-KY*Y) *  SIN(KZ*Z-PHI/2)/KZ
C        -      B0/1/4 *                  EXP(-KZ*Y) *  SIN(KZ*Z-PHI/2)/KZ
C
C     AY4=
C        -KX/KY*Bi/2/4 * SIN(KX*(X-X0)) * EXP(-KY*Y) * - SIN(KZ*Z+PHI/2)/KZ
C     AX4=
C        -      Bi/2/4 * COS(KX*(X-X0)) * EXP(-KY*Y) *  SIN(KZ*Z+PHI/2)/KZ
C        -      B0/1/4 *                  EXP(-KZ*Y) *  SIN(KZ*Z+PHI/2)/KZ

      IMPLICIT NONE

      DOUBLE PRECISION BX,BY,BZ,AX,AY,AZ,X,Y,Z
     &  ,XIN,YIN,ZIN
     &  ,BXOUT,BYOUT,BZOUT
     &  ,AXOUT,AYOUT,AZOUT

      DOUBLE PRECISION XKXP,XKXM,YKY,PHI,PHI2,PHIROW,PHIROW2,BI2,ZKY
     &  ,BX1,BY1,BZ1
     &  ,BX2,BY2,BZ2
     &  ,BX3,BY3,BZ3
     &  ,BX4,BY4,BZ4
     &  ,AX1,AY1
     &  ,AX2,AY2
     &  ,AX3,AY3
     &  ,AX4,AY4
     &  ,COSXP,COSXM,EXPY,EXPZ
     &  ,SINXP,SINXM,EXPYM,EXPZM,ZKYK,XKYK,BRAD,PEL
     &  ,ZKZP1,ZKZP3,COSZP1,COSZP3,SINZP1,SINZP3
     &  ,ZKZP2,ZKZP4,COSZP2,COSZP4,SINZP2,SINZP4
     &  ,XKXI,YKI,HLEN100,HLEN75,BCONST
     &  ,GAPCOEF,YGAP,DEXPYGAP

+SEQ,CONTRL.
+SEQ,PHYCON.
+SEQ,ELLANA.

      INTEGER ICAL,ICOEF,IDUM

      DATA ICAL/0/

      IF (ICAL.EQ.0) THEN

        IF (XLELLANA.NE.0.D0) THEN
          XKELLANA=2.D0*PI1/XLELLANA
        ELSE
          XKELLANA=0.D0
        ENDIF

        IF (ZLELLANA.NE.0.D0) THEN
          ZKELLANA=2.D0*PI1/ZLELLANA
        ELSE
          ZKELLANA=0.D0
        ENDIF

        YKELLANA=DSQRT(XKELLANA**2+ZKELLANA**2)

        IF (YKELLANA.NE.0.D0) THEN
          YLELLANA=2.D0*PI1/YKELLANA
        ELSE
          YLELLANA=0.D0
        ENDIF

        PHI=SHELLANA*2.0D0*PI1
        PHI2=PHI/2.0D0
        PHIROW=ROWSHELLA*2.0D0*PI1
        PHIROW2=PHIROW/2.0D0
        PEL=EMASSG1*DSQRT( (DMYGAMMA+1.D0)*(DMYGAMMA-1.D0) )

        IF (B0ELLANA.NE.0.0D0) THEN
          BRAD=PEL/CLIGHT1*1.D9/B0ELLANA
        ELSE
          BRAD=0.0D0
        ENDIF

        IF (IELLCOEF.GT.0) THEN

          IF (IELLCOEF.GT.NELLCOEFP) THEN
            WRITE(6,*)'*** Error in BELLANA: Too many coefficients'
            WRITE(6,*)'*** i.e. more than',NELLCOEFP
            WRITE(6,*)'*** Program WAVE aborted ***'
            WRITE(LUNGFO,*)'*** Error in BELLANA: Too many coefficients'
            WRITE(LUNGFO,*)'*** i.e. more than',NELLCOEFP
            WRITE(LUNGFO,*)'*** Program WAVE aborted ***'
            STOP
          ENDIF

          OPEN(UNIT=99,FILE='bellana.coef',STATUS='OLD')

          read(99,*)gapcoef
          gapcoef=gapcoef/1000.0d0

          if (abs(gapcoef-refgapell).gt.1.0e-6) then
            print*,'*** Error in BELLANA: Bad reference gap on file bellana.coef'
            stop '*** Program WAVE aborted ***'
          endif

          DO ICOEF=1,IELLCOEF

            READ(99,*)IDUM,ELLCOEF(ICOEF)
            ELLCOEF(ICOEF)=ELLCOEF(ICOEF)*4.0D0
            IF (IDUM.NE.ICOEF-1) THEN
              WRITE(6,*)'*** Error in BELLANA: Bad numbering of coefficients'
              WRITE(6,*)'*** Program WAVE aborted ***'
              WRITE(LUNGFO,*)
     &          '*** Error in BELLANA: Bad numbering of coefficients'
              WRITE(LUNGFO,*)
     &          '*** Program WAVE aborted ***'
              STOP
            ENDIF
          ENDDO

          CLOSE(99)

        ELSE !IF (IELLCOEF.LE.0)

          ELLCOEF(1)=0.5D0
          ELLCOEF(2)=1.0D0

        ENDIF

        YGAP=(GAPELL-REFGAPELL)/2.0D0

        TLENELL=ZLELLANA*(NPERELLA+2)
        HLENELL=TLENELL/2.0D0
        HLEN75=HLENELL-ZLELLANA/2.0D0
        HLEN100=HLENELL-ZLELLANA

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     SR BELLANA, Parameter of elliptical undulator:'
        WRITE(LUNGFO,*)'     Field amplitude [T], bending radius[m], X0 [m]:  '
        WRITE(LUNGFO,*)'     ',SNGL(B0ELLANA),SNGL(BRAD),SNGL(X0ELLANA)
        WRITE(LUNGFO,*)'     Number of periods:  ',NPERELLA
        WRITE(LUNGFO,*)'     Half and total device length [m]:  '
        WRITE(LUNGFO,*)'     ',TLENELL,HLENELL
        WRITE(LUNGFO,*)'     Lx [m], Ly[m], Lz [m]:  '
        WRITE(LUNGFO,*)'     ',SNGL(XLELLANA),SNGL(YLELLANA),SNGL(ZLELLANA)
        WRITE(LUNGFO,*)'     Kx, Ky, Kz:  '
        WRITE(LUNGFO,*)'     ',SNGL(XKELLANA),SNGL(YKELLANA),SNGL(ZKELLANA)
        WRITE(LUNGFO,*)'     Shift and additional row shift in units of Lz:  '
        WRITE(LUNGFO,*)'     ',SNGL(SHELLANA),SNGL(ROWSHELLA)
        WRITE(LUNGFO,*)'     Gap and reference gap [m]:  '
        WRITE(LUNGFO,*)'     ',SNGL(GAPELL),SNGL(REFGAPELL)
        WRITE(LUNGFO,*)'     IELLS2S3:  ',IELLS2S3
        IF (IELLCOEF.LE.0) THEN
          WRITE(LUNGFO,*)'     Fourier coefficients:'
          WRITE(LUNGFO,*)'     0 0.125'
          WRITE(LUNGFO,*)'     1 0.25'
          IELLCOEF=2
        ELSE
          WRITE(LUNGFO,*)'     Fourier coefficients from file bellana.coef:'
          DO ICOEF=1,IELLCOEF
            WRITE(LUNGFO,*)'     ',icoef,ELLCOEF(ICOEF)
          ENDDO
        ENDIF
        WRITE(LUNGFO,*)

        WRITE(6,*)
        WRITE(6,*)'*** Warning in BELLANA: Vector potential not yet implemented'
        WRITE(6,*)

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** Warning in BELLANA: Vector potential not yet implemented'
        WRITE(LUNGFO,*)

        ICAL=1

      ENDIF !ICAL

      X=-ZIN
      Y=YIN
      Z=XIN

      IF (ABS(Z).GT.HLENELL) THEN
        BXOUT=0.0D0
        BYOUT=0.0D0
        BZOUT=0.0D0
        AXOUT=0.0D0
        AYOUT=0.0D0
        AZOUT=0.0D0
        RETURN
      ELSE IF (ABS(Z).GT.HLEN75) THEN
        BCONST=0.25D0
      ELSE IF (ABS(Z).GT.HLEN100) THEN
        BCONST=0.75D0
      ELSE
        BCONST=1.0D0
      ENDIF

      YKY=YKELLANA*Y
      ZKYK=ZKELLANA/YKELLANA
      ZKY=ZKELLANA*Y

      IF (IELLS2S3.GE.0) THEN
        ZKZP1=ZKELLANA*Z+PHI2
        ZKZP2=ZKELLANA*Z-PHI2
        ZKZP3=ZKELLANA*Z+PHI2+PHIROW
        ZKZP4=ZKELLANA*Z-PHI2+PHIROW
      ELSE
        ZKZP1=ZKELLANA*Z-PHI-PHIROW2
        ZKZP2=ZKELLANA*Z    -PHIROW2
        ZKZP3=ZKELLANA*Z+PHI+PHIROW2
        ZKZP4=ZKELLANA*Z    +PHIROW2
      ENDIF

      DEXPYGAP=DEXP(-ZKELLANA*YGAP)

      EXPZ=DEXP(ZKY)
      EXPZM=1.0D0/EXPZ
      EXPZ=EXPZ*DEXPYGAP
      EXPZM=EXPZM*DEXPYGAP

      COSZP1=DCOS(ZKZP1)
      SINZP1=DSIN(ZKZP1)
      COSZP3=DCOS(ZKZP3)
      SINZP3=DSIN(ZKZP3)

      COSZP2=DCOS(ZKZP2)
      SINZP2=DSIN(ZKZP2)
      COSZP4=DCOS(ZKZP4)
      SINZP4=DSIN(ZKZP4)

C first Fourier coefficient

      !X0ELLANA is distance of magnet center from device axis

      XKXP=XKELLANA*(X+X0ELLANA)
      XKXM=XKELLANA*(X-X0ELLANA)
      XKYK=XKELLANA/YKELLANA

      COSXP=DCOS(XKXP)
      COSXM=DCOS(XKXM)
      SINXP=DSIN(XKXP)
      SINXM=DSIN(XKXM)

      BI2=B0ELLANA/4.D0*ELLCOEF(1)

      BX1=0.0d0
      BY1=-     BI2 *         EXPZ * COSZP1
      BZ1=+     BI2 *         EXPZ * SINZP1

      BX2=0.0d0
      BY2=-     BI2 *         EXPZ * COSZP2
      BZ2=+     BI2 *         EXPZ * SINZP2

      BX3=0.0d0
      BY3=-     BI2 *         EXPZM * COSZP3
      BZ3=-     BI2 *         EXPZM * SINZP3

      BX4=0.0d0
      BY4=-     BI2 *         EXPZM * COSZP4
      BZ4=-     BI2 *         EXPZM * SINZP4

      AZ=0.0D0

      AX1=
     &  -   BI2 *                  EXPZ * SINZP1/ZKELLANA


      AY1=0.0D0

      AX2=
     &    -      BI2 *                  EXPZ * SINZP2/ZKELLANA
      AY2=0.0D0

      AX3=
     &  -      BI2 *                  EXPZM * SINZP3/ZKELLANA
      AY3=0.0D0

      AY4=0.0D0
      AX4=
     &    -      BI2 *                  EXPZM * SINZP4/ZKELLANA

      DO ICOEF=2,IELLCOEF

        XKXI=(ICOEF-1)*XKELLANA

        XKXP=XKXI*(X+X0ELLANA)
        XKXM=XKXI*(X-X0ELLANA)

        YKI=DSQRT(XKXI**2+ZKELLANA**2)

        YKY=YKI*Y
        DEXPYGAP=DEXP(-YKI*YGAP)
        EXPY=DEXP(YKY)
        EXPYM=1.0D0/EXPY
        EXPY=EXPY*DEXPYGAP
        EXPYM=EXPYM*DEXPYGAP

        ZKYK=ZKELLANA/YKI
        XKYK=XKXI/YKI

        COSXP=DCOS(XKXP)
        COSXM=DCOS(XKXM)
        SINXP=DSIN(XKXP)
        SINXM=DSIN(XKXM)

        BI2=B0ELLANA/8.D0*ELLCOEF(ICOEF)

        BX1=BX1+XKYK*BI2 * SINXM * EXPY * COSZP1
        BY1=BY1-     BI2 * COSXM * EXPY * COSZP1
        BZ1=BZ1+ZKYK*BI2 * COSXM * EXPY * SINZP1

        BX2=BX2+XKYK*BI2 * SINXP * EXPY * COSZP2
        BY2=BY2-     BI2 * COSXP * EXPY * COSZP2
        BZ2=BZ2+ZKYK*BI2 * COSXP * EXPY * SINZP2

        BX3=BX3-XKYK*BI2 * SINXP * EXPYM * COSZP3
        BY3=BY3-     BI2 * COSXP * EXPYM * COSZP3
        BZ3=BZ3-ZKYK*BI2 * COSXP * EXPYM * SINZP3

        BX4=BX4-XKYK*BI2 * SINXM * EXPYM * COSZP4
        BY4=BY4-     BI2 * COSXM * EXPYM * COSZP4
        BZ4=BZ4-ZKYK*BI2 * COSXM * EXPYM * SINZP4

        AY1=AY1
     &    +XKYK*BI2 * SINXM * EXPY * (-SINZP1)/ZKELLANA
        AX1=AX1
     &    -   BI2 * COSXM * EXPY * SINZP1/ZKELLANA

        AY2=AY2
     &    +XKYK*BI2 * SINXP * EXPY * (-SINZP2)/ZKELLANA
        AX2=AX2
     &    -      BI2 * COSXP * EXPY * SINZP2/ZKELLANA

        AY3=AY3
     &    -XKYK*BI2 * SINXP * EXPYM * (-SINZP3)/ZKELLANA

        AX3=AX3
     &    -      BI2 * COSXP * EXPYM * SINZP3/ZKELLANA

        AY4=AY4
     &    -XKYK*BI2 * SINXM * EXPYM * (-SINZP4)/ZKELLANA
        AX4=AX4
     &    -      BI2 * COSXM * EXPYM * SINZP4/ZKELLANA

      ENDDO !IELLCOEF-1

      BX=BX1+BX2+BX3+BX4
      BY=BY1+BY2+BY3+BY4
      BZ=BZ1+BZ2+BZ3+BZ4

      AX=AX+AX1+AX2+AX3+AX4
      AY=AY+AY1+AY2+AY3+AY4

      BXOUT=BZ*BCONST
      BYOUT=BY*BCONST
      BZOUT=-BX*BCONST

C Noch berichtigen (Gode)
      AXOUT=AZ*BCONST
      AYOUT=AY*BCONST
      AZOUT=-AX*BCONST

C     AX=-INT(DF(V,Y),Z)=INT(BY,Z)
C     AY=+INT(DF(V,X),Z)=-INT(BX,Z)
        AXOUT=0.0D0
        AYOUT=0.0D0
        AZOUT=0.0D0

      RETURN
      END
+DECK,BELLCRS.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.20/09 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ : 00.01/07 24/02/95  09.42.55  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  14.47.19  by  Michael Scheer
*CMZ : 00.00/07 01/06/94  10.41.53  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BELLCRS(XIN,Y,Z,BX,BY,BZ,AX,AY,AZ)

+seq,gplhint.

C--- TWO TIMES ELLIPTICAL UNDULATOR WITH MODULATOR INBETWEEN

      DOUBLE PRECISION X,Y,Z,BX,BY,BZ,AX,AY,AZ
      DOUBLE PRECISION XIN,XLENEU,XLENHU,TOTLEN,XLENEU2,XLENHU2,TOTLEN2
      DOUBLE PRECISION B0H,B0V

      INTEGER ICAL

+SEQ,CONTRL.
+SEQ,ELLIP.
+SEQ,HALBASY.
+SEQ,USERVAR.

      DATA ICAL/0/

      IF (ICAL.EQ.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &'     SR BELLCRS: VARIABLES OF NAMELIST ELLIP AND HALBASY TAKEN FOR FIRST'
          WRITE(LUNGFO,*)
     &'                 UNDULATOR AND MODULATOR, NAMELIST USERN (USER(1:2) USED'
          WRITE(LUNGFO,*)
     &'                 TO SCALE SECOND UNDULATOR'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)

          B0H=B0ELLIPH
          B0V=B0ELLIPV
          ICAL=1
      ENDIF !ICAL

      XLENEU=DABS((PERELLIP+2.5+ELLSHFT)*XLELLIP)
      IF (FASYM.NE.2.D0) THEN
              XLENHU=ZLHALBASY*(AHWPOL+FASYM)/2.D0
      ELSE
              XLENHU=ZLHALBASY*((AHWPOL-1.D0)/2.+1.D0)
      ENDIF
      TOTLEN=2.D0*XLENEU+XLENHU
      TOTLEN2=TOTLEN/2.D0
      XLENEU2=XLENEU/2.D0
      XLENHU2=XLENHU/2.D0

      IF (XIN.LT.-TOTLEN2) THEN
          BX=0.0
          BY=0.0
          BZ=0.0
          AX=0.0
          AY=0.0
          AZ=0.0
      ELSEIF(XIN.LT.-XLENHU2) THEN  !FIRST ELLIPTICAL UNDULATOR
          X=XIN+XLENHU2+XLENEU2
            B0ELLIPH=B0H
            B0ELLIPV=B0V
          CALL BELLIP(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
      ELSEIF(XIN.LT.XLENHU2) THEN   !MODULATOR
          CALL BHALBASY(XIN,Y,Z,BX,BY,BZ,AX,AY,AZ)
      ELSEIF(XIN.LT.TOTLEN2) THEN   !SECOND ELLIPTICAL UNDULATOR
          X=XIN-XLENHU2-XLENEU2
            B0ELLIPH=B0H*USER(1)
            B0ELLIPV=B0V*USER(2)
          CALL BELLIP(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
      ELSEIF(XIN.GT.TOTLEN2) THEN
          BX=0.0
          BY=0.0
          BZ=0.0
          AX=0.0
          AY=0.0
          AZ=0.0
      ENDIF


      RETURN
      END
+DECK,BELLIP.
*CMZ :  4.01/04 06/12/2023  10.37.05  by  Michael Scheer
*CMZ :  4.01/02 26/04/2023  07.35.28  by  Michael Scheer
*CMZ :  4.00/15 28/04/2022  09.27.00  by  Michael Scheer
*CMZ :  4.00/07 09/07/2020  12.37.21  by  Michael Scheer
*CMZ :  3.06/00 26/02/2019  14.12.24  by  Michael Scheer
*CMZ :  3.05/06 17/07/2018  11.15.16  by  Michael Scheer
*CMZ :  3.03/04 03/08/2017  15.33.14  by  Michael Scheer
*CMZ :  3.03/02 31/08/2016  15.06.48  by  Michael Scheer
*CMZ :  3.01/02 02/09/2013  15.00.48  by  Michael Scheer
*CMZ :  3.01/01 19/07/2013  16.20.01  by  Michael Scheer
*CMZ :  3.00/02 10/04/2013  09.27.41  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.67/04 11/05/2012  11.18.26  by  Michael Scheer
*CMZ :  2.67/02 18/04/2012  14.13.08  by  Michael Scheer
*CMZ :  2.66/09 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.66/07 02/03/2010  09.40.31  by  Michael Scheer
*CMZ :  2.62/02 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  2.16/08 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  16.58.05  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  14.44.33  by  Michael Scheer
*CMZ : 00.01/07 28/02/95  14.22.48  by  Michael Scheer
*CMZ : 00.01/06 17/02/95  12.25.05  by  Michael Scheer
*CMZ : 00.01/04 19/01/95  09.36.21  by  Michael Scheer
*CMZ : 00.01/02 24/11/94  15.45.15  by  Michael Scheer
*CMZ : 00.01/01 21/09/94  17.30.43  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.46.58  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.41  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BELLIP(X,Y,Z,BX,BY,BZ,AX,AY,AZ)

      use f1k

+seq,gplhint.

      IMPLICIT NONE

      DOUBLE PRECISION BX,BY,BZ,AX,AY,AZ,X,Y,Z
      DOUBLE PRECISION WLEN1,PARK,B0EFF,EHARM1,parkv,parkh
      DOUBLE PRECISION RHV,pbue(13),f1

      INTEGER,save :: ICAL=0
      INTEGER i

+seq,cmpara.
+SEQ,CONTRL.
+SEQ,PHYCON.
+SEQ,ELLIP.
+seq,mgsqc.
+SEQ,freqs.


      IF (ICAL.EQ.0) THEN

        park=parkell

        if (nharmell.ne.0.and.harmell.ne.0.0d0) then
          if (harmell.eq.-9999.0d0) then
c            if (ifreq2p.eq.1) then
c              harmell=freqlow
c            else
              harmell=(freqlow+freqhig)/2.0d0
c            endif
          endif
          if (harmell.lt.0.0d0) then
            harmell=-wtoe1/harmell
          endif
          WLEN1=wtoe1/abs(harmell/nharmell)
          park=2.0d0*(wlen1/(xlellip*1.0D9/2.0d0/DMYGAMMA**2)-1.0d0)
          if (park.lt.0.0d0) then
            write(6,*)
     &        '*** Error in BELLIP:'
            write(6,*)
     &        'Inconsistent values of NHARMELL, HARMELL, and XLELLIP'
            write(6,*)' '
            write(lungfo,*)
     &        '*** Error in BELLIP:'
            write(lungfo,*)
     &        'Inconsistent values of NHARMELL, HARMELL, and XELLIP'
            write(lungfo,*)' '
            stop
          endif
          park=sqrt(park)
          parkell=park
        endif

        IF (parkell.NE.0.0) THEN

          B0EFF=parkell/(echarge1*XLELLIP/(2.*PI1*EMASSKG1*CLIGHT1))

          if (b0elliph.eq.0.0d0.and.b0ellipv.ne.0d0) then
            b0ellipv=b0ellipv/abs(b0ellipv)*b0eff
          else if (b0ellipv.eq.0.0d0.and.b0elliph.ne.0d0) then
            b0elliph=b0elliph/abs(b0elliph)*b0eff
          else

            rhv=b0elliph/b0ellipv

            b0elliph=b0eff/sqrt(1.0d0+1.0d0/rhv**2)*b0elliph/abs(b0elliph)
            b0ellipv=b0elliph/rhv

          endif

        ENDIF

        IF (B0ELLIPV.NE.0.0) THEN
          RHV=B0ELLIPH/B0ELLIPV
        ELSE
          RHV=0.0D0
        ENDIF

        XLENELL=DABS((PERELLIP+ELLSHFT)*XLELLIP)
        IF (XLELLIP.NE.0.0) then
          XKELLIP=2.D0*PI1/XLELLIP
          zampell=b0ellipv*clight1/emom/xkellip**2
          yampell=b0elliph*clight1/emom/xkellip**2
        endif

        B0EFF=DSQRT(B0ELLIPH**2+B0ELLIPV**2)
        PARKv=ECHARGE1*DABS(B0elliph)*XLELLIP/(2.*PI1*EMASSKG1*CLIGHT1)
        PARKh=ECHARGE1*DABS(B0ellipv)*XLELLIP/(2.*PI1*EMASSKG1*CLIGHT1)
        PARK=ECHARGE1*DABS(B0EFF)*XLELLIP/(2.*PI1*EMASSKG1*CLIGHT1)
        WLEN1=(1.0d0+PARK**2/2.0d0)/2.0d0/DMYGAMMA**2*XLELLIP*1.0D9
        IF (WLEN1.NE.0.0) EHARM1=WTOE1/WLEN1

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     SR BELLIP, Parameters of elliptical undulator:'
        WRITE(LUNGFO,*)
     &    '     horizontal and vertical peak field [T]:'
     &    ,SNGL(B0ELLIPH),SNGL(B0ELLIPV)
        WRITE(LUNGFO,*)
     &    '     number of periods, period and device length [m]:'
        WRITE(LUNGFO,*)
     &    '     ',SNGL(PERELLIP),SNGL(XLELLIP),SNGL(XLENELL)
        WRITE(LUNGFO,*)
     &    '     shift parameter [periods], B_h/B_v:    '
     &    ,SNGL(ELLSHFT),SNGL(RHV)
        WRITE(LUNGFO,*)
     &    '     B0_eff [T], deflection parameter K:'
     &    ,SNGL(B0EFF),SNGL(PARK)
        WRITE(LUNGFO,*)
     &    '     Approximated path hori. and. vert. amplitudes [m]:',
     &    SNGL(zampell),sngl(yampell)
        WRITE(LUNGFO,*)
     &    '     Hori. and. vert. deflection angle [rad]:',
     &    SNGL(parkv/dmygamma),sngl(parkh/dmygamma)
        WRITE(LUNGFO,*)
     &    '     1. harmonical [nm] and [eV], omega [1/s]:',
     &    sngl(wlen1),SNGL(EHARM1),sngl(eharm1/hbarev1)
        WRITE(LUNGFO,*)
     &    '     critical energy [eV]:',SNGL(ecdipev1*DABS(B0EFF)*DMYENERGY**2)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     longitudinal position of device center [m]:',xcenell
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     taper factor to compensate energy-loss:',elltap
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     Estimate of 1. harm. on-axis flux-density in 10m / mm**2 / 0.1%BW'
        do i=1,1000
          if (park.ge.f1kk(i)) cycle
          f1=f1kf(i)
          exit
        enddo
        WRITE(LUNGFO,*)
     &    '     ',
     &    sngl(1.744e14*perellip**2*dmyenergy**2*dmycur*f1/100.0d0)
        WRITE(LUNGFO,*)

        ICAL=1

      ENDIF

      pbue=PMAG(1:13,NMGSQP)

      PMAG(1,NMGSQP)=park
      PMAG(2,NMGSQP)=b0ellipv
      PMAG(3,NMGSQP)=b0elliph
cerror 31.8.2016      PMAG(4,NMGSQP)=ellshft*xlellip
      PMAG(4,NMGSQP)=ellshft
      PMAG(5,NMGSQP)=xcenell
      PMAG(6,NMGSQP)=xlellip
      PMAG(7,NMGSQP)=perellip
      PMAG(8,NMGSQP)=0.0d0
      pmag(11,nmgsqp)=elltap

      call bue(x,y,z,bx,by,bz,ax,ay,az,nmgsqp)

      PMAG(1:13,NMGSQP)=pbue

      RETURN
      END
+DECK,BERROR.
*CMZ :  4.00/15 06/06/2022  08.45.26  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.63/02 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.15/00 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.03.48  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  14.45.16  by  Michael Scheer
*CMZ : 00.01/12 27/09/96  15.28.21  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.47.23  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.59  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BERROR(XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT)

+seq,gplhint.

C CALCULATES MAGNETIC FIELD ERRORS; FOR FORMULAS SEE BHALBASY

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,B0SCGLOB.
+SEQ,ELLANA.
+SEQ,BERROR.
+SEQ,halbasy.
+SEQ,halbach.
+SEQ,PHYCON.

      INTEGER ICAL,NPERMXP,IX,NTOTIN,NTOT2IN,kfibona,LFIBO,MODANA,ixz,lunerr
c      PARAMETER (NPERMXP=1024)

      DOUBLE PRECISION XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT,
     &  XKX,YKY,ZKZ,DSNXKX,DCSXKX,DSHYKY,DCHYKY,DSNZKZ,DCSZKZ
     &  ,BXH,BYH,BZH,AXH,AYH,AZH,X,TOTLEN,TOTLEN2,SUM,RMS,POLWID,
     &  xxran,xxranz,byellmx,bzellmx

      real rr(2)
      REAL, dimension (:), allocatable :: xran,yran,fibo

      DATA ICAL/0/

      save

      BxOUT=0.0d0
      ByOUT=0.0d0
      BzOUT=0.0d0
      axOUT=0.0d0
      ayOUT=0.0d0
      azOUT=0.0d0

      IF (ICAL.EQ.0) THEN

        IF (XLENERR.LT.0.0D0) THEN
          MODANA=1
          call bellana(0.0d0,0.0d0,0.0d0,bxh,byh,bzh,axh,ayh,azh)
          byellmx=abs(byh)
          call bellana(zlellana/4.0d0,0.0d0,0.0d0,bxh,byh,bzh,axh,ayh,azh)
          bzellmx=abs(bzh)
        ELSE
          MODANA=0
        ENDIF

        IF (XSTART.EQ.9999.0d0) RETURN
        IF (XSTOP.EQ.9999.0d0) RETURN

        if (nberror.eq.-1) then

          kfibona=1

          if (modana.eq.0) then
            NBERROR=(XSTOP-XSTART-ZLENERR)/(ZLENERR/2.0d0)
          else
            NBERROR=(NPERELLA-2)*2
          endif

          NBERROR=(NBERROR/2)*2-1

          allocate(XRAN(nberror),YRAN(nberror),FIBO(nberror))

c          IF (NBERROR.GT.NPERMXP) THEN
c            WRITE(6,*)'*** ERROR IN BERROR: DIMENSION NPERMXP EXCEEDED'
c            WRITE(6,*)
c     &        '*** USE FEWER PERIODS IN NAMELIST BERROR OR INCREASE PARAMETER'
c            STOP '*** PROGRAM WAVE ABORTED ***'
c          ENDIF

          call fibonacci(nberror,xran,etafibo,icutfibo)

          DO IX=1,NBERROR
            IF (XRAN(IX).GT.0.) THEN
              YRAN(IX)=1.
              FIBO(IX)=1.
            ELSE IF (XRAN(IX).LT.0.) THEN
              YRAN(IX)=-1.
              FIBO(IX)=-1.
            ELSE
              FIBO(IX)=0.
              YRAN(IX)=0.
            ENDIF
            IF (XRAN(IX).NE.0) LFIBO=IX
          ENDDO

          IF (NBERRMOD.EQ.1) THEN
            SUM=0.0D0
            DO IX=2,LFIBO
              FIBO(IX-1)=YRAN(IX-1)-YRAN(IX)
              XRAN(IX-1)=IX-1
              SUM=SUM+FIBO(IX-1)
            ENDDO
            SUM=SUM+FIBO(LFIBO)
            FIBO(1)=FIBO(1)-SUM
          ELSE IF (NBERRMOD.NE.2) THEN
            if (lfibo.ge.nberror) then
              lfibo=nberror-1
              XRAN(nberror)=0.
              YRAN(nberror)=0.
              fibo(nberror)=0.
            endif
            SUM=0.0D0
            DO IX=2,LFIBO-1
              FIBO(IX)=YRAN(IX)-YRAN(IX-1)/2.-YRAN(IX+1)/2.
              XRAN(IX-1)=IX-1
              XRAN(IX+1)=IX+1
              SUM=SUM+FIBO(IX)
            ENDDO
            FIBO(1)=-YRAN(2)/2.
            FIBO(NBERROR)=-SUM
          ENDIF   !NBERRMOD

        else

          kfibona=0

        endif

        IF (NBERROR.EQ.-9999) THEN
c          if (khalbasy.ne.0) then
c            nberror=int(ahwpol-2)
c          else if (khalba.ne.0) then
c            nberror=int(perhal*2.0d0)-2
c          else
            NBERROR=(XSTOP-XSTART-ZLENERR)/(ZLENERR/2.0d0)-2
c          endif
c          if (nberrmod.ne.0) then
c            NBERROR=(NBERROR/2)*2-1
c          endif
        ENDIF

        if (kfibona.eq.0) allocate(XRAN(nberror),YRAN(nberror))

c        IF (NBERROR.GT.NPERMXP) THEN
c          WRITE(6,*)'*** ERROR IN BERROR: DIMENSION NPERMXP EXCEEDED'
c          WRITE(6,*)
c     &      '*** USE FEWER PERIODS IN NAMELIST BERROR OR INCREASE PARAMETER'
c          STOP '*** PROGRAM WAVE ABORTED ***'
c        ENDIF

c        IF (NBERROR.LT.4) THEN
c          WRITE(LUNGFO,*)
c     &      '*** WARNING IN BERROR: LESS THAN THREE POLES FOR FIELDERRORS SPECIFIED'
c          WRITE(LUNGFO,*)
c     &      '*** NBERROR SET TO THREE'
c          WRITE(LUNGFO,*)
c          WRITE(6,*)
c     &      '*** WARNING IN BERROR: LESS THAN THREE POLES FOR FIELDERRORS SPECIFIED'
c          WRITE(6,*)
c     &      '*** NBERROR SET TO THREE'
c          WRITE(6,*)
c          NBERROR=3
c        ENDIF

        POLWID=ZLENERR/2.0D0
        TOTLEN=NBERROR*POLWID
        TOTLEN2=TOTLEN/2.0d0

C--- K-VALUES

        XKERROR=0.0d0
        YKERROR=0.0d0
        ZKERROR=0.0d0

        IF (ZLENERR.NE.0.0d0) ZKERROR=2.0d0*PI1/ZLENERR
        IF (YLENERR.NE.0.0d0) YKERROR=2.0d0*PI1/YLENERR
        IF (XLENERR.NE.0.0d0) XKERROR=2.0d0*PI1/XLENERR

C--- ADJUST K-VALUES

        YKERROR=DSQRT(ZKERROR**2+XKERROR**2)
        YLENERR=2.0d0*PI1/YKERROR

        IF (KFIBONA.EQ.0) THEN

          if (nberrmod.lt.10) then
            IF (IBERRSEED.NE.0) THEN
              CALL RMARIN(IBERRSEED,NTOTIN,NTOT2IN) !CERN V113
            ENDIF
            CALL RNORML(XRAN,NBERROR,rr)
          else
            nberrmod=nberrmod-1
            open(newunit=lunerr,file='wave_berror.dat')
            close(lunerr)
          endif

          YRAN(1:nberror)=XRAN(1:nberror)

          iF (NBERRMOD.eq.0) THEN
c            nberrmod=nberrmod/3*3
            nberror=nberror/3*3
            DO IX=2,NBERROR-1,3
              XRAN(IX-1)=yRAN(IX)/2.
              XRAN(IX+1)=YRAN(IX)/2.
            ENDDO
          else if (NBERRMOD.eq.3) THEN
c            nberrmod=nberrmod/3*3
            nberror=nberror/4*4
            DO IX=2,NBERROR-2,4
              XRAN(IX-1)=yRAN(IX)
              XRAN(IX+1)=yRAN(IX)
              XRAN(IX+2)=-yRAN(IX)
            ENDDO
          else IF (NBERRMOD.EQ.1) THEN
            YRAN(NBERROR)=0.
            DO IX=2,NBERROR,2
              XRAN(IX-1)=YRAN(IX)
            ENDDO
          else IF (NBERRMOD.ne.2) THEN
            stop "*** Error in BERROR: Bad NBERRMOD ***"

+self,if=-20220323,if=20220602.
          IF (NBERRMOD.EQ.1) THEN
            YRAN(NBERROR)=0.
            DO IX=2,NBERROR
              XRAN(IX)=YRAN(IX)+YRAN(IX-1)
            ENDDO
            XRAN(1)=YRAN(2)/2.
            XRAN(NBERROR)=YRAN(NBERROR-1)/2.
          ELSE IF (NBERRMOD.NE.2) THEN
            nberrmod=nberrmod/3*3
            DO IX=2,NBERROR-1,3
              XRAN(IX-1)=YRAN(IX)/2.
              XRAN(IX+1)=YRAN(IX)/2.
            ENDDO
+self,if=20220323,if=20220602.
          IF (NBERRMOD.EQ.1) THEN
            YRAN(NBERROR)=0.
            DO IX=2,NBERROR
              XRAN(IX)=YRAN(IX)-YRAN(IX-1)
            ENDDO
          ELSE IF (NBERRMOD.NE.2) THEN
            YRAN(1)=0.
            YRAN(NBERROR)=0.
            DO IX=2,NBERROR-1
              XRAN(IX)=YRAN(IX)-YRAN(IX-1)/2.-YRAN(IX+1)/2.
            ENDDO
            XRAN(1)=-YRAN(2)/2.
            XRAN(NBERROR)=-YRAN(NBERROR-1)/2.
+self.
          ENDIF   !NBERRMOD

          SUM=0.0d0
          DO IX=1,NBERROR-1,2
            SUM=SUM+XRAN(IX)
          ENDDO
          DO IX=2,NBERROR,2
            SUM=SUM+XRAN(IX)
          ENDDO
          RMS=0.0d0
          SUM=SUM/NBERROR
          DO IX=1,NBERROR
            RMS=RMS+(SUM-XRAN(IX))**2
          ENDDO
          RMS=SQRT(RMS/NBERROR)*B0ERROR

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'      SUBROUTINE BERROR:'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'      NBERROR, IBERRSEED,NBERRMOD:'
     &      ,NBERROR, IBERRSEED,NBERRMOD
          WRITE(LUNGFO,*)'      B0ERROR,RMS:',SNGL(B0ERROR),SNGL(RMS)
          WRITE(LUNGFO,*)'      ZLENERR,XLENERR,XCENERR:'
     &      ,SNGL(ZLENERR),SNGL(XLENERR),SNGL(XCENERR)
          WRITE(LUNGFO,*)'      MODANA:',MODANA
          WRITE(LUNGFO,*)

        ELSE !KFIBONA

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'      SUBROUTINE BERROR:'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'      Fibonacci-Sequence applied'
          WRITE(LUNGFO,*)'      ETAFIBO,ICUTFIBO:',ETAFIBO,ICUTFIBO
          WRITE(LUNGFO,*)'      see fibonacci.dat for sequence'
          WRITE(LUNGFO,*)'      NBERROR, NBERRMOD:',NBERROR, NBERRMOD
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'      B0ERROR:',SNGL(B0ERROR)
          WRITE(LUNGFO,*)'      ZLENERR,XLENERR,XCENERR:'
          WRITE(LUNGFO,*)'      ',ZLENERR,XLENERR,XCENERR
          WRITE(LUNGFO,*)'      MODANA:',MODANA
          WRITE(LUNGFO,*)

        ENDIF !KFIBONA

        ICAL=1

      ENDIF

      X=XIN-XCENERR+totlen2
      IX=X/POLWID+1

      IF (IX.LT.1.OR.IX.GT.NBERROR) THEN
        return
      else
        XXRAN=XRAN(IX)
      endif

      IF (KFIBONA.EQ.0) THEN

        IF (IX.LT.1.OR.IX.GT.NBERROR) THEN
          return
        else
          XXRAN=XRAN(IX)
        endif

      ELSE !KFIBONA

        IF (IX.LT.1.OR.IX.GT.NBERROR) THEN
          xxran=0.0d0
        else
          IF (FIBO(IX).NE.0) THEN
            IX=ABS(XRAN(IX))
            XXRAN=FIBO(IX)
          ELSE
            XXRAN=0.0
          ENDIF
        ENDIF

        IXz=(X-zlellana/4.0d0)/POLWID+1

        IF (IXz.LT.1.OR.IXz.GT.NBERROR) THEN
          xxranz=.0d0
        else
          IF (FIBO(IXz).NE.0) THEN
            IXz=ABS(XRAN(IXz))
            XXRANz=FIBO(IXz)
          ELSE
            XXRANz=0.0
          ENDIF
        ENDIF

      ENDIF !KFIBONA

      IF (MODANA.EQ.0) THEN

        XKX=XKERROR*(-ZIN)
        YKY=YKERROR*YIN
        ZKZ=ZKERROR*(XIN-XCENERR)

        DSNXKX=DSIN(XKX)
        DCSXKX=DCOS(XKX)
        DSHYKY=DSINH(YKY)
        DCHYKY=DSQRT(1.0d0+DSHYKY*DSHYKY)
        DSNZKZ=DSIN(ZKZ)
        DCSZKZ=DCOS(ZKZ)

        BXH=-XKERROR/YKERROR*B0ERROR*xxran*DSNXKX*DSHYKY*DCSZKZ
        BYH=                 B0ERROR*xxran*DCSXKX*DCHYKY*DCSZKZ
        BZH=-ZKERROR/YKERROR*B0ERROR*xxran*DCSXKX*DSHYKY*DSNZKZ

        AXH=B0ERROR*xxran/ZKERROR*                DCSXKX*DCHYKY*DSNZKZ
        AYH=B0ERROR*xxran/ZKERROR*XKERROR/YKERROR*DSNXKX*DSHYKY*DSNZKZ
        AZH=0.0d0

        BZOUT=-BXH
        BYOUT=BYH
        BXOUT=BZH

        AZOUT=-AXH
        AYOUT=AYH
        AXOUT=AZH

      ELSE !MODANA

        if (xxran.ne.0.0d0) then

          XKX=XKERROR*(-ZIN)
          YKY=YKERROR*YIN
          ZKZ=ZKERROR*X

          DSNXKX=DSIN(XKX)
          DCSXKX=DCOS(XKX)
          DSHYKY=DSINH(YKY)
          DCHYKY=DSQRT(1.0d0+DSHYKY*DSHYKY)
          DSNZKZ=DSIN(ZKZ)
          DCSZKZ=DCOS(ZKZ)

          BXH=-XKERROR/YKERROR*B0ERROR*xxran*DSNXKX*DSHYKY*DCSZKZ
          BYH=                 B0ERROR*xxran*DCSXKX*DCHYKY*DCSZKZ
          BZH=-ZKERROR/YKERROR*B0ERROR*xxran*DCSXKX*DSHYKY*DSNZKZ

          AXH=B0ERROR*xxran/ZKERROR*                DCSXKX*DCHYKY*DSNZKZ
          AYH=B0ERROR*xxran/ZKERROR*XKERROR/YKERROR*DSNXKX*DSHYKY*DSNZKZ
          AZH=0.0d0

          BZOUT=-BXH
          BYOUT=BYH
          BXOUT=BZH

          AZOUT=-AXH
          AYOUT=AYH
          AXOUT=AZH

          BxOUT=bxout*byellmx
          ByOUT=byout*byellmx
          BzOUT=bzout*byellmx

          axOUT=axout*byellmx
          ayOUT=ayout*byellmx
          azOUT=azout*byellmx

        endif

        if (xxranz.ne.0.0d0) then

          X=XIN-XCENERR+TOTLEN2
          X=X-(IXz+0.5)*POLWID

          XKX=XKERROR*(-ZIN)
          YKY=YKERROR*YIN
c          ZKZ=ZKERROR*X
          ZKZ=ZKERROR*(X+polwid/2.0d0)

          DSNXKX=DSIN(XKX)
          DCSXKX=DCOS(XKX)
          DSHYKY=DSINH(YKY)
          DCHYKY=DSQRT(1.0d0+DSHYKY*DSHYKY)
          DSNZKZ=DSIN(ZKZ)
          DCSZKZ=DCOS(ZKZ)

          BXH=-XKERROR/YKERROR*B0ERROR*xxranz*DSNXKX*DSHYKY*DCSZKZ
          BYH=                 B0ERROR*xxranz*DCSXKX*DCHYKY*DCSZKZ
          BZH=-ZKERROR/YKERROR*B0ERROR*xxranz*DCSXKX*DSHYKY*DSNZKZ

          AXH=B0ERROR*xxranz/ZKERROR*                DCSXKX*DCHYKY*DSNZKZ
          AYH=B0ERROR*xxranz/ZKERROR*XKERROR/YKERROR*DSNXKX*DSHYKY*DSNZKZ
          AZH=0.0d0

          BxOUT=bxout+bzh*bzellmx
          ByOUT=byout-bxh*bzellmx
          BzOUT=bzout-byh*bzellmx

          AxOUT=axout+azh*bzellmx
          AyOUT=ayout-axh*bzellmx
          AzOUT=azout-ayh*bzellmx

        endif !xxranz

      ENDIF !MODANA

9999  continue

      RETURN
      END
+DECK,BETATRAN.
*CMZ :  3.05/23 26/11/2018  21.53.32  by  Michael Scheer
*CMZ :  3.05/11 15/08/2018  15.13.49  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.15/00 12/05/2010  13.34.28  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  14.23.35  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.47.02  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.35  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BETATRAN

+seq,gplhint.

C--- SUBROUTINE CALCULATES HORIZONTAL LINEAR TRANSFER-MATRIX FROM BETA-FUNCTION
C--- CALCULATION IS PERFORMED ONLY FOR POSITIVE X-VALUES, I.E. ONE HALF OF THE
C--- WLS
      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,MYFILES.
+SEQ,CONTRL.
+SEQ,BETAWLS.
+SEQ,DEPOLA.
+SEQ,PHYCON.

      INTEGER I
      DOUBLE PRECISION DELPHI,ALPHA,BETA,ALPHA0,T11,T12,T22,T21,COSPHI,SINPHI,B0,DX

C--- SUM UP

      DELPHI=0.
      DO I=INULLP,MBETA
        IF(I.EQ.1) THEN
          DX=XBETA(2)-XBETA(1)
        ELSE IF(I.EQ.MBETA) THEN
          DX=XBETA(MBETA)-XBETA(MBETA-1)
        ELSE
          DX=0.5*(XBETA(I+1)-XBETA(I-1))
        ENDIF
        DELPHI=DELPHI+1/YBETA(I)*DX
      ENDDO

      COSPHI=DCOS(DELPHI)
      SINPHI=DSIN(DELPHI)
      B0=YBETA(INULLP)
      BETA=YBETA(MBETA)
      ALPHA0=-0.5*YBETAP(INULLP)
      ALPHA=-0.5*YBETAP(MBETA)

      T11=DSQRT(BETA/B0)*(COSPHI+ALPHA0*SINPHI)
      T12=DSQRT(BETA*B0)*SINPHI
      T21=-1.0d0/DSQRT(BETA*B0)*((ALPHA-ALPHA0)*COSPHI+
     &  (1.0d0+ALPHA*ALPHA0)*SINPHI)
      T22=DSQRT(B0/BETA)*(COSPHI-ALPHA*SINPHI)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*) '*** SR BETATRAN ***'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'HORIZONTALE LINEARE TRANSFER-MATRIX OF SECOND HALF OF THE WLS:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)SNGL(T11),SNGL(T12)
      WRITE(LUNGFO,*)SNGL(T21),SNGL(T22)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'DETERMINANTE:',SNGL(T11*T22-T12*T21)

      RETURN
      END
+DECK,bextern.
*CMZ :  4.01/00 12/03/2023  14.27.05  by  Michael Scheer
*CMZ :  4.00/11 06/07/2021  11.35.01  by  Michael Scheer
*CMZ :  3.03/02 15/12/2015  15.57.23  by  Michael Scheer
*CMZ :  3.01/02 24/01/2014  17.44.47  by  Michael Scheer
*CMZ :  3.01/00 04/07/2013  08.33.03  by  Michael Scheer
*CMZ :  3.00/01 02/04/2013  13.47.23  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.63/05 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.61/06 12/04/2007  09.47.01  by  Michael Scheer
*CMZ :  2.58/01 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.57/05 24/08/2006  16.44.25  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.35.17  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  14.47.19  by  Michael Scheer
*CMZ : 00.00/07 01/06/94  10.41.53  by  Michael Scheer
*-- Author : Michael Scheer
C-----------------------------------------------------------
      subroutine bextern(xin,yin,zin,bxout,byout,bzout,axout,ayout,azout)
C-----------------------------------------------------------

      implicit none

+seq,uservar.

C--- USER ROUTINE TO CALCULATE MAGNETIC FIELD

C     INPUT: X, Y, Z
C     OUTPUT: MAGNETIC FIELD BXOUT,BYOUT,BZOUT
C             VECTOR POTENTIAL AXOUT,AYOUT,AZOUT

      double precision xtab(1000),bytab(1000),bztab(1000)
      integer ntab,luno

      double precision xin,yin,zin,bxout,byout,bzout,axout,ayout,azout

+self,if=bbend.
      double precision :: b(3)=[0.,1.,0.], center(3)=[0.,0.,-1.],
     &  fint=0.5,gap=0.05,pin(3)=[-0.1,0.,0.],pout(3)=[0.1,0.0,0.0],
     &  vnin(3)=[1.,0.,0.],vnout(3)=[1.,0.,0.]

      integer :: istatus,modus=0,inowarn=0

      vnin=user(1:3)
      vnout=user(4:6)
      fint=user(7)
      gap=user(8)
      b(2)=user(9)
      pin(1)=user(10)
      pout(1)=-user(10)
      modus=int(user(11))

      call bbend(xin,yin,zin,bxout,byout,bzout,axout,ayout,azout,
     &  fint,gap,center,b,pin,vnin,pout,vnout,
     &  modus,istatus,inowarn)

+self.

+self,if=bexintbybz.

      double precision :: zz,pi=3.141592653589793d0

      !Note:
      !  Mode = 2:
      !    The data are splined such, that the number of points
      !    for the FFT are a power of 2, with
      !    ipow=nint(dlog(user(4))/dlog(2.0d0))
      !    npow2=max(4,2**ipow)
      !
      !    The period-length is calculated as
      !    dz=(z(npoi)-z(1))/(npow2-1)
      !    perlen=z(npoi)-z(1)+dz
      !  else:
      !    Fields from divB=0

      double precision, dimension (:), allocatable ::
     &  by,bz,z,bypp,aa,bb,cc,c,bzpp,ffty,zfft,fftz,cosy,siny,cosz,sinz,
     &  xkfour,ykfour,zkfour

      real, dimension (:), allocatable :: rffty,rfftz

      complex, dimension (:), allocatable :: cffty,cfftz

      double precision dum,xlen,dbydz,dbzdz,bysp,bzsp,xmin,xmax,dz,perlen,
     &  axf,ayf,azf

      double precision bxh,byh,bzh,axh,ayh,azh,perhal,
     &  bxfy,byfy,bzfy,bxfz,byfz,bzfz

      integer lun,ifail,i,ieof,modus,ipow,npow2,k
      integer :: ical=0,npoi=0,ini,modecs=1

      save

      if (ical.eq.0) then

        xmin=user(1)
        xmax=user(2)
        modus=nint(user(3))

        xlen=xmax-xmin

        if (xlen.le.0.0d0) then
          print*,"*** Error in bextern: Zero or negative length of device, i.e. "//
     &      "user(1) = user(2) ***"
          stop "*** Program WAVE aborted ***"
        endif

        open(newunit=lun,file=trim(userchar(1)),status='old',err=88)

        do while (.true.)
          call util_skip_comment_end(lun,ieof)
          if (ieof.ne.0) exit
          read(lun,*,err=88,end=9) dum
          npoi=npoi+1
        enddo
9       continue

        rewind(lun)

        allocate(z(npoi),by(npoi),bz(npoi),
     &    bypp(npoi),bzpp(npoi),
     &    aa(npoi),bb(npoi),cc(npoi),c(npoi))

        do i=1,npoi
          call util_skip_comment_end(lun,ieof)
          read(lun,*) z(i),by(i),bz(i)
        enddo

        close(lun)

        by=by/xlen
        bz=bz/xlen

        call util_spline_coef(z,by,npoi,0.0d0,0.0d0,bypp,aa,bb,cc,c)
        call util_spline_coef(z,bz,npoi,0.0d0,0.0d0,bzpp,aa,bb,cc,c)

        if (modus.eq.2) then

          if (user(4).gt.0.0d0) then
            ipow=nint(dlog(user(4))/dlog(2.0d0))
          else
            ipow=4
          endif

          npow2=max(4,2**ipow)

        endif !modus

        ical=1

      endif !ical

      axout=0.0d0
      ayout=0.0d0
      azout=0.0d0

      if (xin.lt.xmin.or.xin.gt.xmax) then
        bxout=0.0d0
        byout=0.0d0
        bzout=0.0d0
        return
      endif

      bxout=0.0d0
      ini=1

      if (modus.ne.2) then

        call util_spline_inter_deriv(z,by,bypp,npoi,zin,bysp,dbydz,-1)
        call util_spline_inter_deriv(z,bz,bzpp,npoi,zin,bzsp,dbzdz,-1)

        byout=bysp-dbzdz*yin
        bzout=bzsp+dbydz*yin

      else
        stop "Siehe neue Fassung von bfourtabzy"
        ini=1
        do k=1,npoi
          call bfourtabzy(z(k),yin,0.0d0,
     &      bxout,byout,bzout,axf,ayf,azf,npoi,z,by,npoi,z,bz,
     &      npow2,0,ini)
          ini=0
          write(99,*)"1 ",z(k),byout,bzout
        enddo

        ini=1
        do k=1,npoi
          call bfourtabzy(z(k),yin,0.0d0,
     &      bxout,byout,bzout,axf,ayf,azf,npoi,z,by,npoi,z,bz,
     &      npow2,1,ini)
          ini=0
          write(99,*)"2 ",z(k),byout,bzout
        enddo

        stop "Ende"

      endif !modus

      return

88    print*,"*** Error in bextern: File " // trim(userchar(1)) // " not found or not correct ***"
      stop "*** Program WAVE aborted ***"
+self.

      return
      end
+DECK,BFELD.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.54/01 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.52/11 29/11/2004  16.35.20  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  1.03/06 06/08/98  18.01.07  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  14.48.44  by  Michael Scheer
*CMZ : 00.00/07 10/05/94  15.54.47  by  Michael Scheer
*CMZ : 00.00/05 29/04/94  19.47.02  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.47.07  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.02  by  Michael Scheer
*-- Author : Michael Scheer
C*****************************************************************
      SUBROUTINE BFELD( BX, BY, BZ,XX,Y,Z)
C*****************************************************************
+seq,gplhint.

C INPUT ORT X,Y,Z
C OUT B(X,Y,Z)

      IMPLICIT NONE

+SELF,IF=LINUX.
      EXTERNAL DCOSD,DSIND
      DOUBLE PRECISION DCOSD,DSIND
+SELF.

+SEQ,CONTRL.
+SEQ,CMPARA.
+SEQ,BFELD.

+SEQ,PHYCON.

      DOUBLE PRECISION BX,BY,BZ,XX,X,Y,Z,PELEV
      DOUBLE PRECISION XLBBY1,XLBBY2,XLBBY3,XLBBY4,XLBBY5,XLBBY6,XLBBY7
      DOUBLE PRECISION PHIBBY1,PHIBBY2,PHIBBY3,PHIBBY4,PHIBBY5,PHIBBY6,
     &  PHIBBY7
      DOUBLE PRECISION DUM

      INTEGER I

C     DATA CLIGHT/2.99792458D8/
C     DATA EMASSGEV/511003.3732832001D-9/

C     DIMENSION XLIM(12)

      Y=Y
      Z=Z

      X=XX
CERR18.3.93 IF (IBSYM.NE.0) X=DABS(XX)

      IF (IBFELD.NE.1) THEN   !FIRST CALL

       IF(IKBFORM.NE.0) THEN
          CALL BFORM
       ENDIF

       XLIM(1) =XM1-YSOFT1(1)
       XLIM(2) =XP1+YSOFT1(2)
       XLIM(3) =XM2-YSOFT2(1)
       XLIM(4) =XP2+YSOFT2(2)
       XLIM(5) =XM3-YSOFT3(1)
       XLIM(6) =XP3+YSOFT3(2)
       XLIM(7) =XM4-YSOFT4(1)
       XLIM(8) =XP4+YSOFT4(2)
       XLIM(9) =XM5-YSOFT5(1)
       XLIM(10)=XP5+YSOFT5(2)
       XLIM(11)=XM6-YSOFT6(1)
       XLIM(12)=XP6+YSOFT6(2)
       XLIM(13)=XM7-YSOFT7(1)
       XLIM(14)=XP7+YSOFT7(2)

       DO I=1,6
         IF(XLIM(I).GT.XLIM(I+1)) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)' *** ERROR IN BFELD ***'
            WRITE(LUNGFO,*)'MAGNETS COLLIDE, CHECK INPUT'
            WRITE(LUNGFO,*)'(NAMELIST BBFELD)'
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN BFELD ***'
            WRITE(6,*)'MAGNETS COLLIDE, CHECK INPUT'
            WRITE(6,*)'(NAMELIST BBFELD)'
            WRITE(6,*)
            STOP
         ENDIF
       ENDDO
          IF (IBGAUSS.EQ.0) THEN

       XLBBY1=XP1-XM1
       XLBBY2=XP2-XM2
       XLBBY3=XP3-XM3
       XLBBY4=XP4-XM4
       XLBBY5=XP5-XM5
       XLBBY6=XP6-XM6
       XLBBY7=XP7-XM7

       PELEV=DSQRT(  (DMYENERGY-EMASSG1)*(DMYENERGY+EMASSG1)  )*1.D9

       IF (BBY1.NE.0.0) R0BBY1=PELEV/(CLIGHT1*BBY1)
       IF (BBY2.NE.0.0) R0BBY2=PELEV/(CLIGHT1*BBY2)
       IF (BBY3.NE.0.0) R0BBY3=PELEV/(CLIGHT1*BBY3)
       IF (BBY4.NE.0.0) R0BBY4=PELEV/(CLIGHT1*BBY4)
       IF (BBY5.NE.0.0) R0BBY5=PELEV/(CLIGHT1*BBY5)
       IF (BBY6.NE.0.0) R0BBY6=PELEV/(CLIGHT1*BBY6)
       IF (BBY7.NE.0.0) R0BBY7=PELEV/(CLIGHT1*BBY7)

       IF (R0BBY1.NE.0) THEN
          DUM=XLBBY1/R0BBY1
          IF (DABS(DUM).LE.1.D0) THEN
         PHIBBY1=DASIN(DUM)
          ELSE
         PHIBBY1=-9999.D0
          ENDIF
       ENDIF
       IF (R0BBY2.NE.0) THEN
          DUM=XLBBY2/R0BBY2
          IF (DABS(DUM).LE.1.D0) THEN
         PHIBBY2=DASIN(DUM)
          ELSE
         PHIBBY2=-9999.D0
          ENDIF
       ENDIF
       IF (R0BBY3.NE.0) THEN
          DUM=XLBBY3/R0BBY3
          IF (DABS(DUM).LE.1.D0) THEN
         PHIBBY3=DASIN(DUM)
          ELSE
         PHIBBY3=-9999.D0
          ENDIF
       ENDIF
       IF (R0BBY4.NE.0) THEN
          DUM=XLBBY4/R0BBY4
          IF (DABS(DUM).LE.1.D0) THEN
         PHIBBY4=DASIN(DUM)
          ELSE
         PHIBBY4=-9999.D0
          ENDIF
       ENDIF
       IF (R0BBY5.NE.0) THEN
          DUM=XLBBY5/R0BBY5
          IF (DABS(DUM).LE.1.D0) THEN
         PHIBBY5=DASIN(DUM)
          ELSE
         PHIBBY5=-9999.D0
          ENDIF
       ENDIF
       IF (R0BBY6.NE.0) THEN
          DUM=XLBBY6/R0BBY6
          IF (DABS(DUM).LE.1.D0) THEN
         PHIBBY6=DASIN(DUM)
          ELSE
         PHIBBY6=-9999.D0
          ENDIF
       ENDIF
       IF (R0BBY7.NE.0) THEN
         DUM=XLBBY7/R0BBY7
         IF (DABS(DUM).LE.1.D0) THEN
           PHIBBY7=DASIN(DUM)
         ELSE
           PHIBBY7=-9999.D0
         ENDIF
       ENDIF

       WRITE(LUNGFO,*)
       WRITE(LUNGFO,*)'      SR BFELD:'
       IF(IKBFORM.NE.0) THEN
          CALL BFORM
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'B0FORM,B0LP:      ',SNGL(B0FORM),SNGL(B0LP)
          WRITE(LUNGFO,*)'FB0N,FB0M  :      ',SNGL(FB0N),SNGL(FB0M)
          WRITE(LUNGFO,*)
       ENDIF
       WRITE(LUNGFO,*)
       WRITE(LUNGFO,*)'      Input parameters of XMi, XPi, YSOFTi, length XPi-XMi, magnetic field, bending radius, bending angle'
       WRITE(LUNGFO,*)'      (fringe fields not taken into account):'
       WRITE(LUNGFO,*)
       WRITE(LUNGFO,*)'      XM1,XP1,YSOFT1(1:2):',
     &                         SNGL(XM1),SNGL(XP1)
     &                        ,SNGL(YSOFT1(1)),SNGL(YSOFT1(2))
       WRITE(LUNGFO,*)'      XLBBY1,BBY1,R0BBY1,PHIBBY1:',
     &                   SNGL(XLBBY1),SNGL(BBY1),SNGL(R0BBY1),SNGL(PHIBBY1)
       WRITE(LUNGFO,*)'      XM2,XP2,YSOFT2(1:2):',
     &                         SNGL(XM2),SNGL(XP2)
     &                        ,SNGL(YSOFT1(1)),SNGL(YSOFT2(2))
       WRITE(LUNGFO,*)'      XLBBY2,BBY2,R0BBY2,PHIBBY2:',
     &                   SNGL(XLBBY2),SNGL(BBY2),SNGL(R0BBY2),SNGL(PHIBBY2)
       WRITE(LUNGFO,*)'      XM3,XP3,YSOFT3(1:2):',
     &                         SNGL(XM3),SNGL(XP3)
     &                        ,SNGL(YSOFT3(1)),SNGL(YSOFT3(2))
       WRITE(LUNGFO,*)'      XLBBY3,BBY3,R0BBY3,PHIBBY3:',
     &                   SNGL(XLBBY3),SNGL(BBY3),SNGL(R0BBY3),SNGL(PHIBBY3)
       WRITE(LUNGFO,*)'      XM4,XP4,YSOFT4(1:2):',
     &                         SNGL(XM4),SNGL(XP4)
     &                        ,SNGL(YSOFT4(1)),SNGL(YSOFT4(2))
       WRITE(LUNGFO,*)'      XLBBY4,BBY4,R0BBY4,PHIBBY4:',
     &                   SNGL(XLBBY4),SNGL(BBY4),SNGL(R0BBY4),SNGL(PHIBBY4)
       WRITE(LUNGFO,*)'      XM5,XP5,YSOFT5(1:2):',
     &                         SNGL(XM5),SNGL(XP5)
     &                        ,SNGL(YSOFT5(1)),SNGL(YSOFT5(2))
       WRITE(LUNGFO,*)'      XLBBY5,BBY5,R0BBY5,PHIBBY5:',
     &                   SNGL(XLBBY5),SNGL(BBY5),SNGL(R0BBY5),SNGL(PHIBBY5)
       WRITE(LUNGFO,*)'      XM6,XP6,YSOFT6(1:2):',
     &                         SNGL(XM6),SNGL(XP6)
     &                        ,SNGL(YSOFT6(1)),SNGL(YSOFT6(2))
       WRITE(LUNGFO,*)'      XLBBY6,BBY6,R0BBY6,PHIBBY6:',
     &                   SNGL(XLBBY6),SNGL(BBY6),SNGL(R0BBY6),SNGL(PHIBBY6)
       WRITE(LUNGFO,*)'      XM7,XP7,YSOFT7(1:2):',
     &   SNGL(XM7),SNGL(XP7)
     &   ,SNGL(YSOFT7(1)),SNGL(YSOFT7(2))
       WRITE(LUNGFO,*)'      XLBBY7,BBY7,R0BBY7,PHIBBY7:',
     &   SNGL(XLBBY7),SNGL(BBY7),SNGL(R0BBY7),SNGL(PHIBBY7)
      ENDIF

          IBFELD=1

      ENDIF

      BX=0.D0
      BY=0.D0
      BZ=0.D0

C=================================================== 17.10.90
      IF(IBGAUSS.NE.0) GOTO 1000
C=================================================== 17.10.90
CC    slam=(XP3-XM3)/(3.141592654D0*2.d0)
CC    BY=BBY3*DCOS((X-0.5D0*(XM3+XP3))/slam)*dcosh(y/slam)
CC    bx=-bby3*dsinh(y/slam)*dsin((x-0.5d0*(xm3+xp3))/slam)
CC    goto 999
C------------------------------
      IF (
     &  X.LT.(XM1-YSOFT1(1))
     &  .OR.
     &  (X.GT.(XP1+YSOFT1(2)) .AND. X.LT.(XM2-YSOFT2(1)))
     &  .OR.
     &  (X.GT.(XP2+YSOFT2(2)) .AND. X.LT.(XM3-YSOFT3(1)))
     &  .OR.
     &  (X.GT.(XP3+YSOFT3(2)) .AND. X.LT.(XM4-YSOFT4(1)))
     &  .OR.
     &  (X.GT.(XP4+YSOFT4(2)) .AND. X.LT.(XM5-YSOFT5(1)))
     &  .OR.
     &  (X.GT.(XP5+YSOFT5(2)) .AND. X.LT.(XM6-YSOFT6(1)))
     &  .OR.
     &  (X.GT.(XP6+YSOFT6(2)) .AND. X.LT.(XM7-YSOFT7(1)))
     &  .OR.
     &  (X.GT.(XP7+YSOFT7(2)))) goto 999

C--- 1. MAGNET

      IF (X.LE.XM1) THEN
       IF (YSOFT1(1).LT.1.D-31) goto 999
       BY=BBY1*0.5D0*(1.D0+DCOSD((X-XM1)/YSOFT1(1)*180.D0))
       goto 999
      ENDIF

      IF (X.LE.XP1) THEN
       BY=BBY1
       goto 999
      ENDIF

      IF (X.LE.(XP1+YSOFT1(2))) THEN
       IF (YSOFT1(2).LT.1.D-31) goto 999
       BY=BBY1*0.5D0*(1.D0+DCOSD((X-XP1)/YSOFT1(2)*180.D0))
       goto 999
      ENDIF

C--- 2. MAGNET

      IF (X.LE.XM2) THEN
       IF (YSOFT2(1).LT.1.D-31) goto 999
       BY=BBY2*0.5D0*(1.D0+DCOSD((X-XM2)/YSOFT2(1)*180.D0))
       goto 999
      ENDIF

      IF (X.LE.XP2) THEN
       BY=BBY2
       goto 999
      ENDIF

      IF (X.LE.(XP2+YSOFT2(2))) THEN
       IF (YSOFT2(2).LT.1.D-31) goto 999
       BY=BBY2*0.5D0*(1.D0+DCOSD((X-XP2)/YSOFT2(2)*180.D0))
       goto 999
      ENDIF

C--- 3. MAGNET

      IF (X.LE.XM3) THEN
       IF (YSOFT3(1).LT.1.D-31) goto 999
       BY=BBY3*0.5D0*(1.D0+DCOSD((X-XM3)/YSOFT3(1)*180.D0))
       goto 999
      ENDIF

      IF (X.LE.XP3) THEN
       BY=BBY3
       goto 999
      ENDIF

      IF (X.LE.(XP3+YSOFT3(2))) THEN
       IF (YSOFT3(2).LT.1.D-31) goto 999
       BY=BBY3*0.5D0*(1.D0+DCOSD((X-XP3)/YSOFT3(2)*180.D0))
       goto 999
      ENDIF

C--- 4. MAGNET

      IF (X.LE.XM4) THEN
       IF (YSOFT4(1).LT.1.D-31) goto 999
       BY=BBY4*0.5D0*(1.D0+DCOSD((X-XM4)/YSOFT4(1)*180.D0))
       goto 999
      ENDIF

      IF (X.LE.XP4) THEN
       BY=BBY4
       goto 999
      ENDIF

      IF (X.LE.(XP4+YSOFT4(2))) THEN
       IF (YSOFT4(2).LT.1.D-31) goto 999
       BY=BBY4*0.5D0*(1.D0+DCOSD((X-XP4)/YSOFT4(2)*180.D0))
       goto 999
      ENDIF

C--- 5. MAGNET

      IF (X.LE.XM5) THEN
       IF (YSOFT5(1).LT.1.D-31) goto 999
       BY=BBY5*0.5D0*(1.D0+DCOSD((X-XM5)/YSOFT5(1)*180.D0))
       goto 999
      ENDIF

      IF (X.LE.XP5) THEN
       BY=BBY5
       goto 999
      ENDIF

      IF (X.LE.(XP5+YSOFT5(2))) THEN
       IF (YSOFT5(2).LT.1.D-31) goto 999
       BY=BBY5*0.5D0*(1.D0+DCOSD((X-XP5)/YSOFT5(2)*180.D0))
       goto 999
      ENDIF

C--- 6. MAGNET

      IF (X.LE.XM6) THEN
        IF (YSOFT6(1).LT.1.D-31) goto 999
        BY=BBY6*0.5D0*(1.D0+DCOSD((X-XM6)/YSOFT6(1)*180.D0))
       goto 999
      ENDIF

      IF (X.LE.XP6) THEN
        BY=BBY6
       goto 999
      ENDIF

      IF (X.LE.(XP6+YSOFT6(2))) THEN
        IF (YSOFT6(2).LT.1.D-31) goto 999
        BY=BBY6*0.5D0*(1.D0+DCOSD((X-XP6)/YSOFT6(2)*180.D0))
       goto 999
      ENDIF

C--- 7. MAGNET

      IF (X.LE.XM7) THEN
        IF (YSOFT7(1).LT.1.D-31) goto 999
        BY=BBY7*0.5D0*(1.D0+DCOSD((X-XM7)/YSOFT7(1)*180.D0))
       goto 999
      ENDIF

      IF (X.LE.XP7) THEN
        BY=BBY7
       goto 999
      ENDIF

      IF (X.LE.(XP7+YSOFT7(2))) THEN
        IF (YSOFT7(2).LT.1.D-31) goto 999
        BY=BBY7*0.5D0*(1.D0+DCOSD((X-XP7)/YSOFT7(2)*180.D0))
       goto 999
      ENDIF


      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'*** ERROR IN BFELD ***'
      WRITE(LUNGFO,*)'SOMETHING IS WRONG, CHECK INPUT'
      WRITE(LUNGFO,*)
      WRITE(6,*)
      WRITE(6,*)'*** ERROR IN BFELD ***'
      WRITE(6,*)'SOMETHINGS WRONG, CHECK INPUT'
      WRITE(6,*)
         STOP
C=================================================== 17.10.90
C     !BERECHNE MAGNETFELD ALS UEBERLAGERUNG VON 3 GAUSSIANS
C     ! HSR-88-2, SEP.14, 1988, ODER TSKUBA KONF 1988 S.1851
1000    CONTINUE
      BY=0
      DO I=1,7
      BY=BY+
     &  B0GAUSS(I)*DEXP (
     &  -0.5D0*( (X-X0GAUSS(I)) / BSGGAUS(I) )**2)

C151091     &  -2.77259D0*( (X-X0GAUSS(I)) / BSGGAUS(I) )**2)
CERROR 18.10.90 SIEH LOGBUCH "PROBLEME"   BY=BY+
CERROR     &  B0GAUSS(I)*DEXP (
CERROR     &  -2.77259D2* (X-X0GAUSS(I))**2 / BSGGAUS(I) )
      ENDDO

C=================================================== 17.10.90

CERR18.3.93 999   IF (IBSYM.NE.0.AND.XX.LT.0.0) BX=-BX   !12.6.92
999   CONTINUE    ! BX=-BX IN MYBFELD
      RETURN


      END
+DECK,BFORCE.
*CMZ :  3.02/04 25/11/2014  10.04.56  by  Michael Scheer
*CMZ :  3.02/00 10/10/2014  11.20.47  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.61/02 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.52/05 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  1.01/00 04/12/97  14.32.11  by  Michael Scheer
*-- Author :    Michael Scheer   26/11/97

      SUBROUTINE BFORCE

+seq,gplhint.

        implicit none

+SEQ,CONTRL.
+SEQ,PHYCON.
+SEQ,BFORCE.

      INTEGER ICAL
      DATA ICAL/0/

      INTEGER NPOIX,NPOIY,NPOIZ,IY,IZ,IX,I,NBFDIMP

      DOUBLE PRECISION RMU0,BFINT(3),XX,YY,ZZ,XBASE,YBASE,ZBASE
     &  ,DX,DY,DZ,BX,BY,BZ,AX,AY,AZ,BNX,BNY,BNZ
     &  ,F(3),R(3),T(3),RESULT,
     &  RX,RY,RZ,TORQTOTX,TORQTOTY,TORQTOTZ,TORQROTX,TORQROTY,TORQROTZ

      DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE ::
     &  XB,YB,WS1,WS2,WS3,WS4,COEF,ZB

      DOUBLE PRECISION, DIMENSION(:,:),ALLOCATABLE :: BB,BBI,BT,BTI

      NBFDIMP=MAX(NBFORCX,NBFORCY,NBFORCZ)+1

      ALLOCATE(XB(NBFDIMP))
      ALLOCATE(YB(NBFDIMP))
      ALLOCATE(ZB(NBFDIMP))
      ALLOCATE(WS1(NBFDIMP))
      ALLOCATE(WS2(NBFDIMP))
      ALLOCATE(WS3(NBFDIMP))
      ALLOCATE(WS4(NBFDIMP))
      ALLOCATE(COEF(NBFDIMP))

      ALLOCATE(BB(NBFDIMP,3))
      ALLOCATE(BBI(NBFDIMP,3))
      ALLOCATE(BT(NBFDIMP,3))
      ALLOCATE(BTI(NBFDIMP,3))

      IF (ICAL.EQ.0) THEN

        RMU0=4.D0*PI1/1.D7

        NPOIX=NBFORCX+1
        NPOIY=NBFORCY+1
        NPOIZ=NBFORCZ+1

        IF (
     &      NPOIX.GT.NBFDIMP
     &      .OR.
     &      NPOIY.GT.NBFDIMP
     &      .OR.
     &      NPOIZ.GT.NBFDIMP
     &      ) THEN

          WRITE(LUNGFO,*)'*** ERROR IN BFORCE:'
          WRITE(LUNGFO,*)
     &      'DIMENSION NBFDIMP IN BFORCE.CMN EXCEEDED'
          WRITE(LUNGFO,*)
     &      'CURRENT VALUE IS:',NBFDIMP
          WRITE(LUNGFO,*)
     &      '(NUMBER OF POINTS IS NUMBER OF MASHES+1 IN EACH DIMENSION)'
          WRITE(6,*)'*** ERROR IN BFORCE:'
          WRITE(6,*)
     &      'DIMENSION NBFDIMP IN BFORCE.CMN EXCEEDED'
          WRITE(6,*)
     &      'CURRENT VALUE IS:',NBFDIMP
          WRITE(6,*)
     &      '(NUMBER OF POINTS IS NUMBER OF MASHES+1 IN EACH DIMENSION)'
          STOP

        ENDIF   !NBFDIMP

        IF (NBFORCX.NE.0) THEN
          DX=BFLENX/NBFORCX
        ELSE
          DX=0.0
        ENDIF

        IF (NBFORCY.NE.0) THEN
          DY=BFLENY/NBFORCY
        ELSE
          DY=0.0
        ENDIF

        IF (NBFORCZ.NE.0) THEN
          DZ=BFLENZ/NBFORCZ
        ELSE
          DZ=0.0
        ENDIF

        XBASE=BFCENX-BFLENX/2.D0
        YBASE=BFCENY-BFLENY/2.D0
        ZBASE=BFCENZ-BFLENZ/2.D0

        ICAL=1

      ENDIF !ICAL

C FIRST YZ-PLANE, NORMAL VECTOR IS (-1,0,0){

      BNX=-1.D0
      BNY=0.D0
      BNZ=0.D0

      XX=XBASE
      YY=YBASE-DY

      DO IY=1,NPOIY

        YY=YY+DY
        YB(IY)=YY
        ZZ=ZBASE-DZ

        DO IZ=1,NPOIZ

          ZZ=ZZ+DZ
          CALL MYBFELD(XX,YY,ZZ,BX,BY,BZ,AX,AY,AZ)

          ZB(IZ)=ZZ
          BB(IZ,1)=BX*(BX*BNX+BY*BNY+BZ*BNZ)
     &      -0.5D0*((BX*BX+BY*BY+BZ*BZ)*BNX)
          BB(IZ,2)=BY*(BX*BNX+BY*BNY+BZ*BNZ)
     &      -0.5D0*((BX*BX+BY*BY+BZ*BZ)*BNY)
          BB(IZ,3)=BZ*(BX*BNX+BY*BNY+BZ*BNZ)
     &      -0.5D0*((BX*BX+BY*BY+BZ*BZ)*BNZ)

          F(1)=BB(IZ,1)
          F(2)=BB(IZ,2)
          F(3)=BB(IZ,3)

          R(1)=XX-BFCENX
          R(2)=YY-BFCENY
          R(3)=ZZ-BFCENZ

          CALL UTIL_VCROSS(R,F,T)

          BT(IZ,1)=T(1)
          BT(IZ,2)=T(2)
          BT(IZ,3)=T(3)

        ENDDO  !IZ

        CALL WAVE_SPLINE_INTEGRAL(ZB,BB(1,1),NPOIZ,RESULT
     &    ,COEF,WS1,WS2,WS3,WS4)
        BBI(IY,1)=RESULT
        CALL WAVE_SPLINE_INTEGRAL(ZB,BB(1,2),NPOIZ,RESULT
     &    ,COEF,WS1,WS2,WS3,WS4)
        BBI(IY,2)=RESULT
        CALL WAVE_SPLINE_INTEGRAL(ZB,BB(1,3),NPOIZ,RESULT
     &    ,COEF,WS1,WS2,WS3,WS4)
        BBI(IY,3)=RESULT

        CALL WAVE_SPLINE_INTEGRAL(ZB,BT(1,1),NPOIZ,RESULT
     &    ,COEF,WS1,WS2,WS3,WS4)
        BTI(IY,1)=RESULT
        CALL WAVE_SPLINE_INTEGRAL(ZB,BT(1,2),NPOIZ,RESULT
     &    ,COEF,WS1,WS2,WS3,WS4)
        BTI(IY,2)=RESULT
        CALL WAVE_SPLINE_INTEGRAL(ZB,BT(1,3),NPOIZ,RESULT
     &    ,COEF,WS1,WS2,WS3,WS4)
        BTI(IY,3)=RESULT

      ENDDO !IY

      CALL WAVE_SPLINE_INTEGRAL(YB,BBI(1,1),NPOIY,RESULT
     &  ,COEF,WS1,WS2,WS3,WS4)
      BFINT(1)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(YB,BBI(1,2),NPOIY,RESULT
     &  ,COEF,WS1,WS2,WS3,WS4)
      BFINT(2)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(YB,BBI(1,3),NPOIY,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(3)=RESULT

      BFORCX(1)=BFINT(1)/RMU0
      BFORCY(1)=BFINT(2)/RMU0
      BFORCZ(1)=BFINT(3)/RMU0

      CALL WAVE_SPLINE_INTEGRAL(YB,BTI(1,1),NPOIY,RESULT
     &  ,COEF,WS1,WS2,WS3,WS4)
      BFINT(1)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(YB,BTI(1,2),NPOIY,RESULT
     &  ,COEF,WS1,WS2,WS3,WS4)
      BFINT(2)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(YB,BTI(1,3),NPOIY,RESULT
     &  ,COEF,WS1,WS2,WS3,WS4)
      BFINT(3)=RESULT

      TORQX(1)=BFINT(1)/RMU0
      TORQY(1)=BFINT(2)/RMU0
      TORQZ(1)=BFINT(3)/RMU0

C }FIRST YZ-PLANE, NORMAL VECTOR IS (-1,0,0)

C SECOND YZ-PLANE, NORMAL VECTOR IS (1,0,0){

      BNX=1.D0
      BNY=0.D0
      BNZ=0.D0

      XX=XBASE+BFLENX
      YY=YBASE-DY

      DO IY=1,NPOIY

        YY=YY+DY
        YB(IY)=YY
        ZZ=ZBASE-DZ

        DO IZ=1,NPOIZ

          ZZ=ZZ+DZ
          CALL MYBFELD(XX,YY,ZZ,BX,BY,BZ,AX,AY,AZ)

          ZB(IZ)=ZZ
          BB(IZ,1)=BX*(BX*BNX+BY*BNY+BZ*BNZ)
     &              -0.5D0*((BX*BX+BY*BY+BZ*BZ)*BNX)
          BB(IZ,2)=BY*(BX*BNX+BY*BNY+BZ*BNZ)
     &              -0.5D0*((BX*BX+BY*BY+BZ*BZ)*BNY)
          BB(IZ,3)=BZ*(BX*BNX+BY*BNY+BZ*BNZ)
     &              -0.5D0*((BX*BX+BY*BY+BZ*BZ)*BNZ)

          F(1)=BB(IZ,1)
          F(2)=BB(IZ,2)
          F(3)=BB(IZ,3)

          R(1)=XX-BFCENX
          R(2)=YY-BFCENY
          R(3)=ZZ-BFCENZ

          CALL UTIL_VCROSS(R,F,T)

          BT(IZ,1)=T(1)
          BT(IZ,2)=T(2)
          BT(IZ,3)=T(3)

        ENDDO  !IZ

      CALL WAVE_SPLINE_INTEGRAL(ZB,BB(1,1),NPOIZ,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BBI(IY,1)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(ZB,BB(1,2),NPOIZ,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BBI(IY,2)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(ZB,BB(1,3),NPOIZ,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BBI(IY,3)=RESULT

      CALL WAVE_SPLINE_INTEGRAL(ZB,BT(1,1),NPOIZ,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BTI(IY,1)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(ZB,BT(1,2),NPOIZ,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BTI(IY,2)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(ZB,BT(1,3),NPOIZ,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BTI(IY,3)=RESULT

      ENDDO !IY

      CALL WAVE_SPLINE_INTEGRAL(YB,BBI(1,1),NPOIY,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(1)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(YB,BBI(1,2),NPOIY,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(2)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(YB,BBI(1,3),NPOIY,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(3)=RESULT

      BFORCX(3)=BFINT(1)/RMU0
      BFORCY(3)=BFINT(2)/RMU0
      BFORCZ(3)=BFINT(3)/RMU0

      CALL WAVE_SPLINE_INTEGRAL(YB,BTI(1,1),NPOIY,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(1)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(YB,BTI(1,2),NPOIY,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(2)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(YB,BTI(1,3),NPOIY,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(3)=RESULT

      TORQX(3)=BFINT(1)/RMU0
      TORQY(3)=BFINT(2)/RMU0
      TORQZ(3)=BFINT(3)/RMU0

C } SECOND YZ-PLANE, NORMAL VECTOR IS (1,0,0)

C FIRST XZ-PLANE, NORMAL VECTOR IS (0,-1,0){

      BNX=0.D0
      BNY=-1.D0
      BNZ=0.D0

      XX=XBASE-DX
      YY=YBASE

      DO IX=1,NPOIX

        XX=XX+DX
        XB(IX)=XX
        ZZ=ZBASE-DZ

        DO IZ=1,NPOIZ

          ZZ=ZZ+DZ
          CALL MYBFELD(XX,YY,ZZ,BX,BY,BZ,AX,AY,AZ)

          ZB(IZ)=ZZ
          BB(IZ,1)=BX*(BX*BNX+BY*BNY+BZ*BNZ)
     &              -0.5D0*((BX*BX+BY*BY+BZ*BZ)*BNX)
          BB(IZ,2)=BY*(BX*BNX+BY*BNY+BZ*BNZ)
     &              -0.5D0*((BX*BX+BY*BY+BZ*BZ)*BNY)
          BB(IZ,3)=BZ*(BX*BNX+BY*BNY+BZ*BNZ)
     &              -0.5D0*((BX*BX+BY*BY+BZ*BZ)*BNZ)

          F(1)=BB(IZ,1)
          F(2)=BB(IZ,2)
          F(3)=BB(IZ,3)

          R(1)=XX-BFCENX
          R(2)=YY-BFCENY
          R(3)=ZZ-BFCENZ

          CALL UTIL_VCROSS(R,F,T)

          BT(IZ,1)=T(1)
          BT(IZ,2)=T(2)
          BT(IZ,3)=T(3)

        ENDDO  !IZ

      CALL WAVE_SPLINE_INTEGRAL(ZB,BB(1,1),NPOIZ,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BBI(IX,1)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(ZB,BB(1,2),NPOIZ,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BBI(IX,2)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(ZB,BB(1,3),NPOIZ,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BBI(IX,3)=RESULT

      CALL WAVE_SPLINE_INTEGRAL(ZB,BT(1,1),NPOIZ,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BTI(IX,1)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(ZB,BT(1,2),NPOIZ,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BTI(IX,2)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(ZB,BT(1,3),NPOIZ,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BTI(IX,3)=RESULT

      ENDDO !IX

      CALL WAVE_SPLINE_INTEGRAL(XB,BBI(1,1),NPOIX,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(1)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(XB,BBI(1,2),NPOIX,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(2)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(XB,BBI(1,3),NPOIX,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(3)=RESULT

      BFORCX(2)=BFINT(1)/RMU0
      BFORCY(2)=BFINT(2)/RMU0
      BFORCZ(2)=BFINT(3)/RMU0

      CALL WAVE_SPLINE_INTEGRAL(XB,BTI(1,1),NPOIX,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(1)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(XB,BTI(1,2),NPOIX,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(2)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(XB,BTI(1,3),NPOIX,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(3)=RESULT

      TORQX(2)=BFINT(1)/RMU0
      TORQY(2)=BFINT(2)/RMU0
      TORQZ(2)=BFINT(3)/RMU0

C }FIRST XZ-PLANE, NORMAL VECTOR IS (0,-1,0)

C SECOND XZ-PLANE, NORMAL VECTOR IS (0,+1,0){

      BNX=0.D0
      BNY=1.D0
      BNZ=0.D0

      XX=XBASE-DX
      YY=YBASE+BFLENY

      DO IX=1,NPOIX

        XX=XX+DX
        XB(IX)=XX
        ZZ=ZBASE-DZ

        DO IZ=1,NPOIZ

          ZZ=ZZ+DZ
          CALL MYBFELD(XX,YY,ZZ,BX,BY,BZ,AX,AY,AZ)

          ZB(IZ)=ZZ
          BB(IZ,1)=BX*(BX*BNX+BY*BNY+BZ*BNZ)
     &              -0.5D0*((BX*BX+BY*BY+BZ*BZ)*BNX)
          BB(IZ,2)=BY*(BX*BNX+BY*BNY+BZ*BNZ)
     &              -0.5D0*((BX*BX+BY*BY+BZ*BZ)*BNY)
          BB(IZ,3)=BZ*(BX*BNX+BY*BNY+BZ*BNZ)
     &              -0.5D0*((BX*BX+BY*BY+BZ*BZ)*BNZ)

          F(1)=BB(IZ,1)
          F(2)=BB(IZ,2)
          F(3)=BB(IZ,3)

          R(1)=XX-BFCENX
          R(2)=YY-BFCENY
          R(3)=ZZ-BFCENZ

          CALL UTIL_VCROSS(R,F,T)

          BT(IZ,1)=T(1)
          BT(IZ,2)=T(2)
          BT(IZ,3)=T(3)

        ENDDO  !IZ

      CALL WAVE_SPLINE_INTEGRAL(ZB,BB(1,1),NPOIZ,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BBI(IX,1)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(ZB,BB(1,2),NPOIZ,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BBI(IX,2)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(ZB,BB(1,3),NPOIZ,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BBI(IX,3)=RESULT

      CALL WAVE_SPLINE_INTEGRAL(ZB,BT(1,1),NPOIZ,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BTI(IX,1)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(ZB,BT(1,2),NPOIZ,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BTI(IX,2)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(ZB,BT(1,3),NPOIZ,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BTI(IX,3)=RESULT

      ENDDO !IX

      CALL WAVE_SPLINE_INTEGRAL(XB,BBI(1,1),NPOIX,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(1)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(XB,BBI(1,2),NPOIX,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(2)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(XB,BBI(1,3),NPOIX,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(3)=RESULT

      BFORCX(4)=BFINT(1)/RMU0
      BFORCY(4)=BFINT(2)/RMU0
      BFORCZ(4)=BFINT(3)/RMU0

      CALL WAVE_SPLINE_INTEGRAL(XB,BTI(1,1),NPOIX,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(1)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(XB,BTI(1,2),NPOIX,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(2)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(XB,BTI(1,3),NPOIX,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(3)=RESULT

      TORQX(4)=BFINT(1)/RMU0
      TORQY(4)=BFINT(2)/RMU0
      TORQZ(4)=BFINT(3)/RMU0

C }SECOND XZ-PLANE, NORMAL VECTOR IS (0,+1,0)

C FIRST XY-PLANE, NORMAL VECTOR IS (0,0,-1){

      BNX=0.D0
      BNY=0.D0
      BNZ=-1.D0

      XX=XBASE-DX
      ZZ=ZBASE

      DO IX=1,NPOIX

        XX=XX+DX
        XB(IX)=XX
        YY=YBASE-DY

        DO IY=1,NPOIY

          YY=YY+DY
          CALL MYBFELD(XX,YY,ZZ,BX,BY,BZ,AX,AY,AZ)

          YB(IY)=YY
          BB(IY,1)=BX*(BX*BNX+BY*BNY+BZ*BNZ)
     &              -0.5D0*((BX*BX+BY*BY+BZ*BZ)*BNX)
          BB(IY,2)=BY*(BX*BNX+BY*BNY+BZ*BNZ)
     &              -0.5D0*((BX*BX+BY*BY+BZ*BZ)*BNY)
          BB(IY,3)=BZ*(BX*BNX+BY*BNY+BZ*BNZ)
     &              -0.5D0*((BX*BX+BY*BY+BZ*BZ)*BNZ)

          F(1)=BB(IY,1)
          F(2)=BB(IY,2)
          F(3)=BB(IY,3)

          R(1)=XX-BFCENX
          R(2)=YY-BFCENY
          R(3)=ZZ-BFCENZ

          CALL UTIL_VCROSS(R,F,T)

          BT(IY,1)=T(1)
          BT(IY,2)=T(2)
          BT(IY,3)=T(3)

        ENDDO  !IY

      CALL WAVE_SPLINE_INTEGRAL(YB,BB(1,1),NPOIY,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BBI(IX,1)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(YB,BB(1,2),NPOIY,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BBI(IX,2)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(YB,BB(1,3),NPOIY,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BBI(IX,3)=RESULT

      CALL WAVE_SPLINE_INTEGRAL(YB,BT(1,1),NPOIY,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BTI(IX,1)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(YB,BT(1,2),NPOIY,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BTI(IX,2)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(YB,BT(1,3),NPOIY,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BTI(IX,3)=RESULT

      ENDDO !IX

      CALL WAVE_SPLINE_INTEGRAL(XB,BBI(1,1),NPOIX,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(1)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(XB,BBI(1,2),NPOIX,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(2)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(XB,BBI(1,3),NPOIX,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(3)=RESULT

      BFORCX(5)=BFINT(1)/RMU0
      BFORCY(5)=BFINT(2)/RMU0
      BFORCZ(5)=BFINT(3)/RMU0

      CALL WAVE_SPLINE_INTEGRAL(XB,BTI(1,1),NPOIX,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(1)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(XB,BTI(1,2),NPOIX,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(2)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(XB,BTI(1,3),NPOIX,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(3)=RESULT

      TORQX(5)=BFINT(1)/RMU0
      TORQY(5)=BFINT(2)/RMU0
      TORQZ(5)=BFINT(3)/RMU0

C }FIRST XY-PLANE, NORMAL VECTOR IS (0,0,-1)

C SECOND XY-PLANE, NORMAL VECTOR IS (0,0,+1){

      BNX=0.D0
      BNY=0.D0
      BNZ=1.D0

      XX=XBASE-DX
      ZZ=ZBASE+BFLENZ

      DO IX=1,NPOIX

        XX=XX+DX
        XB(IX)=XX
        YY=YBASE-DY

        DO IY=1,NPOIY

          YY=YY+DY
          CALL MYBFELD(XX,YY,ZZ,BX,BY,BZ,AX,AY,AZ)

          YB(IY)=YY
          BB(IY,1)=BX*(BX*BNX+BY*BNY+BZ*BNZ)
     &              -0.5D0*((BX*BX+BY*BY+BZ*BZ)*BNX)
          BB(IY,2)=BY*(BX*BNX+BY*BNY+BZ*BNZ)
     &              -0.5D0*((BX*BX+BY*BY+BZ*BZ)*BNY)
          BB(IY,3)=BZ*(BX*BNX+BY*BNY+BZ*BNZ)
     &              -0.5D0*((BX*BX+BY*BY+BZ*BZ)*BNZ)

          F(1)=BB(IY,1)
          F(2)=BB(IY,2)
          F(3)=BB(IY,3)

          R(1)=XX-BFCENX
          R(2)=YY-BFCENY
          R(3)=ZZ-BFCENZ

          CALL UTIL_VCROSS(R,F,T)

          BT(IY,1)=T(1)
          BT(IY,2)=T(2)
          BT(IY,3)=T(3)

        ENDDO  !IY

      CALL WAVE_SPLINE_INTEGRAL(YB,BB(1,1),NPOIY,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BBI(IX,1)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(YB,BB(1,2),NPOIY,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BBI(IX,2)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(YB,BB(1,3),NPOIY,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BBI(IX,3)=RESULT

      CALL WAVE_SPLINE_INTEGRAL(YB,BT(1,1),NPOIY,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BTI(IX,1)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(YB,BT(1,2),NPOIY,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BTI(IX,2)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(YB,BT(1,3),NPOIY,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BTI(IX,3)=RESULT

      ENDDO !IX

      CALL WAVE_SPLINE_INTEGRAL(XB,BBI(1,1),NPOIX,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(1)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(XB,BBI(1,2),NPOIX,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(2)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(XB,BBI(1,3),NPOIX,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(3)=RESULT

      BFORCX(6)=BFINT(1)/RMU0
      BFORCY(6)=BFINT(2)/RMU0
      BFORCZ(6)=BFINT(3)/RMU0

      CALL WAVE_SPLINE_INTEGRAL(XB,BTI(1,1),NPOIX,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(1)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(XB,BTI(1,2),NPOIX,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(2)=RESULT
      CALL WAVE_SPLINE_INTEGRAL(XB,BTI(1,3),NPOIX,RESULT
     & ,COEF,WS1,WS2,WS3,WS4)
      BFINT(3)=RESULT

      TORQX(6)=BFINT(1)/RMU0
      TORQY(6)=BFINT(2)/RMU0
      TORQZ(6)=BFINT(3)/RMU0

C }SECOND XY-PLANE, NORMAL VECTOR IS (0,0,+1)


      BFORCX(7)=0.D0
      BFORCY(7)=0.D0
      BFORCZ(7)=0.D0
      TORQX(7)=0.D0
      TORQY(7)=0.D0
      TORQZ(7)=0.D0
      DO I=1,6
          BFORCX(7)=BFORCX(7)+BFORCX(I)
          BFORCY(7)=BFORCY(7)+BFORCY(I)
          BFORCZ(7)=BFORCZ(7)+BFORCZ(I)
          TORQX(7)=TORQX(7)+TORQX(I)
          TORQY(7)=TORQY(7)+TORQY(I)
          TORQZ(7)=TORQZ(7)+TORQZ(I)
      ENDDO

        RX=BFCENX-TORQCENX
        RY=BFCENY-TORQCENY
        RZ=BFCENZ-TORQCENZ

        TORQROTX=RY*BFORCZ(7)-RZ*BFORCY(7)
        TORQROTY=RZ*BFORCX(7)-RX*BFORCZ(7)
        TORQROTZ=RX*BFORCY(7)-RY*BFORCX(7)

        TORQTOTX=TORQROTX+TORQX(7)
        TORQTOTY=TORQROTY+TORQY(7)
        TORQTOTZ=TORQROTZ+TORQZ(7)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SR BFORCE:'
      WRITE(LUNGFO,*)

        IF (KBREC.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING:'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'IF CONSIDERED  VOLUME IS INSIDE OR PARTIALLY INSIDE'
          WRITE(LUNGFO,*)'MAGNET, RESULTS ARE WRONG!!'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN BFORCE:'
          WRITE(6,*)
          WRITE(6,*)'IF CONSIDERED  VOLUME IS INSIDE OR PARTIALLY INSIDE'
          WRITE(6,*)'MAGNET, RESULTS ARE WRONG!!'
          WRITE(6,*)
        ENDIF

      WRITE(LUNGFO,*)'     Box parameters:'
      WRITE(LUNGFO,*)'     BFCENX,BFCENY,BFCENZ:'
     &                      ,SNGL(BFCENX),SNGL(BFCENY),SNGL(BFCENZ)
      WRITE(LUNGFO,*)'     BFLENX,BFLENY,BFLENZ:'
     &                      ,SNGL(BFLENX),SNGL(BFLENY),SNGL(BFLENZ)
      WRITE(LUNGFO,*)'     Reference point for total torque:'
      WRITE(LUNGFO,*)'     '
     &                      ,SNGL(TORQCENX),SNGL(TORQCENY),SNGL(TORQCENZ)
      WRITE(LUNGFO,*)'     NBFORCX,NBFORCY,NBFORCZ:'
     &                      ,NBFORCX,NBFORCY,NBFORCZ
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Plane            Force [N]      Torque [Nm] (with resp. to box center):'

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &'     low X, X-comp. ',SNGL(BFORCX(1)),SNGL(TORQX(1))
      WRITE(LUNGFO,*)
     &'     low X, Y-comp. ',SNGL(BFORCY(1)),SNGL(TORQY(1))
      WRITE(LUNGFO,*)
     &'     low X, Z-comp. ',SNGL(BFORCZ(1)),SNGL(TORQZ(1))
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &'     high X, X-comp.',SNGL(BFORCX(3)),SNGL(TORQX(3))
      WRITE(LUNGFO,*)
     &'     high X, Y-comp.',SNGL(BFORCY(3)),SNGL(TORQY(3))
      WRITE(LUNGFO,*)
     &'     high X, Z-comp.',SNGL(BFORCZ(3)),SNGL(TORQZ(3))

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &'     low Y, X-comp. ',SNGL(BFORCX(2)),SNGL(TORQX(2))
      WRITE(LUNGFO,*)
     &'     low Y, Y-comp. ',SNGL(BFORCY(2)),SNGL(TORQY(2))
      WRITE(LUNGFO,*)
     &'     low Y, Z-comp. ',SNGL(BFORCZ(2)),SNGL(TORQZ(2))
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &'     high Y, X-comp.',SNGL(BFORCX(4)),SNGL(TORQX(4))
      WRITE(LUNGFO,*)
     &'     high Y, Y-comp.',SNGL(BFORCY(4)),SNGL(TORQY(4))
      WRITE(LUNGFO,*)
     &'     high Y, Z-comp.',SNGL(BFORCZ(4)),SNGL(TORQZ(4))

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &'     low Z, X-comp. ',SNGL(BFORCX(5)),SNGL(TORQX(5))
      WRITE(LUNGFO,*)
     &'     low Z, Y-comp. ',SNGL(BFORCY(5)),SNGL(TORQY(5))
      WRITE(LUNGFO,*)
     &'     low Z, Z-comp. ',SNGL(BFORCZ(5)),SNGL(TORQZ(5))
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &'     high Z, X-comp.',SNGL(BFORCX(6)),SNGL(TORQX(6))
      WRITE(LUNGFO,*)
     &'     high Z, Y-comp.',SNGL(BFORCY(6)),SNGL(TORQY(6))
      WRITE(LUNGFO,*)
     &'     high Z, Z-comp.',SNGL(BFORCZ(6)),SNGL(TORQZ(6))

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &'     Sum X:         ',SNGL(BFORCX(7)),SNGL(TORQX(7))
      WRITE(LUNGFO,*)
     &'     Sum Y:         ',SNGL(BFORCY(7)),SNGL(TORQY(7))
      WRITE(LUNGFO,*)
     &'     Sum Z:         ',SNGL(BFORCZ(7)),SNGL(TORQZ(7))
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &'     Torque due to r x F:         '
      WRITE(LUNGFO,*)
     &'     ',SNGL(TORQROTX),SNGL(TORQROTY),SNGL(TORQROTZ)
      WRITE(LUNGFO,*)
     &'     Total torque:         '
      WRITE(LUNGFO,*)
     &'     ',SNGL(TORQTOTX),SNGL(TORQTOTY),SNGL(TORQTOTZ)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

        DEALLOCATE(XB)
        DEALLOCATE(YB)
        DEALLOCATE(ZB)
        DEALLOCATE(WS1)
        DEALLOCATE(WS2)
        DEALLOCATE(WS3)
        DEALLOCATE(WS4)
        DEALLOCATE(COEF)

        DEALLOCATE(BB)
        DEALLOCATE(BBI)
        DEALLOCATE(BT)
        DEALLOCATE(BTI)

      RETURN
      END
+DECK,BFORM.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.52/11 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  2.13/09 08/03/2000  17.52.23  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.04  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BFORM

+seq,gplhint.

C--- BERECHNET HARD-EDGE B-FELDKONFIGURATION


      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,BFELD.

      DOUBLE PRECISION B0LM

      IF (IBSYM.EQ.0) STOP '*** S/R BFORM: IBSYM.EQ.0 ***'

CC    FB0M=FB0MFUN(FB0N)

      BBY1=B0FORM
      BBY2=-B0FORM/FB0M
      BBY3=B0FORM/FB0M/FB0N
      BBY4=-B0FORM/FB0N
      BBY5=BBY3

      BBY6=0.0
        BBY7=0.0

      B0LM=FB0N/2.*B0LP

      XM1=0.0
      XP1=B0LP/8.
      XM2=XP1
      XP2=XM2+B0LP/8.
      XM3=XP2
      XP3=XM3+B0LM/8.
      XM4=XP3
      XP4=XM4+B0LM/4.
      XM5=XP4
      XP5=XM5+B0LM/8.

C250991  XM6=XP5+1.
C250991  XP6=XM6+1.
      XM6=XP5  !C250991
      XP6=XM6  !C250991
        XM7=XP7
        XP7=XM7

      RETURN
      END
+DECK,BFOUR.
*CMZ :  4.00/13 02/09/2021  13.02.53  by  Michael Scheer
*CMZ :  4.00/11 10/05/2021  10.29.59  by  Michael Scheer
*CMZ :  3.04/00 18/01/2018  12.39.42  by  Michael Scheer
*CMZ :  3.01/00 16/07/2013  09.32.23  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.68/02 27/06/2012  16.34.34  by  Michael Scheer
*CMZ :  2.54/05 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.53/05 11/02/2005  09.55.20  by  Michael Scheer
*CMZ :  2.52/14 20/12/2004  17.10.56  by  Michael Scheer
*CMZ :  2.52/09 21/10/2004  15.47.48  by  Michael Scheer
*CMZ :  2.52/06 14/10/2004  09.16.20  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.34/07 04/09/2001  16.15.01  by  Michael Scheer
*CMZ :  2.16/08 01/11/2000  18.41.44  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  17.26.51  by  Michael Scheer
*CMZ : 00.01/11 11/09/96  17.24.24  by  Michael Scheer
*CMZ : 00.01/10 11/09/96  12.42.14  by  Michael Scheer
*CMZ : 00.01/07 16/03/95  14.21.07  by  Michael Scheer
*CMZ : 00.01/02 24/11/94  15.45.58  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  18.05.04  by  Michael Scheer
*CMZ : 00.00/03 29/04/94  10.18.17  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.37  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BFOUR(XXIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,
     &                               AXOUT,AYOUT,AZOUT)

+seq,gplhint.

C SUBROUTINE CALCULATES MAGNETIC FIELD AND VECTOR POTENTIAL FOR FOURIER
C EXPANSION OF HALBACH WIGGLER.
C FOURIER COEFFICIENTS ARE READ FROM DATA FILE OR CALCULATED
C ANALYTICALLY AND STORED IN COMMON-BLOCK FOR SIMPLE WAVELENGTH SHIFTER
C MODEL WITH ONE MAIN POLE.
C INTERNALLY HALBACHS CONVENTION IS USED FOR COORDINATE, INPUT AND
C OUTPUT CORRESPOND TO LAB.-SYSTEM.

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,CMPARA.
+SEQ,HALBASY.
+SEQ,MYFILES.
+SEQ,FOURIER.
+SEQ,PHYCON.

      CHARACTER(60) CODEF

      INTEGER I,IK,ICAL,K,NKOEF,ICODEF,ifound

      DOUBLE PRECISION A0,A(MAXFOUR),XKFOUR(MAXFOUR),YKFOUR(MAXFOUR),ZKFOUR(MAXFOUR)
      REAL*4 AR(MAXFOUR),SUMCK2,SUMC
      DOUBLE PRECISION ZRFOUR,XL0FOUR,YL0FOUR,ZL0FOUR,XK0FOUR,YK0FOUR,ZK0FOUR,
     &  ZL0FOUR2,DUMZ,DUMN

      DOUBLE PRECISION XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT,
     &  DSNXKX,DCSXKX,DSHYKY,DCHYKY,DSNZKZ,DCSZKZ
     &  ,BXH,BYH,BZH,AXH,AYH,AZH,AN,AM,X,xxin


      DOUBLE PRECISION EXPOMY,DEXPOMY,EXPOMY1

      DOUBLE PRECISION DNULL
      COMPLEX*16 CDEXPOMX,CEXPOMZ,CDEXPOMZ
      DATA DNULL/0.D0/

      DATA ICAL/0/

      IF (KBEXTERN.NE.0) IRFILF=1

      xin=xxin+xshbfour

      IF (ICAL.NE.1) THEN

        IF (NFOUR.NE.-9999.AND.(NFOUR.LT.1.OR.NFOUR.GT.MAXFOUR)) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN BFOUR ***'
          WRITE(LUNGFO,*)'NFOUR.LT.1.OR.NFOUR.GT.MAXFOUR'
          WRITE(LUNGFO,*)'CHECK NFOUR (NAMELIST FOURIER)'
          WRITE(LUNGFO,*)'OR INCREASE MAXFOUR (FILE CMPARA.CMN)'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN BFOUR ***'
          WRITE(6,*)'NFOUR.LT.1.OR.NFOUR.GT.MAXFOUR'
          WRITE(6,*)'CHECK NFOUR (NAMELIST FOURIER)'
          WRITE(6,*)'OR INCREASE MAXFOUR (FILE CMPARA.CMN)'
          WRITE(6,*)
          STOP
        ENDIF

        IF (IRFILF.NE.0) THEN

          OPEN(UNIT=LUNF,FILE=FILEF,STATUS='OLD',FORM='FORMATTED')

c          READ(LUNF,1000)ICODEF,CODEF
c1000      FORMAT(I10,'  ',1A60)
          read(lunf,'(a)')codef
          read(codef,*) icodef
          ifound=0
          do i=1,60
            if (
     &        codef(i:i).eq."0".or.
     &        codef(i:i).eq."1".or.
     &        codef(i:i).eq."2".or.
     &        codef(i:i).eq."3".or.
     &        codef(i:i).eq."4".or.
     &        codef(i:i).eq."5".or.
     &        codef(i:i).eq."6".or.
     &        codef(i:i).eq."7".or.
     &        codef(i:i).eq."8".or.
     &        codef(i:i).eq."9") ifound=1
            if (ifound.eq.1.and.codef(i:i).eq.' ') goto 1000
          enddo
1000      codef=codef(i+1:60)
          READ(LUNF,*)ZRFOUR
          READ(LUNF,*)NKOEF
          IF (NFOUR.EQ.-9999) NFOUR=NKOEF
          IF (NKOEF.GT.MAXFOUR.OR.NKOEF.LT.NFOUR) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '*** ERROR IN BFOUR ***'
            WRITE(LUNGFO,*)'NKOEF.GT.MAXFOUR.OR.NKOEF.LT.NFOUR'
            WRITE(LUNGFO,*)'CHECK PARAMETERS IN FILE CMPARA.CMN AND NAMELISTS FOURIER (AND MAYBE HALBASY)'
            WRITE(6,*)
            WRITE(6,*)
     &        '*** ERROR IN BFOUR ***'
            WRITE(6,*)'NKOEF.GT.MAXFOUR.OR.NKOEF.LT.NFOUR'
            WRITE(6,*)'CHECK PARAMETERS IN FILE CMPARA.CMN AND NAMELISTS FOURIER (AND MAYBE HALBASY)'
            STOP
          ENDIF

          READ(LUNF,*)IK,A0

          DO I=1,NKOEF-1
            READ(LUNF,*)IK,AR(IK-1)
            A(IK-1)=DBLE(AR(IK-1))
          END DO

          ZL0FOUR=ZRFOUR
          ZL0FOUR2=ZL0FOUR/2.
          ZK0FOUR=2.D0*PI1/ZL0FOUR
C021291          XL0FOUR=XLHALBASY  !VORERST SIEHE OBEN
          XL0FOUR=XLENFOUR      !VORERST SIEHE OBEN
          XK0FOUR=0.D0
          IF(XL0FOUR.NE.0.) XK0FOUR=2.D0*PI1/XL0FOUR
          YK0FOUR=DSQRT(ZK0FOUR**2+XK0FOUR**2)
          YL0FOUR=2.D0*PI1/YK0FOUR

          if (scbfour.eq.-9999.0d0) scbfour=1.0d0
          if (xshbfour.eq.-9999.0d0) xshbfour=0.0d0
          if (fouentr.eq.-9999.0d0) fouentr=-zl0four/2.0d0-xshbfour
          if (fouexit.eq.-9999.0d0) fouexit=zl0four/2.0d0-xshbfour

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     SR BFOUR:',NKOEF,' coefficients read from file:'
          WRITE(LUNGFO,*)'     ',FILEF
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     FOUENTR, FOUEXIT: ',fouentr,fouexit
          WRITE(LUNGFO,*)'     SCBFOUR, XSHBFOUR:',scbfour,xshbfour
          WRITE(LUNGFO,*)

          CLOSE(LUNF)

        ELSE !(IRFILF.NE.0)

          IF (AHWPOL.NE.1.) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN BFOUR ***'
            WRITE(LUNGFO,*)
     &        'FOR THIS FEATURE (IAHWPOL.NE.0) PARAMETER AHWPOL HAS TO BE 1. ***'
            WRITE(6,*)
            WRITE(6,*)
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN BFOUR ***'
            WRITE(6,*)
     &        'FOR THIS FEATURE (IAHWPOL.NE.0) PARAMETER AHWPOL HAS TO BE 1. ***'
            WRITE(6,*)
            STOP
          ENDIF

          IF (NFOUR.EQ.-9999) NFOUR=NFOURWLS

          IF (FASYM.EQ.2.0D0) THEN
            ZL0FOUR=ZLHALBASY
          ELSE
            ZL0FOUR=ZLHALBASY/2.*(1.+FASYM)
          ENDIF

          ZL0FOUR2=ZL0FOUR/2.
          ZK0FOUR=2.D0*PI1/ZL0FOUR
C110996              XL0FOUR=XLHALBASY  !VORERST SIEHE OBEN
          XL0FOUR=XLENFOUR
          XK0FOUR=0.D0
          IF(XL0FOUR.NE.0.) XK0FOUR=2.D0*PI1/XL0FOUR
          YK0FOUR=DSQRT(ZK0FOUR**2+XK0FOUR**2)
          YL0FOUR=2.D0*PI1/YK0FOUR

          AN=FASYM

          A0=0.
          DO I=1,NFOUR-1

            AM=I

            DUMZ=
     &        -2.D0*
     &         (
     &          (2.D0*AM**2*AN**2-4.*AM**2-AN**2-2.D0*AN-1.D0)*
     &          DCOS((AM*PI1)/(AN+1.D0))-
     &          (2.D0*AM+AN+1.D0)*(2.D0*AM-AN-1.D0)*
     &          DCOS(AM*PI1)
     &         )*
     &         (AN+1.D0)

            DUMN=
     &        (AM*AN+AN+1.D0)*
     &        (AM*AN-AN-1.D0)*(2.D0*AM+AN+1.D0)*(2.D0*AM-AN-1.D0)*PI1

            IF (DUMN.NE.0.0D0) THEN
              A(I)=B0HALBASY*DUMZ/DUMN       !NORMIERUNG AUF PEAK-FELD
            ELSE
              A(I)=0.0D0
            ENDIF

          END DO

          WRITE(LUNGFO,*)
     &      '     SR BFOUR: Fourier expansion of wavelength shifter calculated'
          WRITE(LUNGFO,*)
     &      '               number of coefficients:',NFOUR
          WRITE(LUNGFO,*)

        ENDIF

        DO I=1,NFOUR-1
          ZKFOUR(I)=ZK0FOUR*I
          XKFOUR(I)=XK0FOUR !VORERST, SIEHE AUCH OBEN
          YKFOUR(I)=DSQRT(ZKFOUR(I)**2+XKFOUR(I)**2)
        END DO

C--- LONGITUDINAL FIELD HOMOGENITY, FIELD IS EXPANDED IN TAYLOR SERIE
C    TO SECOND ORDER. MAXIMUM AT Z=0 ASSUMED

CERROR 19MAY05
        SUMC=A0/2.0D0 !SUMC was not initialized (before 19may05)
        SUMCK2=0.0D0
        DO I=1,NFOUR-1
          SUMC=SUMC+A(I)
          SUMCK2=SUMCK2+A(I)*ZKFOUR(I)**2
        ENDDO
        IF (SUMCK2.NE.0.0) THEN
          XBHOMF=DSQRT(DABS(DBHOMF*2.D0/SUMCK2*SUMC))
        ELSE
          XBHOMF=9999.0D9
        ENDIF
C---

        IF (IRFILF.NE.0) THEN
          IF(IFOUR0.NE.0) A0=0.
          WRITE(LUNGFO,*)
     &      '     run number and comment of job that calculated Fourier coefficients:'
          WRITE(LUNGFO,*)ICODEF,'  ',CODEF
          WRITE(LUNGFO,*)'     flag IFOUR0:  ',IFOUR0
          WRITE(LUNGFO,*)'     period length ZL0FOUR:',SNGL(ZL0FOUR)
          WRITE(LUNGFO,*)
     &      '     lx, kx/kz:',SNGL(XL0FOUR),SNGL(XK0FOUR/ZK0FOUR)
          WRITE(LUNGFO,*)
        ENDIF

        IF(IPRNTF.NE.0) THEN
          WRITE(LUNGFO,*)'     Fourier coefficients and  kx/kz:'
          WRITE(LUNGFO,*)
          I=1
          WRITE(LUNGFO,*)'          0',SNGL(A0)
          DO I=1,NFOUR-1
            WRITE(LUNGFO,*)I,SNGL(A(I)),SNGL(XKFOUR(I)/ZKFOUR(I))
          ENDDO
        ENDIF !IPRNTF

        WRITE(LUNGFO,*)
     &    '     required homogeneity (DBHOMF) and corresponding distance from center:'
        WRITE(LUNGFO,*)'     ',SNGL(DBHOMF),SNGL(XBHOMF)
        WRITE(LUNGFO,*)

        DEVLEN=ZL0FOUR
        DEVLEN2=ZL0FOUR2

        ICAL=1

      ENDIF

C-------------------------------------------------------------------
C     IF (XIN.LT.-ZL0FOUR2.OR.XIN.GT.ZL0FOUR2) THEN  !VORSICHT WEGEN TRANPOLY
C     IF (DABS(XIN.LT.-ZL0FOUR2.OR.XIN.GT.ZL0FOUR2) THEN  !SIEHE LOGBUCH S. 218
C
      BXOUT=0.0
      BYOUT=0.0
      BZOUT=0.0
C
      AXOUT=0.
      AYOUT=0.
      AZOUT=0.
C
C        RETURN
C     ENDIF

      if (xin.lt.fouentr.or.xin.gt.fouexit) then
        return
      endif

      X=DMOD(XIN,ZL0FOUR) !2.12.91

      IF (X.GT.ZL0FOUR2) THEN
        X=X-ZL0FOUR
      ELSE IF (X.LT.-ZL0FOUR2) THEN
        X=X+ZL0FOUR
      ENDIF

      BXH=0.
      BYH=A0/2.D0
      BZH=0.

C IF CHANGED, CONSIDER FOLLOWING LOOP AND SR MYBFELD {

+SELF,IF=DIPAXAZ.
      AXH= A0/4.D0*  XIN
      AYH=0.
      AZH=-A0/4.D0*(-ZIN)
+SELF.

+SELF,IF=DIPAZ.
      AXH=0.
      AYH=0.
      AZH=A0/2.D0*ZIN  ! (-ZIN) IS X HERE
+SELF.

+SELF,IF=-DIPAXAZ,IF=-DIPAZ.
      AXH= A0/2.D0*  XIN !XIN IS HERE Z
      AYH=0.
      AZH=0.
+SELF.

C IF CHANGED, CONSIDER FOLLOWING LOOP AND SR MYBFELD }

      CDEXPOMX=CDEXP(DCMPLX(DNULL,XKFOUR(1)*(-ZIN)))
      DCSXKX=DREAL(CDEXPOMX)
      DSNXKX=DIMAG(CDEXPOMX)

      DEXPOMY=DEXP(YKFOUR(1)*YIN)
      EXPOMY=1.D0

      CDEXPOMZ=CDEXP(DCMPLX(DNULL,ZKFOUR(1)*    X ))
      CEXPOMZ=DCMPLX(1.D0,DNULL)

      DO K=1,NFOUR-1

        IF (XK0FOUR.NE.0.0D0) THEN
          EXPOMY=DEXP(YKFOUR(K)*YIN)
        ELSE
          EXPOMY=EXPOMY*DEXPOMY
        ENDIF

        EXPOMY1=1.D0/EXPOMY
        DCHYKY=(EXPOMY+EXPOMY1)*0.5D0
        DSHYKY=(EXPOMY-EXPOMY1)*0.5D0

        CEXPOMZ=CEXPOMZ*CDEXPOMZ
        DCSZKZ=DREAL(CEXPOMZ)
        DSNZKZ=DIMAG(CEXPOMZ)

        BXH=BXH-A(K)*XKFOUR(K)/YKFOUR(K)*DSNXKX*DSHYKY*DCSZKZ
        BYH=BYH+A(K)*                    DCSXKX*DCHYKY*DCSZKZ
        BZH=BZH-A(K)*ZKFOUR(K)/YKFOUR(K)*DCSXKX*DSHYKY*DSNZKZ

+SELF,IF=HALAXAZ.
        AXH=AXH+0.5D0*A(K)/ZKFOUR(K)*DCSXKX*DCHYKY*DSNZKZ
        IF (XKFOUR(K).NE.0.0) THEN
          AZH=AZH-0.5D0*A(K)/XKFOUR(K)*DSNXKX*DCHYKY*DCSZKZ
        ELSE
          AZH=AZH-0.5D0*A(K)*(-ZIN)*DCHYKY*DCSZKZ
        ENDIF
+SELF.

+SELF,IF=HALAZ.
        AXH=AXH+0.0
        IF (XKFOUR(K).NE.0.0) THEN
          AZH=AZH-A(K)/XKFOUR(K)*DSNXKX*DCHYKY*DCSZKZ
        ELSE
          AZH=AZH-A(K)*(-ZIN)*DCHYKY*DCSZKZ
        ENDIF
+SELF.

+SELF,IF=-HALAXAZ,IF=-HALAZ.
        AXH=AXH+A(K)/ZKFOUR(K)*DCSXKX*DCHYKY*DSNZKZ
        AZH=AZH+0.0
+SELF.

        AYH=AYH+A(K)/ZKFOUR(K)*XKFOUR(K)/YKFOUR(K)*DSNXKX*DSHYKY*DSNZKZ

      ENDDO

      BZOUT=-BXH*scbfour
      BYOUT= BYH*scbfour
      BXOUT= BZH*scbfour

      AZOUT=-AXH*scbfour
      AYOUT= AYH*scbfour
      AXOUT= AZH*scbfour

      IF (KBEXTERN.NE.0) IRFILF=0

      RETURN

      END
+DECK,BGENESIS.
*CMZ :  3.02/03 23/10/2014  13.43.13  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.10.30  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.68/05 28/09/2012  12.21.08  by  Michael Scheer
*CMZ :  2.67/00 13/02/2012  10.58.17  by  Michael Scheer
*CMZ :  2.47/12 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.47/10 30/05/2003  08.16.14  by  Michael Scheer
*CMZ :  2.47/09 26/05/2003  16.00.38  by  Michael Scheer
*CMZ :  2.47/08 16/05/2003  15.52.55  by  Michael Scheer
*CMZ :  2.36/00 05/11/2001  11.14.30  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ : 00.01/10 21/08/96  12.30.33  by  Michael Scheer
*CMZ : 00.01/04 30/11/94  14.09.41  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.47.18  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.57  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BGENESIS(XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT
     &                               ,AXOUT,AYOUT,AZOUT)

+seq,gplhint.

+SEQ,SOURCEF90U,IF=F90.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,GENESIS.
+seq,sourcef90.

+SEQ,PHYCON.

      DOUBLE PRECISION
     &  XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT,
     &  XKX,YKY,ZKZ,DSNXKX,DCSXKX,DSHYKY,DCHYKY,DSNZKZ,DCSZKZ,
     &  BXH,BYH,BZH,AXH,AYH,AZH,XKHALBA,YKHALBA,ZKHALBA,B0HALBA,
     &  AW,QF,CONSTAW,FIELD,GSTYPE,GSTYPEO,CURLEN,BX,BY,BZ,
     &  QYCEN,QZCEN,SL,CX,CY,XLHALBA,YLHALBA,ROOT2

      INTEGER LC,NTUPP
      PARAMETER (LC=80,NTUPP=13)

      double precision FILL(NTUPP)

      INTEGER ICAL,I,IH,IL,NREP,NDIST,IGST,ICHA

      CHARACTER(LC) CHEADER,CVERSION,CUNITLENGTH,CLINE
      CHARACTER(2) CHTAGS(NTUPP)
      CHARACTER(80) CHANGE,COMGEN

      DATA ICAL/0/,IL/1/,IH/2/

      data chtags/'x','y','z','bx','by','bz','aw','dp',
     &'qf','ad','sl','cx','cy'/

      IF (ICAL.EQ.0) THEN

        ROOT2=SQRT(2.D0)

        CALL GENESISIN

        OPEN(UNIT=99,FILE='wave_genesis.bnd',STATUS='NEW',FORM='FORMATTED')
        OPEN(UNIT=LUNGENL,FILE=FILEGENL,STATUS='OLD',FORM='FORMATTED',ERR=9)

        READ(LUNGENL,'(A)',ERR=99) CHEADER

        IF (CHEADER.NE.'# Header is included') THEN
          WRITE(6,*)'*** ERROR IN BGENESIS: BAD HEADERLINE ON LATTICE FILE'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
          WRITE(LUNGFO,*)'*** ERROR IN BGENESIS: BAD HEADERLINE ON LATTICE FILE'
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
          STOP
        ENDIF

        READ(LUNGENL,'(A)',ERR=99) CVERSION

        READ(LUNGENL,'(A)',ERR=99) CUNITLENGTH

        IF (CUNITLENGTH(1:12).NE.'? UNITLENGTH') THEN
          WRITE(6,*)'*** ERROR IN BGENESIS: LINE FOR UNITLENGTH FILE'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
          WRITE(LUNGFO,*)'*** ERROR IN BGENESIS: LINE FOR UNITLENGTH FILE'
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
          STOP
        ENDIF

        READ(CUNITLENGTH(14:21),*) GSUNILEN

        GSLATT(1,1)=GSUNILEN
        DO IH=2,10
          GSLATT(IH,1)=-9999.
        ENDDO

        DO I=2,NGSDIMP
          GSLATT(1,I)=GSLATT(1,I-1)+GSUNILEN
          DO IH=2,10
            GSLATT(IH,I)=-9999.
          ENDDO
        ENDDO

        NGSELEM=0
        GSTOTLEN=0.D0
        GSTYPEO=-1.

11      READ(LUNGENL,'(A)',END=88,ERR=99) CLINE

        IF (CLINE(1:2).EQ.'AW') THEN
          GSTYPE=2.
        ELSE IF (CLINE(1:2).EQ.'DP') THEN
          GSTYPE=3.
        ELSE IF (CLINE(1:2).EQ.'QF') THEN
          GSTYPE=4. ! quadrupol, gradient [T/m],
          !QF > 0 is horizontally focusing
          !QF < 0 is vertically focusing
        ELSE IF (CLINE(1:2).EQ.'QX') THEN
          GSTYPE=5. ! quadrupol offset in x
        ELSE IF (CLINE(1:2).EQ.'QY') THEN
          GSTYPE=6. ! quadrupol offset in y
        ELSE IF (CLINE(1:2).EQ.'AD') THEN
          GSTYPE=7.  ! for the time being (26.5.2003) just a drift
        ELSE IF (CLINE(1:2).EQ.'SL') THEN
          GSTYPE=8. ! solenoid, field strength [T]?
        ELSE IF (CLINE(1:2).EQ.'CX') THEN
          GSTYPE=9. ! pur vertical field, angle [mrad]
        ELSE IF (CLINE(1:2).EQ.'CY') THEN
          GSTYPE=10.  ! pur horizontal field, angle [mrad]
        ELSE
          WRITE(6,*)' '
          WRITE(6,*)
     &      '*** ERROR IN BGENESIS: BAD MAGNET TYPE ON LATTICE FILE'
          WRITE(6,*)CLINE
          WRITE(6,*)' '
          WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
          WRITE(LUNGFO,*)' '
          WRITE(LUNGFO,*)
     &      '*** ERROR IN BGENESIS: BAD MAGNET TYPE ON LATTICE FILE'
          WRITE(LUNGFO,*)CLINE
          WRITE(LUNGFO,*)' '
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
          STOP
        ENDIF !(CLINE(1:2).EQ.'AW')

        IGST=GSTYPE

        READ(CLINE(3:LC),*) FIELD,NREP,NDIST

        IF (GSTYPE.NE.GSTYPEO) THEN
          IL=0
          CURLEN=0.D0
        ENDIF  ! GSTYPE

        DO I=1,NDIST
          IL=IL+1
          CURLEN=CURLEN+GSUNILEN
          IF (CURLEN.GT.GSTOTLEN) THEN
            GSTOTLEN=CURLEN
            IF (IL.GT.NGSDIMP-1) GOTO 999
            NGSELEM=IL
          ENDIF
        ENDDO !NDIST

        DO I=1,NREP
          IL=IL+1
          CURLEN=CURLEN+GSUNILEN
          IF (CURLEN.GT.GSTOTLEN) THEN
            GSTOTLEN=CURLEN
            IF (IL.GT.NGSDIMP-1) GOTO 999
            NGSELEM=IL
          ENDIF
          IF (GSLATT(IGST,IL).NE.-9999.) THEN
            WRITE(6,*)
     &        '*** ERROR IN BGENESIS: COLLIDING ELEMENTS ON LATTICE FILE'
            WRITE(6,*)IL,IGST,GSLATT(IGST,IL),GSLATT(1,IL)
            WRITE(6,*)CLINE
            WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
            WRITE(LUNGFO,*)
     &        '*** ERROR IN BGENESIS: COLLIDING ELEMENTS ON LATTICE FILE'
            WRITE(LUNGFO,*)IL,IGST,GSLATT(IGST,IL),GSLATT(1,IL)
            WRITE(LUNGFO,*)CLINE
            WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
            STOP
          ENDIF

          GSLATT(IGST,IL)=FIELD

        ENDDO ! NREP

        GSTYPEO=GSTYPE

        GOTO 11

88      CLOSE(LUNGENL)

        IF (ROIX(1).GT.0..OR.ROIX(2).LT.GSTOTLEN) THEN
            WRITE(6,*)' '
            WRITE(6,*)'*** WARNING IN BGENESIS: INCOMPATIBLE ROIS'
            WRITE(6,*)'ROIS ARE SET OR OVERWRITTEN BY BGENESIS'
            WRITE(6,*)'CHECK NAMELIST $ROIN IN INPUT FILE WAVE.IN'
            WRITE(6,*)' '
            WRITE(LUNGFO,*)' '
            WRITE(LUNGFO,*)'*** WARNING IN BGENESIS: INCOMPATIBLE ROIS'
            WRITE(LUNGFO,*)'ROIS ARE SET OR OVERWRITTEN BY BGENESIS'
            WRITE(LUNGFO,*)'CHECK NAMELIST $ROI IN INPUT FILE WAVE.IN'
            WRITE(LUNGFO,*)' '
        ENDIF

      IF (NGSELEM.LE.2) THEN
        WRITE(6,*)'*** ERROR IN BGENESIS:'
        WRITE(6,*)'TOO FEW ELEMENTS ON LATTICE FILE.'
        WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
        WRITE(LUNGFO,*)'*** ERROR IN BGENESIS:'
        WRITE(LUNGFO,*)'TOO FEW ELEMENTS ON LATTICE FILE.'
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
        STOP
      ENDIF

      NROI=2
      ROIX(1)=GSLATT(1,1)-GSUNILEN
      ROIX(2)=GSLATT(1,NGSELEM)

      DO I=1,NGSELEM-1

        CHANGE=''
        ICHA=1

        IF(
     &      GSLATT(2,I).NE.GSLATT(2,I+1) .OR. !AW
     &      GSLATT(3,I).NE.GSLATT(3,I+1) .OR. !DP
     &      GSLATT(4,I).NE.GSLATT(4,I+1) .OR. !QF
     &      GSLATT(5,I).NE.GSLATT(5,I+1) .OR. !QX
     &      GSLATT(6,I).NE.GSLATT(6,I+1) .OR. !QY
     &      GSLATT(7,I).NE.GSLATT(7,I+1) .OR. !AD
     &      GSLATT(8,I).NE.GSLATT(8,I+1) .OR. !SL
     &      GSLATT(9,I).NE.GSLATT(9,I+1) .OR. !CX
     &      GSLATT(10,I).NE.GSLATT(10,I+1)
     &      ) THEN

          ROIX(NROI)=GSLATT(1,I)

          IF(GSLATT(2,I).NE.GSLATT(2,I+1)) THEN
            CHANGE(ICHA:ICHA+2)=' AW'
            ICHA=ICHA+3
          ENDIF

          IF(GSLATT(3,I).NE.GSLATT(3,I+1)) THEN
            CHANGE(ICHA:ICHA+2)=' DP'
            ICHA=ICHA+3
          ENDIF

          IF(GSLATT(4,I).NE.GSLATT(4,I+1)) THEN
            CHANGE(ICHA:ICHA+2)=' QF'
            ICHA=ICHA+3
          ENDIF

          IF(GSLATT(5,I).NE.GSLATT(5,I+1)) THEN
            CHANGE(ICHA:ICHA+2)=' QX'
            ICHA=ICHA+3
          ENDIF

          IF(GSLATT(6,I).NE.GSLATT(6,I+1)) THEN
            CHANGE(ICHA:ICHA+2)=' QY'
            ICHA=ICHA+3
          ENDIF

          IF(GSLATT(7,I).NE.GSLATT(7,I+1)) THEN
            CHANGE(ICHA:ICHA+2)=' AD'
            ICHA=ICHA+3
          ENDIF

          IF(GSLATT(8,I).NE.GSLATT(8,I+1)) THEN
            CHANGE(ICHA:ICHA+2)=' SL'
            ICHA=ICHA+3
          ENDIF

          IF(GSLATT(9,I).NE.GSLATT(9,I+1)) THEN
            CHANGE(ICHA:ICHA+2)=' CX'
            ICHA=ICHA+3
          ENDIF

          IF(GSLATT(10,I).NE.GSLATT(10,I+1)) THEN
            CHANGE(ICHA:ICHA+2)=' CY'
            ICHA=ICHA+3
          ENDIF

          WRITE(99,*)'N, ROIX(N):',NROI,ROIX(NROI),CHANGE(1:ICHA)

          NROI=NROI+1

          IF (NROI.GT.NROIP) THEN
            WRITE(6,*)' '
            WRITE(6,*)
     &        '*** ERROR IN BGENESIS: DIMENSION NROIP EXCEEDED'
            WRITE(6,*)' '
            WRITE(LUNGFO,*)' '
            WRITE(LUNGFO,*)
     &        '*** ERROR IN BGENESIS: DIMENSION NROIP EXCEEDED'
            WRITE(LUNGFO,*)' '
            STOP
          ENDIF

          ROIX(NROI)=GSLATT(1,NGSELEM)

        ENDIF

      ENDDO !NGSELEM

      CLOSE(99)

      GSZLHAL=GSXLAMD

      IF (GSZLHAL.NE.0.D0) THEN
        ZKHALBA=2.D0*PI1/GSZLHAL
      ELSE
        ZKHALBA=0.D0
      ENDIF

      IF (IGSWITYP.EQ.0) THEN ! planar undulator

        IF (GSXKX.LE.0.0) THEN
          XKHALBA=SQRT(ABS(GSXKX))*ZKHALBA
        ELSE !(GSXKX.LT.0)
          WRITE(6,*)' '
          WRITE(6,*)
     &      '*** WARNING IN BGENESIS: horizontal focusing of undulator > 0'
          WRITE(6,*)' '
          WRITE(LUNGFO,*)' '
          WRITE(LUNGFO,*)
     &      '*** WARNING IN BGENESIS: horizontal focusing of undulator > 0'
          WRITE(LUNGFO,*)' '
        ENDIF !(GSXKX.LT.0)

        IF (GSXKY.GE.0.0) THEN
          YKHALBA=SQRT(GSXKY)*ZKHALBA
        ELSE !(GSXKY.LT.0)
          WRITE(6,*)' '
          WRITE(6,*)
     &      '*** ERROR IN BGENESIS: vertical focusing of undulator < 0'
          WRITE(6,*)' '
          WRITE(LUNGFO,*)' '
          WRITE(LUNGFO,*)
     &      '*** ERROR IN BGENESIS: vertical focusing of undulator < 0'
          WRITE(LUNGFO,*)' '
          STOP
        ENDIF !(GSXKY.LT.0)

          ELSE !IGSWITYP

            WRITE(6,*)' '
            WRITE(6,*)'*** ERROR IN BGENESIS: ONLY PLANAR UNDULATOR AVAILABLE'
            WRITE(6,*)' '
            WRITE(LUNGFO,*)' '
            WRITE(LUNGFO,*)'*** ERROR IN BGENESIS: ONLY PLANAR UNDULATOR AVAILABLE'
            WRITE(LUNGFO,*)' '
            STOP

          ENDIF !IGSWITYP

          IF (XKHALBA.NE.0.D0) THEN
            XLHALBA=2.D0*PI1/XKHALBA
          ELSE
            XLHALBA=1.D30
          ENDIF

          IF (YKHALBA.NE.0.D0) THEN
            YLHALBA=2.D0*PI1/YKHALBA
          ELSE
            YLHALBA=1.D30
          ENDIF


          WRITE(LUNGFO,*)' '
          WRITE(LUNGFO,*)'First call to BGENESIS:'
          WRITE(LUNGFO,*)' '
          WRITE(LUNGFO,*)'      name of GENESIS input file: ',FILEGENI
          OPEN(UNIT=99,FILE='genesis.out',STATUS='OLD')
            READ(99,'(A)')COMGEN
            READ(99,'(A)')COMGEN
            READ(99,'(A)')COMGEN
            WRITE(LUNGFO,*)COMGEN
            READ(99,'(A)')COMGEN
            READ(99,'(A)')COMGEN
            READ(99,'(A)')COMGEN
            WRITE(LUNGFO,*)COMGEN
          CLOSE(99)
          WRITE(LUNGFO,*)'      AW0, XLAMD:',
     &      SNGL(GSAW0),SNGL(GSXLAMD)
          WRITE(LUNGFO,*)'      XKX, XKY (normalized to ZKZ):',
     &      SNGL(GSXKX),SNGL(GSXKY)
          WRITE(LUNGFO,*)'      corresponding XLHALBA,YLHALBA [m]:',
     &      SNGL(XLHALBA),SNGL(YLHALBA)
          WRITE(LUNGFO,*)' '
          WRITE(LUNGFO,*)'      name of lattice file: ',FILEGENL
          WRITE(LUNGFO,*)'      unitlength, periodlength:',
     &      SNGL(GSUNILEN),SNGL(GSZLHAL)
          WRITE(LUNGFO,*)'      number of items on lattice file:',NGSELEM
          WRITE(LUNGFO,*)'      total length in unitlengths and meter:',
     &      SNGL(GSTOTLEN/GSUNILEN),SNGL(GSTOTLEN)

          IF (ABS(GSZLHAL/GSUNILEN-1.D0) .GT. 1.D-6 .AND.
     &        ABS(GSZLHAL/GSUNILEN-2.D0) .GT. 1.D-6) THEN
            WRITE(6,*)'*** WARNING IN BGENESIS: STRANGE PERIODLENGTH (GSZLHAL)'
            WRITE(6,*)'GENESIS NAMELIST- AND LATTICE-FILES'
            WRITE(LUNGFO,*)'*** WARNING IN BGENESIS: STRANGE PERIODLENGTH (GSZLHAL)'
            WRITE(LUNGFO,*)'GENESIS NAMELIST- AND LATTICE-FILES'
          ENDIF

          CONSTAW=EMASSKG1*CLIGHT1/ECHARGE1

          WRITE(6,*)
          WRITE(LUNGFO,*)

          ICAL=1

        ENDIF !ICAL

        IF (ICAL.EQ.3.AND.IHISINI_C.EQ.0) THEN
          CALL HISINI
          IF (KBGENESIS.GT.0) THEN
            NIDGENESIS=13
            CALL hbookm(NIDGENESIS,'GENESIS$',NTUPP,'//WAVE',1024,CHTAGS)
          ENDIF !KBGENESIS
        ELSE IF (IHISINI_C.EQ.0) THEN
          ICAL=ICAL+1
        ENDIF !ICAL


        IF (XIN.LT.0.D0.OR.XIN.GE.GSLATT(1,NGSELEM)) THEN
          BXOUT=0.D0
          BYOUT=0.D0
          BZOUT=0.D0
          AXOUT=0.D0
          AYOUT=0.D0
          AZOUT=0.D0
          GOTO 8888 ! RETURN
        ENDIF

C get position and index

          IL=XIN/GSUNILEN+1

          BXOUT=0.D0
          BYOUT=0.D0
          BZOUT=0.D0

          AXOUT=0.D0
          AYOUT=0.D0
          AZOUT=0.D0

        IF (GSLATT(2,IL).NE.-9999.) THEN

          IF(IGSWITYP.EQ.0) THEN ! planar device

            AW=GSLATT(2,IL)
            B0HALBA=AW*ROOT2*ZKHALBA*CONSTAW

            XKX=XKHALBA*(-ZIN)
            YKY=YKHALBA*YIN
            ZKZ=ZKHALBA*XIN

            IF (XKX.LT.0.D0) THEN
              DSNXKX=DSIN(XKX)
              DCSXKX=DCOS(XKX)
            ELSE
              DSNXKX=DSINH(XKX)
              DCSXKX=DCOSH(XKX)
            ENDIF

            DSHYKY=DSINH(YKY)
            DCHYKY=DSQRT(1.D0+DSHYKY*DSHYKY)
            DSNZKZ=DSIN(ZKZ)
            DCSZKZ=DCOS(ZKZ)

            BXH=-XKHALBA/YKHALBA*B0HALBA*DSNXKX*DSHYKY*DCSZKZ
            BYH=                 B0HALBA*DCSXKX*DCHYKY*DCSZKZ
            BZH=-ZKHALBA/YKHALBA*B0HALBA*DCSXKX*DSHYKY*DSNZKZ

            AXH=B0HALBA/ZKHALBA*                DCSXKX*DCHYKY*DSNZKZ
            AYH=B0HALBA/ZKHALBA*XKHALBA/YKHALBA*DSNXKX*DSHYKY*DSNZKZ
            AZH=0.

            BZOUT=BZOUT-BXH
            BYOUT=BYOUT+BYH
            BXOUT=BXOUT+BZH

            AZOUT=AZOUT-AXH
            AYOUT=AYOUT+AYH
            AXOUT=AXOUT+AZH

          ELSE !IGSWITYP

            WRITE(6,*)' '
            WRITE(6,*)'*** ERROR IN BGENESIS: ONLY PLANAR UNDULATOR AVAILABLE'
            WRITE(6,*)' '
            WRITE(LUNGFO,*)' '
            WRITE(LUNGFO,*)'*** ERROR IN BGENESIS: ONLY PLANAR UNDULATOR AVAILABLE'
            WRITE(LUNGFO,*)' '
            STOP

          END IF !IGSWITYP

        ENDIF !AW

C        IF (GSLATT(3,IL).NE.-9999.) THEN
C
C          BX=0.D0
C          BY=0.D0
C          BZ=0.D0
C
C          BXOUT=BXOUT+BX
C          BYOUT=BYOUT+BY
C          BZOUT=BZOUT+BZ
C
C        ENDIF !DP

        IF (GSLATT(4,IL).NE.-9999.) THEN

          QF=GSLATT(4,IL) ! QUADRUPOL GRADIENT [T]

          IF (GSLATT(5,IL).NE.-9999.) THEN
            QZCEN=GSLATT(5,IL)
          ELSE
            QZCEN=GSLATT(5,IL)
          ENDIF !QX

          IF (GSLATT(6,IL).NE.-9999.) THEN
            QYCEN=GSLATT(6,IL)
          ELSE
            QYCEN=GSLATT(6,IL)
          ENDIF !QY

          BX=0.D0
          BY=QF*(ZIN-QZCEN)
          BZ=QF*(YIN-QYCEN)

          BXOUT=BXOUT+BX
          BYOUT=BYOUT+BY
          BZOUT=BZOUT+BZ

        ENDIF !QF


C        IF (GSLATT(7,IL).NE.-9999.) THEN
C
C          BX=0.D0
C          BY=0.D0
C          BZ=0.D0
C
C          BXOUT=BXOUT+BX
C          BYOUT=BYOUT+BY
C          BZOUT=BZOUT+BZ
C
C        ENDIF !AD

        IF (GSLATT(8,IL).NE.-9999.) THEN

          SL=GSLATT(8,IL)

          BX=SL
          BY=0.D0
          BZ=0.D0

          BXOUT=BXOUT+BX
          BYOUT=BYOUT+BY
          BZOUT=BZOUT+BZ

        ENDIF !SL

        IF (GSLATT(9,IL).NE.-9999.) THEN

          CX=GSLATT(9,IL)/1000.D0 ! mrad to rad

          BX=0.D0
          BY=CX*DBRHO/GSUNILEN
          BZ=0.D0

          BXOUT=BXOUT+BX
          BYOUT=BYOUT+BY
          BZOUT=BZOUT+BZ

        ENDIF !CX

        IF (GSLATT(10,IL).NE.-9999.) THEN

          CY=GSLATT(10,IL)/1000.D0

          BX=0.D0
          BY=0.D0
          BZ=CY*DBRHO/GSUNILEN

          BXOUT=BXOUT+BX
          BYOUT=BYOUT+BY
          BZOUT=BZOUT+BZ

        ENDIF !CY

8888  CONTINUE

      IF (KBGENESIS.GT.0.AND.IHISINI_C.NE.0) THEN
        FILL(1)=XIN
        FILL(2)=YIN
        FILL(3)=ZIN
        FILL(4)=BXOUT
        FILL(5)=BYOUT
        FILL(6)=BZOUT
        FILL(7)=GSLATT(2,IL) !AW
        FILL(8)=GSLATT(3,IL) !DP
        FILL(9)=GSLATT(4,IL) !QF
        FILL(10)=GSLATT(7,IL) !AD
        FILL(11)=GSLATT(8,IL) !SL
        FILL(12)=GSLATT(9,IL) !CX
        FILL(13)=GSLATT(10,IL) !CY
        CALL hfm(NIDGENESIS,FILL)
      ENDIF !KBGENESIS

      RETURN

9       WRITE(6,*)'*** ERROR IN BGENESIS: LATTICE FILE NOT FOUND'
        WRITE(6,*)'FILE: ',FILEGENL
        WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'

        WRITE(LUNGFO,*)'*** ERROR IN BGENESIS: LATTICE FILE NOT FOUND'
        WRITE(LUNGFO,*)'FILE: ',FILEGENL
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'

        STOP

99      WRITE(6,*)'*** ERROR IN BGENESIS: BAD LINE IN LATTICE FILE'
        WRITE(6,*)CLINE
        WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'

        WRITE(LUNGFO,*)'*** ERROR IN BGENESIS: BAD LINE IN LATTICE FILE'
        WRITE(LUNGFO,*)CLINE
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'

        STOP

999     WRITE(6,*)'*** ERROR IN BGENESIS: DIMENSION EXCEEDED'
        WRITE(6,*)'TOO MANY ELEMENTS ON LATTICE FILE.'
        WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'

        WRITE(LUNGFO,*)'*** ERROR IN BGENESIS: DIMENSION EXCEEDED'
        WRITE(LUNGFO,*)'TOO MANY ELEMENTS ON LATTICE FILE.'
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'

        STOP

      END
+DECK,BHALBA.
*CMZ :  4.00/15 07/04/2022  08.20.53  by  Michael Scheer
*CMZ :  3.05/06 17/07/2018  11.15.16  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.67/04 11/05/2012  11.18.26  by  Michael Scheer
*CMZ :  2.64/01 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.36/00 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ : 00.01/10 21/08/96  12.30.33  by  Michael Scheer
*CMZ : 00.01/04 30/11/94  14.09.41  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.47.18  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.57  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BHALBA(XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT)

+seq,gplhint.

C Calculates magnetic field according to Halbach's formulas
C Inside the routine the coodinate system corresponds to
C Halbach's convention i.e. Z is the longitudinal coordinate
C Input and Output are converted according to the coordinate
C system of WAVE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,HALBACH.
+seq,freqs.
+SEQ,PHYCON.

      INTEGER ICAL

      DOUBLE PRECISION XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT,
     &  XKX,YKY,ZKZ,DSNXKX,DCSXKX,DSHYKY,DCHYKY,DSNZKZ,DCSZKZ
     &  ,BXH,BYH,BZH,AXH,AYH,AZH

      DOUBLE PRECISION PARK,WLEN1,EHARM1

      DATA ICAL/0/

      IF (ICAL.EQ.0) THEN

        park=pkhalba

        if (nhhalba.ne.0.and.hhalba.ne.0.0d0) then
          if (hhalba.eq.-9999.0d0) then
            if (ifreq2p.eq.1) then
              hhalba=freqlow
            else
              hhalba=(freqlow+freqhig)/2.0d0
            endif
          else if (hhalba.lt.0.0d0) then
            hhalba=-wtoe1/hhalba
          endif
          WLEN1=wtoe1/abs(hhalba/nhhalba)
          park=2.0d0*(wlen1/(zlhalba*1.0D9/2.0d0/DMYGAMMA**2)-1.0d0)
          if (park.lt.0.0d0) then
            write(6,*)
     &        '*** Error in BHALBA:'
            write(6,*)
     &        'Inconsistent values of NHHALBA, HHALBA, and ZLHALBA'
            write(6,*)' '
            write(lungfo,*)
     &        '*** Error in BHALBA:'
            write(lungfo,*)
     &        'Inconsistent values of NHHALBA, HHALBA, and ZLHALBA'
            write(lungfo,*)' '
            stop
          endif
          park=sqrt(park)
          pkhalba=park
        endif

        IF (park.ne.0.0d0) THEN
          B0halba=pkhalba/(echarge1*zlhalba/(2.*PI1*EMASSKG1*CLIGHT1))
        endif

        IF(B0HALBA.EQ.9999.0D0) THEN
          OPEN(UNIT=LUNH,FILE=FILEH,STATUS='OLD',FORM='FORMATTED')
          READ(LUNH,*)B0HALBA,XLHALBA,YLHALBA,ZLHALBA
          ZLENHAL=ZLHALBA
        ENDIF

        IF (PERHAL.LT.0.) THEN
          ZLHALBA=-ZLENHAL/PERHAL
          XLHALBA= XLHALBA/PERHAL
        ENDIF

        XKHALBA=0.0D0
        YKHALBA=0.0D0
        ZKHALBA=0.0D0

        IF (ZLHALBA.NE.0.0D0) ZKHALBA=2.0D0*PI1/ZLHALBA
        IF (YLHALBA.NE.0.0D0) YKHALBA=2.0D0*PI1/YLHALBA
        IF (XLHALBA.NE.0.0D0) XKHALBA=2.0D0*PI1/XLHALBA

C--- ADJUST K-VALUES

        YKHALBA=DSQRT(ZKHALBA*ZKHALBA+XKHALBA*XKHALBA)
        YLHALBA=2.0D0*PI1/YKHALBA

        IF(PERHAL.GE.0) ZLENHAL=PERHAL*ZLHALBA     !29.10.91

        ZLENHAL2=ZLENHAL/2.0D0

C--- BENDING RADIUS

C21.8.96         RHALBA=DMYGAMMA*EMASSE1/(CLIGHT1*B0HALBA)
        IF (B0HALBA.NE.0.0D0) THEN
          RHALBA=EMOM/(CLIGHT1*B0HALBA)
          COHAL=1.0D0/(ZKHALBA**2*RHALBA)   !CLOSED ORBIT OFFSET
          zamphalba=b0halba*clight1/emom/zkhalba**2
        ELSE
          RHALBA=0.0D0
          COHAL=0.0D0   !CLOSED ORBIT OFFSET
        ENDIF  !(B0HALBA.NE.0.0D0)

        PARK=ECHARGE1*DABS(B0HALBA)*ZLHALBA/(2.*PI1*EMASSKG1*CLIGHT1)
        WLEN1=(1+PARK**2/2.)/2./DMYGAMMA**2*ZLHALBA*1.0D9
        IF (WLEN1.NE.0.0) EHARM1=WTOE1/WLEN1

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '      SR BHALBA: parameters of Halbach wiggler'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '      B0 [T] and corresponding radius [m]:     ',
     &    SNGL(B0HALBA),SNGL(RHALBA)
        WRITE(LUNGFO,*)
     &    '      Length and half length of device [m]:    '
     &    ,SNGL(ZLENHAL),SNGL(ZLENHAL2)
        WRITE(LUNGFO,*)
     &    '      Approximated path amplitude for zero gradient [m]:',
     &    SNGL(zamphalba)
        WRITE(LUNGFO,*)'      L0, L0X, L0Y [m]:'
     &    ,SNGL(ZLHALBA),SNGL(XLHALBA),SNGL(YLHALBA)
        WRITE(LUNGFO,*)'      K, KX, KY [1/m]: '
     &    ,SNGL(ZKHALBA),SNGL(XKHALBA),SNGL(YKHALBA)
        WRITE(LUNGFO,*)
     &    '      Number of periods, closed orbit offset [m]:'
     &    ,SNGL(PERHAL), SNGL(COHAL)
        WRITE(LUNGFO,*)
     &    '      Deflection parameter K, 1. harmonical [eV]:'
     &    ,SNGL(PARK),SNGL(EHARM1)
        WRITE(LUNGFO,*)'      Critical energy [eV]:'
     &    ,SNGL(ecdipev1*DABS(B0HALBA)*DMYENERGY**2)
        WRITE(LUNGFO,*)

        ICAL =1

      ENDIF

      IF (KHALBA.LT.0.AND.ABS(XIN-XCENHALBA).GT.ZLENHAL2) THEN
        BXOUT=0.0D0
        BYOUT=0.0D0
        BZOUT=0.0D0
        AXOUT=0.0D0
        AYOUT=0.0D0
        AZOUT=0.0D0
        RETURN
      ENDIF

      XKX=XKHALBA*(-ZIN)
      YKY=YKHALBA*YIN
      ZKZ=ZKHALBA*(XIN-XCENHALBA)

      DSNXKX=DSIN(XKX)
      DCSXKX=DCOS(XKX)
      DSHYKY=DSINH(YKY)
      DCHYKY=DSQRT(1.0D0+DSHYKY*DSHYKY)
      DSNZKZ=DSIN(ZKZ)
      DCSZKZ=DCOS(ZKZ)

      BXH=-XKHALBA/YKHALBA*B0HALBA*DSNXKX*DSHYKY*DCSZKZ
      BYH=                 B0HALBA*DCSXKX*DCHYKY*DCSZKZ
      BZH=-ZKHALBA/YKHALBA*B0HALBA*DCSXKX*DSHYKY*DSNZKZ

      AXH=B0HALBA/ZKHALBA*                DCSXKX*DCHYKY*DSNZKZ
      AYH=B0HALBA/ZKHALBA*XKHALBA/YKHALBA*DSNXKX*DSHYKY*DSNZKZ
      AZH=0.

      BZOUT=-BXH
      BYOUT=BYH
      BXOUT=BZH

      AZOUT=-AXH
      AYOUT= AYH
      AXOUT= AZH

      RETURN
      END
+DECK,BHALBASY.
*CMZ :  4.00/15 19/03/2022  09.33.42  by  Michael Scheer
*CMZ :  3.05/06 17/07/2018  11.15.16  by  Michael Scheer
*CMZ :  3.05/04 28/06/2018  08.22.42  by  Michael Scheer
*CMZ :  3.03/02 17/12/2015  10.13.22  by  Michael Scheer
*CMZ :  3.01/00 10/04/2013  09.49.08  by  Michael Scheer
*CMZ :  3.00/02 10/04/2013  09.24.32  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.67/04 11/05/2012  11.18.26  by  Michael Scheer
*CMZ :  2.67/02 03/05/2012  09.32.01  by  Michael Scheer
*CMZ :  2.62/04 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.52/06 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.20/09 22/03/2001  13.10.36  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.03.48  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  14.45.16  by  Michael Scheer
*CMZ : 00.01/12 27/09/96  15.28.21  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.47.23  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.59  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BHALBASY(XINI,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT)

+seq,gplhint.

C SUBROUTINE CALCULATES MAGNETIC FIELD AND VECTOR POTENTIAL FOR SIMPLE
C WAVELENGTH SHIFTER MODEL WITH END POLES. THE FIELD OF THE SINGLE POLES
C CORRESPONDS TO HALBACHS FORMULA.
C INPUT AND OUTPUT CORRESPOND TO LAB.-SYSTEM, WHERE X IS COORDINATE ON
C LONGITUDINAL AXIS
C IF FLAG IAHWFOUR IS SET FIELD IS SUPERPOSITION OF HALBACH-WIGGLER
C ACCORDING TO FOURIER EXPANSION OF ON-AXIS FIELD

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,cmpara.
+SEQ,freqs.
+SEQ,HALBASY.

      INTEGER ICAL,NAHWPOL

      DOUBLE PRECISION PARK,WLEN1,EHARM1

      DOUBLE PRECISION XIN,XINI,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT,
     &         XKX,YKY,ZKZ,DSNXKX,DCSXKX,DSHYKY,DCHYKY,DSNZKZ,DCSZKZ
     &        ,BXH,BYH,BZH,AXH,AYH,AZH,AHWMOD,X,TOTLEN,TOTLEN2

+SEQ,PHYCON.

      DATA TOTLEN/1.0d30/
      DATA TOTLEN2/1.0d30/

      DATA ICAL/0/

      IF (ICAL.EQ.0) THEN

        park=pkhalbasy

        if (nhhalbasy.ne.0.and.hhalbasy.ne.0.0d0) then
          if (hhalbasy.eq.-9999.0d0) then
            if (ifreq2p.eq.1) then
              hhalbasy=freqlow
            else
              hhalbasy=(freqlow+freqhig)/2.0d0
            endif
          else if (hhalbasy.lt.0.0d0) then
            hhalbasy=-wtoe1/hhalbasy
          endif
          WLEN1=wtoe1/abs(hhalbasy/nhhalbasy)
          park=2.0d0*(wlen1/(zlhalbasy*1.0D9/2.0d0/DMYGAMMA**2)-1.0d0)
          if (park.lt.0.0d0) then
            write(6,*)
     &        '*** Error in BHALBASY:'
            write(6,*)
     &        'Inconsistent values of NHHALBASY, HHALBASY, and ZLHALBASY'
            write(6,*)' '
            write(lungfo,*)
     &        '*** Error in BHALBASY:'
            write(lungfo,*)
     &        'Inconsistent values of NHHALBASY, HHALBASY, and ZLHALBASY'
            write(lungfo,*)' '
            stop
          endif
          park=sqrt(park)
          pkhalbasy=park
        endif

        IF (park.ne.0.0d0) THEN
          B0halbasy=pkhalbasy/(echarge1*zlhalbasy/(2.*PI1*EMASSKG1*CLIGHT1))
        endif

      endif !ical

      XIN=XINI-XCENHAL

      IF (FASYM.EQ.2.0d0)  THEN
        CALL BHALBASY2(XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT)
        RETURN
      ENDIF


      IF (ICAL.EQ.0) THEN

C--- K-VALUES

         XKHALBASY=0.0d0
         YKHALBASY=0.0d0
         ZKHALBASY=0.0d0

         IF (ZLHALBASY.NE.0.0d0) ZKHALBASY=2.0d0*PI1/ZLHALBASY
         IF (YLHALBASY.NE.0.0d0) YKHALBASY=2.0d0*PI1/YLHALBASY
         IF (XLHALBASY.NE.0.0d0) XKHALBASY=2.0d0*PI1/XLHALBASY

         IF (IAHWFOUR.NE.0 .AND. XLHALBASY.NE.0) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN BHALBASY ***'
            WRITE(LUNGFO,*)
     & 'IF IAHWFOUR IS SET, XLHALBASY MUST BE 0.'
            WRITE(LUNGFO,*)
     & 'SPECIFY THE GRADIENT VIA XLENFOUR IN NAMELIST FOURIER'
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN BHALBASY ***'
            WRITE(6,*)
     & 'IF IAHWFOUR IS SET, XLHALBASY MUST BE 0.'
            WRITE(6,*)
     & 'THE GRADIENT IS GIVEN BY XLENFOUR IN NAMELIST FOURIER'
            WRITE(6,*)
            STOP
         ENDIF

C--- ADJUST K-VALUES

         YKHALBASY=DSQRT(ZKHALBASY**2+XKHALBASY**2)
         YLHALBASY=2.0d0*PI1/YKHALBASY

         IF (KHALBASY.NE.0.OR.IAHWFOUR.NE.0) THEN

C--- BENDING RADIUS AND DEVICE LENGTH

           IF(B0HALBASY.NE.0.0D0) THEN
             RHALBASY=DMYGAMMA*EMASSE1/(CLIGHT1*B0HALBASY)
           ELSE
             RHALBASY=0.0D0
           ENDIF

           TOTLEN=ZLHALBASY*(AHWPOL+FASYM)/2.0d0
           TOTLEN2=TOTLEN/2.0d0

           PARK=ECHARGE1*DABS(B0HALBASY)*ZLHALBASY/(2.*PI1*EMASSKG1*CLIGHT1)
           WLEN1=(1+PARK**2/2.)/2./DMYGAMMA**2*ZLHALBASY*1.0d9
           IF (WLEN1.NE.0.0) EHARM1=WTOE1/WLEN1

           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
     &       '     Parameters of simple wavelength shifter model:'
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
     &       '     peak field [T] and bending radius [m]:  ',
     &       SNGL(B0HALBASY),SNGL(RHALBASY)
           IF (IAHWFOUR.EQ.0) THEN
             WRITE(LUNGFO,*)
     &         '     l0, l0x, l0y [m]: ',
     &         SNGL(ZLHALBASY),SNGL(XLHALBASY),SNGL(YLHALBASY)
             WRITE(LUNGFO,*)
     &         '     k, kx, ky [1/m]:  ',
     &         SNGL(ZKHALBASY),SNGL(XKHALBASY),SNGL(YKHALBASY)
             WRITE(LUNGFO,*)
           ELSE
             WRITE(LUNGFO,*)
     &         '     l0, l0y [m]: ',
     &         SNGL(ZLHALBASY),SNGL(YLHALBASY)
             WRITE(LUNGFO,*)
     &         '     k, ky [1/m]:  ',
     &         SNGL(ZKHALBASY),SNGL(YKHALBASY)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &         '     *** flag IAHWFOUR is set, i.e. global kx is taken'
             WRITE(LUNGFO,*)
     &         '     from XLENFOUR of namelist FOURIER.'
           ENDIF
           WRITE(LUNGFO,*)
     &       '     peak field ratio, total number of poles:',
     &       SNGL(FASYM),NINT(AHWPOL+2.0d0)
           WRITE(LUNGFO,*)
     &       '     total device length, half length:       ',
     &       SNGL(TOTLEN),SNGL(TOTLEN2)
           WRITE(LUNGFO,*)
     &       '     x-position of device center:            ',
     &       SNGL(xcenhal)
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
     &       '      Deflection parameter K, 1. harmonical [eV] (main poles):'
           WRITE(LUNGFO,*)
     &       '     ',SNGL(PARK),SNGL(EHARM1)
           WRITE(LUNGFO,*)'      Critical energy [eV] (main poles):'
     &       ,SNGL(ecdipev1*DABS(B0HALBASY)*DMYENERGY**2)
           WRITE(LUNGFO,*)
         ENDIF

         ICAL=1
       ENDIF

       IF(IAHWFOUR.NE.0) THEN
         CALL BFOUR(XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT)
         RETURN
       ENDIF

       NAHWPOL=AHWPOL
       AHWMOD=ISIGN(1,-(MOD(NAHWPOL,4)-2))

       X=XIN
       IF (DABS(XIN).GT.TOTLEN2) THEN
         BXOUT=0.0d0
         BYOUT=0.0d0
         BZOUT=0.0d0
         AXOUT=0.0d0
         AYOUT=0.0d0
         AZOUT=0.0d0
         RETURN
       ENDIF

       IF (DABS(X).LE.(AHWPOL*ZLHALBASY)/4.) THEN

         XKX=XKHALBASY*(-ZIN)
         YKY=YKHALBASY*YIN
         ZKZ=ZKHALBASY*X

         DSNXKX=DSIN(XKX)
         DCSXKX=DCOS(XKX)
         DSHYKY=DSINH(YKY)
         DCHYKY=DSQRT(1.0d0+DSHYKY*DSHYKY)
         DSNZKZ=DSIN(ZKZ)
         DCSZKZ=DCOS(ZKZ)

         BXH=-XKHALBASY/YKHALBASY*B0HALBASY*DSNXKX*DSHYKY*DCSZKZ
         BYH=                 B0HALBASY*DCSXKX*DCHYKY*DCSZKZ
         BZH=-ZKHALBASY/YKHALBASY*B0HALBASY*DCSXKX*DSHYKY*DSNZKZ

         AXH=B0HALBASY/ZKHALBASY*                    DCSXKX*DCHYKY*DSNZKZ
         AYH=B0HALBASY/ZKHALBASY*XKHALBASY/YKHALBASY*DSNXKX*DSHYKY*DSNZKZ
         AZH=0.0d0

         BZOUT=-BXH
         BYOUT=BYH
         BXOUT=BZH

         AZOUT=-AXH
         AYOUT=AYH
         AXOUT=AZH

         RETURN

       ELSE IF (X.GT.(AHWPOL*ZLHALBASY)/4.) THEN

         XKX=XKHALBASY*(-ZIN/FASYM*2.)
         YKY=YKHALBASY*YIN/FASYM*2.
         ZKZ=(X*ZKHALBASY-AHWPOL*PI1/2.)/FASYM*2.-PI1/2.

         DSNXKX=DSIN(XKX)
         DCSXKX=DCOS(XKX)
         DSHYKY=DSINH(YKY)
         DCHYKY=DSQRT(1.0d0+DSHYKY*DSHYKY)
         DSNZKZ=DSIN(ZKZ)
         DCSZKZ=DCOS(ZKZ)

         BXH=-XKHALBASY/YKHALBASY*B0HALBASY/(-FASYM)*DSNXKX*DSHYKY*DCSZKZ
         BYH=                 B0HALBASY/(-FASYM)*DCSXKX*DCHYKY*DCSZKZ
         BZH=-ZKHALBASY/YKHALBASY*B0HALBASY/(-FASYM)*DCSXKX*DSHYKY*DSNZKZ

         AXH=B0HALBASY/(-FASYM)/ZKHALBASY*           DCSXKX*DCHYKY*DSNZKZ
         AYH=B0HALBASY/(-FASYM)/ZKHALBASY*XKHALBASY/YKHALBASY
     &     *DSNXKX*DSHYKY*DSNZKZ
         AZH=0.0d0

         BZOUT=-BXH*AHWMOD
         BYOUT=BYH*AHWMOD
         BXOUT=BZH*AHWMOD

         AZOUT=-AXH*AHWMOD
         AYOUT=AYH*AHWMOD
         AXOUT=AZH*AHWMOD

         RETURN

       ELSE

         XKX=XKHALBASY*(-ZIN/FASYM*2.)
         YKY=YKHALBASY*YIN/FASYM*2.
         ZKZ=((X*ZKHALBASY+AHWPOL*PI1/2.)/FASYM*2.+PI1/2.)

         DSNXKX=DSIN(XKX)
         DCSXKX=DCOS(XKX)
         DSHYKY=DSINH(YKY)
         DCHYKY=DSQRT(1.0d0+DSHYKY*DSHYKY)
         DSNZKZ=DSIN(ZKZ)
         DCSZKZ=DCOS(ZKZ)

         BXH=-XKHALBASY/YKHALBASY*B0HALBASY/(-FASYM)*DSNXKX*DSHYKY*DCSZKZ
         BYH=                 B0HALBASY/(-FASYM)*DCSXKX*DCHYKY*DCSZKZ
         BZH=-ZKHALBASY/YKHALBASY*B0HALBASY/(-FASYM)*DCSXKX*DSHYKY*DSNZKZ

         AXH=B0HALBASY/(-FASYM)/ZKHALBASY*           DCSXKX*DCHYKY*DSNZKZ
         AYH=B0HALBASY/(-FASYM)/ZKHALBASY*XKHALBASY/YKHALBASY
     &     *DSNXKX*DSHYKY*DSNZKZ
         AZH=0.0d0

         BZOUT=-BXH*AHWMOD
         BYOUT=BYH*AHWMOD
         BXOUT=BZH*AHWMOD

         AZOUT=-AXH*AHWMOD
         AYOUT=AYH*AHWMOD
         AXOUT=AZH*AHWMOD

         RETURN

       ENDIF

      END
+DECK,BHALBASY2.
*CMZ :  4.00/15 24/03/2022  07.14.23  by  Michael Scheer
*CMZ :  3.05/06 17/07/2018  11.15.16  by  Michael Scheer
*CMZ :  3.05/04 28/06/2018  08.21.29  by  Michael Scheer
*CMZ :  3.04/00 16/01/2018  10.03.31  by  Michael Scheer
*CMZ :  3.03/02 17/12/2015  10.12.49  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.67/04 11/05/2012  11.18.26  by  Michael Scheer
*CMZ :  2.62/04 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.20/09 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.03.48  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  14.45.16  by  Michael Scheer
*CMZ : 00.01/12 27/09/96  15.28.21  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.47.23  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.59  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BHALBASY2(XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT)

+seq,gplhint.

C SUBROUTINE CALCULATES MAGNETIC FIELD AND VECTOR POTENTIAL FOR SIMPLE
C WAVELENGTH SHIFTER MODEL WITH END POLES. THE FIELD OF THE SINGLE POLES
C CORRESPONDS TO HALBACHS FORMULA.
C INPUT AND OUTPUT CORRESPOND TO LAB.-SYSTEM, WHERE X IS COORDINATE ON
C LONGITUDINAL AXIS
C IF FLAG IAHWFOUR IS SET FIELD IS SUPERPOSITION OF HALBACH-WIGGLER
C ACCORDING TO FOURIER EXPANSION OF ON-AXIS FIELD

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,HALBASY.

      INTEGER ICAL,NAHWPOL

      DOUBLE PRECISION PARK,WLEN1,EHARM1

      DOUBLE PRECISION XKHALBASY2,YKHALBASY2,ZKHALBASY2,ZLHALBASY2,X2

      DOUBLE PRECISION XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT,
     &         XKX,YKY,ZKZ,DSNXKX,DCSXKX,DSHYKY,DCHYKY,DSNZKZ,DCSZKZ
     &        ,BXH,BYH,BZH,AXH,AYH,AZH,AHWMOD,X,TOTLEN,TOTLEN2

+SEQ,PHYCON.

      DATA TOTLEN/1.D30/
      DATA TOTLEN2/1.D30/

      DATA ICAL/0/

C--- K-VALUES

      XKHALBASY=0.0D0
      YKHALBASY=0.0D0
      ZKHALBASY=0.0D0

      IF (ZLHALBASY.NE.0.0D0) ZKHALBASY=2.D0*PI1/ZLHALBASY
      IF (YLHALBASY.NE.0.0D0) YKHALBASY=2.D0*PI1/YLHALBASY
      IF (XLHALBASY.NE.0.0D0) XKHALBASY=2.D0*PI1/XLHALBASY

      IF (IAHWFOUR.NE.0 .AND. XLHALBASY.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN BHALBASY2 ***'
        WRITE(LUNGFO,*)
     &    'IF IAHWFOUR IS SET, XLHALBASY MUST BE 0.0'
        WRITE(LUNGFO,*)
     &    'SPECIFY THE GRADIENT VIA XLENFOUR IN NAMELIST FOURIER'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN BHALBASY2 ***'
        WRITE(6,*)
     &    'IF IAHWFOUR IS SET, XLHALBASY MUST BE 0.0'
        WRITE(6,*)
     &    'THE GRADIENT IS GIVEN BY XLENFOUR IN NAMELIST FOURIER'
        WRITE(6,*)
        STOP
      ENDIF

C--- ADJUST K-VALUES

      YKHALBASY=DSQRT(ZKHALBASY**2+XKHALBASY**2)
      YLHALBASY=2.D0*PI1/YKHALBASY

      IF (KHALBASY.NE.0.OR.IAHWFOUR.NE.0) THEN

C--- BENDING RADIUS AND DEVICE LENGTH

        IF(B0HALBASY.NE.0.00D0) THEN
          RHALBASY=DMYGAMMA*EMASSE1/(CLIGHT1*B0HALBASY)
        ELSE
          RHALBASY=0.00D0
        ENDIF

        PARK=ECHARGE1*DABS(B0HALBASY)*ZLHALBASY/(2.*PI1*EMASSKG1*CLIGHT1)
        WLEN1=(1+PARK**2/2.)/2./DMYGAMMA**2*ZLHALBASY*1.D9

        TOTLEN=ZLHALBASY*((AHWPOL-1.D0)/2.D0+1.D0)
        TOTLEN2=TOTLEN/2.D0

        IF (WLEN1.NE.0.00) EHARM1=WTOE1/WLEN1

        IF (ICAL.EQ.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     Parameters of simple wavelength shifter model:'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     peak field [T] and bending radius [m]:  ',
     &      SNGL(B0HALBASY),SNGL(RHALBASY)
          IF (IAHWFOUR.EQ.0) THEN
            WRITE(LUNGFO,*)
     &        '     l0, l0x, l0y [m]: ',
     &        SNGL(ZLHALBASY),SNGL(XLHALBASY),SNGL(YLHALBASY)
            WRITE(LUNGFO,*)
     &        '     k, kx, ky [1/m]:  ',
     &        SNGL(ZKHALBASY),SNGL(XKHALBASY),SNGL(YKHALBASY)
            WRITE(LUNGFO,*)
          ELSE
            WRITE(LUNGFO,*)
     &        '     l0, l0y [m]: ',
     &        SNGL(ZLHALBASY),SNGL(YLHALBASY)
            WRITE(LUNGFO,*)
     &        '     k, ky [1/m]:  ',
     &        SNGL(ZKHALBASY),SNGL(YKHALBASY)
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '     *** flag IAHWFOUR is set, i.e. global kx is taken'
            WRITE(LUNGFO,*)
     &        '     from XLENFOUR of namelist FOURIER.'
          ENDIF
          WRITE(LUNGFO,*)
     &      '     peak field ratio, total number of poles:',
     &      SNGL(FASYM),NINT(AHWPOL+2.D0)
          WRITE(LUNGFO,*)
     &      '     total device length, half length:       ',
     &      SNGL(TOTLEN),SNGL(TOTLEN2)
          WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
     &       '     x-position of device center:            ',
     &       SNGL(xcenhal)
          WRITE(LUNGFO,*)
     &      '      Deflection parameter K, 1. harmonical [eV] (main poles):'
          WRITE(LUNGFO,*)
     &      '     ',SNGL(PARK),SNGL(EHARM1)
          WRITE(LUNGFO,*)'      Critical energy [eV] (main poles):'
     &      ,SNGL(ecdipev1*DABS(B0HALBASY)*DMYENERGY**2)
          WRITE(LUNGFO,*)
        ENDIF

        ICAL=1
      ENDIF

      TOTLEN=ZLHALBASY*((AHWPOL-1.D0)/2.D0+1.D0)
      TOTLEN2=TOTLEN/2.D0

      IF(IAHWFOUR.NE.0) THEN
          CALL BFOUR(XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT)
          RETURN
      ENDIF

      NAHWPOL=AHWPOL
      AHWMOD=-ISIGN(1,-(MOD(NAHWPOL,4)-2))/2.D0

      X=XIN
      IF (DABS(XIN).GT.TOTLEN2) THEN
          BXOUT=0.0
          BYOUT=0.0
          BZOUT=0.0
          AXOUT=0.0
          AYOUT=0.0
          AZOUT=0.0
          RETURN
      ENDIF

      IF (DABS(X).LE.TOTLEN2-ZLHALBASY/2.D0) THEN

          XKX=XKHALBASY*(-ZIN)
          YKY=YKHALBASY*YIN
          ZKZ=ZKHALBASY*X

          DSNXKX=DSIN(XKX)
          DCSXKX=DCOS(XKX)
          DSHYKY=DSINH(YKY)
          DCHYKY=DSQRT(1.D0+DSHYKY*DSHYKY)
          DSNZKZ=DSIN(ZKZ)
          DCSZKZ=DCOS(ZKZ)


          BXH=-XKHALBASY/YKHALBASY*B0HALBASY*DSNXKX*DSHYKY*DCSZKZ
          BYH=                 B0HALBASY*DCSXKX*DCHYKY*DCSZKZ
          BZH=-ZKHALBASY/YKHALBASY*B0HALBASY*DCSXKX*DSHYKY*DSNZKZ

          AXH=B0HALBASY/ZKHALBASY*                    DCSXKX*DCHYKY*DSNZKZ
          AYH=B0HALBASY/ZKHALBASY*XKHALBASY/YKHALBASY*DSNXKX*DSHYKY*DSNZKZ
          AZH=0.0

          BZOUT=-BXH
          BYOUT=BYH
          BXOUT=BZH

          AZOUT=-AXH
          AYOUT=AYH
          AXOUT=AZH

          RETURN

      ELSE

        XKHALBASY2=XKHALBASY

        ZKHALBASY2=ZKHALBASY
        ZLHALBASY2=2.D0*PI1/ZKHALBASY2
          YKHALBASY2=DSQRT(ZKHALBASY2**2+XKHALBASY2**2)
          YLHALBASY=2.D0*PI1/YKHALBASY2

        X2=X+TOTLEN2+ZLHALBASY/2.D0

          XKX=XKHALBASY2*(-ZIN)
          YKY=YKHALBASY2*YIN
          ZKZ=ZKHALBASY2*(X2)

          DSNXKX=DSIN(XKX)
          DCSXKX=DCOS(XKX)
          DSHYKY=DSINH(YKY)
          DCHYKY=DSQRT(1.D0+DSHYKY*DSHYKY)
          DSNZKZ=DSIN(ZKZ)
          DCSZKZ=DCOS(ZKZ)

          BXH=-XKHALBASY2/YKHALBASY2*B0HALBASY*DSNXKX*DSHYKY*DCSZKZ
          BYH=                 B0HALBASY*DCSXKX*DCHYKY*DCSZKZ
          BZH=-ZKHALBASY2/YKHALBASY2*B0HALBASY*DCSXKX*DSHYKY*DSNZKZ

          AXH=B0HALBASY/ZKHALBASY2*                    DCSXKX*DCHYKY*DSNZKZ
          AYH=B0HALBASY/ZKHALBASY2*XKHALBASY2/YKHALBASY2*DSNXKX*DSHYKY*DSNZKZ
          AZH=0.0

          ZKHALBASY2=ZKHALBASY*2.D0
          ZLHALBASY2=2.D0*PI1/ZKHALBASY2
          YKHALBASY2=DSQRT(ZKHALBASY2**2+XKHALBASY2**2)
          YLHALBASY=2.D0*PI1/YKHALBASY2

          XKX=XKHALBASY2*(-ZIN)
          YKY=YKHALBASY2*YIN
          ZKZ=ZKHALBASY2*(X2)

          DSNXKX=DSIN(XKX)
          DCSXKX=DCOS(XKX)
          DSHYKY=DSINH(YKY)
          DCHYKY=DSQRT(1.D0+DSHYKY*DSHYKY)
          DSNZKZ=DSIN(ZKZ)
          DCSZKZ=DCOS(ZKZ)

          BXH=BXH-XKHALBASY2/YKHALBASY2*B0HALBASY*DSNXKX*DSHYKY*DCSZKZ
          BYH=BYH+                      B0HALBASY*DCSXKX*DCHYKY*DCSZKZ
          BZH=BZH-ZKHALBASY2/YKHALBASY2*B0HALBASY*DCSXKX*DSHYKY*DSNZKZ

          AXH=AXH+B0HALBASY/ZKHALBASY2*                    DCSXKX*DCHYKY*DSNZKZ
          AYH=AYH+B0HALBASY/ZKHALBASY2*XKHALBASY2/YKHALBASY2*DSNXKX*DSHYKY*DSNZKZ
          AZH=0.0

          BZOUT=BXH*AHWMOD
          BYOUT=-BYH*AHWMOD
          BXOUT=-BZH*AHWMOD

          AZOUT=AXH*AHWMOD
          AYOUT=-AYH*AHWMOD
          AXOUT=-AZH*AHWMOD

      RETURN

      ENDIF

      END
+DECK,BHARD.
*CMZ :  3.05/11 14/08/2018  12.28.54  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.52/11 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  2.13/09 08/03/2000  17.28.37  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  11.36.07  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.47.27  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.33  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BHARD(XS,XE,GAMMA,ZI,ZIP,YI,YIP,      ZF,ZFP,YF,YFP)

+seq,gplhint.

C--- SUBROUTINE BERECHNET ZUNAECHST DIE LINEARE TRANSFERMATRIX EINES HARD-EDGE
C             WLS UND DANN BEI JEDEM AUFRUF DIE AUS DEN KOORDINATEN XI,XIP...
C        DIE ENDKOORDINATEN XF,XFP,...

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,BFELD.

      INTEGER ICAL,IMAT,ICOMP,IMAG,JMAG,I,IDRIFT
      DOUBLE PRECISION T3,DL,DL0,RHO,DPHI,XVI,XVF,EMASS,CLIGHT,XI,ZI,XIP,ZIP
     &        ,TWORK,XS,XE,XF,ZF,ZFP,XFP,YF,YFP,YI,YIP,GAMMA,P

        DIMENSION T3(4,4,29) !TRANSFER-MATRIZEN FUER 7 RECHTECKMAG. INCL.
        !WEDGES UND 6 DRIFTS
     &    ,TWORK(4*4*29)

        DIMENSION DL(7),    !LAENGE DER BAHN IM MAGNETEN
     &    DL0(7),   !LAENGE DES MAGNETEN
     &    RHO(7),   !BAHNRADIUS IM MAGNETEN
     &    DPHI(7),  !WINKELAENDERUNG IM MAGNETEN
     &        XVI(4),XVF(4) !HILFSVEKTOREN

      EQUIVALENCE (T3,TWORK)

      DATA ICAL/0/

      DATA EMASS /0.5110034D-3/
      DATA CLIGHT/2.99792458D8/

C--- KOORDINATEN-SYSTEM WECHSELN

      XI=-ZI
      XIP=-ZIP

C---------  ICAL .NE. 1  ----------------------------------------------------
      IF (ICAL.NE.1) THEN  !MATRIX BERECHEN AUS DATEN VON NAMELIST BBFELD

        IF(XS.GT.XM1.OR.XE.LT.XP7)
     &    STOP'*** SR BHARD: XSTART.GT.XM1.OR.XEND.LT.XP7 ***'

C        IN DIESEM FALL NUR 5 MATRIZEN KORREKT
      IF(IKBFORM.NE.0)
     &  STOP '*** STOP SR BHARD: IKBFORM.NE.0 ***'

C--- BERECHNE FUER JEDEN MAGNETEN RHO, LAENGE DER BAHN UND ABLENKWINKEL

          DL0(1)=XP1-XM1
          DL0(2)=XP2-XM2
          DL0(3)=XP3-XM3
          DL0(4)=XP4-XM4
          DL0(5)=XP5-XM5
          DL0(6)=XP6-XM6
          DL0(7)=XP7-XM7

          P=GAMMA*EMASS*1.D9    !IMPULS IN eV


          DO I=1,7
         RHO(I)=0.D0
            ENDDO

          IF(BBY1.NE.0.D0) RHO(1)=P/(CLIGHT*BBY1) !RHO KANN NEGATIV SEIN
          IF(BBY2.NE.0.D0) RHO(2)=P/(CLIGHT*BBY2)
          IF(BBY3.NE.0.D0) RHO(3)=P/(CLIGHT*BBY3)
          IF(BBY4.NE.0.D0) RHO(4)=P/(CLIGHT*BBY4)
          IF(BBY5.NE.0.D0) RHO(5)=P/(CLIGHT*BBY5)
          IF(BBY6.NE.0.D0) RHO(6)=P/(CLIGHT*BBY6)
          IF(BBY7.NE.0.D0) RHO(7)=P/(CLIGHT*BBY7)

          DO I=1,4*4*25
         TWORK(I)=0.D0
          ENDDO

C--- DRIFTS
          DO IDRIFT=1,29,4
         T3(1,1,IDRIFT)=1.D0
         T3(2,2,IDRIFT)=1.D0
         T3(3,3,IDRIFT)=1.D0
         T3(4,4,IDRIFT)=1.D0
          END DO

          T3(1,2,1) = XM1-XS
          T3(3,4,1) = XM1-XS

          T3(1,2,5) = XM2-XP1
          T3(3,4,5) = XM2-XP1
          T3(1,2,9) = XM3-XP2
          T3(3,4,9) = XM3-XP2
          T3(1,2,13)= XM4-XP3
          T3(3,4,13)= XM4-XP3
          T3(1,2,17)= XM5-XP4
          T3(3,4,17)= XM5-XP4
          T3(1,2,21)= XM6-XP5
          T3(3,4,21)= XM6-XP5
          T3(1,2,25)= XM7-XP6
          T3(3,4,25)= XM7-XP6

          T3(1,2,29)= XE-XP7
          T3(3,4,29)= XE-XP7

C--- MAGNETE (SECTOR)

          DO I=1,7
            IF(RHO(I).NE.0.D0) THEN
              DPHI(I)=2.D0*DASIN(DL0(I)/(2.D0*RHO(I)))
              DL(I)=RHO(I)*DPHI(I)
            ELSE
              DL(I)=DL0(I)
              DPHI(I)=0.D0
            ENDIF
          ENDDO

          JMAG=0
          DO IMAG=3,27,4
             JMAG=JMAG+1
             T3(1,1,IMAG)=DCOS(DPHI(JMAG))
             T3(2,2,IMAG)=T3(1,1,IMAG)
             T3(1,2,IMAG)=DL0(JMAG)

             IF(RHO(JMAG).NE.0.0) THEN
               T3(1,2,IMAG)=RHO(JMAG)*DSIN(DPHI(JMAG))
               T3(2,1,IMAG)=-DSIN(DPHI(JMAG))/RHO(JMAG)
             ENDIF

             T3(3,3,IMAG)=1.D0
             T3(4,4,IMAG)=1.D0
             T3(3,4,IMAG)=DL(JMAG)
          ENDDO

C--- WEDGES; DER WINKEL DES KEILES WIRD UEBER DEN EINGELESENEN FAKTOR AUS DPHI
C            BERECHNET

          JMAG=0
          DO I=3,27,4
             JMAG=JMAG+1
             T3(1,1,I-1)=1.D0
             T3(2,2,I-1)=1.D0
             T3(3,3,I-1)=1.D0
             T3(4,4,I-1)=1.D0
             T3(1,1,I+1)=1.D0
             T3(2,2,I+1)=1.D0
             T3(3,3,I+1)=1.D0
             T3(4,4,I+1)=1.D0

          IF (RHO(JMAG).NE.0.0)
     &        T3(2,1,I-1)= DTAN(WEDFACL(JMAG)*DPHI(JMAG))/RHO(JMAG)
          IF (RHO(JMAG).NE.0.0)
     &        T3(2,1,I+1)= DTAN(WEDFACR(JMAG)*DPHI(JMAG))/RHO(JMAG)
          IF (RHO(JMAG).NE.0.0)
     &        T3(4,3,I-1)=-DTAN(WEDFACL(JMAG)*DPHI(JMAG))/RHO(JMAG)
          IF (RHO(JMAG).NE.0.0)
     &        T3(4,3,I+1)=-DTAN(WEDFACR(JMAG)*DPHI(JMAG))/RHO(JMAG)
          ENDDO


      END IF
C---------  ICAL .NE. 1  ----------------------------------------------------

C--- XF,XFP... BERECHNEN

      XVI(1)=XI
      XVI(2)=XIP
      XVI(3)=YI
      XVI(4)=YIP

      DO IMAT=1,29
        DO ICOMP=1,4
          XVF(ICOMP)=
     &      T3(ICOMP,1,IMAT)*XVI(1)+T3(ICOMP,2,IMAT)*XVI(2)+
     &      T3(ICOMP,3,IMAT)*XVI(3)+T3(ICOMP,4,IMAT)*XVI(4)
        END DO
        DO ICOMP=1,4
          XVI(ICOMP)=XVF(ICOMP)
        ENDDO
      END DO

      XF=XVF(1)
      XFP=XVF(2)
      YF=XVF(3)
      YFP=XVF(4)

C--- KOORDINATEN-SYSTEM WECHSELN

      ZF=-XF
      ZFP=-XFP

      ICAL=1

      RETURN
      END
+DECK,BHARM.
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  1.03/06 11/06/98  13.46.47  by  Michael Scheer
*CMZ : 00.01/08 04/04/95  17.31.58  by  Michael Scheer
*CMZ : 00.01/03 28/11/94  13.20.41  by  Michael Scheer
*CMZ :  0.00/03 14/11/94  12.38.33  by  Michael Scheer
*CMZ :  0.00/02 02/11/94  11.28.11  by  Michael Scheer
*CMZ :  0.00/01 31/10/94  09.48.00  by  Michael Scheer
*CMZ :  0.00/00 28/10/94  16.14.51  by  Michael Scheer
*-- Author :    Michael Scheer   28/10/94
C***************************************************************
        SUBROUTINE BHARM(X,Y,Z,BX,BY,BZ
     &  ,NFIRSTX,NORDX,NSTEPX
     &  ,NFIRSTY,NORDY,NSTEPY
     &  ,Q,QA0,QA,NQDIM,XKX,YKY,ZKZ,IFHALBA,GAP2PI,WIDTH)

+seq,gplhint.

      IMPLICIT NONE

      INTEGER NDUMP
      PARAMETER (NDUMP=1000)

      INTEGER NFIRSTX,NORDX,NSTEPX,NFIRSTY,NORDY,NSTEPY,NQDIM
      INTEGER IORDX,IORDY
      INTEGER IFHALBA

        DOUBLE PRECISION DUM,DXC,DXS

      DOUBLE PRECISION GAP2PI,WIDTH

      DOUBLE PRECISION X,Y,Z,BX,BY,BZ,Q(NQDIM,NQDIM),XKX,YKY,ZKZ
      DOUBLE PRECISION QA0(NQDIM),QA(NQDIM,NQDIM)

      DOUBLE PRECISION XSIN(NDUMP),XCOS(NDUMP)
      DOUBLE PRECISION YSINH(NDUMP),YCOSH(NDUMP)
      DOUBLE PRECISION ZSIN(NDUMP),ZCOS(NDUMP)
      DOUBLE PRECISION ZIJC,ZIJS,YIJC,YIJS,XKIJ,ZKIJ,RKIJ


      IF (NQDIM.GT.NDUMP) THEN
      WRITE(6,*)'*** ERROR IN BHARM: DIMENSION EXCEEDED ***'
      STOP
      ENDIF

      IF (IFHALBA.NE.0) THEN

      CALL B_FIELD(X,Y,Z,Bx,By,Bz,QA0,QA,GAP2PI,ZKZ,width,
     &             NFIRSTX,NORDX,NSTEPX,NFIRSTY,NORDY,NSTEPY,NQDIM)

      ELSE  !IFHALBA

      BX=0.0
      BY=0.0
      BZ=0.0

      IF (YKY.GT.0.0) THEN

      WRITE(6,*)'ADDITIONSTHEOREME EINBAUEN'
        DO IORDY=NFIRSTY,NORDY,NSTEPY
          YCOSH(IORDY)=DCOSH(Y*(IORDY-1)*YKY)
          YSINH(IORDY)=DSINH(Y*(IORDY-1)*YKY)
        ENDDO

        DO IORDX=NFIRSTX,NORDX,NSTEPX
          XCOS(IORDX)=DCOS(X*(IORDX-1)*XKX)
          XSIN(IORDY)=DSIN(X*(IORDX-1)*XKX)
        ENDDO

        DO IORDX=NFIRSTX,NORDX,NSTEPX
        DO IORDY=NFIRSTY,NORDY,NSTEPY

          IF ((((IORDY-1)*YKY)**2-((IORDX-1)*XKX)**2).GE.0.0) THEN
            RKIJ=(IORDY-1)*YKY
            XKIJ=(IORDX-1)*XKX
            ZKIJ=DSQRT(((IORDY-1)*YKY)**2-((IORDX-1)*XKX)**2)
            ZIJC=DCOS (Z*ZKIJ)
            ZIJS=DSIN (Z*ZKIJ)
          ELSE
            RKIJ=1.E-30
            XKIJ=0.0
            ZKIJ=0.0
            YCOSH(IORDY)=0.0
            YSINH(IORDY)=0.0
            ZIJC=0.0
            ZIJS=0.0
          ENDIF

          BX=BX-XKIJ/RKIJ*Q(IORDX,IORDY)*XSIN(IORDX)*YSINH(IORDY)*ZIJC
          BY=BY+          Q(IORDX,IORDY)*XCOS(IORDX)*YCOSH(IORDY)*ZIJC
          BZ=BZ-ZKIJ/RKIJ*Q(IORDX,IORDY)*XCOS(IORDX)*YSINH(IORDY)*ZIJS

        ENDDO
        ENDDO

      ENDIF   !YKY>0

      IF (YKY.LT.0.0) THEN


        DUM=X*(NFIRSTX-1)*XKX
        XCOS(NFIRSTX)=DCOS(DUM)
        XSIN(NFIRSTX)=DSIN(DUM)
        DUM=X*NSTEPX*XKX
        DXC=DCOS(DUM)
        DXS=DSIN(DUM)

        DO IORDX=NFIRSTX+NSTEPX,NORDX,NSTEPX
          XCOS(IORDX)=XCOS(IORDX-NSTEPX)*DXC-XSIN(IORDX-NSTEPX)*DXS
          XSIN(IORDX)=XCOS(IORDX-NSTEPX)*DXS+XSIN(IORDX-NSTEPX)*DXC
        ENDDO

C        DO IORDX=NFIRSTX,NORDX,NSTEPX
C          XCOS(IORDX)=DCOS (X*(IORDX-1)*XKX)
C          XSIN(IORDX)=DSIN (X*(IORDX-1)*XKX)
C        ENDDO

        DUM=Z*(NFIRSTY-1)*ZKZ
        ZCOS(NFIRSTY)=DCOS(DUM)
        ZSIN(NFIRSTY)=DSIN(DUM)
        DUM=Z*NSTEPY*ZKZ
        DXC=DCOS(DUM)
        DXS=DSIN(DUM)

        DO IORDY=NFIRSTY+NSTEPY,NORDY,NSTEPY
          ZCOS(IORDY)=ZCOS(IORDY-NSTEPY)*DXC-ZSIN(IORDY-NSTEPY)*DXS
          ZSIN(IORDY)=ZCOS(IORDY-NSTEPY)*DXS+ZSIN(IORDY-NSTEPY)*DXC
        ENDDO

C        DO IORDY=NFIRSTY,NORDY,NSTEPY
C          ZCOS(IORDY)=DCOS (Z*(IORDY-1)*ZKZ)
C          ZSIN(IORDY)=DSIN (Z*(IORDY-1)*ZKZ)
C        ENDDO

        DO IORDX=NFIRSTX,NORDX,NSTEPX
        DO IORDY=NFIRSTY,NORDY,NSTEPY
          RKIJ=DSQRT(((IORDY-1)*ZKZ)**2+((IORDX-1)*XKX)**2)
          XKIJ=(IORDX-1)*XKX
          ZKIJ=(IORDY-1)*ZKZ
          YIJS=DSINH(Y*RKIJ)
C          YIJC=DCOSH(Y*RKIJ)
          YIJC=DSQRT(1.D0+YIJS**2)
          BX=BX-XKIJ/RKIJ*Q(IORDX,IORDY)*XSIN(IORDX)*YIJS*ZCOS(IORDY)
          BY=BY+          Q(IORDX,IORDY)*XCOS(IORDX)*YIJC*ZCOS(IORDY)
          BZ=BZ-ZKIJ/RKIJ*Q(IORDX,IORDY)*XCOS(IORDX)*YIJS*ZSIN(IORDY)
        ENDDO
        ENDDO

      ELSEIF (YKY.EQ.0.0) THEN
      WRITE(6,*)'*** ERROR IN BHARM: YKY=0.0 ?? ***'
        STOP
      ENDIF   !YKY.LT.0

      RETURN
      ENDIF !IFHALBA

      END
+DECK,bhelitrieste.
*CMZ :  2.41/10 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  17.27.12  by  Michael Scheer
*CMZ :  2.14/02 19/04/2000  17.02.45  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  11.45.40  by  Michael Scheer
*CMZ : 00.02/01 17/12/96  12.01.36  by  Michael Scheer
*-- Author :    Michael Scheer   16/12/96

      SUBROUTINE BHELITRIESTE(XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT)

+seq,gplhint.

C     MAGNETIC FIELD ACCORDING TO POLYNOMIAL FIT
C     TRANSVERSALLY AND HARMONICS IN LONGITUDINALLY
C
C     INPUT/OUTPUT COORDINATE SYSTEM: X LONG., Y VERTICAL
C     INTERNAL COORDINATE SYSTEM: Z LONG., Y VERTICAL
C
C     UNIT: METER AND TESLA
C

      IMPLICIT NONE

+SEQ,CONTRL.

      INTEGER ICAL,LUNIN

      DOUBLE PRECISION PI
      DOUBLE PRECISION XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT
      DOUBLE PRECISION X,Y,Z,BX,BY,BZ,BXH,BXV,BYH,BYV,BZH,BZV
      DOUBLE PRECISION X2,X4,X6,Y2,Y4,Y6
      DOUBLE PRECISION ZL,ZK,ZK2,SINZKZ,SINZKZ3,COSZKZ,COSZKZ3

+SELF,IF=-NOCMPLX.
      COMPLEX*16 CZKZ,CZKZ3
+SELF,IF=NOCMPLX.
       DOUBLE PRECISION ZKZ
+SELF.

      DOUBLE PRECISION BH1,B2H1,C3H1,D4H1
      DOUBLE PRECISION BH3,B2H3,C3H3,D4H3
      DOUBLE PRECISION BV1,B2V1,C3V1,D4V1
      DOUBLE PRECISION BV3,B2V3,C3V3,D4V3

      DOUBLE PRECISION A2H1,B3H1,C4H1,A3H1,B4H1,A4H1
      DOUBLE PRECISION A2V1,B3V1,C4V1,A3V1,B4V1,A4V1
      DOUBLE PRECISION A2H3,B3H3,C4H3,A3H3,B4H3,A4H3
      DOUBLE PRECISION A2V3,B3V3,C4V3,A3V3,B4V3,A4V3

      CHARACTER(64) COMMENT,FILEIN

      DATA ICAL/0/

      DATA LUNIN/10/
      DATA FILEIN/'HELI_TRIESTE.FIT'/
      DATA PI/3.141592653589793D0/

C--- INITIALIZATION

      IF (ICAL.EQ.0) THEN

         OPEN(UNIT=LUNIN,FILE=FILEIN,STATUS='OLD')

            READ(LUNIN,'(A64)')COMMENT

            READ(LUNIN,*)ZL

            READ(LUNIN,*)BH1
            READ(LUNIN,*)B2H1
            READ(LUNIN,*)C3H1
            READ(LUNIN,*)D4H1
            READ(LUNIN,*)BH3
            READ(LUNIN,*)B2H3
            READ(LUNIN,*)C3H3
            READ(LUNIN,*)D4H3

            READ(LUNIN,*)BV1
            READ(LUNIN,*)B2V1
            READ(LUNIN,*)C3V1
            READ(LUNIN,*)D4V1
            READ(LUNIN,*)BV3
            READ(LUNIN,*)B2V3
            READ(LUNIN,*)C3V3
            READ(LUNIN,*)D4V3

            WRITE(LUNGFO,*)'     SUBROUTINE BHELITRIESTE:'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     COEFFICENT FILE:'
            WRITE(LUNGFO,'(''      '',A64)')FILEIN
            WRITE(LUNGFO,*)'     COMMENT:'
            WRITE(LUNGFO,'(''      '',A64)')COMMENT
            WRITE(LUNGFO,*)

            WRITE(LUNGFO,*)'     Z-Lambda:',ZL
            WRITE(LUNGFO,*)

            WRITE(LUNGFO,*)'     COEFFICIENTS:'
            WRITE(LUNGFO,*)'     ',BH1
            WRITE(LUNGFO,*)'     ',B2H1
            WRITE(LUNGFO,*)'     ',C3H1
            WRITE(LUNGFO,*)'     ',D4H1
            WRITE(LUNGFO,*)'     ',BH3
            WRITE(LUNGFO,*)'     ',B2H3
            WRITE(LUNGFO,*)'     ',C3H3
            WRITE(LUNGFO,*)'     ',D4H3

            WRITE(LUNGFO,*)'     ',BV1
            WRITE(LUNGFO,*)'     ',B2V1
            WRITE(LUNGFO,*)'     ',C3V1
            WRITE(LUNGFO,*)'     ',D4V1
            WRITE(LUNGFO,*)'     ',BV3
            WRITE(LUNGFO,*)'     ',B2V3
            WRITE(LUNGFO,*)'     ',C3V3
            WRITE(LUNGFO,*)'     ',D4V3

         CLOSE(LUNIN)

         ZK=2.D0*PI/ZL
         ZK2=ZK*ZK

         A2H1=(ZK2     - 2.D0*B2H1)/6.D0
         B3H1=(ZK2*B2H1-12.D0*C3H1)/6.D0
         C4H1=(ZK2*C3H1-30.D0*D4H1)/6.D0
         A3H1=(ZK2*A2H1- 2.D0*B3H1)/20.D0
         B4H1=(ZK2*B3H1-12.D0*C4H1)/20.D0
         A4H1=(ZK2*A3H1- 2.D0*B4H1)/42.D0

         A2H3=(9.D0*ZK2     - 2.D0*B2H3)/6.D0
         B3H3=(9.D0*ZK2*B2H3-12.D0*C3H3)/6.D0
         C4H3=(9.D0*ZK2*C3H3-30.D0*D4H3)/6.D0
         A3H3=(9.D0*ZK2*A2H3- 2.D0*B3H3)/20.D0
         B4H3=(9.D0*ZK2*B3H3-12.D0*C4H3)/20.D0
         A4H3=(9.D0*ZK2*A3H3- 2.D0*B4H3)/42.D0

         A2V1=(ZK2     - 2.D0*B2V1)/6.D0
         B3V1=(ZK2*B2V1-12.D0*C3V1)/6.D0
         C4V1=(ZK2*C3V1-30.D0*D4V1)/6.D0
         A3V1=(ZK2*A2V1- 2.D0*B3V1)/20.D0
         B4V1=(ZK2*B3V1-12.D0*C4V1)/20.D0
         A4V1=(ZK2*A3V1- 2.D0*B4V1)/42.D0

         A2V3=(9.D0*ZK2     - 2.D0*B2V3)/6.D0
         B3V3=(9.D0*ZK2*B2V3-12.D0*C3V3)/6.D0
         C4V3=(9.D0*ZK2*C3V3-30.D0*D4V3)/6.D0
         A3V3=(9.D0*ZK2*A2V3- 2.D0*B3V3)/20.D0
         B4V3=(9.D0*ZK2*B3V3-12.D0*C4V3)/20.D0
         A4V3=(9.D0*ZK2*A3V3- 2.D0*B4V3)/42.D0

         AXOUT=0.D0
         AYOUT=0.D0
         AZOUT=0.D0

         ICAL=1

      ENDIF !ICAL

C --- CHANGE COORDINATE SYSTEMS

      X=-ZIN
      Y=YIN
      Z=XIN

      X2=X*X
      X4=X2*X2
      X6=X4*X2

      Y2=Y*Y
      Y4=Y2*Y2
      Y6=Y4*Y2

C--- MAGNETIC FIELD

+SELF,IF=-NOCMPLX.
      CZKZ=CDEXP(DCMPLX(0.D0,ZK*Z))
      CZKZ3=CZKZ*CZKZ*CZKZ
      SINZKZ =DIMAG( CZKZ)
      SINZKZ3=DIMAG(CZKZ3)
      COSZKZ =DREAL( CZKZ)
      COSZKZ3=DREAL(CZKZ3)
+SELF,IF=NOCMPLX.
        WRITE(6,*)'CHECK +SELF,NOCMPLX'
      ZKZ=ZK*Z
      COSZKZ=COS(ZKZ)
      SINZKZ=SIN(ZKZ)
      COSZKZ3=COS(3.D0*ZKZ)
      SINZKZ3=SIN(3.D0*ZKZ)
+SELF.
C--------------------------------------------- s HELI_TRIESTE.RED,~.COM
      bxv=-2.D0*((2.D0*(c3v1+c4v1*y2)*x2+b2v1+(b3v1+b4v1*y2)*y2
     . )*SINZKZ*bv1+(2.D0*(c3v3+c4v3*y2)*x2+b2v3+(b3v3+b4v3*y
     . 2)*y2)*SINZKZ3*bv3)*x*y
      byv=-(3.D0*SINZKZ*a2v1*bv1*y2+5.D0*SINZKZ*a3v1*bv1*y4+
     . 7.D0*SINZKZ*a4v1*bv1*y6+SINZKZ*b2v1*bv1*x2+3.D0*SINZ
     . KZ*b3v1*bv1*x2*y2+5.D0*SINZKZ*b4v1*bv1*x2*y4+SINZ
     . KZ*bv1*c3v1*x4+3.D0*SINZKZ*bv1*c4v1*x4*y2+SINZKZ*
     . bv1*d4v1*x6+SINZKZ*bv1+3.D0*SINZKZ3*a2v3*bv3*y2+5.D0*
     . SINZKZ3*a3v3*bv3*y4+7.D0*SINZKZ3*a4v3*bv3*y6+
     . SINZKZ3*b2v3*bv3*x2+3.D0*SINZKZ3*b3v3*bv3*x2*y
     . 2+5.D0*SINZKZ3*b4v3*bv3*x2*y4+SINZKZ3*bv3*
     . c3v3*x4+3.D0*SINZKZ3*bv3*c4v3*x4*y2+SINZKZ3*
     . bv3*d4v3*x6+SINZKZ3*bv3)
      bzv=-((d4v1*x6+1.D0+c4v1*x4*y2+c3v1*x4+b4v1*x2*y4+b3v1
     . *x2*y2+b2v1*x2+a4v1*y6+a3v1*y4+a2v1*y2)*COSZKZ*
     . bv1+3.D0*(d4v3*x6+1.D0+c4v3*x4*y2+c3v3*x4+b4v3*x2*y4+
     . b3v3*x2*y2+b2v3*x2+a4v3*y6+a3v3*y4+a2v3*y2)*COS
     . ZKZ3*bv3)*y*zk
      bxh=-(3.D0*COSZKZ*a2h1*bh1*x2+5.D0*COSZKZ*a3h1*bh1*x4+
     . 7.D0*COSZKZ*a4h1*bh1*x6+COSZKZ*b2h1*bh1*y2+3.D0*SINZ
     . KZ*b3h1*bh1*x2*y2+5.D0*COSZKZ*b4h1*bh1*x4*y2+SINZ
     . KZ*bh1*c3h1*y4+3.D0*COSZKZ*bh1*c4h1*x2*y4+COSZKZ*
     . bh1*d4h1*y6+COSZKZ*bh1+3.D0*COSZKZ3*a2h3*bh3*x2+5.D0*
     . COSZKZ3*a3h3*bh3*x4+7.D0*COSZKZ3*a4h3*bh3*x6+
     . COSZKZ3*b2h3*bh3*y2+3.D0*COSZKZ3*b3h3*bh3*x2*y
     . 2+5.D0*COSZKZ3*b4h3*bh3*x4*y2+COSZKZ3*bh3*
     . c3h3*y4+3.D0*COSZKZ3*bh3*c4h3*x2*y4+COSZKZ3*
     . bh3*d4h3*y6+COSZKZ3*bh3)
      byh=-2.D0*((2.D0*(c3h1+c4h1*x2)*y2+b2h1+(b3h1+b4h1*x2)*x2
     . )*COSZKZ*bh1+(2.D0*(c3h3+c4h3*x2)*y2+b2h3+(b3h3+b4h3*x
     . 2)*x2)*COSZKZ3*bh3)*x*y
      bzh=((d4h1*y6+1.D0+c4h1*x2*y4+c3h1*y4+b4h1*x4*y2+b3h1*
     . x2*y2+b2h1*y2+a4h1*x6+a3h1*x4+a2h1*x2)*SINZKZ*
     . bh1+3.D0*(d4h3*y6+1.D0+c4h3*x2*y4+c3h3*y4+b4h3*x4*y2+
     . b3h3*x2*y2+b2h3*y2+a4h3*x6+a3h3*x4+a2h3*x2)*SIN
     . ZKZ3*bh3)*x*zk
C---------------------------------------------

      BX=BXH+BXV
      BY=BYH+BYV
      BZ=BZH+BZV

C --- CHANGE COORDINATE SYSTEMS

      BXOUT=BZ
      BYOUT=BY
      BZOUT=-BX

      RETURN
      END
+DECK,BHELM.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  11.03.55  by  Michael Scheer
*CMZ :  2.54/05 20/04/2005  09.45.17  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  2.14/02 19/04/2000  17.02.45  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  11.45.40  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.24.35  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  14.43.01  by  Michael Scheer
*CMZ : 00.01/09 01/12/95  15.36.40  by  Michael Scheer
*CMZ : 00.01/02 24/11/94  15.48.36  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.47.32  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.10  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BHELM(X,Y,Z,BX,BY,BZ)

+seq,gplhint.

C  SUBROUTINE BERECHNET B-FELD NUMERISCH FUER HELMHOLTZ-SPULEN
C     SPULEN LIEGEN PARALLEL ZUR Z,X-EBENE, PHI IST DER WINKEL
C     DES RADIUS-VEKTORS ZUR Z-ACHSE

+SEQ,BHELM.

      INTEGER MINT
      PARAMETER(MINT=1000)

      DOUBLE PRECISION DL
      DIMENSION DL(2,MINT,3)

      INTEGER ICAL,I,IC
      DOUBLE PRECISION X,Y,Z,BX,BY,BZ,PI,PHI,CPHI,SPHI,DPHI,RX,RZ,RYP,RYM,R1P
     &  ,R1P3,R1M,R1M3,DBXP,DBYP,DBZP,DBXM,DBYM,DBZM

      DATA ICAL/0/
      DATA PI/3.141592653589793D0/


C--- ARRAYS FUER INTEGRATION AUFSETZEN

      IF (ICAL.NE.1) THEN

        IF(INTHELM.GT.MINT) STOP '*** SR BHELM: INTHELM.GT.MINT ***'

        DPHI=2.D0*PI/DFLOAT(INTHELM)
        DPHI=2.D0*PI/DFLOAT(INTHELM)

        DO IC=1,3
          P0HELM(2,IC)=R0HELM(IC)*0.5D0
          CURHELM(IC)=B0HELM(IC)*R0HELM(IC)*(DSQRT(1.25D0))**3/(4.D-7*PI)
        ENDDO

        DO I=1,INTHELM
          PHI=DFLOAT(I)*DPHI
          CPHI=DCOS(PHI)
          SPHI=DSIN(PHI)
          DO IC=1,3
            DL(1,I,IC)=R0HELM(IC)*(-SPHI)*DPHI*CURHELM(IC)*1.D-7
            DL(2,I,IC)=R0HELM(IC)*  CPHI *DPHI*CURHELM(IC)*1.D-7
          END DO
        END DO

        WRITE(16,*)
        WRITE(16,*)'      BHELM:'
        WRITE(16,*)
        WRITE(16,*)'      Radius[m], B0[T], I[A]:',
     &    (SNGL(R0HELM(1))),
     &    (SNGL(B0HELM(1))),
     &    (SNGL(CURHELM(1)))
        WRITE(16,*)'      X,Y,Z[m]:',(SNGL(P0HELM(IC,1)),IC=1,3)
        WRITE(16,*)'      Radius[m], B0[T], I[A]:',
     &    (SNGL(R0HELM(2))),
     &    (SNGL(B0HELM(2))),
     &    (SNGL(CURHELM(2)))
        WRITE(16,*)'      X,Y,Z[m]:',(SNGL(P0HELM(IC,2)),IC=1,3)
        WRITE(16,*)'      Radius[m], B0[T], I[A]:',
     &    (SNGL(R0HELM(3))),
     &    (SNGL(B0HELM(3))),
     &    (SNGL(CURHELM(3)))
        WRITE(16,*)'      X,Y,Z[m]:',(SNGL(P0HELM(IC,3)),IC=1,3)

        ICAL=1
      END IF

C--- INTEGRATION DER B-FELDER

      BX=0.D0
      BY=0.D0
      BZ=0.D0

      DO IC=1,3
        DO I=1,INTHELM
          RX=X-P0HELM(1,IC)-R0HELM(IC)*DSIN(DFLOAT(I)*DPHI)
          RZ=Z-P0HELM(3,IC)-R0HELM(IC)*DCOS(DFLOAT(I)*DPHI)
          RYP=Y-P0HELM(2,IC)
          RYM=Y+P0HELM(2,IC)

          R1P=1.D0/(DSQRT(RX*RX+RYP*RYP+RZ*RZ))
          R1P3=R1P*R1P*R1P
          R1M=1.D0/(DSQRT(RX*RX+RYM*RYM+RZ*RZ))
          R1M3=R1M*R1M*R1M

          DBXP=-RYP*DL(1,I,IC)*R1P3
          DBYP =(RX *DL(1,I,IC)-RZ*DL(2,I,IC))*R1P3
          DBZP= RYP*DL(2,I,IC)*R1P3

          DBXM=-RYM*DL(1,I,IC)*R1M3
          DBYM =(RX *DL(1,I,IC)-RZ*DL(2,I,IC))*R1M3
          DBZM= RYM*DL(2,I,IC)*R1M3


          BX=BX+DBXP+DBXM
          BY=BY+DBYP+DBYM
          BZ=BZ+DBZP+DBZM
        END DO
      END DO

      RETURN
      END
+DECK,BLENDE.
*CMZ :  3.08/01 03/04/2019  14.39.38  by  Michael Scheer
*CMZ :  3.07/00 15/03/2019  15.22.31  by  Michael Scheer
*CMZ :  3.03/02 27/02/2017  13.51.45  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.10  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  16.22.59  by  Michael Scheer
*CMZ :  2.52/09 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.35/01 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.34/09 24/09/2001  12.08.47  by  Michael Scheer
*CMZ :  2.34/01 25/06/2001  14.39.42  by  Michael Scheer
*CMZ :  2.34/00 11/05/2001  12.14.41  by  Michael Scheer
*CMZ :  2.31/00 23/04/2001  18.27.11  by  Michael Scheer
*CMZ :  2.20/09 23/03/2001  11.01.07  by  Michael Scheer
*CMZ :  2.16/08 24/10/2000  14.08.07  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.08.20  by  Michael Scheer
*CMZ :  2.13/03 11/01/2000  18.22.27  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  15.04.41  by  Michael Scheer
*CMZ :  1.00/00 31/07/97  17.36.12  by  Michael Scheer
*CMZ : 00.02/05 18/03/97  15.48.44  by  Michael Scheer
*CMZ : 00.02/04 26/02/97  12.07.43  by  Michael Scheer
*CMZ : 00.02/00 10/12/96  18.07.52  by  Michael Scheer
*CMZ : 00.01/09 01/09/95  12.58.16  by  Michael Scheer
*CMZ : 00.01/02 24/11/94  15.49.44  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.47.38  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.04  by  Michael Scheer
*-- Author :
      SUBROUTINE BLENDE(ISOUR,kfreq)

+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.

C--- INTEGRATES THE SPLINES THAT INTERPOLATE THE INTENSITY INSIDE THE PINHOLE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,PHYCON.

      INTEGER kfreq,ISOUR,IY,IZ,IOBSV,IIY,ICAL,IR,IP,NR,MR,MP,KDUM,IERR
      INTEGER JCAL,IWBLEN,IDUM
      INTEGER IWRPHIS,IWRPHIF,IWSOUR,IWFREQ,ILIOBFR1

      DOUBLE PRECISION DSUM,RPHI,DIA
      DOUBLE PRECISION SUMZ(NDOBSVYP),S2(NDOBSVYP),SUM,OBSVYF(NDOBSVYP)
      DOUBLE PRECISION SUMY(NDOBSVZP)
      DOUBLE PRECISION SUMZP(NDOBSVYP),S2P(NDOBSVYP),SUMP,DSUMP
      DOUBLE PRECISION R(NDOBSVZP),PHI(NDOBSVYP)
     &  ,FPHI(NDOBSVYP)
     &  ,SZ(NDOBSVZP),SY(NDOBSVYP)
     &  ,FZ(NDOBSVZP),FY(NDOBSVYP),DPHI,DR,X,Y

      DATA ICAL/0/,JCAL/0/,iwblen/0/

      if (ipin.eq.3) then
        ILIOBFR=ISOUR+NSOURCE*(kfreq-1)
        if (ipincirc.eq.0) then
          WFLUX(ILIOBFR)=SPEC(ILIOBFR)*pinw*pinh
        else
          WFLUX(ILIOBFR)=SPEC(ILIOBFR)*pinr**2*pi1
        endif
        return
      endif

c      IWBLEN=0

      IF (IPINCIRC.EQ.0) THEN

        IF (IF1DIM.NE.2) THEN

C--- INTEGRATION ALONG HORIZONTAL AXIS Z

          IIY=0
C290693  DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
          DO IY=1,NOBSVY

            IIY=IIY+1
            SUMZ(IIY)=0.0
            SUMZP(IIY)=0.0
            OBSVYF(IIY)=OBSVY(IY)

            IF(MOBSVZ.GT.1) THEN

              DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ-1

                IOBSV=(IY-1)*NOBSVZ+IZ

                ILIOBFR=ISOUR+NSOURCE*(IOBSV-1+NOBSV*(kfreq-1))
                ILIOBFR1=ISOUR+NSOURCE*(IOBSV+NOBSV*(kfreq-1))

                DSUM=OBSVDZ*0.5D0
     &            *(SPEC(ILIOBFR)+SPEC(ILIOBFR1))
     &            -OBSVDZ**3/24.D0*(SPCOEF(IOBSV)+SPCOEF(IOBSV+1))

                IF(
     &              (IWSOUR.NE.ISOUR.OR.IWFREQ.NE.kfreq)
     &              .AND.
     &              DSUM.LT.0.0) THEN

                  IF (IWBLEN.EQ.0) THEN
                    WRITE(LUNGFO,*)
                    WRITE(LUNGFO,*)
                    WRITE(LUNGFO,*)'*** WARNING IN BLENDE ***'
                    WRITE(LUNGFO,*)
     &                'SPLINE INTEGRATION FAILED, RESULTS NOT RELIABLE'
                    WRITE(LUNGFO,*)
                    WRITE(LUNGFO,*)
                  ENDIF
                  IWSOUR=ISOUR
                  IWFREQ=kfreq
                  IW_BLEN=1
                  IWBLEN=1
                  DO IDUM=1,IIY
                    SUMZP(IDUM)=SUMZ(IDUM)
                  ENDDO
                ENDIF !IWSOUR

                IF (IWBLEN.NE.0) SUMZP(IIY)=SUMZP(IIY)+DABS(DSUM)
                SUMZ(IIY)=SUMZ(IIY)+DSUM

              ENDDO   !IZ

            ELSE  !MOBSVZ

              IOBSV=(IY-1)*NOBSVZ+(NOBSVZ-MOBSVZ)/2+1
              SUMZ(IIY)=OBSVDZ*SPEC(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(kfreq-1)))

              IF (IWBLEN.NE.0) SUMZP(IIY)=SUMZ(IIY)

            ENDIF !MOBSVZ

          ENDDO !IY

C--- INTEGRATION ALONG VERTICAL AXIS Y

          CALL FSPLINDX(OBSVDY,SUMZ,NOBSVY,0.D0,0.D0,S2)
          IF (IWBLEN.NE.0)
     &      CALL FSPLINDX(OBSVDY,SUMZP,NOBSVY,0.D0,0.D0,S2P)

          IF(MOBSVY.GT.1) THEN

            SUM=0.0
            SUMP=0.0
            DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY-1

              DSUM=
     &          OBSVDY*0.5D0
     &          *(SUMZ(IY)+SUMZ(IY+1))
     &          -OBSVDY**3/24.D0
     &          *(S2(IY)+S2(IY+1))

              IF (IWBLEN.NE.0) THEN
                DSUMP=
     &            OBSVDY*0.5D0
     &            *(SUMZP(IY)+SUMZP(IY+1))
     &            -OBSVDY**3/24.D0
     &            *(S2P(IY)+S2P(IY+1))
              ENDIF

              IF(
     &            (IWSOUR.NE.ISOUR.OR.IWFREQ.NE.kfreq)
     &            .AND.
     &            DSUM.LT.0.0) THEN
                IF (IWBLEN.EQ.0) THEN
                  WRITE(LUNGFO,*)
                  WRITE(LUNGFO,*)
                  WRITE(LUNGFO,*)'*** WARNING IN BLENDE ***'
                  WRITE(LUNGFO,*)
     &              'SPLINE INTEGRATION FAILED, RESULTS NOT RELIABLE'
                  WRITE(LUNGFO,*)
                  WRITE(LUNGFO,*)
                ENDIF

                IWSOUR=ISOUR
                IWFREQ=kfreq
                IW_BLEN=1
                IWBLEN=1

                DO IDUM=1,NOBSVY
                  S2P(IDUM)=S2(IDUM)
                  SUMZP(IDUM)=SUMZ(IDUM)
                  SUMP=SUM
                  DSUMP=DSUM
                ENDDO

              ENDIF !IWSOUR

              IF (IWBLEN.NE.0) SUMP=SUMP+DABS(DSUMP)

              SUM=SUM+DSUM

            ENDDO !IY

          ELSE !MOBSVY

            SUM=OBSVDY*SUMZ(NOBSVY/2+1)

            IF (IWBLEN.NE.0) SUMP=OBSVDY*SUMZP(NOBSVY/2+1)

          ENDIF !MOBSVY

        ELSE !(IF1DIM.EQ.2)

C--- INTEGRATION ALONG HORIZONTAL AXIS Z

          DO IY=1,NOBSVY

            SUMZP(IY)=0.0
            OBSVYF(IY)=OBSVY(IY)

            DIA=ABS((PINR-(PINCEN(2)-OBSV(2,IY)))
     &        *(PINR+(PINCEN(2)-OBSV(2,IY))))
            IF (DIA.GT.0.D0) THEN
              DIA=2.D0*SQRT(DIA)
            ELSE
              DIA=0.D0
            ENDIF
            SUMZ(IY)=DIA*SPEC(ISOUR+NSOURCE*(IY-1+NOBSV*(kfreq-1)))

            IF (IWBLEN.NE.0) SUMZP(IY)=SUMZ(IY)

          ENDDO !IY

        ENDIF  !IF1DIM

C--- INTEGRATION ALONG VERTICAL AXIS Y

        CALL FSPLINDX(OBSVDY,SUMZ,NOBSVY,0.D0,0.D0,S2)
        IF (IWBLEN.NE.0)
     &    CALL FSPLINDX(OBSVDY,SUMZP,NOBSVY,0.D0,0.D0,S2P)

        IF(MOBSVY.GT.1) THEN

          SUM=0.0
          SUMP=0.0
          DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY-1


            DSUM=
     &        OBSVDY*0.5D0
     &        *(SUMZ(IY)+SUMZ(IY+1))
     &        -OBSVDY**3/24.D0
     &        *(S2(IY)+S2(IY+1))

            IF (IWBLEN.NE.0) THEN
              DSUMP=
     &          OBSVDY*0.5D0
     &          *(SUMZP(IY)+SUMZP(IY+1))
     &          -OBSVDY**3/24.D0
     &          *(S2P(IY)+S2P(IY+1))
            ENDIF

            IF(
     &          (IWSOUR.NE.ISOUR.OR.IWFREQ.NE.kfreq)
     &          .AND.
     &          DSUM.LT.0.0) THEN
              IF (IWBLEN.EQ.0) THEN
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'*** WARNING IN BLENDE ***'
                WRITE(LUNGFO,*)
     &            'SPLINE INTEGRATION FAILED, RESULTS NOT RELIABLE'
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)
              ENDIF

              IWSOUR=ISOUR
              IWFREQ=kfreq
              IW_BLEN=1
              IWBLEN=1
              DO IDUM=1,NOBSVY
                S2P(IDUM)=S2(IDUM)
                SUMZP(IDUM)=SUMZ(IDUM)
                SUMP=SUM
                DSUMP=DSUM
              ENDDO

            ENDIF !IWSOUR

            IF (IWBLEN.NE.0) SUMP=SUMP+DABS(DSUMP)

            SUM=SUM+DSUM

          ENDDO !IY

        ELSE IF (IF1DIM.EQ.2) THEN

          SUM=PI1*PINR*SUMZ(NOBSVY/2+1)/2.D0

          IF (IWBLEN.NE.0) SUMP=PI1*PINR*SUMZP(NOBSVY/2+1)/2.D0

        ELSE !MOBSVY

          SUM=OBSVDY*SUMZ(NOBSVY/2+1)

          IF (IWBLEN.NE.0) SUMP=OBSVDY*SUMZP(NOBSVY/2+1)

        ENDIF !MOBSVY

      ELSE  !IPINCIRC (BZW. IF1DIM.EQ.1)

        IF (IRPHI.NE.0) THEN !INTEGRATION WITH RESPECT TO POLAR COORDINATES

C--- INTEGRATION OVER PHI

          IF (ICAL.EQ.0) THEN

            DR=DMIN1(OBSVDZ,OBSVDY)
            MR=NINT(PINR/DR)+1
            DR=PINR/(MR-1)
            MEDGER=MIN( MEDGEZ, MEDGEY)
            NR=MR+MEDGER
            MP=MOBSVY

            IF (MR.LT.1) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'*** ERROR IN BLENDE ***'
              WRITE(LUNGFO,*)'NOT ENOUGH GRID POINTS FOR CIRCULAR PINHOLE'
              WRITE(LUNGFO,*)'INCREASE PARAMETER MPINZ IN NAMELIST PINHOLE'
              WRITE(LUNGFO,*)
              WRITE(6,*)
              WRITE(6,*)'*** ERROR IN BLENDE ***'
              WRITE(6,*)'NOT ENOUGH GRID POINTS FOR CIRCULAR PINHOLE'
              WRITE(6,*)'INCREASE PARAMETER MPINZ IN NAMELIST PINHOLE'
              WRITE(6,*)
            ENDIF
            IF (MP.LT.4) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'*** ERROR IN BLENDE ***'
              WRITE(LUNGFO,*)'NOT ENOUGH GRID POINTS FOR CIRCULAR PINHOLE'
              WRITE(LUNGFO,*)'INCREASE PARAMETER MPINY IN NAMELIST PINHOLE'
              WRITE(LUNGFO,*)
              WRITE(6,*)
              WRITE(6,*)'*** ERROR IN BLENDE ***'
              WRITE(6,*)'NOT ENOUGH GRID POINTS FOR CIRCULAR PINHOLE'
              WRITE(6,*)'INCREASE PARAMETER MPINY IN NAMELIST PINHOLE'
              WRITE(6,*)
            ENDIF

            DPHI=2.D0*PI1/(MP-1)
            DO IP=1,MP
              PHI(IP)=(IP-1)*DPHI
            ENDDO

            DO IR=1,NR
              R(IR)=(IR-1)*DR
            ENDDO

            DO IR=2,NR
              DO IP=1,MP
                XC(IP+(IR-1)*NOBSVY)=R(IR)*DCOS(PHI(IP))+PINCEN(3)
                YC(IP+(IR-1)*NOBSVY)=R(IR)*DSIN(PHI(IP))+PINCEN(2)
              ENDDO !IP
            ENDDO !IR

            ICAL=1

          ENDIF !ICAL

C--- INTERPOLATION OF INTENSITY FOR CIRCULAR GRID

          DO IR=2,NR
            DO IP=1,MP

              X=XC(IP+(IR-1)*NOBSVY)
              Y=YC(IP+(IR-1)*NOBSVY)

              DO IY=1,NOBSVY

                DO IZ=1,NOBSVZ
                  IOBSV=(IY-1)*NOBSVZ+IZ
                  FZ(IZ)=SPEC(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(kfreq-1)))
                  SZ(IZ)=SPCOEF(IOBSV)
                ENDDO !IZ

                CALL SPLINZY(NOBSVZ,X,FY(IY),OBSVZ,FZ,SZ,KDUM)

              ENDDO !IY

              CALL FSPLINDX(OBSVDY,FY,NOBSVY,0.D0,0.D0,SY)
              CALL SPLINZY(NOBSVY,Y,FPHIR(IP+(IR-1)*NOBSVY),OBSVY,FY,SY,KDUM)

              IF(
     &          (IWRPHIS.NE.ISOUR.OR.IWRPHIF.NE.kfreq)
     &          .AND.
     &          FPHIR(IP+(IR-1)*NOBSVY).LT.0.0) THEN
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'*** WARNING IN BLENDE ***'
                WRITE(LUNGFO,*)
     &            'SPLINE INTERPOLATION FOR OPTION IRPHI FAILED, RESULTS NOT RELIABLE'
                WRITE(LUNGFO,*)'SOURCE POINT AND PHOTON ENERGY:'
     &            ,ISOUR,SNGL(FREQ(kfreq))
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)
                IWRPHIS=ISOUR
                IWRPHIF=kfreq
                IW_BLEN=1
                IWBLEN=1
              ENDIF !IWPHIR

            ENDDO !IP
          ENDDO !IR

C--- DO THE INTEGRATION OF FPHIR OVER PHI AND R

          SUM=0.D0
          SUMY(1)=0.0
          DO IR=2,NR  !FIRST RADIUS IS ZERO

            DO IP=1,MP
              FPHI(IP)=FPHIR(IP+(IR-1)*NOBSVY)
            ENDDO   !IP

            CALL FSPLPER(DPHI,FPHI,MP,SY)

            SUMY(IR)=0.D0
            RPHI=R(IR)*DPHI
            DO IP=1,MP-1

              DSUM=
     &          RPHI*0.5D0*(FPHI(IP)+FPHI(IP+1))
     &          -RPHI**3/24.D0*(SY(IP)+SY(IP+1))

              IF(
     &            (IWSOUR.NE.ISOUR.OR.IWFREQ.NE.kfreq)
     &            .AND.
     &            DSUM.LT.0.0) THEN
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'*** WARNING IN BLENDE ***'
                WRITE(LUNGFO,*)
     &            'SPLINE INTEGRATION FAILED, RESULTS NOT RELIABLE'
                WRITE(LUNGFO,*)'SOURCE POINT AND PHOTON ENERGY:'
     &            ,ISOUR,SNGL(FREQ(kfreq))
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)
                IWSOUR=ISOUR
                IWFREQ=kfreq
                IW_BLEN=1
                IWBLEN=1
              ENDIF !IWSOUR

              SUMY(IR)=SUMY(IR)+DSUM

            ENDDO   !IP

          ENDDO !IR

          CALL FSPLINDX(DR,SUMY,NR,0.D0,0.D0,SZ)

          SUM=0.0
          DO IR=1,MR-1

            DSUM=
     &        DR*0.5D0
     &        *(SUMY(IR)+SUMY(IR+1))
     &        -DR**3/24.D0
     &        *(SZ(IR)+SZ(IR+1))

            IF(
     &          (IWSOUR.NE.ISOUR.OR.IWFREQ.NE.kfreq)
     &          .AND.
     &          DSUM.LT.0.0) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'*** WARNING IN BLENDE ***'
              WRITE(LUNGFO,*)
     &          'SPLINE INTEGRATION FAILED, RESULTS NOT RELIABLE'
              WRITE(LUNGFO,*)'SOURCE POINT AND PHOTON ENERGY:'
     &          ,ISOUR,SNGL(FREQ(kfreq))
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
              IWSOUR=ISOUR
              IWFREQ=kfreq
              IW_BLEN=1
              IWBLEN=1
            ENDIF !IWSOUR

            SUM=SUM+DSUM

          ENDDO

        ELSE  !IRPHI

          DO IOBSV=1,NOBSV
            FPHIR(IOBSV)=SPEC(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(kfreq-1)))
          ENDDO !IOBSV

          CALL CIRCPIN(NOBSVZ,NOBSVY,MOBSVZ,MOBSVY,FPHIR,SUM,SUMP,ISOUR,kfreq,
     &      IERR)

          IF (IERR.NE.0) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'SR CIRCPIN HAS BEEN CALLED BY SR BLENDE WITH ERRORS'
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)'SR CIRCPIN HAD BEEN CALLED BY SR BLENDE WITH ERRORS'
            WRITE(6,*)
          ENDIF

        ENDIF !IRPHI

      ENDIF !IPINCIRC

      WFLUX(ISOUR+NSOURCE*(kfreq-1))=SUM

      IF (IRPHI.EQ.0.AND.(IWBLEN.NE.0.OR.IERR.NE.0)) THEN
        IF (JCAL.EQ.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'      *** SUBROUTINE BLENDE:'
          WRITE(LUNGFO,*)
     &      '      LINES INDICATED BY * SHOW A RAW ESTIMATE OF ERRORS DUE TO'
          WRITE(LUNGFO,*)
     &      '      SPLINE FAILURE IF REL. ERROR .GT. 1E-5 (FIRST NUMBER IS SOURCE)'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'      *** SUBROUTINE BLENDE:'
          WRITE(6,*)
     &      '      LINES INDICATED BY * SHOW A RAW ESTIMATE OF ERRORS DUE TO'
          WRITE(6,*)
     &      '      SPLINE FAILURE IF REL. ERROR .GT. 1E-5 (FIRST NUMBER IS SOURCE)'
          WRITE(6,*)
          WRITE(6,*)
          WRITE(6,*)
     &      '      source, energy, flux, flux+error, ratio:'
          JCAL=1
        ENDIF   !JCAL
        IF (SUMP.NE.0.D0) THEN
          DSUM=SUM/SUMP
        ELSE
          DSUM=-9999.
        ENDIF
        IF (DABS(DSUM-1.D0).GT.1.D-5) THEN
          WRITE(LUNGFO,*)'*',ISOUR,
     &      SNGL(FREQ(kfreq)),SNGL(SUM),SNGL(SUMP),SNGL(DSUM)
          WRITE(6,*)'*',ISOUR,
     &      SNGL(FREQ(kfreq)),SNGL(SUM),SNGL(SUMP),SNGL(DSUM)
        ENDIF
      ENDIF !IWBLEN

      RETURN
      END
+DECK,BLENDEF.
*CMZ :  3.07/00 15/03/2019  13.06.55  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.10  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.35/01 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.34/09 24/09/2001  12.09.00  by  Michael Scheer
*CMZ :  2.34/00 11/05/2001  12.20.12  by  Michael Scheer
*CMZ :  2.16/08 24/10/2000  14.08.42  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  16.26.19  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.08.20  by  Michael Scheer
*CMZ :  2.13/04 21/01/2000  12.17.14  by  Michael Scheer
*CMZ :  2.13/03 11/01/2000  18.22.27  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  15.04.41  by  Michael Scheer
*CMZ : 00.02/04 25/02/97  17.36.07  by  Michael Scheer
*CMZ : 00.02/00 10/12/96  18.09.03  by  Michael Scheer
*CMZ : 00.01/09 01/09/95  13.01.10  by  Michael Scheer
*CMZ : 00.01/02 24/11/94  15.50.50  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.47.44  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.06  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BLENDEF(ISOUR,kfreq)

+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.

C--- INTEGRATES THE SPLINES THAT INTERPOLATE THE INTENSITY INSIDE THE PINHOLE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,PHYCON.


      INTEGER IWRPHIS,IWRPHIF,IWSOUR,IWFREQ
      DOUBLE PRECISION DSUM,RPHI

      INTEGER kfreq,ISOUR,IY,IZ,IOBSV,IIY,IIZ
     &  ,ICAL,IR,IP,MR,MP,KDUM,IERR

      DOUBLE PRECISION SUMZ(NDOBSVYP),S2(NDOBSVYP),SUM,SUMY(NDOBSVZP)
      DOUBLE PRECISION OBSVYF(NDOBSVYP),SUMP,DIA
      DOUBLE PRECISION R(NDOBSVZP),PHI(NDOBSVYP)
     &  ,FPHI(NDOBSVYP)
     &  ,SZ(NDOBSVZP),SY(2*NDOBSVYP)
     &  ,FZ(NDOBSVZP),FY(NDOBSVYP),DPHI,DR,X,Y

      DOUBLE PRECISION OBSVZF(NDOBSVZP)

      DATA ICAL/0/

C--- TAKE INNER EDGE OF PINHOLE INTO ACCOUNT, I.E. SET MOBSVZ,MOBVY,MOBSV
C    TO ORIGINAL VALUES. THEY HAVE BEEN OVERWRITTEN IN SR WFOLINT

      MOBSVZ=MOBSVZ-2*MMEDGEZ
      MOBSVY=MOBSVY-2*MMEDGEY
      MOBSV=MOBSVZ*MOBSVY

      IF (IPINCIRC.EQ.0) THEN

        IF (IF1DIM.NE.2) THEN

C--- INTEGRATION ALONG HORIZONTAL AXIS Z

          IIY=0

C010793  DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY

          DO IY=(NOBSVY-MOBSVY-2*MMEDGEY)/2+1,
     &        (NOBSVY-MOBSVY-2*MMEDGEY)/2+MOBSVY+2*MMEDGEY

            IIY=IIY+1
            OBSVYF(IIY)=OBSVY(IY)

            IF(MOBSVZ.GT.1) THEN

              SUMZ(IIY)=0.0

              DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ-1

                IOBSV=(IY-1)*NOBSVZ+IZ

                DSUM=
     &            OBSVDZ*0.5D0
     &            *(SPECF(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(kfreq-1)))
     &            +SPECF(ISOUR+NSOURCE*(IOBSV+NOBSV*(kfreq-1))))
     &            -OBSVDZ**3/24.D0
     &            *(SPCOEFM(IOBSV)
     &            + SPCOEFM(IOBSV+1))
                IF(
     &              (IWSOUR.NE.ISOUR.OR.IWFREQ.NE.kfreq)
     &              .AND.
     &              DSUM.LT.0.0) THEN
                  WRITE(LUNGFO,*)
                  WRITE(LUNGFO,*)
                  WRITE(LUNGFO,*)'*** WARNING SR BLENDEF ***'
                  WRITE(LUNGFO,*)
     &              'SPLINE INTEGRATION FAILED, RESULTS NOT RELIABLE'
                  WRITE(LUNGFO,*)'SOURCE POINT AND PHOTON ENERGY:'
     &              ,ISOUR,SNGL(FREQ(kfreq))
                  WRITE(LUNGFO,*)
                  WRITE(LUNGFO,*)
                  IWSOUR=ISOUR
                  IWFREQ=kfreq
                  IW_BLENF=1
                ENDIF !IWSOUR

                SUMZ(IIY)=SUMZ(IIY)+DSUM

              ENDDO   !IZ

            ELSE !MOBSVZ.GT.1

              IOBSV=(IY-1)*NOBSVZ+(NOBSVZ-MOBSVZ)/2+1
              SUMZ(IIY)=OBSVDZ*SPECF(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(kfreq-1)))
            ENDIF

          ENDDO !IY

        ELSE  !IF1DIM.EQ.2

C--- INTEGRATION ALONG HORIZONTAL AXIS Z

          IIY=0

C010793  DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY

          DO IY=(NOBSVY-MOBSVY-2*MMEDGEY)/2+1,
     &        (NOBSVY-MOBSVY-2*MMEDGEY)/2+MOBSVY+2*MMEDGEY

            IIY=IIY+1
            OBSVYF(IIY)=OBSVY(IY)

            IOBSV=(IY-1)*NOBSVZ+(NOBSVZ-MOBSVZ)/2+1
            DIA=ABS((PINR-(PINCEN(2)-OBSV(2,IOBSV)))
     &        *(PINR+(PINCEN(2)-OBSV(2,IOBSV))))
            IF (DIA.GT.0.D0) THEN
              DIA=2.D0*SQRT(DIA)
            ELSE
              DIA=0.D0
            ENDIF
            SUMZ(IIY)=DIA*SPECF(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(kfreq-1)))

          ENDDO !IY

        ENDIF !IF1DIM.EQ.2

C--- INTEGRATION ALONG VERTICAL AXIS Y

        CALL FSPLINDX(OBSVDY,SUMZ,MOBSVY+2*MMEDGEY,0.D0,0.D0,S2)

        IF(MOBSVY.GT.1) THEN

          SUM=0.0

C010793      DO IY=1,MOBSVY-1

          DO IY=MMEDGEY+1,MMEDGEY+MOBSVY-1

            DSUM=
     &        OBSVDY*0.5D0
     &        *(SUMZ(IY)+SUMZ(IY+1))
     &        -OBSVDY**3/24.D0
     &        *(S2(IY)+S2(IY+1))

            IF(
     &          (IWSOUR.NE.ISOUR.OR.IWFREQ.NE.kfreq)
     &          .AND.
     &          DSUM.LT.0.0) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'*** WARNING SR BLENDEF ***'
              WRITE(LUNGFO,*)
     &          'SPLINE INTEGRATION FAILED, RESULTS NOT RELIABLE'
              WRITE(LUNGFO,*)'SOURCE POINT AND PHOTON ENERGY:'
     &          ,ISOUR,SNGL(FREQ(kfreq))
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
              IWSOUR=ISOUR
              IWFREQ=kfreq
              IW_BLENF=1
            ENDIF !IWSOUR

            SUM=SUM+DSUM

          ENDDO

        ELSE IF (IF1DIM.EQ.2) THEN

          SUM=PI1*PINR*SUMZ(MMEDGEY+1)/2.D0

        ELSE

          SUM=OBSVDY*SUMZ(MMEDGEY+1)

        ENDIF

      ELSE  !IPINCIRC

        IF (IRPHI.NE.0) THEN !INTEGRATION WITH RESPECT TO POLAR COORDINATES

C--- INTEGRATION OVER PHI

          IF (ICAL.EQ.0) THEN

            DR=DMIN1(OBSVDZ,OBSVDY)
            MR=NINT(PINR/DR)+1
            DR=PINR/(MR-1)
            MEDGER=MIN(MMEDGEZ,MMEDGEY)
            MP=MOBSVY

            IF (MR.LT.1) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'*** ERROR IN BLENDEF ***'
              WRITE(LUNGFO,*)'NOT ENOUGH GRID POINTS FOR CIRCULAR PINHOLE'
              WRITE(LUNGFO,*)'INCREASE PARAMETER MPINZ IN NAMELIST PINHOLE'
              WRITE(LUNGFO,*)
              WRITE(6,*)
              WRITE(6,*)'*** ERROR IN BLENDEF ***'
              WRITE(6,*)'NOT ENOUGH GRID POINTS FOR CIRCULAR PINHOLE'
              WRITE(6,*)'INCREASE PARAMETER MPINZ IN NAMELIST PINHOLE'
              WRITE(6,*)
            ENDIF
            IF (MP.LT.4) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'*** ERROR IN BLENDEF ***'
              WRITE(LUNGFO,*)'NOT ENOUGH GRID POINTS FOR CIRCULAR PINHOLE'
              WRITE(LUNGFO,*)'INCREASE PARAMETER MPINY IN NAMELIST PINHOLE'
              WRITE(LUNGFO,*)
              WRITE(6,*)
              WRITE(6,*)'*** ERROR IN BLENDEF ***'
              WRITE(6,*)'NOT ENOUGH GRID POINTS FOR CIRCULAR PINHOLE'
              WRITE(6,*)'INCREASE PARAMETER MPINY IN NAMELIST PINHOLE'
              WRITE(6,*)
            ENDIF

            DPHI=2.D0*PI1/(MP-1)
            DO IP=1,MP
              PHI(IP)=(IP-1)*DPHI
            ENDDO

            DO IR=1,MR+MEDGER
              R(IR)=(IR-1)*DR
            ENDDO

            DO IR=2,MR+MEDGER
              DO IP=1,MP
                XC(IP+(IR-1)*NOBSVY)=R(IR)*DCOS(PHI(IP))+PINCEN(3)
                YC(IP+(IR-1)*NOBSVY)=R(IR)*DSIN(PHI(IP))+PINCEN(2)
              ENDDO !IP
            ENDDO !IR

            ICAL=1

          ENDIF !ICAL

C--- INTERPOLATION OF INTENSITY FOR CIRCULAR GRID

          DO IR=2,MR+MEDGER
            DO IP=1,MP

              X=XC(IP+(IR-1)*NOBSVY)
              Y=YC(IP+(IR-1)*NOBSVY)
              IIY=0
              DO IY=(NOBSVY-MOBSVY-2*MMEDGEY)/2+1,
     &            (NOBSVY-MOBSVY-2*MMEDGEY)/2+MOBSVY+2*MMEDGEY
                IIY=IIY+1

                IIZ=0
                DO IZ=(NOBSVZ-MOBSVZ-2*MMEDGEZ)/2+1,
     &              (NOBSVZ-MOBSVZ-2*MMEDGEZ)/2+MOBSVZ+2*MMEDGEZ

                  IIZ=IIZ+1
                  IOBSV=(IY-1)*NOBSVZ+IZ
                  FZ(IIZ)=SPECF(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(kfreq-1)))
                  SZ(IIZ)=SPCOEFM(IOBSV)
                  OBSVZF(IIZ)=OBSVZ(IZ)

                ENDDO !IZ

                CALL SPLINZY(IIZ,X,FY(IIY),OBSVZF,FZ,SZ,KDUM)

                OBSVYF(IIY)=OBSVY(IY)

              ENDDO !IY

              CALL FSPLINDX(OBSVDY,FY,IIY,0.D0,0.D0,SY)
              CALL SPLINZY(IIY,Y,FPHIR(IP+(IR-1)*NOBSVY),OBSVYF,FY,SY,KDUM)

              IF(
     &          (IWRPHIS.NE.ISOUR.OR.IWRPHIF.NE.kfreq)
     &          .AND.
     &            FPHIR(IP+(IR-1)*NOBSVY).LT.0.0) THEN
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'*** WARNING SR BLENDEF ***'
                WRITE(LUNGFO,*)
     &            'SPLINE INTERPOLATION FOR OPTION IRPHI FAILED, RESULTS NOT RELIABLE'
                WRITE(LUNGFO,*)'SOURCE POINT AND PHOTON ENERGY:'
     &            ,ISOUR,SNGL(FREQ(kfreq))
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)
                IWRPHIS=ISOUR
                IWRPHIF=kfreq
                IW_BLENF=1
              ENDIF !IWPHIR

            ENDDO !IP
          ENDDO !IR

C--- DO THE INTEGRATION OF FPHIR OVER PHI AND R

          SUM=0.0D0
          SUMY(1)=0.D0
          DO IR=2,MR+MEDGER !FIRST RADIUS IS ZERO

            DO IP=1,MP
              FPHI(IP)=FPHIR(IP+(IR-1)*NOBSVY)
            ENDDO   !IP

            CALL FSPLPER(DPHI,FPHI,MP,SY)

            SUMY(IR)=0.0D0
            RPHI=R(IR)*DPHI
            DO IP=1,MP-1

              DSUM=
     &          RPHI*0.5D0*(FPHI(IP)+FPHI(IP+1))
     &          -RPHI**3/24.D0*(SY(IP)+SY(IP+1))

              IF(
     &            (IWSOUR.NE.ISOUR.OR.IWFREQ.NE.kfreq)
     &            .AND.
     &            DSUM.LT.0.0) THEN
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'*** WARNING SR BLENDEF ***'
                WRITE(LUNGFO,*)
     &            'SPLINE INTEGRATION FAILED, RESULTS NOT RELIABLE'
                WRITE(LUNGFO,*)'SOURCE POINT AND PHOTON ENERGY:'
     &            ,ISOUR,SNGL(FREQ(kfreq))
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)
                IWSOUR=ISOUR
                IWFREQ=kfreq
                IW_BLENF=1
              ENDIF !IWSOUR

              SUMY(IR)=SUMY(IR)+DSUM

            ENDDO   !IP

          ENDDO !IR

          CALL FSPLINDX(DR,SUMY,MR+MEDGER,0.D0,0.D0,SZ)

          SUM=0.0d0
          DO IR=1,MR-1    !MUST START FROM ONE

            DSUM=
     &        DR*0.5D0
     &        *(SUMY(IR)+SUMY(IR+1))
     &        -DR**3/24.D0
     &        *(SZ(IR)+SZ(IR+1))

            IF(
     &          (IWSOUR.NE.ISOUR.OR.IWFREQ.NE.kfreq)
     &          .AND.
     &          DSUM.LT.0.0) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'*** WARNING SR BLENDEF ***'
              WRITE(LUNGFO,*)
     &          'SPLINE INTEGRATION FAILED, RESULTS NOT RELIABLE'
              WRITE(LUNGFO,*)'SOURCE POINT AND PHOTON ENERGY:'
     &          ,ISOUR,SNGL(FREQ(kfreq))
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
              IWSOUR=ISOUR
              IWFREQ=kfreq
              IW_BLENF=1
            ENDIF !IWSOUR

            SUM=SUM+DSUM
          ENDDO

        ELSE  !IRPHI

          DO IOBSV=1,NOBSV
            FPHIR(IOBSV)=SPECF(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(kfreq-1)))
          ENDDO !IOBSV

          CALL CIRCPIN(NOBSVZ,NOBSVY,MOBSVZ,MOBSVY,FPHIR,SUM,SUMP,ISOUR,kfreq,IERR)
          IF (IERR.NE.0) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'SR CIRCPIN HAD BEEN CALLED BY SR BLENDEF'
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)'SR CIRCPIN HAD BEEN CALLED BY SR BLENDEF'
            WRITE(6,*)
          ENDIF

        ENDIF !IRPHI

      ENDIF !PINCIRC

      WFLUXF(ISOUR+NSOURCE*(kfreq-1))=SUM

      RETURN
      END
+DECK,BLENDEPOWV.
*CMZ :  3.00/00 11/03/2013  15.12.10  by  Michael Scheer
*CMZ :  2.35/01 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.34/09 26/09/2001  14.10.06  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  14.22.44  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  2.13/07 17/02/2000  15.11.12  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.08.20  by  Michael Scheer
*CMZ :  2.13/03 11/01/2000  18.01.43  by  Michael Scheer
*CMZ :  2.10/01 25/02/99  15.57.16  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  15.04.41  by  Michael Scheer
*-- Author : Michael Scheer

      SUBROUTINE BLENDEPOWV(ISOUR,IZ)
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SELF.

C--- INTEGRATES THE SPLINES THAT INTERPOLATE THE POWER INSIDE THE PINHOLE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,sourcef90.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,PHYCON.


      INTEGER ISOUR,IY,IZ,IOBSV
      INTEGER ICAL,IWBLEN,IDUM
      INTEGER IWSOUR
      DOUBLE PRECISION DSUM,DIA

      DOUBLE PRECISION SUMZ(NDOBSVYP),S2(NDOBSVYP),SUM
      DOUBLE PRECISION SUMZP(NDOBSVYP),S2P(NDOBSVYP),SUMP,DSUMP

      DATA ICAL/0/

      IWBLEN=0

      IF (IPINCIRC.EQ.0) THEN

C--- INTEGRATION ALONG VERTICAL AXIS Y

      IF (IF1DIM.NE.2) THEN

      DO IY=1,NOBSVY
          IOBSV=IZ+(IY-1)*NOBSVZ
+SELF,IF=-NEWWAVE.
          SUMZ(IY)=SPECPOW(ISOUR,IOBSV)
+SELF,IF=NEWWAVE.
          SUMZ(IY)=SPECPOW(ISOUR+NSOURCE*(IOBSV-1))
+SELF.
      ENDDO

      ELSE

      DO IY=1,NOBSVY
          IOBSV=IZ+(IY-1)*NOBSVZ
             DIA=ABS((PINR-(PINCEN(2)-OBSV(2,IY)))
     &         *(PINR+(PINCEN(2)-OBSV(2,IY))))
            IF (DIA.GT.0.D0) THEN
               DIA=2.D0*SQRT(DIA)
            ELSE
               DIA=0.D0
            ENDIF
+SELF,IF=-NEWWAVE.
          SUMZ(IY)=DIA*SPECPOW(ISOUR,IOBSV)
+SELF,IF=NEWWAVE.
          SUMZ(IY)=DIA*SPECPOW(ISOUR+NSOURCE*(IOBSV-1))
+SELF.
      ENDDO

      ENDIF !(IF1DIM.NE.2)

      CALL FSPLINDX(OBSVDY,SUMZ,NOBSVY,0.D0,0.D0,S2)

        IF(MOBSVY.GT.1) THEN

          SUM=0.0
          SUMP=0.0

          DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY-1

            DSUM=
     &          OBSVDY*0.5D0
     &          *(SUMZ(IY)+SUMZ(IY+1))
     &          -OBSVDY**3/24.D0
     &          *(S2(IY)+S2(IY+1))

          IF (IW_BLEN.NE.0) THEN
                 DSUMP=
     &          OBSVDY*0.5D0
     &          *(SUMZP(IY)+SUMZP(IY+1))
     &          -OBSVDY**3/24.D0
     &          *(S2P(IY)+S2P(IY+1))
          ENDIF

             IF(
     &              (IWSOUR.NE.ISOUR)
     &              .AND.
     &              DSUM.LT.0.0) THEN
         IF (IW_BLEN.EQ.0) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'*** WARNING SR BLENDEPOWV ***'
              WRITE(LUNGFO,*)
     &              'SPLINE INTEGRATION FAILED, RESULTS NOT RELIABLE'
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
          ENDIF

             IWSOUR=ISOUR
           IW_BLEN=1
           IWBLEN=1
           DO IDUM=1,NOBSVY
         S2P(IDUM)=S2(IDUM)
         SUMZP(IDUM)=SUMZ(IDUM)
         SUMP=SUM
         DSUMP=DSUM
           ENDDO

            ENDIF !IWSOUR

          IF (IWBLEN.NE.0) SUMP=SUMP+DABS(DSUMP)

             SUM=SUM+DSUM

          ENDDO !IY

        ELSEIF (IF1DIM.EQ.2) THEN

         SUM=PI1*PINR*SUMZ(NOBSVY/2+1)/2.D0

         IF (IWBLEN.NE.0) SUMP=PI1*PINR*SUMZP(NOBSVY/2+1)/2.D0

        ELSE !MOBSVY

         SUM=OBSVDY*SUMZ(NOBSVY/2+1)

         IF (IWBLEN.NE.0) SUMP=OBSVDY*SUMZP(NOBSVY/2+1)

        ENDIF !MOBSVY

      ELSE  !IPINCIRC

      WRITE(LUNGFO,*)'*** WARNING IN BLENDEPOWV: ***'
      WRITE(LUNGFO,*)'INTEGRATION OF POWERDENSITY NOT IMPLEMENTED'
      WRITE(LUNGFO,*)'FOR CIRCULAR PINHOLE (ONLY FOR IF1DIM.NE.0).'
      WRITE(LUNGFO,*)'USE PAW AND NTUPLE FOR RAW OFFLINE INTEGRATION'
      WRITE(6,*)'*** WARNING IN BLENDEPOWV: ***'
      WRITE(6,*)'INTEGRATION OF POWERDENSITY NOT IMPLEMENTED'
      WRITE(6,*)'FOR CIRCULAR PINHOLE (ONLY FOR IF1DIM.NE.0).'
      WRITE(6,*)'USE PAW AND NTUPLE FOR RAW OFFLINE INTEGRATION'
      RETURN

      ENDIF !IPINCIRC

+SELF,IF=-NEWWAVE.
      SPECPOWV(ISOUR,IZ)=SUM
+SELF,IF=NEWWAVE.
      SPECPOWV(ISOUR+NSOURCE*(IZ-1))=SUM
+SELF.

      IF (IWBLEN.NE.0) THEN
          IF (ICAL.EQ.0) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'*** SR BLENDEPOWV:'
         WRITE(LUNGFO,*)
     &'LINES INDICATED BY * SHOW A RAW ESTIMATE OF ERRORS DUE TO'
         WRITE(LUNGFO,*)
     &'SPLINE FAILURE IF REL. ERROR .GT. 1E-5 (FIRST NUMBER IS SOURCE)'
         WRITE(LUNGFO,*)
         ICAL=1
          ENDIF   !ICAL
          IF (SUMP.NE.0.D0) THEN
         DSUM=SUM/SUMP
          ELSE
         DSUM=-9999.
          ENDIF
          IF (DABS(DSUM-1.D0).GT.1.D-5) THEN
            WRITE(LUNGFO,*)'*',ISOUR,IZ,
     &        SNGL(SUM),SNGL(SUMP),SNGL(DSUM)
            WRITE(6,*)'*',ISOUR,IZ,
     &        SNGL(SUM),SNGL(SUMP),SNGL(DSUM)
          ENDIF
      ENDIF !IWBLEN

      RETURN
      END
+DECK,BLENDEPOWVH.
*CMZ :  3.00/00 11/03/2013  15.12.10  by  Michael Scheer
*CMZ :  2.50/01 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.34/09 26/09/2001  14.57.05  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  14.22.44  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  2.13/07 17/02/2000  15.11.12  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.08.20  by  Michael Scheer
*CMZ :  2.13/04 21/01/2000  14.56.12  by  Michael Scheer
*CMZ :  2.13/03 11/01/2000  18.01.43  by  Michael Scheer
*CMZ :  2.10/01 25/02/99  15.32.04  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  15.04.41  by  Michael Scheer
*-- Author : Michael Scheer

      SUBROUTINE BLENDEPOWVH(ISOUR)
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SELF.

C--- INTEGRATES THE SPLINES THAT INTERPOLATE THE POWER INSIDE THE PINHOLE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,sourcef90.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,PHYCON.


      INTEGER ISOUR,IZ
      INTEGER ICAL,IWBLEN,IDUM
      INTEGER IWSOUR
      DOUBLE PRECISION DSUM

      DOUBLE PRECISION SUMZ(NDOBSVZP),S2(NDOBSVZP),SUM
      DOUBLE PRECISION SUMZP(NDOBSVZP),S2P(NDOBSVZP),SUMP,DSUMP

      DATA ICAL/0/

      IWBLEN=0

      IF (IPINCIRC.EQ.0) THEN

C--- INTEGRATION ALONG HORIZONTAL AXIS (Z)

      DO IZ=1,NOBSVZ
+SELF,IF=-NEWWAVE.
          SUMZ(IZ)=SPECPOWV(ISOUR,IZ)
+SELF,IF=NEWWAVE.
          SUMZ(IZ)=SPECPOWV(ISOUR+NSOURCE*(IZ-1))
+SELF.
      ENDDO

      CALL FSPLINDX(OBSVDZ,SUMZ,NOBSVZ,0.D0,0.D0,S2)

        IF(MOBSVZ.GT.1) THEN

          SUM=0.0
          SUMP=0.0

          DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ-1

            DSUM=
     &          OBSVDZ*0.5D0
     &          *(SUMZ(IZ)+SUMZ(IZ+1))
     &          -OBSVDZ**3/24.D0
     &          *(S2(IZ)+S2(IZ+1))

          IF (IW_BLEN.NE.0) THEN
                 DSUMP=
     &          OBSVDZ*0.5D0
     &          *(SUMZP(IZ)+SUMZP(IZ+1))
     &          -OBSVDZ**3/24.D0
     &          *(S2P(IZ)+S2P(IZ+1))
          ENDIF

             IF(
     &              (IWSOUR.NE.ISOUR)
     &              .AND.
     &              DSUM.LT.0.0) THEN
         IF (IW_BLEN.EQ.0) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'*** WARNING SR BLENDEPOWVH ***'
              WRITE(LUNGFO,*)
     &              'SPLINE INTEGRATION FAILED, RESULTS NOT RELIABLE'
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
          ENDIF

             IWSOUR=ISOUR
           IW_BLEN=1
           IWBLEN=1
           DO IDUM=1,NOBSVZ
         S2P(IDUM)=S2(IDUM)
         SUMZP(IDUM)=SUMZ(IDUM)
         SUMP=SUM
         DSUMP=DSUM
           ENDDO

            ENDIF !IWSOUR

          IF (IWBLEN.NE.0) SUMP=SUMP+DABS(DSUMP)

             SUM=SUM+DSUM

          ENDDO !IZ

        ELSEIF (IF1DIM.EQ.2) THEN

         SUM=SUMZ(NOBSVZ/2+1)

         IF (IWBLEN.NE.0) SUMP=SUMZP(NOBSVZ/2+1)

        ELSE !MOBSVZ

         SUM=OBSVDZ*SUMZ(NOBSVZ/2+1)

         IF (IWBLEN.NE.0) SUMP=OBSVDZ*SUMZP(NOBSVZ/2+1)

        ENDIF !MOBSVZ

      ELSE  !IPINCIRC

      WRITE(LUNGFO,*)'*** WARNING IN BLENDEPOWVH: ***'
      WRITE(LUNGFO,*)'INTEGRATION OF POWERDENSITY NOT POSSIBLE'
      WRITE(LUNGFO,*)'FOR CIRCULAR PINHOLE, SORRY'
      WRITE(LUNGFO,*)'USE PAW AND NTUPLE FOR RAW OFFLINE INTEGRATION'
      WRITE(6,*)'*** WARNING IN BLENDEPOWVH: ***'
      WRITE(6,*)'INTEGRATION OF POWERDENSITY NOT POSSIBLE'
      WRITE(6,*)'FOR CIRCULAR PINHOLE, SORRY'
      WRITE(6,*)'USE PAW AND NTUPLE FOR RAW OFFLINE INTEGRATION'
      RETURN

      ENDIF !IPINCIRC

      SPECPOWVH(ISOUR)=SUM

      IF (IWBLEN.NE.0) THEN
          IF (ICAL.EQ.0) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'*** SUBROUTINE BLENDEPOWVH:'
         WRITE(LUNGFO,*)
     &'LINES INDICATED BY * SHOW A RAW ESTIMATE OF ERRORS DUE TO'
         WRITE(LUNGFO,*)
     &'SPLINE FAILURE IF REL. ERROR .GT. 1E-5 (FIRST NUMBER IS SOURCE)'
         WRITE(LUNGFO,*)
         ICAL=1
          ENDIF   !ICAL
          IF (SUMP.NE.0.D0) THEN
         DSUM=SUM/SUMP
          ELSE
         DSUM=-9999.
          ENDIF
          IF (DABS(DSUM-1.D0).GT.1.D-5) THEN
            WRITE(LUNGFO,*)'*',ISOUR,
     &        SNGL(SUM),SNGL(SUMP),SNGL(DSUM)
          ENDIF
      ENDIF !IWBLEN

      RETURN
      END
+DECK,BLENDSPECIV.
*CMZ :  3.00/00 11/03/2013  15.12.10  by  Michael Scheer
*CMZ :  2.33/06 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  14.22.46  by  Michael Scheer
*CMZ :  2.16/05 04/08/2000  11.03.38  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  2.13/07 17/02/2000  15.11.12  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.08.20  by  Michael Scheer
*CMZ :  2.13/03 11/01/2000  18.01.43  by  Michael Scheer
*CMZ :  2.10/01 25/02/99  15.57.16  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  15.04.41  by  Michael Scheer
*-- Author : Michael Scheer

      SUBROUTINE BLENDSPECIV(ISOUR,IZ)
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SELF.

C--- INTEGRATES THE SPLINES THAT INTERPOLATE THE POWER INSIDE THE PINHOLE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,sourcef90.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,PHYCON.


      INTEGER ISOUR,IY,IZ,IOBSV
      INTEGER ICAL,IWBLEN,IDUM
      INTEGER IWSOUR
      DOUBLE PRECISION DSUM

      DOUBLE PRECISION SUMZ(NDOBSVYP),S2(NDOBSVYP),SUM
      DOUBLE PRECISION SUMZP(NDOBSVYP),S2P(NDOBSVYP),SUMP,DSUMP

      DATA ICAL/0/

      IWBLEN=0

      IF (IPINCIRC.EQ.0) THEN

C--- INTEGRATION ALONG VERTICAL AXIS Y

      DO IY=1,NOBSVY
          IOBSV=IZ+(IY-1)*NOBSVZ
+SELF,IF=-NEWWAVE.
          SUMZ(IY)=SPECI(ISOUR,IOBSV)
+SELF,IF=NEWWAVE.
          SUMZ(IY)=SPECI(ISOUR+NSOURCE*(IOBSV-1))
+SELF.
      ENDDO

      CALL FSPLINDX(OBSVDY,SUMZ,NOBSVY,0.D0,0.D0,S2)

        IF(MOBSVY.GT.1) THEN

          SUM=0.0
          SUMP=0.0

          DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY-1

            DSUM=
     &          OBSVDY*0.5D0
     &          *(SUMZ(IY)+SUMZ(IY+1))
     &          -OBSVDY**3/24.D0
     &          *(S2(IY)+S2(IY+1))

          IF (IW_BLEN.NE.0) THEN
                 DSUMP=
     &          OBSVDY*0.5D0
     &          *(SUMZP(IY)+SUMZP(IY+1))
     &          -OBSVDY**3/24.D0
     &          *(S2P(IY)+S2P(IY+1))
          ENDIF

             IF(
     &              (IWSOUR.NE.ISOUR)
     &              .AND.
     &              DSUM.LT.0.0) THEN
         IF (IW_BLEN.EQ.0) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'*** WARNING SR BLENDSPECIV ***'
              WRITE(LUNGFO,*)
     &              'SPLINE INTEGRATION FAILED, RESULTS NOT RELIABLE'
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
              ENDIF

             IWSOUR=ISOUR
           IW_BLEN=1
           IWBLEN=1
           DO IDUM=1,NOBSVY
         S2P(IDUM)=S2(IDUM)
         SUMZP(IDUM)=SUMZ(IDUM)
         SUMP=SUM
         DSUMP=DSUM
           ENDDO

            ENDIF !IWSOUR

          IF (IWBLEN.NE.0) SUMP=SUMP+DABS(DSUMP)

             SUM=SUM+DSUM

          ENDDO !IY

        ELSE !MOBSVY

         SUM=OBSVDY*SUMZ(NOBSVY/2+1)

         IF (IWBLEN.NE.0) SUMP=OBSVDY*SUMZP(NOBSVY/2+1)

        ENDIF !MOBSVY

      ELSE  !IPINCIRC

      WRITE(LUNGFO,*)'*** WARNING IN BLENDSPECIV: ***'
      WRITE(LUNGFO,*)'INTEGRATION OF POWERDENSITY NOT POSSIBLE'
      WRITE(LUNGFO,*)'FOR CIRCULAR PINHOLE, SORRY'
      WRITE(LUNGFO,*)'USE PAW AND NTUPLE FOR RAW OFFLINE INTEGRATION'
      WRITE(6,*)'*** WARNING IN BLENDSPECIV: ***'
      WRITE(6,*)'INTEGRATION OF POWERDENSITY NOT POSSIBLE'
      WRITE(6,*)'FOR CIRCULAR PINHOLE, SORRY'
      WRITE(6,*)'USE PAW AND NTUPLE FOR RAW OFFLINE INTEGRATION'
      RETURN

      ENDIF !IPINCIRC

+SELF,IF=-NEWWAVE.
      SPECIV(ISOUR,IZ)=SUM
+SELF,IF=NEWWAVE.
      SPECIV(ISOUR+NSOURCE*(IZ-1))=SUM
+SELF.

      IF (IWBLEN.NE.0) THEN
          IF (ICAL.EQ.0) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'*** SR BLENDSPECIV:'
         WRITE(LUNGFO,*)
     &'LINES INDICATED BY * SHOW A RAW ESTIMATE OF ERRORS DUE TO'
         WRITE(LUNGFO,*)
     &'SPLINE FAILURE IF REL. ERROR .GT. 1E-5 (FIRST NUMBER IS SOURCE)'
         WRITE(LUNGFO,*)
         ICAL=1
          ENDIF   !ICAL
          IF (SUMP.NE.0.D0) THEN
         DSUM=SUM/SUMP
          ELSE
         DSUM=-9999.
          ENDIF
          IF (DABS(DSUM-1.D0).GT.1.D-5) THEN
            WRITE(LUNGFO,*)'*',ISOUR,IZ,
     &        SNGL(SUM),SNGL(SUMP),SNGL(DSUM)
            WRITE(6,*)'*',ISOUR,IZ,
     &        SNGL(SUM),SNGL(SUMP),SNGL(DSUM)
          ENDIF
      ENDIF !IWBLEN

      RETURN
      END
+DECK,BLENSTO.
*CMZ :  3.08/01 01/04/2019  16.57.05  by  Michael Scheer
*CMZ :  3.07/00 15/03/2019  12.57.36  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.10  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  16.23.18  by  Michael Scheer
*CMZ :  2.35/01 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.34/09 26/09/2001  11.56.11  by  Michael Scheer
*CMZ :  2.34/00 11/05/2001  12.20.31  by  Michael Scheer
*CMZ :  2.16/08 24/10/2000  14.15.55  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.08.20  by  Michael Scheer
*CMZ :  2.13/03 12/01/2000  14.27.55  by  Michael Scheer
*CMZ :  2.11/01 18/05/99  11.15.36  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  15.04.42  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  15.13.09  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.47.50  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.03  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BLENSTO(kfreq)
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SELF.

C--- INTEGRATES THE STOKES INTENSITIES

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,PHYCON.

      DOUBLE PRECISION DSUM,RPHI,SUMP

      INTEGER kfreq,IY,IZ,IOBSV
     &  ,ICAL,IR,IP,NR,MR,MP,ISTOK,II,KDUM,IERR

      DOUBLE PRECISION SUMZ(NDOBSVYP),SUM,DIA
      DOUBLE PRECISION SUMY(NDOBSVZP)
      DOUBLE PRECISION R(NDOBSVZP),PHI(NDOBSVYP)
     &  ,FPHI(NDOBSVYP)
     &  ,SZ(NDOBSVZP),SY(NDOBSVYP)
     &  ,SZY(NDOBSVZP,NDOBSVYP)
     &  ,FZ(NDOBSVZP),FY(NDOBSVYP),DPHI,DR,X,Y

      data ical/0/

      if (ipin.eq.3) then
        DO ISTOK=1,4
          if (ipincirc.eq.0) then
            wstokes(istok,kfreq)=stokes(istok,kfreq)*pinh*pinw
          else
            wstokes(istok,kfreq)=stokes(istok,kfreq)*pinr**2*pi1
          endif
        enddo
        return
      endif

      DO ISTOK=1,4

        IF (IPINCIRC.EQ.0) THEN

          IF (IF1DIM.NE.2) THEN

            DO IY=1,NOBSVY

              SUMZ(IY)=0.0d0

              IF(MOBSVZ.GT.1) THEN

                DO IZ=1,NOBSVZ
                  FZ(IZ)=STOKES(ISTOK,(IY-1)*NOBSVZ+IZ+NOBSV*(kfreq-1))
                ENDDO      !IZ

                CALL FSPLINDX(OBSVDZ,FZ,NOBSVZ,0.D0,0.D0,SZ)

                DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ-1

                  DSUM=OBSVDZ*0.5D0
     &              *(FZ(IZ)+FZ(IZ+1))
     &              -OBSVDZ**3/24.D0*(SZ(IZ)+SZ(IZ+1))

                  SUMZ(IY)=SUMZ(IY)+DSUM

                ENDDO   !IZ

              ELSE  !MOBSVZ

                IOBSV=(IY-1)*NOBSVZ+(NOBSVZ-MOBSVZ)/2+1
                SUMZ(IY)=OBSVDZ*STOKES(ISTOK,IOBSV+NOBSV*(kfreq-1))
              ENDIF !MOBSVZ

            ENDDO !IY

          ELSE  !IF1DIM.EQ.2

            DO IY=1,NOBSVY

              SUMZ(IY)=0.0d0

              IOBSV=(IY-1)*NOBSVZ+(NOBSVZ-MOBSVZ)/2+1
              DIA=ABS((PINR-(PINCEN(2)-OBSV(2,IOBSV)))
     &          *(PINR+(PINCEN(2)-OBSV(2,IOBSV))))
              IF (DIA.GT.0.D0) THEN
                DIA=2.D0*SQRT(DIA)
              ELSE
                DIA=0.0D0
              ENDIF
              SUMZ(IY)=DIA*STOKES(ISTOK,IOBSV+NOBSV*(kfreq-1))

            ENDDO !IY

          ENDIF !IF1DIM.EQ.2

C--- INTEGRATION ALONG VERTICAL AXIS Y

          CALL FSPLINDX(OBSVDY,SUMZ,NOBSVY,0.D0,0.D0,SY)

          IF(MOBSVY.GT.1) THEN

            SUM=0.0d0
            DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY-1

              DSUM=
     &          OBSVDY*0.5D0
     &          *(SUMZ(IY)+SUMZ(IY+1))
     &          -OBSVDY**3/24.D0
     &          *(SY(IY)+SY(IY+1))

              SUM=SUM+DSUM

            ENDDO

          ELSE IF (IF1DIM.EQ.2) THEN

            SUM=PI1*PINR*SUMZ(NOBSVY/2+1)/2.D0

          ELSE

            SUM=OBSVDY*SUMZ(NOBSVY/2+1)

          ENDIF

        ELSE  !PINCIRC

          IF (IRPHI.NE.0) THEN !INTEGRATION WITH RESPECT TO POLAR COORDINATES

C--- INTEGRATION OVER PHI

            IF (ICAL.EQ.0) THEN

              DR=DMIN1(OBSVDZ,OBSVDY)
              MR=NINT(PINR/DR)+1
              DR=PINR/(MR-1)
              MEDGER=MIN( MEDGEZ, MEDGEY)
              NR=MR+MEDGER
              MP=MOBSVY

              IF (MR.LT.1) THEN
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'*** ERROR IN BLENSTO ***'
                WRITE(LUNGFO,*)'NOT ENOUGH GRID POINTS FOR CIRCULAR PINHOLE'
                WRITE(LUNGFO,*)'INCREASE PARAMETER MPINZ IN NAMELIST PINHOLE'
                WRITE(LUNGFO,*)
                WRITE(6,*)
                WRITE(6,*)'*** ERROR IN BLENSTO ***'
                WRITE(6,*)'NOT ENOUGH GRID POINTS FOR CIRCULAR PINHOLE'
                WRITE(6,*)'INCREASE PARAMETER MPINZ IN NAMELIST PINHOLE'
                WRITE(6,*)
              ENDIF
              IF (MP.LT.4) THEN
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'*** ERROR IN BLENSTO ***'
                WRITE(LUNGFO,*)'NOT ENOUGH GRID POINTS FOR CIRCULAR PINHOLE'
                WRITE(LUNGFO,*)'INCREASE PARAMETER MPINY IN NAMELIST PINHOLE'
                WRITE(LUNGFO,*)
                WRITE(6,*)
                WRITE(6,*)'*** ERROR IN BLENSTO ***'
                WRITE(6,*)'NOT ENOUGH GRID POINTS FOR CIRCULAR PINHOLE'
                WRITE(6,*)'INCREASE PARAMETER MPINY IN NAMELIST PINHOLE'
                WRITE(6,*)
              ENDIF

              DPHI=2.D0*PI1/(MP-1)
              DO IP=1,MP
                PHI(IP)=(IP-1)*DPHI
              ENDDO

              DO IR=1,NR
                R(IR)=(IR-1)*DR
              ENDDO

              DO IR=2,NR
                DO IP=1,MP
                  XC(IP+(IR-1)*NOBSVY)=R(IR)*DCOS(PHI(IP))+PINCEN(3)
                  YC(IP+(IR-1)*NOBSVY)=R(IR)*DSIN(PHI(IP))+PINCEN(2)
                ENDDO !IP
              ENDDO !IR

              ICAL=1

            ENDIF !ICAL

C--- INTERPOLATION OF INTENSITY FOR CIRCULAR GRID

            DO IY=1,NOBSVY
              DO IZ=1,NOBSVZ
                II=(IY-1)*NOBSVZ+IZ
                FZ(IZ)=STOKES(ISTOK,II+NOBSV*(kfreq-1))
              ENDDO !IZ

              CALL FSPLINDX(OBSVDZ,FZ,NOBSVZ,0.D0,0.D0,SZ)

              DO IZ=1,NOBSVZ
                SZY(IZ,IY)=SZ(IZ)
              ENDDO !IZ

            ENDDO !IY

            DO IR=2,NR
              DO IP=1,MP

                X=XC(IP+(IR-1)*NOBSVY)
                Y=YC(IP+(IR-1)*NOBSVY)

                DO IY=1,NOBSVY

                  DO IZ=1,NOBSVZ
                    FZ(IZ)=STOKES(ISTOK,(IY-1)*NOBSVZ+IZ+NOBSV*(kfreq-1))
                    SZ(IZ)=SZY(IZ,IY)
                  ENDDO      !IZ

                  CALL SPLINZY(NOBSVZ,X,FY(IY),OBSVZ,FZ,SZ,KDUM)

                ENDDO !IY

                CALL FSPLINDX(OBSVDY,FY,NOBSVY,0.D0,0.D0,SY)
                CALL SPLINZY(NOBSVY,Y,FPHIR(IP+(IR-1)*NOBSVY),OBSVY,FY,SY,KDUM)

              ENDDO !IP
            ENDDO !IR

C--- DO THE INTEGRATION OF FPHIR OVER PHI AND R

            SUM=0.0D0
            SUMY(1)=0.0D0
            DO IR=2,NR  !FIRST RADIUS IS ZERO

              DO IP=1,MP
                FPHI(IP)=FPHIR(IP+(IR-1)*NOBSVY)
              ENDDO   !IP

              CALL FSPLPER(DPHI,FPHI,MP,SY)

              SUMY(IR)=0.0D0
              RPHI=R(IR)*DPHI
              DO IP=1,MP-1

                DSUM=
     &            RPHI*0.5D0*(FPHI(IP)+FPHI(IP+1))
     &            -RPHI**3/24.D0*(SY(IP)+SY(IP+1))

                SUMY(IR)=SUMY(IR)+DSUM

              ENDDO   !IP

            ENDDO !IR

            CALL FSPLINDX(DR,SUMY,NR,0.D0,0.D0,SZ)

            SUM=0.0d0
            DO IR=1,MR-1

              DSUM=DR*0.5D0
     &          *(SUMY(IR)+SUMY(IR+1))
     &          -DR**3/24.D0
     &          *(SZ(IR)+SZ(IR+1))

              SUM=SUM+DSUM

            ENDDO

          ELSE  !IRPHI

            DO IOBSV=1,NOBSV
              FPHIR(IOBSV)=STOKES(ISTOK,IOBSV+NOBSV*(kfreq-1))
            ENDDO !IOBSV
            CALL CIRCPIN(NOBSVZ,NOBSVY,MOBSVZ,MOBSVY,FPHIR,SUM,SUMP,-ISTOK,kfreq,IERR)
          ENDIF !IRPHI

        ENDIF !PINCIRC

        WSTOKES(ISTOK,kfreq)=SUM

      ENDDO !ISTO

      RETURN
      END
+DECK,BLENSTOF.
*CMZ :  3.07/00 15/03/2019  13.20.05  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.10  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.35/01 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.34/09 26/09/2001  12.12.32  by  Michael Scheer
*CMZ :  2.34/00 11/05/2001  12.20.49  by  Michael Scheer
*CMZ :  2.16/08 24/10/2000  14.28.41  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.08.20  by  Michael Scheer
*CMZ :  2.13/03 12/01/2000  16.31.33  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  15.04.42  by  Michael Scheer
*CMZ : 00.01/02 24/11/94  15.51.13  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.47.58  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.05  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BLENSTOF(ISTOK,IFREQ)
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.

C--- INTEGRATES THE SPLINES THAT INTERPOLATE THE INTENSITY INSIDE THE PINHOLE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,PHYCON.

      DOUBLE PRECISION DSUM,RPHI,SUMP

      INTEGER IFREQ,ISTOK,IY,IZ,IOBSV,IIY,IIZ
     &  ,ICAL,IR,IP,MR,MP,KDUM,IERR

      DOUBLE PRECISION SUMZ(NDOBSVYP),S2(NDOBSVYP),SUM,SUMY(NDOBSVZP)
      DOUBLE PRECISION OBSVYF(NDOBSVYP),DIA

      DOUBLE PRECISION R(NDOBSVZP),PHI(NDOBSVYP)
     &  ,FPHI(NDOBSVYP)
     &  ,SZ(NDOBSVZP),SY(NDOBSVYP)
     &  ,FZ(NDOBSVZP),FY(NDOBSVYP),DPHI,DR,X,Y
      DOUBLE PRECISION OBSVZF(NDOBSVZP)

      DATA ICAL/0/

C--- TAKE INNER EDGE OF PINHOLE INTO ACCOUNT, I.E. SET MOBSVZ,MOBVY,MOBSV
C    TO ORIGINAL VALUES. THEY HAVE BEEN OVERWRITTEN IN SR WFOLINT

      MOBSVZ=MOBSVZ-2*MMEDGEZ
      MOBSVY=MOBSVY-2*MMEDGEY
      MOBSV=MOBSVZ*MOBSVY

      IF (IPINCIRC.EQ.0) THEN

        IF (IF1DIM.NE.2) THEN

C--- INTEGRATION ALONG HORIZONTAL AXIS Z

          IIY=0
          DO IY=(NOBSVY-MOBSVY-2*MMEDGEY)/2+1,
     &        (NOBSVY-MOBSVY-2*MMEDGEY)/2+MOBSVY+2*MMEDGEY

            IIY=IIY+1
            OBSVYF(IIY)=OBSVY(IY)

            IF(MOBSVZ.GT.1) THEN

              SUMZ(IIY)=0.0d0
              DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ-1

                IOBSV=(IY-1)*NOBSVZ+IZ
                IOBFR=IOBSV+NOBSV*(IFREQ-1)
                DSUM=
     &            OBSVDZ*0.5D0
     &            *(STOKESF(ISTOK,IOBFR)+STOKESF(ISTOK,IOBFR+1))
     &            -OBSVDZ**3/24.D0
     &            *(SPCOEFM(IOBSV)
     &            + SPCOEFM(IOBSV+1))

                SUMZ(IIY)=SUMZ(IIY)+DSUM

              ENDDO   !IZ

            ELSE

              IOBSV=(IY-1)*NOBSVZ+(NOBSVZ-MOBSVZ)/2+1
              SUMZ(IIY)=OBSVDZ*STOKESF(ISTOK,IOBSV+NOBSV*(IFREQ-1))
            ENDIF

          ENDDO !IY

        ELSE   !IF1DIM.EQ.2

C--- INTEGRATION ALONG HORIZONTAL AXIS Z

          IIY=0
          DO IY=(NOBSVY-MOBSVY-2*MMEDGEY)/2+1,
     &        (NOBSVY-MOBSVY-2*MMEDGEY)/2+MOBSVY+2*MMEDGEY


            IIY=IIY+1
            OBSVYF(IIY)=OBSVY(IY)

            IOBSV=(IY-1)*NOBSVZ+(NOBSVZ-MOBSVZ)/2+1
            DIA=ABS((PINR-(PINCEN(2)-OBSV(2,IOBSV)))
     &        *(PINR+(PINCEN(2)-OBSV(2,IOBSV))))
            IF (DIA.GT.0.D0) THEN
              DIA=2.D0*SQRT(DIA)
            ELSE
              DIA=0.D0
            ENDIF
            SUMZ(IIY)=DIA*STOKESF(ISTOK,IOBSV+NOBSV*(IFREQ-1))

          ENDDO !IY

        ENDIF   !IF1DIM.EQ.2

C--- INTEGRATION ALONG VERTICAL AXIS Y

        CALL FSPLINDX(OBSVDY,SUMZ,MOBSVY+2*MMEDGEY,0.D0,0.D0,S2)

        IF(MOBSVY.GT.1) THEN

          SUM=0.0d0

          DO IY=MMEDGEY+1,MMEDGEY+MOBSVY-1

            DSUM=
     &        OBSVDY*0.5D0
     &        *(SUMZ(IY)+SUMZ(IY+1))
     &        -OBSVDY**3/24.D0
     &        *(S2(IY)+S2(IY+1))

            SUM=SUM+DSUM

          ENDDO

        ELSE IF (IF1DIM.EQ.2) THEN

          SUM=PI1*PINR*SUMZ(MMEDGEY+1)/2.D0

        ELSE

          SUM=OBSVDY*SUMZ(MMEDGEY+1)

        ENDIF

      ELSE  !IPINCIRC

C--- INTEGRATION OVER PHI

        IF (IRPHI.NE.0) THEN !INTEGRATION WITH RESPECT TO POLAR COORDINATES

          IF (ICAL.EQ.0) THEN

            DR=DMIN1(OBSVDZ,OBSVDY)
            MR=NINT(PINR/DR)+1
            DR=PINR/(MR-1)
            MEDGER=MIN(MMEDGEZ,MMEDGEY)
            MP=MOBSVY

            IF (MR.LT.1) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'*** ERROR IN BLENSTOF ***'
              WRITE(LUNGFO,*)'NOT ENOUGH GRID POINTS FOR CIRCULAR PINHOLE'
              WRITE(LUNGFO,*)'INCREASE PARAMETER MPINZ IN NAMELIST PINHOLE'
              WRITE(LUNGFO,*)
              WRITE(6,*)
              WRITE(6,*)'*** ERROR IN BLENSTOF ***'
              WRITE(6,*)'NOT ENOUGH GRID POINTS FOR CIRCULAR PINHOLE'
              WRITE(6,*)'INCREASE PARAMETER MPINZ IN NAMELIST PINHOLE'
              WRITE(6,*)
            ENDIF
            IF (MP.LT.4) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'*** ERROR IN BLENSTOF ***'
              WRITE(LUNGFO,*)'NOT ENOUGH GRID POINTS FOR CIRCULAR PINHOLE'
              WRITE(LUNGFO,*)'INCREASE PARAMETER MPINY IN NAMELIST PINHOLE'
              WRITE(LUNGFO,*)
              WRITE(6,*)
              WRITE(6,*)'*** ERROR IN BLENSTOF ***'
              WRITE(6,*)'NOT ENOUGH GRID POINTS FOR CIRCULAR PINHOLE'
              WRITE(6,*)'INCREASE PARAMETER MPINY IN NAMELIST PINHOLE'
              WRITE(6,*)
            ENDIF

            DPHI=2.D0*PI1/(MP-1)
            DO IP=1,MP
              PHI(IP)=(IP-1)*DPHI
            ENDDO

            DO IR=1,MR+MEDGER
              R(IR)=(IR-1)*DR
            ENDDO

            DO IR=2,MR+MEDGER
              DO IP=1,MP
                XC(IP+(IR-1)*NOBSVY)=R(IR)*DCOS(PHI(IP))+PINCEN(3)
                YC(IP+(IR-1)*NOBSVY)=R(IR)*DSIN(PHI(IP))+PINCEN(2)
              ENDDO !IP
            ENDDO !IR

            ICAL=1

          ENDIF !ICAL

C--- INTERPOLATION OF INTENSITY FOR CIRCULAR GRID

          DO IR=2,MR+MEDGER
            DO IP=1,MP

              X=XC(IP+(IR-1)*NOBSVY)
              Y=YC(IP+(IR-1)*NOBSVY)

              IIY=0
              DO IY=(NOBSVY-MOBSVY-2*MMEDGEY)/2+1,
     &            (NOBSVY-MOBSVY-2*MMEDGEY)/2+MOBSVY+2*MMEDGEY
                IIY=IIY+1

                IIZ=0
                DO IZ=(NOBSVZ-MOBSVZ-2*MMEDGEZ)/2+1,
     &              (NOBSVZ-MOBSVZ-2*MMEDGEZ)/2+MOBSVZ+2*MMEDGEZ
                  IIZ=IIZ+1
                  IOBSV=(IY-1)*NOBSVZ+IZ
                  FZ(IIZ)=STOKESF(ISTOK,IOBSV+NOBSV*(IFREQ-1))
                  SZ(IIZ)=SPCOEFM(IOBSV)
                  OBSVZF(IIZ)=OBSVZ(IZ)
                ENDDO !IZ

                CALL SPLINZY(IIZ,X,FY(IIY),OBSVZF,FZ,SZ,KDUM)

                OBSVYF(IIY)=OBSVY(IY)

              ENDDO !IY

              CALL FSPLINDX(OBSVDY,FY,IIY,0.D0,0.D0,SY)
              CALL SPLINZY(IIY,Y,FPHIR(IP+(IR-1)*NOBSVY),OBSVYF,FY,SY,KDUM)

            ENDDO !IP
          ENDDO !IR

C--- DO THE INTEGRATION OF FPHIR OVER PHI AND R

          SUM=0.0D0
          SUMY(1)=0.0D0
          DO IR=2,MR+MEDGER !FIRST RADIUS IS ZERO

            DO IP=1,MP
              FPHI(IP)=FPHIR(IP+(IR-1)*NOBSVY)
            ENDDO   !IP

            CALL FSPLPER(DPHI,FPHI,MP,SY)

            SUMY(IR)=0.0D0
            RPHI=R(IR)*DPHI
            DO IP=1,MP-1

              DSUM=
     &          RPHI*0.5D0*(FPHI(IP)+FPHI(IP+1))
     &          -RPHI**3/24.D0*(SY(IP)+SY(IP+1))

              SUMY(IR)=SUMY(IR)+DSUM

            ENDDO   !IP

          ENDDO !IR

          CALL FSPLINDX(DR,SUMY,MR+MEDGER,0.D0,0.D0,SZ)

          SUM=0.0d0
          DO IR=1,MR-1

            DSUM=
     &        DR*0.5D0
     &        *(SUMY(IR)+SUMY(IR+1))
     &        -DR**3/24.D0
     &        *(SZ(IR)+SZ(IR+1))

            SUM=SUM+DSUM

          ENDDO

        ELSE  !IRPHI

          DO IOBSV=1,NOBSV
            FPHIR(IOBSV)=STOKESF(ISTOK,IOBSV+NOBSV*(IFREQ-1))
          ENDDO !IOBSV

          CALL CIRCPIN(NOBSVZ,NOBSVY,MOBSVZ,MOBSVY,FPHIR,SUM,SUMP,-ISTOK,IFREQ,IERR)

        ENDIF !IRPHI

      ENDIF !PINCIRC

      WSTOKESF(ISTOK,IFREQ)=SUM

      RETURN
      END
+DECK,BLINE.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  16.22.05  by  Michael Scheer
*CMZ :  1.00/00 09/06/97  12.17.43  by  Michael Scheer
*-- Author : Michael Scheer   09/06/97

      SUBROUTINE BLINE(X,Y,Z,BX,BY,BZ)
+seq,gplhint.

      IMPLICIT NONE

      DOUBLE PRECISION X,Y,Z,BX,BY,BZ,CURRU,CENXU,CENYU,CURRD,CENXD,CENYD
     &,RX1,RX2,RY1,RY2,R31,R32
     &,RX3,RX4,RY3,RY4,R33,R34
     &,BXU,BXD,BYU,BYD,BZU,BZD

+SEQ,USERVAR.

      Z=Z

      CURRU=USER(1)
      CENXU=USER(2)
      CENYU=USER(3)
      CURRD=USER(4)
      CENXD=USER(5)
      CENYD=USER(6)

      RX1=X-CENXU
      RY1=Y-CENYU
      RX2=X+CENXU
      RY2=Y-CENYU

      RX3=X-CENXD
      RY3=Y-CENYD
      RX4=X+CENXD
      RY4=Y-CENYD

      R31=DABS(RX1*RX1+RY1*RY1)
      R32=DABS(RX2*RX2+RY2*RY2)
      R33=DABS(RX3*RX3+RY3*RY3)
      R34=DABS(RX4*RX4+RY4*RY4)

      BXU= CURRU*(RY1/R31-RY2/R32)
      BYU=-CURRU*(RX1/R31-RX2/R32)
      BZU=0.D0
      BXD= CURRD*(RY3/R33-RY4/R34)
      BYD=-CURRD*(RX3/R33-RX4/R34)
      BZD=0.D0

      BX=BXU+BXD
      BY=BYU+BYD
      BZ=BZU+BZD

      END
+DECK,BMAGSEQ.
*CMZ :  4.01/07 19/01/2025  08.40.03  by  Michael Scheer
*CMZ :  4.00/11 26/07/2021  08.38.41  by  Michael Scheer
*CMZ :  4.00/07 09/07/2020  12.27.02  by  Michael Scheer
*CMZ :  3.06/00 11/02/2019  12.49.00  by  Michael Scheer
*CMZ :  3.04/00 16/01/2018  17.30.02  by  Michael Scheer
*CMZ :  3.03/04 11/10/2017  11.26.09  by  Michael Scheer
*CMZ :  3.03/02 18/03/2016  14.37.19  by  Michael Scheer
*CMZ :  3.02/00 28/08/2014  08.47.45  by  Michael Scheer
*CMZ :  3.01/01 29/07/2013  14.03.24  by  Michael Scheer
*CMZ :  3.01/00 17/07/2013  16.10.24  by  Michael Scheer
*CMZ :  3.00/01 28/03/2013  12.44.42  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.68/03 07/08/2012  11.36.24  by  Michael Scheer
*CMZ :  2.68/02 06/07/2012  13.23.04  by  Michael Scheer
*CMZ :  2.67/06 24/05/2012  12.31.33  by  Michael Scheer
*CMZ :  2.66/20 06/07/2011  09.41.56  by  Michael Scheer
*CMZ :  2.66/07 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.63/05 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  2.61/02 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  10.56.03  by  Michael Scheer
*CMZ :  2.52/11 06/12/2004  15.54.00  by  Michael Scheer
*CMZ :  2.47/10 30/05/2003  11.44.20  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.20/03 23/02/2001  11.01.50  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  1.02/03 07/01/98  11.52.22  by  Michael Scheer
*CMZ :  1.02/00 06/01/98  15.08.07  by  Michael Scheer
*CMZ :  1.01/00 28/10/97  12.14.09  by  Michael Scheer
*CMZ : 00.01/08 01/04/95  16.54.24  by  Michael Scheer
*CMZ : 00.01/07 10/03/95  11.22.55  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  15.21.20  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.48.03  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.42  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BMAGSEQ(XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT)
+seq,gplhint.

C--- READ DATA-FILE BMAGSEQ.IN, THAT CONTAINS MAGNET CONFIGURATION
C    STRUCTURE IS CENTERED AROUND ORIGIN

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,CMPARA.
+seq,B0SCGLOB.
+SEQ,MYFILES.
+SEQ,PHYCON.

      INTEGER :: ICAL,IM,ieof,imag,ifour,nrotmg,ir,irot,ifound

+SEQ,fourier.
+SEQ,MGSQC.

      DOUBLE PRECISION BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT
      DOUBLE PRECISION XIN,YIN,ZIN,x3(3),z3(3),xc,zc,a(3,3),ainv(3,3)
      double precision shift,xcen,perlen,pern,xlamb,ahwpol,totlen,vin(3)

      DOUBLE PRECISION VN,BETA,V0,X1,Y1,Z1,X2,Y2,Z2
     &  ,VX1,VY1,VZ1,VX2,VY2,VZ2,ANG1z,ANG2z,DANGz,ang1y,ang2y,dangy
     &  ,DTIM,BSHIFT,xlen2,dint,bx,by,bz,
     &  xfour(nfoumagcp+2+2),dxfour,
     &  posi(7,5),edge(2),strength,angle,dlength,seclen,
     &  fint,gap,hgap,de,ds,dum,r,xexit,zexit,fringe,fa,fb,fc,angex

      COMPLEX CKOEF(nfoumagcp/2+1+2)
      REAL*4  YFOUR(nfoumagcp+2+2)
      EQUIVALENCE (CKOEF,YFOUR)

      integer ip,i1,i,mfour,k,istatus,ifail,modus

      character(32) cbmodel,cposmodel
      CHARACTER(3) CDUM2
      CHARACTER(5) CDUM1
      CHARACTER(256) cnam(nmgsqp),clow

      save ical, cnam

      DATA ICAL/0/

C--- INITIALISATION

      IF (ICAL.EQ.0) THEN

C- OPEN FILE, READ FIRST TIME IN ORDER TO DECODE MAGNET-TYPES


        OPEN(UNIT=LUNMG,FILE=FILEMG,FORM='FORMATTED',STATUS='OLD')

        mmag=0
        nrotmg=0
        rotmg=0.0d0
        pmag=0.0d0

        DO IM=1,NMGSQP

          call util_skip_commentblock_end(lunmg,ieof)
          if (ieof.ne.0) goto 99

          READ(LUNMG,*,END=99) cnam(im),CTYP(IM)
          clow=trim(cnam(im))
          call util_lower_case(clow)

          backspace(lunmg)

          if (clow.eq.'rotate') then
            ifound=0
            do i=1,mmag
              if (cnam(i).eq.ctyp(im)) then
                ifound=i
                exit
              endif
            enddo
            if (ifound.eq.0) then
              write(6,*)"*** Error in BMAGSEQ: To many rotations or shifts for magnet ",cnam(im)
              write(6,*)"*** Limit is 10, will ignore it"
              cycle
            endif
            if (pmag(19,i).ge.10.0d0) then
              write(6,*)"*** Error in BMAGSEQ: To many rotations or shifts for magnet ",cnam(im)
              write(6,*)"*** Limit is 10, will ignore it"
              read(lunmg,*)cdum1,cdum2
            else
              nrotmg=nrotmg+1
              pmag(19,i)=pmag(19,i)+1.0d0
              irot=int(pmag(19,i))
              read(lunmg,*)cdum1,cdum2,rotmg(1:7,irot,i)
            endif
            pmag(19,im)=pmag(19,i)
          else if (clow.eq.'brotate') then
            ifound=0
            do i=1,mmag
              if (cnam(i).eq.ctyp(im)) then
                ifound=i
                exit
              endif
            enddo
            if (ifound.eq.0) then
              write(6,*)"*** Error in BMAGSEQ: To many rotations or shifts for magnet ",cnam(im)
              write(6,*)"*** Limit is 10, will ignore it"
              cycle
            endif
            if (pmag(19,i).ge.10.0d0) then
              write(6,*)"*** Error in BMAGSEQ: To many rotations or shifts for magnet ",cnam(im)
              write(6,*)"*** Limit is 10, will ignore it"
              read(lunmg,*)cdum1,cdum2
            else
              nrotmg=nrotmg+1
              pmag(19,i)=pmag(19,i)+1.0d0
              irot=int(pmag(19,i))
              read(lunmg,*)cdum1,cdum2,rotmg(1:7,irot,i)
              pmag(20,i)=nrotmg
            endif
            pmag(19:20,im)=pmag(19:20,i)
          else if (clow.eq.'shift') then
            ifound=0
            do i=1,mmag
              if (cnam(i).eq.ctyp(im)) then
                ifound=i
                exit
              endif
            enddo
            if (ifound.eq.0) then
              write(6,*)"*** Error in BMAGSEQ: To many rotations or shifts for magnet ",cnam(im)
              write(6,*)"*** Limit is 10, will ignore it"
              cycle
            endif
            if (pmag(19,i).ge.10.0d0) then
              write(6,*)"*** Error in BMAGSEQ: To many rotations or shifts for magnet ",cnam(im)
              write(6,*)"*** Limit is 10, will ignore it"
              read(lunmg,*)cdum1,cdum2
            else
              nrotmg=nrotmg+1
              pmag(19,i)=pmag(19,i)+1.0d0
              irot=int(pmag(19,i))
              read(lunmg,*)cdum1,cdum2,rotmg(1:3,irot,i)
              rotmg(7,irot,i)=-9999.0d0
            endif
          else
            IF     (CTYP(IM).EQ.'DI') THEN
              pmag(1:6,im)=0.0d0
              call util_skip_commentblock_end(lunmg,ieof)
              READ(LUNMG,*,iostat=istatus)CDUM1,CDUM2,PMAG(1:5,IM)
              if (istatus.ne.0) then
c              rewind(lunmg)
                backspace(lunmg)
                backspace(lunmg)
                READ(LUNMG,*)CDUM1,CDUM2,PMAG(1:4,IM)
                pmag(5,im)=0.0d0
              endif
              pmag(6,im)=sin(pmag(5,im)*grarad1)
              pmag(5,im)=cos(pmag(5,im)*grarad1)

            else IF (
     &          CTYP(IM).EQ.'SANDW'
     &          ) THEN

              call util_skip_commentblock_end(lunmg,ieof)

              read(lunmg,*)cdum1,cdum2,pmag(14,im),pmag(1:12,im),cbmodel,fint,gap

              hgap=gap/2.0d0

              call util_lower_case(cbmodel)

              pmag(13,im)=0.0d0
              if (cbmodel.eq.'linear') then
                pmag(13,im)=1.0d0
              else if (cbmodel.eq.'cubic-spline') then
                pmag(13,im)=3.0d0
              else if (cbmodel.eq.'quintic-spline') then
                pmag(13,im)=5.0d0
              endif

              call sbend_fringe(cbmodel,fint,hgap,
     &          pmag(15,im),pmag(16,im),pmag(17,im),pmag(18,im),istatus)

              if (strength.ne.0.0d0) then
                r=abs(dbrho)/strength
              else
                r=0.0d0
              endif

              if (strength.ne.0.0d) then
                r=dbrho/strength
                dibounds(1,im)=pmag(1,im)
                dibounds(2,im)=pmag(7,im)
              endif

            else IF (
     &          CTYP(IM).EQ.'SBEND' .or.
     &          CTYP(IM).EQ.'RBEND'
     &          ) THEN

              call util_skip_commentblock_end(lunmg,ieof)

              read(lunmg,*)cdum1,cdum2,strength,angle,fint,gap,cbmodel,xexit,zexit,cposmodel,angex

              !hard edge as starting point:

              hgap=gap/2.0d0

              call util_lower_case(cbmodel)
              call util_lower_case(cposmodel)

              if (

     &            cposmodel.ne.'entrance'.and.
     &            cposmodel.ne.'zenith'.and.
     &            cposmodel.ne.'exit'
     &            ) then
                print*,"*** Error in BMAGSEQ: Unknown alignmet model: ",cposmodel
                print*,"*** Using exit mode ***"
                cposmodel="exit"
              endif

              if (strength.ne.0.0d0) then
                r=abs(dbrho)/strength
              else
                r=0.0d0
              endif

               ds=1.0D0/dble(myinum)

               if (CTYP(IM).EQ.'SBEND') then
                 call sbend(nmgsqp,im,cbmodel,r,dbrho,angle,fint,hgap,
     &             cposmodel,xexit,zexit,angex,dmyenergy,strength,bmovecut,ds,icharge,fringe,fa,fb,fc,istatus)
               else
                 call sbend(-nmgsqp,im,cbmodel,r,dbrho,angle,fint,hgap,
     &             cposmodel,xexit,zexit,angex,dmyenergy,strength,bmovecut,ds,icharge,fringe,fa,fb,fc,istatus)
               endif

              if (strength.ne.0.0d) then
                r=dbrho/strength
                dibounds(1,im)=pmag(1,im)-abs(r*sin(pmag(8,im)))
                dibounds(2,im)=pmag(5,im)+abs(r*sin(pmag(9,im)))
              else
                r=1.0d30
                dibounds(1,im)=pmag(1,im)
                dibounds(2,im)=pmag(5,im)
              endif

            else IF (CTYP(IM).EQ.'DIL') THEN
              call util_skip_commentblock_end(lunmg,ieof)
              READ(LUNMG,*)CDUM1,CDUM2,PMAG(1:10,IM)
              ds=sqrt(pmag(8,im)**2+pmag(9,im)**2+pmag(10,im)**2)
              if (ds.eq.0.0d0) then
                print*," "
                print*,"*** Error in bmagseq: Bad normal vector for entrance plane of DCS element ***"
                print*," "
                stop
              else
                pmag(8:10,im)=pmag(8:10,im)/ds
              endif
              ds=1.0D0/dble(myinum)
              cbmodel="linear"
              angle=pmag(1,im)*radgra1
              dlength=pmag(1,im)*pmag(2,im)
              edge=angle/2.0d0
              fint=pmag(6,im)
              hgap=pmag(7,im)/2.0d0
              call csbend(cbmodel,strength,angle,dlength,edge,seclen,
     &          posi,fint,hgap,de,dmyenergy,bmovecut,ds,istatus)
              pmag(11,im)=seclen
              pmag(12,im)=strength

            else IF (CTYP(IM).EQ.'DQSO') THEN
              call util_skip_commentblock_end(lunmg,ieof)
              READ(LUNMG,*)CDUM1,CDUM2,PMAG(1:10,IM)
              ds=sqrt(pmag(8,im)**2+pmag(9,im)**2+pmag(10,im)**2)
              if (ds.eq.0.0d0) then
                print*," "
                print*,"*** Error in bmagseq: Bad normal vector for entrance plane of DQS element ***"
                print*," "
                stop
              else
                pmag(8:10,im)=pmag(8:10,im)/ds
              endif
              ds=1.0D0/dble(myinum)
              cbmodel="quintic-spline"
              angle=pmag(1,im)*radgra1
              dlength=pmag(1,im)*pmag(2,im)
              edge=angle/2.0d0
              fint=pmag(6,im)
              hgap=pmag(7,im)/2.0d0
              call csbend(cbmodel,strength,angle,dlength,edge,seclen,
     &          posi,fint,hgap,de,dmyenergy,bmovecut,ds,istatus)
              pmag(11,im)=seclen
              pmag(12,im)=strength

            else IF (CTYP(IM).EQ.'DQS') THEN
              call util_skip_commentblock_end(lunmg,ieof)
              READ(LUNMG,*)CDUM1,CDUM2,PMAG(1:10,IM)
              ds=sqrt(pmag(8,im)**2+pmag(9,im)**2+pmag(10,im)**2)
              if (ds.eq.0.0d0) then
                print*," "
                print*,"*** Error in bmagseq: Bad normal vector for entrance plane of DQS element ***"
                print*," "
                stop
              else
                pmag(8:10,im)=pmag(8:10,im)/ds
              endif
              ds=1.0D0/dble(myinum)
              cbmodel="quintic-spline"
              angle=pmag(1,im)*radgra1
              dlength=pmag(1,im)*pmag(2,im)
              edge=angle/2.0d0
              fint=pmag(6,im)
              hgap=pmag(7,im)/2.0d0
              call csbend(cbmodel,strength,angle,dlength,edge,seclen,
     &          posi,fint,hgap,de,dmyenergy,bmovecut,ds,istatus)
              pmag(11,im)=seclen
              pmag(12,im)=strength

            else IF (CTYP(IM).EQ.'DH') THEN
              call util_skip_commentblock_end(lunmg,ieof)
              READ(LUNMG,*)CDUM1,CDUM2,
     &          PMAG(1,IM),PMAG(2,IM),PMAG(3,IM),PMAG(4,IM)
            else IF (CTYP(IM).EQ.'DIF') THEN
              pmag(1:7,im)=0.0d0
              nfoumags=nfoumags+1
              call util_skip_commentblock_end(lunmg,ieof)
              READ(LUNMG,*,iostat=istatus)CDUM1,CDUM2,PMAG(1:7,IM)
              if (istatus.ne.0) then
c              rewind(lunmg)
                backspace(lunmg)
                backspace(lunmg)
                READ(LUNMG,*)CDUM1,CDUM2,PMAG(1:6,IM)
                pmag(7,im)=0.0d0
              endif
              pmag(8,im)=sin(pmag(7,im)*grarad1)
              pmag(7,im)=cos(pmag(7,im)*grarad1)
              xfoubounds(4,nfoumags)=pmag(5,im)
              xfoubounds(5,nfoumags)=pmag(6,im)
              if (pmag(6,im).gt.nfoumagcp) then
                print*,"*** Error in BMAGSEQ: Number of Fourier coefficients exceeds dimension nfoumagcp =",nfoumagcp,"  ***"
                stop "*** Program WAVE aborted ***"
              endif
            else IF (CTYP(IM).EQ.'DHF') THEN
              nfoumags=nfoumags+1
              call util_skip_commentblock_end(lunmg,ieof)
              READ(LUNMG,*)CDUM1,CDUM2,
     &          PMAG(1,IM),PMAG(2,IM),PMAG(3,IM),PMAG(4,IM),
     &          pmag(5,im),pmag(6,im)
              xfoubounds(4,nfoumags)=pmag(5,im)
              xfoubounds(5,nfoumags)=pmag(6,im)
              if (pmag(6,im).gt.nfoumagcp) then
                print*,"*** Error in BMAGSEQ: Number of Fourier coefficients exceeds dimension nfoumagcp =",nfoumagcp,"  ***"
                stop "*** Program WAVE aborted ***"
              endif
            ELSE IF (CTYP(IM).EQ.'QP'.OR.CTYP(IM).EQ.'QF') THEN
              call util_skip_commentblock_end(lunmg,ieof)
              READ(LUNMG,*)CDUM1,CDUM2,
     &          PMAG(1,IM),PMAG(2,IM),PMAG(3,IM),PMAG(4,IM),PMAG(5,IM)
            ELSE IF (CTYP(IM).EQ.'SX') THEN
              call util_skip_commentblock_end(lunmg,ieof)
              READ(LUNMG,*)CDUM1,CDUM2,
     &          PMAG(1,IM),PMAG(2,IM),PMAG(3,IM),PMAG(4,IM),PMAG(5,IM)
            ELSE IF (CTYP(IM).EQ.'UE') THEN
              call util_skip_commentblock_end(lunmg,ieof)
              READ(LUNMG,*)CDUM1,CDUM2,
     &          PMAG(1:13,IM)
              ! 1. 2.   3.     4.    5.      6.     7.     8.       9.   10.
              ! K  B0V, B0H, Shift, XCen, PerLen, NPer, Lambda_X, Nharm Eharm
              ! 11.     12.    13.
              ! ctaper z-shift ang
              shift=pmag(4,im)
              xcen=pmag(5,im)
              perlen=pmag(6,im)
              pern=pmag(7,im)
              xlamb=pmag(8,im)
              ahwpol=((pern-1.0d0)*2+1.0d0)
              totlen=perlen*((ahwpol-1.0d0)/2.0d0+1.0d0)+shift
              uebounds(1,im)=xcen-0.5d0*totlen
              uebounds(2,im)=xcen+0.5d0*totlen
            ELSE

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'*** ERROR IN BMAGSEQ ***'
              WRITE(LUNGFO,*)'ILLEGAL MAGNET TYP >> ',ctyp(im), ' << ON FILE FILEMG'
              WRITE(LUNGFO,*)
              WRITE(6,*)
              WRITE(6,*)'*** ERROR IN BMAGSEQ ***'
              WRITE(6,*)'ILLEGAL MAGNET TYP >> ',ctyp(im), ' << ON FILE FILEMG'
              WRITE(6,*)

              STOP

            ENDIF !CTYP

            mmag=mmag+1
            cnam(mmag)=cnam(im)
            ctyp(mmag)=ctyp(im)
            pmag(:,mmag)=pmag(:,im)

          endif

c          if (ctyp(im).eq.'BEND') then
c            call util_skip_commentblock_end(lunmg,ieof)
c            READ(LUNMG,*,END=99) DUM
c          endif
        ENDDO !IM

99      CONTINUE

+self,if=mgrere.
C- REWIND FILE AND READ AGAIN TO GET PARAMETERS

        REWIND(LUNMG)

        nfoumags=0

        DO IM=1,mmag

          call util_skip_commentblock_end(lunmg,ieof)
          CORR(IM)=1.0D0

          IF     (CTYP(IM).EQ.'DI') THEN
            pmag(1:6,im)=0.0d0
            call util_skip_commentblock_end(lunmg,ieof)
            READ(LUNMG,*,iostat=istatus)CDUM1,CDUM2,PMAG(1:5,IM)
            if (istatus.ne.0) then
c              rewind(lunmg)
              backspace(lunmg)
              backspace(lunmg)
              READ(LUNMG,*)CDUM1,CDUM2,PMAG(1:4,IM)
              pmag(5,im)=0.0d0
            endif
            pmag(6,im)=sin(pmag(5,im)*grarad1)
            pmag(5,im)=cos(pmag(5,im)*grarad1)

          else IF (CTYP(IM).EQ.'BEND') THEN

            ! 1-2: x,z of point in entrance plane
            ! 3-4: x,z of point in orbit plane
            ! 5-6: x,z of point in exit plane
            ! 7-9: field strength, angles of entrance and exit planes
            ! 10-11: fint, gap
            ! 12: mode

            call util_skip_commentblock_end(lunmg,ieof)
            read(lunmg,*)cdum1,cdum2,pmag(7:12,im)
            call util_skip_commentblock_end(lunmg,ieof)
            read(lunmg,*)pmag(1:6,im)

            if (pmag(12,im).ne.3.0d0.and.pmag(12,im).ne.5.0d0) pmag(10:11,im)=0.0d0

            strength=pmag(7,im)

            x3=[pmag(1,im),pmag(3,im),pmag(5,im)]
            z3=[pmag(2,im),pmag(4,im),pmag(6,im)]

            call util_circle(x3,z3,xc,zc,r)

            if (strength.ne.0.0d) then
              r=dbrho/strength
              dibounds(1,im)=pmag(1,im)-abs(r*sin(pmag(8,im)))
              dibounds(2,im)=pmag(5,im)+abs(r*sin(pmag(9,im)))
            else
              r=1.0d30
              dibounds(1,im)=pmag(1,im)
              dibounds(2,im)=pmag(5,im)
            endif

            pmag(14,im)=cos(pmag(8,im))
            pmag(15,im)=sin(pmag(8,im))
            pmag(16,im)=cos(pmag(9,im))
            pmag(17,im)=sin(pmag(9,im))

          else IF (CTYP(IM).EQ.'DIL') THEN
            call util_skip_commentblock_end(lunmg,ieof)
            READ(LUNMG,*)CDUM1,CDUM2,PMAG(1:10,IM)
            ds=sqrt(pmag(8,im)**2+pmag(9,im)**2+pmag(10,im)**2)
            if (ds.eq.0.0d0) then
              print*," "
              print*,"*** Error in bmagseq: Bad normal vector for entrance plane of DCS element ***"
              print*," "
              stop
            else
              pmag(8:10,im)=pmag(8:10,im)/ds
            endif
            ds=1.0D0/dble(myinum)
            cbmodel="linear"
            angle=pmag(1,im)*radgra1
            dlength=pmag(1,im)*pmag(2,im)
            edge=angle/2.0d0
            fint=pmag(6,im)
            hgap=pmag(7,im)/2.0d0
            call csbend(cbmodel,strength,angle,dlength,edge,seclen,
     &        posi,fint,hgap,de,dmyenergy,bmovecut,ds,istatus)
            pmag(11,im)=seclen
            pmag(12,im)=strength

          else IF (CTYP(IM).EQ.'DQSO') THEN
            call util_skip_commentblock_end(lunmg,ieof)
            READ(LUNMG,*)CDUM1,CDUM2,PMAG(1:10,IM)
            ds=sqrt(pmag(8,im)**2+pmag(9,im)**2+pmag(10,im)**2)
            if (ds.eq.0.0d0) then
              print*," "
              print*,"*** Error in bmagseq: Bad normal vector for entrance plane of DQS element ***"
              print*," "
              stop
            else
              pmag(8:10,im)=pmag(8:10,im)/ds
            endif
            ds=1.0D0/dble(myinum)
            cbmodel="quintic-spline"
            angle=pmag(1,im)*radgra1
            dlength=pmag(1,im)*pmag(2,im)
            edge=angle/2.0d0
            fint=pmag(6,im)
            hgap=pmag(7,im)/2.0d0
            call csbend(cbmodel,strength,angle,dlength,edge,seclen,
     &        posi,fint,hgap,de,dmyenergy,bmovecut,ds,istatus)
            pmag(11,im)=seclen
            pmag(12,im)=strength

          else IF (CTYP(IM).EQ.'DQS') THEN
            call util_skip_commentblock_end(lunmg,ieof)
            READ(LUNMG,*)CDUM1,CDUM2,PMAG(1:10,IM)
            ds=sqrt(pmag(8,im)**2+pmag(9,im)**2+pmag(10,im)**2)
            if (ds.eq.0.0d0) then
              print*," "
              print*,"*** Error in bmagseq: Bad normal vector for entrance plane of DQS element ***"
              print*," "
              stop
            else
              pmag(8:10,im)=pmag(8:10,im)/ds
            endif
            ds=1.0D0/dble(myinum)
            cbmodel="quintic-spline"
            angle=pmag(1,im)*radgra1
            dlength=pmag(1,im)*pmag(2,im)
            edge=angle/2.0d0
            fint=pmag(6,im)
            hgap=pmag(7,im)/2.0d0
            call csbend(cbmodel,strength,angle,dlength,edge,seclen,
     &        posi,fint,hgap,de,dmyenergy,bmovecut,ds,istatus)
            pmag(11,im)=seclen
            pmag(12,im)=strength

          else IF (CTYP(IM).EQ.'DH') THEN
            call util_skip_commentblock_end(lunmg,ieof)
            READ(LUNMG,*)CDUM1,CDUM2,
     &        PMAG(1,IM),PMAG(2,IM),PMAG(3,IM),PMAG(4,IM)
          else IF (CTYP(IM).EQ.'DIF') THEN
            pmag(1:7,im)=0.0d0
            nfoumags=nfoumags+1
            call util_skip_commentblock_end(lunmg,ieof)
            READ(LUNMG,*,iostat=istatus)CDUM1,CDUM2,PMAG(1:7,IM)
            if (istatus.ne.0) then
c              rewind(lunmg)
              backspace(lunmg)
              backspace(lunmg)
              READ(LUNMG,*)CDUM1,CDUM2,PMAG(1:6,IM)
              pmag(7,im)=0.0d0
            endif
            pmag(8,im)=sin(pmag(7,im)*grarad1)
            pmag(7,im)=cos(pmag(7,im)*grarad1)
            xfoubounds(4,nfoumags)=pmag(5,im)
            xfoubounds(5,nfoumags)=pmag(6,im)
            if (pmag(6,im).gt.nfoumagcp) then
              print*,"*** Error in BMAGSEQ: Number of Fourier coefficients exceeds dimension nfoumagcp =",nfoumagcp,"  ***"
              stop "*** Program WAVE aborted ***"
            endif
          else IF (CTYP(IM).EQ.'DHF') THEN
            nfoumags=nfoumags+1
            call util_skip_commentblock_end(lunmg,ieof)
            READ(LUNMG,*)CDUM1,CDUM2,
     &        PMAG(1,IM),PMAG(2,IM),PMAG(3,IM),PMAG(4,IM),
     &        pmag(5,im),pmag(6,im)
            xfoubounds(4,nfoumags)=pmag(5,im)
            xfoubounds(5,nfoumags)=pmag(6,im)
            if (pmag(6,im).gt.nfoumagcp) then
              print*,"*** Error in BMAGSEQ: Number of Fourier coefficients exceeds dimension nfoumagcp =",nfoumagcp,"  ***"
              stop "*** Program WAVE aborted ***"
            endif
          ELSE IF (CTYP(IM).EQ.'QP'.OR.CTYP(IM).EQ.'QF') THEN
            call util_skip_commentblock_end(lunmg,ieof)
            READ(LUNMG,*)CDUM1,CDUM2,
     &        PMAG(1,IM),PMAG(2,IM),PMAG(3,IM),PMAG(4,IM),PMAG(5,IM)
          ELSE IF (CTYP(IM).EQ.'SX') THEN
            call util_skip_commentblock_end(lunmg,ieof)
            READ(LUNMG,*)CDUM1,CDUM2,
     &        PMAG(1,IM),PMAG(2,IM),PMAG(3,IM),PMAG(4,IM),PMAG(5,IM)
          ELSE IF (CTYP(IM).EQ.'UE') THEN
            call util_skip_commentblock_end(lunmg,ieof)
            READ(LUNMG,*)CDUM1,CDUM2,
     &        PMAG(1:13,IM)
            ! 1. 2.   3.     4.    5.      6.     7.     8.       9.   10.
            ! K  B0V, B0H, Shift, XCen, PerLen, NPer, Lambda_X, Nharm Eharm
            ! 11.     12.    13.
            ! ctaper z-shift ang
            shift=pmag(4,im)
            xcen=pmag(5,im)
            perlen=pmag(6,im)
            pern=pmag(7,im)
            xlamb=pmag(8,im)
            ahwpol=((pern-1.0d0)*2+1.0d0)
            totlen=perlen*((ahwpol-1.0d0)/2.0d0+1.0d0)+shift
            uebounds(1,im)=xcen-0.5d0*totlen
            uebounds(2,im)=xcen+0.5d0*totlen
          ELSE

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN BMAGSEQ ***'
            WRITE(LUNGFO,*)'ILLEGAL MAGNET TYP >> ',ctyp(im), ' << ON FILE FILEMG'
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN BMAGSEQ ***'
            WRITE(6,*)'ILLEGAL MAGNET TYP >> ',ctyp(im), ' << ON FILE FILEMG'
            WRITE(6,*)

            STOP

          ENDIF !CTYP

        ENDDO   !IM
+self.,if=mgrere.

        CLOSE(LUNMG)

        if (nfoumags.gt.maxfoumagp) then
          print*
          print*,"*** Error in BMAGSEQ: Too many Fourier magnets ***"
          print*,"*** Please, increase MAXFOUMAGSP and recompile WAVE"
          print*,"*** Program WAVE aborted ***"
          print*
          stop
        endif

C---{ CORRECT FOR FRINGE-FIELD-EFFECTS

        IF (KMAGCOR.NE.0) THEN

          BSHIFT=0.5D0          !DONT WORRY
          BETA=DSQRT((1.D0-1.D0/DMYGAMMA)*(1.D0+1.D0/DMYGAMMA))
          V0=CLIGHT1*BETA
          DTIM=1.0D0/(v0*myinum)   !TIME INTERVALLS FOR TRACKING

          X1=XSTART
          Y1=YSTART
          Z1=ZSTART
          VX1=VXIN
          VY1=VYIN
          VZ1=VZIN

          DO IM=1,mmag
            IF (CTYP(IM).EQ.'DI'.or.ctyp(im).eq.'DIF') THEN
c              CALL BDI(XSTART,Y1,Z1,BXOUT,BYOUT,BZOUT,IM)
              ! The correction has only an effect, if the plateau is not reached
              xlen2=dabs(pmag(2,im)*sin(pmag(1,im)/2.0d0))
              dint=exp(2.0d0*pmag(4,im)*xlen2)/
     &          (pmag(4,im)*(exp(2.0d0*pmag(4,im)*xlen2)-1.0d0))*
     &          2.0d0*pmag(4,im)*xlen2
              if (dint.ne.dint) then
                corr(im)=1.0d0
              else
                corr(im)=corr(im)/dint*(2.0d0*xlen2)
              endif
            else IF (CTYP(IM).EQ.'DH'.or.ctyp(im).eq.'DHF') THEN
c              CALL BDH(XSTART,Y1,Z1,BXOUT,BYOUT,BZOUT,IM)
              ! The correction has only an effect, if the plateau is not reached
              xlen2=dabs(pmag(2,im)*sin(pmag(1,im)/2.0d0))
              dint=exp(2.0d0*pmag(4,im)*xlen2)/
     &          (pmag(4,im)*(exp(2.0d0*pmag(4,im)*xlen2)-1.0d0))*
     &          2.0d0*pmag(4,im)*xlen2
              corr(im)=corr(im)/dint*(2.0d0*xlen2)
            ENDIF !DI
          ENDDO   !mmag

          if (kmagcor.gt.0) then

            VN=V0/DSQRT(VX1*VX1+VY1*VY1+VZ1*VZ1)

            VX1=VX1*VN
            VY1=VY1*VN
            VZ1=VZ1*VN

            ANG2y=DATAN(Vy1/VX1)
            ANG2z=DATAN(VZ1/VX1)

            DO IMag=1,mmag

              IF (CTYP(IM).EQ.'DI'.or.ctyp(im).eq.'DIF') THEN
                im=imag
                ifour=0
                IF (ctyp(im).eq.'DIF') THEN
                  ifour=1
                endif
              else if (CTYP(IM).EQ.'DH'.or.ctyp(im).eq.'DHF') THEN
                im=-imag
              else
                cycle
              endif

              ANG1y=ANG2y
              ANG1z=ANG2z

              CALL TRACKBMAG(1,X1,Y1,Z1,VX1,VY1,VZ1,
     &          xstop,0.D0,0.D0,1.D0,0.D0,0.D0,
     &          X2,Y2,Z2,VX2,VY2,VZ2,DTIM,BSHIFT,DMYGAMMA,IM,BMOVECUT,
     &          IUSTEP,IENELOSS,ifour)

              ANG2y=DATAN(Vy2/VX2)
              ANG2z=DATAN(VZ2/VX2)
              DANGy=ANG2y-ANG1y
              DANGz=ANG2z-ANG1z

              IF (im.lt.0.and.DANGy.NE.0.0) THEN
                CORR(IMag)=corr(imag)*DABS(PMAG(1,IMag)/DANGy)
              else IF (im.gt.0.and.DANGz.NE.0.0) THEN
                CORR(IMag)=corr(imag)*DABS(PMAG(1,IMag)/DANGz)
              ENDIF

              CALL TRACKBMAG(1,X1,Y1,Z1,VX1,VY1,VZ1,
     &          xstop,0.D0,0.D0,1.D0,0.D0,0.D0,
     &          X2,Y2,Z2,VX2,VY2,VZ2,DTIM,BSHIFT,DMYGAMMA,IM,BMOVECUT,
     &          IUSTEP,IENELOSS,ifour)

              ANG2y=DATAN(Vy2/VX2)
              ANG2z=DATAN(VZ2/VX2)
              DANGy=ANG2y-ANG1y
              DANGz=ANG2z-ANG1z

              IF (im.lt.0.and.DANGy.NE.0.0) THEN
                CORR(IMag)=corr(imag)*DABS(PMAG(1,IMag)/DANGy)
              else IF (im.gt.0.and.DANGz.NE.0.0) THEN
                CORR(IMag)=corr(imag)*DABS(PMAG(1,IMag)/DANGz)
              ENDIF

            ENDDO !mmag

          ENDIF   !(KMAGCOR.NE.0)

          WRITE(LUNGFO,*)'     after corrections:'
          WRITE(LUNGFO,*)
          DO IM=1,mmag
            IF (CTYP(IM).ne.'DI'.and.ctyp(im).ne.'DIF'.and.CTYP(IM).ne.'DH'.and.ctyp(im).ne.'DHF') cycle
            WRITE(LUNGFO,1200) CTYP(IM),
     &        PMAG(1,IM),PMAG(2,IM)/CORR(IM),PMAG(3:13,IM)
1200        FORMAT('      ',A,13E14.6)
          ENDDO !IM
          WRITE(LUNGFO,*)

        ENDIF  !(KMAGCOR.NE.0)

C---} CORRECT FOR FRINGE-FIELD-EFFECTS

        if (nfoumags.gt.0) then

          mfour=nint(alog(float(nfoumagcp))/alog(2.0E0))
          nfoumags=0

          DO imag=1,mmag

            IF (CTYP(IMag).EQ.'DIF') THEN
              nfoumags=nfoumags+1
              xlen2=dabs(pmag(2,imag)*sin(pmag(1,imag)/2.0d0))
     &          +70.0d0/pmag(4,imag)
              dxfour=4.0d0*xlen2/nfoumagcp
              do i=1,nfoumagcp/2+1
                xfour(i)=-dxfour*(nfoumagcp/2+1-i)
                xfour(nfoumagcp+1-i+1)=-xfour(i)
              enddo
              do i=1,nfoumagcp/2+1
                i1=i-1
                ip=nfoumagcp/2+1+i1
                im=nfoumagcp/2+1-i1
                call bdi(pmag(3,imag)-xfour(ip),0.0d0,0.0d0,bx,by,bz,-imag)
                yfour(ip)=by
                yfour(im)=by
              enddo
              xfoubounds(1,nfoumags)=imag
              xfoubounds(2,nfoumags)=xfour(1)+pmag(3,imag)
              xfoubounds(3,nfoumags)=-xfour(1)+pmag(3,imag)
              call rfft(ckoef,-mfour) !fft mit cern-routine d703
              do k=1,nint(xfoubounds(5,nfoumags))  !reelle koeffizienten
                foumags(k,nfoumags)=(-1.)**(k-1)*2.0*real(ckoef(k))
              enddo
            else IF (CTYP(IMag).EQ.'DHF') THEN
              nfoumags=nfoumags+1
              xlen2=dabs(pmag(2,imag)*sin(pmag(1,imag)/2.0d0))
     &          +70.0d0/pmag(4,imag)
              dxfour=4.0d0*xlen2/nfoumagcp
              do i=1,nfoumagcp/2+1
                xfour(i)=-dxfour*(nfoumagcp/2+1-i)
                xfour(nfoumagcp+1-i+1)=-xfour(i)
              enddo
              do i=1,nfoumagcp/2+1
                i1=i-1
                ip=nfoumagcp/2+1+i1
                im=nfoumagcp/2+1-i1
                call bdh(pmag(3,imag)-xfour(ip),0.0d0,0.0d0,bx,by,bz,imag)
                yfour(ip)=bz
                yfour(im)=bz
              enddo
              xfoubounds(1,nfoumags)=imag
              xfoubounds(2,nfoumags)=xfour(1)+pmag(3,imag)
              xfoubounds(3,nfoumags)=-xfour(1)+pmag(3,imag)
              call rfft(ckoef,-mfour) !fft mit cern-routine d703
              do k=1,nint(xfoubounds(5,nfoumags))  !reelle koeffizienten
                foumags(k,nfoumags)=(-1.)**(k-1)*2.0*real(ckoef(k))
              enddo
            ENDIF !CTYP

          ENDDO   !IM

        endif !nfoumags

      ENDIF !ICAL

      if (ical.lt.10) ical=ical+1

      if (ical.eq.2) then

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     Subroutine BMAGSEQ: Magnets read from file:'
        write(lungfo,*)
        WRITE(LUNGFO,*)'     ',FILEMG(1:len_trim(filemg))
        WRITE(LUNGFO,*)'     X-shift (XSHMAGSEQ):',xshmagseq
        write(lungfo,*)
        WRITE(LUNGFO,1100)mmag,NMGSQP
1100    FORMAT('      Number of magnets: ',I6,' (Limit IS ',I6,' Magnets)')
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     Name Typ Boundaries Parameters'
        WRITE(LUNGFO,*)

        DO IM=1,mmag
          if (ctyp(im).eq.'DI') then
            WRITE(LUNGFO,1201) trim(cnam(im)),ctyp(im),dibounds(1:2,im),PMAG(1:6,IM)
          else if (ctyp(im).eq.'BEND') then
            WRITE(LUNGFO,1201) trim(cnam(im)),ctyp(im),dibounds(1:2,im),PMAG(1:12,IM)
            write(lungfo,*)"     vnin(1),vnin(3):",pmag(14,im),pmag(15,im)
            write(lungfo,*)"     vnout(1),vnout(3):",pmag(16,im),pmag(17,im)
          else if (ctyp(im).eq.'DIL') then
            WRITE(LUNGFO,1201) trim(cnam(im)),ctyp(im),dibounds(1:2,im),PMAG(1:11,IM)
          else if (ctyp(im).eq.'DCS') then
            WRITE(LUNGFO,1201) trim(cnam(im)),ctyp(im),dibounds(1:2,im),PMAG(1:11,IM)
          else if (ctyp(im).eq.'DQS') then
            WRITE(LUNGFO,1201) trim(cnam(im)),ctyp(im),dibounds(1:2,im),PMAG(1:11,IM)
          else if (ctyp(im).eq.'QF') then
            WRITE(LUNGFO,1201) trim(cnam(im)),ctyp(im),qfbounds(1:2,im),PMAG(1:6,IM)
          else if (ctyp(im).eq.'QP') then
            WRITE(LUNGFO,1201) trim(cnam(im)),ctyp(im),qfbounds(1:2,im),PMAG(1:6,IM)
          else if (ctyp(im).eq.'SX') then
            WRITE(LUNGFO,1201) trim(cnam(im)),ctyp(im),sxbounds(1:2,im),PMAG(1:6,IM)
          else if (ctyp(im).eq.'DH') then
            WRITE(LUNGFO,1201) trim(cnam(im)),ctyp(im),dhbounds(1:2,im),PMAG(1:6,IM)
          else if (ctyp(im).eq.'DIF') then
            WRITE(LUNGFO,1201) trim(cnam(im)),ctyp(im),dibounds(1:2,im),PMAG(1:6,IM)
          else if (ctyp(im).eq.'DHF') then
            WRITE(LUNGFO,1201) trim(cnam(im)),ctyp(im),dhbounds(1:2,im),PMAG(1:6,IM)
          else if (ctyp(im).eq.'UE') then
            WRITE(LUNGFO,1201) trim(cnam(im)),ctyp(im),uebounds(1:2,im),PMAG(1:13,IM)
          endif
c          if (pmag(20,im).ne.0.0d0) then
c            WRITE(LUNGFO,*)'      Shift:',sngl(shiftmg(1:3,im))
c          endif
c          if (pmag(19,im).ne.0.0d0) then
c            WRITE(LUNGFO,*)'      Rotation:'
c            WRITE(LUNGFO,*)'      ',sngl(rotmg(1,:,im))
c            WRITE(LUNGFO,*)'      ',sngl(rotmg(2,:,im))
c            WRITE(LUNGFO,*)'      ',sngl(rotmg(3,:,im))
c          endif
1201      FORMAT('      ',a,' ',a5,15E14.6)
        enddo
        write(lungfo,*)
        WRITE(LUNGFO,*)
        ICAL=2
      ENDIF !ICAL

C--- MAGNETIC FIELD

      CALL BMAGSEQC(XIN+xshmagseq,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT)

      RETURN
      END
+DECK,BMAGSEQC.
*CMZ :  4.01/07 19/01/2025  10.05.26  by  Michael Scheer
*CMZ :  4.00/11 26/07/2021  09.08.58  by  Michael Scheer
*CMZ :  3.06/00 11/02/2019  12.49.34  by  Michael Scheer
*CMZ :  3.04/00 19/01/2018  16.33.13  by  Michael Scheer
*CMZ :  3.03/02 16/02/2016  12.18.47  by  Michael Scheer
*CMZ :  3.01/00 15/07/2013  08.04.32  by  Michael Scheer
*CMZ :  2.68/03 07/08/2012  13.09.30  by  Michael Scheer
*CMZ :  2.66/07 04/12/2009  16.11.19  by  Michael Scheer
*CMZ :  2.52/11 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  1.02/00 19/12/97  16.15.53  by  Michael Scheer
*CMZ :  1.01/00 28/10/97  12.14.09  by  Michael Scheer
*CMZ : 00.01/08 01/04/95  16.54.24  by  Michael Scheer
*CMZ : 00.01/07 10/03/95  11.22.55  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  15.21.20  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.48.03  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.42  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BMAGSEQC(XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT)
+seq,gplhint.

      IMPLICIT NONE

      INTEGER IM,ISTORE

+SEQ,CONTRL.
+SEQ,MGSQC.
+SEQ,fourier.
+seq,phycon.

      DOUBLE PRECISION BX,BY,BZ,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT
      DOUBLE PRECISION XIN,YIN,ZIN,xlen2,xr,yr,zr,ex,ey,ez,dist,fint,gap,
     &  bxr,byr,bzr,axr,ayr,azr,xbend,xshift,xsym,ybend,zbend,fringe,fa,fb,fc,
     &  strength,pin(3),center(3),pout(3),vnin(3),vnout(3),b(3),edge(2),x,y,z,xrs(3),
     &  x2,x3,x4,x5,y2,y3,vin(3),vrot(3),vout(3),phi

      integer ical,istatus,modus,irsh
      data ical/0/

      x=xin
      y=yin
      z=zin

      if (ical.eq.0) then

        bmsqbounds(1)=1.0d30
        bmsqbounds(2)=-1.0d30

        do im=1,mmag

          if (ctyp(im).eq.'QP') then
            xlen2=pmag(1,im)/2.0d0
            qfbounds(1,im)=pmag(3,im)-xlen2
            qfbounds(2,im)=pmag(3,im)+xlen2
            if (qfbounds(2,im).lt.qfbounds(1,im)) then
              write(lungfo,*)'*** Error in BMAGSEQC: Bounderies of QP ',im,'bad! ***'
              write(6,*)'*** Error in BMAGSEQC: Bounderies of QP ',im,'bad! ***'
              stop '*** Program WAVE aborted ***'
            endif
            if (qfbounds(1,im).lt.bmsqbounds(1)) bmsqbounds(1)=qfbounds(1,im)
            if (qfbounds(2,im).gt.bmsqbounds(2)) bmsqbounds(2)=qfbounds(2,im)
          else if (ctyp(im).eq.'QF') then
            xlen2=pmag(1,im)/2.0d0
            qfbounds(1,im)=pmag(3,im)-70.0d0/1000.0d0-xlen2
            qfbounds(2,im)=pmag(3,im)+70.0d0/1000.0d0+xlen2
            if (qfbounds(2,im).lt.qfbounds(1,im)) then
              write(lungfo,*)'*** Error in BMAGSEQC: Bounderies of QF ',im,'bad! ***'
              write(6,*)'*** Error in BMAGSEQC: Bounderies of QF ',im,'bad! ***'
              stop '*** Program WAVE aborted ***'
            endif
            if (qfbounds(1,im).lt.bmsqbounds(1)) bmsqbounds(1)=qfbounds(1,im)
            if (qfbounds(2,im).gt.bmsqbounds(2)) bmsqbounds(2)=qfbounds(2,im)
          else if (ctyp(im).eq.'SX') then
            xlen2=pmag(1,im)/2.0d0
            sxbounds(1,im)=pmag(3,im)-70.0d0/1000.0d0-xlen2
            sxbounds(2,im)=pmag(3,im)+70.0d0/1000.0d0+xlen2
            if (sxbounds(2,im).lt.sxbounds(1,im)) then
              write(lungfo,*)'*** Error in BMAGSEQC: Bounderies of SX ',im,'bad! ***'
              write(6,*)'*** Error in BMAGSEQC: Bounderies of SX ',im,'bad! ***'
              stop '*** Program WAVE aborted ***'
            endif
            if (sxbounds(1,im).lt.bmsqbounds(1)) bmsqbounds(1)=sxbounds(1,im)
            if (sxbounds(2,im).gt.bmsqbounds(2)) bmsqbounds(2)=sxbounds(2,im)
          else if (ctyp(im).eq.'DI'.or.ctyp(im).eq.'DIF') then
            xlen2=dabs(pmag(2,im)*sin(pmag(1,im)/2.0d0))
            dibounds(1,im)=pmag(3,im)-70.0d0/pmag(4,im)-xlen2
            dibounds(2,im)=pmag(3,im)+70.0d0/pmag(4,im)+xlen2
            if (dibounds(1,im).lt.bmsqbounds(1)) bmsqbounds(1)=dibounds(1,im)
            if (dibounds(2,im).gt.bmsqbounds(2)) bmsqbounds(2)=dibounds(2,im)
          else if (ctyp(im).eq.'DIL') then
            dibounds(1,im)=pmag(3,im)-pmag(11,im)/2.0d0
            dibounds(2,im)=pmag(3,im)+pmag(11,im)/2.0d0
            if (dibounds(1,im).lt.bmsqbounds(1)) bmsqbounds(1)=dibounds(1,im)
            if (dibounds(2,im).gt.bmsqbounds(2)) bmsqbounds(2)=dibounds(2,im)
c          else if (ctyp(im).eq.'RBEND' .or. ctyp(im).eq.'SBEND') then
c            if (dibounds(1,im).lt.bmsqbounds(1)) bmsqbounds(1)=dibounds(1,im)
c            if (dibounds(2,im).gt.bmsqbounds(2)) bmsqbounds(2)=dibounds(2,im)
          else if (ctyp(im).eq.'DCS') then
            dibounds(1,im)=pmag(3,im)-pmag(11,im)/2.0d0
            dibounds(2,im)=pmag(3,im)+pmag(11,im)/2.0d0
            if (dibounds(1,im).lt.bmsqbounds(1)) bmsqbounds(1)=dibounds(1,im)
            if (dibounds(2,im).gt.bmsqbounds(2)) bmsqbounds(2)=dibounds(2,im)
          else if (ctyp(im).eq.'DQS') then
            dibounds(1,im)=pmag(3,im)-pmag(11,im)/2.0d0
            dibounds(2,im)=pmag(3,im)+pmag(11,im)/2.0d0
            if (dibounds(1,im).lt.bmsqbounds(1)) bmsqbounds(1)=dibounds(1,im)
            if (dibounds(2,im).gt.bmsqbounds(2)) bmsqbounds(2)=dibounds(2,im)
          else if (ctyp(im).eq.'DH'.or.ctyp(im).eq.'DHF') then
            xlen2=dabs(pmag(2,im)*sin(pmag(1,im)/2.0d0))
            dhbounds(1,im)=pmag(3,im)-70.0d0/pmag(4,im)-xlen2
            dhbounds(2,im)=pmag(3,im)+70.0d0/pmag(4,im)+xlen2
            if (dhbounds(1,im).lt.bmsqbounds(1)) bmsqbounds(1)=dhbounds(1,im)
            if (dhbounds(2,im).gt.bmsqbounds(2)) bmsqbounds(2)=dhbounds(2,im)
          else if (ctyp(im).eq.'UE') then
            if (uebounds(2,im).lt.uebounds(1,im)) then
              write(lungfo,*)'*** Error in BMAGSEQC: Bounderies of UE ',im,'bad! ***'
              write(6,*)'*** Error in BMAGSEQC: Bounderies of UE ',im,'bad! ***'
              stop '*** Program WAVE aborted ***'
            endif
            if (uebounds(1,im).lt.bmsqbounds(1)) bmsqbounds(1)=uebounds(1,im)
            if (uebounds(2,im).gt.bmsqbounds(2)) bmsqbounds(2)=uebounds(2,im)
          endif
        enddo

        ical=1

      endif

      BXOUT=0.0d0
      BYOUT=0.0d0
      BZOUT=0.0d0

      AXOUT=0.0d0
      AYOUT=0.0d0
      AZOUT=0.0d0

      BX=0.0d0
      BY=0.0d0
      BZ=0.0d0

C- FIELD

      IF(IWFILF.NE.99.AND.IMGSQF.NE.0) THEN
        ISTORE=IRFILF
        IRFILF=99
        CALL BFOUR(x,y,z,BX,BY,BZ,AXOUT,AYOUT,AZOUT)
        IRFILF=ISTORE
      ENDIF !IWFILF

      DO IM=1,mmag

        x=xin
        y=yin
        z=zin

        do irsh=1,int(pmag(19,im))
          if (irsh.eq.int(pmag(20,im))) cycle
          if (rotmg(7,irsh,im).eq.-9999d0) then
            x=x-rotmg(1,irsh,im)
            y=y-rotmg(2,irsh,im)
            z=z-rotmg(3,irsh,im)
          else
            center=rotmg(1:3,irsh,im)
            vrot=rotmg(4:6,irsh,im)
            vin=[x,y,z]
            phi=-rotmg(7,irsh,im)*grarad1
            call util_rotate(center,vrot,phi,vin,vout,istatus)
            x=vout(1)
            y=vout(2)
            z=vout(3)
          endif
        enddo

        IF (ctyp(IM).EQ.'QP') THEN
          CALL BQP(x,y,z,BXOUT,BYOUT,BZOUT,IM)
        ELSE IF (ctyp(IM).EQ.'QF') THEN
          if (x+1.0d-10.ge.qfbounds(1,im).and.x-1.0d-10.le.qfbounds(2,im)) then
            CALL BQF(x,y,z,BXOUT,BYOUT,BZOUT,IM)
          else
            bxout=0.0d0
            byout=0.0d0
            bzout=0.0d0
          endif
        ELSE IF (ctyp(IM).EQ.'SX') THEN
          if (x+1.0d-10.ge.sxbounds(1,im).and.x-1.0d-10.le.sxbounds(2,im)) then
            CALL bsx(x,y,z,BXOUT,BYOUT,BZOUT,IM)
          else
            bxout=0.0d0
            byout=0.0d0
            bzout=0.0d0
          endif

        ELSE IF (ctyp(IM).EQ.'SBEND' .or. ctyp(IM).EQ.'RBEND') THEN

          call bybend(mmag,im,x,y,z,bxout,byout,bzout,axout,ayout,azout)

        ELSE IF (ctyp(IM).EQ.'SANDW') THEN

          call bysandwich(mmag,im,x,y,z,bxout,byout,bzout,axout,ayout,azout)

        ELSE IF (ctyp(IM).EQ.'DI') THEN
          if (x+1.0d-10.ge.dibounds(1,im).and.x-1.0d-10.le.dibounds(2,im)) then
            CALL BDI(x,y,z,BXOUT,BYOUT,BZOUT,IM)
          else
            bxout=0.0d0
            byout=0.0d0
            bzout=0.0d0
          endif
        ELSE IF (ctyp(IM).EQ.'DCS') THEN
          bxout=0.0d0
          byout=0.0d0
          bzout=0.0d0
          if (x+1.0d-10.ge.dibounds(1,im).and.x-1.0d-10.le.dibounds(2,im)) then
            xshift=pmag(11,im)/2.0d0
            xr=x-pmag(3,im)+xshift
            yr=y-pmag(4,im)
            zr=z-pmag(5,im)
            ex=pmag(8,im)
            ey=pmag(9,im)
            ez=pmag(10,im)
            dist=xr*ex+yr*ey+zr*ez
            if (dist.lt.0.0d0) return
            xbend=dist
            ybend=yr
            zbend=0.0d0 ! Or change mrad_csbend etc.
            xsym=xbend
            gap=pmag(7,im)
            fint=pmag(6,im)
            strength=pmag(12,im)
            if (xshift.gt.0.0d0) then
              if (xbend.gt.xshift) then
                xsym=xshift-(xbend-xshift)
              endif
              call mrad_fringe_cubic_spline(xsym,ybend,zbend,
     &          bxr,byr,bzr,axr,ayr,azr,fint,gap,fringe,
     &          istatus)
            endif
            if (xbend.gt.xshift) then
              bxr=-bxr
            endif
            bxout=bxr*strength
            byout=byr*strength
            bzout=bzr*strength
          endif
        ELSE IF (ctyp(IM).EQ.'DIL') THEN
          bxout=0.0d0
          byout=0.0d0
          bzout=0.0d0
          if (x+1.0d-10.ge.dibounds(1,im).and.x-1.0d-10.le.dibounds(2,im)) then
            xshift=pmag(11,im)/2.0d0
            xr=x-pmag(3,im)+xshift
            yr=y-pmag(4,im)
            zr=z-pmag(5,im)
            ex=pmag(8,im)
            ey=pmag(9,im)
            ez=pmag(10,im)
            dist=xr*ex+yr*ey+zr*ez
            if (dist.lt.0.0d0) return
            xbend=dist
            ybend=yr
            zbend=0.0d0 ! Or change mrad_csbend etc.
            xsym=xbend
            gap=pmag(7,im)
            fint=pmag(6,im)
            strength=pmag(12,im)
            if (xshift.gt.0.0d0) then
              if (xbend.gt.xshift) then
                xsym=xshift-(xbend-xshift)
              endif
              call mrad_fringe_linear(xsym,ybend,zbend,
     &          bxr,byr,bzr,axr,ayr,azr,fint,gap,fringe,
     &          istatus)
            endif
            if (xbend.gt.xshift) then
              bxr=-bxr
            endif
            bxout=bxr*strength
            byout=byr*strength
            bzout=bzr*strength
          endif
        ELSE IF (ctyp(IM).EQ.'DQS') THEN
          bxout=0.0d0
          byout=0.0d0
          bzout=0.0d0
          if (x+1.0d-10.ge.dibounds(1,im).and.x-1.0d-10.le.dibounds(2,im)) then
            xshift=pmag(11,im)/2.0d0
            xr=x-pmag(3,im)+xshift
            yr=y-pmag(4,im)
            zr=z-pmag(5,im)
            ex=pmag(8,im)
            ey=pmag(9,im)
            ez=pmag(10,im)
            dist=xr*ex+yr*ey+zr*ez
            if (dist.lt.0.0d0) return
            xbend=dist
            ybend=yr
            zbend=0.0d0 ! Or change mrad_csbend etc.
            xsym=xbend
            gap=pmag(7,im)
            fint=pmag(6,im)
            strength=pmag(12,im)
            if (xshift.gt.0.0d0) then
              if (xbend.gt.xshift) then
                xsym=xshift-(xbend-xshift)
              endif
              call mrad_fringe_quintic_spline(xsym,ybend,zbend,
     &          bxr,byr,bzr,axr,ayr,azr,fint,gap,fringe,
     &          istatus)
            endif
            if (xbend.gt.xshift) then
              bxr=-bxr
            endif
            bxout=bxr*strength
            byout=byr*strength
            bzout=bzr*strength
          endif
        ELSE IF (ctyp(IM).EQ.'DIF') THEN
          if (x+1.0d-10.ge.dibounds(1,im).and.x-1.0d-10.le.dibounds(2,im)) then
            CALL bfoumag(x,y,z,BXOUT,BYOUT,BZOUT,axout,ayout,azout,IM)
          else
            bxout=0.0d0
            byout=0.0d0
            bzout=0.0d0
          endif
        ELSE IF (ctyp(IM).EQ.'DHF') THEN
          if (x+1.0d-10.ge.dhbounds(1,im).and.x-1.0d-10.le.dhbounds(2,im)) then
            CALL bfoumag(x,y,z,BXOUT,BYOUT,BZOUT,axout,ayout,azout,-IM)
          else
            bxout=0.0d0
            byout=0.0d0
            bzout=0.0d0
          endif
        ELSE IF (ctyp(IM).EQ.'DH') THEN
          if (x+1.0d-10.ge.dhbounds(1,im).and.x-1.0d-10.le.dhbounds(2,im)) then
            CALL BDH(x,y,z,BXOUT,BYOUT,BZOUT,IM)
          else
            bxout=0.0d0
            byout=0.0d0
            bzout=0.0d0
          endif
        ELSE IF (ctyp(IM).EQ.'UE') THEN
          if (x+1.0d-10.ge.uebounds(1,im).and.x-1.0d-10.le.uebounds(2,im)) then
            CALL BUE(x,y,z,BXOUT,BYOUT,BZOUT,axout,ayout,azout,IM)
          else
            bxout=0.0d0
            byout=0.0d0
            bzout=0.0d0
          endif
        ENDIF !CTYP

        if (pmag(20,im).ne.0.0d0) then
          irsh=int(pmag(20,im))
          center=rotmg(1:3,irsh,im)
          vrot=rotmg(4:6,irsh,im)
          vin=[bxout,byout,bzout]
          phi=rotmg(7,irsh,im)*grarad1
          call util_rotate(center,vrot,phi,vin,vout,istatus)
          bxout=vout(1)
          byout=vout(2)
          bzout=vout(3)
        endif

        BX=BX+BXOUT
        BY=BY+BYOUT
        BZ=BZ+BZOUT

      ENDDO !IM

      BXOUT=BX
      BYOUT=BY
      BZOUT=BZ

      RETURN
      END
+DECK,BMAGSPLN.
*CMZ :  4.00/17 04/10/2022  08.10.22  by  Michael Scheer
*CMZ :  4.00/16 09/09/2022  17.24.46  by  Michael Scheer
*CMZ :  3.02/03 04/11/2014  12.27.16  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.63/03 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.62/02 16/07/2007  09.37.01  by  Michael Scheer
*CMZ :  2.52/16 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.48/04 16/04/2004  09.24.47  by  Michael Scheer
*CMZ :  2.41/13 22/08/2002  13.57.52  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.20/01 08/11/2000  16.17.05  by  Michael Scheer
*CMZ :  2.16/08 31/10/2000  14.25.16  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.25.04  by  Michael Scheer
*CMZ :  2.12/00 03/06/99  10.48.13  by  Michael Scheer
*CMZ :  2.11/00 12/05/99  12.07.51  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  15.05.53  by  Michael Scheer
*CMZ :  1.00/00 31/07/97  10.47.01  by  Michael Scheer
*CMZ : 00.01/09 31/08/95  15.27.27  by  Michael Scheer
*CMZ : 00.01/08 22/06/95  13.10.15  by  Michael Scheer
*-- Author : Michael Scheer   22/06/95

      SUBROUTINE BMAGSPLN(X,Y,Z,BX,BY,BZ)
+seq,gplhint.

+SEQ,TRACKF90U,IF=F90.
+SEQ,WORKF90U,IF=F90.

C--- USES STORED MAGNETIC FIELD OF REFERENCE ORBIT TO EVALUATE MAGNETIC
C    FIELD BY SPLINE INTERPOLATION

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,CMPARA.
+SEQ,TRACK.
+SEQ,debugwave.

      DOUBLE PRECISION X,Y,Z,BX,BY,BZ,DUM
      DOUBLE PRECISION XSTOPR
      DOUBLE PRECISION H,A,B,A3A,B3B,H26,H1

      INTEGER ICAL,I,MCODE,MDIM
      INTEGER KLO,KHI,K,KD

      DATA KLO/1/
      DATA ICAL/0/

      IF (ICAL.EQ.0) THEN

        DUM=Y
        DUM=Z

        MDIM=NCO

        IF (IMAGSPLN.EQ.-999) THEN

          IF (IXAMAG_I.EQ.0) THEN
            ALLOCATE(XAMAG(NCO))
            ALLOCATE(BXAMAG(NCO))
            ALLOCATE(BYAMAG(NCO))
            ALLOCATE(BZAMAG(NCO))
            IXAMAG_I=1
          ENDIF

        ELSE IF (IMAGSPLN.LT.0) THEN

          IF (IXAMAG_I.EQ.0) THEN
             ALLOCATE(XAMAG(NCO))
            ALLOCATE(BXAMAG(NCO))
            ALLOCATE(BYAMAG(NCO))
            ALLOCATE(BZAMAG(NCO))
          IXAMAG_I=1
        ENDIF

        OPEN(UNIT=99,FILE='magjob.dat',STATUS='NEW'
+SELF,IF=-WINDOWS.
     &          ,RECL=256)
+SELF,IF=windows.
     &          )
+SELF.
        WRITE(99,*)ICODE
          WRITE(99,*)NCO,IBYONLY
          WRITE(99,*)WTRA(1,1,1),WTRA(2,1,1),WTRA(3,1,1)
          WRITE(99,*)WTRA(1,2,1),WTRA(2,2,1),WTRA(3,2,1)
          WRITE(99,*)WTRA(1,1,MDIM),DMYENERGY
          DO I=1,MDIM
            WRITE(99,*)XAMAG(I),BXAMAG(I),BYAMAG(I),BZAMAG(I)
          ENDDO
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     SR BMAGSPLN:'
          WRITE(LUNGFO,*)
     &      '     MAGNETIC FIELD ARRAY WRITTEN FILE magjob.dat'
          WRITE(LUNGFO,*)
          CLOSE(99)

        ELSE    !IMAGSPLN

          OPEN(UNIT=99,FILE='magjob.dat',STATUS='OLD'
+SELF,IF=-WINDOWS.
     &      ,RECL=256)
+SELF,IF=windows.
     &      )
+SELF.

          READ(99,*)MCODE
          MCODE=ABS(MCODE)

          READ(99,*)MDIM,IBYONLY

          IF (IXAMAG_I.EQ.0) THEN
            ALLOCATE(XAMAG(MDIM))
            ALLOCATE(BXAMAG(MDIM))
            ALLOCATE(BYAMAG(MDIM))
            ALLOCATE(BZAMAG(MDIM))
            ALLOCATE(BY2A(MDIM))

            IF (IBYONLY.EQ.0) THEN
              ALLOCATE(BX2A(MDIM))
              ALLOCATE(BZ2A(MDIM))
            ENDIF
            IXAMAG_I=1
          ENDIF

          READ(99,*)XSTART,YSTART,ZSTART
          READ(99,*)VXIN,VYIN,VZIN
          READ(99,*)XSTOPR,DMYENERGY
          IF (XSTOP.EQ.9999.) XSTOP=XSTOPR

          DO I=1,MDIM
            READ(99,*)XAMAG(I),BXAMAG(I),BYAMAG(I),BZAMAG(I)
          ENDDO

          CLOSE(99)

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     BMAGSPLN:'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     MAGNETIC FIELD READ FROM FILE magjob.dat'
          WRITE(LUNGFO,*)
     &      '     INITIALIZATION OF ELECTRON OVERWRITTEN'
          WRITE(LUNGFO,*)

        ENDIF   !IMAGSPLN

        ALLOCATE(WS1(MDIM))
        ALLOCATE(WS2(MDIM))
        ALLOCATE(WS3(MDIM))
        ALLOCATE(WS4(MDIM))

        IF (IBYONLY.EQ.0) THEN

          CALL util_spline_coef(XAMAG,BXAMAG,MDIM,-9999.0d0,-9999.0d0,BX2A,WS1,WS2,WS3,WS4)
          CALL util_spline_coef(XAMAG,BYAMAG,MDIM,-9999.0d0,-9999.0d0,BY2A,WS1,WS2,WS3,WS4)
          CALL util_spline_coef(XAMAG,BZAMAG,MDIM,-9999.0d0,-9999.0d0,BZ2A,WS1,WS2,WS3,WS4)

        ELSE

          CALL util_spline_coef(XAMAG,BYAMAG,MDIM,-9999.0d0,-9999.0d0,BY2A,WS1,WS2,WS3,WS4)

        ENDIF

        DEALLOCATE(WS1)
        DEALLOCATE(WS2)
        DEALLOCATE(WS3)
        DEALLOCATE(WS4)

        ICAL=1

      ENDIF !ICAL

      IF (IBYONLY.EQ.0) THEN

        IF (X.LT.XAMAG(1)) THEN
          IF (XAMAG(1)-X.LT.2.*(XAMAG(2)-XAMAG(1))) THEN
            BX=BXAMAG(1)+(BXAMAG(2)-BXAMAG(1))/(XAMAG(2)-XAMAG(1))*(X-XAMAG(1))
            BY=BYAMAG(1)+(BYAMAG(2)-BYAMAG(1))/(XAMAG(2)-XAMAG(1))*(X-XAMAG(1))
            BZ=BZAMAG(1)+(BZAMAG(2)-BZAMAG(1))/(XAMAG(2)-XAMAG(1))*(X-XAMAG(1))
            RETURN
          ELSE
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN BMAGSPLN: X OUT OF RANGE ***'
            WRITE(LUNGFO,*)'TRY TO INCREASE NPLOI OR TO DECREASE MYINUM'
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN BMAGSPLN: X OUT OF RANGE ***'
            WRITE(6,*)'TRY TO INCREASE NPLOI OR TO DECREASE MYINUM'
            WRITE(6,*)
            STOP
          ENDIF
        ENDIF

        IF (X.GT.XAMAG(MDIM)) THEN
          IF (X-XAMAG(MDIM).LT.2.*(XAMAG(MDIM)-XAMAG(MDIM-1))) THEN
            BX=BXAMAG(MDIM-1)+(BXAMAG(MDIM)-BXAMAG(MDIM-1))/(XAMAG(MDIM)-XAMAG(MDIM-1))*(X-XAMAG(MDIM-1))
            BY=BYAMAG(MDIM-1)+(BYAMAG(MDIM)-BYAMAG(MDIM-1))/(XAMAG(MDIM)-XAMAG(MDIM-1))*(X-XAMAG(MDIM-1))
            BZ=BZAMAG(MDIM-1)+(BZAMAG(MDIM)-BZAMAG(MDIM-1))/(XAMAG(MDIM)-XAMAG(MDIM-1))*(X-XAMAG(MDIM-1))
            RETURN
          ELSE
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN BMAGSPLN: X OUT OF RANGE ***'
            WRITE(LUNGFO,*)'TRY TO INCREASE NPLOI OR TO DECREASE MYINUM'
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN BMAGSPLN: X OUT OF RANGE ***'
            WRITE(6,*)'TRY TO INCREASE NPLOI OR TO DECREASE MYINUM'
            WRITE(6,*)
            STOP
          ENDIF
        ENDIF

C--- BMAG_SPLINE_INTER_XYZ{

        IF(     XAMAG(1).LT.XAMAG(MDIM).AND.(X.LT.XAMAG(1).OR.X.GT.XAMAG(MDIM))
     &      .OR.
     &      XAMAG(MDIM).LT.XAMAG(1).AND.(X.LT.XAMAG(MDIM).OR.X.GT.XAMAG(1))) THEN
          STOP '*** ERROR IN BMAGSPLN: X OUT OF RANGE ***'
        ENDIF

        IF (X.GE.XAMAG(KLO)) THEN

C HUNT UP
          KD=1
11        KHI=MIN(KLO+KD,MDIM)
          IF (X.GT.XAMAG(KHI)) THEN
            KD=2*KD
            KLO=KHI
            GOTO 11
          ENDIF

        ELSE    !(X.GE.XAMAG(KLO))

C HUNT DOWN
          KD=1
          KHI=KLO
22        KLO=MAX(KHI-KD,1)
          IF (X.LT.XAMAG(KLO)) THEN
            KD=2*KD
            KHI=KLO
            GOTO 22
          ENDIF

        ENDIF

1       IF (KHI-KLO.GT.1) THEN
          K=(KHI+KLO)/2
          IF(XAMAG(K).GT.X)THEN
            KHI=K
          ELSE
            KLO=K
          ENDIF
          GOTO 1
        ENDIF

        H=XAMAG(KHI)-XAMAG(KLO)


        IF (H.EQ.0.) THEN
          WRITE(6,*) '*** ERROR IN BMAG_SPLINE_INTER: BAD INPUT ***'
          STOP
        ENDIF

        H1=1.D0/H
        H26=H*H/6.D0
        A=(XAMAG(KHI)-X)*H1
        B=(X-XAMAG(KLO))*H1
        A3A=A*A*A-A
        B3B=B*B*B-B

        BX=A*BXAMAG(KLO)+B*BXAMAG(KHI)+(A3A*BX2A(KLO)+B3B*BX2A(KHI))*H26
        BY=A*BYAMAG(KLO)+B*BYAMAG(KHI)+(A3A*BY2A(KLO)+B3B*BY2A(KHI))*H26
        BZ=A*BZAMAG(KLO)+B*BZAMAG(KHI)+(A3A*BZ2A(KLO)+B3B*BZ2A(KHI))*H26

C--- BMAG_SPLINE_INTER_XYZ}

      ELSE  !IBYONLY

        BX=0.0D0
        BZ=0.0D0

        IF (X.LT.XAMAG(1)) THEN
          IF (XAMAG(1)-X.LT.2.*(XAMAG(2)-XAMAG(1))) THEN
            BY=BYAMAG(1)+(BYAMAG(2)-BYAMAG(1))/(XAMAG(2)-XAMAG(1))*(X-XAMAG(1))
            RETURN
          ELSE
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN BMAGSPLN: X OUT OF RANGE ***'
            WRITE(LUNGFO,*)'TRY TO INCREASE NPLOI OR TO DECREASE MYINUM'
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN BMAGSPLN: X OUT OF RANGE ***'
            WRITE(6,*)'TRY TO INCREASE NPLOI OR TO DECREASE MYINUM'
            WRITE(6,*)
            STOP
          ENDIF
        ENDIF

        IF (X.GT.XAMAG(MDIM)) THEN
          IF (X-XAMAG(MDIM).LT.2.*(XAMAG(MDIM)-XAMAG(MDIM-1))) THEN
            BY=BYAMAG(MDIM-1)+(BYAMAG(MDIM)-BYAMAG(MDIM-1))/(XAMAG(MDIM)-XAMAG(MDIM-1))*(X-XAMAG(MDIM-1))
            RETURN
          ELSE
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN BMAGSPLN: X OUT OF RANGE ***'
            WRITE(LUNGFO,*)'TRY TO INCREASE NPLOI OR TO DECREASE MYINUM'
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN BMAGSPLN: X OUT OF RANGE ***'
            WRITE(6,*)'TRY TO INCREASE NPLOI OR TO DECREASE MYINUM'
            WRITE(6,*)
            STOP
          ENDIF
        ENDIF

C--- BMAG_SPLINE_INTER_XYZ{

        IF(     XAMAG(1).LT.XAMAG(MDIM).AND.(X.LT.XAMAG(1).OR.X.GT.XAMAG(MDIM))
     &      .OR.
     &      XAMAG(MDIM).LT.XAMAG(1).AND.(X.LT.XAMAG(MDIM).OR.X.GT.XAMAG(1))) THEN
          STOP '*** ERROR IN BMAGSPLN: X OUT OF RANGE ***'
        ENDIF

        IF (X.GE.XAMAG(KLO)) THEN

C HUNT UP
          KD=1
311       KHI=MIN(KLO+KD,MDIM)
          IF (X.GT.XAMAG(KHI)) THEN
            KD=2*KD
            KLO=KHI
            GOTO 311
          ENDIF

        ELSE    !(X.GE.XAMAG(KLO))

C HUNT DOWN
          KD=1
          KHI=KLO
322       KLO=MAX(KHI-KD,1)
          IF (X.LT.XAMAG(KLO)) THEN
            KD=2*KD
            KHI=KLO
            GOTO 322
          ENDIF

        ENDIF

31      IF (KHI-KLO.GT.1) THEN
          K=(KHI+KLO)/2
          IF(XAMAG(K).GT.X)THEN
            KHI=K
          ELSE
            KLO=K
          ENDIF
          GOTO 31
        ENDIF

        H=XAMAG(KHI)-XAMAG(KLO)

        IF (H.EQ.0.0D0) THEN
          WRITE(6,*) '*** ERROR IN BMAG_SPLINE_INTER: BAD INPUT ***'
          STOP
        ENDIF

        H1=1.0D0/H
        H26=H*H/6.D0
        A=(XAMAG(KHI)-X)*H1
        B=(X-XAMAG(KLO))*H1
        A3A=A*A*A-A
        B3B=B*B*B-B

        BY=A*BYAMAG(KLO)+B*BYAMAG(KHI)+(A3A*BY2A(KLO)+B3B*BY2A(KHI))*H26

C--- BMAG_SPLINE_INTER_XYZ}

      ENDIF !IBYONLY

      RETURN
      END
+DECK,BMAG_SPLINE_INTER.
*CMZ :  3.02/00 24/09/2014  13.51.08  by  Michael Scheer
*CMZ :  3.01/03 19/03/2014  12.24.14  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.66/19 07/06/2011  14.08.31  by  Michael Scheer
*CMZ :  2.63/03 07/05/2008  14.17.54  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  15.14.32  by  Michael Scheer
*CMZ :  1.00/00 06/08/97  17.55.00  by  Michael Scheer
*CMZ : 00.01/08 22/06/95  10.22.03  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  10.39.41  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.50  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BMAG_SPLINE_INTER(XA,YA,Y2A,N,X,Y,MODE)
+seq,gplhint.

C---  INTERPOLATES Y(X) VIA SPLINE

C--   INPUT:

C-       N: NUMBER OF X,Y-VALUES
C-       XA:   ARRAY OF X-VALUES
C-       YA:   ARRAY OF Y-VALUES
C-       YA2:  ARRAY SPLINE COEFFICIENTS
C-       X: Y(X) IS CALCULATED
C-       MODE: CONTROL FLAG:
C-             MODE.GE.0: USE VALUES OF LAST CALL TO START WITH
C-             MODE.LT.0: NEW INITIALIZATION

C--   OUTPUT:

C-       Y: Y(X) IS CALCULATED

      IMPLICIT NONE

      INTEGER NOLD,N,KLO,KHI,KLOLD,K,MODE

      DOUBLE PRECISION Y,X,XA1OLD,XANOLD,H,A,B

      DOUBLE PRECISION XA(*),YA(*),Y2A(*)

      save klold,nold,xa1old,xanold

      DATA KLOLD/1/,NOLD/-99/
      DATA XA1OLD/-9999.D0/,XANOLD/-9999./

      IF(     XA(1).LT.XA(N).AND.(X.LT.XA(1).OR.X.GT.XA(N))
     &    .OR.
     &    XA(N).LT.XA(1).AND.(X.LT.XA(N).OR.X.GT.XA(1))) THEN
        STOP '***SR BMAG_SPLINE_INTER: X OUT OF RANGE ***'
      ENDIF

      IF ( MODE.GE.0.AND.NOLD.EQ.N) THEN
        IF ( XA(1).EQ.XA1OLD
     &      .AND. XA(N).EQ.XANOLD
     &      .AND. X.GT.XA(KLOLD)
     &      ) THEN
          KLO=KLOLD
        ELSE
          KLO=1
        ENDIF
      ELSE
        KLO=1
      ENDIF

      IF (X.LT.XA(KLO+1)) THEN
      KHI=KLO+1
      GOTO 2
      ENDIF

      KHI=N
1     IF (KHI-KLO.GT.1) THEN
        K=(KHI+KLO)/2
        IF(XA(K).GT.X)THEN
          KHI=K
        ELSE
          KLO=K
        ENDIF
      GOTO 1
      ENDIF

2     H=XA(KHI)-XA(KLO)

      IF (H.LE.0.) THEN
        WRITE(6,*) '*** ERROR IN BMAG_SPLINE_INTER: BAD INPUT ***'
        STOP
      ENDIF

      A=(XA(KHI)-X)/H
      B=(X-XA(KLO))/H
      Y=A*YA(KLO)+B*YA(KHI)+
     *      ((A**3-A)*Y2A(KLO)+(B**3-B)*Y2A(KHI))*(H**2)/6.

      KLOLD=KLO
      NOLD=N
      XA1OLD=XA(1)
      XANOLD=XA(N)

      RETURN
      END
+DECK,BMAG_SPLINE_INTER_XYZ.
*CMZ :  3.02/00 24/09/2014  13.51.08  by  Michael Scheer
*CMZ :  3.01/03 19/03/2014  12.24.14  by  Michael Scheer
*CMZ :  2.66/19 07/06/2011  14.08.31  by  Michael Scheer
*CMZ :  2.63/03 07/05/2008  14.17.54  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  2.11/00 11/05/99  14.47.30  by  Michael Scheer
*-- Author :    Michael Scheer   11/05/99
      SUBROUTINE BMAG_SPLINE_INTER_XYZ(XA,BXA,BYA,BZA,BX2A,BY2A,BZ2A
     &                                ,N,X,BX,BY,BZ,MODE)
+seq,gplhint.

C---  INTERPOLATES Y(X) VIA SPLINE

C--   INPUT:

C-       N: NUMBER OF X,Y-VALUES
C-       XA:   ARRAY OF X-VALUES
C-       BYA:   ARRAY OF Y-VALUES
C-       BY2A:  ARRAY SPLINE COEFFICIENTS
C-       X: Y(X) IS CALCULATED
C-       MODE: CONTROL FLAG:
C-             MODE.GE.0: USE VALUES OF LAST CALL TO START WITH
C-             MODE.LT.0: NEW INITIALIZATION

C--   OUTPUT:

C-       Y: Y(X) IS CALCULATED

      IMPLICIT NONE

      INTEGER NOLD,N,KLO,KHI,KLOLD,K,MODE

      DOUBLE PRECISION BX,BY,BZ,X,XA1OLD,XANOLD,H,A,B,A3A,B3B,H26,H1

      DOUBLE PRECISION XA(*),BXA(*),BYA(*),BZA(*),BX2A(*),BY2A(*),BZ2A(*)

      save klold,nold,xa1old,xanold

      DATA KLOLD/1/,NOLD/-99/
      DATA XA1OLD/-9999.D0/,XANOLD/-9999./

      IF(     XA(1).LT.XA(N).AND.(X.LT.XA(1).OR.X.GT.XA(N))
     &    .OR.
     &    XA(N).LT.XA(1).AND.(X.LT.XA(N).OR.X.GT.XA(1))) THEN
        STOP '***SR BMAG_SPLINE_INTER: X OUT OF RANGE ***'
      ENDIF

      IF ( MODE.GE.0.AND.NOLD.EQ.N) THEN
        IF ( XA(1).EQ.XA1OLD
     &      .AND. XA(N).EQ.XANOLD
     &      .AND. X.GT.XA(KLOLD)
     &      ) THEN
          KLO=KLOLD
        ELSE
          KLO=1
        ENDIF
      ELSE
        KLO=1
      ENDIF

      IF (X.LT.XA(KLO+1)) THEN
      KHI=KLO+1
      GOTO 2
      ENDIF

      KHI=N
1     IF (KHI-KLO.GT.1) THEN
        K=(KHI+KLO)/2
        IF(XA(K).GT.X)THEN
          KHI=K
        ELSE
          KLO=K
        ENDIF
      GOTO 1
      ENDIF

2     H=XA(KHI)-XA(KLO)

      IF (H.LE.0.) THEN
        WRITE(6,*) '*** ERROR IN BMAG_SPLINE_INTER: BAD INPUT ***'
        STOP
      ENDIF

      H1=1.D0/H
      H26=H*H/6.D0
      A=(XA(KHI)-X)*H1
      B=(X-XA(KLO))*H1
      A3A=A*A*A-A
      B3B=B*B*B-B

      BX=A*BXA(KLO)+B*BXA(KHI)+(A3A*BX2A(KLO)+B3B*BX2A(KHI))*H26
      BY=A*BYA(KLO)+B*BYA(KHI)+(A3A*BY2A(KLO)+B3B*BY2A(KHI))*H26
      BZ=A*BZA(KLO)+B*BZA(KHI)+(A3A*BZ2A(KLO)+B3B*BZ2A(KHI))*H26

      KLOLD=KLO
      NOLD=N
      XA1OLD=XA(1)
      XANOLD=XA(N)

      RETURN
      END
+DECK,BMASH3D.
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.02.52  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  22.21.26  by  Michael Scheer
*CMZ :  1.00/00 29/07/97  10.15.30  by  Michael Scheer
*CMZ : 00.02/00 21/11/96  14.40.10  by  Michael Scheer
*CMZ :  1.00/03 27/09/95  17.15.24  by  Michael Scheer
*CMZ :  1.00/01 25/09/95  18.20.26  by  Michael Scheer
*CMZ :  1.00/00 21/09/95  17.13.57  by  Michael Scheer
*-- Author :    Michael Scheer   21/09/95
      SUBROUTINE BMASH3D(X,Y,Z,BX,BY,BZ,IFAIL)
+seq,gplhint.

C---  TO FIT 3D POTENTIAL V=SUM( CG(I,J,K) * X**(I-1) * Y**(J-1) * Z**(K-1))
C     OF A MAGNETIC FIELD B=(BX,BY,BZ)=-GRAD(V)
C

C--- OUTPUT:

C     IFAIL : FAILURE FLAG

      IMPLICIT NONE


+SEQ,BMASH.

      INTEGER IFAIL,I,NCINDG

      DOUBLE PRECISION X(NPOIP),Y(NPOIP),Z(NPOIP)
     &                  ,BX(NPOIP),BY(NPOIP),BZ(NPOIP)

      INTEGER ICAL,ICOEF,IX,IY,IZ,IS,NS
     &         ,JX,JY,JZ
      INTEGER ICG(MORDP+1,MORDP+1,MORDP+1)

      DOUBLE PRECISION VC(MFITP)

      DATA ICAL/0/

      DO IZ=1,MORDP+1
      DO IY=1,MORDP+1
      DO IX=1,MORDP+1
          CG(IX,IY,IZ)=0.D0
          ICG(IX,IY,IZ)=0
      ENDDO
      ENDDO
      ENDDO

      IF (ICAL.EQ.0) THEN
          CALL BMASH3DINIT
      ENDIF !ICAL

      CALL BMASH3DFIT(X,Y,Z,BX,BY,BZ,VC,IFAIL)

C--- GET FITTED COEFFICIENTS

      DO ICOEF=1,MFITP
          IX=INDEX(1,ICOEF)
          IY=INDEX(2,ICOEF)
          IZ=INDEX(3,ICOEF)
C         IF (ICAL.EQ.0) READ(5,*)VC(ICOEF)
          CG(IX+1,IY+1,IZ+1)=VC(ICOEF)
          ICG(IX+1,IY+1,IZ+1)=1
      ENDDO

C--- CALCULATE OTHER COEFFICIENTS

      DO ICOEF=1,MFITP
            NS=INDEX(4,ICOEF)
          IF (NS.GT.1) THEN
             IX=INDEX(1,ICOEF)
             IY=INDEX(2,ICOEF)
             IZ=INDEX(3,ICOEF)
             DO IS=1,NS
            JX=NINT(FSTAK(1,IS,ICOEF))
            JY=NINT(FSTAK(2,IS,ICOEF))
            JZ=NINT(FSTAK(3,IS,ICOEF))
            IF (IX.NE.JX.OR.IY.NE.JY.OR.IZ.NE.JZ) THEN
            ICG(JX+1,JY+1,JZ+1)=2
            CG(JX+1,JY+1,JZ+1)=CG(JX+1,JY+1,JZ+1)
     &         +FSTAK(4,IS,ICOEF)*CG(IX+1,IY+1,IZ+1)
                 ENDIF
             ENDDO   !IS
         ENDIF
      ENDDO

      IF (ICAL.EQ.0) THEN

         NCINDG=0
              DO IZ=1,MORDP+1
              DO IY=1,MORDP+1
              DO IX=1,MORDP+1
                  IF (ICG(IX,IY,IZ).NE.0) THEN
            NCINDG=NCINDG+1
            ICINDG(1,NCINDG)=IX
            ICINDG(2,NCINDG)=IY
            ICINDG(3,NCINDG)=IZ
             ENDIF
              ENDDO
              ENDDO
              ENDDO

         IF (NCINDG.NE.MTOTP) THEN
             WRITE(6,*)
             WRITE(6,*)
     & '*** ERROR IN BMASH3D: WRONG NUMBER OF COEFFICIENTS'
             WRITE(6,*)
             STOP
         ENDIF

         ICAL=1

      ENDIF

      DO I=1,NCINDG
          CINDG(I)=CG(ICINDG(1,I),ICINDG(2,I),ICINDG(3,I))
      ENDDO

      RETURN
      END
+DECK,BMASH3DFIT.
*CMZ :  2.13/05 08/02/2000  17.02.52  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  14.58.52  by  Michael Scheer
*CMZ :  1.00/00 28/07/97  15.04.13  by  Michael Scheer
*CMZ : 00.02/00 15/11/96  13.26.33  by  Michael Scheer
*CMZ :  1.00/01 26/09/95  16.53.15  by  Michael Scheer
*CMZ :  1.00/00 21/09/95  17.14.11  by  Michael Scheer
*-- Author :    Michael Scheer   21/09/95
      SUBROUTINE BMASH3DFIT(X,Y,Z,BX,BY,BZ,VC,IFAIL)
+seq,gplhint.

C--- FITS V=...+VC(IXYZ)*X**(INDEX(1,IXYZ))*Y**(INDEX(2,IXYZ))*Z**(INDEX(3,IXYZ)
C--- WITH (BX,BY,BZ)=-GRAD(V)

C---  OUTPUT:
C-    VC     : COEFFICIENTS VC(N) TO BE FITTED
C-    IFAIL       :  FAILURE FLAG

      IMPLICIT NONE

+SEQ,BMASH.

      INTEGER IX,IY,IZ,JX,JY,JZ,IXYZ,JXYZ,IPOI,IFIT
     &         ,JFIT,IS,NS,JS,MS

      INTEGER IFAIL

      DOUBLE PRECISION X(NPOIP),Y(NPOIP),Z(NPOIP)
     &                  ,BX(NPOIP),BY(NPOIP),BZ(NPOIP)
     &                  ,VC(MFITP)
     &                  ,A(MFITP,MFITP)
     &                  ,WS(2*MFITP)
     &                  ,XPOW(MORDP+1),YPOW(MORDP+1),ZPOW(MORDP+1)

      DOUBLE PRECISION AX1,AY1,AZ1,AX2,AY2,AZ2,XPOI,YPOI,ZPOI
     &                  ,XPOW1,YPOW1,ZPOW1
     &                  ,XPOW2,YPOW2,ZPOW2
     &         ,BSUM,X99,Y99,Z99

      IFAIL=0

      DO IY=1,MFITP
          VC(IY)=0.D0
          DO IX=1,MFITP
         A(IX,IY)=0.D0
          ENDDO
      ENDDO

C- DO THE FITTING

      DO IPOI=1,NPOIP

          XPOI=X(IPOI)
          YPOI=Y(IPOI)
          ZPOI=Z(IPOI)

          XPOW(1)=1.D0
          DO IX=2,MORDP+1
          XPOW(IX)=XPOW(IX-1)*XPOI
        ENDDO

          YPOW(1)=1.D0
          DO IY=2,MORDP+1
          YPOW(IY)=YPOW(IY-1)*YPOI
        ENDDO

          ZPOW(1)=1.D0
          DO IZ=2,MORDP+1
          ZPOW(IZ)=ZPOW(IZ-1)*ZPOI
        ENDDO

        IF (BX(IPOI).EQ.-9999.) THEN
          X99=0.0D0
        ELSE
          X99=1.0D0
        ENDIF

        IF (BY(IPOI).EQ.-9999.) THEN
          Y99=0.0D0
        ELSE
          Y99=1.0D0
        ENDIF

        IF (BZ(IPOI).EQ.-9999.) THEN
          Z99=0.0D0
        ELSE
          Z99=1.0D0
        ENDIF


      IFIT=0
      DO IXYZ=1,MFITP

         IFIT=IFIT+1

           NS=INDEX(4,IXYZ)

           BSUM=0.D0
           AX1=0.D0
           AY1=0.D0
           AZ1=0.D0
           DO IS=1,NS

            IX=NINT(FSTAK(1,IS,IXYZ))+1
            IY=NINT(FSTAK(2,IS,IXYZ))+1
            IZ=NINT(FSTAK(3,IS,IXYZ))+1

                      IF(IX.GT.1) THEN
                         XPOW1=XPOW(IX-1)
            ELSE
                         XPOW1=1.D0
                      ENDIF

                      IF(IY.GT.1) THEN
                         YPOW1=YPOW(IY-1)
            ELSE
                         YPOW1=1.D0
                      ENDIF

                      IF(IZ.GT.1) THEN
                         ZPOW1=ZPOW(IZ-1)
            ELSE
                         ZPOW1=1.D0
                      ENDIF

            BSUM=BSUM+FSTAK(4,IS,IXYZ)*(
     &                  -(IX-1)*BX(IPOI)*XPOW1*YPOW(IY)*ZPOW(IZ)*X99
     &         -(IY-1)*BY(IPOI)*YPOW1*XPOW(IX)*ZPOW(IZ)*Y99
     &              -(IZ-1)*BZ(IPOI)*ZPOW1*XPOW(IX)*YPOW(IY)*Z99
     &                  )

                  AX1=AX1
     &                     +X99*FSTAK(4,IS,IXYZ)*(IX-1)*XPOW1*YPOW(IY)*ZPOW(IZ)
                      AY1=AY1
     &                     +Y99*FSTAK(4,IS,IXYZ)*(IY-1)*YPOW1*XPOW(IX)*ZPOW(IZ)
            AZ1=AZ1
     &                      +Z99*FSTAK(4,IS,IXYZ)*(IZ-1)*ZPOW1*XPOW(IX)*YPOW(IY)

         ENDDO !NS

                      VC(IFIT)=VC(IFIT)+BSUM

      JFIT=0
      DO JXYZ=1,MFITP

         JFIT=JFIT+1

           MS=INDEX(4,JXYZ)

           AX2=0.D0
           AY2=0.D0
           AZ2=0.D0
           DO JS=1,MS

            JX=NINT(FSTAK(1,JS,JXYZ))+1
            JY=NINT(FSTAK(2,JS,JXYZ))+1
            JZ=NINT(FSTAK(3,JS,JXYZ))+1

                      IF(JX.GT.1) THEN
                         XPOW2=XPOW(JX-1)
            ELSE
                         XPOW2=1.D0
                      ENDIF

                      IF(JY.GT.1) THEN
                         YPOW2=YPOW(JY-1)
            ELSE
                         YPOW2=1.D0
                      ENDIF

                      IF(JZ.GT.1) THEN
                         ZPOW2=ZPOW(JZ-1)
            ELSE
                         ZPOW2=1.D0
                      ENDIF

                  AX2=AX2
     &                     +X99*FSTAK(4,JS,JXYZ)*(JX-1)*XPOW2*YPOW(JY)*ZPOW(JZ)
                      AY2=AY2
     &                     +Y99*FSTAK(4,JS,JXYZ)*(JY-1)*YPOW2*XPOW(JX)*ZPOW(JZ)
            AZ2=AZ2
     &                      +Z99*FSTAK(4,JS,JXYZ)*(JZ-1)*ZPOW2*XPOW(JX)*YPOW(JY)

         ENDDO !NS

         A(IFIT,JFIT)=A(IFIT,JFIT)+AX1*AX2+AY1*AY2+AZ1*AZ2

      ENDDO !JXYZ
      ENDDO !IXYZ

      ENDDO !IPOI

        CALL DEQN(MFITP,A,MFITP,WS,IFAIL,1,VC) !CERN F010

      RETURN
      END
+DECK,BMASH3DINIT.
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  16.21.18  by  Michael Scheer
*CMZ :  1.03/06 11/06/98  18.22.03  by  Michael Scheer
*CMZ :  1.00/00 28/07/97  15.09.21  by  Michael Scheer
*CMZ : 00.02/00 14/11/96  17.55.17  by  Michael Scheer
*CMZ : 00.01/09 05/10/95  16.34.35  by  Michael Scheer
*CMZ :  1.00/01 25/09/95  14.26.06  by  Michael Scheer
*CMZ :  1.00/00 21/09/95  17.14.08  by  Michael Scheer
*-- Author :    Michael Scheer   21/09/95
      SUBROUTINE BMASH3DINIT

      IMPLICIT NONE
+seq,gplhint.

+SEQ,BMASH.

      CHARACTER(80) FILECOEFF

      INTEGER NCOEF,IORD

      INTEGER IX,IY,IZ,IS,NS,IR

      DATA FILECOEFF/'WI:BMASH.COEF'/

      MORD=MORDP
      MFIT=MFITP
      MTOT=MTOTP
      NPOI=NPOIP

      NCOEF=0

+SELF,IF=VMS.
      OPEN(UNIT=99,FILE=FILECOEFF,STATUS='OLD',SHARED)
+SELF.
+SELF,IF=LINUX,WINDOWS.
        OPEN(UNIT=99,FILE=FILECOEFF,STATUS='OLD')
+SELF.


100       READ(99,*,END=900) IX,IY,IZ,NS

          DO IORD=1,MORDP
         IF(IX+IY+IZ.EQ.IORD) GOTO 50
          ENDDO
          GOTO 100

50        NCOEF=NCOEF+1

          IF (NCOEF.GT.MTOTP) THEN
             WRITE(6,*)
             WRITE(6,*)
     &   '*** ERROR IN BMASH3DINIT: DIMENSION MTOTP EXCEEDED ***'
             WRITE(6,*)
             STOP
          ENDIF

          IF (NS.GT.NSTAKP) THEN
             WRITE(6,*)
             WRITE(6,*)
     &   '*** ERROR IN BMASH3DINIT: DIMENSION NSTAKP EXCEEDED ***'
             WRITE(6,*)
             STOP
          ENDIF

          INDEX(1,NCOEF)=IX
          INDEX(2,NCOEF)=IY
          INDEX(3,NCOEF)=IZ

          IF (NS.GT.0) THEN
         INDEX(4,NCOEF)=NS
         DO IS=1,NS
             READ(99,*)(FSTAK(IR,IS,NCOEF),IR=1,4)
         ENDDO
          ELSE
         INDEX(4,NCOEF)=1
         FSTAK(1,1,NCOEF)=IX
         FSTAK(2,1,NCOEF)=IY
         FSTAK(3,1,NCOEF)=IZ
         FSTAK(4,1,NCOEF)=1.D0
          ENDIF   !IS

      GOTO 100

900   CLOSE(99)

      IF (NCOEF.NE.MFITP) THEN
         WRITE(6,*)
     &'*** ERROR IN BMASH3DINIT: WRONG NUMBER OF COEFFICIENTS ***'
         WRITE(6,*)'CHECK ',FILECOEFF
         WRITE(6,*)
         STOP
      ENDIF

      RETURN
      END
+DECK,BMASHB.
*CMZ :  1.00/00 29/07/97  10.17.24  by  Michael Scheer
*CMZ : 00.02/00 15/11/96  11.30.41  by  Michael Scheer
*CMZ : 00.01/09 25/10/95  17.37.17  by  Michael Scheer
*-- Author :    Michael Scheer   29/09/95

      SUBROUTINE BMASHB(X,Y,Z,BX,BY,BZ)
+seq,gplhint.

C--- ALL INDICES ACCORDING TO FORTRAN, BUT LORD3DG AND MORD3DG REFER TO MATH. INDICES

      IMPLICIT NONE

+SEQ,BMASH.


      INTEGER IX,IY,IZ,IND

      DOUBLE PRECISION X,Y,Z,BX,BY,BZ,XPOW1,YPOW1,ZPOW1

      DOUBLE PRECISION XPOW(MORDP+1),YPOW(MORDP+1),ZPOW(MORDP+1)


      XPOW(1)=1.D0
      DO IX=2,MORDP+1
          XPOW(IX)=XPOW(IX-1)*X
      ENDDO

      YPOW(1)=1.D0
      DO IY=2,MORDP+1
          YPOW(IY)=YPOW(IY-1)*Y
      ENDDO

      ZPOW(1)=1.D0
      DO IZ=2,MORDP+1
          ZPOW(IZ)=ZPOW(IZ-1)*Z
      ENDDO

      BX=0.D0
      BY=0.D0
      BZ=0.D0

      DO IND=1,MTOTP

             IX=ICINDG(1,IND)
             IY=ICINDG(2,IND)
             IZ=ICINDG(3,IND)

             IF (IX.GT.1) THEN
            XPOW1=XPOW(IX-1)
             ELSE
            XPOW1=1.D0
             ENDIF
             BX=BX-(IX-1)*CINDG(IND)*XPOW1*YPOW(IY)*ZPOW(IZ)

             IF (IY.GT.1) THEN
            YPOW1=YPOW(IY-1)
             ELSE
            YPOW1=1.D0
             ENDIF

             BY=BY-(IY-1)*CINDG(IND)*XPOW(IX)*YPOW1*ZPOW(IZ)

             IF (IZ.GT.1) THEN
            ZPOW1=ZPOW(IZ-1)
             ELSE
            ZPOW1=1.D0
             ENDIF

             BZ=BZ-(IZ-1)*CINDG(IND)*XPOW(IX)*YPOW(IY)*ZPOW1

      ENDDO

      RETURN
      END
+DECK,BMESS.
*CMZ :  3.00/00 18/09/2013  12.33.23  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.68/02 02/07/2012  11.43.27  by  Michael Scheer
*CMZ :  2.57/00 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.54/05 17/05/2005  15.01.37  by  Michael Scheer
*CMZ :  2.45/01 13/12/2002  14.40.32  by  Michael Scheer
*CMZ :  2.44/01 10/12/2002  17.52.22  by  Michael Scheer
*CMZ :  2.44/00 07/11/2002  17.13.48  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.34/09 20/09/2001  12.05.02  by  Michael Scheer
*CMZ :  2.16/08 29/10/2000  17.13.01  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.02.52  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  14.58.52  by  Michael Scheer
*CMZ :  1.00/00 06/08/97  17.14.18  by  Michael Scheer
*CMZ : 00.02/05 16/04/97  17.05.38  by  Michael Scheer
*CMZ : 00.02/00 22/11/96  15.24.30  by  Michael Scheer
*CMZ : 00.01/09 05/10/95  13.50.07  by  Michael Scheer
*CMZ : 00.01/04 28/11/94  18.31.15  by  Michael Scheer
*CMZ : 00.01/02 24/11/94  15.54.08  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.33.07  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.00  by  Michael Scheer
*-- Author : Michael Scheer
C**********************************************************************
      SUBROUTINE BMESS(X,Y,Z,BX,BY,BZ)

C     INTERPOLATION OF 3D EQUALLY SPACED FIELD MAP
C**********************************************************************

+seq,gplhint.
+SEQ,BMESSF90U,IF=F90.

      IMPLICIT NONE

      CHARACTER(64) COMMENT

      INTEGER ICAL,IX,IX1,IX2,IY,IY1,IY2,IZ,IZ1,IZ2,NPOIP,NPOI,IFAIL
      INTEGER IX1O,IY1O,IZ1O,I,NX,NY,NZ,IWARNX
      PARAMETER (NPOIP=4*4*4)

      DOUBLE PRECISION BXO,BYO,BZO
      DOUBLE PRECISION X,Y,Z,BX,BY,BZ,STEP,DXX,DYY,DZZ
      DOUBLE PRECISION DX,DY,DZ,SCALXYZ
      DOUBLE PRECISION XPOI(NPOIP),YPOI(NPOIP),ZPOI(NPOIP)
      DOUBLE PRECISION BXPOI(NPOIP),BYPOI(NPOIP),BZPOI(NPOIP)
      DOUBLE PRECISION B111(3),B211(3), B121(3),B221(3)
      DOUBLE PRECISION B112(3),B212(3), B122(3),B222(3)
      DOUBLE PRECISION B112111(3),B212211(3), B122121(3),B222221(3)
      DOUBLE PRECISION BLOW(3),BHIG(3),B(3)

+SEQ,CONTRL.
+SEQ,CMPARA.
+SEq,bmessf90.
+SEQ,BPOLY3DG.

      DATA ICAL/0/
      DATA SCALXYZ/100.D0/
      DATA IWARNX/0/

      IF (IRFILB0.EQ.-4) THEN
        CALL BMESS4(X,Y,Z,BX,BY,BZ)
        RETURN
      else IF (IRFILB0.EQ.6.or.irfilb0.eq.-6) THEN
        CALL bmap(X,Y,Z,BX,BY,BZ)
        RETURN
      ENDIF

      IF (ICAL.EQ.0) THEN

        STEP=1.D0/MYINUM
        LORD3DG=1
        NDORD3DG=1

        CALL BMESSINI

        B3DSCALEG=SCALXYZ

        X3DMING=BMXMIN*SCALXYZ
        X3DMAXG=BMXMAX*SCALXYZ
        Y3DMING=BMYMIN*SCALXYZ
        Y3DMAXG=BMYMAX*SCALXYZ
        Z3DMING=BMZMIN*SCALXYZ
        Z3DMAXG=BMZMAX*SCALXYZ

        NX=NBMDATX
        NY=NBMDATY
        NZ=NBMDATZ

        IF (IRFILB0.EQ.-1.OR.IRFILB0.EQ.-2) THEN
          NX=2
          NY=2
          NZ=2
        ENDIF

        ICAL=1

      ENDIF

      IF (IWARNX.EQ.0.AND.(X.LT.BMXMIN-STEP.OR.X.GT.BMXMAX+STEP)) THEN
        WRITE(6,*)'*** WARNING: IN BMESS: X OUT OF RANGE'
        WRITE(6,*)'X:',X
        WRITE(6,*)'Y:',Y
        WRITE(6,*)'Z:',Z
        WRITE(LUNGFO,*)'*** WARNING IN BMESS: X OUT OF RANGE'
        WRITE(LUNGFO,*)'X:',X
        WRITE(LUNGFO,*)'Y:',Y
        WRITE(LUNGFO,*)'Z:',Z
        IWARNX=1
      ENDIF

      IF (IWARNX.NE.0.AND.(X.LT.BMXMIN-STEP.OR.X.GT.BMXMAX+STEP)) THEN
        BX=0.0D0
        BY=0.0D0
        BZ=0.0D0
        RETURN
      ENDIF

      IF (Y.LT.BMYMIN-STEP.OR.Y.GT.BMYMAX+STEP) THEN
        WRITE(6,*)'*** ERROR IN BMESS: Y OUT OF RANGE'
        WRITE(6,*)'X:',X
        WRITE(6,*)'Y:',Y
        WRITE(6,*)'Z:',Z
        WRITE(LUNGFO,*)'*** ERROR IN BMESS: Y OUT OF RANGE'
        WRITE(LUNGFO,*)'X:',X
        WRITE(LUNGFO,*)'Y:',Y
        WRITE(LUNGFO,*)'Z:',Z
        STOP
      ENDIF

      IF (Z.LT.BMZMIN-STEP.OR.Z.GT.BMZMAX+STEP) THEN
        WRITE(6,*)'*** ERROR IN BMESS: Z OUT OF RANGE'
        WRITE(6,*)'X:',X
        WRITE(6,*)'Y:',Y
        WRITE(6,*)'Z:',Z
        WRITE(LUNGFO,*)'*** ERROR IN BMESS: Z OUT OF RANGE'
        WRITE(LUNGFO,*)'X:',X
        WRITE(LUNGFO,*)'Y:',Y
        WRITE(LUNGFO,*)'Z:',Z
        STOP
      ENDIF

      IF (X.LT.BMXMIN) THEN
        IX1=1
      ELSE
C        IX1=NINT((X-BMXMIN+BMESSEPS)/BMESSDX)+1
        IX1=(X-BMXMIN)/BMESSDX+1-(NX-1)/2
        IX1=MAX(1,IX1)
      ENDIF
      IX2=IX1+NX-1
      IF (IX2.GT.NBMESSX) THEN
        IX2=NBMESSX
        IX1=IX2-NX+1
      ENDIF

      IF (Y.LT.BMYMIN) THEN
        IY1=1
      ELSE
C        IY1=NINT((Y-BMYMIN+BMESSEPS)/BMESSDY)+1
        IY1=(Y-BMYMIN)/BMESSDY+1-(NY-1)/2
        IY1=MAX(1,IY1)
      ENDIF
      IY2=IY1+NY-1
      IF (IY2.GT.NBMESSY) THEN
        IY2=NBMESSY
        IY1=IY2-NY+1
      ENDIF

      IF (Z.LT.BMZMIN) THEN
        IZ1=1
      ELSE
C        IZ1=NINT((Z-BMZMIN+BMESSEPS)/BMESSDZ)+1
        IZ1=(Z-BMZMIN)/BMESSDZ+1-(NZ-1)/2
        IZ1=MAX(1,IZ1)
      ENDIF
      IZ2=IZ1+NZ-1
      IF (IZ2.GT.NBMESSZ) THEN
        IZ2=NBMESSZ
        IZ1=IZ2-NZ+1
      ENDIF

      IF (IRFILB0.EQ.-1) THEN

        IF (IX1.EQ.IX1O.AND.IY1.EQ.IY1O.AND.IZ1.EQ.IZ1O) THEN
          BX=BXO
          BY=BYO
          BZ=BZO
        ELSE
          BX=BDATA(1,IZ1,IY1,IX1)
          BY=BDATA(2,IZ1,IY1,IX1)
          BZ=BDATA(3,IZ1,IY1,IX1)
          BXO=BX
          BYO=BY
          BZO=BZ
        ENDIF   !OLD VOXL

      ELSE IF (IRFILB0.EQ.-2) THEN

        DXX=(X-(BMXMIN+(IX1-1)*BMESSDX))/BMESSDX
        DYY=(Y-(BMYMIN+(IY1-1)*BMESSDY))/BMESSDY
        DZZ=(Z-(BMZMIN+(IZ1-1)*BMESSDZ))/BMESSDZ

        DO I=1,3

          B111(I)=BDATA(I,IZ1,IY1,IX1)
          B211(I)=BDATA(I,IZ2,IY1,IX1)
          B121(I)=BDATA(I,IZ1,IY2,IX1)
          B221(I)=BDATA(I,IZ2,IY2,IX1)
          B112(I)=BDATA(I,IZ1,IY1,IX2)
          B212(I)=BDATA(I,IZ2,IY1,IX2)
          B122(I)=BDATA(I,IZ1,IY2,IX2)
          B222(I)=BDATA(I,IZ2,IY2,IX2)

          B112111(I)=B111(I)+(B112(I)-B111(I))*DXX
          B122121(I)=B121(I)+(B122(I)-B121(I))*DXX
          B212211(I)=B211(I)+(B212(I)-B211(I))*DXX
          B222221(I)=B221(I)+(B222(I)-B221(I))*DXX

          BLOW(I)=B112111(I)+(B212211(I)-B112111(I))*DZZ
          BHIG(I)=B122121(I)+(B222221(I)-B122121(I))*DZZ

          B(I)=BLOW(I)+(BHIG(I)-BLOW(I))*DYY

        ENDDO

        BX=B(1)
        BY=B(2)
        BZ=B(3)

      ELSE !(IRFILB0.EQ.-1)

        DX=(X-(BMXMIN+(IX1-1)*BMESSDX))*SCALXYZ
        DY=(Y-(BMYMIN+(IY1-1)*BMESSDY))*SCALXYZ
        DZ=(Z-(BMZMIN+(IZ1-1)*BMESSDZ))*SCALXYZ

C SKIP FIT, IF STILL IN OLD VOXEL
        IF (IX1.EQ.IX1O.AND.IY1.EQ.IY1O.AND.IZ1.EQ.IZ1O) GOTO 500

        NPOI=0
        DO IX=IX1,IX2
          DO IY=IY1,IY2
            DO IZ=IZ1,IZ2

              NPOI=NPOI+1
              IF (NPOI.GT.NPOIP) THEN
                WRITE(6,*)'*** ERROR IN BMESS: DIMENSION EXCEEDED ***'
                STOP
              ENDIF


              XPOI(NPOI)=BMESSDX*(IX-IX1)*SCALXYZ
              YPOI(NPOI)=BMESSDY*(IY-IY1)*SCALXYZ
              ZPOI(NPOI)=BMESSDZ*(IZ-IZ1)*SCALXYZ

C ATTENTION: IZ,IY,IX !! BE AWARE
              BXPOI(NPOI)=BDATA(1,IZ,IY,IX)
              BYPOI(NPOI)=BDATA(2,IZ,IY,IX)
              BZPOI(NPOI)=BDATA(3,IZ,IY,IX)

            ENDDO
          ENDDO
        ENDDO

        CALL BMPOT3D(NPOI,XPOI,YPOI,ZPOI,BXPOI,BYPOI,BZPOI,IFAIL,COMMENT)

        IF (IFAIL.NE.0) THEN
          WRITE(6,*)'*** ERROR IN BMESS: FIT FAILED'
          WRITE(6,*)'X,Y,Z:'
          WRITE(6,*)X,Y,Z
          WRITE(6,*)'XPOI(NPOI),YPOI(NPOI),ZPOI(NPOI)'
          WRITE(6,*)'BXPOI(NPOI),BYPOI(NPOI),BZPOI(NPOI)'
          WRITE(LUNGFO,*)'*** ERROR IN BMESS: FIT FAILED'
          WRITE(LUNGFO,*)'X,Y,Z:'
          WRITE(LUNGFO,*)X,Y,Z
          WRITE(LUNGFO,*)'XPOI(NPOI),YPOI(NPOI),ZPOI(NPOI)'
          WRITE(LUNGFO,*)'BXPOI(NPOI),BYPOI(NPOI),BZPOI(NPOI)'
          NPOI=0
          DO IX=IX1,IX2
            DO IY=IY1,IY2
              DO IZ=IZ1,IZ2
                NPOI=NPOI+1
                WRITE(6,*)XPOI(NPOI),YPOI(NPOI),ZPOI(NPOI)
                WRITE(6,*)BXPOI(NPOI),BYPOI(NPOI),BZPOI(NPOI)
                WRITE(LUNGFO,*)XPOI(NPOI),YPOI(NPOI),ZPOI(NPOI)
                WRITE(LUNGFO,*)BXPOI(NPOI),BYPOI(NPOI),BZPOI(NPOI)
              ENDDO
            ENDDO
          ENDDO
          STOP
        ENDIF

500   CONTINUE

      CALL BMESS3D(DX,DY,DZ,BX,BY,BZ)

      ENDIF !(IRFILB0.EQ.-1)

      IX1O=IX1
      IY1O=IY1
      IZ1O=IZ1

      RETURN
      END
+DECK,BMESS3D.
*CMZ :  2.44/01 18/09/2013  12.33.23  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  1.00/00 28/07/97  11.04.15  by  Michael Scheer
*CMZ : 00.02/00 15/11/96  11.30.41  by  Michael Scheer
*CMZ : 00.01/09 25/10/95  17.37.17  by  Michael Scheer
*-- Author :    Michael Scheer   29/09/95

      SUBROUTINE BMESS3D(X,Y,Z,BX,BY,BZ)

C--- ALL INDICES ACCORDING TO FORTRAN, BUT LORD3DG AND MORD3DG REFER TO MATH. INDICES

      IMPLICIT NONE

+seq,gplhint.
+SEQ,CONTRL.
+SEQ,BPOLY3DG.

      INTEGER IX,IY,IZ,NPOWP
     &         ,IWARNXMN,IWARNXMX,IWARNYMN,IWARNYMX,IWARNZMN,IWARNZMX
     &         ,IND,ICAL

      DOUBLE PRECISION X,Y,Z,BX,BY,BZ,XPOW1,YPOW1,ZPOW1,AX,AY,AZ

      PARAMETER (NPOWP=NDIMCG+1)
      DOUBLE PRECISION XPOW(NPOWP),YPOW(NPOWP),ZPOW(NPOWP)

      DATA IWARNXMN,IWARNXMX,IWARNYMN,IWARNYMX,IWARNZMN,IWARNZMX/6*0/
      DATA ICAL/0/

      IF (ICAL.EQ.0) THEN

      IF (MORD3DG.GT.NDIMCG-1) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN BMESS3D: DIMENSION NDIMCG EXCEEDED ***'
          WRITE(6,*)
          STOP
      ENDIF

      IF (MORD3DG.GT.NPOWP) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN BMESS3D: DIMENSION NPOWP EXCEEDED ***'
          WRITE(6,*)
          STOP
      ENDIF

      AX=0.D0
      AY=0.D0
      AZ=0.D0

      ICAL=1

      ENDIF

      IF (IWARNXMN.EQ.0.AND.X.LT.X3DMING) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING SR BMESS3D: X OUT OF FIT RANGE'
          WRITE(LUNGFO,*)'X .LT. X3DMING'
          WRITE(LUNGFO,*)'X, X3DMING:',X,X3DMING
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING SR BMESS3D: X OUT OF FIT RANGE'
          WRITE(6,*)'X .LT. X3DMING'
          WRITE(6,*)'X, X3DMING:',X,X3DMING
          WRITE(6,*)
          IWARNXMN=1
      ENDIF

      IF (IWARNXMX.EQ.0.AND.X.GT.X3DMAXG) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING SR BMESS3D: X OUT OF FIT RANGE'
          WRITE(LUNGFO,*)'X .GT. X3DMAXG'
          WRITE(LUNGFO,*)'X, X3DMAXG:',X,X3DMAXG
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING SR BMESS3D: X OUT OF FIT RANGE'
          WRITE(6,*)'X .GT. X3DMAXG'
          WRITE(6,*)'X, X3DMAXG:',X,X3DMAXG
          WRITE(6,*)
          IWARNXMX=1
      ENDIF

      IF (IWARNYMN.EQ.0.AND.Y.LT.Y3DMING) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING SR BMESS3D: Y OUT OF FIT RANGE'
          WRITE(LUNGFO,*)'Y .LT. Y3DMING'
          WRITE(LUNGFO,*)'Y, Y3DMING:',Y,Y3DMING
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING SR BMESS3D: Y OUT OF FIT RANGE'
          WRITE(6,*)'Y .LT. Y3DMING'
          WRITE(6,*)'Y, Y3DMING:',Y,Y3DMING
          WRITE(6,*)
          IWARNYMN=1
      ENDIF

      IF (IWARNYMX.EQ.0.AND.Y.GT.Y3DMAXG) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING SR BMESS3D: Y OUT OF FIT RANGE'
          WRITE(LUNGFO,*)'Y .GT. Y3DMAXG'
          WRITE(LUNGFO,*)'Y, Y3DMAXG:',Y,Y3DMAXG
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING SR BMESS3D: Y OUT OF FIT RANGE'
          WRITE(6,*)'Y .GT. Y3DMAXG'
          WRITE(6,*)'Y, Y3DMAXG:',Y,Y3DMAXG
          WRITE(6,*)
          IWARNYMX=1
      ENDIF

      IF (IWARNZMN.EQ.0.AND.Z.LT.Z3DMING) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING SR BMESS3D: Z OUT OF FIT RANGE'
          WRITE(LUNGFO,*)'Z .LT. Z3DMING'
          WRITE(LUNGFO,*)'Z, Z3DMING:',Z,Z3DMING
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING SR BMESS3D: Z OUT OF FIT RANGE'
          WRITE(6,*)'Z .LT. Z3DMING'
          WRITE(6,*)'Z, Z3DMING:',Z,Z3DMING
          WRITE(6,*)
          IWARNZMN=1
      ENDIF

      IF (IWARNZMX.EQ.0.AND.Z.GT.Z3DMAXG) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING SR BMESS3D: Z OUT OF FIT RANGE'
          WRITE(LUNGFO,*)'Z .GT. Z3DMAXG'
          WRITE(LUNGFO,*)'Z, Z3DMAXG:',Z,Z3DMAXG
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING SR BMESS3D: Z OUT OF FIT RANGE'
          WRITE(6,*)'Z .GT. Z3DMAXG'
          WRITE(6,*)'Z, Z3DMAXG:',Z,Z3DMAXG
          WRITE(6,*)
          IWARNZMX=1
      ENDIF

      XPOW(1)=1.D0
      DO IX=2,MORD3DG
          XPOW(IX)=XPOW(IX-1)*X
      ENDDO

      YPOW(1)=1.D0
      DO IY=2,MORD3DG
          YPOW(IY)=YPOW(IY-1)*Y
      ENDDO

      ZPOW(1)=1.D0
      DO IZ=2,MORD3DG
          ZPOW(IZ)=ZPOW(IZ-1)*Z
      ENDDO

      BX=0.D0
      BY=0.D0
      BZ=0.D0

      DO IND=1,NCINDG

             IX=ICINDG(1,IND)
             IY=ICINDG(2,IND)
             IZ=ICINDG(3,IND)

             IF (IX.GT.1) THEN
            XPOW1=XPOW(IX-1)
             ELSE
            XPOW1=1.D0
             ENDIF
             BX=BX-(IX-1)*CINDG(IND)*XPOW1*YPOW(IY)*ZPOW(IZ)

             IF (IY.GT.1) THEN
            YPOW1=YPOW(IY-1)
             ELSE
            YPOW1=1.D0
             ENDIF

             BY=BY-(IY-1)*CINDG(IND)*XPOW(IX)*YPOW1*ZPOW(IZ)

             IF (IZ.GT.1) THEN
            ZPOW1=ZPOW(IZ-1)
             ELSE
            ZPOW1=1.D0
             ENDIF

             BZ=BZ-(IZ-1)*CINDG(IND)*XPOW(IX)*YPOW(IY)*ZPOW1

      ENDDO

      RETURN
      END
+DECK,bmess3d4.
*CMZ :  2.44/01 18/09/2013  12.33.23  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  1.00/00 28/07/97  11.04.15  by  Michael Scheer
*CMZ : 00.02/00 15/11/96  11.30.41  by  Michael Scheer
*CMZ : 00.01/09 25/10/95  17.37.17  by  Michael Scheer
*-- Author :    Michael Scheer   29/09/95

      SUBROUTINE BMESS3D4(X,Y,Z,BX,BY,BZ,KX,KY,KZ)

+seq,gplhint.
+SEQ,BMESSF90U,IF=F90.

C--- ALL INDICES ACCORDING TO FORTRAN, BUT LORD3DG AND MORD3DG REFER TO MATH. INDICES

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,BPOLY3DG.

      INTEGER IX,IY,IZ,NPOWP,KX,KY,KZ
     &         ,IWARNXMN,IWARNXMX,IWARNYMN,IWARNYMX,IWARNZMN,IWARNZMX
     &         ,IND,ICAL

      DOUBLE PRECISION X,Y,Z,BX,BY,BZ,XPOW1,YPOW1,ZPOW1,AX,AY,AZ

      PARAMETER (NPOWP=NDIMCG+1)
      DOUBLE PRECISION XPOW(NPOWP),YPOW(NPOWP),ZPOW(NPOWP)

      DATA IWARNXMN,IWARNXMX,IWARNYMN,IWARNYMX,IWARNZMN,IWARNZMX/6*0/
      DATA ICAL/0/

      IF (ICAL.EQ.0) THEN

      IF (MORD3DG.GT.NDIMCG-1) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN BMESS3D4: DIMENSION NDIMCG EXCEEDED ***'
          WRITE(6,*)
          STOP
      ENDIF

      IF (MORD3DG.GT.NPOWP) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN BMESS3D4: DIMENSION NPOWP EXCEEDED ***'
          WRITE(6,*)
          STOP
      ENDIF

      AX=0.D0
      AY=0.D0
      AZ=0.D0

      ICAL=1

      ENDIF

      IF (IWARNXMN.EQ.0.AND.X.LT.X3DMING) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN BMESS3D4: X OUT OF FIT RANGE'
          WRITE(LUNGFO,*)'X .LT. X3DMING'
          WRITE(LUNGFO,*)'X, X3DMING:',X,X3DMING
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN BMESS3D4: X OUT OF FIT RANGE'
          WRITE(6,*)'X .LT. X3DMING'
          WRITE(6,*)'X, X3DMING:',X,X3DMING
          WRITE(6,*)
          IWARNXMN=1
      ENDIF

      IF (IWARNXMX.EQ.0.AND.X.GT.X3DMAXG) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN BMESS3D4: X OUT OF FIT RANGE'
          WRITE(LUNGFO,*)'X .GT. X3DMAXG'
          WRITE(LUNGFO,*)'X, X3DMAXG:',X,X3DMAXG
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN BMESS3D4: X OUT OF FIT RANGE'
          WRITE(6,*)'X .GT. X3DMAXG'
          WRITE(6,*)'X, X3DMAXG:',X,X3DMAXG
          WRITE(6,*)
          IWARNXMX=1
      ENDIF

      IF (IWARNYMN.EQ.0.AND.Y.LT.Y3DMING) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN BMESS3D4: Y OUT OF FIT RANGE'
          WRITE(LUNGFO,*)'Y .LT. Y3DMING'
          WRITE(LUNGFO,*)'Y, Y3DMING:',Y,Y3DMING
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN BMESS3D4: Y OUT OF FIT RANGE'
          WRITE(6,*)'Y .LT. Y3DMING'
          WRITE(6,*)'Y, Y3DMING:',Y,Y3DMING
          WRITE(6,*)
          IWARNYMN=1
      ENDIF

      IF (IWARNYMX.EQ.0.AND.Y.GT.Y3DMAXG) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN BMESS3D4: Y OUT OF FIT RANGE'
          WRITE(LUNGFO,*)'Y .GT. Y3DMAXG'
          WRITE(LUNGFO,*)'Y, Y3DMAXG:',Y,Y3DMAXG
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN BMESS3D4: Y OUT OF FIT RANGE'
          WRITE(6,*)'Y .GT. Y3DMAXG'
          WRITE(6,*)'Y, Y3DMAXG:',Y,Y3DMAXG
          WRITE(6,*)
          IWARNYMX=1
      ENDIF

      IF (IWARNZMN.EQ.0.AND.Z.LT.Z3DMING) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN BMESS3D4: Z OUT OF FIT RANGE'
          WRITE(LUNGFO,*)'Z .LT. Z3DMING'
          WRITE(LUNGFO,*)'Z, Z3DMING:',Z,Z3DMING
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN BMESS3D4: Z OUT OF FIT RANGE'
          WRITE(6,*)'Z .LT. Z3DMING'
          WRITE(6,*)'Z, Z3DMING:',Z,Z3DMING
          WRITE(6,*)
          IWARNZMN=1
      ENDIF

      IF (IWARNZMX.EQ.0.AND.Z.GT.Z3DMAXG) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN BMESS3D4: Z OUT OF FIT RANGE'
          WRITE(LUNGFO,*)'Z .GT. Z3DMAXG'
          WRITE(LUNGFO,*)'Z, Z3DMAXG:',Z,Z3DMAXG
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN BMESS3D4: Z OUT OF FIT RANGE'
          WRITE(6,*)'Z .GT. Z3DMAXG'
          WRITE(6,*)'Z, Z3DMAXG:',Z,Z3DMAXG
          WRITE(6,*)
          IWARNZMX=1
      ENDIF

      XPOW(1)=1.D0
      DO IX=2,MORD3DG
          XPOW(IX)=XPOW(IX-1)*X
      ENDDO

      YPOW(1)=1.D0
      DO IY=2,MORD3DG
          YPOW(IY)=YPOW(IY-1)*Y
      ENDDO

      ZPOW(1)=1.D0
      DO IZ=2,MORD3DG
          ZPOW(IZ)=ZPOW(IZ-1)*Z
      ENDDO

      BX=0.D0
      BY=0.D0
      BZ=0.D0

      DO IND=1,NCINDG

             IX=ICINDG(1,IND)
             IY=ICINDG(2,IND)
             IZ=ICINDG(3,IND)

             IF (IX.GT.1) THEN
            XPOW1=XPOW(IX-1)
             ELSE
            XPOW1=1.D0
             ENDIF
             BX=BX-(IX-1)*BMCOEF(IND,KZ,KY,KX)*XPOW1*YPOW(IY)*ZPOW(IZ)

             IF (IY.GT.1) THEN
            YPOW1=YPOW(IY-1)
             ELSE
            YPOW1=1.D0
             ENDIF

             BY=BY-(IY-1)*BMCOEF(IND,KZ,KY,KX)*XPOW(IX)*YPOW1*ZPOW(IZ)

             IF (IZ.GT.1) THEN
            ZPOW1=ZPOW(IZ-1)
             ELSE
            ZPOW1=1.D0
             ENDIF

             BZ=BZ-(IZ-1)*BMCOEF(IND,KZ,KY,KX)*XPOW(IX)*YPOW(IY)*ZPOW1

      ENDDO

      RETURN
      END
+DECK,BMESS4.
*CMZ :  3.00/00 18/09/2013  12.33.23  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.46/02 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.44/02 12/12/2002  14.09.23  by  Michael Scheer
*CMZ :  2.44/01 06/12/2002  11.10.22  by  Michael Scheer
*CMZ :  2.44/00 07/11/2002  17.13.48  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.34/09 20/09/2001  12.05.02  by  Michael Scheer
*CMZ :  2.16/08 29/10/2000  17.13.01  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.02.52  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  14.58.52  by  Michael Scheer
*CMZ :  1.00/00 06/08/97  17.14.18  by  Michael Scheer
*CMZ : 00.02/05 16/04/97  17.05.38  by  Michael Scheer
*CMZ : 00.02/00 22/11/96  15.24.30  by  Michael Scheer
*CMZ : 00.01/09 05/10/95  13.50.07  by  Michael Scheer
*CMZ : 00.01/04 28/11/94  18.31.15  by  Michael Scheer
*CMZ : 00.01/02 24/11/94  15.54.08  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.33.07  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.00  by  Michael Scheer
*-- Author : Michael Scheer
C**********************************************************************
      SUBROUTINE BMESS4(X,Y,Z,BX,BY,BZ)

C     INTERPOLATION OF 3D EQUALLY SPACED COEFFICIENT MAP
C**********************************************************************
+seq,gplhint.

+SEQ,BMESSF90U,IF=F90.

      IMPLICIT NONE

      INTEGER ICAL,IX1,IY1,IZ1
      INTEGER IX1O,IY1O,IZ1O

      DOUBLE PRECISION X,Y,Z,BX,BY,BZ,STEP
      DOUBLE PRECISION DX,DY,DZ

+SEQ,CONTRL.
+SEQ,CMPARA.
+SEq,bmessf90.
+SEQ,BPOLY3DG.

      DATA ICAL/0/

      IF (ICAL.EQ.0) THEN

            STEP=1.D0/MYINUM

          CALL BMESSINI4

          X3DMING=BMXMIN*B3DSCALEG
          X3DMAXG=BMXMAX*B3DSCALEG
          Y3DMING=BMYMIN*B3DSCALEG
          Y3DMAXG=BMYMAX*B3DSCALEG
          Z3DMING=BMZMIN*B3DSCALEG
          Z3DMAXG=BMZMAX*B3DSCALEG

          ICAL=1

      ENDIF

      IF (X.LT.BMXMIN-STEP.OR.X.GT.BMXMAX+STEP) THEN
          WRITE(6,*)'*** ERROR IN BMESS4: X OUT OF RANGE'
          WRITE(6,*)'X:',X
          WRITE(LUNGFO,*)'*** ERROR IN BMESS4: X OUT OF RANGE'
          WRITE(LUNGFO,*)'X:',X
          STOP
      ENDIF

      IF (Y.LT.BMYMIN-STEP.OR.Y.GT.BMYMAX+STEP) THEN
          WRITE(6,*)'*** ERROR IN BMESS4: Y OUT OF RANGE'
          WRITE(6,*)'Y:',Y
          WRITE(LUNGFO,*)'*** ERROR IN BMESS4: Y OUT OF RANGE'
          WRITE(LUNGFO,*)'Y:',Y
          STOP
      ENDIF

      IF (Z.LT.BMZMIN-STEP.OR.Z.GT.BMZMAX+STEP) THEN
          WRITE(6,*)'*** ERROR IN BMESS4: Z OUT OF RANGE'
          WRITE(6,*)'Z:',Z
          WRITE(LUNGFO,*)'*** ERROR IN BMESS4: Z OUT OF RANGE'
          WRITE(LUNGFO,*)'Z:',Z
          STOP
      ENDIF

      IX1=(X-BMXMIN)/BMESSDX+1
      IX1=MAX(1,IX1)
      IX1=MIN(NBMESSX-1,IX1)

      IY1=(Y-BMYMIN)/BMESSDY+1
      IY1=MAX(1,IY1)
      IY1=MIN(NBMESSY-1,IY1)

      IZ1=(Z-BMZMIN)/BMESSDZ+1
      IZ1=MAX(1,IZ1)
      IZ1=MIN(NBMESSZ-1,IZ1)

500   CONTINUE

        DX=(X-(BMXMIN+(IX1-1)*BMESSDX))*B3DSCALEG
        DY=(Y-(BMYMIN+(IY1-1)*BMESSDY))*B3DSCALEG
        DZ=(Z-(BMZMIN+(IZ1-1)*BMESSDZ))*B3DSCALEG

      CALL BMESS3D4(DX,DY,DZ,BX,BY,BZ,IX1,IY1,IZ1)

      IX1O=IX1
      IY1O=IY1
      IZ1O=IZ1

      RETURN
      END
+DECK,BMESSINI.
*CMZ :  4.00/14 30/12/2021  11.43.05  by  Michael Scheer
*CMZ :  4.00/13 16/12/2021  18.47.30  by  Michael Scheer
*CMZ :  3.05/10 13/08/2018  14.40.26  by  Michael Scheer
*CMZ :  3.02/05 22/03/2015  19.39.25  by  Michael Scheer
*CMZ :  3.02/03 23/10/2014  13.43.13  by  Michael Scheer
*CMZ :  3.02/00 28/08/2014  15.19.42  by  Michael Scheer
*CMZ :  3.01/06 18/06/2014  09.18.20  by  Michael Scheer
*CMZ :  3.01/05 12/06/2014  08.52.10  by  Michael Scheer
*CMZ :  3.00/00 18/09/2013  12.33.23  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  15.31.59  by  Michael Scheer
*CMZ :  2.68/05 28/09/2012  11.51.13  by  Michael Scheer
*CMZ :  2.68/02 15/06/2012  15.18.04  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  09.55.57  by  Michael Scheer
*CMZ :  2.47/23 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.47/22 03/12/2003  13.17.28  by  Michael Scheer
*CMZ :  2.44/01 04/12/2002  17.24.27  by  Michael Scheer
*CMZ :  2.44/00 08/11/2002  12.15.59  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.34/08 17/09/2001  19.11.02  by  Michael Scheer
*CMZ :  2.34/05 23/08/2001  17.35.07  by  Michael Scheer
*CMZ :  2.34/01 02/07/2001  17.22.17  by  Michael Scheer
*CMZ :  2.16/08 29/10/2000  17.25.47  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.02.52  by  Michael Scheer
*CMZ :  1.03/06 11/06/98  18.22.03  by  Michael Scheer
*CMZ :  1.00/00 29/07/97  16.33.37  by  Michael Scheer
*CMZ : 00.02/05 17/04/97  17.59.48  by  Michael Scheer
*CMZ : 00.02/04 12/02/97  14.52.46  by  Michael Scheer
*CMZ : 00.02/00 28/11/96  17.04.35  by  Michael Scheer
*-- Author :    Michael Scheer   11/11/96
      SUBROUTINE BMESSINI
+seq,gplhint.

+SEQ,BMESSF90U,IF=F90.

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,CMPARA.
+SEQ,MYFILES.
+SEQ,BPOLY3DG.
+SEQ,B0SCGLOB.
+SEq,bmessf90.
+seq,whbook.
+seq,pawcmn.

      CHARACTER(65) COMMENT

      INTEGER IREAD,IX,IY,IZ,ICAL,I,ISTAT,IERR
      INTEGER IBMESSX,IBMESSY,IBMESSZ
      INTEGER NOENT,NTUP,ICODEBM

      REAL*4 X,Y,Z,BX,BY,BZ,XO,YO,ZO,TUP(6)
      DOUBLE PRECISION DUM,DUMO

      INTEGER NTUP_P,ICYCLE
      PARAMETER (NTUP_P=6)
      REAL*8 TUP_D(NTUP_P)
      CHARACTER(3) CHTAGS_D(NTUP_P)
      data chtags_d/'x','y','z','bx','by','bz'/

      DATA ICAL/0/
      DATA XO,YO,ZO/3*0.D0/
      DATA NTUP/599/

      IF (ICAL.NE.0) RETURN

      NBMESSX=9999
      NBMESSY=9999
      NBMESSZ=9999

      OPEN(UNIT=99,STATUS='SCRATCH')

      ICAL=1

      IF (IHLIMIT_C.EQ.0) THEN
+self,if=mhbook.
        CALL hlimitm(mhbookp)
+self,if=-mhbook.
        CALL hlimitm(NDPAWC)
+self.
        IHLIMIT_C=1
      ENDIF

      BMESSEPS=0.00001

      BMXMIN=1.D30
      BMXMAX=-1.D30
      BMYMIN=1.D30
      BMYMAX=-1.D30
      BMZMIN=1.D30
      BMZMAX=-1.D30

      BMBXMIN=1.D30
      BMBXMAX=-1.D30
      BMBYMIN=1.D30
      BMBYMAX=-1.D30
      BMBZMIN=1.D30
      BMBZMAX=-1.D30

      BMESSDX=9999.
      BMESSDY=9999.
      BMESSDZ=9999.

      IF (NTUPGRID.LE.0) THEN

        IF (NTUPGRID.LT.0) THEN
          CALL HISINI
+self,if=-mhbook.
          CALL hbookm(NTUP,'WBMAP$',NTUP_P,'//WAVE',1024,CHTAGS_D)
+self,if=mhbook.
          CALL hbookm(NTUP,'WBMAP',NTUP_P,'//WAVE',
     &      nbmessx*nbmessy*nbmessz,CHTAGS_D)
+self.
        ENDIF

        OPEN(UNIT=LUNB0,FILE=FILEB0,STATUS='OLD',FORM='UNFORMATTED',ERR=9999)
        REWIND(LUNB0)

        READ(LUNB0,ERR=901)ICODEBM,COMMENT
        GOTO 902
901     WRITE(6,*)ICODEBM,COMMENT
902     CONTINUE
        READ(LUNB0,ERR=903)NBMESSX,BMXMIN,BMXMAX
        GOTO 904
903     WRITE(6,*)NBMESSX,BMXMIN,BMXMAX
904     CONTINUE
        READ(LUNB0)NBMESSY,BMYMIN,BMYMAX
        READ(LUNB0)NBMESSZ,BMZMIN,BMZMAX

        ALLOCATE(BDATA(3,NBMESSZ,NBMESSY,NBMESSX))
        DO IX=1,NBMESSX
          DO IY=1,NBMESSY
            DO IZ=1,NBMESSZ
              DO I=1,3
                BDATA(I,IZ,IY,IX)=-9999.
              ENDDO
            ENDDO
          ENDDO
        ENDDO

        BMESSDX=(BMXMAX-BMXMIN)/(NBMESSX-1)
        BMESSDY=(BMYMAX-BMYMIN)/(NBMESSY-1)
        BMESSDZ=(BMZMAX-BMZMIN)/(NBMESSZ-1)

        DO IBMESSX=1,NBMESSX
          DO IBMESSY=1,NBMESSY
            DO IBMESSZ=1,NBMESSZ

              READ(LUNB0)BX,BY,BZ

C*** ATTENTION LAST INDEX IS IN LONGITUDINAL DIRECTION (I.E. X)

              BDATA(1,IBMESSZ,IBMESSY,IBMESSX)=BX
              BDATA(2,IBMESSZ,IBMESSY,IBMESSX)=BY
              BDATA(3,IBMESSZ,IBMESSY,IBMESSX)=BZ

              IF (BX.LT.BMBXMIN) BMBXMIN=BX
              IF (BX.GT.BMBXMAX) BMBXMAX=BX
              IF (BY.LT.BMBYMIN) BMBYMIN=BY
              IF (BY.GT.BMBYMAX) BMBYMAX=BY
              IF (BZ.LT.BMBZMIN) BMBZMIN=BZ
              IF (BZ.GT.BMBZMAX) BMBZMAX=BZ

            ENDDO
          ENDDO
        ENDDO

        IF (NTUPGRID.LT.0) THEN

          DO IBMESSX=1,NBMESSX
            DO IBMESSY=1,NBMESSY
              DO IBMESSZ=1,NBMESSZ

                TUP_D(1)=BMXMIN+(IBMESSX-1)*BMESSDX
                TUP_D(2)=BMYMIN+(IBMESSY-1)*BMESSDY
                TUP_D(3)=BMZMIN+(IBMESSZ-1)*BMESSDZ
                TUP_D(4)=BDATA(1,IBMESSZ,IBMESSY,IBMESSX)
                TUP_D(5)=BDATA(2,IBMESSZ,IBMESSY,IBMESSX)
                TUP_D(6)=BDATA(3,IBMESSZ,IBMESSY,IBMESSX)
                CALL hfm(NTUP,TUP_D)

              ENDDO
            ENDDO
          ENDDO

          CALL MHROUT(NTUP,ICYCLE,' ')
          CALL hdeletm(NTUP)

        ENDIF   !NTUPGRID

        CLOSE(LUNB0)

        IREAD=NBMESSX*NBMESSY*NBMESSZ

      ELSE  !NTUPGRID

        CALL hropenm(LUNB0,'BMAP',FILEB0,' ',1024,ISTAT)

        IF (ISTAT.NE.0) THEN
          WRITE(6,*)
     &      '*** SR BMESSINI: ERROR OPENING NTUPLE FILE FILEB0'
          STOP
        ENDIF

        CALL hgnparm(NTUP,'BMESSINI')
        CALL hnoentm(NTUP,NOENT)

        DO IREAD=1,NOENT

          CALL hgnfm(NTUP,IREAD,TUP,IERR)
          IF (IERR.NE.0) THEN
            WRITE(6,*)'*** SR BMESSINI: ERROR READING NTUPLE'
            STOP
          ENDIF

          X=TUP(1)
          Y=TUP(2)
          Z=TUP(3)
          BX=TUP(4)
          BY=TUP(5)
          BZ=TUP(6)

          IF (IREAD.EQ.1) THEN
            XO=X
            YO=Y
            ZO=Z
          ENDIF

          IF (X.NE.XO) THEN
            IF (BMESSDX.EQ.9999.) THEN
              WRITE(99,*)X,XO
              BACKSPACE(99)
              READ(99,*)DUM,DUMO
              BMESSDX=DABS(DUM-DUMO)
            ENDIF
          ENDIF

          IF (Y.NE.YO) THEN
            IF (BMESSDY.EQ.9999.) THEN
              WRITE(99,*)Y,YO
              BACKSPACE(99)
              READ(99,*)DUM,DUMO
              BMESSDY=DABS(DUM-DUMO)
            ENDIF
          ENDIF

          IF (Z.NE.ZO) THEN
            IF (BMESSDZ.EQ.9999.) THEN
              WRITE(99,*)Z,ZO
              BACKSPACE(99)
              READ(99,*)DUM,DUMO
              BMESSDZ=DABS(DUM-DUMO)
            ENDIF
          ENDIF

          IF (X.LT.BMXMIN) BMXMIN=X
          IF (X.GT.BMXMAX) BMXMAX=X
          IF (Y.LT.BMYMIN) BMYMIN=Y
          IF (Y.GT.BMYMAX) BMYMAX=Y
          IF (Z.LT.BMZMIN) BMZMIN=Z
          IF (Z.GT.BMZMAX) BMZMAX=Z

          IF (BX.LT.BMBXMIN) BMBXMIN=BX
          IF (BX.GT.BMBXMAX) BMBXMAX=BX
          IF (BY.LT.BMBYMIN) BMBYMIN=BY
          IF (BY.GT.BMBYMAX) BMBYMAX=BY
          IF (BZ.LT.BMBZMIN) BMBZMIN=BZ
          IF (BZ.GT.BMBZMAX) BMBZMAX=BZ

          IBMESSX=NINT((X-BMXMIN)/BMESSDX)
          IF (ABS(X-(BMXMIN+IBMESSX*BMESSDX)).GT.BMESSEPS) THEN
            WRITE(6,*)'*** ERROR IN BMESSINI:'
            WRITE(6,*)'BAD X-VALUE:',X
            WRITE(LUNGFO,*)'*** ERROR IN BMESSINI:'
            WRITE(LUNGFO,*)'BAD X-VALUE:',X
            STOP
          ENDIF
          IBMESSX=IBMESSX+1

          IBMESSY=NINT((Y-BMYMIN)/BMESSDY)
          IF (ABS(Y-(BMYMIN+IBMESSY*BMESSDY)).GT.BMESSEPS) THEN
            WRITE(6,*)'*** ERROR IN BMESSINI:'
            WRITE(6,*)'BAD Y-VALUE:',Y
            WRITE(LUNGFO,*)'*** ERROR IN BMESSINI:'
            WRITE(LUNGFO,*)'BAD Y-VALUE:',Y
            STOP
          ENDIF
          IBMESSY=IBMESSY+1

          IBMESSZ=NINT((Z-BMZMIN)/BMESSDZ)
          IF (ABS(Z-(BMZMIN+IBMESSZ*BMESSDZ)).GT.BMESSEPS) THEN
            WRITE(6,*)'*** ERROR IN BMESSINI:'
            WRITE(6,*)'BAD Z-VALUE:',Z
            WRITE(LUNGFO,*)'*** ERROR IN BMESSINI:'
            WRITE(LUNGFO,*)'BAD Z-VALUE:',Z
            STOP
          ENDIF
          IBMESSZ=IBMESSZ+1

        ENDDO  !IREAD

        IREAD=NOENT
        NBMESSX=NINT((BMXMAX-BMXMIN)/BMESSDX)+1
        NBMESSY=NINT((BMYMAX-BMYMIN)/BMESSDY)+1
        NBMESSZ=NINT((BMZMAX-BMZMIN)/BMESSDZ)+1

        if (iroottrees.ge.0) then
          CALL hrendm('BMAP')
        endif
        CLOSE(LUNB0)

        ALLOCATE(BDATA(3,NBMESSZ,NBMESSY,NBMESSX))
        DO IX=1,NBMESSX
          DO IY=1,NBMESSY
            DO IZ=1,NBMESSZ
              DO I=1,3
                BDATA(I,IZ,IY,IX)=-9999.
              ENDDO
            ENDDO
          ENDDO
        ENDDO

        CALL hropenm(LUNB0,'BMAP',FILEB0,' ',1024,ISTAT)

        IF (ISTAT.NE.0) THEN
          WRITE(6,*)
     &      '*** SR BMESSINI: ERROR OPENING NTUPLE FILE FILEB0'
          STOP
        ENDIF

        CALL hgnparm(NTUP,'BMESSINI')
        CALL hnoentm(NTUP,NOENT)

        DO IREAD=1,NOENT

          CALL hgnfm(NTUP,IREAD,TUP,IERR)
          IF (IERR.NE.0) THEN
            WRITE(6,*)'*** SR BMESSINI: ERROR READING NTUPLE'
            STOP
          ENDIF

          X=TUP(1)
          Y=TUP(2)
          Z=TUP(3)
          BX=TUP(4)
          BY=TUP(5)
          BZ=TUP(6)

          IF (IREAD.EQ.1) THEN
            XO=X
            YO=Y
            ZO=Z
          ENDIF

          IF (X.NE.XO) THEN
            IF (BMESSDX.EQ.9999.) THEN
              WRITE(99,*)X,XO
              BACKSPACE(99)
              READ(99,*)DUM,DUMO
              BMESSDX=DABS(DUM-DUMO)
            ENDIF
          ENDIF

          IF (Y.NE.YO) THEN
            IF (BMESSDY.EQ.9999.) THEN
              WRITE(99,*)Y,YO
              BACKSPACE(99)
              READ(99,*)DUM,DUMO
              BMESSDY=DABS(DUM-DUMO)
            ENDIF
          ENDIF

          IF (Z.NE.ZO) THEN
            IF (BMESSDZ.EQ.9999.) THEN
              WRITE(99,*)Z,ZO
              BACKSPACE(99)
              READ(99,*)DUM,DUMO
              BMESSDZ=DABS(DUM-DUMO)
            ENDIF
          ENDIF

          IF (X.LT.BMXMIN) BMXMIN=X
          IF (X.GT.BMXMAX) BMXMAX=X
          IF (Y.LT.BMYMIN) BMYMIN=Y
          IF (Y.GT.BMYMAX) BMYMAX=Y
          IF (Z.LT.BMZMIN) BMZMIN=Z
          IF (Z.GT.BMZMAX) BMZMAX=Z

          IF (BX.LT.BMBXMIN) BMBXMIN=BX
          IF (BX.GT.BMBXMAX) BMBXMAX=BX
          IF (BY.LT.BMBYMIN) BMBYMIN=BY
          IF (BY.GT.BMBYMAX) BMBYMAX=BY
          IF (BZ.LT.BMBZMIN) BMBZMIN=BZ
          IF (BZ.GT.BMBZMAX) BMBZMAX=BZ

          IBMESSX=NINT((X-BMXMIN)/BMESSDX)
          IF (ABS(X-(BMXMIN+IBMESSX*BMESSDX)).GT.BMESSEPS) THEN
            WRITE(6,*)'*** ERROR IN BMESSINI:'
            WRITE(6,*)'BAD X-VALUE:',X
            WRITE(LUNGFO,*)'*** ERROR IN BMESSINI:'
            WRITE(LUNGFO,*)'BAD X-VALUE:',X
            STOP
          ENDIF
          IBMESSX=IBMESSX+1

          IBMESSY=NINT((Y-BMYMIN)/BMESSDY)
          IF (ABS(Y-(BMYMIN+IBMESSY*BMESSDY)).GT.BMESSEPS) THEN
            WRITE(6,*)'*** ERROR IN BMESSINI:'
            WRITE(6,*)'BAD Y-VALUE:',Y
            WRITE(LUNGFO,*)'*** ERROR IN BMESSINI:'
            WRITE(LUNGFO,*)'BAD Y-VALUE:',Y
            STOP
          ENDIF
          IBMESSY=IBMESSY+1

          IBMESSZ=NINT((Z-BMZMIN)/BMESSDZ)
          IF (ABS(Z-(BMZMIN+IBMESSZ*BMESSDZ)).GT.BMESSEPS) THEN
            WRITE(6,*)'*** ERROR IN BMESSINI:'
            WRITE(6,*)'BAD Z-VALUE:',Z
            WRITE(LUNGFO,*)'*** ERROR IN BMESSINI:'
            WRITE(LUNGFO,*)'BAD Z-VALUE:',Z
            STOP
          ENDIF
          IBMESSZ=IBMESSZ+1

C*** ATTENTION LAST INDEX IS IN LONGITUDINAL DIRECTION (I.E. X)

          BDATA(1,IBMESSZ,IBMESSY,IBMESSX)=BX
          BDATA(2,IBMESSZ,IBMESSY,IBMESSX)=BY
          BDATA(3,IBMESSZ,IBMESSY,IBMESSX)=BZ

        ENDDO  !IREAD

        IREAD=NOENT

        if (iroottrees.ge.0) then
          CALL hrendm('BMAP')
        endif
        CLOSE(LUNB0)

      ENDIF !NTUPGRID

      X=BMXMAX
      IBMESSX=NINT((X-BMXMIN)/BMESSDX)

      IF (ABS(X-(BMXMIN+IBMESSX*BMESSDX)).GT.BMESSEPS) THEN
        WRITE(6,*)'*** ERROR IN BMESSINI:'
        WRITE(6,*)'BAD X-VALUE:',X
        WRITE(LUNGFO,*)'*** ERROR IN BMESSINI:'
        WRITE(LUNGFO,*)'BAD X-VALUE:',X
        STOP
      ENDIF

      IF (NBMESSX.EQ.9999) THEN
        NBMESSX=IBMESSX+1
      ENDIF

      Y=BMYMAX
      IBMESSY=NINT((Y-BMYMIN)/BMESSDY)

      IF (ABS(Y-(BMYMIN+IBMESSY*BMESSDY)).GT.BMESSEPS) THEN
        WRITE(6,*)'*** ERROR IN BMESSINI:'
        WRITE(6,*)'BAD Y-VALUE:',Y
        WRITE(LUNGFO,*)'*** ERROR IN BMESSINI:'
        WRITE(LUNGFO,*)'BAD Y-VALUE:',Y
        STOP
      ENDIF

      IF (NBMESSY.EQ.9999) THEN
        NBMESSY=IBMESSY+1
      ENDIF

      Z=BMZMAX
      IBMESSZ=NINT((Z-BMZMIN)/BMESSDZ)

      IF (ABS(Z-(BMZMIN+IBMESSZ*BMESSDZ)).GT.BMESSEPS) THEN
        WRITE(6,*)'*** ERROR IN BMESSINI:'
        WRITE(6,*)'BAD Z-VALUE:',Z
        WRITE(LUNGFO,*)'*** ERROR IN BMESSINI:'
        WRITE(LUNGFO,*)'BAD Z-VALUE:',Z
        STOP
      ENDIF

      IF (NBMESSZ.EQ.9999) THEN
        NBMESSZ=IBMESSZ+1
      ENDIF

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SUBROUTINE BMESSINI:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     DATA FILE:'
      WRITE(LUNGFO,*)'     ',FILEB0

      IF (NTUPGRID.EQ.0) THEN
        WRITE(LUNGFO,*)'     ',ICODEBM,' ',COMMENT
      ENDIF

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     NUMBER OF DATA POINTS READ: ',IREAD
      WRITE(LUNGFO,*)'     NBMESSX, NBMESSY, NBMESSZ:  '
     &  ,NBMESSX,NBMESSY,NBMESSZ
      WRITE(LUNGFO,*)'     XMIN, XMAX:   ',BMXMIN,BMXMAX
      WRITE(LUNGFO,*)'     YMIN, YMAX:   ',BMYMIN,BMYMAX
      WRITE(LUNGFO,*)'     ZMIN, ZMAX:   ',BMZMIN,BMZMAX
      WRITE(LUNGFO,*)'     BXMIN, BXMAX: ',BMBXMIN,BMBXMAX
      WRITE(LUNGFO,*)'     BYMIN, BYMAX: ',BMBYMIN,BMBYMAX
      WRITE(LUNGFO,*)'     BZMIN, BZMAX: ',BMBZMIN,BMBZMAX
      WRITE(LUNGFO,*)'     BMESSDX, BMESSDY, BMESSDZ:  '
      WRITE(LUNGFO,*)'     ',BMESSDX,BMESSDY,BMESSDZ
      WRITE(LUNGFO,*)'     EPSILON:                    ',BMESSEPS

      IF (IRFILB0.GT.0) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     MORD3DG:     ',MORD3DG
        WRITE(LUNGFO,*)'     NBMDATX,NBMDATY,NBMDATZ:',NBMDATX,NBMDATY,NBMDATZ

        IF (NBMESSX.LT.NBMDATX) THEN
          WRITE(6,*)
     &      '*** ERROR IN BMESSINI: MUST HAVE NBMDATX DIFFERENT X-VALUES'
          WRITE(6,*)'CHECK DATA FILE FILEB0 AND NAMELIST BGRIDN'
          WRITE(LUNGFO,*)
     &      '*** ERROR IN BMESSINI: MUST HAVE NBMDATX DIFFERENT X-VALUES'
          WRITE(LUNGFO,*)'CHECK DATA FILE FILEB0 AND NAMELIST BGRIDN'
          WRITE(LUNGFO,*)
          STOP
        ENDIF

        IF (NBMESSY.LT.NBMDATY) THEN
          WRITE(6,*)
     &      '*** ERROR IN BMESSINI: MUST HAVE NBMDATY DIFFERENT Y-VALUES'
          WRITE(6,*)'CHECK DATA FILE FILEB0 AND NAMELIST BGRIDN'
          WRITE(LUNGFO,*)
     &      '*** ERROR IN BMESSINI: MUST HAVE NBMDATY DIFFERENT Y-VALUES'
          WRITE(LUNGFO,*)'CHECK DATA FILE FILEB0 AND NAMELIST BGRIDN'
          STOP
        ENDIF

        IF (NBMESSZ.LT.NBMDATZ) THEN
          WRITE(6,*)
     &      '*** ERROR IN BMESSINI: MUST HAVE NBMDATZ DIFFERENT Z-VALUES'
          WRITE(6,*)'CHECK DATA FILE FILEB0 AND NAMELIST BGRIDN'
          WRITE(LUNGFO,*)
     &      '*** ERROR IN BMESSINI: MUST HAVE NBMDATZ DIFFERENT Z-VALUES'
          WRITE(LUNGFO,*)'CHECK DATA FILE FILEB0 AND NAMELIST BGRIDN'
          STOP
        ENDIF

      ELSE !IRFILB0.GT.0

        IF (NBMESSX.LT.2) THEN
          WRITE(6,*)
     &      '*** ERROR IN BMESSINI: MUST HAVE 2 DIFFERENT X-VALUES'
          WRITE(6,*)'CHECK DATA FILE FILEB0 AND NAMELIST BGRIDN'
          WRITE(LUNGFO,*)
     &      '*** ERROR IN BMESSINI: MUST HAVE 2 DIFFERENT X-VALUES'
          WRITE(LUNGFO,*)'CHECK DATA FILE FILEB0 AND NAMELIST BGRIDN'
          WRITE(LUNGFO,*)
          STOP
        ENDIF

        IF (NBMESSY.LT.2) THEN
          WRITE(6,*)
     &      '*** ERROR IN BMESSINI: MUST HAVE 2 DIFFERENT Y-VALUES'
          WRITE(6,*)'CHECK DATA FILE FILEB0 AND NAMELIST BGRIDN'
          WRITE(LUNGFO,*)
     &      '*** ERROR IN BMESSINI: MUST HAVE 2 DIFFERENT Y-VALUES'
          WRITE(LUNGFO,*)'CHECK DATA FILE FILEB0 AND NAMELIST BGRIDN'
          STOP
        ENDIF

        IF (NBMESSZ.LT.2) THEN
          WRITE(6,*)
     &      '*** ERROR IN BMESSINI: MUST HAVE 2 DIFFERENT Z-VALUES'
          WRITE(6,*)'CHECK DATA FILE FILEB0 AND NAMELIST BGRIDN'
          WRITE(LUNGFO,*)
     &      '*** ERROR IN BMESSINI: MUST HAVE 2 DIFFERENT Z-VALUES'
          WRITE(LUNGFO,*)'CHECK DATA FILE FILEB0 AND NAMELIST BGRIDN'
          STOP
        ENDIF

      ENDIF !IRFILB0.GT.0

      DO IX=1,NBMESSX
        DO IY=1,NBMESSY
          DO IZ=1,NBMESSZ
            IF (
     &          BDATA(1,IZ,IY,IX).EQ.-9999. .OR.
     &          BDATA(2,IZ,IY,IX).EQ.-9999. .OR.
     &          BDATA(3,IZ,IY,IX).EQ.-9999.) THEN
              WRITE(6,*)'*** ERROR IN BMESSINI: STRANGE INPUT FILE'
              WRITE(LUNGFO,*)'*** ERROR IN BMESSINI: STRANGE INPUT FILE'
              STOP
            ENDIF
          ENDDO
        ENDDO
      ENDDO

      IF (XSTART.EQ.9999.) THEN
        IF (IPERIODG.NE.0.AND.SIGNG.LT.0.D0) THEN
          XSTART=2.D0*BMXMIN
        ELSE
          XSTART=BMXMIN
        ENDIF
      ENDIF

      IF (XSTOP.EQ.9999.) THEN
        IF (IPERIODG.NE.0.AND.SIGNG.LT.0.D0) THEN
          XSTOP=2.D0*BMXMAX
        ELSE
          XSTOP=BMXMAX
        ENDIF
      ENDIF

      CLOSE(99)

      RETURN

9999  WRITE(6,*) '*** Error in BMESSINI: Could not open file'
      WRITE(6,*) FILEB0

      STOP
      END
+DECK,BMESSINI4.
*CMZ :  3.05/10 13/08/2018  14.40.26  by  Michael Scheer
*CMZ :  3.00/00 18/09/2013  12.33.23  by  Michael Scheer
*CMZ :  2.48/04 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.45/01 13/12/2002  17.24.57  by  Michael Scheer
*CMZ :  2.44/02 12/12/2002  14.09.47  by  Michael Scheer
*CMZ :  2.44/01 06/12/2002  14.56.41  by  Michael Scheer
*CMZ :  2.44/00 08/11/2002  12.15.59  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.34/08 17/09/2001  19.11.02  by  Michael Scheer
*CMZ :  2.34/05 23/08/2001  17.35.07  by  Michael Scheer
*CMZ :  2.34/01 02/07/2001  17.22.17  by  Michael Scheer
*CMZ :  2.16/08 29/10/2000  17.25.47  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.02.52  by  Michael Scheer
*CMZ :  1.03/06 11/06/98  18.22.03  by  Michael Scheer
*CMZ :  1.00/00 29/07/97  16.33.37  by  Michael Scheer
*CMZ : 00.02/05 17/04/97  17.59.48  by  Michael Scheer
*CMZ : 00.02/04 12/02/97  14.52.46  by  Michael Scheer
*CMZ : 00.02/00 28/11/96  17.04.35  by  Michael Scheer
*-- Author :    Michael Scheer   11/11/96

      SUBROUTINE BMESSINI4
+seq,gplhint.

+SEQ,BMESSF90U,IF=F90.

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,CMPARA.
+SEQ,MYFILES.
+SEQ,BPOLY3DG.
+SEQ,B0SCGLOB.
+SEq,bmessf90.
+seq,whbook.
+seq,pawcmn.


      INTEGER IBMESSX,IBMESSY,IBMESSZ
      INTEGER ICODEBM,IND,ICAL

      REAL*4 X,Y,Z

        CHARACTER(13) COMMENT4
        CHARACTER(65) COMMENT

      DATA ICAL/0/

      IF (ICAL.NE.0) RETURN

      ICAL=1

      BMESSEPS=0.00001

      IF (NTUPGRID.NE.0) THEN
          WRITE(6,*)'*** ERROR IN BMESSINI4: NTUPGRID.NE.0'
          WRITE(LUNGFO,*)'*** ERROR IN BMESSINI4: NTUPGRID.NE.0'
          STOP
      ENDIF

      OPEN(UNIT=LUNB0,FILE=FILEB0,STATUS='OLD'
     &    ,FORM='UNFORMATTED')
        REWIND(LUNB0)

        READ(LUNB0) COMMENT4
      IF (COMMENT4.NE.'MAP OF COEFFS') THEN
          WRITE(6,*)'*** ERROR IN BMESSINI4: NOT A COEFFICIENT MAP ON FILE'
          WRITE(6,*)FILEBMAP
          WRITE(LUNGFO,*)'*** ERROR IN BMESSINI4: NOT A COEFFICIENT MAP ON FILE'
          WRITE(LUNGFO,*)FILEBMAP
          STOP
      ENDIF

      READ(LUNB0)ICODEBM,COMMENT
      READ(LUNB0)NBMESSX,BMXMIN,BMXMAX
      READ(LUNB0)NBMESSY,BMYMIN,BMYMAX
      READ(LUNB0)NBMESSZ,BMZMIN,BMZMAX

      READ(LUNB0)NCINDG,MORD3DG
      IF (NCINDG.GT.NDIMCIPG) THEN
          WRITE(6,*)'*** ERROR IN BMESSINI4: DIMENSION NDIMCIPG EXCEEDED'
          WRITE(LUNGFO,*)'*** ERROR IN BMESSINI4: DIMENSION NDIMCIPG EXCEEDED'
          STOP
      ENDIF
      DO IND=1,NCINDG
        READ(LUNB0) ICINDG(1,IND),ICINDG(2,IND),ICINDG(3,IND)
      ENDDO

      ALLOCATE(BMCOEF(NCINDG,NBMESSZ,NBMESSY,NBMESSX))

          DO IBMESSX=1,NBMESSX-1
          DO IBMESSY=1,NBMESSY-1
          DO IBMESSZ=1,NBMESSZ-1
          READ(LUNB0)(BMCOEF(IND,IBMESSZ,IBMESSY,IBMESSX),IND=1,NCINDG)
          ENDDO
          ENDDO
          ENDDO

          READ(LUNB0)B3DSCALEG

      CLOSE(LUNB0)

          BMESSDX=(BMXMAX-BMXMIN)/(NBMESSX-1)
          BMESSDY=(BMYMAX-BMYMIN)/(NBMESSY-1)
          BMESSDZ=(BMZMAX-BMZMIN)/(NBMESSZ-1)

      X=BMXMAX
          IBMESSX=NINT((X-BMXMIN)/BMESSDX)
          IF (ABS(X-(BMXMIN+IBMESSX*BMESSDX)).GT.BMESSEPS) THEN
            WRITE(6,*)'*** ERROR IN BMESSINI4:'
            WRITE(6,*)'BAD X-VALUE:',X
            WRITE(LUNGFO,*)'*** ERROR IN BMESSINI4:'
            WRITE(LUNGFO,*)'BAD X-VALUE:',X
            STOP
          ENDIF
      IF (NBMESSX.EQ.9999) THEN
          NBMESSX=IBMESSX+1
      ENDIF

      Y=BMYMAX
          IBMESSY=NINT((Y-BMYMIN)/BMESSDY)
          IF (ABS(Y-(BMYMIN+IBMESSY*BMESSDY)).GT.BMESSEPS) THEN
            WRITE(6,*)'*** ERROR IN BMESSINI4:'
            WRITE(6,*)'BAD Y-VALUE:',Y
            WRITE(LUNGFO,*)'*** ERROR IN BMESSINI4:'
            WRITE(LUNGFO,*)'BAD Y-VALUE:',Y
            STOP
          ENDIF
      IF (NBMESSY.EQ.9999) THEN
          NBMESSY=IBMESSY+1
      ENDIF

      Z=BMZMAX
          IBMESSZ=NINT((Z-BMZMIN)/BMESSDZ)
          IF (ABS(Z-(BMZMIN+IBMESSZ*BMESSDZ)).GT.BMESSEPS) THEN
            WRITE(6,*)'*** ERROR IN BMESSINI4:'
            WRITE(6,*)'BAD Z-VALUE:',Z
            WRITE(LUNGFO,*)'*** ERROR IN BMESSINI4:'
            WRITE(LUNGFO,*)'BAD Z-VALUE:',Z
            STOP
          ENDIF
      IF (NBMESSZ.EQ.9999) THEN
          NBMESSZ=IBMESSZ+1
      ENDIF

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SUBROUTINE BMESSINI4:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     DATA FILE:'
      WRITE(LUNGFO,*)'     ',FILEB0
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     NUMBER OF COEFFICIENTS READ:',NCINDG
      WRITE(LUNGFO,*)'     XMIN, XMAX:  ',BMXMIN,BMXMAX
      WRITE(LUNGFO,*)'     YMIN, YMAX:  ',BMYMIN,BMYMAX
      WRITE(LUNGFO,*)'     ZMIN, ZMAX:  ',BMZMIN,BMZMAX
      WRITE(LUNGFO,*)'     DX, DY, DZ:  '
      WRITE(LUNGFO,*)'     ',BMESSDX,BMESSDY,BMESSDZ
      WRITE(LUNGFO,*)'     EPSILON:     ',BMESSEPS

      IF (XSTART.EQ.9999.) THEN
          IF (IPERIODG.NE.0.AND.SIGNG.LT.0.D0) THEN
         XSTART=2.D0*BMXMIN
          ELSE
         XSTART=BMXMIN
          ENDIF
      ENDIF

      IF (XSTOP.EQ.9999.) THEN
          IF (IPERIODG.NE.0.AND.SIGNG.LT.0.D0) THEN
         XSTOP=2.D0*BMXMAX
          ELSE
         XSTOP=BMXMAX
          ENDIF
      ENDIF

      RETURN
      END
+DECK,BMOVE.
*CMZ :  3.05/04 04/07/2018  15.30.22  by  Michael Scheer
*CMZ :  3.02/04 02/12/2014  16.21.37  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.66/20 22/11/2011  10.34.00  by  Michael Scheer
*CMZ :  2.61/02 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  10.41.29  by  Michael Scheer
*CMZ :  2.52/16 21/01/2005  17.08.15  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  10.56.48  by  Michael Scheer
*CMZ :  2.20/01 29/11/2000  18.34.26  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  2.12/00 27/05/99  18.01.14  by  Michael Scheer
*CMZ :  2.10/01 07/05/99  12.21.34  by  Michael Scheer
*CMZ : 00.01/10 20/08/96  12.00.15  by  Michael Scheer
*CMZ : 00.01/08 21/06/95  17.17.07  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  15.22.06  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.48.13  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.17  by  Michael Scheer
*-- Author : Michael Scheer
+seq,gplhint.
C*******************************************************************************
      Subroutine BMOVE(R0X,R0Y,R0Z,V0X,V0Y,V0Z,BXIN,BYIN,BZIN,DELTAT,
     &             X,Y,Z,VX,VY,VZ,VXP,VYP,VZP,Gamma,ICHARGE,BMOVECUT,IUSTEP)

C
C     SEE ALSO MYBMOVE
C
C
C*******************************************************************************
C
C BERECHNET DIE EXAKTE 3-DIM Trajektorie EINES TEILCHENS IN EINEM
C 3-DIM HOMOGENEN Magnetfeld
C  NEUESTE VERSION VOM 15.5.1985
C
C LAENGEN IN METERN
C GeschwindigkeitEN IN M/SEC
C ZEIT IN SEKUNDEN
C B-FELDER IN TESLA V SEC/M**2
C
C*******************************************************************

C20.8.96      ImpLicit DOUBLE PRECISION(A-Z)

        IMPLICIT NONE

        DOUBLE PRECISION BX,BY,BZ,BSQ,BBET,BUX,BUY,BUZ,V0SQ,V0X,V0Y,V0Z,
     &         V0BET,VPAR,VPARX,VPARY,VPARZ,VSENK,DELTAT,BXIN,BYIN,BZIN
        DOUBLE PRECISION N1X,N1Y,N1Z,N2X,N2Y,N2Z,RHO  !DAS WAR ICH NICHT

        DOUBLE PRECISION X,Y,Z,VX,VY,VZ,R0X,R0Y,R0Z,VXP,VYP,VZP,ZYK,GAMMA,SZ,CZ
        DOUBLE PRECISION BMOVECUT,dgammao

        double precision dgamma,acc

      INTEGER ICHARGE,IUSTEP

C      DATA QEL,CLIGHT,EMASS/1.6021892D-19,2.99792458D08, 9.109534D-31/

+SEQ,efield.
+SEQ,PHYCON.
C
C KOMPONENTEN DER EINHEITSVEKTOREN IN
C B-RICHTUNG
C

      IF (ICHARGE.GT.0) THEN
          BX=-BXIN
          BY=-BYIN
          BZ=-BZIN
      ELSE
          BX=BXIN
          BY=BYIN
          BZ=BZIN
      ENDIF

        IF(DABS(BX).LT.BMOVECUT.AND.DABS(BY).LT.BMOVECUT
     &    .AND.DABS(BZ).LT.BMOVECUT) GO TO 30

      BSQ=BX*BX+BY*BY+BZ*BZ
      BBET=SQRT(BSQ)
      BUX=BX/BBET
      BUY=BY/BBET
      BUZ=BZ/BBET

C
C   BETRAG VON V0 PARALELL UND SENKRECHT
C
      V0SQ=V0X*V0X+V0Y*V0Y+V0Z*V0Z
      V0BET=SQRT(V0SQ)
      VPAR=(V0X*BX+V0Y*BY+V0Z*BZ)/BBET
      VSENK=V0BET-VPAR
      IF (VSENK.LT.0.0) THEN
          VSENK=0.0
      ELSE
          VSENK=SQRT((V0BET+VPAR)*VSENK)
      ENDIF

C
C   VEKTOR N1 BERECHNEN
C
      IF(VSENK.EQ.0.) N1X=0.
      IF(VSENK.EQ.0.) N1Y=0.
      IF(VSENK.EQ.0.) N1Z=0.
      IF(VSENK.EQ.0.) GO TO 10

      N1X=(V0X-VPAR*BUX)/VSENK
      N1Y=(V0Y-VPAR*BUY)/VSENK
      N1Z=(V0Z-VPAR*BUZ)/VSENK

10    CONTINUE

C
C  VEKTOR N2=(BUX,BUY,BUZ) KREUZ N1
C
      N2X = BUY*N1Z - BUZ*N1Y
      N2Y = BUZ*N1X - BUX*N1Z
      N2Z = BUX*N1Y - BUY*N1X

C
C  VPAR
C
      VPARX=VPAR*BUX
      VPARY=VPAR*BUY
      VPARZ=VPAR*BUZ

C
C ZYKLOTRONFREQUENZ
C
      ZYK= (ECHARGE1/(Gamma*EMASSKG1))*BBET

C
C
      SZ=DSIN(ZYK*DELTAT)
      CZ=DCOS(ZYK*DELTAT)

C
C  ZEITABLEITUNG DER Geschwindigkeit
C
c This is at the beginning of the step
cerror 4.7.2018      VXP=VSENK*ZYK*N2X
cerror 4.7.2018      VYP=VSENK*ZYK*N2Y
cerror 4.7.2018      VZP=VSENK*ZYK*N2Z

C
C V(DELTAT),X(DELTAT) BERECHNEN
C
      VX=VPARX + VSENK*(N1X*CZ+N2X*SZ)
      VY=VPARY + VSENK*(N1Y*CZ+N2Y*SZ)
      VZ=VPARZ + VSENK*(N1Z*CZ+N2Z*SZ)

      IF(VSENK.EQ.0.) X=R0X+VPARX*DELTAT
      IF(VSENK.EQ.0.) Y=R0Y+VPARY*DELTAT
      IF(VSENK.EQ.0.) Z=R0Z+VPARZ*DELTAT
      IF(VSENK.EQ.0.) GO TO 20

C
C X(DELTAT) BERECHNEN
C

      RHO=VSENK/ZYK

      X=R0X+RHO*(N2X+N1X*SZ-N2X*CZ)+VPARX*DELTAT
      Y=R0Y+RHO*(N2Y+N1Y*SZ-N2Y*CZ)+VPARY*DELTAT
      Z=R0Z+RHO*(N2Z+N1Z*SZ-N2Z*CZ)+VPARZ*DELTAT

20    CONTINUE
      GOTO 999

30    CONTINUE

      VXP=0.D0
      VYP=0.D0
      VZP=0.D0

      X=R0X+V0X*DELTAT
      Y=R0Y+V0Y*DELTAT
      Z=R0Z+V0Z*DELTAT

      VX=V0X
      VY=V0Y
      VZ=V0Z

cerror 4.7.2018, due to error above, now here
      acc=icharge*echarge1/(gamma*emasskg1)
      vxp=acc*(vy*bzin-vz*byin)
      vyp=acc*(vz*bxin-vx*bzin)
      vzp=acc*(vx*byin-vy*bxin)

999   CONTINUE

      IF (kefield.NE.0) THEN
        dgammao=dgamma
        CALL estep(X,Y,Z,VX,VY,VZ,deltat,gamma,dgamma)
        dgamma=dgammao+dgamma
        VXP=(VX-V0X)/DELTAT
        VYP=(VY-V0Y)/DELTAT
        VZP=(VZ-V0Z)/DELTAT
      ENDIF

      IF (IUSTEP.NE.0) THEN
        dgammao=dgamma
        CALL USTEP(X,Y,Z,VX,VY,VZ,vxp,vyp,vzp,deltat,gamma,dgamma)
        dgamma=dgammao+dgamma
      ENDIF

      RETURN
      End
+DECK,BMOVETAYL.
*CMZ :  3.06/00 14/02/2019  21.59.37  by  Michael Scheer
*CMZ :  3.05/20 31/10/2018  10.50.14  by  Michael Scheer
*CMZ :  3.05/13 19/09/2018  08.53.32  by  Michael Scheer
*CMZ :  3.05/04 04/07/2018  13.24.53  by  Michael Scheer
*CMZ :  3.05/00 02/05/2018  11.05.41  by  Michael Scheer
*CMZ :  3.04/01 08/03/2018  16.10.29  by  Michael Scheer
*CMZ :  3.04/00 01/03/2018  15.48.20  by  Michael Scheer
*CMZ :  3.02/04 02/12/2014  16.21.05  by  Michael Scheer
*CMZ :  3.01/06 20/06/2014  16.41.15  by  Michael Scheer
*CMZ :  3.01/04 20/05/2014  12.53.10  by  Michael Scheer
*CMZ :  3.01/00 18/07/2013  13.23.00  by  Michael Scheer
*CMZ :  2.68/03 22/08/2012  12.47.44  by  Michael Scheer
*CMZ :  2.68/02 06/06/2012  09.45.08  by  Michael Scheer
*CMZ :  2.68/00 24/05/2012  15.54.07  by  Michael Scheer
*CMZ :  2.67/06 24/05/2012  14.24.46  by  Michael Scheer
*CMZ :  2.67/02 09/05/2012  09.06.48  by  Michael Scheer
*CMZ :  2.66/20 22/11/2011  10.34.00  by  Michael Scheer
*CMZ :  2.63/05 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.61/02 14/03/2007  16.37.46  by  Michael Scheer
*CMZ :  2.53/02 24/01/2005  13.48.52  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  12.59.53  by  Michael Scheer
*CMZ :  2.52/16 21/01/2005  17.08.32  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  11.03.35  by  Michael Scheer
*CMZ :  2.20/11 11/04/2001  11.16.32  by  Michael Scheer
*CMZ :  2.20/01 05/12/2000  14.03.36  by  Michael Scheer
*CMZ :  2.16/08 20/10/2000  17.40.03  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  2.12/00 27/05/99  18.01.33  by  Michael Scheer
*CMZ :  2.11/00 11/05/99  14.23.02  by  Michael Scheer
*-- Author :    Michael Scheer   11/05/99
C*******************************************************************************
      Subroutine BMOVETAYL(Xin,yin,zin,VX1,VY1,VZ1,BXIN,BYIN,BZIN,DTIM,
     &  X2,Y2,Z2,VX2,VY2,VZ2,VXP,VYP,VZP,GAMMA,ICHARGE,BMOVECUT,
     &  IUSTEP,IENELOSS,DGAMMA)
C*******************************************************************************
+seq,gplhint.
C
C
C BMOVE OPTIMIERT, ABER NACH WIE VOR WIRD (VXP,VYP,VZP) AM EINGANG DES ZEIT-
C INTERVALLES BERECHNET
C

C BERECHNET DIE 3-DIM Trajektorie EINES TEILCHENS IN EINEM
C 3-DIM HOMOGENEN Magnetfeld
C
C LAENGEN IN METERN
C GeschwindigkeitEN IN M/SEC
C ZEIT IN SEKUNDEN
C B-FELDER IN TESLA V SEC/M**2
C
C*******************************************************************

      IMPLICIT NONE
+seq,uservar.
+seq,ustep.

      DOUBLE PRECISION BBET1,VSENK1,VSENK2,TZ,TZ2,TZ3,TZ4,TZ5,VSENKZYK
      !31.10.2018
      double precision xin,yin,zin

      DOUBLE PRECISION BX2,BY2,BZ2,BSQ,BBET,BUX,BUY,BUZ,V0SQ,VX1,VY1,VZ1,
     &  V0BET,VPAR,VPARX,VPARY,VPARZ,VPARSQ,VSENK,DTIM,BXIN,BYIN,BZIN
      DOUBLE PRECISION X1N,Y1N,Z1N,X2N,Y2N,Z2N,
     &  vx12,vy12,vz12

      DOUBLE PRECISION X2,Y2,Z2,VX2,VY2,VZ2,X1,Y1,Z1,VXP,VYP,VZP,ZYK,GAMMA,SZ,CZ
     &  ,DGAMMA,PDUM

      DOUBLE PRECISION BMOVECUT,dgammao,v0,v12n(3),emom,pel(3),
     &  zp,yp,brho,dz,dy,acc,y12,z12,dk

      INTEGER ICHARGE,IUSTEP,IENELOSS,icorry,icorrz,isbig

+SEQ,photon.
+SEQ,efield.
+SEQ,PHYCON.

      !31.10.2018
      x1=0.0d0
      y1=0.0d0
      z1=0.0d0

      isbig=0

      PDUM=CGAM1/2.0D0/PI1*CLIGHT1*(CLIGHT1/1.0D9)**2*EMASSG1

      DGAMMA=0.0D0

      IF (ICHARGE.GT.0) THEN
        BX2=-BXIN
        BY2=-BYIN
        BZ2=-BZIN
      ELSE
        BX2=BXIN
        BY2=BYIN
        BZ2=BZIN
      ENDIF

      IF(DABS(BX2).LT.BMOVECUT.AND.DABS(BY2).LT.BMOVECUT
     &    .AND.DABS(BZ2).LT.BMOVECUT) THEN

        VXP=0.0D0
        VYP=0.0D0
        VZP=0.0D0

        X2=X1+VX1*DTIM
        Y2=Y1+VY1*DTIM
        Z2=Z1+VZ1*DTIM

        VX2=VX1
        VY2=VY1
        VZ2=VZ1

        GOTO 999

      ENDIF !B-CUT

      BSQ=BX2*BX2+BY2*BY2+BZ2*BZ2
      BBET=DSQRT(BSQ)
      BBET1=1.0D0/BBET

      BUX=BX2*BBET1
      BUY=BY2*BBET1
      BUZ=BZ2*BBET1

C
C   BETRAG VON V0 PARALELL UND SENKRECHT
C
      V0SQ=VX1*VX1+VY1*VY1+VZ1*VZ1
      v0=sqrt(v0sq)
      V0BET=DSQRT(V0SQ)

C
C  VPAR
C
      VPAR=VX1*BUX+VY1*BUY+VZ1*BUZ
      VPARSQ=VPAR*VPAR
      VPARX=VPAR*BUX
      VPARY=VPAR*BUY
      VPARZ=VPAR*BUZ

c      VSENK2=(V0SQ-VPARSQ)
      vsenk2=(v0bet-vpar)*(v0bet+vpar)

      IF (VSENK2.LE.0.0D0) THEN

C
C  ZEITABLEITUNG DER Geschwindigkeit
C
        VXP=0.D0
        VYP=0.D0
        VZP=0.D0

C
C V(DTIM),X(DTIM) BERECHNEN
C

        X2=X1+VX1*DTIM
        Y2=Y1+VY1*DTIM
        Z2=Z1+VZ1*DTIM

        VX2=VX1
        VY2=VY1
        VZ2=VZ1

        GOTO 999

      ELSE    !(VSENK2.LT.0.0)

        VSENK=DSQRT(VSENK2)
        VSENK1=1.0D0/VSENK

C
C   VEKTOR N1 BERECHNEN
C

        X1N=(VX1-VPAR*BUX)*VSENK1
        Y1N=(VY1-VPAR*BUY)*VSENK1
        Z1N=(VZ1-VPAR*BUZ)*VSENK1

C
C  VEKTOR N2=(BUX,BUY,BUZ) KREUZ N1
C

        X2N = BUY*Z1N - BUZ*Y1N
        Y2N = BUZ*X1N - BUX*Z1N
        Z2N = BUX*Y1N - BUY*X1N

C
C ZYKLOTRONFREQUENZ
C
        ZYK=(ECHARGE1/(GAMMA*EMASSKG1))*BBET
C
C

        TZ=ZYK*DTIM

        IF (TZ.LE.0.03D0) THEN
          TZ2=TZ*TZ
          TZ3=TZ2*TZ
          TZ4=TZ3*TZ
          TZ5=TZ4*TZ
          CZ=1.0D0-TZ2/2.0D0+TZ4/24.0D0
          SZ=TZ-TZ3/6.0D0+TZ5/120.0D0
        ELSE
          CZ=COS(TZ)
          SZ=SIN(TZ)
          isbig=1
        ENDIF

C
C  ZEITABLEITUNG DER Geschwindigkeit
C
cerror 4.7.2018, this is at the beginning of the step
c        VXP=VSENK*ZYK*X2N
c        VYP=VSENK*ZYK*Y2N
c        VZP=VSENK*ZYK*Z2N

C
C V(DTIM),X(DTIM) BERECHNEN
C

        VX2=VPARX + VSENK*(X1N*CZ+X2N*SZ)
        VY2=VPARY + VSENK*(Y1N*CZ+Y2N*SZ)
        VZ2=VPARZ + VSENK*(Z1N*CZ+Z2N*SZ)

C
C X(DTIM) BERECHNEN
C

        VSENKZYK=VSENK/ZYK

        X2=X1+VSENKZYK*(X2N+X1N*SZ-X2N*CZ)+VPARX*DTIM
        Y2=Y1+VSENKZYK*(Y2N+Y1N*SZ-Y2N*CZ)+VPARY*DTIM
        Z2=Z1+VSENKZYK*(Z2N+Z1N*SZ-Z2N*CZ)+VPARZ*DTIM

        emom=emassg1*dsqrt((gamma-1.0d0)*(gamma+1.0d0)) !GeV
        brho=emom*1.0d9/clight1

        if (ieneloss.ne.0) then
          dgamma=-pdum*bsq*vsenk2/v0sq*gamma**2*dtim
          if (ieneloss.eq.-1) then
c            v12n(1)=(vx1+vx2)/2.0d0/v0
c            v12n(2)=(vy1+vy2)/2.0d0/v0
c            v12n(3)=(vz1+vz2)/2.0d0/v0
            v12n(1)=vx2/v0
            v12n(2)=vy2/v0
            v12n(3)=vz2/v0
            call photon(x2+xin,y2+yin,z2+zin,
     &        v12n,gamma,bx2,by2,bz2,dgamma,dtim,-1) !dgamma will be overwritten
            if (dgamma.ne.0.0d0) then
c              dgamma=0.0d0
c              dpphoton=0.0d0
              pel=emom*v12n+dpphoton
              dgamma=
     &          sqrt(1.0d0+(pel(1)**2+pel(2)**2+pel(3)**2)/emassg1**2)-
     &          gamma
c              emom=emassg1*dsqrt((gamma+dgamma-1.0d0)*(gamma+dgamma+1.0d0)) !GeV
              emom=sqrt(pel(1)**2+pel(2)**2+pel(3)**2)
              vx2=pel(1)/((gamma+dgamma)*emassg1)*clight1
              vy2=pel(2)/((gamma+dgamma)*emassg1)*clight1
              vz2=pel(3)/((gamma+dgamma)*emassg1)*clight1
            endif !dgamma
          endif !ieneloss .eq. -1
        endif !ieneloss
+self,if=b0329.
c20180392{

        IF(abs(vy1/vx1).gt.1.0d-9
     &      .or.gamma.gt.1.0d10 !20180427
     &      ) THEN
          dy=(clight1*dtim)**2*abs(by2)/brho
          if (y2.eq.0.0d0.and.y1.eq.0.0d0
     &        .or. dy/abs(y1+y2).lt.1.0d-9
     &        .or.gamma.gt.1.0d10 !20180427
     &        ) then
            y2=y1+Vy1*DTIM
            yp=vy1/vx1+bz2/brho*(dtim*clight1)
            vy2=yp*vx2
            vyp=(vy2-vy1)/dtim
          ENDIF
        ENDIF

        IF(abs(vz1/vx1).gt.1.0d-9
     &      .or.gamma.gt.1.0d10 !20180427
     &      ) THEN
          dz=(clight1*dtim)**2*abs(by2)/brho
          if (z2.eq.0.0d0.and.z1.eq.0.0d0
     &        .or. dz/abs(z1+z2).lt.1.0d-9
     &        .or.gamma.gt.1.0d10 !20180427
     &        ) then
c        if (z2.eq.0.0d0.and.z1.eq.0.0d0
c     &      .or.
c     &      abs((z2-z1)/(z2+z1)).lt.1.0d0-8
c     &      ) then
            Z2=Z1+VZ1*DTIM
            zp=vz1/vx1-by2/brho*(dtim*clight1)
            vz2=zp*vx2
            vzp=(vz2-vz1)/dtim
          ENDIF
        ENDIF
c20180392}
+self.,if=b0329.

      ENDIF   !(VSENK.LT.0.0)

+self,if=b091818.

      acc=icharge*echarge1/(gamma*emasskg1)

      dk=(clight1*dtim)**2/brho
      dy=abs(bz2)*dk
      y12=abs(y1+y2)
      icorry=0
      if (y12.eq.0.0d0) y12=1.0d0
      if (y2.eq.0.0d0.and.y1.eq.0.0d0
     &    .or. dy/y12.lt.1.0d-9
     &    .or.gamma.gt.1.0d10
     &    ) then
        y2=y1+vy1*dtim
        icorry=1
      endif

      dz=abs(by2)*dk
      z12=abs(z1+z2)
      icorrz=0
      if (z12.eq.0.0d0) z12=1.0d0
      if (z2.eq.0.0d0.and.z1.eq.0.0d0
     &    .or. dz/z12.lt.1.0d-9
     &    .or.gamma.gt.1.0d10
     &    ) then
        z2=z1+vz1*dtim
        icorrz=1
      endif

      if (icorry.eq.1.and.icorrz.eq.1) then
        x2=x1+vx1*dtim
      endif

+self.,if=b091818.

cccccccccccccccccccccccccccccccccccccccccc

      acc=icharge*echarge1/(gamma*emasskg1)
cerror 4.7.2018, due to error above, now here
      vx12=(vx1+vx2)/2.0d0
      vy12=(vy1+vy2)/2.0d0
      vz12=(vz1+vz2)/2.0d0

      vxp=acc*(vy12*bzin-vz12*byin)
      vyp=acc*(vz12*bxin-vx12*bzin)
      vzp=acc*(vx12*byin-vy12*bxin)

      if (isbig.eq.0) then

        dk=(clight1*dtim)**2/brho

        dy=abs(bz2*dk)
        y12=abs(y1-y2)
        icorry=0
        if (dy.ge.2.0d0*y12
     &      .or.gamma.gt.1.0d10
     &      ) then
          y2=y1+vy12*dtim
          icorry=1
        endif

        dz=abs(by2*dk)
        z12=abs(z1-z2)
        icorrz=0
        if (dz.ge.2.0d0*z12
     &      .or.gamma.gt.1.0d10
     &      ) then
          z2=z1+vz12*dtim
          icorrz=1
        endif

        if (icorry.eq.1.and.icorrz.eq.1) then
          x2=x1+vx1*dtim
        endif

      endif !(isbig.eq.0) then

cccccccccccccccccccccccccccccccccccccccccc

999   CONTINUE

      IF (kefield.NE.0) THEN
        dgammao=dgamma
        CALL estep(X2,Y2,Z2,VX2,VY2,VZ2,DTIM,gamma,dgamma)
        dgamma=dgammao+dgamma
        VXP=(VX2-VX1)/DTIM
        VYP=(VY2-VY1)/DTIM
        VZP=(VZ2-VZ1)/DTIM
      ENDIF

      gammaustep=gamma
      dgammaustep=dgamma
      bxustep=bx2
      byustep=by2
      bzustep=bz2
      IF (IUSTEP.NE.0) THEN
        dgammao=dgamma
        CALL USTEP(X2,Y2,Z2,VX2,VY2,VZ2,vxp,vyp,vzp,DTIM,gamma,dgamma)
        dgamma=dgammao+dgamma
      ENDIF

      !31.10.2018

      x2=x2+xin
      y2=y2+yin
      z2=z2+zin

      RETURN
      End
+DECK,BMPOT3D.
*CMZ :  2.44/01 18/09/2013  12.33.23  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.02.52  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  22.20.23  by  Michael Scheer
*CMZ :  1.00/00 24/07/97  16.38.25  by  Michael Scheer
*CMZ : 00.02/00 21/11/96  14.40.10  by  Michael Scheer
*CMZ :  1.00/03 27/09/95  17.15.24  by  Michael Scheer
*CMZ :  1.00/01 25/09/95  18.20.26  by  Michael Scheer
*CMZ :  1.00/00 21/09/95  17.13.57  by  Michael Scheer
*-- Author :    Michael Scheer   21/09/95
      SUBROUTINE BMPOT3D(NPOI,X,Y,Z,BX,BY,BZ,IFAIL,COMMENT)
+seq,gplhint.

+SEQ,BMPOT3DU.

C---  TO FIT 3D POTENTIAL V=SUM( CG(I,J,K) * X**(I-1) * Y**(J-1) * Z**(K-1))
C     OF A MAGNETIC FIELD B=(BX,BY,BZ)=-GRAD(V)
C

C--- INPUT:

C     NPOI  : NUMBER OF DATA POINTS X,Y,Z,BX,BY,BZ

C--- OUTPUT:

C     IFAIL : FAILURE FLAG
C     COMMENT : COMMENT ON COEF-FILE (SR BMPOT3DINIT)

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,BPOLY3DG.

      INTEGER NPOI,IFAIL,I,LUN,MTOT,MFIT

      DOUBLE PRECISION X(NPOI),Y(NPOI),Z(NPOI),BX(NPOI),BY(NPOI),BZ(NPOI)

      INTEGER NSTAKP
      PARAMETER (NSTAKP=4)

      CHARACTER(60) COMMENT,FILE

      INTEGER ICAL,NCOEF,ICOEF,IX,IY,IZ,IS,NS
     &         ,JX,JY,JZ


      DATA ICAL/0/
      DATA LUN/99/
      DATA FILE/'BMESS.COEF'/

      IF (ICAL.EQ.0) THEN

         ALLOCATE(ICG(NDIMCG,NDIMCG,NDIMCG))
         ALLOCATE(XPOW(NDIMCIPG))
         ALLOCATE(YPOW(NDIMCIPG))
         ALLOCATE(ZPOW(NDIMCIPG))
         ALLOCATE(VC(NDIMCIPG))
         ALLOCATE(A(NDIMCIPG,NDIMCIPG))
         ALLOCATE(WA(NDIMCIPG,NDIMCIPG))
         ALLOCATE(B(NDIMCIPG))
         ALLOCATE(WS(2*NDIMCIPG))
         ALLOCATE(WB(NDIMCIPG))
         ALLOCATE(INDEX(4,NDIMCIPG))
         ALLOCATE(FSTAK(4,NSTAKP,NDIMCIPG))

         MTOT=(MORD3DG*(MORD3DG+1)*(2*MORD3DG+1)/6
     &              +MORD3DG*(MORD3DG+1)*3/2+2*MORD3DG)/2

         MFIT=(MORD3DG+1)**2-1

      IF (MTOT.GT.NDIMCIPG) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'ERROR IN BMPOT3D: DIMENSION NDIMCIPG EXCEEDED ***'
          WRITE(LUNGFO,*)'CHECK INPUT OR BMPOLY3D.CMN'
          WRITE(6,*)
          WRITE(6,*)'ERROR IN BMPOT3D: DIMENSION NDIMPCIPG EXCEEDED ***'
          WRITE(6,*)'CHECK INPUT OR BMPOLY3D.CMN'
          WRITE(6,*)
          STOP
      ENDIF

      IF (MFIT.GT.NDIMCIPG) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'ERROR IN BMPOT3D: DIMENSION NDIMCIPG EXCEEDED ***'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'ERROR IN BMPOT3D: DIMENSION NDIMCIPG EXCEEDED ***'
          WRITE(6,*)
          STOP
      ENDIF

          CALL BMPOT3DINIT(NDIMCIPG,LORD3DG,MORD3DG,NDORD3DG,
     &                       INDEX,NCOEF
     &                      ,NSTAKP,FSTAK,LUN,FILE,COMMENT)

      ENDIF !ICAL

      DO IZ=1,NDIMCG
      DO IY=1,NDIMCG
      DO IX=1,NDIMCG
          CG(IX,IY,IZ)=0.D0
          ICG(IX,IY,IZ)=0
      ENDDO
      ENDDO
      ENDDO

      CALL BMPOT3DFIT(NPOI,X,Y,Z,BX,BY,BZ,NDIMCIPG,NCOEF,MORD3DG
     &                       ,INDEX,VC,NSTAKP,FSTAK,A,B,WS,WA,WB
     &                       ,XPOW,YPOW,ZPOW,IFAIL)

C--- GET FITTED COEFFICIENTS

      DO ICOEF=1,NCOEF
          IX=INDEX(1,ICOEF)
          IY=INDEX(2,ICOEF)
          IZ=INDEX(3,ICOEF)
          CG(IX+1,IY+1,IZ+1)=VC(ICOEF)
          ICG(IX+1,IY+1,IZ+1)=1
      ENDDO

C--- CALCULATE OTHER COEFFICIENTS

      DO ICOEF=1,NCOEF
            NS=INDEX(4,ICOEF)
          IF (NS.GT.1) THEN
             IX=INDEX(1,ICOEF)
             IY=INDEX(2,ICOEF)
             IZ=INDEX(3,ICOEF)
             DO IS=1,NS
            JX=NINT(FSTAK(1,IS,ICOEF))
            JY=NINT(FSTAK(2,IS,ICOEF))
            JZ=NINT(FSTAK(3,IS,ICOEF))
            IF (IX.NE.JX.OR.IY.NE.JY.OR.IZ.NE.JZ) THEN
            IF (IX+1.GT.NDIMCG.OR.IY+1.GT.NDIMCG.OR.IZ+1.GT.NDIMCG) THEN
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'ERROR IN BMPOT3D: DIMENSION NDIMCG EXCEEDED ***'
                WRITE(LUNGFO,*)
                WRITE(6,*)
                WRITE(6,*)'ERROR IN BMPOT3D: DIMENSION NDIMCG EXCEEDED ***'
                WRITE(6,*)
                STOP
            ENDIF
            ICG(JX+1,JY+1,JZ+1)=2
            CG(JX+1,JY+1,JZ+1)=CG(JX+1,JY+1,JZ+1)
     &         +FSTAK(4,IS,ICOEF)*CG(IX+1,IY+1,IZ+1)
                 ENDIF
             ENDDO   !IS
         ENDIF
      ENDDO

      IF (ICAL.EQ.0) THEN

         NCINDG=0
              DO IZ=1,NDIMCG
              DO IY=1,NDIMCG
              DO IX=1,NDIMCG
                  IF (ICG(IX,IY,IZ).NE.0) THEN
            NCINDG=NCINDG+1
            ICINDG(1,NCINDG)=IX
            ICINDG(2,NCINDG)=IY
            ICINDG(3,NCINDG)=IZ
             ENDIF
              ENDDO
              ENDDO
              ENDDO

         WRITE(LUNGFO,*)'     SR BMPOT3D:'
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'     NUMBER OF FITTED COEFFICIENTS:    ',NCOEF
         WRITE(LUNGFO,*)'     TOTAL NUMBER OF COEFFICIENTS:',NCINDG
         WRITE(LUNGFO,*)

         IF (NCINDG.NE.MTOT.OR.NCOEF.NE.MFIT) THEN
             WRITE (6,*)
     &              '*** ERROR IN BMPOT3D: WRONG NUMBER OF COEFFICIENTS'
             WRITE (6,*)
     &              '*** ERROR IN BMPOT3D: CHECK FILE BMESS.COEF'
             WRITE (LUNGFO,*)
     &              '*** ERROR IN BMPOT3D: WRONG NUMBER OF COEFFICIENTS'
             WRITE (LUNGFO,*)
     &              '*** ERROR IN BMPOT3D: CHECK FILE BMESS.COEF'
             STOP
         ENDIF


         ICAL=1

      ENDIF !ICAL

      DO I=1,NCINDG
          CINDG(I)=CG(ICINDG(1,I),ICINDG(2,I),ICINDG(3,I))
      ENDDO

      RETURN
      END
+DECK,BMPOT3D4.
*CMZ :  2.45/03 18/09/2013  12.33.23  by  Michael Scheer
*CMZ :  2.44/01 05/12/2002  18.10.01  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.02.52  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  22.20.23  by  Michael Scheer
*CMZ :  1.00/00 24/07/97  16.38.25  by  Michael Scheer
*CMZ : 00.02/00 21/11/96  14.40.10  by  Michael Scheer
*CMZ :  1.00/03 27/09/95  17.15.24  by  Michael Scheer
*CMZ :  1.00/01 25/09/95  18.20.26  by  Michael Scheer
*CMZ :  1.00/00 21/09/95  17.13.57  by  Michael Scheer
*-- Author :    Michael Scheer   21/09/95
      SUBROUTINE BMPOT3D4(NPOI,X,Y,Z,BX,BY,BZ,IFAIL,COMMENT)

+seq,gplhint.
+SEQ,BMPOT3DU.

C---  TO FIT 3D POTENTIAL V=SUM( CG(I,J,K) * X**(I-1) * Y**(J-1) * Z**(K-1))
C     OF A MAGNETIC FIELD B=(BX,BY,BZ)=-GRAD(V)
C

C--- INPUT:

C     NPOI  : NUMBER OF DATA POINTS X,Y,Z,BX,BY,BZ

C--- OUTPUT:

C     IFAIL : FAILURE FLAG
C     COMMENT : COMMENT ON COEF-FILE (SR BMPOT3DINIT)

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,BPOLY3DG.

      INTEGER NPOI,IFAIL,I,LUN,MTOT,MFIT

      DOUBLE PRECISION X(NPOI),Y(NPOI),Z(NPOI),BX(NPOI),BY(NPOI),BZ(NPOI)

      INTEGER NSTAKP
      PARAMETER (NSTAKP=4)

      CHARACTER(60) COMMENT,FILE

      INTEGER ICAL,NCOEF,ICOEF,IX,IY,IZ,IS,NS
     &         ,JX,JY,JZ


      DATA ICAL/0/
      DATA LUN/99/
      DATA FILE/'BMESS.COEF'/

      IF (ICAL.EQ.0) THEN

         ALLOCATE(ICG(NDIMCG,NDIMCG,NDIMCG))
         ALLOCATE(XPOW(NDIMCIPG))
         ALLOCATE(YPOW(NDIMCIPG))
         ALLOCATE(ZPOW(NDIMCIPG))
         ALLOCATE(VC(NDIMCIPG))
         ALLOCATE(A(NDIMCIPG,NDIMCIPG))
         ALLOCATE(WA(NDIMCIPG,NDIMCIPG))
         ALLOCATE(B(NDIMCIPG))
         ALLOCATE(WS(2*NDIMCIPG))
         ALLOCATE(WB(NDIMCIPG))
         ALLOCATE(INDEX(4,NDIMCIPG))
         ALLOCATE(FSTAK(4,NSTAKP,NDIMCIPG))

         MTOT=(MORD3DG*(MORD3DG+1)*(2*MORD3DG+1)/6
     &              +MORD3DG*(MORD3DG+1)*3/2+2*MORD3DG)/2

         MFIT=(MORD3DG+1)**2-1

      IF (MTOT.GT.NDIMCIPG) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'ERROR IN BMPOT3D4: DIMENSION NDIMCIPG EXCEEDED ***'
          WRITE(LUNGFO,*)'CHECK INPUT OR BMPOLY3D.CMN'
          WRITE(6,*)
          WRITE(6,*)'ERROR IN BMPOT3D4: DIMENSION NDIMPCIPG EXCEEDED ***'
          WRITE(6,*)'CHECK INPUT OR BMPOLY3D.CMN'
          WRITE(6,*)
          STOP
      ENDIF

      IF (MFIT.GT.NDIMCIPG) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'ERROR IN BMPOT3D4: DIMENSION NDIMCIPG EXCEEDED ***'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'ERROR IN BMPOT3D4: DIMENSION NDIMCIPG EXCEEDED ***'
          WRITE(6,*)
          STOP
      ENDIF

          CALL BMPOT3DINIT(NDIMCIPG,LORD3DG,MORD3DG,NDORD3DG,
     &                       INDEX,NCOEF
     &                      ,NSTAKP,FSTAK,LUN,FILE,COMMENT)

      ENDIF !ICAL

      DO IZ=1,NDIMCG
      DO IY=1,NDIMCG
      DO IX=1,NDIMCG
          CG(IX,IY,IZ)=0.D0
          ICG(IX,IY,IZ)=0
      ENDDO
      ENDDO
      ENDDO

      CALL BMPOT3DFIT(NPOI,X,Y,Z,BX,BY,BZ,NDIMCIPG,NCOEF,MORD3DG
     &                       ,INDEX,VC,NSTAKP,FSTAK,A,B,WS,WA,WB
     &                       ,XPOW,YPOW,ZPOW,IFAIL)

C--- GET FITTED COEFFICIENTS

      DO ICOEF=1,NCOEF
          IX=INDEX(1,ICOEF)
          IY=INDEX(2,ICOEF)
          IZ=INDEX(3,ICOEF)
          CG(IX+1,IY+1,IZ+1)=VC(ICOEF)
          ICG(IX+1,IY+1,IZ+1)=1
      ENDDO

C--- CALCULATE OTHER COEFFICIENTS

      DO ICOEF=1,NCOEF
            NS=INDEX(4,ICOEF)
          IF (NS.GT.1) THEN
             IX=INDEX(1,ICOEF)
             IY=INDEX(2,ICOEF)
             IZ=INDEX(3,ICOEF)
             DO IS=1,NS
            JX=NINT(FSTAK(1,IS,ICOEF))
            JY=NINT(FSTAK(2,IS,ICOEF))
            JZ=NINT(FSTAK(3,IS,ICOEF))
            IF (IX.NE.JX.OR.IY.NE.JY.OR.IZ.NE.JZ) THEN
            IF (IX+1.GT.NDIMCG.OR.IY+1.GT.NDIMCG.OR.IZ+1.GT.NDIMCG) THEN
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'ERROR IN BMPOT3D4: DIMENSION NDIMCG EXCEEDED ***'
                WRITE(LUNGFO,*)
                WRITE(6,*)
                WRITE(6,*)'ERROR IN BMPOT3D4: DIMENSION NDIMCG EXCEEDED ***'
                WRITE(6,*)
                STOP
            ENDIF
            ICG(JX+1,JY+1,JZ+1)=2
            CG(JX+1,JY+1,JZ+1)=CG(JX+1,JY+1,JZ+1)
     &         +FSTAK(4,IS,ICOEF)*CG(IX+1,IY+1,IZ+1)
                 ENDIF
             ENDDO   !IS
         ENDIF
      ENDDO

      IF (ICAL.EQ.0) THEN

         NCINDG=0
              DO IZ=1,NDIMCG
              DO IY=1,NDIMCG
              DO IX=1,NDIMCG
                  IF (ICG(IX,IY,IZ).NE.0) THEN
            NCINDG=NCINDG+1
            ICINDG(1,NCINDG)=IX
            ICINDG(2,NCINDG)=IY
            ICINDG(3,NCINDG)=IZ
             ENDIF
              ENDDO
              ENDDO
              ENDDO

         WRITE(LUNGFO,*)'     SR BMPOT3D4:'
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'     NUMBER OF FITTED COEFFICIENTS:    ',NCOEF
         WRITE(LUNGFO,*)'     TOTAL NUMBER OF COEFFICIENTS:',NCINDG
         WRITE(LUNGFO,*)

         IF (NCINDG.NE.MTOT.OR.NCOEF.NE.MFIT) THEN
             WRITE (6,*)
     &              '*** ERROR IN BMPOT3D4: WRONG NUMBER OF COEFFICIENTS'
             WRITE (6,*)
     &              '*** ERROR IN BMPOT3D4: CHECK FILE BMESS.COEF'
             WRITE (LUNGFO,*)
     &              '*** ERROR IN BMPOT3D4: WRONG NUMBER OF COEFFICIENTS'
             WRITE (LUNGFO,*)
     &              '*** ERROR IN BMPOT3D4: CHECK FILE BMESS.COEF'
             STOP
         ENDIF


         ICAL=1

      ENDIF !ICAL

      DO I=1,NCINDG
          CINDG4(I)=CG(ICINDG(1,I),ICINDG(2,I),ICINDG(3,I))
      ENDDO

      RETURN
      END
+DECK,BMPOT3DFIT.
*CMZ :  2.13/05 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  14.58.52  by  Michael Scheer
*CMZ :  1.00/00 28/07/97  17.08.42  by  Michael Scheer
*CMZ : 00.02/00 15/11/96  13.26.33  by  Michael Scheer
*CMZ :  1.00/01 26/09/95  16.53.15  by  Michael Scheer
*CMZ :  1.00/00 21/09/95  17.14.11  by  Michael Scheer
*-- Author :    Michael Scheer   21/09/95
      SUBROUTINE BMPOT3DFIT(NPOI,X,Y,Z,BX,BY,BZ,NDIMP,N,MORD
     &                       ,INDEX,VC,NSTAKP,FSTAK,A,B,WS,WA,WB
     &                       ,XPOW,YPOW,ZPOW,IFAIL)

+seq,gplhint.
C--- FITS V=...+VC(IXYZ)*X**(INDEX(1,IXYZ))*Y**(INDEX(2,IXYZ))*Z**(INDEX(3,IXYZ)
C--- WITH (BX,BY,BZ)=-GRAD(V)

C---  INPUT:
C-    NPOI      : NUMBER OF POINTS X,F(X)
C-    NDIMP       :  DIMENSION PARAMETER OF ARRAYS A,B,WS,WA,WB,
C-    N           :  NUMBER OF COEFFICIENTS VC
C-    X,Y,Z     : ARGUMENTS OF FUNCTION F(X,Y,Z)
C-    BX,BY,BZ    :  MAGNETIC FIELD COMPONENTS
C-    MORD      :   HIGHEST ORDER OF FITTED COEFFS
C-    INDEX     :   INDEX(3,N) IS POINTER TO INDICES I,J,K
C-    NSTAKP       : STACK DIMENSION
C-    FSTAK     :   STACK OF COEFFICIENTS FSTAK(4,NSTAKP,N)

C---  OUTPUT:
C-    VC     : COEFFICIENTS VC(N) TO BE FITTED
C-    IFAIL       :  FAILURE FLAG

C---  WORKING SPACE:
C-    A  :  MATRIX OF EQUATION SYSTEM A(NDIMP,NDIMP)
C-    B  :  INHOMOGENITY OF EQUATION SYSTEM B(NDIMP)
C-    WS :  WORKING SPACE WS(2*NDIMP)
C-    WA :  WORKING SPACE WA(NDIMP,NDIMP)
C-    WB :  WORKING SPACE WB(NDIMP)
C-    XPOW  :  WORKING SPACE XPOW(N)
C-    YPOW  :  WORKING SPACE YPOW(N)
C-    ZPOW  :  WORKING SPACE ZPOW(N)

      IMPLICIT NONE

+SEQ,CONTRL.

      INTEGER NPOI,N,MORD,INDEX(4,N),IFAIL,NDIMP,NSTAKP
      INTEGER IX,IY,IZ,JX,JY,JZ,IXYZ,JXYZ,IPOI,IFIT,JFIT,NFIT,IS,NS,JS,MS

      DOUBLE PRECISION X(NPOI),Y(NPOI),Z(NPOI),BX(NPOI),BY(NPOI),BZ(NPOI)
     &                  ,VC(N)
     &                  ,A(NDIMP,NDIMP),WA(NDIMP,NDIMP)
     &                  ,B(NDIMP),WS(2*NDIMP),WB(NDIMP)
     &                  ,XPOW(MORD+1),YPOW(MORD+1),ZPOW(MORD+1)
     &                  ,FSTAK(4,NSTAKP,N)

      DOUBLE PRECISION AX1,AY1,AZ1,AX2,AY2,AZ2,XPOI,YPOI,ZPOI
     &                  ,XPOW1,YPOW1,ZPOW1
     &                  ,XPOW2,YPOW2,ZPOW2
     &         ,BSUM,X99,Y99,Z99
      IFAIL=0

      IF (N.GT.NPOI*3) THEN
          WRITE(LUNGFO,*)
     &      '*** WARNING SR BMPOT3DFIT: NOT ENOUGH DATA'
          WRITE(6,*)
     &      '*** WARNING SR BMPOT3DFIT: NOT ENOUGH DATA'
          IFAIL=999
          RETURN
      ENDIF

      DO IXYZ=1,N
          B(IXYZ)=0.D0
          VC(IXYZ)=0.D0
      ENDDO

      DO IY=1,N
      DO IX=1,N
          A(IX,IY)=0.D0
      ENDDO
      ENDDO

C- DO THE FITTING

      NFIT=N

      DO IPOI=1,NPOI

          XPOI=X(IPOI)
          YPOI=Y(IPOI)
          ZPOI=Z(IPOI)

          XPOW(1)=1.D0
          DO IX=2,MORD+1
          XPOW(IX)=XPOW(IX-1)*XPOI
        ENDDO

          YPOW(1)=1.D0
          DO IY=2,MORD+1
          YPOW(IY)=YPOW(IY-1)*YPOI
        ENDDO

          ZPOW(1)=1.D0
          DO IZ=2,MORD+1
          ZPOW(IZ)=ZPOW(IZ-1)*ZPOI
        ENDDO

        IF (BX(IPOI).EQ.-9999.) THEN
          X99=0.0D0
        ELSE
          X99=1.0D0
        ENDIF

        IF (BY(IPOI).EQ.-9999.) THEN
          Y99=0.0D0
        ELSE
          Y99=1.0D0
        ENDIF

        IF (BZ(IPOI).EQ.-9999.) THEN
          Z99=0.0D0
        ELSE
          Z99=1.0D0
        ENDIF


      IFIT=0
      DO IXYZ=1,NFIT

         IFIT=IFIT+1

           NS=INDEX(4,IXYZ)

           BSUM=0.D0
           AX1=0.D0
           AY1=0.D0
           AZ1=0.D0
           DO IS=1,NS

            IX=NINT(FSTAK(1,IS,IXYZ))+1
            IY=NINT(FSTAK(2,IS,IXYZ))+1
            IZ=NINT(FSTAK(3,IS,IXYZ))+1

                      IF(IX.GT.1) THEN
                         XPOW1=XPOW(IX-1)
            ELSE
                         XPOW1=1.D0
                      ENDIF

                      IF(IY.GT.1) THEN
                         YPOW1=YPOW(IY-1)
            ELSE
                         YPOW1=1.D0
                      ENDIF

                      IF(IZ.GT.1) THEN
                         ZPOW1=ZPOW(IZ-1)
            ELSE
                         ZPOW1=1.D0
                      ENDIF

            BSUM=BSUM+FSTAK(4,IS,IXYZ)*(
     &                  -(IX-1)*BX(IPOI)*XPOW1*YPOW(IY)*ZPOW(IZ)*X99
     &         -(IY-1)*BY(IPOI)*YPOW1*XPOW(IX)*ZPOW(IZ)*Y99
     &              -(IZ-1)*BZ(IPOI)*ZPOW1*XPOW(IX)*YPOW(IY)*Z99
     &                  )

                  AX1=AX1
     &                     +X99*FSTAK(4,IS,IXYZ)*(IX-1)*XPOW1*YPOW(IY)*ZPOW(IZ)
                      AY1=AY1
     &                     +Y99*FSTAK(4,IS,IXYZ)*(IY-1)*YPOW1*XPOW(IX)*ZPOW(IZ)
            AZ1=AZ1
     &                      +Z99*FSTAK(4,IS,IXYZ)*(IZ-1)*ZPOW1*XPOW(IX)*YPOW(IY)

         ENDDO !NS

                      B(IFIT)=B(IFIT)+BSUM

      JFIT=0
      DO JXYZ=1,NFIT

         JFIT=JFIT+1

           MS=INDEX(4,JXYZ)

           AX2=0.D0
           AY2=0.D0
           AZ2=0.D0
           DO JS=1,MS

            JX=NINT(FSTAK(1,JS,JXYZ))+1
            JY=NINT(FSTAK(2,JS,JXYZ))+1
            JZ=NINT(FSTAK(3,JS,JXYZ))+1

                      IF(JX.GT.1) THEN
                         XPOW2=XPOW(JX-1)
            ELSE
                         XPOW2=1.D0
                      ENDIF

                      IF(JY.GT.1) THEN
                         YPOW2=YPOW(JY-1)
            ELSE
                         YPOW2=1.D0
                      ENDIF

                      IF(JZ.GT.1) THEN
                         ZPOW2=ZPOW(JZ-1)
            ELSE
                         ZPOW2=1.D0
                      ENDIF

                  AX2=AX2
     &                     +X99*FSTAK(4,JS,JXYZ)*(JX-1)*XPOW2*YPOW(JY)*ZPOW(JZ)
                      AY2=AY2
     &                     +Y99*FSTAK(4,JS,JXYZ)*(JY-1)*YPOW2*XPOW(JX)*ZPOW(JZ)
            AZ2=AZ2
     &                      +Z99*FSTAK(4,JS,JXYZ)*(JZ-1)*ZPOW2*XPOW(JX)*YPOW(JY)

         ENDDO !NS

         A(IFIT,JFIT)=A(IFIT,JFIT)+AX1*AX2+AY1*AY2+AZ1*AZ2

      ENDDO !JXYZ
      ENDDO !IXYZ

      ENDDO !IPOI

      DO IXYZ=1,NFIT
         WB(IXYZ)=B(IXYZ)
      ENDDO

      DO IY=1,NFIT
      DO IX=1,NFIT
              WA(IX,IY)=A(IX,IY)
      ENDDO
      ENDDO

      DO IXYZ=1,NFIT
         WB(IXYZ)=B(IXYZ)
      ENDDO

      DO IY=1,NFIT
      DO IX=1,NFIT
              WA(IX,IY)=A(IX,IY)
      ENDDO
      ENDDO

        CALL DEQN(NFIT,WA,NDIMP,WS,IFAIL,1,WB) !CERN F010

      DO IFIT=1,NFIT
         VC(IFIT)=WB(IFIT)
      ENDDO

      RETURN
      END
+DECK,BMPOT3DINIT.
*CMZ :  2.41/10 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ : 00.02/00 14/11/96  17.55.17  by  Michael Scheer
*CMZ : 00.01/09 05/10/95  16.34.35  by  Michael Scheer
*CMZ :  1.00/01 25/09/95  14.26.06  by  Michael Scheer
*CMZ :  1.00/00 21/09/95  17.14.08  by  Michael Scheer
*-- Author :    Michael Scheer   21/09/95
      SUBROUTINE BMPOT3DINIT(NDIMP,LORD,MORD,NDORD,INDEX,NCOEF,NSTAKP,FSTAK
     &                        ,LUNCOEFF,FILECOEFF,COMMENT)

      IMPLICIT NONE

+seq,gplhint.
+SEQ,CONTRL.

      CHARACTER(60) FILECOEFF,COMMENT

      INTEGER NDIMP,INDEX(4,NDIMP),NSTAKP,NCOEF
     &         ,LUNCOEFF,IORD,LORD,MORD,NDORD

      INTEGER IX,IY,IZ,IS,NS,IR,IXYZ,IFOUND

      DOUBLE PRECISION FSTAK(4,NSTAKP,NDIMP)

      NCOEF=0
      OPEN(UNIT=LUNCOEFF,FILE=FILECOEFF,STATUS='OLD')

          READ(LUNCOEFF,'(A60)')COMMENT
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     SR BMPOT3DINIT:'
          WRITE(LUNGFO,*)'     comment on COEF-FILE:'
          WRITE(LUNGFO,*)'     ',COMMENT
          WRITE(LUNGFO,*)
100       READ(LUNCOEFF,*,END=900) IX,IY,IZ,NS

          DO IORD=LORD,MORD,NDORD
         IF(IX+IY+IZ.EQ.IORD) GOTO 50
          ENDDO
          GOTO 100

50        NCOEF=NCOEF+1

          IF (NCOEF.GT.NDIMP) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &   '*** ERROR IN BMPOT3DINIT: DIMENSION NDIMP EXCEEDED ***'
             WRITE(LUNGFO,*)
             WRITE(6,*)
             WRITE(6,*)
     &   '*** ERROR IN BMPOT3DINIT: DIMENSION NDIMP EXCEEDED ***'
             WRITE(6,*)
             STOP
          ENDIF

          IF (NS.GT.NSTAKP) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &   '*** ERROR IN BMPOT3DINIT: DIMENSION NSTAKP EXCEEDED ***'
             WRITE(LUNGFO,*)
             WRITE(6,*)
             WRITE(6,*)
     &   '*** ERROR IN BMPOT3DINIT: DIMENSION NSTAKP EXCEEDED ***'
             WRITE(6,*)
             STOP
          ENDIF

          INDEX(1,NCOEF)=IX
          INDEX(2,NCOEF)=IY
          INDEX(3,NCOEF)=IZ

          IF (NS.GT.0) THEN
         INDEX(4,NCOEF)=NS
         DO IS=1,NS
             READ(LUNCOEFF,*)(FSTAK(IR,IS,NCOEF),IR=1,4)
         ENDDO
          ELSE
         INDEX(4,NCOEF)=1
         FSTAK(1,1,NCOEF)=IX
         FSTAK(2,1,NCOEF)=IY
         FSTAK(3,1,NCOEF)=IZ
         FSTAK(4,1,NCOEF)=1.D0
          ENDIF   !IS

      GOTO 100

900   CLOSE(LUNCOEFF)


      DO IORD=LORD,MORD,NDORD
      IFOUND=0
      DO IXYZ=1,NCOEF
         IX=INDEX(1,IXYZ)
         IY=INDEX(2,IXYZ)
         IZ=INDEX(3,IXYZ)
         IF (IX+IY+IZ.EQ.IORD) IFOUND=1
      ENDDO
      IF (IFOUND.EQ.0) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)
     &'*** WARNING SR BMPOT3DINIT: NO COEFFICIENTS FOUND FOR INQUIRED ORDER ***'
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'ORDER :',IORD
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)
     &'*** WARNING SR BMPOT3DINIT: NO COEFFICIENTS FOUND FOR INQUIRED ORDER ***'
         WRITE(6,*)
         WRITE(6,*)'ORDER :',IORD
         WRITE(6,*)
      ENDIF
      ENDDO

      RETURN
      END
+DECK,BPAND.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  14.43.03  by  Michael Scheer
*CMZ : 00.02/03 23/01/97  16.27.48  by  Michael Scheer
*CMZ : 00.01/02 24/11/94  15.55.05  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  18.02.03  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.05  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BPAND(DOUX,DOUY,DOUZ,DOBX,DOBY,DOBZ)

+seq,gplhint.
      DOUBLE PRECISION DOUX,DOUY,DOUZ,DOBX,DOBY,DOBZ

      DOUX=1.*DOUX
      DOUY=1.*DOUY
      DOUZ=1.*DOUZ
      DOBX=0.
      DOBY=0.
      DOBZ=0.

C     BPAND BERECHNET B-FELD AUS PANDIRA-DATEN

      WRITE(6,*)'*** ERROR IN BPAND: OBSOLETE ROUTINE; SEE OLD VERSION ***'
      STOP

      END
+DECK,BPANDOLD.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  14.43.03  by  Michael Scheer
*CMZ : 00.02/03 23/01/97  16.28.45  by  Michael Scheer
*CMZ : 00.01/02 24/11/94  15.55.05  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  18.02.03  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.05  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BPANDOLD(DOUX,DOUY,DOUZ,DOBX,DOBY,DOBZ)

+seq,gplhint.
      DOUBLE PRECISION DOUX,DOUY,DOUZ,DOBX,DOBY,DOBZ

      DOUX=1.*DOUX
      DOUY=1.*DOUY
      DOUZ=1.*DOUZ
      DOBX=0.
      DOBY=0.
      DOBZ=0.

C     BPANDOLD BERECHNET B-FELD AUS PANDIRA-DATEN

      WRITE(6,*)'*** ERROR IN BPANDOLD: OBSOLETE ROUTINE; SEE OLD VERSION ***'
      STOP

      END
+DECK,bpen.
*CMZ :  0.00/06 16/02/2004  17.22.39  by  Michael Scheer
*CMZ :  0.00/05 23/12/2003  11.36.18  by  Michael Scheer
*CMZ :  0.00/04 19/12/2003  18.17.16  by  Michael Scheer
*CMZ :  0.00/02 12/12/2003  10.40.20  by  Michael Scheer
*CMZ :  0.00/01 08/12/2003  10.56.22  by  Michael Scheer
*-- Author :    Michael Scheer   04/12/2003
      subroutine bpen(imag,iplan,p1,p2,p3,vn)
c      subroutine bpen(vmag,p1,p2,p3,vn,idreh)

+seq,gplhint.
      double precision p1(3),p2(3),p3(3),vn(3),d2(3),d3(3),vnn
      integer imag,iplan
c      integer idreh,vmag(3)

c vmag is point inside magnet
c for the time being (23.12.2003), normal vector is calculated from direction
c of rotation


      d2(1)=p2(1)-p1(1)
      d2(2)=p2(2)-p1(2)
      d2(3)=p2(3)-p1(3)

      d3(1)=p3(1)-p1(1)
      d3(2)=p3(2)-p1(2)
      d3(3)=p3(3)-p1(3)

c vn= d2 x d3

      vn(1)=d2(2)*d3(3)-d2(3)*d3(2)
      vn(2)=d2(3)*d3(1)-d2(1)*d3(3)
      vn(3)=d2(1)*d3(2)-d2(2)*d3(1)

c      d2(1)=p1(1)-vmag(1)
c      d2(2)=p1(2)-vmag(2)
c      d2(3)=p1(3)-vmag(3)
c      vnn=vn(1)*d2(1)+vn(2)*d2(2)+vn(3)*d2(3)

        vnn=sqrt(vn(1)*vn(1)+vn(2)*vn(2)+vn(3)*vn(3))

c      if (vnn.lt.0.d0) THEN
c        vnn=-sqrt(vn(1)*vn(1)+vn(2)*vn(2)+vn(3)*vn(3))
c        idreh=-1
c      else
c        vnn=sqrt(vn(1)*vn(1)+vn(2)*vn(2)+vn(3)*vn(3))
c        idreh=1
c      endif

c      print *
c      print *,'idreh:', idreh
c      print *

      if (vnn.ne.0.d0) then
        vn(1)=vn(1)/vnn
        vn(2)=vn(2)/vnn
        vn(3)=vn(3)/vnn
      else
        print *,'***Error in bpen: Zero normal vector'
        print *,'magnet, plane:', imag,iplan
        stop
      endif

c      print *
c      print *,'vn:', vn(1),vn(2),vn(3)
c      print *

      return
      end
+DECK,bpeq.
*CMZ :  2.67/00 16/02/2012  13.16.00  by  Michael Scheer
*CMZ :  2.53/05 24/02/2005  14.03.18  by  Michael Scheer
*CMZ :  0.99/07 16/02/2004  17.22.16  by  Michael Scheer
*CMZ :  0.99/03 12/02/2004  10.50.28  by  Michael Scheer
*CMZ :  0.99/02 12/02/2004  10.20.35  by  Michael Scheer
*CMZ :  0.99/01 11/02/2004  13.54.20  by  Michael Scheer
*CMZ :  0.99/00 29/01/2004  14.14.29  by  Michael Scheer
*CMZ :  0.00/08 23/01/2004  15.31.25  by  Michael Scheer
*CMZ :  0.00/06 14/01/2004  16.32.20  by  Michael Scheer
*CMZ :  0.00/05 23/12/2003  16.08.27  by  Michael Scheer
*CMZ :  0.00/04 19/12/2003  18.32.08  by  Michael Scheer
*-- Author :    Michael Scheer   19/12/2003
      subroutine bpeq(x1,x2,a,b,zin,qx,qy,qz,tiny,
+seq,gplhint.
+self,if=verbose,debug.
     &  imag,iplan,icorn,
+self.
     &  reverse,iwarn)

      implicit none

      double precision x1,x2,a,b,zin,z,tiny,twopi,pi,f1,f2,dum1,dum2
      double precision qx,qy,qz,xi1,xi2,abz2,a2z2b2,
     &  are1,aim1,are2,aim2,arei1,aimi1,arei2,aimi2,dphi,dphi1,dphi2,phi1,phi2,
     &  sdum,dum,xpi(5),reverse,x1r,x2r,y1,y2,a21,ab,z2,a2,b2,az,a2z2,
     &  arem,aimm,arep,aimp,phim,phip,xm1,xp1,xm2,xp2

      double precision ra21,rho1,rho2,x2rxz,x1rxz,
     &  arg1,arg2,arg31,arg32,arg4

+self,if=debug.
      double precision dx,x,ddphi,phi
      integer istep,i
+self.
      integer iwarn
+self,if=verbose,debug.
     &  ,imag,iplan,icorn
+self.
      parameter (pi=3.1415926535897932385d0)
      parameter (twopi=6.2831853071795864769d0)
+self,if=verbose,debug.
      print *
      print *,'imag,iplan,icorn: ',imag,iplan,icorn
+self.
c      if (zin.lt.0.d0) print *,'neg. z: ',zin

      xm1=1.d30
      xp1=1.d30
      xm2=1.d30
      xp2=1.d30
      dphi1=0.d0
      dphi2=0.d0
      iwarn=0

      if (abs(zin).lt.tiny) then
+self,if=-nobpeqwarn.
        print *
        print *,'*** Warning in bpeq: Magnet boundary hit'
        print *,'z changed by ',tiny ,'mm'
        print *,'z: ',zin
        print *
+self.
        z=sign(tiny,zin)
        iwarn=1
      else
        z=zin
      endif

      if (x1.gt.x2) then
        x1r=x2
        x2r=x1
        reverse=-1.d0
      else
        x1r=x1
        x2r=x2
        reverse=1.d0
      endif

c-------------------------------------------------------------------------

      y1=a*x1+b
      y2=a*x2+b
      z2=z*z

      ab=a*b
      a2=a*a
      b2=b*b
      az=a*z
      a2z2=a2*z2
      abz2=ab*z2
      a2z2b2=a2z2+b2

      a21=1.d0+a2
      ra21=Sqrt(a21)

      rho1=Sqrt(x1**2+y1**2+z2)
      rho2=Sqrt(x2**2+y2**2+z2)

      arg1=(ab+x1*a21)/ra21+rho1
      arg2=(ab+x2*a21)/ra21+rho2

      arg31=((b*(y1+rho1)+z2)**2 + (z*(a21*x1+a*(b+rho1)))**2)/(x1**2+z**2)
      arg32=((b*(y2+rho2)+z2)**2 + (z*(a21*x2+a*(b+rho2)))**2)/(x2**2+z**2)

      if (
     &    ra21.eq.0.d0.or.arg2.eq.0.d0.or.arg32.eq.0.d0
     &    .or.sign(1.d0,arg1).ne.sign(1.d0,arg2)
     &    .or.sign(1.d0,arg31).ne.sign(1.d0,arg32)
     &   ) then
+self,if=-nobpeqwarn.
        print *,'*** Warning in BPEQ: Numerical problems while calculating Bx'
+self.
        iwarn=10
        return
      endif

      arg4=Log(arg1/arg2)/ra21

      qx=Log(arg31/arg32)/2.d0-a*arg4

c-------------------------------------------------------------------------

      x2rxz=x2+Sqrt(x2**2+z2)
      x1rxz=x1+Sqrt(x1**2+z2)

      if (x1rxz.eq.0.d0.or.sign(1.d0,x2rxz).ne.sign(1.d0,x1rxz)) then
+self,if=-nobpeqwarn.
        print *,'*** Warning in BPEQ: Numerical problems while calculating By'
+self.
        iwarn=11
        return
      endif

      qy=Log(x2rxz/x1rxz)+arg4

c-------------------------------------------------------------------------

      f1=((az+b)*(az-b))**2*a2z2b2-4.0d0*abz2**2
      f2=a21*z2+b2;

      sdum=f1*f2

      dum=(((1.0d0+3.0d0*a21)*z2+b2)*a2z2+(a2z2-b2)*b2)*b2

      if (sdum.gt.0.d0.and.dum.ne.0.d0) then

        dum1=2.0d0*sqrt(sdum)*abs(ab)*z2
        dum2=abz2*a2z2b2**2

        xi1=(+dum1-dum2)/dum
        xi2=(-dum1-dum2)/dum

      else

        xi1=-1.d30
        xi2=-1.d30

      endif

c--------------

      if (xi1.gt.xi2) then
        xpi(1)=xi1
        xi1=xi2
        xi2=xpi(1)
      else if (xi1.eq.xi2) then
        xi2=-1.d30
      endif

c On the way from x1 to x2, the atan2 may be not continuous. So we check,
c xi1, and xi2 and add +/- pi, respectivly

      if (xi1.lt.x1r.or.xi1.gt.x2r) then
        xi1=-1.d30
      endif

      if (xi2.lt.x1r.or.xi2.gt.x2r) then
        xi2=-1.d30
      endif

c----------

      if (xi1.ne.-1.d30) then

c is it real null or pi?

        xm1=xi1-tiny
        xp1=xi1+tiny

        call areim(xm1,a,b,z,arem,aimm)
        call areim(xi1,a,b,z,arei1,aimi1)
        call areim(xp1,a,b,z,arep,aimp)

        if (arem.eq.0.d0.and.aimm.eq.0.d0) then
          stop '*** Error in BPEQ: 0/0'
        endif

        if (arep.eq.0.d0.and.aimp.eq.0.d0) then
          stop '*** Error in BPEQ: 0/0'
        endif

        phim=atan2(aimm,arem)
        phip=atan2(aimp,arep)

        if (sign(1.d0,phim).eq.sign(1.d0,phip)) then
          xi1=-1.d30
        else
          dphi1=pi*nint((phim-phip)/pi)
        endif
+self,if=-nobpeqwarn.
        if (abs(arei1).lt.tiny.and.abs(aimi1).lt.tiny) then
          print*, '*** Warning in BPEQ: eps/eps'
          print*, 'arei1 / aimi1'
          print*,'Check if really null'
          print*, arei1,' / ',aimi1
        endif
+self.
        if (arei1.gt.tiny) then
          xi1=-1.d30
+self,if=-nobpeqwarn.
        else if (arei1.gt.-tiny) then
c d.h. sehr Nahe am mglichen Phasensprung
          print *,'*** Warning in BPEQ: arei1.gt.-tiny'
          print*,'close to jump'
+self.
        endif

      endif !xi1.ne.-1.d30

c--------------

      if (xi2.ne.-1.d30) then

        xm2=xi2-tiny
        xp2=xi2+tiny

        call areim(xm2,a,b,z,arem,aimm)
        call areim(xi2,a,b,z,arei2,aimi2)
        call areim(xp2,a,b,z,arep,aimp)

        if (arem.eq.0.d0.and.aimm.eq.0.d0) then
          stop '*** Error in BPEQ: 0/0'
        endif

        if (arep.eq.0.d0.and.aimp.eq.0.d0) then
          stop '*** Error in BPEQ: 0/0'
        endif

        phim=atan2(aimm,arem)
        phip=atan2(aimp,arep)

        if (sign(1.d0,phim).eq.sign(1.d0,phip)) then
          xi2=-1.d30
        else
          dphi2=pi*nint((phim-phip)/pi)
        endif

        if (arei2.eq.0.d0.and.aimi2.eq.0.d0) then
          stop '*** Error in BPEQ: 0/0'
        endif

+self,if=-nobpeqwarn.
        if (abs(arei2).lt.tiny.and.abs(aimi2).lt.tiny) then
          print*, '*** Warning in BPEQ: eps/eps'
          print*, 'arei2 / aimi2'
          print*,'Check if really null'
          print*, arei2,' / ',aimi2
        endif
+self.

        if (arei2.gt.tiny) then
          xi2=-1.d30
+self,if=-nobpeqwarn.
        else if (arei2.gt.-tiny) then
          print *,'*** Warning in BPEQ: arei2.gt.-tiny'
          print*,'close to jump'
+self.
        endif

      endif !xi2.ne.-1.d30

      call areim(x1r,a,b,z,are1,aim1)

      if (are1.eq.0.d0.and.aim1.eq.0.d0) then
+self,if=-nobpeqwarn.
        print*, '*** Warning in BPEQ while calculating Bz: 0/0'
        print *,'x1r:'
        print *,x1r
        print *,'a,b,z:'
        print *,a,b,z
+self.
        iwarn=4
        phi1=0.d0
      else
        phi1=atan2(aim1,are1)
      endif

+self,if=-nobpeqwarn.
      if (abs(are1).lt.tiny.and.abs(aim1).lt.tiny) then
        print*, '*** Warning in BPEQ: eps/eps'
        print*,'calculation of phi1'
        print*,'are1 / aim1'
        print*, are1,' / ',aim1
      endif
+self.

      call areim(x2r,a,b,z,are2,aim2)

      if (are2.eq.0.d0.and.aim2.eq.0.d0) then
+self,if=-nobpeqwarn.
        print*, '*** Warning in BPEQ while calculating Bz: 0/0'
        print *,'x2r:'
        print *,x2r
        print *,'a,b,z:'
        print *,a,b,z
+self.
        iwarn=5
        phi2=0.d0
      else
        phi2=atan2(aim2,are2)
      endif

+self,if=-nobpeqwarn.
      if (abs(are2).lt.tiny.and.abs(aim2).lt.tiny) then
        print*, '*** Warning in BPEQ: eps/eps'
        print*,'calculation of phi2'
        print*, 'are2 / aim2'
        print*, are2,' / ',aim2
      endif
+self.

      dphi=dphi1+dphi2

      if (abs(dphi).gt.twopi) then

c probably two nulls detected due to numerical problems, but actually only one

+self,if=-nobpeqwarn.
        print *,'*** Warning in BPEQ while calculating Bz: |dphi| > 2*pi'
        print *,'*** reduced by 2*pi'

        print *,'first and second null:'
        print *,'z,x1r,x2r,xi1,xi2:'
        write(6,'(5e15.5)')z,x1r,x2r,xi1,xi2

        print *,'are1,aim1,phi1:'
        write(6,'(3e15.5)')are1,aim1,phi1*180.d0/pi

        print *,'are2,aim2,phi2:'
        write(6,'(3e15.5)')are2,aim2,phi2*180.d0/pi
+self.

        if (dphi.gt.twopi) dphi=dphi-twopi
        if (dphi.lt.-twopi) dphi=dphi+twopi

        iwarn=6

      endif

      dphi=phi2-phi1+dphi

      qz=-reverse*dphi

+self,if=debug.
      print *
      call areim(x1r,a,b,z,are1,aim1)
      phi1=atan2(aim1,are1)
      istep=51
      dx=(x2r-x1r)/(istep-1)
      ddphi=0.d0
      do i=1,istep
        x=x1r+(i-1)*dx
        if (x.gt.xp1) then
          ddphi=ddphi+dphi1*180./pi
          xp1=1.d30
        endif
        if (x.gt.xp2) then
          ddphi=ddphi+dphi2*180./pi
          xp2=1.d30
        endif
        call areim(x,a,b,z,arem,aimm)
        phi=atan2(aimm,arem)*180./pi
        print *,sngl(x),
     &    sngl(phi),sngl(ddphi),sngl(phi+ddphi)
      enddo

+self.
      return
      end
+DECK,bpet.
*CMZ :  0.00/06 14/01/2004  15.36.48  by  Michael Scheer
*CMZ :  0.00/05 23/12/2003  14.17.24  by  Michael Scheer
*CMZ :  0.00/04 23/12/2003  10.12.22  by  Michael Scheer
*CMZ :  0.00/03 15/12/2003  14.19.52  by  Michael Scheer
*CMZ :  0.00/02 12/12/2003  10.32.59  by  Michael Scheer
*CMZ :  0.00/01 08/12/2003  11.19.50  by  Michael Scheer
*-- Author :    Michael Scheer   04/12/2003
      subroutine bpet(vnz,t,t1)

+seq,gplhint.
      double precision vnz(3),t(3,3),t1(3,3)
      double precision det,eps,vz1,vxyz1,vyyz1

      integer i,j
      integer ifail

      data eps/1.0d-10/

      if (abs(vnz(3)+1.0d0).lt.eps) then

        t(1,1)=-1.d0
        t(1,2)=0.d0
        t(1,3)=0.d0

        t(2,1)=0.d0
        t(2,2)=1.d0
        t(2,3)=0.d0

        t(3,1)=0.d0
        t(3,2)=0.d0
        t(3,3)=-1.d0

      else

        vz1=vnz(3)+1.d0
        vxyz1=-vnz(1)*vnz(2)/vz1
        vyyz1=vnz(2)*vnz(2)/vz1

        t(1,1)=vnz(3)+vyyz1
        t(1,2)=vxyz1
        t(1,3)=-vnz(1)

        t(2,1)=vxyz1
        t(2,2)=1.d0-vyyz1
        t(2,3)=-vnz(2)

        t(3,1)=vnz(1)
        t(3,2)=vnz(2)
        t(3,3)=vnz(3)

      endif

      do i=1,3
        do j=1,3
          t1(i,j)=t(j,i)
        enddo
      enddo

      call util_determinante(3,t,det,ifail)

      if (ifail.ne.0) then
        print *,'*** Error in bpet: Bad determinante of matrix'
        stop
      endif

      if (abs(det-1.d0).gt.1.d-10) then
        print *,'*** Error in bpet: Bad determinante of matrix'
        print *
        print *,'Matrix t'
        do i=1,3
          print *,t(i,1),t(i,2),t(i,3)
        enddo
        print *
        print *,'det: ',det
        print *
        stop
      endif

+self,if=verbose.
      print *
      print *,'Matrix t'
      do i=1,3
        print *,t(i,1),t(i,2),t(i,3)
      enddo
      print *
      print *,'det: ',det
      print *
+self.

      return
      end
+DECK,BPHARM.
*CMZ :  2.44/00 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  17.01.45  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  14.43.05  by  Michael Scheer
*CMZ : 00.02/04 24/02/97  17.08.37  by  Michael Scheer
*CMZ : 00.02/03 04/02/97  16.38.06  by  Michael Scheer
*-- Author :    Michael Scheer   22/01/97

      SUBROUTINE BPHARM(XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT)
+seq,gplhint.

C
C     INPUT/OUTPUT COORDINATE SYSTEM: X LONG., Y VERTICAL
C     INTERNAL COORDINATE SYSTEM: Z LONG., Y VERTICAL
C
C     UNIT: METER AND TESLA
C

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,BPHARM.
+SEQ,PHYCON.

      INTEGER ICAL,IPAR,N,NXY

      DOUBLE PRECISION XOFF
      DOUBLE PRECISION XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT
      DOUBLE PRECISION X,Y,Z,BXX,BYY,BZZ,B0X,B0Y,B0Z
      DOUBLE PRECISION ZK

        DOUBLE PRECISION COSNZ,SINNXYX,SINHY,COSNXYY,COSHX,SINNZ
     &        ,COSNXYX,COSHY
        DOUBLE PRECISION SINNXYY,SINHX,yKs,XKC
        DOUBLE PRECISION ASINHY(NHARMP,NTRANSP),ACOSHX(NHARMP,NTRANSP)
        DOUBLE PRECISION ACOSHY(NHARMP,NTRANSP),ASINHX(NHARMP,NTRANSP)
        DOUBLE PRECISION YKC(NHARMP,NTRANSP),XKS(NHARMP,NTRANSP)
        DOUBLE PRECISION ACOSNZ(NHARMP),ASINNZ(NHARMP)
        DOUBLE PRECISION ACOSNXYX(NTRANSP),ASINNXYX(NTRANSP)
        DOUBLE PRECISION ACOSNXYY(NTRANSP),ASINNXYY(NTRANSP)
      DOUBLE PRECISION B0S,B0C

+SELF,IF=-NOCMPLX.
        COMPLEX*16 CZKN(NHARMP),CXN(NTRANSP),CYN(NTRANSP)
+SELF,IF=NOCMPLX.
        DOUBLE PRECISION CZKNR(NHARMP),CXNR(NTRANSP),CYNR(NTRANSP)
        DOUBLE PRECISION CZKNI(NHARMP),CXNI(NTRANSP),CYNI(NTRANSP)
+SELF.
       CHARACTER(64) COMMENT

      DATA ICAL/0/

C--- INITIALIZATION

      IF (ICAL.EQ.0) THEN

         OPEN(UNIT=LUNPHFIT,FILE=FILEPHFIT,STATUS='OLD')

            READ(LUNPHFIT,'(A64)')COMMENT
            READ(LUNPHFIT,*)PERLENPH,PHASEPH
            READ(LUNPHFIT,*)XLENCPH,YLENSPH
            READ(LUNPHFIT,*)XPHMIN,XPHMAX
            READ(LUNPHFIT,*)YPHMIN,YPHMAX
            READ(LUNPHFIT,*)ZPHMIN,ZPHMAX
            READ(LUNPHFIT,*)NTRANS0,NTRANS,NTRANSD
            READ(LUNPHFIT,*)NHARM0,NHARM,NHARMD
          READ(LUNPHFIT,*)NPARPH

          DO IPAR=1,NPARPH
         READ(LUNPHFIT,*)PARPH(IPAR)
          ENDDO

            WRITE(LUNGFO,*)'     SUBROUTINE BPHARM:'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Fitparameters read from file:'
            WRITE(LUNGFO,*)'     ',FILEPHFIT
            WRITE(LUNGFO,*)

            WRITE(LUNGFO,'(''      '',A64)')COMMENT
            WRITE(LUNGFO,*)
     &'     periodlength, phase, and scaling factor:'
            WRITE(LUNGFO,*)
     &'     (PERLENPH,PHASEPH,XLENCPH,YLENSPH)'
            WRITE(LUNGFO,*)'     ',PERLENPH
            WRITE(LUNGFO,*)'     ',PHASEPH
            WRITE(LUNGFO,*)'     ',XLENCPH
            WRITE(LUNGFO,*)'     ',YLENSPH
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     XPHMIN,XPHMAX:',XPHMIN,XPHMAX
            WRITE(LUNGFO,*)'     YPHMIN,YPHMAX:',YPHMIN,YPHMAX
            WRITE(LUNGFO,*)'     ZPHMIN,ZPHMAX:',ZPHMIN,ZPHMAX
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &'     NTRANS0,NTRANS,NTRANSD:',NTRANS0,NTRANS,NTRANSD
            WRITE(LUNGFO,*)
     &'     NHARM0,NHARM,NHARMD:   ',NHARM0,NHARM,NHARMD
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     NPARPH:',NPARPH
            WRITE(LUNGFO,*)

          DO IPAR=1,NPARPH
         WRITE(LUNGFO,*)'          ',PARPH(IPAR)
          ENDDO

          IF (NPARPH.GT.NPARPHP) THEN
         WRITE(LUNGFO)
     &'*** ERROR IN BPHARM: DIMENSION NPARPHP IN BPHARM.CMN EXCEEDED  ***'
         WRITE(LUNGFO)
         WRITE(6,*)
     &'*** ERROR IN BPHARM: DIMENSION NPARPHP IN BPHARM.CMN EXCEEDED  ***'
         WRITE(6,*)
         WRITE(6,*) '--- PROGRAM ABORTED DUE TO ERROR ---'
         STOP
          ENDIF

          IF (NTRANS.GT.NTRANSP) THEN
         WRITE(LUNGFO)
     &'*** ERROR IN BPHARM: DIMENSION NTRANSP IN BPHARM.CMN EXCEEDED  ***'
         WRITE(LUNGFO)
         WRITE(6,*)
     &'*** ERROR IN BPHARM: DIMENSION NTRANSP IN BPHARM.CMN EXCEEDED  ***'
         WRITE(6,*)
         WRITE(6,*) '--- PROGRAM ABORTED DUE TO ERROR ---'
         STOP
          ENDIF

         CLOSE(LUNPHFIT)

        XOFF=PHASEPH*PERLENPH
        ZK=2.D0*PI1/PERLENPH
        IF (XLENCPH.NE.0.D0) THEN
           XKCPH=2.D0*PI1/XLENCPH
        ELSE
           XKCPH=0.D0
        ENDIF
        IF (YLENSPH.NE.0.D0) THEN
           YKSPH=2.D0*PI1/YLENSPH
        ELSE
           YKSPH=0.D0
        ENDIF
        XKC=XKCPH
        YKS=YKSPH

         AXOUT=0.D0
         AYOUT=0.D0
         AZOUT=0.D0

         ICAL=1

      ENDIF !ICAL

C --- CHANGE COORDINATE SYSTEMS

      X=-ZIN
      Y=YIN
      Z=XIN+XOFF

C--- MAGNETIC FIELD

      BXOUT=0.D0
      BYOUT=0.D0
      BZOUT=0.D0
      B0X=0.0
      B0Y=0.0
      B0Z=0.0

+SELF,IF=-NOCMPLX.

        CZKN(1)=CDEXP(DCMPLX(0.D0,ZK*Z))
        DO N=2,NHARM
                CZKN(N)=CZKN(N-1)*CZKN(1)
        ENDDO   !NHARM

        CXN(1)=CDEXP(DCMPLX(0.D0,XKC*X))
        CYN(1)=CDEXP(DCMPLX(0.D0,YKS*Y))
        DO NXY=2,NTRANS
                CXN(NXY)=CXN(NXY-1)*CXN(1)
                CYN(NXY)=CYN(NXY-1)*CYN(1)
        ENDDO


      IF (NHARM0.GT.0) THEN
        DO N=NHARM0,NHARM,NHARMD
                ACOSNZ(N)=DREAL(CZKN(N))
                ASINNZ(N)=DIMAG(CZKN(N))
        ENDDO   !NHARM
      ENDIF

      IF (NTRANS0.GT.0) THEN
        DO NXY=NTRANS0,NTRANS,NTRANSD
                ACOSNXYX(NXY)=DREAL(CXN(NXY))
                ASINNXYX(NXY)=DIMAG(CXN(NXY))
                ACOSNXYY(NXY)=DREAL(CYN(NXY))
                ASINNXYY(NXY)=DIMAG(CYN(NXY))
        ENDDO
      ENDIF

+SELF,IF=NOCMPLX.

      WRITE(6,*)'CHECK +SELF,NOCMPLX'

      CZKNR(1)=COS(ZK*Z)
      CZKNI(1)=SIN(ZK*Z)
        DO N=2,NHARM
         CZKNR(N)=CZKNR(N-1)*CZKNR(1)-CZKNI(N-1)*CZKNI(1)
         CZKNI(N)=CZKNI(N-1)*CZKNR(1)+CZKNR(N-1)*CZKNI(1)
        ENDDO   !NHARM

        DO N=NHARM0,NHARM,NHARMD
                ACOSNZ(N)=CZKNR(N)
                ASINNZ(N)=CZKNI(N)
        ENDDO   !NHARM

      CXNR(1)=COS(XKC*X)
      CXNI(1)=SIN(XKC*X)
      CYNR(1)=COS(YKS*Y)
      CYNI(1)=SIN(YKS*Y)
        DO NXY=2,NTRANS
         CXNR(NXY)=CXNR(NXY-1)*CXNR(1)-CXNI(NXY-1)*CXNI(1)
         CXNI(NXY)=CXNI(NXY-1)*CXNR(1)+CXNR(NXY-1)*CXNI(1)
         CYNR(NXY)=CYNR(NXY-1)*CYNR(1)-CYNI(NXY-1)*CYNI(1)
         CYNI(NXY)=CYNI(NXY-1)*CYNR(1)+CYNR(NXY-1)*CYNI(1)
        ENDDO


        DO NXY=NTRANS0,NTRANS,NTRANSD
                ACOSNXYX(NXY)=CXNR(NXY)
                ASINNXYX(NXY)=CXNI(NXY)
                ACOSNXYY(NXY)=CYNR(NXY)
                ASINNXYY(NXY)=CYNI(NXY)
        ENDDO

+SELF.

      IF (NPARPH.GT.3) THEN

        DO NXY=NTRANS0,NTRANS,NTRANSD
        DO N=NHARM0,NHARM,NHARMD

                YKC(N,NXY)=DSQRT((ZK*N)**2+(NXY*XKC)**2)
                XKS(N,NXY)=DSQRT((ZK*N)**2+(NXY*YKS)**2)
                ASINHY(N,NXY)=DSINh(YKc(N,NXY)*y)
                ASINHX(N,NXY)=DSINh(XKs(N,NXY)*x)
                ACOSHX(N,NXY)=DSQRT(1.D0+ASINHX(N,NXY)**2)
                ACOSHY(N,NXY)=DSQRT(1.D0+ASINHY(N,NXY)**2)

        ENDDO   !NHARM
        ENDDO   !NTRANS

      IPAR=3
        DO NXY=NTRANS0,NTRANS,NTRANSD
        DO N=NHARM0,NHARM,NHARMD

                IPAR=IPAR+2

           B0C=PARPH(IPAR-1)
           B0S=PARPH(IPAR)

                SINHY=ASINHY(N,NXY)
                COSHX=ACOSHX(N,NXY)
                COSHY=ACOSHY(N,NXY)
                SINHX=ASINHX(N,NXY)
                COSNZ=ACOSNZ(N)
                SINNZ=ASINNZ(N)
                COSNXYX=ACOSNXYX(NXY)
                SINNXYX=ASINNXYX(NXY)
                COSNXYY=ACOSNXYY(NXY)
                SINNXYY=ASINNXYY(NXY)


c achtung: einige Sinusterme nacheditieren   INCLUDE 'RED:VPOT-HARM_BFELD.FOR'

      bxx=(-(COSNZ*SINNXYX*SINHY*b0c*XKC*
     . nxy-YKC(N,nxy)*b0x-COSNXYY*COSHX*YKC(N,nxy
     . )*SINNZ*b0s))/YKC(N,nxy)
      byy=(XKS(N,nxy)*b0y-SINNXYY*SINNZ*SINHX*b0s*YKS*nxy
     &+COSNXYX*COSNZ*COSHY*
     . XKS(N,nxy)*b0c)/XKS(N,nxy)
      bzz=((COSNXYY*COSNZ*SINHX*b0s*ZK*n+
     . XKS(N,nxy)*b0z)*YKC(N,nxy)-COSNXYX*XKS(N,nxy)*sinnz
     . *SINHY*b0c*ZK*n)/(XKS(N,nxy)*YKC(N,nxy))


C --- CHANGE COORDINATE SYSTEMS

      BXOUT=BXOUT+BXX
      BYOUT=BYOUT+BYY
      BZOUT=BZOUT+BZZ

      ENDDO !NTRANS
      ENDDO !NHARM

      ENDIF !NPARPH.GT.3

C --- CHANGE COORDINATE SYSTEMS

      BXX= BZOUT+PARPH(3)
      BYY= BYOUT+PARPH(2)
      BZZ=-BXOUT-PARPH(1)

      BXOUT=BXX
      BYOUT=BYY
      BZOUT=BZZ

      RETURN
      END
+DECK,BPHARMFIT.
*CMZ :  4.00/14 22/12/2021  16.40.21  by  Michael Scheer
*CMZ :  3.02/03 23/10/2014  13.43.13  by  Michael Scheer
*CMZ :  3.00/01 20/03/2013  10.18.08  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  10.40.59  by  Michael Scheer
*CMZ :  2.68/05 28/09/2012  11.51.36  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  09.55.57  by  Michael Scheer
*CMZ :  2.48/04 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.42/04 29/10/2002  10.38.26  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.41/08 12/08/2002  16.38.26  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.16/08 29/10/2000  18.05.38  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  13.48.28  by  Michael Scheer
*CMZ :  1.00/00 24/09/97  10.31.28  by  Michael Scheer
*CMZ : 00.02/04 24/02/97  14.54.02  by  Michael Scheer
*CMZ : 00.02/03 31/01/97  15.06.26  by  Michael Scheer
*CMZ :          22/01/97  11.27.20  by  Michael Scheer
*-- Author :    Michael Scheer   22/01/97

      SUBROUTINE BPHARMFIT
+seq,gplhint.

C FIT MAGNETIC FIELD ACCORDING TO SCALAR POTENTIAL:
C     VC:=-B0C/KYC(N,NXY)*COS(NXY*KXC*X)*SINH(KYC(N,NXY)*Y)*COS(N*KZ*Z)$
C     VS:=-B0S/KXS(N,NXY)*COS(NXY*KYS*Y)*SINH(KXS(N,NXY)*X)*SIN(N*KZ*Z)$
C     SEE REDUCE VPOT-HARM, COMMENT FROM 29OCT02

+SEQ,BPHARMF90U,IF=F90.

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,CMPARA.
+SEQ,MYFILES.
+SEQ,BPHARM.
+SEQ,PHYCON.
+seq,whbook.
+seq,pawcmn.

      INTEGER IPOI,IFAIL,IX,IPAR
      INTEGER MPOI,IREAD
      INTEGER NPHPOIX,NPHPOIY,NPHPOIZ,NPHPOI

      DOUBLE PRECISION
     &  RESBX,RESBY,RESBZ,RESB
     &  ,BXAMEAN,BYAMEAN,BZAMEAN,BAMEAN
     &  ,BERRMX(8),BXERRMX(8),BYERRMX(8),BZERRMX(8)
     &  ,XX,YY,ZZ,BBX,BBY,BBZ,AX,AY,AZ

      DOUBLE PRECISION XOFF

      INTEGER NTUP_P,ICYCLE
      PARAMETER (NTUP_P=9)
      REAL*8 TUP_D(NTUP_P)
      CHARACTER(3) CHTAGS_D(NTUP_P)
      data chtags_d/'x','y','z','bx','by','bz','bxf','byf','bzf'/

      IF (NHARM.GT.NHARMP) THEN
        WRITE(6,*) '*** ERROR IN BPHARMFIT: DIMENSION NHARMP EXCEEDED'
        STOP
      ENDIF
      IF (NTRANS.GT.NTRANSP) THEN
        WRITE(6,*) '*** ERROR IN BPHARMFIT: DIMENSION NTRANSP EXCEEDED'
        STOP
      ENDIF

C--- READ FIELD MAP {

      XOFF=PERLENPH*PHASEPH

      NPHPOIX=0
      NPHPOIY=0
      NPHPOIZ=0
      MPOI=0
      IREAD=0

      OPEN(UNIT=LUNBMAP,FILE=FILEBMAP,STATUS='OLD')

100   CONTINUE
      IF (IWBPHARM.EQ.1) THEN
        READ(LUNBMAP,*,END=90)XX
        READ(LUNBMAP,*)YY
        READ(LUNBMAP,*)ZZ
        READ(LUNBMAP,*)BBX
        READ(LUNBMAP,*)BBY
        READ(LUNBMAP,*)BBZ
        READ(LUNBMAP,*)
      ELSE IF (IWBPHARM.EQ.2) THEN
        READ(LUNBMAP,*,END=90)XX,YY,ZZ,BBX,BBY,BBZ
      ELSE
        WRITE(6,*) '*** ERROR IN BPHARMFIT: FLAG IWBPHARM WRONG, CHECK INPUT'
        STOP
      ENDIF
      IREAD=IREAD+1
      IF (XPHMIN.NE.9999.AND.XX.LT.XPHMIN) GOTO 100
      IF (XPHMAX.NE.9999.AND.XX.GT.XPHMAX) GOTO 100
      IF (YPHMIN.NE.9999.AND.YY.LT.YPHMIN) GOTO 100
      IF (YPHMAX.NE.9999.AND.YY.GT.YPHMAX) GOTO 100
      IF (ZPHMIN.NE.9999.AND.ZZ.LT.ZPHMIN) GOTO 100
      IF (ZPHMAX.NE.9999.AND.ZZ.GT.ZPHMAX) GOTO 100
      IF (BBX.EQ.-9999..AND.BBY.EQ.-9999..AND.BBZ.EQ.-9999.) GOTO 100
      MPOI=MPOI+1

      IF (BBX.NE.-9999.) NPHPOIX=NPHPOIX+1
      IF (BBY.NE.-9999.) NPHPOIY=NPHPOIY+1
      IF (BBZ.NE.-9999.) NPHPOIZ=NPHPOIZ+1
      GOTO 100
90    CLOSE(LUNBMAP)

      ALLOCATE(X(MPOI))
      ALLOCATE(Y(MPOI))
      ALLOCATE(Z(MPOI))
      ALLOCATE(BX(MPOI))
      ALLOCATE(BY(MPOI))
      ALLOCATE(BZ(MPOI))
      ALLOCATE(BXF(MPOI))
      ALLOCATE(BYF(MPOI))
      ALLOCATE(BZF(MPOI))

      NPHPOIX=0
      NPHPOIY=0
      NPHPOIZ=0
      MPOI=0
      IREAD=0
      OPEN(UNIT=LUNBMAP,FILE=FILEBMAP,STATUS='OLD')

101   CONTINUE
      IF (IWBPHARM.EQ.1) THEN
        READ(LUNBMAP,*,END=91)XX
        READ(LUNBMAP,*)YY
        READ(LUNBMAP,*)ZZ
        READ(LUNBMAP,*)BBX
        READ(LUNBMAP,*)BBY
        READ(LUNBMAP,*)BBZ
        READ(LUNBMAP,*)
      ELSE IF (IWBPHARM.EQ.2) THEN
        READ(LUNBMAP,*,END=91)XX,YY,ZZ,BBX,BBY,BBZ
      ELSE
        WRITE(6,*) '*** ERROR IN BPHARMFIT: FLAG IWBPHARM WRONG, CHECK INPUT'
        STOP
      ENDIF
      IREAD=IREAD+1
      IF (XPHMIN.NE.9999.AND.XX.LT.XPHMIN) GOTO 101
      IF (XPHMAX.NE.9999.AND.XX.GT.XPHMAX) GOTO 101
      IF (YPHMIN.NE.9999.AND.YY.LT.YPHMIN) GOTO 101
      IF (YPHMAX.NE.9999.AND.YY.GT.YPHMAX) GOTO 101
      IF (ZPHMIN.NE.9999.AND.ZZ.LT.ZPHMIN) GOTO 101
      IF (ZPHMAX.NE.9999.AND.ZZ.GT.ZPHMAX) GOTO 101
      IF (BBX.EQ.-9999..AND.BBY.EQ.-9999..AND.BBZ.EQ.-9999.) GOTO 101
      MPOI=MPOI+1
      IF (BBX.NE.-9999.) NPHPOIX=NPHPOIX+1
      IF (BBY.NE.-9999.) NPHPOIY=NPHPOIY+1
      IF (BBZ.NE.-9999.) NPHPOIZ=NPHPOIZ+1
      X(MPOI)=XX+XOFF
      Y(MPOI)=YY
      Z(MPOI)=ZZ
      BX(MPOI)=BBX
      BY(MPOI)=BBY
      BZ(MPOI)=BBZ
      GOTO 101
91    CLOSE(LUNBMAP)

      NPHPOI=MPOI

C--- READ FIELD MAP }

      IF (XPHMIN.EQ.9999.) THEN
        XPHMIN=1.D30
        DO IPOI=1,MPOI
          XX=X(IPOI)-XOFF
          IF (XX.LT.XPHMIN) XPHMIN=XX
        ENDDO
        XPHMIN=XPHMIN
      ENDIF

      IF (XPHMAX.EQ.9999.) THEN
        XPHMAX=-1.D30
        DO IPOI=1,MPOI
          XX=X(IPOI)-XOFF
          IF (XX.GT.XPHMAX) XPHMAX=XX
        ENDDO
        XPHMAX=XPHMAX
      ENDIF

      IF (YPHMIN.EQ.9999.) THEN
        YPHMIN=1.D30
        DO IPOI=1,MPOI
          IF (Y(IPOI).LT.YPHMIN) YPHMIN=Y(IPOI)
        ENDDO
        YPHMIN=YPHMIN
      ENDIF

      IF (YPHMAX.EQ.9999.) THEN
        YPHMAX=-1.D30
        DO IPOI=1,MPOI
          IF (Y(IPOI).GT.YPHMAX) YPHMAX=Y(IPOI)
        ENDDO
        YPHMAX=YPHMAX
      ENDIF

      IF (ZPHMIN.EQ.9999.) THEN
        ZPHMIN=1.D30
        DO IPOI=1,MPOI
          IF (Z(IPOI).LT.ZPHMIN) ZPHMIN=Z(IPOI)
        ENDDO
        ZPHMIN=ZPHMIN
      ENDIF

      IF (ZPHMAX.EQ.9999.) THEN
        ZPHMAX=-1.D30
        DO IPOI=1,MPOI
          IF (Z(IPOI).GT.ZPHMAX) ZPHMAX=Z(IPOI)
        ENDDO
        ZPHMAX=ZPHMAX
      ENDIF

      IF (XLENCPH.EQ.9999.) XLENCPH=DABS(ZPHMAX-ZPHMIN)*2.d0
      IF (YLENSPH.EQ.9999.) YLENSPH=DABS(YPHMAX-YPHMIN)*2.d0

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SUBROUTINE BPHARMFIT:'
      WRITE(LUNGFO,*)'     ======================'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     period length and long. shift:        '
     &  , SNGL(PERLENPH),SNGL(PHASEPH)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     transversal lengths (hor. and vert.): '
     &  , SNGL(XLENCPH),SNGL(YLENSPH)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     field map read from file:'
      WRITE(LUNGFO,*)'     ',FILEBMAP
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)'     number of data points read:      ',IREAD
      WRITE(LUNGFO,*)'     number of data points accepted:  ',MPOI
      WRITE(LUNGFO,*)'     number of Bx, By, Bz .ne. -9999.:'
     &  ,NPHPOIX,NPHPOIY,NPHPOIZ
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     fitted coefficients are written to file:'
      WRITE(LUNGFO,*)'     ',FILEPHFIT
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Considered range in x, y, and z:'
      WRITE(LUNGFO,*)'     ',XPHMIN,XPHMAX
      WRITE(LUNGFO,*)'     ',YPHMIN,YPHMAX
      WRITE(LUNGFO,*)'     ',ZPHMIN,ZPHMAX
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     NTRANS0,NTRANS,NTRANSD:',NTRANS0,NTRANS,NTRANSD
      WRITE(LUNGFO,*)'     NHARM0,NHARM,NHARMD:',NHARM0,NHARM,NHARMD
      WRITE(LUNGFO,*)

      IF (XLENCPH.NE.0.D0) THEN
        XKCPH=2.D0*PI1/XLENCPH
      ELSE
        XKCPH=0.D0
      ENDIF
      IF (YLENSPH.NE.0.D0) THEN
        YKSPH=2.D0*PI1/YLENSPH
      ELSE
        YKSPH=0.D0
      ENDIF

      CALL VPOTPH(MPOI,IFAIL)

      IF (IFAIL.NE.0) THEN
        WRITE(6,*) '*** IFAIL NOT ZERO ***'
        WRITE(6,*) '*** (maybe no transversal field gradient ***'
        WRITE(6,*) '*** (or XLENCPH, YLENSPH zero) ***'
        STOP
      ENDIF

      DO IPOI=1,MPOI
        X(IPOI)=X(IPOI)-XOFF
      ENDDO

      OPEN(UNIT=LUNPHFIT,FILE=FILEPHFIT,STATUS='NEW')
      WRITE(LUNPHFIT,'(I5,1H ,A64)')ICODE,CODE
      WRITE(LUNPHFIT,*)PERLENPH,PHASEPH
      WRITE(LUNPHFIT,*)XLENCPH,YLENSPH
      WRITE(LUNPHFIT,*)XPHMIN,XPHMAX
      WRITE(LUNPHFIT,*)YPHMIN,YPHMAX
      WRITE(LUNPHFIT,*)ZPHMIN,ZPHMAX
      WRITE(LUNPHFIT,*)NTRANS0,NTRANS,NTRANSD
      WRITE(LUNPHFIT,*)NHARM0,NHARM,NHARMD
      WRITE(LUNPHFIT,*)NPARPH

      DO IPAR=1,NPARPH
        WRITE(LUNPHFIT,*) PARPH(IPAR)
      ENDDO
      CLOSE(LUNPHFIT)

      IF (IHBPHARM.NE.0) THEN
+self,if=-mhbook.
        CALL hbookm(NIDBPOLY,'BPHARM FIT$',NTUP_P,'//WAVE',1024,CHTAGS_D)
+self,if=mhbook.
        CALL hbookm(NIDBPOLY,'BPHARM FIT',NTUP_P,'//WAVE',mpoi,CHTAGS_D)
+self.
      ENDIF

      DO IPOI=1,MPOI

        CALL BPHARM(X(IPOI),Y(IPOI),Z(IPOI)
     &    ,BXF(IPOI),BYF(IPOI),BZF(IPOI),AX,AY,AZ)

        IF (IHBPHARM.NE.0) THEN
          TUP_D(1)=X(IPOI)
          TUP_D(2)=Y(IPOI)
          TUP_D(3)=Z(IPOI)
          TUP_D(4)=BX(IPOI)
          TUP_D(5)=BY(IPOI)
          TUP_D(6)=BZ(IPOI)
          TUP_D(7)=BXF(IPOI)
          TUP_D(8)=BYF(IPOI)
          TUP_D(9)=BZF(IPOI)
          CALL hfm(NIDBPOLY,TUP_D)
        ENDIF

      ENDDO !IPOI

      CALL BRESI      (MPOI,NPHPOIX,NPHPOIY,NPHPOIZ
     &  ,X,Y,Z,BX,BY,BZ,BXF,BYF,BZF
     &  ,RESBX,RESBY,RESBZ,RESB
     &  ,BXAMEAN,BYAMEAN,BZAMEAN,BAMEAN
     &  ,BERRMX,BXERRMX,BYERRMX,BZERRMX)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     RESB:',SNGL(RESB)
      WRITE(LUNGFO,*)'     RESBX, RESBY,RESBZ:',SNGL(RESBX),SNGL(RESBY),SNGL(RESBZ)
      WRITE(LUNGFO,*)
      IF (BAMEAN.NE.0.D0)
     &  WRITE(LUNGFO,*)'     |B|mean,   RESB/|B|mean: ',SNGL(BAMEAN),SNGL(RESB/BAMEAN)
      IF (BXAMEAN.NE.0.D0)
     &  WRITE(LUNGFO,*)'     |BX|mean, RESBX/|BX|mean:',SNGL(BXAMEAN),SNGL(RESBX/BXAMEAN)
      IF (BYAMEAN.NE.0.D0)
     &  WRITE(LUNGFO,*)'     |BY|mean, RESBY/|BY|mean:',SNGL(BYAMEAN),SNGL(RESBY/BYAMEAN)
      IF (BZAMEAN.NE.0.D0)
     &  WRITE(LUNGFO,*)'     |BZ|mean, RESBZ/|BZ|mean:',SNGL(BZAMEAN),SNGL(RESBZ/BZAMEAN)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     MAXIMUM ERRORS OF B, BX, BY AND BZ:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'  X      Y      Z       BX        BY        BZ       B         ERR'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,'(3F8.4,5(1PE10.2))')(SNGL(BERRMX(IX)),IX=1,8)
      WRITE(LUNGFO,'(3F8.4,5(1PE10.2))')(SNGL(BXERRMX(IX)),IX=1,8)
      WRITE(LUNGFO,'(3F8.4,5(1PE10.2))')(SNGL(BYERRMX(IX)),IX=1,8)
      WRITE(LUNGFO,'(3F8.4,5(1PE10.2))')(SNGL(BZERRMX(IX)),IX=1,8)
      WRITE(LUNGFO,*)

      IF (IHBPHARM.NE.0) THEN
        CALL MHROUT(NIDBPOLY,ICYCLE,' ')
        CALL hdeletm(NIDBPOLY)
      ENDIF

      RETURN
      END
+DECK,BPHARM_FIT.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.44/00 31/10/2002  10.24.06  by  Michael Scheer
*CMZ :  1.00/00 30/06/97  11.44.26  by  Michael Scheer
*CMZ : 00.02/04 13/02/97  16.42.34  by  Michael Scheer
*CMZ : 00.02/03 04/02/97  16.23.52  by  Michael Scheer
*CMZ : 00.00/01 17/01/97  16.00.54  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BPHARM_FIT
     &  (IFAIL,NPAR,PARAM,NDIMPOI,NPOI,NARG,NFUN,A,T,FUNDATA,CURDAT)
+seq,gplhint.

C     DOUBLE PRECISION SUBROUTINE FOR MULTIDIMENSIONAL LINEAR FIT

C     INPUT:
C       ------
C     NPAR:     NUMBER OF PARAMETERS TO FIT
C     NPOI:     NUMBER OF DATAPOINTS (NPOI MUST BE .LE. NDIMPOI)
C     NDIMPOI:    DIMENSION FOR NUMBER OF DATAPOINTS
C     NARG:     NUMBER OF ARGUMENTS FOR FUNCTION
C     NFUN:     DIMENSION OF FUNCTION
C     A:     WORKINGSPACE A(NPAR,NPAR)
C     T:     WORKINGSPACE T(NFUN,NPAR)
C     FUNDATA:    DATA POINTS FUNDATA(NARG+NFUN,NDIMPOI)
C            IF A FUNCTION VALUE IS 9999. DATA IS SKIPPED
C            NUMBER OF DATA MUST BE AT LEAST NPAR

C     OUTPUT:
C     -------
C     PARAM:       PARAMETERS TO BE FITTED
C     IFAIL:       FAILURE FLAG, ZERO IF EVERYTHING SEEMS TO BE OK

C     EXAMPLE:
C     --------
C     NPAR=4
C     NPOI=10
C     NARG=3
C     NFUN=2
C     FUNDATA(NARG+NFUN,NPOI):
C         FUNDATA(1,I)=X(I)
C         FUNDATA(2,I)=Y(I)
C         FUNDATA(3,I)=Z(I)
C         FUNDATA(4,I)=BX(I)
C         FUNDATA(5,I)=BY(I)
C

C     FIT SUCH THAT
C
C         dCHI2/dP1=0
C         dCHI2/dP2=0
C         dCHI2/dP3=0
C         dCHI2/dP4=0
C
C     WITH
C
C         DO I=1,NPOI
C          CHI2=CHI2+
C         +((P1*X(I)*Y(I)*SIN(  K*Z(I)+)-BX(IPOI))**2
C         +((P2*X(I)*Y(I)*COS(  K*Z(I)+)-BX(IPOI))**2
C         +((P3*X(I)*Y(I)*SIN(3*K*Z(I)+)-BY(IPOI))**2
C         +((P4*X(I)*Y(I)*COS(3*K*Z(I)+)-BY(IPOI))**2
C         ENDDO   !IPOI
C
C     AND P1=PARAM(1), P2=....
C

      IMPLICIT NONE

      INTEGER IFAIL,NPAR,NDIMPOI,NPOI,NARG,NFUN
      INTEGER IPAR,IPOI,IFUN
      INTEGER JPAR,JPOI,IDAT

      DOUBLE PRECISION PARAM,A,T,FUNDATA,CURDAT
      DIMENSION PARAM(NPAR),A(NPAR,NPAR)
     &           ,T(NFUN,NPAR)
     & ,FUNDATA(NARG+NFUN,NDIMPOI),CURDAT(NARG+NFUN)

+SEQ,BPHARM.

      IF (NPOI.GT.NDIMPOI) STOP
     &'*** ERROR IN BPHARM_FIT: DIMENSION NDIMPOI EXCEEDED ***'

      IFAIL=0

      JPOI=0
      DO IPOI=1,NPOI
      DO IFUN=1,NFUN
          IF (FUNDATA(NARG+IFUN,IPOI).NE.9999.) JPOI=JPOI+1
      ENDDO
      ENDDO

C ATTENTION: SINCE T IS ALSO USED AS WORKINGSPACE FOR F010
C          ITS DIMENSION MUST BE AT LEAST 2*NPAR, I.E. NPOI.GE.NPAR
      IF (JPOI.LT.NPAR) THEN
          IFAIL=9999
          RETURN
      ENDIF

      DO JPAR=1,NPAR
          PARAM(JPAR)=0.D0
      DO IPAR=1,NPAR
          A(IPAR,JPAR)=0.D0
      ENDDO
      ENDDO


C--- SET UP EQUATION SYSTEM


C -- SET UP INHOMOGENITY OF EQUATION SYSTEM

      DO IPOI=1,NPOI
C    T(IFUN,IPAR)=dChi2/dIPAR for each point and function
      DO IDAT=1,NARG+NFUN
          CURDAT(IDAT)=FUNDATA(IDAT,IPOI)
      ENDDO
      CALL BPHARM_USER(NARG,NFUN,NPAR,CURDAT,T)
      DO IPAR=1,NPAR
      DO IFUN=1,NFUN

          PARAM(IPAR)=PARAM(IPAR)
     &                 +T(IFUN,IPAR)*CURDAT(NARG+IFUN)

      ENDDO !NFUN
      ENDDO !NPAR
      ENDDO !NPOI

C -- SET UP MATRIX OF EQUATION SYSTEM

      DO IPOI=1,NPOI
      DO IDAT=1,NARG+NFUN
          CURDAT(IDAT)=FUNDATA(IDAT,IPOI)
      ENDDO
      CALL BPHARM_USER(NARG,NFUN,NPAR,CURDAT,T)
      DO IFUN=1,NFUN
      DO JPAR=1,NPAR
          DO IPAR=1,NPAR
         A(IPAR,JPAR)=A(IPAR,JPAR)
     &                      +(T(IFUN,IPAR)*T(IFUN,JPAR))
          ENDDO
      ENDDO
      ENDDO
      ENDDO

C KILL SINE-LIKE PARAMETERS IF YLENSPH.EQ.0.D0

      IF (YLENSPH.EQ.0.D0) THEN
          DO IPAR=5,NPAR,2
         DO JPAR=1,NPAR
             A(JPAR,IPAR)=0.D0
         ENDDO
          ENDDO
          DO IPAR=5,NPAR,2
         DO JPAR=1,NPAR
             A(IPAR,JPAR)=0.D0
         ENDDO
          ENDDO
          DO IPAR=5,NPAR,2
         A(IPAR,IPAR)=1.D0
         PARAM(IPAR)=0.D0
          ENDDO
      ENDIF

C--- SOLVE EQUATION SYSTEM WITH CERN-ROUTINE F010

      CALL DEQN(NPAR,A,NPAR,T,IFAIL,1,PARAM)

      RETURN
      END
+DECK,BPHARM_USER.
*CMZ :  2.44/00 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  17.09.10  by  Michael Scheer
*CMZ : 00.02/04 24/02/97  15.40.14  by  Michael Scheer
*CMZ : 00.02/03 04/02/97  16.36.40  by  Michael Scheer
*-- Author :    Michael Scheer   23/01/97

        SUBROUTINE BPHARM_USER(NARG,NFUN,NPAR,CURDAT,T)
+seq,gplhint.

      IMPLICIT NONE

+SEQ,BPHARM.
+SEQ,PHYCON.

      INTEGER ICAL
      INTEGER NARG,NFUN,NPAR,IPAR
      INTEGER N,NXY
      DOUBLE PRECISION CURDAT,T
      DIMENSION CURDAT(NARG+NFUN),T(NFUN,NPAR)
      DOUBLE PRECISION TT(3,2)
      DOUBLE PRECISION COSNZ,SINNXYX,SINHY,COSNXYY,COSHX,SINNZ
     &        ,COSNXYX,COSHY
      DOUBLE PRECISION SINNXYY,SINHX,yKs
     &        ,XKS(NHARMP,NTRANSP),YKC(NHARMP,NTRANSP),XKC
      DOUBLE PRECISION ZK,X,Y,Z
      DOUBLE PRECISION ASINHY(NHARMP,NTRANSP),ACOSHX(NHARMP,NTRANSP)
      DOUBLE PRECISION ACOSHY(NHARMP,NTRANSP),ASINHX(NHARMP,NTRANSP)
      DOUBLE PRECISION ACOSNZ(NHARMP),ASINNZ(NHARMP)
      DOUBLE PRECISION ACOSNXYX(NTRANSP),ASINNXYX(NTRANSP)
      DOUBLE PRECISION ACOSNXYY(NTRANSP),ASINNXYY(NTRANSP)

+SELF,IF=-NOCMPLX.
      COMPLEX*16 CZKN(NHARMP),CXN(NTRANSP),CYN(NTRANSP)
+SELF,IF=NOCMPLX.
      DOUBLE PRECISION CZKNR(NHARMP),CXNR(NTRANSP),CYNR(NTRANSP)
      DOUBLE PRECISION CZKNI(NHARMP),CXNI(NTRANSP),CYNI(NTRANSP)
+SELF.
      DATA ICAL/0/

      IF (ICAL.EQ.0) THEN
         ZK=2.D0*PI1/PERLENPH
                XKC=XKCPH
                YKS=YKSPH
         ICAL=1
      ENDIF !ICAL

      x=CURdat(1)
      y=CURdat(2)
      z=CURdat(3)

+SELF,IF=-NOCMPLX.

      CZKN(1)=CDEXP(DCMPLX(0.D0,ZK*Z))
      DO N=2,NHARM
         CZKN(N)=CZKN(N-1)*CZKN(1)
      ENDDO !NHARM

      CXN(1)=CDEXP(DCMPLX(0.D0,XKC*X))
      CYN(1)=CDEXP(DCMPLX(0.D0,YKS*Y))
      DO NXY=2,NTRANS
         CXN(NXY)=CXN(NXY-1)*CXN(1)
         CYN(NXY)=CYN(NXY-1)*CYN(1)
      ENDDO

      T(1,1)=1.D0
      T(1,2)=0.D0
      T(1,3)=0.D0
      T(2,1)=0.D0
      T(2,2)=1.D0
      T(2,3)=0.D0
      T(3,1)=0.D0
      T(3,2)=0.D0
      T(3,3)=1.D0

      IF(NHARM0.GT.0) THEN
      DO N=NHARM0,NHARM,NHARMD
         ACOSNZ(N)=DREAL(CZKN(N))
         ASINNZ(N)=DIMAG(CZKN(N))
      ENDDO !NHARM
      ENDIF

      IF (NTRANS0.GT.0) THEN
      DO NXY=NTRANS0,NTRANS,NTRANSD
         ACOSNXYX(NXY)=DREAL(CXN(NXY))
         ASINNXYX(NXY)=DIMAG(CXN(NXY))
         ACOSNXYY(NXY)=DREAL(CYN(NXY))
         ASINNXYY(NXY)=DIMAG(CYN(NXY))
      ENDDO
      ENDIF
+SELF,IF=NOCMPLX.

        WRITE(6,*)'CHECK +SELF,NOCMPLX'

        CZKNR(1)=COS(ZK*Z)
        CZKNI(1)=SIN(ZK*Z)
        DO N=2,NHARM
                CZKNR(N)=CZKNR(N-1)*CZKNR(1)-CZKNI(N-1)*CZKNI(1)
                CZKNI(N)=CZKNI(N-1)*CZKNR(1)+CZKNR(N-1)*CZKNI(1)
        ENDDO   !NHARM

        CXNR(1)=COS(XKC*X)
        CXNI(1)=SIN(XKC*X)
        CYNR(1)=COS(YKS*Y)
        CYNI(1)=SIN(YKS*Y)
        DO NXY=2,NTRANS
                CXNR(NXY)=CXNR(NXY-1)*CXNR(1)-CXNI(NXY-1)*CXNI(1)
                CXNI(NXY)=CXNI(NXY-1)*CXNR(1)+CXNR(NXY-1)*CXNI(1)
                CYNR(NXY)=CYNR(NXY-1)*CYNR(1)-CYNI(NXY-1)*CYNI(1)
                CYNI(NXY)=CYNI(NXY-1)*CYNR(1)+CYNR(NXY-1)*CYNI(1)
        ENDDO

      IF(NHARM0.GT.0) THEN
        DO N=NHARM0,NHARM,NHARMD
                ACOSNZ(N)=CZKNR(N)
                ASINNZ(N)=CZKNI(N)
        ENDDO   !NHARM
      ENDIF

      IF (NTRANS0.GT.0) THEN
        DO NXY=NTRANS0,NTRANS,NTRANSD
                ACOSNXYX(NXY)=CXNR(NXY)
                ASINNXYX(NXY)=CXNI(NXY)
                ACOSNXYY(NXY)=CYNR(NXY)
                ASINNXYY(NXY)=CYNI(NXY)
        ENDDO
      ENDIF
+SELF.

      IF (NPAR.GT.3) THEN

      DO NXY=NTRANS0,NTRANS,NTRANSD
      DO N=NHARM0,NHARM,NHARMD

         YKC(N,NXY)=DSQRT((ZK*N)**2+(NXY*XKC)**2)
         XKS(N,NXY)=DSQRT((ZK*N)**2+(NXY*YKS)**2)
         ASINHY(N,NXY)=DSINh(YKC(N,NXY)*y)
         ASINHX(N,NXY)=DSINh(XKS(N,NXY)*x)
         ACOSHX(N,NXY)=DSQRT(1.D0+ASINHX(N,NXY)**2)
         ACOSHY(N,NXY)=DSQRT(1.D0+ASINHY(N,NXY)**2)

      ENDDO !NHARM
      ENDDO !NTRANS

      IPAR=3
      DO NXY=NTRANS0,NTRANS,NTRANSD
      DO N=NHARM0,NHARM,NHARMD

         IPAR=IPAR+2

         SINHY=ASINHY(N,NXY)
         COSHX=ACOSHX(N,NXY)
         COSHY=ACOSHY(N,NXY)
         SINHX=ASINHX(N,NXY)
         COSNZ=ACOSNZ(N)
         SINNZ=ASINNZ(N)
         COSNXYX=ACOSNXYX(NXY)
         SINNXYX=ASINNXYX(NXY)
         COSNXYY=ACOSNXYY(NXY)
         SINNXYY=ASINNXYY(NXY)

c     INCLUDE 'RED:VPOT-HARM.FOR'

      tt(1,1)=(-COSNZ*SINNXYX*SINHY*XKC*nxy
     . )/YKC(N,nxy)
      tt(1,2)=COSNXYY*COSHX*SINNZ
      tt(2,1)=COSNXYX*COSNZ*COSHY
      tt(2,2)=(-SINNXYY*SINNZ*SINHX*YKS*nxy
     . )/XKS(N,nxy)
      tt(3,1)=(-COSNXYX*SINNZ*SINHY*ZK*n)/
     . YKC(N,nxy)
      tt(3,2)=(COSNXYY*COSNZ*SINHX*ZK*n)/
     . XKS(N,nxy)

      IF (YKS.EQ.0.D0) THEN
          TT(1,2)=0.D0
          TT(2,2)=0.D0
          TT(3,2)=0.D0
      ENDIF

         T(1,IPAR-1)=TT(1,1)
         T(1,IPAR)  =TT(1,2)
         T(2,IPAR-1)=TT(2,1)
         T(2,IPAR)  =TT(2,2)
         T(3,IPAR-1)=TT(3,1)
         T(3,IPAR)  =TT(3,2)

      ENDDO !NHARM
      ENDDO !NTRANS

      ENDIF !NPAR.GT.3

      RETURN
      END
+DECK,BPOLY2DH.
*CMZ :  2.70/05 02/01/2013  12.22.05  by  Michael Scheer
*CMZ :  2.65/02 28/09/2009  08.44.50  by  Michael Scheer
*CMZ :  2.63/04 11/06/2009  12.20.28  by  Michael Scheer
*CMZ :  2.48/04 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.47/23 17/02/2004  10.07.04  by  Michael Scheer
*CMZ :  2.47/18 26/11/2003  18.23.46  by  Michael Scheer
*CMZ :  2.47/08 08/05/2003  12.49.51  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.41/08 02/08/2002  19.53.38  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  14.39.20  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  17.16.55  by  Michael Scheer
*CMZ :  2.14/02 19/04/2000  17.02.45  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  11.45.40  by  Michael Scheer
*CMZ :  1.03/06 07/08/98  10.05.39  by  Michael Scheer
*CMZ : 00.02/04 12/02/97  11.00.58  by  Michael Scheer
*CMZ : 00.02/03 04/02/97  16.38.06  by  Michael Scheer
*-- Author :    Michael Scheer   22/01/97

      SUBROUTINE BPOLY2DH(XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT)
+seq,gplhint.

C *** ATTENTION: DEFINITION OF COEFFICIENTS DIFFERENT FROM R. WALKER'S

C     MAGNETIC FIELD ACCORDING TO POLYNOMIAL FIT
C     TRANSVERSALLY AND HARMONICS IN LONGITUDINALLY
C
C     INPUT/OUTPUT COORDINATE SYSTEM: X LONG., Y VERTICAL
C     INTERNAL COORDINATE SYSTEM: Z LONG., Y VERTICAL
C
C     UNIT: METER AND TESLA
C

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,BPOLY2DH.

      INTEGER ICAL,LUNIN,IPAR,IHV,NN
      INTEGER N
      DOUBLE PRECISION N2,N4,N6,N8,N10

      DOUBLE PRECISION PI,XOFF
      DOUBLE PRECISION XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT
      DOUBLE PRECISION X,Y,Z,BXX,BYY,BZZ
      DOUBLE PRECISION XX,X2,X3,X4,X5,X6,X7,X8,X9,X10
      DOUBLE PRECISION YY,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,Y10
      DOUBLE PRECISION XX2,XX3,XX4,XX5,XX6,XX7,XX8,XX9,XX10
      DOUBLE PRECISION YY2,YY3,YY4,YY5,YY6,YY7,YY8,YY9,YY10
      DOUBLE PRECISION ZL,ZK,ZK2,ZK4,ZK6,ZK8,ZK10
      DOUBLE PRECISION P(NPAR2DHP,NORD2DHP)
      DOUBLE PRECISION ANS1,ANS2,ANS3,ANS4,ANS5,ANS6,ANS7

      DOUBLE PRECISION SINZKZ(NORD2DHP+1),SSINZKZ(NORD2DHP+1)
      DOUBLE PRECISION COSZKZ(NORD2DHP+1),CCOSZKZ(NORD2DHP+1)

+SELF,IF=-NOCMPLX.
      COMPLEX*16 CZKZ(NORD2DHP+1)
+SELF,IF=NOCMPLX.
      DOUBLE PRECISION CZKZR(NORD2DHP+1)
      DOUBLE PRECISION CZKZI(NORD2DHP+1)
+SELF.

      CHARACTER(64) COMMENT,FILEIN

      DATA ICAL/0/
      DATA PI/3.141592653589793D0/


C--- INITIALIZATION

      LUNIN=LUN2DHFIT
      FILEIN=FILE2DHFIT

      IF (ICAL.EQ.0) THEN

         OPEN(UNIT=LUNIN,FILE=FILEIN,STATUS='OLD')

            READ(LUN2DHFIT,'(A64)')COMMENT
            READ(LUN2DHFIT,*)PERLEN2DH,PHASE2DH,XYZ2DH
            READ(LUN2DHFIT,*)X2DHMIN,X2DHMAX
            READ(LUN2DHFIT,*)Y2DHMIN,Y2DHMAX
            READ(LUN2DHFIT,*)Z2DHMIN,Z2DHMAX
            READ(LUN2DHFIT,*)NORD2DH,NPAR2DH

          NPARTOT=(NORD2DH+1)/2*NPAR2DH*2
          DO IPAR=1,NPARTOT
         READ(LUN2DHFIT,*)PAR2DH(IPAR)
          ENDDO

            WRITE(LUNGFO,*)'     SUBROUTINE BPOLY2DH:'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Fitparameters read from file:'
            WRITE(LUNGFO,*)'     ',FILEIN
            WRITE(LUNGFO,*)

            WRITE(LUNGFO,'(A64)')COMMENT
            WRITE(LUNGFO,*)
     &'     periodlength, phase, and scaling factor:'
            WRITE(LUNGFO,*)
     &'     (PERLEN2DH,PHASE2DH,XYZ2DH)'
            WRITE(LUNGFO,*)'     ',PERLEN2DH
            WRITE(LUNGFO,*)'     ',PHASE2DH
            WRITE(LUNGFO,*)'     ',XYZ2DH
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     X2DHMIN,X2DHMAX:',X2DHMIN,X2DHMAX
            WRITE(LUNGFO,*)'     Y2DHMIN,Y2DHMAX:',Y2DHMIN,Y2DHMAX
            WRITE(LUNGFO,*)'     Z2DHMIN,Z2DHMAX:',Z2DHMIN,Z2DHMAX
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     NORD2DH:',NORD2DH
            WRITE(LUNGFO,*)

          DO IPAR=1,NPARTOT
         WRITE(LUNGFO,*)PAR2DH(IPAR)
          ENDDO

          IF (NPAR2DH.GT.NPAR2DHP) THEN
         WRITE(LUNGFO,*)
     &'*** ERROR IN BPOLY2DH: DIMENSION NPAR2DHP IN BPOLY2DH.CMN EXCEEDED  ***'
         WRITE(LUNGFO,*)
         WRITE(6,*)
     &'*** ERROR IN BPOLY2DH: DIMENSION NPAR2DHP IN BPOLY2DH.CMN EXCEEDED  ***'
         WRITE(6,*)
         WRITE(6,*) '--- PROGRAM ABORTED DUE TO ERROR ---'
         STOP
          ENDIF

          IF (NORD2DH.GT.NORD2DHP) THEN
         WRITE(LUNGFO,*)
     &'*** ERROR IN BPOLY2DH: DIMENSION NORD2DHP IN BPOLY2DH.CMN EXCEEDED  ***'
         WRITE(LUNGFO,*)
         WRITE(6,*)
     &'*** ERROR IN BPOLY2DH: DIMENSION NORD2DHP IN BPOLY2DH.CMN EXCEEDED  ***'
         WRITE(6,*)
         WRITE(6,*) '--- PROGRAM ABORTED DUE TO ERROR ---'
         STOP
          ENDIF

         CLOSE(LUNIN)

      XOFF=PHASE2DH*PERLEN2DH
      ZL=PERLEN2DH*XYZ2DH

         ZK=2.D0*PI/ZL
         ZK2=ZK*ZK
         ZK4=ZK2*ZK2
         ZK6=ZK4*ZK2
         ZK8=ZK6*ZK2
         ZK10=ZK8*ZK2

         AXOUT=0.D0
         AYOUT=0.D0
         AZOUT=0.D0

         ICAL=1

      ENDIF !ICAL

C --- CHANGE COORDINATE SYSTEMS

      XX=-ZIN*XYZ2DH
      YY=YIN*XYZ2DH
      Z =(XIN+XOFF)*XYZ2DH

      XX2=XX*XX
      XX3=XX2*XX
      XX4=XX3*XX
      XX5=XX4*XX
      XX6=XX5*XX
      XX7=XX6*XX
      XX8=XX7*XX
      XX9=XX8*XX
      XX10=XX9*XX

      YY2=YY*YY
      YY3=YY2*YY
      YY4=YY3*YY
      YY5=YY4*YY
      YY6=YY5*YY
      YY7=YY6*YY
      YY8=YY7*YY
      YY9=YY8*YY
      YY10=YY9*YY

C--- MAGNETIC FIELD

+SELF,IF=-NOCMPLX.
      CZKZ(1)=CDEXP(DCMPLX(0.D0,ZK*Z))
      CZKZ(2)=CZKZ(1)*CZKZ(1)
      DO N=3,NORD2DH,2
            CZKZ(N)=CZKZ(N-2)*CZKZ(2)
      ENDDO !NORD2H

      DO N=1,NORD2DH,2
          SSINZKZ(N)=DIMAG(CZKZ(N))
          CCOSZKZ(N)=DREAL(CZKZ(N))
      ENDDO

+SELF,IF=NOCMPLX.
        WRITE(6,*)'CHECK +SELF,NOCMPLX'

      CZKZR(1)=COS(ZK*Z)
      CZKZI(1)=SIN(ZK*Z)
      CZKZR(2)=CZKZR(1)*CZKZR(1)-CZKZI(1)*CZKZI(1)
      CZKZI(2)=CZKZI(1)*CZKZR(1)+CZKZI(1)*CZKZR(1)
      DO N=3,NORD2DH,2
              CZKZR(N)=CZKZR(N-2)*CZKZR(2)-CZKZI(N-2)*CZKZI(2)
              CZKZI(N)=CZKZI(N-2)*CZKZR(2)+CZKZR(N-2)*CZKZI(2)
      ENDDO !NORD2H

      DO N=1,NORD2DH,2
          SSINZKZ(N)=CZKZI(N)
          CCOSZKZ(N)=CZKZR(N)
      ENDDO
+SELF.

      BXOUT=0.D0
      BYOUT=0.D0
      BZOUT=0.D0

      IPAR=0
      DO IHV=1,2

          IF (IHV.EQ.1) THEN

         X=XX
         X2=XX2
         X3=XX3
         X4=XX4
         X5=XX5
         X6=XX6
         X7=XX7
         X8=XX8
         X9=XX9
         X10=XX10

         Y=YY
         Y2=YY2
         Y3=YY3
         Y4=YY4
         Y5=YY5
         Y6=YY6
         Y7=YY7
         Y8=YY8
         Y9=YY9
         Y10=YY10

         DO N=1,NORD2DH,2
            sinzkz(N)=SSINZKZ(N)
            coszkz(N)=CCOSZKZ(N)
         ENDDO !N
          ELSE

         Y=XX
         Y2=XX2
         Y3=XX3
         Y4=XX4
         Y5=XX5
         Y6=XX6
         Y7=XX7
         Y8=XX8
         Y9=XX9
         Y10=XX10

         X=YY
         X2=YY2
         X3=YY3
         X4=YY4
         X5=YY5
         X6=YY6
         X7=YY7
         X7=YY7
         X8=YY8
         X9=YY9
         X10=YY10

C ACHTUNG VORZEICHENWECHSEL IN PARAMETERN WG ABLEITUNGEN VON SIN - COS !?
         DO N=1,NORD2DH,2
            sinzkz(N)=CCOSZKZ(N)
            coszkz(N)=SSINZKZ(N)
         ENDDO !N
          ENDIF

      DO N=1,NORD2DH,2

         N2=N*N
         N4=N2*N2
         N6=N4*N2
         N8=N6*N2
         N10=N8*N2

      DO NN=1,NPAR2DHP
          IPAR=IPAR+1
          P(NN,N)=PAR2DH(IPAR)
      ENDDO

+SELF,IF=-WINDOWS
c         INCLUDE 'red:poly2dh_bfeld.for'
      ans6=-0.00208333333333d0*p(2,n)*ZK6*n6*y8+0.116666666667d0*p
     . (2,n)*ZK4*n4*x6-0.116666666667d0*p(2,n)*ZK4*n4*y6+
     . 3.5*p(2,n)*ZK2*n2*x4-3.5*p(2,n)*ZK2*n2*y4+42.0*p
     . (2,n)*x2-42.0*p(2,n)*y2-0.0000115740740741d0*p(1,n)*ZK
     . 10*n10*x10-0.00104166666667d0*p(1,n)*ZK8*n8*x8-
     . 0.0583333333333d0*p(1,n)*ZK6*n6*x6-1.75*p(1,n)*ZK4*n
     . 4*x4-21.0*p(1,n)*ZK2*n2*x2-42.0*p(1,n)
      ans5=p(6,n)*x10-45.0*p(6,n)*x8*y2+210.0*p(6,n)*x6
     . *y4-210.0*p(6,n)*x4*y6+45.0*p(6,n)*x2*y8-p(6,n
     . )*y10-0.1*p(5,n)*ZK2*n2*x10+3.0*p(5,n)*ZK2*n2*x
     . 8*y2-7.0*p(5,n)*ZK2*n2*x6*y4+1.5*p(5,n)*ZK2*n
     . 2*x2*y8-0.0666666666667d0*p(5,n)*ZK2*n2*y10-3.0*p(
     . 5,n)*x8+84.0*p(5,n)*x6*y2-210.0*p(5,n)*x4*y4+
     . 84.0*p(5,n)*x2*y6-3.0*p(5,n)*y8+0.000555555555556d0*p(
     . 3,n)*ZK6*n6*x10-0.00625*p(3,n)*ZK6*n6*x8*y2+
     . 0.000138888888889d0*p(3,n)*ZK6*n6*y10+0.0375*p(3,n)*ZK
     . 4*n4*x8-0.35*p(3,n)*ZK4*n4*x6*y2+0.0125*p(3,n)*
     . ZK4*n4*y8+1.4*p(3,n)*ZK2*n2*x6-10.5*p(3,n)*ZK2*
     . n2*x4*y2+0.7*p(3,n)*ZK2*n2*y6+21.0*p(3,n)*x4-
     . 126.0*p(3,n)*x2*y2+21.0*p(3,n)*y4+0.0000231481481481d0
     . *p(2,n)*ZK8*n8*x10-0.0000231481481481d0*p(2,n)*ZK8*n
     . 8*y10+0.00208333333333d0*p(2,n)*ZK6*n6*x8+ans6
      ans4=0.0238095238095d0*ans5
      ans3=-ans4
      ans2=0.00000027557319224d0*(25920.0*(ZK2*n2*x2+ZK2*n2*y
     . 2+28.0)*(x2+4.0*x*y+y2)*(x2-4.0*x*y+y2)+432.0*(x8-
     . 14.0*x6*y2-14.0*x4*y4-14.0*x2*y6+y8)*ZK4*n4)*
     . (x+y)*(x-y)*p(4,n)+ans3
      ans7=COSZKz(n)
      ans1=ans2*ans7
      bxx=-ans1
      byy=(0.015873015873d0*(ZK2*n2*x2+ZK2*n2*y2+36.0)*(x2+
     . 2.0*x*y-y2)*(x2-2.0*x*y-y2)*(x+y)*(x-y)*p(5,n)-
     . 0.238095238095d0*(x4-2.0*x2*y2+0.2*y4)*(x4-10.0*x2*y
     . 2+5.0*y4)*p(6,n)-0.0000055114638448d0*(ZK8*n8*y8+72.0
     . *ZK6*n6*y6+3024.0*ZK4*n4*y4+60480.0*ZK2*n2*y2+
     . 3.6288e+5)*p(2,n)-0.0000055114638448d0*(432.0*(ZK4*n4*x4+
     . ZK4*n4*x2*y2+ZK4*n4*y4+42.0*ZK2*n2*x2+42.0*ZK
     . 2*n2*y2+840.0)+6.0*(x4+y4)*(x2+y2)*ZK6*n6)*(x
     . +y)*(x-y)*p(3,n)+0.0000055114638448d0*(5184.0*(x6-7.0*x2*y
     . 4+2.0*y6)*ZK2*n2+2.17728e+5*(x2-0.333333333333d0*y2)*
     . (x2-3.0*y2)+72.0*(x8-12.0*x2*y6+3.0*y8)*ZK4*n4)
     . *p(4,n))*COSZKz(n)*x*y
      ans5=231.0*p(3,n)*y4+0.0000231481481481d0*p(2,n)*ZK8*n8*
     . x10-0.00025462962963d0*p(2,n)*ZK8*n8*y10+
     . 0.0025462962963d0*p(2,n)*ZK6*n6*x8-0.0229166666667d0*p(2,
     . n)*ZK6*n6*y8+0.183333333333d0*p(2,n)*ZK4*n4*x6-
     . 1.28333333333d0*p(2,n)*ZK4*n4*y6+7.7*p(2,n)*ZK2*n2*x
     . 4-38.5*p(2,n)*ZK2*n2*y4+154.0*p(2,n)*x2-462.0*p(
     . 2,n)*y2-0.0000115740740741d0*p(1,n)*ZK10*n10*x10-
     . 0.00127314814815d0*p(1,n)*ZK8*n8*x8-0.0916666666667d0*
     &  p(1,n)*ZK6*n6*x6-3.85*p(1,n)*ZK4*n4*x4-77.0*p(1,n)*
     . ZK2*n2*x2-462.0*p(1,n)
      ans4=p(6,n)*x10-55.0*p(6,n)*x8*y2+330.0*p(6,n)*x6
     . *y4-462.0*p(6,n)*x4*y6+165.0*p(6,n)*x2*y8-11.0*p
     . (6,n)*y10-0.005*p(4,n)*ZK4*n4*x10+0.0916666666667d0*p
     . (4,n)*ZK4*n4*x8*y2-0.275*p(4,n)*ZK4*n4*x2*y8
     . +0.055*p(4,n)*ZK4*n4*y10-0.366666666667d0*p(4,n)*ZK2*n
     . 2*x8+6.6*p(4,n)*ZK2*n2*x6*y2-15.4*p(4,n)*ZK2*n
     . 2*x2*y6+3.3*p(4,n)*ZK2*n2*y8-13.2*p(4,n)*x6+
     . 277.2*p(4,n)*x4*y2-462.0*p(4,n)*x2*y4+92.4*p(4,n
     . )*y6+0.000555555555556d0*p(3,n)*ZK6*n6*x10-
     . 0.00763888888889d0*p(3,n)*ZK6*n6*x8*y2+0.00152777777778d0
     . *p(3,n)*ZK6*n6*y10+0.0458333333333d0*p(3,n)*ZK4*n4*x
     . 8-0.55*p(3,n)*ZK4*n4*x6*y2+0.1375*p(3,n)*ZK4*n
     . 4*y8+2.2*p(3,n)*ZK2*n2*x6-23.1*p(3,n)*ZK2*n2*x
     . 4*y2+7.7*p(3,n)*ZK2*n2*y6+46.2*p(3,n)*x4-462.0*p(
     . 3,n)*x2*y2+ans5
      ans3=0.0021645021645d0*ans4
      ans2=-ans3
      ans1=0.0000000250521083854d0*(8640.0*(x10-36.6666666667d0*x8*y
     . 2+110.0*x6*y4-55.0*x2*y8+7.33333333333d0*y10)*ZK2*n
     . 2+3.168e+5*(x6-33.0*x4*y2+27.0*x2*y4-3.0*y6)*(x
     . 2-3.0*y2))*p(5,n)+ans2
      ans6=SINZKz(n)*ZK*n*x
      bzz=ans1*ans6
+SELF,IF=WINDOWS.
C         INCLUDE 'C:\local\wav\POLY2DH_BFELD.FOR'
      ans6=-0.00208333333333*p(2,n)*ZK6*n6*y8+0.116666666667*p
     . (2,n)*ZK4*n4*x6-0.116666666667*p(2,n)*ZK4*n4*y6+
     . 3.5*p(2,n)*ZK2*n2*x4-3.5*p(2,n)*ZK2*n2*y4+42.0*p
     . (2,n)*x2-42.0*p(2,n)*y2-0.0000115740740741*p(1,n)*ZK
     . 10*n10*x10-0.00104166666667*p(1,n)*ZK8*n8*x8-
     . 0.0583333333333*p(1,n)*ZK6*n6*x6-1.75*p(1,n)*ZK4*n
     . 4*x4-21.0*p(1,n)*ZK2*n2*x2-42.0*p(1,n)
      ans5=p(6,n)*x10-45.0*p(6,n)*x8*y2+210.0*p(6,n)*x6
     . *y4-210.0*p(6,n)*x4*y6+45.0*p(6,n)*x2*y8-p(6,n
     . )*y10-0.1*p(5,n)*ZK2*n2*x10+3.0*p(5,n)*ZK2*n2*x
     . 8*y2-7.0*p(5,n)*ZK2*n2*x6*y4+1.5*p(5,n)*ZK2*n
     . 2*x2*y8-0.0666666666667*p(5,n)*ZK2*n2*y10-3.0*p(
     . 5,n)*x8+84.0*p(5,n)*x6*y2-210.0*p(5,n)*x4*y4+
     . 84.0*p(5,n)*x2*y6-3.0*p(5,n)*y8+0.000555555555556*p(
     . 3,n)*ZK6*n6*x10-0.00625*p(3,n)*ZK6*n6*x8*y2+
     . 0.000138888888889*p(3,n)*ZK6*n6*y10+0.0375*p(3,n)*ZK
     . 4*n4*x8-0.35*p(3,n)*ZK4*n4*x6*y2+0.0125*p(3,n)*
     . ZK4*n4*y8+1.4*p(3,n)*ZK2*n2*x6-10.5*p(3,n)*ZK2*
     . n2*x4*y2+0.7*p(3,n)*ZK2*n2*y6+21.0*p(3,n)*x4-
     . 126.0*p(3,n)*x2*y2+21.0*p(3,n)*y4+0.0000231481481481
     . *p(2,n)*ZK8*n8*x10-0.0000231481481481*p(2,n)*ZK8*n
     . 8*y10+0.00208333333333*p(2,n)*ZK6*n6*x8+ans6
      ans4=0.0238095238095*ans5
      ans3=-ans4
      ans2=0.00000027557319224*(25920.0*(ZK2*n2*x2+ZK2*n2*y
     . 2+28.0)*(x2+4.0*x*y+y2)*(x2-4.0*x*y+y2)+432.0*(x8-
     . 14.0*x6*y2-14.0*x4*y4-14.0*x2*y6+y8)*ZK4*n4)*
     . (x+y)*(x-y)*p(4,n)+ans3
      ans7=COSZKz(n)
      ans1=ans2*ans7
      bxx=-ans1
      byy=(0.015873015873*(ZK2*n2*x2+ZK2*n2*y2+36.0)*(x2+
     . 2.0*x*y-y2)*(x2-2.0*x*y-y2)*(x+y)*(x-y)*p(5,n)-
     . 0.238095238095*(x4-2.0*x2*y2+0.2*y4)*(x4-10.0*x2*y
     . 2+5.0*y4)*p(6,n)-0.0000055114638448*(ZK8*n8*y8+72.0
     . *ZK6*n6*y6+3024.0*ZK4*n4*y4+60480.0*ZK2*n2*y2+
     . 3.6288e+5)*p(2,n)-0.0000055114638448*(432.0*(ZK4*n4*x4+
     . ZK4*n4*x2*y2+ZK4*n4*y4+42.0*ZK2*n2*x2+42.0*ZK
     . 2*n2*y2+840.0)+6.0*(x4+y4)*(x2+y2)*ZK6*n6)*(x
     . +y)*(x-y)*p(3,n)+0.0000055114638448*(5184.0*(x6-7.0*x2*y
     . 4+2.0*y6)*ZK2*n2+2.17728e+5*(x2-0.333333333333*y2)*
     . (x2-3.0*y2)+72.0*(x8-12.0*x2*y6+3.0*y8)*ZK4*n4)
     . *p(4,n))*COSZKz(n)*x*y
      ans5=231.0*p(3,n)*y4+0.0000231481481481*p(2,n)*ZK8*n8*
     . x10-0.00025462962963*p(2,n)*ZK8*n8*y10+
     . 0.0025462962963*p(2,n)*ZK6*n6*x8-0.0229166666667*p(2,
     . n)*ZK6*n6*y8+0.183333333333*p(2,n)*ZK4*n4*x6-
     . 1.28333333333*p(2,n)*ZK4*n4*y6+7.7*p(2,n)*ZK2*n2*x
     . 4-38.5*p(2,n)*ZK2*n2*y4+154.0*p(2,n)*x2-462.0*p(
     . 2,n)*y2-0.0000115740740741*p(1,n)*ZK10*n10*x10-
     . 0.00127314814815*p(1,n)*ZK8*n8*x8-0.0916666666667*p(1.0
     . ,n)*ZK6*n6*x6-3.85*p(1,n)*ZK4*n4*x4-77.0*p(1,n)*
     . ZK2*n2*x2-462.0*p(1,n)
      ans4=p(6,n)*x10-55.0*p(6,n)*x8*y2+330.0*p(6,n)*x6
     . *y4-462.0*p(6,n)*x4*y6+165.0*p(6,n)*x2*y8-11.0*p
     . (6,n)*y10-0.005*p(4,n)*ZK4*n4*x10+0.0916666666667*p
     . (4,n)*ZK4*n4*x8*y2-0.275*p(4,n)*ZK4*n4*x2*y8
     . +0.055*p(4,n)*ZK4*n4*y10-0.366666666667*p(4,n)*ZK2*n
     . 2*x8+6.6*p(4,n)*ZK2*n2*x6*y2-15.4*p(4,n)*ZK2*n
     . 2*x2*y6+3.3*p(4,n)*ZK2*n2*y8-13.2*p(4,n)*x6+
     . 277.2*p(4,n)*x4*y2-462.0*p(4,n)*x2*y4+92.4*p(4,n
     . )*y6+0.000555555555556*p(3,n)*ZK6*n6*x10-
     . 0.00763888888889*p(3,n)*ZK6*n6*x8*y2+0.00152777777778
     . *p(3,n)*ZK6*n6*y10+0.0458333333333*p(3,n)*ZK4*n4*x
     . 8-0.55*p(3,n)*ZK4*n4*x6*y2+0.1375*p(3,n)*ZK4*n
     . 4*y8+2.2*p(3,n)*ZK2*n2*x6-23.1*p(3,n)*ZK2*n2*x
     . 4*y2+7.7*p(3,n)*ZK2*n2*y6+46.2*p(3,n)*x4-462.0*p(
     . 3,n)*x2*y2+ans5
      ans3=0.0021645021645*ans4
      ans2=-ans3
      ans1=0.0000000250521083854*(8640.0*(x10-36.6666666667*x8*y
     . 2+110.0*x6*y4-55.0*x2*y8+7.33333333333*y10)*ZK2*n
     . 2+3.168e+5*(x6-33.0*x4*y2+27.0*x2*y4-3.0*y6)*(x
     . 2-3.0*y2))*p(5,n)+ans2
      ans6=SINZKz(n)*ZK*n*x
      bzz=ans1*ans6

+self.

C --- CHANGE COORDINATE SYSTEMS

          IF (IHV.EQ.1) THEN
             BXOUT=BXOUT+BZZ
             BYOUT=BYOUT+BYY
             BZOUT=BZOUT-BXX
          ELSE
             BZZ=-BZZ
             BXOUT=BXOUT+BZZ
             BYOUT=BYOUT+BXX
             BZOUT=BZOUT-BYY
          ENDIF

      ENDDO !NORD2DH
      ENDDO !IHV

      RETURN
      END
+DECK,BPOLY2DHFIT.
*CMZ :  4.00/14 22/12/2021  16.40.21  by  Michael Scheer
*CMZ :  4.00/04 23/08/2019  15.47.38  by  Michael Scheer
*CMZ :  3.05/10 13/08/2018  14.40.26  by  Michael Scheer
*CMZ :  3.02/03 23/10/2014  13.43.13  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  10.40.59  by  Michael Scheer
*CMZ :  2.68/05 28/09/2012  11.54.30  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  09.55.57  by  Michael Scheer
*CMZ :  2.48/04 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.42/04 28/10/2002  16.57.50  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.16/08 29/10/2000  17.42.22  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  13.48.28  by  Michael Scheer
*CMZ :  1.00/00 24/09/97  10.31.28  by  Michael Scheer
*CMZ : 00.02/04 11/02/97  11.55.40  by  Michael Scheer
*CMZ : 00.02/03 31/01/97  15.06.26  by  Michael Scheer
*CMZ :          22/01/97  11.27.20  by  Michael Scheer
*-- Author :    Michael Scheer   22/01/97

      SUBROUTINE BPOLY2DHFIT
+seq,gplhint.

+SEQ,BPOLY2DHF90U,IF=F90.

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,CMPARA.
+SEQ,MYFILES.
+SEQ,BPOLY2DH.
+seq,whbook.
+seq,pawcmn.

      INTEGER IPOI,IFAIL,IX,IPAR
      INTEGER MPOI,IREAD
      INTEGER N2DHPOIX,N2DHPOIY,N2DHPOIZ,N2DHPOI

+SELF,IF=-F90.
      DOUBLE PRECISION X(N2DHPOIP),Y(N2DHPOIP),Z(N2DHPOIP)
     &                  ,BX(N2DHPOIP),BY(N2DHPOIP),BZ(N2DHPOIP)
     &                  ,BXF(N2DHPOIP),BYF(N2DHPOIP),BZF(N2DHPOIP)
+SELF.

      DOUBLE PRECISION
     &                   RESBX,RESBY,RESBZ,RESB
     &                  ,BXAMEAN,BYAMEAN,BZAMEAN,BAMEAN
     &                  ,BERRMX(8),BXERRMX(8),BYERRMX(8),BZERRMX(8)
     &                  ,XX,YY,ZZ,BBX,BBY,BBZ,AX,AY,AZ

      DOUBLE PRECISION XOFF

      INTEGER NTUP_P,ICYCLE
        PARAMETER (NTUP_P=9)
        REAL*8 TUP_D(NTUP_P)
        CHARACTER(3) CHTAGS_D(NTUP_P)
      data chtags_d/'x','y','z','bx','by','bz','bxf','byf','bzf'/

      NPAR2DH=NPAR2DHP
      NPARTOT=(NORD2DH+1)/2*NPAR2DHP*2
      IF (NORD2DH.GT.NORD2DHP) THEN
          WRITE(6,*) '*** ERROR IN BPOLY2DHFIT: DIMENSION NORD2DHP EXCEEDED'
          STOP
      ENDIF

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SUBROUTINE BPOLY2DHFIT:'
      WRITE(LUNGFO,*)'     ======================'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Period length and long. shift:'
     &                 , SNGL(PERLEN2DH),SNGL(PHASE2DH)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     field map read from file:'
      WRITE(LUNGFO,*)'     ',FILEBMAP
      WRITE(LUNGFO,*)

C--- READ FIELD MAP {

      XOFF=PERLEN2DH*PHASE2DH
      PERLEN2DH=PERLEN2DH*XYZ2DH

      N2DHPOIX=0
      N2DHPOIY=0
      N2DHPOIZ=0
      MPOI=0
      IREAD=0

      OPEN(UNIT=LUNBMAP,FILE=FILEBMAP,STATUS='OLD')

100       CONTINUE
          IF (IWBPOLY2DH.EQ.1) THEN
             READ(LUNBMAP,*,END=90)XX
             READ(LUNBMAP,*)YY
             READ(LUNBMAP,*)ZZ
             READ(LUNBMAP,*)BBX
             READ(LUNBMAP,*)BBY
             READ(LUNBMAP,*)BBZ
             READ(LUNBMAP,*)
          ELSEIF (IWBPOLY2DH.EQ.2) THEN
             READ(LUNBMAP,*,END=90)XX,YY,ZZ,BBX,BBY,BBZ
          ELSE
         WRITE(6,*) '*** ERROR IN BPOLY2DHFIT: FLAG IWBPOLY2DH WRONG, CHECK INPUT'
         STOP
          ENDIF
          IREAD=IREAD+1
          IF (X2DHMIN.NE.9999.AND.XX.LT.X2DHMIN) GOTO 100
          IF (X2DHMAX.NE.9999.AND.XX.GT.X2DHMAX) GOTO 100
          IF (Y2DHMIN.NE.9999.AND.YY.LT.Y2DHMIN) GOTO 100
          IF (Y2DHMAX.NE.9999.AND.YY.GT.Y2DHMAX) GOTO 100
          IF (Z2DHMIN.NE.9999.AND.ZZ.LT.Z2DHMIN) GOTO 100
          IF (Z2DHMAX.NE.9999.AND.ZZ.GT.Z2DHMAX) GOTO 100
          IF (BBX.EQ.-9999..AND.BBY.EQ.-9999..AND.BBZ.EQ.-9999.) GOTO 100
          MPOI=MPOI+1
+SELF,IF=-F90.
          IF (MPOI.GT.N2DHPOIP) THEN
         WRITE(6,*) '*** ERROR IN BPOLY2DHFIT: DIMENSION N2DHPOIP EXCEEDED ***'
         STOP
          ENDIF
+SELF.
          IF (BBX.NE.-9999.) N2DHPOIX=N2DHPOIX+1
          IF (BBY.NE.-9999.) N2DHPOIY=N2DHPOIY+1
          IF (BBZ.NE.-9999.) N2DHPOIZ=N2DHPOIZ+1
          GOTO 100
90    CLOSE(LUNBMAP)

+SELF,IF=F90.
      ALLOCATE(X(MPOI))
      ALLOCATE(Y(MPOI))
      ALLOCATE(Z(MPOI))
      ALLOCATE(BX(MPOI))
      ALLOCATE(BY(MPOI))
      ALLOCATE(BZ(MPOI))
      ALLOCATE(BXF(MPOI))
      ALLOCATE(BYF(MPOI))
      ALLOCATE(BZF(MPOI))
+SELF.

      N2DHPOIX=0
      N2DHPOIY=0
      N2DHPOIZ=0
      MPOI=0
      IREAD=0

      OPEN(UNIT=LUNBMAP,FILE=FILEBMAP,STATUS='OLD')

101       CONTINUE
          IF (IWBPOLY2DH.EQ.1) THEN
             READ(LUNBMAP,*,END=91)XX
             READ(LUNBMAP,*)YY
             READ(LUNBMAP,*)ZZ
             READ(LUNBMAP,*)BBX
             READ(LUNBMAP,*)BBY
             READ(LUNBMAP,*)BBZ
             READ(LUNBMAP,*)
          ELSEIF (IWBPOLY2DH.EQ.2) THEN
             READ(LUNBMAP,*,END=91)XX,YY,ZZ,BBX,BBY,BBZ
          ELSE
         WRITE(6,*) '*** ERROR IN BPOLY2DHFIT: FLAG IWBPOLY2DH WRONG, CHECK INPUT'
         STOP
          ENDIF
          IREAD=IREAD+1
          IF (X2DHMIN.NE.9999.AND.XX.LT.X2DHMIN) GOTO 101
          IF (X2DHMAX.NE.9999.AND.XX.GT.X2DHMAX) GOTO 101
          IF (Y2DHMIN.NE.9999.AND.YY.LT.Y2DHMIN) GOTO 101
          IF (Y2DHMAX.NE.9999.AND.YY.GT.Y2DHMAX) GOTO 101
          IF (Z2DHMIN.NE.9999.AND.ZZ.LT.Z2DHMIN) GOTO 101
          IF (Z2DHMAX.NE.9999.AND.ZZ.GT.Z2DHMAX) GOTO 101
          IF (BBX.EQ.-9999..AND.BBY.EQ.-9999..AND.BBZ.EQ.-9999.) GOTO 101
          MPOI=MPOI+1
          IF (BBX.NE.-9999.) N2DHPOIX=N2DHPOIX+1
          IF (BBY.NE.-9999.) N2DHPOIY=N2DHPOIY+1
          IF (BBZ.NE.-9999.) N2DHPOIZ=N2DHPOIZ+1
          X(MPOI)=(XX+XOFF)*XYZ2DH
          Y(MPOI)=YY*XYZ2DH
          Z(MPOI)=ZZ*XYZ2DH
          BX(MPOI)=BBX
          BY(MPOI)=BBY
          BZ(MPOI)=BBZ
          GOTO 101
91    CLOSE(LUNBMAP)

      N2DHPOI=MPOI

      WRITE(LUNGFO,*)'     number of data points read:      ',IREAD
      WRITE(LUNGFO,*)'     number of data points accepted:  ',MPOI
      WRITE(LUNGFO,*)'     number of Bx, By, Bz .ne. -9999.:'
     &                      ,N2DHPOIX,N2DHPOIY,N2DHPOIZ
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     fitted coefficients are written to file:'
      WRITE(LUNGFO,*)'     ',FILE2DHFIT
      WRITE(LUNGFO,*)

C--- READ FIELD MAP }

+SELF,IF=-F90.
      CALL VPOT2DH(MPOI,X,Y,Z,BX,BY,BZ,IFAIL)
+SELF,IF=F90.
      CALL VPOT2DH(MPOI,IFAIL)
+SELF.
      IF (IFAIL.NE.0) THEN
          WRITE(6,*) '*** IFAIL NOT ZERO ***'
          STOP
      ENDIF

      DO IPOI=1,MPOI
          X(IPOI)=X(IPOI)-XOFF*XYZ2DH
      ENDDO

      IF (X2DHMIN.EQ.9999.) THEN
          X2DHMIN=1.D30
          DO IPOI=1,MPOI
         IF (X(IPOI).LT.X2DHMIN) X2DHMIN=X(IPOI)
          ENDDO
          X2DHMIN=X2DHMIN/XYZ2DH
      ENDIF

      IF (X2DHMAX.EQ.9999.) THEN
          X2DHMAX=-1.D30
          DO IPOI=1,MPOI
         IF (X(IPOI).GT.X2DHMAX) X2DHMAX=X(IPOI)
          ENDDO
          X2DHMAX=X2DHMAX/XYZ2DH
      ENDIF

      IF (Y2DHMIN.EQ.9999.) THEN
          Y2DHMIN=1.D30
          DO IPOI=1,MPOI
         IF (Y(IPOI).LT.Y2DHMIN) Y2DHMIN=Y(IPOI)
          ENDDO
          Y2DHMIN=Y2DHMIN/XYZ2DH
      ENDIF

      IF (Y2DHMAX.EQ.9999.) THEN
          Y2DHMAX=-1.D30
          DO IPOI=1,MPOI
         IF (Y(IPOI).GT.Y2DHMAX) Y2DHMAX=Y(IPOI)
          ENDDO
          Y2DHMAX=Y2DHMAX/XYZ2DH
      ENDIF

      IF (Z2DHMIN.EQ.9999.) THEN
          Z2DHMIN=1.D30
          DO IPOI=1,MPOI
         IF (Z(IPOI).LT.Z2DHMIN) Z2DHMIN=Z(IPOI)
          ENDDO
          Z2DHMIN=Z2DHMIN/XYZ2DH
      ENDIF

      IF (Z2DHMAX.EQ.9999.) THEN
          Z2DHMAX=-1.D30
          DO IPOI=1,MPOI
         IF (Z(IPOI).GT.Z2DHMAX) Z2DHMAX=Z(IPOI)
          ENDDO
          Z2DHMAX=Z2DHMAX/XYZ2DH
      ENDIF

          PERLEN2DH=PERLEN2DH/XYZ2DH

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Considered range in x, y, and z:'
      WRITE(LUNGFO,*)'     ',X2DHMIN,X2DHMAX
      WRITE(LUNGFO,*)'     ',Y2DHMIN,Y2DHMAX
      WRITE(LUNGFO,*)'     ',Z2DHMIN,Z2DHMAX
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Harmonical order of fit:',NORD2DH
      WRITE(LUNGFO,*)

      OPEN(UNIT=LUN2DHFIT,FILE=FILE2DHFIT,STATUS='NEW')
          WRITE(LUN2DHFIT,'(I5,1H ,A64)')ICODE,CODE
          WRITE(LUN2DHFIT,*)PERLEN2DH,PHASE2DH,XYZ2DH
          WRITE(LUN2DHFIT,*)X2DHMIN,X2DHMAX
          WRITE(LUN2DHFIT,*)Y2DHMIN,Y2DHMAX
          WRITE(LUN2DHFIT,*)Z2DHMIN,Z2DHMAX
          WRITE(LUN2DHFIT,*)NORD2DH,NPAR2DH
          DO IPAR=1,NPARTOT
         WRITE(LUN2DHFIT,*) PAR2DH(IPAR)
          ENDDO
      CLOSE(LUN2DHFIT)

      IF (IHBPOLY2DH.NE.0) THEN
+self,if=-mhbook.
      CALL hbookm(NIDBPOLY,'BPOLY2DH FIT$',NTUP_P,'//WAVE',1024,CHTAGS_D)
+self,if=mhbook.
      CALL hbookm(NIDBPOLY,'BPOLY2DH FIT$',NTUP_P,'//WAVE',mpoi,CHTAGS_D)
+self.
      ENDIF

      DO IPOI=1,MPOI

          X(IPOI)=X(IPOI)/XYZ2DH
          Y(IPOI)=Y(IPOI)/XYZ2DH
          Z(IPOI)=Z(IPOI)/XYZ2DH

           CALL BPOLY2DH(X(IPOI),Y(IPOI),Z(IPOI)
     &                ,BXF(IPOI),BYF(IPOI),BZF(IPOI),AX,AY,AZ)

      IF (IHBPOLY2DH.NE.0) THEN
          TUP_D(1)=X(IPOI)
          TUP_D(2)=Y(IPOI)
          TUP_D(3)=Z(IPOI)
          TUP_D(4)=BX(IPOI)
          TUP_D(5)=BY(IPOI)
          TUP_D(6)=BZ(IPOI)
          TUP_D(7)=BXF(IPOI)
          TUP_D(8)=BYF(IPOI)
          TUP_D(9)=BZF(IPOI)
          CALL hfm(NIDBPOLY,TUP_D)
      ENDIF

      ENDDO !IPOI

      CALL BRESI      (MPOI,N2DHPOIX,N2DHPOIY,N2DHPOIZ
     &                  ,X,Y,Z,BX,BY,BZ,BXF,BYF,BZF
     &                  ,RESBX,RESBY,RESBZ,RESB
     &                  ,BXAMEAN,BYAMEAN,BZAMEAN,BAMEAN
     &                  ,BERRMX,BXERRMX,BYERRMX,BZERRMX)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     RESB:',SNGL(RESB)
      WRITE(LUNGFO,*)'     RESBX, RESBY,RESBZ:',SNGL(RESBX),SNGL(RESBY),SNGL(RESBZ)
      WRITE(LUNGFO,*)
      IF (BAMEAN.NE.0.D0)
     &WRITE(LUNGFO,*)'     |B|mean,   RESB/|B|mean: ',SNGL(BAMEAN),SNGL(RESB/BAMEAN)
      IF (BXAMEAN.NE.0.D0)
     &WRITE(LUNGFO,*)'     |BX|mean, RESBX/|BX|mean:',SNGL(BXAMEAN),SNGL(RESBX/BXAMEAN)
      IF (BYAMEAN.NE.0.D0)
     &WRITE(LUNGFO,*)'     |BY|mean, RESBY/|BY|mean:',SNGL(BYAMEAN),SNGL(RESBY/BYAMEAN)
      IF (BZAMEAN.NE.0.D0)
     &WRITE(LUNGFO,*)'     |BZ|mean, RESBZ/|BZ|mean:',SNGL(BZAMEAN),SNGL(RESBZ/BZAMEAN)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     MAXIMUM ERRORS OF B, BX, BY AND BZ:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'  X      Y      Z       BX        BY        BZ       B         ERR'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,'(3F8.4,5(1PE10.2))')(SNGL(BERRMX(IX)),IX=1,8)
      WRITE(LUNGFO,'(3F8.4,5(1PE10.2))')(SNGL(BXERRMX(IX)),IX=1,8)
      WRITE(LUNGFO,'(3F8.4,5(1PE10.2))')(SNGL(BYERRMX(IX)),IX=1,8)
      WRITE(LUNGFO,'(3F8.4,5(1PE10.2))')(SNGL(BZERRMX(IX)),IX=1,8)
      WRITE(LUNGFO,*)

      IF (IHBPOLY2DH.NE.0) THEN
        CALL MHROUT(NIDBPOLY,ICYCLE,' ')
        CALL hdeletm(NIDBPOLY)
      ENDIF

      RETURN
      END
+DECK,BPOLY3D.
*CMZ :  2.16/04 18/09/2013  12.33.23  by  Michael Scheer
*CMZ : 00.02/00 07/11/96  17.02.37  by  Michael Scheer
*CMZ : 00.01/09 25/10/95  17.37.17  by  Michael Scheer
*-- Author :    Michael Scheer   29/09/95

      SUBROUTINE BPOLY3D(XIN,YIN,ZIN,BX,BY,BZ,AX,AY,AZ)
+seq,gplhint.

C--- ALL INDICES ACCORDING TO FORTRAN, BUT LORD3D AND MORD3D REFER TO MATH. INDICES

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,BPOLY3D.

+SELF,IF=OBSOLETE.
      INTEGER IORD
+SELF.
      INTEGER IX,IY,IZ,NPOWP,ICAL
     &         ,IWARNXMN,IWARNXMX,IWARNYMN,IWARNYMX,IWARNZMN,IWARNZMX
     &         ,IBX,IBY,IBZ
     &         ,IND

      DOUBLE PRECISION X,Y,Z,BX,BY,BZ,XPOW1,YPOW1,ZPOW1,AX,AY,AZ
     &                  ,XIN,YIN,ZIN,DLEN,DLEN2

      PARAMETER (NPOWP=NDIMC+1)
      DOUBLE PRECISION XPOW(NPOWP),YPOW(NPOWP),ZPOW(NPOWP)

      DATA ICAL/0/
      DATA IWARNXMN,IWARNXMX,IWARNYMN,IWARNYMX,IWARNZMN,IWARNZMX/6*0/

      IF (ICAL.EQ.0) THEN
          CALL BPOLY3DINI
          DLEN2=2.D0*X3DMAX
          DLEN=2.D0*DLEN2
          ICAL=1
      ENDIF

      IF (MORD3D.GT.NDIMC-1) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN BPOLY3D: DIMENSION NDIMC EXCEEDED ***'
          WRITE(6,*)
          STOP
      ENDIF

      IF (MORD3D.GT.NPOWP) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN BPOLY3D: DIMENSION NPOWP EXCEEDED ***'
          WRITE(6,*)
          STOP
      ENDIF

      X3DMIN=X3DMIN*B3DSCALE
      X3DMAX=X3DMAX*B3DSCALE
      Y3DMIN=Y3DMIN*B3DSCALE
      Y3DMAX=Y3DMAX*B3DSCALE
      Z3DMIN=Z3DMIN*B3DSCALE
      Z3DMAX=Z3DMAX*B3DSCALE

      X=XIN*B3DSCALE
      Y=YIN*B3DSCALE
      Z=ZIN*B3DSCALE

      IBX=1
      IBY=1
      IBZ=1
      IF (I3DQUART.NE.0) THEN

          X=DMOD(X,DLEN)

          IF (X.GT.DLEN2) THEN
         X=X-DLEN
          ELSEIF (X.LT.-DLEN2) THEN
         X=X+DLEN
          ENDIF

          IF(X.LT.0.0D0) THEN
         X=-X
         IBX=-IBX
          ENDIF

          IF(Y.LT.0.0D0) THEN
         Y=-Y
         IBZ=-IBZ
          ENDIF

          IF(Z.LT.0.0) THEN
         Z=-Z
         IBZ=-IBZ
          ENDIF

          IF(X.GT.X3DMAX) THEN
         X=X3DMAX-(X-X3DMAX)
         IBY=-IBY
         IBZ=-IBZ
          ENDIF

          IF(X.LT.0.0D0) THEN
         X=-X
         IBX=-IBX
          ENDIF

      ENDIF !I3DQUART

      IF (IWARNXMN.EQ.0.AND.X.LT.X3DMIN) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING SR BPOLY3D: X OUT OF FIT RANGE'
          WRITE(LUNGFO,*)'X .LT. X3DMIN'
          WRITE(LUNGFO,*)'X, X3DMIN:',X,X3DMIN
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING SR BPOLY3D: X OUT OF FIT RANGE'
          WRITE(6,*)'X .LT. X3DMIN'
          WRITE(6,*)'X, X3DMIN:',X,X3DMIN
          WRITE(6,*)
          IWARNXMN=1
      ENDIF

      IF (IWARNXMX.EQ.0.AND.X.GT.X3DMAX) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING SR BPOLY3D: X OUT OF FIT RANGE'
          WRITE(LUNGFO,*)'X .GT. X3DMAX'
          WRITE(LUNGFO,*)'X, X3DMAX:',X,X3DMAX
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING SR BPOLY3D: X OUT OF FIT RANGE'
          WRITE(6,*)'X .GT. X3DMAX'
          WRITE(6,*)'X, X3DMAX:',X,X3DMAX
          WRITE(6,*)
          IWARNXMX=1
      ENDIF

      IF (IWARNYMN.EQ.0.AND.Y.LT.Y3DMIN) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING SR BPOLY3D: Y OUT OF FIT RANGE'
          WRITE(LUNGFO,*)'Y .LT. Y3DMIN'
          WRITE(LUNGFO,*)'Y, Y3DMIN:',Y,Y3DMIN
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING SR BPOLY3D: Y OUT OF FIT RANGE'
          WRITE(6,*)'Y .LT. Y3DMIN'
          WRITE(6,*)'Y, Y3DMIN:',Y,Y3DMIN
          WRITE(6,*)
          IWARNYMN=1
      ENDIF

      IF (IWARNYMX.EQ.0.AND.Y.GT.Y3DMAX) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING SR BPOLY3D: Y OUT OF FIT RANGE'
          WRITE(LUNGFO,*)'Y .GT. Y3DMAX'
          WRITE(LUNGFO,*)'Y, Y3DMAX:',Y,Y3DMAX
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING SR BPOLY3D: Y OUT OF FIT RANGE'
          WRITE(6,*)'Y .GT. Y3DMAX'
          WRITE(6,*)'Y, Y3DMAX:',Y,Y3DMAX
          WRITE(6,*)
          IWARNYMX=1
      ENDIF

      IF (IWARNZMN.EQ.0.AND.Z.LT.Z3DMIN) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING SR BPOLY3D: Z OUT OF FIT RANGE'
          WRITE(LUNGFO,*)'Z .LT. Z3DMIN'
          WRITE(LUNGFO,*)'Z, Z3DMIN:',Z,Z3DMIN
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING SR BPOLY3D: Z OUT OF FIT RANGE'
          WRITE(6,*)'Z .LT. Z3DMIN'
          WRITE(6,*)'Z, Z3DMIN:',Z,Z3DMIN
          WRITE(6,*)
          IWARNZMN=1
      ENDIF

      IF (IWARNZMX.EQ.0.AND.Z.GT.Z3DMAX) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING SR BPOLY3D: Z OUT OF FIT RANGE'
          WRITE(LUNGFO,*)'Z .GT. Z3DMAX'
          WRITE(LUNGFO,*)'Z, Z3DMAX:',Z,Z3DMAX
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING SR BPOLY3D: Z OUT OF FIT RANGE'
          WRITE(6,*)'Z .GT. Z3DMAX'
          WRITE(6,*)'Z, Z3DMAX:',Z,Z3DMAX
          WRITE(6,*)
          IWARNZMX=1
      ENDIF

      XPOW(1)=1.D0
      DO IX=2,MORD3D
          XPOW(IX)=XPOW(IX-1)*X
      ENDDO

      YPOW(1)=1.D0
      DO IY=2,MORD3D
          YPOW(IY)=YPOW(IY-1)*Y
      ENDDO

      ZPOW(1)=1.D0
      DO IZ=2,MORD3D
          ZPOW(IZ)=ZPOW(IZ-1)*Z
      ENDDO

      AX=0.D0
      AY=0.D0
      AZ=0.D0

      BX=0.D0
      BY=0.D0
      BZ=0.D0

+SELF,IF=OBSOLETE.
      DO IZ=1,MORD3D+1
      DO IY=1,MORD3D+1
      DO IX=1,MORD3D+1
          DO IORD=LORD3D,MORD3D,NDORD3D

         IF (IX+IY+IZ.EQ.IORD+3) THEN

             IF (IX.GT.1) THEN
            XPOW1=XPOW(IX-1)
             ELSE
            XPOW1=0.D0
             ENDIF
             BX=BX-(IX-1)*C(IX,IY,IZ)*XPOW1*YPOW(IY)*ZPOW(IZ)

             IF (IY.GT.1) THEN
            YPOW1=YPOW(IY-1)
             ELSE
            YPOW1=0.D0
             ENDIF

             BY=BY-(IY-1)*C(IX,IY,IZ)*XPOW(IX)*YPOW1*ZPOW(IZ)

             IF (IZ.GT.1) THEN
            ZPOW1=ZPOW(IZ-1)
             ELSE
            ZPOW1=0.D0
             ENDIF

             BZ=BZ-(IZ-1)*C(IX,IY,IZ)*XPOW(IX)*YPOW(IY)*ZPOW1

         ENDIF
          ENDDO
      ENDDO
      ENDDO
      ENDDO
+SELF,IF=-OBSOLETE.
      DO IND=1,NCIND

             IX=ICIND(1,IND)
             IY=ICIND(2,IND)
             IZ=ICIND(3,IND)

             IF (IX.GT.1) THEN
            XPOW1=XPOW(IX-1)
             ELSE
            XPOW1=0.D0
             ENDIF
             BX=BX-(IX-1)*CIND(IND)*XPOW1*YPOW(IY)*ZPOW(IZ)

             IF (IY.GT.1) THEN
            YPOW1=YPOW(IY-1)
             ELSE
            YPOW1=0.D0
             ENDIF

             BY=BY-(IY-1)*CIND(IND)*XPOW(IX)*YPOW1*ZPOW(IZ)

             IF (IZ.GT.1) THEN
            ZPOW1=ZPOW(IZ-1)
             ELSE
            ZPOW1=0.D0
             ENDIF

             BZ=BZ-(IZ-1)*CIND(IND)*XPOW(IX)*YPOW(IY)*ZPOW1

      ENDDO
+SELF.

      IF (IBX.LT.0) BX=-BX
      IF (IBY.LT.0) BY=-BY
      IF (IBZ.LT.0) BZ=-BZ

      X3DMIN=X3DMIN/B3DSCALE
      X3DMAX=X3DMAX/B3DSCALE
      Y3DMIN=Y3DMIN/B3DSCALE
      Y3DMAX=Y3DMAX/B3DSCALE
      Z3DMIN=Z3DMIN/B3DSCALE
      Z3DMAX=Z3DMAX/B3DSCALE

      RETURN
      END

+DECK,BPOLY3DFIT.
*CMZ :  4.00/14 22/12/2021  16.40.21  by  Michael Scheer
*CMZ :  4.00/04 23/08/2019  15.47.38  by  Michael Scheer
*CMZ :  3.05/10 13/08/2018  14.40.26  by  Michael Scheer
*CMZ :  3.02/03 23/10/2014  13.43.13  by  Michael Scheer
*CMZ :  3.00/00 18/09/2013  12.33.23  by  Michael Scheer
*CMZ :  2.68/05 28/09/2012  11.54.30  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  09.55.57  by  Michael Scheer
*CMZ :  2.48/04 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.42/04 28/10/2002  16.57.51  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.16/08 29/10/2000  17.30.59  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  16.39.57  by  Michael Scheer
*CMZ :  1.00/00 24/09/97  10.31.27  by  Michael Scheer
*CMZ : 00.02/03 22/01/97  14.23.26  by  Michael Scheer
*CMZ : 00.02/00 25/11/96  10.03.32  by  Michael Scheer
*CMZ : 00.01/09 24/10/95  17.31.19  by  Michael Scheer
*-- Author :    Michael Scheer   22/09/95

      SUBROUTINE BPOLY3DFIT
+seq,gplhint.

+SEQ,BPOLY3DF90U,IF=F90.

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,CMPARA.
+SEQ,MYFILES.
+SEQ,BPOLY3D.
+seq,whbook.
+seq,pawcmn.

      CHARACTER(60) COMMENT

      INTEGER IPOI,IFAIL,IX,IY,IZ
      INTEGER MPOI,IREAD

+SELF,IF=-F90.
      DOUBLE PRECISION X(N3DPOIP),Y(N3DPOIP),Z(N3DPOIP)
     &                  ,BX(N3DPOIP),BY(N3DPOIP),BZ(N3DPOIP)
     &                  ,BXF(N3DPOIP),BYF(N3DPOIP),BZF(N3DPOIP)
+SELF.

      DOUBLE PRECISION
     &                   RESBX,RESBY,RESBZ,RESB
     &                  ,BXAMEAN,BYAMEAN,BZAMEAN,BAMEAN
     &                  ,BERRMX(8),BXERRMX(8),BYERRMX(8),BZERRMX(8)
     &                  ,XX,YY,ZZ,BBX,BBY,BBZ,AX,AY,AZ

C     DOUBLE PRECISION DIV

      INTEGER NTUP_P,ICYCLE
        PARAMETER (NTUP_P=9)
        REAL*8 TUP_D(NTUP_P)
        CHARACTER(3) CHTAGS_D(NTUP_P)
      data chtags_d/'x','y','z','bx','by','bz','bxf','byf','bzf'/

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SUBROUTINE BPOLY3DFIT:'
      WRITE(LUNGFO,*)'     ======================'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     order of fit (LORD3D, MORD3D, NDORD3D):'
     &                ,LORD3D, MORD3D, NDORD3D
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     considered range in x, y, and z:'
      WRITE(LUNGFO,*)'     ',X3DMIN,X3DMAX
      WRITE(LUNGFO,*)'     ',Y3DMIN,Y3DMAX
      WRITE(LUNGFO,*)'     ',Z3DMIN,Z3DMAX
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     field map read from file:'
      WRITE(LUNGFO,*)'     ',FILEBMAP
      WRITE(LUNGFO,*)

C--- READ FIELD MAP {

      N3DPOIX=0
      N3DPOIY=0
      N3DPOIZ=0
      MPOI=0
      IREAD=0
+SELF,IF=VMS.
      OPEN(UNIT=LUNBMAP,FILE=FILEBMAP,STATUS='OLD',READONLY)
+SELF.

+SELF,IF=LINUX,WINDOWS,HPUX,TRUE64.
      OPEN(UNIT=LUNBMAP,FILE=FILEBMAP,STATUS='OLD')
+SELF.

100       CONTINUE
          IF (IWBPOLY3D.EQ.1) THEN
             READ(LUNBMAP,*,END=90)XX
             READ(LUNBMAP,*)YY
             READ(LUNBMAP,*)ZZ
             READ(LUNBMAP,*)BBX
             READ(LUNBMAP,*)BBY
             READ(LUNBMAP,*)BBZ
             READ(LUNBMAP,*)
          ELSEIF (IWBPOLY3D.EQ.2) THEN
             READ(LUNBMAP,*,END=90)XX,YY,ZZ,BBX,BBY,BBZ
          ELSE
         WRITE(6,*) '*** ERROR IN BPOLY3DFIT: FLAG IWBPOLY3D WRONG, CHECK INPUT'
         STOP
          ENDIF
          IREAD=IREAD+1
          IF (X3DMIN.NE.9999.AND.XX.LT.X3DMIN) GOTO 100
          IF (X3DMAX.NE.9999.AND.XX.GT.X3DMAX) GOTO 100
          IF (Y3DMIN.NE.9999.AND.YY.LT.Y3DMIN) GOTO 100
          IF (Y3DMAX.NE.9999.AND.YY.GT.Y3DMAX) GOTO 100
          IF (Z3DMIN.NE.9999.AND.ZZ.LT.Z3DMIN) GOTO 100
          IF (Z3DMAX.NE.9999.AND.ZZ.GT.Z3DMAX) GOTO 100
          IF (BBX.EQ.-9999..AND.BBY.EQ.-9999..AND.BBZ.EQ.-9999.) GOTO 100
          MPOI=MPOI+1
+SELF,IF=-F90.
          IF (MPOI.GT.N3DPOIP) THEN
         WRITE(6,*) '*** ERROR IN BPOLY3DFIT: DIMENSION N3DPOIP EXCEEDED ***'
         STOP
          ENDIF
+SELF.
          IF (BBX.NE.-9999.) N3DPOIX=N3DPOIX+1
          IF (BBY.NE.-9999.) N3DPOIY=N3DPOIY+1
          IF (BBZ.NE.-9999.) N3DPOIZ=N3DPOIZ+1
          GOTO 100
90    CLOSE(LUNBMAP)

+SELF,IF=F90.
      ALLOCATE(X(MPOI))
      ALLOCATE(Y(MPOI))
      ALLOCATE(Z(MPOI))
      ALLOCATE(BX(MPOI))
      ALLOCATE(BY(MPOI))
      ALLOCATE(BZ(MPOI))
      ALLOCATE(BXF(MPOI))
      ALLOCATE(BYF(MPOI))
      ALLOCATE(BZF(MPOI))
+SELF.

      N3DPOIX=0
      N3DPOIY=0
      N3DPOIZ=0
      MPOI=0
      IREAD=0

+SELF,IF=VMS.
      OPEN(UNIT=LUNBMAP,FILE=FILEBMAP,STATUS='OLD',READONLY)
+SELF.

+SELF,IF=LINUX,WINDOWS,HPUX,TRUE64.
      OPEN(UNIT=LUNBMAP,FILE=FILEBMAP,STATUS='OLD')
+SELF.

101       CONTINUE
          IF (IWBPOLY3D.EQ.1) THEN
             READ(LUNBMAP,*,END=91)XX
             READ(LUNBMAP,*)YY
             READ(LUNBMAP,*)ZZ
             READ(LUNBMAP,*)BBX
             READ(LUNBMAP,*)BBY
             READ(LUNBMAP,*)BBZ
             READ(LUNBMAP,*)
          ELSEIF (IWBPOLY3D.EQ.2) THEN
             READ(LUNBMAP,*,END=91)XX,YY,ZZ,BBX,BBY,BBZ
          ELSE
         WRITE(6,*) '*** ERROR IN BPOLY3DFIT: FLAG IWBPOLY3D WRONG, CHECK INPUT'
         STOP
          ENDIF
          IREAD=IREAD+1
          IF (X3DMIN.NE.9999.AND.XX.LT.X3DMIN) GOTO 101
          IF (X3DMAX.NE.9999.AND.XX.GT.X3DMAX) GOTO 101
          IF (Y3DMIN.NE.9999.AND.YY.LT.Y3DMIN) GOTO 101
          IF (Y3DMAX.NE.9999.AND.YY.GT.Y3DMAX) GOTO 101
          IF (Z3DMIN.NE.9999.AND.ZZ.LT.Z3DMIN) GOTO 101
          IF (Z3DMAX.NE.9999.AND.ZZ.GT.Z3DMAX) GOTO 101
          IF (BBX.EQ.-9999..AND.BBY.EQ.-9999..AND.BBZ.EQ.-9999.) GOTO 101
          MPOI=MPOI+1
          IF (BBX.NE.-9999.) N3DPOIX=N3DPOIX+1
          IF (BBY.NE.-9999.) N3DPOIY=N3DPOIY+1
          IF (BBZ.NE.-9999.) N3DPOIZ=N3DPOIZ+1
          X(MPOI)=XX*XYZ3DSC
          Y(MPOI)=YY*XYZ3DSC
          Z(MPOI)=ZZ*XYZ3DSC
          BX(MPOI)=BBX
          BY(MPOI)=BBY
          BZ(MPOI)=BBZ
          GOTO 101
91    CLOSE(LUNBMAP)

      N3DPOI=MPOI

      WRITE(LUNGFO,*)'     number of data points read:    ',IREAD
      WRITE(LUNGFO,*)'     number of data points accepted:',MPOI
      WRITE(LUNGFO,*)'     number of Bx, By, Bz .ne. -9999.:'
     &                      ,N3DPOIX,N3DPOIY,N3DPOIZ
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     fitted coefficients are written to file:'
      WRITE(LUNGFO,*)'     ',FILE3DFIT
      WRITE(LUNGFO,*)

C--- READ FIELD MAP }

      CALL VPOT3D(MPOI,X,Y,Z,BX,BY,BZ,IFAIL,COMMENT)

      IF (IFAIL.NE.0) THEN
          WRITE(6,*) '*** IFAIL NOT ZERO ***'
          STOP
      ENDIF

      IF (X3DMIN.EQ.9999.) THEN
          X3DMIN=1.D30
          DO IPOI=1,MPOI
         IF (X(IPOI).LT.X3DMIN) X3DMIN=X(IPOI)
          ENDDO
          X3DMIN=X3DMIN/XYZ3DSC
      ENDIF

      IF (X3DMAX.EQ.9999.) THEN
          X3DMAX=-1.D30
          DO IPOI=1,MPOI
         IF (X(IPOI).GT.X3DMAX) X3DMAX=X(IPOI)
          ENDDO
          X3DMAX=X3DMAX/XYZ3DSC
      ENDIF

      IF (Y3DMIN.EQ.9999.) THEN
          Y3DMIN=1.D30
          DO IPOI=1,MPOI
         IF (Y(IPOI).LT.Y3DMIN) Y3DMIN=Y(IPOI)
          ENDDO
          Y3DMIN=Y3DMIN/XYZ3DSC
      ENDIF

      IF (Y3DMAX.EQ.9999.) THEN
          Y3DMAX=-1.D30
          DO IPOI=1,MPOI
         IF (Y(IPOI).GT.Y3DMAX) Y3DMAX=Y(IPOI)
          ENDDO
          Y3DMAX=Y3DMAX/XYZ3DSC
      ENDIF

      IF (Z3DMIN.EQ.9999.) THEN
          Z3DMIN=1.D30
          DO IPOI=1,MPOI
         IF (Z(IPOI).LT.Z3DMIN) Z3DMIN=Z(IPOI)
          ENDDO
          Z3DMIN=Z3DMIN/XYZ3DSC
      ENDIF

      IF (Z3DMAX.EQ.9999.) THEN
          Z3DMAX=-1.D30
          DO IPOI=1,MPOI
         IF (Z(IPOI).GT.Z3DMAX) Z3DMAX=Z(IPOI)
          ENDDO
          Z3DMAX=Z3DMAX/XYZ3DSC
      ENDIF

      OPEN(UNIT=LUN3DFIT,FILE=FILE3DFIT,STATUS='NEW')
          WRITE(LUN3DFIT,'(I5,1H ,A64)')ICODE,CODE
          WRITE(LUN3DFIT,'(A60)')COMMENT
          WRITE(LUN3DFIT,*)XYZ3DSC
          WRITE(LUN3DFIT,*)X3DMIN,X3DMAX
          WRITE(LUN3DFIT,*)Y3DMIN,Y3DMAX
          WRITE(LUN3DFIT,*)Z3DMIN,Z3DMAX
          DO IZ=1,MORD3D+1
          DO IY=1,MORD3D+1
          DO IX=1,MORD3D+1
             IF (C(IX,IY,IZ).NE.0.0D0) WRITE(LUN3DFIT,*)IX,IY,IZ,C(IX,IY,IZ)
          ENDDO
          ENDDO
          ENDDO
      CLOSE(LUN3DFIT)

+self,if=-mhbook.
      CALL hbookm(NIDBPOLY,'BPOLY3D FIT$',NTUP_P,'//WAVE',1024,CHTAGS_D)
+self,if=mhbook.
      CALL hbookm(NIDBPOLY,'BPOLY3D FIT',NTUP_P,'//WAVE',mpoi,CHTAGS_D)
+self.

      DO IPOI=1,MPOI

          X(IPOI)=X(IPOI)/XYZ3DSC
          Y(IPOI)=Y(IPOI)/XYZ3DSC
          Z(IPOI)=Z(IPOI)/XYZ3DSC

           CALL BPOLY3D(X(IPOI),Y(IPOI),Z(IPOI)
     &                ,BXF(IPOI),BYF(IPOI),BZF(IPOI),AX,AY,AZ)

C       CALL DIVB(X(IPOI),Y(IPOI),Z(IPOI),NDIMC+1,C
C     &             ,LORD3D,MORD3D,NDORD3D,DIV)

          TUP_D(1)=X(IPOI)
          TUP_D(2)=Y(IPOI)
          TUP_D(3)=Z(IPOI)
          TUP_D(4)=BX(IPOI)
          TUP_D(5)=BY(IPOI)
          TUP_D(6)=BZ(IPOI)
          TUP_D(7)=BXF(IPOI)
          TUP_D(8)=BYF(IPOI)
          TUP_D(9)=BZF(IPOI)
          CALL hfm(NIDBPOLY,TUP_D)

      ENDDO !IPOI

      CALL BRESI      (MPOI,N3DPOIX,N3DPOIY,N3DPOIZ
     &                  ,X,Y,Z,BX,BY,BZ,BXF,BYF,BZF
     &                  ,RESBX,RESBY,RESBZ,RESB
     &                  ,BXAMEAN,BYAMEAN,BZAMEAN,BAMEAN
     &                  ,BERRMX,BXERRMX,BYERRMX,BZERRMX)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     RESB:',SNGL(RESB)
      WRITE(LUNGFO,*)'     RESBX, RESBY,RESBZ:',SNGL(RESBX),SNGL(RESBY),SNGL(RESBZ)
      WRITE(LUNGFO,*)
      IF (BAMEAN.NE.0.D0)
     &WRITE(LUNGFO,*)'     |B|mean, RESB/|B|mean:',SNGL(BAMEAN),SNGL(RESB/BAMEAN)
      IF (BXAMEAN.NE.0.D0)
     &WRITE(LUNGFO,*)'     |BX|mean, RESBX/|BX|mean:',SNGL(BXAMEAN),SNGL(RESBX/BXAMEAN)
      IF (BYAMEAN.NE.0.D0)
     &WRITE(LUNGFO,*)'     |BY|mean, RESBY/|BY|mean:',SNGL(BYAMEAN),SNGL(RESBY/BYAMEAN)
      IF (BZAMEAN.NE.0.D0)
     &WRITE(LUNGFO,*)'     |BZ|mean, RESBZ/|BZ|mean:',SNGL(BZAMEAN),SNGL(RESBZ/BZAMEAN)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     MAXIMUM ERRORS OF B, BX, BY AND BZ:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'  X      Y      Z       BX        BY        BZ       B         ERR'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,'(3F8.4,5(1PE10.2))')(SNGL(BERRMX(IX)),IX=1,8)
      WRITE(LUNGFO,'(3F8.4,5(1PE10.2))')(SNGL(BXERRMX(IX)),IX=1,8)
      WRITE(LUNGFO,'(3F8.4,5(1PE10.2))')(SNGL(BYERRMX(IX)),IX=1,8)
      WRITE(LUNGFO,'(3F8.4,5(1PE10.2))')(SNGL(BZERRMX(IX)),IX=1,8)
      WRITE(LUNGFO,*)

      CALL MHROUT(NIDBPOLY,ICYCLE,' ')
      CALL hdeletm(NIDBPOLY)

      RETURN
      END
+DECK,BPOLY3DINI.
*CMZ :  2.41/10 18/09/2013  12.33.23  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ : 00.01/09 25/10/95  17.57.38  by  Michael Scheer
*-- Author :    Michael Scheer   29/09/95

      SUBROUTINE BPOLY3DINI
+seq,gplhint.

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,BPOLY3D.

      INTEGER IX,IY,IZ,NREAD,IORD
      CHARACTER(64) COMMENT,WCOMMENT

      DOUBLE PRECISION CC
     &  ,X3DMIND,Y3DMIND,Z3DMIND
     &  ,X3DMAXD,Y3DMAXD,Z3DMAXD

      IF (LORD3D.LT.1) LORD3D=1

      NREAD=0
      NCIND=0
      OPEN(UNIT=LUN3DFIT,FILE=FILE3DFIT,STATUS='OLD')
          READ(LUN3DFIT,'(A64)')WCOMMENT
          READ(LUN3DFIT,'(A64)')COMMENT
          READ(LUN3DFIT,*)B3DSCALE
          XYZ3DSC=B3DSCALE
          READ(LUN3DFIT,*)X3DMIND,X3DMAXD
          READ(LUN3DFIT,*)Y3DMIND,Y3DMAXD
          READ(LUN3DFIT,*)Z3DMIND,Z3DMAXD
100       READ(LUN3DFIT,*,END=900) IX,IY,IZ,CC
          NREAD=NREAD+1
          IF (IX.LT.1.OR.IX.GT.NDIMC) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)
     &'*** ERROR IN BPOLY3DINI: INDEX ON FILE EXCEEDS DIMENSION ***'
         WRITE(LUNGFO,*)'INDEX IX IS:',IX
         WRITE(LUNGFO,*)'DIMENSION IS:',NDIMC
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)
     &'*** ERROR IN BPOLY3DINI: INDEX ON FILE EXCEEDS DIMENSION ***'
         WRITE(6,*)'INDEX IX IS:',IX
         WRITE(6,*)'DIMENSION IS:',NDIMC
         WRITE(6,*)
         STOP
          ENDIF
          IF (IY.LT.1.OR.IY.GT.NDIMC) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)
     &'*** ERROR IN BPOLY3DINI: INDEX ON FILE EXCEEDS DIMENSION ***'
         WRITE(LUNGFO,*)'INDEX IY IS:',IY
         WRITE(LUNGFO,*)'DIMENSION IS:',NDIMC
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)
     &'*** ERROR IN BPOLY3DINI: INDEX ON FILE EXCEEDS DIMENSION ***'
         WRITE(6,*)'INDEX IY IS:',IY
         WRITE(6,*)'DIMENSION IS:',NDIMC
         WRITE(6,*)
         STOP
          ENDIF
          IF (IZ.LT.1.OR.IZ.GT.NDIMC) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)
     &'*** ERROR IN BPOLY3DINI: INDEX ON FILE EXCEEDS DIMENSION ***'
         WRITE(LUNGFO,*)'INDEX IZ IS:',IZ
         WRITE(LUNGFO,*)'DIMENSION IS:',NDIMC
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)
     &'*** ERROR IN BPOLY3DINI: INDEX ON FILE EXCEEDS DIMENSION ***'
         WRITE(6,*)'INDEX IZ IS:',IZ
         WRITE(6,*)'DIMENSION IS:',NDIMC
         WRITE(6,*)
         STOP
          ENDIF
          C(IX,IY,IZ)=0.D0
          IF (
     &               IX-1+IY-1+IZ-1.GE.LORD3D
     &         .AND.
     &               IX-1+IY-1+IZ-1.LE.MORD3D
     &      ) THEN
             C(IX,IY,IZ)=CC
             DO IORD=LORD3D,MORD3D,NDORD3D
                IF (IX+IY+IZ.EQ.IORD+3) THEN
                   NCIND=NCIND+1
                   IF (NCIND.GT.NDIMCIP) THEN
                     WRITE(LUNGFO,*)
                     WRITE(LUNGFO,*)
     &'*** ERROR IN BPOLY3DINI: DIMENSION NDIMCIP (COMMON BPOLY3DC) EXCEEDED ***'
                     WRITE(LUNGFO,*)
                     WRITE(6,*)
                     WRITE(6,*)
     &'*** ERROR IN BPOLY3DINI: DIMENSION NDIMCIP (COMMON BPOLY3DC) EXCEEDED ***'
                     WRITE(6,*)
                     STOP '--- PROGRAM ABORTED ---'
                   ENDIF
                   ICIND(1,NCIND)=IX
                   ICIND(2,NCIND)=IY
                   ICIND(3,NCIND)=IZ
                   CIND(NCIND)=CC
                ENDIF
             ENDDO
          ENDIF
          GOTO 100
900   CLOSE(LUN3DFIT)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SR BPOLY3DINI:'
      WRITE(LUNGFO,*)'     Number of coefficients read:',NREAD
      WRITE(LUNGFO,*)'     from file:'
      WRITE(LUNGFO,*)'     ',FILE3DFIT
      WRITE(LUNGFO,*)'     WAVE comment on file'
      WRITE(LUNGFO,*)'     ',WCOMMENT
      WRITE(LUNGFO,*)'     comment on file'
      WRITE(LUNGFO,*)'     ',COMMENT
      WRITE(LUNGFO,*)'     number of coefficients used:',NCIND
      WRITE(LUNGFO,*)'     scaling factor:',B3DSCALE
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     x-range of fit:',X3DMIND,X3DMAXD
      WRITE(LUNGFO,*)'     y-range of fit:',Y3DMIND,Y3DMAXD
      WRITE(LUNGFO,*)'     z-range of fit:',Z3DMIND,Z3DMAXD
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

      RETURN
      END
+DECK,bpolyeder.
*CMZ :  3.05/00 25/04/2018  13.09.51  by  Michael Scheer
*CMZ :  3.01/02 18/09/2013  12.46.29  by  Michael Scheer
*CMZ :  2.63/05 22/07/2009  08.34.06  by  Michael Scheer
*CMZ :  2.54/00 28/02/2005  17.30.57  by  Michael Scheer
*CMZ :  2.53/05 24/02/2005  14.01.19  by  Michael Scheer
*CMZ :  2.52/05 17/08/2004  12.50.56  by  Michael Scheer
*CMZ :  1.02/01 09/08/2004  14.48.51  by  Michael Scheer
*CMZ :  1.02/00 27/07/2004  13.36.14  by  Michael Scheer
*CMZ :  1.01/01 22/07/2004  13.27.23  by  Michael Scheer
*CMZ :  1.00/00 26/02/2004  17.30.03  by  Michael Scheer
*CMZ :  0.99/07 16/02/2004  16.00.03  by  Michael Scheer
*CMZ :  0.99/03 12/02/2004  10.51.58  by  Michael Scheer
*CMZ :  0.99/01 11/02/2004  13.42.37  by  Michael Scheer
*CMZ :  0.99/00 29/01/2004  12.50.00  by  Michael Scheer
*CMZ :  0.00/08 23/01/2004  15.23.23  by  Michael Scheer
*CMZ :  0.00/07 20/01/2004  16.45.51  by  Michael Scheer
*CMZ :  0.00/06 16/01/2004  10.43.52  by  Michael Scheer
*CMZ :  0.00/05 23/12/2003  16.07.01  by  Michael Scheer
*CMZ :  0.00/04 23/12/2003  10.43.15  by  Michael Scheer
*CMZ :  0.00/02 15/12/2003  12.43.34  by  Michael Scheer
*CMZ :  0.00/01 10/12/2003  17.56.52  by  Michael Scheer
*-- Author :    Michael Scheer   02/12/2003
      subroutine bpolyeder(xin,yin,zin,bxout,byout,bzout)
+seq,gplhint.
c
c       Calculation of magnetic field of polyhedron according to
c      Oleb Chubar, Pascal Elleaume and Joel Chavanne
c       J. Synchrotron Rad. (1998) 5, 481-484
c
c Paper contains an error: The rotation matrix is wrong, since for nz=-1 the
c                          determinant is -1, which yields to errors??.


+seq,bwpolyederf90u.

      implicit none

      double precision xstart,xstop,win2,xino

      double precision xin,yin,zin,bxout,byout,bzout,
     &  bxm,bym,bzm,bxp,byp,bzp,xxm,yym,zzm,xxp,yyp,zzp,xx0,yy0,zz0,
     &  rr0,rrm

      double precision r1(3),r2(3),dlab(3),blab(3)
      double precision ts(3,3),tsinv(3,3),bplan(3),bcvn,vnormlab(3)
      double precision xx,yy,zz,xxrot,yyrot,zzrot
      double precision a,b,z,qx,qy,qz,pi4inv,reverse,tiny2
      double precision q(3,3),vmagrot(3),vmaglab(3),h(3),
     &  xr(2),yr(2),zr(2),dum,dume

      parameter (pi4inv=0.0795774715459477d0)

      integer ical
      integer iout,kmag1,iwarni,itiny,iwtiny,jtiny
      integer imag,iplan,icorn,i,j,k,ip2,kwarn,kwarntot,lwarn,lwarnmax,mwarn

      data ical/0/
      data iwarni/0/
      data lwarnmax/20/
      data lwarn/0/
      data xino/1.0d30/
      data kmag1/1/

      kwarntot=0
      mwarn=0

      if (ical.eq.0) then
      win2=winpm*500.d0
        tiny2=tiny*tiny
        call bpolyini(xstart,xstop,16)
        ical=1
      endif !ical


c calculate field at (xin,yin,zin)

      xx=xin*1000.0d0
      yy=yin*1000.0d0
      zz=zin*1000.0d0

      xxp=xx
      yyp=yy
      zzp=zz

      xx0=xx
      yy0=yy
      zz0=zz

      xxm=xx
      yym=yy
      zzm=zz

      itiny=0
      jtiny=0
      iwtiny=0

1     continue

c      if (kwarn.gt.1) then
      if (kwarn.gt.0.or.jtiny.ne.0) then !24feb05
        if (kwarn.gt.0) then
          lwarn=lwarn+1
          mwarn=mwarn+1
          if (mwarn.gt.1000) then
            print *,'*** Error in BPOLYEDER: Endless loop?'
            print *,' ical:',ical
            print *,'x,y,z (mm): '
            print *,xin*1000.d0,yin*1000.d0,zin*1000.d0
            print *,'Bx,By,Bz: '
            print *,bxout,byout,bzout
            print *,' '
            stop '***Program WAVE aborted ***'
          else if (mwarn.gt.0.and.ibpnowarn.eq.0) then
            print *,'*** Warning in BPOLYEDER'
            print *,'Counter for this warning:',mwarn
            print *,'x,y,z (mm): '
            print *,xx,yy,zz
            print *,'Bx,By,Bz: '
            print *,bxout,byout,bzout
            print *,'x,y,z will be changed by',1000.*tiny
            print *,' '
          endif
        endif !kwarn
2       if (itiny.eq.0) then
          if (kwarn.eq.0.and.jtiny.eq.1) then
            itiny=1
            iwtiny=0
            goto 2
          else
            xxp=xxp+1000.*tiny
            yyp=yyp+1000.*tiny
            zzp=zzp+1000.*tiny
            xx=xxp
            yy=yyp
            zz=zzp
            jtiny=1
            iwtiny=1
          endif
        else if (itiny.eq.1) then
          if (kwarn.eq.0.and.jtiny.eq.2) then
            itiny=2
            iwtiny=0
            goto 2
          else
            xxm=xxm-1000.*tiny
            yym=yym-1000.*tiny
            zzm=zzm-1000.*tiny
            xx=xxm
            yy=yym
            zz=zzm
            jtiny=2
            iwtiny=2
          endif
        else if (itiny.eq.2) then
          rr0=sqrt((xxp-xxm)**2+(yyp-yym)**2+(zzp-zzm)**2)
          rrm=sqrt((xxm-xx0)**2+(yym-yy0)**2+(zzm-zz0)**2)
          bxout=bxm+(bxp-bxm)/rr0*rrm
          byout=bym+(byp-bym)/rr0*rrm
          bzout=bzm+(bzp-bzm)/rr0*rrm
          return
        endif
      endif !kwarn

      bxout=0.d0
      byout=0.d0
      bzout=0.d0

      if (xin.lt.xino) kmag1=1

      do imag=kmag1,nmag
        if (abs(xx-bpexpos(imag)).le.win2) then
          kmag1=imag
          goto 901
        endif
      enddo

901   xino=xin

      do imag=kmag1,nmag

        if (abs(xx-bpexpos(imag)).gt.win2) goto 999

        if (bpebc(7,imag).ne.0.0d0) then !non-zero magnetization

          if(bpebc(8,imag).eq.1) then !not rectangular magnet

c check, if we are inside of magnet; we assume convex shape

            iout=-1

            do iplan=1,ibpeplan(imag)

              dlab(1)=xx-bpemag(1,1,iplan,imag)
              dlab(2)=yy-bpemag(2,1,iplan,imag)
              dlab(3)=zz-bpemag(3,1,iplan,imag)

              vnormlab(1)=bpetm(1,8,iplan,imag)
              vnormlab(2)=bpetm(2,8,iplan,imag)
              vnormlab(3)=bpetm(3,8,iplan,imag)

              if( dlab(1)*vnormlab(1)+dlab(2)*vnormlab(2)+
     &            dlab(3)*vnormlab(3).gt.0.d0) then
                iout=1
                goto 9
              endif

            enddo !iplan

9           continue

            do iplan=1,ibpeplan(imag)

              bcvn=-bpetm(1,7,iplan,imag)*pi4inv

              bplan(1)=0.d0
              bplan(2)=0.d0
              bplan(3)=0.d0

c transform everything to the nz=(0,0,1) system

              if (ibpecorn(iplan,imag).gt.0) then

                do i=1,3
                  do j=1,3
                    ts(i,j)=bpetm(i,j,iplan,imag)
                    tsinv(i,j)=bpetm(i,j+3,iplan,imag)
                  enddo
                enddo

                xxrot=ts(1,1)*xx+ts(1,2)*yy+ts(1,3)*zz
                yyrot=ts(2,1)*xx+ts(2,2)*yy+ts(2,3)*zz
                zzrot=ts(3,1)*xx+ts(3,2)*yy+ts(3,3)*zz

                do icorn=1,ibpecorn(iplan,imag)-1

                  ip2=icorn+1

                  r1(1)=bperot(1,icorn,iplan,imag)-xxrot
                  r1(2)=bperot(2,icorn,iplan,imag)-yyrot
                  r1(3)=bperot(3,icorn,iplan,imag)-zzrot

                  r2(1)=bperot(1,ip2,iplan,imag)-xxrot
                  r2(2)=bperot(2,ip2,iplan,imag)-yyrot
                  r2(3)=bperot(3,ip2,iplan,imag)-zzrot

                  if (abs(r1(1)-r2(1)).gt.tiny) then

                    a=(r2(2)-r1(2))/(r2(1)-r1(1))
                    b=r1(2)-a*r1(1)

                    if (abs(a).lt.tiny2) then
                      a=0.0d0
                      b=r1(2)
                    endif

                    z=r1(3)

                    call bpeq(r1(1),r2(1),a,b,z,qx,qy,qz,
     &                tiny,reverse,kwarn)

                    if (kwarn.eq.1) then
                      kwarntot=1 !close to magnet boundary, position changed
                      goto 1 !24feb05
                    else if (kwarn.gt.1) then
                      kwarntot=2
                      goto 1
                    endif

                    bplan(1)=bplan(1)-qx*bcvn
                    bplan(2)=bplan(2)-qy*bcvn
                    bplan(3)=bplan(3)-qz*bcvn

                  endif !(abs(r1(1)-r2(1)).gt.tiny)

                enddo !icorn=1,ncorn

                blab(1)=tsinv(1,1)*bplan(1)+tsinv(1,2)*bplan(2)+tsinv(1,3)*bplan(3)
                blab(2)=tsinv(2,1)*bplan(1)+tsinv(2,2)*bplan(2)+tsinv(2,3)*bplan(3)
                blab(3)=tsinv(3,1)*bplan(1)+tsinv(3,2)*bplan(2)+tsinv(3,3)*bplan(3)

                bxout=bxout+blab(1)
                byout=byout+blab(2)
                bzout=bzout+blab(3)

              endif !magnetization parallel to normal vector

            enddo ! iplan=1,nplan

            if (iout.eq.-1) then
              bxout=bxout+bpebc(4,imag)
              byout=byout+bpebc(5,imag)
              bzout=bzout+bpebc(6,imag)
              if (iwarni.eq.0) then
                iwarni=1
                print *
                print *,'*** Error in BPOLYEDER: Inside Magnet! ***'
                print *,'imag,x,y,z (mm): ',imag,sngl(xx),sngl(yy),sngl(zz)
                print*
                stop '*** program WAVE aborted ***'
              endif
            endif !iout

          else !bpebc(8,imag) .eq. 1

c rectangular magnet
c check, if we are inside of magnet; we assume convex shape

            iout=-1

            do iplan=1,ibpeplan(imag)

              dlab(1)=xx-bpemag(1,1,iplan,imag)
              dlab(2)=yy-bpemag(2,1,iplan,imag)
              dlab(3)=zz-bpemag(3,1,iplan,imag)

              vnormlab(1)=bpetm(1,8,iplan,imag)
              vnormlab(2)=bpetm(2,8,iplan,imag)
              vnormlab(3)=bpetm(3,8,iplan,imag)

              if( dlab(1)*vnormlab(1)+dlab(2)*vnormlab(2)+
     &            dlab(3)*vnormlab(3).gt.0.d0) then
                iout=1
                goto 91
              endif

            enddo !iplan

91          continue

+self,if=-noqmat.

            vmaglab(1)=bpebc(4,imag)
            vmaglab(2)=bpebc(5,imag)
            vmaglab(3)=bpebc(6,imag)

c transform everything to the nz=(0,0,1) system and rotate it parallel to x-axis

            do i=1,3
              do j=1,3
                ts(i,j)=bpetm(i,j,1,imag)
                tsinv(i,j)=bpetm(i,j+3,1,imag)
              enddo
            enddo

            xxrot=ts(1,1)*xx+ts(1,2)*yy+ts(1,3)*zz
            yyrot=ts(2,1)*xx+ts(2,2)*yy+ts(2,3)*zz
            zzrot=ts(3,1)*xx+ts(3,2)*yy+ts(3,3)*zz

            vmagrot(1)=
     &        ts(1,1)*vmaglab(1)+ts(1,2)*vmaglab(2)+ts(1,3)*vmaglab(3)
            vmagrot(2)=
     &        ts(2,1)*vmaglab(1)+ts(2,2)*vmaglab(2)+ts(2,3)*vmaglab(3)
            vmagrot(3)=
     &        ts(3,1)*vmaglab(1)+ts(3,2)*vmaglab(2)+ts(3,3)*vmaglab(3)

            xr(1)=bperot(1,1,1,imag)-xxrot
            xr(2)=bperot(1,2,1,imag)-xxrot
            yr(1)=bperot(2,1,1,imag)-yyrot
            yr(2)=bperot(2,3,1,imag)-yyrot

            zr(1)=bperot(3,1,1,imag)-zzrot
            zr(2)=bperot(3,1,3,imag)-zzrot

            if (abs(xr(2)-xr(1)).lt.tiny) then
              print*,'abs(xr(2)-xr(1)).lt.tiny'
            endif

            if (abs(yr(2)-yr(1)).lt.tiny) then
              print*,'abs(yr(2)-yr(1)).lt.tiny'
            endif

            if (abs(zr(2)-zr(1)).lt.tiny) then
              print*,'abs(zr(2)-zr(1)).lt.tiny'
            endif

            kwarn=0

            if (
     &          abs(xr(1)).lt.tiny.or.
     &          abs(xr(2)).lt.tiny.or.
     &          abs(yr(1)).lt.tiny.or.
     &          abs(yr(2)).lt.tiny.or.
     &          abs(zr(1)).lt.tiny.or.
     &          abs(zr(2)).lt.tiny) then
              kwarn=10
              kwarntot=3
              goto 1
            endif

            q(1,1)=0.0d0
            q(2,2)=0.0d0
            q(3,3)=0.0d0

            q(1,2)=1.0d0
            q(1,3)=1.0d0
            q(2,3)=1.0d0

            do i=1,2
              do j=1,2
                do k=1,2

                  q(1,1)=q(1,1)+
     &              (-1)**(i+j+k+1)*
     &              atan(
     &              yr(j)/xr(i)*zr(k)/
     &              sqrt(xr(i)**2+yr(j)**2+zr(k)**2)
     &              )

                  q(2,2)=q(2,2)+
     &              (-1)**(i+j+k+1)*
     &              atan(
     &              xr(j)/yr(i)*zr(k)/
     &              sqrt(yr(i)**2+xr(j)**2+zr(k)**2)
     &              )

                  q(3,3)=q(3,3)+
     &              (-1)**(i+j+k+1)*
     &              atan(
     &              yr(j)/zr(i)*xr(k)/
     &              sqrt(zr(i)**2+yr(j)**2+xr(k)**2)
     &              )

                  dum=zr(k)+sqrt(xr(i)**2+yr(j)**2+zr(k)**2)
                  dume=(-1.0d0)**(i+j+k)

                  if (dum.ne.0.0d0) then
                    if (dume.gt.0.0d0) then
                      q(1,2)=q(1,2)*dum
                    else
                      q(1,2)=q(1,2)/dum
                    endif
                  endif

                  dum=yr(k)+sqrt(xr(i)**2+zr(j)**2+yr(k)**2)
                  if (dum.ne.0.0d0) then
                    if (dume.gt.0.0d0) then
                      q(1,3)=q(1,3)*dum
                    else
                      q(1,3)=q(1,3)/dum
                    endif
                  endif

                  dum=xr(k)+sqrt(zr(i)**2+yr(j)**2+xr(k)**2)
                  if (dum.ne.0.0d0) then
                    if (dume.gt.0.0d0) then
                      q(2,3)=q(2,3)*dum
                    else
                      q(2,3)=q(2,3)/dum
                    endif
                  endif

                enddo !k
              enddo !j
            enddo !i

            if (
     &          q(1,2).lt.tiny2.or.
     &          q(1,3).lt.tiny2.or.
     &          q(2,3).lt.tiny2) then
              kwarn=10
              kwarntot=10
              goto 1
            endif

            q(1,2)=log(q(1,2))
            q(1,3)=log(q(1,3))
            q(2,3)=log(q(2,3))

            q(2,1)=q(1,2)
            q(3,1)=q(1,3)
            q(3,2)=q(2,3)

            h(1)=
     &        -(q(1,1)*vmagrot(1)+q(1,2)*vmagrot(2)+q(1,3)*vmagrot(3))*
     &        pi4inv
            h(2)=
     &        -(q(2,1)*vmagrot(1)+q(2,2)*vmagrot(2)+q(2,3)*vmagrot(3))*
     &        pi4inv
            h(3)=
     &        -(q(3,1)*vmagrot(1)+q(3,2)*vmagrot(2)+q(3,3)*vmagrot(3))*
     &        pi4inv

            bplan(1)=h(1)
            bplan(2)=h(2)
            bplan(3)=h(3)

            blab(1)=tsinv(1,1)*bplan(1)+tsinv(1,2)*bplan(2)+tsinv(1,3)*bplan(3)
            blab(2)=tsinv(2,1)*bplan(1)+tsinv(2,2)*bplan(2)+tsinv(2,3)*bplan(3)
            blab(3)=tsinv(3,1)*bplan(1)+tsinv(3,2)*bplan(2)+tsinv(3,3)*bplan(3)

            bxout=bxout+blab(1)
            byout=byout+blab(2)
            bzout=bzout+blab(3)

+self,if=noqmat.

            do iplan=1,ibpeplan(imag)

              bcvn=-bpetm(1,7,iplan,imag)*pi4inv

              bplan(1)=0.d0
              bplan(2)=0.d0
              bplan(3)=0.d0

c transform everything to the nz=(0,0,1) system and rotate it parallel to x-axis

              if (ibpecorn(iplan,imag).gt.0) then

                do i=1,3
                  do j=1,3
                    ts(i,j)=bpetm(i,j,iplan,imag)
                    tsinv(i,j)=bpetm(i,j+3,iplan,imag)
                  enddo
                enddo

                xxrot=ts(1,1)*xx+ts(1,2)*yy+ts(1,3)*zz
                yyrot=ts(2,1)*xx+ts(2,2)*yy+ts(2,3)*zz
                zzrot=ts(3,1)*xx+ts(3,2)*yy+ts(3,3)*zz

                x1=bperot(1,1,iplan,imag)-xxrot
                x2=bperot(1,2,iplan,imag)-xxrot
                y1=bperot(2,1,iplan,imag)-yyrot
                y2=bperot(2,3,iplan,imag)-yyrot

                z=bperot(3,1,iplan,imag)-zzrot

                if (abs(x2-x1).gt.tiny) then

                  if (abs(z).lt.tiny) z=sign(tiny,z)

                  x12=x1*x1
                  x22=x2*x2
                  y12=y1*y1
                  y22=y2*y2
                  z2=z*z

                  x12z2=x12+z2
                  x22z2=x22+z2
                  y12z2=y12+z2
                  y22z2=y22+z2

                  sqx12z2y12=Sqrt(x12z2 + y12)
                  sqx12z2y22=Sqrt(x12z2 + y22)
                  sqx22z2y12=Sqrt(x22z2 + y12)
                  sqx22z2y22=Sqrt(x22z2 + y22)

                  qx=
     &              log(
     &              ((y1 + sqx22z2y12)*(y2 + sqx12z2y22))/
     &              ((y2 + sqx22z2y22)*(y1 + sqx12z2y12))
     &              )

                  qy=
     &              log(
     &              ((x1 + sqx12z2y22)*(x2 + sqx22z2y12))/
     &              ((x2 + sqx22z2y22)*(x1 + sqx12z2y12))
     &              )

                  qz=
     &               atan((x1*y1)/(z*sqx12z2y12))
     &              -atan((x2*y1)/(z*sqx22z2y12))
     &              -atan((x1*y2)/(z*sqx12z2y22))
     &              +atan((x2*y2)/(z*sqx22z2y22))

                  bplan(1)=bplan(1)+qx*bcvn
                  bplan(2)=bplan(2)+qy*bcvn
                  bplan(3)=bplan(3)+qz*bcvn

                endif !(abs(r1(1)-r2(1)).gt.tiny)

                blab(1)=tsinv(1,1)*bplan(1)+tsinv(1,2)*bplan(2)+tsinv(1,3)*bplan(3)
                blab(2)=tsinv(2,1)*bplan(1)+tsinv(2,2)*bplan(2)+tsinv(2,3)*bplan(3)
                blab(3)=tsinv(3,1)*bplan(1)+tsinv(3,2)*bplan(2)+tsinv(3,3)*bplan(3)

                bxout=bxout+blab(1)
                byout=byout+blab(2)
                bzout=bzout+blab(3)

              endif !magnetization parallel to normal vector

            enddo ! iplan=1,nplan

            print*,bxout
            print*,byout
            print*,bzout
            print*
+self. !if=noqmat.

            if (iout.eq.-1) then
              bxout=bxout+bpebc(4,imag)
              byout=byout+bpebc(5,imag)
              bzout=bzout+bpebc(6,imag)
              if (iwarni.eq.0) then
                iwarni=1
                print *
                print *,'*** Error in BPOLYEDER: Inside Magnet! ***'
                print *,'imag,x,y,z (mm): ',imag,sngl(xx),sngl(yy),sngl(zz)
                print*
                stop '*** program WAVE aborted ***'
              endif
            endif !iout

          endif !(bpebc(8,imag).eq.1)

        endif !non-zero magnetization

      enddo !imag=1,nmag

999   continue

      bxout=bxout*bscalepm
      byout=byout*bscalepm
      bzout=bzout*bscalepm

      if (jtiny.eq.1) then
        bxp=bxout
        byp=byout
        bzp=bzout
        goto 1
      else if (jtiny.eq.2) then
        bxm=bxout
        bym=byout
        bzm=bzout
        goto 1
      endif

      if (kwarntot.ne.0.and.lwarn.lt.lwarnmax) then
        print *
        print *,'x,y,z (mm): '
        print *,xx,yy,zz
        print *,'Bx,By,Bz: '
        print *,bxout,byout,bzout
        print *,'*** Questionable data written to polymag.err'
        print *,'------------------------------------------'
      endif

      if (lwarn.eq.lwarnmax) then
        lwarn=lwarn+1
        print *
        print *,'*** Maximum number of printed warning reached!!'
        print *,'*** Questionable data written to polymag.err'
        print *,'------------------------------------------'
      endif

      if (kwarntot.ne.0) then
        write(34,'(6e15.5)')
     &    sngl(xin),sngl(yin),sngl(zin),
     &    sngl(bxout),sngl(byout),sngl(bzout)
      endif

      return
      end
+DECK,BPOLYHARM.
*CMZ :  4.00/04 17/05/2019  11.46.54  by  Michael Scheer
*CMZ :  2.66/09 08/04/2010  12.10.57  by  Michael Scheer
*CMZ :  2.48/04 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.48/03 03/03/2004  12.49.38  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.16/08 01/11/2000  18.41.44  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  1.03/06 11/06/98  10.26.40  by  Michael Scheer
*CMZ : 00.01/04 16/01/95  13.52.05  by  Michael Scheer
*CMZ : 00.01/03 28/11/94  12.04.43  by  Michael Scheer
*CMZ :  0.00/03 15/11/94  16.48.07  by  Michael Scheer
*CMZ :  0.00/02 02/11/94  16.15.54  by  Michael Scheer
*CMZ :  0.00/01 31/10/94  10.05.04  by  Michael Scheer
*CMZ :  0.00/00 28/10/94  16.14.51  by  Michael Scheer
*-- Author :    Michael Scheer   28/10/94
      SUBROUTINE BPOLYHARM(XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT)
+seq,gplhint.

      IMPLICIT NONE

+SEQ,CONTRL.

      INTEGER NORDP
      PARAMETER (NORDP=20)

      CHARACTER(50) FILECOE

      INTEGER IPOLY
      INTEGER ICAL
      INTEGER LUNCOE
      INTEGER NFIRSTX,NORDX,NSTEPX
      INTEGER NFIRSTY,NORDY,NSTEPY
      INTEGER IFHALBA

      DATA ICAL/0/

      DATA LUNCOE/10/
      DATA FILECOE/'wave_bpolyharm_coef.dat'/

      DOUBLE PRECISION X,Y,Z
      DOUBLE PRECISION XIN,YIN,ZIN
      DOUBLE PRECISION Q(NORDP,NORDP),QA0(NORDP),QA(NORDP,NORDP)
      DOUBLE PRECISION BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT
      DOUBLE PRECISION BX,BY,BZ

      DOUBLE PRECISION XLX,YLY,ZLZ,XKX,YKY,ZKZ
      DOUBLE PRECISION GAP2PI,WIDTH

      IF (ICAL.EQ.0) THEN

+SELF,IF=VMS.
       OPEN(UNIT=LUNCOE,FILE=FILECOE,STATUS='OLD',READONLY)
+SELF.

+SELF,IF=LINUX,WINDOWS,HPUX,TRUE64.
       OPEN(UNIT=LUNCOE,FILE=FILECOE,STATUS='OLD')
+SELF.

         READ(LUNCOE,*)IFHALBA,IPOLY
       CLOSE(LUNCOE)

       CALL BRCOEF(LUNCOE,FILECOE
     &            ,XLX,YLY,ZLZ
     &            ,XKX,YKY,ZKZ
     &            ,NFIRSTX,NORDX,NSTEPX
     &            ,NFIRSTY,NORDY,NSTEPY
     &            ,NORDP,Q,QA0,QA,IFHALBA,GAP2PI,WIDTH)

      IF (XSTART.EQ.9999.) XSTART=-ZLZ/2.
      IF (XSTOP.EQ.9999.) XSTOP=+ZLZ/2.

       WRITE(LUNGFO,*)
       WRITE(LUNGFO,*)
     &'*** WARNING SR BPOLYHARM: VECTOR POTENTIAL NOT AVAILABLE (SET TO ZERO) ***'
       WRITE(LUNGFO,*)
       WRITE(6,*)
       WRITE(6,*)
     &'*** WARNING SR BPOLYHARM: VECTOR POTENTIAL NOT AVAILABLE (SET TO ZERO) ***'
       WRITE(6,*)
       WRITE(LUNGFO,*)
       WRITE(LUNGFO,*)'     SR BPOLYHARM:'
       WRITE(LUNGFO,*)
     &'     COEFFICIENTS READ FROM FILE wave_bpolyharm_coef.dat'
       WRITE(LUNGFO,*)
     &'     POLYHARM RUN NUMBER ON FILE:',IPOLY
       WRITE(LUNGFO,*)
       CALL wave_print_file(lungfo,'wave_bpolyharm_coef.dat')
       WRITE(LUNGFO,*)
          ICAL=1
      ENDIF !ICAL

      AXOUT=0.0
      AYOUT=0.0
      AZOUT=0.0

      X=-ZIN
      Y=YIN
        Z=XIN

            CALL BHARM(X,Y,Z,BX,BY,BZ
     &                ,NFIRSTX,NORDX,NSTEPX
     &                ,NFIRSTY,NORDY,NSTEPY
     &                ,Q,QA0,QA,NORDP,XKX,YKY,ZKZ,IFHALBA,GAP2PI,WIDTH)

      BXOUT=BZ
      BYOUT=BY
      BZOUT=-BX

      RETURN
      END
+DECK,bpolyini.
*CMZ :  3.05/00 25/04/2018  13.09.51  by  Michael Scheer
*CMZ :  3.01/02 27/08/2013  09.19.16  by  Michael Scheer
*CMZ :  2.62/01 24/04/2007  12.00.02  by  Michael Scheer
*CMZ :  2.62/00 16/04/2007  16.00.14  by  Michael Scheer
*CMZ :  2.57/05 01/08/2006  19.29.50  by  Michael Scheer
*CMZ :  2.54/02 13/04/2005  12.35.45  by  Michael Scheer
*CMZ :  2.53/05 23/02/2005  18.54.13  by  Michael Scheer
*CMZ :  2.52/05 16/08/2004  14.49.57  by  Michael Scheer
*CMZ :  2.48/00 01/03/2004  17.55.46  by  Michael Scheer
*CMZ :  2.47/23 17/02/2004  13.47.20  by  Michael Scheer
*CMZ :  0.99/07 16/02/2004  17.22.16  by  Michael Scheer
*CMZ :  0.99/03 12/02/2004  13.55.05  by  Michael Scheer
*CMZ :  0.99/00 26/01/2004  17.03.49  by  Michael Scheer
*CMZ :  0.00/08 23/01/2004  12.52.23  by  Michael Scheer
*CMZ :  0.00/07 16/01/2004  11.05.44  by  Michael Scheer
*CMZ :  0.00/06 09/01/2004  15.55.17  by  Michael Scheer
*CMZ :  0.00/05 23/12/2003  14.52.54  by  Michael Scheer
*CMZ :  0.00/04 23/12/2003  10.15.07  by  Michael Scheer
*CMZ :  0.00/02 15/12/2003  12.43.34  by  Michael Scheer
*CMZ :  0.00/01 10/12/2003  17.56.52  by  Michael Scheer
*-- Author :    Michael Scheer   02/12/2003
      subroutine bpolyini(xstart,xstop,lungfo)
+seq,gplhint.

+seq,bwpolyederf90u.

      implicit none

+seq,bforce.

      double precision, dimension (:), allocatable :: xsort,ysort,bpexpos0

      integer, dimension (:), allocatable :: ibpeplan0
      integer, dimension (:,:), allocatable :: ibpecorn0

      double precision, dimension (:,:), allocatable :: bpebc0
      double precision, dimension (:,:,:), allocatable :: bpemat0
      double precision, dimension (:,:,:,:), allocatable :: bpemag0,shuffle,
     &  bperot0,bpetm0

      integer, dimension (:), allocatable :: ibpecol

      double precision x0,y0,z0,bc,xm,ym,zm,rmag(3),vmaglab(3),
     &  vnormlab(3),r1(3),bdum,dum,r1lab(3),
     &  xstart,xstop,xmn,xmx,
     &  rausch,offrausch

      double precision ts(3,3),tsinv(3,3),p1(3),p2(3),p3(3)
      double precision v1x,v1y,v1z,v2x,v2y,v2z,vsx,vsy,vsz
      double precision xmin,xmax,ymin,ymax,zmin,zmax
      double precision space,vspace(3),vbsym(3),rotmod(3,3),
     &  xmod,ymod,zmod,q,qsign,a,b,r2(3),det,
     &  xlen,ylen,zlen,vx,vy,vn,ca,sa,tz(3,3),ws(3,3),
     &  ts1(3,3),ts1inv(3,3),
     &  bxi,byi,bzi,xint,yint,zint,
     &  vxint,vyint,vzint,
     &  bxint,byint,bzint,ddum,rmin,rmax,y0max,y0min,ylenmax,ylenmin,ycen,
     &  shll,shlr,shul,shur,hgap

      real xplmin,xplmax,yplmin,yplmax,zplmin,zplmax,theta,phi

      integer iwarn,ifilemodus,ifail,lungfo,iplot,idum,
     &  iallowin,ishfield,ibextern,iseed

      integer ntupp,nx,ny,nz,nmagdiv,ndiv,idiv,n2div
      parameter(ntupp=10)

      real htup(ntupp)

      integer ical
      integer nplan,ncol,ncorn,nmodule,ncopy
      integer nmagmax,nplanmax,ncornmax,kmag1,kmag2
      integer imag,jmag,kmag,iplan,icorn,imodul,icopy,i,
     &      j,ip1,ip2,iflange,nflange,nmago

      character(256) usercom,cfile

      data ical/0/

      if (ical.eq.0) then

        tiny=1.0d-6

        lunbpe=lunpm
        filebpe=filepm

        open(unit=lunbpe,file=filebpe,form='formatted',status='old')

        call util_skip_comment(lunbpe)
        read(lunbpe,*)ifilemodus,iplot,
     &    xplmin,xplmax,yplmin,yplmax,zplmin,zplmax,theta,phi

        call util_skip_comment(lunbpe)
        read(lunbpe,'(a)')usercom

        call util_skip_comment(lunbpe)
        read(lunbpe,*)iaxint,x0int,y0int,z0int,nstepint,ranginti,ranginte

        call util_skip_comment(lunbpe)
        read(lunbpe,*)idum,idum,idum,iforcol

        call util_skip_comment(lunbpe)
        read(lunbpe,*)ddum,ddum,ddum

        call util_skip_comment(lunbpe)
        read(lunbpe,*)ddum,ddum,ddum

        call util_skip_comment(lunbpe)
        read(lunbpe,*)ddum,ddum,ddum

        call util_skip_comment(lunbpe)
        read(lunbpe,*)idum,idum,ddum

        call util_skip_comment(lunbpe)
        read(lunbpe,*)ddum,ddum,ddum,ddum

        call util_skip_comment(lunbpe)
        read(lunbpe,*)ddum,ddum,ddum

        call util_skip_comment(lunbpe)
        read(lunbpe,*)nx,xmin,xmax

        call util_skip_comment(lunbpe)
        read(lunbpe,*)ny,ymin,ymax

        call util_skip_comment(lunbpe)
        read(lunbpe,*)nz,zmin,zmax

        call util_skip_comment(lunbpe)
        read(lunbpe,*)ddum

        nmagmax=0
        nplanmax=0
        ncornmax=0

11      call util_skip_comment(lunbpe)
        read(lunbpe,*)nmag

        nmago=nmag

        if (nmag.eq.0) then
          call util_skip_comment(lunbpe)
          read(lunbpe,'(a)')cfile
          lunbpe=197
          open(unit=lunbpe,file=cfile,form='formatted',status='old')
          call util_skip_comment(lunbpe)
          read(lunbpe,*)nmag
        endif !nmago

        if (nmag.eq.9999) goto 99

c get dimensions

        do imag=1,nmag

          call util_skip_comment(lunbpe)
          read(lunbpe,*)x0,y0,z0

          call util_skip_comment(lunbpe)
          read(lunbpe,*)bc,x0,y0,z0

          call util_skip_comment(lunbpe)
          read(lunbpe,*)nplan,ncol

          if ((nplan.eq.-1.or.nplan.eq.-6).and.nplanmax.lt.6) then
            nplanmax=6
          else if (abs(nplan).gt.nplanmax) then
            nplanmax=abs(nplan)
          endif

          if (nplan.gt.0) then

            do iplan=1,nplan

              call util_skip_comment(lunbpe)
              read(lunbpe,*)ncorn

              if (ncorn.lt.3) then
                print *
                print *,'*** ERROR IN BPOLYINI: Too few points'
                print *,'Magnet, plane: ',imag,iplan
                print *
                stop
              endif

              if (ncorn+1.gt.ncornmax) ncornmax=ncorn+1

              do icorn=1,ncorn
                call util_skip_comment(lunbpe)
                read(lunbpe,*)x0,y0,z0
              enddo

              ncorn=ncorn+1

            enddo !nplan

          else if (nplan.eq.-6) then

              ncorn=4
              if (ncorn+1.gt.ncornmax) ncornmax=ncorn+1
              ncorn=ncorn+1

              call util_skip_comment(lunbpe)
              read(lunbpe,*)xlen,ylen,zlen

          else if (nplan.eq.-1) then

            ncorn=4
            if (ncorn+1.gt.ncornmax) ncornmax=ncorn+1
            ncorn=ncorn+1

            call util_skip_comment(lunbpe)
            read(lunbpe,*)xlen,ylen,zlen,ndiv

            if (xlen.gt.0.0d0) then
              nmagdiv=nmagdiv+2*ndiv-1
              n2div=2*ndiv
            else
              nmagdiv=nmagdiv+ndiv-1
              n2div=ndiv
            endif

          else !(nplan.eq.-6)
            print*, '*** Error in BPOLYINI: Bad value of number of planes'
            print*, '*** Magnet:', imag
            stop '*** Program aborted ***'
          endif !nplan.gt.0

        enddo !nmag

        nmag=nmag+nmagdiv

        lunbpe=lunpm

        call util_skip_comment(lunbpe)
        read(lunbpe,*)nmodule

        do imodul=1,nmodule

          call util_skip_comment(lunbpe)
          read(lunbpe,*)x0,y0,z0

          call util_skip_comment(lunbpe)
          read(lunbpe,*)x0,y0,z0

          call util_skip_comment(lunbpe)
          read(lunbpe,*)x0,y0,z0

          call util_skip_comment(lunbpe)
          read(lunbpe,*)x0,y0,z0

          call util_skip_comment(lunbpe)
          read(lunbpe,*)ncopy

          call util_skip_comment(lunbpe)
          read(lunbpe,*)space,vspace(1),vspace(2),vspace(3)

          call util_skip_comment(lunbpe)
          read(lunbpe,*)vbsym(1),vbsym(2),vbsym(3)

          nmagmax=nmagmax+ncopy*nmag

        enddo !imodul=1,nomodul

        goto 11

99      continue

        call util_skip_comment(lunbpe)
        rausch=0.0
        offrausch=0.0

        read(lunbpe,*,end=991)rausch,offrausch
        offrausch=offrausch/1000.

        read(lunbpe,*)iseed

        call util_skip_comment(lunbpe)
        read(lunbpe,*,end=991)iallowin

        call util_skip_comment(lunbpe)
        read(lunbpe,*,end=991)ishfield

        call util_skip_comment(lunbpe)
        read(lunbpe,*,end=991)ibextern

        call util_skip_comment(lunbpe)
        read(lunbpe,*,end=991)shll
        call util_skip_comment(lunbpe)
        read(lunbpe,*,end=991)shlr
        call util_skip_comment(lunbpe)
        read(lunbpe,*,end=991)shul
        call util_skip_comment(lunbpe)
        read(lunbpe,*,end=991)shur
        call util_skip_comment(lunbpe)
c        read(lunbpe,*,end=991)gappm
        read(lunbpe,*,end=991)dum

c        shiftll=shiftll+shll
c        shiftlr=shiftlr+shlr
c        shiftul=shiftul+shul
c        shiftur=shiftur+shur

991     continue

        allocate(bpexpos(nmagmax))
        allocate(bpebc(8,nmagmax))
        allocate(bpemat(3,3,nmagmax))
        allocate(bpemag(6,ncornmax,nplanmax,nmagmax))
        allocate(shuffle(7,ncornmax,nplanmax,nmagmax))
        allocate(bperot(3,ncornmax,nplanmax,nmagmax))
        allocate(bpetm(3,8,nplanmax,nmagmax))
        allocate(ibpeplan(nmagmax))
        allocate(ibpecol(nmagmax))
        allocate(ibpecorn(nplanmax,nmagmax))
        allocate(bflange(7,ncornmax*nplanmax))

        allocate(bpexpos0(nmagmax))
        allocate(bpebc0(8,nmagmax))
        allocate(bpemat0(3,3,nmagmax))
        allocate(bpemag0(6,ncornmax,nplanmax,nmagmax))
        allocate(bperot0(3,ncornmax,nplanmax,nmagmax))
        allocate(bpetm0(3,8,nplanmax,nmagmax))
        allocate(ibpeplan0(nmagmax))
        allocate(ibpecorn0(nplanmax,nmagmax))

        rewind(lunbpe)

c read and store data

        nmagmax=0
        nplanmax=0
        ncornmax=0

        call util_skip_comment(lunbpe)
        read(lunbpe,*)ifilemodus,iplot,
     &    xplmin,xplmax,yplmin,yplmax,zplmin,zplmax,theta,phi

        call util_skip_comment(lunbpe)
        read(lunbpe,'(a)')usercom

        call util_skip_comment(lunbpe)
        read(lunbpe,*)iaxint,x0int,y0int,z0int,nstepint,ranginti,ranginte

        call util_skip_comment(lunbpe)
        read(lunbpe,*)idum,idum,idum,iforcol

        call util_skip_comment(lunbpe)
        read(lunbpe,*)ddum,ddum,ddum

        call util_skip_comment(lunbpe)
        read(lunbpe,*)ddum,ddum,ddum

        call util_skip_comment(lunbpe)
        read(lunbpe,*)ddum,ddum,ddum

        forcol=iforcol

        bflenxmm=bflenx*1000.0d0
        bflenymm=bfleny*1000.0d0
        bflenzmm=bflenz*1000.0d0

        bfcenxmm=bfcenx*1000.0d0
        bfcenymm=bfceny*1000.0d0
        bfcenzmm=bfcenz*1000.0d0

        torqcenxmm=torqcenx*1000.0d0
        torqcenymm=torqceny*1000.0d0
        torqcenzmm=torqcenz*1000.0d0

        forxpl(1)=bfcenxmm-bflenxmm/2.
        forxpl(2)=bfcenxmm+bflenxmm/2.
        forypl(1)=bfcenymm-bflenymm/2.
        forypl(2)=bfcenymm+bflenymm/2.
        forzpl(1)=bfcenzmm-bflenzmm/2.
        forzpl(2)=bfcenzmm+bflenzmm/2.

        call util_skip_comment(lunbpe)
        read(lunbpe,*)idum,idum,ddum

        call util_skip_comment(lunbpe)
        read(lunbpe,*)ddum,ddum,ddum,ddum

        call util_skip_comment(lunbpe)
        read(lunbpe,*)ddum,ddum,ddum

        call util_skip_comment(lunbpe)
        read(lunbpe,*)nx,xmin,xmax

        call util_skip_comment(lunbpe)
        read(lunbpe,*)ny,ymin,ymax

        call util_skip_comment(lunbpe)
        read(lunbpe,*)nz,zmin,zmax

        call util_skip_comment(lunbpe)
        read(lunbpe,*)ddum

1       call util_skip_comment(lunbpe)
        read(lunbpe,*)nmag

        if (nmag.eq.9999) goto 9

        if (nmag.eq.0) then
          call util_skip_comment(lunbpe)
          read(lunbpe,'(a)')cfile
          lunbpe=197
          rewind(lunbpe)
          call util_skip_comment(lunbpe)
          read(lunbpe,*)nmag
        endif !nmago

        kmag1=nmagmax+1
        kmag2=nmagmax+nmag

        do imag=1,nmag

          nmagmax=nmagmax+1

          call util_skip_comment(lunbpe)
          read(lunbpe,*)bpebc0(1,nmagmax),bpebc0(2,nmagmax),bpebc0(3,nmagmax)

          call util_skip_comment(lunbpe)
          read(lunbpe,*)bc,xm,ym,zm !magnetization vector M

          bdum=sqrt(xm*xm+ym*ym+zm*zm)
          if (bdum.eq.0.d0) then
            print *
            print *,'*** ERROR IN BPOLYEDER: Bad magnetization vector'
            print *,'Magnet ',imag
            print *
            stop
          endif
          bdum=bc/bdum

          bpebc0(4,nmagmax)=xm*bdum
          bpebc0(5,nmagmax)=ym*bdum
          bpebc0(6,nmagmax)=zm*bdum

          call util_skip_comment(lunbpe)
          read(lunbpe,*)nplan,ncol

          ibpecol(nmagmax)=ncol

          if (nplan.gt.0) then

            bpebc0(7,nmagmax)=1

            do iplan=1,nplan

              call util_skip_comment(lunbpe)
              read(lunbpe,*)ncorn

              ncorn=ncorn+1

              ibpecorn(iplan,nmagmax)=ncorn

              do icorn=1,ncorn

                if (icorn.lt.ncorn) then

                  call util_skip_comment(lunbpe)
                  read(lunbpe,*)x0,y0,z0

                  bpemag0(1,icorn,iplan,nmagmax)=x0
                  bpemag0(2,icorn,iplan,nmagmax)=y0
                  bpemag0(3,icorn,iplan,nmagmax)=z0

                else ! icorn.lt.ncorn

                  bpemag0(1,icorn,iplan,nmagmax)=bpemag0(1,1,iplan,nmagmax)
                  bpemag0(2,icorn,iplan,nmagmax)=bpemag0(2,1,iplan,nmagmax)
                  bpemag0(3,icorn,iplan,nmagmax)=bpemag0(3,1,iplan,nmagmax)

                endif ! icorn.lt.ncorn

              enddo !icorn

            enddo !iplan

            ibpeplan(nmagmax)=nplan

          else if (nplan.eq.-6) then

            bpebc0(7,nmagmax)=-6

            nplan=6

            call util_skip_comment(lunbpe)
            read(lunbpe,*)xlen,ylen,zlen

            ibpeplan(nmagmax)=6

            iplan=1
            ibpecorn(iplan,nmagmax)=5
            icorn=1
            bpemag0(1,icorn,iplan,nmagmax)=-xlen/2.0d0
            bpemag0(2,icorn,iplan,nmagmax)=-ylen/2.0d0
            bpemag0(3,icorn,iplan,nmagmax)=-zlen/2.0d0
            icorn=2
            bpemag0(1,icorn,iplan,nmagmax)=-xlen/2.0d0
            bpemag0(2,icorn,iplan,nmagmax)=-ylen/2.0d0
            bpemag0(3,icorn,iplan,nmagmax)=+zlen/2.0d0
            icorn=3
            bpemag0(1,icorn,iplan,nmagmax)=-xlen/2.0d0
            bpemag0(2,icorn,iplan,nmagmax)=+ylen/2.0d0
            bpemag0(3,icorn,iplan,nmagmax)=+zlen/2.0d0
            icorn=4
            bpemag0(1,icorn,iplan,nmagmax)=-xlen/2.0d0
            bpemag0(2,icorn,iplan,nmagmax)=+ylen/2.0d0
            bpemag0(3,icorn,iplan,nmagmax)=-zlen/2.0d0

            iplan=2
            ibpecorn(iplan,nmagmax)=5
            icorn=4
            bpemag0(1,icorn,iplan,nmagmax)=+xlen/2.0d0
            bpemag0(2,icorn,iplan,nmagmax)=-ylen/2.0d0
            bpemag0(3,icorn,iplan,nmagmax)=-zlen/2.0d0
            icorn=3
            bpemag0(1,icorn,iplan,nmagmax)=+xlen/2.0d0
            bpemag0(2,icorn,iplan,nmagmax)=-ylen/2.0d0
            bpemag0(3,icorn,iplan,nmagmax)=+zlen/2.0d0
            icorn=2
            bpemag0(1,icorn,iplan,nmagmax)=+xlen/2.0d0
            bpemag0(2,icorn,iplan,nmagmax)=+ylen/2.0d0
            bpemag0(3,icorn,iplan,nmagmax)=+zlen/2.0d0
            icorn=1
            bpemag0(1,icorn,iplan,nmagmax)=+xlen/2.0d0
            bpemag0(2,icorn,iplan,nmagmax)=+ylen/2.0d0
            bpemag0(3,icorn,iplan,nmagmax)=-zlen/2.0d0

            iplan=3
            ibpecorn(iplan,nmagmax)=5
            icorn=4
            bpemag0(1,icorn,iplan,nmagmax)=-xlen/2.0d0
            bpemag0(2,icorn,iplan,nmagmax)=-ylen/2.0d0
            bpemag0(3,icorn,iplan,nmagmax)=-zlen/2.0d0
            icorn=3
            bpemag0(1,icorn,iplan,nmagmax)=-xlen/2.0d0
            bpemag0(2,icorn,iplan,nmagmax)=-ylen/2.0d0
            bpemag0(3,icorn,iplan,nmagmax)=+zlen/2.0d0
            icorn=2
            bpemag0(1,icorn,iplan,nmagmax)=+xlen/2.0d0
            bpemag0(2,icorn,iplan,nmagmax)=-ylen/2.0d0
            bpemag0(3,icorn,iplan,nmagmax)=+zlen/2.0d0
            icorn=1
            bpemag0(1,icorn,iplan,nmagmax)=+xlen/2.0d0
            bpemag0(2,icorn,iplan,nmagmax)=-ylen/2.0d0
            bpemag0(3,icorn,iplan,nmagmax)=-zlen/2.0d0

            iplan=4
            ibpecorn(iplan,nmagmax)=5
            icorn=1
            bpemag0(1,icorn,iplan,nmagmax)=-xlen/2.0d0
            bpemag0(2,icorn,iplan,nmagmax)=+ylen/2.0d0
            bpemag0(3,icorn,iplan,nmagmax)=-zlen/2.0d0
            icorn=2
            bpemag0(1,icorn,iplan,nmagmax)=-xlen/2.0d0
            bpemag0(2,icorn,iplan,nmagmax)=+ylen/2.0d0
            bpemag0(3,icorn,iplan,nmagmax)=+zlen/2.0d0
            icorn=3
            bpemag0(1,icorn,iplan,nmagmax)=+xlen/2.0d0
            bpemag0(2,icorn,iplan,nmagmax)=+ylen/2.0d0
            bpemag0(3,icorn,iplan,nmagmax)=+zlen/2.0d0
            icorn=4
            bpemag0(1,icorn,iplan,nmagmax)=+xlen/2.0d0
            bpemag0(2,icorn,iplan,nmagmax)=+ylen/2.0d0
            bpemag0(3,icorn,iplan,nmagmax)=-zlen/2.0d0

            iplan=5
            ibpecorn(iplan,nmagmax)=5
            icorn=1
            bpemag0(1,icorn,iplan,nmagmax)=-xlen/2.0d0
            bpemag0(2,icorn,iplan,nmagmax)=-ylen/2.0d0
            bpemag0(3,icorn,iplan,nmagmax)=-zlen/2.0d0
            icorn=2
            bpemag0(1,icorn,iplan,nmagmax)=-xlen/2.0d0
            bpemag0(2,icorn,iplan,nmagmax)=+ylen/2.0d0
            bpemag0(3,icorn,iplan,nmagmax)=-zlen/2.0d0
            icorn=3
            bpemag0(1,icorn,iplan,nmagmax)=+xlen/2.0d0
            bpemag0(2,icorn,iplan,nmagmax)=+ylen/2.0d0
            bpemag0(3,icorn,iplan,nmagmax)=-zlen/2.0d0
            icorn=4
            bpemag0(1,icorn,iplan,nmagmax)=+xlen/2.0d0
            bpemag0(2,icorn,iplan,nmagmax)=-ylen/2.0d0
            bpemag0(3,icorn,iplan,nmagmax)=-zlen/2.0d0

            iplan=6
            ibpecorn(iplan,nmagmax)=5
            icorn=4
            bpemag0(1,icorn,iplan,nmagmax)=-xlen/2.0d0
            bpemag0(2,icorn,iplan,nmagmax)=-ylen/2.0d0
            bpemag0(3,icorn,iplan,nmagmax)=+zlen/2.0d0
            icorn=3
            bpemag0(1,icorn,iplan,nmagmax)=-xlen/2.0d0
            bpemag0(2,icorn,iplan,nmagmax)=+ylen/2.0d0
            bpemag0(3,icorn,iplan,nmagmax)=+zlen/2.0d0
            icorn=2
            bpemag0(1,icorn,iplan,nmagmax)=+xlen/2.0d0
            bpemag0(2,icorn,iplan,nmagmax)=+ylen/2.0d0
            bpemag0(3,icorn,iplan,nmagmax)=+zlen/2.0d0
            icorn=1
            bpemag0(1,icorn,iplan,nmagmax)=+xlen/2.0d0
            bpemag0(2,icorn,iplan,nmagmax)=-ylen/2.0d0
            bpemag0(3,icorn,iplan,nmagmax)=+zlen/2.0d0

            do iplan=1,6
              bpemag0(1,5,iplan,nmagmax)=bpemag0(1,1,iplan,nmagmax)
              bpemag0(2,5,iplan,nmagmax)=bpemag0(2,1,iplan,nmagmax)
              bpemag0(3,5,iplan,nmagmax)=bpemag0(3,1,iplan,nmagmax)
            enddo !iplan

          else if (nplan.eq.-1) then

            call util_skip_comment(lunbpe)
            read(lunbpe,*)xlen,ylen,zlen,ndiv

            nmag=nmag+n2div-1
            kmag2=kmag2+n2div-1

            rmin=xlen
            rmax=ylen

            ylenmax=2.0d0*rmax/ndiv
            ylenmin=2.0d0*rmin/ndiv

            xm=bpebc0(4,nmagmax)
            ym=bpebc0(5,nmagmax)
            zm=bpebc0(6,nmagmax)

            x0=bpebc0(1,nmagmax)
            ycen=bpebc0(2,nmagmax)
            y0max=ycen-rmax-ylenmax/2.0d0
            y0min=ycen-rmin-ylenmin/2.0d0
            z0=bpebc0(3,nmagmax)

            nmagmax=nmagmax-1

            do idiv=1,n2div

c divide cylindrical magnet into rectangular blocks

              nmagmax=nmagmax+1

              if ((idiv/2)*2.ne.idiv.or.rmin.le.0.0d0)  then
                y0max=y0max+ylenmax
                xlen=2.0d0*
     &            sqrt((rmax+(y0max-ycen))*(rmax-(y0max-ycen)))
                ylen=ylenmax
            bpebc0(2,nmagmax)=y0max
                bpebc0(4,nmagmax)=xm
                bpebc0(5,nmagmax)=ym
                bpebc0(6,nmagmax)=zm
              else
                y0MIN=y0MIN+ylenMIN
                xlen=2.0d0*
     &           sqrt((rMIN+(y0MIN-ycen))*(rMIN-(y0MIN-ycen)))
                ylen=ylenmin
            bpebc0(2,nmagmax)=y0min
                bpebc0(4,nmagmax)=-xm
                bpebc0(5,nmagmax)=-ym
                bpebc0(6,nmagmax)=-zm
              endif

              bpebc0(1,nmagmax)=x0
              bpebc0(3,nmagmax)=z0

              bpebc0(7,nmagmax)=-6
              nplan=6

              ibpeplan(nmagmax)=6

              iplan=1
              ibpecorn(iplan,nmagmax)=5
              icorn=1
              bpemag0(1,icorn,iplan,nmagmax)=-xlen/2.0d0
              bpemag0(2,icorn,iplan,nmagmax)=-ylen/2.0d0
              bpemag0(3,icorn,iplan,nmagmax)=-zlen/2.0d0
              icorn=2
              bpemag0(1,icorn,iplan,nmagmax)=-xlen/2.0d0
              bpemag0(2,icorn,iplan,nmagmax)=-ylen/2.0d0
              bpemag0(3,icorn,iplan,nmagmax)=+zlen/2.0d0
              icorn=3
              bpemag0(1,icorn,iplan,nmagmax)=-xlen/2.0d0
              bpemag0(2,icorn,iplan,nmagmax)=+ylen/2.0d0
              bpemag0(3,icorn,iplan,nmagmax)=+zlen/2.0d0
              icorn=4
              bpemag0(1,icorn,iplan,nmagmax)=-xlen/2.0d0
              bpemag0(2,icorn,iplan,nmagmax)=+ylen/2.0d0
              bpemag0(3,icorn,iplan,nmagmax)=-zlen/2.0d0

              iplan=2
              ibpecorn(iplan,nmagmax)=5
              icorn=4
              bpemag0(1,icorn,iplan,nmagmax)=+xlen/2.0d0
              bpemag0(2,icorn,iplan,nmagmax)=-ylen/2.0d0
              bpemag0(3,icorn,iplan,nmagmax)=-zlen/2.0d0
              icorn=3
              bpemag0(1,icorn,iplan,nmagmax)=+xlen/2.0d0
              bpemag0(2,icorn,iplan,nmagmax)=-ylen/2.0d0
              bpemag0(3,icorn,iplan,nmagmax)=+zlen/2.0d0
              icorn=2
              bpemag0(1,icorn,iplan,nmagmax)=+xlen/2.0d0
              bpemag0(2,icorn,iplan,nmagmax)=+ylen/2.0d0
              bpemag0(3,icorn,iplan,nmagmax)=+zlen/2.0d0
              icorn=1
              bpemag0(1,icorn,iplan,nmagmax)=+xlen/2.0d0
              bpemag0(2,icorn,iplan,nmagmax)=+ylen/2.0d0
              bpemag0(3,icorn,iplan,nmagmax)=-zlen/2.0d0

              iplan=3
              ibpecorn(iplan,nmagmax)=5
              icorn=4
              bpemag0(1,icorn,iplan,nmagmax)=-xlen/2.0d0
              bpemag0(2,icorn,iplan,nmagmax)=-ylen/2.0d0
              bpemag0(3,icorn,iplan,nmagmax)=-zlen/2.0d0
              icorn=3
              bpemag0(1,icorn,iplan,nmagmax)=-xlen/2.0d0
              bpemag0(2,icorn,iplan,nmagmax)=-ylen/2.0d0
              bpemag0(3,icorn,iplan,nmagmax)=+zlen/2.0d0
              icorn=2
              bpemag0(1,icorn,iplan,nmagmax)=+xlen/2.0d0
              bpemag0(2,icorn,iplan,nmagmax)=-ylen/2.0d0
              bpemag0(3,icorn,iplan,nmagmax)=+zlen/2.0d0
              icorn=1
              bpemag0(1,icorn,iplan,nmagmax)=+xlen/2.0d0
              bpemag0(2,icorn,iplan,nmagmax)=-ylen/2.0d0
              bpemag0(3,icorn,iplan,nmagmax)=-zlen/2.0d0

              iplan=4
              ibpecorn(iplan,nmagmax)=5
              icorn=1
              bpemag0(1,icorn,iplan,nmagmax)=-xlen/2.0d0
              bpemag0(2,icorn,iplan,nmagmax)=+ylen/2.0d0
              bpemag0(3,icorn,iplan,nmagmax)=-zlen/2.0d0
              icorn=2
              bpemag0(1,icorn,iplan,nmagmax)=-xlen/2.0d0
              bpemag0(2,icorn,iplan,nmagmax)=+ylen/2.0d0
              bpemag0(3,icorn,iplan,nmagmax)=+zlen/2.0d0
              icorn=3
              bpemag0(1,icorn,iplan,nmagmax)=+xlen/2.0d0
              bpemag0(2,icorn,iplan,nmagmax)=+ylen/2.0d0
              bpemag0(3,icorn,iplan,nmagmax)=+zlen/2.0d0
              icorn=4
              bpemag0(1,icorn,iplan,nmagmax)=+xlen/2.0d0
              bpemag0(2,icorn,iplan,nmagmax)=+ylen/2.0d0
              bpemag0(3,icorn,iplan,nmagmax)=-zlen/2.0d0

              iplan=5
              ibpecorn(iplan,nmagmax)=5
              icorn=1
              bpemag0(1,icorn,iplan,nmagmax)=-xlen/2.0d0
              bpemag0(2,icorn,iplan,nmagmax)=-ylen/2.0d0
              bpemag0(3,icorn,iplan,nmagmax)=-zlen/2.0d0
              icorn=2
              bpemag0(1,icorn,iplan,nmagmax)=-xlen/2.0d0
              bpemag0(2,icorn,iplan,nmagmax)=+ylen/2.0d0
              bpemag0(3,icorn,iplan,nmagmax)=-zlen/2.0d0
              icorn=3
              bpemag0(1,icorn,iplan,nmagmax)=+xlen/2.0d0
              bpemag0(2,icorn,iplan,nmagmax)=+ylen/2.0d0
              bpemag0(3,icorn,iplan,nmagmax)=-zlen/2.0d0
              icorn=4
              bpemag0(1,icorn,iplan,nmagmax)=+xlen/2.0d0
              bpemag0(2,icorn,iplan,nmagmax)=-ylen/2.0d0
              bpemag0(3,icorn,iplan,nmagmax)=-zlen/2.0d0

              iplan=6
              ibpecorn(iplan,nmagmax)=5
              icorn=4
              bpemag0(1,icorn,iplan,nmagmax)=-xlen/2.0d0
              bpemag0(2,icorn,iplan,nmagmax)=-ylen/2.0d0
              bpemag0(3,icorn,iplan,nmagmax)=+zlen/2.0d0
              icorn=3
              bpemag0(1,icorn,iplan,nmagmax)=-xlen/2.0d0
              bpemag0(2,icorn,iplan,nmagmax)=+ylen/2.0d0
              bpemag0(3,icorn,iplan,nmagmax)=+zlen/2.0d0
              icorn=2
              bpemag0(1,icorn,iplan,nmagmax)=+xlen/2.0d0
              bpemag0(2,icorn,iplan,nmagmax)=+ylen/2.0d0
              bpemag0(3,icorn,iplan,nmagmax)=+zlen/2.0d0
              icorn=1
              bpemag0(1,icorn,iplan,nmagmax)=+xlen/2.0d0
              bpemag0(2,icorn,iplan,nmagmax)=-ylen/2.0d0
              bpemag0(3,icorn,iplan,nmagmax)=+zlen/2.0d0

              do iplan=1,6
                bpemag0(1,5,iplan,nmagmax)=bpemag0(1,1,iplan,nmagmax)
                bpemag0(2,5,iplan,nmagmax)=bpemag0(2,1,iplan,nmagmax)
                bpemag0(3,5,iplan,nmagmax)=bpemag0(3,1,iplan,nmagmax)
              enddo !iplan

            enddo !ndiv

          endif !nplan.gt.0

        enddo !imag

        lunbpe=lunpm

        call util_skip_comment(lunbpe)
        read(lunbpe,*)nmodule

        nmagmax=nmagmax-nmag

        do imodul=1,nmodule

          call util_skip_comment(lunbpe)
          read(lunbpe,*)xmod,ymod,zmod

          call util_skip_comment(lunbpe)
          read(lunbpe,*)rotmod(1,1),rotmod(1,2),rotmod(1,3)

          call util_skip_comment(lunbpe)
          read(lunbpe,*)rotmod(2,1),rotmod(2,2),rotmod(2,3)

          call util_skip_comment(lunbpe)
          read(lunbpe,*)rotmod(3,1),rotmod(3,2),rotmod(3,3)

          call util_determinante(3,rotmod,det,ifail)
          if (ifail.ne.0.or.abs(abs(det)-1.0d0).gt.tiny) then
            print *,
     &        '*** Error in bpolyini: Bad rotation matrix'
            print *,'magnet, plane: ',imag,iplan
            stop
          endif

          call util_skip_comment(lunbpe)
          read(lunbpe,*)ncopy

          call util_skip_comment(lunbpe)
          read(lunbpe,*)space,vspace(1),vspace(2),vspace(3)

          call util_vnorm(3,vspace,vspace)

          call util_skip_comment(lunbpe)
          read(lunbpe,*)vbsym(1),vbsym(2),vbsym(3)

          do icopy=1,ncopy

            do imag=kmag1,kmag2

              nmagmax=nmagmax+1

              ibpecol(nmagmax)=ibpecol(imag)
              ibpeplan(nmagmax)=ibpeplan(imag)

              x0=xmod+bpebc0(1,imag)+(icopy-1)*space*vspace(1)
              y0=ymod+bpebc0(2,imag)+(icopy-1)*space*vspace(2)
              z0=zmod+bpebc0(3,imag)+(icopy-1)*space*vspace(3)

              bpebc(1,nmagmax)=x0
              bpebc(2,nmagmax)=y0
              bpebc(3,nmagmax)=z0

              bpebc(4,nmagmax)=bpebc0(4,imag)*vbsym(1)
              bpebc(5,nmagmax)=bpebc0(5,imag)*vbsym(2)
              bpebc(6,nmagmax)=bpebc0(6,imag)*vbsym(3)

              bpebc(8,nmagmax)=bpebc0(7,imag)

              do iplan=1,ibpeplan(nmagmax)

                ibpecorn(iplan,nmagmax)=ibpecorn(iplan,imag)

                do icorn=1,ibpecorn(iplan,nmagmax)

                  bpemag(1,icorn,iplan,nmagmax)=
     &              bpemag0(1,icorn,iplan,imag)
                  bpemag(2,icorn,iplan,nmagmax)=
     &              bpemag0(2,icorn,iplan,imag)
                  bpemag(3,icorn,iplan,nmagmax)=
     &              bpemag0(3,icorn,iplan,imag)

c rotation of magnet
                  x0=
     &              rotmod(1,1)*bpemag(1,icorn,iplan,nmagmax)+
     &              rotmod(1,2)*bpemag(2,icorn,iplan,nmagmax)+
     &              rotmod(1,3)*bpemag(3,icorn,iplan,nmagmax)

                  y0=
     &              rotmod(2,1)*bpemag(1,icorn,iplan,nmagmax)+
     &              rotmod(2,2)*bpemag(2,icorn,iplan,nmagmax)+
     &              rotmod(2,3)*bpemag(3,icorn,iplan,nmagmax)

                  z0=
     &              rotmod(3,1)*bpemag(1,icorn,iplan,nmagmax)+
     &              rotmod(3,2)*bpemag(2,icorn,iplan,nmagmax)+
     &              rotmod(3,3)*bpemag(3,icorn,iplan,nmagmax)

                  bpemag(1,icorn,iplan,nmagmax)=x0+bpebc(1,nmagmax)
                  bpemag(2,icorn,iplan,nmagmax)=y0+bpebc(2,nmagmax)
                  bpemag(3,icorn,iplan,nmagmax)=z0+bpebc(3,nmagmax)

                enddo !icorn

                if (det.lt.0.0d0) then

                  do icorn=1,ibpecorn(iplan,nmagmax)
                    ip1=ibpecorn(iplan,nmagmax)-icorn+1
                    shuffle(1,ip1,iplan,nmagmax)=bpemag(1,icorn,iplan,nmagmax)
                    shuffle(2,ip1,iplan,nmagmax)=bpemag(2,icorn,iplan,nmagmax)
                    shuffle(3,ip1,iplan,nmagmax)=bpemag(3,icorn,iplan,nmagmax)
                  enddo !icorn

                  do icorn=1,ibpecorn(iplan,nmagmax)
                    bpemag(1,icorn,iplan,nmagmax)=
     &                shuffle(1,icorn,iplan,nmagmax)
                    bpemag(2,icorn,iplan,nmagmax)=
     &                shuffle(2,icorn,iplan,nmagmax)
                    bpemag(3,icorn,iplan,nmagmax)=
     &                shuffle(3,icorn,iplan,nmagmax)
                  enddo !icorn

                endif !det

              enddo !iplan

            enddo !imag

          enddo !icopy

        enddo !imodul=1,nmodul

        goto 1

9     continue !end of input file

      nmag=nmagmax

      close(lunbpe)

      do imag=1,nmag
c center of magnet in lab

c Anders als in POLYMAG, werden hier alle Magnete geschoben

        hgap=gappm/2.0d0

        if (bpebc(2,imag).lt.0.0d0.and.bpebc(3,imag).lt.0.0d0) then
          bpebc(1,imag)=bpebc(1,imag)+shiftll
          bpebc(2,imag)=bpebc(2,imag)-hgap
          do iplan=1,ibpeplan(imag)
            do icorn=1,ibpecorn(iplan,imag)
              bpemag(1,icorn,iplan,imag)=bpemag(1,icorn,iplan,imag)+shiftll
              bpemag(2,icorn,iplan,imag)=bpemag(2,icorn,iplan,imag)-hgap
            enddo
          enddo
        else if (bpebc(2,imag).lt.0.0d0.and.bpebc(3,imag).gt.0.0d0) then
          bpebc(1,imag)=bpebc(1,imag)+shiftlr
          bpebc(2,imag)=bpebc(2,imag)-hgap
          do iplan=1,6
            do icorn=1,5
              bpemag(1,icorn,iplan,imag)=bpemag(1,icorn,iplan,imag)+shiftlr
              bpemag(2,icorn,iplan,imag)=bpemag(2,icorn,iplan,imag)-hgap
            enddo
          enddo
        else if (bpebc(2,imag).gt.0.0d0.and.bpebc(3,imag).gt.0.0d0) then
          bpebc(1,imag)=bpebc(1,imag)+shiftur
          bpebc(2,imag)=bpebc(2,imag)+hgap
          do iplan=1,6
            do icorn=1,5
              bpemag(1,icorn,iplan,imag)=bpemag(1,icorn,iplan,imag)+shiftur
              bpemag(2,icorn,iplan,imag)=bpemag(2,icorn,iplan,imag)+hgap
            enddo
          enddo
        else if (bpebc(2,imag).gt.0.0d0.and.bpebc(3,imag).lt.0.0d0) then
          bpebc(1,imag)=bpebc(1,imag)+shiftul
          bpebc(2,imag)=bpebc(2,imag)+hgap
          do iplan=1,6
            do icorn=1,5
              bpemag(1,icorn,iplan,imag)=bpemag(1,icorn,iplan,imag)+shiftul
              bpemag(2,icorn,iplan,imag)=bpemag(2,icorn,iplan,imag)+hgap
            enddo
          enddo
        endif

        rmag(1)=bpebc(1,imag)
        rmag(2)=bpebc(2,imag)
        rmag(3)=bpebc(3,imag)

c magnetization vector in lab

        vmaglab(1)=bpebc(4,imag)
        vmaglab(2)=bpebc(5,imag)
        vmaglab(3)=bpebc(6,imag)

        bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)

        do iplan=1,ibpeplan(imag)

c three points defining plane (lab.-system)

          p1(1)=bpemag(1,1,iplan,imag)
          p1(2)=bpemag(2,1,iplan,imag)
          p1(3)=bpemag(3,1,iplan,imag)

          p2(1)=bpemag(1,2,iplan,imag)
          p2(2)=bpemag(2,2,iplan,imag)
          p2(3)=bpemag(3,2,iplan,imag)

          p3(1)=bpemag(1,3,iplan,imag)
          p3(2)=bpemag(2,3,iplan,imag)
          p3(3)=bpemag(3,3,iplan,imag)

          call bpen(imag,iplan,p1,p2,p3,vnormlab)

c check if normal vector is perpendicular to magnetization vector
c if mag. vector is parallel, skip plane

          if (bc.ne.0.d0) then
            dum=abs(
     &        (vnormlab(1)*vmaglab(1)+vnormlab(2)*vmaglab(2)+
     &        vnormlab(3)*vmaglab(3))
     &        /bc
     &        )
          else
            dum=0.0d0
          endif

          if (dum.lt.1.d-20.and.bpebc(8,imag).ne.-6) then

            ibpecorn(iplan,imag)=-ibpecorn(iplan,imag)
            bpetm(1,8,iplan,imag)=vnormlab(1)
            bpetm(2,8,iplan,imag)=vnormlab(2)
            bpetm(3,8,iplan,imag)=vnormlab(3)

          else

            bpetm(1,7,iplan,imag)=
     &        vmaglab(1)*vnormlab(1)+
     &        vmaglab(2)*vnormlab(2)+
     &        vmaglab(3)*vnormlab(3)
            bpetm(1,8,iplan,imag)=vnormlab(1)
            bpetm(2,8,iplan,imag)=vnormlab(2)
            bpetm(3,8,iplan,imag)=vnormlab(3)

c get matrices ts and tsinv

            call bpet(vnormlab,ts,tsinv)

            if (bpebc(8,imag).eq.-6) then

c for rectangular magnets, we rotate plan such, that the flanges coinside with
c the axis of the coord.-system.


c All planes are rotated to the system of the
c first plane

              if (iplan.eq.1) then
                ts1=ts
                ts1inv=tsinv
              else
                ts=ts1
                tsinv=ts1inv
              endif !(iplan.eq.1)

              do icorn=1,2

                r1lab(1)=bpemag(1,icorn,iplan,imag)
                r1lab(2)=bpemag(2,icorn,iplan,imag)
                r1lab(3)=bpemag(3,icorn,iplan,imag)

                r1(1)=ts(1,1)*r1lab(1)+ts(1,2)*r1lab(2)+ts(1,3)*r1lab(3)
                r1(2)=ts(2,1)*r1lab(1)+ts(2,2)*r1lab(2)+ts(2,3)*r1lab(3)
                r1(3)=ts(3,1)*r1lab(1)+ts(3,2)*r1lab(2)+ts(3,3)*r1lab(3)

                bperot(1,icorn,iplan,imag)=r1(1)
                bperot(2,icorn,iplan,imag)=r1(2)
                bperot(3,icorn,iplan,imag)=r1(3)

              enddo !icorn=1,ncorn

              vx=bperot(1,2,iplan,imag)-bperot(1,1,iplan,imag)
              vy=bperot(2,2,iplan,imag)-bperot(2,1,iplan,imag)
              vn=sqrt(vx*vx+vy*vy)

              sa=vy/vn
              ca=vx/vn

              tz=ts

              ts(1,1)=ca
              ts(1,2)=sa
              ts(1,3)=0.0d0

              ts(2,1)=-sa
              ts(2,2)=ca
              ts(2,3)=0.0d0

              ts(3,1)=0.0d0
              ts(3,2)=0.0d0
              ts(3,3)=1.0d0

              call util_matrix_multiplication(3,3,3,ts,tz,ts,ws)

              do i=1,3
                do j=1,3
                  tsinv(i,j)=ts(j,i)
                enddo
              enddo

            endif ! if (bpebc(8,imag).eq.-6)

            do i=1,3
              do j=1,3
                bpetm(i,j,iplan,imag)=ts(i,j)
                bpetm(i,j+3,iplan,imag)=tsinv(i,j)
              enddo
            enddo

          endif !check if normal vector is perpendicular to magnetization vector

        enddo !iplan

      enddo !imag

      do imag=1,nmag

c check, if all flanges appear twice, i.e. volume is closed

        iwarn=0

        nflange=0
        do iplan=1,ibpeplan(imag)
          do icorn=1,iabs(ibpecorn(iplan,imag))-1
            nflange=nflange+1
            ip1=icorn
            ip2=ip1+1
            bflange(1,nflange)=bpemag(1,ip1,iplan,imag)
            bflange(2,nflange)=bpemag(2,ip1,iplan,imag)
            bflange(3,nflange)=bpemag(3,ip1,iplan,imag)
            bflange(4,nflange)=bpemag(1,ip2,iplan,imag)
            bflange(5,nflange)=bpemag(2,ip2,iplan,imag)
            bflange(6,nflange)=bpemag(3,ip2,iplan,imag)
          enddo ! icorn
        enddo !iplan

        do iflange=1,nflange
          bflange(7,iflange)=1.d0
        enddo

        do iflange=1,nflange

          do i=iflange+1,nflange

            if (
     &          bflange(1,i).eq.bflange(1,iflange) .and.
     &          bflange(2,i).eq.bflange(2,iflange) .and.
     &          bflange(3,i).eq.bflange(3,iflange) .and.
     &          bflange(4,i).eq.bflange(4,iflange) .and.
     &          bflange(5,i).eq.bflange(5,iflange) .and.
     &          bflange(6,i).eq.bflange(6,iflange)
     &          .or.
     &          bflange(4,i).eq.bflange(1,iflange) .and.
     &          bflange(5,i).eq.bflange(2,iflange) .and.
     &          bflange(6,i).eq.bflange(3,iflange) .and.
     &          bflange(1,i).eq.bflange(4,iflange) .and.
     &          bflange(2,i).eq.bflange(5,iflange) .and.
     &          bflange(3,i).eq.bflange(6,iflange)
     &          ) then

              bflange(7,iflange)=bflange(7,iflange)+1.d0
              bflange(7,i)=bflange(7,i)+1.d0

            endif !hit

          enddo !i

          if (bflange(7,iflange).ne.2.d0.and.iwarn.eq.0) then
            iwarn=1
            print *,
c     &        '*** Error in bpolyini: Magnet is not a closed volume'
     &        '*** Warning in bpolyini: Magnet is not a closed volume'
            print *,'magnet: ',imag
            print *
c            stop
          endif

        enddo !iflange

c center of gravity is a point inside the magnet since shape is convex

        x0=0.d0
        y0=0.d0
        z0=0.d0

        i=0
        do iplan=1,ibpeplan(imag)
          do icorn=1,iabs(ibpecorn(iplan,imag))-1
            i=i+1
            x0=x0+bpemag(1,icorn,iplan,imag)
            y0=y0+bpemag(2,icorn,iplan,imag)
            z0=z0+bpemag(3,icorn,iplan,imag)
          enddo ! icorn
        enddo !iplan

        x0=x0/i
        y0=y0/i
        z0=z0/i

        bpexpos(imag)=x0

        do iplan=1,ibpeplan(imag)

          vnormlab(1)=bpetm(1,8,iplan,imag)
          vnormlab(2)=bpetm(2,8,iplan,imag)
          vnormlab(3)=bpetm(3,8,iplan,imag)

c does normal vector point outside?

          vsx=bpemag(1,1,iplan,imag)-x0
          vsy=bpemag(2,1,iplan,imag)-y0
          vsz=bpemag(3,1,iplan,imag)-z0

          if ( vsx*vnormlab(1) + vsy*vnormlab(2) + vsz*vnormlab(3)
     &        .lt. 0.d0 ) then
            print *
            print *,
     &        '*** Error in bpolyini: Normal vector is not pointing outside'
            print *,'magnet, plane: ',imag,iplan
            print *
            stop
          endif

          do icorn=3,iabs(ibpecorn(iplan,imag))-1

            ip1=icorn-2
            ip2=icorn-1

            v1x=bpemag(1,ip2,iplan,imag)-bpemag(1,ip1,iplan,imag)
            v1y=bpemag(2,ip2,iplan,imag)-bpemag(2,ip1,iplan,imag)
            v1z=bpemag(3,ip2,iplan,imag)-bpemag(3,ip1,iplan,imag)

            v2x=bpemag(1,icorn,iplan,imag)-bpemag(1,ip2,iplan,imag)
            v2y=bpemag(2,icorn,iplan,imag)-bpemag(2,ip2,iplan,imag)
            v2z=bpemag(3,icorn,iplan,imag)-bpemag(3,ip2,iplan,imag)

            vsx=v1y*v2z-v1z*v2y
            vsy=v1z*v2x-v1x*v2z
            vsz=v1x*v2y-v1y*v2x

            if ( abs(v2x*vnormlab(1)+ v2y*vnormlab(2)+ v2z*vnormlab(3))
     &          .gt.tiny ) then
              print *
              print *,'*** Error in bpolyini: Points not in a plane'
              print *,'magnet, plane, point: ',imag,iplan,icorn
              print *
              stop
            endif

            if ( vsx*vnormlab(1) + vsy*vnormlab(2) + vsz*vnormlab(3)
     &          .lt. 0.d0 ) then
              print *
              print *,'*** Error in bpolyini: Direction of rotation not unique'
              print *,'magnet, plane, point ',imag,iplan,icorn
              print *
              stop
            endif

          enddo !icorn=1,ncorn

        enddo ! iplan=1,nplan

      enddo ! imag=1,nmag

c transform everything to the nz=(0,0,1) system

      do imag=1,nmag

        qsign=0.d0

        do iplan=1,ibpeplan(imag)

          if (ibpecorn(iplan,imag).gt.0) then

            do i=1,3
              do j=1,3
                ts(i,j)=bpetm(i,j,iplan,imag)
              enddo
            enddo

            vnormlab(1)=bpetm(1,8,iplan,imag)
            vnormlab(2)=bpetm(2,8,iplan,imag)
            vnormlab(3)=bpetm(3,8,iplan,imag)

            do icorn=1,ibpecorn(iplan,imag)

              r1lab(1)=bpemag(1,icorn,iplan,imag)
              r1lab(2)=bpemag(2,icorn,iplan,imag)
              r1lab(3)=bpemag(3,icorn,iplan,imag)

              r1(1)=ts(1,1)*r1lab(1)+ts(1,2)*r1lab(2)+ts(1,3)*r1lab(3)
              r1(2)=ts(2,1)*r1lab(1)+ts(2,2)*r1lab(2)+ts(2,3)*r1lab(3)
              r1(3)=ts(3,1)*r1lab(1)+ts(3,2)*r1lab(2)+ts(3,3)*r1lab(3)

              bperot(1,icorn,iplan,imag)=r1(1)
              bperot(2,icorn,iplan,imag)=r1(2)
              bperot(3,icorn,iplan,imag)=r1(3)

            enddo !icorn=1,ncorn

            do icorn=1,iabs(ibpecorn(iplan,imag))-1

              ip2=icorn+1

              r1(1)=bperot(1,icorn,iplan,imag)
              r1(2)=bperot(2,icorn,iplan,imag)
              r1(3)=bperot(3,icorn,iplan,imag)

              r2(1)=bperot(1,ip2,iplan,imag)
              r2(2)=bperot(2,ip2,iplan,imag)
              r2(3)=bperot(3,ip2,iplan,imag)

              if (abs(r1(1)-r2(1)).gt.tiny) then

                a=(r2(2)-r1(2))/(r2(1)-r1(1))
                b=r1(2)-a*r1(1)

              else

                a=0.0d0
                b=r1(2)

              endif !(abs(r1(1)-r2(1)).gt.tiny)

              q=-((a*r1(1)+ a*r2(1) + 2*b)*(r1(1) - r2(1)))/2.d0

              qsign=qsign+q*(
     &           vnormlab(1)*bpebc(4,imag)
     &          +vnormlab(2)*bpebc(5,imag)
     &          +vnormlab(3)*bpebc(6,imag))

            enddo ! icorn

          endif !(ibpecorn(iplan,imag).gt.0) then

        enddo ! iplan=1,nplan

        if (abs(qsign).gt.1.d-10.and.bpebc(8,imag).ne.-6) then
          print *
          print *,
     &      '*** Warning in BPOLYINI: Sum of magnetic charge not zero ***'
          print *,'magnet: ',imag
          print *
        endif

      enddo ! imag=1,nmag

      open(unit=99,file='polymag.mag',form='formatted',status='unknown')

      xmn=1.0d30
      xmx=-1.0d30

      do imag=1,nmag
        do iplan=1,ibpeplan(imag)
          do icorn=1,abs(ibpecorn(iplan,imag))

            if (xmn.gt.bpemag(1,icorn,iplan,imag))
     &          xmn=bpemag(1,icorn,iplan,imag)
            if (xmx.lt.bpemag(1,icorn,iplan,imag))
     &          xmx=bpemag(1,icorn,iplan,imag)

            htup(1)=imag
            htup(2)=ibpecol(imag)
            htup(3)=iplan
            htup(4)=icorn*sign(1,ibpecorn(iplan,imag))
            htup(5)=bpemag(1,icorn,iplan,imag)
            htup(6)=bpemag(2,icorn,iplan,imag)
            htup(7)=bpemag(3,icorn,iplan,imag)
            htup(8)=bpebc(4,imag)
            htup(9)=bpebc(5,imag)
            htup(10)=bpebc(6,imag)

            vmaglab(1)=bpebc(4,imag)
            vmaglab(2)=bpebc(5,imag)
            vmaglab(3)=bpebc(6,imag)

            bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
            bpebc(7,imag)=bc

            if (bc.ne.0.d0) then
              if (xmn.gt.bpemag(1,icorn,iplan,imag))
     &          xmn=bpemag(1,icorn,iplan,imag)
              if (xmx.lt.bpemag(1,icorn,iplan,imag))
     &          xmx=bpemag(1,icorn,iplan,imag)
              write(99,'(4f7.0,6e15.5)')htup
            endif

      enddo !ncorn
      enddo !nplan
      enddo !nmag

      close(99)

      if (xstart.eq.9999.d0) xstart=xmn/1000.0d0-rangpm
      if (xstop .eq.9999.d0) xstop =xmx/1000.0d0+rangpm

      open(unit=34,file='polymag.err',status='unknown',form='formatted')

      write(lungfo,*)
      write(lungfo,*)'      SUBROUTINE BPOLYINI:'
      write(lungfo,*)
      write(lungfo,*)'      Comment on file polymag.in:'
      write(lungfo,*)'      ',usercom
      write(lungfo,*)'      WINPM, RANGPM: ',WINPM,RANGPM
      write(lungfo,*)'      BSCALEPM: ',BSCALEPM
      write(lungfo,*)
      write(lungfo,*)'      SHIFTLL,SHIFTLR:',SHIFTLL,SHIFTLR
      write(lungfo,*)'      SHIFTUL,SHIFTUR:',SHIFTUL,SHIFTUR
      write(lungfo,*)'      GAPPM:          ',GAPPM
      write(lungfo,*)

c sort by x-position and weed zero-magnets {

c store values
      do imag=1,nmagmax

        bpexpos0(imag)=bpexpos(imag)

        do i=1,8
          bpebc0(i,imag)=bpebc(i,imag)
        enddo

        ibpeplan0(imag)=ibpeplan(imag)

        do i=1,3
          do j=1,3
            bpemat0(j,i,imag)=bpemat(j,i,imag)
          enddo
        enddo

        do iplan=1,ibpeplan(imag)

          ibpecorn0(iplan,imag)=ibpecorn(iplan,imag)

          do icorn=1,abs(ibpecorn(iplan,imag))

            do i=1,6
              bpemag0(i,icorn,iplan,imag)=bpemag(i,icorn,iplan,imag)
            enddo

            do i=1,3
              bperot0(i,icorn,iplan,imag)=bperot(i,icorn,iplan,imag)
              do j=1,8
                bpetm0(i,j,iplan,imag)=bpetm(i,j,iplan,imag)
              enddo
            enddo

          enddo !icorn
        enddo !iplan
      enddo !imag

c weed

      imag=0
      do kmag=1,nmagmax

        if (bpebc0(7,kmag).eq.0.0d0) goto 999

      imag=imag+1

        bpexpos(imag)=bpexpos0(kmag)

        do i=1,8
          bpebc(i,imag)=bpebc0(i,kmag)
        enddo

        ibpeplan(imag)=ibpeplan0(kmag)

        do i=1,3
          do j=1,3
            bpemat(j,i,imag)=bpemat0(j,i,kmag)
          enddo
        enddo

        do iplan=1,ibpeplan0(kmag)

          ibpecorn(iplan,imag)=ibpecorn0(iplan,kmag)

          do icorn=1,abs(ibpecorn0(iplan,kmag))

            do i=1,6
              bpemag(i,icorn,iplan,imag)=bpemag0(i,icorn,iplan,kmag)
            enddo

            do i=1,3
              bperot(i,icorn,iplan,imag)=bperot0(i,icorn,iplan,kmag)
              do j=1,8
                bpetm(i,j,iplan,imag)=bpetm0(i,j,iplan,kmag)
              enddo
            enddo

          enddo
        enddo
999   continue
      enddo !imag

      nmag=imag
      nmagmax=nmag

      allocate(xsort(nmagmax))
      allocate(ysort(nmagmax))

c store values
      do imag=1,nmagmax

        do i=1,8
          bpebc0(i,imag)=bpebc(i,imag)
        enddo

        ibpeplan0(imag)=ibpeplan(imag)

        do i=1,3
          do j=1,3
            bpemat0(j,i,imag)=bpemat(j,i,imag)
          enddo
        enddo

        do iplan=1,ibpeplan(imag)

          ibpecorn0(iplan,imag)=ibpecorn(iplan,imag)

          do icorn=1,abs(ibpecorn(iplan,imag))

            do i=1,6
              bpemag0(i,icorn,iplan,imag)=bpemag(i,icorn,iplan,imag)
            enddo

            do i=1,3
              bperot0(i,icorn,iplan,imag)=bperot(i,icorn,iplan,imag)
              do j=1,8
                bpetm0(i,j,iplan,imag)=bpetm(i,j,iplan,imag)
              enddo
            enddo

          enddo !icorn
        enddo !iplan
      enddo !imag

      do imag=1,nmagmax
        bpexpos0(imag)=bpexpos(imag)
        xsort(imag)=bpexpos(imag)
        ysort(imag)=imag
      enddo

      call util_sort_func(nmagmax,xsort,ysort)

      imag=0
      do jmag=1,nmagmax

      imag=imag+1

        kmag=ysort(jmag)

        bpexpos(imag)=bpexpos0(kmag)

        do i=1,8
          bpebc(i,imag)=bpebc0(i,kmag)
        enddo

        ibpeplan(imag)=ibpeplan0(kmag)

        do i=1,3
          do j=1,3
            bpemat(j,i,imag)=bpemat0(j,i,kmag)
          enddo
        enddo

        do iplan=1,ibpeplan0(kmag)

          ibpecorn(iplan,imag)=ibpecorn0(iplan,kmag)

          do icorn=1,abs(ibpecorn0(iplan,kmag))

            do i=1,6
              bpemag(i,icorn,iplan,imag)=bpemag0(i,icorn,iplan,kmag)
            enddo

            do i=1,3
              bperot(i,icorn,iplan,imag)=bperot0(i,icorn,iplan,kmag)
              do j=1,8
                bpetm(i,j,iplan,imag)=bpetm0(i,j,iplan,kmag)
              enddo
            enddo

          enddo
        enddo
      enddo !imag

      deallocate(bpebc0)
      deallocate(bpemat0)
      deallocate(bpemag0)
      deallocate(bperot0)
      deallocate(bpetm0)
      deallocate(ibpeplan0)
      deallocate(ibpecorn0)
      deallocate(xsort)
      deallocate(ysort)
      deallocate(bpexpos0)

c sort by x-position }

      if (iplot.ne.0) then
        call bpolyplot(iplot,xplmin,xplmax,yplmin,yplmax,zplmin,zplmax,
     &    theta,phi,usercom)
      endif !iplot

      if (iaxint.eq.1.or.iaxint.eq.2.or.iaxint.eq.3) then

        xint=x0int*0.001d0
        yint=y0int*0.001d0
        zint=z0int*0.001d0

        vxint=0.0d0
        vyint=0.0d0
        vzint=0.0d0

        if (iaxint.eq.1) then
          vxint=1.0d0
        else if (iaxint.eq.2) then
          vyint=1.0d0
        else if (iaxint.eq.3) then
          vzint=1.0d0
        endif

        if (nstepint.ge.0) then

          bxi=0.0d0
          byi=0.0d0
          bzi=0.0d0

          do imag=1,nmag

            call bpolyint(imag,xint,yint,zint,
     &        vxint,vyint,vzint,
     &        bxint,byint,bzint)

            bxi=bxi+bxint
            byi=byi+byint
            bzi=bzi+bzint

          enddo

          write(lungfo,*)
          write(lungfo,*)'First field integrals [Tm]'
          write(lungfo,*)
     &      '(analytically,only correct for ensemble of rectangular magnets)'
          write(lungfo,*)

          if (iaxint.eq.1) then
            write(lungfo,*)'integration parallel to x-axis, through [mm]:'
            write(lungfo,*)sngl(x0int),sngl(y0int),sngl(z0int)
            write(lungfo,*)
          else if (iaxint.eq.2) then
            write(lungfo,*)'integration parallel to y-axis, through [mm]:'
            write(lungfo,*)sngl(x0int),sngl(y0int),sngl(z0int)
            write(lungfo,*)
          else if (iaxint.eq.3) then
            write(lungfo,*)'integration parallel to z-axis, through [mm]:'
            write(lungfo,*)sngl(x0int),sngl(y0int),sngl(z0int)
            write(lungfo,*)
          endif

          write(lungfo,*)bxi
          write(lungfo,*)byi
          write(lungfo,*)bzi

        endif !(nstepint.ge.0)

        if (nstepint.ne.0) then

          nstepint=abs(nstepint)

          bxi=0.0d0
          byi=0.0d0
          bzi=0.0d0

          do imag=1,nmag

            call bpolyintnum(imag,xint,yint,zint,
     &        vxint,vyint,vzint,
     &        bxint,byint,bzint)

            bxi=bxi+bxint
            byi=byi+byint
            bzi=bzi+bzint

          enddo

          write(lungfo,*)
          write(lungfo,*)'First field integrals [Tm]'
          write(lungfo,*)'(numerically)'
          write(lungfo,*)
          write(lungfo,*)
          write(lungfo,*)bxi
          write(lungfo,*)byi
          write(lungfo,*)bzi
          write(lungfo,*)
          write(lungfo,*)

        endif !(nstepint.ne.0)

      endif ! (iaxint.eq.1.or.iaxint.eq.2.or.iaxint.eq.3)

      ical=1

      else

        return

      endif !ical

      return
      end
+DECK,bpolyplot.
*CMZ :  3.06/00 15/02/2019  14.44.39  by  Michael Scheer
*CMZ :  3.05/00 25/04/2018  13.09.51  by  Michael Scheer
*CMZ :  3.02/03 10/11/2014  10.47.09  by  Michael Scheer
*CMZ :  3.02/00 09/10/2014  14.54.58  by  Michael Scheer
*CMZ :  3.01/05 12/06/2014  09.31.15  by  Michael Scheer
*CMZ :  3.01/02 28/01/2014  17.00.03  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  10.40.59  by  Michael Scheer
*CMZ :  2.63/05 22/07/2009  08.31.37  by  Michael Scheer
*CMZ :  2.63/03 18/02/2009  13.15.35  by  Michael Scheer
*CMZ :  2.54/01 01/03/2005  09.47.58  by  Michael Scheer
*CMZ :  2.53/05 25/02/2005  11.55.05  by  Michael Scheer
*CMZ :  2.52/05 17/08/2004  08.54.30  by  Michael Scheer
*CMZ :  1.01/01 11/08/2004  13.30.53  by  Michael Scheer
*CMZ :  1.01/00 02/03/2004  17.00.13  by  Michael Scheer
*CMZ :  1.00/01 27/02/2004  14.29.35  by  Michael Scheer
*CMZ :  1.00/00 26/02/2004  17.21.29  by  Michael Scheer
*CMZ :  0.99/13 26/02/2004  16.14.57  by  Michael Scheer
*CMZ :  0.99/12 26/02/2004  12.02.34  by  Michael Scheer
*CMZ :  0.99/11 25/02/2004  15.21.06  by  Michael Scheer
*CMZ :  0.99/10 25/02/2004  13.42.35  by  Michael Scheer
*CMZ :  0.99/09 20/02/2004  17.26.48  by  Michael Scheer
*CMZ :  0.99/08 20/02/2004  16.32.55  by  Michael Scheer
*CMZ :  0.99/07 16/02/2004  15.21.29  by  Michael Scheer
*CMZ :  0.99/03 12/02/2004  13.55.05  by  Michael Scheer
*CMZ :  0.99/00 26/01/2004  17.03.49  by  Michael Scheer
*CMZ :  0.00/08 23/01/2004  12.52.23  by  Michael Scheer
*CMZ :  0.00/07 16/01/2004  11.05.44  by  Michael Scheer
*CMZ :  0.00/06 09/01/2004  15.55.17  by  Michael Scheer
*CMZ :  0.00/05 23/12/2003  14.52.54  by  Michael Scheer
*CMZ :  0.00/04 23/12/2003  10.15.07  by  Michael Scheer
*CMZ :  0.00/02 15/12/2003  12.43.34  by  Michael Scheer
*CMZ :  0.00/01 10/12/2003  17.56.52  by  Michael Scheer
*-- Author :    Michael Scheer   02/12/2003
      subroutine bpolyplot(iplot,xmin,xmax,ymin,ymax,zmin,zmax,theta,phi,
     &  usercom)
+seq,gplhint.

+seq,bwpolyederf90u.

      implicit none

+seq,mshplt.

      real, dimension (:), allocatable :: xpl,ypl,zpl,zplm,xmpl,ympl,zmpl

      real
     &  xplb(2),yplb(2),zplb(2),
     &  xplbo(2),yplbo(2),zplbo(2),eps

      real xmin,xmax,ymin,ymax,zmin,zmax,theta,phi,
     &  x,y,z,bx,by,bz,dx,dy,dz,bxo,byo,bzo,bo,
     &  xmn,xmx,ymn,ymx,zmn,zmx,
     &  xmmn,xmmx,ymmn,ymmx,zmmn,zmmx,
     &  xplmin,xplmax,yplmin,yplmax,zplmin,zplmax,
     &  rmag,rcol,rcolo,rplan,rcorn,
     &  xc,yc,zc,xmc(1),ymc(1),zmc(1),dot0,circ0,pscal,vn,vnx,vny,vnz,
     &  rmtyp20,rmtyp24,rmtyp31

      integer i,iplot,iplot1,iplot10,iplot100,ibatch,idev,
     &  imag,icol,iplan,icorn,
     &  iplano,ncorno,iline,nline,
     &  ncorn,nplanmax,ncornmax,idx,igird,imago,impl,izero
     &  ,lunbase

      character(20) cdx
      character(23) cdxmm
      character(256) usercom

+seq,pawcmn.

+self,if=higz.
      data dot0/10./
      data circ0/10./
      data rmtyp20/20./
      data rmtyp24/24./
      data rmtyp31/31./
+self,if=-higz.
      data dot0/25./
      data circ0/5./
      data rmtyp20/20./
      data rmtyp24/-9999./
      data rmtyp31/31./
+self.

      data eps/0.01/

      nplanmax=0
      ncornmax=0

      iplano=0
      nline=0

      xmn=1.e10
      xmx=-1.e10
      ymn=1.e10
      ymx=-1.e10
      zmn=1.e10
      zmx=-1.e10

      open(unit=99,file='polymag.mag',status='old')

1     read(99,*,end=9) rmag,rcol,rplan,rcorn,x,y,z,bx,by,bz
      if (bx**2+by**2+bz**2.eq.0.0d0) goto 1

      nline=nline+1

      imag=rmag
      icol=rcol
      iplan=rplan
      icorn=rcorn

      if (iplan.gt.nplanmax) nplanmax=iplan
      if (abs(icorn).gt.ncornmax) ncornmax=abs(icorn)

      if (x.lt.xmn) xmn=x
      if (x.gt.xmx) xmx=x
      if (y.lt.ymn) ymn=y
      if (y.gt.ymx) ymx=y
      if (z.lt.zmn) zmn=z
      if (z.gt.zmx) zmx=z

      goto 1

9     close (99)

      allocate(xpl(ncornmax))
      allocate(ypl(ncornmax))
      allocate(zpl(ncornmax))
      allocate(zplm(ncornmax))

      allocate(xmpl(ncornmax*nplanmax))
      allocate(ympl(ncornmax*nplanmax))
      allocate(zmpl(ncornmax*nplanmax))

c initialize plotting

      call util_test_batch(ibatch)

      if (ibatch.eq.0) then
        idev=1   !x11
      else
        idev=0
      endif

c      call mplint(idev)
      lunbase=300000
      call util_get_free_lun(lunbase)
      print*,' '
      print*,
     &  '--- BPOLYPLOT: File polymag*.eps will be generated according plotting option in polymag.in'
      print*,' '
      call mshplt_init(lunbase,-20.,-20.,0,0,800,800,
     &  'polymag.eps',
     &  '',
     &  '',
c     &  'polymag_viewer.sh',
c     &  'polymag_kill_viewer.sh',
     &  0.0)
      call mplopt('DATE',1)
      call mplset('YGTI',1.0)
      call mplset('GSIZ',0.5)

      iplot100=abs(iplot)/100
      iplot10=(abs(iplot)-iplot100*100)/10
      iplot1=abs(iplot)-iplot100*100-iplot10*10

c--- Open plotfiles {

      open(unit=99,file='polymag.mag',status='old')

c--- Open plotfiles }

      iplano=1

      if (xmin.eq.9999.) then
        xplmin=xmn
      else
        xplmin=xmin
      endif

      if (xmax.eq.9999.) then
        xplmax=xmx
      else
        xplmax=xmax
      endif

      if (ymin.eq.9999.) then
        yplmin=ymn
      else
        yplmin=ymin
      endif

      if (ymax.eq.9999.) then
        yplmax=ymx
      else
        yplmax=ymax
      endif

      if (zmin.eq.9999.) then
        zplmin=zmn
      else
        zplmin=zmin
      endif

      if (zmax.eq.9999.) then
        zplmax=zmx
      else
        zplmax=zmax
      endif

      dx=(xplmax-xplmin)*0.05
      if (xmin.eq.9999.) then
        xplmin=xplmin-dx
      endif

      if (xmax.eq.9999.) then
        xplmax=xplmax+dx
      endif

      dy=(yplmax-yplmin)*0.05
      if (ymin.eq.9999.) then
        yplmin=yplmin-dy
      endif

      if (ymax.eq.9999.) then
        yplmax=yplmax+dy
      endif

      dz=(zplmax-zplmin)*0.05
      if (zmin.eq.9999.) then
        zplmin=zplmin-dz
      endif

      if (zmax.eq.9999.) then
        zplmax=zplmax+dz
      endif

      if (xplmax.le.xplmin.or.zplmax.le.zplmin.or.zplmax.le.zplmin) then
        print *,'*** Warning in BPOLYPLOT: Bad coordinate system for plotting '
        goto 9999
      endif

      pscal=sqrt(10000./((xplmax-xplmin)*(zplmax-zplmin)))

c--- Only 3D plot {

      if (abs(iplot100).eq.1) then

c y is vertical (WAVE-system)

        call mplfr3(xplmin,xplmax,-zplmax,-zplmin,yplmin,yplmax,theta,phi,'W')

        do iline=1,nline

11        read(99,*) rmag,rcol,rplan,rcorn,x,y,z,bx,by,bz
          if (bx**2+by**2+bz**2.eq.0.0d0) goto 11

          imag=rmag
          icol=rcol
          iplan=rplan
          icorn=rcorn

          ncorn=abs(icorn)

          if (iline.eq.nline) then

            xpl(ncorn)=x
            ypl(ncorn)=y
            zpl(ncorn)=z

            iplano=iplan
            ncorno=ncorn
            rcolo=rcol

          endif !(iline.eq.nline

          if(iplan.ne.iplano.or.iline.eq.nline) then

            do i=1,ncorno
              if (
     &          xpl(i).lt.xplmin.or.
     &          xpl(i).gt.xplmax.or.
     &          ypl(i).lt.yplmin.or.
     &          ypl(i).gt.yplmax.or.
     &          zpl(i).lt.zplmin.or.
     &          zpl(i).gt.zplmax
     &          ) goto 7
            enddo

            do i=1,ncorno
              zplm(i)=-zpl(i)
            enddo

            call mgset('PLCI',1.)
            call mpl3(ncorno,xpl,zplm,ypl)

            xc=0.
            yc=0.
            zc=0.

            do i=1,ncorno-1
              xc=xc+xpl(i)
              yc=yc+ypl(i)
              zc=zc+zpl(i)
            enddo

            xc=xc/(ncorno-1)
            yc=yc/(ncorno-1)
            zc=zc/(ncorno-1)

            do i=1,ncorno
              xpl(i)=xpl(i)+(xc-xpl(i))*0.015*rcolo
              ypl(i)=ypl(i)+(yc-ypl(i))*0.015*rcolo
              zpl(i)=zpl(i)+(zc-zpl(i))*0.015*rcolo
              zplm(i)=-zpl(i)
            enddo

            call mgset('PLCI',rcolo)
            call mpl3(ncorno,xpl,zplm,ypl)
 7        continue

        endif !iplano

        xpl(ncorn)=x
        ypl(ncorn)=y
        zpl(ncorn)=z

        iplano=iplan
        ncorno=ncorn
        rcolo=rcol

      enddo !nline

      dx=xplmax-xplmin
      idx=nint(log10(dx)-1)
      dx=10.**idx

      xpl(1)=xplmin
      xpl(2)=xpl(1)+dx
      ypl(1)=yplmin-(yplmax-yplmin)*0.03
      ypl(2)=ypl(1)
      zpl(1)=-zplmax-(-zplmin+zplmax)*0.03
      zpl(2)=zpl(1)

      call mgset('PLCI',1.)
      call mpl3(2,xpl,zpl,ypl)

      xpl(2)=xpl(1)
      zpl(2)=zpl(1)+(-zplmin+zplmax)*0.03

      call mgset('PLCI',1.)
      call mpl3(2,xpl,zpl,ypl)

      xpl(1)=xpl(1)+dx
      xpl(2)=xpl(1)
      zpl(2)=zpl(1)+(-zplmin+zplmax)*0.03

      call mgset('PLCI',1.)
      call mpl3(2,xpl,zpl,ypl)
      call miztoc(nint(dx),cdx)

      dx=(xplmax-xplmin)/10.
      dy=(yplmax-yplmin)/10.
      dz=(zplmin-zplmax)/10.

      xpl(1)=xplmin-dx*7.
      xpl(2)=xpl(1)+dx*3.
      ypl(1)=yplmin+dy*3.
      ypl(2)=ypl(1)
      zpl(1)=-zplmax-dz*0.03
      zpl(2)=zpl(1)

      call mpl3(2,xpl,zpl,ypl)

      xpl(1)=xplmin-dx*7.
      xpl(2)=xpl(1)
      ypl(1)=yplmin+dy*3.
      ypl(2)=ypl(1)+dy*3.
      zpl(1)=-zplmax-dz*0.03
      zpl(2)=zpl(1)

      call mpl3(2,xpl,zpl,ypl)

      xpl(1)=xplmin-dx*7.
      xpl(2)=xpl(1)
      ypl(1)=yplmin+dy*3.
      ypl(2)=ypl(1)
      zpl(1)=-zplmax+dz*0.
      zpl(2)=zpl(1)+dz*3.

      call mpl3(2,xpl,zpl,ypl)

      call mplfra(0.,10.,0.,10.,'ABS')
      do i=1,idx+1
        cdxmm(i:i)=cdx(i:i)
      enddo
      cdxmm(idx+2:idx+4)=' mm'
      do i=idx+5,23
        cdxmm(i:i)=' '
      enddo

      call mtx(2.,9.5,usercom)
      call mtx(2.0,1.05,'x')
      call mtx(0.05,2.5,'y')
      call mtx(0.95,0.05,'z')
      call mtx(4.5,0.05,'scale ')
      call mtx(6.,0.05,cdxmm)

      call muwk(0,0)

      if (idev.ne.0) then
+self,if=-mshplt.
        write(6,*)
        write(6,*)'hit RETURN key to continue !'
        read(5,*)
+self.
      endif

      else  if (abs(iplot100).eq.2) then

c z is vertical

        call mplfr3(xplmin,xplmax,yplmin,yplmax,zplmin,zplmax,theta,phi,'W')

        do iline=1,nline

21        read(99,*) rmag,rcol,rplan,rcorn,x,y,z,bx,by,bz
          if (bx**2+by**2+bz**2.eq.0.0d0) goto 21

          imag=rmag
          icol=rcol
          iplan=rplan
          icorn=rcorn

          ncorn=abs(icorn)

          if (iline.eq.nline) then

            xpl(ncorn)=x
            ypl(ncorn)=y
            zpl(ncorn)=z

            iplano=iplan
            ncorno=ncorn
            rcolo=rcol

          endif !(iline.eq.nline

          if(iplan.ne.iplano.or.iline.eq.nline) then

            do i=1,ncorno
              if (
     &            xpl(i).lt.xplmin.or.
     &            xpl(i).gt.xplmax.or.
     &            ypl(i).lt.yplmin.or.
     &            ypl(i).gt.yplmax.or.
     &            zpl(i).lt.zplmin.or.
     &            zpl(i).gt.zplmax
     &          ) goto 17
            enddo

            call mgset('PLCI',1.)
            call mpl3(ncorno,xpl,ypl,zpl)

            xc=0.
            yc=0.
            zc=0.

            do i=1,ncorno-1
              xc=xc+xpl(i)
              yc=yc+ypl(i)
              zc=zc+zpl(i)
            enddo

            xc=xc/(ncorno-1)
            yc=yc/(ncorno-1)
            zc=zc/(ncorno-1)

            do i=1,ncorno
              xpl(i)=xpl(i)+(xc-xpl(i))*0.015*rcolo
              ypl(i)=ypl(i)+(yc-ypl(i))*0.015*rcolo
              zpl(i)=zpl(i)+(zc-zpl(i))*0.015*rcolo
              zplm(i)=-zpl(i)
            enddo

            call mgset('PLCI',rcolo)
            call mpl3(ncorno,xpl,ypl,zpl)
 17         continue

          endif !iplano

          xpl(ncorn)=x
          ypl(ncorn)=y
          zpl(ncorn)=z

          iplano=iplan
          ncorno=ncorn
          rcolo=rcol

        enddo !nline

        dx=xplmax-xplmin
        idx=nint(log10(dx)-1)
        dx=10.**idx

        xpl(1)=xplmin
        xpl(2)=xpl(1)+dx
        ypl(1)=yplmin-(yplmax-yplmin)*0.03
        ypl(2)=ypl(1)
        zpl(1)=zplmin-(zplmax-zplmin)*0.03
        zpl(2)=zpl(1)
        zplm(2)=-zpl(1)
        zplm(1)=-zpl(2)

        call mgset('PLCI',1.)
        call mpl3(2,xpl,ypl,zpl)

        xpl(2)=xpl(1)
        ypl(2)=ypl(1)+(yplmax-yplmin)*0.03

        call mgset('PLCI',1.)
        call mpl3(2,xpl,ypl,zpl)

        xpl(1)=xpl(1)+dx
        xpl(2)=xpl(1)
        ypl(2)=ypl(1)+(yplmax-yplmin)*0.03

        call mgset('PLCI',1.)
        call mpl3(2,xpl,ypl,zpl)

        dx=(xplmax-xplmin)/10.
        dy=(yplmax-yplmin)/10.
        dz=(zplmax-zplmin)/10.

        xpl(1)=xplmin-dx*5.5
        xpl(2)=xpl(1)+dx*3.
        ypl(1)=yplmin+dy*1.
        ypl(2)=ypl(1)
        zpl(1)=zplmin+dz*0.03
        zpl(2)=zpl(1)

        call mpl3(2,xpl,zpl,ypl)

        xpl(1)=xplmin-dx*5.5
        xpl(2)=xpl(1)
        ypl(1)=yplmin+dy*1.
        ypl(2)=ypl(1)+dy*3.
        zpl(1)=zplmin+dz*0.03
        zpl(2)=zpl(1)

        call mpl3(2,xpl,zpl,ypl)

        xpl(1)=xplmin-dx*5.5
        xpl(2)=xpl(1)
        ypl(1)=yplmin+dy*1.
        ypl(2)=ypl(1)
        zpl(1)=zplmin+dz*0.
        zpl(2)=zpl(1)+dz*3.

        call mpl3(2,xpl,zpl,ypl)

        dx=xplmax-xplmin
        idx=nint(log10(dx)-1)
        dx=10.**idx

        call miztoc(nint(dx),cdx)

        call mplfra(0.,10.,0.,10.,'ABS')
        do i=1,idx+1
          cdxmm(i:i)=cdx(i:i)
        enddo
        cdxmm(idx+2:idx+4)=' mm'
        do i=idx+5,23
          cdxmm(i:i)=' '
        enddo

        call mtx(2.3,0.2,'x')
        call mtx(0.8,1.5,'z')
        call mtx(0.0,0.6,'y')
        call mtx(2.,9.5,usercom)
        call mtx(4.5,0.05,'scale ')
        call mtx(6.,0.05,cdxmm)

        call muwk(0,0)

        if (idev.ne.0) then
+self,if=-mshplt.
          write(6,*)
          write(6,*)'hit RETURN key to continue !'
          read(5,*)
+self.
        endif

      endif !iplot100

c--- Only 3D plot }

c--- 3D, top and side views {

      if (iplot10.ne.0) then

        call mtitle(usercom)

        call mplset('YMGL',0.5)
        call mplzon(1,1,1,' ')
        call mplfra(0.,10.,0.,10.,'AB')
        call mgset('CHHE',0.4)
        call mtx(3.5,5.3,'upper magnets')
        call mtx(3.5,0.15,'lower magnets')
        call mgset('CHHE',0.25)
        call mplset('YMGL',2.)

        call mplzon(2,2,1,'S')

        rewind(99)
        iplano=1

c--- 3D {

        if (abs(iplot10).eq.1) then

c y is vertical (WAVE-system)

          call mplfr3(xplmin,xplmax,-zplmax,-zplmin,yplmin,yplmax,theta,phi,'W')

          do iline=1,nline

31          read(99,*) rmag,rcol,rplan,rcorn,x,y,z,bx,by,bz
            if (bx**2+by**2+bz**2.eq.0.0d0) goto 31

            imag=rmag
            icol=rcol
            iplan=rplan
            icorn=rcorn

            ncorn=abs(icorn)

            if (iline.eq.nline) then

              xpl(ncorn)=x
              ypl(ncorn)=y
              zpl(ncorn)=z

              iplano=iplan
              ncorno=ncorn
              rcolo=rcol

            endif !(iline.eq.nline

            if(iplan.ne.iplano.or.iline.eq.nline) then

              do i=1,ncorno
                if (
     &            xpl(i).lt.xplmin.or.
     &            xpl(i).gt.xplmax.or.
     &            ypl(i).lt.yplmin.or.
     &            ypl(i).gt.yplmax.or.
     &            zpl(i).lt.zplmin.or.
     &            zpl(i).gt.zplmax
     &            ) goto 8
              enddo

              do i=1,ncorno
                zplm(i)=-zpl(i)
              enddo

              call mgset('PLCI',1.)
              call mpl3(ncorno,xpl,zplm,ypl)

              xc=0.
              yc=0.
              zc=0.

              do i=1,ncorno-1
                xc=xc+xpl(i)
                yc=yc+ypl(i)
                zc=zc+zpl(i)
              enddo

              xc=xc/(ncorno-1)
              yc=yc/(ncorno-1)
              zc=zc/(ncorno-1)

              do i=1,ncorno
                xpl(i)=xpl(i)+(xc-xpl(i))*0.015*rcolo
                ypl(i)=ypl(i)+(yc-ypl(i))*0.015*rcolo
                zpl(i)=zpl(i)+(zc-zpl(i))*0.015*rcolo
                zplm(i)=-zpl(i)
              enddo

              call mgset('PLCI',rcolo)
              call mpl3(ncorno,xpl,zplm,ypl)
 8            continue

            endif !iplano

            xpl(ncorn)=x
            ypl(ncorn)=y
            zpl(ncorn)=z

            iplano=iplan
            ncorno=ncorn
            rcolo=rcol

          enddo !nline

          dx=xplmax-xplmin
          idx=nint(log10(dx)-1)
          dx=10.**idx

          xpl(1)=xplmin
          xpl(2)=xpl(1)+dx
          ypl(1)=yplmin-(yplmax-yplmin)*0.03
          ypl(2)=ypl(1)
          zpl(1)=-zplmax-(-zplmin+zplmax)*0.03
          zpl(2)=zpl(1)

          call mgset('PLCI',1.)
          call mpl3(2,xpl,zpl,ypl)

          xpl(2)=xpl(1)
          zpl(2)=zpl(1)+(-zplmin+zplmax)*0.03

          call mgset('PLCI',1.)
          call mpl3(2,xpl,zpl,ypl)

          xpl(1)=xpl(1)+dx
          xpl(2)=xpl(1)
          zpl(2)=zpl(1)+(-zplmin+zplmax)*0.03

          call mgset('PLCI',1.)
          call mpl3(2,xpl,zpl,ypl)
          call miztoc(nint(dx),cdx)

          dx=(xplmax-xplmin)/10.
          dy=(yplmax-yplmin)/10.
          dz=(zplmin-zplmax)/10.

          xpl(1)=xplmin-dx*7.
          xpl(2)=xpl(1)+dx*3.
          ypl(1)=yplmin+dy*3.
          ypl(2)=ypl(1)
          zpl(1)=-zplmax-dz*0.03
          zpl(2)=zpl(1)

          call mpl3(2,xpl,zpl,ypl)

          xpl(1)=xplmin-dx*7.
          xpl(2)=xpl(1)
          ypl(1)=yplmin+dy*3.
          ypl(2)=ypl(1)+dy*3.
          zpl(1)=-zplmax-dz*0.03
          zpl(2)=zpl(1)

          call mpl3(2,xpl,zpl,ypl)

          xpl(1)=xplmin-dx*7.
          xpl(2)=xpl(1)
          ypl(1)=yplmin+dy*3.
          ypl(2)=ypl(1)
          zpl(1)=-zplmax+dz*0.
          zpl(2)=zpl(1)+dz*3.

          call mpl3(2,xpl,zpl,ypl)

          call mplfra(0.,10.,0.,10.,'ABS')
          do i=1,idx+1
            cdxmm(i:i)=cdx(i:i)
          enddo
          cdxmm(idx+2:idx+4)=' mm'
          do i=idx+5,23
            cdxmm(i:i)=' '
          enddo

c          call mtx(2.,9.5,usercom)
          call mtx(2.0,1.05,'x')
          call mtx(-0.25,2.5,'y')
          call mtx(0.95,0.05,'z')
          call mtx(4.5,0.05,'scale ')
          call mtx(6.,0.05,cdxmm)

        else  if (abs(iplot10).eq.2) then

c z is vertical

          call mplfr3(xplmin,xplmax,yplmin,yplmax,zplmin,zplmax,theta,phi,'W')

          do iline=1,nline

41          read(99,*) rmag,rcol,rplan,rcorn,x,y,z,bx,by,bz
            if (bx**2+by**2+bz**2.eq.0.0d0) goto 41

            imag=rmag
            icol=rcol
            iplan=rplan
            icorn=rcorn

            ncorn=abs(icorn)

            if (iline.eq.nline) then

              xpl(ncorn)=x
              ypl(ncorn)=y
              zpl(ncorn)=z

              iplano=iplan
              ncorno=ncorn
              rcolo=rcol

            endif !(iline.eq.nline

            if(iplan.ne.iplano.or.iline.eq.nline) then

              do i=1,ncorno
                if (
     &            xpl(i).lt.xplmin.or.
     &            xpl(i).gt.xplmax.or.
     &            ypl(i).lt.yplmin.or.
     &            ypl(i).gt.yplmax.or.
     &            zpl(i).lt.zplmin.or.
     &            zpl(i).gt.zplmax
     &            ) goto 18
              enddo

              call mgset('PLCI',1.)
              call mpl3(ncorno,xpl,ypl,zpl)

              xc=0.
              yc=0.
              zc=0.

              do i=1,ncorno-1
                xc=xc+xpl(i)
                yc=yc+ypl(i)
                zc=zc+zpl(i)
              enddo

              xc=xc/(ncorno-1)
              yc=yc/(ncorno-1)
              zc=zc/(ncorno-1)

              do i=1,ncorno
                xpl(i)=xpl(i)+(xc-xpl(i))*0.015*rcolo
                ypl(i)=ypl(i)+(yc-ypl(i))*0.015*rcolo
                zpl(i)=zpl(i)+(zc-zpl(i))*0.015*rcolo
                zplm(i)=-zpl(i)
              enddo

              call mgset('PLCI',rcolo)
              call mpl3(ncorno,xpl,ypl,zpl)
 18           continue

            endif !iplano

            xpl(ncorn)=x
            ypl(ncorn)=y
            zpl(ncorn)=z

            iplano=iplan
            ncorno=ncorn
            rcolo=rcol

          enddo !nline

          dx=xplmax-xplmin
          idx=nint(log10(dx)-1)
          dx=10.**idx

          xpl(1)=xplmin
          xpl(2)=xpl(1)+dx
          ypl(1)=yplmin-(yplmax-yplmin)*0.03
          ypl(2)=ypl(1)
          zpl(1)=zplmin-(zplmax-zplmin)*0.03
          zpl(2)=zpl(1)
          zplm(2)=-zpl(1)
          zplm(1)=-zpl(2)

          call mgset('PLCI',1.)
          call mpl3(2,xpl,ypl,zpl)

          xpl(2)=xpl(1)
          ypl(2)=ypl(1)+(yplmax-yplmin)*0.03

          call mgset('PLCI',1.)
          call mpl3(2,xpl,ypl,zpl)

          xpl(1)=xpl(1)+dx
          xpl(2)=xpl(1)
          ypl(2)=ypl(1)+(yplmax-yplmin)*0.03

          call mgset('PLCI',1.)
          call mpl3(2,xpl,ypl,zpl)

          dx=(xplmax-xplmin)/10.
          dy=(yplmax-yplmin)/10.
          dz=(zplmax-zplmin)/10.

          xpl(1)=xplmin-dx*5.5
          xpl(2)=xpl(1)+dx*3.
          ypl(1)=yplmin+dy*1.
          ypl(2)=ypl(1)
          zpl(1)=zplmin+dz*0.03
          zpl(2)=zpl(1)

          call mpl3(2,xpl,zpl,ypl)

          xpl(1)=xplmin-dx*5.5
          xpl(2)=xpl(1)
          ypl(1)=yplmin+dy*1.
          ypl(2)=ypl(1)+dy*3.
          zpl(1)=zplmin+dz*0.03
          zpl(2)=zpl(1)

          call mpl3(2,xpl,zpl,ypl)

          xpl(1)=xplmin-dx*5.5
          xpl(2)=xpl(1)
          ypl(1)=yplmin+dy*1.
          ypl(2)=ypl(1)
          zpl(1)=zplmin+dz*0.
          zpl(2)=zpl(1)+dz*3.

          call mpl3(2,xpl,zpl,ypl)

          dx=xplmax-xplmin
          idx=nint(log10(dx)-1)
          dx=10.**idx

          call miztoc(nint(dx),cdx)

          call mplfra(0.,10.,0.,10.,'ABS')
          do i=1,idx+1
            cdxmm(i:i)=cdx(i:i)
          enddo
          cdxmm(idx+2:idx+4)=' mm'
          do i=idx+5,23
            cdxmm(i:i)=' '
          enddo

          call mtx(2.3,0.2,'x')
          call mtx(0.8,1.5,'z')
          call mtx(0.0,0.6,'y')
c          call mtx(2.,9.5,usercom)
          call mtx(4.5,0.05,'scale ')
          call mtx(6.,0.05,cdxmm)

        endif !iplot10

c--- 3D }

c--- y vs z or z vs y {

        if (iplot10.eq.1) then
          call mplfra(zplmin,zplmax,yplmin,yplmax,' ')
          call mplax('z (mm)', 'y (mm)')
          call bpolypl2(forzpl,forypl,forcol,23)
        else if (iplot10.eq.2) then
          call mplfra(yplmin,yplmax,zplmin,zplmax,' ')
          call mplax('y (mm)', 'z (mm)')
          call bpolypl2(forypl,forzpl,forcol,23)
        endif

        rewind(99)
        iplano=1

        do iline=1,nline

51        read(99,*) rmag,rcol,rplan,rcorn,x,y,z,bx,by,bz
          if (bx**2+by**2+bz**2.eq.0.0d0) goto 51

          imag=rmag
          icol=rcol
          iplan=rplan
          icorn=rcorn

          ncorn=abs(icorn)

          if (iline.eq.nline) then

            xpl(ncorn)=x
            ypl(ncorn)=y
            zpl(ncorn)=z

            iplano=iplan
            ncorno=ncorn
            rcolo=rcol

          endif !(iline.eq.nline

          if(iplan.ne.iplano.or.iline.eq.nline) then

            do i=1,ncorno
              zplm(i)=-zpl(i)
            enddo

            call mgset('PLCI',1.)

            if (iplot10.eq.1) then
              call mpl(ncorno,zpl,ypl)
            else if (iplot10.eq.2) then
              call mpl(ncorno,ypl,zpl)
            endif

            xc=0.
            yc=0.
            zc=0.

            do i=1,ncorno-1
              xc=xc+xpl(i)
              yc=yc+ypl(i)
              zc=zc+zpl(i)
            enddo

            xc=xc/(ncorno-1)
            yc=yc/(ncorno-1)
            zc=zc/(ncorno-1)

            izero=0
            do i=1,ncorno
              if (
     &          abs(yc-ypl(i)).gt.1.0e-6 .and. abs(zc-zpl(i)).gt.1.0e-6
     &          ) izero=1
              xpl(i)=xpl(i)+(xc-xpl(i))*0.03*rcolo
              ypl(i)=ypl(i)+(yc-ypl(i))*0.03*rcolo
              zpl(i)=zpl(i)+(zc-zpl(i))*0.03*rcolo
              zplm(i)=-zpl(i)
            enddo

            call mgset('PLCI',rcolo)

            if (iplot10.eq.1) then
              if (izero.ne.0) call mpl(ncorno,zpl,ypl)
            else if (iplot10.eq.2) then
              if (izero.ne.0) call mpl(ncorno,ypl,zpl)
            endif

          endif !iplano

          xpl(ncorn)=x
          ypl(ncorn)=y
          zpl(ncorn)=z

          iplano=iplan
          ncorno=ncorn
          rcolo=rcol

        enddo !nline

        if (iplot10.eq.1) then
          call bpolypl2(forzpl,forypl,forcol,23)
        else if (iplot10.eq.2) then
          call bpolypl2(forypl,forzpl,forcol,23)
        endif

c--- y vs z or z vs y }

c--- top views of girder {

        call mplzon(1,4,3,'S')

        do igird=1,2

c--- z vs x, y is vertical coordinate {

          call mplfra(xplmin,xplmax,zplmin,zplmax,' ')
          call mplax('x (mm)', 'z (mm)')
          call bpolypl2(forxpl,forzpl,forcol,13)

          rewind(99)
61        read(99,*) rmag,rcol,rplan,rcorn,x,y,z,bx,by,bz
          if (bx**2+by**2+bz**2.eq.0.0d0) goto 61
          backspace(99)
          imago=rmag
          iplano=1
          impl=0

          do iline=1,nline

71          read(99,*) rmag,rcol,rplan,rcorn,x,y,z,bx,by,bz
            if (bx**2+by**2+bz**2.eq.0.0d0) goto 71

            imag=rmag
            icol=rcol
            iplan=rplan
            icorn=rcorn

            ncorn=abs(icorn)

            if (iline.eq.nline) then

              xpl(ncorn)=x
              ypl(ncorn)=y
              zpl(ncorn)=z

              iplano=iplan
              ncorno=ncorn
              rcolo=rcol

            endif !(iline.eq.nline

            if (imag.ne.imago.or.iline.eq.nline) then

              xmc(1)=0.
              ymc(1)=0.
              zmc(1)=0.

              xmmx=-1.0e30
              xmmn= 1.0e30
              ymmx=-1.0e30
              ymmn= 1.0e30
              zmmx=-1.0e30
              zmmn= 1.0e30

              do i=1,impl-1
                xmc(1)=xmc(1)+xmpl(i)
                ymc(1)=ymc(1)+ympl(i)
                zmc(1)=zmc(1)+zmpl(i)
                if (xmpl(i).gt.xmmx) xmmx=xmpl(i)
                if (xmpl(i).lt.xmmn) xmmn=xmpl(i)
                if (ympl(i).gt.ymmx) ymmx=ympl(i)
                if (ympl(i).lt.ymmn) ymmn=ympl(i)
                if (zmpl(i).gt.zmmx) zmmx=zmpl(i)
                if (zmpl(i).lt.zmmn) zmmn=zmpl(i)
              enddo

              xmc(1)=xmc(1)/(impl-1)
              ymc(1)=ymc(1)/(impl-1)
              zmc(1)=zmc(1)/(impl-1)

              dx=xmmx-xmmn
              dy=ymmx-ymmn
              dz=zmmx-zmmn

              impl=0

            endif !imag.ne.imago

            impl=impl+1

            if (iline.eq.nline) then

              xpl(ncorn)=x
              ypl(ncorn)=y
              zpl(ncorn)=z

              xmpl(impl)=x
              ympl(impl)=y
              zmpl(impl)=z

              bxo=bx
              byo=by
              bzo=bz

              iplano=iplan
              ncorno=ncorn
              rcolo=rcol

            endif !(iline.eq.nline

            if(iplan.ne.iplano.or.iline.eq.nline) then

              xc=0.
              yc=0.
              zc=0.

              do i=1,ncorno-1
                xc=xc+xpl(i)
                yc=yc+ypl(i)
                zc=zc+zpl(i)
              enddo

              xc=xc/(ncorno-1)
              yc=yc/(ncorno-1)
              zc=zc/(ncorno-1)

              if (igird.eq.1.and.yc.ge.0.0) then

                do i=1,ncorno
                  zplm(i)=-zpl(i)
                enddo

                call mgset('PLCI',1.)
                call mpl(ncorno,xpl,zpl)

                izero=0
                do i=1,ncorno
                  if (
     &              abs(xc-xpl(i)).gt.1.0e-6 .and. abs(zc-zpl(i)).gt.1.0e-6
     &              ) izero=1
                  xpl(i)=xpl(i)+(xc-xpl(i))*0.03*rcolo
                  ypl(i)=ypl(i)+(yc-ypl(i))*0.03*rcolo
                  zpl(i)=zpl(i)+(zc-zpl(i))*0.03*rcolo
                  zplm(i)=-zpl(i)
                enddo

                call mgset('PLCI',rcolo)
                if (izero.ne.0) call mpl(ncorno,xpl,zpl)

                if (imag.ne.imago.or.iline.eq.nline) then

                  bo=sqrt(bxo*bxo+byo*byo+bzo*bzo)

                  if (abs(bxo).lt.bo*eps) bxo=0.0
                  if (abs(byo).lt.bo*eps) byo=0.0
                  if (abs(bzo).lt.bo*eps) bzo=0.0

                  xplb(1)=xmc(1)-2.*bxo/bo*dx/8.
                  xplb(2)=xmc(1)+2.*bxo/bo*dx/8.
                  yplb(1)=ymc(1)-2.*byo/bo*dy/8.
                  yplb(2)=ymc(1)+2.*byo/bo*dy/8.
                  zplb(1)=zmc(1)-2.*bzo/bo*dz/8.
                  zplb(2)=zmc(1)+2.*bzo/bo*dz/8.

                  xplbo(1)=xplb(1)
                  xplbo(2)=xplb(2)
                  yplbo(1)=yplb(1)
                  yplbo(2)=yplb(2)
                  zplbo(1)=zplb(1)
                  zplbo(2)=zplb(2)

                  call mpl(2,xplbo,zplbo)

                  vn=sqrt((xplbo(2)-xplbo(1))**2+(zplbo(2)-zplbo(1))**2)

                  if (vn.ne.0.0d0) then

                    vnx=(xplbo(2)-xplbo(1))/vn
                    vnz=(zplbo(2)-zplbo(1))/vn

                    xplb(1)=xplbo(2)+vnz*dx/10.0-vnx*dx/10.0
                    zplb(1)=zplbo(2)-vnx*dz/10.0-vnz*dz/10.0

                    call mpl(2,xplb,zplb)

                    xplb(1)=xplbo(2)-vnz*dx/10.0-vnx*dx/10.0
                    zplb(1)=zplbo(2)+vnx*dz/10.0-vnz*dz/10.0

                    call mpl(2,xplb,zplb)

                  endif !vn

                  if (byo.gt.0.0) then
                    call mgset('MTYP',rmtyp24)
                    call mgset('MSCF',circ0*pscal/5.)
                    call mpm(1,xmc(1),zmc(1))
                    call mgset('MTYP',rmtyp20)
                    call mgset('MSCF',dot0*pscal/5.)
                    call mpm(1,xmc(1),zmc(1))
                  else if (byo.lt.0.0) then
                    call mgset('MTYP',rmtyp24)
                    call mgset('MSCF',circ0*pscal/5.)
                    call mpm(1,xmc(1),zmc(1))
                    call mgset('MTYP',rmtyp31)
                    call mgset('MSCF',dot0*pscal/5.)
                    call mpm(1,xmc(1),zmc(1))
                  endif

                endif !imago

              else if (igird.eq.2.and.yc.le.0.0) then

                do i=1,ncorno
                  zplm(i)=-zpl(i)
                enddo

                call mgset('PLCI',1.)
                call mpl(ncorno,xpl,zpl)

                izero=0
                do i=1,ncorno
                  if (
     &              abs(xc-xpl(i)).gt.1.0e-6 .and. abs(zc-zpl(i)).gt.1.0e-6
     &              ) izero=1
                  xpl(i)=xpl(i)+(xc-xpl(i))*0.03*rcolo
                  ypl(i)=ypl(i)+(yc-ypl(i))*0.03*rcolo
                  zpl(i)=zpl(i)+(zc-zpl(i))*0.03*rcolo
                  zplm(i)=-zpl(i)
                enddo

                call mgset('PLCI',rcolo)
                if (izero.ne.0) call mpl(ncorno,xpl,zpl)

                if (imag.ne.imago.or.iline.eq.nline) then

                  bo=sqrt(bxo*bxo+byo*byo+bzo*bzo)

                  if (abs(bxo).lt.bo*eps) bxo=0.0
                  if (abs(byo).lt.bo*eps) byo=0.0
                  if (abs(bzo).lt.bo*eps) bzo=0.0

                  xplb(1)=xmc(1)-2.*bxo/bo*dx/8.
                  xplb(2)=xmc(1)+2.*bxo/bo*dx/8.
                  yplb(1)=ymc(1)-2.*byo/bo*dy/8.
                  yplb(2)=ymc(1)+2.*byo/bo*dy/8.
                  zplb(1)=zmc(1)-2.*bzo/bo*dz/8.
                  zplb(2)=zmc(1)+2.*bzo/bo*dz/8.

                  xplbo(1)=xplb(1)
                  xplbo(2)=xplb(2)
                  yplbo(1)=yplb(1)
                  yplbo(2)=yplb(2)
                  zplbo(1)=zplb(1)
                  zplbo(2)=zplb(2)

                  call mpl(2,xplbo,zplbo)

                  vn=sqrt((xplbo(2)-xplbo(1))**2+(zplbo(2)-zplbo(1))**2)

                  if (vn.ne.0.0d0) then

                    vnx=(xplbo(2)-xplbo(1))/vn
                    vnz=(zplbo(2)-zplbo(1))/vn

                    xplb(1)=xplbo(2)+vnz*dx/10.0-vnx*dx/10.0
                    zplb(1)=zplbo(2)-vnx*dz/10.0-vnz*dz/10.0

                    call mpl(2,xplb,zplb)

                    xplb(1)=xplbo(2)-vnz*dx/10.0-vnx*dx/10.0
                    zplb(1)=zplbo(2)+vnx*dz/10.0-vnz*dz/10.0

                    call mpl(2,xplb,zplb)

                  endif !vn

                  if (byo.gt.0.0) then
                    call mgset('MTYP',rmtyp24)
                    call mgset('MSCF',circ0*pscal/5.)
                    call mpm(1,xmc(1),zmc(1))
                    call mgset('MTYP',rmtyp20)
                    call mgset('MSCF',dot0*pscal/5.)
                    call mpm(1,xmc(1),zmc(1))
                  else if (byo.lt.0.0) then
                    call mgset('MTYP',rmtyp24)
                    call mgset('MSCF',circ0*pscal/5.)
                    call mpm(1,xmc(1),zmc(1))
                    call mgset('MTYP',rmtyp31)
                    call mgset('MSCF',dot0*pscal/5.)
                    call mpm(1,xmc(1),zmc(1))
                  endif

                endif !imago

              endif !yc

            endif !iplano

            xpl(ncorn)=x
            ypl(ncorn)=y
            zpl(ncorn)=z

            xmpl(impl)=x
            ympl(impl)=y
            zmpl(impl)=z

            bxo=bx
            byo=by
            bzo=bz

            iplano=iplan
            ncorno=ncorn
            rcolo=rcol
            imago=imag

          enddo !nline

          call bpolypl2(forxpl,forzpl,forcol,13)

        enddo !igird

c--- y vs x }

        call muwk(0,0)

        if (idev.ne.0) then
+self,if=-mshplt.
          write(6,*)
          write(6,*)'hit RETURN key to continue !'
          read(5,*)
+self.
        endif

      else if (iplot10.eq.2) then

        call mplset('YMGL',0.5)
        call mplzon(1,1,1,' ')
        call mplfra(0.,10.,0.,10.,'AB')
        call mgset('CHHE',0.4)
        call mtx(3.5,5.3,'upper magnets')
        call mtx(3.5,0.15,'lower magnets')
        call mgset('CHHE',0.25)
        call mplset('YMGL',2.)

        call mplzon(1,4,3,'S')

        do igird=1,2

c--- z vs x, z is vertical coordinate {

          call mplfra(xplmin,xplmax,yplmin,yplmax,' ')
          call mplax('x (mm)', 'y (mm)')
          call bpolypl2(forxpl,forypl,forcol,12)

          rewind(99)
81        read(99,*) rmag,rcol,rplan,rcorn,x,y,z,bx,by,bz
          if (bx**2+by**2+bz**2.eq.0.0d0) goto 81
          backspace(99)
          imago=rmag
          iplano=1
          impl=0

          do iline=1,nline

91          read(99,*) rmag,rcol,rplan,rcorn,x,y,z,bx,by,bz
            if (bx**2+by**2+bz**2.eq.0.0d0) goto 91

            imag=rmag
            icol=rcol
            iplan=rplan
            icorn=rcorn

            ncorn=abs(icorn)

            if (imag.ne.imago.or.iline.eq.nline) then

              xmc(1)=0.
              ymc(1)=0.
              zmc(1)=0.

              xmmx=-1.0e30
              xmmn= 1.0e30
              ymmx=-1.0e30
              ymmn= 1.0e30
              zmmx=-1.0e30
              zmmn= 1.0e30

              do i=1,impl-1
                xmc(1)=xmc(1)+xmpl(i)
                ymc(1)=ymc(1)+ympl(i)
                zmc(1)=zmc(1)+zmpl(i)
                if (xmpl(i).gt.xmmx) xmmx=xmpl(i)
                if (xmpl(i).lt.xmmn) xmmn=xmpl(i)
                if (ympl(i).gt.ymmx) ymmx=ympl(i)
                if (ympl(i).lt.ymmn) ymmn=ympl(i)
                if (zmpl(i).gt.zmmx) zmmx=zmpl(i)
                if (zmpl(i).lt.zmmn) zmmn=zmpl(i)
              enddo

              xmc(1)=xmc(1)/(impl-1)
              ymc(1)=ymc(1)/(impl-1)
              zmc(1)=zmc(1)/(impl-1)

              dx=xmmx-xmmn
              dy=ymmx-ymmn
              dz=zmmx-zmmn

              impl=0

            endif !imag.ne.imago

            impl=impl+1

            if (iline.eq.nline) then

              xpl(ncorn)=x
              ypl(ncorn)=y
              zpl(ncorn)=z

              xmpl(impl)=x
              ympl(impl)=y
              zmpl(impl)=z

              bxo=bx
              byo=by
              bzo=bz

              iplano=iplan
              ncorno=ncorn
              rcolo=rcol

            endif !(iline.eq.nline

            if(iplan.ne.iplano.or.iline.eq.nline) then

              xc=0.
              yc=0.
              zc=0.

              do i=1,ncorno-1
                xc=xc+xpl(i)
                yc=yc+ypl(i)
                zc=zc+zpl(i)
              enddo

              xc=xc/(ncorno-1)
              yc=yc/(ncorno-1)
              zc=zc/(ncorno-1)

              if (igird.eq.1.and.zc.ge.0.0) then

                do i=1,ncorno
                  zplm(i)=-zpl(i)
                enddo

                call mgset('PLCI',1.)
                call mpl(ncorno,xpl,ypl)

                izero=0
                do i=1,ncorno
                  if (
     &              abs(yc-ypl(i)).gt.1.0e-6 .and. abs(xc-xpl(i)).gt.1.0e-6
     &              ) izero=1
                  xpl(i)=xpl(i)+(xc-xpl(i))*0.03*rcolo
                  ypl(i)=ypl(i)+(yc-ypl(i))*0.03*rcolo
                  zpl(i)=zpl(i)+(zc-zpl(i))*0.03*rcolo
                  zplm(i)=-zpl(i)
                enddo

                call mgset('PLCI',rcolo)
                if (izero.ne.0) call mpl(ncorno,xpl,ypl)

                if (imag.ne.imago.or.iline.eq.nline) then

                  bo=sqrt(bxo*bxo+byo*byo+bzo*bzo)

                  if (abs(bxo).lt.bo*eps) bxo=0.0
                  if (abs(byo).lt.bo*eps) byo=0.0
                  if (abs(bzo).lt.bo*eps) bzo=0.0

                  xplb(1)=xmc(1)-2.*bxo/bo*dx/8.
                  xplb(2)=xmc(1)+2.*bxo/bo*dx/8.
                  yplb(1)=ymc(1)-2.*byo/bo*dy/8.
                  yplb(2)=ymc(1)+2.*byo/bo*dy/8.
                  zplb(1)=zmc(1)-2.*bzo/bo*dz/8.
                  zplb(2)=zmc(1)+2.*bzo/bo*dz/8.

                  xplbo(1)=xplb(1)
                  xplbo(2)=xplb(2)
                  yplbo(1)=yplb(1)
                  yplbo(2)=yplb(2)
                  zplbo(1)=zplb(1)
                  zplbo(2)=zplb(2)

                  call mpl(2,xplbo,yplbo)

                  vn=sqrt((xplbo(2)-xplbo(1))**2+(yplbo(2)-yplbo(1))**2)

                  if (vn.ne.0.0d0) then
                    vnx=(xplbo(2)-xplbo(1))/vn
                    vny=(yplbo(2)-yplbo(1))/vn

                    xplb(1)=xplbo(2)+vny*dx/10.0-vnx*dx/10.0
                    yplb(1)=yplbo(2)-vnx*dy/10.0-vny*dy/10.0

                    call mpl(2,xplb,yplb)

                    xplb(1)=xplbo(2)-vny*dx/10.0-vnx*dx/10.0
                    yplb(1)=yplbo(2)+vnx*dy/10.0-vny*dy/10.0

                    call mpl(2,xplb,yplb)
                  endif !vn

                  if (byo.gt.0.0) then
                    call mgset('MTYP',rmtyp24)
                    call mgset('MSCF',circ0*pscal/5.)
                    call mpm(1,xmc(1),ymc(1))
                    call mgset('MTYP',rmtyp20)
                    call mgset('MSCF',dot0*pscal/5.)
                    call mpm(1,xmc(1),ymc(1))
                  else if (byo.lt.0.0) then
                    call mgset('MTYP',rmtyp24)
                    call mgset('MSCF',circ0*pscal/5.)
                    call mpm(1,xmc(1),ymc(1))
                    call mgset('MTYP',rmtyp31)
                    call mgset('MSCF',dot0*pscal/5.)
                    call mpm(1,xmc(1),ymc(1))
                  endif

                endif !imago

              else if (igird.eq.2.and.zc.le.0.0) then

                do i=1,ncorno
                  zplm(i)=-zpl(i)
                enddo

                call mgset('PLCI',1.)
                call mpl(ncorno,xpl,ypl)

                izero=0
                do i=1,ncorno
                  if (
     &              abs(yc-ypl(i)).gt.1.0e-6 .and. abs(xc-xpl(i)).gt.1.0e-6
     &              ) izero=1
                  xpl(i)=xpl(i)+(xc-xpl(i))*0.03*rcolo
                  ypl(i)=ypl(i)+(yc-ypl(i))*0.03*rcolo
                  zpl(i)=zpl(i)+(zc-zpl(i))*0.03*rcolo
                  zplm(i)=-zpl(i)
                enddo

                call mgset('PLCI',rcolo)
                if (izero.ne.0) call mpl(ncorno,xpl,ypl)

                if (imag.ne.imago.or.iline.eq.nline) then

                  bo=sqrt(bxo*bxo+byo*byo+bzo*bzo)

                  if (abs(bxo).lt.bo*eps) bxo=0.0
                  if (abs(byo).lt.bo*eps) byo=0.0
                  if (abs(bzo).lt.bo*eps) bzo=0.0

                  xplb(1)=xmc(1)-2.*bxo/bo*dx/8.
                  xplb(2)=xmc(1)+2.*bxo/bo*dx/8.
                  yplb(1)=ymc(1)-2.*byo/bo*dy/8.
                  yplb(2)=ymc(1)+2.*byo/bo*dy/8.
                  zplb(1)=zmc(1)-2.*bzo/bo*dz/8.
                  zplb(2)=zmc(1)+2.*bzo/bo*dz/8.

                  xplbo(1)=xplb(1)
                  xplbo(2)=xplb(2)
                  yplbo(1)=yplb(1)
                  yplbo(2)=yplb(2)
                  zplbo(1)=zplb(1)
                  zplbo(2)=zplb(2)

                  call mpl(2,xplbo,yplbo)

                  vn=sqrt((xplbo(2)-xplbo(1))**2+(yplbo(2)-yplbo(1))**2)

                  if (vn.ne.0.0d0) then
                    vnx=(xplbo(2)-xplbo(1))/vn
                    vny=(yplbo(2)-yplbo(1))/vn

                    xplb(1)=xplbo(2)+vny*dx/10.0-vnx*dx/10.0
                    yplb(1)=yplbo(2)-vnx*dy/10.0-vny*dy/10.0

                    call mpl(2,xplb,yplb)

                    xplb(1)=xplbo(2)-vny*dx/10.0-vnx*dx/10.0
                    yplb(1)=yplbo(2)+vnx*dy/10.0-vny*dy/10.0

                    call mpl(2,xplb,yplb)
                  endif !vn

                  if (byo.gt.0.0) then
                    call mgset('MTYP',rmtyp24)
                    call mgset('MSCF',circ0*pscal/5.)
                    call mpm(1,xmc(1),ymc(1))
                    call mgset('MTYP',rmtyp20)
                    call mgset('MSCF',dot0*pscal/5.)
                    call mpm(1,xmc(1),ymc(1))
                  else if (byo.lt.0.0) then
                    call mgset('MTYP',rmtyp24)
                    call mgset('MSCF',circ0*pscal/5.)
                    call mpm(1,xmc(1),ymc(1))
                    call mgset('MTYP',rmtyp31)
                    call mgset('MSCF',dot0*pscal/5.)
                    call mpm(1,xmc(1),ymc(1))
                  endif

                endif !imago

              endif !yc

            endif !iplano

            xpl(ncorn)=x
            ypl(ncorn)=y
            zpl(ncorn)=z

            xmpl(impl)=x
            ympl(impl)=y
            zmpl(impl)=z

            bxo=bx
            byo=by
            bzo=bz

            iplano=iplan
            ncorno=ncorn
            rcolo=rcol
            imago=imag

          enddo !nline

          call bpolypl2(forxpl,forypl,forcol,12)

        enddo !igird

c--- y vs x }

        call muwk(0,0)

        if (idev.ne.0) then
+self,if=-mshplt.
          write(6,*)
          write(6,*)'hit RETURN key to continue !'
          read(5,*)
+self.
        endif

        call muwk(0,0)

        if (idev.ne.0) then
+self,if=-mshplt.
          write(6,*)
          write(6,*)'hit RETURN key to continue !'
          read(5,*)
+self.
        endif

      endif !iplot10

c--- top views of girder}

c--- 3D, top and side views }

c--- top views of girder {

      if (iplot1.eq.1) then

        call mtitle(usercom)

        call mplset('YMGL',0.5)
        call mplzon(1,1,1,' ')
        call mplfra(0.,10.,0.,10.,'AB')
        call mgset('CHHE',0.4)
        call mtx(3.5,5.3,'upper magnets')
        call mtx(3.5,0.15,'lower magnets')
        call mgset('CHHE',0.25)
        call mplset('YMGL',2.)

        call mplzon(1,2,1,'S')

        do igird=1,2

c--- z vs x, y is vertical coordinate {

          call mplfra(xplmin,xplmax,zplmin,zplmax,' ')
          call mplax('x (mm)', 'z (mm)')
          call bpolypl2(forxpl,forzpl,forcol,13)

          rewind(99)
101       read(99,*) rmag,rcol,rplan,rcorn,x,y,z,bx,by,bz
          if (bx**2+by**2+bz**2.eq.0.0d0) goto 101
          backspace(99)
          imago=rmag
          iplano=1
          impl=0

          do iline=1,nline

102         read(99,*) rmag,rcol,rplan,rcorn,x,y,z,bx,by,bz
            if (bx**2+by**2+bz**2.eq.0.0d0) goto 102

            imag=rmag
            icol=rcol
            iplan=rplan
            icorn=rcorn

            ncorn=abs(icorn)

            if (iline.eq.nline) then

              xpl(ncorn)=x
              ypl(ncorn)=y
              zpl(ncorn)=z

              iplano=iplan
              ncorno=ncorn
              rcolo=rcol

            endif !(iline.eq.nline

            if (imag.ne.imago.or.iline.eq.nline) then

              xmc(1)=0.
              ymc(1)=0.
              zmc(1)=0.

              xmmx=-1.0e30
              xmmn= 1.0e30
              ymmx=-1.0e30
              ymmn= 1.0e30
              zmmx=-1.0e30
              zmmn= 1.0e30

              do i=1,impl-1
                xmc(1)=xmc(1)+xmpl(i)
                ymc(1)=ymc(1)+ympl(i)
                zmc(1)=zmc(1)+zmpl(i)
                if (xmpl(i).gt.xmmx) xmmx=xmpl(i)
                if (xmpl(i).lt.xmmn) xmmn=xmpl(i)
                if (ympl(i).gt.ymmx) ymmx=ympl(i)
                if (ympl(i).lt.ymmn) ymmn=ympl(i)
                if (zmpl(i).gt.zmmx) zmmx=zmpl(i)
                if (zmpl(i).lt.zmmn) zmmn=zmpl(i)
              enddo

              xmc(1)=xmc(1)/(impl-1)
              ymc(1)=ymc(1)/(impl-1)
              zmc(1)=zmc(1)/(impl-1)

              dx=xmmx-xmmn
              dy=ymmx-ymmn
              dz=zmmx-zmmn

              impl=0

            endif !imag.ne.imago

            impl=impl+1

            if (iline.eq.nline) then

              xpl(ncorn)=x
              ypl(ncorn)=y
              zpl(ncorn)=z

              xmpl(impl)=x
              ympl(impl)=y
              zmpl(impl)=z

              bxo=bx
              byo=by
              bzo=bz

              iplano=iplan
              ncorno=ncorn
              rcolo=rcol

            endif !(iline.eq.nline

            if(iplan.ne.iplano.or.iline.eq.nline) then

              xc=0.
              yc=0.
              zc=0.

              do i=1,ncorno-1
                xc=xc+xpl(i)
                yc=yc+ypl(i)
                zc=zc+zpl(i)
              enddo

              xc=xc/(ncorno-1)
              yc=yc/(ncorno-1)
              zc=zc/(ncorno-1)

              if (igird.eq.1.and.yc.ge.0.0) then

                do i=1,ncorno
                  zplm(i)=-zpl(i)
                enddo

                call mgset('PLCI',1.)
                call mpl(ncorno,xpl,zpl)

                izero=0
                do i=1,ncorno
                  if (
     &              abs(xc-xpl(i)).gt.1.0e-6 .and. abs(zc-zpl(i)).gt.1.0e-6
     &              ) izero=1
                  xpl(i)=xpl(i)+(xc-xpl(i))*0.03*rcolo
                  ypl(i)=ypl(i)+(yc-ypl(i))*0.03*rcolo
                  zpl(i)=zpl(i)+(zc-zpl(i))*0.03*rcolo
                  zplm(i)=-zpl(i)
                enddo

                call mgset('PLCI',rcolo)
                if (izero.ne.0) call mpl(ncorno,xpl,zpl)

                if (imag.ne.imago.or.iline.eq.nline) then

                  bo=sqrt(bxo*bxo+byo*byo+bzo*bzo)

                  if (abs(bxo).lt.bo*eps) bxo=0.0
                  if (abs(byo).lt.bo*eps) byo=0.0
                  if (abs(bzo).lt.bo*eps) bzo=0.0

                  xplb(1)=xmc(1)-2.*bxo/bo*dx/8.
                  xplb(2)=xmc(1)+2.*bxo/bo*dx/8.
                  yplb(1)=ymc(1)-2.*byo/bo*dy/8.
                  yplb(2)=ymc(1)+2.*byo/bo*dy/8.
                  zplb(1)=zmc(1)-2.*bzo/bo*dz/8.
                  zplb(2)=zmc(1)+2.*bzo/bo*dz/8.

                  xplbo(1)=xplb(1)
                  xplbo(2)=xplb(2)
                  yplbo(1)=yplb(1)
                  yplbo(2)=yplb(2)
                  zplbo(1)=zplb(1)
                  zplbo(2)=zplb(2)

                  call mpl(2,xplbo,zplbo)

                  vn=sqrt((xplbo(2)-xplbo(1))**2+(zplbo(2)-zplbo(1))**2)

                  if (vn.ne.0.0d0) then
                    vnx=(xplbo(2)-xplbo(1))/vn
                    vnz=(zplbo(2)-zplbo(1))/vn

                    xplb(1)=xplbo(2)+vnz*dx/10.0-vnx*dx/10.0
                    zplb(1)=zplbo(2)-vnx*dz/10.0-vnz*dz/10.0

                    call mpl(2,xplb,zplb)

                    xplb(1)=xplbo(2)-vnz*dx/10.0-vnx*dx/10.0
                    zplb(1)=zplbo(2)+vnx*dz/10.0-vnz*dz/10.0

                    call mpl(2,xplb,zplb)
                  endif !vn

                  if (byo.gt.0.0) then
                    call mgset('MTYP',rmtyp24)
                    call mgset('MSCF',circ0*pscal/5.)
                    call mpm(1,xmc(1),zmc(1))
                    call mgset('MTYP',rmtyp20)
                    call mgset('MSCF',dot0*pscal/5.)
                    call mpm(1,xmc(1),zmc(1))
                  else if (byo.lt.0.0) then
                    call mgset('MTYP',rmtyp24)
                    call mgset('MSCF',circ0*pscal/5.)
                    call mpm(1,xmc(1),zmc(1))
                    call mgset('MTYP',rmtyp31)
                    call mgset('MSCF',dot0*pscal/5.)
                    call mpm(1,xmc(1),zmc(1))
                  endif

                endif !imago

              else if (igird.eq.2.and.yc.le.0.0) then

                do i=1,ncorno
                  zplm(i)=-zpl(i)
                enddo

                call mgset('PLCI',1.)
                call mpl(ncorno,xpl,zpl)

                izero=0
                do i=1,ncorno
                  if (
     &              abs(xc-xpl(i)).gt.1.0e-6 .and. abs(zc-zpl(i)).gt.1.0e-6
     &              ) izero=1
                  xpl(i)=xpl(i)+(xc-xpl(i))*0.03*rcolo
                  ypl(i)=ypl(i)+(yc-ypl(i))*0.03*rcolo
                  zpl(i)=zpl(i)+(zc-zpl(i))*0.03*rcolo
                  zplm(i)=-zpl(i)
                enddo

                call mgset('PLCI',rcolo)
                if (izero.ne.0) call mpl(ncorno,xpl,zpl)

                if (imag.ne.imago.or.iline.eq.nline) then

                  bo=sqrt(bxo*bxo+byo*byo+bzo*bzo)

                  if (abs(bxo).lt.bo*eps) bxo=0.0
                  if (abs(byo).lt.bo*eps) byo=0.0
                  if (abs(bzo).lt.bo*eps) bzo=0.0

                  xplb(1)=xmc(1)-2.*bxo/bo*dx/8.
                  xplb(2)=xmc(1)+2.*bxo/bo*dx/8.
                  yplb(1)=ymc(1)-2.*byo/bo*dy/8.
                  yplb(2)=ymc(1)+2.*byo/bo*dy/8.
                  zplb(1)=zmc(1)-2.*bzo/bo*dz/8.
                  zplb(2)=zmc(1)+2.*bzo/bo*dz/8.

                  xplbo(1)=xplb(1)
                  xplbo(2)=xplb(2)
                  yplbo(1)=yplb(1)
                  yplbo(2)=yplb(2)
                  zplbo(1)=zplb(1)
                  zplbo(2)=zplb(2)

                  call mpl(2,xplbo,zplbo)

                  vn=sqrt((xplbo(2)-xplbo(1))**2+(zplbo(2)-zplbo(1))**2)
                  if (vn.ne.0.0d0) then
                    vnx=(xplbo(2)-xplbo(1))/vn
                    vnz=(zplbo(2)-zplbo(1))/vn

                    xplb(1)=xplbo(2)+vnz*dx/10.0-vnx*dx/10.0
                    zplb(1)=zplbo(2)-vnx*dz/10.0-vnz*dz/10.0

                    call mpl(2,xplb,zplb)

                    xplb(1)=xplbo(2)-vnz*dx/10.0-vnx*dx/10.0
                    zplb(1)=zplbo(2)+vnx*dz/10.0-vnz*dz/10.0

                    call mpl(2,xplb,zplb)
                  endif !vn

                  if (byo.gt.0.0) then
                    call mgset('MTYP',rmtyp24)
                    call mgset('MSCF',circ0*pscal/5.)
                    call mpm(1,xmc(1),zmc(1))
                    call mgset('MTYP',rmtyp20)
                    call mgset('MSCF',dot0*pscal/5.)
                    call mpm(1,xmc(1),zmc(1))
                  else if (byo.lt.0.0) then
                    call mgset('MTYP',rmtyp24)
                    call mgset('MSCF',circ0*pscal/5.)
                    call mpm(1,xmc(1),zmc(1))
                    call mgset('MTYP',rmtyp31)
                    call mgset('MSCF',dot0*pscal/5.)
                    call mpm(1,xmc(1),zmc(1))
                  endif

                endif !imago

              endif !yc

            endif !iplano

            xpl(ncorn)=x
            ypl(ncorn)=y
            zpl(ncorn)=z

            xmpl(impl)=x
            ympl(impl)=y
            zmpl(impl)=z

            bxo=bx
            byo=by
            bzo=bz

            iplano=iplan
            ncorno=ncorn
            rcolo=rcol
            imago=imag

          enddo !nline

          call bpolypl2(forxpl,forzpl,forcol,13)

        enddo !igird

c--- y vs x }

        call muwk(0,0)

        if (idev.ne.0) then
+self,if=-mshplt.
          write(6,*)
          write(6,*)'hit RETURN key to continue !'
          read(5,*)
+self.
        endif

      else if (iplot1.eq.2) then

        call mtitle(usercom)

        call mplset('YMGL',0.5)
        call mplzon(1,1,1,' ')
        call mplfra(0.,10.,0.,10.,'AB')
        call mgset('CHHE',0.4)
        call mtx(3.5,5.3,'upper magnets')
        call mtx(3.5,0.15,'lower magnets')
        call mgset('CHHE',0.25)
        call mplset('YMGL',2.)

        call mplzon(1,2,1,'S')

        do igird=1,2

c--- z vs x, z is vertical coordinate {

          call mplfra(xplmin,xplmax,yplmin,yplmax,' ')
          call mplax('x (mm)', 'y (mm)')
          call bpolypl2(forxpl,forypl,forcol,12)

          rewind(99)
103       read(99,*) rmag,rcol,rplan,rcorn,x,y,z,bx,by,bz
          if (bx**2+by**2+bz**2.eq.0.0d0) goto 103
          backspace(99)
          imago=rmag
          iplano=1
          impl=0

          do iline=1,nline

104         read(99,*) rmag,rcol,rplan,rcorn,x,y,z,bx,by,bz
            if (bx**2+by**2+bz**2.eq.0.0d0) goto 104

            imag=rmag
            icol=rcol
            iplan=rplan
            icorn=rcorn

            ncorn=abs(icorn)

            if (imag.ne.imago.or.iline.eq.nline) then

              xmc(1)=0.
              ymc(1)=0.
              zmc(1)=0.

              xmmx=-1.0e30
              xmmn= 1.0e30
              ymmx=-1.0e30
              ymmn= 1.0e30
              zmmx=-1.0e30
              zmmn= 1.0e30

              do i=1,impl-1
                xmc(1)=xmc(1)+xmpl(i)
                ymc(1)=ymc(1)+ympl(i)
                zmc(1)=zmc(1)+zmpl(i)
                if (xmpl(i).gt.xmmx) xmmx=xmpl(i)
                if (xmpl(i).lt.xmmn) xmmn=xmpl(i)
                if (ympl(i).gt.ymmx) ymmx=ympl(i)
                if (ympl(i).lt.ymmn) ymmn=ympl(i)
                if (zmpl(i).gt.zmmx) zmmx=zmpl(i)
                if (zmpl(i).lt.zmmn) zmmn=zmpl(i)
              enddo

              xmc(1)=xmc(1)/(impl-1)
              ymc(1)=ymc(1)/(impl-1)
              zmc(1)=zmc(1)/(impl-1)

              dx=xmmx-xmmn
              dy=ymmx-ymmn
              dz=zmmx-zmmn

              impl=0

            endif !imag.ne.imago

            impl=impl+1

            if (iline.eq.nline) then

              xpl(ncorn)=x
              ypl(ncorn)=y
              zpl(ncorn)=z

              xmpl(impl)=x
              ympl(impl)=y
              zmpl(impl)=z

              bxo=bx
              byo=by
              bzo=bz

              iplano=iplan
              ncorno=ncorn
              rcolo=rcol

            endif !(iline.eq.nline

            if(iplan.ne.iplano.or.iline.eq.nline) then

              xc=0.
              yc=0.
              zc=0.

              do i=1,ncorno-1
                xc=xc+xpl(i)
                yc=yc+ypl(i)
                zc=zc+zpl(i)
              enddo

              xc=xc/(ncorno-1)
              yc=yc/(ncorno-1)
              zc=zc/(ncorno-1)

              if (igird.eq.1.and.zc.ge.0.0) then

                do i=1,ncorno
                  zplm(i)=-zpl(i)
                enddo

                call mgset('PLCI',1.)
                call mpl(ncorno,xpl,ypl)

                izero=0
                do i=1,ncorno
                  if (
     &              abs(yc-ypl(i)).gt.1.0e-6 .and. abs(xc-xpl(i)).gt.1.0e-6
     &              ) izero=1
                  xpl(i)=xpl(i)+(xc-xpl(i))*0.03*rcolo
                  ypl(i)=ypl(i)+(yc-ypl(i))*0.03*rcolo
                  zpl(i)=zpl(i)+(zc-zpl(i))*0.03*rcolo
                  zplm(i)=-zpl(i)
                enddo

                call mgset('PLCI',rcolo)
                if (izero.ne.0) call mpl(ncorno,xpl,ypl)

                if (imag.ne.imago.or.iline.eq.nline) then

                  bo=sqrt(bxo*bxo+byo*byo+bzo*bzo)

                  if (abs(bxo).lt.bo*eps) bxo=0.0
                  if (abs(byo).lt.bo*eps) byo=0.0
                  if (abs(bzo).lt.bo*eps) bzo=0.0

                  xplb(1)=xmc(1)-2.*bxo/bo*dx/8.
                  xplb(2)=xmc(1)+2.*bxo/bo*dx/8.
                  yplb(1)=ymc(1)-2.*byo/bo*dy/8.
                  yplb(2)=ymc(1)+2.*byo/bo*dy/8.
                  zplb(1)=zmc(1)-2.*bzo/bo*dz/8.
                  zplb(2)=zmc(1)+2.*bzo/bo*dz/8.

                  xplbo(1)=xplb(1)
                  xplbo(2)=xplb(2)
                  yplbo(1)=yplb(1)
                  yplbo(2)=yplb(2)
                  zplbo(1)=zplb(1)
                  zplbo(2)=zplb(2)

                  call mpl(2,xplbo,yplbo)

                  vn=sqrt((xplbo(2)-xplbo(1))**2+(yplbo(2)-yplbo(1))**2)
                  if (vn.ne.0.0d0) then
                    vnx=(xplbo(2)-xplbo(1))/vn
                    vny=(yplbo(2)-yplbo(1))/vn

                    xplb(1)=xplbo(2)+vny*dx/10.0-vnx*dx/10.0
                    yplb(1)=yplbo(2)-vnx*dy/10.0-vny*dy/10.0

                    call mpl(2,xplb,yplb)

                    xplb(1)=xplbo(2)-vny*dx/10.0-vnx*dx/10.0
                    yplb(1)=yplbo(2)+vnx*dy/10.0-vny*dy/10.0

                    call mpl(2,xplb,yplb)
                  endif !vn

                  if (byo.gt.0.0) then
                    call mgset('MTYP',rmtyp24)
                    call mgset('MSCF',circ0*pscal/5.)
                    call mpm(1,xmc(1),ymc(1))
                    call mgset('MTYP',rmtyp20)
                    call mgset('MSCF',dot0*pscal/5.)
                    call mpm(1,xmc(1),ymc(1))
                  else if (byo.lt.0.0) then
                    call mgset('MTYP',rmtyp24)
                    call mgset('MSCF',circ0*pscal/5.)
                    call mpm(1,xmc(1),ymc(1))
                    call mgset('MTYP',rmtyp31)
                    call mgset('MSCF',dot0*pscal/5.)
                    call mpm(1,xmc(1),ymc(1))
                  endif

                endif !imago

              else if (igird.eq.2.and.zc.le.0.0) then

                do i=1,ncorno
                  zplm(i)=-zpl(i)
                enddo

                call mgset('PLCI',1.)
                call mpl(ncorno,xpl,ypl)

                izero=0
                do i=1,ncorno
                  if (
     &              abs(yc-ypl(i)).gt.1.0e-6 .and. abs(xc-xpl(i)).gt.1.0e-6
     &              ) izero=1
                  xpl(i)=xpl(i)+(xc-xpl(i))*0.03*rcolo
                  ypl(i)=ypl(i)+(yc-ypl(i))*0.03*rcolo
                  zpl(i)=zpl(i)+(zc-zpl(i))*0.03*rcolo
                  zplm(i)=-zpl(i)
                enddo

                call mgset('PLCI',rcolo)
                if (izero.ne.0) call mpl(ncorno,xpl,ypl)

                if (imag.ne.imago.or.iline.eq.nline) then

                  bo=sqrt(bxo*bxo+byo*byo+bzo*bzo)

                  if (abs(bxo).lt.bo*eps) bxo=0.0
                  if (abs(byo).lt.bo*eps) byo=0.0
                  if (abs(bzo).lt.bo*eps) bzo=0.0

                  xplb(1)=xmc(1)-2.*bxo/bo*dx/8.
                  xplb(2)=xmc(1)+2.*bxo/bo*dx/8.
                  yplb(1)=ymc(1)-2.*byo/bo*dy/8.
                  yplb(2)=ymc(1)+2.*byo/bo*dy/8.
                  zplb(1)=zmc(1)-2.*bzo/bo*dz/8.
                  zplb(2)=zmc(1)+2.*bzo/bo*dz/8.

                  xplbo(1)=xplb(1)
                  xplbo(2)=xplb(2)
                  yplbo(1)=yplb(1)
                  yplbo(2)=yplb(2)
                  zplbo(1)=zplb(1)
                  zplbo(2)=zplb(2)

                  call mpl(2,xplbo,yplbo)

                  vn=sqrt((xplbo(2)-xplbo(1))**2+(yplbo(2)-yplbo(1))**2)
                  if (vn.ne.0.0d0) then
                    vnx=(xplbo(2)-xplbo(1))/vn
                    vny=(yplbo(2)-yplbo(1))/vn

                    xplb(1)=xplbo(2)+vny*dx/10.0-vnx*dx/10.0
                    yplb(1)=yplbo(2)-vnx*dy/10.0-vny*dy/10.0

                    call mpl(2,xplb,yplb)

                    xplb(1)=xplbo(2)-vny*dx/10.0-vnx*dx/10.0
                    yplb(1)=yplbo(2)+vnx*dy/10.0-vny*dy/10.0

                    call mpl(2,xplb,yplb)
                  endif !vn

                  if (byo.gt.0.0) then
                    call mgset('MTYP',rmtyp24)
                    call mgset('MSCF',circ0*pscal/5.)
                    call mpm(1,xmc(1),ymc(1))
                    call mgset('MTYP',rmtyp20)
                    call mgset('MSCF',dot0*pscal/5.)
                    call mpm(1,xmc(1),ymc(1))
                  else if (byo.lt.0.0) then
                    call mgset('MTYP',rmtyp24)
                    call mgset('MSCF',circ0*pscal/5.)
                    call mpm(1,xmc(1),ymc(1))
                    call mgset('MTYP',rmtyp31)
                    call mgset('MSCF',dot0*pscal/5.)
                    call mpm(1,xmc(1),ymc(1))
                  endif

                endif !imago

              endif !yc

            endif !iplano

            xpl(ncorn)=x
            ypl(ncorn)=y
            zpl(ncorn)=z

            xmpl(impl)=x
            ympl(impl)=y
            zmpl(impl)=z

            bxo=bx
            byo=by
            bzo=bz

            iplano=iplan
            ncorno=ncorn
            rcolo=rcol
            imago=imag

          enddo !nline

          call bpolypl2(forxpl,forypl,forcol,12)

        enddo !igird

c--- y vs x }

        call muwk(0,0)

        if (idev.ne.0) then
+self,if=-mshplt.
          write(6,*)
          write(6,*)'hit RETURN key to continue !'
          read(5,*)
+self.
        endif

      endif !iplot1

c--- top views of girder}

9999  close (99)

      deallocate(xpl)
      deallocate(ypl)
      deallocate(zpl)
      deallocate(zplm)
      deallocate(xmpl)
      deallocate(ympl)
      deallocate(zmpl)

      call mplend

+self,if=linux,hpux,if=-mshplt,if=obsolete.
      if (iplot.gt.0) then
        call system('mv fort.98 polymag.ps') !c_higz_bug
      else if (iplot.lt.0) then
        call system('mv fort.98 polymag.eps') !c_higz_bug
      endif
+self.
      return
      end
+DECK,BQP.
*CMZ :  2.67/01 15/03/2012  10.51.33  by  Michael Scheer
*CMZ :  2.66/07 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.15/00 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  1.02/00 18/12/97  13.35.57  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  15.24.44  by  Michael Scheer
*CMZ : 00.00/05 29/04/94  19.35.51  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.43  by  Michael Scheer
*-- Author : Michael Scheer
C***********************************************************************
      SUBROUTINE BQP(XI,YI,ZI,BX,BY,BZ,IMAG)
+seq,gplhint.
      IMPLICIT NONE
      INTEGER IMAG

+SEQ,MGSQC.

      DOUBLE PRECISION Y,Z,BX,BY,BZ,G,XI,YI,ZI,PHI,SPHI,CPHI,XCEN,ZCEN,DX,DZ
      DOUBLE PRECISION DXA,DZA,DXE,DZE,XA,XE,ZA,ZE,ADUMA,ADUME

+SEQ,CONTRL.
+SEQ,PHYCON.

      PHI=PMAG(5,IMAG)
      CPHI=DCOS(PHI)
      SPHI=DSIN(PHI)
      XCEN=PMAG(3,IMAG)
      ZCEN=PMAG(4,IMAG)

      XA=XCEN-CPHI*PMAG(1,IMAG)/2.
      ZA=ZCEN-SPHI*PMAG(1,IMAG)/2.
      XE=XCEN+CPHI*PMAG(1,IMAG)/2.
      ZE=ZCEN+SPHI*PMAG(1,IMAG)/2.
      DXA=XI-XA
      DZA=ZI-ZA
      DXE=XI-XE
      DZE=ZI-ZE

      ADUMA=DXA*CPHI+DZA*SPHI
      ADUME=DXE*CPHI+DZE*SPHI

      IF (IWFILF.NE.99.AND.ADUMA*ADUME.LE.0.) THEN

        DX=XI-XCEN
        DZ=ZI-ZCEN
        Z=-SPHI*DX+CPHI*DZ
        Y=YI

        G=PMAG(2,IMAG)*EMOM/CLIGHT1

        BX=0.
        BY=G*Z
        BZ=G*Y

      ELSE

        BX=0.
        BY=0.
        BZ=0.

      ENDIF !IWFILF

      RETURN
      END
+DECK,BRCOEF.
*CMZ :  2.48/04 12/03/2004  15.40.31  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  13.48.25  by  Michael Scheer
*CMZ : 00.01/03 18/11/94  11.39.59  by  Michael Scheer
*CMZ :  0.00/03 09/11/94  18.29.44  by  Michael Scheer
*CMZ :  0.00/02 02/11/94  12.17.57  by  Michael Scheer
*-- Author :    Michael Scheer   31/10/94
      SUBROUTINE BRCOEF(LUN,FILE
     &                 ,XLX,YLY,ZLZ
     &                 ,XKX,YKY,ZKZ
     &                 ,NFIRSTX,NORDX,NSTEPX
     &                 ,NFIRSTY,NORDY,NSTEPY
     &                 ,NDIMQ,Q,QA0,QA,IFHALBA,GAP2PI,WIDTH)

+seq,gplhint.
      IMPLICIT NONE

      CHARACTER(50) FILE

      INTEGER LUN,IORD,JORD,IORD1,JORD1,NDIMQ
     &                 ,NFIRSTX,NORDX,NSTEPX
     &                 ,NFIRSTY,NORDY,NSTEPY
     &                 ,I,J
     &                 ,IFHALBA

      INTEGER IORDX,IORDY,IDUMX,IDUMY

      DIMENSION Q(NDIMQ,NDIMQ)
      DOUBLE PRECISION XLX,YLY,ZLZ,XKX,YKY,ZKZ,Q
      DOUBLE PRECISION GAP2PI,WIDTH
      DOUBLE PRECISION QA0(NDIMQ),QA(NDIMQ,NDIMQ)

      DO I=1,NDIMQ
      DO J=2,NDIMQ
             Q(I,J)=0.
      ENDDO
      ENDDO

+SELF,IF=VMS.
      OPEN(UNIT=LUN,FILE=FILE,STATUS='OLD',READONLY)
+SELF.

+SELF,IF=LINUX,WINDOWS,HPUX,TRUE64.
      OPEN(UNIT=LUN,FILE=FILE,STATUS='OLD')
+SELF.


         READ(LUN,*)IFHALBA
         READ(LUN,*)XLX
         READ(LUN,*)YLY
         READ(LUN,*)ZLZ
         READ(LUN,*)XKX
         READ(LUN,*)YKY
         READ(LUN,*)ZKZ
         READ(LUN,*)GAP2PI
         READ(LUN,*)WIDTH
         READ(LUN,*)NFIRSTX,NORDX,NSTEPX
         READ(LUN,*)NFIRSTY,NORDY,NSTEPY

         IF (IFHALBA.EQ.0) THEN
           DO IORD=NFIRSTX,NORDX,NSTEPX
           DO JORD=NFIRSTY,NORDY,NSTEPY
               READ(LUN,*)IORD1,JORD1,Q(IORD1+1,JORD1+1)
           ENDDO
           ENDDO
           NFIRSTX=NFIRSTX+1    !FORTRAN-INDICES
           NORDX=NORDX+1
           NFIRSTY=NFIRSTY+1
           NORDY=NORDY+1
         ELSE !IFHALBA
           IORD=0
           DO IORDY=NFIRSTY,NORDY,NSTEPY
               iord=iord+1
               READ(LUN,*)IDUMY,QA0(IDUMY)
           DO IORDX=NFIRSTX,NORDX,NSTEPX
               iord=iord+1
               READ(LUN,*)IDUMY,IDUMX,QA(IDUMY,IDUMX)
           ENDDO
           ENDDO
         ENDIF !IFHALBA
      CLOSE(LUN)

      RETURN
      END
+DECK,BREC.
*CMZ :  4.00/07 04/06/2020  17.17.29  by  Michael Scheer
*CMZ :  3.06/00 18/02/2019  17.12.04  by  Michael Scheer
*CMZ :  3.03/02 07/03/2016  09.53.53  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ : 00.01/08 01/04/95  16.52.27  by  Michael Scheer
*CMZ : 00.01/07 03/03/95  17.01.49  by  Michael Scheer
*-- Author :    Michael Scheer   03/03/95
      SUBROUTINE BREC(XIN,YIN,ZIN,BX,BY,BZ,AX,AY,AZ)
+seq,gplhint.

C     TO CALCULATED MAGNETIC FIELD OF REC-STRUCTURE WITH REC_FIELD ROUTINES

      use ompmod

      IMPLICIT NONE

      DOUBLE PRECISION XIN,YIN,ZIN,X,Y,Z,BX,BY,BZ,AX,AY,AZ
      INTEGER ICAL

+seq,klotz.

      DATA ICAL/0/

      IF (ICAL.EQ.0) THEN
        CALL REC_INIT
        ICAL=1
      ENDIF

      X=XIN*1000.0D0
      Y=YIN*1000.0D0
      Z=ZIN*1000.0D0

      AX=0.0
      AY=0.0
      AZ=0.0

c      if (irecsolve.ne.0) call rec_solve

      if (iomp.eq.0) then
        CALL REC_BFELD(X,Y,Z,BX,BY,BZ)
      else
        CALL REC_BFELD_OMP(X,Y,Z,BX,BY,BZ)
      endif

      RETURN
      END
+DECK,BRESI.
*CMZ : 00.01/09 05/10/95  16.28.55  by  Michael Scheer
*CMZ :  1.00/03 27/09/95  16.41.21  by  Michael Scheer
*CMZ :  1.00/02 26/09/95  17.45.08  by  Michael Scheer
*CMZ :  1.00/01 22/09/95  18.24.37  by  Michael Scheer
*-- Author :    Michael Scheer   22/09/95

      SUBROUTINE BRESI(NPOI,NPOIX,NPOIY,NPOIZ
     &                  ,X,Y,Z,BX,BY,BZ,BXF,BYF,BZF
     &                  ,RESBX,RESBY,RESBZ,RESB
     &                  ,BXAMEAN,BYAMEAN,BZAMEAN,BAMEAN
     &                  ,BERRMX,BXERRMX,BYERRMX,BZERRMX)
+seq,gplhint.

      IMPLICIT NONE

      INTEGER NPOI,I,NPOIX,NPOIY,NPOIZ

      DOUBLE PRECISION
     &                  BX(NPOI),BY(NPOI),BZ(NPOI)
     &                  ,X(NPOI),Y(NPOI),Z(NPOI)
     &                  ,BXF(NPOI),BYF(NPOI),BZF(NPOI)
     &                  ,RESBX,RESBY,RESBZ,RESB
     &                  ,BXAMEAN,BYAMEAN,BZAMEAN,BAMEAN
     &                  ,BBX,BBY,BBZ,BBXF,BBYF,BBZF,BB,BBF
     &                  ,DBX,DBY,DBZ,DBX2,DBY2,DBZ2,DBB
     &                  ,BERRMX(8),BXERRMX(8),BYERRMX(8),BZERRMX(8)

      RESBX=0.D0
      RESBY=0.D0
      RESBZ=0.D0
      RESB=0.D0

      BXAMEAN=0.D0
      BYAMEAN=0.D0
      BZAMEAN=0.D0
      BAMEAN=0.D0

      BERRMX(8)=0.D0
      BXERRMX(8)=0.D0
      BYERRMX(8)=0.D0
      BZERRMX(8)=0.D0

      DO I=1,NPOI

          BBX=BX(I)
          BBY=BY(I)
          BBZ=BZ(I)
          BBXF=BXF(I)
          BBYF=BYF(I)
          BBZF=BZF(I)

          IF (BBX.EQ.-9999.) THEN
         BBX=0.D0
         BBXF=0.D0
          ENDIF

          IF (BBY.EQ.-9999.) THEN
         BBY=0.D0
         BBYF=0.D0
          ENDIF

          IF (BBZ.EQ.-9999.) THEN
         BBZ=0.D0
         BBZF=0.D0
          ENDIF

          BB=DSQRT(BBX*BBX+BBY*BBY+BBZ*BBZ)
          BBF=DSQRT(BBXF*BBXF+BBYF*BBYF+BBZF*BBZF)

          DBX=DABS(BBX-BBXF)
          DBY=DABS(BBY-BBYF)
          DBZ=DABS(BBZ-BBZF)
          DBB=DABS(BB-BBF)

          DBX2=DBX**2
          DBY2=DBY**2
          DBZ2=DBZ**2

          IF (DBB.GT.DABS(BERRMX(8))) THEN
         BERRMX(1)=X(I)
         BERRMX(2)=Y(I)
         BERRMX(3)=Z(I)
         BERRMX(4)=BX(I)
         BERRMX(5)=BY(I)
         BERRMX(6)=BZ(I)
         BERRMX(7)=BB
         BERRMX(8)=BB-BBF
          ENDIF
          IF (DBX.GT.DABS(BXERRMX(8))) THEN
         BXERRMX(1)=X(I)
         BXERRMX(2)=Y(I)
         BXERRMX(3)=Z(I)
         BXERRMX(4)=BX(I)
         BXERRMX(5)=BY(I)
         BXERRMX(6)=BZ(I)
         BXERRMX(7)=BB
         BXERRMX(8)=BBX-BBXF
          ENDIF
          IF (DBY.GT.DABS(BYERRMX(8))) THEN
         BYERRMX(1)=X(I)
         BYERRMX(2)=Y(I)
         BYERRMX(3)=Z(I)
         BYERRMX(4)=BX(I)
         BYERRMX(5)=BY(I)
         BYERRMX(6)=BZ(I)
         BYERRMX(7)=BB
         BYERRMX(8)=BBY-BBYF
          ENDIF
          IF (DBZ.GT.DABS(BZERRMX(8))) THEN
         BZERRMX(1)=X(I)
         BZERRMX(2)=Y(I)
         BZERRMX(3)=Z(I)
         BZERRMX(4)=BX(I)
         BZERRMX(5)=BY(I)
         BZERRMX(6)=BZ(I)
         BZERRMX(7)=BB
         BZERRMX(8)=BBZ-BBZF
          ENDIF

          BXAMEAN=BXAMEAN+DABS(BBX)
          BYAMEAN=BYAMEAN+DABS(BBY)
          BZAMEAN=BZAMEAN+DABS(BBZ)
          BAMEAN=BAMEAN+DSQRT(BBX*BBX+BBY*BBY+BBZ*BBZ)

          RESBX=RESBX+DBX2
          RESBY=RESBY+DBY2
          RESBZ=RESBZ+DBZ2
          RESB=RESB
     &     +((DSQRT(BBX**2+BBY**2+BBZ**2)
     &      -DSQRT(BBXF**2+BBYF**2+BBZF**2)))**2

      ENDDO !NPOI

      BAMEAN=BAMEAN/NPOI
      BXAMEAN=BXAMEAN/NPOIX
      BYAMEAN=BYAMEAN/NPOIY
      BZAMEAN=BZAMEAN/NPOIZ

      RESB=DSQRT(RESB/NPOI)
      IF (NPOIX.NE.0) RESBX=DSQRT(RESBX/NPOIX)
      IF (NPOIY.NE.0) RESBY=DSQRT(RESBY/NPOIY)
      IF (NPOIZ.NE.0) RESBZ=DSQRT(RESBZ/NPOIZ)

      RETURN
      END
+DECK,BRILL.
*CMZ :  4.01/02 12/05/2023  12.40.43  by  Michael Scheer
*CMZ :  4.00/07 16/04/2020  20.09.04  by  Michael Scheer
*CMZ :  3.05/28 18/12/2018  13.58.31  by  Michael Scheer
*CMZ :  3.05/04 27/06/2018  14.22.34  by  Michael Scheer
*CMZ :  3.05/00 25/04/2018  13.09.51  by  Michael Scheer
*CMZ :  3.02/04 21/01/2015  14.21.41  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.10  by  Michael Scheer
*CMZ :  2.66/14 22/10/2010  12.10.20  by  Michael Scheer
*CMZ :  2.66/13 25/06/2010  14.49.11  by  Michael Scheer
*CMZ :  2.66/07 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.66/03 18/11/2009  10.22.04  by  Michael Scheer
*CMZ :  2.66/01 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  2.66/00 09/10/2009  11.37.29  by  Michael Scheer
*CMZ :  2.63/00 14/09/2009  15.19.42  by  Michael Scheer
*CMZ :  2.61/05 11/04/2007  11.58.07  by  Michael Scheer
*CMZ :  2.52/00 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.48/04 15/03/2004  15.22.55  by  Michael Scheer
*CMZ :  2.20/01 18/11/2000  10.19.57  by  Michael Scheer
*CMZ :  2.17/00 06/11/2000  16.13.47  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  16.27.20  by  Michael Scheer
*CMZ :  2.16/04 24/06/2000  19.53.18  by  Michael Scheer
*CMZ :  2.16/00 15/06/2000  11.56.41  by  Michael Scheer
*-- Author :    Michael Scheer   08/06/2000
      SUBROUTINE BRILL
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,OBSERVF90U.
+SEQ,SOURCEF90U.
+SEQ,WFOLDF90U.
+SEQ,bwpolyederf90U.
+SELF.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,SPECT.
+SEQ,FREQS.
+seq,sourcef90.
+SEq,wfoldf90.
+SEq,observf90.
+SEQ,KLOTZ.
+SEQ,PHYCON.

C--- CONVERTION OF STOKES-VECTORS TO BRILLIANCE  (SPECTRAL BRIGHTNESS)
C--- SIGR=SQRT(2*LAMBDA*L)/2/PI*SIGRC AND SIGRP=SQRT(LAMBDA/2/L)*SIGRP
C--- THIS MAKES ONLY SENSE FOR UNDULATORS!

      DOUBLE PRECISION WAVE,SIGRP,SIGR,DEVILEN,CONV,CONVF,SIGZ,SIGY
     &                  ,SIGRF,SIGRPF,SIGZP,SIGYP,CENXEXI,DIST

      INTEGER IFREQ,IS

      IF (SIGRC.EQ.0.D0) SIGRC=1.D0
      IF (SIGRPC.EQ.0.D0) SIGRPC=1.D0

      IF (XIANF.GT.XSTART) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN BRILL: XIANF.GT.XSTART'
        WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
        WRITE(6,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN BRILL: XIANF.GT.XSTART'
        WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
        WRITE(6,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN BRILL: XIANF.GT.XSTART'
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN BRILL: XIANF.GT.XSTART'
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
        WRITE(LUNGFO,*)
        STOP
      ENDIF

      IF (XIEND.LT.XSTOP) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN BRILL: XIEND.LT.XSTOP'
        WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
        WRITE(6,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN BRILL: XIEND.LT.XSTOP'
        WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
        WRITE(6,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN BRILL: XIEND.LT.XSTOP'
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN BRILL: XIEND.LT.XSTOP'
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
        WRITE(LUNGFO,*)
        STOP
      ENDIF

      IF (NSOURCE.NE.1) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN BRILL: Number of source points not one'
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN BRILL: Number of source points not one'
        WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
        WRITE(6,*)
        STOP
      ENDIF

      CENXEXI=(SOURCEEO(1,1,1)+SOURCEAO(1,1,1))/2.D0
      DIST=PINCEN(1)-CENXEXI

      SIGZ=BSIGZ(ISIGSTO)
      SIGY=BSIGY(ISIGSTO)
      SIGZP=BSIGZP(ISIGSTO)
      SIGYP=BSIGYP(ISIGSTO)

      DEVILEN=XSTOP-XSTART
      if (kampli.gt.0) then
        devilen=devilen*dble(kampli)
      else IF (IAMPLI.LT.0) THEN
        DEVILEN=ABS(IAMPLI)*DEVILEN
      ENDIF

      IF (KBREC.NE.0) DEVILEN=DEVILEN-2.D0*RANGREC
      IF (KBPOLYMAG.GT.0) DEVILEN=DEVILEN-2.D0*RANGPM

      DO IFREQ=1,NFREQ

        WAVE=WTOE1/FREQ(IFREQ)*1.D-9

        ! According to Walker for sigrc=1 and sigrpc=1
        SIGR=SQRT(2.D0*WAVE*DEVILEN)/2.D0/PI1*SIGRC
        SIGRP=SQRT(WAVE/DEVILEN/2.D0)*SIGRPC

        CONV=(DIST/SIGR)**2/2.D0/PI1

        SIGRF=SQRT(SQRT(SIGR**2+SIGZ**2)*SQRT(SIGR**2+SIGY**2))
        SIGRPF=SQRT(SQRT(SIGRP**2+SIGZP**2)*SQRT(SIGRP**2+SIGYP**2))
        CONVF=(DIST/SIGRF)**2/2.D0/PI1

        BRILLC(1,IFREQ)=STOKEC(1,IFREQ)*CONV
        BRILLC(2,IFREQ)=STOKEC(2,IFREQ)*CONV
        BRILLC(3,IFREQ)=STOKEC(3,IFREQ)*CONV
        BRILLC(4,IFREQ)=STOKEC(4,IFREQ)*CONV

        if (ibunch.eq.0) then

          IF (IFOLD.NE.0) THEN

            BRILLCF(1,IFREQ)=STOKECF(1,IFREQ)*CONVF
            BRILLCF(2,IFREQ)=STOKECF(2,IFREQ)*CONVF
            BRILLCF(3,IFREQ)=STOKECF(3,IFREQ)*CONVF
            BRILLCF(4,IFREQ)=STOKECF(4,IFREQ)*CONVF

            IF (IEFOLD.NE.0) THEN
              BRILLCE(1,IFREQ)=STOKECE(1,IFREQ)*CONV
              BRILLCE(2,IFREQ)=STOKECE(2,IFREQ)*CONV
              BRILLCE(3,IFREQ)=STOKECE(3,IFREQ)*CONV
              BRILLCE(4,IFREQ)=STOKECE(4,IFREQ)*CONV
              BRILLCEF(1,IFREQ)=STOKECEF(1,IFREQ)*CONVF
              BRILLCEF(2,IFREQ)=STOKECEF(2,IFREQ)*CONVF
              BRILLCEF(3,IFREQ)=STOKECEF(3,IFREQ)*CONVF
              BRILLCEF(4,IFREQ)=STOKECEF(4,IFREQ)*CONVF
            ENDIF   !IEFOLD

          ELSE !(IFOLD.NE.0) THEN

            BRILLCF(1,IFREQ)=STOKEC(1,IFREQ)*CONVF*(SIGRP/SIGRPF)**2
            BRILLCF(2,IFREQ)=STOKEC(2,IFREQ)*CONVF*(SIGRP/SIGRPF)**2
            BRILLCF(3,IFREQ)=STOKEC(3,IFREQ)*CONVF*(SIGRP/SIGRPF)**2
            BRILLCF(4,IFREQ)=STOKEC(4,IFREQ)*CONVF*(SIGRP/SIGRPF)**2

            IF (IEFOLD.NE.0) THEN
              BRILLCE(1,IFREQ)=STOKECE(1,IFREQ)*CONV
              BRILLCE(2,IFREQ)=STOKECE(2,IFREQ)*CONV
              BRILLCE(3,IFREQ)=STOKECE(3,IFREQ)*CONV
              BRILLCE(4,IFREQ)=STOKECE(4,IFREQ)*CONV
              BRILLCEF(1,IFREQ)=STOKECE(1,IFREQ)*CONVF*(SIGRP/SIGRPF)**2
              BRILLCEF(2,IFREQ)=STOKECE(2,IFREQ)*CONVF*(SIGRP/SIGRPF)**2
              BRILLCEF(3,IFREQ)=STOKECE(3,IFREQ)*CONVF*(SIGRP/SIGRPF)**2
              BRILLCEF(4,IFREQ)=STOKECE(4,IFREQ)*CONVF*(SIGRP/SIGRPF)**2
            ENDIF   !IEFOLD

          ENDIF   !IFOLD

        endif !ibunch
      ENDDO !IFREQ

      DO IS=1,4

        IF (STOKCMX(IS,1).NE.0.D0) THEN

          BRILLCMX(IS,1)=STOKCMX(IS,1)
          WAVE=WTOE1/BRILLCMX(IS,1)*1.D-9
          SIGR=SQRT(2.D0*WAVE*DEVILEN)/2.D0/PI1*SIGRC
          SIGRP=SQRT(WAVE/DEVILEN/2.D0)*SIGRPC
          CONV=(DIST/SIGR)**2/2.D0/PI1
          SIGRF=SQRT(SQRT(SIGR**2+SIGZ**2)*SQRT(SIGR**2+SIGY**2))
          SIGRPF=SQRT(SQRT(SIGRP**2+SIGZP**2)*SQRT(SIGRP**2+SIGYP**2))
          CONVF=(DIST/SIGRF)**2/2.D0/PI1
          BRILLCMX(IS,2)=STOKCMX(IS,2)*CONV
          B3CMX(1)=G3CMX(1)
          B3CMX(2)=G3CMX(2)*CONV

c Estimated flux
          BRILLCMX(IS+4,2)=STOKCMX(IS,2)*dist**2*2.0d0*pi1*sigrp**2

          if (ibunch.eq.0) then
            IF (IEFOLD.NE.0.and.STOKCMXE(IS,1).ne.0.0d0) THEN
              BRILLCMXE(IS,1)=STOKCMXE(IS,1)
              WAVE=WTOE1/BRILLCMXE(IS,1)*1.D-9
              SIGR=SQRT(2.D0*WAVE*DEVILEN)/2.D0/PI1*SIGRC
              SIGRP=SQRT(WAVE/DEVILEN/2.D0)*SIGRPC
              CONV=(DIST/SIGR)**2/2.D0/PI1
              SIGRF=SQRT(SQRT(SIGR**2+SIGZ**2)*SQRT(SIGR**2+SIGY**2))
              SIGRPF=SQRT(SQRT(SIGRP**2+SIGZP**2)*SQRT(SIGRP**2+SIGYP**2))
              CONVF=(DIST/SIGRF)**2/2.D0/PI1
              BRILLCMXE(IS,2)=STOKCMXE(IS,2)*CONV
c Estimated flux
              BRILLCMXE(IS+4,2)=STOKCMXE(IS,2)*dist**2*2.0d0*pi1*sigrp**2
              B3CMXE(1)=G3CMXE(1)
              B3CMXE(2)=G3CMXE(2)*CONV
            ENDIF  !IEFOLD

            IF (IFOLD.NE.0.and.STOKCMXF(IS,1).ne.0.0d0) THEN
              BRILLCMXF(IS,1)=STOKCMXF(IS,1)
              WAVE=WTOE1/BRILLCMXF(IS,1)*1.D-9
              SIGR=SQRT(2.D0*WAVE*DEVILEN)/2.D0/PI1*SIGRC
              SIGRP=SQRT(WAVE/DEVILEN/2.D0)*SIGRPC
              CONV=(DIST/SIGR)**2/2.D0/PI1
              SIGRF=SQRT(SQRT(SIGR**2+SIGZ**2)*SQRT(SIGR**2+SIGY**2))
              SIGRPF=SQRT(SQRT(SIGRP**2+SIGZP**2)*SQRT(SIGRP**2+SIGYP**2))
              CONVF=(DIST/SIGRF)**2/2.D0/PI1
              BRILLCMXF(IS,2)=STOKCMXF(IS,2)*CONVF
c Estimated flux
              BRILLCMXF(IS+4,2)=STOKCMXF(IS,2)*dist**2*2.0d0*pi1*sigrpf**2
              B3CMXF(1)=G3CMXF(1)
              B3CMXF(2)=G3CMXF(2)*CONVF
              IF (IEFOLD.NE.0.and.STOKCMXEF(IS,1).ne.0.0d0) THEN
                BRILLCMXEF(IS,1)=STOKCMXEF(IS,1)
                WAVE=WTOE1/BRILLCMXEF(IS,1)*1.D-9
                SIGR=SQRT(2.D0*WAVE*DEVILEN)/2.D0/PI1*SIGRC
                SIGRP=SQRT(WAVE/DEVILEN/2.D0)*SIGRPC
                CONV=(DIST/SIGR)**2/2.D0/PI1
                SIGRF=SQRT(SQRT(SIGR**2+SIGZ**2)*SQRT(SIGR**2+SIGY**2))
                SIGRPF=SQRT(SQRT(SIGRP**2+SIGZP**2)*SQRT(SIGRP**2+SIGYP**2))
                CONVF=(DIST/SIGRF)**2/2.D0/PI1
                BRILLCMXEF(IS,2)=STOKCMXEF(IS,2)*CONVF
c Estimated flux
                BRILLCMXEF(IS+4,2)=STOKCMXEF(IS,2)*dist**2*2.0d0*pi1*sigrp**2
                B3CMXEF(1)=G3CMXEF(1)
                B3CMXEF(2)=G3CMXEF(2)*CONVF
              ENDIF   !IEFOLD
            ELSE IF (STOKCMX(IS,1).ne.0.0d0) THEN   !IFOLD
              BRILLCMXF(IS,1)=STOKCMX(IS,1)
              WAVE=WTOE1/BRILLCMX(IS,1)*1.D-9
              SIGR=SQRT(2.D0*WAVE*DEVILEN)/2.D0/PI1*SIGRC
              SIGRP=SQRT(WAVE/DEVILEN/2.D0)*SIGRPC
              CONV=(DIST/SIGR)**2/2.D0/PI1
              SIGRF=SQRT(SQRT(SIGR**2+SIGZ**2)*SQRT(SIGR**2+SIGY**2))
              SIGRPF=SQRT(SQRT(SIGRP**2+SIGZP**2)*SQRT(SIGRP**2+SIGYP**2))
              CONVF=(DIST/SIGRF)**2/2.D0/PI1
              STOKCMXF(IS,2)=STOKCMX(IS,2)*(SIGRP/SIGRPF)**2
              BRILLCMXF(IS,2)=STOKCMX(IS,2)*CONVF*(SIGRP/SIGRPF)**2
c Estimated flux
              ! flux and folded flux are the same, therefore sigrp!!
              BRILLCMXF(IS+4,2)=STOKCMX(IS,2)*dist**2*2.0d0*pi1*sigrp**2
              B3CMXF(1)=G3CMX(1)
              B3CMXF(2)=G3CMX(2)*CONVF*(SIGRP/SIGRPF)**2
              STOKCMXEF(IS,2)=STOKCMXE(IS,2)*(SIGRP/SIGRPF)**2
              IF (IEFOLD.NE.0.and.STOKCMXE(IS,1).ne.0.0d0) THEN
                BRILLCMXEF(IS,1)=STOKCMXE(IS,1)
                WAVE=WTOE1/BRILLCMXE(IS,1)*1.D-9
                SIGR=SQRT(2.D0*WAVE*DEVILEN)/2.D0/PI1*SIGRC
                SIGRP=SQRT(WAVE/DEVILEN/2.D0)*SIGRPC
                CONV=(DIST/SIGR)**2/2.D0/PI1
                SIGRF=SQRT(SQRT(SIGR**2+SIGZ**2)*SQRT(SIGR**2+SIGY**2))
                SIGRPF=SQRT(SQRT(SIGRP**2+SIGZP**2)*SQRT(SIGRP**2+SIGYP**2))
                CONVF=(DIST/SIGRF)**2/2.D0/PI1
                BRILLCMXEF(IS,2)=STOKCMXE(IS,2)*CONVF*(SIGRP/SIGRPF)**2
c Estimated flux
                ! flux and folded flux are the same, therefore sigrp!!
                BRILLCMXEF(IS+4,2)=STOKCMXE(IS,2)*dist**2*2.0d0*pi1*sigrp**2
                B3CMXEF(1)=G3CMXE(1)
                B3CMXEF(2)=G3CMXE(2)*CONVF*(SIGRP/SIGRPF)**2
              ENDIF   !IEFOLD
            ENDIF  !IFOLD
          ENDIF !STOKCMX
        endif !ibunch
      ENDDO  !IS

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

      write(lungfo,*)'     Brilliance calculations:'
      write(lungfo,*)'     (only meaningful for undulators)'
      write(lungfo,*)
      write(lungfo,*)
     &  '     sigr=sqrt(2*lambda*L)/2/pi*sigrc and '
      write(lungfo,*)
     &  '     sigrp=sqrt(lambda/2/L)*sigrpc'
      write(lungfo,*)
      write(lungfo,*)'      sigrc,sigrpc:',sigrc,sigrpc
      write(lungfo,*)
      write(lungfo,*)
     &  '     make sure that the device length agrees to the length'
      write(lungfo,*)
     &  '     of the trajectory'
      write(lungfo,*)'     (for rec-fields rangrec and rangpm are substracted by program)'

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Observation point:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     '
     &  ,SNGL(OBSV(1,ICBRILL)),SNGL(OBSV(2,ICBRILL)),SNGL(OBSV(3,ICBRILL))
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     considered device length [m]:',SNGL(DEVILEN)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Brilliance [photons/sec/BW/mm**2/mrad**2]'
      WRITE(LUNGFO,*)

      DO IFREQ=1,NFREQ
        WRITE(LUNGFO,'(5x,5G15.5)')SNGL(FREQ(IFREQ))
     &    ,(BRILLC(IS,IFREQ)*(1.D-6)**2,IS=1,4)
      ENDDO !IFREQ

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     estimated brilliance maxima, flux and flux-density of S0, S1, S2, S3:'
      WRITE(LUNGFO,*)
      DO IS=1,4
        WRITE(LUNGFO,'(5X,4G15.5)')BRILLCMX(IS,1)
     &    ,BRILLCMX(IS,2)*(1.D-6)**2
     &    ,BRILLCMX(IS+4,2)
     &    ,STOKCMX(IS,2)*DIST**2*(1.D-3)**2
      ENDDO

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     estimated brilliance maximum of S3*S3/S0:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,'(5X,2G15.5)')B3CMX(1),B3CMX(2)*(1.D-6)**2

      if (ibunch.eq.0) then

        IF (IFOLD.EQ.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     ---> flag IFOLD is not set, emittance effects are estimated'
          WRITE(LUNGFO,*)
     &      '     from horizontal beam size [mm] and divergence [mrad]: '
          WRITE(LUNGFO,*)
     &      '     ',SNGL(BSIGZ(ISIGSTO)),SNGL(BSIGZP(ISIGSTO))
          WRITE(LUNGFO,*)
     &      '     vertical beam size [mm] and divergence [mrad]: '
          WRITE(LUNGFO,*)
     &      '     ',SNGL(BSIGY(ISIGSTO)),SNGL(BSIGYP(ISIGSTO))
          WRITE(LUNGFO,*)
        ENDIF   !IFOLD

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     Brilliance [photons/sec/BW/mm**2/mrad**2] with emittance'
        WRITE(LUNGFO,*)

        DO IFREQ=1,NFREQ
          WRITE(LUNGFO,'(5x,5G15.5)')SNGL(FREQ(IFREQ))
     &      ,(BRILLCF(IS,IFREQ)*(1.D-6)**2,IS=1,4)
        ENDDO   !IFREQ

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     estimated brilliance maxima, flux and flux-density of S0, S1, S2, S3'
        WRITE(LUNGFO,*)
     &    '     with emittance:'
        WRITE(LUNGFO,*)
        DO IS=1,4
          WRITE(LUNGFO,'(5X,4G15.5)')BRILLCMXF(IS,1)
     &      ,BRILLCMXF(IS,2)*(1.D-6)**2
     &      ,BRILLCMXF(IS+4,2)
     &      ,STOKCMXF(IS,2)*DIST**2*(1.D-3)**2
        ENDDO

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     estimated brilliance maximum of S3*S3/S0 with emittance:'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,'(5X,2G15.5)')B3CMXF(1),B3CMXF(2)*(1.D-6)**2

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     corresponding sigmas of source size [mm]'
        WRITE(LUNGFO,*)
     &    '     and divergence [mrad] without and with emittance'
        WRITE(LUNGFO,*)
     &    '     (including corr. factors sigrc,sigrpc):'
        IF (BRILLCMXF(1,1).NE.0.0D0) THEN
          WAVE=WTOE1/BRILLCMXF(1,1)*1.D-9
        ELSE
          WAVE=0.0D0
        ENDIF
        SIGR=SQRT(2.D0*WAVE*DEVILEN)/2.D0/PI1*SIGRC
        SIGRP=SQRT(WAVE/DEVILEN/2.D0)*SIGRPC
        SIGRF=SQRT(SQRT(SIGR**2+SIGZ**2)*SQRT(SIGR**2+SIGY**2))
        SIGRPF=SQRT(SQRT(SIGRP**2+SIGZP**2)*SQRT(SIGRP**2+SIGYP**2))
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     L/mm, lambda/mm: ',SNGL(DEVILEN*1000.0d0),SNGL(WAVE*1000.0d0)
        WRITE(LUNGFO,*)'     without emit.: ',SNGL(SIGR*1000.D0),SNGL(SIGRP*1000.D0)
        WRITE(LUNGFO,*)'        with emit.: ',SNGL(SIGRF*1000.D0),SNGL(SIGRPF*1000.D0)
        WRITE(LUNGFO,*)'        (sigrf**2 = sigrxf*sigryf)'
        WRITE(LUNGFO,*)

        IF (IEFOLD.NE.0) THEN

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     Brilliance [photons/sec/BW/mm**2/mrad**2] (e-folded)'
          WRITE(LUNGFO,*)

          DO IFREQ=1,NFREQ
            WRITE(LUNGFO,'(5x,5G15.5)')SNGL(FREQ(IFREQ))
     &        ,(BRILLCE(IS,IFREQ)*(1.D-6)**2,IS=1,4)
          ENDDO !IFREQ

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     estimated brilliance maxima, flux and flux-density of S0, S1, S2, S3'
          WRITE(LUNGFO,*)'     with energy spread:'
          WRITE(LUNGFO,*)
          DO IS=1,4
            WRITE(LUNGFO,'(5X,4G15.5)')BRILLCMXE(IS,1)
     &        ,BRILLCMXE(IS,2)*(1.D-6)**2
     &        ,BRILLCMXE(IS+4,2)
     &        ,STOKCMXE(IS,2)*DIST**2*(1.D-3)**2
          ENDDO

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     estimated brilliance maximum of S3*S3/S0'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     with energy spread:'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,'(5X,2G15.5)')B3CMXE(1),B3CMXE(2)*(1.D-6)**2

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     Brilliance [photons/sec/BW/mm**2/mrad**2] with emittance'
          WRITE(LUNGFO,*)
     &      '     (e-folded)'
          WRITE(LUNGFO,*)

          DO IFREQ=1,NFREQ
            WRITE(LUNGFO,'(5x,5G15.5)')SNGL(FREQ(IFREQ))
     &        ,(BRILLCEF(IS,IFREQ)*(1.D-6)**2,IS=1,4)
          ENDDO !IFREQ

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     estimated brilliance maxima, flux and flux-density of S0, S1, S2, S3'
          WRITE(LUNGFO,*)
     &      '     with emittance and energy spread:'
          WRITE(LUNGFO,*)
          DO IS=1,4
            WRITE(LUNGFO,'(5X,4G15.5)')BRILLCMXEF(IS,1)
     &        ,BRILLCMXEF(IS,2)*(1.D-6)**2
     &        ,BRILLCMXEF(IS+4,2)
     &        ,STOKCMXEF(IS,2)*DIST**2*(1.D-3)**2
          ENDDO

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     estimated brilliance maximum of S3*S3/S0'
          WRITE(LUNGFO,*)
     &      '     with emittance and energy spread:'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,'(5X,2G15.5)')B3CMXEF(1),B3CMXEF(2)*(1.D-6)**2

        ENDIF   !EFOLD

      endif !ibunch

      IF(IWFILBRILL.NE.0.AND.ISTOKES.NE.0) THEN

        OPEN(UNIT=LUNC,FILE=FILEBRILL,STATUS='NEW')

        WRITE(LUNC,*)ICODE,' ',CODE
        WRITE(LUNC,*)NFREQ

        DO IFREQ=1,NFREQ
          IF (IUNIT.EQ.0)
     &      WRITE(LUNC,*)SNGL(FREQ(IFREQ))
     &      ,((BRILLC(IS,IFREQ)),IS=1,4)
        ENDDO

        CLOSE(LUNC)
      ENDIF !IWFILB

      if (ibunch.eq.0) then

        IF(IWFILBRILLF.NE.0.AND.ISTOKES.NE.0) THEN

          OPEN(UNIT=LUNCF,FILE=FILEBRILLF,STATUS='NEW')

          WRITE(LUNCF,*)ICODE,' ',CODE
          WRITE(LUNCF,*)NFREQ

          DO IFREQ=1,NFREQ
            IF (IUNIT.EQ.0)
     &        WRITE(LUNCF,*)SNGL(FREQ(IFREQ))
     &        ,((BRILLCF(IS,IFREQ)),IS=1,4)
          ENDDO

          CLOSE(LUNCF)
        ENDIF !IWFILBF

        IF(IEFOLD.NE.0.AND.IWFILBRILLE.NE.0.AND.ISTOKES.NE.0) THEN

          OPEN(UNIT=LUNCE,FILE=FILEBRILLE,STATUS='NEW')

          WRITE(LUNCE,*)ICODE,' ',CODE
          WRITE(LUNCE,*)NFREQ

          DO IFREQ=1,NFREQ
            IF (IUNIT.EQ.0)
     &        WRITE(LUNCE,*)SNGL(FREQ(IFREQ))
     &        ,((BRILLCE(IS,IFREQ)),IS=1,4)
          ENDDO
          CLOSE(LUNCE)
        ENDIF !IWFILBE

        IF(IEFOLD.NE.0.AND.IWFILBRILLEF.NE.0.AND.ISTOKES.NE.0) THEN

          OPEN(UNIT=LUNCEF,FILE=FILEBRILLEF,STATUS='NEW')

          WRITE(LUNCEF,*)ICODE,' ',CODE
          WRITE(LUNCEF,*)NFREQ

          DO IFREQ=1,NFREQ
            IF (IUNIT.EQ.0)
     &        WRITE(LUNCEF,*)SNGL(FREQ(IFREQ))
     &        ,((BRILLCEF(IS,IFREQ)),IS=1,4)
          ENDDO

          CLOSE(LUNCEF)

        ENDIF !IWFILBEF

      endif !ibunch

      OPEN(UNIT=LUNCEF,FILE='brill_brilliance.dat',
     &  STATUS='unknown')
      do is=1,4
        WRITE(LUNcef,'(2G15.5)')BRILLCMX(IS,1)
     &    ,BRILLCMX(IS,2)*(1.D-6)**2
      enddo
      close(luncef)

      OPEN(UNIT=LUNCEF,FILE='brill_flux-density.dat',
     &  STATUS='unknown')
      do is=1,4
        WRITE(LUNcef,'(2G15.5)')BRILLCMX(IS,1)
     &    ,STOKCMX(IS,2)*DIST**2*(1.D-3)**2
      enddo
      close(luncef)

      OPEN(UNIT=LUNCEF,FILE='brill_flux.dat',
     &  STATUS='unknown')
      do is=1,4
        WRITE(LUNcef,'(2G15.5)')BRILLCMX(IS,1)
     &    ,BRILLCMX(IS+4,2)
      enddo
      close(luncef)

      if (ibunch.eq.0) then

        OPEN(UNIT=LUNCEF,FILE='brill_brilliance_e.dat',
     &    STATUS='unknown')
        do is=1,4
          WRITE(LUNcef,'(2G15.5)')BRILLCMXe(IS,1)
     &      ,BRILLCMXe(IS,2)*(1.D-6)**2
        enddo
        close(luncef)

        OPEN(UNIT=LUNCEF,FILE='brill_flux-density_e.dat',
     &    STATUS='unknown')
        do is=1,4
          WRITE(LUNcef,'(2G15.5)')BRILLCMXE(IS,1)
     &      ,STOKCMXE(IS,2)*DIST**2*(1.D-3)**2
        enddo
        close(luncef)

        OPEN(UNIT=LUNCEF,FILE='brill_flux_e.dat',
     &    STATUS='unknown')
        do is=1,4
          WRITE(LUNcef,'(2G15.5)')BRILLCMXe(IS,1)
     &      ,BRILLCMXe(IS+4,2)
        enddo
        close(luncef)

        OPEN(UNIT=LUNCEF,FILE='brill_brilliance_f.dat',
     &    STATUS='unknown')
        do is=1,4
          WRITE(LUNcef,'(2G15.5)')BRILLCMXf(IS,1)
     &      ,BRILLCMXf(IS,2)*(1.D-6)**2
        enddo
        close(luncef)

        OPEN(UNIT=LUNCEF,FILE='brill_flux-density_f.dat',
     &    STATUS='unknown')
        do is=1,4
          WRITE(LUNcef,'(2G15.5)')BRILLCMXf(IS,1)
     &      ,STOKCMXf(IS,2)*DIST**2*(1.D-3)**2
        enddo
        close(luncef)

        OPEN(UNIT=LUNCEF,FILE='brill_flux_f.dat',
     &    STATUS='unknown')
        do is=1,4
          WRITE(LUNcef,'(2G15.5)')BRILLCMXf(IS,1)
     &      ,BRILLCMXf(IS+4,2)
        enddo
        close(luncef)

        OPEN(UNIT=LUNCEF,FILE='brill_brilliance_ef.dat',
     &    STATUS='unknown')
        do is=1,4
          WRITE(LUNcef,'(2G15.5)')BRILLCMXef(IS,1)
     &      ,BRILLCMXef(IS,2)*(1.D-6)**2
        enddo
        close(luncef)

        OPEN(UNIT=LUNCEF,FILE='brill_flux-density_ef.dat',
     &    STATUS='unknown')
        do is=1,4
          WRITE(LUNcef,'(2G15.5)')BRILLCMXef(IS,1)
     &      ,STOKCMXef(IS,2)*DIST**2*(1.D-3)**2
        enddo
        close(luncef)

        OPEN(UNIT=LUNCEF,FILE='brill_flux_ef.dat',
     &   STATUS='unknown')
        do is=1,4
          WRITE(LUNcef,'(2G15.5)')BRILLCMXef(IS,1)
     &      ,BRILLCMXef(IS+4,2)
        enddo
        close(luncef)

      endif !ibunch

      RETURN
      END
+DECK,BSPLINE.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  2.13/09 08/03/2000  18.08.37  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.14  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BSPLINE(X,YX,YY,N,YP1,YPN,Y2X,Y2Y,UX,UY)
+seq,gplhint.

      IMPLICIT NONE

      INTEGER K,I,N

      DOUBLE PRECISION X,YX,YY,Y2X,Y2Y,UX,UY,QN,UNX,UNY,SIG,PX,PY,YPN,YP1
        DIMENSION X(N),YX(N),YY(N),Y2X(N),Y2Y(N),UX(N),UY(N)

      IF (YP1.GT..99E30) THEN
        Y2X(1)=0.
        UX(1)=0.
        Y2Y(1)=0.
        UY(1)=0.
      ELSE
        Y2X(1)=-0.5
        UX(1)=(3./(X(2)-X(1)))*((YX(2)-YX(1))/(X(2)-X(1))-YP1)
        Y2Y(1)=-0.5
        UY(1)=(3./(X(2)-X(1)))*((YY(2)-YY(1))/(X(2)-X(1))-YP1)
      ENDIF
      DO 11 I=2,N-1
        SIG=(X(I)-X(I-1))/(X(I+1)-X(I-1))
        PX=SIG*Y2X(I-1)+2.
        Y2X(I)=(SIG-1.)/PX
        UX(I)=(6.*((YX(I+1)-YX(I))/(X(I+1)-X(I))-(YX(I)-YX(I-1))
     *      /(X(I)-X(I-1)))/(X(I+1)-X(I-1))-SIG*UX(I-1))/PX
        PY=SIG*Y2Y(I-1)+2.
        Y2Y(I)=(SIG-1.)/PY
        UY(I)=(6.*((YY(I+1)-YY(I))/(X(I+1)-X(I))-(YY(I)-YY(I-1))
     *      /(X(I)-X(I-1)))/(X(I+1)-X(I-1))-SIG*UY(I-1))/PY
11    CONTINUE
      IF (YPN.GT..99E30) THEN
        QN=0.
        UNX=0.
        UNY=0.
      ELSE
        QN=0.5
        UNX=(3./(X(N)-X(N-1)))*(YPN-(YX(N)-YX(N-1))/(X(N)-X(N-1)))
        UNY=(3./(X(N)-X(N-1)))*(YPN-(YY(N)-YY(N-1))/(X(N)-X(N-1)))
      ENDIF
      Y2X(N)=(UNX-QN*UX(N-1))/(QN*Y2X(N-1)+1.)
      Y2Y(N)=(UNY-QN*UY(N-1))/(QN*Y2Y(N-1)+1.)
      DO 12 K=N-1,1,-1
        Y2X(K)=Y2X(K)*Y2X(K+1)+UX(K)
        Y2Y(K)=Y2Y(K)*Y2Y(K+1)+UY(K)
12    CONTINUE
      RETURN
      END
+DECK,BSPLINT.
*CMZ :  3.02/00 24/09/2014  13.51.08  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.66/19 07/06/2011  14.08.31  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  16.46.16  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.48.34  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.15  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BSPLINT(XA,YAX,YAY,Y2AX,Y2AY,N,X,YX,YY,KOLD,KLO)
+seq,gplhint.

      IMPLICIT NONE

      INTEGER N,INC,KOLD,KLO,KHI,K
      REAL XA,YAX,YAY,Y2AX,Y2AY,X,YX,YY,B
      REAL H,A

      DIMENSION XA(*),YAX(*),YAY(*),Y2AX(*),Y2AY(*)

C SUBROUTINE MACHT SPLINE-INTERPOLATIONS. SIEHE "NUMERICAL RECIPIES"

      IF(X.GT.XA(N).OR.X.LT.XA(1)) THEN
          STOP '*** S/R BSPLINT: X OUT OF RANGE ***'
      ELSE IF (X.EQ.XA(N)) THEN
          YX=YAX(N)
          YY=YAY(N)
          RETURN
      ELSE IF (X.EQ.XA(1)) THEN
          YX=YAX(1)
          YY=YAY(1)
          RETURN
      ENDIF

      KLO=KOLD

      IF(KLO.LT.1 .OR. KLO.GT.N) THEN
          KLO=1
          KHI=N
          GOTO 3
      ENDIF

      INC=1
      IF (X.GT.XA(KLO)) THEN
1         KHI=KLO+INC
          IF (KHI.GT.N) THEN
         KHI=N
          ELSE IF (X.GE.XA(KHI)) THEN
         KLO=KHI
         INC=INC+INC
         GOTO 1
          ENDIF
      ELSE
          KHI=KLO
2         KLO=KHI-INC
          IF (KLO.LT.1) THEN
         KLO=1
          ELSE IF (X.LT.XA(KLO)) THEN
         KHI=KLO
         INC=INC+INC
         GOTO 2
          ENDIF
      ENDIF
3     IF (KHI-KLO.GT.1) THEN
        K=(KHI+KLO)/2
        IF(XA(K).GT.X)THEN
          KHI=K
        ELSE
          KLO=K
        ENDIF
      GOTO 3
      ENDIF
      H=XA(KHI)-XA(KLO)
      IF (H.LE.0.    .OR. X.LT.XA(KLO).OR.X.GT.XA(KHI)) THEN
        WRITE(6,*) '*** SR BSPLINT: Bad XA input. ***'
        STOP
      ENDIF
      A=(XA(KHI)-X)/H
      B=(X-XA(KLO))/H
      YX=A*YAX(KLO)+B*YAX(KHI)+
     *      ((A**3-A)*Y2AX(KLO)+(B**3-B)*Y2AX(KHI))*(H**2)/6.
      YY=A*YAY(KLO)+B*YAY(KHI)+
     *      ((A**3-A)*Y2AY(KLO)+(B**3-B)*Y2AY(KHI))*(H**2)/6.
      RETURN
      END
+DECK,btab.
*CMZ :  4.00/16 22/07/2022  10.31.35  by  Michael Scheer
*CMZ :  4.00/15 28/03/2022  12.44.37  by  Michael Scheer
*CMZ :  4.00/11 17/05/2021  11.34.14  by  Michael Scheer
*CMZ :  4.00/07 09/07/2020  16.52.53  by  Michael Scheer
*CMZ :  4.00/03 07/05/2019  14.24.38  by  Michael Scheer
*CMZ :  3.05/23 23/11/2018  18.01.47  by  Michael Scheer
*CMZ :  3.04/00 19/01/2018  13.23.56  by  Michael Scheer
*CMZ :  3.03/02 16/02/2017  13.03.18  by  Michael Scheer
*CMZ :  3.01/04 09/05/2014  14.31.02  by  Michael Scheer
*CMZ :  3.01/03 20/03/2014  13.03.02  by  Michael Scheer
*CMZ :  2.63/02 24/01/2008  15.24.28  by  Michael Scheer
*CMZ :  2.52/11 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.52/09 29/10/2004  12.30.03  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  2.13/10 25/03/2000  14.36.30  by  Michael Scheer
*CMZ :  2.13/11 22/03/2000  13.00.11  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.25.04  by  Michael Scheer
*CMZ :  2.13/00 03/12/99  16.05.55  by  Michael Scheer
*CMZ :  2.11/00 10/05/99  17.40.30  by  Michael Scheer
*CMZ :  1.04/00 25/11/98  14.08.28  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  15.07.21  by  Michael Scheer
*CMZ : 00.02/05 03/03/97  12.25.12  by  Michael Scheer
*CMZ : 00.01/12 15/10/96  12.15.47  by  Michael Scheer
*CMZ : 00.01/02 24/11/94  15.56.48  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.48.39  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.35  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BTAB(XIN,Y,Z,BX,BY,BZ,AX,AY,AZ)
+seq,gplhint.

C     BTAB LIEST B-FELD TABELLE UND BERECHNET DURCH SPLINE-INTERPOLATION B-FELD

      use fbtabzymod

      IMPLICIT NONE

      CHARACTER(60) BTABCOM

      INTEGER ISYM,ICAL,I,NPOINT,IWARNY,IWARN,IMONO,ifaili,ieof,ifaile
+self,if=btabparab.
      INTEGER ILOW,IHIGH
+self.

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,B0SCGLOB.

      DOUBLE PRECISION XA(NBTABP),BYA(NBTABP),Y2A(NBTABP)
      DOUBLE PRECISION XSCALE,BYSCALE,X,Y,Z,BX,BY,BZ,XIN,TOTLEN,TOTLEN2
      DOUBLE PRECISION AX,AY,AZ,apl,aph,x0l,x0h
+self,if=btabparab.
      DOUBLE PRECISION AL(3),AH(3)
+self.

      COMMON/BTABC/XA,BYA,Y2A

+self,if=btabparab.
      DATA ILOW/0/
      DATA IHIGH/0/
+self.
      DATA ISYM/0/,ICAL/0/
      DATA IWARN/0/

      IF (ICAL.NE.1) THEN

        IWARNY=0

        OPEN (UNIT=LUNTB,FILE = FILETB,STATUS = 'OLD',FORM = 'FORMATTED')

        if (irbtab.gt.0.or.irbtabzy.gt.0.or.irbtabxyz.gt.0) then
          call util_skip_comment_end(luntb,ieof)
          READ(LUNTB,'(1A60)') BTABCOM
          call util_skip_comment_end(luntb,ieof)
          READ(LUNTB,*) XSCALE,BYSCALE
          call util_skip_comment_end(luntb,ieof)
          READ(LUNTB,*) NPOINT
          call util_skip_comment_end(luntb,ieof)
        else
          npoint=0
          btabcom=filetb(1:60)
1         continue
          call util_skip_comment_end(luntb,ieof)
          if (ieof.ne.0) goto 9
          READ(LUNTB,*) x,by
          npoint=npoint+1
          goto 1
9         rewind(luntb)
          xscale=1.0d0
          if (irbtab.eq.-2) xscale=0.001d0
          byscale=1.0d0
        endif

        IF (NPOINT.GT.NBTABP.OR.-2*NPOINT-1.GT.NBTABP) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN BTAB ***'
          WRITE(LUNGFO,*)'DIMENSION EXCEEDED, INCREASE NBTABP***'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN BTAB ***'
          WRITE(6,*)'DIMENSION EXCEEDED, INCREASE NBTABP***'
          WRITE(6,*)
          STOP
        ENDIF

        IF (ABS(NPOINT).LT.2) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN BTAB ***'
          WRITE(LUNGFO,*)
     &      'LESS THAN TWO POINTS ON DATA FILE OF MAGNETIC FIELD'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN BTAB ***'
          WRITE(6,*)'LESS THAN TWO POINTS ON DATA FILE OF MAGNETIC FIELD'
          WRITE(6,*)
          STOP
        ENDIF

        IF (NPOINT.GT.0.AND.NPOINT.LT.3) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN BTAB ***'
          WRITE(LUNGFO,*)
     &      'LESS THAN THREE POINTS ON DATA FILE OF MAGNETIC FIELD'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN BTAB ***'
          WRITE(6,*)'LESS THAN THREE POINTS ON DATA FILE OF MAGNETIC FIELD'
          WRITE(6,*)
        ENDIF

        IF (NPOINT.LT.0) THEN
          ISYM=1
          NPOINT=-NPOINT
        ENDIF

        DO I=1,NPOINT
          call util_skip_comment_end(luntb,ieof)
          READ(LUNTB,*)XA(I),BYA(I)
          XA(I)=XA(I)*XSCALE-XSHBTAB
          BYA(I)=BYA(I)*BYSCALE
c          write(6,*)i,xa(i),bya(i)
        END DO

        call util_parabola_to_zero(xa(1:2),bya(1:2),apl,x0l,ifaili)
        call util_parabola_to_zero(xa(npoint-1:npoint),bya(npoint-1:npoint),
     &    aph,x0h,ifaile)

        CLOSE(LUNTB)

        call util_sort_func(npoint,xa,bya)

        CALL UTIL_CHECK_MONOTON(NPOINT,XA,IMONO)
        IF (ABS(IMONO).NE.2) THEN
          PRINT *,'*** ERROR IN BTAB: Field data not monoton'
          WRITE(LUNGFO,*)'*** ERROR IN BTAB: FIELD DATA NOT MONOTON'
          STOP '*** Program WAVE aborted'
        ENDIF

C--- SYMMETRISIEREN

        IF (ISYM.EQ.1) THEN

          IF(XA(1).LT.0.) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN BTAB ***'
            WRITE(LUNGFO,*)'FIRST X-VALUE ON DATA FILE LOWER ZERO'
            WRITE(LUNGFO,*)'SYMMETRY OPTION REQUIRES POSITIV X-VALUES'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN BTAB ***'
            WRITE(6,*)'FIRST X-VALUE ON DATA FILE LOWER ZERO'
            WRITE(6,*)'SYMMETRY OPTION REQUIRES POSITIV X-VALUES'
            WRITE(6,*)
            STOP
          ENDIF !XA

          IF(XA(1).NE.0.) THEN

            DO I=1,NPOINT        !SHIFT
              XA(I+NPOINT)= XA(I)
              BYA(I+NPOINT)=BYA(I)
            END DO

            DO I=1,NPOINT
              XA(I)=-XA(2*NPOINT-I+1)
              BYA(I)=BYA(2*NPOINT-I+1)
            END DO

            NPOINT=2*NPOINT

          ELSE

            DO I=1,NPOINT        !SHIFT

              XA(2*NPOINT-I)= XA(NPOINT-I+1)
              BYA(2*NPOINT-I)=BYA(NPOINT-I+1)

            END DO

            DO I=1,NPOINT-1
              XA(I) =-XA(2*NPOINT-I)
              BYA(I)=BYA(2*NPOINT-I)
            END DO

            NPOINT=2*NPOINT-1

          ENDIF

        ENDIF

        TOTLEN=DABS(XA(NPOINT)-XA(1))
        TOTLEN2=TOTLEN/2.D0
        DEVLEN=TOTLEN
        DEVLEN2=TOTLEN2

        WRITE (LUNGFO,*)
        WRITE (LUNGFO,*)'     SR BTAB: Magnetic field data read from file'
        WRITE (LUNGFO,*)'     ',FILETB
        WRITE (LUNGFO,*)
        WRITE (LUNGFO,*)'     BTAB comment:',BTABCOM
        WRITE (LUNGFO,*)
        WRITE (LUNGFO,*)'     Length of device:     ',TOTLEN
        WRITE (LUNGFO,*)'     Half length of device:',TOTLEN2
        WRITE (LUNGFO,*)

C060793  CALL SPLINETB(XA,BYA,NPOINT,2.D30,2.D30,Y2A)
        CALL SPLINETB(XA,BYA,NPOINT,0.D0,0.D0,Y2A)

        IF (XSTART.EQ.9999.) XSTART=XA(1)
        IF ( XSTOP.EQ.9999.)  XSTOP=XA(NPOINT)

        nfbtabc=npoint
        ical=1
      ENDIF !(ICAL)

      IF(Y.NE.0..AND.IWARNY.EQ.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING SR BTAB ***'
        WRITE(LUNGFO,*)'Y-COORDINATE OF ELECTRON NOT ZERO'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING SR BTAB ***'
        WRITE(6,*)'Y-COORDINATE OF ELECTRON NOT ZERO'
        WRITE(6,*)
        IWARNY=1
      ENDIF

C22.3.93 X=DMOD(XIN,TOTLEN) !2.12.91
C22.3.93 IF (X.GT.TOTLEN2) THEN
C22.3.93     X=X-TOTLEN
C22.3.93 ELSEIF (X.LT.-TOTLEN2) THEN
C22.3.93     X=X+TOTLEN
C22.3.93 ENDIF

C22.3.93 IF(X.LT.XA(1).OR.X.GT.XA(NPOINT)) THEN
C22.3.93     STOP '*** S/R BTAB: X MORE THAN ONE STEP OUT OF TABLE ***'
C22.3.93 ENDIF


C22.3.93 --------------------------------------------------------

      IF (XIN.EQ.9999.) THEN
        X=XSTART
      ELSE
        X=XIN
      ENDIF

      IF(iperiodg.eq.0.and.IWARN.EQ.0.AND.
     &    (X.LT.XA(1)-1./MYINUM.OR.X.GT.XA(NPOINT)+1./MYINUM)) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN BTAB ***'
        WRITE(LUNGFO,*)'X MORE THAN ONE STEP OUT OF TABLE'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'X, XMIN, XMAX:'
        WRITE(LUNGFO,*)X,XA(1),XA(NPOINT)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN BTAB ***'
        WRITE(6,*)'X MORE THAN ONE STEP OUT OF TABLE'
        WRITE(6,*)
        WRITE(6,*)'X, XMIN, XMAX:'
        WRITE(6,*)X,XA(1),XA(NPOINT)
+self,if=btabparab.
        print*,'Field and vector potential extrapolated form parabola'
+self,if=-btabparab.
        print*,'Field and vector potential smoothed to zero'
+self.
        IWARN=1
      ENDIF

      IF(X.LT.XA(1)) THEN
+self,if=btabparab.
        IF (ILOW.NE.1) THEN
          CALL PARABEL(XA(1),BYA(1),XA(2),BYA(2),XA(3),BYA(3),AL)
          ILOW=1
        ENDIF   ! ILOW

        BX=0.
        BY=AL(1)+AL(2)*X+AL(3)*X*X
        BZ=0.

        AX=0.5*BY*Z
        AY=0.0
        AZ=-0.5*BY*X
+self,if=-btabparab.
        BX=0.0D0
        BZ=0.0D0
        if (x.lt.x0l.or.ifaili.ne.0) then
          if (ifaili.eq.-1) then
            print*,"*** WARNING IN BTAB: Failed to find extrapolation parabola at intrance"
            ifaili=-2
          endif
          BY=0.0D0
        else
          by=apl*(x-x0l)**2
        endif
        AX=0.5*BY*Z
        AY=0.0
        AZ=-0.5*BY*X
+self.
        RETURN
      ENDIF !X.LT.XA(1)

      IF(X.GT.XA(NPOINT)) THEN
+self,if=btabparab.
        IF (IHIGH.NE.1) THEN
          CALL PARABEL(XA(NPOINT-2),BYA(NPOINT-2)
     &      ,XA(NPOINT-1),BYA(NPOINT-1)
     &      ,XA(NPOINT)  ,BYA(NPOINT)  ,AH)
          IHIGH=1
        ENDIF   ! IHIGH

        BX=0.
        BY=AH(1)+AH(2)*X+AH(3)*X*X
        BZ=0.

        AX=0.5*BY*Z
        AY=0.0
        AZ=-0.5*BY*X

+self,if=-btabparab.
        BX=0.0D0
        BZ=0.0D0
        if (x.gt.x0h.or.ifaile.ne.0) then
          if (ifaile.eq.-1) then
            print*,"*** WARNING IN BTAB: Failed to find extrapolation parabola at exit"
            ifaile=-2
          endif
          BY=0.0D0
        else
          by=aph*(x-x0h)**2
        endif
        AX=0.5*BY*Z
        AY=0.0
        AZ=-0.5*BY*X
+self.

        RETURN
      ENDIF !X.GT.XA(NPOINT)

C22.3.93 --------------------------------------------------------

c      write(6,*)ical,npoint,x,by
      CALL SPLINTB(NPOINT,X,BY)

      BX=0.
      BZ=0.

      AX=0.5*BY*Z
      AY=0.0
      AZ=-0.5*BY*X

      RETURN
      END
+DECK,BTABZ.
*CMZ :  4.00/15 28/03/2022  12.42.45  by  Michael Scheer
*CMZ :  4.00/11 17/05/2021  11.34.33  by  Michael Scheer
*CMZ :  3.01/04 21/03/2014  14.02.03  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.54/04 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.52/09 29/10/2004  12.30.12  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.25.04  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  15.07.21  by  Michael Scheer
*CMZ : 00.01/08 31/05/95  13.36.58  by  Michael Scheer
*CMZ : 00.01/02 24/11/94  15.57.38  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.48.44  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.59  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BTABZ(XIN,Y,Z,BX,BY,BZ,AX,AY,AZ,XS,XE)
+seq,gplhint.

C     BTAB-Version for horizontal field Bz

      use fbtabzymod

      IMPLICIT NONE

      CHARACTER(60) BTABCOM

      INTEGER :: ISYM,ICAL,I,NPOINT,ILOW,IHIGH,IWARN,ieof=0

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,B0SCGLOB.

      DOUBLE PRECISION XA(NBTABP),BYA(NBTABP),Y2A(NBTABP)
      DOUBLE PRECISION XSCALE,BYSCALE,X,Y,Z,BX,BY,BZ,XIN,TOTLEN,TOTLEN2
      DOUBLE PRECISION AL(3),AH(3),AX,AY,AZ
      DOUBLE PRECISION XS,XE,ZDUM

      COMMON/BTABCz/XA,BYA,Y2A


      DATA ILOW/0/
      DATA IHIGH/0/
      DATA ISYM/0/,ICAL/0/

      IF (ICAL.NE.1) THEN

        ZDUM=Z

        OPEN (UNIT=LUNTBz,FILE = FILETBz,STATUS = 'OLD',FORM = 'FORMATTED')

        if (irbtabzy.gt.0.or.irbtabxyz.gt.0) then
          READ(LUNTBZ,'(1A60)') BTABCOM
          READ(LUNTBZ,*) XSCALE,BYSCALE
          READ(LUNTBZ,*) NPOINT
        else
          btabcom=trim(filetbz)
          xscale=1.0d0
          if (irbtabzy.eq.-2.or.irbtabxyz.eq.-2) xscale=0.001d0
          byscale=1.0d0
          npoint=0
          do while (ieof.eq.0)
            call util_skip_comment_end(luntbz,ieof)
            read(luntbz,*)x,by
            if (ieof.ne.0) then
              rewind(luntbz)
              exit
            endif
            npoint=npoint+1
          enddo
        endif

        IF (NPOINT.GT.NBTABP.OR.-2*NPOINT-1.GT.NBTABP) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN BTABZ ***'
          WRITE(LUNGFO,*)'DIMENSION EXCEEDED, INCREASE NBTABP***'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN BTABZ ***'
          WRITE(6,*)'DIMENSION EXCEEDED, INCREASE NBTABP***'
          WRITE(6,*)
          STOP
        ENDIF

        IF (ABS(NPOINT).LT.2) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN BTABZ ***'
          WRITE(LUNGFO,*)
     &      'LESS THAN TWO POINTS ON DATA FILE OF MAGNETIC FIELD'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN BTABZ ***'
          WRITE(6,*)'LESS THAN TWO POINTS ON DATA FILE OF MAGNETIC FIELD'
          WRITE(6,*)
        ENDIF

        IF (NPOINT.GT.0.AND.NPOINT.LT.3) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN BTABZ ***'
          WRITE(LUNGFO,*)
     &      'LESS THAN THREE POINTS ON DATA FILE OF MAGNETIC FIELD'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN BTABZ ***'
          WRITE(6,*)'LESS THAN THREE POINTS ON DATA FILE OF MAGNETIC FIELD'
          WRITE(6,*)
        ENDIF

        IF (NPOINT.LT.0) THEN
          ISYM=1
          NPOINT=-NPOINT
        ENDIF

        DO I=1,NPOINT
          READ(LUNTBZ,*)XA(I),BYA(I)
          XA(I)=XA(I)*XSCALE-XSHBTAB
          BYA(I)=BYA(I)*BYSCALE
        END DO

        CLOSE(LUNTBZ)

        call util_sort_func(npoint,xa,bya)

C--- SYMMETRISIEREN

        IF (ISYM.EQ.1) THEN

          IF(XA(1).LT.0.) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN BTABZ ***'
            WRITE(LUNGFO,*)'FIRST X-VALUE ON DATA FILE LOWER ZERO'
            WRITE(LUNGFO,*)'SYMMETRY OPTION REQUIRES POSITIV X-VALUES'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN BTABZ ***'
            WRITE(6,*)'FIRST X-VALUE ON DATA FILE LOWER ZERO'
            WRITE(6,*)'SYMMETRY OPTION REQUIRES POSITIV X-VALUES'
            WRITE(6,*)
            STOP
          ENDIF !XA

          IF(XA(1).NE.0) THEN

            DO I=1,NPOINT        !SHIFT
              XA(I+NPOINT)= XA(I)
              BYA(I+NPOINT)=BYA(I)
            END DO

            DO I=1,NPOINT
              XA(I)=-XA(2*NPOINT-I+1)
              BYA(I)=BYA(2*NPOINT-I+1)
            END DO

            NPOINT=2*NPOINT

          ELSE


            DO I=1,NPOINT        !SHIFT

              XA(2*NPOINT-I)= XA(NPOINT-I+1)
              BYA(2*NPOINT-I)=BYA(NPOINT-I+1)

            END DO

            DO I=1,NPOINT-1
              XA(I) =-XA(2*NPOINT-I)
              BYA(I)=BYA(2*NPOINT-I)
            END DO

            NPOINT=2*NPOINT-1

          ENDIF

        ENDIF

        TOTLEN=DABS(XA(NPOINT)-XA(1))
        TOTLEN2=TOTLEN/2.D0
        DEVLEN=TOTLEN
        DEVLEN2=TOTLEN2

        WRITE (LUNGFO,*)
        WRITE (LUNGFO,*)'     SR BTABZ: Magnetic field data read from file'
        WRITE (LUNGFO,*)'     ',FILETBz
        WRITE (LUNGFO,*)
        WRITE (LUNGFO,*)'     BTABZ comment:',BTABCOM
        WRITE (LUNGFO,*)
        WRITE (LUNGFO,*)'     Length of device:     ',TOTLEN
        WRITE (LUNGFO,*)'     Half length of device:',TOTLEN2
        WRITE (LUNGFO,*)

C060793  CALL SPLINETB(XA,BYA,NPOINT,2.D30,2.D30,Y2A)
        CALL SPLINETB(XA,BYA,NPOINT,0.D0,0.D0,Y2A)

        IF (XS.EQ.9999.)  XSTART=XA(1)
        IF (XE.EQ.9999.)  XSTOP=XA(NPOINT)

        ICAL=1

        nfbtabcz=npoint

      ENDIF !(ICAL)

      IF(Y.NE.0.) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN BTABZ ***'
        WRITE(LUNGFO,*)'Y-COORDINATE OF ELECTRON NOT ZERO'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN BTABZ ***'
        WRITE(6,*)'Y-COORDINATE OF ELECTRON NOT ZERO'
        WRITE(6,*)
        STOP
      ENDIF

      IF (XIN.EQ.9999.) THEN
        X=XSTART
      ELSE
        X=XIN
      ENDIF

      IF(X.LT.XA(1)-1./MYINUM.OR.X.GT.XA(NPOINT)+1./MYINUM) THEN
        IF (IWARN.EQ.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN BTABZ ***'
          WRITE(LUNGFO,*)'X MORE THAN ONE STEP OUT OF TABLE'
          WRITE(LUNGFO,*)'X:',X
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN BTABZ ***'
          WRITE(6,*)'X MORE THAN ONE STEP OUT OF TABLE'
          WRITE(6,*)'X:',X
          WRITE(6,*)
          IWARN=1
        ENDIF
        BX=0.0D0
        BY=0.0D0
        BZ=0.0D0
        AX=0.0D0
        AY=0.0D0
        AZ=0.0D0
        RETURN
      ENDIF

      IF(X.LT.XA(1)) THEN
        IF (ILOW.NE.1) THEN
          CALL PARABEL(XA(1),BYA(1),XA(2),BYA(2),XA(3),BYA(3),AL)
          ILOW=1
        ENDIF   ! ILOW

        Bx=0.
        By=0.
        Bz=AL(1)+AL(2)*X+AL(3)*X*X

        AX=-0.5*Bz*y
        Ay= 0.5*Bz*x
        Az= 0.0

        RETURN
      ENDIF !X.LT.XA(1)

      IF(X.GT.XA(NPOINT)) THEN

        IF (IHIGH.NE.1) THEN

          CALL PARABEL(XA(NPOINT-2),BYA(NPOINT-2)
     &      ,XA(NPOINT-1),BYA(NPOINT-1)
     &      ,XA(NPOINT)  ,BYA(NPOINT)  ,AH)

          IHIGH=1
        ENDIF   ! IHIGH

        By=0.
        Bx=0.
        Bz=AH(1)+AH(2)*X+AH(3)*X*X

        AX=-0.5*Bz*y
        Ay= 0.5*Bz*x
        Az= 0.0

        RETURN

      ENDIF !X.GT.XA(NPOINT)

      CALL SPLINTBz(NPOINT,X,Bz)

      BX=0.
      By=0.

      AX=-0.5*Bz*y
      Ay= 0.5*Bz*x
      Az= 0.0

      RETURN
      END
+DECK,BTABZY.
*CMZ :  4.00/11 17/05/2021  11.08.35  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.54/04 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.16/08 01/11/2000  18.41.44  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ : 00.01/08 31/05/95  13.30.40  by  Michael Scheer
*CMZ : 00.01/02 24/11/94  16.00.44  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  18.02.31  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.57  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BTABZY(XIN,DUMY,DUMZ,BX,BY,BZ,AX,AY,AZ)
+seq,gplhint.

C     BTABZY reads By and Bz from data files and interpolates fields

      IMPLICIT NONE

+SEQ,CONTRL.

      INTEGER ICAL

      DOUBLE PRECISION XIN,DUMY,DUMZ,DUMZY,XS,XE,XS1,XS2,XE1,XE2
      DOUBLE PRECISION AX,AY,AZ,BX,BY,BZ
      DOUBLE PRECISION AXX,AYY,AZZ,BXX,BYY,BZZ
      DOUBLE PRECISION AXXX,AYYY,AZZZ,BXXX,BYYY,BZZZ

      DATA ICAL/0/
      DATA XS1,XS2,XE1,XE2/4*0.0/

      DUMZY=DUMY
      DUMZY=DUMZ

      BXX=0.
      BYY=0.
      BZZ=0.

      AXX=0.
      AYY=0.
      AZZ=0.

      BXXX=0.
      BYYY=0.
      BZZZ=0.

      AXXX=0.
      AYYY=0.
      AZZZ=0.

      XS=XSTART
      XE=XSTOP


      CALL BTAB (XIN,0.D0,0.D0, BXX, BYY, BZZ, AXX, AYY, AZZ)

      IF (ICAL.EQ.0) THEN

         XS1=XSTART
         XE1=XSTOP

      ENDIF !ICAL

      CALL BTABZ(XIN,0.D0,0.D0,BXXX,BYYY,BZZZ,AXXX,AYYY,AZZZ,XS,XE)

      IF (ICAL.EQ.0) THEN

          XS2=XSTART
          XE2=XSTOP

          IF (XS1.NE.XS2) XSTART=DMIN1(XS1,XS2)
          IF (XE1.NE.XE2)  XSTOP=DMAX1(XE1,XE2)

          ICAL=1

      ENDIF !ICAL

      BX=BXX+BXXX
      BY=BYY+BYYY
      BZ=BZZ+BZZZ

      AX=AXX+AXXX
      AY=AYY+AYYY
      AZ=AZZ+AZZZ

      RETURN
      END
+DECK,btosca.
*CMZ :  2.41/10 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.16/04 19/06/2000  14.36.05  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  17.24.47  by  Michael Scheer
*CMZ :  2.14/02 19/04/2000  17.02.45  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  11.45.40  by  Michael Scheer
*CMZ : 00.02/03 21/01/97  14.52.55  by  Michael Scheer
*CMZ : 00.02/01 17/12/96  12.01.36  by  Michael Scheer
*-- Author :    Michael Scheer   16/12/96

      SUBROUTINE BTOSCA(XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT)
+seq,gplhint.

C *** ATTENTION: DEFINITION OF COEFFICIENTS DIFFERENT FROM R. WALKER'S
C *** ATTENTION: HALBACH ANSATZ CAN NOT BE FITTED SINCE FIELD MUST BE
C         BY ~ SIN(K*Z)

C     MAGNETIC FIELD ACCORDING TO POLYNOMIAL FIT
C     TRANSVERSALLY AND HARMONICS IN LONGITUDINALLY
C
C     INPUT/OUTPUT COORDINATE SYSTEM: X LONG., Y VERTICAL
C     INTERNAL COORDINATE SYSTEM: Z LONG., Y VERTICAL
C
C     UNIT: METER AND TESLA
C

      IMPLICIT NONE

+SEQ,CONTRL.

      INTEGER ICAL,LUNIN

      DOUBLE PRECISION PI
      DOUBLE PRECISION XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT
      DOUBLE PRECISION X,Y,Z,BXX,BYY,BZZ
      DOUBLE PRECISION X2,X3,X4,X5,X6,Y2,Y3,Y4,Y5,Y6
      DOUBLE PRECISION ZL,ZK,ZK2,ZK22,ZK23,SIN3ZKZ,SINZKZ,COSZKZ,COS3ZKZ

      DOUBLE PRECISION ANS1,ANS2
     &,bv01
     &,b2v1
     &,c3v1
     &,d4v1
     &,bv03
     &,b2v3
     &,c3v3
     &,d4v3
     &,bH01
     &,b2H1
     &,c3H1
     &,d4H1
     &,bH03
     &,b2H3
     &,c3H3
     &,d4H3

+SELF,IF=-NOCMPLX.
      COMPLEX*16 CZKZ,CZKZ3
+SELF,IF=NOCMPLX.
C     DOUBLE PRECISION CZKZR,CZKZ3R
C     DOUBLE PRECISION CZKZI,CZKZ3I
+SELF.

      CHARACTER(64) COMMENT,FILEIN

      DATA ICAL/0/

      DATA LUNIN/10/
      DATA FILEIN/'TOSCA.FIT'/
      DATA PI/3.141592653589793D0/

C--- INITIALIZATION

      IF (ICAL.EQ.0) THEN

         OPEN(UNIT=LUNIN,FILE=FILEIN,STATUS='OLD')

            READ(LUNIN,'(A64)')COMMENT

          READ(LUNIN,*)ZL

               READ(LUNIN,*)bH01
               READ(LUNIN,*)b2H1
               READ(LUNIN,*)c3H1
               READ(LUNIN,*)d4H1
               READ(LUNIN,*)bH03
               READ(LUNIN,*)b2H3
               READ(LUNIN,*)c3H3
               READ(LUNIN,*)d4H3

               READ(LUNIN,*)bv01
               READ(LUNIN,*)b2v1
               READ(LUNIN,*)c3v1
               READ(LUNIN,*)d4v1
               READ(LUNIN,*)bv03
               READ(LUNIN,*)b2v3
               READ(LUNIN,*)c3v3
               READ(LUNIN,*)d4v3

            WRITE(LUNGFO,*)'     SUBROUTINE BTOSCA:'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     COEFFICENT FILE:'
            WRITE(LUNGFO,'(''      '',A64)')FILEIN
            WRITE(LUNGFO,*)'     COMMENT:'
            WRITE(LUNGFO,'(''      '',A64)')COMMENT
            WRITE(LUNGFO,*)

            WRITE(LUNGFO,*)'     Z-Lambda:',ZL
            WRITE(LUNGFO,*)

            WRITE(LUNGFO,*)'     COEFFICIENTS:'

              WRITE(LUNGFO,*)bH01
              WRITE(LUNGFO,*)b2H1
              WRITE(LUNGFO,*)c3H1
              WRITE(LUNGFO,*)d4H1
              WRITE(LUNGFO,*)bH03
              WRITE(LUNGFO,*)b2H3
              WRITE(LUNGFO,*)c3H3
              WRITE(LUNGFO,*)d4H3

              WRITE(LUNGFO,*)bv01
              WRITE(LUNGFO,*)b2v1
              WRITE(LUNGFO,*)c3v1
              WRITE(LUNGFO,*)d4v1
              WRITE(LUNGFO,*)bv03
              WRITE(LUNGFO,*)b2v3
              WRITE(LUNGFO,*)c3v3
              WRITE(LUNGFO,*)d4v3

         CLOSE(LUNIN)

         ZK=2.D0*PI/ZL
         ZK2=ZK*ZK
         ZK22=ZK2*ZK2
         ZK23=ZK2*ZK2*ZK2

         AXOUT=0.D0
         AYOUT=0.D0
         AZOUT=0.D0

         ICAL=1

      ENDIF !ICAL

C --- CHANGE COORDINATE SYSTEMS

      X=-ZIN
      Y=YIN
      Z=XIN

      X2=X*X
      X3=X2*X
      X4=X3*X
      X5=X4*X
      X6=X5*X

      Y2=Y*Y
      Y3=Y2*Y
      Y4=Y3*Y
      Y5=Y4*Y
      Y6=Y5*Y

C--- MAGNETIC FIELD

+SELF,IF=-NOCMPLX.

      CZKZ=CDEXP(DCMPLX(0.D0,ZK*Z))
      CZKZ3=CZKZ*CZKZ*CZKZ

      SINZKZ =DIMAG( CZKZ)
      SIN3ZKZ=DIMAG(CZKZ3)

      COSZKZ =DREAL( CZKZ)
      COS3ZKZ=DREAL(CZKZ3)

+SELF,IF=NOCMPLX.

        WRITE(6,*)'CHECK +SELF,NOCMPLX'

      SINZKZ =SIN(ZK*Z)
      SIN3ZKZ =SIN(3.D0*ZK*Z)

      COSZKZ =COS(ZK*Z)
      COS3ZKZ=COS(3.D0*ZK*Z)

+SELF.

C------------------ s TRIESTE_TOSCA_... IN RED:REDUCE.CMZ
C     include 'red:trieste_tosca_bfeld.for'
C     ERZEUGEN MIT TRIESTE_TOSCA_RED AUS REDUCE.CMZ
C       BEARBEITEN MIT TRIESTE_TOSCA_EDI AUS REDUCE.CMZ
C
      ans2=0.00138888888889*(648.0*(x6*zk2+1.11111111111*y4)+
     . 3240.0*(y2*zk2-1.33333333333)*x2*y2-6480.0*(y2*zk2-
     . 0.111111111111)*x4)*c3h3*cos3zkz-0.00138888888889*(6.0*(x
     . 6*zk22-120.0*y2)-30.0*(y2*zk2-4.0)*x4*zk2-360.0*(y2*
     . zk2-2.0)*x2)*b2h1*coszkz-0.00138888888889*(486.0*(x6*zk2
     . 2-1.48148148148*y2)-2430.0*(y2*zk2-0.444444444444)*x4*
     . zk2-3240.0*(y2*zk2-0.222222222222)*x2)*b2h3*cos3zkz
      ans1=(0.0166666666667*(b2v1*sinzkz*y4*zk22+20.0*b2v1*
     . sinzkz*y2*zk2+120.0*b2v1*sinzkz+81.0*b2v3*sin3zkz*y4*
     . zk22+180.0*b2v3*sin3zkz*y2*zk2+120.0*b2v3*sin3zkz)+6.0*(
     . d4v1*sinzkz+d4v3*sin3zkz)*(x2-0.333333333333*y2)*(x2-
     . 3.0*y2))*x*y-(d4h1*coszkz+d4h3*cos3zkz)*(x2+4.0*x*y+y2
     . )*(x2-4.0*x*y+y2)*(x+y)*(x-y)+0.00138888888889*(x6*zk2
     . 3+30.0*x4*zk22+360.0*x2*zk2+720.0)*bh01*coszkz+1.0125*(
     . x6*zk23+3.33333333333*x4*zk22+4.44444444444*x2*zk2+
     . 0.987654320988)*bh03*cos3zkz-0.00138888888889*(288.0*(y2*
     . zk2+10.0)*y2-480.0*(y2*zk2+6.0)*x2)*c3v1*sinzkz*x*y-
     . 0.00138888888889*(2592.0*(y2*zk2+1.11111111111)*y2-4320.0*
     . (y2*zk2+0.666666666667)*x2)*c3v3*sin3zkz*x*y+
     . 0.00138888888889*(72.0*(x6*zk2+10.0*y4)+360.0*(y2*zk2-
     . 12.0)*x2*y2-720.0*(y2*zk2-1.0)*x4)*c3h1*coszkz+ans2
      bxx=-ans1
      ans2=-0.00138888888889*(486.0*(y4*zk22+2.22222222222*y2*
     . zk2+1.48148148148)*y2-2430.0*(y4*zk22+1.33333333333*y2
     . *zk2+0.296296296296)*x2)*b2v3*sin3zkz+0.00138888888889*(
     . 72.0*(y2*zk2+10.0)*y4+360.0*(y2*zk2+2.0)*x4-720.0*(y
     . 2*zk2+6.0)*x2*y2)*c3v1*sinzkz+0.00138888888889*(648.0*(y
     . 2*zk2+1.11111111111)*y4+3240.0*(y2*zk2+0.222222222222)*x
     . 4-6480.0*(y2*zk2+0.666666666667)*x2*y2)*c3v3*sin3zkz
      ans1=0.00138888888889*(bv01*sinzkz*y6*zk23+30.0*bv01*
     . sinzkz*y4*zk22+360.0*bv01*sinzkz*y2*zk2+720.0*bv01*
     . sinzkz+729.0*bv03*sin3zkz*y6*zk23+2430.0*bv03*sin3zkz*y
     . 4*zk22+3240.0*bv03*sin3zkz*y2*zk2+720.0*bv03*sin3zkz)+
     . 6.0*(d4h1*coszkz+d4h3*cos3zkz)*(x2-0.333333333333*y2)*(x
     . 2-3.0*y2)*x*y+(d4v1*sinzkz+d4v3*sin3zkz)*(x2+4.0*x*y+y
     . 2)*(x2-4.0*x*y+y2)*(x+y)*(x-y)-0.4*(x4*zk2-
     . 1.66666666667*x2*y2*zk2+10.0*x2-10.0*y2)*c3h1*coszkz*
     . x*y-3.6*(x4*zk2-1.66666666667*x2*y2*zk2+1.11111111111*x
     . 2-1.11111111111*y2)*c3h3*cos3zkz*x*y+0.0166666666667*(x
     . 4*zk22+20.0*x2*zk2+120.0)*b2h1*coszkz*x*y+1.35*(x4*zk2
     . 2+2.22222222222*x2*zk2+1.48148148148)*b2h3*cos3zkz*x*y-
     . 0.00138888888889*(6.0*(y4*zk22+20.0*y2*zk2+120.0)*y2-
     . 30.0*(y4*zk22+12.0*y2*zk2+24.0)*x2)*b2v1*sinzkz+ans2
      byy=-ans1
      ans2=((0.2*(y2*zk2+10.0)*y2-0.166666666667*(y2*zk2+6.0)*x
     . 2)*x2-0.0142857142857*(y2*zk2+14.0)*y4)*c3v1*coszkz*y
     . +((5.4*(y2*zk2+1.11111111111)*y2-4.5*(y2*zk2+
     . 0.666666666667)*x2)*x2-0.385714285714*(y2*zk2+
     . 1.55555555556)*y4)*c3v3*cos3zkz*y+(0.385714285714*(x6*zk2
     . +7.77777777778*y4)+4.5*(y2*zk2-1.33333333333)*x2*y2-
     . 5.4*(y2*zk2-0.111111111111)*x4)*c3h3*sin3zkz*x+(
     . 0.0142857142857*x6*zk2+y4+0.166666666667*(y2*zk2-12.0)*x
     . 2*y2-0.2*(y2*zk2-1.0)*x4)*c3h1*sinzkz*x-(
     . 0.00119047619048*(x6*zk22-840.0*y2)-0.00833333333333*(y
     . 2*zk2-4.0)*x4*zk2-0.166666666667*(y2*zk2-2.0)*x2)*b2h1
     . *sinzkz*x-(0.289285714286*(x6*zk22-10.3703703704*y2)-
     . 2.025*(y2*zk2-0.444444444444)*x4*zk2-4.5*(y2*zk2-
     . 0.222222222222)*x2)*b2h3*sin3zkz*x
      ans1=0.000198412698413*(bh01*sinzkz*x6*zk23+42.0*bh01*
     . sinzkz*x4*zk22+840.0*bh01*sinzkz*x2*zk2+5040.0*bh01*
     . sinzkz+2187.0*bh03*sin3zkz*x6*zk23+10206.0*bh03*sin3zkz
     . *x4*zk22+22680.0*bh03*sin3zkz*x2*zk2+15120.0*bh03*
     . sin3zkz)*x-(d4v1*coszkz+3.0*d4v3*cos3zkz)*(x6-5.0*x4*y
     . 2+3.0*x2*y4-0.142857142857*y6)*y-0.142857142857*(d4h1*
     . sinzkz+3.0*d4h3*sin3zkz)*(x6-21.0*x4*y2+35.0*x2*y4
     . -7.0*y6)*x-0.000198412698413*(bv01*coszkz*y6*zk23+42.0*
     . bv01*coszkz*y4*zk22+840.0*bv01*coszkz*y2*zk2+5040.0*
     . bv01*coszkz+2187.0*bv03*cos3zkz*y6*zk23+10206.0*bv03*
     . cos3zkz*y4*zk22+22680.0*bv03*cos3zkz*y2*zk2+15120.0*
     . bv03*cos3zkz)*y+(0.00119047619048*(y4*zk22+28.0*y2*zk2+
     . 280.0)*y2-0.00833333333333*(y4*zk22+20.0*y2*zk2+120.0)
     . *x2)*b2v1*coszkz*y+(0.289285714286*(y4*zk22+
     . 3.11111111111*y2*zk2+3.45679012346)*y2-2.025*(y4*zk22+
     . 2.22222222222*y2*zk2+1.48148148148)*x2)*b2v3*cos3zkz*y+
     . ans2
      bzz=ans1*zk
C
C---------------------------------------------

C --- CHANGE COORDINATE SYSTEMS

      BXOUT=BZZ
      BYOUT=BYY
      BZOUT=-BXX

      RETURN
      END
+DECK,BUCROSS.
*CMZ :  3.00/01 26/03/2013  19.45.55  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.70/06 04/01/2013  13.24.05  by  Michael Scheer
*CMZ :  2.67/02 03/05/2012  09.35.17  by  Michael Scheer
*CMZ :  2.20/09 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.24.35  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  14.43.01  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  15.31.37  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.48.51  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.36  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BUCROSS(XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,
     &                               AXOUT,AYOUT,AZOUT)
+seq,gplhint.


C--- MAGNETIC FIELD OF A CROSSED UNDULATOR. FIRST UNDULATOR IS HORIZONTAL,
C    MODULATOR IS HORIZONTAL, SECOND UNDULATOR IS VERTICAL
C    MODULATOR CENTER IS DEVICE CENTER

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,CMPARA.
+SEQ,HALBASY.
+SEQ,UCROSS.
+SEQ,PHYCON.

      INTEGER ICAL,I

      DOUBLE PRECISION X,Y,Z,BY,BZ,BXOUT,BYOUT,BZOUT,AY,AZ,AXOUT,AYOUT,AZOUT
      DOUBLE PRECISION XIN,YIN,ZIN,xcen

      DOUBLE PRECISION WLEN1,EHARM1(3),PARK(3)
      double precision b0halbasyo,xkhalbasyo,zlhalbasyo,zkhalbasyo,fasymo,
     &  ahwpolo

      DATA ICAL/0/

      b0halbasyo=b0halbasy
      xkhalbasyo=xkhalbasy
      zlhalbasyo=zlhalbasy
      zkhalbasyo=zkhalbasy
      fasymo=fasym
      ahwpolo=ahwpol
      xcen=xcenhal
      xcenhal=0.0d0

      IF (IUCRSAX.NE.0) THEN
          CALL BUCROSS_AX(XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,
     &      AXOUT,AYOUT,AZOUT)
          goto 9999
      ENDIF

C--- FIRST CALL

      IF (ICAL.EQ.0) THEN

        DO I=1,3
          ZKUHAL(I)=2.*PI1/ZLUHAL(I)
          PARK(I)=
     &      ECHARGE1*DABS(B0UCROSS(I))*ZLUHAL(I)/(2.*PI1*EMASSKG1*CLIGHT1)
          WLEN1=(1+PARK(I)**2/2.)/2./DMYGAMMA**2*ZLUHAL(I)*1.D9
          IF (WLEN1.NE.0.0) EHARM1(I)=WTOE1/WLEN1
          ucharm1=eharm1
        ENDDO   !I


      IF (UASYM(2).NE.2.D0) THEN
          ULIMI(2)=-ZLUHAL(2)/2.*(DFLOAT(NMUPOL(2))+UASYM(2))/2.
      ELSE
          ULIMI(2)=-ZLUHAL(2)*(DFLOAT(NMUPOL(2)-1)/2.D0+1.D0)/2.
      ENDIF
          ULIMI(3)=-ULIMI(2)

      IF (UASYM(1).NE.2.D0) THEN
          ULIMI(1)=ULIMI(2)-ZLUHAL(1)/2.*(DFLOAT(NMUPOL(1))+UASYM(1))
      ELSE
          ULIMI(1)=ULIMI(2)-ZLUHAL(1)*(DFLOAT(NMUPOL(1)-1)/2.D0+1.D0)
      ENDIF

      IF (UASYM(3).NE.2.D0) THEN
          ULIMI(4)=ULIMI(3)+ZLUHAL(3)/2.*(DFLOAT(NMUPOL(3))+UASYM(3))
      ELSE
          ULIMI(4)=ULIMI(3)+ZLUHAL(3)*(DFLOAT(NMUPOL(3)-1)/2.D0+1.D0)
      ENDIF


          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     SR BUCROSS: Parameter of crossed undulator:'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Peak field B0:    ',(SNGL(B0UCROSS(I)),I=1,3)
          WRITE(LUNGFO,*)'     Number of main poles:',(NMUPOL(I),I=1,3)
          WRITE(LUNGFO,*)'     Period lengths:   ',(SNGL(ZLUHAL(I)),I=1,3)
          WRITE(LUNGFO,*)'     Limits of modules:'
          WRITE(LUNGFO,*)'     ',(SNGL(ULIMI(I)),I=1,4)
          WRITE(LUNGFO,*)'     Deflection parameter K:',(SNGL(PARK(I)),I=1,3)
          WRITE(LUNGFO,*)'     First harmonical [eV]: ',(SNGL(EHARM1(I)),I=1,3)
          WRITE(LUNGFO,*)

          ICAL=1

      ENDIF

      IF (XIN.LT.ULIMI(1).OR.XIN.GT.ULIMI(4))THEN

          BXOUT=0.
          BYOUT=0.
          BZOUT=0.
          AXOUT=0.
          AYOUT=0.
          AZOUT=0.

      ELSE IF(XIN.LT.ULIMI(2)) THEN

C HORIZONTAL

      B0HALBASY=B0UCROSS(1)
      XKHALBASY=0.
      ZLHALBASY=ZLUHAL(1)
      ZKHALBASY=ZKUHAL(1)
      YKHALBASY=ZKHALBASY
      FASYM=UASYM(1)
      AHWPOL=DFLOAT(NMUPOL(1))

      X=XIN-ULIMI(1)-(ULIMI(2)-ULIMI(1))/2.
      CALL BHALBASY(X,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT)

      ELSE IF(XIN.LT.ULIMI(3)) THEN

C MODULATOR

      B0HALBASY=B0UCROSS(2)
      XKHALBASY=0.
      ZLHALBASY=ZLUHAL(2)
      ZKHALBASY=ZKUHAL(2)
      YKHALBASY=ZKHALBASY
      FASYM=UASYM(2)
      AHWPOL=DFLOAT(NMUPOL(2))

      X=XIN
      CALL BHALBASY(X,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT)

      ELSE IF(XIN.LT.ULIMI(4)) THEN

C VERTICAL


      B0HALBASY=B0UCROSS(3)
      XKHALBASY=0.
      ZLHALBASY=ZLUHAL(3)
      ZKHALBASY=ZKUHAL(3)
      YKHALBASY=ZKHALBASY
      FASYM=UASYM(3)
      AHWPOL=DFLOAT(NMUPOL(3))

      X=XIN-ULIMI(3)-(ULIMI(4)-ULIMI(3))/2.
      Z=YIN
      Y=ZIN

      CALL BHALBASY(X,Y,Z,BXOUT,BY,BZ,AXOUT,AY,AZ)

      BZOUT= BY
      BYOUT= BZ
      AZOUT= AY
      AYOUT= AZ

      ENDIF

9999  xcenhal=xcen
      b0halbasy=b0halbasyo
      xkhalbasy=xkhalbasyo
      zlhalbasy=zlhalbasyo
      zkhalbasy=zkhalbasyo
      fasym=fasymo
      ahwpol=ahwpolo

      RETURN
      END
+DECK,BUCROSS_AX.
*CMZ :  3.00/01 26/03/2013  19.46.50  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.70/06 04/01/2013  13.25.02  by  Michael Scheer
*CMZ :  2.67/02 19/04/2012  09.50.56  by  Michael Scheer
*CMZ :  2.20/09 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  2.13/08 02/03/2000  11.25.34  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.24.35  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  14.43.01  by  Michael Scheer
*CMZ : 00.01/06 15/02/95  20.20.16  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  15.32.24  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.48.56  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.39  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BUCROSS_AX(XINOLD,YIN,ZIN,BXOUT,BYOUT,BZOUT,
     &                               AXOUT,AYOUT,AZOUT)
+seq,gplhint.


C--- MAGNETIC FIELD OF A CROSSED UNDULATOR. FIRST UNDULATOR IS HORIZONTAL,
C    MODULATOR IS HORIZONTAL, SECOND UNDULATOR IS VERTICAL
C    MODULATOR CENTER IS DEVICE CENTER

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,CMPARA.
+SEQ,HALBASY.
+SEQ,UCROSS.
+SEQ,PHYCON.

      INTEGER ICAL,I

      DOUBLE PRECISION X,Y,Z,BY,BZ,BXOUT,BYOUT,BZOUT,AY,AZ,AXOUT,AYOUT,AZOUT
      DOUBLE PRECISION XIN,YIN,ZIN

      DOUBLE PRECISION WLEN1,EHARM1(3),PARK(3)
      DOUBLE PRECISION XCEN,XINOLD

      double precision b0halbasyo,xkhalbasyo,zlhalbasyo,zkhalbasyo,fasymo,
     &  ahwpolo,xcenhalo

      DATA ICAL/0/

      b0halbasyo=b0halbasy
      xkhalbasyo=xkhalbasy
      zlhalbasyo=zlhalbasy
      zkhalbasyo=zkhalbasy
      fasymo=fasym
      ahwpolo=ahwpol
      xcenhalo=xcenhal

      XIN=XINOLD

C--- FIRST CALL

      IF (ICAL.EQ.0) THEN


          DO I=1,3

            IF (UASYM(I).EQ.2.D0) UASYM(I)=2.00000001D0

               ZKUHAL(I)=2.*PI1/ZLUHAL(I)

              IF (XLUHAL(I).NE.0.D0) THEN
                XKUHAL(I)=2.*PI1/XLUHAL(I)
              ELSE
                XKUHAL(I)=0.0D0
              ENDIF

            YKUHAL(I)=SQRT(XKUHAL(I)*XKUHAL(I)+ZKUHAL(I)*ZKUHAL(I))
            YLUHAL(I)=2.*PI1/YKUHAL(I)

              PARK(I)=
     &          ECHARGE1*DABS(B0UCROSS(I))*ZLUHAL(I)
     &          /(2.*PI1*EMASSKG1*CLIGHT1)
              WLEN1=(1+PARK(I)**2/2.)/2./DMYGAMMA**2*ZLUHAL(I)*1.D9
              IF (WLEN1.NE.0.0) EHARM1(I)=WTOE1/WLEN1
              ucharm1=eharm1

          ENDDO   !I

          ULIMI(2)=-ZLUHAL(2)/2.*(DFLOAT(NMUPOL(2))+UASYM(2))/2.
          ULIMI(3)=-ULIMI(2)
          ULIMI(1)=ULIMI(2)-ZLUHAL(1)/2.*(DFLOAT(NMUPOL(1))+UASYM(1))
          ULIMI(4)=ULIMI(3)+ZLUHAL(3)/2.*(DFLOAT(NMUPOL(3))+UASYM(3))

          IF (IUCRSAX.EQ.2) THEN
             XCEN=(ULIMI(2)+ULIMI(1))/2.D0
          ELSE IF (IUCRSAX.EQ.3) THEN
             XCEN=(ULIMI(3)+ULIMI(4))/2.D0
          ELSE
             XCEN=0.0D0
          ENDIF

          ULIMI(1)=ULIMI(1)-XCEN
          ULIMI(2)=ULIMI(2)-XCEN
          ULIMI(3)=ULIMI(3)-XCEN
          ULIMI(4)=ULIMI(4)-XCEN

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     SR BUCROSS_AX: Parameter of crossed undulator:'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Peak field B0:    ',(SNGL(B0UCROSS(I)),I=1,3)
          WRITE(LUNGFO,*)'     Number of main poles:',(NMUPOL(I),I=1,3)
          WRITE(LUNGFO,*)'     asymmetrie of end poles:',(UASYM(I),I=1,3)
          WRITE(LUNGFO,*)'     Period lengths:   ',(SNGL(ZLUHAL(I)),I=1,3)
          WRITE(LUNGFO,*)'     2*PI/Kx:          ',(SNGL(XLUHAL(I)),I=1,3)
          WRITE(LUNGFO,*)'     Limits of modules:'
          WRITE(LUNGFO,*)'     ',(SNGL(ULIMI(I)),I=1,4)
          WRITE(LUNGFO,*)'     Deflection parameter K:',(SNGL(PARK(I)),I=1,3)
          WRITE(LUNGFO,*)
     &      '     First harmonical [eV]: ',(SNGL(EHARM1(I)),I=1,3)
          WRITE(LUNGFO,*)

          ICAL=1

      ENDIF

      IF (XIN.LT.ULIMI(1).OR.XIN.GT.ULIMI(4))THEN

          BXOUT=0.
          BYOUT=0.
          BZOUT=0.
          AXOUT=0.
          AYOUT=0.
          AZOUT=0.

      ELSE IF(XIN.LT.ULIMI(2)) THEN

C HORIZONTAL

      B0HALBASY=B0UCROSS(1)
      XKHALBASY=XKUHAL(1)
      XLHALBASY=XLUHAL(1)
      ZLHALBASY=ZLUHAL(1)
      ZKHALBASY=ZKUHAL(1)
      YKHALBASY=YKUHAL(1)
      YLHALBASY=YLUHAL(1)
      FASYM=UASYM(1)
      AHWPOL=DFLOAT(NMUPOL(1))

      X=XIN-ULIMI(1)-(ULIMI(2)-ULIMI(1))/2.
      CALL BHALBASY(X,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT)

      IF     (XIN.LT.ULIMI(1)+ZLUHAL(1)*FASYM/4.) THEN
          BXOUT=BXOUT*0.5
          BYOUT=BYOUT*0.5
          BZOUT=BZOUT*0.5
      ELSE IF (XIN.LT.ULIMI(1)+ZLUHAL(1)*(FASYM/4.+1./2.)) THEN
          BXOUT=BXOUT*0.75
          BYOUT=BYOUT*0.75
          BZOUT=BZOUT*0.75
      ELSE IF (XIN.GT.ULIMI(2)-ZLUHAL(1)*FASYM/4.) THEN
          BXOUT=BXOUT*0.5
          BYOUT=BYOUT*0.5
          BZOUT=BZOUT*0.5
      ELSE IF (XIN.GT.ULIMI(2)-ZLUHAL(1)*(FASYM/4.+1./2.)) THEN
          BXOUT=BXOUT*0.75
          BYOUT=BYOUT*0.75
          BZOUT=BZOUT*0.75
      ENDIF

      ELSE IF(XIN.LT.ULIMI(3)) THEN

C MODULATOR

      B0HALBASY=B0UCROSS(2)
      XKHALBASY=XKUHAL(2)
      XLHALBASY=XLUHAL(2)
      ZLHALBASY=ZLUHAL(2)
      ZKHALBASY=ZKUHAL(2)
      YKHALBASY=YKUHAL(2)
      YLHALBASY=YLUHAL(2)
      FASYM=UASYM(2)
      AHWPOL=DFLOAT(NMUPOL(2))

      X=XIN+XCEN
      CALL BHALBASY(X,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT)

      ELSE IF(XIN.LT.ULIMI(4)) THEN

C VERTICAL


      B0HALBASY=B0UCROSS(3)
      XKHALBASY=XKUHAL(3)
      XLHALBASY=XLUHAL(3)
      ZLHALBASY=ZLUHAL(3)
      ZKHALBASY=ZKUHAL(3)
      YKHALBASY=YKUHAL(3)
      YLHALBASY=YLUHAL(3)
      FASYM=UASYM(3)
      AHWPOL=DFLOAT(NMUPOL(3))

      X=XIN-ULIMI(3)-(ULIMI(4)-ULIMI(3))/2.
      Z=YIN
      Y=ZIN

      CALL BHALBASY(X,Y,Z,BXOUT,BY,BZ,AXOUT,AY,AZ)

      BZOUT= BY
      BYOUT= BZ
      AZOUT= AY
      AYOUT= AZ

      IF     (XIN.LT.ULIMI(3)+ZLUHAL(3)*FASYM/4.) THEN
          BXOUT=BXOUT*0.5
          BYOUT=BYOUT*0.5
          BZOUT=BZOUT*0.5
      ELSE IF (XIN.LT.ULIMI(3)+ZLUHAL(3)*(FASYM/4.+1./2.)) THEN
          BXOUT=BXOUT*0.75
          BYOUT=BYOUT*0.75
          BZOUT=BZOUT*0.75
      ELSE IF (XIN.GT.ULIMI(4)-ZLUHAL(3)*FASYM/4.) THEN
          BXOUT=BXOUT*0.5
          BYOUT=BYOUT*0.5
          BZOUT=BZOUT*0.5
      ELSE IF (XIN.GT.ULIMI(4)-ZLUHAL(3)*(FASYM/4.+1./2.)) THEN
          BXOUT=BXOUT*0.75
          BYOUT=BYOUT*0.75
          BZOUT=BZOUT*0.75
      ENDIF

      ELSE IF(XIN.LT.ULIMI(3)) THEN

      ENDIF

      b0halbasy=b0halbasyo
      xkhalbasy=xkhalbasyo
      zlhalbasy=zlhalbasyo
      zkhalbasy=zkhalbasyo
      fasym=fasymo
      ahwpol=ahwpolo
      xcenhal=xcenhalo

      RETURN
      END
+DECK,B_POLY_F.
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ : 00.01/03 15/11/94  19.17.57  by  Michael Scheer
*CMZ :  0.00/03 15/11/94  18.15.46  by  Michael Scheer
*-- Author :Johannes Bahrdt
c*******************************************************************
      Subroutine B_FIELD(X,Y,Z,Bx,By,Bz,Qa0,Qa,XKX,YKY,width,
     &  NFIRSTX,NORDX,NSTEPX,NFIRSTY,NORDY,NSTEPY,NORDP)
c*******************************************************************
+seq,gplhint.

      IMPLICIT NONE

      INTEGER NFIRSTX,NORDX,NSTEPX,NFIRSTY,NORDY,NSTEPY,NORDP
      INTEGER IORDX,IORDY


      DOUBLE PRECISION X,Y,Z,Bx,By,Bz,Qa0(NORDP),Qa(NORDP,NORDP)
      DOUBLE PRECISION XKX,YKY,width

      DOUBLE PRECISION c0,s0,xn,xm,xknm

      Bx=0.
      By=0.
      Bz=0.

      DO IORDY=NFIRSTY,NORDY,NSTEPY    ! step size = 2
         xn=iordy
           c0=dcos(xn*yky*z)
           s0=-xn*yky*dsin(xn*yky*z)
         bx=bx
         by=by+c0*qa0(iordy)*xn*yky*dcosh(xn*yky*y)
           bz=bz+s0*qa0(iordy)*dsinh(xn*yky*y)
      DO IORDX=NFIRSTX,NORDX,NSTEPX    ! step size = 1
         xm=iordx
         xknm=dsqrt(xn**2*yky**2+xm**2*xkx**2)
         bx=bx+c0*dsin(xm*xkx*y)*xknm*dsinh(xknm*x)*
     &                     (qa(iordy,iordx)/dcosh(xknm*width))
         by=by+c0*xm*xkx*dcos(xm*xkx*y)*dcosh(xknm*x)*
     &                     (qa(iordy,iordx)/dcosh(xknm*width))
         bz=bz+s0*dsin(xm*xkx*y)*dcosh(xknm*x)*
     &                     (qa(iordy,iordx)/dcosh(xknm*width))
      ENDDO
      ENDDO

      RETURN
      END
+DECK,CHECKOB.
*CMZ :  4.01/04 20/11/2023  22.07.55  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.10  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.17/00 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  14.22.44  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  2.12/03 22/07/99  10.49.26  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  15.40.33  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.49.00  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.51  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE CHECKOB
+seq,gplhint.

+SELF,IF=F90.
+SEQ,OBSERVF90U.
+SELF.

C--- CHECKS CONSISTENCE OF OBSERVATION POINTS AND COLLIMATOR

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEq,observf90.
+SEQ,COLLI.

      INTEGER IOBSV

      DOUBLE PRECISION XOB,YOB,ZOB
      DOUBLE PRECISION UP1,DOWN1,RIGHT1,LEFT1,UP2,DOWN2,RIGHT2,LEFT2
      DOUBLE PRECISION YSLOPEU,YSLOPED,ZSLOPEL,ZSLOPER,DLEN,DIST

      UP1=CY1+HIG1/2.D0
      DOWN1=CY1-HIG1/2.D0
      RIGHT1=CZ1+WID1/2.D0
      LEFT1=CZ1-WID1/2.D0

      UP2=CY2+HIG2/2.D0
      DOWN2=CY2-HIG2/2.D0
      RIGHT2=CZ2+WID2/2.D0
      LEFT2=CZ2-WID2/2.D0

      DLEN=CX2-CX1

      IF (DLEN.EQ.0.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING SR CHECKOB ***'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'COLLIMATOR HAS ZERO LENGTH, OBSERVER POSITIONS ARE NOT CHECKED, BE CAREFUL !'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(6,*)'*** WARNING SR CHECKOB ***'
        WRITE(6,*)
        WRITE(6,*)'COLLIMATOR HAS ZERO LENGTH, OBSERVER POSITIONS ARE NOT CHECKED, BE CAREFUL !'
        WRITE(6,*)
        WRITE(6,*)
        RETURN
      ENDIF

      YSLOPEU=(UP2-DOWN1)/DLEN
      YSLOPED=(DOWN2-UP1)/DLEN
      ZSLOPEL=(LEFT2-RIGHT1)/DLEN
      ZSLOPER=(RIGHT2-LEFT1)/DLEN

      DO IOBSV=1,NOBSV

        if (rpinsph.ne.0.0d0) then
          XOB=OBSV(1,IOBSV)+1.0e-5
        else
          XOB=OBSV(1,IOBSV)
        endif
        YOB=OBSV(2,IOBSV)
        ZOB=OBSV(3,IOBSV)
        DIST=XOB-CX2

        IF(
     &      XOB.LT.CX2
     &      .OR.
     &      YOB.GT.UP2+YSLOPEU*DIST
     &      .OR.
     &      YOB.LT.DOWN2+YSLOPED*DIST
     &      .OR.
     &      ZOB.GT.RIGHT2+ZSLOPER*DIST
     &      .OR.
     &      ZOB.LT.LEFT2+ZSLOPEL*DIST
     &      ) THEN
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN SR CHECKOB ***'
          WRITE(6,*)
     &      'OBSERVATION POINTS AND COLLIMATOR INCONSISTENT'
          WRITE(6,*)'CHECK RESULTS CAREFULLY'
          WRITE(6,*)
          WRITE(6,*)'OBSERVATION POINT (X,Y,Z):'
          WRITE(6,*)XOB,YOB,ZOB
          WRITE(6,*)
          WRITE(6,*)'CHECK ALSO DEFINITION OF COLLIMATOR'
          WRITE(6,*)
     &      'IN NAMELIST COLLIN; MAYBE DEFAULTS NOT USEFUL'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN SR CHECKOB ***'
          WRITE(LUNGFO,*)
     &      'OBSERVATION POINTS AND COLLIMATOR INCONSISTENT'
          WRITE(LUNGFO,*)'CHECK RESULTS CAREFULLY'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'OBSERVATION POINT (X,Y,Z):'
          WRITE(LUNGFO,*)XOB,YOB,ZOB
          WRITE(LUNGFO,*)'(REMAINING POINTS NOT CHECKED)'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'CHECK ALSO DEFINITION OF COLLIMATOR'
          WRITE(LUNGFO,*)
     &      'IN NAMELIST COLLIN; MAYBE DEFAULTS NOT USEFUL'
          RETURN
        ENDIF
      ENDDO

      RETURN
      END
+DECK,CIRCPIN.
*CMZ :  3.08/01 04/04/2019  11.29.24  by  Michael Scheer
*CMZ :  3.07/00 14/03/2019  16.28.58  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.10  by  Michael Scheer
*CMZ :  2.69/00 24/10/2012  16.32.37  by  Michael Scheer
*CMZ :  2.57/03 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.57/00 22/11/2005  10.31.34  by  Michael Scheer
*CMZ :  2.34/00 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.33/09 10/05/2001  18.02.55  by  Michael Scheer
*CMZ :  2.16/08 24/10/2000  11.19.57  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  14.43.04  by  Michael Scheer
*CMZ : 00.02/04 25/02/97  17.37.15  by  Michael Scheer
*CMZ : 00.01/09 01/09/95  13.03.01  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  15.45.26  by  Michael Scheer
*CMZ : 00.00/06 29/04/94  21.43.32  by  Michael Scheer
*CMZ : 00.00/05 29/04/94  20.18.16  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.15  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE CIRCPIN(NZ,NY,MZ,MY,SPEC,SUM,SUMP,ISOUR,IFREQ,IWSOUR)
+seq,gplhint.

+SELF,IF=F90.
+SEQ,OBSERVF90U.
+SELF.

C---  SUBROUTINE TO INTEGRATE SPEC OVER CIRCULAR PINHOLE
C     NZ,NY ARE ARRAY DIMENSIONS
C       INTEGRATION IS DONE FOR MZ AND MY POINTS

      IMPLICIT NONE
+SEQ,CMPARA.
+SEQ,CONTRL.
+SEq,observf90.
+SEQ,FREQS.

      INTEGER NZ,NY,IY,IZ,MZ,MY,KLM,KLP,KHM,KHP,IIZ,IIY,ISOUR,IFREQ
      INTEGER IWSOUR,IWFREQ,IWSOUR1,IWSOUR2,IWSOUR3,IDUM

      DOUBLE PRECISION SUM,SUMP,DZ,FL,FH,SH,SL,A,B,DY
     &  ,SPEC(NDOBSVP)
     &  ,SZ(NDOBSVZP),SUMY(NDOBSVP),SUMYP(NDOBSVP)
     &  ,FZ(NDOBSVZP),OBSVZF(NDOBSVZP),ZH,ZL
     &  ,DSUM,DSUML,DSUMH

      IF (IF1DIM.NE.0) THEN
        CALL CIRCPIN1D(NY,MY,SPEC,SUM,SUMP)
        RETURN
      ENDIF

      IWSOUR=0

      IF (MZ.LT.2) THEN
        WRITE(6,*) '*** ERROR IN CIRCPIN: MZ TOO LOW ***'
        STOP
      ENDIF
      IF (MY.LT.2) THEN
        WRITE(6,*) '*** ERROR IN CIRCPIN: MY TOO LOW ***'
        STOP
      ENDIF

C--- LOOP OF VERTICAL DIRECTION

      IIY=0
      DO IY=(NY-MY)/2+1,(NY-MY)/2+MY

        IIY=IIY+1
        SUMY(IIY)=0.D0
        SUMYP(IIY)=0.D0

        IF (DABS(OBSVY(IY)-PINCEN(2)).LT.PINR-OBSVDY/4.D0) THEN

C--  SPLINE COEFFICENTS

          IIZ=0
          DO IZ=(NZ-MZ)/2+1,(NZ-MZ)/2+MZ
            IIZ=IIZ+1
            FZ(IIZ)=SPEC((IY-1)*NZ+IZ)
            OBSVZF(IIZ)=OBSVZ(IZ)
          ENDDO !IZ

          CALL FSPLINDX(OBSVDZ,FZ,IIZ,0.D0,0.D0,SZ)

C--  INTEGRATION LIMITS

          ZH=DSQRT(-(OBSVY(IY)-PINCEN(2))**2+PINR**2)
          ZL=PINCEN(3)-ZH
          ZH=PINCEN(3)+ZH

          CALL SPLINZY(IIZ,ZL,FL,OBSVZF,FZ,SZ,KLM)
          CALL SPLINZY(IIZ,ZH,FH,OBSVZF,FZ,SZ,KHM)

          KLP=KLM+1
          KHP=KHM+1

C--  CONTRIBUTION FORM PARTIAL INTERVALLS

          DZ=OBSVDZ
          DY=OBSVDY

          A=0.D0
          B=1.D0

          SH=
     &      -FZ(KLM)*A**2/2.*DZ+FZ(KLP)*B**2/2.*DZ
     &      +DZ**2/6.
     &      *((-DZ*A**4/4.+DZ*A**2/2.)*SZ(KLM)
     &      +(DZ*B**4/4.-DZ*B**2/2.)*SZ(KLP))

          A=(OBSVZF(KLP)-ZL)/OBSVDZ
          B=(ZL-OBSVZF(KLM))/OBSVDZ

          SL=
     &      -FZ(KLM)*A**2/2.*DZ+FZ(KLP)*B**2/2.*DZ
     &      +DZ**2/6.
     &      *((-DZ*A**4/4.+DZ*A**2/2.)*SZ(KLM)
     &      +(DZ*B**4/4.-DZ*B**2/2.)*SZ(KLP))

          DSUML=SH-SL

          IF(
     &        (IWSOUR1.NE.ISOUR.OR.IWFREQ.NE.IFREQ)
     &        .AND. ISOUR.GT.0 .AND.
     &        DSUML.LT.0.0) THEN
            IF ( DABS((SH-SL)/(SH+SL)) .GT. 5.D-15 ) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'*** WARNING IN CIRCPIN ***'
              WRITE(LUNGFO,*)
     &          'SPLINE INTEGRATION FAILED FOR LEFT EDGE OF PINHOLE, RESULTS NOT RELIABLE'
              WRITE(LUNGFO,*)'SOURCE POINT AND PHOTON ENERGY:'
     &          ,ISOUR,SNGL(FREQ(IFREQ))
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
              WRITE(6,*)
              WRITE(6,*)
              WRITE(6,*)'*** WARNING IN CIRCPIN ***'
              WRITE(6,*)
     &          'SPLINE INTEGRATION FAILED FOR LEFT EDGE OF PINHOLE, RESULTS NOT RELIABLE'
              WRITE(6,*)'SOURCE POINT AND PHOTON ENERGY:'
     &          ,ISOUR,SNGL(FREQ(IFREQ))
              WRITE(6,*)
              WRITE(6,*)
              IWSOUR1=ISOUR
              IWSOUR=1
              IWFREQ=IFREQ
              IW_CIRC=1
            ENDIF    !SH-SL
          ENDIF !IWSOUR1

          A=1.D0
          B=0.D0

          SL=
     &      -FZ(KHM)*A**2/2.*DZ+FZ(KHP)*B**2/2.*DZ
     &      +DZ**2/6.
     &      *((-DZ*A**4/4.+DZ*A**2/2.)*SZ(KHM)
     &      +(DZ*B**4/4.-DZ*B**2/2.)*SZ(KHP))

          A=(OBSVZF(KHP)-ZH)/OBSVDZ
          B=(ZH-OBSVZF(KHM))/OBSVDZ

          SH=
     &      -FZ(KHM)*A**2/2.*DZ+FZ(KHP)*B**2/2.*DZ
     &      +DZ**2/6.
     &      *((-DZ*A**4/4.+DZ*A**2/2.)*SZ(KHM)
     &      +(DZ*B**4/4.-DZ*B**2/2.)*SZ(KHP))


          DSUMH=SH-SL

          IF(
     &        (IWSOUR2.NE.ISOUR.OR.IWFREQ.NE.IFREQ)
     &        .AND. ISOUR.GT.0 .AND.
     &        DSUMH.LT.0.0) THEN
            IF ( DABS((SH-SL)/(SH+SL)) .GT. 5.D-15 ) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'*** WARNING IN CIRCPIN ***'
              WRITE(LUNGFO,*)
     &          'SPLINE INTEGRATION FAILED FOR RIGHT EDGE OF PINHOLE, RESULTS NOT RELIABLE'
              WRITE(LUNGFO,*)'SOURCE POINT AND PHOTON ENERGY:'
     &          ,ISOUR,SNGL(FREQ(IFREQ))
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
              WRITE(6,*)
              WRITE(6,*)
              WRITE(6,*)'*** WARNING IN CIRCPIN ***'
              WRITE(6,*)
     &          'SPLINE INTEGRATION FAILED FOR RIGHT EDGE OF PINHOLE, RESULTS NOT RELIABLE'
              WRITE(6,*)'SOURCE POINT AND PHOTON ENERGY:'
     &          ,ISOUR,SNGL(FREQ(IFREQ))
              WRITE(6,*)
              WRITE(6,*)
              IWSOUR2=ISOUR
              IWSOUR=1
              IWFREQ=IFREQ
              IW_CIRC=1
            ENDIF
          ENDIF !IWSOUR2

C---  NOW ALL FULL INTERVALLS

          DO IZ=KLP,KHM-1
            DSUM=
     &        OBSVDZ*0.5D0
     &        *(FZ(IZ)+FZ(IZ+1))
     &        -OBSVDZ**3/24.D0
     &        *(SZ(IZ)+SZ(IZ+1))

            IF(
     &          (IWSOUR3.NE.ISOUR.OR.IWFREQ.NE.IFREQ)
     &          .AND. ISOUR.GT.0 .AND.
     &          DSUM.LT.0.0) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'*** WARNING IN CIRCPIN ***'
              WRITE(LUNGFO,*)
     &          'SPLINE INTEGRATION FAILED INSIDE PINHOLE, RESULTS NOT RELIABLE'
              WRITE(LUNGFO,*)'SOURCE POINT AND PHOTON ENERGY:'
     &          ,ISOUR,SNGL(FREQ(IFREQ))
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
              WRITE(6,*)
              WRITE(6,*)
              WRITE(6,*)'*** WARNING IN CIRCPIN ***'
              WRITE(6,*)
     &          'SPLINE INTEGRATION FAILED INSIDE, RESULTS NOT RELIABLE'
              WRITE(6,*)'SOURCE POINT AND PHOTON ENERGY:'
     &          ,ISOUR,SNGL(FREQ(IFREQ))
              WRITE(6,*)
              WRITE(6,*)
              IWSOUR3=ISOUR
              IWSOUR=1
              IWFREQ=IFREQ
              IW_CIRC=1
              DO IDUM=1,IIY
                SUMYP(IIY)=SUMY(IIY)
              ENDDO
            ENDIF !IWSOUR3

            SUMY(IIY)=SUMY(IIY)+DSUM
            IF (IW_CIRC.NE.0) SUMYP(IIY)=SUMYP(IIY)+ABS(DSUM)

          ENDDO !IZ

          SUMY(IIY)=(SUMY(IIY)+DSUML+DSUMH)

          IF (ZH.GT.0.0D0) THEN
            SUMY(IIY)=SUMY(IIY)/(2.0D0*ZH)
          ELSE
            IF (SUMY(IIY).NE.0.0D0) THEN
              PRINT*,
     &          '*** WARNING IN PINCIRC: INTEGRATION WIDTH=0 BUT CONTRIBUTION NOT'
              PRINT*,'CONTRIBUTION:',SUMYP(IIY)
            ENDIF
          ENDIF

          IF (IW_CIRC.NE.0) THEN
            SUMYP(IIY)=SUMYP(IIY)+ABS(DSUML)+ABS(DSUMH)
            IF (ZH.GT.0.0D0) THEN
              SUMYP(IIY)=SUMYP(IIY)/(2.0D0*ZH)
            ELSE
              IF (SUMYP(IIY).NE.0.0D0) THEN
                PRINT*,
     &            '*** WARNING IN PINCIRC: INTEGRATION WIDTH=0 BUT CONTRIBUTION NOT'
                PRINT*,'CONTRIBUTION:',SUMYP(IIY)
              ENDIF
            ENDIF
          ENDIF

        ELSE !INSIDE PINHOLE

          IZ=NZ/2+1
          SUMY(IIY)=SPEC((IY-1)*NZ+IZ) ! FOR CIRCPIN1D

        ENDIF !INSIDE PINHOLE

      ENDDO !IY

C--- INTEGRATION OVER VERTICAL DIRECTION

      CALL CIRCPIN1D(NY,MY,SUMY,SUM,SUMP)

      IF (IW_CIRC.NE.0) THEN
        CALL CIRCPIN1D(NY,MY,SUMYP,SUMP,SUMP)
      ENDIF

      RETURN
      END
+DECK,CIRCPOW.
*CMZ :  3.00/00 11/03/2013  15.12.10  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.57/00 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.34/00 11/05/2001  15.55.02  by  Michael Scheer
*CMZ :  2.33/09 10/05/2001  18.02.55  by  Michael Scheer
*CMZ :  2.16/08 24/10/2000  11.19.57  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  14.43.04  by  Michael Scheer
*CMZ : 00.02/04 25/02/97  17.37.15  by  Michael Scheer
*CMZ : 00.01/09 01/09/95  13.03.01  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  15.45.26  by  Michael Scheer
*CMZ : 00.00/06 29/04/94  21.43.32  by  Michael Scheer
*CMZ : 00.00/05 29/04/94  20.18.16  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.15  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE CIRCPOW(ISOUR,NSOURCE)
+seq,gplhint.

+SELF,IF=F90.
+SEQ,OBSERVF90U.
+SEQ,SPECTF90U.
+SELF.

C---  SUBROUTINE TO INTEGRATE SPECPOW OVER CIRCULAR PINHOLE
C     NZ,NY ARE ARRAY DIMENSIONS
C       INTEGRATION IS DONE FOR MZ AND MY POINTS

      IMPLICIT NONE
+SEQ,CMPARA.
+SEQ,CONTRL.
+SEq,observf90.

      INTEGER NZ,NY,IY,IZ,MZ,MY,KLM,KLP,KHM,KHP,IIZ,IIY,ISOUR,IWCIRCO
      INTEGER IWSOUR,IWSOUR1,IWSOUR2,IWSOUR3,IWSOUR4,IDUM,NSOURCE,ICAL

      DOUBLE PRECISION SUM,SUMP,DZ,FL,FH,SH,SL,A,B,DY
     &  ,SPECK(NDOBSVP)
     &  ,SZ(NDOBSVZP),SY(NDOBSVYP),SUMY(NDOBSVYP),SUMYP(NDOBSVYP)
     &  ,FZ(NDOBSVZP),OBSVZF(NDOBSVZP),ZH,ZL
     &  ,DSUM,DSUML,DSUMH

      DATA ICAL/0/

      DO IDUM=1,NOBSV
        SPECK(IDUM)=SPECPOW(ISOUR+NSOURCE*(IDUM-1))
      ENDDO

      MZ=MOBSVZ
      NZ=NOBSVZ
      MY=MOBSVY
      NY=NOBSVY

      IF (IF1DIM.NE.0) THEN
        CALL CIRCPIN1D(NY,MY,SPECK,SUM,SUMP)
      SPECPOWVH(ISOUR)=SUM
        RETURN
      ENDIF

      IWSOUR=0
      IWCIRCO=IW_CIRC

      IF (MZ.LT.2) THEN
          WRITE(6,*) '*** ERROR IN CIRCPOW: MZ TOO LOW ***'
          STOP
      ENDIF
      IF (MY.LT.2) THEN
          WRITE(6,*) '*** ERROR IN CIRCPOW: MY TOO LOW ***'
          STOP
      ENDIF

C--- LOOP OF VERTICAL DIRECTION

      IIY=0
      DO IY=(NY-MY)/2+1,(NY-MY)/2+MY

      IIY=IIY+1
      SUMY(IIY)=0.D0

      IF (DABS(OBSVY(IY)-PINCEN(2)).LT.PINR-OBSVDY/4.D0) THEN

C--  SPLINE COEFFICENTS

      IIZ=0
      DO IZ=(NZ-MZ)/2+1,(NZ-MZ)+MZ
          IIZ=IIZ+1
          FZ(IIZ)=SPECK((IY-1)*NZ+IZ)
          OBSVZF(IIZ)=OBSVZ(IZ)
      ENDDO !IZ

      CALL FSPLINDX(OBSVDZ,FZ,IIZ,0.D0,0.D0,SZ)

C--  INTEGRATION LIMITS

      ZH=DSQRT(-(OBSVY(IY)-PINCEN(2))**2+PINR**2)
      ZL=PINCEN(3)-ZH
      ZH=PINCEN(3)+ZH

      CALL SPLINZY(IIZ,ZL,FL,OBSVZF,FZ,SZ,KLM)
      CALL SPLINZY(IIZ,ZH,FH,OBSVZF,FZ,SZ,KHM)

      KLP=KLM+1
      KHP=KHM+1

C--  CONTRIBUTION FORM PARTIAL INTERVALLS

      DZ=OBSVDZ
      DY=OBSVDY

      A=0.D0
      B=1.D0

      SH=
     &           -FZ(KLM)*A**2/2.*DZ+FZ(KLP)*B**2/2.*DZ
     &           +DZ**2/6.
     &           *((-DZ*A**4/4.+DZ*A**2/2.)*SZ(KLM)
     &           +(DZ*B**4/4.-DZ*B**2/2.)*SZ(KLP))

      A=(OBSVZF(KLP)-ZL)/OBSVDZ
      B=(ZL-OBSVZF(KLM))/OBSVDZ

      SL=
     &           -FZ(KLM)*A**2/2.*DZ+FZ(KLP)*B**2/2.*DZ
     &           +DZ**2/6.
     &           *((-DZ*A**4/4.+DZ*A**2/2.)*SZ(KLM)
     &           +(DZ*B**4/4.-DZ*B**2/2.)*SZ(KLP))

      DSUML=SH-SL

         IF(IWSOUR1.NE.ISOUR.AND.ISOUR.GT.0.AND.DSUML.LT.0.0) THEN
             IF ( DABS((SH-SL)/(SH+SL)) .GT. 5.D-15 ) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)'*** WARNING IN CIRCPOW ***'
             WRITE(LUNGFO,*)
     &'SPLINE INTEGRATION FAILED FOR LEFT EDGE OF PINHOLE, RESULTS NOT RELIABLE'
             WRITE(LUNGFO,*)'SOURCE POINT:',ISOUR
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(6,*)
             WRITE(6,*)
             WRITE(6,*)'*** WARNING IN CIRCPOW ***'
             WRITE(6,*)
     &'SPLINE INTEGRATION FAILED FOR LEFT EDGE OF PINHOLE, RESULTS NOT RELIABLE'
             WRITE(6,*)'SOURCE POINT:',ISOUR
             WRITE(6,*)
             WRITE(6,*)
             IWSOUR1=ISOUR
             IWSOUR=1
           IW_CIRC=1
             ENDIF    !SH-SL
         ENDIF !IWSOUR1

      A=1.D0
      B=0.D0

      SL=
     &           -FZ(KHM)*A**2/2.*DZ+FZ(KHP)*B**2/2.*DZ
     &           +DZ**2/6.
     &           *((-DZ*A**4/4.+DZ*A**2/2.)*SZ(KHM)
     &           +(DZ*B**4/4.-DZ*B**2/2.)*SZ(KHP))

      A=(OBSVZF(KHP)-ZH)/OBSVDZ
      B=(ZH-OBSVZF(KHM))/OBSVDZ

      SH=
     &           -FZ(KHM)*A**2/2.*DZ+FZ(KHP)*B**2/2.*DZ
     &           +DZ**2/6.
     &           *((-DZ*A**4/4.+DZ*A**2/2.)*SZ(KHM)
     &           +(DZ*B**4/4.-DZ*B**2/2.)*SZ(KHP))


      DSUMH=SH-SL

         IF(IWSOUR2.NE.ISOUR.AND.ISOUR.GT.0.AND.DSUMH.LT.0.0) THEN
             IF ( DABS((SH-SL)/(SH+SL)) .GT. 5.D-15 ) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)'*** WARNING IN CIRCPOW ***'
             WRITE(LUNGFO,*)
     &          'SPLINE INTEGRATION FAILED FOR RIGHT EDGE OF PINHOLE, RESULTS NOT RELIABLE'
             WRITE(LUNGFO,*)'SOURCE POINT:',ISOUR
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(6,*)
             WRITE(6,*)
             WRITE(6,*)'*** WARNING IN CIRCPOW ***'
             WRITE(6,*)
     &          'SPLINE INTEGRATION FAILED FOR RIGHT EDGE OF PINHOLE, RESULTS NOT RELIABLE'
             WRITE(6,*)'SOURCE POINT:',ISOUR
             WRITE(6,*)
             WRITE(6,*)
             IWSOUR2=ISOUR
             IWSOUR=1
           IW_CIRC=1
             ENDIF
         ENDIF !IWSOUR2

C---  NOW ALL FULL INTERVALLS

      DO IZ=KLP,KHM-1
         DSUM=
     &    OBSVDZ*0.5D0
     &    *(FZ(IZ)+FZ(IZ+1))
     &    -OBSVDZ**3/24.D0
     &    *(SZ(IZ)+SZ(IZ+1))

         IF(IWSOUR3.NE.ISOUR.AND.ISOUR.GT.0.AND.DSUM.LT.0.0) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)'*** WARNING IN CIRCPOW ***'
             WRITE(LUNGFO,*)
     &          'SPLINE INTEGRATION FAILED INSIDE PINHOLE, RESULTS NOT RELIABLE'
             WRITE(LUNGFO,*)'SOURCE POINT:',ISOUR
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(6,*)
             WRITE(6,*)
             WRITE(6,*)'*** WARNING IN CIRCPOW ***'
             WRITE(6,*)
     &              'SPLINE INTEGRATION FAILED INSIDE, RESULTS NOT RELIABLE'
             WRITE(6,*)'SOURCE POINT:',ISOUR
             WRITE(6,*)
             WRITE(6,*)
             IWSOUR3=ISOUR
             IWSOUR=1
           IW_CIRC=1
           DO IDUM=1,IIY
         SUMYP(IIY)=SUMY(IIY)
           ENDDO
         ENDIF !IWSOUR3

         SUMY(IIY)=SUMY(IIY)+DSUM
          IF (IW_CIRC.NE.0) SUMYP(IIY)=SUMYP(IIY)+ABS(DSUM)

      ENDDO !IZ

      SUMY(IIY)=SUMY(IIY)+DSUML+DSUMH
      IF (IW_CIRC.NE.0) SUMYP(IIY)=SUMYP(IIY)+ABS(DSUML)+ABS(DSUMH)

      ELSE !INSIDE PINHOLE

      SUMY(IIY)=0.0

      ENDIF !INSIDE PINHOLE
      ENDDO !IY

C--- INTEGRATION OVER VERTICAL DIRECTION

      CALL FSPLINDX(OBSVDY,SUMY,MY,0.D0,0.D0,SY)

      SUM=0.0
      DO IY=1,MY-1

        DSUM=
     &    OBSVDY*0.5D0
     &    *(SUMY(IY)+SUMY(IY+1))
     &    -OBSVDY**3/24.D0
     &    *(SY(IY)+SY(IY+1))

         IF(IWSOUR4.NE.ISOUR.AND.ISOUR.GT.0.AND.DSUM.LT.0.0) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)'*** WARNING IN CIRCPOW ***'
             WRITE(LUNGFO,*)
     &          'SPLINE INTEGRATION FAILED FOR VERTICAL INTEGRATION, RESULTS NOT RELIABLE'
             WRITE(LUNGFO,*)'SOURCE POINT:',ISOUR
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(6,*)
             WRITE(6,*)
             WRITE(6,*)'*** WARNING IN CIRCPOW ***'
             WRITE(6,*)
     &'SPLINE INTEGRATION FAILED FOR VERTICAL INTEGRATION, RESULTS NOT RELIABLE'
             WRITE(6,*)'SOURCE POINT:',ISOUR
             WRITE(6,*)
             WRITE(6,*)
             IWSOUR4=ISOUR
             IWSOUR=1
           IW_CIRC=1
         ENDIF !IWSOUR4

         SUM=SUM+DSUM

      ENDDO !IY

      IF (IW_CIRC.NE.0) THEN

      CALL FSPLINDX(OBSVDY,SUMYP,MY,0.D0,0.D0,SY)

      SUMP=0.0
      DO IY=1,MY-1

        DSUM=
     &    OBSVDY*0.5D0
     &    *(SUMYP(IY)+SUMYP(IY+1))
     &    -OBSVDY**3/24.D0
     &    *(SY(IY)+SY(IY+1))

         SUMP=SUMP+ABS(DSUM)

      ENDDO !IY

      ENDIF   !IW_CIRC

      SPECPOWVH(ISOUR)=SUM
      IW_CIRC=IWCIRCO

      IF (ICAL.EQ.0) THEN
      ICAL=1
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'*** WARNING IN CIRCPOW ***'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'FOR CIRCULAR PINHOLE ONLY POWER THROUGH PINHOLE'
      WRITE(LUNGFO,*)'IS CALCULATED. THE VERTICALLY INTEGRATED POWERDENSITY'
      WRITE(LUNGFO,*)'IS NOT, SINCE NOT MEANINGFUL'
      WRITE(LUNGFO,*)
      ENDIF

      RETURN
      END
+DECK,CIRCPOWRP.
*CMZ :  3.00/00 11/03/2013  15.12.10  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.34/00 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.31/00 23/04/2001  18.27.11  by  Michael Scheer
*CMZ :  2.20/09 23/03/2001  11.01.07  by  Michael Scheer
*CMZ :  2.16/08 24/10/2000  14.08.07  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.08.20  by  Michael Scheer
*CMZ :  2.13/03 11/01/2000  18.22.27  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  15.04.41  by  Michael Scheer
*CMZ :  1.00/00 31/07/97  17.36.12  by  Michael Scheer
*CMZ : 00.02/05 18/03/97  15.48.44  by  Michael Scheer
*CMZ : 00.02/04 26/02/97  12.07.43  by  Michael Scheer
*CMZ : 00.02/00 10/12/96  18.07.52  by  Michael Scheer
*CMZ : 00.01/09 01/09/95  12.58.16  by  Michael Scheer
*CMZ : 00.01/02 24/11/94  15.49.44  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.47.38  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.04  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE CIRCPOWRP(ISOUR)
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SELF.

C--- INTEGRATES THE POWER DENSITY INSIDE THE PINHOLE

      IMPLICIT NONE


+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,PHYCON.


      INTEGER ISOUR,IY,IZ,IOBSV,ICAL,IR,IP,NR,MR,MP,KDUM
      INTEGER IWBLEN
      INTEGER IWRPHIS,IWSOUR
      INTEGER IW_BLENO

      DOUBLE PRECISION DSUM,RPHI,SUM

      DOUBLE PRECISION SUMY(NDOBSVZP)
+SELF,IF=-NEWWAVE,IF=-F90.
      DOUBLE PRECISION FPHIR(NDOBSVYP,NDOBSVZP)
     &        ,XC(NDOBSVYP,NDOBSVZP),YC(NDOBSVYP,NDOBSVZP)
     &        ,BUFF(NDOBSVP)
      EQUIVALENCE (FPHIR(1,1),BUFF(1))
+SELF,IF=NEWWAVE,IF=-F90.
      DOUBLE PRECISION FPHIR(NDOBSVP),XC(NDOBSVP),YC(NDOBSVP)
+SELF.
      DOUBLE PRECISION R(NDOBSVZP),PHI(NDOBSVYP)
     &        ,FPHI(NDOBSVYP)
     &        ,SZ(NDOBSVZP),SY(NDOBSVYP)
     &        ,FZ(NDOBSVZP),FY(NDOBSVYP),DPHI,DR,X,Y


      DATA ICAL/0/

      IWBLEN=0
      IW_BLENO=IW_BLEN

C--- INTEGRATION OVER PHI

      IF (ICAL.EQ.0) THEN

          DR=DMIN1(OBSVDZ,OBSVDY)
          MR=NINT(PINR/DR)+1
          DR=PINR/(MR-1)
          MEDGER=MIN( MEDGEZ, MEDGEY)
          NR=MR+MEDGER
          MP=MOBSVY

          IF (MR.LT.1) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'*** ERROR IN CIRCPOWRP ***'
           WRITE(LUNGFO,*)'NOT ENOUGH GRID POINTS FOR CIRCULAR PINHOLE'
           WRITE(LUNGFO,*)'INCREASE PARAMETER MPINZ IN NAMELIST PINHOLE'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)'*** ERROR IN CIRCPOWRP ***'
           WRITE(6,*)'NOT ENOUGH GRID POINTS FOR CIRCULAR PINHOLE'
           WRITE(6,*)'INCREASE PARAMETER MPINZ IN NAMELIST PINHOLE'
           WRITE(6,*)
          ENDIF
          IF (MP.LT.4) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'*** ERROR IN CIRCPOWRP ***'
           WRITE(LUNGFO,*)'NOT ENOUGH GRID POINTS FOR CIRCULAR PINHOLE'
           WRITE(LUNGFO,*)'INCREASE PARAMETER MPINY IN NAMELIST PINHOLE'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)'*** ERROR IN CIRCPOWRP ***'
           WRITE(6,*)'NOT ENOUGH GRID POINTS FOR CIRCULAR PINHOLE'
           WRITE(6,*)'INCREASE PARAMETER MPINY IN NAMELIST PINHOLE'
           WRITE(6,*)
          ENDIF

          DPHI=2.D0*PI1/(MP-1)
          DO IP=1,MP
               PHI(IP)=(IP-1)*DPHI
          ENDDO

          DO IR=1,NR
               R(IR)=(IR-1)*DR
          ENDDO

      DO IR=2,NR
      DO IP=1,MP
+SELF,IF=-NEWWAVE.
          XC(IP,IR)=R(IR)*DCOS(PHI(IP))+PINCEN(3)
          YC(IP,IR)=R(IR)*DSIN(PHI(IP))+PINCEN(2)
+SELF,IF=NEWWAVE.
          XC(IP+(IR-1)*NOBSVY)=R(IR)*DCOS(PHI(IP))+PINCEN(3)
          YC(IP+(IR-1)*NOBSVY)=R(IR)*DSIN(PHI(IP))+PINCEN(2)
+SELF.
      ENDDO !IP
      ENDDO !IR

          ICAL=1

      ENDIF !ICAL

C--- INTERPOLATION OF INTENSITY FOR CIRCULAR GRID

      DO IR=2,NR
          DO IP=1,MP

+SELF,IF=-NEWWAVE.
            X=XC(IP,IR)
            Y=YC(IP,IR)
+SELF,IF=NEWWAVE.
            X=XC(IP+(IR-1)*NOBSVY)
            Y=YC(IP+(IR-1)*NOBSVY)
+SELF.

         DO IY=1,NOBSVY
         DO IZ=1,NOBSVZ
             IOBSV=(IY-1)*NOBSVZ+IZ
+SELF,IF=-NEWWAVE.
             FZ(IZ)=SPECPOW(ISOUR,IOBSV)
+SELF,IF=NEWWAVE.
             FZ(IZ)=SPECPOW(ISOUR+(IOBSV-1)*NSOURCE)
+SELF.
         ENDDO !IZ

       CALL FSPLINDX(OBSVDZ,FZ,NOBSVZ,0.D0,0.D0,SZ)
         CALL SPLINZY(NOBSVZ,X,FY(IY),OBSVZ,FZ,SZ,KDUM)

         ENDDO !IY

         CALL FSPLINDX(OBSVDY,FY,NOBSVY,0.D0,0.D0,SY)
+SELF,IF=-NEWWAVE.
         CALL SPLINZY(NOBSVY,Y,FPHIR(IP,IR),OBSVY,FY,SY,KDUM)
+SELF,IF=NEWWAVE.
         CALL SPLINZY(NOBSVY,Y,FPHIR(IP+(IR-1)*NOBSVY),OBSVY,FY,SY,KDUM)
+SELF.
         IF(IWRPHIS.NE.ISOUR.AND.
+SELF,IF=-NEWWAVE.
     &              FPHIR(IP,IR).LT.0.0) THEN
+SELF,IF=NEWWAVE.
     &              FPHIR(IP+(IR-1)*NOBSVY).LT.0.0) THEN
+SELF.
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)'*** WARNING SR CIRCPOWRP ***'
             WRITE(LUNGFO,*)
     &              'SPLINE INTERPOLATION FOR OPTION IRPHI FAILED, RESULTS NOT RELIABLE'
             WRITE(LUNGFO,*)'SOURCE POINT:',ISOUR
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             IWRPHIS=ISOUR
           IW_BLEN=1
         ENDIF !IWPHIR

          ENDDO !IP
      ENDDO !IR

C--- DO THE INTEGRATION OF FPHIR OVER PHI AND R

      SUMY(1)=0.0
      DO IR=2,NR  !FIRST RADIUS IS ZERO

          DO IP=1,MP
+SELF,IF=-NEWWAVE.
         FPHI(IP)=FPHIR(IP,IR)
+SELF,IF=NEWWAVE.
         FPHI(IP)=FPHIR(IP+(IR-1)*NOBSVY)
+SELF.
          ENDDO   !IP

          CALL FSPLPER(DPHI,FPHI,MP,SY)

          SUMY(IR)=0.D0
          RPHI=R(IR)*DPHI
          DO IP=1,MP-1

         DSUM=
     &       RPHI*0.5D0*(FPHI(IP)+FPHI(IP+1))
     &          -RPHI**3/24.D0*(SY(IP)+SY(IP+1))

         IF(IWSOUR.NE.ISOUR.AND.DSUM.LT.0.0) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)'*** WARNING SR CIRCPOWRP ***'
             WRITE(LUNGFO,*)
     &              'SPLINE INTEGRATION FAILED, RESULTS NOT RELIABLE'
             WRITE(LUNGFO,*)'SOURCE POINT:',ISOUR
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             IWSOUR=ISOUR
           IW_BLEN=1
         ENDIF !IWSOUR

         SUMY(IR)=SUMY(IR)+DSUM

          ENDDO   !IP

      ENDDO !IR

      CALL FSPLINDX(DR,SUMY,NR,0.D0,0.D0,SZ)

          SUM=0.0
          DO IR=1,MR-1

         DSUM=
     &          DR*0.5D0
     &          *(SUMY(IR)+SUMY(IR+1))
     &          -DR**3/24.D0
     &          *(SZ(IR)+SZ(IR+1))

         IF(IWSOUR.NE.ISOUR.AND.DSUM.LT.0.0) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)'*** WARNING SR CIRCPOWRP ***'
             WRITE(LUNGFO,*)
     &              'SPLINE INTEGRATION FAILED, RESULTS NOT RELIABLE'
             WRITE(LUNGFO,*)'SOURCE POINT:',ISOUR
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             IWSOUR=ISOUR
           IW_BLEN=1
         ENDIF !IWSOUR

         SUM=SUM+DSUM

          ENDDO

        SPECPOWVH(ISOUR)=SUM

      IW_BLEN=IW_BLENO

      RETURN
      END
+DECK,circspeciv.
*CMZ :  3.00/00 11/03/2013  15.12.10  by  Michael Scheer
*CMZ :  2.34/01 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.33/06 04/05/2001  13.50.00  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  14.22.46  by  Michael Scheer
*CMZ :  2.16/05 04/08/2000  11.03.38  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  2.13/07 17/02/2000  15.11.12  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.08.20  by  Michael Scheer
*CMZ :  2.13/03 11/01/2000  18.01.43  by  Michael Scheer
*CMZ :  2.10/01 25/02/99  15.57.16  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  15.04.41  by  Michael Scheer
*-- Author : Michael Scheer

      SUBROUTINE CIRCSPECIV(ISOUR,IZ)
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SELF.

C--- INTEGRATES THE SPLINES THAT INTERPOLATE THE POWER INSIDE THE PINHOLE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,sourcef90.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,PHYCON.


      INTEGER ISOUR,IY,IZ,IOBSV
      INTEGER ICAL,IWBLEN,IDUM
      INTEGER IWSOUR
      DOUBLE PRECISION DSUM

      DOUBLE PRECISION SUMZ(NDOBSVYP),S2(NDOBSVYP),SUM
      DOUBLE PRECISION SUMZP(NDOBSVYP),S2P(NDOBSVYP),SUMP,DSUMP

      DATA ICAL/0/

      IWBLEN=0

      IF (IPINCIRC.EQ.0) THEN

C--- INTEGRATION ALONG VERTICAL AXIS Y

      DO IY=1,NOBSVY
          IOBSV=IZ+(IY-1)*NOBSVZ
+SELF,IF=-NEWWAVE.
          SUMZ(IY)=SPECI(ISOUR,IOBSV)
+SELF,IF=NEWWAVE.
          SUMZ(IY)=SPECI(ISOUR+NSOURCE*(IOBSV-1))
+SELF.
      ENDDO

      CALL FSPLINDX(OBSVDY,SUMZ,NOBSVY,0.D0,0.D0,S2)

        IF(MOBSVY.GT.1) THEN

          SUM=0.0
          SUMP=0.0

          DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY-1

            DSUM=
     &          OBSVDY*0.5D0
     &          *(SUMZ(IY)+SUMZ(IY+1))
     &          -OBSVDY**3/24.D0
     &          *(S2(IY)+S2(IY+1))

          IF (IW_BLEN.NE.0) THEN
                 DSUMP=
     &          OBSVDY*0.5D0
     &          *(SUMZP(IY)+SUMZP(IY+1))
     &          -OBSVDY**3/24.D0
     &          *(S2P(IY)+S2P(IY+1))
          ENDIF

             IF(
     &              (IWSOUR.NE.ISOUR)
     &              .AND.
     &              DSUM.LT.0.0) THEN
         IF (IW_BLEN.EQ.0) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'*** WARNING SR CIRCSPECIV ***'
              WRITE(LUNGFO,*)
     &              'SPLINE INTEGRATION FAILED, RESULTS NOT RELIABLE'
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
              ENDIF

             IWSOUR=ISOUR
           IW_BLEN=1
           IWBLEN=1
           DO IDUM=1,NOBSVY
         S2P(IDUM)=S2(IDUM)
         SUMZP(IDUM)=SUMZ(IDUM)
         SUMP=SUM
         DSUMP=DSUM
           ENDDO

            ENDIF !IWSOUR

          IF (IWBLEN.NE.0) SUMP=SUMP+DABS(DSUMP)

             SUM=SUM+DSUM

          ENDDO !IY

        ELSE !MOBSVY

         SUM=OBSVDY*SUMZ(NOBSVY/2+1)

         IF (IWBLEN.NE.0) SUMP=OBSVDY*SUMZP(NOBSVY/2+1)

        ENDIF !MOBSVY

      ELSE  !IPINCIRC

      WRITE(LUNGFO,*)'*** WARNING IN CIRCSPECIV: ***'
      WRITE(LUNGFO,*)'INTEGRATION OF POWERDENSITY NOT POSSIBLE'
      WRITE(LUNGFO,*)'FOR CIRCULAR PINHOLE, SORRY'
      WRITE(LUNGFO,*)'USE PAW AND NTUPLE FOR RAW OFFLINE INTEGRATION'
      WRITE(6,*)'*** WARNING IN CIRCSPECIV: ***'
      WRITE(6,*)'INTEGRATION OF POWERDENSITY NOT POSSIBLE'
      WRITE(6,*)'FOR CIRCULAR PINHOLE, SORRY'
      WRITE(6,*)'USE PAW AND NTUPLE FOR RAW OFFLINE INTEGRATION'
      RETURN

      ENDIF !IPINCIRC

+SELF,IF=-NEWWAVE.
      SPECIV(ISOUR,IZ)=SUM
+SELF,IF=NEWWAVE.
      SPECIV(ISOUR+NSOURCE*(IZ-1))=SUM
+SELF.

      IF (IWBLEN.NE.0) THEN
          IF (ICAL.EQ.0) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'*** SR CIRCSPECIV:'
         WRITE(LUNGFO,*)
     &'LINES INDICATED BY * SHOW A RAW ESTIMATE OF ERRORS DUE TO'
         WRITE(LUNGFO,*)
     &'SPLINE FAILURE IF REL. ERROR .GT. 1E-5 (FIRST NUMBER IS SOURCE)'
         WRITE(LUNGFO,*)
         ICAL=1
          ENDIF   !ICAL
          IF (SUMP.NE.0.D0) THEN
         DSUM=SUM/SUMP
          ELSE
         DSUM=-9999.
          ENDIF
          IF (DABS(DSUM-1.D0).GT.1.D-5) THEN
            WRITE(LUNGFO,*)'*',ISOUR,IZ,
     &        SNGL(SUM),SNGL(SUMP),SNGL(DSUM)
            WRITE(6,*)'*',ISOUR,IZ,
     &        SNGL(SUM),SNGL(SUMP),SNGL(DSUM)
          ENDIF
      ENDIF !IWBLEN

      RETURN
      END
+DECK,CLOSEOR.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.49.07  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.29  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE CLOSEOR(A01,A10,A11,A20,A02,X,P)
+seq,gplhint.

      IMPLICIT NONE

      DOUBLE PRECISION A01,A10,A11,A20,A02,X,P

      X=0.
      P=0.

      IF(A11.NE.1.D0) THEN
          X=(A01*(1.-A11)+2.*A02*A10)/((1.-A11)**2-4.*A02*A20)
          P=A10/(1.-A11)+2.*A20/(1.-A11)*X
C     ELSEIF(A11.EQ.1.D0)THEN
C         IF (A20.NE.0) X=-A10/(2.*A20)
C         IF (A02.NE.0) P=-A01/(2.*A02)
C         IF (A02.EQ.0. .AND. A01.NE.0. .OR. A20.EQ.0. .AND. A10.NE.0.)
C     &      STOP '*** S/R CLOSEOR: KOEFFIZIENTEN INKONSISTENT ***'
      ENDIF

c     P=P/DSQRT(1.D0-P*P)

      RETURN
      END
+DECK,COHEREN.
*CMZ :  3.00/00 11/03/2013  15.10.30  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.16/08 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  15.46.45  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.49.11  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.01  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE COHEREN
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SOURCEF90U.
+SEQ,TRACKF90U.
+SELF.

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,CMPARA.
+seq,sourcef90.
+SEQ,TRACK.
+SEQ,FREQS.
+SEQ,PHYCON.

      INTEGER IFREQ,ISOUR
      DOUBLE PRECISION OSZILL,OSZMAX,OSZMIN
      DOUBLE PRECISION DTIME,DTIMEP,DTIM

      OSZMAX=-1.D30
      OSZMIN= 1.D30

      DO IFREQ=1,NFREQ
          DO ISOUR=1,NSOURCE

          DTIME=SOURCET(2,ISOUR)-SOURCET(1,ISOUR)
          DTIMEP=(SOURCEE(1,1,ISOUR)-SOURCEA(1,1,ISOUR))/CLIGHT1

          DTIM=DTIME-DTIMEP

         OSZILL=FREQ(IFREQ)/HBAREV1*DTIM/2.D0/PI1
         IF (OSZILL.LT.OSZMIN) OSZMIN=OSZILL
         IF (OSZILL.GT.OSZMAX) OSZMAX=OSZILL

          ENDDO   !ISOUR
      ENDDO !IFREQ

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SR COHEREN:'
      WRITE(LUNGFO,*)
     &'     Minimum and maximum number of phases  between'
      WRITE(LUNGFO,*)
     &'     photons and electrons:'
      WRITE(LUNGFO,*)'     ',SNGL(OSZMIN),SNGL(OSZMAX)
      WRITE(LUNGFO,*)

      RETURN
      END
+DECK,Conv2.
*CMZ :  4.00/07 09/01/2020  13.45.41  by  Michael Scheer
*CMZ :  2.16/08 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.14/02 19/04/2000  17.02.45  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  11.38.23  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.09.58  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  16.22.06  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  15.49.08  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.49.16  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.55  by  Michael Scheer
*-- Author : Chaoen Wang
C...............................................................................
      Subroutine Conv2
      PRINT*,"CONV2 IS OBSOLETE,  SEE //WAVE/USEM IN WAVE.CMZ"
      Return
      End
+DECK,CONVUN.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.15/00 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  11.56.14  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.49.20  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.34  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE CONVUN
+seq,gplhint.

      IMPLICIT NONE

C--- CONVERTS FREQUENCES ON INPUT FILE FROM EV TO NM OR VICE VERSA

+SEQ,CMPARA.
+SEQ,FREQS.
+SEQ,PHYCON.

      INTEGER IFREQ
      DOUBLE PRECISION FBUFF(NDFREQP)

      DO IFREQ=1,NFREQ
          FBUFF(IFREQ)=WTOE1/FREQ(IFREQ)
      ENDDO

      DO IFREQ=1,NFREQ
             FREQ(IFREQ)=FBUFF(NFREQ+1-IFREQ)
      ENDDO


      IF (FREQC.NE.0.0) FREQC=WTOE1/FREQC
      IF (FREQCF.NE.0.0) FREQCF=WTOE1/FREQCF

      RETURN
      END
+DECK,CRIFREQ.
*CMZ :  3.00/00 11/03/2013  15.10.30  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.16/08 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  2.13/03 11/01/2000  18.22.28  by  Michael Scheer
*CMZ :  2.12/03 29/07/99  14.01.14  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.49.24  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.50  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE CRIFREQ
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SELF.

C     INTEGRATES SPECTRAL FLUX THROUGH PINHOLE
C     OVER ALL PHOTON ENERGIES TO CALCULATE CRITICAL ENERGY

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,SPECT.
+SEQ,FREQS.
+SEQ,PHYCON.
+seq,sourcef90.

      INTEGER IFREQ,ISOUR
      DOUBLE PRECISION FBUFF(NDFREQP),DFBUFF(NDFREQP),SBUFF(NDFREQP),DSUM,SUM,SUM2

      IF(NFREQ.LT.2) RETURN

      DO IFREQ=1,NFREQ
          FBUFF(IFREQ)=0.0
      DO ISOUR=1,NSOURCE
+SELF,IF=-NEWWAVE.
          FBUFF(IFREQ)=FBUFF(IFREQ)+WFLUX(ISOUR,IFREQ)/BANWID*ECHARGE1
+SELF,IF=NEWWAVE.
          FBUFF(IFREQ)=FBUFF(IFREQ)+WFLUX(ISOUR+NSOURCE*(IFREQ-1))
     &                /BANWID*ECHARGE1
+SELF.
      ENDDO !ISOUR
      ENDDO !IFREQ

      DO IFREQ=2,NFREQ
          DFBUFF(IFREQ)=FREQ(IFREQ)-FREQ(IFREQ-1)
      ENDDO !IFREQ

      SUM=0.0
      SBUFF(1)=0.0
      DO IFREQ=2,NFREQ
          DSUM=(FBUFF(IFREQ)+FBUFF(IFREQ-1))/2.*DFBUFF(IFREQ)
          SUM=SUM+DSUM
          SBUFF(IFREQ)=SUM
      ENDDO !IFREQ

      SUM2=SUM/2.
      DO IFREQ=2,NFREQ
          IF (SBUFF(IFREQ).GT.SUM2) GOTO 100
      ENDDO !IFREQ

100   CONTINUE

      IF (SBUFF(IFREQ)-SBUFF(IFREQ-1).NE.0.) THEN
           FREQC=FREQ(IFREQ-1)
     &       +(SUM2-SBUFF(IFREQ-1))/(SBUFF(IFREQ)-SBUFF(IFREQ-1))
     &       *DFBUFF(IFREQ)
      ELSE
           FREQC=0.0
      ENDIF

      IF (IFOLD.NE.0) THEN
      DO IFREQ=1,NFREQ
          FBUFF(IFREQ)=0.0
      DO ISOUR=1,NSOURCE
+SELF,IF=-NEWWAVE.
          FBUFF(IFREQ)=FBUFF(IFREQ)+WFLUXF(ISOUR,IFREQ)/BANWID*ECHARGE1
+SELF,IF=NEWWAVE.
          FBUFF(IFREQ)=FBUFF(IFREQ)+WFLUXF(ISOUR+NSOURCE*(IFREQ-1))
     &                /BANWID*ECHARGE1
+SELF.
      ENDDO !ISOUR
      ENDDO !IFREQ

      SUM=0.0
      SBUFF(1)=0.0
      DO IFREQ=2,NFREQ
          DSUM=(FBUFF(IFREQ)+FBUFF(IFREQ-1))/2.*DFBUFF(IFREQ)
          SUM=SUM+DSUM
          SBUFF(IFREQ)=SUM
      ENDDO !IFREQ

      SUM2=SUM/2.
      DO IFREQ=2,NFREQ
          IF (SBUFF(IFREQ).GT.SUM2) GOTO 200
      ENDDO !IFREQ

200   CONTINUE

      IF (SBUFF(IFREQ)-SBUFF(IFREQ-1).NE.0.) THEN
           FREQCF=FREQ(IFREQ-1)
     &       +(SUM2-SBUFF(IFREQ-1))/(SBUFF(IFREQ)-SBUFF(IFREQ-1))
     &       *DFBUFF(IFREQ)
      ELSE
           FREQCF=0.0
      ENDIF

      ENDIF !IFOLD

      IF (FREQC.EQ.0.0) FREQC=FREQ(NFREQ/2+1)
      IF (FREQCF.EQ.0.0) FREQCF=FREQ(NFREQ/2+1)

      IF (FREQC.NE.0.0) WELLENC=WTOE1/FREQC
      IF (FREQCF.NE.0.0) WELLENCF=WTOE1/FREQCF

      RETURN
      END
+DECK,CRIFREQS.
*CMZ :  3.00/00 11/03/2013  15.12.10  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.16/08 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  2.13/03 16/12/99  10.51.00  by  Michael Scheer
*CMZ :  2.12/04 20/08/99  11.22.54  by  Michael Scheer
*CMZ :  2.12/03 29/07/99  14.01.14  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.49.24  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.50  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE CRIFREQS(IOBSV)
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SELF.

C     INTEGRATES SPECTRAL SINGLE OBSERVATION POINT
C     OVER ALL PHOTON ENERGIES TO CALCULATE CRITICAL ENERGY

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,SPECT.
+SEq,observf90.
+SEQ,FREQS.
+SEQ,PHYCON.
+seq,sourcef90.

      INTEGER IFREQ,ISOUR,IOBSV
      DOUBLE PRECISION FBUFF(NDFREQP),DFBUFF(NDFREQP),SBUFF(NDFREQP),DSUM,SUM,SUM2

      IF(NFREQ.LT.2) RETURN

      DO IFREQ=1,NFREQ
          FBUFF(IFREQ)=0.0
      DO ISOUR=1,NSOURCE
          FBUFF(IFREQ)=FBUFF(IFREQ)
+SELF,IF=-NEWWAVE.
     &                +SPEC(ISOUR,IOBSV,IFREQ)/BANWID*ECHARGE1
+SELF,IF=NEWWAVE.
     &                +SPEC(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))
     &                /BANWID*ECHARGE1
+SELF.
      ENDDO !ISOUR
      ENDDO !IFREQ

      DO IFREQ=2,NFREQ
          DFBUFF(IFREQ)=FREQ(IFREQ)-FREQ(IFREQ-1)
      ENDDO !IFREQ

      SUM=0.0
      SBUFF(1)=0.0
      DO IFREQ=2,NFREQ
          DSUM=(FBUFF(IFREQ)+FBUFF(IFREQ-1))/2.*DFBUFF(IFREQ)
          SUM=SUM+DSUM
          SBUFF(IFREQ)=SUM
      ENDDO !IFREQ

      SUM2=SUM/2.
      DO IFREQ=2,NFREQ
          IF (SBUFF(IFREQ).GT.SUM2) GOTO 100
      ENDDO !IFREQ

100   CONTINUE

      IF (SBUFF(IFREQ)-SBUFF(IFREQ-1).NE.0.) THEN
           FREQC=FREQ(IFREQ-1)
     &       +(SUM2-SBUFF(IFREQ-1))/(SBUFF(IFREQ)-SBUFF(IFREQ-1))
     &       *DFBUFF(IFREQ)
      ELSE
           FREQC=0.0
      ENDIF

      IF (FREQC.EQ.0.0) FREQC=FREQ(NFREQ/2+1)

      IF (FREQC.NE.0.0) WELLENC=WTOE1/FREQC

      RETURN
      END
+DECK,DCOSD.
*CMZ :  4.00/16 09/09/2022  17.29.00  by  Michael Scheer
*CMZ :  2.48/04 12/03/2004  15.40.31  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  2.14/02 20/04/2000  14.28.52  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.36.30  by  Michael Scheer
*-- Author :    Michael Scheer   08/02/2000
      DOUBLE PRECISION FUNCTION DCOSD(X)

      DOUBLE PRECISION X,GR
      PARAMETER (GR=0.0174532925199D0)

      DCOSD=COS(X*GR)

      RETURN
      END
+DECK,DEFUN.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  15.52.22  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.44  by  Michael Scheer
*-- Author : Michael Scheer
+seq,gplhint.
      DOUBLE PRECISION FUNCTION DEFUN(CD,C5,C2,DI2,DI5,E)
          IMPLICIT NONE
          DOUBLE PRECISION CD,C5,C2,DI2,DI5,E

            C5=C5
          DEFUN=5.*(DI5-CD*DI2)*E**4-3.*CD*C2*E**2

          RETURN
          END
+DECK,DEFUNP.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.15/00 12/05/2010  13.34.28  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  15.53.14  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.37.11  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.45  by  Michael Scheer
*-- Author : Michael Scheer
+seq,gplhint.
C******************************************************************

      DOUBLE PRECISION FUNCTION DEFUNP(R,B3,T0,TK,E)

          IMPLICIT NONE
+SEQ,PHYCON.
          DOUBLE PRECISION R,B3,T0,TK,E

      T0=T0
      TK=TK
          DEFUNP=5.*E**4+2.*(CLIGHT1*1.D-9)**3*R**2/(2.*PI1)*B3*E

          RETURN
      END
+DECK,DFDTDP.
*CMZ :  4.00/13 01/12/2021  09.06.02  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.67/04 11/05/2012  12.53.41  by  Michael Scheer
*CMZ :  2.33/00 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  2.00/00 15/12/98  10.35.46  by  Michael Scheer
*CMZ : 00.02/02 15/01/97  15.18.41  by  Michael Scheer
*CMZ : 00.00/07 18/05/94  14.54.15  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.54.12  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.24  by  Michael Scheer
*-- Author : Michael Scheer
+seq,gplhint.
      DOUBLE PRECISION FUNCTION DFDTDP
     &  (Y,PSI,DMYGAMMA,DMYCUR,BANWID,PAR,PER,POWR)

C--- CALCULATE DIPOL SPECTRUM

      IMPLICIT NONE

+SEQ,PHYCON.

      integer ical

      DOUBLE PRECISION Y,PSI,DMYGAMMA,DMYCUR,BANWID,PAR,PER,POWR
      DOUBLE PRECISION X,XX,XX1,XI,BK13,BK23,DBSKR3,CONST

      data ical/0/

      if (ical.eq.0) then
        CONST=3.0d0/4.0d0*ALPHA1/PI1**2*DMYGAMMA**2*BANWID*DMYCUR/ECHARGE1
        ical=1
      endif

      IF (Y.EQ.0.0d0) THEN
        WRITE(6,*)'     E/Ec is zero in function DFDTDP'
        STOP '--- PROGRAM WAVE ABORTED ---'
      ENDIF

      X=DMYGAMMA*PSI
      XX=X*X
      XX1=XX+1.0d0
      XI=Y*DSQRT(XX1)**3/2.0d0
      BK13=DBSKR3(XI,1)
      BK23=DBSKR3(XI,2)
      PAR=CONST*(Y*XX1)**2*BK23**2
      PER=CONST*Y*Y*XX*XX1*BK13**2
C      DFDTDP=CONST*(Y*XX1)**2*(BK23**2+XX/XX1*BK13**2)
      DFDTDP=PAR+PER
C      POWR=7.0d0/16.0d0*(ECHARGE1*(CLIGHT1*10.0d0))**2
C     &       /(SQRT(PSI*PSI+1.0d0/DMYGAMMA/DMYGAMMA))**5
C     &       *(1.0d0+5.0d0/7.0d0*XX/XX1)*1.0d-9*DMYCUR/ECHARGE1
      POWR=7.0d0/16.0d0*ECHARGE1*ECHARGE1/4.0d0/PI1/EPS01
     &  /(SQRT(PSI*PSI+1.0d0/DMYGAMMA/DMYGAMMA))**5
     &  *(1.0d0+5.0d0/7.0d0*XX/XX1)*DMYCUR/ECHARGE1

      RETURN
      END
+DECK,DOPTFUN.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.47/04 12/03/2003  15.42.26  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.49.34  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.47  by  Michael Scheer
*-- Author : Michael Scheer
+seq,gplhint.
C**********************************************************************
      DOUBLE PRECISION FUNCTION DOPTFUN(NN,PHI,R1)
C**********************************************************************

c     optimum external dispersion; REDUCE 31.03.92

      IMPLICIT NONE

      DOUBLE PRECISION NN,PHI,R1,ANS

      ANS=(R1*PHI**2*(-0.019894367886487d0*NN**3-0.027976454840372d0
     &  *NN**2-0.012900254176394d0*NN-0.019894367886487d0
     . ))/(NN**2+1.)

      DOPTFUN=-ANS !GODE RECHNET MIT NEGATIVER ABLAGE UND NEGATIVER DISPERSION


      RETURN
      END
+DECK,DSIND.
*CMZ :  4.00/16 09/09/2022  17.30.28  by  Michael Scheer
*CMZ :  2.48/04 12/03/2004  15.40.31  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  2.14/02 20/04/2000  14.28.53  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.37.38  by  Michael Scheer
*-- Author :    Michael Scheer   08/02/2000
+seq,gplhint.
      DOUBLE PRECISION FUNCTION DSIND(X)

      DOUBLE PRECISION X,GR
      PARAMETER (GR=0.0174532925199D0)

      DSIND=SIN(X*GR)

      RETURN
      END
+DECK,EFFI.
*CMZ :  3.00/00 11/03/2013  15.12.10  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.36/00 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  14.22.46  by  Michael Scheer
*CMZ :  2.16/01 15/06/2000  16.16.24  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  2.13/03 17/12/99  10.44.11  by  Michael Scheer
*CMZ : 00.00/05 29/04/94  20.12.40  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.46  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE EFFI
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SELF.

C--- READS PHOTO YIELD FROM FILE AND APPLIES TO SPECTRUM

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,MYFILES.
+SEQ,CONTRL.
+SEQ,PHYCON.
+seq,sourcef90.
+SEQ,SPECT.
+SEQ,FREQS.
+SEq,observf90.

      INTEGER ISOUR,IOBSV,IFREQ

      DOUBLE PRECISION AEFF

C- ABSORPTION COEFFICIENT (SPLINE INTERPOLATION)

      DO IFREQ=1,NFREQ
          CALL YIELD(IEFFI,FREQ(IFREQ),AEFF,EFFCOM)
          EFF(IFREQ)=AEFF
      ENDDO !IFREQ

      DO ISOUR=1,NSOURCE
      DO IOBSV=1,NOBSV
      DO IFREQ=1,NFREQ

+SELF,IF=-NEWWAVE.
            SPEC(ISOUR,IOBSV,IFREQ)=
     &      SPEC(ISOUR,IOBSV,IFREQ)*EFF(IFREQ)
+SELF,IF=NEWWAVE.
          ILIOBFR=ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1))
            SPEC(ILIOBFR)=
     &      SPEC(ILIOBFR)*EFF(IFREQ)
+SELF.

      ENDDO !IFREQ
      ENDDO !IOBSV
      ENDDO !ISOUR

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &   '     *** SR EFFI CALLED, I.E. SPECTRUM IS GIVEN AS SEEN BY DETECTOR ***'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     FILE WITH PHOTO YIELD:'
      WRITE(LUNGFO,*)'     ',FILEFF
      WRITE(LUNGFO,*)'     COMMENT ON DATA FILE:'
      WRITE(LUNGFO,*)'     ',EFFCOM
      WRITE(LUNGFO,*)

      RETURN
      END
+DECK,efold.
*CMZ :  4.00/07 07/04/2020  08.56.40  by  Michael Scheer
*CMZ :  4.00/04 14/05/2019  10.06.52  by  Michael Scheer
*CMZ :  3.03/02 03/12/2015  13.58.49  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.10  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.52/16 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.52/00 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.51/00 13/05/2004  12.01.48  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  16.27.20  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  2.13/03 12/01/2000  16.31.33  by  Michael Scheer
*CMZ : 00.01/06 01/02/95  16.22.16  by  Michael Scheer
*CMZ : 00.01/04 25/01/95  16.36.51  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  16.19.11  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.49.38  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.43  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE EFOLD
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,OBSERVF90U.
+SEQ,WFOLDF90U.

C--- THE ROUTINE FOLDS THE SPECTRAL FLUXES WITH A GAUSSIAN TO TAKE THE BEAM
C    ENERGY SPREAD INTO ACCOUNT

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,SPECT.
+SEQ,FREQS.
+SEq,wfoldf90.
+SEq,observf90.

      INTEGER kfreq
      INTEGER ICEN,IPINOLD
      REAL*4 F,S0,S1,S2,S3

      INTEGER NFOLDP,kmode,iefoldold
      integer :: iwarn=1
      PARAMETER (NFOLDP=1000)
      DOUBLE PRECISION DF,F3SIG,dnsigma
      DOUBLE PRECISION S0E(NDFREQP),S2E(NDFREQP),S3E(NDFREQP),S1E(NDFREQP)
      DOUBLE PRECISION S0EF(NDFREQP),S2EF(NDFREQP),S3EF(NDFREQP),S1EF(NDFREQP)
      double precision ws1(ndfreqp),ws2(ndfreqp)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SR EFOLD called to perform energy folding'
      WRITE(LUNGFO,*)
     &  '     Beam energy spread (ESPREAD) and number of sigmas:'
      WRITE(LUNGFO,*)'     ',SNGL(ESPREAD),NSIGE
      WRITE(LUNGFO,*)

      IPINOLD=IPIN

      IF (IPIN.NE.0) THEN
          IPIN=1
          ICEN=ICBRILL
      ELSE    !IPIN
          ICEN=ICBRILL
      ENDIF   !IPIN

10    CONTINUE

      IF (IPIN.EQ.1) THEN

        DO kfreq=1,NFREQ
          F=FREQ(kfreq)
          S0=WSTOKES(1,kfreq)
          S1=WSTOKES(2,kfreq)
          S2=WSTOKES(3,kfreq)
          S3=WSTOKES(4,kfreq)
          S0E(kfreq)=S0
          S1E(kfreq)=S1
          S2E(kfreq)=S2
          S3E(kfreq)=S3
        ENDDO !kfreq

      ELSE !IPIN

        DO kfreq=1,NFREQ
          F=FREQ(kfreq)
          IOBFR=ICEN+NOBSV*(kfreq-1)
          S0=STOKES(1,IOBFR)
          S1=STOKES(2,IOBFR)
          S2=STOKES(3,IOBFR)
          S3=STOKES(4,IOBFR)
          S0E(kfreq)=S0
          S1E(kfreq)=S1
          S2E(kfreq)=S2
          S3E(kfreq)=S3
        ENDDO !kfreq

      ENDIF !IPIN

1     continue
      kmode=-1
      DO kfreq=NFREQEM+1,NFREQ-NFREQEP
        DF=FREQ(kfreq)*ESPREAD*2.D0*NSIGE
        F3SIG=FREQ(kfreq)*ESPREAD*2.D0
        IF(FREQ(kfreq)-DF.GE.FREQ(1)
     &      .AND.
     &      FREQ(kfreq)+DF.LE.FREQ(NFREQ)) THEN
          if (iefold.ne.3) then
            CALL EFOLD_GAUSS
     &        (NFREQ,FREQ,S0E,F3SIG,NSIGE,FREQ(kfreq),kmode,S0EF(kfreq))
          else
            call util_fold_gauss_lin(nfreq,freq,s0e,f3sig,
     &        dble(nsige),kfreq,s0ef(kfreq),ws1,ws2)
          endif
          kmode=1
          if (s0ef(kfreq).lt.0.0d0) then
            write(lungfo,*)'*** Warning in EFOLD_GAUSS: Negative value of S0_E found.'
            write(lungfo,*)'*** Probably problems with oszillating splines.'
            write(lungfo,*)'*** Check/change or photon energy range and number of intervals.'
            write(lungfo,*)'*** Switching to IEFOLD=3 ***'
            write(6,*)'*** Warning in EFOLD_GAUSS: Negative value of S0_E found.'
            write(6,*)'*** Probably problems with oszillating splines.'
            write(6,*)'*** Check/change photon energy range and number of intervals.'
            write(6,*)'*** Switching to IEFOLD=3 ***'
            iefold=3
            goto 1
          endif
        ELSE
          S0EF(kfreq)=9.999D-11
        ENDIF
      ENDDO !kfreq

      kmode=-1
      DO kfreq=NFREQEM+1,NFREQ-NFREQEP
        DF=FREQ(kfreq)*ESPREAD*2.D0*NSIGE
        F3SIG=FREQ(kfreq)*ESPREAD*2.D0
        IF(FREQ(kfreq)-DF.GE.FREQ(1)
     &      .AND.
     &      FREQ(kfreq)+DF.LE.FREQ(NFREQ)) THEN
          if (iefold.ne.3) then
            CALL EFOLD_GAUSS
     &        (NFREQ,FREQ,S1E,F3SIG,NSIGE,FREQ(kfreq),kmode,S1EF(kfreq))
          else
            call util_fold_gauss_lin(nfreq,freq,s1e,f3sig,
     &        dble(nsige),kfreq,s1ef(kfreq),ws1,ws2)
          endif
          kmode=1
        ELSE
          S1EF(kfreq)=0.0
        ENDIF
      ENDDO !kfreq

      kmode=-1
      DO kfreq=NFREQEM+1,NFREQ-NFREQEP
        DF=FREQ(kfreq)*ESPREAD*2.D0*NSIGE
        F3SIG=FREQ(kfreq)*ESPREAD*2.D0
        IF(FREQ(kfreq)-DF.GE.FREQ(1)
     &      .AND.
     &      FREQ(kfreq)+DF.LE.FREQ(NFREQ)) THEN
          if (iefold.ne.3) then
            CALL EFOLD_GAUSS
     &        (NFREQ,FREQ,S2E,F3SIG,NSIGE,FREQ(kfreq),kmode,S2EF(kfreq))
          else
            call util_fold_gauss_lin(nfreq,freq,s2e,f3sig,
     &        dble(nsige),kfreq,s2ef(kfreq),ws1,ws2)
          endif
          kmode=1
        ELSE
          S2EF(kfreq)=0.0
        ENDIF
      ENDDO !kfreq

      kmode=-1
      DO kfreq=NFREQEM+1,NFREQ-NFREQEP
        DF=FREQ(kfreq)*ESPREAD*2.D0*NSIGE
        F3SIG=FREQ(kfreq)*ESPREAD*2.D0
        IF(FREQ(kfreq)-DF.GE.FREQ(1)
     &      .AND.
     &      FREQ(kfreq)+DF.LE.FREQ(NFREQ)) THEN
          if (iefold.ne.3) then
            CALL EFOLD_GAUSS
     &        (NFREQ,FREQ,S3E,F3SIG,NSIGE,FREQ(kfreq),kmode,S3EF(kfreq))
          else
            call util_fold_gauss_lin(nfreq,freq,s3e,f3sig,
     &        dble(nsige),kfreq,s3ef(kfreq),ws1,ws2)
          endif
          kmode=1
        ELSE
          S3EF(kfreq)=0.0
        ENDIF
      ENDDO !kfreq

      IF (IPIN.EQ.0) THEN

        DO kfreq=1,NFREQ

          IF (kfreq.GT.NFREQEM.AND.kfreq.LE.NFREQ-NFREQEP) THEN
            WSTOKESE(1,kfreq)=S0EF(kfreq)
            WSTOKESE(2,kfreq)=S1EF(kfreq)
            WSTOKESE(3,kfreq)=S2EF(kfreq)
            WSTOKESE(4,kfreq)=S3EF(kfreq)
          ELSE
            WSTOKESE(1,kfreq)=0.0
            WSTOKESE(2,kfreq)=0.0
            WSTOKESE(3,kfreq)=0.0
            WSTOKESE(4,kfreq)=0.0
          ENDIF

          STOKECE(1,kfreq)=WSTOKESE(1,kfreq)
          STOKECE(2,kfreq)=WSTOKESE(2,kfreq)
          STOKECE(3,kfreq)=WSTOKESE(3,kfreq)
          STOKECE(4,kfreq)=WSTOKESE(4,kFREQ)

          stokesE(1,kfreq)=WSTOKESE(1,kfreq)
          stokesE(2,kfreq)=WSTOKESE(2,kfreq)
          stokesE(3,kfreq)=WSTOKESE(3,kfreq)
          stokesE(4,kfreq)=WSTOKESE(4,kFREQ)

        ENDDO !kfreq

      ELSE IF (IPIN.EQ.1) THEN

        DO kfreq=1,NFREQ

          IF (kfreq.GT.NFREQEM.AND.kfreq.LE.NFREQ-NFREQEP) THEN
            WSTOKESE(1,kfreq)=S0EF(kfreq)
            WSTOKESE(2,kfreq)=S1EF(kfreq)
            WSTOKESE(3,kfreq)=S2EF(kfreq)
            WSTOKESE(4,kfreq)=S3EF(kfreq)
          ELSE
            WSTOKESE(1,kfreq)=0.0
            WSTOKESE(2,kfreq)=0.0
            WSTOKESE(3,kfreq)=0.0
            WSTOKESE(4,kfreq)=0.0
          ENDIF

        ENDDO !kfreq

      ELSE IF (IPIN.EQ.2) THEN

        DO kfreq=1,NFREQ

          IF (kfreq.GT.NFREQEM.AND.kfreq.LE.NFREQ-NFREQEP) THEN
            STOKECE(1,kfreq)=S0EF(kfreq)
            STOKECE(2,kfreq)=S1EF(kfreq)
            STOKECE(3,kfreq)=S2EF(kfreq)
            STOKECE(4,kfreq)=S3EF(kfreq)
          ELSE
            STOKECE(1,kfreq)=0.0
            STOKECE(2,kfreq)=0.0
            STOKECE(3,kfreq)=0.0
            STOKECE(4,kfreq)=0.0
          ENDIF

        ENDDO !kfreq

      ENDIF   !IPIN

      IF (IPIN.EQ.1) THEN
        IPIN=2
        GOTO 10 !JUMP BACK TO RERUN FOR CENTER OF PINHOLE
      ELSE IF (IPIN.EQ.2) THEN
        IPIN=1
      ENDIF

      IF (IFOLD.NE.0) THEN

20      CONTINUE

        IF (IPIN.EQ.1) THEN
          DO kfreq=1,NFREQ
            F=FREQ(kfreq)
            S0=WSTOKESF(1,kfreq)
            S1=WSTOKESF(2,kfreq)
            S2=WSTOKESF(3,kfreq)
            S3=WSTOKESF(4,kfreq)
            S0E(kfreq)=S0
            S1E(kfreq)=S1
            S2E(kfreq)=S2
            S3E(kfreq)=S3
          ENDDO !kfreq
        ELSE    !IPIN
          DO kfreq=1,NFREQ
            F=FREQ(kfreq)
            IOBFR=ICEN+NOBSV*(kfreq-1)
            S0=STOKESF(1,IOBFR)
            S1=STOKESF(2,IOBFR)
            S2=STOKESF(3,IOBFR)
            S3=STOKESF(4,IOBFR)
            S0E(kfreq)=S0
            S1E(kfreq)=S1
            S2E(kfreq)=S2
            S3E(kfreq)=S3
          ENDDO !kfreq
        ENDIF   !IPIN

        kmode=-1
        DO kfreq=NFREQEM+1,NFREQ-NFREQEP
          DF=FREQ(kfreq)*ESPREAD*2.D0*NSIGE
          F3SIG=FREQ(kfreq)*ESPREAD*2.D0
          IF(FREQ(kfreq)-DF.GE.FREQ(1)
     &        .AND.
     &        FREQ(kfreq)+DF.LE.FREQ(NFREQ)) THEN
            if (iefold.ne.3) then
              CALL EFOLD_GAUSS
     &          (NFREQ,FREQ,S0E,F3SIG,NSIGE,FREQ(kfreq),kmode,S0EF(kfreq))
            else
              call util_fold_gauss_lin(nfreq,freq,s0e,f3sig,
     &          dble(nsige),kfreq,s0ef(kfreq),ws1,ws2)
            endif
            kmode=1
          ELSE
            S0EF(kfreq)=9.999D-11
          ENDIF
        ENDDO !kfreq

        kmode=-1
        DO kfreq=NFREQEM+1,NFREQ-NFREQEP
          DF=FREQ(kfreq)*ESPREAD*2.D0*NSIGE
          F3SIG=FREQ(kfreq)*ESPREAD*2.D0
          IF(FREQ(kfreq)-DF.GE.FREQ(1)
     &        .AND.
     &        FREQ(kfreq)+DF.LE.FREQ(NFREQ)) THEN
            if (iefold.ne.3) then
              CALL EFOLD_GAUSS
     &          (NFREQ,FREQ,S1E,F3SIG,NSIGE,FREQ(kfreq),kmode,S1EF(kfreq))
            else
              call util_fold_gauss_lin(nfreq,freq,s1e,f3sig,
     &          dble(nsige),kfreq,s1ef(kfreq),ws1,ws2)
            endif
            kmode=1
          ELSE
            S1EF(kfreq)=0.0
          ENDIF
        ENDDO !kfreq

        kmode=-1
        DO kfreq=NFREQEM+1,NFREQ-NFREQEP
          DF=FREQ(kfreq)*ESPREAD*2.D0*NSIGE
          F3SIG=FREQ(kfreq)*ESPREAD*2.D0
          IF(FREQ(kfreq)-DF.GE.FREQ(1)
     &        .AND.
     &        FREQ(kfreq)+DF.LE.FREQ(NFREQ)) THEN
            if (iefold.ne.3) then
              CALL EFOLD_GAUSS
     &          (NFREQ,FREQ,S2E,F3SIG,NSIGE,FREQ(kfreq),kmode,S2EF(kfreq))
            else
              call util_fold_gauss_lin(nfreq,freq,s2e,f3sig,
     &          dble(nsige),kfreq,s2ef(kfreq),ws1,ws2)
            endif
            kmode=1
          ELSE
            S2EF(kfreq)=0.0
          ENDIF
        ENDDO !kfreq

        kmode=-1
        DO kfreq=NFREQEM+1,NFREQ-NFREQEP
          DF=FREQ(kfreq)*ESPREAD*2.D0*NSIGE
          F3SIG=FREQ(kfreq)*ESPREAD*2.D0
          IF(FREQ(kfreq)-DF.GE.FREQ(1)
     &        .AND.
     &        FREQ(kfreq)+DF.LE.FREQ(NFREQ)) THEN
            if (iefold.ne.3) then
              CALL EFOLD_GAUSS
     &          (NFREQ,FREQ,S3E,F3SIG,NSIGE,FREQ(kfreq),kmode,S3EF(kfreq))
            else
              call util_fold_gauss_lin(nfreq,freq,s3e,f3sig,
     &          dble(nsige),kfreq,s3ef(kfreq),ws1,ws2)
            endif
            kmode=1
          ELSE
            S3EF(kfreq)=0.0
          ENDIF
        ENDDO !kfreq


        IF (IPIN.EQ.1) THEN

          DO kfreq=1,NFREQ

            IF (kfreq.GT.NFREQEM.AND.kfreq.LE.NFREQ-NFREQEP) THEN
              WSTOKESEF(1,kfreq)=S0EF(kfreq)
              WSTOKESEF(2,kfreq)=S1EF(kfreq)
              WSTOKESEF(3,kfreq)=S2EF(kfreq)
              WSTOKESEF(4,kfreq)=S3EF(kfreq)
            ELSE
              WSTOKESEF(1,kfreq)=0.0
              WSTOKESEF(2,kfreq)=0.0
              WSTOKESEF(3,kfreq)=0.0
              WSTOKESEF(4,kfreq)=0.0
            ENDIF

          ENDDO !kfreq

        ELSE IF (IPIN.EQ.2) THEN

          DO kfreq=1,NFREQ

            IF (kfreq.GT.NFREQEM.AND.kfreq.LE.NFREQ-NFREQEP) THEN
              STOKECEF(1,kfreq)=S0EF(kfreq)
              STOKECEF(2,kfreq)=S1EF(kfreq)
              STOKECEF(3,kfreq)=S2EF(kfreq)
              STOKECEF(4,kfreq)=S3EF(kfreq)
            ELSE
              STOKECEF(1,kfreq)=0.0
              STOKECEF(2,kfreq)=0.0
              STOKECEF(3,kfreq)=0.0
              STOKECEF(4,kfreq)=0.0
            ENDIF

          ENDDO !kfreq

        ENDIF   !IPIN

        IF (IPIN.EQ.1) THEN
          IPIN=2
          GOTO 20 !JUMP BACK TO RERUN FOR CENTER OF PINHOLE
        ELSE IF (IPIN.EQ.2) THEN
          IPIN=1
        ENDIF

      ENDIF !IFOLD

      if (ipin.eq.1) CALL EFOLDPIN !20190510

      IPIN=IPINOLD

      RETURN
      END
+DECK,EFOLD_GAUSS.
*CMZ :  4.00/07 05/04/2020  19.23.35  by  Michael Scheer
*CMZ :  4.00/04 14/05/2019  10.42.12  by  Michael Scheer
*CMZ :  3.03/02 03/12/2015  13.58.36  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.63/03 02/05/2008  14.41.00  by  Michael Scheer
*CMZ :  2.52/02 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.51/03 23/06/2004  12.05.57  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  2.14/02 19/04/2000  17.02.45  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  11.45.40  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.09.58  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  16.57.23  by  Michael Scheer
*CMZ :  1.00/00 19/08/97  16.17.52  by  Michael Scheer
*CMZ : 00.01/08 22/06/95  10.12.13  by  Michael Scheer
*CMZ : 00.01/06 14/02/95  10.17.13  by  Michael Scheer
*CMZU: 00.01/04 18/01/95  18.16.43  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  16.21.01  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.49.43  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.46  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE EFOLD_GAUSS(NF,XF,F,SIGMA,NSIGMA,X0,kmode,FG)
+seq,gplhint.

C--- SUBROUTINE TO EVALUATE THE FOLDED FUNCTION FG(X)=INT{F(XF)*G(XF-X),DXF}

C--   INPUT:

C-       NF:   NUMBER OF XF,F-VALUES
C-       XF:   ARRAY OF X-VALUES (MUST BE IN ASCENDING ORDER)
C-       F: ARRAY OF FUNCTION-VALUES
C-       SIGMA:  SIGMA OF GAUSSIAN
C-       NSIGMA: NUMBER OF SIGMAS TO BE CONSIDERED
C-       X0:   FG(X0) IS CALCULATED
C-               X0-NSIGM*SIGMA MUST NOT BE LOWER THAN XF(1)
C-               X0+NSIGM*SIGMA MUST NOT EXCEED XF(NF)
C-       kmode: CONTROL FLAG:
C-             kmode.GE.0: USE VALUES OF LAST CALL TO START WITH
C-             kmode.LT.0: NEW INITIALIZATION

C--   OUTPUT:

C-       FG:   FG(X0) IS CALCULATED


      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,CMPARA.

      INTEGER NF,kmode,MSTEPP,NSTEP,ISTEP,NSIGMA,NLOW,NHIGH
      INTEGER ICOUNT,IL,IH,I,kl,kh

      DOUBLE PRECISION XF(NF),F(NF),SIGMA,X0,FG,XLOW,XHIGH,DXW,G,FWW
      DOUBLE PRECISION XW(NDFREQP),F2(NDFREQP),COEF(NDFREQP),FW(NDFREQP),DR2P1
      DOUBLE PRECISION VS1(NDFREQP),VS2(NDFREQP),VS3(NDFREQP),VS4(NDFREQP)
      DOUBLE PRECISION WS1(NDFREQP),WS2(NDFREQP),WS3(NDFREQP),WS4(NDFREQP)

+SELF,IF=LINUX.
      EXTERNAL FUNCTION DERF
+SELF.

       DOUBLE PRECISION  CH,CL,CH2,CL2,CHCL,CH2CL,CHCL2,XL,XH,YL,YH,H,H61,
     &  XHXL,XH2,XL2,SN,S2,ROOT2,SNR21,DERF,FGH,FGL,R2PI1,DX,X02,S22,
     &  SQPI2,X02S2,X023S2,SR2PI1,RNSIGMA

      DATA ROOT2/1.4142135623731D0/
      DATA R2PI1/0.398942280401433D0/
      DATA DR2P1/0.398942280401433D0/
      DATA SQPI2/1.2533141373155D0/

      save

      IF (NF.GT.NDFREQP) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN EFOLD_GAUSS ***'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED  ***'
      ENDIF

C- SPLINES OF FUNCTION F

      IF (kmode.LT.0) THEN
        CALL util_spline_coef(XF,F,NF,-9999.0d0,-9999.0d0,F2,WS1,WS2,WS3,WS4)
      ENDIF !kmode


      IF (IEFOLD.GT.0) THEN

        IF (kmode.LT.0) THEN
          DO IL=1,NF-1

            IH=IL+1

            XL=XF(IL)
            XH=XF(IH)
            YL=F(IL)
            YH=F(IH)
            CL=F2(IL)
            CH=F2(IH)

            CL2=2.0D0*CL
            CH2=2.0D0*CH
            CHCL=CH-CL
            CHCL2=CH+CL2
            CH2CL=CH2+CL
            XHXL=XH*XL
            XH2=XH*XH
            XL2=XL*XL

            H=XH-XL

            IF (H.LE.0.0D0) THEN
              PRINT*,
     &          '*** ERROR SR EFOLD_GAUSS:'
              PRINT*,
     &          '*** E-ARRAY NOT IN ASCENDING ORDER'
              STOP
            ENDIF

            H61=1.0D0/(6.0D0*H)

            WS1(IL)=((CHCL2*XH-CH2CL*XL)*XHXL+6.0D0*(XH*YL-XL*YH))*H61
            WS2(IL)=((CH2-CL2)*XHXL-CHCL2*XH2+CH2CL*XL2+6.0D0*(YH-YL))*H61
            WS3(IL)=(-CH*XL+CL*XH)/(2.0D0*H)
            WS4(IL)=CHCL*H61

          ENDDO !NF-1
        ENDIF !kmode

        if (kmode.lt.0) then
          nlow=1
        endif

        if (x0.le.xf(nlow)) then
          nlow=1
        endif

        I=-1
        DO IL=nlow,nf
          IF (X0.EQ.XF(IL)) THEN
            I=IL
            nlow=il
            GOTO 1
          ENDIF
        ENDDO

1       IF (I.EQ.-1) THEN
          PRINT*,
     &      '*** ERROR SR EFOLD_GAUSS:'
          PRINT*,
     &      '*** BAD ENERGY FOR FOLDING'
          PRINT*,X0
          STOP
        ENDIF

        FG=0.0D0

        RNSIGMA=NSIGMA
        SN=RNSIGMA*SIGMA
        S2=SIGMA*SIGMA
        S22=2.0D0*S2
        SNR21=1.0D0/(ROOT2*SIGMA)
        SR2PI1=R2PI1/SIGMA

        X02=X0*X0
        X02S2=S2+X02
        X023S2=S22+X02S2

        IF (X0-SN.GE.XF(1).AND.X0+SN.LE.XF(NF)) THEN

C UPPER BRANCH

          DO IL=I,NF-1

            IH=IL+1

            XL=XF(IL)
            XH=XF(IH)

            IF (XL-X0.LE.SN) THEN

              IF (XH-X0.GT.SN) XH=X0+SN

              DX=XH-X0

              FGH=
     &          SR2PI1*(
     &          -EXP(-DX**2/S22)*S2*(
     &          WS2(IL)+WS3(IL)*(XH+X0)+WS4(IL)*(S22+XH**2+XH*X0+X02))
     &          +SQPI2*SIGMA*(
     &          WS1(IL)+WS3(IL)*X02S2
     &          +X0*(WS2(IL)+WS4(IL)*X023S2))*
     &          DERF(DX*SNR21))

              DX=XL-X0

              FGL=
     &          SR2PI1*(
     &          -EXP(-DX**2/S22)*S2*(
     &          WS2(IL)+WS3(IL)*(XL+X0)+WS4(IL)*(S22+XL**2+XL*X0+X02))
     &          +SQPI2*SIGMA*(
     &          WS1(IL)+WS3(IL)*X02S2
     &          +X0*(WS2(IL)+WS4(IL)*X023S2))*
     &          DERF(DX*SNR21))

              FG=FG+FGH-FGL

            ELSE
              GOTO 81
            ENDIF ! (X-SN.GE.XF(1).AND.X+SN.LE.XF(NF))

          ENDDO !IL

 81       CONTINUE

C LOWER BRANCH

          DO IH=I,2,-1

            IL=IH-1

            XL=XF(IL)
            XH=XF(IH)

            IF (X0-XH.LE.SN) THEN

              IF (X0-XL.GT.SN) XL=X0-SN

              DX=XH-X0

              FGH=
     &          SR2PI1*(
     &          -EXP(-DX**2/S22)*S2*(
     &          WS2(IL)+WS3(IL)*(XH+X0)+WS4(IL)*(S22+XH**2+XH*X0+X02))
     &          +SQPI2*SIGMA*(
     &          WS1(IL)+WS3(IL)*X02S2
     &          +X0*(WS2(IL)+WS4(IL)*X023S2))*
     &          DERF(DX*SNR21))

              DX=XL-X0

              FGL=
     &          SR2PI1*(
     &          -EXP(-DX**2/S22)*S2*(
     &          WS2(IL)+WS3(IL)*(XL+X0)+WS4(IL)*(S22+XL**2+XL*X0+X02))
     &          +SQPI2*SIGMA*(
     &          WS1(IL)+WS3(IL)*X02S2
     &          +X0*(WS2(IL)+WS4(IL)*X023S2))*
     &          DERF(DX*SNR21))

              FG=FG+FGH-FGL

            ELSE
              GOTO 82
            ENDIF ! (X-SN.GE.XF(1).AND.X+SN.LE.XF(NF))

          ENDDO !IH
 82       CONTINUE

        ELSE IF (X0+SN.GT.XF(NF)) THEN
          GOTO 88
        ENDIF ! (X-SN.GE.XF(1).AND.X+SN.LE.XF(NF))
 88     CONTINUE

      ELSE !IEFOLD

C OLD VERSION

C-- SET UP FOLDING BUFFER

      XLOW =X0-NSIGMA*SIGMA
      XHIGH=X0+NSIGMA*SIGMA

      IF (DABS(XLOW-XHIGH)/XHIGH.LT.1.D-6) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN EFOLD_GAUSS ***'
        WRITE(LUNGFO,*)'DABS(XLOW-XHIGH)/XHIGH.LT.1.D-LUNGFO'
        WRITE(LUNGFO,*)'ESPREAD TOO SMALL, CHECK INPUT FILE'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN EFOLD_GAUSS ***'
        WRITE(6,*)'DABS(XLOW-XHIGH)/XHIGH.LT.1.D-6'
        WRITE(6,*)'ESPREAD TOO SMALL, CHECK INPUT FILE'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED  ***'
      ENDIF

      IF (XLOW.LT.XF(1)) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN EFOLD_GAUSS ***'
        WRITE(LUNGFO,*)'X0 IS LOWER THEN XF(1)'
        WRITE(LUNGFO,*)'CHECK INPUT TO ROUTINE'
        WRITE(LUNGFO,*)'X0,XF(1):',X0,XF(1)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN EFOLD_GAUSS ***'
        WRITE(6,*)'X0 IS LOWER THEN XF(1)'
        WRITE(6,*)'CHECK INPUT TO ROUTINE'
        WRITE(6,*)'X0,XF(1):',X0,XF(1)
        STOP '*** PROGRAM WAVE ABORTED  ***'
      ENDIF

      IF (XHIGH.GT.XF(NF)) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN EFOLD_GAUSS ***'
        WRITE(LUNGFO,*)'X0 IS GREATER THEN XF(NF)'
        WRITE(LUNGFO,*)'CHECK INPUT TO ROUTINE'
        WRITE(LUNGFO,*)'X0,XF(NF):',X0,XF(NF)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN EFOLD_GAUSS ***'
        WRITE(6,*)'X0 IS GREATER THEN XF(NF)'
        WRITE(6,*)'CHECK INPUT TO ROUTINE'
        WRITE(6,*)'X0,XF(NF):',X0,XF(NF)
        STOP '*** PROGRAM WAVE ABORTED  ***'
      ENDIF


C- NUMBER OF POINTS WITHIN FOLDING INTERVALL

      if (kmode.lt.0) then
        nlow=1
        nhigh=nf
      endif

      if (x0.le.xf(nlow)) then
        nlow=1
      endif

      kl=nlow

      DO ISTEP=kl,NF
        IF (XF(ISTEP).LT.XLOW) THEN
          NLOW=ISTEP
        ELSE
          GOTO 100
        ENDIF
      ENDDO
100   CONTINUE

      nhigh=nhigh+1
      if (nhigh.gt.nf) then
        nhigh=nf
      endif

      kh=nhigh
      DO ISTEP=kh,1,-1
        IF (XF(ISTEP).GT.XHIGH) THEN
          NHIGH=ISTEP
        ELSE
          GOTO 101
        ENDIF
      ENDDO
101   CONTINUE

      MSTEPP=(NSIGMA*5)/2*2+1
      NSTEP=MAX(NHIGH-NLOW,MSTEPP)

      XW(1)=XLOW
      DXW=(XHIGH-XLOW)/(NSTEP-1)
      DO ISTEP=2,NSTEP
        XW(ISTEP)=XW(ISTEP-1)+DXW
      ENDDO

CERROR 19.8.97      DO ISTEP=1,NSTEP-1
      DO ISTEP=1,NSTEP
        IF (XW(ISTEP).GE.XF(1).AND.XW(ISTEP).LE.XF(NF)) THEN
          CALL WAVE_SPLINE_INTER(XF,F,F2,NF,XW(ISTEP),FWW,-1,ICOUNT)
          G=DEXP(-0.5D0*((XW(ISTEP)-X0)/SIGMA)**2)*DR2P1/SIGMA
          FW(ISTEP)=FWW*G
C         WRITE(8,*)XW(ISTEP),FWW,G,FW(ISTEP)
        ELSE
          FW(ISTEP)=0.0d0
        ENDIF
      ENDDO

C- ACTUAL INTEGRATION

      CALL WAVE_SPLINE_INTEGRAL(XW,FW,NSTEP,FG,COEF,VS1,VS2,VS3,VS4)

C     CALL WAVE_SIMPSON(NSTEP,XW,FW,WS1(1))
C     IF ( (WS1(1)+FG).NE.0.D0
C     & .AND.DABS((WS1(1)-FG)/(WS1(1)+FG) ).GT.0.02
C     &) THEN
C        WRITE(6,*)
C        WRITE(6,*)'SPLINE RESULTAT:',FG
C        WRITE(6,*)'SIMPSON RESULTAT:',WS1(1)
C        WRITE(6,*)
C     ENDIF

      ENDIF !IEFOLD

      RETURN
      END
+DECK,EFUN.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.49.48  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.44  by  Michael Scheer
*-- Author : Michael Scheer
+seq,gplhint.
      DOUBLE PRECISION FUNCTION EFUN(CD,C5,C2,DI2,DI5,E)
          IMPLICIT NONE
          DOUBLE PRECISION CD,C5,C2,DI2,DI5,E

          EFUN=C5+(DI5-CD*DI2)*E**5-CD*C2*E**3

          RETURN
          END
+DECK,EFUNP.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.15/00 12/05/2010  13.34.28  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.37.33  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.45  by  Michael Scheer
*-- Author : Michael Scheer
+seq,gplhint.
C******************************************************************

      DOUBLE PRECISION FUNCTION EFUNP(R,B3,T0,TK,E)

          IMPLICIT NONE
+SEQ,PHYCON.
          DOUBLE PRECISION R,B3,T0,TK,E

          EFUNP=E**5+(CLIGHT1*1.D-9)**3*R**2/(2.*PI1)*B3*E**2-T0/TK

          RETURN
      END
+DECK,EMIN0.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  16.22.05  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.50.01  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.44  by  Michael Scheer
*-- Author : Michael Scheer
C****************************************************************
      SUBROUTINE EMIN0(CD,C5,C2,DI2,DI5,ENERG,EMINEM,EMIN,IOK)
C****************************************************************
+seq,gplhint.
C     LOEST GLEICHUNGSSYSTEM FUER MINIMALES E
          IMPLICIT NONE
          DOUBLE PRECISION CD,C5,C2,DI2,DI5,E,DEFUN,EFUN,EMINEM,EMIN,ENERG
          DOUBLE PRECISION A,B,EN
          INTEGER I,IOK

      ENERG=ENERG

C--- NEWTON-VERFAHREN

      IOK=1
      E=EMINEM
      DO I=1,100
          A=DEFUN(CD,C5,C2,DI2,DI5,E)
          B=EFUN(CD,C5,C2,DI2,DI5,E)-A*E
          EN=-B/A
          IF(DABS((EN-E)/EN).LT.1.D-10) GOTO 100
          E=EN
          IF(E.GT.1.D6) THEN  !FAENGT OVERFLOW AB
         IOK=0
              RETURN
          ENDIF
          END DO
      IOK=0
      RETURN
C     STOP '*** S/R EMIN0: KEINE LOESUNG GEFUNDEN ***'
100   CONTINUE
      EMIN=EN
      IF(EMIN.LT.0.) IOK=0
      RETURN
      END
+DECK,EMINP.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.15/00 15/03/2007  11.13.54  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.36.44  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.45  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE EMINP(R,B3,T0,TK,EMIN)
+seq,gplhint.

C     SOLVES EQUATION TO DETERMINE MINIMUM ENERGY FOR GIVEN POLARIZATION LEVEL
C     LOGBUCH SEITE 189

          IMPLICIT NONE

+SEQ,CONTRL.

          DOUBLE PRECISION R,B3,T0,TK,EMIN,E
          DOUBLE PRECISION A,B,EN,DEFUNP,EFUNP
          INTEGER I

C--- ALGORITHM OF NEWTON X(N+1)=X(N)-F(X(N))/F'(X(N))

      E=1.D0
      DO I=1,100
          A=DEFUNP(R,B3,T0,TK,E)
          B=EFUNP(R,B3,T0,TK,E)-A*E
          EN=-B/A
          IF(DABS((EN-E)/EN).LT.1.D-10) GOTO 100
          E=EN
          END DO

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'*** WARNING SR EMINP ***'
      WRITE(LUNGFO,*)'NEWTON ALGORITHM FAILED TO DETERMINE MINIMUM ENERGY'
      WRITE(LUNGFO,*)'CHECK RESULTS CAREFULLY'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

100   CONTINUE

      EMIN=EN

      RETURN
      END
+DECK,EMIT.
*CMZ :  2.52/15 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  10.23.48  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.50.09  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.46  by  Michael Scheer
*-- Author : Michael Scheer
C****************************************************************
      SUBROUTINE EMIT(B0,XLAM0,FASYM,
     &         E,RHODIP,TAU0E5,BETA0,DI2RING,DI5RING,
     &                  EMIRING,EMI,EMIOPT,EMITOT,EMITOPT,B3AWLS,
     &         F,F0,BETOPT,TAU,TAU1GEV,POLLEV,POLLV1G,ZMAX,
     &                  DI2,DI5,DI5OPT,LUN,
     &                  DISP0,DISPOPT,EMI2OPT,EMIT2OPT,BET2OPT,BETUNI,
     &                  BET2UNI,DI52OPT)
C****************************************************************
+seq,gplhint.

C CALCULATES APPROXIMATELY EMITTANCE EFFECTS OF AN ASYMMETRIC WLS

C INPUT: B0,XLAM0,FASYM,E,RHODIP,TAU0E5,BETA0,DI2RING,DI5RING,LUN

      IMPLICIT NONE

      DOUBLE PRECISION B0,XLAM0,FASYM                !INPUT
      DOUBLE PRECISION GAMMA,RHODIP,TAU0E5,BETA0,DI2RING,DI5RING    !INPUT
      DOUBLE PRECISION EMI,EMIOPT,EMITOT,EMITOPT,B3RING,B3RG1G      !OUTPUT

      DOUBLE PRECISION E,RHO0,RHO01,XL
      DOUBLE PRECISION F0,F,FN,BETOPT,FBET,PHI0,PHI,PHIN,PHIMAX
      DOUBLE PRECISION DI2,DI5,DI5OPT,DI2TOT,DI5TOT,DI5TOPT,EMIRING
      DOUBLE PRECISION XK,B3WLS,B3AWLS,POLFAC,POLFC1G,TAU,TAU0,TAU1GEV
      DOUBLE PRECISION POLLEV,POLLV1G,ZMAX
      DOUBLE PRECISION XHOMK,DBHOM,XKK
      DOUBLE PRECISION FBETFUN,F0FNFUN,F2,F20,F2BET,DI5T2OPT,DOPTFUN
     &                ,DISP0,DISPOPT,EMI2OPT,EMIT2OPT,BET2OPT,BETUNI,
     &                 BET2UNI,DI52OPT

      INTEGER LUN

+SEQ,PHYCON.

      DATA DBHOM/1.D-4/

      GAMMA=E/EMASSG1
      RHO01=CLIGHT1*1.D-9*B0/E
      RHO0=1./RHO01
      PHI0=XLAM0/RHO0
      XL=XLAM0/2.*(1.+FASYM)
      XKK=2.* PI1/XLAM0
      XHOMK=DSQRT(2.*DBHOM)/XKK
      PHIN=DSQRT(((FASYM+1.)**2/8./FASYM))
      FN=PHIN**3

      F=F0FNFUN(FASYM,DISP0,PHI0,RHO0)
      F0=F/FN
      FBET=FBETFUN(FASYM,DISP0,PHI0,RHO0)
      BETOPT=FBET*XLAM0
      PHI=PHIN*PHI0  !NUR FUER OUTPUT
      DI2=XLAM0/4./RHO0**2*(1.+1./FASYM)
      EMIRING=CQ1*GAMMA**2*DI5RING/DI2RING

      DISPOPT=DOPTFUN(FASYM,PHI0,RHO0)
      F2=F0FNFUN(FASYM,DISPOPT,PHI0,RHO0)
      F20=F2/FN
      F2BET=FBETFUN(FASYM,DISPOPT,PHI0,RHO0)
      BET2OPT=F2BET*XLAM0

      DI5OPT=F*PHI0**3*DI2
      EMIOPT=CQ1*GAMMA**2*DI5OPT/DI2
      EMI=EMIOPT *  0.5*(BETA0/BETOPT+BETOPT/BETA0)
      DI5=EMI/GAMMA**2/CQ1*DI2

      DI2TOT=DI2+DI2RING
      DI5TOT=DI5+DI5RING
      DI5TOPT=DI5OPT+DI5RING

      EMITOPT=CQ1*GAMMA**2*DI5TOPT/DI2TOT
      EMITOT =CQ1*GAMMA**2* DI5TOT/DI2TOT

      DI52OPT=F2*PHI0**3*DI2
      EMI2OPT=CQ1*GAMMA**2*DI52OPT/DI2
      DI5T2OPT=DI52OPT+DI5RING
      EMIT2OPT=CQ1*GAMMA**2*DI5T2OPT/DI2TOT

      BETUNI=-9999.

      IF(DI5OPT/DI2.LT.DI5RING/DI2RING)
     &   BETUNI=(BETOPT*(DSQRT(DI2**2*DI5RING**2-DI5OPT**2*DI2RING
     . **2)+DI2*DI5RING))/(DI5OPT*DI2RING)

      BET2UNI=-9999.

      IF(DI52OPT/DI2.LT.DI5RING/DI2RING)
     &   BET2UNI=(BET2OPT*(DSQRT(DI2**2*DI5RING**2-DI52OPT**2*DI2RING
     . **2)+DI2*DI5RING))/(DI52OPT*DI2RING)

C--- INFLUENCE ON BEAM POLARISATION TIME AND LEVEL

      XK=2.*PI1/XLAM0
      B3WLS=4./3.*B0**3/XK*(1-1./FASYM**2)
      B3AWLS=4./3.*DABS(B0)**3/XK*(1+1./FASYM**2)

      B3RING=2.*PI1*RHODIP*(E/RHODIP/(CLIGHT1*1.D-9))**3
      B3RG1G=2.*PI1*RHODIP*(1./RHODIP/(CLIGHT1*1.D-9))**3
      POLFAC=1.+B3AWLS/B3RING
      POLFC1G=1.+B3AWLS/B3RG1G
      TAU0=TAU0E5/E**5
      TAU=TAU0/POLFAC
      TAU1GEV=TAU0E5/POLFC1G
      POLLEV=POL1CON1*(B3WLS+B3RING)/(B3AWLS+B3RING)
      POLLV1G=POL1CON1*(B3WLS+B3RG1G)/(B3AWLS+B3RG1G)

C--- MAX. DISPLACEMENT AND DEFLECTION

      PHIMAX=PHI0/(2.*PI1)
      ZMAX=1./(16.*PI1)*XLAM0**2/RHO0*
     &      (FASYM+4./PI1) !010891

      IF(LUN.EQ.0) RETURN

C     IF(LUN.NE.6) OPEN(UNIT=LUN,FILE='EMIT.DAT',STATUS='NEW')

      WRITE(LUN,*)
      WRITE(LUN,*) '     SR EMIT:'
      WRITE(LUN,*) '     ========='
      WRITE(LUN,*)
      WRITE(LUN,*)
      WRITE(LUN,*)'     Results from analytical ansatz for asymmetric WLS:'
      WRITE(LUN,*)'     --------------------------------------------------'
      WRITE(LUN,*)
     &'     (only correct if orbit is planar, WLS has no transversal gradient,'
      WRITE(LUN,*)
     &'     WLS is symmetric with respect to origin of coordinate system,'
      WRITE(LUN,*)
     &'     centered in the straight section, (VZ/VX)**2 << 1,'
      WRITE(LUN,*)
     &'     and derivation of external dispersion vanishes outside WLS)'
      WRITE(LUN,*)
      WRITE(LUN,*)
     &'     Beta function at WLS center, I5(WLS), I5/I2 (WLS):'
      WRITE(LUN,*)'     ',SNGL(BETA0),SNGL(DI5),SNGL(DI5/DI2)
      WRITE(LUN,*)
      WRITE(LUN,*)'     Total emittance change:',SNGL(EMITOT/EMIRING)
      WRITE(LUN,*)
      WRITE(LUN,*)
     &'     optimum beta function, corresponding I5(WLS) and total emittance change'
      WRITE(LUN,*)
     &'     for actual external dispersion:'
      WRITE(LUN,*)'     ',SNGL(BETOPT),SNGL(DI5OPT),SNGL(EMITOPT/EMIRING)
      WRITE(LUN,*)
      WRITE(LUN,*)'     optimum external dispersion:',SNGL(DISPOPT)
      WRITE(LUN,*)
     &'     optimum beta function, corresponding I5(WLS) and total emittance change'
      WRITE(LUN,*)
     &'     for optimum external dispersion:'
         WRITE(LUN,*)'     ',SNGL(BET2OPT),SNGL(EMI2OPT/CQ1/GAMMA**2)
     &                     ,SNGL(EMIT2OPT/EMIRING)
      WRITE(LUN,*)
      WRITE(LUN,*)'     neutral beta function:             ',SNGL(BETUNI)
      WRITE(LUN,*)'     neutral beta function for opt. eta:',SNGL(BET2UNI)
      WRITE(LUN,*)

C     IF (LUN.NE.6) CLOSE(LUN)

      RETURN
      END
+DECK,ERZANA.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  16.23.06  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.50.13  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.12  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE ERZANA(OPSTARTX,OPENDX,
     &                  OPNX,OPNY,OPNZ,
     &                  OPNFX,OPNFY,OPNFZ,
     &                  ZI,ZPI,YI,YPI,ZF,ZPF,YF,YPF,
     &                  BXI,BYI,BZI,BXF,BYF,BZF,
     &                  AXI,AYI,AZI,AXF,AYF,AZF)
+seq,gplhint.

      IMPLICIT NONE

      INTEGER ICAL

      DOUBLE PRECISION ZI,ZPI,ZF,ZPF,YI,YPI,YF,YPF
     &        ,OPSTARTX,OPENDX,OPNX,OPNY,OPNZ,OPNFX,OPNFY,OPNFZ
     &        ,BXI,BYI,BZI,BXF,BYF,BZF
     &        ,AXI,AYI,AZI,AXF,AYF,AZF

      DATA ICAL/0/

      IF (ICAL.EQ.0) THEN

          OPSTARTX=0.
          OPENDX=1.

          OPNX=1.
          OPNY=0.
          OPNZ=0.

          OPNFX=1.
          OPNFY=0.
          OPNFZ=0.

          ICAL=1

      ENDIF

      BXI=0.
      BYI=0.
      BZI=0.

      BXF=0.
      BYF=0.
      BZF=0.

      AXI=0.
      AYI=0.
      AZI=0.

      AXF=0.
      AYF=0.
      AZF=0.

      ZF=ZI+ZPI
      ZPF=ZPI

      YF=YI+YPI
      YPF=YPI

      RETURN
      END
+DECK,ERZFUN.
*CMZ :  3.00/00 11/03/2013  10.38.00  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.61/00 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.16/08 01/11/2000  18.41.44  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ : 00.01/10 03/09/96  15.06.58  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  16.24.37  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.50.18  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.18  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE ERZFUN  (GAMMA,ZI,BXI,BYI,BZI,BXF,BYF,BZF,
     &                     AXI,AYI,AZI,AXF,AYF,AZF,XI,XPI,YI,YPI,
     &            XF,XPF,YF,YPF,X0,XF0)
+seq,gplhint.


c     The subroutine calculates the phase space coordinates according
c     to the coefficients of the generating function on the data file
c     WAVE_ERZFUN.IN. The indices I,J,K,L of the coefficients A(I,J,K,L)
c     are considered as mathematical indices rather than FORTRAN
c     array indices.

c     INPUT: XI,XPI,YI,YPI,AXI,AYI
c     OUTPUT:XI,XPI,YI,YPI,XF,XPF,YF,YPF,AXI,AYI;
c              i.e. the input is overwritten !!

c     INPUT-FILE: WAVE_ERZFUN.IN
c     LUN=LIN


      IMPLICIT NONE

      CHARACTER(65) TRANCODE

      INTEGER LIN,ICAL,I,J,K,L,IDUM,nkoef

+SEQ,GENFUN.
+SEQ,CONTRL.
+SEQ,PHYCON.

      DOUBLE PRECISION A(NORDNG+1,NORDNG+1,NORDNG+1,NORDNG+1),PXF,PYF,PXI,PYI,
     &         BRHO,PEL,GAMMA
     &        ,ZI,AXI,AYI,AXF,AYF,BXI,BYI,BXF,BYF
     &        , XI,XPI,YI,YPI,XF,XPF,YF,YPF,XII,PXFJ,YIK,PYFL,DSQ1,
     &          BZI,AZI,AZF,BZF,AX0,AY0,AZ0,AXF0,AYF0,AZF0,X0,XF0
     &        ,BX0,BY0,BZ0,BXF0,BYF0,BZF0,DUM

      DATA LIN/20/
      DATA ICAL/0/

      IF (ICAL.NE.-1) THEN

          PEL=EMASSE1*DSQRT( (GAMMA+1.D0)*(GAMMA-1.D0) )
          BRHO=PEL/CLIGHT1 !ABSOLUTE VALUE

          DO I=0,NORDNG
          DO J=0,NORDNG
          DO K=0,NORDNG
          DO L=0,NORDNG

         A(I+1,J+1,K+1,L+1)=0.D0

          ENDDO
          ENDDO
          ENDDO
          ENDDO

          OPEN(UNIT=LIN,FILE='wave_erzfun.in',FORM='FORMATTED',STATUS='OLD')

          READ(LIN,'(1A65)')TRANCODE
          read(lin,*)idum
          read(lin,*)dum
          read(lin,*)dum
          read(lin,*)dum
          read(lin,*)dum
          read(lin,*)dum
          read(lin,*)dum
          read(lin,*)dum
          read(lin,*)dum
          read(lin,*)dum
          read(lin,*)dum
          read(lin,*)dum
          read(lin,*)dum

          DO WHILE (.TRUE.)
               READ (LIN,*,END=99) I,J,K,L,A(I+1,J+1,K+1,L+1)
          END DO

99        CLOSE(LIN)

          IF ( A(2,1,1,1).NE.0. .OR. A(1,2,1,1).NE.0. .OR. A(1,1,2,1)
     &           .NE.0. .OR. A(1,1,1,2).NE.0.) THEN

           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
     &       '     ***  ERZFUN: CLOSED ORBIT SET TO ZERO ***'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*) '***  ERZFUN: CLOSED ORBIT SET TO ZERO ***'
           WRITE(6,*)

           A(2,1,1,1)=0.
           A(1,2,1,1)=0.
           A(1,1,2,1)=0.
           A(1,1,1,2)=0.

           ENDIF

           CALL MYBFELD(X0,0.D0,0.D0,BXF0,BYF0,BZF0,AXF0,AYF0,AZF0)
           CALL MYBFELD(XF0,0.D0,0.D0,BX0,BY0,BZ0,AX0,AY0,AZ0)

           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'      ERZFUN called: Code on file wave_erzfun.in:'
           WRITE(LUNGFO,*)'      ',TRANCODE
           WRITE(LUNGFO,*)

           ICAL=-1

         ENDIF

C--- NON-CANONICAL VARIABLES, THE

      XPF=XPI
      YPF=YPI

C--- CANONICAL VARIABLES

      BXF=BXI
      BYF=BYI
      BZF=BZI

      AXF=AXI-AX0
      AYF=AYI-AY0
      AZF=AZI-AZ0

      DSQ1=1.D0/DSQRT(1.D0+XPI*XPI+YPI*YPI)

C--- THE VECTOR POTENTIAL IS MORE OR LESS ARBITRARY BUT PXF,AZF AND XPF
C    MUST BE CONSISTENT

      PXF=-AZF/BRHO+XPI*DSQ1
      PYF=-AYF/BRHO+YPI*DSQ1

      XF=0.D0
      DO I=0,NORDNG
          DO J=1,NORDNG
         DO K=0,NORDNG
             DO L=0,NORDNG

      IF( I+J+K+L .LE. NORDNG ) THEN

         IF(I.EQ.0 .AND. XI.EQ. 0.D0)  THEN
            XII=1.D0
         ELSE
            XII=XI**I
         ENDIF
         IF(J-1.EQ.0 .AND. PXF.EQ. 0.D0)  THEN
            PXFJ=1.D0
         ELSE
            PXFJ=PXF**(J-1)
         ENDIF
         IF(K.EQ.0 .AND. YI.EQ.0.D0) THEN
            YIK=1.D0
         ELSE
            YIK=YI**K
         ENDIF
         IF(L.EQ.0.AND.PYF.EQ.0.D0) THEN
            PYFL=1.D0
         ELSE
            PYFL=PYF**L
         ENDIF

      XF = XF +
     &      J * A(I+1,J+1,K+1,L+1) *
     &      XII * PXFJ * YIK * PYFL
      ENDIF
             END DO
         END DO
          END DO
      END DO

      PXI=0.D0
      DO I=1,NORDNG
          DO J=0,NORDNG
         DO K=0,NORDNG
             DO L=0,NORDNG

      IF( I+J+K+L .LE. NORDNG ) THEN

         IF(I-1.EQ.0 .AND. XI.EQ. 0.D0)   THEN
            XII=1.D0
         ELSE
            XII=XI**(I-1)
         ENDIF
         IF(J.EQ.0 .AND. PXF.EQ. 0.D0)    THEN
            PXFJ=1.D0
         ELSE
            PXFJ=PXF**J
         ENDIF
         IF(K.EQ.0 .AND. YI.EQ.0.D0) THEN
            YIK=1.D0
         ELSE
            YIK=YI**K
         ENDIF
         IF(L.EQ.0.AND.PYF.EQ.0.D0) THEN
            PYFL=1.D0
         ELSE
            PYFL=PYF**L
         ENDIF

      PXI = PXI +
     &      I * A(I+1,J+1,K+1,L+1) *
     &      XII * PXFJ * YIK * PYFL
      ENDIF
             END DO
         END DO
          END DO
      END DO

      YF=0.D0
      DO I=0,NORDNG
          DO J=0,NORDNG
         DO K=0,NORDNG
             DO L=1,NORDNG

      IF( I+J+K+L .LE. NORDNG ) THEN

         IF(I.EQ.0 .AND. XI.EQ. 0.D0)  THEN
            XII=1.D0
         ELSE
            XII=XI**I
         ENDIF
         IF(J.EQ.0 .AND. PXF.EQ. 0.D0)    THEN
            PXFJ=1.D0
         ELSE
            PXFJ=PXF**J
         ENDIF
         IF(K.EQ.0 .AND. YI.EQ.0.D0) THEN
            YIK=1.D0
         ELSE
            YIK=YI**K
         ENDIF
         IF(L-1.EQ.0.AND.PYF.EQ.0.D0) THEN
            PYFL=1.D0
         ELSE
            PYFL=PYF**(L-1)
         ENDIF

      YF = YF +
     &      L * A(I+1,J+1,K+1,L+1) *
     &      XII * PXFJ * YIK * PYFL
      ENDIF
             END DO
         END DO
          END DO
      END DO

      PYI=0.D0
      DO I=0,NORDNG
          DO J=0,NORDNG
         DO K=1,NORDNG
             DO L=0,NORDNG
      IF( I+J+K+L .LE. NORDNG ) THEN

         IF(I.EQ.0 .AND. XI.EQ. 0.D0)  THEN
            XII=1.D0
         ELSE
            XII=XI**I
         ENDIF
         IF(J.EQ.0 .AND. PXF.EQ. 0.D0)    THEN
            PXFJ=1.D0
         ELSE
            PXFJ=PXF**J
         ENDIF
         IF(K-1.EQ.0 .AND. YI.EQ.0.D0) THEN
            YIK=1.D0
         ELSE
            YIK=YI**(K-1)
         ENDIF
         IF(L.EQ.0.AND.PYF.EQ.0.D0) THEN
            PYFL=1.D0
         ELSE
            PYFL=PYF**L
         ENDIF

      PYI = PYI +
     &      K * A(I+1,J+1,K+1,L+1) *
     &      XII * PXFJ * YIK * PYFL
      ENDIF
             END DO
         END DO
          END DO
      END DO

C--- TAKE CHANGE OF COORDINATES INTO ACCOUNT IN THE CALLING SEQUENCE

        CALL MYBFELD(ZI,YF,XF,BXI,BYI,BZI,AXI,AYI,AZI)

      AXI=AXI-AXF0
      AYI=AYI-AYF0
      AZI=AZI-AZF0

      DSQ1=1.D0-(PXI+AZI/BRHO)**2-(PYI+AYI/BRHO)**2

      IF (DSQ1.LE.0.) THEN

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     VECTOR POTENTIAL OR COEFFICIENTS CRAZY'
      WRITE(LUNGFO,*)'     1.D0-(PXI+AZI/BRHO)**2-(PYI+AYI/BRHO)**2 .LE.0'
      WRITE(LUNGFO,*)'     CHECK INPUT TO WAVE'
      WRITE(LUNGFO,*)

      WRITE(6,*)'     *** ERROR IN ERZFUN ***'
      WRITE(6,*)'     VECTOR POTENTIAL OR COEFFICIENTS CRAZY'
      WRITE(6,*)'     1.D0-(PXI+AZI/BRHO)**2-(PYI+AYI/BRHO)**2 .LE.0'
      WRITE(6,*)'     CHECK INPUT TO WAVE'
      STOP

      ENDIF

      DSQ1=1.D0/DSQRT(DSQ1)

C--- THE VECTOR POTENTIAL IS MORE OR LESS ARBITRARY BUT PXI,AZI AND XPI
C    MUST BE CONSISTENT

      XPI=(PXI+AZI/BRHO)*DSQ1
      YPI=(PYI+AYI/BRHO)*DSQ1

      RETURN
      END
+DECK,ERZTRA.
*CMZ :  3.00/00 11/03/2013  10.37.07  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.50.22  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.54  by  Michael Scheer
*-- Author : Michael Scheer
C****************************************************************
      SUBROUTINE ERZTRA (XI,PXF,YI,PYF,   XF,PXI,YF,PYI)
C****************************************************************
+seq,gplhint.
C
C FUNCTIONAL DESCRIPTION:
C
C     CALCULATES CANONICAL COORDINATES AND MOMENTA ACCORDING TO
C     COEFFICIENTS ADUM (I,J,K,L) OF GENERATING FUNCTION
C
C     INPUT: XI,PXF,YI,PYF, ADUM VIA COMMOM/AKO/
C     OUTPUT:XF,PXI,YF,PYI
C
      IMPLICIT NONE

      INTEGER I,J,K,L,NORD,NKOEF

+SEQ,GENFUN.

      DOUBLE PRECISION  XI,PXF,YI,PYF,XF,PXI,YF,PYI,XII,PXFJ,YIK,PYFL

      NORD=NORDNG-1

      XF=0.D0
      DO I=0,NORD
          DO J=1,NORD
         DO K=0,NORD
             DO L=0,NORD

      IF( I+J+K+L .LE. NORD ) THEN

         IF(I.EQ.0 .AND. XI.EQ. 0.D0)  THEN
            XII=1.D0
         ELSE
            XII=XI**I
         ENDIF
         IF(J-1.EQ.0 .AND. PXF.EQ. 0.D0)  THEN
            PXFJ=1.D0
         ELSE
            PXFJ=PXF**(J-1)
         ENDIF
         IF(K.EQ.0 .AND. YI.EQ.0.D0) THEN
            YIK=1.D0
         ELSE
            YIK=YI**K
         ENDIF
         IF(L.EQ.0.AND.PYF.EQ.0.D0) THEN
            PYFL=1.D0
         ELSE
            PYFL=PYF**L
         ENDIF

      XF = XF +
     &      J * ADUM(I+1,J+1,K+1,L+1) *
     &      XII * PXFJ * YIK * PYFL
      ENDIF
             END DO
         END DO
          END DO
      END DO

      PXI=0.D0
      DO I=1,NORD
          DO J=0,NORD
         DO K=0,NORD
             DO L=0,NORD

      IF( I+J+K+L .LE. NORD ) THEN

         IF(I-1.EQ.0 .AND. XI.EQ. 0.D0)   THEN
            XII=1.D0
         ELSE
            XII=XI**(I-1)
         ENDIF
         IF(J.EQ.0 .AND. PXF.EQ. 0.D0)    THEN
            PXFJ=1.D0
         ELSE
            PXFJ=PXF**J
         ENDIF
         IF(K.EQ.0 .AND. YI.EQ.0.D0) THEN
            YIK=1.D0
         ELSE
            YIK=YI**K
         ENDIF
         IF(L.EQ.0.AND.PYF.EQ.0.D0) THEN
            PYFL=1.D0
         ELSE
            PYFL=PYF**L
         ENDIF

      PXI = PXI +
     &      I * ADUM(I+1,J+1,K+1,L+1) *
     &      XII * PXFJ * YIK * PYFL
      ENDIF
             END DO
         END DO
          END DO
      END DO

      YF=0.D0
      DO I=0,NORD
          DO J=0,NORD
         DO K=0,NORD
             DO L=1,NORD

      IF( I+J+K+L .LE. NORD ) THEN

         IF(I.EQ.0 .AND. XI.EQ. 0.D0)  THEN
            XII=1.D0
         ELSE
            XII=XI**I
         ENDIF
         IF(J.EQ.0 .AND. PXF.EQ. 0.D0)    THEN
            PXFJ=1.D0
         ELSE
            PXFJ=PXF**J
         ENDIF
         IF(K.EQ.0 .AND. YI.EQ.0.D0) THEN
            YIK=1.D0
         ELSE
            YIK=YI**K
         ENDIF
         IF(L-1.EQ.0.AND.PYF.EQ.0.D0) THEN
            PYFL=1.D0
         ELSE
            PYFL=PYF**(L-1)
         ENDIF

      YF = YF +
     &      L * ADUM(I+1,J+1,K+1,L+1) *
     &      XII * PXFJ * YIK * PYFL
      ENDIF
             END DO
         END DO
          END DO
      END DO

      PYI=0.D0
      DO I=0,NORD
          DO J=0,NORD
         DO K=1,NORD
             DO L=0,NORD
      IF( I+J+K+L .LE. NORD ) THEN

         IF(I.EQ.0 .AND. XI.EQ. 0.D0)  THEN
            XII=1.D0
         ELSE
            XII=XI**I
         ENDIF
         IF(J.EQ.0 .AND. PXF.EQ. 0.D0)    THEN
            PXFJ=1.D0
         ELSE
            PXFJ=PXF**J
         ENDIF
         IF(K-1.EQ.0 .AND. YI.EQ.0.D0) THEN
            YIK=1.D0
         ELSE
            YIK=YI**(K-1)
         ENDIF
         IF(L.EQ.0.AND.PYF.EQ.0.D0) THEN
            PYFL=1.D0
         ELSE
            PYFL=PYF**L
         ENDIF

      PYI = PYI +
     &      K * ADUM(I+1,J+1,K+1,L+1) *
     &      XII * PXFJ * YIK * PYFL
      ENDIF
             END DO
         END DO
          END DO
      END DO

      RETURN
      END
+DECK,F0FNFUN.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.47/04 12/03/2003  15.56.12  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.50.26  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.47  by  Michael Scheer
*-- Author : Michael Scheer
C**********************************************************************
      DOUBLE PRECISION FUNCTION F0FNFUN(NN,D0M,PHI,R1)
C**********************************************************************
+seq,gplhint.

c     Form factor of asymm. WLS, calculated with REDUCE (26.2.92)
c     revised 310.03.92

      IMPLICIT NONE

      DOUBLE PRECISION NN,PHI,D0,D0M,R1,ANS,ANS1

      D0=-D0M  !GODE RECHNET MIT NEGATIVER ABLAGE UND NEGATIVER DISPERSION

      ANS1=10240.0*D0**2*NN**4+25600.0*D0**2*NN**2+15360.0
     . *D0**2+407.43665431525d0*D0*R1*NN**5*PHI**2+572.95779
     . 513082d0*D0*R1*NN**4*PHI**2+875.35218700542d0*D0*R1*NN
     . **3*PHI**2+1266.8733470115d0*D0*R1*NN**2*PHI**2+396.2
     . 9580829882d0*D0*R1*NN*PHI**2+611.15498147288d0*D0*R1*
     . PHI**2+4.0528473456935d0*R1**2*NN**6*PHI**4+11.398633
     . 159763d0*R1**2*NN**5*PHI**4+16.092762348004d0*R1**2*NN
     . **4*PHI**4+23.164555610229d0*R1**2*NN**3*PHI**4+19.88
     . 3653809028d0*R1**2*NN**2*PHI**4+9.0999088058775d0*R1**2
     . *NN*PHI**4+7.2951252222483d0*R1**2*PHI**4
      ANS=ANS1/((4.*NN**2+6.)**0.5*(1795444365.9387d0*D0**2*
     . NN**2+1795444365.9387d0*D0**2+71438461.471411d0*D0*R1*
     . NN**3*PHI**2+100460336.44417d0*D0*R1*NN**2*PHI**2+463
     . 23377.360368d0*D0*R1*NN*PHI**2+71438461.471411d0*D0*R1*
     . PHI**2+710611.51687843d0*R1**2*NN**4*PHI**4+1998594.8
     . 912206d0*R1**2*NN**3*PHI**4+1755729.1592639d0*R1**2*NN
     . **2*PHI**4+1063696.6143274d0*R1**2*NN*PHI**4+852733.8
     . 2025412d0*R1**2*PHI**4)**0.5*R1*NN*PHI**2*(NN+1.))

      F0FNFUN=ANS

      RETURN
      END
+DECK,F0PFUN.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.22  by  Michael Scheer
*-- Author : Michael Scheer
+seq,gplhint.
C******************************************************************
      DOUBLE PRECISION FUNCTION F0PFUN(FASYM)

      IMPLICIT NONE
      DOUBLE PRECISION FASYM

      CALL F0PSPLINE(FASYM,F0PFUN)

      RETURN
      END
+DECK,F0PSPLINE.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.16/08 01/11/2000  18.41.44  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  16.29.19  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.50.33  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.22  by  Michael Scheer
*-- Author : Michael Scheer
C******************************************************************
      SUBROUTINE F0PSPLINE(XI,YO)
+seq,gplhint.

C--- DOUBLE PRECISION SUBROUTINE FOR CUBIC SPLINE INTERPOLATION
C    SUBROUTINES FROM NUMERICAL RECIEPIES

      IMPLICIT NONE
      INTEGER NPOINT,ICAL,NMAX
      PARAMETER (NMAX=100) !BEACHTE AUCH NMAX IN S/R SPLINE UND SPLINT
      DOUBLE PRECISION X(NMAX),Y(NMAX),Y2(NMAX),XI,YO

      DATA ICAL/0/

C--- DATA SET I.E. TABULATED FUNCTION Y(X)

      DATA NPOINT   /       6        /

      DATA X(1),Y(1)/       1.0,    0.01953      /
      DATA X(2),Y(2)/       2.0,    0.006354     /
      DATA X(3),Y(3)/       3.0,    0.004078     /
      DATA X(4),Y(4)/       4.0,    0.003322     /
      DATA X(5),Y(5)/       6.0,    0.001831     /
      DATA X(6),Y(6)/       8.0,    0.0010612       /

      IF (ICAL.NE.1) THEN
          CALL SPLINE(X,Y,NPOINT,2.D30,2.D30,Y2)
          ICAL=1
      ENDIF

      CALL SPLINT(X,Y,Y2,NPOINT,XI,YO)

      RETURN
      END
+DECK,FB0MFUN.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  16.33.53  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.50.38  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.22  by  Michael Scheer
*-- Author : Michael Scheer
C******************************************************************
      DOUBLE PRECISION FUNCTION FB0MFUN(FASYM)
+seq,gplhint.

C--- FUER EIN GEGEBENES FASYM WIRD FB0M SO BERECHNET, DASS DIE DIPOL-
C    FOLGE UND DER ASYMMETRISCHE HALBACHTYP DIE GLEICHE EMITTANZ HABEN
C     EMPIRISCHER FIT

      IMPLICIT NONE
      DOUBLE PRECISION FASYM
CC      DOUBLE PRECISION FASYM,P1,P2,P3

CC      DATA P1,P2,P3/0.8400358,-0.0316626,1.224754/ !FIT VOM 080891 (CA.)

CC    FB0MFUN=1./(FASYM-P1)+P2*FASYM+P3 !FIT, S.OUTPUT VOM 13.08.91 (2852FF.)

      CALL FB0MSPLINE(FASYM,FB0MFUN)

      RETURN
      END
+DECK,FB0MSPLINE.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.16/08 01/11/2000  18.41.44  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  16.35.03  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.50.42  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.22  by  Michael Scheer
*-- Author : Michael Scheer
C******************************************************************
      SUBROUTINE FB0MSPLINE(XI,YO)
+seq,gplhint.

C--- DOUBLE PRECISION SUBROUTINE FOR CUBIC SPLINE INTERPOLATION
C    SUBROUTINES FROM NUMERICAL RECIEPIES

      IMPLICIT NONE
      INTEGER NPOINT,ICAL,NMAX
      PARAMETER (NMAX=100) !BEACHTE AUCH NMAX IN S/R SPLINE UND SPLINT
      DOUBLE PRECISION X(NMAX),Y(NMAX),Y2(NMAX),XI,YO

      DATA ICAL/0/

C--- DATA SET I.E. TABULATED FUNCTION Y(X)

      DATA NPOINT   /       8        /

      DATA X(1),Y(1)/       1.0,    7.0       /
      DATA X(2),Y(2)/       1.5,    3.5       /
      DATA X(3),Y(3)/       2.0,    2.0       /
      DATA X(4),Y(4)/       3.0,    1.5       /
      DATA X(5),Y(5)/       4.0,    1.4       /
      DATA X(6),Y(6)/       5.0,    1.35    /
      DATA X(7),Y(7)/       6.0,    1.2     /
      DATA X(8),Y(8)/       8.0,    1.1       /

      IF (ICAL.NE.1) THEN
          CALL SPLINE(X,Y,NPOINT,2.D30,2.D30,Y2)
          ICAL=1
      ENDIF

      CALL SPLINT(X,Y,Y2,NPOINT,XI,YO)

      RETURN
      END
+DECK,FBETFUN.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.47/04 12/03/2003  15.52.58  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.47  by  Michael Scheer
*-- Author : Michael Scheer
C**********************************************************************
      DOUBLE PRECISION FUNCTION FBETFUN(NN,D0M,PHI,R1)
C**********************************************************************
+seq,gplhint.

C     Formfactor Fbeta, calculated with REDUCE (26.2.91)
c     revised 31.03.92

      IMPLICIT NONE

      DOUBLE PRECISION NN,D0,D0M,PHI,R1,ANS

      D0=-D0M  !GODE RECHNET MIT NEGATIVER ABLAGE UND NEGATIVER DISPERSION

        ANS=(0.00066314559621623d0*(1795444365.9387d0*D0**2*NN**2    !310392
     . +1795444365.9387d0*D0**2+71438461.471411d0*D0*R1*NN**3
     . *PHI**2+100460336.44417d0*D0*R1*NN**2*PHI**2+46323377.360368d0
     &  *D0*R1*NN*PHI**2+71438461.471411d0*D0*R1*PHI**
     . 2+710611.51687843d0*R1**2*NN**4*PHI**4+1998594.8912206d0
     . *R1**2*NN**3*PHI**4+1755729.1592639d0*R1**2*NN**2*
     . PHI**4+1063696.6143274d0*R1**2*NN*PHI**4+852733.82025412d0
     &*R1**2*PHI**4)**0.5)/((4.*NN**2+6.)**0.5*R1*PHI
     . **2)

      FBETFUN=ANS

      RETURN
      END
+DECK,FBETPFUN.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.50.49  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.22  by  Michael Scheer
*-- Author : Michael Scheer
C******************************************************************
      DOUBLE PRECISION FUNCTION FBETPFUN(FASYM)
+seq,gplhint.

      IMPLICIT NONE
      DOUBLE PRECISION FASYM

      CALL FBETPSPLINE(FASYM,FBETPFUN)

      RETURN
      END
+DECK,FBETPSPLINE.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.16/08 01/11/2000  18.41.44  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  16.36.10  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.50.53  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.22  by  Michael Scheer
*-- Author : Michael Scheer
C******************************************************************
      SUBROUTINE FBETPSPLINE(XI,YO)
+seq,gplhint.

C--- DOUBLE PRECISION SUBROUTINE FOR CUBIC SPLINE INTERPOLATION
C    SUBROUTINES FROM NUMERICAL RECIEPIES

      IMPLICIT NONE
      INTEGER NPOINT,ICAL,NMAX
      PARAMETER (NMAX=100) !BEACHTE AUCH NMAX IN S/R SPLINE UND SPLINT
      DOUBLE PRECISION X(NMAX),Y(NMAX),Y2(NMAX),XI,YO

      DATA ICAL/0/

C--- DATA SET I.E. TABULATED FUNCTION Y(X)

      DATA NPOINT   /       6        /

      DATA X(1),Y(1)/       1.0,    0.4704       /
      DATA X(2),Y(2)/       2.0,    0.3332       /
      DATA X(3),Y(3)/       3.0,    0.2405       /
      DATA X(4),Y(4)/       4.0,    0.2018       /
      DATA X(5),Y(5)/       6.0,    0.1329       /
      DATA X(6),Y(6)/       8.0,    0.08906      /

      IF (ICAL.NE.1) THEN
          CALL SPLINE(X,Y,NPOINT,2.D30,2.D30,Y2)
          ICAL=1
      ENDIF

      CALL SPLINT(X,Y,Y2,NPOINT,XI,YO)

      RETURN
      END
+DECK,FDiskFx.
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.14/02 19/04/2000  17.21.02  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  15.49.52  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.50.57  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.55  by  Michael Scheer
*-- Author : Michael Scheer
+seq,gplhint.
C...............................................................................
      Function FDiskFx(Rkx,Rky,Radius)
C...............................................................................

      IMPLICIT NONE

      REAL Rkx,Rky,Radius,FDISKFX,PI,BESJ1
      ReaL Dummy
      DATA PI/3.141592653589793D0/

CMSH  FDiskFx=1.0 !normierte
      FDiskFx=(Pi*Radius*Radius) !MSH
C     FDiskFx=(Pi*Radius*Radius)/(Pi*Radius*Radius) !normierte
C     FDiskFx=(Pi*Radius*Radius)
      If ( Rkx*Rkx+Rky*Rky.ne.0 ) Then
           Dummy=Radius*Sqrt(Rkx*Rkx+Rky*Rky)

CMSH USE CERN ROUTINE BESJ1 (C312)
           FDiskFx=FDiskFx*2.0*BESJ1(Dummy)/Dummy
CMSH       FDiskFx=FDiskFx*2.0*BesselFx1(Dummy)/Dummy

      Endif
        Return
        End
+DECK,FFT.
*CMZ :  4.00/11 07/05/2021  07.34.04  by  Michael Scheer
*CMZ :  4.00/07 09/01/2020  13.45.07  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.29.14  by  Michael Scheer
*CMZ :  2.14/02 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  12.40.42  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.09.58  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  16.56.14  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.51.02  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.55  by  Michael Scheer
*-- Author : Chaoen Wang
C...............................................................................
      Subroutine FFT(Z1,M,ISign)
C...............................................................................
+seq,gplhint.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.

      COMPLEX Z1(NDOBSVZP+NDOBSVYP) !SR USMCON2

CMSH  Parameter (MaxPt0=616)
CMSH  CompLex Z1(MaxPt0)

      CompLex ZU,ZW,ZT

      INTEGER K,NM1,NV2,I,J,N,IP,LE,LE1,L,M,ISIGN

      REAL PI

      DATA PI/3.141592653589793D0/

      print*,"FFT IS OBSOLETE, SEE //WAVE/USEM IN WAVE.CMZ"

      Return
      End
+DECK,FFT2d.
*CMZ :  4.00/07 09/01/2020  13.44.20  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.16/08 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.14/02 19/04/2000  17.02.45  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  12.15.08  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.09.58  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  16.56.43  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.51.06  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.55  by  Michael Scheer
*-- Author : Chaoen Wang
+seq,gplhint.
C..........................................................................
+SELF,IF=-F90.
        Subroutine FFT2d(Z2,NoMx,NoMy,HXLgh,HYLgh,ISign)
+SELF,IF=F90.
        Subroutine FFT2d(NoMx,NoMy,HXLgh,HYLgh,ISign)
+SELF.
C..........................................................................

+SEQ,USEMF90U,IF=F90.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.

+SELF,IF=-F90.
      COMPLEX Z1(NDOBSVZP+NDOBSVYP),Z2(NDOBSVZP,NDOBSVYP) !SR USMCON2
+SELF,IF=F90.
      COMPLEX Z1(NDOBSVZP+NDOBSVYP) !SR USMCON2
+SELF.

CMSH  Parameter (MaxPt0=616,MaxPtx=616,MaxPty=553)

CMSH        CompLex Z1(MaxPt0),Z2(MaxPtx,MaxPty)

        CompLex ZI,ZJ

      INTEGER NODELX,NODELY,NOMX,NOMY,ISIGN,JYTH,JXTH,NYTH,IXTH,MXTH
      REAL HKyLgh,DeLKy,HKxLgh,DeLy,DeLkx,DeLx,HXLgh,HYLgh,PI

      DATA PI/3.141592653589793D0/

      PRINT*,"FFT2D IS OBSOLETE, SEE //WAVE/USEM IN WAVE.CMZ"
        Return
      End
+DECK,FGauss.
*CMZ :  2.13/09 09/03/2000  15.51.54  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.51.10  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.55  by  Michael Scheer
*-- Author :
+seq,gplhint.
C...............................................................................
      CompLex Function FGauss(VGauss,VRms,VMean)
C...............................................................................

      IMPLICIT NONE

        CompLex ZI
      REAL VGauss,VRms,VMean

      ZI=CMPLX(0.0,1.0)

        FGauss=Exp(-VGauss*VGauss*VRms*VRms/2.0)*CExp(-ZI*VGauss*VMean)

        Return
        End
+DECK,FGauss1.
*CMZ :  2.13/09 09/03/2000  15.53.12  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.51.14  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.55  by  Michael Scheer
*-- Author :
+seq,gplhint.
C...............................................................................
      CompLex Function FGauss1(VGauss,VRms,VMean)
C...............................................................................

      IMPLICIT NONE

        CompLex ZI
      REAL VGauss,VRms,VMean

         ZI=CMPLX(0.0,1.0)
        FGauss1=Exp(VGauss*VGauss*VRms*VRms/2.0)*CExp(ZI*VGauss*VMean)

        Return
        End
+DECK,FILTER.
*CMZ :  4.00/10 07/09/2020  15.46.05  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.10  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.56/01 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.36/00 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  14.22.44  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  2.13/03 17/12/99  10.44.11  by  Michael Scheer
*CMZ : 00.00/05 29/04/94  20.12.40  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.46  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE FILTER
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SELF.

C--- READS ABSORPTION COEFFICIENT FROM FILE AND APPLIES FILTER TO SPECTRUM

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,MYFILES.
+SEQ,CONTRL.
+SEQ,PHYCON.
+seq,sourcef90.
+SEQ,SPECT.
+SEQ,FREQS.
+SEq,observf90.

      DOUBLE PRECISION AMU

      INTEGER ISOUR,IOBSV,IFREQ,ICAL

      DATA ICAL/0/

C- ABSORPTION COEFFICIENT (SPLINE INTERPOLATION)

      ICAL=ICAL+1

      DO IFREQ=1,NFREQ
        CALL ABSCOEF(FREQ(IFREQ),AMU,ABSDEN,ABSCOM,IFILTER,ICAL)
        ABSMU(IFREQ)=AMU
        EXPMU(IFREQ)=DEXP(-ABSMU(IFREQ)*ABSTHI*ABSDEN)
        IF (EXPMU(IFREQ).GT.1.D0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN FILTER ***'
          WRITE(LUNGFO,*)'REDUCTION FACTOR GREATER THAN ONE'
          WRITE(LUNGFO,*)'PHOTON ENERGY:',FREQ(IFREQ)
          WRITE(LUNGFO,*)'REDUCTION FACTOR:',ABSMU(IFREQ)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN FILTER ***'
          WRITE(6,*)'REDUCTION FACTOR GREATER THAN ONE'
          WRITE(6,*)'PHOTON ENERGY:',FREQ(IFREQ)
          WRITE(6,*)'REDUCTION FACTOR:',EXPMU(IFREQ)
          WRITE(6,*)'MASS ABSORPTION COEFFICIENT [KG/M**2]:',ABSMU(IFREQ)
          WRITE(6,*)
          WRITE(6,*)
          STOP
        ENDIF
      ENDDO !IFREQ

      DO ISOUR=1,NSOURCE
        DO IOBSV=1,NOBSV
          DO IFREQ=1,NFREQ

+SELF,IF=-NEWWAVE.
            SPEC(ISOUR,IOBSV,IFREQ)=SPEC(ISOUR,IOBSV,IFREQ)*EXPMU(IFREQ)
+SELF,IF=NEWWAVE.
            ILIOBFR=ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1))
            SPEC(ILIOBFR)=SPEC(ILIOBFR)*EXPMU(IFREQ)
+SELF.

          ENDDO !IFREQ
        ENDDO !IOBSV
      ENDDO !ISOUR

+SELF,IF=NEWWAVE.
      if (istokes.ne.0) then
        DO IOBSV=1,NOBSV
          DO IFREQ=1,NFREQ
            IOBFR=IOBSV+NOBSV*(IFREQ-1)
            stokes(1:4,iobfr)=stokes(1:4,iobfr)*expmu(ifreq)
          ENDDO !IFREQ
        ENDDO !IOBSV
      endif
+SELF.

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     *** SR FILTER CALLED, I.E. SPECTRUM IS GIVEN BEHIND ABSORBER ***'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     FILE WITH ABSORPTION COEFFICIENTS:'
      WRITE(LUNGFO,*)'     ',FILEABS
      WRITE(LUNGFO,*)'     COMMENT ON DATA FILE:'
      WRITE(LUNGFO,*)'     ',ABSCOM
      WRITE(LUNGFO,*)'     THICKNESS OF FILTER:',ABSTHI
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

      RETURN
      END
+DECK,FOUFUNX.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.15/00 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.14/02 27/04/2000  17.56.53  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.51.21  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.19  by  Michael Scheer
*-- Author : Michael Scheer
C**************************************************************
      FUNCTION FOUFUNX(X,WSIG)
C*************************************************************
+seq,gplhint.
      IMPLICIT NONE
      DOUBLE PRECISION FOUFUNX,X,WSIG
+SEQ,PHYCON.

      FOUFUNX=DEXP(-X*X/(WSIG*WSIG)/2.D0)/WSIG/DSQRT(2.D0*PI1)

      RETURN
      END
+DECK,FOURWLS.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.16/04 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.26.25  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  17.02.52  by  Michael Scheer
*CMZ : 00.01/08 22/06/95  10.55.14  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.38.33  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.41  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE FOURWLS
+seq,gplhint.

C Expands the magnetic field By on the device axis into a Fourier series
C The field has to be symmetric i.e. By(x)= By(-x).
C The field is calculated for the negativ x-values and also assigned
C to the positiv x.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,FOURIER.

      INTEGER I,K,I1,IP,IM,NFOURD2,MFOUR

C--- DUE TO CERN MAIL DIMENSION INCREASED TO 2 (AT LEAST BY 1) 22.06.95

      COMPLEX CKOEF(NFOURD/2+1+2)
      REAL*4  YFOUR(NFOURD+2+2),AKOEF(NFOURD/2+1+2)
      EQUIVALENCE (CKOEF,YFOUR)

      DOUBLE PRECISION XFOUR(NFOURD+2+2)
      DOUBLE PRECISION XLFOUR,DXFOUR,BX,BY,BZ,AX,AY,AZ

C--- LOOP UBER NFOURD-PUNKTE FUER FAST-FOURIER-TRANSFORMATION

      IF (XSTART+XSTOP.NE.0.0) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*) '*** WARNING SR FOURWLS: XSTART.NE.-XSTOP ***'
         WRITE(LUNGFO,*) 'CHECK RESULTS CAREFULLY'
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*) '*** WARNING SR FOURWLS: XSTART.NE.-XSTOP ***'
         WRITE(6,*) 'CHECK RESULTS CAREFULLY'
         WRITE(6,*)
      ENDIF !XSTART

      IF(NFOURWLS.GT.NFOURD/2) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '*** ERROR IN FOURWLS ***'
          WRITE(LUNGFO,*)
     &      'NFOURWLS.GT.NFOURD/2'
          WRITE(LUNGFO,*)
     &      'CHECK NFOURWLS OR INCREASE PARAMETER NFOURD IN FILE CMPARA.CMN'
          WRITE(6,*)
          WRITE(6,*)
     &      '*** ERROR IN FOURWLS ***'
          WRITE(6,*)
     &      'NFOURWLS.GT.NFOURD/2'
          WRITE(6,*)
     &      'CHECK NFOURWLS OR INCREASE PARAMETER NFOURD IN FILE CMPARA.CMN'
           STOP
      ENDIF

C     XLFOUR=DABS(XSTART-XSTOP)
      XLFOUR=DABS(2.*XSTOP)   !WEGEN SR BMAGSEQ
      DXFOUR=XLFOUR/NFOURD
      NFOURD2=NFOURD/2
      MFOUR=NINT(ALOG(FLOAT(NFOURD))/ALOG(2.E0))

      DO I=1,NFOURD2+1           !SYMMETRISCHE X-WERTE
          XFOUR(I)          =-DXFOUR*(NFOURD2+1-I)
          XFOUR(NFOURD+1-I+1)=-XFOUR(I)
      END DO

      DO I=1,NFOURD2+1           !SYMMETRISCHE Y-WERTE

          I1=I-1
          IP=NFOURD2+1+I1
          IM=NFOURD2+1-I1

C141091      CALL BREC00(BX,BY,BZ,XFOUR(IP),0.,0.)
          CALL MYBFELD(XFOUR(IP),0.D0,0.D0,BX,BY,BZ,AX,AY,AZ)

          YFOUR(IP)=BY
          YFOUR(IM)=BY

      END DO



      CALL RFFT(CKOEF,-MFOUR) !FFT MIT CERN-ROUTINE D703


      DO K=1,NFOURD2+1  !REELLE KOEFFIZIENTEN
          AKOEF(K)=(-1.)**(K-1)*2.*REAL(CKOEF(K))
      ENDDO

C--- OUTPUT AUF FILE SCHREIBEN

      OPEN(UNIT=LUNF,FILE=FILEF,STATUS='NEW',FORM='FORMATTED')

      WRITE(LUNF,1000)ICODE,CODE
1000    FORMAT(I10,'  ',1A60)
      WRITE(LUNF,*)XLFOUR
      WRITE(LUNF,*)NFOURWLS

      DO I=1,NFOURWLS
          WRITE(LUNF,*)I,AKOEF(I)
      ENDDO

      CLOSE(LUNF)

      IF(IWFILF.NE.99) THEN
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SR FOURWLS: Coefficients written to file:'
      WRITE(LUNGFO,*)'     ',FILEF
      WRITE(LUNGFO,*)

      DO I=1,NFOURWLS
          WRITE(LUNGFO,*)I,AKOEF(I)
      ENDDO
      WRITE(LUNGFO,*)
      ENDIF !IWFILF

      RETURN
      END
+DECK,FRectFx.
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  15.56.32  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.51.32  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.55  by  Michael Scheer
*-- Author :
C...............................................................................
      REAL Function FRectFx(RkRect,Window)
C...............................................................................
+seq,gplhint.

      IMPLICIT NONE

      REAL RkRect,Window

      DOUBLE PRECISION Dummy


CMSH  FRectFx=1.0 !normierte
C     FRectFx=Abs(Window)/Abs(Window) !normierte
      FRectFx=Abs(Window)
      If ( RkRect.ne.0 ) Then
           Dummy=RkRect*0.5*Window
           Dummy=DSin(Dummy)
           FRectFx=FRectFx*ReaL(Dummy)/(RkRect*0.5*Window)
      Endif
        Return
        End
+DECK,FSPLINDX.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.63/05 22/07/2009  07.43.29  by  Michael Scheer
*CMZ :  2.48/04 12/03/2004  15.40.31  by  Michael Scheer
*CMZ :  2.47/07 14/04/2003  15.17.05  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  16.33.46  by  Michael Scheer
*CMZ : 00.01/04 28/11/94  18.36.50  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.55  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE FSPLINDX(DX,Y,N,YP1,YPN,Y2)
+seq,gplhint.


      IMPLICIT NONE
+SEQ,CMPARA.

      INTEGER N,J
      DOUBLE PRECISION DX,Y(N),Y2(N)

+SELF,IF=LINUX,WINDOWS,HPUX,TRUE64.
      DOUBLE PRECISION  C(NDOBSVZP+NDOBSVYP)
      DOUBLE PRECISION AA(NDOBSVZP+NDOBSVYP)
      DOUBLE PRECISION BB(NDOBSVZP+NDOBSVYP)
      DOUBLE PRECISION CC(NDOBSVZP+NDOBSVYP)
+SELF.

+SELF,IF=VMS.
      INTEGER max
      DOUBLE PRECISION  C(max(NDOBSVZP,NDOBSVYP))
      DOUBLE PRECISION AA(max(NDOBSVZP,NDOBSVYP))
      DOUBLE PRECISION BB(max(NDOBSVZP,NDOBSVYP))
      DOUBLE PRECISION CC(max(NDOBSVZP,NDOBSVYP))
+SELF.

      DOUBLE PRECISION YP1,YPN,H6,H3

      Y2(1)=YP1
      Y2(N)=YPN

      IF (N.LT.3) RETURN

      C(1)=YP1
      C(N)=YPN

      H6=1./6.D0
      H3=4.D0*H6

      BB(1)=1.D0
      CC(1)=0.D0


      DO J=2,N-1
          AA(J)=H6
          BB(J)=H3
          CC(J)=H6
          C(J)=(Y(J+1)-2.D0*Y(J)+Y(J-1))/DX**2
      ENDDO !J

      DO J=2,N-1

          BB(J)=BB(J)-AA(J)*CC(J-1)
           C(J)= C(J)-AA(J)* C(J-1)
C030414          AA(J)=AA(J)-AA(J)*BB(J-1)

          CC(J)=CC(J)/BB(J)
           C(J)= C(J)/BB(J)
          BB(J)=1.D0

      ENDDO !J

      DO J=N-1,2,-1
         Y2(J)=C(J)-CC(J)*Y2(J+1)
      ENDDO

      RETURN
      END
+DECK,FSPLINE.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.63/05 22/07/2009  07.43.29  by  Michael Scheer
*CMZ :  2.48/04 12/03/2004  15.40.31  by  Michael Scheer
*CMZ :  2.47/07 14/04/2003  15.17.05  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  17.00.52  by  Michael Scheer
*CMZ : 00.01/04 28/11/94  18.37.46  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.51.38  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.54  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE FSPLINE(X,Y,N,YP1,YPN,Y2)
+seq,gplhint.


      IMPLICIT NONE

+SEQ,CMPARA.

      INTEGER N,J
      DOUBLE PRECISION  X(N),Y(N),Y2(N)

+SELF,IF=LINUX,WINDOWS,HPUX,TRUE64.
      DOUBLE PRECISION  C(NDOBSVZP+NDOBSVYP)
      DOUBLE PRECISION AA(NDOBSVZP+NDOBSVYP)
      DOUBLE PRECISION BB(NDOBSVZP+NDOBSVYP)
      DOUBLE PRECISION CC(NDOBSVZP+NDOBSVYP)
+SELF.

+SELF,IF=VMS.
      INTEGER max
      DOUBLE PRECISION  C(max(NDOBSVZP,NDOBSVYP))
      DOUBLE PRECISION AA(max(NDOBSVZP,NDOBSVYP))
      DOUBLE PRECISION BB(max(NDOBSVZP,NDOBSVYP))
      DOUBLE PRECISION CC(max(NDOBSVZP,NDOBSVYP))
+SELF.

      DOUBLE PRECISION YP1,YPN

      Y2(1)=YP1
      Y2(N)=YPN

      IF (N.LT.3) RETURN

      C(1)=YP1
      C(N)=YPN

      BB(1)=1.D0
      CC(1)=0.D0
      CC(N)=1.D0

      DO J=2,N-1
          AA(J)=(X(J  )-X(J-1))/6.D0
          BB(J)=(X(J+1)-X(J-1))/3.D0
          CC(J)=(X(J+1)-X(J  ))/6.D0
          C(J)=(Y(J+1)-Y(J  ))/(X(J+1)-X(J  ))
     &          -(Y(J  )-Y(J-1))/(X(J  )-X(J-1))
      ENDDO !J

      DO J=2,N-1

          BB(J)=BB(J)-AA(J)*CC(J-1)
           C(J)= C(J)-AA(J)* C(J-1)
C030414          AA(J)=AA(J)-AA(J)*BB(J-1)

          CC(J)=CC(J)/BB(J)
           C(J)= C(J)/BB(J)
          BB(J)=1.D0

      ENDDO !J

      DO J=N-1,2,-1
         Y2(J)=C(J)-CC(J)*Y2(J+1)
      ENDDO

      RETURN
      END
+DECK,FSPLINEF.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.47/07 14/04/2003  15.17.05  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.35  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.59  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE FSPLINEF(X,Y,N,YP1,YPN,Y2)
+seq,gplhint.


      IMPLICIT NONE

+SEQ,CMPARA.

      INTEGER N,J
      DOUBLE PRECISION  X(N),Y(N),Y2(N)
      DOUBLE PRECISION  C(NDFREQP)
      DOUBLE PRECISION AA(NDFREQP)
      DOUBLE PRECISION BB(NDFREQP)
      DOUBLE PRECISION CC(NDFREQP)

      DOUBLE PRECISION YP1,YPN

      Y2(1)=YP1
      Y2(N)=YPN

      IF (N.LT.3) RETURN

      C(1)=YP1
      C(N)=YPN

      BB(1)=1.D0
      CC(1)=0.D0
      CC(N)=1.D0

      DO J=2,N-1
          AA(J)=(X(J  )-X(J-1))/6.D0
          BB(J)=(X(J+1)-X(J-1))/3.D0
          CC(J)=(X(J+1)-X(J  ))/6.D0
          C(J)=(Y(J+1)-Y(J  ))/(X(J+1)-X(J  ))
     &          -(Y(J  )-Y(J-1))/(X(J  )-X(J-1))
      ENDDO !J

      DO J=2,N-1

          BB(J)=BB(J)-AA(J)*CC(J-1)
           C(J)= C(J)-AA(J)* C(J-1)
C030414      AA(J)=AA(J)-AA(J)*BB(J-1)

          CC(J)=CC(J)/BB(J)
           C(J)= C(J)/BB(J)
          BB(J)=1.D0

      ENDDO !J

      DO J=N-1,2,-1
         Y2(J)=C(J)-CC(J)*Y2(J+1)
      ENDDO

      RETURN
      END
+DECK,FSPLPER.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.63/05 22/07/2009  07.43.29  by  Michael Scheer
*CMZ :  2.48/04 12/03/2004  15.40.31  by  Michael Scheer
*CMZ :  2.47/07 14/04/2003  15.17.05  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.35  by  Michael Scheer
*CMZ :  1.03/06 06/08/98  18.15.25  by  Michael Scheer
*CMZ : 00.01/04 28/11/94  18.44.24  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  16.38.52  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.51.45  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.56  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE FSPLPER(DX,Y,N,Y2)
+seq,gplhint.

C--- FOR PERIODIC CASE
C--- ONLY FOR EQUIDISTANT X-VALUES

C ROUTINES SOLVES THE FOLLOWING SYSTEM OF LINEAR EQUATIONS:

C  BB( 1 ) CC( 1 )   0     ....... ....... .......   0     ZZ( 1 ) | C( 1 )
C  AA( 2 ) BB( 2 ) CC( 2 )    0    ....... .......   0        0    | C( 2 )
C  ....... AA( 3 ) BB( 3 ) CC( 3 )    0    .......   0        0    | C( 3 )
C              .
C              .
C              .
C     0    ....... .......    0    AA(N-3) BB(N-3) CC(N-3)    0    | C(N-3)
C     0    ....... ....... .......    0    AA(N-2) BB(N-2) ZZ(N-2) | C(N-2)
C  CC(N-1)    0    ....... ....... .......    0    AA(N-1) ZZ(N-1) | C(N-1)


      IMPLICIT NONE

+SEQ,CMPARA.

      INTEGER N,J
      DOUBLE PRECISION DX,Y(N),Y2(N)

+SELF,IF=LINUX,WINDOWS,HPUX,TRUE64.
      DOUBLE PRECISION  C(2*(NDOBSVZP+NDOBSVYP))
      DOUBLE PRECISION AA(2*(NDOBSVZP+NDOBSVYP))
      DOUBLE PRECISION BB(2*(NDOBSVZP+NDOBSVYP))
      DOUBLE PRECISION CC(2*(NDOBSVZP+NDOBSVYP))
      DOUBLE PRECISION ZZ(2*(NDOBSVZP+NDOBSVYP))
+SELF.

+SELF,IF=VMS.
      INTEGER max
      DOUBLE PRECISION  C(2*max(NDOBSVZP,NDOBSVYP))
      DOUBLE PRECISION AA(2*max(NDOBSVZP,NDOBSVYP))
      DOUBLE PRECISION BB(2*max(NDOBSVZP,NDOBSVYP))
      DOUBLE PRECISION CC(2*max(NDOBSVZP,NDOBSVYP))
      DOUBLE PRECISION ZZ(2*max(NDOBSVZP,NDOBSVYP))
+SELF.

      DOUBLE PRECISION H6,H3

      IF (N.LT.4) THEN
      WRITE(6,*) '*** ERROR IN FSPLPER: N TOO LOW ***'
      STOP
      ENDIF

      H6=DX/6.D0
      H3=4.D0*H6

      BB(1)=1.0
      CC(1)=0.25
      ZZ(1)=0.25
      C(1)=( Y(3)-2.D0*Y(2)+Y(1) )/DX/H3

      DO J=2,N-3
          AA(J)=H6
          BB(J)=H3
          CC(J)=H6
          ZZ(J)=0.D0
          C(J)=(Y(J+1+1)-2.D0*Y(J+1)+Y(J-1+1))/DX
      ENDDO !J

      AA(N-2)=H6
      BB(N-2)=H3
      ZZ(N-2)=H6
      C (N-2)=(Y(N-2+1+1)-2.D0*Y(N-2+1)+Y(N-2-1+1))/DX

      AA(N-1)=H6
      ZZ(N-1)=H3
      CC(N-1)=H6
      C (N-1)=(Y(2)-2.D0*Y(N)+Y(N-1))/DX

      DO J=2,N-3

          ZZ(J)=ZZ(J)-AA(J)*ZZ(J-1)
           C(J)= C(J)-AA(J)* C(J-1)
          BB(J)=BB(J)-AA(J)*CC(J-1)
C030414          AA(J)=AA(J)-AA(J)*BB(J-1)

          CC(J)=CC(J)/BB(J)
          ZZ(J)=ZZ(J)/BB(J)
           C(J)= C(J)/BB(J)
          BB(J)=1.D0

      ENDDO !J

      BB(N-2)=BB(N-2)-AA(N-2)*CC(N-3)
      ZZ(N-2)=ZZ(N-2)-AA(N-2)*ZZ(N-3)
      C (N-2)=C(N-2) -AA(N-2)*C (N-3)

      ZZ(N-2)=ZZ(N-2)/BB(N-2)
      C (N-2)=C (N-2)/BB(N-2)
      BB(N-2)=1.D0

      ZZ(N-1)=ZZ(N-1)-CC(N-1)*ZZ(1)
       C(N-1)= C(N-1)-CC(N-1)* C(1)
      CC(N-1)=       -CC(N-1)*CC(1) ! CC MOVES DOWN THE ROW

      DO J=2,N-4
        ZZ(N-1)=ZZ(N-1)-CC(N-1)*ZZ(J)
        C(N-1)=  C(N-1)-CC(N-1)* C(J)
        CC(N-1)=       -CC(N-1)*CC(J)  ! CC MOVES DOWN THE ROW
      ENDDO !J

      AA(N-1)=AA(N-1)-CC(N-1)*CC(N-3)
      ZZ(N-1)=ZZ(N-1)-CC(N-1)*ZZ(N-3)
      C(N-1)=  C(N-1)-CC(N-1)*C(N-3)

      ZZ(N-1)=ZZ(N-1)-AA(N-1)*ZZ(N-2)
       C(N-1)= C(N-1)-AA(N-1)* C(N-2)
      AA(N-1)=AA(N-1)-AA(N-1)*BB(N-2)

       C(N-1)=C(N-1)/ZZ(N-1)
      ZZ(N-1)=1.D0

      Y2(N-1+1)= C(N-1)
      CC(N-2  )=ZZ(N-2)

      Y2(N-2+1)=C(N-2)-CC(N-2)*Y2(N-1+1)
      DO J=N-3,1,-1
         Y2(J+1)=C(J)-CC(J)*Y2(J+1+1)-ZZ(J)*Y2(N-1+1)
      ENDDO

      Y2(1)=Y2(N)

      RETURN
      END
+DECK,FUTIL.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.16/08 01/11/2000  11.11.07  by  Michael Scheer
*CMZ :  1.03/06 22/09/98  12.17.42  by  Michael Scheer
*CMZ :  1.00/00 04/08/97  12.41.44  by  Michael Scheer
*-- Author : Michael Scheer
C****************************************************************
      REAL FUNCTION FUTIL(X)
+seq,gplhint.

      REAL X

      X=0.
      FUTIL=0.

      RETURN
      END
+DECK,Gauss.
*CMZ :  2.14/02 19/04/2000  17.02.45  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  15.57.56  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.55  by  Michael Scheer
*-- Author :
C...............................................................................
      REAL Function Gauss(VGauss,VRms,VMean)
C...............................................................................
+seq,gplhint.

      IMPLICIT NONE

      REAL VGauss,VRms,VMean,PI

      DATA PI/3.141592653589793D0/

        Gauss=Exp(-(VGauss-VMean)*(VGauss-VMean)/
     &        VRms/VRms/2.0)/Sqrt(2.*Pi)/VRms

        Return
        End
+DECK,GENESISIN.
*CMZ :  2.47/10 28/05/2003  15.41.33  by  Michael Scheer
*-- Author :    Michael Scheer   28/05/2003
      SUBROUTINE GENESISIN
+seq,gplhint.

C READS GENESIS NAMELIST INPUT FILE AND TRANSFERS VARIABLES

+SEQ,GENESIS.
+SEQ,GENESISIN.
+SEQ,MYFILES.

      OPEN(UNIT=LUNGENI,FILE=FILEGENI,STATUS='OLD')

      READ(LUNGENI,NEWRUN)

      GSAW0=AW0
      GSXKX=XKX
      GSXKY=XKY
      GSXLAMD=XLAMD
      IGSWITYP=IWITYP

      CLOSE (LUNGENI)

      RETURN
      END
+DECK,gfinit.
*CMZ :  4.01/07 19/11/2024  14.51.23  by  Michael Scheer
*CMZ :  4.01/05 26/04/2024  10.38.28  by  Michael Scheer
*CMZ :  4.01/04 27/12/2023  16.20.07  by  Michael Scheer
*CMZ :  4.01/03 29/06/2023  10.07.32  by  Michael Scheer
*CMZ :  4.01/03 15/05/2023  16.38.53  by  Michael Scheer
*CMZ :  4.01/02 14/05/2023  13.42.26  by  Michael Scheer
*CMZ :  4.01/00 08/01/2023  16.56.29  by  Michael Scheer
*CMZ :  4.00/17 15/11/2022  10.57.19  by  Michael Scheer
*CMZ :  4.00/16 09/09/2022  17.24.46  by  Michael Scheer
*CMZ :  4.00/15 30/05/2022  15.47.16  by  Michael Scheer
*CMZ :  4.00/14 30/12/2021  11.57.49  by  Michael Scheer
*CMZ :  4.00/13 09/11/2021  09.50.16  by  Michael Scheer
*CMZ :  4.00/11 27/06/2021  11.57.49  by  Michael Scheer
*CMZ :  4.00/10 22/09/2020  09.17.04  by  Michael Scheer
*CMZ :  4.00/07 06/06/2020  13.59.12  by  Michael Scheer
*CMZ :  4.00/06 02/12/2019  15.36.11  by  Michael Scheer
*CMZ :  4.00/04 24/09/2019  10.58.03  by  Michael Scheer
*CMZ :  4.00/03 09/05/2019  11.04.11  by  Michael Scheer
*CMZ :  4.00/01 12/04/2019  10.43.33  by  Michael Scheer
*CMZ :  4.00/00 04/04/2019  12.37.42  by  Michael Scheer
*CMZ :  3.08/01 03/04/2019  16.19.59  by  Michael Scheer
*CMZ :  3.07/01 29/03/2019  14.39.14  by  Michael Scheer
*CMZ :  3.06/00 28/02/2019  15.01.36  by  Michael Scheer
*CMZ :  3.05/28 18/12/2018  13.52.06  by  Michael Scheer
*CMZ :  3.05/14 25/09/2018  08.52.05  by  Michael Scheer
*CMZ :  3.05/13 19/09/2018  13.56.36  by  Michael Scheer
*CMZ :  3.05/06 17/07/2018  11.15.16  by  Michael Scheer
*CMZ :  3.05/05 11/07/2018  09.20.23  by  Michael Scheer
*CMZ :  3.05/04 28/06/2018  09.36.14  by  Michael Scheer
*CMZ :  3.05/03 18/05/2018  11.56.52  by  Michael Scheer
*CMZ :  3.05/02 15/05/2018  16.25.19  by  Michael Scheer
*CMZ :  3.05/01 04/05/2018  16.04.30  by  Michael Scheer
*CMZ :  3.05/00 26/04/2018  15.51.12  by  Michael Scheer
*CMZ :  3.04/00 01/03/2018  12.10.21  by  Michael Scheer
*CMZ :  3.03/04 06/11/2017  16.05.55  by  Michael Scheer
*CMZ :  3.03/02 28/06/2017  13.49.04  by  Michael Scheer
*CMZ :  3.03/01 11/11/2015  14.37.19  by  Michael Scheer
*CMZ :  3.03/00 25/09/2015  15.02.58  by  Michael Scheer
*CMZ :  3.02/09 08/07/2015  12.22.02  by  Michael Scheer
*CMZ :  3.02/06 12/06/2015  15.06.01  by  Michael Scheer
*CMZ :  3.02/05 22/03/2015  19.47.46  by  Michael Scheer
*CMZ :  3.02/04 11/03/2015  13.46.12  by  Michael Scheer
*CMZ :  3.02/03 10/11/2014  11.01.30  by  Michael Scheer
*CMZ :  3.02/00 09/09/2014  13.16.05  by  Michael Scheer
*CMZ :  3.01/10 14/08/2014  14.43.07  by  Michael Scheer
*CMZ :  3.01/08 04/07/2014  09.03.18  by  Michael Scheer
*CMZ :  3.01/06 20/06/2014  16.28.51  by  Michael Scheer
*CMZ :  3.01/01 18/09/2013  12.33.23  by  Michael Scheer
*CMZ :  3.01/00 18/07/2013  11.34.23  by  Michael Scheer
*CMZ :  3.00/02 08/04/2013  14.49.02  by  Michael Scheer
*CMZ :  3.00/01 20/03/2013  14.29.33  by  Michael Scheer
*CMZ :  3.00/00 14/03/2013  10.24.03  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.70/11 22/02/2013  14.32.53  by  Michael Scheer
*CMZ :  2.70/09 15/01/2013  13.58.17  by  Michael Scheer
*CMZ :  2.70/08 14/01/2013  17.39.36  by  Michael Scheer
*CMZ :  2.70/07 14/01/2013  16.55.40  by  Michael Scheer
*CMZ :  2.70/06 03/01/2013  15.40.36  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  14.05.34  by  Michael Scheer
*CMZ :  2.70/04 21/12/2012  10.03.13  by  Michael Scheer
*CMZ :  2.70/01 12/12/2012  12.39.56  by  Michael Scheer
*CMZ :  2.69/02 05/11/2012  12.35.44  by  Michael Scheer
*CMZ :  2.69/00 30/10/2012  16.25.27  by  Michael Scheer
*CMZ :  2.68/05 18/10/2012  09.38.10  by  Michael Scheer
*CMZ :  2.68/03 27/08/2012  15.39.32  by  Michael Scheer
*CMZ :  2.68/02 01/08/2012  14.02.50  by  Michael Scheer
*CMZ :  2.68/01 29/05/2012  16.08.27  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  09.56.07  by  Michael Scheer
*CMZ :  2.67/06 24/05/2012  12.11.08  by  Michael Scheer
*CMZ :  2.67/05 16/05/2012  13.53.49  by  Michael Scheer
*CMZ :  2.67/04 15/05/2012  12.59.15  by  Michael Scheer
*CMZ :  2.67/02 08/05/2012  16.36.00  by  Michael Scheer
*CMZ :  2.67/00 16/02/2012  13.07.31  by  Michael Scheer
*CMZ :  2.66/22 22/11/2011  13.58.07  by  Michael Scheer
*CMZ :  2.66/20 22/11/2011  10.45.51  by  Michael Scheer
*CMZ :  2.66/17 23/11/2010  10.01.44  by  Michael Scheer
*CMZ :  2.66/16 22/11/2010  14.00.45  by  Michael Scheer
*CMZ :  2.66/13 15/07/2010  12.58.56  by  Michael Scheer
*CMZ :  2.66/12 20/05/2010  09.00.48  by  Michael Scheer
*CMZ :  2.66/09 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.66/07 10/03/2010  12.23.23  by  Michael Scheer
*CMZ :  2.66/06 27/11/2009  15.57.31  by  Michael Scheer
*CMZ :  2.66/04 24/11/2009  08.18.52  by  Michael Scheer
*CMZ :  2.66/03 16/11/2009  13.49.00  by  Michael Scheer
*CMZ :  2.65/03 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  2.65/02 29/09/2009  09.24.12  by  Michael Scheer
*CMZ :  2.64/01 14/09/2009  15.19.42  by  Michael Scheer
*CMZ :  2.64/00 18/08/2009  15.17.59  by  Michael Scheer
*CMZ :  2.63/05 12/08/2009  08.49.28  by  Michael Scheer
*CMZ :  2.63/03 15/04/2008  09.57.05  by  Michael Scheer
*CMZ :  2.63/02 13/03/2008  15.28.16  by  Michael Scheer
*CMZ :  2.63/00 10/01/2008  12.43.13  by  Michael Scheer
*CMZ :  2.62/02 16/07/2007  08.39.06  by  Michael Scheer
*CMZ :  2.61/05 11/04/2007  11.58.30  by  Michael Scheer
*CMZ :  2.61/02 26/03/2007  20.08.09  by  Michael Scheer
*CMZ :  2.60/00 26/01/2007  10.48.21  by  Michael Scheer
*CMZ :  2.59/01 24/01/2007  14.13.43  by  Michael Scheer
*CMZ :  2.58/00 16/01/2007  12.28.50  by  Michael Scheer
*CMZ :  2.57/05 13/12/2006  10.49.24  by  Michael Scheer
*CMZ :  2.57/00 22/11/2005  09.53.36  by  Michael Scheer
*CMZ :  2.56/02 21/10/2005  13.13.47  by  Michael Scheer
*CMZ :  2.56/00 17/10/2005  12.32.39  by  Michael Scheer
*CMZ :  2.55/00 10/08/2005  13.53.39  by  Michael Scheer
*CMZ :  2.54/07 16/06/2005  09.40.54  by  Michael Scheer
*CMZ :  2.54/06 02/06/2005  13.53.54  by  Michael Scheer
*CMZ :  2.54/05 02/06/2005  08.14.28  by  Michael Scheer
*CMZ :  2.54/01 07/03/2005  10.32.21  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  11.05.51  by  Michael Scheer
*CMZ :  2.52/16 07/01/2005  16.08.34  by  Michael Scheer
*CMZ :  2.52/15 05/01/2005  16.24.14  by  Michael Scheer
*CMZ :  2.52/13 16/12/2004  21.13.02  by  Michael Scheer
*CMZ :  2.52/10 08/12/2004  13.39.18  by  Michael Scheer
*CMZ :  2.52/09 29/10/2004  11.12.01  by  Michael Scheer
*CMZ :  2.52/05 16/08/2004  13.37.21  by  Michael Scheer
*CMZ :  2.52/00 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.51/02 22/06/2004  13.57.32  by  Michael Scheer
*CMZ :  2.51/01 16/06/2004  17.05.27  by  Michael Scheer
*CMZ :  2.51/00 26/05/2004  16.17.52  by  Michael Scheer
*CMZ :  2.50/02 30/04/2004  15.27.48  by  Michael Scheer
*CMZ :  2.50/00 29/04/2004  17.07.53  by  Michael Scheer
*CMZ :  2.49/00 19/03/2004  17.58.17  by  Michael Scheer
*CMZ :  2.48/04 16/03/2004  10.43.05  by  Michael Scheer
*CMZ :  2.48/03 03/03/2004  12.49.38  by  Michael Scheer
*CMZ :  2.47/23 17/02/2004  11.00.48  by  Michael Scheer
*CMZ :  2.47/18 27/11/2003  14.31.04  by  Michael Scheer
*CMZ :  2.47/15 08/08/2003  10.34.03  by  Michael Scheer
*CMZ :  2.47/14 07/08/2003  09.42.49  by  Michael Scheer
*CMZ :  2.47/12 03/07/2003  09.22.07  by  Michael Scheer
*CMZ :  2.47/10 28/05/2003  15.25.10  by  Michael Scheer
*CMZ :  2.47/09 27/05/2003  15.50.23  by  Michael Scheer
*CMZ :  2.47/08 16/05/2003  14.34.52  by  Michael Scheer
*CMZ :  2.47/07 14/04/2003  14.14.46  by  Michael Scheer
*CMZ :  2.47/06 28/03/2003  15.40.34  by  Michael Scheer
*CMZ :  2.47/04 13/03/2003  09.59.14  by  Michael Scheer
*CMZ :  2.47/03 12/03/2003  15.45.44  by  Michael Scheer
*CMZ :  2.44/01 11/12/2002  11.15.11  by  Michael Scheer
*CMZ :  2.44/00 08/11/2002  11.15.00  by  Michael Scheer
*CMZ :  2.41/13 02/09/2002  15.35.59  by  Michael Scheer
*CMZ :  2.41/07 15/07/2002  16.10.05  by  Michael Scheer
*CMZ :  2.41/06 10/05/2002  15.24.47  by  Michael Scheer
*CMZ :  2.41/03 21/03/2002  12.44.08  by  Michael Scheer
*CMZ :  2.41/02 21/03/2002  12.41.22  by  Michael Scheer
*CMZ :  2.41/00 20/03/2002  14.16.00  by  Michael Scheer
*CMZ :  2.40/03 20/03/2002  12.31.55  by  Michael Scheer
*CMZ :  2.38/00 13/12/2001  11.26.22  by  Michael Scheer
*CMZ :  2.37/06 07/12/2001  15.01.29  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.35/02 30/10/2001  17.13.56  by  Michael Scheer
*CMZ :  2.34/09 19/09/2001  13.39.52  by  Michael Scheer
*CMZ :  2.34/08 11/09/2001  14.21.00  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  10.25.20  by  Michael Scheer
*CMZ :  2.34/03 11/07/2001  11.18.43  by  Michael Scheer
*CMZ :  2.34/01 01/06/2001  15.26.15  by  Michael Scheer
*CMZ :  2.33/06 04/05/2001  13.56.33  by  Michael Scheer
*CMZ :  2.33/00 03/05/2001  10.35.09  by  Michael Scheer
*CMZ :  2.32/04 26/04/2001  12.17.53  by  Michael Scheer
*CMZ :  2.32/03 26/04/2001  11.11.52  by  Michael Scheer
*CMZ :  2.32/02 26/04/2001  11.09.09  by  Michael Scheer
*CMZ :  2.31/01 25/04/2001  15.12.03  by  Michael Scheer
*CMZ :  2.30/04 23/04/2001  12.32.14  by  Michael Scheer
*CMZ :  2.30/03 20/04/2001  16.29.29  by  Michael Scheer
*CMZ :  2.20/10 05/04/2001  16.02.13  by  Michael Scheer
*CMZ :  2.20/09 23/03/2001  11.10.39  by  Michael Scheer
*CMZ :  2.20/03 21/02/2001  14.28.56  by  Michael Scheer
*CMZ :  2.20/01 20/02/2001  14.28.03  by  Michael Scheer
*CMZ :  2.20/00 07/11/2000  18.38.35  by  Michael Scheer
*CMZ :  2.17/00 07/11/2000  18.36.28  by  Michael Scheer
*CMZ :  2.16/09 01/11/2000  19.18.54  by  Michael Scheer
*CMZ :  2.16/08 01/11/2000  18.46.41  by  Michael Scheer
*CMZ :  2.16/07 13/10/2000  12.33.36  by  Michael Scheer
*CMZ :  2.16/05 25/08/2000  16.07.46  by  Michael Scheer
*CMZ :  2.16/04 21/07/2000  14.48.52  by  Michael Scheer
*CMZ :  2.16/03 19/06/2000  12.19.35  by  Michael Scheer
*CMZ :  2.16/02 15/06/2000  17.28.05  by  Michael Scheer
*CMZ :  2.16/01 15/06/2000  17.27.10  by  Michael Scheer
*CMZ :  2.16/00 15/06/2000  12.08.02  by  Michael Scheer
*CMZ :  2.15/00 19/05/2000  11.05.28  by  Michael Scheer
*CMZ :  2.14/02 19/04/2000  17.14.40  by  Michael Scheer
*CMZ :  2.14/01 19/04/2000  13.54.26  by  Michael Scheer
*CMZ :  2.14/00 19/04/2000  11.58.09  by  Michael Scheer
*CMZ :  2.13/10 23/03/2000  13.06.35  by  Michael Scheer
*CMZ :  2.13/11 10/03/2000  15.07.30  by  Michael Scheer
*CMZ :  2.13/10 09/03/2000  17.39.34  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  18.08.34  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  17.10.43  by  Michael Scheer
*CMZ :  2.13/08 02/03/2000  12.13.35  by  Michael Scheer
*CMZ :  2.13/07 18/02/2000  12.32.29  by  Michael Scheer
*CMZ :  2.13/04 24/01/2000  17.59.24  by  Michael Scheer
*CMZ :  2.13/02 14/12/99  16.41.31  by  Michael Scheer
*CMZ :  2.13/00 26/10/99  15.40.04  by  Michael Scheer
*CMZ :  2.12/04 27/08/99  12.30.27  by  Michael Scheer
*CMZ :  2.12/03 06/08/99  15.36.20  by  Michael Scheer
*CMZ :  2.12/02 15/06/99  16.13.28  by  Michael Scheer
*CMZ :  2.12/01 14/06/99  15.34.53  by  Michael Scheer
*CMZ :  2.12/00 04/06/99  13.28.31  by  Michael Scheer
*CMZ :  2.11/01 12/05/99  12.19.46  by  Michael Scheer
*CMZ :  2.11/00 11/05/99  16.21.08  by  Michael Scheer
*CMZ :  2.10/02 07/05/99  12.23.41  by  Michael Scheer
*CMZ :  2.10/01 17/03/99  18.20.52  by  Michael Scheer
*CMZ :  2.02/00 15/02/99  10.20.15  by  Michael Scheer
*CMZ :  2.01/00 21/01/99  16.58.37  by  Michael Scheer
*CMZ :  2.00/03 13/01/99  10.57.51  by  Michael Scheer
*CMZ :  2.00/01 11/01/99  16.06.57  by  Michael Scheer
*CMZ :  2.00/00 11/01/99  16.04.55  by  Michael Scheer
*CMZ :  1.04/03 11/12/98  16.57.07  by  Michael Scheer
*CMZ :  1.04/02 11/12/98  11.35.47  by  Michael Scheer
*CMZ :  1.04/01 11/12/98  11.21.43  by  Michael Scheer
*CMZ :  1.04/00 11/12/98  10.45.26  by  Michael Scheer
*CMZ :  1.03/06 02/10/98  15.51.15  by  Michael Scheer
*CMZ :  1.03/05 27/04/98  13.57.17  by  Michael Scheer
*CMZ :  1.03/04 27/03/98  14.22.25  by  Michael Scheer
*CMZ :  1.03/02 23/02/98  14.31.16  by  Michael Scheer
*CMZ :  1.03/01 10/02/98  17.33.38  by  Michael Scheer
*CMZ :  1.03/00 16/01/98  14.55.02  by  Michael Scheer
*CMZ :  1.02/05 16/01/98  11.00.30  by  Michael Scheer
*CMZ :  1.02/04 16/01/98  10.59.38  by  Michael Scheer
*CMZ :  1.02/02 06/01/98  17.07.13  by  Michael Scheer
*CMZ :  1.02/00 06/01/98  14.56.08  by  Michael Scheer
*CMZ :  1.01/01 10/12/97  13.23.56  by  Michael Scheer
*CMZ :  1.01/00 04/12/97  15.59.21  by  Michael Scheer
*CMZ :  1.00/04 21/10/97  13.41.08  by  Michael Scheer
*CMZ :  1.00/03 20/10/97  15.20.55  by  Michael Scheer
*CMZ :  1.00/02 20/10/97  15.15.32  by  Michael Scheer
*CMZ :  1.00/00 29/09/97  17.11.38  by  Michael Scheer
*CMZ : 00.02/05 16/04/97  16.32.33  by  Michael Scheer
*CMZ : 00.02/04 25/02/97  17.37.37  by  Michael Scheer
*CMZ : 00.02/03 31/01/97  11.25.25  by  Michael Scheer
*CMZ : 00.02/02 15/01/97  13.21.25  by  Michael Scheer
*CMZ : 00.02/01 18/12/96  13.23.11  by  Michael Scheer
*CMZ : 00.01/12 07/10/96  13.32.57  by  Michael Scheer
*CMZ : 00.01/10 02/09/96  13.52.46  by  Michael Scheer
*CMZ : 00.01/09 28/05/96  12.08.51  by  Michael Scheer
*CMZ : 00.01/08 17/07/95  16.20.53  by  Michael Scheer
*CMZ : 00.01/07 23/03/95  11.36.42  by  Michael Scheer
*CMZ : 00.01/04 27/01/95  10.15.13  by  Michael Scheer
*CMZ : 00.01/03 28/11/94  12.04.13  by  Michael Scheer
*CMZ : 00.01/02 22/11/94  10.20.21  by  Michael Scheer
*CMZ : 00.01/01 23/06/94  13.25.42  by  Michael Scheer
*CMZ : 00.01/00 21/06/94  09.57.03  by  Michael Scheer
*CMZ : 00.00/07 25/05/94  17.37.44  by  Michael Scheer
*CMZ : 00.00/06 29/04/94  21.08.08  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  18.05.26  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.33  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE GFINIT(BETX0,BETY0,BETZ0,BETXF0,BETYF0,BETZF0,
     &                     DTIM,BSHIFT,GAMMA)
+seq,gplhint.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,WFOLDF90U.
+SEQ,TRACKF90U.
+SEQ,WBETAF90U.
+SEQ,BPOLYMAGF90U.
+SEQ,bwpolyederf90U.

      use omp_lib
      use ompmod
      use bunchmod
      use clustermod
      use f1k
      !use waveenv
      use fbtabzymod
      !use waveenv

      IMPLICIT NONE

+seq,datetime.
+SELF,IF=LINUX.
      EXTERNAL DCOSD,DSIND
      DOUBLE PRECISION  DCOSD,DSIND
+SELF.

      INTEGER IGFNUM,ICOMP,ISTORE,IAMBI,I,IELEM,ISTO,IROI,JWSECTMAGS,
     &  KSUM,lun,idum,lunsi,ieof,istat,iclusterold

      DOUBLE PRECISION BETX0,BETY0,BETZ0,ZP0,YP0,ZPF0,YPF0,
     &  BETXF0,BETYF0,BETZF0,BTAPV,BTAPH,dtshort,
     &  DTIM,BSHIFT,GAMMA,XJUST,YJUST,XSTARTO,XSTOPO

      DOUBLE PRECISION ZP,YP,VXINO,VYINO,VZINO,YSTARTO,ZSTARTO
     &  ,GAMMAL,gamma1,omegac,emom1,rho1,vxi,vyi,vzi,
     &  wlen1,rhv,park,b0eff

+SELF,IF=-NOCMPLX.
      COMPLEX*16 VPOLAN
+SELF,IF=NOCMPLX.
      DOUBLE PRECISION VPOLAN
+SELF.
      DOUBLE PRECISION VSTO

      DOUBLE PRECISION BETA,VN,V0,ENERGV
      DOUBLE PRECISION BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM,DUM
      DOUBLE PRECISION ENEGEV,TAUPOL0,TAUPOL0EP,BSTORE,BSTORE2,BSTORE2Z
      DOUBLE PRECISION BDIPL1G,POLFC1G,POLLV1G,TAUPL1G,EMINPOL
      DOUBLE PRECISION BDIPLEP,POLFCEP,ASTORE,XSTOPR
      DOUBLE PRECISION BSTOREY,BSTOREZ,ASTOREZ,ASTOREY
      DOUBLE PRECISION BY,RI,TANPHI,BANA,BPANA,BANAC,BPANAC,
     &  YCEN,ZCEN,YPCEN,ZPCEN

+SEQ,CMPARA.
+seq,pawcmn.
+SEQ,CONTRL.
+SEQ,B0SCGLOB.
+SEQ,MYFILES.
+SEQ,OPTIC.
+SEQ,BFELD.
+SEQ,mgsqc.
+SEQ,HALBACH.
+SEQ,HALBASY.
+SEQ,undugap.
+SEQ,FOURIER.
+SEQ,TRANPO.
+SEQ,DEPOLA.
+SEQ,WLSOPT.
+SEQ,TRACK.
+SEQ,BETAWLS.
+seq,wbetaf90.
+SEQ,PHYCON.
+SEQ,COLLI.
+seq,reargf90.
+seq,sourcef90.
+SEQ,SPECT.
+SEq,wfoldf90.
+SEq,observf90.
+SEQ,FREQS.
+SEQ,UCROSS.
+SEQ,ELLIP.
+SEQ,ELLANA.
+SEQ,WBTAB.
+SEQ,USERVAR.
+SEQ,KLOTZ.
+SEQ,MODULATOR.
+SEQ,BMAP.
+SEQ,BAMWLS.
+SEQ,BPOLY3D.
+SEQ,BPOLY2DH.
+SEQ,BPHARM.
+SEQ,BPOLY3DG.
+SEQ,BHELM.
+SEQ,TRALIN.
+SEQ,PHASETRACK.
+SEQ,SPECDIP.
+SEQ,BFORCE.
+SEq,phasef90.
+SEQ,AMPLI.
+SEQ,BERROR.
+SEQ,CMZSEL.
+SEQ,GENESIS.
+SEQ,TRACK0.
+seq,primkin.
+seq,efield.
+seq,photon.
c+seq,gseed,if=grndm.
+seq,random.
+seq,ustep.
+seq,whbook.
+seq,undumagc.
+seq,waveenv.

      integer irootmode
      character(32) c32

+SELF,IF=-newwave.
      stop '**** +self,if=newwave ist erforderlich! ***'
+SELF.
+SELF,IF=-f90.
      stop '**** +self,if=f90 ist erforderlich! ***'
+SELF.
+SELF,IF=NOCMPLX.
      stop '**** +self,if=nocmplx ist obsolet! ***'
+SELF.

C--- LOGICAL UNITS
      LUNGFI=15
      LUNGFO=16
      FILEI='wave.in'
      FILEGFO='wave.out'
+SELF,IF=HPUX,TRUE64.
      call system('rm wave.out 2>/dev/null')
      CALL UNCOMNAMELIST
      FILEI='wave.in.linux'
      FILEGFO='wave.out'
+SELF,IF=VMS.
      FILEI='WI:WAVE.IN'
      FILEGFO='WO:WAVE.OUT'
+SELF.

C--- CHECK CMZ-SELECTIONS{

      IXAMAG_I=0
      ICMZF90=1

+SELF,IF=NEWWAVE.
      ICMZNEWWAVE=1
+SELF.

+SELF,IF=F90.
      ICMZNOCMPLX=1
+SELF.

+SELF,IF=VMS.
      ICMZVMS=1
+SELF,IF=-VMS.
      ICMZVMS=0
+SELF.

+SELF,IF=HPUX.
      ICMZHPUX=1
+SELF,IF=-HPUX.
      ICMZHPUX=0
+SELF.

+SELF,IF=TRUE64.
        ICMZTRUE64=1
+SELF,IF=-TRUE64.
        ICMZTRUE64=0
+SELF.

+SELF,IF=LINUX.
      ICMZLINUX=1
+SELF,IF=-LINUX.
      ICMZLINUX=0
+SELF.

+SELF,IF=WINDOWS.
      ICMZWINDOWS=1
+SELF,IF=-WINDOWS.
      ICMZWINDOWS=0
+SELF.

        IF (ABS(ICMZVMS)+ABS(ICMZLINUX)+ABS(ICMZHPUX)+ABS(ICMZTRUE64)+
     &      ABS(ICMZWINDOWS).NE.1) THEN
          WRITE(6,*)'*** BAD CMZ-SELECTION VMS, LINUX OR WINDOWS ***'
          STOP
      ENDIF

+seq,setf1k.

C--- CHECK CMZ-SELECTIONS}

C     CALL UTIL_TEST_BATCH(IBATCH)

      fouentr=-9999.
      fouexit=-9999.
      scbfour=-9999.
      xshbfour=-9999.

      XINTER=-9999.
      xbetfun=9999.
      IW_BLEN=0
      IW_BLENF=0
      IW_CIRC=0

      BMAXGL2=-1.0D30

C--- PHYSICAL CONSTANTS

+seq,phycon1.

+SELF,IF=LINUX,WINDOWS.
      XMX=-1.0D30
      YMX=-1.0D30
      ZMX=-1.0D30
      BXMX=-1.0D30
      BYMX=-1.0D30
      BZMX=-1.0D30
      PHIMX=-1.0D30
      XMN=1.0D30
      YMN=1.0D30
      ZMN=1.0D30
      BXMN=1.0D30
      BYMN=1.0D30
      BZMN=1.0D0
      PHIMN=1.0D30
+SELF.

C--- STORE DIMENSION-PARAMETERS

      NDPOL=NDPOLP
      NDOBSVZ=NDOBSVZP
      NDOBSVY=NDOBSVYP
      NDMASHZ=NDMASHZP
      NDMASHY=NDMASHYP
+self,if=-mhbook.
      NDPAWC=NDPAWCP
+self.
      NDARGU=NDARGUP
      NDFREQ=NDFREQP
      NDOBSV=NDOBSVP
      NWMAX=NWMAXP
      NBETA=NBETAP
C5.10.95      NBDIM=NBDIMP
      LIDIM=LIDIMP
      NOMDIM=NOMDIMP
      IBFDIM4=IBFDIM4P
      IBFDIM2=IBFDIM2P
      NXPAN=NXPANP
      NYPAN=NYPANP
      NBTAB=NBTABP
      NDWSOU=NDWSOUP
      NGCOEF=NGCOEFP
      NDSPAR=NDSPARP

      IF(NDOBSVZ*NDOBSVY.NE.NDOBSV) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'     DIMENSION DECLARATIONS NOT CONSISTENT'
        WRITE(LUNGFO,*)'     NDOBSVP MUST BE EQUAL TO NDOBSVZP*NDOBSVYP'
        WRITE(LUNGFO,*)'     CHANGE PARAMETER IN CMPARA.CMN'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'     *** ERROR IN GFINIT ***'
        WRITE(6,*)'     DIMENSION DECLARATIONS NOT CONSISTENT'
        WRITE(6,*)'     NDOBSVP MUST BE EQUAL TO NDOBSVZP*NDOBSVYP'
        WRITE(6,*)'     CHANGE PARAMETER IN CMPARA.'
        WRITE(6,*)
        STOP
      ENDIF

C--- READ PARAMETER AND CONTRL-FLAGS FROM NAMELISTS

      iclusterold=icluster

      userchar=''
      user=0.0d0

      OPEN (UNIT=LUNGFI,FILE=FILEI,STATUS='OLD')

      READ(LUNGFI, CONTRL )
+SELF,if=grndm.
c      READ(LUNGFI,gseedn)
+SELF.,if=grndm.
      READ(LUNGFI,randomn)
      READ(LUNGFI,cluster)
c     WRITE(6,*)'READING NAMELIST B0SCGLOBN'
      READ(LUNGFI, B0SCGLOBN )
      IF(IBHELM.NE.0 ) WRITE(6,*)'READING NAMELIST BBHELM'
      IF(IBHELM.NE.0 ) READ(LUNGFI, BBHELM )
c     WRITE(6,*)'READING NAMELIST BBFELD'
      READ(LUNGFI, BBFELD )
c     WRITE(6,*)'READING NAMELIST HALBACH'
      READ(LUNGFI, HALBACH )
c     WRITE(6,*)'READING NAMELIST HALBASY'
      READ(LUNGFI, HALBASY )
      READ(LUNGFI, undugapn)
c     WRITE(6,*)'READING NAMELIST UCROSSN'
      READ(LUNGFI, UCROSSN )
c     WRITE(6,*)'READING NAMELIST ELLIPN'
      READ(LUNGFI, ELLIPN )
c     WRITE(6,*)'READING NAMELIST ELLANAN'
      READ(LUNGFI, ELLANAN )
c     WRITE(6,*)'READING NAMELIST FOURIER'
      READ(LUNGFI, FOURIER )
      if (ifourbtabzy.ne.0) READ(LUNGFI, fbtabzyn )
c     WRITE(6,*)'READING NAMELIST DEPOLA'
      READ(LUNGFI, DEPOLA )
c     WRITE(6,*)'READING NAMELIST WLSOPTN'
      READ(LUNGFI, WLSOPTN )
c     WRITE(6,*)'READING NAMELIST MYFILES'
      READ(LUNGFI, MYFILES )
c     WRITE(6,*)'READING NAMELIST TRALINN'
      READ(LUNGFI, TRALINN )
c     WRITE(6,*)'READING NAMELIST PHASETRACKN'
      READ(LUNGFI, PHASETRACKN )
c     WRITE(6,*)'READING NAMELIST OPTIK'
      READ(LUNGFI, OPTIK )
c     WRITE(6,*)'READING NAMELIST TRANPON'
      READ(LUNGFI, TRANPON )
c     WRITE(6,*)'READING NAMELIST COLLIN'
      READ(LUNGFI, COLLIN )
c     WRITE(6,*)'READING NAMELIST SPECTN'
      READ(LUNGFI, SPECTN )
c     WRITE(6,*)'READING NAMELIST WFOLDN'
      READ(LUNGFI, WFOLDN )
      READ(LUNGFI,BUNCHN)
c     WRITE(6,*)'READING NAMELIST PINHOLE'
      READ(LUNGFI, PINHOLE )
c     WRITE(6,*)'READING NAMELIST FREQN'
      READ(LUNGFI, FREQN )
c     WRITE(6,*)'READING NAMELIST WBTABN'
      READ(LUNGFI, WBTABN )
c     WRITE(6,*)'READING NAMELIST RECN'
      READ(LUNGFI, RECN )
c     WRITE(6,*)'READING NAMELIST MODUN'
      READ(LUNGFI, MODUN )
c      IF (kbundumag.ne.0) THEN
        READ(LUNGFI,unduhybridn)
        READ(LUNGFI,undumagn)
        kbundumag_c=kbundumag
        kbunduverb_c=kbunduverb
        kbundumap_c=kbundumap
c      ENDIF
      IF (KBPOLYMAG.GT.0) THEN
c        WRITE(6,*)'READING NAMELIST POLYMAGN'
        READ(LUNGFI,POLYMAGN)
      ENDIF
c     WRITE(6,*)'READING NAMELIST BMAPN'
      READ(LUNGFI, BMAPN )
c     WRITE(6,*)'READING NAMELIST BAMWLSN'
      IF (KBAMWLS.NE.0) READ(LUNGFI, BAMWLSN )
c     WRITE(6,*)'READING NAMELIST BPOLY3DN'
      READ(LUNGFI, BPOLY3DN )
c     WRITE(6,*)'READING NAMELIST BPOLY2DHN'
      READ(LUNGFI, BPOLY2DHN )
c     WRITE(6,*)'READING NAMELIST BPHARMN'
      READ(LUNGFI, BPHARMN )
c     WRITE(6,*)'READING NAMELIST BGRIDN'
      READ(LUNGFI, BGRIDN )
c     WRITE(6,*)'READING NAMELIST SPECDIPN'
      READ(LUNGFI, SPECDIPN )

C--- READ AND WRITE CURRENT NUMBER

      OPEN(UNIT=LUNCOD,FILE=FILECOD,STATUS='OLD',FORM='FORMATTED',
     &       ERR=99)
          READ(LUNCOD,*,ERR=99)IGFNUM

99    IGFNUM=IGFNUM+1

      CLOSE(LUNCOD)
+SELF,IF=VMS.
      OPEN(UNIT=LUNCOD,FILE=FILECOD,STATUS='NEW',FORM='FORMATTED')
+SELF,IF=LINUX,WINDOWS,HPUX,TRUE64.
      OPEN(UNIT=LUNCOD,FILE=FILECOD,status='unknown',FORM='FORMATTED')
      REWIND(LUNCOD)
+SELF.
      WRITE(LUNCOD,*)IGFNUM
      ICODE=IGFNUM
C          IF(IGFLOAT.NE.0) ICODE=-ICODE
      CLOSE(LUNCOD)

C--- OPEN OUTPUT-FILE

      call util_file_delete(trim(filegfo),istat)
      OPEN (UNIT=LUNGFO,FILE=FILEGFO)

      CALL ZEIT(LUNGFO)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'          *********************************************'
      WRITE(LUNGFO,*)'          *          PROGRAM WAVE                     *'
      WRITE(LUNGFO,*)'          *                                           *'
      WRITE(LUNGFO,*)
+SEQ,WVERSION.
      WRITE(LUNGFO,*)'          *                                           *'
      WRITE(LUNGFO,*)'          *          Michael Scheer                   *'
      WRITE(LUNGFO,*)'          *              BESSY                        *'
      WRITE(LUNGFO,*)'          *********************************************'
      WRITE(LUNGFO,*)

      write(lungfo,*)
      write(lungfo,*)"     Compiler-Version: ",trim(chcompiler)
      write(lungfo,*)"     Hostname: ",trim(chhostname)
      write(lungfo,*)"     Working directory: ",trim(chcwd)
      write(lungfo,*)

      WRITE(LUNGFO,*)'     USER COMMENT:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     ',CODE
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     CURRENT NUMBER:',ICODE
      WRITE(LUNGFO,*)


      WRITE(6,*)
      WRITE(6,*)
      WRITE(6,*)'          USER COMMENT:'
      WRITE(6,*)
      WRITE(6,*)'          ',CODE
      WRITE(6,*)
      WRITE(6,*)'          CURRENT NUMBER:',ICODE
      WRITE(6,*)

      WRITE(LUNGFO,*)

      icluster=iclusterold

      if (ibunch.ne.0) then
c        if (iundulator.ne.2) then
c          mthreads=0
c        endif
        if (nbunch.le.0) nbunch=1
        if (neinbunch.le.0) neinbunch=1
      endif

      if (iemit.ne.0.or.ibunch.ne.0) imagspln=0

C--- USER MAY OVERWRITE HERE VARIABLES OF NAMELISTS

      mmedgey=0 !3.4.2019, to avoid trouble with OMP
      mmedgez=0

      IF (IUNAME.NE.0) THEN
        CALL UNAME
        IF (IABEND.EQ.5) goto 9999
      ENDIF

      if (kbrec.ne.0.and.scaladd.eq.0.0d0.and.scalkl.eq.0.0d0
     &    .and.irecmodu.eq.0.and.irecu.eq.0) then
        irecu=1
      endif

+self,if=xxnoroot.
      if (iroothdf5.ne.0.or.iroottrees.ne.0) then
        print*
        write(6,*)'*** Warning in gfinit:'
        print*,'CERN package ROOT is not available'
        write(6,*)'for this version of WAVE, use ROOT-macro mhbook_to_root.C '
        print*,'to convert WAVE.mhb etc..'
        iroothdf5=0
        iroottrees=0
      endif
+self.
      if (nocern.ne.0) iroottrees=0
+self,if=-noroot.
      if (iroothdf5.ne.0.and.iroottrees.eq.0) iroottrees=-1
      if (ihisascii.ne.0.and.iroottrees.lt.0) then
        iroottrees=1
        write(6,*)''
        write(6,*)'*** WARNING: IROOTREES SET TO 1, DUE TO IHISASCII'
        write(6,*)''
        write(LUNGFO,*)''
        write(LUNGFO,*)'*** WARNING: IROOTREES SET TO 1, DUE TO IHISASCII'
        write(LUNGFO,*)''
      endif

      irootmode=0
      if (iroottrees.ne.0) call rootini(irootmode)
+self.

      kefield=iefield

      IF (BMOVECUT.LE.0.0D0) BMOVECUT=1.0D-6

      IF (IBFORCE.NE.0) THEN
+SELF,IF=LINUX,WINDOWS.
c     WRITE(6,*)'READING NAMELIST BFORCN'
+SELF.
        READ(LUNGFI,BFORCN)
      ENDIF

      IF (MPINZ.LE.0) MPINZ=1
      IF (MPINY.LE.0) MPINY=1

      IF (IF1DIM.NE.0) THEN
        IF1DIM=1
      ENDIF

      IF (IPHASE.NE.0) THEN
        DO IELEM=1,NPHELEMP
          PHELEM(1,1,IELEM)=1.0D0
          PHELEM(2,2,IELEM)=1.0D0
          PHELEM(3,3,IELEM)=1.0D0
          PHELEM(4,4,IELEM)=1.0D0
          PHELEM(5,1,IELEM)=-1.0D30
          PHELEM(5,2,IELEM)=+1.0D30
          PHELEM(5,3,IELEM)=-1.0D30
          PHELEM(5,4,IELEM)=+1.0D30
        ENDDO
+SELF,IF=LINUX,WINDOWS.
c     WRITE(6,*)'READING NAMELIST PHASEN'
+SELF.
        READ(LUNGFI,PHASEN)
      ENDIF

      if (ibunch.ne.0.and.neinbunch.gt.1.and.icluster.gt.0) then
        if (neinbunch.ne.(neinbunch/nwgood)*nwgood) then
          write(lungfo,*)"Warning in GFINIT: NEINBUNCH changed to fit number of WAVE instances ***"
          neinbunch=(neinbunch/nwgood)*nwgood
          write(lungfo,*)"New value:", neinbunch
          print*,"Warning in GFINIT: NEINBUNCH changed to fit number of WAVE instances ***"
          neinbunch=(neinbunch/nwgood)*nwgood
          print*,"New value:", neinbunch
        endif
      endif

      if (neinbunch.gt.0.and.bunchcharge.eq.-9999.)
     &  bunchcharge=echarge1*neinbunch

      if (ibunch.eq.0) then
        iubunch=0
        neinbunch=0
        nbunch=0
      else
        if (ispecdip.ne.0) then
          print*,"*** Error: ISPECDIP is not allowed for IBUNCH option ***"
          iabend=11
          goto 9999
        endif
      endif

      nbuncho=nbunch
      neinbuncho=neinbunch

      IF (KAMPLI.NE.0.or.iundulator.eq.2) THEN
        READ(LUNGFI,PHASEREPN)
        if (ibunch.ne.0.and.nbunch.ne.1.and.neinbunch.ne.1) then
          write(lungfo,*)'*** Error in GFINIT: For IUNDULATOR=2 or KAMPLI.ne.0, one of NBUNCH or NEINBUNCH must be one ***'
          stop '*** Error in GFINIT: For IUNDULATOR=2 or KAMPLI.ne.0, one of NBUNCH or NEINBUNCH must be one ***'
        endif
        if (noespreadph.ne.0) phrespread=0.0d0
        if (noemitph.ne.0) then
          phremith=0.0d0
          phremitv=0.0d0
        endif
      ENDIF

c      IF (IAMPLI.NE.0.or.ibunch.ne.0.or.iundulator.eq.2) THEN
        READ(LUNGFI,AMPLIN)
c        IF (IAMPLI.LT.0) IAMPSKIP=0
c      ENDIF

+SELF,IF=LINUX,WINDOWS.
c     WRITE(6,*)'READING NAMELIST ROIN'
+SELF.
      READ(LUNGFI,ROIN)

+SELF,IF=LINUX,WINDOWS.
c     WRITE(6,*)'READING NAMELIST BERRORN'
+SELF.
      READ(LUNGFI, BERRORN )
      ihphotons=0
      if (ieneloss.lt.0) read(lungfi,photonn)
+SELF,IF=LINUX,WINDOWS.
c     WRITE(6,*)'READING NAMELIST USERN'
+SELF.
      READ(LUNGFI,USERN)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     USER NAMELIST:'
      WRITE(LUNGFO,*)
      DO I=1,1000
        write(c32,*) i
        IF (USER(I).NE.0.0d0) THEN
          WRITE(LUNGFO,*)'     USER('//trim(adjustl(c32))//'): ',USER(I)
        ENDIF
      ENDDO
      WRITE(LUNGFO,*)
      DO I=1,1000
        write(c32,*) i
        IF (USERCHAR(I).NE.'') THEN
          WRITE(LUNGFO,*)'     USERCHAR('//trim(adjustl(c32))//'): ',USERCHAR(I)
        ENDIF
      ENDDO
      WRITE(LUNGFO,*)
+SELF,IF=LINUX,WINDOWS.
      WRITE(6,*)
      WRITE(6,*)
      WRITE(6,*)
+SELF.

C      CLOSE (LUNGFI)

      if (irbtabxyz.ne.0) then
        irbtab=0
        irbtabzy=0
      else if (irbtabzy.ne.0) then
        irbtab=0
      endif

      IF (XABSORB   .EQ.9999.) XABSORB=XWALLE
      IF (ZABSORB(1).EQ.9999.) ZABSORB(1)=WALL(1)
      IF (ZABSORB(2).EQ.9999.) ZABSORB(2)=WALL(2)

C ALL MULTIPLICATIONS WITH REFLEC ARE WRONG, SO WE CORRECT IT HERE
C (15. MAI 2004)

      DO I=1,3
        REFLEC(I)=CONJG(REFLEC(I))
      ENDDO

      IF (IWBMAP.EQ.-1) IHBPOLY3D=1
      IF (IWBMAP.EQ.-1.AND.IWBPOLY2DH.NE.0) IHBPOLY2DH=1
      IF (IWBMAP.EQ.-1.AND.IWBPOLY2DH.NE.0) IHBPHARM=1

      CALL date_and_time(dtday,dttime,dtzone,idatetime)

      OPEN(UNIT=99,FILE='wave_run.log',status='unknown',access='append')
      WRITE(99,*)icode,' ',dtday,' ',dttime
      close(99)

      if (iampseed.eq.-9999) iampseed=icode

      IF (ABS(KBGENESIS).EQ.2) THEN
        OPEN(UNIT=LUNGENI,FILE='genesis.start',STATUS='OLD')
        READ(LUNGENI,*)XSTART,DMYGAMMA,DUM,ZSTART,YSTART,VZIN,VYIN
        VXIN=1.0D0
        VYIN=VYIN/DMYGAMMA
        VZIN=VZIN/DMYGAMMA
        DMYENERGY=DMYGAMMA*EMASSG1
        CLOSE(LUNGENI)
      ENDIF

      if (abs(xstart).ne.9999.0d0.and.xstop.ne.9999.0d0
     &    .and.xstart.ge.xstop-1.0d0/myinum) then
        write(LUNGFO,*)' '
        write(LUNGFO,*)'*** Error in GFINIT: XSTART and XSTOP are not compatible.'
        write(LUNGFO,*)'Decrease XSTART or nncrease MYINUM or XSTOP!'
        write(LUNGFO,*)' '
        write(6,*)' '
        write(6,*)'*** Error in GFINIT: XSTART and XSTOP are not compatible.'
        write(6,*)'Decrease XSTART or nncrease MYINUM or XSTOP!'
        write(6,*)' '
        STOP '*** PROGRAM WAVE ABORTED ***'
      endif

      DMYGAMMA=DMYENERGY/EMASSG1

      if (ibunch.ne.0.and.ispec.eq.0) then
        write(6,*)' '
        write(6,*)'*** WARNING: ISPEC SET DUE TO IBUNCH AND IUBUNCH'
        write(6,*)' '
        write(lungfo,*)' '
        write(lungfo,*)'*** WARNING: ISPEC SET DUE TO IBUNCH AND IUBUNCH'
        write(lungfo,*)' '
        ispec=1
      endif

      if (ibunch.ne.0.and.iubunch.eq.3) then
        open(unit=21,file='wave_phasespace.dat',status='old')
        call util_skip_comment_end(21,ieof)
        read(21,*)dmygamma,bunchx,xstart,ystart,zstart,yp0,zp0
        close(21)
        dmyenergy=dmygamma*emassg1
        vxin=1.0d0
        vyin=yp0
        vzin=zp0
        xinter=-9999.0d0
c        write(6,*)' '
c        write(6,*)'*** WARNING: IBUNCH AND IUBUNCH HAVE TRIGGERED OVERWRITING'
c        write(6,*)'*** WARNING: OF XSTART ETC.'
c        write(6,*)' '
        write(lungfo,*)' '
        write(lungfo,*)'*** WARNING: IBUNCH AND IUBUNCH HAVE TRIGGERED OVERWRITING'
        write(lungfo,*)'*** WARNING: OF XSTART ETC.'
        write(lungfo,*)' '
      endif

      dmyenergyP=DMYENERGY
      dmygammaP=DMYGAMMA
      DMYBETA=DSQRT((1.0D0-1.0D0/DMYGAMMA)*(1.0D0+1.0D0/DMYGAMMA))
      dmybetaP=DMYBETA
      gammaustep=dmygamma

C--- MODES

      IF (IUNDULATOR*IWIGGLER.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'BOTH FLAGS IUNDULATOR AND IWIGGLER ARE SET'
        WRITE(LUNGFO,*)'ONLY ONE IS ALLOWED'
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'BOTH FLAGS IUNDULATOR AND IWIGGLER ARE SET'
        WRITE(6,*)'ONLY ONE IS ALLOWED'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IWIGGLER.NE.0) THEN
        IEXPERT=0
      ENDIF

C{--- CONVERT B-FIELD TO MAP

      IF (IWBMAP.EQ.5) THEN
        CALL WBMAP5
        IABEND=7
        goto 9999
      ENDIF
C}--- CONVERT B-FIELD TO MAP

      if (iundulator.eq.2) then
        ispec=1
c        ifreq2p=3
      endif

      if (iwiggler.ne.0.or.iundulator.ne.0) then
        istokes=1
      endif

c      if (kampli.ne.0.or.iundulator.eq.2) then
c        CALL BELLIP(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
c        phb0h=B0ELLIPh
c        phb0v=B0ELLIPv
c        phperl=xlellip
c        phshift=ellshft*phperl
c      endif

      if (iundulator.eq.2) then

c        iundulator=0
        kampli=nint(perellip)
        xcenell=0.0d0
c        perellip=5.0d0

        if (xstart.eq.9999.0d0.and.xinter.eq.-9999.0d0
     &      .and.xstop.eq.9999.0d0) then
c          xstart=-(perellip*xlellip+ellshft*xlellip)/2.0d0+xcenell
          xstart=-(5.0d0*xlellip+ellshft*xlellip)/2.0d0+xcenell
        endif

        park=parkell

        if (nharmell.ne.0.and.harmell.ne.0.0d0) then
          if (harmell.eq.-9999.0d0) then
c            if (ifreq2p.eq.1) then
c              harmell=freqlow
c            else
              harmell=(freqlow+freqhig)/2.0d0
c            endif
          endif
          if (harmell.lt.0.0d0) then
            harmell=-wtoe1/harmell
          endif
          WLEN1=wtoe1/abs(harmell/nharmell)
          park=2.0d0*(wlen1/(xlellip*1.0D9/2.0d0/DMYGAMMA**2)-1.0d0)
          if (park.lt.0.0d0) then
            write(6,*)
     &        '*** Error in GFINIT:'
            write(6,*)
     &        'Inconsistent values of NHARMELL, HARMELL, and XLELLIP'
            write(6,*)' '
            write(lungfo,*)
     &        '*** Error in GFINIT:'
            write(lungfo,*)
     &        'Inconsistent values of NHARMELL, HARMELL, and XELLIP'
            write(lungfo,*)' '
            stop
          endif
          park=sqrt(park)
          parkell=park
        endif

        IF (parkell.NE.0.0) THEN
          B0EFF=parkell/(echarge1*XLELLIP/(2.*PI1*EMASSKG1*CLIGHT1))
          if (b0elliph.eq.0.0d0.and.b0ellipv.ne.0d0) then
            b0ellipv=b0ellipv/abs(b0ellipv)*b0eff
          else if (b0ellipv.eq.0.0d0.and.b0elliph.ne.0d0) then
            b0elliph=b0elliph/abs(b0elliph)*b0eff
          else
            rhv=b0elliph/b0ellipv
            b0elliph=b0eff/sqrt(1.0d0+1.0d0/rhv**2)*b0elliph/abs(b0elliph)
            b0ellipv=b0elliph/rhv
          endif
        endif

        if (phrb0h.eq.9999.0d0) phrb0h=B0ELLIPh
        if (phrb0v.eq.9999.0d0) phrb0v=B0ELLIPV
        if (phrperl.eq.9999.0d0) phrperl=xlellip
        if (phrshift.eq.9999.0d0) phrshift=ellshft*phrperl

        WGWINFC = 45.
        nlpoi=0
        ibsuper=0
        KBEXTERN=0
        KBAMWLS=0
        KHALBA=0
        KBFELD=0
        KHALBASY=0
        KUNDUGAP=0
        IRFILF=0
        IRFILB=0
        IRBTAB=0
        IFOURBTABZY=0
        IRBTABZY=0
        IRBTABXYZ=0
        KUCROSS=0
        KELLANA=0
        KBREC=0
        kbundumag=0
        kbundumag_c=kbundumag
        KBPOLYMAG=0
        KBGENESIS=0
        KBPOLYH=0
        KBPOLY3D=0
        KBPOLY2DH=0
        KBPHARM=0
        IRFILP=0
        IRFILB0=0
        IBHELM=0
        IMAGSPLN=0
        KMAGSEQ=0
        IWSECTMAGS=0
        ibmasksp=0
        ibsym=0
        ibsymy=0
        ibsymz=0
        bygoff=0.0d0
        bzgoff=0.0d0
        jbmask=0
        ibmask=0
        B0SCGLOBY=1.0
        B0SCGLOBz=1.0
        xbshift=0.0d0
        hshift=0.0d0
        vshift=0.0d0
        xrotd=0.0d0
        IPERIODG=0.0d0
        BTAPERV=0.0d0
        BTAPERH=0.0d0
        XTAPER=0.0d0
        iampli=0

        kellip=1

        if (xstart.eq.9999.0d0.and.xinter.eq.-9999.0d0
     &      .and.xstop.eq.9999.0d0) then
          xstop=phrperl/2.0d0
        endif
        ieneloss=0
        !imagspln=0

        gamma=dmygamma

        DTIM=1.0D0/(CLIGHT1*dmybetap*MYINUM)   !TIME INTERVALLS FOR TRACKING
        BSHIFT=0.5D0          !DONT WORRY

        DS0=CLIGHT1*DTIM
        GAMMA=DMYGAMMA
        ENERGV=GAMMA*EMASSE1
        GMOM=EMASSG1*DSQRT((GAMMA-1.0d0)*(GAMMA+1.0d0))
        EMOM=EMASSE1*DSQRT((GAMMA-1.0d0)*(GAMMA+1.0d0))
        DBRHO=ICHARGE*EMOM/CLIGHT1
        BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
        DMYBETA=BETA
        V0=CLIGHT1*BETA

        VN=1.0D0/DSQRT(VXIN**2+VYIN**2+VZIN**2)
        VXIN=VXIN*VN*v0
        VYIN=VYIN*VN*v0
        VZIN=VZIN*VN*v0

        TAUPOL01G=POL2CON1*UMFANG*RDIPOL**2/1.**5

        ecdipev1=3.0d0/2.0d0*hbarev1*(clight1/emasse1)**2/emasse1*1.0d18

        gamma1=1.0d0/emassg1
        emom1=emasse1*dsqrt((gamma1-1.0d0)*(gamma1+1.0d0))
        rho1=emom1/clight1
        omegac=1.5d0*gamma1**3*clight1/rho1

        CROTD=DCOSD(XROTD)
        SROTD=DSIND(XROTD)

        IF (XINTER.NE.XSTART.AND.XINTER.NE.-9999.) THEN

          YSTARTO=YSTART
          ZSTARTO=ZSTART

          VXINO=VXIN
          VYINO=VYIN
          VZINO=VZIN

          BETX0=VXIN*BETA
          BETY0=VYIN*BETA
          BETZ0=VZIN*BETA

          X0=XSTART
          Y0=YSTART
          Z0=ZSTART

          VX0=VXIN
          VY0=VYIN
          VZ0=VZIN

          IF (XINTER.GT.XSTART) THEN

            BYDUM=B0SCGLOB
            B0SCGLOB=-B0SCGLOB
            btaperv=-btaperv
            btaperh=-btaperh

            CALL TRACKSHORT(ISNORDER,XINTER,Y0,Z0,-VX0,-VY0,-VZ0,
     &        XSTART,0.0D0,0.0D0,-1.0D0,0.0D0,0.0D0,
     &        XF0,YF0,ZF0,dtshort,VXF0,VYF0,VZF0,DTIM,BSHIFT,GAMMA,BMOVECUT,
     &        IUSTEP,IENELOSS,GAMMAL)

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Result of back-tracking due to XINTER:'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     x:',XF0
            WRITE(LUNGFO,*)'     y:',YF0
            WRITE(LUNGFO,*)'     z:',ZF0
            WRITE(LUNGFO,*)'     vx:',-VXF0
            WRITE(LUNGFO,*)'     vy:',-VYF0
            WRITE(LUNGFO,*)'     vz:',-VZF0
            WRITE(LUNGFO,*)'     yp:',VYF0/VXF0
            WRITE(LUNGFO,*)'     zp:',VZF0/VXF0
            WRITE(LUNGFO,*)

            B0SCGLOB=BYDUM
            btaperv=-btaperv
            btaperh=-btaperh
            XSTART=XF0
            YSTART=YF0
            ZSTART=ZF0
            VXIN=-VXF0
            VYIN=-VYF0
            VZIN=-VZF0

            GAMMA=GAMMA-GAMMAL !We gain energy here, and gammal is negative!
            DMYGAMMA=GAMMA
            DMYENERGY=GAMMA*EMASSG1

            ENERGV=GAMMA*EMASSE1
            GMOM=EMASSG1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
            EMOM=EMASSE1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
            DBRHO=ICHARGE*EMOM/CLIGHT1
            BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
            DMYBETA=BETA
            V0=CLIGHT1*BETA

          ELSE   !XINTER.GT.XSTART

            CALL TRACKSHORT(ISNORDER,XINTER,Y0,Z0,VX0,VY0,VZ0,
     &        XSTART,0.0D0,0.0D0,1.0D0,0.0D0,0.0D0,
     &        XF0,YF0,ZF0,dtshort,VXF0,VYF0,VZF0,DTIM,BSHIFT,GAMMA,BMOVECUT,
     &        IUSTEP,IENELOSS,GAMMAL)

            XSTART=XF0
            YSTART=YF0
            ZSTART=ZF0
            VXIN=VXF0
            VYIN=VYF0
            VZIN=VZF0

            GAMMA=GAMMA+GAMMAL !We lose energy here!
            DMYGAMMA=GAMMA
            DMYENERGY=GAMMA*EMASSG1

            ENERGV=GAMMA*EMASSE1
            GMOM=EMASSG1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
            EMOM=EMASSE1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
            DBRHO=ICHARGE*EMOM/CLIGHT1
            BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
            DMYBETA=BETA
            V0=CLIGHT1*BETA

          ENDIF  !XINTER.GT.XSTART

        ENDIF !(XINTER.NE.-9999.)

        xinter=-9999.0d0

      endif !iundulator.eq.2

      if (iundulator.ne.2.and.kampli.ne.0) then

        kampli=nint(perellip)
        xcenell=0.0d0

        park=parkell

        if (nharmell.ne.0.and.harmell.ne.0.0d0) then
          if (harmell.eq.-9999.0d0) then
              harmell=(freqlow+freqhig)/2.0d0
          endif
          if (harmell.lt.0.0d0) then
            harmell=-wtoe1/harmell
          endif
          WLEN1=wtoe1/abs(harmell/nharmell)
          park=2.0d0*(wlen1/(xlellip*1.0D9/2.0d0/DMYGAMMA**2)-1.0d0)
          if (park.lt.0.0d0) then
            write(6,*)
     &        '*** Error in GFINIT:'
            write(6,*)
     &        'Inconsistent values of NHARMELL, HARMELL, and XLELLIP'
            write(6,*)' '
            write(lungfo,*)
     &        '*** Error in GFINIT:'
            write(lungfo,*)
     &        'Inconsistent values of NHARMELL, HARMELL, and XELLIP'
            write(lungfo,*)' '
            stop
          endif
          park=sqrt(park)
          parkell=park
        endif

        IF (parkell.NE.0.0) THEN
          B0EFF=parkell/(echarge1*XLELLIP/(2.*PI1*EMASSKG1*CLIGHT1))
          if (b0elliph.eq.0.0d0.and.b0ellipv.ne.0d0) then
            b0ellipv=b0ellipv/abs(b0ellipv)*b0eff
          else if (b0ellipv.eq.0.0d0.and.b0elliph.ne.0d0) then
            b0elliph=b0elliph/abs(b0elliph)*b0eff
          else
            rhv=b0elliph/b0ellipv
            b0elliph=b0eff/sqrt(1.0d0+1.0d0/rhv**2)*b0elliph/abs(b0elliph)
            b0ellipv=b0elliph/rhv
          endif
        endif

        if (phrb0h.eq.9999.0d0) phrb0h=B0ELLIPh
        if (phrb0v.eq.9999.0d0) phrb0v=B0ELLIPV
        if (phrperl.eq.9999.0d0) phrperl=xlellip
        if (phrshift.eq.9999.0d0) phrshift=ellshft*phrperl

        kellip=1

        if (xstart.eq.9999.0d0.and.xinter.eq.-9999.0d0
     &      .and.xstop.eq.9999.0d0) then
          xstop=phrperl/2.0d0
        endif
        ieneloss=0
        !imagspln=0

        gamma=dmygamma

        DTIM=1.0D0/(CLIGHT1*dmybetap*MYINUM)   !TIME INTERVALLS FOR TRACKING
        BSHIFT=0.5D0          !DONT WORRY

        DS0=CLIGHT1*DTIM
        GAMMA=DMYGAMMA
        ENERGV=GAMMA*EMASSE1
        GMOM=EMASSG1*DSQRT((GAMMA-1.0d0)*(GAMMA+1.0d0))
        EMOM=EMASSE1*DSQRT((GAMMA-1.0d0)*(GAMMA+1.0d0))
        DBRHO=ICHARGE*EMOM/CLIGHT1
        BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
        DMYBETA=BETA
        V0=CLIGHT1*BETA

        VN=1.0D0/DSQRT(VXIN**2+VYIN**2+VZIN**2)
        VXIN=VXIN*VN*v0
        VYIN=VYIN*VN*v0
        VZIN=VZIN*VN*v0

        TAUPOL01G=POL2CON1*UMFANG*RDIPOL**2/1.**5

        ecdipev1=3.0d0/2.0d0*hbarev1*(clight1/emasse1)**2/emasse1*1.0d18

        gamma1=1.0d0/emassg1
        emom1=emasse1*dsqrt((gamma1-1.0d0)*(gamma1+1.0d0))
        rho1=emom1/clight1
        omegac=1.5d0*gamma1**3*clight1/rho1

        CROTD=DCOSD(XROTD)
        SROTD=DSIND(XROTD)

        IF (XINTER.NE.XSTART.AND.XINTER.NE.-9999.) THEN

          YSTARTO=YSTART
          ZSTARTO=ZSTART

          VXINO=VXIN
          VYINO=VYIN
          VZINO=VZIN

          BETX0=VXIN*BETA
          BETY0=VYIN*BETA
          BETZ0=VZIN*BETA

          X0=XSTART
          Y0=YSTART
          Z0=ZSTART

          VX0=VXIN
          VY0=VYIN
          VZ0=VZIN

          IF (XINTER.GT.XSTART) THEN

            BYDUM=B0SCGLOB
            B0SCGLOB=-B0SCGLOB
            btaperv=-btaperv
            btaperh=-btaperh

            CALL TRACKSHORT(ISNORDER,XINTER,Y0,Z0,-VX0,-VY0,-VZ0,
     &        XSTART,0.0D0,0.0D0,-1.0D0,0.0D0,0.0D0,
     &        XF0,YF0,ZF0,dtshort,VXF0,VYF0,VZF0,DTIM,BSHIFT,GAMMA,BMOVECUT,
     &        IUSTEP,IENELOSS,GAMMAL)

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Result of back-tracking due to XINTER:'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     x:',XF0
            WRITE(LUNGFO,*)'     y:',YF0
            WRITE(LUNGFO,*)'     z:',ZF0
            WRITE(LUNGFO,*)'     vx:',-VXF0
            WRITE(LUNGFO,*)'     vy:',-VYF0
            WRITE(LUNGFO,*)'     vz:',-VZF0
            WRITE(LUNGFO,*)'     yp:',VYF0/VXF0
            WRITE(LUNGFO,*)'     zp:',VZF0/VXF0
            WRITE(LUNGFO,*)

            B0SCGLOB=BYDUM
            btaperv=-btaperv
            btaperh=-btaperh
            XSTART=XF0
            YSTART=YF0
            ZSTART=ZF0
            VXIN=-VXF0
            VYIN=-VYF0
            VZIN=-VZF0

            GAMMA=GAMMA-GAMMAL !We gain energy here, and gammal is negative!
            DMYGAMMA=GAMMA
            DMYENERGY=GAMMA*EMASSG1

            ENERGV=GAMMA*EMASSE1
            GMOM=EMASSG1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
            EMOM=EMASSE1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
            DBRHO=ICHARGE*EMOM/CLIGHT1
            BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
            DMYBETA=BETA
            V0=CLIGHT1*BETA

          ELSE   !XINTER.GT.XSTART

            CALL TRACKSHORT(ISNORDER,XINTER,Y0,Z0,VX0,VY0,VZ0,
     &        XSTART,0.0D0,0.0D0,1.0D0,0.0D0,0.0D0,
     &        XF0,YF0,ZF0,dtshort,VXF0,VYF0,VZF0,DTIM,BSHIFT,GAMMA,BMOVECUT,
     &        IUSTEP,IENELOSS,GAMMAL)

            XSTART=XF0
            YSTART=YF0
            ZSTART=ZF0
            VXIN=VXF0
            VYIN=VYF0
            VZIN=VZF0

            GAMMA=GAMMA+GAMMAL !We lose energy here!
            DMYGAMMA=GAMMA
            DMYENERGY=GAMMA*EMASSG1

            ENERGV=GAMMA*EMASSE1
            GMOM=EMASSG1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
            EMOM=EMASSE1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
            DBRHO=ICHARGE*EMOM/CLIGHT1
            BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
            DMYBETA=BETA
            V0=CLIGHT1*BETA

          ENDIF  !XINTER.GT.XSTART

        ENDIF !(XINTER.NE.-9999.)

        xinter=-9999.0d0

      endif !kampli

      IF (IUNDULATOR.NE.0) THEN

        IEXPERT=0
        ihtrackm=0

        if (ibunch.eq.0) then

+self,if=20220316.
          IF ((IWBMAP.NE.0.OR.IWBTAB.NE.0.OR.IBFORCE.NE.0.OR.IOPTIC.NE.0) then
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
            WRITE(LUNGFO,*)'IUNDULATOR HAS SET IMAGSPLN=-9999,'
            WRITE(LUNGFO,*)
     &        'WHICH IS INCOMPATIBLE WITH IWBMAP/IWBTAB/IBFORCE/IOPTIC'
            WRITE(LUNGFO,*)'TURN OFF IUNDULATOR, IF YOU USE IWBMAP/IWBTAB/IBFORCE/IOPTIC'
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN GFINIT ***'
            WRITE(6,*)'IUNDULATOR HAS SET IMAGSPLN=-9999,'
            WRITE(6,*)
     &        'WHICH IS INCOMPATIBLE WITH IWBMAP/IWBTAB/IBFORCE/IOPTIC'
            WRITE(6,*)'TURN OFF IUNDULATOR, IF YOU USE IWBMAP/IWBTAB/IBFORCE/IOPTIC'
            WRITE(6,*)
            STOP '*** PROGRAM WAVE ABORTED ***'
          ENDIF
+self,if=-20220316.
          IF ((IWBMAP.NE.0.OR.IBFORCE.NE.0.OR.IOPTIC.NE.0)
     &        .and.
     &    (iemit.ne.0.or.kbrec.ne.0.or.kbundumag.ne.0.or.kbextern.ne.0.or.kbpolymag.ne.0)) then
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
            WRITE(LUNGFO,*)'IUNDULATOR HAS SET IMAGSPLN=-9999,'
            WRITE(LUNGFO,*)
     &        'WHICH IS INCOMPATIBLE WITH IWBMAP/IBFORCE/IOPTIC'
            WRITE(LUNGFO,*)'TURN OFF IUNDULATOR, IF YOU USE IWBMAP/IBFORCE/IOPTIC'
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN GFINIT ***'
            WRITE(6,*)'IUNDULATOR HAS SET IMAGSPLN=-9999,'
            WRITE(6,*)
     &        'WHICH IS INCOMPATIBLE WITH IWBMAP/IBFORCE/IOPTIC'
            WRITE(6,*)'TURN OFF IUNDULATOR, IF YOU USE IWBMAP/IBFORCE/IOPTIC'
            WRITE(6,*)
            STOP '*** PROGRAM WAVE ABORTED ***'
          ENDIF
+self.

          icluster=0

          IF (ISPEC.NE.0) THEN

            ispecmode=2

            !if (nroi.ne.0) ispecmode=1

            IF (IAMPLI.GT.0.AND.ISPECMODE.NE.3.and.iamprep.ge.0) THEN
c noch ueberdenken, iphase bereits kompatible gemacht, 17.10.2012
              WRITE(LUNGFO,*)
     &          '*** Warning in GFINIT: ISPECMODE not 3, but IAMPLI.gt.0 and IAMPREP.gt.0'
              WRITE(6,*)"*** BE CAREFUL ***"
              PRINT *,
     &          '*** Warning in GFINIT: ISPECMODE not 3, but IAMPLI.gt.0 and IAMPREP.gt.0'
              print*,"*** BE CAREFUL ***"
            ENDIF

          ENDIF !ISPEC

          IMAGSPLN=-9999
          if (iemit.ne.0.or.kbrec.ne.0.or.kbundumag.ne.0.or.kbextern.ne.0.or.kbpolymag.ne.0) IMAGSPLN=0

          IRFILL0=0
C         IWFILL0=1
c          NLPOI=-9999
          NLPOI=0
          CX1=9999.
          CY1=9999.
          CZ1=9999.
          HIG1=1000.
          WID1=1000.
          CX2=9999.
          CY2=9999.
          CZ2=9999.
          HIG2=1000.
          WID2=1000.
          WGWINFC=PI1/4.0D0*DMYGAMMA
          WBL0CUT=0.0
          WBL0HYS=1.0
          IBL0CUT=0
          ISOUREXT=0
          ISPECDIP=0
          IF (IFOLD.NE.0) IFOLD=1
          IF (iefold.ne.0.and.IEFOLD.ne.1.and.iefold.ne.-1.and.iefold.ne.3) then
            write(lungfo,*)
            write(lungfo,*)"*** Warning in gfinit: IEFOLD MUST BE ONE OF [0,1,3,-1]"
            write(lungfo,*)"*** Will set it to IEFOLD=1 ***"
            write(lungfo,*)
            print*
            print*,"*** Warning in gfinit: IEFOLD MUST BE ONE OF [0,1,3,-1]"
            print*,"*** Will set it to IEFOLD=1 ***"
            print*
            IEFOLD=1
          endif
          IF (IPIN.GT.0.and.ipin.ne.3) IPIN=1
          BMOVECUT=1.0D-6

        else !ibunch

          if (icluster.ne.0) mthreads=0

          IF (ISPEC.NE.0) THEN

            ISPECMODE=2

            IF (IPHASE.NE.0) THEN
              WRITE(LUNGFO,*)' '
              WRITE(LUNGFO,*)
     &          '*** Warning in GFINIT: IPHASE set to zero, due to IBUNCH'
              WRITE(LUNGFO,*)' '
              PRINT *,' '
              PRINT *,
     &          '*** Warning in GFINIT: IPHASE set to zero, due to IBUNCH'
              PRINT *,' '
              iphase=0
            ENDIF

            IF (iampli.ne.0.and.iamprep.lt.0) THEN
              WRITE(LUNGFO,*)
     &          '*** Error in GFINIT: IBUNCH and IAMPREP < 0 are not compatible ***'
              PRINT *,
     &          '*** Error in GFINIT: IBUNCH and IAMPREP < 0 are not compatible ***'
              STOP '*** PROGRAM WAVE ABORTED ***'
            ENDIF

          ENDIF !ISPEC

          IFOLD=0
          IEFOLD=0
          !IMAGSPLN=0
          IRFILL0=0
c          NLPOI=-9999
          NLPOI=0
          CX1=9999.
          CY1=9999.
          CZ1=9999.
          HIG1=1000.
          WID1=1000.
          CX2=9999.
          CY2=9999.
          CZ2=9999.
          HIG2=1000.
          WID2=1000.
          WGWINFC=PI1/4.0D0*DMYGAMMA
          WBL0CUT=0.0
          WBL0HYS=1.0
          IBL0CUT=0
          ISOUREXT=0
          ISPECDIP=0
          IFOLD=0
          IEFOLD=0

          if (iefold.ne.0) then
            WRITE(6,*)' '
            WRITE(6,*)
     &        '      *** Warning in GFINIT: IEFOLD is used for IBUNCH, be careful!'
            WRITE(6,*)' '
            WRITE(LUNGFO,*)' '
            WRITE(LUNGFO,*)
     &        '      *** Warning in GFINIT: IEFOLD is used for IBUNCH, be careful!'
            WRITE(LUNGFO,*)' '
          endif

          IF (iundulator.ne.2
     &        .and.IPIN.GT.0.and.ipin.ne.3.and.neinbunch.eq.1) then
            IPIN=3
            WRITE(6,*)' '
            WRITE(6,*)
     &        '      *** GFINIT: IPIN=3 has been set due to IUNDULATOR and IBUNCH and NEINBUNCH=1, be careful!'
            WRITE(lungfo,*)' '
            WRITE(lungfo,*)
     &        '      *** GFINIT: IPIN=3 has been set due to IUNDULATOR and IBUNCH and NEINBUNCH=1, be careful!'
            WRITE(6,*)' '
          endif

          BMOVECUT=1.0D-6

        endif !ibunch

      ENDIF !IUNDULATOR

      IF (IWIGGLER.GT.1) THEN

        IF (ibunch.ne.0) then
          WRITE(LUNGFO,*)
     &      '*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      '*** IWIGGLER.GT.1 .AND. IBUNCH.NE.0 ARE INCOMPATIBLE ***'
          WRITE(6,*)
     &      '*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      '*** IWIGGLER.GT.1 .AND. IBUNCH.NE.0 ARE INCOMPATIBLE ***'
          STOP '*** PROGRAM WAVE ABORTED ***'
        endif

+self,if=20220316.
        IF (IWBMAP.NE.0.OR.IWBTAB.NE.0.OR.IBFORCE.NE.0.OR.IOPTIC.NE.0)THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'IWIGGLER HAS TURNED SET IMAGSPLN=-9999,'
          WRITE(LUNGFO,*)
     &      'WHICH IS INCOMPATIBLE WITH IWBMAP/IWBTAB/IBFORCE/IOPTIC/IBUNCH'
          WRITE(LUNGFO,*)'TURN OFF IWIGGLER, IF YOU USE IWBMAP/IWBTAB/IBFORCE/IOPTIC/IBUNCH'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'IWIGGLER HAS TURNED SET IMAGSPLN=-9999,'
          WRITE(6,*)
     &      'WHICH IS INCOMPATIBLE WITH IWBMAP/IWBTAB/IBFORCE/IOPTIC/IBUNCH'
          WRITE(6,*)'TURN OFF IWIGGLER, IF YOU USE IWBMAP/IWBTAB/IBFORCE/IOPTIC/IBUNCH'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF
+self,if=-20220316.
          IF ((IWBMAP.NE.0.OR.IBFORCE.NE.0.OR.IOPTIC.NE.0)
     &        .and.
     &    (iemit.ne.0.or.kbrec.ne.0.or.kbundumag.ne.0.or.kbextern.ne.0.or.kbpolymag.ne.0)) then

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'IWIGGLER HAS TURNED SET IMAGSPLN=-9999,'
          WRITE(LUNGFO,*)
     &      'WHICH IS INCOMPATIBLE WITH IWBMAP/IBFORCE/IOPTIC/IBUNCH'
          WRITE(LUNGFO,*)'TURN OFF IWIGGLER, IF YOU USE IWBMAP/IBFORCE/IOPTIC/IBUNCH'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'IWIGGLER HAS TURNED SET IMAGSPLN=-9999,'
          WRITE(6,*)
     &      'WHICH IS INCOMPATIBLE WITH IWBMAP/IBFORCE/IOPTIC/IBUNCH'
          WRITE(6,*)'TURN OFF IWIGGLER, IF YOU USE IWBMAP/IBFORCE/IOPTIC/IBUNCH'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF
+self.

        ISPECDIP=-2

        IMAGSPLN=-9999
        !if (iemit.ne.0.or.kbrec.ne.0.or.kbundumag.ne.0.or.kbextern.ne.0.or.kbpolymag.ne.0) IMAGSPLN=0

        IRFILL0=0
C         IWFILL0=1
        NLPOI=-9999
        WGWINFC=1.
        CX1=9999.
        CY1=9999.
        CZ1=9999.
        HIG1=9999.
        WID1=9999.
        CX2=9999.
        CY2=9999.
        CZ2=9999.
        HIG2=9999.
        WID2=9999.
        WBL0CUT=0.05
        WBL0HYS=1.0
        IBL0CUT=1
        ISOUREXT=0
        IF (IFOLD.NE.0) IFOLD=1
        IF (IEFOLD.NE.0) IEFOLD=1
      ENDIF !IWIGGLER

      IF (IWIGGLER.EQ.1) THEN

+self,if=20220316.
        IF (IWBMAP.NE.0.OR.IWBTAB.NE.0.OR.IBFORCE.NE.0.OR.IOPTIC.NE.0)THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'IWIGGLER HAS TURNED SET IMAGSPLN=-9999,'
          WRITE(LUNGFO,*)
     &      'WHICH IS INCOMPATIBLE WITH IWBMAP/IWBTAB/IBFORCE/IOPTIC/IBUNCH'
          WRITE(LUNGFO,*)'TURN OFF IWIGGLER, IF YOU USE IWBMAP/IWBTAB/IBFORCE/IOPTIC/IBUNCH'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'IWIGGLER HAS TURNED SET IMAGSPLN=-9999,'
          WRITE(6,*)
     &      'WHICH IS INCOMPATIBLE WITH IWBMAP/IWBTAB/IBFORCE/IOPTIC/IBUNCH'
          WRITE(6,*)'TURN OFF IWIGGLER, IF YOU USE IWBMAP/IWBTAB/IBFORCE/IOPTIC/IBUNCH'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF
+self,if=-20220316.
          IF ((IWBMAP.NE.0.OR.IBFORCE.NE.0.OR.IOPTIC.NE.0)
     &        .and.
     &    (iemit.ne.0.or.kbrec.ne.0.or.kbundumag.ne.0.or.kbextern.ne.0.or.kbpolymag.ne.0)) then
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'IWIGGLER HAS TURNED SET IMAGSPLN=-9999,'
          WRITE(LUNGFO,*)
     &      'WHICH IS INCOMPATIBLE WITH IWBMAP/IBFORCE/IOPTIC/IBUNCH'
          WRITE(LUNGFO,*)'TURN OFF IWIGGLER, IF YOU USE IWBMAP/IBFORCE/IOPTIC/IBUNCH'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'IWIGGLER HAS TURNED SET IMAGSPLN=-9999,'
          WRITE(6,*)
     &      'WHICH IS INCOMPATIBLE WITH IWBMAP/IBFORCE/IOPTIC/IBUNCH'
          WRITE(6,*)'TURN OFF IWIGGLER, IF YOU USE IWBMAP/IBFORCE/IOPTIC/IBUNCH'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF
+self.

C        IF (IPHASE.NE.0.OR.IAMPLI.NE.0) THEN
c noch ueberdenken, iphase bereits kompatible gemacht, 17.10.2012
C          WRITE(LUNGFO,*)
C     &      '*** Warning in GFINIT: ISPECMODE set to 3, due to IPHASE'
C          PRINT *,
C     &      '*** Warning in GFINIT: ISPECMODE set to 3, due to IPHASE'
C          ISPECMODE=3
C        ELSE
C          ISPECMODE=2
C          if (icluster.eq.0.and.ibunch.eq.0.and.nroi.eq.0) ispecmode=3
C        ENDIF

        IF (ISPECMODE.NE.3.AND.(IPHASE.NE.0.OR.IAMPLI.NE.0)) THEN
          WRITE(6,*)
     &      '*** Warning in GFINIT: ISPECMODE not 3, but IPHASE or IAMPLI set ***'
          WRITE(6,*)
     &      '*** This is not yet fully tested, be careful ***'
          WRITE(LUNGFO,*)
     &      '*** Warning in GFINIT: ISPECMODE not 3, but IPHASE or IAMPLI set ***'
          WRITE(LUNGFO,*)
     &      '*** This is not yet fully tested, be careful ***'
        ENDIF

        IMAGSPLN=-9999
        !if (iemit.ne.0.or.kbrec.ne.0.or.kbundumag.ne.0.or.kbextern.ne.0.or.kbpolymag.ne.0) IMAGSPLN=-9999

        IRFILL0=0
C         IWFILL0=1
        NLPOI=-9999
        WGWINFC=9999.
        CX1=9999.
        CY1=9999.
        CZ1=9999.
        HIG1=9999.
        WID1=9999.
        CX2=9999.
        CY2=9999.
        CZ2=9999.
        HIG2=9999.
        WID2=9999.
        WBL0CUT=0.1
        WBL0HYS=1.0
        IBL0CUT=1
        ISOUREXT=0
        ISPECDIP=0

        IF (IFOLD.NE.0) IFOLD=1

        if (ibunch.ne.0) ibunch=-1
        if (ibunch.ne.0) then
          IFOLD=0
          IEFOLD=0
        endif
      ENDIF !IWIGGLER

      if (iwiggler.ne.0.and.ibunch.ne.0.and.ipin.ne.0.and.neinbunch.eq.1) ipin=3

      if (espread.le.0.0d0.and.iefold.ne.0) then
        iefold=0
        write(lungfo,*)'     *** Warning in GFINIT: IEFOLD set zero, since ESPREAD <= 0.0'
        write(6,*)'     *** Warning in GFINIT: IEFOLD set zero, since ESPREAD <= 0.0'
      endif

      IF (ISPEC.NE.0) THEN

        if (ibunch.ne.0.and.ifold.ne.0) then
          write(6,*)' '
          write(6,*)' *** Warning in gfinit: IBUNCH and IFOLD are both set, be careful!'
          write(6,*)' '
          write(lungfo,*)' '
          write(lungfo,*)' *** Warning in gfinit: IBUNCH and IFOLD are both set, be careful!'
          write(lungfo,*)' '
        endif

        if (ibunch.ne.0.and.iefold.ne.0) then
          write(6,*)' '
          write(6,*)' *** Warning in gfinit: IBUNCH and IEFOLD are both set, be careful!'
          write(6,*)' '
          write(lungfo,*)' '
          write(lungfo,*)' *** Warning in gfinit: IBUNCH and IEFOLD are both set, be careful!'
          write(lungfo,*)' '
        endif

        if (ieneloss.ne.0.and.ispecmode.gt.3) then
          write(lungfo,*)' '
          write(lungfo,*)'*** Error: IENELOSS and ISPECMODE are incompatible ***'
          WRITE(lungfo,*)'*** PROGRAM WAVE ABORTED'
          write(lungfo,*)' '
          write(6,*)' '
          write(6,*)'*** Error: IENELOSS and ISPECMODE are incompatible ***'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED'
          write(6,*)' '
          stop
        endif

        if (ibunch.ne.0.and.ispecmode.ne.2) then
          write(6,*)' '
          write(6,*)' *** ERROR IN GFINIT: IBUNCH set, but ISPECMODE.ne.2!'
          write(6,*)' **** Please check namelist $CONTRL in wave.in'
          write(6,*)' '
          WRITE(6,*)'*** PROGRAM WAVE ABORTED'
          write(6,*)' '
          write(lungfo,*)' '
          write(lungfo,*)' *** ERROR IN GFINIT: IBUNCH set, but ISPECMODE.ne.2!'
          write(lungfo,*)' **** Please check namelist $CONTRL in wave.in'
          write(lungfo,*)' '
          WRITE(lungfo,*)'*** PROGRAM WAVE ABORTED'
          write(lungfo,*)' '
          stop
        endif

        if (iefold.ne.0.and.ifreq2p.ne.3) then
          write(LUNGFO,*)' '
          write(LUNGFO,*)'*** Warning in GFINIT: IEFOLD.ne.0 and IFRQE2P.ne.3 ***'
          write(LUNGFO,*)'IFREQ2P set to IFREQ2P=3'
          write(LUNGFO,*)' '
          write(6,*)' '
          write(6,*)'*** Warning in GFINIT: IEFOLD.ne.0 and IFRQE2P.ne.3 ***'
          write(6,*)'IFREQ2P set to IFREQ2P=3'
          write(6,*)' '
          IFREQ2P=3
        endif

        IF (ISPECMODE.NE.5) THEN
          IF (IPIN.EQ.2) THEN
            WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. ISPECMODE.NE.5'
            WRITE(6,*)'*** IPIN SET TO 1'
            WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. ISPECMODE.NE.5'
            WRITE(LUNGFO,*)'*** IPIN SET TO 1'
            IPIN=1
          ENDIF !IPIN.EQ.2
          if (ibunch.eq.0) then
            IF (IFOLD.EQ.2) THEN
              WRITE(6,*)'*** WARNING IN GFINIT: IFOLD.EQ.2 .AND. ISPECMODE.NE.5'
              WRITE(6,*)'*** IFOLD SET TO 1'
              WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IFOLD.EQ.2 .AND. ISPECMODE.NE.5'
              WRITE(LUNGFO,*)'*** IFOLD SET TO 1'
              IFOLD=1
            ENDIF !IPIN.EQ.2
            IF (IEFOLD.EQ.2) THEN
              WRITE(6,*)'*** WARNING IN GFINIT: IEFOLD.EQ.2 .AND. ISPECMODE.NE.5'
              WRITE(6,*)'*** IEFOLD SET TO 1'
              WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IEFOLD.EQ.2 .AND. ISPECMODE.NE.5'
              WRITE(LUNGFO,*)'*** IEFOLD SET TO 1'
              IEFOLD=1
            ENDIF !IEFOLD.EQ.2
          endif
        ENDIF !ISPECMODE

        IF (IPIN.EQ.2.AND.ISPECDIP.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. ISPECDIP.NE.0'
          WRITE(6,*)'*** IPIN SET TO 1'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. ISPECDIP.NE.0'
          WRITE(LUNGFO,*)'*** IPIN SET TO 1'
          IPIN=1
        ENDIF !IPIN.EQ.2

        if (ibunch.eq.0) then
          IF (IFOLD.NE.0.AND.IPIN.EQ.0.AND.IFOLD.NE.2) THEN
            PRINT*,'            *** WARNING IN GFINIT: IPIN.EQ.0 .AND. IFOLD.NE.2'
            PRINT*,'            *** IFOLD SET TO ZERO'
            print*
            WRITE(LUNGFO,*)'             *** WARNING IN GFINIT: IPIN.EQ.0 .AND. IFOLD.NE.2'
            WRITE(LUNGFO,*)'             *** IFOLD SET TO ZERO'
            write(lungfo,*)
            IFOLD=0
          ENDIF
        endif !(ibunch.eq.0) then

        IF (IPIN.EQ.2.AND.IPINALL.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IPINALL.NE.0'
          WRITE(6,*)'*** IPINALL SET TO ZERO'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IPINALL.NE.0'
          WRITE(LUNGFO,*)'*** IPINALL SET TO ZERO'
          IPINALL=0
        ENDIF !IPIN.EQ.2

        IF (IPIN.EQ.2.AND.IWFILRAY.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IWFILRAY.NE.0'
          WRITE(6,*)'*** IWFILRAY SET TO ZERO'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IWFILRAY.NE.0'
          WRITE(LUNGFO,*)'*** IWFILRAY SET TO ZERO'
          IWFILRAY=0
        ENDIF !IPIN.EQ.2

        IF (IPIN.EQ.3.AND.IWFILRAY.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.3 .AND. IWFILRAY.NE.0'
          WRITE(6,*)'*** IWFILRAY SET TO ZERO'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.3 .AND. IWFILRAY.NE.0'
          WRITE(LUNGFO,*)'*** IWFILRAY SET TO ZERO'
          IWFILRAY=0
        ENDIF !IPIN.EQ.2

        IF (IPIN.EQ.2.AND.ISPECSUM.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. ISPECSUM.NE.0'
          WRITE(6,*)'*** ISPECSUM SET TO ZERO'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. ISPECSUM.NE.0'
          WRITE(LUNGFO,*)'*** ISPECSUM SET TO ZERO'
          ISPECSUM=0
        ENDIF !IPIN.EQ.2

        IF (IPIN.EQ.2.AND.ISPECANA.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. ISPECANA.NE.0'
          WRITE(6,*)'*** IPIN SET TO 1'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. ISPECANA.NE.0'
          WRITE(LUNGFO,*)'*** IPIN SET TO 1'
          IPIN=1
        ENDIF !IPIN.EQ.2

        IF (IPIN.EQ.2.AND.IAMPLI.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IAMPLI.NE.0'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IAMPLI.NE.0'
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED'
          STOP
        ENDIF !IPIN.EQ.2

        IF (IPIN.EQ.2.AND.IRFILOB.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IRFILOB.NE.0'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IRFILOB.NE.0'
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED'
          STOP
        ENDIF !IPIN.EQ.2

        IF (IPIN.EQ.2.AND.IUSEM.NE.0) THEN
          WRITE(6,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IUSEM.NE.0'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED'
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT: IPIN.EQ.2 .AND. IUSEM.NE.0'
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED'
          STOP
        ENDIF !IPIN.EQ.2

      ENDIF !ISPEC.NE.0

      IF (IFOLD.NE.0
     &    .AND.IFOLD.NE.1.AND.IFOLD.NE.2.AND.IFOLD.NE.-1.AND.IFOLD.NE.-2
     &    ) THEN
        WRITE(LUNGFO,*)
     &    '*** ERROR IN GFINIT: BAD VALUE OF IFOLD, CHECK INPUT '
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
        WRITE(6,*)
     &    '*** ERROR IN GFINIT: BAD VALUE OF IFOLD, CHECK INPUT '
        WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
        STOP
      ENDIF

      IF (NROI.EQ.0) THEN
        NROI=2
        ROIX(1)=-1.0D10
        ROIX(2)=1.0D10
        ROIP(1)=1.0D0
        ROIP(2)=1.0D0
        IROIASYEXP(1)=0
      ENDIF

      NROIA=ABS(NROI)

      IF (NROIA.GT.NROIP) THEN
        WRITE(6,*)
     &    '*** PARAMETER NROIP EXCEEDED: CHECK NROI IN NAMELIST ROIN'
        WRITE(6,*)
     &    'OR INCREASE NROIP IN SOURCE.CMN  ***'
        WRITE(LUNGFO,*)
     &    '*** PARAMETER NROIP EXCEEDED: CHECK NROI IN NAMELIST ROIN'
        WRITE(LUNGFO,*)
     &    'OR INCREASE NROIP IN SOURCE.CMN  ***'
        STOP
      ENDIF

      DO IROI=1,NROIA
        IF (ROIP(IROI).EQ.0.0D0) THEN
          ROIP(IROI)=1.0D0
        ENDIF
      ENDDO   !IROI

      IF (NROI.GT.0) THEN
        DO IROI=1,NROIA-1
          IF (ROIX(IROI).GE.ROIX(IROI+1)) THEN
            WRITE(6,*)
     &        '*** ERROR IN NAMELIST ROIN: VALUES OF ROIX NOT IN INCREASING ORDER'
            WRITE(6,*)
     &        '*** OR NUMBER OF ROIX DOES NOT MATCH NROI'
            WRITE(LUNGFO,*)
     &        '*** ERROR IN NAMELIST ROIN: VALUES OF ROIX NOT IN INCREASING ORDER'
            WRITE(LUNGFO,*)
     &        '*** OR NUMBER OF ROIX DOES NOT MATCH NROI'
            STOP
          ENDIF
        ENDDO   !IROI
      ENDIF

      IF (IPIN.EQ.2) THEN
        mpinyorig=mpiny
        mpinzorig=mpinz
        MPINZ=1
        MPINY=1
      ENDIF

      IF (ISIGSTO.EQ.0) ISIGSTO=1

      IF (ISPec.ne.0.and.ipin.eq.3.AND.IBRILL.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
        WRITE(LUNGFO,*)'FLAG IBRILL AND IPIN=3 ARE NOT COMPATIBLE'
        WRITE(LUNGFO,*)'IBRILL SET TO ZERO'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN GFINIT ***'
        WRITE(6,*)'FLAG IBRILL AND IPIN=3 ARE NOT COMPATIBLE'
        WRITE(6,*)'IBRILL SET TO ZERO'
        WRITE(6,*)
        ibrill=0
      ENDIF

      IF (ISPEC.NE.0.AND.IBRILL.NE.0.AND.ISTOKES.EQ.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'FLAG IBRILL IS SET BUT ISTOKES IS NOT'
        WRITE(LUNGFO,*)'SET ALSO FLAG ISTOKES IN INPUT FILE'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'FLAG IBRILL IS SET BUT ISTOKES IS NOT'
        WRITE(6,*)'SET ALSO FLAG ISTOKES IN INPUT FILE'
        WRITE(6,*)
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPEC.NE.0.AND.IWFILRAY.NE.0.AND.ISTOKES.EQ.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'FLAG IWFILRAY IS SET BUT ISTOKES IS NOT'
        WRITE(LUNGFO,*)'SET ALSO FLAG ISTOKES IN INPUT FILE'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'FLAG IWFILRAY IS SET BUT ISTOKES IS NOT'
        WRITE(6,*)'SET ALSO FLAG ISTOKES IN INPUT FILE'
        WRITE(6,*)
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPECMODE.LT.0) ISPECMODE=-ISPECMODE
      IF (ISPECMODE.EQ.0) ISPECMODE=2

      IF (
     &    ISPECMODE.NE.1.AND.
     &    ISPECMODE.NE.2.AND.
     &    ISPECMODE.NE.3.AND.
     &    ISPECMODE.NE.4.AND.
     &    ISPECMODE.NE.5) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'BAD VALUE OF ISPECMODE'
        WRITE(LUNGFO,*)'CHECK INPUT FILE WAVE.IN'
        WRITE(LUNGFO,*)

        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'BAD VALUE OF ISPECMODE'
        WRITE(6,*)'CHECK INPUT FILE WAVE.IN'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'

      ENDIF

C7MAR97      IF (IFILTER.EQ.0) IHFIL=0

      IF (IFILTER.LT.0.AND.IFILMUL.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'IFILTER.LT.0.AND.IFILMUL.NE.0'
        WRITE(LUNGFO,*)'CHECK INPUT FILE WAVE.IN'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'IFILTER.LT.0.AND.IFILMUL.NE.0'
        WRITE(6,*)'CHECK INPUT FILE WAVE.IN'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IFILTER.EQ.0.AND.IFILMUL.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
        WRITE(LUNGFO,*)'IFILMUL.NE.0 .AND. IFILTER.EQ.0'
        WRITE(LUNGFO,*)'IFILTER SET TO ONE'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN GFINIT ***'
        WRITE(6,*)'IFILMUL.NE.0 .AND. IFILTER.EQ.0'
        WRITE(6,*)'IFILTER SET TO ONE'
        WRITE(6,*)
        IFILTER=1
      ENDIF

      if (imagspln.eq.-9999.and.ibunch.ne.0) then
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
        WRITE(LUNGFO,*)'IMAGSPLN.EQ.-9999.AND.IUBUNCH.NE.0'
        WRITE(LUNGFO,*)'IMAGSPLN SET TO ZERO'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN GFINIT ***'
        WRITE(6,*)'IMAGSPLN.EQ.-9999.AND.IUBUNCH.NE.0'
        WRITE(6,*)'IMAGSPLN SET TO ZERO'
        WRITE(6,*)
        imagspln=0
      endif

      IF (IMAGSPLN.NE.-9999.AND.IMAGSPLN.LT.0) IMAGSPLN=-1

      IF (IMAGSPLN.GT.0) THEN

        OPEN(UNIT=99,FILE='magjob.dat',STATUS='OLD'
+SELF,IF=-windows.
     &    ,RECL=256)
+SELF,IF=WINDOWS.
     &    )
+SELF.

        READ(99,*)IMAGJOB
        READ(99,*)

        IF (IMAGSPLN.NE.IMAGJOB) THEN

          WRITE(6,*)'*** ERROR IN GFINIT:'
          WRITE(6,*)
     &      'IMAGSPLN DOES NOT MATCH JOB NUMBER ON FILE IMAGSPL:magjob.dat'
          WRITE(6,*)'FIELD TAKEN FROM REFERENCE ORBIT'
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT:'
          WRITE(LUNGFO,*)
     &      'IMAGSPLN DOES NOT MATCH JOB NUMBER ON FILE IMAGSPL:magjob.dat'
          WRITE(LUNGFO,*)'FIELD TAKEN FROM REFERENCE ORBIT'
          READ(99,*)XSTART,YSTART,ZSTART
          READ(99,*)VXIN,VYIN,VZIN
          READ(99,*)XSTOPR,DMYENERGY
          IF (XSTOP.EQ.9999.) XSTOP=XSTOPR

        ENDIF   !IMAGJOB

        CLOSE(99)

      ENDIF   !IMAGSPLN

C5.10.95 IF (ISPEC.NE.0.AND.IMAGSPLN.NE.0.AND.IOPTIC.NE.0) THEN
C5.10.95 WARUM ISPEC ?? IN ABFRAGE?? BEOBACHTEN
      IF (IMAGSPLN.NE.0.AND.IOPTIC.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'FLAGS IMAGSPLN AND IOPTIC ARE SET'
        WRITE(LUNGFO,*)'TURN OFF IMAGSPLN, IF YOU USE IOPTIC'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'FLAGS IMAGSPLN AND IOPTIC ARE SET'
        WRITE(6,*)'TURN OFF IMAGSPLN, IF YOU USE IOPTIC'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IMAGSPLN.NE.0.AND.IBFORCE.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'FLAGS IMAGSPLN AND IBFORCE ARE SET'
        WRITE(LUNGFO,*)'TURN OFF IMAGSPLN, IF YOU USE IBFORCE'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'FLAGS IMAGSPLN AND IBFORCE ARE SET'
        WRITE(6,*)'TURN OFF IMAGSPLN, IF YOU USE IBFORCE'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

+self,if=-20220316.
      IF (IMAGSPLN.NE.0.AND.IWBMAP.NE.0
     &    .OR.
     &    IMAGSPLN.NE.0.AND.IWBTAB.NE.0
     &    ) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'BOTH FLAGS IMAGSPLN AND IWBMAP/IWBTAB ARE SET'
        WRITE(LUNGFO,*)'TURN OFF IMAGSPLN, IF YOU USE IWBMAP/IWBTAB'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'BOTH FLAGS IMAGSPLN AND IWBMAP/IWBTAB ARE SET'
        WRITE(6,*)'TURN OFF IMAGSPLN, IF YOU USE IWBMAP/IWBTAB'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF
+self,if=+20220316.
          IF ((IWBMAP.NE.0.OR.IBFORCE.NE.0.OR.IOPTIC.NE.0)
     &        .and.
     &    (iemit.ne.0.or.kbrec.ne.0.or.kbundumag.ne.0.or.kbextern.ne.0.or.kbpolymag.ne.0)) then
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
        WRITE(LUNGFO,*)'BOTH FLAGS IMAGSPLN AND IWBMAP ARE SET'
        WRITE(LUNGFO,*)'TURN OFF IMAGSPLN, IF YOU USE IWBMAP'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN GFINIT ***'
        WRITE(6,*)'BOTH FLAGS IMAGSPLN AND IWBMAP ARE SET'
        WRITE(6,*)'TURN OFF IMAGSPLN, IF YOU USE IWBMAP'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF
+self.

      IF (ISPEC.NE.0) THEN

        IF (IDESYNC.NE.0.AND.IFOLD.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IDESYNC AND IFOLD ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'IFOLD SET TO ZERO'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IDESYNC AND IFOLD ARE INCOMPATIBLE'
          WRITE(6,*)'IFOLD SET TO ZERO'
          WRITE(6,*)
          IFOLD=0
        ENDIF

        IF (IDESYNC.NE.0.AND.IDOSE.EQ.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IDESYNC AND IDOSE ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'IDOSE SET TO ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IDESYNC AND IDOSE ARE INCOMPATIBLE'
          WRITE(6,*)'IDOSE SET TO ONE'
          WRITE(6,*)
          IDOSE=1
        ENDIF

        IF (IDESYNC.NE.0.AND.ISTOKES.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IDESYNC AND ISTOKES ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'ISTOKES SET TO ZERO'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IDESYNC AND ISTOKES ARE INCOMPATIBLE'
          WRITE(6,*)'ISTOKES SET TO ZERO'
          WRITE(6,*)
          ISTOKES=0
        ENDIF

        IF (IRFILSP0.NE.0.AND.IBRILL.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IRFILSP0 AND IBRILL ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'IBRILL SET TO ZERO'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IRFILSP0 AND IBRILL ARE INCOMPATIBLE'
          WRITE(6,*)'IBRILL SET TO ZERO'
          WRITE(6,*)
          IBRILL=0
        ENDIF

        IF (IRFILSP0.NE.0.AND.ISTOKES.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IRFILSP0 AND ISTOKES ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'ISTOKES SET TO ZERO'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IRFILSP0 AND ISTOKES ARE INCOMPATIBLE'
          WRITE(6,*)'ISTOKES SET TO ZERO'
          WRITE(6,*)
          ISTOKES=0
        ENDIF

        IF (IDESYNC.NE.0.AND.IPIN.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IDESYNC AND IPIN ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'IPIN SET TO ZERO'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IDESYNC AND IPIN ARE INCOMPATIBLE'
          WRITE(6,*)'IPIN SET TO ZERO'
          WRITE(6,*)
          IPIN=0
        ENDIF

        IF (IPHASE.NE.0.AND.(IPIN.EQ.0.OR.IPIN.EQ.2)) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAGS IPHASE AND IPIN ARE INCOMPATIBLE'
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAGS IPHASE AND IPIN ARE INCOMPATIBLE'
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF

+self,if=testiampli
        IF (iampskip.eq.0
     &      .and.IAMPLI.GT.0.AND.ISPECMODE.lt.3.and.iamprep.ge.0) THEN
c noch ueberdenken, iphase bereits kompatibel gemacht, 17.10.2012
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAGS IAMPLI AND ISPECMODE ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'WILL RESULTS IN ERRORS FOR PHASE PROPAGATION'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN GFINIT ***'
          WRITE(6,*)'FLAGS IAMPLI AND ISPECMODE ARE INCOMPATIBLE'
          WRITE(6,*)'WILL RESULTS IN ERRORS FOR PHASE PROPAGATION'
          WRITE(LUNGFO,*)
     &      '*** ISPECMODE set to 3, due to IPHASE'
          PRINT *,
     &      '*** ISPECMODE set to 3, due to IPHASE'
                ISPECMODE=3
          WRITE(6,*)
        ENDIF
+self...,if=testiampli

      ENDIF !ISPEC

      IF (IF1DIM.EQ.1.AND.IRPHI.NE.0.AND.IPINCIRC.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '*** WARNING IN GFINIT: IF1DIM.EQ.1.AND.IRPHI.NE.0.AND.IPINCIRC.NE.0'
        WRITE(LUNGFO,*)'IRPHI SET TO ZERO'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)
     &    '*** WARNING IN GFINIT: IF1DIM.EQ.1.AND.IRPHI.NE.0.AND.IPINCIRC.NE.0'
        WRITE(6,*)'IRPHI SET TO ZERO'
        WRITE(6,*)
        IRPHI=0
      ENDIF

      IF (IPIN.EQ.0.AND.IPINCIRC.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'WARNING IN GFINIT: IPIN.EQ.0.AND.IPINCIRC.NE.0'
        WRITE(LUNGFO,*)'IPINCIRC SET TO ZERO'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'WARNING IN GFINIT: IPIN.EQ.0.AND.IPINCIRC.NE.0'
        WRITE(6,*)'IPINCIRC SET TO ZERO'
        WRITE(6,*)
        IPINCIRC=0
      ENDIF

      if (ivelofield.eq.2) then
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '*** IVELOFIELD=2 is obsolete and not supported anymore ***'
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED'
        WRITE(6,*)
        WRITE(6,*)
     &    '*** IVELOFIELD=2 is obsolete and not supported anymore ***'
        WRITE(6,*)'*** PROGRAM WAVE ABORTED'
        stop
      endif

      IF (iphfold.ne.0.and.(phbeth.eq.-9999.0d0 .or. phbetav.eq.-9999.0d0)) THEN
        print*,'--- IEMIT triggerd due to IPHFOLD and (IPHBETH=-9999 or IPHBETAV=-9999 ---'
        iemit=1
      ENDIF

C--- WRITE CONTROL FLAGS

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     MODE FLAGS:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     IUNDULATOR,IWIGGLER: ',IUNDULATOR,IWIGGLER
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     CONTROL FLAGS:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)'     IUNAME,IUSTEP,IUOUT: ',IUNAME,IUSTEP,IUOUT
      WRITE(LUNGFO,*)'     IOPTIC,IGENFUN:      ',IOPTIC,IGENFUN
      WRITE(LUNGFO,*)'     IMAGSPLN:            ',IMAGSPLN
      IF (IOPTIC.NE.0.) THEN
       WRITE(LUNGFO,*)'        IPHASPAC, IHPHSPAC:         ',IPHASPAC,IHPHSPAC
      ENDIF
      IF (IOPTIC.NE.0.OR.IGENFUN.NE.0) THEN
         WRITE(LUNGFO,*)'        IERZANA,IERZFUN,I2DIM:     ',
     &                             IERZANA,IERZFUN,I2DIM
      ENDIF
      WRITE(LUNGFO,*)'     IEMIT,IEMIAHW:       ',IEMIT,IEMIAHW
      WRITE(LUNGFO,*)'     IWLSOPT,IBEAMPOL:    ',IWLSOPT,IBEAMPOL
      IF (IWLSOPT.NE.0) THEN
         WRITE(LUNGFO,*)'        IEMICRIT:                  ',IEMICRIT
      ENDIF
      WRITE(LUNGFO,*)'     IENELOSS, IEFIELD:   ',IENELOSS,IEFIELD
      WRITE(LUNGFO,*)'     IPOWER,ISPEC:        ',IPOWER,ISPEC
      WRITE(LUNGFO,*)'     IVELOFIELD,ISPECMODE:',IVELOFIELD,ISPECMODE

      IF (JWFILINT.LE.0) JWFILINT=-jwfilint

      IF (ISPEC.NE.0) THEN
        if (mthreads.ne.0.and.mthreads.ne.1.and.iwfilint.ne.0) then
          print*,"*** Warning in gfinit: MTHREADS set to zero, since IWFILINT is set ***"
          mthreads=0
        endif
        WRITE(LUNGFO,*)'        IWFILL0,IRFILL0:           ',IWFILL0,IRFILL0
        WRITE(LUNGFO,*)'        ISPECINT,IPIN:             ',ISPECINT,IPIN
        WRITE(LUNGFO,*)'        ISTOKES,IBRILL:            ',ISTOKES,IBRILL
        WRITE(LUNGFO,*)'        IPINCIRC,IRPHI:            ',IPINCIRC,IRPHI
        WRITE(LUNGFO,*)'        IFOLD,ISIGUSR:             ',IFOLD,ISIGUSR
        WRITE(LUNGFO,*)'        IF1DIM,IPOLA:              ',IF1DIM,IPOLA
        WRITE(LUNGFO,*)'        IWFILSP0,IWFILSPF:         ',IWFILSP0,IWFILSPF
        WRITE(LUNGFO,*)'        IRFILSP0,IRFILSTO:         ',IRFILSP0,IRFILSTO
        WRITE(LUNGFO,*)'        IWFILSTO,IWFLSTOF:         ',IWFILSTO,IWFLSTOF
        WRITE(LUNGFO,*)'        ISPECANA,ISPECANAF:        ',ISPECANA,ISPECANAF
        WRITE(LUNGFO,*)'        IAMPLI,IAMPSKIP:           ',IAMPLI,IAMPSKIP
        WRITE(LUNGFO,*)'        IWFILFL0,IWFILFLF:         ',IWFILFL0,IWFILFLF
        WRITE(LUNGFO,*)'        IWFILS,IWFILSF:            ',IWFILS,IWFILSF
        WRITE(LUNGFO,*)'        IWFILSE,IWFILSEF:          ',IWFILSE,IWFILSEF
        WRITE(LUNGFO,*)'        IWFILB,IWFILBF:            ',IWFILB,IWFILBF
        WRITE(LUNGFO,*)'        IWFILBE,IWFILBEF:          ',IWFILBE,IWFILBEF
        WRITE(LUNGFO,*)'        IWFILINT,IPINALL:          ',IWFILINT,IPINALL
        WRITE(LUNGFO,*)'        IRFILOB,IFILTER:           ',IRFILOB,IFILTER
        WRITE(LUNGFO,*)'        IWFILRAY,IDESYNC:          ',IWFILRAY,IDESYNC
        WRITE(LUNGFO,*)'        IPHASE,IPHASEANA:          ',IPHASE,IPHASEANA
        WRITE(LUNGFO,*)'        IDOSE,IEFOLD:              ',IDOSE,IEFOLD
        WRITE(LUNGFO,*)'        ISPECDIP,IBL0CUT:          ',ISPECDIP,IBL0CUT
        WRITE(LUNGFO,*)'        IEFFI,IFILMUL:             ',IEFFI,IFILMUL
        WRITE(LUNGFO,*)'        IBUNCH, IUBUNCH, NBUNCH:   ',IBUNCH,IUBUNCH,NBUNCH
      ENDIF !ISPEC

      WRITE(LUNGFO,*)'     IWFILF:              ',IWFILF


      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     MAGNETIC FIELD FLAGS:'
      WRITE(LUNGFO,*)
      IF (ICHARGE.GT.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'ATTENTION: TRACKING POSITRONS ***'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'ATTENTION: TRACKING POSITRONS ***'
        WRITE(6,*)
        ICHARGE=1
      ELSE IF (ICHARGE.LT.0) THEN
        ICHARGE=-1
      ELSE
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** Error in GFINIT: ICHARGE IS ZERO, check wave.in'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** Error in GFINIT: ICHARGE IS ZERO, check wave.in'
        WRITE(6,*)
        STOP '*** Program WAVE aborted ***'
      ENDIF !ICHARGE

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     ICHARGE,IBMASK,JBMASK:',ICHARGE,IBMASK,JBMASK
      WRITE(LUNGFO,*)'     IBSUPER,IBERROR:      ',IBSUPER,IBERROR
      WRITE(LUNGFO,*)'     ICUTFIBO:             ',ICUTFIBO
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)'     IPERIODG,IBSYM:      ',IPERIODG,IBSYM
      WRITE(LUNGFO,*)'     IBSYMY,IBSYMZ:       ',IBSYMY,IBSYMZ
      WRITE(LUNGFO,*)'     KBEXTERN,KBFELD:     ',KBEXTERN,KBFELD
      WRITE(LUNGFO,*)'     KHALBA,KHALBASY:     ',KHALBA,KHALBASY
      WRITE(LUNGFO,*)'     KUCROSS,IRFILP:      ',KUCROSS,IRFILP
      WRITE(LUNGFO,*)'     KMAGSEQ,IMGSQF:      ',KMAGSEQ,IMGSQF
      WRITE(LUNGFO,*)'            KMAGCOR:      ',KMAGCOR
      WRITE(LUNGFO,*)'     IRFILF,KELLIP:       ',IRFILF,KELLIP
      WRITE(LUNGFO,*)'     IRBTAB,IRBTABZY:     ',IRBTAB,IRBTABZY
      WRITE(LUNGFO,*)'     IFOURBTABZY:         ',IFOURBTABZY
      WRITE(LUNGFO,*)'     IRFILT0,IRBTABXYZ:   ',IRFILT0,IRBTABXYZ
      WRITE(LUNGFO,*)'     KBPOLYH,KBPOLY3D:    ',KBPOLYH,KBPOLY3D
      WRITE(LUNGFO,*)'     KBREC,KELLANA:       ',KBREC,KELLANA
      if (kbrec.gt.0) then
        WRITE(LUNGFO,*)'          IRECU:          ',IRECU
        WRITE(LUNGFO,*)'          IRECMODU:       ',IRECMODU
      endif
      WRITE(LUNGFO,*)'     KUNDUGAP,KBUNDUMAG:  ',kundugap,kbundumag
      WRITE(LUNGFO,*)'     KBPOLYMAG,KBGENESIS: ',KBPOLYMAG,KBGENESIS
      WRITE(LUNGFO,*)'     KBAMWLS,IRFILB0:     ',KBAMWLS,IRFILB0
      WRITE(LUNGFO,*)'     ICLUSTER:            ',ICLUSTER
      WRITE(LUNGFO,*)

+self,if=omp.
c      if (iundulator.ne.2.and.ibunch.ne.0.and.mthreads.ne.0.and.icluster.eq.0) then
c        write(6,*)""
c        write(6,*)"*** Warning in gfinit: IBUNCH and MTHREAD not zero ***"
c        write(6,*)"*** This is not yet implemented, be careful, better set MTHREADS=0 ***"
c        write(6,*)"*** Or consider IUNDULATOR=2 ***"
c        write(6,*)""
c      endif

      if (ipin.ne.3.and.ipin.ne.0) then
        call omp_ini(lungfo,mthreads,1)
      else
        mthreads=0
        iomp=0
      endif
+self.

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     HISTOGRAM FLAGS:'
      WRITE(LUNGFO,*)

      IF (NINTFREQ.GT.99.AND.IHPIN.GT.0.and.IFREQ2P.gt.1.and.ispec.ne.0) THEN
      IHPIN=0
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &'*** WARNING IN GFINIT: MORE THAN 99 PHOTONENERGIES CONSIDERED'
      WRITE(LUNGFO,*)
     &'HISTOGRAMS FOR FOLDING FUNCTION AND FLUX DISTRIBUTION CANCELED'
      WRITE(LUNGFO,*)
      WRITE(6,*)
      WRITE(6,*)
     &'*** WARNING IN GFINIT: MORE THAN 99 PHOTONENERGIES CONSIDERED'
      WRITE(6,*)
     &'HISTOGRAMS FOR FOLDING FUNCTION AND FLUX DISTRIBUTION CANCELED'
      WRITE(6,*)
      ENDIF

      IF (IEMIT.EQ.0) IHBETA=0
      IF (IPIN.EQ.0)  IHPIN=0
      IF (IPIN.EQ.0)  IHFOLD=0
      IF (IFOLD.EQ.0)  IHFOLD=0
      IF (ISPEC.EQ.0) then
        IHFREQ=0
        ihpin=0
      endif

      if (ihpin.ne.0.and.ihfreq.eq.0) then
        write(6,*)'*** Warning in GFINIT: IHPIN.NE.0 but IHFREQ.EQ.0 ***'
        write(6,*)'*** IHFREQ SET TO ONE ***'
        write(LUNGFO,*)'*** Warning in GFINIT: IHPIN.NE.0 but IHFREQ.EQ.0 ***'
        write(LUNGFO,*)'*** IHFREQ SET TO ONE ***'
        ihfreq=1
      endif

      if (ntupgrid.ne.0.and.mhbookp.ne.0) then
        write(6,*)'*** WARNING: NTUPGRID is set zero, since it is obsolete for this version of WAVE!'
        ntupgrid=0
      endif

      ihtrack=-abs(ihtrack) ! Block old fashioned histograms
      ihtrackm=-abs(ihtrackm) ! Block old fashioned histograms

      IF (IHFIL.NE.0.OR.IHPIN.NE.0.OR.IHTRACK.NE.0.OR.IHBETA.NE.0
     &  .OR.IHTRACKM.NE.0.OR. IHFREQ.NE.0.OR.IPOWER.NE.0
     &  .OR.IHPHSPAC.NE.0.OR.IHINPUT.NE.0
     &  .OR.IHBPOLY3D.NE.0.OR.IHBPOLY2DH.NE.0.OR.IHBPHARM.NE.0
     &  .OR.IHSEL.NE.0.OR.IHFOLD.NE.0.OR.NTUPGRID.NE.0.OR.KBGENESIS.GT.0
     &  .or.ihbunch.ne.0.or.(ieneloss.lt.0.and.ihphotons.ne.0)
     &  )IHBOOK=1

      if (ihbook.eq.0) ihindex=0

      WRITE(LUNGFO,*)'     IHBOOK,IHINDEX:      ',IHBOOK,IHINDEX

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     OTHER OPTIONS:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)'     IWBTAB,IWFILT0:      ',IWBTAB,IWFILT0
      WRITE(LUNGFO,*)'     IWSECTMAGS:          ',IWSECTMAGS
      WRITE(LUNGFO,*)'     IJUST,ISNORDER:      ',IJUST,ISNORDER
      WRITE(LUNGFO,*)'     IWBMAP,IWBPOLY3D:    ',IWBMAP,IWBPOLY3D
      WRITE(LUNGFO,*)'     IWBPOLY2DH,IWBPHARM: ',IWBPOLY2DH,IWBPHARM
      WRITE(LUNGFO,*)

      if (irfilt0.ne.0) call trajectory_to_bfield_ini

C--- MERGE FILE WITH ABSORPTION COEFFICIENTS AND EXIT

      IF (ISPEC.NE.0.AND.IFILTER.LT.0) THEN
          CALL ABSCOEF_MERGE
      ENDIF

C--- SOME USEFUL CONSTANTS AND VARIABLES

c11.10.2017      DTIM=1.0D0/(CLIGHT1*MYINUM)   !TIME INTERVALLS FOR TRACKING
      DTIM=1.0D0/(CLIGHT1*dmybetap*MYINUM)   !TIME INTERVALLS FOR TRACKING
      BSHIFT=0.5D0          !DONT WORRY

      DS0=CLIGHT1*DTIM
      GAMMA=DMYGAMMA
      ENERGV=GAMMA*EMASSE1
      GMOM=EMASSG1*DSQRT((GAMMA-1.0d0)*(GAMMA+1.0d0))
      EMOM=EMASSE1*DSQRT((GAMMA-1.0d0)*(GAMMA+1.0d0))
      DBRHO=ICHARGE*EMOM/CLIGHT1
      BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
      DMYBETA=BETA
      V0=CLIGHT1*BETA
      TAUPOL01G=POL2CON1*UMFANG*RDIPOL**2/1.**5

      ecdipev1=3.0d0/2.0d0*hbarev1*(clight1/emasse1)**2/emasse1*1.0d18

      gamma1=1.0d0/emassg1
      emom1=emasse1*dsqrt((gamma1-1.0d0)*(gamma1+1.0d0))
      rho1=emom1/clight1
      omegac=1.5d0*gamma1**3*clight1/rho1
c      ecdipev=omegac*hbar1/echarge1
c      ecdipkev=ecdipev/1000.0d0

      CROTD=DCOSD(XROTD)
      SROTD=DSIND(XROTD)

C--- NORMALIZATION OF SPECTRUM
C    THE INTEGRATION (SR SPECTRUM) YIELDS THE PHOTON POWER PER ENERGY INTERVAL
C    dE AND SURFACE ELEMENT dA. THIS RESULT IS MULITPLIED BY THE NUMBER OF
C    ELECTRONS (DMYCUR/ECHARGE1),
C    A CONSTANT (ECHARGE1**2/(16*PI**3*EPS01*CLIGHT),
C    dE/E AND THE RELATIVE BANDWIDTH (USUALLY 1/1000). THE FINAL RESULT IS
C    OBTAINED BY A DIVISION THROUGH THE PHOTON ENERGY HBAR*OMEGA, WHICH GIVES
C    NOW THE PHOTON RATE PER BANDWIDTH AND SURFACE ELEMENT IN SI-UNITS

C     SPECNOR=    !DONT USE IT!!!
C     &          ECHARGE1**2/(4.D0*PI1**2*CLIGHT1)
C     &          /(4.D0*PI1*EPS01)
C     &          *DMYCUR/ECHARGE1
C     &          *BANWID
C     &          /(HBAREV1*ECHARGE1)

      SPECNOR=
     &          BANWID
     &          /(4.0D0*PI1**2*CLIGHT1*HBAREV1)
     &          /(4.0D0*PI1*EPS01)
     &          *DMYCUR

      POWNOR=ECHARGE1/16.0D0/PI1/PI1/EPS01/CLIGHT1*DMYCUR

C- NORMALIZE POLARIZATION VECTOR

      IF (IPOLA.NE.0) THEN

+SELF,IF=-NOCMPLX.

          VPOLAN=CDSQRT(
     &             VPOLA(1)*CONJG(VPOLA(1))
     &            +VPOLA(2)*CONJG(VPOLA(2))
     &            +VPOLA(3)* CONJG(VPOLA(3)))

          IF (VPOLAN.EQ.0.0) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
         WRITE(LUNGFO,*)'     POLARIZATION PLANE NOT DEFINED'
         WRITE(LUNGFO,*)'     CHECK VECTOR VPOLA IN NAMELIST SPECTN'
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)'     *** ERROR IN GFINIT ***'
         WRITE(6,*)'     POLARIZATION PLANE NOT DEFINED'
         WRITE(6,*)'     CHECK VECTOR VPOLA IN NAMELIST SPECTN'
         WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
          ENDIF !VPOLAN
          DO ICOMP=1,3
         VPOLA(ICOMP)=VPOLA(ICOMP)/VPOLAN
          ENDDO   !ICOMP
      ENDIF !IPOLA


        VSTOKES(1,1)=( 0.0d0,        0.0d0)      !HORIZONTAL POLARIZATION
        VSTOKES(1,2)=( 0.0d0,        0.0d0)
c        VSTOKES(1,3)=(-1.0d0,        0.0d0) !7mar05
        VSTOKES(1,3)=(-1.0d0,       -1.0d0) !Definition siehe
                                       !scienceworld.wolfram.com
                                       !liefert aber nur Phasenfaktor
                                       !im Vergleich zur alten Fassung

        VSTOKES(2,1)=( 0.0d0,        0.0d0)      !RIGHT HANDED POLARIZATION
        VSTOKES(2,2)=( 0.0d0,       -1.0d0)
        VSTOKES(2,3)=(+1.0d0,        0.0d0)

        VSTOKES(3,1)=( 0.0d0,        0.0d0)      !LEFT HANDED POLARIZATION
        VSTOKES(3,2)=( 0.0d0,       -1.0d0)
        VSTOKES(3,3)=(-1.0d0,        0.0d0)

        VSTOKES(4,1)=( 0.0d0,        0.0d0)      !45 DEGREE LINEAR POLARIZATION
        VSTOKES(4,2)=( 1.0d0,        0.0d0)
        VSTOKES(4,3)=(-1.0d0,        0.0d0)

         DO ISTO=1,4
             VSTO=DSQRT
     &            (CDABS(VSTOKES(ISTO,1))**2
     &            +CDABS(VSTOKES(ISTO,2))**2
     &            +CDABS(VSTOKES(ISTO,3))**2)
             VSTOKES(ISTO,1)=VSTOKES(ISTO,1)/VSTO
             VSTOKES(ISTO,2)=VSTOKES(ISTO,2)/VSTO
             VSTOKES(ISTO,3)=VSTOKES(ISTO,3)/VSTO

+SELF,IF=NOCMPLX.
             stop '*** Error in GFINIT: Check Stokes vectors, see complex version, 18.4.2024'
          VPOLAN=SQRT(
     &             VPOLAR(1)*VPOLAR(1)+VPOLAI(1)*VPOLAI(1)
     &            +VPOLAR(2)*VPOLAR(2)+VPOLAI(2)*VPOLAI(2)
     &            +VPOLAR(3)*VPOLAR(3)+VPOLAI(3)*VPOLAI(3))

          IF (VPOLAN.EQ.0.0) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
         WRITE(LUNGFO,*)'     POLARIZATION PLANE NOT DEFINED'
         WRITE(LUNGFO,*)'     CHECK VECTOR VPOLA IN NAMELIST SPECTN'
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)'     *** ERROR IN GFINIT ***'
         WRITE(6,*)'     POLARIZATION PLANE NOT DEFINED'
         WRITE(6,*)'     CHECK VECTOR VPOLA IN NAMELIST SPECTN'
         WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
          ENDIF !VPOLAN

          DO ICOMP=1,3
              VPOLAR(ICOMP)=VPOLAR(ICOMP)/VPOLAN
              VPOLAI(ICOMP)=VPOLAI(ICOMP)/VPOLAN
          ENDDO   !ICOMP

      ENDIF !IPOLA


        VSTOKESR(1,1)=0.0D0      !HORIZONTAL POLARIZATION
        VSTOKESR(1,2)=0.0D0
        VSTOKESR(1,3)=-1.0D0
        VSTOKESI(1,1)=0.0D0      !HORIZONTAL POLARIZATION
        VSTOKESI(1,2)=0.0D0
        VSTOKESI(1,3)=0.0D0

        VSTOKESR(2,1)=0.0D0    !RIGHT HANDED POLARIZATION
        VSTOKESR(2,2)=0.0D0
        VSTOKESR(2,3)=+1.0D0
        VSTOKESI(2,1)=0.0D0      !RIGHT HANDED POLARIZATION
        VSTOKESI(2,2)=-1.0D0
        VSTOKESI(2,3)=0.0D0

        VSTOKESR(3,1)=0.0D0  !LEFT HANDED POLARIZATION
        VSTOKESR(3,2)=0.0D0
        VSTOKESR(3,3)=-1.0D0
        VSTOKESI(3,1)=0.0D0      !LEFT HANDED POLARIZATION
        VSTOKESI(3,2)=-1.0D0
        VSTOKESI(3,3)=0.0D0

        VSTOKESR(4,1)=0.0D0  !45 DEGREE LINEAR POLARIZATION
        VSTOKESR(4,2)=1.0D0
        VSTOKESR(4,3)=-1.0D0
      VSTOKESI(4,1)=0.0D0      !45 DEGREE LINEAR POLARIZATION
        VSTOKESI(4,2)=0.0D0
        VSTOKESI(4,3)=0.0D0

         DO ISTO=1,4
             VSTO=SQRT(
     &            VSTOKESR(ISTO,1)**2+VSTOKESI(ISTO,1)**2
     &           +VSTOKESR(ISTO,2)**2+VSTOKESI(ISTO,2)**2
     &           +VSTOKESR(ISTO,3)**2+VSTOKESI(ISTO,3)**2)
             VSTOKESR(ISTO,1)=VSTOKESR(ISTO,1)/VSTO
             VSTOKESR(ISTO,2)=VSTOKESR(ISTO,2)/VSTO
             VSTOKESR(ISTO,3)=VSTOKESR(ISTO,3)/VSTO
             VSTOKESI(ISTO,1)=VSTOKESI(ISTO,1)/VSTO
             VSTOKESI(ISTO,2)=VSTOKESI(ISTO,2)/VSTO
             VSTOKESI(ISTO,3)=VSTOKESI(ISTO,3)/VSTO

+SELF.
         ENDDO

C--- RETURN IF WLSOPT IS SELECTED

c      IF(IDISPER.EQ.0.AND.IWLSOPT.NE.0) RETURN !NUR OPTIMALEN AHW SUCHEN

C--- ADJUST SOMETHING

      IF(IJUST.NE.0) THEN
         XJUST=HSHIFT   !XJUST is adjusted by bringing YJUST to zero
         YJUST=ZF0
         CALL WLSJUST(XJUST,YJUST)
         HSHIFT=XJUST
      ENDIF

C--- CHECK CONTROL FLAGS (HBOOK FLAGS ALREADY CHECKED)

c24.3.94{ wegen efold und anderer unsicherheiten, da evtl irgendwo statements
c         wie dfreq=freq(2)-freq(1) auftauchen}

      IF (IUNIT.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'OPTION iunit DISABLED, DO NOT USE!'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'OPTION iunit DISABLED, DO NOT USE!'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

c24.3.94}

      IF (IWBPOLY3D.NE.0.AND.KBPOLY3D.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAGS IWBPOLY3D AND KBPOLY3D ARE BOTH SET'
          WRITE(LUNGFO,*)'ONLY ONE IS ALLOWED'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAGS IWBPOLY3D AND KBPOLY3D ARE BOTH SET'
          WRITE(6,*)'ONLY ONE IS ALLOWED'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IWBPOLY3D.NE.0.AND.IWBPOLY2DH.NE.0.AND.IWBPHARM.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &'MORE THAN ONE FLAG OF IWBPOLY3D,IWBPOLY2DH,IWBPHARM ARE SET'
          WRITE(LUNGFO,*)'ONLY ONE IS ALLOWED'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &'MORE THAN ONE FLAG OF IWBPOLY3D,IWBPOLY2DH,IWBPHARM ARE SET'
          WRITE(6,*)'ONLY ONE IS ALLOWED'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IWBPOLY3D.NE.0.AND.IWBMAP.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAGS IWBPOLY3D AND IWBMAP ARE BOTH SET'
          WRITE(LUNGFO,*)'ONLY ONE IS ALLOWED'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAGS IWBPOLY3D AND IWBMAP ARE BOTH SET'
          WRITE(6,*)'ONLY ONE IS ALLOWED'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IWBPOLY2DH.NE.0.AND.KBPOLY2DH.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAGS IWBPOLY2DH AND KBPOLY2DH ARE BOTH SET'
          WRITE(LUNGFO,*)'ONLY ONE IS ALLOWED'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAGS IWBPOLY2DH AND KBPOLY2DH ARE BOTH SET'
          WRITE(6,*)'ONLY ONE IS ALLOWED'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IWBPHARM.NE.0.AND.KBPHARM.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAGS IWBPHARM AND KBPHARM ARE BOTH SET'
          WRITE(LUNGFO,*)'ONLY ONE IS ALLOWED'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAGS IWBPHARM AND KBPHARM ARE BOTH SET'
          WRITE(6,*)'ONLY ONE IS ALLOWED'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IWBPOLY2DH.NE.0.AND.IWBMAP.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAGS IWBPOLY2DH AND IWBMAP ARE BOTH SET'
          WRITE(LUNGFO,*)'ONLY ONE IS ALLOWED'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAGS IWBPOLY2DH AND IWBMAP ARE BOTH SET'
          WRITE(6,*)'ONLY ONE IS ALLOWED'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IWBPHARM.NE.0.AND.IWBMAP.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAGS IWBPHARM AND IWBMAP ARE BOTH SET'
          WRITE(LUNGFO,*)'ONLY ONE IS ALLOWED'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAGS IWBPHARM AND IWBMAP ARE BOTH SET'
          WRITE(6,*)'ONLY ONE IS ALLOWED'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPEC.NE.0.AND.IEFOLD.NE.0.AND.ISTOKES.EQ.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAG IEFOLD IS SET BUT ISTOKES IS NOT'
          WRITE(LUNGFO,*)'SET ALSO FLAG ISTOKES IN INPUT FILE'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAG IEFOLD IS SET BUT ISTOKES IS NOT'
          WRITE(6,*)'SET ALSO FLAG ISTOKES IN INPUT FILE'
          WRITE(6,*)
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPEC.NE.0.AND.IDOSE.NE.0.AND.ISPECINT.EQ.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'FLAG IDOSE IS SET BUT ISPECINT IS NOT'
          WRITE(LUNGFO,*)'SET FLAG ISPECINT IN INPUT FILE'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'FLAG IDOSE IS SET BUT ISPECINT IS NOT'
          WRITE(6,*)'SET FLAG ISPECINT IN INPUT FILE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF
      IF (IWFILSP0.NE.0.AND.IRFILSP0.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IWFILSP0 AND IRFILSP0 ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IWFILSP0 AND IRFILSP0 ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IWFILSTO.NE.0.AND.IRFILSTO.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IWFILSTO AND IRFILSTO ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IWFILSTO AND IRFILSTO ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPECANA.NE.0.AND.IDESYNC.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS ISPECANA AND IDESYNC ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS ISPECANA AND IDESYNC ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPECANA.NE.0.AND.ISPECDIP.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS ISPECANA AND ISPECDIP ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS ISPECANA AND ISPECDIP ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPECDIP.NE.0.AND.IDESYNC.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS ISPECDIP AND IDESYNC ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS ISPECDIP AND IDESYNC ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPECANA.NE.0.AND.IRFILSP0.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS ISPECANA AND IRFILSP0 ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS ISPECANA AND IRFILSP0 ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPECDIP.NE.0.AND.IRFILSP0.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS ISPECDIP AND IRFILSP0 ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS ISPECDIP AND IRFILSP0 ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ISPECANA.NE.0.AND.IRFILSTO.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS ISPECANA AND IRFILSTO ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS ISPECANA AND IRFILSTO ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IUSEM.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'IUSEM IS NOT SUPPORTED ANYMORE!'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)'IUSEM IS NOT SUPPORTED ANYMORE!'
          WRITE(6,*)
          stop "*** WAVE aborted ***"
      ENDIF

      IF (IUSEM.NE.0 .AND. IF1DIM.EQ.1) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &      'FLAGS IF1DIM AND IUSEM ARE INCOMPATIBLE'
          WRITE(LUNGFO,*)'SET ONLY ONE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN GFINIT ***'
          WRITE(6,*)
     &      'FLAGS IF1DIM AND IUSEM ARE INCOMPATIBLE'
          WRITE(6,*)'SET ONLY ONE'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

C     IF (IPINCIRC.NE.0 .AND. IUSEM.EQ.0) THEN
C         WRITE(LUNGFO,*)
C         WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
C         WRITE(LUNGFO,*)
C     &      'FLAG IPINCIRC IS SET BUT FLAG IUSEM IS NOT'
C         WRITE(LUNGFO,*)
C     &      'SET BOTH FLAGS TO CALCULATE FLUX THROUGH CIRCULAR PINHOLE'
C         WRITE(LUNGFO,*)
C         WRITE(6,*)
C         WRITE(6,*)'*** ERROR IN GFINIT ***'
C         WRITE(6,*)
C     &      'FLAG IPINCIRC IS SET BUT FLAG IUSEM IS NOT'
C         WRITE(6,*)
C     &      'SET BOTH FLAGS TO CALCULATE FLUX THROUGH CIRCULAR PINHOLE'
C         WRITE(6,*)
C         STOP
C     ENDIF

C     IF (ISTOKES.NE.0.AND.IPIN.NE.0  .AND. IUSEM.EQ.0) THEN
C         WRITE(LUNGFO,*)
C         WRITE(LUNGFO,*)'*** ERROR IN GFINIT ***'
C         WRITE(LUNGFO,*)
C     &      'FLAG ISTOKES AND IPIN ARE SET BUT FLAG IUSEM IS NOT'
C         WRITE(LUNGFO,*)
C     &      'SET ALL THESE FLAGS TO CALCULATE STOKES VECTORS FOR PINHOLE'
C         WRITE(LUNGFO,*)
C         WRITE(6,*)
C         WRITE(6,*)'*** ERROR IN GFINIT ***'
C         WRITE(6,*)
C     &      'FLAG ISTOKES AND IPIN ARE SET BUT FLAG IUSEM IS NOT'
C         WRITE(6,*)
C     &      'SET ALL THESE FLAGS TO CALCULATE STOKES VECTORS FOR PINHOLE'
C         WRITE(6,*)
C         STOP
C     ENDIF

      IF (IEMIAHW.NE.0.AND.DDISP0.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'     FLAG IEMIAHW INCOMPATIBLE WITH DDISP0.NE.0)'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'     *** ERROR IN GFINIT ***'
          WRITE(6,*)'     FLAG IEMIAHW INCOMPATIBLE WITH DDISP0.NE.0)'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IEMIAHW.NE.0.AND.KHALBASY.EQ.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)'     FLAG IEMIAHW SET BUT KHALBASY=0'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'     *** ERROR IN GFINIT ***'
          WRITE(6,*)'     FLAG IEMIAHW SET BUT KHALBASY=0'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IFOLD.NE.0.AND.IPIN.LT.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &'     FLAG IFOLD SET. FLAG IPIN MUST BE GREATER OR EQUAL ZERO'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*) '     *** ERROR IN GFINIT ***'
          WRITE(6,*)
     &'     FLAG IFOLD SET. FLAG IPIN MUST BE GREATER OR EQUAL ZERO'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ispec.ne.0.and.IFOLD.NE.0.AND.ISIGUSR.EQ.0.AND.IEMIT.EQ.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
          WRITE(LUNGFO,*)
     &       '     FLAG ISIGUSR NOT SET. THIS REQUIRES FLAG IEMIT TO BE SET'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*) '     *** ERROR IN GFINIT ***'
          WRITE(6,*)
     &       '     FLAG ISIGUSR NOT SET. THIS REQUIRES FLAG IEMIT TO BE SET'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF(NDWSOU.LT.NDARGU) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     *** ERROR IN IN GFINIT ***'
          WRITE(LUNGFO,*)'     PARAMETER NDWSOUP.LT.NDWARGUP'
          WRITE(LUNGFO,*)'     LOOK AT FILE CMPARA.CMN'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'     *** ERROR IN IN GFINIT ***'
          WRITE(6,*)'     PARAMETER NDWSOUP.LT.NDWARGUP'
          WRITE(6,*)'     LOOK AT FILE CMPARA.CMN'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

C- B-FIELD

      IF (IWSECTMAGS.LT.0) THEN
        JWSECTMAGS=1
      ELSE
        JWSECTMAGS=0
      ENDIF

      KSUM=
     &      KBEXTERN**2
     &      +KBAMWLS**2
     &      +KHALBA**2
     &      +KBFELD**2
     &      +ibmasksp**2
     &      +KHALBASY**2
     &      +KUNDUGAP**2
     &      +IRFILF**2
     &      +IRBTAB**2
     &      +IFOURBTABZY**2
     &      +IRBTABZY**2
     &      +IRBTABXYZ**2
     &      +KUCROSS**2
     &      +KELLIP**2
     &      +KELLANA**2
     &      +KBREC**2
     &      +KBGENESIS**2
     &      +IRFILP**2
     &      +KMAGSEQ**2
     &      +IBHELM**2
     &      +KBPOLYH**2
     &      +KBPOLY3D**2
     &      +KBPOLY2DH**2
     &      +KBPHARM**2
     &      +IRFILB0**2
     &      +IRFILB**2
     &      +JWSECTMAGS

      IF (kbundumag.ne.0) KSUM=KSUM+1
      IF (KBPOLYMAG.GT.0) KSUM=KSUM+1

      IF (KSUM.LT.1) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     *** Warning in GFINIT ***'
        WRITE(LUNGFO,*)'     No magnetic field specified'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)
        WRITE(6,*)'     *** Warning in GFINIT ***'
        WRITE(6,*)'     No magnetic field specified'
        WRITE(6,*)
c        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IBSUPER.EQ.0) THEN

      IAMBI=0

      IF (KBEXTERN .NE.0) IAMBI=IAMBI+1
      IF (KBAMWLS .NE.0) IAMBI=IAMBI+1
      IF (KHALBA  .NE.0) IAMBI=IAMBI+1
      IF (KBFELD  .NE.0) IAMBI=IAMBI+1
      IF (KHALBASY.NE.0) IAMBI=IAMBI+1
      IF (KUNDUGAP.NE.0) IAMBI=IAMBI+1
      IF (IRFILF  .NE.0) IAMBI=IAMBI+1
      IF (IRFILB .NE.0) IAMBI=IAMBI+1
      IF (IRBTAB  .NE.0) IAMBI=IAMBI+1
      IF (IFOURBTABZY.NE.0) IAMBI=IAMBI+1
      IF (IRBTABZY.NE.0) IAMBI=IAMBI+1
      IF (IRBTABXYZ.NE.0) IAMBI=IAMBI+1
      IF (KUCROSS .NE.0) IAMBI=IAMBI+1
      IF (KELLIP  .NE.0) IAMBI=IAMBI+1
      IF (KELLANA .NE.0) IAMBI=IAMBI+1
      IF (KBREC   .gt.0) IAMBI=IAMBI+1
      IF (kbundumag.ne.0) IAMBI=IAMBI+1
      IF (KBPOLYMAG.GT.0) IAMBI=IAMBI+1
      IF (KBGENESIS.GT.0) IAMBI=IAMBI+1
      IF (KBPOLYH .NE.0) IAMBI=IAMBI+1
      IF (KBPOLY3D .NE.0)IAMBI=IAMBI+1
      IF (KBPOLY2DH .NE.0)IAMBI=IAMBI+1
      IF (KBPHARM .NE.0)IAMBI=IAMBI+1
      IF (IRFILP  .NE.0) IAMBI=IAMBI+1
      IF (IRFILB0 .NE.0) IAMBI=IAMBI+1
      IF (IBHELM  .NE.0) IAMBI=IAMBI+1
      IF (IMAGSPLN.GT.0) IAMBI=IAMBI+1
      IF (KMAGSEQ.GT.0) IAMBI=IAMBI+1
      IF (IWSECTMAGS.LT.0) IAMBI=IAMBI+1
      IF (IAMBI.GT.1) THEN
      IF (ibmasksp.LT.0) IAMBI=IAMBI+1
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
      WRITE(LUNGFO,*)'     MAGNETIC FIELD AMBIGIOUSLY SPECIFIED'
      WRITE(LUNGFO,*)'     CHECK FIELD SELECTION AND IBMASKSP'
      WRITE(LUNGFO,*)
      WRITE(6,*)
      WRITE(6,*)
      WRITE(6,*)'     *** ERROR IN GFINIT ***'
      WRITE(6,*)'     MAGNETIC FIELD AMBIGIOUSLY SPECIFIED'
      WRITE(6,*)'     CHECK FIELD SELECTION AND IBMASKSP'
      WRITE(6,*)
      STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      ENDIF !IBSUPER

C- ANALYTICALLY DEFINED GENERATING FUNCTION

      IAMBI=0
      IF (IERZFUN.NE.0) IAMBI=IAMBI+1
      IF (IERZANA.NE.0) IAMBI=IAMBI+1
      IF (IAMBI.GT.1) THEN
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
      WRITE(LUNGFO,*)'     FLAGS IERZRANA AND IERZFUN COLLIDE'
      WRITE(LUNGFO,*)'     SET ONLY ONE'
      WRITE(LUNGFO,*)
      WRITE(6,*)
      WRITE(6,*)
      WRITE(6,*)'     *** ERROR IN GFINIT ***'
      WRITE(6,*)'     FLAGS IERZRANA AND IERZFUN COLLIDE'
      WRITE(6,*)'     SET ONLY ONE'
      WRITE(6,*)
      STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

C- FOURIER-TRANSFORMATION

      IAMBI=0
      IF (IRFILF.NE.0) IAMBI=IAMBI+1
      IF (IWFILF.NE.0) IAMBI=IAMBI+1
      IF (IAMBI.GT.1) THEN
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
      WRITE(LUNGFO,*)'     FLAGS IRFILF AND IWFILF COLLIDE'
      WRITE(LUNGFO,*)'     SET ONLY ONE'
      WRITE(LUNGFO,*)
      WRITE(6,*)
      WRITE(6,*)
      WRITE(6,*)'     *** ERROR IN GFINIT ***'
      WRITE(6,*)'     FLAGS IRFILF AND IWFILF COLLIDE'
      WRITE(6,*)'     SET ONLY ONE'
      WRITE(6,*)
      STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

C--- DEFAULT VALUES

C030414      IF (XINTER.EQ.9999..AND.IBSUPER.EQ.0) THEN

C--- CALCULATE FOURIER-COEFFIZIENTS OF B-FIELD FOR SEQUENCE OF MAGNETS

      IF (KMAGSEQ.NE.0.AND.IMGSQF.NE.0) THEN

        xstarto=xstart
        idum=imgsqf
        if (xstart.eq.9999.) then
          imgsqf=0
          CALL bmagseq(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=bmsqbounds(1)
          imgsqf=idum
c          print*
c          print*,"*** Error in GFINIT: Default 9999 not allowed for XSTART for IMGSQF not zero"
c          print*
c          IABEND=8
c          goto 9999
        endif

        if (xstop.eq.9999.) then
          imgsqf=0
          if (xstopo.ne.9999.) then
            CALL bmagseq(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          endif
          XSTOP=bmsqbounds(2)
c          print*
c          print*,"*** Error in GFINIT: Default 9999 not allowed for XSTOP for IMGSQF not zero"
c          print*
c          IABEND=8
c          goto 9999
        endif
        imgsqf=idum

        ISTORE=IWFILF
        IWFILF=99
        BSTORE=B0SCGLOB
        btapv=btaperv
        btaph=btaperh
        btaperv=0.0d0
        btaperh=0.0d0
        ASTORE=A0SCGLOB
        BSTOREY=B0SCGLOBY
        ASTOREY=A0SCGLOBY
        BSTOREZ=B0SCGLOBZ
        ASTOREZ=A0SCGLOBZ
        BSTORE2=BYGOFF
        BSTORE2Z=BZGOFF
        B0SCGLOB=1.0D0
        A0SCGLOB=1.0D0
        B0SCGLOBY=1.0D0
        A0SCGLOBY=1.0D0
        B0SCGLOBZ=1.0D0
        A0SCGLOBZ=1.0D0
        BYGOFF=0.0
        BZGOFF=0.0

        CALL FOURWLS

        IWFILF=ISTORE
        btaperh=btaph
        btaperv=btapv
        A0SCGLOB=ASTORE
        B0SCGLOB=BSTORE
        A0SCGLOBY=ASTOREY
        B0SCGLOBY=BSTOREY
        A0SCGLOBZ=ASTOREZ
        B0SCGLOBZ=BSTOREZ
        BYGOFF=BSTORE2
        BZGOFF=BSTORE2Z

      ENDIF

      IF (KHALBASY.NE.0.and.mod(nint(ahwpol),2).eq.0) THEN
        print*,"*** WARNING: AHWPOL should be odd, or be aware of strange results ***"
        write(lungfo,*)"*** WARNING: AHWPOL should be odd, or be aware of strange results ***"
      endif

      IF (XINTER.EQ.9999.) THEN

        XSTARTO=XSTART

        IF (KHALBA.NE.0) THEN
          CALL BHALBA(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=-ZLENHAL/2.0D0
        ELSE IF (KBFELD.NE.0) THEN
          CALL MYBFELD(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=XLIM(1)
          IF (IKBFORM.NE.0) XINTER=-XP5
        ELSE IF (KHALBASY.NE.0) THEN
          CALL BHALBASY(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          IF (FASYM.NE.2.0D0) THEN
            XINTER=-ZLHALBASY*(AHWPOL+FASYM)/4.0D0+xcenhal
          ELSE
            XINTER=-ZLHALBASY*((AHWPOL-1.0D0)/2.0D0+1.0D0)/2.+xcenhal
          ENDIF
        ELSE IF (KUNDUGAP.NE.0) THEN
          CALL BUNDUGAP(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM,-1)
          XINTER=-ZLUNDUGAP*((UNDUGAPPOL-1.0D0)/2.0D0+1.0D0)/2.+xcenUNDUGAP
        ELSE IF (IRFILF.eq.1) THEN
          CALL BFOUR(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=-DEVLEN2
        ELSE IF (IFOURBTABZY.NE.0) THEN
          CALL BFOURTABZY(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=XSTART
        ELSE IF (IRBTAB.NE.0) THEN
          CALL BTAB(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=XSTART
        ELSE IF (IRBTABZY.NE.0) THEN
          CALL BTABZY(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=XSTART
        ELSE IF (IRBTABXYZ.NE.0) THEN
          CALL BTABXYZ(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=XSTART
        ELSE IF (KUCROSS.NE.0) THEN
          CALL BUCROSS(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=ULIMI(1)
        ELSE IF (KELLIP.NE.0) THEN
          CALL BELLIP(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          Xinter=-(perellip*xlellip+ellshft*xlellip)/2.0d0+xcenell
        ELSE IF (KELLANA.NE.0) THEN
          CALL BELLANA(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=-HLENELL
        ELSE IF (KBPOLYH.NE.0) THEN
          CALL BPHARM(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
        ELSE IF (KBPOLY3D.NE.0) THEN
          CALL BPOLY3D(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=X3DMIN
        ELSE IF (KBPOLY2DH.NE.0) THEN
          CALL BPOLY2DH(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=X2DHMIN
        ELSE IF (KBPOLY2DH.NE.0) THEN
          CALL BPHARM(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=XPHMIN
        ELSE IF (KBREC.gt.0) THEN
          CALL REC_INIT
        ELSE IF (kbundumag.ne.0) THEN
          muthreads=mthreads
          if (kbundumag.eq.2.or.kbundumag.eq.4) then
            uebeam=dmyenergy
            kwrun=icode
            chwcom=code
            call run_undumag(kbundumag,lungfo)
          else  if (kbundumag.lt.0) then
            call run_undumag(kbundumag,lungfo)
          endif
          CALL bundumag_ini(XSTART,XSTOP,LUNGFO)
        ELSE IF (KBPOLYMAG.GT.0) THEN
          CALL BPOLYINI(XSTART,XSTOP,LUNGFO)
        ELSE IF (KBGENESIS.NE.0) THEN
          CALL BGENESIS(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=GSTOTLEN/2.0D0
        ELSE IF (IRFILB0.EQ.-4) THEN
          CALL BMESSINI4
        ELSE IF (IRFILB0.NE.0.and.abs(irfilb0).ne.6) THEN
          CALL BMESSINI
        ELSE IF (IWSECTMAGS.LT.0) THEN
          CALL BSECTMAGS(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XINTER=XSTART
        ENDIF !xinter

        IF (XINTER.EQ.9999.) THEN

          WRITE (LUNGFO,*)
          WRITE (LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE (LUNGFO,*)'DEFAULT 9999. NOT ALLOWED HERE FOR XINTER '
          WRITE (LUNGFO,*)
          WRITE (6,*)
          WRITE (6,*)'*** ERROR IN GFINIT ***'
          WRITE (6,*)'DEFAULT 9999. NOT ALLOWED HERE FOR XINTER '
          WRITE (6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'

        ENDIF !xinter

        XSTART=XSTARTO

      ENDIF !XINTER.EQ.9999.

      XSTOPO=XSTOP

C030414      IF (XSTART.EQ.9999..AND.IBSUPER.EQ.0) THEN
      IF (XSTART.EQ.9999.) THEN

        XSTARTO=XSTART

        IF (KHALBA.NE.0) THEN
          CALL BHALBA(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=-ZLENHAL/2.0D0
        ELSE IF (kmagseq.NE.0) THEN
          CALL bmagseq(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=bmsqbounds(1)
        ELSE IF (KBFELD.NE.0) THEN
          CALL MYBFELD(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=XLIM(1)
          IF (IKBFORM.NE.0) XSTART=-XP5
        ELSE IF (KHALBASY.NE.0) THEN
          CALL BHALBASY(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          IF (FASYM.NE.2.0D0) THEN
            XSTART=-ZLHALBASY*(AHWPOL+FASYM)/4.0D0+xcenhal
          ELSE
            XSTART=-ZLHALBASY*((AHWPOL-1.0D0)/2.0D0+1.0D0)/2.+xcenhal
          ENDIF
        ELSE IF (KUNDUGAP.NE.0) THEN
          CALL BUNDUGAP(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM,-2)
          XSTART=-ZLUNDUGAP*((UNDUGAPPOL-1.0D0)/2.0D0+1.0D0)/2.+xcenUNDUGAP
        ELSE IF (IRFILF.eq.1) THEN
          CALL BFOUR(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=-DEVLEN2
        ELSE IF (IFOURBTABZY.NE.0) THEN
          CALL BFOURTABZY(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=XSTART
        ELSE IF (IRBTAB.NE.0) THEN
          CALL BTAB(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
        ELSE IF (IRBTABZY.NE.0) THEN
          CALL BTABZY(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=XSTART
        ELSE IF (IRBTABXYZ.NE.0) THEN
          CALL BTABXYZ(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=XSTART
        ELSE IF (KUCROSS.NE.0) THEN
          CALL BUCROSS(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=ULIMI(1)
        ELSE IF (KELLIP.NE.0) THEN
          CALL BELLIP(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=-(perellip*xlellip+ellshft*xlellip)/2.0d0+xcenell
        ELSE IF (KELLANA.NE.0) THEN
          CALL BELLANA(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=-HLENELL
        ELSE IF (KBPOLYH.NE.0) THEN
          CALL BPHARM(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
        ELSE IF (KBPOLY3D.NE.0) THEN
          CALL BPOLY3D(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=X3DMIN
        ELSE IF (KBPOLY2DH.NE.0) THEN
          CALL BPOLY2DH(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=X2DHMIN
        ELSE IF (KBPOLY2DH.NE.0) THEN
          CALL BPHARM(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTART=XPHMIN
        ELSE IF (KBREC.gt.0) THEN
          CALL REC_INIT
        ELSE IF (kbundumag.ne.0) THEN
          muthreads=mthreads
          if (kbundumag.eq.2.or.kbundumag.eq.4) then
            uebeam=dmyenergy
            uebeam_h=dmyenergy
            kwrun=icode
            chwcom=code
            call run_undumag(kbundumag,lungfo)
          else  if (kbundumag.lt.0) then
            call run_undumag(kbundumag,lungfo)
          endif
          CALL bundumag_ini(XSTART,XSTOP,LUNGFO)
        ELSE IF (KBPOLYMAG.GT.0) THEN
          CALL BPOLYINI(XSTART,XSTOP,LUNGFO)
        ELSE IF (KBGENESIS.NE.0) THEN
          XSTART=0.0D0
        ELSE IF (IRFILB0.EQ.-4) THEN
          CALL BMESSINI4
        ELSE IF (abs(IRFILB0).EQ.6) THEN
          bxdum=-9999.0d0
          CALL BMAP(axdum,aydum,azdum,bxdum,bydum,bzdum)
          xstart=axdum
        ELSE IF (IRFILB0.NE.0) THEN
          CALL BMESSINI
        ELSE IF (IWSECTMAGS.LT.0) THEN
          CALL BSECTMAGS(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
        ENDIF

        IF (XSTART.EQ.9999.) THEN

          WRITE (LUNGFO,*)
          WRITE (LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE (LUNGFO,*)'DEFAULT NOT ALLOWED HERE FOR XSTART '
          WRITE (LUNGFO,*)
          WRITE (6,*)
          WRITE (6,*)'*** ERROR IN GFINIT ***'
          WRITE (6,*)'DEFAULT NOT ALLOWED HERE FOR XSTART '
          WRITE (6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'

        ENDIF

      ENDIF !XSTART.EQ.9999.

C030414      IF (XSTOP.EQ.9999..AND.IBSUPER.EQ.0) THEN
      IF (XSTOP.EQ.9999.) THEN

        IF (KHALBA.NE.0) THEN
          CALL BHALBA(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=ZLENHAL/2.0D0
        ELSE IF (kmagseq.NE.0) THEN
          CALL bmagseq(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=bmsqbounds(2)
        ELSE IF (KBFELD.NE.0) THEN
          XSTOP=XLIM(12)
          IF (IKBFORM.NE.0) XSTOP=-XSTART
        ELSE IF (KHALBASY.NE.0) THEN
          CALL BHALBASY(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          IF (FASYM.NE.2.0D0) THEN
            XSTOP=ZLHALBASY*(AHWPOL+FASYM)/4.0D0+xcenhal
          ELSE
            XSTOP=ZLHALBASY*((AHWPOL-1.0D0)/2.0D0+1.0D0)/2.+xcenhal
          ENDIF
        ELSE IF (KUNDUGAP.NE.0) THEN
          CALL BUNDUGAP(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM,-3)
          XSTOP=ZLUNDUGAP*((UNDUGAPPOL-1.0D0)/2.0D0+1.0D0)/2.+xcenUNDUGAP
        ELSE IF (IRFILF.eq.1) THEN
          CALL BFOUR(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=DEVLEN2
        ELSE IF (IFOURBTABZY.NE.0) THEN
          CALL BFOURTABZY(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=XSTOP
        ELSE IF (IRBTAB.NE.0) THEN
          CALL BTAB(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
        ELSE IF (IRBTABZY.NE.0) THEN
          CALL BTABZY(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=XSTOP
        ELSE IF (IRBTABXYZ.NE.0) THEN
          CALL BTABXYZ(9999.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=XSTOP
        ELSE IF (KUCROSS.NE.0) THEN
          CALL BUCROSS(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=ULIMI(4)
        ELSE IF (KELLIP.NE.0) THEN
          CALL BELLIP(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XStop=(perellip*xlellip+ellshft*xlellip)/2.0d0+xcenell
        ELSE IF (KELLANA.NE.0) THEN
          CALL BELLANA(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=HLENELL
        ELSE IF (KBPOLYH.NE.0) THEN
          CALL BPHARM(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
        ELSE IF (KBPOLY3D.NE.0) THEN
          CALL BPOLY3D(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=X3DMAX
        ELSE IF (KBPOLY2DH.NE.0) THEN
          CALL BPOLY2DH(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=X2DHMAX
        ELSE IF (KBPHARM.NE.0) THEN
          CALL BPHARM(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=XPHMAX
        ELSE IF (KBREC.gt.0) THEN
          CALL REC_INIT
        ELSE IF (kbundumag.ne.0) THEN
          muthreads=mthreads
          if (kbundumag.eq.2.or.kbundumag.eq.4) then
            uebeam=dmyenergy
            uebeam_h=dmyenergy
            kwrun=icode
            chwcom=code
            call run_undumag(kbundumag,lungfo)
          else  if (kbundumag.lt.0) then
            call run_undumag(kbundumag,lungfo)
          endif
          CALL bundumag_ini(XSTART,XSTOP,LUNGFO)
        ELSE IF (KBPOLYMAG.GT.0) THEN
          CALL BPOLYINI(XSTART,XSTOP,LUNGFO)
        ELSE IF (abs(IRFILB0).EQ.6) THEN
          bxdum=9999.0d0
          CALL BMAP(axdum,aydum,azdum,bxdum,bydum,bzdum)
          xstop=axdum
        ELSE IF (IRFILB0.EQ.-4) THEN
          CALL BMESSINI4
        ELSE IF (IRFILB0.NE.0.and.abs(irfilb0).ne.6) THEN
          CALL BMESSINI
        ELSE IF (KBGENESIS.NE.0) THEN
          CALL BGENESIS(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
          XSTOP=GSTOTLEN
        ELSE IF (IWSECTMAGS.LT.0) THEN
          CALL BSECTMAGS(0.0D0,0.0D0,0.0D0,BXDUM,BYDUM,BZDUM,AXDUM,AYDUM,AZDUM)
        ENDIF

        if (xstop.eq.9999.) then
          WRITE (LUNGFO,*)
          WRITE (LUNGFO,*)'*** ERROR IN GFINIT ***'
          WRITE (LUNGFO,*)'DEFAULT NOT ALLOWED HERE FOR XSTOP '
          WRITE (LUNGFO,*)
          WRITE (6,*)
          WRITE (6,*)'*** ERROR IN GFINIT ***'
          WRITE (6,*)'DEFAULT NOT ALLOWED HERE FOR XSTOP '
          WRITE (6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF

      ENDIF !XSTOP.EQ.9999.

      if (ibunduini.eq.0.and.kbundumag.ne.0) then
          muthreads=mthreads
          if (kbundumag.eq.2.or.kbundumag.eq.4) then
            uebeam=dmyenergy
            uebeam_h=dmyenergy
            kwrun=icode
            chwcom=code
            call run_undumag(kbundumag,lungfo)
          else  if (kbundumag.lt.0) then
            call run_undumag(kbundumag,lungfo)
          endif
          CALL bundumag_ini(XSTART,XSTOP,LUNGFO)
      endif

      IF (IPERIODG.NE.0.AND.XSTOPO.EQ.9999.) THEN
        XSTOP=XSTOP+(XPERWMX-XPERWMN)
      ENDIF

      IF (IBSYM.NE.0.AND.XSTARTO.EQ.9999.) XSTART=-XSTOP

      IF (XSTARTO.EQ.9999.) XSTART=XSTART-XSHIFT
      IF (XSTOPO.EQ.9999.) XSTOP=XSTOP-XSHIFT

      IF (XSTART.EQ.XSTOP) THEN
        WRITE(LUNGFO,*)'*** ERROR IN GFINIT: XSTART=XSTOP ***'
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
        WRITE(6,*)'*** ERROR IN GFINIT: XSTART=XSTOP ***'
        WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
        STOP
      ENDIF

      if (xtaper.eq.9999.0d0) xtaper=xstart

      IF (NSTEPMX.EQ.0) THEN
        NSTEPMX=NWMAXP
      ELSE IF (NSTEPMX.LT.0) THEN
        NSTEPMX=(XSTOP-XSTART)*MYINUM*2.*(-NSTEPMX)
      ENDIF
      IF (NSTEPMX.LE.0) THEN
        NSTEPMX=NWMAXP
      ENDIF
      NWMAX=NSTEPMX

      IF (NPOLMX.EQ.0) NPOLMX=NDPOLP
      NDPOL=NPOLMX

      CALL MYBFELD(XSTART,YSTART,ZSTART,
     &  BXSTART,BYSTART,BZSTART,
     &  AXSTART,AYSTART,AZSTART)


      IF (VXIN.EQ.0.0D0.AND.VYIN.EQ.0.0D0.AND.VZIN.EQ.0.0D0) VXIN=1.0D0

      IF (XINTER.NE.XSTART.AND.XINTER.NE.-9999.) THEN

        YSTARTO=YSTART
        ZSTARTO=ZSTART

        VXINO=VXIN
        VYINO=VYIN
        VZINO=VZIN

        VN=1.0D0/DSQRT(VXIN**2+VYIN**2+VZIN**2)
        VXIN=VXIN*VN
        VYIN=VYIN*VN
        VZIN=VZIN*VN

        BETX0=VXIN*BETA
        BETY0=VYIN*BETA
        BETZ0=VZIN*BETA

        X0=XSTART
        Y0=YSTART
        Z0=ZSTART

        VX0=VXIN*V0
        VY0=VYIN*V0
        VZ0=VZIN*V0

        IF (XINTER.GT.XSTART) THEN

          BYDUM=B0SCGLOB
          B0SCGLOB=-B0SCGLOB
          btaperv=-btaperv
          btaperh=-btaperh

          CALL TRACKSHORT(ISNORDER,XINTER,Y0,Z0,-VX0,-VY0,-VZ0,
     &      XSTART,0.0D0,0.0D0,-1.0D0,0.0D0,0.0D0,
     &      XF0,YF0,ZF0,dtshort,VXF0,VYF0,VZF0,DTIM,BSHIFT,GAMMA,BMOVECUT,
     &      IUSTEP,IENELOSS,GAMMAL)

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Result of back-tracking due to XINTER:'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     x:',XF0
          WRITE(LUNGFO,*)'     y:',YF0
          WRITE(LUNGFO,*)'     z:',ZF0
          WRITE(LUNGFO,*)'     vx:',-VXF0
          WRITE(LUNGFO,*)'     vy:',-VYF0
          WRITE(LUNGFO,*)'     vz:',-VZF0
          WRITE(LUNGFO,*)'     yp:',VYF0/VXF0
          WRITE(LUNGFO,*)'     zp:',VZF0/VXF0
          WRITE(LUNGFO,*)

          B0SCGLOB=BYDUM
          btaperv=-btaperv
          btaperh=-btaperh
          XSTART=XF0
          YSTART=YF0
          ZSTART=ZF0
          VXIN=-VXF0
          VYIN=-VYF0
          VZIN=-VZF0

          GAMMA=GAMMA-GAMMAL !We gain energy here, and gammal is negative!
          DMYGAMMA=GAMMA
          DMYENERGY=GAMMA*EMASSG1

          ENERGV=GAMMA*EMASSE1
          GMOM=EMASSG1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
          EMOM=EMASSE1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
          DBRHO=ICHARGE*EMOM/CLIGHT1
          BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
          DMYBETA=BETA
          V0=CLIGHT1*BETA

        ELSE   !XINTER.GT.XSTART

          CALL TRACKSHORT(ISNORDER,XINTER,Y0,Z0,VX0,VY0,VZ0,
     &      XSTART,0.0D0,0.0D0,1.0D0,0.0D0,0.0D0,
     &      XF0,YF0,ZF0,dtshort,VXF0,VYF0,VZF0,DTIM,BSHIFT,GAMMA,BMOVECUT,
     &      IUSTEP,IENELOSS,GAMMAL)

          XSTART=XF0
          YSTART=YF0
          ZSTART=ZF0
          VXIN=VXF0
          VYIN=VYF0
          VZIN=VZF0

          GAMMA=GAMMA+GAMMAL !We lose energy here!
          DMYGAMMA=GAMMA
          DMYENERGY=GAMMA*EMASSG1

          ENERGV=GAMMA*EMASSE1
          GMOM=EMASSG1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
          EMOM=EMASSE1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
          DBRHO=ICHARGE*EMOM/CLIGHT1
          BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
          DMYBETA=BETA
          V0=CLIGHT1*BETA

        ENDIF  !XINTER.GT.XSTART

      ENDIF !(XINTER.NE.-9999.)

c20aug09      ROIX(1)=XSTART
c20aug09      ROIX(NROIA)=XSTOP

      IF (XSTART.LT.ROIX(1)) THEN
        WRITE(LUNGFO,*)
     &    '*** ERROR IN NAMELIST ROIN: XSTART < ROIX(1)'
        WRITE(6,*)
     &    '*** ERROR IN NAMELIST ROIN: XSTART < ROIX(1)'
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF !(XSTART.LT.ROIX(1))

      IF (XSTOP.GT.ROIX(NROIA)) THEN
        WRITE(LUNGFO,*)
     &    '*** ERROR IN NAMELIST ROIN: XSTOP GREATER THAN LAST ROI-BOUNDARY'
        WRITE(6,*)
     &    '*** ERROR IN NAMELIST ROIN: XSTOP GREATER THAN LAST ROI-BOUNDARY'
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF !(XSTART.GT.ROIX(1))

      IF (XIANF.EQ.9999.) XIANF=-1.0D30
      IF (XIEND.EQ.9999.) XIEND=1.0D30

      if (iexpert.ne.0) then
        xianf=-1.0d30
        xiend=1.0d30
      endif

      IF (XIANF.EQ.XIEND) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN GFINIT: XIANF=XIEND ***'
        WRITE(LUNGFO,*)'*** SET TO XSTART/XSTOP ***'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN GFINIT: XIANF=XIEND ***'
        WRITE(6,*)'*** SET TO XSTART/XSTOP ***'
        WRITE(6,*)
        XIANF=XSTART
        XIEND=XSTOP
      ENDIF

C--- B-FIELD FROM PANDIRA

      IF (IRFILP.NE.0) CALL READBP

C--- CALCULATE FOURIER-COEFFICIENTS OF B-FIELD AND EXIT

      IF (IWFILF.NE.0) THEN
        CALL FOURWLS
        IABEND=1
        goto 9999
      ENDIF

C--- FIND DEFAULTS FOR VXIN,VYIN,VZIN IF NECESSARY

      IF (VYIN.EQ.9999..AND.VZIN.EQ.9999.) THEN

        VXIN=1.0D0
        VYIN=0.0D0
        VZIN=0.0D0

        BETX0=VXIN*BETA
        BETY0=VYIN*BETA
        BETZ0=VZIN*BETA

        X0=XSTART
        Y0=YSTART
        Z0=ZSTART

        VX0=VXIN*V0
        VY0=VYIN*V0
        VZ0=VZIN*V0

        CALL TRACKSHORT(ISNORDER,X0,Y0,Z0,VX0,VY0,VZ0,
     &    XSTART+PERIODG,0.0D0,0.0D0,1.0D0,0.0D0,0.0D0,
     &    XF0,YF0,ZF0,dtshort,VXF0,VYF0,VZF0,DTIM,BSHIFT,GAMMA,BMOVECUT,
     &    IUSTEP,IENELOSS,GAMMAL)

        GAMMA=GAMMA-GAMMAL !We lose energy here!
        DMYGAMMA=GAMMA
        DMYENERGY=GAMMA*EMASSG1

        ENERGV=GAMMA*EMASSE1
        GMOM=EMASSG1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
        EMOM=EMASSE1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
        DBRHO=ICHARGE*EMOM/CLIGHT1
        BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
        DMYBETA=BETA
        V0=CLIGHT1*BETA

        YP=-YF0/PERIODG
        ZP=-ZF0/PERIODG

        VXIN=V0/DSQRT(1.0D0+ZP*ZP+YP*YP)
        VYIN=YP*VXIN
        VZIN=ZP*VXIN

      ELSE IF (VYIN.EQ.9999.) THEN

        VYIN=0.0D0
        VN=1.0D0/DSQRT(VXIN**2+VYIN**2+VZIN**2)
        VXIN=VXIN*VN
        VYIN=VYIN*VN
        VZIN=VZIN*VN

        BETX0=VXIN*BETA
        BETY0=VYIN*BETA
        BETZ0=VZIN*BETA

        X0=XSTART
        Y0=YSTART
        Z0=ZSTART

        VX0=VXIN*V0
        VY0=VYIN*V0
        VZ0=VZIN*V0

        CALL TRACKSHORT(ISNORDER,X0,Y0,Z0,VX0,VY0,VZ0,
     &    XSTART+PERIODG,0.0D0,0.0D0,1.0D0,0.0D0,0.0D0,
     &    XF0,YF0,ZF0,dtshort,VXF0,VYF0,VZF0,DTIM,BSHIFT,GAMMA,BMOVECUT,
     &    IUSTEP,IENELOSS,GAMMAL)

        GAMMA=GAMMA+GAMMAL !We loose energy here!
        DMYGAMMA=GAMMA
        DMYENERGY=GAMMA*EMASSG1

        ENERGV=GAMMA*EMASSE1
        GMOM=EMASSG1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
        EMOM=EMASSE1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
        DBRHO=ICHARGE*EMOM/CLIGHT1
        BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
        DMYBETA=BETA
        V0=CLIGHT1*BETA

        YP=-YF0/PERIODG
        ZP=VZIN/VXIN

        VXIN=V0/DSQRT(1.0D0+ZP*ZP+YP*YP)
        VYIN=YP*VXIN
        VZIN=ZP*VXIN

      ELSE IF (VZIN.EQ.9999.) THEN

        VZIN=0.0D0
        VN=1.0D0/DSQRT(VXIN**2+VYIN**2+VZIN**2)
        VXIN=VXIN*VN
        VYIN=VYIN*VN
        VZIN=VZIN*VN

        BETX0=VXIN*BETA
        BETY0=VYIN*BETA
        BETZ0=VZIN*BETA

        X0=XSTART
        Y0=YSTART
        Z0=ZSTART

        VX0=VXIN*V0
        VY0=VYIN*V0
        VZ0=VZIN*V0

        CALL TRACKSHORT(ISNORDER,X0,Y0,Z0,VX0,VY0,VZ0,
     &    XSTART+PERIODG,0.0D0,0.0D0,1.0D0,0.0D0,0.0D0,
     &    XF0,YF0,ZF0,dtshort,VXF0,VYF0,VZF0,DTIM,BSHIFT,GAMMA,BMOVECUT,
     &    IUSTEP,IENELOSS,GAMMAL)

        GAMMA=GAMMA+GAMMAL !We lose energy here!
        DMYGAMMA=GAMMA
        DMYENERGY=GAMMA*EMASSG1

        ENERGV=GAMMA*EMASSE1
        GMOM=EMASSG1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
        EMOM=EMASSE1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))
        DBRHO=ICHARGE*EMOM/CLIGHT1
        BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
        DMYBETA=BETA
        V0=CLIGHT1*BETA

        ZP=-ZF0/PERIODG
        YP=VYIN/VXIN

        VXIN=V0/DSQRT(1.0D0+ZP*ZP+YP*YP)
        VYIN=YP*VXIN
        VZIN=ZP*VXIN

      ENDIF !VYIN.EQ.9999..AND.VZIN.EQ.9999.

      xstartP=XSTART
      ystartP=YSTART
      zstartP=ZSTART

      vxinP=VXIN
      vyinP=VYIN
      vzinP=VZIN

C--- TRACK REFERENCE ORBIT FROM XSTART TO XSTOP

C-   NORMALIZE VELOCITY

      VN=1.0D0/DSQRT(VXIN**2+VYIN**2+VZIN**2)
      VXIN=VXIN*VN
      VYIN=VYIN*VN
      VZIN=VZIN*VN

      BETX0=VXIN*BETA
      BETY0=VYIN*BETA
      BETZ0=VZIN*BETA

      X0=XSTART
      Y0=YSTART
      Z0=ZSTART

      VX0=VXIN*V0
      VY0=VYIN*V0
      VZ0=VZIN*V0

      if (xstart.ge.xstop) then
        write(lungfo,*)"*** Error in subroutine gfinit: XSTART >= XSTOP ***"
        write(6,*)"*** Error in subroutine gfinit: XSTART >= XSTOP ***"
        stop "*** Program WAVE aborted ***"
      endif

      CALL TRACK(X0,Y0,Z0,VX0,VY0,VZ0,
     &  XSTOP,0.0D0,0.0D0,1.0D0,0.0D0,0.0D0,
     &  XF0,YF0,ZF0,VXF0,VYF0,VZF0,DTIM,BSHIFT,GAMMA,GAMMAL)
      t0track=wtim0(1)
      tftrack=wtim0(nco)

      CALL TRACEN(0.0D0,YCEN,ZCEN,YPCEN,ZPCEN)
      CALL TRACEN(XIANF,YIANF,ZIANF,YPIANF,ZPIANF)
      CALL TRACEN(XIEND,YIEND,ZIEND,YPIEND,ZPIEND)

      !if (eps0h.eq.0.0d0) eps0h=bsigz(1)*bsigzp(1)
      !if (eps0v.eq.0.0d0) eps0v=bsigy(1)*bsigyp(1)

      IF (betfun.EQ.0.0d0) THEN
        if (eps0h.eq.0.0d0) then
          write(lungfo,*)
     &      '*** Error in GFINIT: EPS0H and BETFUN are zero'
          write(lungfo,*)
     &      '*** Error in GFINIT: Please check namelists DEPOLA and WFOLDN'
          write(6,*)
     &      '*** Error in GFINIT: EPS0H and BETFUN are zero'
          write(6,*)
     &      '*** Error in GFINIT: Please check namelists DEPOLA and WFOLDN'
          stop '*** Program WAVE aborted ***'
        endif
        betfun=bsigz(1)**2/eps0h
      endif

      IF (betfunv.EQ.0.0d0) THEN
        if (eps0v.eq.0.0d0) then
          write(lungfo,*)
     &      '*** Error in GFINIT: EPS0V and BETFUN are zero'
          write(lungfo,*)
     &      '*** Error in GFINIT: Please check namelists DEPOLA and WFOLDN'
          write(6,*)
     &      '*** Error in GFINIT: EPS0V and BETFUN are zero'
          write(6,*)
     &      '*** Error in GFINIT: Please check namelists DEPOLA and WFOLDN'
          stop '*** Program WAVE aborted ***'
        endif
        betfunv=bsigy(1)**2/eps0v
      endif

      IF (iemit.ne.0.or.ibunch.eq.-1.and.iubunch.eq.1.and.betfun*eps0h.EQ.0.0d0) THEN

        if (betfun*eps0h.eq.0.0d0) then
          write(lungfo,*)
     &      '*** Warning in GFINIT: EPS0H or BETFUN are zero'
          write(lungfo,*)
     &      '*** Warning in GFINIT: Please check namelists DEPOLA and WFOLDN'
          write(6,*)
     &      '*** Warning in GFINIT: EPS0H or BETFUN are zero'
          write(6,*)
     &      '*** Warning in GFINIT: Please check namelists DEPOLA and WFOLDN'
        endif

        if ((bsigz(1)*bsigzp(1)).eq.0.0d0) then
          write(lungfo,*)
     &      '*** Warning in GFINIT: BSIGZ(1) and BSIGZP(1) are zero'
          write(lungfo,*)
     &      '*** Warning in GFINIT: Please check namelists DEPOLA and WFOLDN'
          write(6,*)
     &      '*** Warning in GFINIT: BSIGZ(1) and BSIGZP(1) are zero'
          write(6,*)
     &      '*** Warning in GFINIT: Please check namelists DEPOLA and WFOLDN'
        endif

      endif

      IF (iemit.ne.0.or.ibunch.eq.-1.and.iubunch.eq.1.and.betfun*eps0v.EQ.0.0d0) THEN

        if (betfun*eps0v.eq.0.0d0) then
          write(lungfo,*)
     &      '*** Warning in GFINIT: EPS0V or BETFUN are zero'
          write(lungfo,*)
     &      '*** Warning in GFINIT: Please check namelists DEPOLA and WFOLDN'
          write(6,*)
     &      '*** Warning in GFINIT: EPS0V or BETFUN are zero'
          write(6,*)
     &      '*** Warning in GFINIT: Please check namelists DEPOLA and WFOLDN'
        endif

        if ((bsigy(1)*bsigyp(1)).eq.0.0d0) then
          write(lungfo,*)
     &      '*** Warning in GFINIT: BSIGY(1) and BSIGYP(1) are zero'
          write(lungfo,*)
     &      '*** Warning in GFINIT: Please check namelists DEPOLA and WFOLDN'
          write(6,*)
     &      '*** Warning in GFINIT: BSIGY(1) and BSIGYP(1) are zero'
          write(6,*)
     &      '*** Warning in GFINIT: Please check namelists DEPOLA and WFOLDN'
        endif

      endif

      IF (betfun.ne.-9999.0d0) THEN
        IF (ABS(BETAH).EQ.9999.) THEN
          BY    =WTRA(2,3,1)
          RI    =CLIGHT1*BY/EMOM
          TANPHI=WTRA(3,2,1)/WTRA(1,2,1)
          BANA  =BETFUN+X0**2./BETFUN
          BPANA =2.*X0/BETFUN
          BANAC =BANA/(1.+TANPHI**2)
          BPANAC=BPANA/(1+TANPHI**2)+2.*BANA*TANPHI/(1.+TANPHI**2)
     &      *RI/(1+TANPHI**2)
          IF (BETAH.EQ.-9999.) THEN
            BETAH=BANAC
          ELSE IF (BETAH.EQ.9999.) THEN
            BETAH=BANA
          ENDIF
        ENDIF

        IF (ABS(BETAPH).EQ.9999.) THEN
          BY    =WTRA(2,3,1)
          RI    =CLIGHT1*BY/EMOM
          TANPHI=WTRA(3,2,1)/WTRA(1,2,1)
          BANA  =BETFUN+X0**2./BETFUN
          BPANA =2.*X0/BETFUN
          BANAC =BANA/(1.+TANPHI**2)
          BPANAC=BPANA/(1+TANPHI**2)+2.*BANA*TANPHI/(1.+TANPHI**2)
     &      *RI/(1+TANPHI**2)
          IF (BETAPH.EQ.-9999.) THEN
            BETAPH=BPANAC
          ELSE IF (BETAPH.EQ.9999.) THEN
            BETAPH=BPANA
          ENDIF
        ENDIF
      endif ! betfun.ne.-9999.

      IF (betfunv.ne.-9999.0d0) THEN
        IF (ABS(BETAV).EQ.9999.) THEN
          IF (BETFUNV.EQ.0.0) BETFUNV=1.0D0
          BETAV =BETFUNV+X0**2./BETFUNV
        ENDIF

        IF (ABS(BETAPV).EQ.9999.) THEN
          IF (BETFUNV.EQ.0.0) BETFUNV=1.0D0
          BETAPV =2.*X0/BETFUNV
        ENDIF
      endif

      if (ibunch.ne.0.or.iemit.ne.0) then
        write(lungfo,*)' '
        WRITE(LUNGFO,*)'     Horizontal emittance EPS0H [m-rad]:',EPS0H
        WRITE(LUNGFO,*)'     Vertical emittance EPS0V [m-rad]:  ',EPS0V
        write(lungfo,*)'     Horizontal beta-function BETAH [m]:',betah
        write(lungfo,*)'     Horizontal derivative BETAPH:      ',betaph
        write(lungfo,*)'     Vertical beta-function BETAV [m]:  ',betav
        write(lungfo,*)'     Vertical derivative BETAPV:        ',betapv
        write(lungfo,*)' '
        write(lungfo,*)'     --> Note: These values may differ from that of spectrum calculations!!'
        write(lungfo,*)' '
        if (iubunch.eq.1) then
          if (betah.lt.0.1.or.betah.gt.100.) then
            print*,"*** Warning in GFINIT: Strange value of BETAH:",betah
            print*,"*** This can cause program crashes for IUBUNCH=1!"
          endif
          if (betav.lt.0.1.or.betav.gt.100.) then
            print*,"*** Warning in GFINIT: Strange value of BETAH:",betah
            print*,"*** This can cause program crashes for IUBUNCH=1!"
          endif
          write(lungfo,*)' '
        endif
      endif

      IF (IWSECTMAGS.GT.0) THEN
        CALL SECTMAGS
      ENDIF !IWSECTMAGS

      IF (IMAGSPLN.LT.0
     &    .OR.
     &    ispec.ne.0.and.(ISPECMODE.EQ.3.or.ispecmode.eq.2)) THEN
C DO NOT USE WTRA(1:3,3,I) OR WBXYZ(1:3,I) DUE TO BSHIFT

        ALLOCATE(XAMAG(NCO))
        ALLOCATE(BXAMAG(NCO))
        ALLOCATE(BYAMAG(NCO))
        ALLOCATE(BZAMAG(NCO))
        ALLOCATE(BX2A(NCO))
        ALLOCATE(BY2A(NCO))
        ALLOCATE(BZ2A(NCO))
        IXAMAG_I=1

        DO I=1,NCO
          XAMAG(I)=WTRA(1,1,I)
          CALL MYBFELD
     &      (WTRA(1,1,I),WTRA(2,1,I),WTRA(3,1,I),
     &      BXAMAG(I),BYAMAG(I),BZAMAG(I),AXDUM,AYDUM,AZDUM)
        ENDDO  !NCO

        IF (IMAGSPLN.LT.0.AND.IMAGSPLN.NE.-9999) THEN
          CALL BMAGSPLN
     &      (WTRA(1,1,1),WTRA(2,1,1),WTRA(3,1,1),AXDUM,AYDUM,AZDUM)
        ENDIF

      ENDIF !IMAGSPLN

      CALL MYBFELD(XF0,YF0,ZF0,
     &  BXSTOP,BYSTOP,BZSTOP,
     &  AXSTOP,AYSTOP,AZSTOP)


      IF (IMAGSPLN.EQ.-9999) THEN
        IMAGSPLN=-999
      ELSE IF (IMAGSPLN.LT.0) THEN
        IMAGSPLN=-1111
      ENDIF

      ZP0=VZ0/VX0
      YP0=VY0/VX0

      ZPF0=VZF0/VXF0
      YPF0=VYF0/VXF0

      BETXF0=VXF0/CLIGHT1
      BETYF0=VYF0/CLIGHT1
      BETZF0=VZF0/CLIGHT1

C--- POLARIZATION

      ENEGEV=ENERGV/1.0D9
      BDIPOL=ENEGEV/RDIPOL*1.0D9/CLIGHT1
      BDIPL1G=1./RDIPOL*1.0D9/CLIGHT1
      TAUPOL0=POL2CON1*UMFANG*RDIPOL**2/ENEGEV**5
      TAUPOL01G=POL2CON1*UMFANG*RDIPOL**2/1.**5
      POLFAC=1.0D0+BINT3YA/2.0D0/PI1/BDIPOL**3/RDIPOL
      POLFC1G=1.0D0+BINT3YA/2.0D0/PI1/BDIPL1G**3/RDIPOL
      TAUPOL=TAUPOL0/POLFAC
      POLLEV=(2.*PI1*RDIPOL*BDIPOL**3+BINT3Y)/
     &  (2.*PI1*RDIPOL*BDIPOL**3+BINT3YA)*POL1CON1
      TAUPL1G=TAUPOL01G/POLFC1G
      POLLV1G=(2.*PI1*RDIPOL*BDIPL1G**3+BINT3Y)/
     &  (2.*PI1*RDIPOL*BDIPL1G**3+BINT3YA)*POL1CON1

      CALL EMINP(RDIPOL,BINT3YA,TAUPOL01G,TAUKRIT,EMINPOL)

      BDIPLEP=EMINPOL/RDIPOL*1.0D9/CLIGHT1
      TAUPOL0EP=POL2CON1*UMFANG*RDIPOL**2/EMINPOL**5
      POLFCEP=1.0D0+BINT3YA/2.0D0/PI1/BDIPLEP**3/RDIPOL
      TAUPLEP=TAUPOL0EP/POLFCEP
      POLLVEP=(2.*PI1*RDIPOL*BDIPLEP**3+BINT3Y)/
     &  (2.*PI1*RDIPOL*BDIPLEP**3+BINT3YA)*POL1CON1

C--- SIMPLE ESTIMATE OF LINEAR TRANSFER MATRIX

c20180111+self,if=notralinshort.
c      if  (betfun.eq.-9999.or.betfunv.eq.-9999.or.iphellip.ne.0
      if  (iemit.ne.0.or.iphellip.ne.0) then

        if (deltaz.eq.0.0d0)  deltaz=0.0001
        if (deltazp.eq.0.0d0) deltazp=0.0001
        if (deltay.eq.0.0d0)  deltay=0.0001
        if (deltayp.eq.0.0d0) deltayp=0.0001

        write(lungfo,*)
        write(lungfo,*)
     &    '--- Remark: Call of TRALIN triggered and IMAGSPLN=0 due to'
        write(lungfo,*)
     &    '            IEMIT or IPHELLIP'
        write(lungfo,*)

        write(6,*)
        write(6,*)
     &    '--- Remark: Call of TRALIN triggered and IMAGSPLN=0 due to'
        write(6,*)
     &    '            IEMIT or IPHELLIP'
        write(6,*)

        imagspln=0

      endif

c20180111+self.

      IF (
     &    DABS(DELTAZ)+DABS(DELTAZP)+DABS(DELTAY)+DABS(DELTAYP).GT.0.0
     &    D0.OR.IPHELLIP.NE.0.or.betfun.eq.-9999.or.betfunv.eq.-9999.) THEN
c23.3.2022        IF (IRBTAB.NE.0.OR.IRBTABZY.NE.0.OR.IRBTABXYZ.NE.0.OR.IMAGSPLN.NE.0) THEN
        IF (IMAGSPLN.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     *** ERROR IN GFINIT ***'
c23.3.2022          WRITE(LUNGFO,*)'     MAGNETIC FIELD FLAG IMAGSPLN,IRBTAB/IRBTABZY/IRBTABXYZ'
          WRITE(LUNGFO,*)'     MAGNETIC FIELD FLAG IMAGSPLN'
          WRITE(LUNGFO,*)'     NOT COMPATIBLE WITH CALL TO SR TRALIN OR'
          WRITE(LUNGFO,*)'     IPHELLIP.NE.0'
          WRITE(LUNGFO,*)'     SET PARAMETERS IN NAMELIST $TRALINN AND IPHELLIP'
          WRITE(LUNGFO,*)'     TO ZERO OR USE OTHER MAGNETIG FIELD FLAG'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'     *** ERROR IN GFINIT ***'
c23.3.2022          WRITE(6,*)'     MAGNETIC FIELD FLAG IMAGSPLN,IRBTAB/IRBTABZY/IRBTABXYZ'
          WRITE(6,*)'     MAGNETIC FIELD FLAG IMAGSPLN'
          WRITE(6,*)'     NOT COMPATIBLE WITH CALL TO SR TRALIN'
          WRITE(6,*)'     SET PARAMETERS IN NAMELIST $TRALINN AND IPHELLIP'
          WRITE(6,*)'     TO ZERO OR USE OTHER MAGNETIG FIELD FLAG'
          WRITE(6,*)
          STOP '--- Program aborted ---'
        ENDIF
        CALL TRALIN
      ENDIF

C--- WRITE SOME RESULTS

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Number of tracking steps per meter (MYINUM): ',MYINUM
      WRITE(LUNGFO,*)

      IF (XINTER.NE.-9999.) THEN

       WRITE(LUNGFO,*)'     Start of the trajectory given by XINTER:'
       WRITE(LUNGFO,*)'     X [m], Y [m], Z[m]:'
       WRITE(LUNGFO,*)'     ',SNGL(XINTER),SNGL(YSTARTO),SNGL(ZSTARTO)
       WRITE(LUNGFO,*)'     VX, VY , VZ:'
       WRITE(LUNGFO,*)'     ',SNGL(VXINO),SNGL(VYINO),SNGL(VZINO)
       WRITE(LUNGFO,*)

      ENDIF   !(XINTER.NE.-9999.)

      WRITE(LUNGFO,*)'     Start and end of the trajectory [m](XSTART,XSTOP):'
      WRITE(LUNGFO,*)'     ',SNGL(XSTART),SNGL(XSTOP)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     BMOVECUT:',SNGL(BMOVECUT)
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)'     Initial energy [GeV] and gamma: '
     &  ,SNGL(ENEGEV),GAMMA
      WRITE(LUNGFO,*)'     Final energy [GeV] and gamma:   '
     &  ,SNGL(ENEGEV-ENEGEV*GAMMAL/DMYGAMMA),DMYGAMMA-GAMMAL
      WRITE(LUNGFO,*)'     Relative change:                '
     &  ,SNGL((DMYGAMMA-GAMMAL-GAMMA)/DMYGAMMA)
      IF (ieneloss.eq.-1) then
        if (nqfphotons.gt.0) then
          qfmean=qfmean/nqfphotons
          qfrms=sqrt((qfrms/nqfphotons-qfmean**2))
        endif
c qfrms is rms of the energy of the irradiated photons, thus
c qfrms*nqfphotons should be the sqrt(nqfphotons)*qfrms
        WRITE(LUNGFO,*)'     number of photons, RMS (keV) and rel. RMS of quantum fluctuation:'
        WRITE(LUNGFO,*)'     ',
     &    nqfphotons,
     &    sngl(qfrms*1.0d6*sqrt(dble(nqfphotons))),
     &    sngl(qfrms*sqrt(dble(nqfphotons))/dmyenergy)
      endif

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     B-rho [Tm], current [A]: ',SNGL(DBRHO),SNGL(DMYCUR)
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)
     &  '     Offset for vert. and hori. magnetic field (BYGOFF, BZGOFF):'
      WRITE(LUNGFO,*)
     &  '      ',SNGL(BYGOFF),SNGL(BZGOFF)
      WRITE(LUNGFO,*)
     &  '     Global scaling factor for mag. field (B0SCGLOB,A0SCGLOB):'
      WRITE(LUNGFO,*)
     &  '      ',SNGL(B0SCGLOB),SNGL(A0SCGLOB)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Global rel. taper (XTAPER, BTAPERV, BTAPERH):'
      WRITE(LUNGFO,*)
     &  '      ',SNGL(XTAPER),SNGL(BTAPERV),SNGL(BTAPERH)
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)
     &  '     Long. shift [m] of device (X(e-) -> X(e-)+XSHIFT): '
     &  ,SNGL(XSHIFT)
      WRITE(LUNGFO,*)
     &  '     Vert. shift [m] of device (Y(e-) -> Y(e-)+VSHIFT): '
     &  ,SNGL(VSHIFT)
      WRITE(LUNGFO,*)
     &  '     Hori. shift [m] of device (Z(e-) -> Z(e-)+HSHIFT): '
     &  ,SNGL(HSHIFT)
      WRITE(LUNGFO,*)
     &  '     Rotation angle [degree] of device:                 '
     &  ,SNGL(XROTD)
      WRITE(LUNGFO,*)
     &  '     Y(e-) -> Y(e-)*sin(XROTD) + Y(e-)*cos(XROTD)'
      WRITE(LUNGFO,*)
     &  '     Z(e-) -> Z(e-)*cos(XROTD) - Y(e-)*sin(XROTD)'
      WRITE(LUNGFO,*)
      IF (IPERIODG.NE.0) THEN
      WRITE(LUNGFO,*)
     &  '     period length of mag. field (PERIODG):               ',SNGL(PERIODG)
      WRITE(LUNGFO,*)
     &  '     longitudinal x-offset for periodical field (PEROFFG):',SNGL(PEROFFG)
      WRITE(LUNGFO,*)
     &  '     scaling and alternating sign reverse factor (SIGNG):',SNGL(SIGNG)
      WRITE(LUNGFO,*)
     &  '     scaling and alternating sign reverse factor (SIGNG2):',SNGL(SIGNG2)
      WRITE(LUNGFO,*)
      ENDIF

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Magnetic field [T] at starting point:'
      WRITE(LUNGFO,*)'     ',SNGL(BXSTART),SNGL(BYSTART),SNGL(BZSTART)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Vector potential [T-m] at starting point:'
      WRITE(LUNGFO,*)'     ',SNGL(AXSTART),SNGL(AYSTART),SNGL(AZSTART)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Magnetic field [T] at stopping point:'
      WRITE(LUNGFO,*)'     ',SNGL(BXSTOP),SNGL(BYSTOP),SNGL(BZSTOP)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Vector potential [T-m] at stopping point:'
      WRITE(LUNGFO,*)'     ',SNGL(AXSTOP),SNGL(AYSTOP),SNGL(AZSTOP)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Extrema of magnetic field [T] and the trajectory [m]:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     BXmax,BXmin: ',SNGL(BXMX),SNGL(BXMN)
      WRITE(LUNGFO,*)'     BYmax,BYmin: ',SNGL(BYMX),SNGL(BYMN)
      WRITE(LUNGFO,*)'     BZmax,BZmin: ',SNGL(BZMX),SNGL(BZMN)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Xmax,Xmin: ',SNGL(XMX),SNGL(XMN)
      WRITE(LUNGFO,*)'     Ymax,Ymin: ',SNGL(YMX),SNGL(YMN)
      WRITE(LUNGFO,*)'     Zmax,Zmin: ',SNGL(ZMX),SNGL(ZMN)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Extrema of magnetic field [T] and the trajectory [m] between'
      WRITE(LUNGFO,*)
     &  '     XIANF and XIEND'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     BXmaxAE,BXminAE: ',SNGL(BXMXAE),SNGL(BXMNAE)
      WRITE(LUNGFO,*)'     BYmaxAE,BYminAE: ',SNGL(BYMXAE),SNGL(BYMNAE)
      WRITE(LUNGFO,*)'     BZmaxAE,BZminAE: ',SNGL(BZMXAE),SNGL(BZMNAE)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     XmaxAE,XminAE: ',SNGL(XMXAE),SNGL(XMNAE)
      WRITE(LUNGFO,*)'     YmaxAE,YminAE: ',SNGL(YMXAE),SNGL(YMNAE)
      WRITE(LUNGFO,*)'     ZmaxAE,ZminAE: ',SNGL(ZMXAE),SNGL(ZMNAE)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Start values (coordinates [m] and slopes) of trajectory:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     X0: ',X0
      WRITE(LUNGFO,*)'     Y0: ',Y0
      WRITE(LUNGFO,*)'     Z0: ',Z0
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     ZP0:',ZP0
      WRITE(LUNGFO,*)'     YP0:',YP0
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     VX0:',VX0
      WRITE(LUNGFO,*)'     VY0:',VY0
      WRITE(LUNGFO,*)'     VZ0:',VZ0
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Values for X=0 (coordinates [m] and slopes) of trajectory:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     YCEN: ',YCEN
      WRITE(LUNGFO,*)'     ZCEN: ',ZCEN
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     YPCEN:',YPCEN
      WRITE(LUNGFO,*)'     ZPCEN:',ZPCEN
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     End values (coordinates [m] and slopes) of trajectory:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     XF0: ',XF0
      WRITE(LUNGFO,*)'     YF0: ',YF0
      WRITE(LUNGFO,*)'     ZF0: ',ZF0
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     ZPF0: ',ZPF0
      WRITE(LUNGFO,*)'     YPF0: ',YPF0
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     VXF0: ',VXF0
      WRITE(LUNGFO,*)'     VYF0: ',VYF0
      WRITE(LUNGFO,*)'     VZF0: ',VZF0
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Values for X=XIANF (coordinates [m] and slopes) of trajectory:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     XIANF: ',XIANF
      WRITE(LUNGFO,*)'     YIANF: ',YIANF
      WRITE(LUNGFO,*)'     ZIANF: ',ZIANF
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     YPIANF:',YPIANF
      WRITE(LUNGFO,*)'     ZPIANF:',ZPIANF
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Values for X=XIEND (coordinates [m] and slopes) of trajectory:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     XIEND: ',XIEND
      WRITE(LUNGFO,*)'     YIEND: ',YIEND
      WRITE(LUNGFO,*)'     ZIEND: ',ZIEND
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     YPIEND:',YPIEND
      WRITE(LUNGFO,*)'     ZPIEND:',ZPIEND
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

      IF (XSTOP.NE.XSTART) THEN
       WRITE(LUNGFO,*)'     ZF0/(XSTOP-XSTART): ',ZF0/(XSTOP-XSTART)
       WRITE(LUNGFO,*)'     YF0/(XSTOP-XSTART): ',YF0/(XSTOP-XSTART)
      ENDIF

      IF (DABS(Z0-ZF0).GT.1.0D-5) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'     *** WARNING IN GFINIT ***'
         WRITE(LUNGFO,*)'     CLOSED ORBIT OFFSET EXCEEDS 1E-5 METER'
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)
         WRITE(6,*)'     *** WARNING IN GFINIT ***'
         WRITE(6,*)'     CLOSED ORBIT OFFSET EXCEEDS 1E-5 METER'
         WRITE(6,*)'     ZF0-Z0:',ZF0-Z0
         WRITE(6,*)
         WRITE(6,*)
      ENDIF

      IF (DABS(ZP0-ZPF0).GT.1.0D-5) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'     *** WARNING IN GFINIT ***'
         WRITE(LUNGFO,*)'     CLOSED ORBIT KICK EXCEEDS 1E-5 RADIAN'
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)
         WRITE(6,*)'     *** WARNING IN GFINIT ***'
         WRITE(6,*)'     CLOSED ORBIT KICK EXCEEDS 1E-5 RADIAN'
         WRITE(6,*)'     ZPF0-ZP0:',ZPF0-ZP0
         WRITE(6,*)
         WRITE(6,*)
      ENDIF

      IF (DABS(Y0-YF0).GT.1.0D-5) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'     *** WARNING IN GFINIT ***'
         WRITE(LUNGFO,*)'     CLOSED ORBIT OFFSET EXCEEDS 1E-5 METER'
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)
         WRITE(6,*)'     *** WARNING IN GFINIT ***'
         WRITE(6,*)'     CLOSED ORBIT OFFSET EXCEEDS 1E-5 METER'
         WRITE(6,*)'     YF0-Y0:',YF0-Y0
         WRITE(6,*)
         WRITE(6,*)
      ENDIF

      IF (DABS(YP0-YPF0).GT.1.0D-5) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'     *** WARNING IN GFINIT ***'
         WRITE(LUNGFO,*)'     CLOSED ORBIT KICK EXCEEDS 1E-5 RADIAN'
         WRITE(LUNGFO,*)'     YPF0-YP0:',YPF0-YP0
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)
         WRITE(6,*)'     *** WARNING IN GFINIT ***'
         WRITE(6,*)'     CLOSED ORBIT KICK EXCEEDS 1E-5 RADIAN'
         WRITE(6,*)'     YPF0-YP0:',YPF0-YP0
         WRITE(6,*)
         WRITE(6,*)
      ENDIF

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     YF0-Y0:',YF0-Y0
      WRITE(LUNGFO,*)'     ZF0-Z0:',ZF0-Z0
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     YPF0-YP0:',YPF0-YP0
      WRITE(LUNGFO,*)'     ZPF0-ZP0:',ZPF0-ZP0
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)'     Straight line fit of z(x):'
      WRITE(LUNGFO,*)'     offset:', zoffstr
      WRITE(LUNGFO,*)'     slope:', zslopetr
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Straight line fit of vz(x)/vx(x):'
      WRITE(LUNGFO,*)'     offset:', zpoffstr
      WRITE(LUNGFO,*)'     slope:', zpslopetr
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)'     Straight line fit of y(x):'
      WRITE(LUNGFO,*)'     offset:', yoffstr
      WRITE(LUNGFO,*)'     slope:', yslopetr
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Straight line fit of vy(x)/vx(x):'
      WRITE(LUNGFO,*)'     offset:', ypoffstr
      WRITE(LUNGFO,*)'     slope:', ypslopetr

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     1. magnetic integral [T-m]: '
     &  ,SNGL(BINT1X),SNGL(BINT1Y),SNGL(BINT1Z)
      WRITE(LUNGFO,*)'     2. mag. integral [T-m**2]: '
     &  ,SNGL(BINT2X),SNGL(BINT2Y),SNGL(BINT2Z)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Integrated By**2 [T**2-m]:                   '
     &  ,SNGL(B2INTY)
      if (kampli.eq.0) then
        WRITE(LUNGFO,*)
     &    '     Energy irradiated by the device per e- [MeV]:'
     &    ,SNGL(PINT/DMYCUR/1.0d6)
        WRITE(LUNGFO,*)
     &    '     Rel. energy loss:                            '
     &    ,SNGL(PINT/DMYCUR/1.0d9/DMYENERGY)
        WRITE(LUNGFO,*)
     &    '     Power irradiated by the device [kWATT]:      '
     &    ,SNGL(PINT/1000.)
      else
        WRITE(LUNGFO,*)
     &    '     Energy irradiated by the device per e- [MeV]:'
     &    ,SNGL(PINT/DMYCUR/1.0d6*iabs(kampli))
        WRITE(LUNGFO,*)
     &    '     Rel. energy loss:                            '
     &    ,SNGL(PINT/DMYCUR/1.0d9/DMYENERGY*iabs(kampli))
        WRITE(LUNGFO,*)
     &    '     Power irradiated by the device [kWATT]:      '
     &    ,SNGL(PINT/1000.*iabs(kampli))
      endif

      IF (IAMPLI.GT.0) THEN
        WRITE(LUNGFO,*)'     (Option IAMPLI not taken into account!!)'
      ENDIF

      IF (IAMPLI.LT.0) THEN
        WRITE(LUNGFO,*)'     scaled according to IAMPLI:     '
     &    ,SNGL(PINT/1000.*(-IAMPLI))
      ENDIF !IAMPLI

      IF (IAMPLI.lt.0.and.icluster.ne.0) THEN
        write(6,*)"*** Warning in GFINIT: IAMPLI < 0 and ICLUSTER <> 0 may cause problems, be careful ***"
        write(lungfo,*)"*** Warning in GFINIT: IAMPLI < 0 and ICLUSTER <> 0 may cause problems, be careful ***"
      endif

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Length of trajectory (BINT0) [m]:'
      WRITE(LUNGFO,*)
     &  '     ',BINT0
      WRITE(LUNGFO,*)
     &  '     Integrated (YP**2+ZP**2)/2 of trajectory (WTRA2I) [m]:'
      WRITE(LUNGFO,*)
     &  '     ',WTRA2I

      IF (HTRA2I.NE.0.0D0) THEN
        WRITE(LUNGFO,*)
     &    '     corresponding phase advance [nm and eV]:'
        WRITE(LUNGFO,*)
     &    '     ',HTRA2I*1.0D9
     &    ,CLIGHT1*HPLANCK1/ECHARGE1/HTRA2I
      ELSE
        WRITE(LUNGFO,*)
     &    '     corresponding phase advance [nm and eV]:'
        WRITE(LUNGFO,*)
     &    '     ',SNGL(HTRA2I*1.0D9),'    0.000'
      ENDIF

      WRITE(LUNGFO,*)
     &    '     dE/E and corresponding dL = 2 * dE/E * L [nm]:'
      WRITE(LUNGFO,*)
     &  '     ',SNGL(ESPREAD)
     &  ,SNGL(2.0D9*ESPREAD*WTRA2I)

      WRITE(LUNGFO,*)
     &  '     Circumference of the ring [m]:              ',SNGL( UMFANG  )
      WRITE(LUNGFO,*)
     &  '     Rel. change of total circumference (from BINT0):         '
      WRITE(LUNGFO,*)
     &  '     ',SNGL((BINT0+XSTART-XSTOP)/UMFANG  )
      WRITE(LUNGFO,*)
     &  '     Rel. change of total circumference (from WTRA2I):'
      WRITE(LUNGFO,*)
     &  '     ',SNGL(WTRA2I/UMFANG  )
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Max. and min. hori. deflection angle [rad]: '
     &  ,SNGL(PHIMX),SNGL(PHIMN)
      WRITE(LUNGFO,*)'     Max. min., and difference of the hori. deflection angle degree]: '
     &  ,SNGL(PHIMX*radgra1),SNGL(PHIMN*radgra1)
     &  ,SNGL((PHIMX-PHIMN)*radgra1)
      WRITE(LUNGFO,*)

      IF (IBEAMPOL.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     Beam polarization time (time constant) [h]: '
     &    ,SNGL (TAUPOL)
        WRITE(LUNGFO,*)'     Reduction factor due to device:             '
     &    ,SNGL (POLFAC)
        WRITE(LUNGFO,*)'     Final level of beam polarization:           '
     &    ,SNGL (POLLEV)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     Same numbers for a beam energy of 1 GeV:    '
     &    ,SNGL(TAUPL1G)
        WRITE(LUNGFO,*)'                                                 '
     &    ,SNGL(POLFC1G)
        WRITE(LUNGFO,*)'                                                 '
     &    ,SNGL(POLLV1G)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     Critical polarization time (TAUKRIT) and corresponding beam'
        WRITE(LUNGFO,*)
     &    '     energy [GeV], reduction factor, and final polarization level:'
        WRITE(LUNGFO,*)'     '
     &    ,SNGL(TAUKRIT),SNGL(EMINPOL),SNGL(POLFCEP),SNGL(POLLVEP)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     Integrals of By**3, |By|**3 of device and integral of By**3'
        WRITE(LUNGFO,*)'     of ring [T-m**3]:'
     &    ,SNGL(BINT3Y),SNGL(BINT3YA),SNGL(6.283185*RDIPOL*BDIPOL**3)
      ENDIF !IBEAMPOL

      IF (IDISPER.NE.0.OR.IBEAMPOL.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Bending radius of the ring dipoles [m]: '
     &      ,SNGL(RDIPOL)
          WRITE(LUNGFO,*)'     Circumference of the ring [m]:          '
     &      ,SNGL(UMFANG)
          WRITE(LUNGFO,*)
      ENDIF

      IF (IDISPER.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     BETA FUNCTION FOR WLS:      ',SNGL(BETFUN)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     INTEGRAL I2 OF RING:        ',SNGL(DI2RING)
          WRITE(LUNGFO,*)'     INTEGRAL I4 OF RING:        ',SNGL(DI4RING)
          WRITE(LUNGFO,*)'     INTEGRAL I5 OF RING:        ',SNGL(DI5RING)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
      ENDIF

C--- ADJUST SOMETHING

      IF (IJUST.NE.0) THEN !SEE ABOVE
         XJUST=HSHIFT
         YJUST=ZF0
         WRITE(6,*)'HSHIFT, ZF0:', HSHIFT,ZF0
         CALL WLSJUST(XJUST,YJUST)
         IF (IJUST.LE.3) THEN
            IABEND=2
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     HSHIFT ADJUSTED'
            WRITE(LUNGFO,*)
            RETURN
         ENDIF
      ENDIF

C--- HBOOK

      IF (IHBOOK.NE.0) CALL HISINI

C--- WRITE B-FIELD TO FILE

      IF (IWBTAB.NE.0) CALL WBTAB

C--- WRITE B-FIELD TO MAP FILE

      IF (IWBMAP.NE.0) CALL WBMAP

C--- CALCULATE 3D POLYNOMIAL-COEFFICIENTS OF B-FIELD AND EXIT

      IF (IWBPOLY3D.NE.0) THEN
          CALL BPOLY3DFIT
          IABEND=3
          goto 9999
      ENDIF

C--- CALCULATE 3D POLYNOMIAL-COEFFICIENTS OF B-FIELD AND EXIT

      IF (IWBPOLY2DH.NE.0) THEN
          CALL BPOLY2DHFIT
          IABEND=3
          goto 9999
      ENDIF

      IF (IWBPHARM.NE.0) THEN
          CALL BPHARMFIT
          IABEND=3
          goto 9999
      ENDIF

      IF (IHTRACK.NE.0) CALL HTRACK

      if (icluster.ne.0.and.ispecmode.eq.3) then
        PRINT *,
     &      '*** Warning in GFINIT: ICLUSTER .NE. 0 but ISPECMODE=3 ***'
        print*,"*** BE CAREFUL ***"
      endif

      if (icluster.ne.0.and.ispecmode.eq.3) then
        PRINT *,
     &      '*** Warning in GFINIT: ICLUSTER .NE. 0 but ISPECMODE=3 ***'
        print*,"*** BE CAREFUL ***"
      endif

      if (iemit.ne.0.or.ibunch.ne.0) imagspln=0

c      if (phrxbeta.eq.-9999.0d0) xbetfun=xstart

      if (phrxbeta.eq.9999.0d0) then
        phrxbeta=xstart
      else if (phrxbeta.eq.-9999.0d0) then
        phrxbeta=xbetfun
      endif

      if (phrbunlen.eq.9999.0d0) then
        phrbunlen=bunchlen
      endif

      if (phrbunlen.eq.-9999.0d0) then
        phrbunlen=ampbunchlen
      endif

      if (phrbetah.eq.9999.0d0) then
        phrbetah=betah
      else if (phrbetah.eq.-9999.0d0) then
        phrbetah=bsigz(1)/bsigzp(1)
      endif

      if (phralphah.eq.9999.0d0) then
        phralphah=-betaph/2.0d0
      endif

      if (phrdisph.eq.9999.0d0) then
        phrdisph=disp0
      endif

      if (phrdispph.eq.9999.0d0) then
        phrdispph=ddisp0
      endif

      if (phrbetav.eq.9999.0d0) then
        phrbetav=betav
      else if (phrbetav.eq.-9999.0d0) then
        phrbetav=bsigy(1)/bsigyp(1)
      endif

      if (phralphav.eq.9999.0d0) then
        phralphav=-betapv/2.0d0
      endif

      if (phremith.eq.9999.0d0) then
        phremith=eps0h
      endif

      if (phremitv.eq.9999.0d0) then
        phremitv=eps0v
      endif

      if (phrespread.eq.9999.0d0) then
        phrespread=delgam
      endif

      if (phrespread.eq.-9999.0d0) then
        phrespread=espread
      endif

      if (phremith.eq.9999.0d0) then
        phremith=eps0h
      endif

      if (phremith.eq.-9999.0d0) then
        phremith=bsigz(1)*bsigzp(1)
        phralphah=0.0d0
      endif

      if (phremitv.eq.-9999.0d0) then
        phremitv=bsigy(1)*bsigyp(1)
        phralphav=0.0d0
      endif

      if (phrbetah.eq.-9999.0d0) then
        phrbetah=bsigz(1)**2/phremith
        phralphah=0.0d0
      endif

      if (phrbetav.eq.-9999.0d0) then
        phrbetav=bsigy(1)**2/phremitv
        phralphav=0.0d0
      endif

      return

9999  iroottrees=0

      return
      END
+DECK,GRADWLS.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.15/00 12/05/2010  13.34.28  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.51.58  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.24  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE GRADWLS
+seq,gplhint.

C--- CALCULATE TRANSVERSAL GRADIENT 2n(s)/rho**3=(dB/B/ds) *dz/dx/B/rho**2
C    GRADIENT IS ONLY CORRECT IF THE COORDINATE ALONG THE TRAJECTORY
C    CAN BE APPROXIMATED BY THE LONGITUDINAL COORDINATE X
c**********************************************************
C     TO MAKE SURE THAT THE ROUTINE WORKS RELIABLE, THE GRADIENT MUST
C       NOT BE TO LARGE I.E. NO STRONG EDGE FOCUSSING LIKE IN HARD-EDGE
C     MAGNETS. THEREFORE THIS ROUTINE SHOULD BE CALLED AFTER OR BY
C     SR BETAWLS, BECAUSE BETAWLS DETECTS PATHOLOGICAL CASES
c**********************************************************
      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,BETAWLS.
+SEQ,PHYCON.

      INTEGER IPOI,IP,IM,I0
      DOUBLE PRECISION BX,BY0,BZ,BYP,BYM,AX,AY,AZ,XP,XM,X0,DXP0,DXM0
      DOUBLE PRECISION DBCUT,RHO2I,BRHO2I,DBDX,DBDXP,DBDXM

      DATA DBCUT/10000./   !ALLOWED CHANGE IN dB WITHIN DXD

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*) '*** SR GRADWLS ***'
      WRITE(LUNGFO,*) 'BE AWARE THAT YOUR WLS HAS NO STRONG EDGE-FOCUSSING!'
      WRITE(LUNGFO,*) 'OTHERWISE RESULTS ARE NOT RELIABLE'
      WRITE(LUNGFO,*)

C--- LOOP OVER ALL POINTS MBETA

      DO IPOI=1,MBETA

      IF (IPOI.EQ.1) THEN
          I0=1
          IP=2
          IM=2
      ELSEIF(IPOI.EQ.MBETA) THEN
          I0=MBETA
          IP=I0-1
          IM=I0-1
      ELSE
          I0=IPOI
          IP=IPOI+1
          IM=IPOI-1
      ENDIF

      X0=XBETA(I0)
      XP=X0+(XBETA(IP)-X0)*0.5
      XM=X0+(XBETA(IM)-X0)*0.5
      DXP0=XP-X0
      DXM0=XM-X0

      CALL MYBFELD(XP,0.D0,0.D0,BX,BYP,BZ,AX,AY,AZ)   !FIELD OF WLS
      CALL MYBFELD(X0,0.D0,0.D0,BX,BY0,BZ,AX,AY,AZ)   !FIELD OF WLS
      CALL MYBFELD(XM,0.D0,0.D0,BX,BYM,BZ,AX,AY,AZ)   !FIELD OF WLS

      DBDXP=(BYP-BY0)/DXP0
      DBDXM=(BYM-BY0)/DXM0
      DBDX=0.5*(DBDXP+DBDXM)

      RHO2I=(CLIGHT1*BY0/EMOM)**2 !ACTUEL INVERSE BENDING-RADIUS
      BRHO2I=0.
      IF(RHO2I.NE.0) BRHO2I=RHO2I/BY0

      IF(DABS(BRHO2I).GT.DBCUT) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** SR GRADWLS: ERROR ***'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'FIELD GRADIENT/RHO**3 EXCEEDS CUT!'
          WRITE(LUNGFO,*)'RHO/B*dB/dZ * dZ/dX / RHO**3:',BRHO2I
          WRITE(LUNGFO,*)'CUT:',DBCUT
          WRITE(LUNGFO,*)
      ENDIF

      G4BETA(IPOI)=2.*BRHO2I*DBDX*ZBETAP(IPOI)
C6.4.92 GROSS K=-k+1/rho**2 soll berechnet werden
      BETAK(IPOI)=-DBDX/EMOM*CLIGHT1*ZBETAP(IPOI)+RHO2I

      ENDDO

      RETURN
      END
+DECK,H2.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.33/09 09/05/2001  16.51.33  by  Michael Scheer
*CMZ :  2.33/00 02/05/2001  14.43.10  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  2.00/00 15/12/98  10.35.46  by  Michael Scheer
*CMZ : 00.02/02 15/01/97  15.18.41  by  Michael Scheer
*CMZ : 00.00/07 18/05/94  14.54.15  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.54.12  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.24  by  Michael Scheer
*-- Author : Michael Scheer
      DOUBLE PRECISION FUNCTION H2(Y)
+seq,gplhint.

C--- FUNCTION H2(Y)

      IMPLICIT NONE

      DOUBLE PRECISION Y,XI,BK23,DBSKR3

      IF (Y.EQ.0.D0) THEN
          WRITE(6,*)'     E/Ec is zero in function H2'
          STOP '--- PROGRAM WAVE ABORTED ---'
      ENDIF

       XI=Y/2.D0
       BK23=DBSKR3(XI,2)
       H2=(Y*BK23)**2

      RETURN
      END
+DECK,HBETA.
*CMZ :  4.00/14 30/12/2021  15.41.22  by  Michael Scheer
*CMZ :  4.00/13 07/12/2021  18.47.10  by  Michael Scheer
*CMZ :  3.03/02 14/01/2016  16.34.05  by  Michael Scheer
*CMZ :  3.00/01 02/04/2013  14.03.46  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.09.17  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.68/05 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.68/02 03/07/2012  15.35.20  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  10.38.43  by  Michael Scheer
*CMZ :  2.66/07 25/06/2010  12.15.46  by  Michael Scheer
*CMZ :  2.16/08 23/10/2009  09.19.41  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  18.05.51  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.33  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE HBETA
+seq,gplhint.

+SEQ,TRACKF90U,IF=F90.
+SEQ,WBETAF90U,IF=F90.

C--- HISTOGRAMS FOR OPTICAL FUNCTIONS

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,whbook.
+seq,pawcmn.

+SEQ,TRACK.
+SEQ,DEPOLA.
+seq,wbetaf90.
+SEQ,PHYCON.

      REAL*8 BETH,BETPH,BETV,BETPV,ETA
      REAL*8 TANPHI,BANA,BANAC,BPANA,BPANAC,RI,BY

      real x,XI,XE
      real*8 xid,xed,xd,dxd
      INTEGER I,nbin,icycle,k

      XId=WBETA(1,1)-DS0/2.
      XEd=WBETA(1,NCO)+DS0/2.
      XI=xid
      XE=xed

      nbin=nco/ihtrsmp
      call hbook1m(IDBETAH-1 ,'hits in beta histos',nbin,XI,XE,VMX)

      call hbook1m(IDBETAH ,'HOR. BETA-FUNCTION',nbin,XI,XE,VMX)
      call hbook1m(IDBETHPC,'HOR. BETA-FUNCTION, ANALYTICALLY',nbin,XI,XE,VMX)
      call hbook1m(IDBETHP, 'HOR. BETA-FUNCTION, PARABOLIC ANSATZ',nbin,XI,XE,VMX)

      call hbook1m(IDBETAPH,'DERIV. OF HOR. BETA-FUNCTION',nbin,XI,XE,VMX)
      call hbook1m(IDBPHPC, 'DERIV. OF HOR. BETA-FUNCTION, ANA.',nbin,XI,XE,VMX)
      call hbook1m(IDBPHP,  'DERIV. OF HOR. BETA-FUNCTION, PARAB.',nbin,XI,XE,VMX)

      call hbook1m(IDBETAV ,'VERT. BETA-FUNCTION',nbin,XI,XE,VMX)
      call hbook1m(IDBETAPV,'DERIV. OF VERT. BETA-FUNCTION',nbin,XI,XE,VMX)
      call hbook1m(IDETA   ,'DISPERSION',nbin,XI,XE,VMX)

      dxd=(xed-xid)/nbin

      xd=xid+ds0/2.-dxd
      do i=1,nbin
        xd=xd+dxd
        do k=1,nco-1
          if (xd.ge.wbeta(1,k).and.xd.lt.wbeta(1,k+1)) then
            goto 9
          endif
        enddo
9       continue

        BETH =wbeta(2,k)
        BETPH=wbeta(3,k)
        BETV =wbeta(4,k)
        BETPV=wbeta(5,k)
        ETA  =wbeta(6,k)

        BY    =wtra(2,3,k)
        RI    =CLIGHT1*BY/EMOM
        TANPHI=WTRA(3,2,k)/WTRA(1,2,k)
        BANA  =BETFUN+X**2./BETFUN
        BPANA =2.*X/BETFUN
        BANAC =BANA/(1.+TANPHI**2)
        BPANAC=BPANA/(1+TANPHI**2)+2.*BANA*TANPHI/(1.+TANPHI**2)
     &    *RI/(1+TANPHI**2)

        x=xd

        CALL hfillm(IDBETAH-1, X,0.,1.0d0)
        CALL hfillm(IDBETAH, X,0.,BETH)
        CALL hfillm(IDBETHPC,X,0.,BANAC)
        CALL hfillm(IDBETHP ,X,0.,BANA)

        CALL hfillm(IDBETAPH,X,0.,BETPH)
        CALL hfillm(IDBPHPC ,X,0.,BPANAC)
        CALL hfillm(IDBPHP  ,X,0.,BPANA)

        CALL hfillm(IDBETAV,X,0.,BETV)
        CALL hfillm(IDBETAPV,X,0.,BETPV)
        CALL hfillm(IDETA,X,0.,ETA)

      enddo
+self,if=oldhbeta.
      DO I=1,NCO,ihtrsmp

          X    =WBETA(1,I)
          BETH =WBETA(2,I)
          BETPH=WBETA(3,I)
          BETV =WBETA(4,I)
          BETPV=WBETA(5,I)
          ETA  =WBETA(6,I)

          BY    =WTRA(2,3,I)
          RI    =CLIGHT1*BY/EMOM
          TANPHI=WTRA(3,2,I)/WTRA(1,2,I)
          BANA  =BETFUN+X**2./BETFUN
          BPANA =2.*X/BETFUN
          BANAC =BANA/(1.+TANPHI**2)
          BPANAC=BPANA/(1+TANPHI**2)+2.*BANA*TANPHI/(1.+TANPHI**2)
     &            *RI/(1+TANPHI**2)

          CALL hfillm(IDBETAH-1, X,0.,1.0d0)
          CALL hfillm(IDBETAH, X,0.,BETH)
          CALL hfillm(IDBETHPC,X,0.,BANAC)
          CALL hfillm(IDBETHP ,X,0.,BANA)

          CALL hfillm(IDBETAPH,X,0.,BETPH)
          CALL hfillm(IDBPHPC ,X,0.,BPANAC)
          CALL hfillm(IDBPHP  ,X,0.,BPANA)

          CALL hfillm(IDBETAV,X,0.,BETV)
          CALL hfillm(IDBETAPV,X,0.,BETPV)
          CALL hfillm(IDETA,X,0.,ETA)

      ENDDO

+self.,if=oldhbeta.

      call hoperam(idbetah,'/',idbetah-1,idbetah,1.,1.)
      call hoperam(idbethpc,'/',idbetah-1,idbethpc,1.,1.)
      call hoperam(idbethp,'/',idbetah-1,idbethp,1.,1.)
      call hoperam(idbetav,'/',idbetah-1,idbetav,1.,1.)
      call hoperam(idbetapv,'/',idbetah-1,idbetapv,1.,1.)
      call hoperam(ideta,'/',idbetah-1,ideta,1.,1.)

      call mhrout(idbetah-1,icycle,' ')
      call mhrout(idbetah,icycle,' ')
      call mhrout(idbethpc,icycle,' ')
      call mhrout(idbethp,icycle,' ')
      call mhrout(idbetav,icycle,' ')
      call mhrout(idbetapv,icycle,' ')
      call mhrout(ideta,icycle,' ')

      call hdeletm(idbetah-1)
      call hdeletm(idbetah)
      call hdeletm(idbethpc)
      call hdeletm(idbethp)
      call hdeletm(idbetav)
      call hdeletm(idbetapv)
      call hdeletm(ideta)

      RETURN
      END
+DECK,HFOLD.
*CMZ :  4.00/14 30/12/2021  15.41.22  by  Michael Scheer
*CMZ :  4.00/13 07/12/2021  14.43.50  by  Michael Scheer
*CMZ :  3.03/01 07/10/2015  14.45.17  by  Michael Scheer
*CMZ :  3.02/06 24/04/2015  16.46.36  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.68/05 28/09/2012  09.24.47  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  10.38.43  by  Michael Scheer
*CMZ :  2.57/01 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.51/02 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.51/00 26/05/2004  15.48.35  by  Michael Scheer
*CMZ :  2.47/09 27/05/2003  15.50.51  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  16.27.20  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.35  by  Michael Scheer
*CMZ :  2.13/03 15/12/99  15.12.32  by  Michael Scheer
*CMZ :  2.13/02 14/12/99  16.33.52  by  Michael Scheer
*CMZ :  1.00/00 24/09/97  10.31.28  by  Michael Scheer
*CMZ : 00.02/00 11/12/96  14.52.22  by  Michael Scheer
*CMZ : 00.01/12 16/10/96  15.22.18  by  Michael Scheer
*CMZ : 00.01/06 13/02/95  14.10.51  by  Michael Scheer
*CMZ : 00.01/04 30/01/95  14.13.04  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  16.53.40  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.52.27  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.49  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE HFOLD
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,WFOLDF90U.

C--- STORE RESULTS OF SPECTRUM CALCULATION ON HISTOGRAM FILE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,COLLI.
+seq,whbook.
+seq,pawcmn.
+SEq,wfoldf90.
+SEQ,PHYCON.

      INTEGER IOB,ISOUR
      INTEGER IFO,IFOUR,ICYCLE

      DOUBLE PRECISION X

      DOUBLE PRECISION XFOLD,YFOLD,DXFOLD

      DOUBLE PRECISION FOUFUNX

      IF (NSOURCE.GE.10) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING SR HFOLD ***'
        WRITE(LUNGFO,*)'TOO MANY SOURCE POINTS'
        WRITE(LUNGFO,*)'HISTOGRAM IDENTIFIER WILL OVERLAP'
        WRITE(LUNGFO,*)'BE CAREFUL OR USE CORRESPONDING NTUPLE!!'
        WRITE(LUNGFO,*)
        WRITE(6,*)'*** WARNING SR HFOLD ***'
      ENDIF

C--- SCAN OBSERVATION POINTS

      X=OBSV(1,1)
      DO IOB=1,NOBSV
        IF(OBSV(1,IOB).NE.X) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN HFOLD ***'
          WRITE(LUNGFO,*)
     &      'X-POSITION OF OBSERVATION POINTS NOT IDENTICAL'
          WRITE(6,*)'*** ERROR IN HFOLD ***'
          WRITE(6,*)
     &      'X-POSITION OF OBSERVATION POINTS NOT IDENTICAL'
          STOP
        ENDIF
      ENDDO !IOB

C--- FOLDING FUNCTION

      DO ISOUR=1,NSOURCE

        call hbook1m(IDFOLFNY+ISOUR*100,'VERTICAL FOLDING FUNCTION'
     &    ,1000,-SNGL(DSIGY(ISOUR)),SNGL(DSIGY(ISOUR)),VMX)

        IF(IF1DIM.EQ.0) THEN

          call hbook1m(IDFOLFNZ+ISOUR*100,'HORIZONTAL FOLDING FUNCTION'
     &      ,1000,-SNGL(DSIGZ(ISOUR)),SNGL(DSIGZ(ISOUR)),VMX)

          DXFOLD=2.*DSIGZ(ISOUR)/1000.
          XFOLD=-DSIGZ(ISOUR)-DXFOLD/2.

          DO IFO=1,1000

            XFOLD=XFOLD+DXFOLD

            IF (IUSEM.EQ.0.AND.IPIN.NE.2) THEN

              IF (IFOLD.EQ.-1.OR.IFOLD.EQ.-2) THEN
                YFOLD=GCOEFH(1,ISOUR)
                DO IFOUR=2,NGFOURZ
                  YFOLD=YFOLD+GCOEFH(IFOUR,ISOUR)
     &              *DCOS(XKGAUSS(IFOUR-1,1)*XFOLD)
                ENDDO !IFOUR
              ELSE
                YFOLD=1.0D0/SQRT(2.0D0*PI1)/WSIGZ(ISOUR)*
     &            EXP(-(XFOLD/WSIGZ(ISOUR))**2/2.0D0)
              ENDIF !IFOLD

            ELSE  !IUSEM
              YFOLD=FOUFUNX(XFOLD,WSIGZ(ISOUR))
            ENDIF !IUSEM

            CALL hfillm(IDFOLFNZ+100*ISOUR,SNGL(XFOLD),0.,YFOLD)

          ENDDO   !IFO

        ENDIF !IF1DIM

        DXFOLD=2.*DSIGY(ISOUR)/1000.
        XFOLD=-DSIGY(ISOUR)-DXFOLD/2.

        DO IFO=1,1000
          XFOLD=XFOLD+DXFOLD

          IF (IUSEM.EQ.0.AND.IPIN.NE.2) THEN

            IF (IFOLD.EQ.-1.OR.IFOLD.EQ.-2) THEN
              YFOLD=GCOEFV(1,ISOUR)
              DO IFOUR=2,NGFOURY
                YFOLD=YFOLD+GCOEFV(IFOUR,ISOUR)
     &            *DCOS(YKGAUSS(IFOUR-1,1)*XFOLD)
              ENDDO !IFOUR
            ELSE
              YFOLD=1.0D0/SQRT(2.0D0*PI1)/WSIGY(ISOUR)*
     &          EXP(-(XFOLD/WSIGY(ISOUR))**2/2.0D0)
            ENDIF !IFOLD

          ELSE  !IUSEM
            YFOLD=FOUFUNX(XFOLD,WSIGY(ISOUR))
          ENDIF !IUSEM

          CALL hfillm(IDFOLFNY+100*ISOUR,SNGL(XFOLD),0.,YFOLD)

        ENDDO   !IFO

        if (if1dim.eq.0) then
          CALL MHROUT(IDFOLFNZ+100*ISOUR,ICYCLE,' ')
          CALL hdeletm(IDFOLFNZ+100*ISOUR)
        endif

        CALL MHROUT(IDFOLFNY+100*ISOUR,ICYCLE,' ')
        CALL hdeletm(IDFOLFNY+100*ISOUR)

      ENDDO   !ISOUR

      RETURN
      END
+DECK,HFREQ.
*CMZ :  4.01/07 29/10/2024  16.01.45  by  Michael Scheer
*CMZ :  4.01/05 11/03/2024  13.30.35  by  Michael Scheer
*CMZ :  4.01/04 15/11/2023  18.07.40  by  Michael Scheer
*CMZ :  4.01/03 10/06/2023  15.52.02  by  Michael Scheer
*CMZ :  4.01/00 08/01/2023  10.16.47  by  Michael Scheer
*CMZ :  4.00/17 04/10/2022  08.10.22  by  Michael Scheer
*CMZ :  4.00/15 07/04/2022  07.14.03  by  Michael Scheer
*CMZ :  4.00/14 30/12/2021  15.41.22  by  Michael Scheer
*CMZ :  4.00/13 07/12/2021  18.47.10  by  Michael Scheer
*CMZ :  4.00/11 11/06/2021  11.00.05  by  Michael Scheer
*CMZ :  4.00/04 23/08/2019  15.58.25  by  Michael Scheer
*CMZ :  4.00/02 12/04/2019  18.39.49  by  Michael Scheer
*CMZ :  3.04/01 03/04/2018  14.26.06  by  Michael Scheer
*CMZ :  3.03/02 18/04/2016  15.26.59  by  Michael Scheer
*CMZ :  3.03/00 20/08/2015  15.24.19  by  Michael Scheer
*CMZ :  3.02/09 09/07/2015  17.12.40  by  Michael Scheer
*CMZ :  3.02/08 25/06/2015  12.41.28  by  Michael Scheer
*CMZ :  3.02/07 24/06/2015  12.40.15  by  Michael Scheer
*CMZ :  3.02/04 12/12/2014  16.56.09  by  Michael Scheer
*CMZ :  3.02/03 04/11/2014  12.49.47  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  09.14.50  by  Michael Scheer
*CMZ :  3.01/05 12/06/2014  08.52.10  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.13.36  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  15.34.39  by  Michael Scheer
*CMZ :  2.70/00 11/12/2012  10.58.11  by  Michael Scheer
*CMZ :  2.69/00 24/10/2012  16.35.22  by  Michael Scheer
*CMZ :  2.68/05 28/09/2012  13.18.55  by  Michael Scheer
*CMZ :  2.68/01 29/05/2012  13.43.27  by  Michael Scheer
*CMZ :  2.67/02 26/04/2012  14.57.31  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  14.11.28  by  Michael Scheer
*CMZ :  2.66/19 16/12/2010  12.57.57  by  Michael Scheer
*CMZ :  2.66/18 16/12/2010  12.52.11  by  Michael Scheer
*CMZ :  2.66/14 09/11/2010  15.39.16  by  Michael Scheer
*CMZ :  2.66/07 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.66/03 27/11/2009  15.57.31  by  Michael Scheer
*CMZ :  2.66/02 26/10/2009  09.28.27  by  Michael Scheer
*CMZ :  2.65/02 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  2.64/01 14/09/2009  15.19.42  by  Michael Scheer
*CMZ :  2.61/03 27/03/2007  13.10.16  by  Michael Scheer
*CMZ :  2.61/01 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.56/00 17/10/2005  12.42.20  by  Michael Scheer
*CMZ :  2.55/00 07/07/2005  16.35.20  by  Michael Scheer
*CMZ :  2.53/04 28/01/2005  12.42.15  by  Michael Scheer
*CMZ :  2.53/03 26/01/2005  15.02.46  by  Michael Scheer
*CMZ :  2.53/02 25/01/2005  16.49.46  by  Michael Scheer
*CMZ :  2.52/16 21/01/2005  13.34.39  by  Michael Scheer
*CMZ :  2.52/13 09/12/2004  11.06.01  by  Michael Scheer
*CMZ :  2.52/00 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.49/00 22/03/2004  09.56.01  by  Michael Scheer
*CMZ :  2.48/04 17/03/2004  10.57.53  by  Michael Scheer
*CMZ :  2.47/08 20/05/2003  14.46.41  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.41/07 13/06/2002  15.05.28  by  Michael Scheer
*CMZ :  2.41/00 20/03/2002  14.37.14  by  Michael Scheer
*CMZ :  2.36/01 08/11/2001  17.30.36  by  Michael Scheer
*CMZ :  2.33/06 04/05/2001  11.44.17  by  Michael Scheer
*CMZ :  2.33/05 04/05/2001  11.42.26  by  Michael Scheer
*CMZ :  2.20/10 04/04/2001  12.21.46  by  Michael Scheer
*CMZ :  2.20/09 23/03/2001  18.26.22  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  17.29.35  by  Michael Scheer
*CMZ :  2.16/07 01/09/2000  14.32.32  by  Michael Scheer
*CMZ :  2.16/06 30/08/2000  13.48.49  by  Michael Scheer
*CMZ :  2.16/05 04/08/2000  12.09.00  by  Michael Scheer
*CMZ :  2.16/04 28/06/2000  17.39.06  by  Michael Scheer
*CMZ :  2.16/01 15/06/2000  15.45.22  by  Michael Scheer
*CMZ :  2.15/00 11/05/2000  10.25.20  by  Michael Scheer
*CMZ :  2.13/07 17/02/2000  15.11.12  by  Michael Scheer
*CMZ :  2.13/03 12/01/2000  16.33.49  by  Michael Scheer
*CMZ :  2.13/00 02/12/99  13.24.15  by  Michael Scheer
*CMZ :  2.10/01 25/02/99  14.18.30  by  Michael Scheer
*CMZ :  1.03/06 23/09/98  17.07.41  by  Michael Scheer
*CMZ :  1.03/00 16/01/98  11.16.48  by  Michael Scheer
*CMZ :  1.00/00 24/09/97  10.31.27  by  Michael Scheer
*CMZ : 00.02/03 16/01/97  11.48.11  by  Michael Scheer
*CMZ : 00.02/02 10/01/97  16.50.11  by  Michael Scheer
*CMZ : 00.01/12 15/10/96  10.36.48  by  Michael Scheer
*CMZ : 00.01/06 14/02/95  10.54.13  by  Michael Scheer
*CMZ : 00.01/04 30/01/95  13.06.50  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  16.43.29  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.52.08  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.39  by  Michael Scheer
*-- Author :  Michael Scheer
      SUBROUTINE HFREQ
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.

      use clustermod

C--- HISTOGRAMS FOR SPECTRA OF SINGLE OBSERVATION POINTS OR PINHOLE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,whbook.
+seq,pawcmn.

+SEQ,SPECT.
+SEQ,FREQS.
+SEq,observf90.
+seq,sourcef90.
+SEQ,SPECDIP.
+SEq,phasef90.
+SEQ,AMPLI.
+SEQ,MYFILES.
+SEQ,PHYCON.
+seq,debugwave.

      INTEGER ID,IOBSV,ifrq,ISOUR,IOBSVY,IOBSVZ,NDIMPH,IOBSVR,IOBSVPHI
      INTEGER ICYCLE,MFREQ,I,ISTAT,I47,jsource

      COMPLEX*16 e(3),b(3)
      DOUBLE PRECISION WEIGHT,smax,reanor,rn(3),
     &  dist,dist0,ddist,h2,censoux,censouy,censouz,dphase,wlen,waves

      REAL*4 FLOW,FHIG,DF

      CHARACTER(80) TIT
      CHARACTER(4) CHTAGS(5)
      CHARACTER(5) CHTAGSF(36)
      CHARACTER(5) CHTAGSFd(36)
      CHARACTER(4) CHSPEC(34)
      CHARACTER(4) CHSPECRPHI(33)
      CHARACTER(4) CHPOW(8)
      CHARACTER(4) CHPOWF(9)
      CHARACTER(4) CHPOWV(5)
      CHARACTER(4) CHSPECF(18)
      CHARACTER(4) CHSTOK(12)
      CHARACTER(4) CHBRILL(17)
      CHARACTER(128) FILE47
      CHARACTER(8) OLDDIR

      INTEGER ND

      REAL*8 FSTUPLE(100),FSPEC(34)
      real*8 , dimension(:), allocatable :: phfill

      data chtags/'x','y','z','ener','spec'/

      data chtagsf/'iene','ener','flux','fluxf'
     &  ,'s0','s1','s2','s3'
     &  ,'s0f','s1f','s2f','s3f'
     &  ,'s0e','s1e','s2e','s3e'
     &  ,'s0ef','s1ef','s2ef','s3ef'
     &  ,'b0','b1','b2','b3'
     &  ,'b0f','b1f','b2f','b3f'
     &  ,'b0e','b1e','b2e','b3e'
     &  ,'b0ef','b1ef','b2ef','b3ef' /

      data chtagsfd/'iene','ener','fldn','fldnf'
     &  ,'s0','s1','s2','s3'
     &  ,'s0f','s1f','s2f','s3f'
     &  ,'s0e','s1e','s2e','s3e'
     &  ,'s0ef','s1ef','s2ef','s3ef'
     &  ,'b0','b1','b2','b3'
     &  ,'b0f','b1f','b2f','b3f'
     &  ,'b0e','b1e','b2e','b3e'
     &  ,'b0ef','b1ef','b2ef','b3ef' /

      data chspec/'isou','iobs','x','y','z','ener','spec'
     &  ,'iz','iy','iene',
     &  're_x','im_x','re_y','im_y','re_z','im_z','rf_y','if_y','rf_z','if_z',
     &  'rb_x','ib_x','rb_y','ib_y','rb_z','ib_z','rbfy','ibfy','rbfz','ibfz',
     &  'phi0','nx','ny','nz'
     &  /
      data chspecrphi/'isou','iobs','x','y','z','r','phi','ener','spec'
     &  ,'ir','iphi','iene',
     &  're_x','im_x','re_y','im_y','re_z','im_z','rf_y','if_y','rf_z','if_z',
     &  'rs_x','is_x','rs_y','is_y','rs_z','is_z','rsfy','isfy','rsfz','isfz',
     &  'phi0'
     &  /
      data chbrill/'ener','b0','b1','b2','b3','b0f','b1f','b2f','b3f',
     &  'b0e','b1e','b2e','b3e','b0ef','b1ef','b2ef','b3ef'/

      data chpow/'x','y','z','pow','iz','iy','iobs','isou'/
      data chpowf/'x','y','z','pow','powf','iz','iy','iobs','isou'/

      data chpowv/'x','z','pow','iz','isou'/

      data chspecf/'isou','iobs','x','y','z','ener','spec'
     &  ,'iz','iy','iene',
     &  're_y','im_y','re_z','im_z',
     &  'rs_y','is_y','rs_z','is_z'
     &  /

      data chstok/'iobs','x','y','z','ener','s0','s1','s2','s3'
     &  ,'iz','iy','iene'
     &  /

      NDIMPH=MPHASEZ*MPHASEY
      allocate(PHFILL(NDIMPH))
      phfill=0.0d0

      if (ipin.eq.3) then
        call hfreq3
        if(ibunch.ne.0.and.icluster.gt.0) call wpampntup
        return
      endif

      I47=0

      IF (mhbookp.eq.0.
     &    .and.
     &    IPIN.EQ.1.AND.NOBSV*NFREQ.GT.100000.and.iroottrees.ge.0) THEN

        I47=1

        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN HFREQ: HISTOGRAM FILE PROBABLY TOO SMALL'
        WRITE(6,*)
     & '*** GENERATING SPECIAL HISTOGRAM FILES FOR DISTRIBUTIONS IN PINHOLES'
        WRITE(6,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN HFREQ: HISTOGRAM FILE PROBABLY TOO SMALL'
        WRITE(LUNGFO,*)
     & '*** GENERATING SPECIAL HISTOGRAM FILES FOR DISTRIBUTIONS IN PINHOLES'
        WRITE(LUNGFO,*)

      ENDIF

      IF (IUNIT.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '*** WARNING SR HFREQ: NO HISTOGRAMS ONLY NTUPLES OF SPECTRUM FOR IUNIT.NE.0'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)
     &    '*** WARNING SR HFREQ: NO HISTOGRAMS ONLY NTUPLES OF SPECTRUM FOR IUNIT.NE.0'
        WRITE(6,*)
        GOTO 100
      ENDIF

      IF (ifreq2P.eq.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING SR HFREQ ***'
        WRITE(LUNGFO,*)'PARAMETER ifreq2P=0 , NO HISTOGRAM BOOKED'
        WRITE(LUNGFO,*)
      else IF (ifreq2P.EQ.2) THEN

        DF=FREQ(2)-FREQ(1)
        FLOW=FREQ(1)-DF/2.
        FHIG=FREQ(NFREQ)+DF/2.

        IF (FLOW.LT.0.) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING SR HFREQ ***'
          WRITE(LUNGFO,*)'LOW EDGE OF HISTOGRAM NEGATIVE'
          WRITE(LUNGFO,*)'BE CAREFUL IF X-AXIS IS PLOTTED WITH LOGARITHMIC SCALE'
          WRITE(LUNGFO,*)
        ENDIF

        IF(IPIN.EQ.0) THEN

          DO IOBSV=1,NOBSV

            ID=ICFREQ+IOBSV
            MFREQ=NINT((FHIG-FLOW)/DF)
            call hbook1m(ID,'PHOTON FLUX DENSITY x 1.E-6',
     &        MFREQ,FLOW,FHIG,VMX)

            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          SPECTOT(IOBSV+NOBSV*(ifrq-1))*1.0d-6)
            ENDDO   !NFREQ

            CALL MHROUT(ID,ICYCLE,' ')
            CALL hdeletm(ID)

          IF (IFOLD.EQ.2) THEN
              ID=ICFREQ+1000+IOBSV
              MFREQ=NINT((FHIG-FLOW)/DF)
              call hbook1m(ID,'PHOTON FLUX DENSITY x 1.E-6 (FOLDED)',
     &        MFREQ,FLOW,FHIG,VMX)

              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          SPECTOTF(IOBSV+NOBSV*(ifrq-1))*1.0d-6)
              ENDDO   !NFREQ

              CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

          ENDIF !IFOLDE.EQ.2

          ENDDO !IOBSV

          IF (ISTOKES.NE.0) THEN

            ID=ICFRS0
            call hbook1m(ID,'S0 (sel. obs. point) x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          dble(STOKES(1,1+NOBSV*(ifrq-1))*1.0d-6))
            ENDDO   !NFREQ

            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRS1
            call hbook1m(ID,'S1 (sel. obs. point) x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          dble(STOKES(2,1+NOBSV*(ifrq-1))*1.0d-6))
            ENDDO   !NFREQ

            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRS2
            call hbook1m(ID,'S2 (sel. obs. point) x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          dble(STOKES(3,1+NOBSV*(ifrq-1))*1.0d-6))
            ENDDO   !NFREQ

            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRS3
            call hbook1m(ID,'S3 (sel. obs. point) x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          dble(STOKES(4,1+NOBSV*(ifrq-1))*1.0d-6))
            ENDDO   !NFREQ

            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP
            call hbook1m(ID,'P (sel. obs. point)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=SQRT
     &          ((STOKES(2,IOBFR)/STOKES(1,IOBFR))**2
     &          +(STOKES(3,IOBFR)/STOKES(1,IOBFR))**2
     &         +(STOKES(4,IOBFR)/STOKES(1,IOBFR))**2)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,WEIGHT)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP1
            call hbook1m(ID,'P1 (sel. obs. point)'
     &                    ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=STOKES(2,IOBFR)/STOKES(1,IOBFR)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,WEIGHT)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP2
            call hbook1m(ID,'P2 (sel. obs. point)'
     &                    ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=STOKES(3,IOBFR)/STOKES(1,IOBFR)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,WEIGHT)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP3
            call hbook1m(ID,'P3 (sel. obs. point)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=STOKES(4,IOBFR)/STOKES(1,IOBFR)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,WEIGHT)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP23
            call hbook1m(ID,'P23 (sel. obs. point)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=SQRT((STOKES(3,IOBFR)/STOKES(1,IOBFR))**2
     &          +(STOKES(4,IOBFR)/STOKES(1,IOBFR))**2)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRG3
            call hbook1m(ID,'G3 (sel. obs. point) x 1.E-6 '
     &                    ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=STOKES(4,IOBFR)/STOKES(1,IOBFR)*STOKES(4,IOBFR)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight*1.0d-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRG23
            call hbook1m(ID,'G23 (sel. obs. point) x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=((STOKES(3,IOBFR)/STOKES(1,IOBFR))**2
     &          +(STOKES(4,IOBFR)/STOKES(1,IOBFR))**2)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight*1.0d-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            IF (IEFOLD.NE.0) THEN

              ID=ICFRS0E
              call hbook1m(ID,'S0_E (sel. obs. point) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(WSTOKESE(1,ifrq)*1.0d-6))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRS1E
              call hbook1m(ID,'S1_E (sel. obs. point) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(wstokESE(2,ifrq)*1.0d-6))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRS2E
              call hbook1m(ID,'S2_E (sel. obs. point) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(wstokESE(3,ifrq)*1.0d-6))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRS3E
              call hbook1m(ID,'S3_E (sel. obs. point) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(wstokESE(4,ifrq)*1.0d-6))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRPE
              call hbook1m(ID,'P_E (sel. obs. point)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=SQRT
     &            ((WSTOKESE(2,ifrq)/WSTOKESE(1,ifrq))**2
     &            +(WSTOKESE(3,ifrq)/WSTOKESE(1,ifrq))**2
     &            +(WSTOKESE(4,ifrq)/WSTOKESE(1,ifrq))**2)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP1E
              call hbook1m(ID,'P1_E (sel. obs. point)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(2,ifrq)/WSTOKESE(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP2E
              call hbook1m(ID,'P2_E (sel. obs. point)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(3,ifrq)/WSTOKESE(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP3E
              call hbook1m(ID,'P3_E (sel. obs. point)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(4,ifrq)/WSTOKESE(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP23E
              call hbook1m(ID,'P23_E (sel. obs. point)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=SQRT(
     &            (WSTOKESE(3,ifrq)/WSTOKESE(1,ifrq))**2
     &            +(WSTOKESE(4,ifrq)/WSTOKESE(1,ifrq))**2)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRG3E
              call hbook1m(ID,'G3_E (sel. obs. point) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(4,ifrq)/WSTOKESE(1,ifrq)*WSTOKESE(4,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight*1.0d-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRG23E
              call hbook1m(ID,'G23_E (sel. obs. point) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(3,ifrq)/WSTOKESE(1,ifrq)*WSTOKESE(3,ifrq)
     &            +WSTOKESE(4,ifrq)/WSTOKESE(1,ifrq)*WSTOKESE(4,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight*1.0d-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

            ENDIF !IEFOLD

            IF (IBRILL.NE.0) THEN

              ID=ICFRB0
              call hbook1m(ID,'SELECTED B0 x 1.E-12'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(brillC(1,ifrq)*1.0d-12))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

              ID=ICFRB1
              call hbook1m(ID,'SELECTED B1 x 1.E-12'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(brillC(2,ifrq)*1.0d-12))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

              ID=ICFRB2
              call hbook1m(ID,'SELECTED B2 x 1.E-12'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(brillC(3,ifrq)*1.0d-12))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

              ID=ICFRB3
              call hbook1m(ID,'SELECTED B3 x 1.E-12'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(brillC(4,ifrq)*1.0d-12))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

              IF (IEFOLD.NE.0) THEN

                ID=ICFRB0E
                call hbook1m(ID,'SELECTED B0_E x 1.E-12'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(brillCE(1,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                ID=ICFRB1E
                call hbook1m(ID,'SELECTED B1_E x 1.E-12'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(brillCE(2,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                ID=ICFRB2E
                call hbook1m(ID,'SELECTED B2_E x 1.E-12'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(brillCE(3,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                ID=ICFRB3E
                call hbook1m(ID,'SELECTED B3_E x 1.E-12'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(brillCE(4,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ENDIF !IEFOLD

              IF (IFOLD.EQ.2) THEN

                ID=ICFRB0F
                call hbook1m(ID,'SELECTED B0 x 1.E-12 (FOLDED)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(brillCF(1,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

                ID=ICFRB1F
                call hbook1m(ID,'SELECTED B1 x 1.E-12 (FOLDED)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(brillCF(2,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

                ID=ICFRB2F
                call hbook1m(ID,'SELECTED B2 x 1.E-12 (FOLDED)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(brillCF(3,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

                ID=ICFRB3F
                call hbook1m(ID,'SELECTED B3 x 1.E-12 (FOLDED)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(brillCF(4,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

                IF (IEFOLD.NE.0) THEN

                  ID=ICFRB0EF
                  call hbook1m(ID,'SELECTED B0_E x 1.E-12 (FOLDED)'
     &              ,NFREQ,FLOW,FHIG,VMX)
                  DO ifrq=1,NFREQ,IHFREQ
                    CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &                dble(brillCEF(1,ifrq)*1.0d-12))
                  ENDDO   !NFREQ
                  CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                  ID=ICFRB1EF
                  call hbook1m(ID,'SELECTED B1_E x 1.E-12 (FOLDED)'
     &              ,NFREQ,FLOW,FHIG,VMX)
                  DO ifrq=1,NFREQ,IHFREQ
                    CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &                dble(brillCEF(2,ifrq)*1.0d-12))
                  ENDDO   !NFREQ
                  CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                  ID=ICFRB2EF
                  call hbook1m(ID,'SELECTED B2_E x 1.E-12 (FOLDED)'
     &              ,NFREQ,FLOW,FHIG,VMX)
                  DO ifrq=1,NFREQ,IHFREQ
                    CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &                dble(brillCEF(3,ifrq)*1.0d-12))
                  ENDDO   !NFREQ
                  CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                  ID=ICFRB3EF
                  call hbook1m(ID,'SELECTED B3_E x 1.E-12 (FOLDED)'
     &              ,NFREQ,FLOW,FHIG,VMX)
                  DO ifrq=1,NFREQ,IHFREQ
                    CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &                dble(brillCEF(4,ifrq)*1.0d-12))
                  ENDDO   !NFREQ
                  CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                ENDIF !IEFOLD
              ENDIF !IFOLD.NE.2

            ENDIF !IBRILL

          ENDIF !ISTOKES

        ELSE  !IPIN

          ID=IDFREQ
          MFREQ=NINT((FHIG-FLOW)/DF)
          call hbook1m(ID,'PHOTON FLUX THROUGH PINHOLE',
     &      MFREQ,FLOW,FHIG,VMX)
          DO ifrq=1,NFREQ,IHFREQ
            CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,WFLUXT(ifrq))
          ENDDO   !NFREQ
          CALL MHROUT(ID,ICYCLE,' ')
          call hdeletm(ID)

          IF (IFOLD.NE.0) THEN
            ID=IDFREQF
            MFREQ=NINT((FHIG-FLOW)/DF)
            call hbook1m(ID,'PHOTON FLUX (pinhole, folded)',
     &        MFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,WFLUXTF(ifrq))
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)
          ENDIF   !IFOLD

        ENDIF !IPIN

      ELSE  !ifreq2P

        DF=FREQ(2)-FREQ(1)
        FLOW=FREQ(1)-DF/2.
        FHIG=FREQ(NFREQ)+DF/2.

        if (ifreq2p.eq.1.or.freqlow.eq.freqhig) then
          DF=freqhig-freqlow
          FLOW=freqlow-DF/2.
          FHIG=freqlow+DF/2.
        else if (ifreq2p.eq.-1) then
          FLOW=freqlow
          FHIG=freqhig
        endif

        IF (FLOW.LT.0.) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING SR HFREQ ***'
          WRITE(LUNGFO,*)'LOW EDGE OF HISTOGRAM NEGATIVE'
          WRITE(LUNGFO,*)
     &      'BE CAREFUL IF X-AXIS IS PLOTTED WITH LOGARITHMIC SCALE'
          WRITE(LUNGFO,*)
        ENDIF

        IF(IPIN.EQ.0) THEN

          DO IOBSV=1,NOBSV

            ID=ICFREQ+IOBSV
            call hbook1m(ID,'PHOTON FLUX DENSITY x 1.E-6 ',NFREQ,FLOW,FHIG,VMX)

            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          specTOT(IOBSV+NOBSV*(ifrq-1))*1.0d-6)
            ENDDO   !NFREQ

            CALL MHROUT(ID,ICYCLE,' ')
            CALL hdeletm(ID)

          IF (IFOLD.EQ.2) THEN

              ID=ICFREQ+1000+IOBSV
              call hbook1m(ID,
     &'PHOTON FLUX DENSITY x 1.E-6 (FOLDED)',NFREQ,FLOW,FHIG,VMX)

              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          specTOTF(IOBSV+NOBSV*(ifrq-1))*1.0d-6)
              ENDDO   !NFREQ

              CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

          ENDIF !IFOLD.EQ.2

          ENDDO !IOBSV

          IF (ISTOKES.NE.0) THEN

            ID=ICFRS0
            call hbook1m(ID,'S0 (sel. obs. point) x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          dble(stokES(1,1+NOBSV*(ifrq-1))*1.0d-6))
            ENDDO   !NFREQ

            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRS1
            call hbook1m(ID,'S1 (sel. obs. point) x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          dble(stokES(2,1+NOBSV*(ifrq-1))*1.0d-6))
            ENDDO   !NFREQ

            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRS2
            call hbook1m(ID,'S2 (sel. obs. point) x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          dble(stokES(3,1+NOBSV*(ifrq-1))*1.0d-6))
            ENDDO   !NFREQ

            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRS3
            call hbook1m(ID,'S3 (sel. obs. point) x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          dble(stokES(4,1+NOBSV*(ifrq-1))*1.0d-6))
            ENDDO   !NFREQ

            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP
            call hbook1m(ID,'P (sel. obs. point)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=SQRT
     &          ((STOKES(2,IOBFR)/STOKES(1,IOBFR))**2
     &          +(STOKES(3,IOBFR)/STOKES(1,IOBFR))**2
     &         +(STOKES(4,IOBFR)/STOKES(1,IOBFR))**2)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP1
            call hbook1m(ID,'P1 (sel. obs. point)'
     &                    ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=STOKES(2,IOBFR)/STOKES(1,IOBFR)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP2
            call hbook1m(ID,'P2 (sel. obs. point)'
     &                    ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=STOKES(3,IOBFR)/STOKES(1,IOBFR)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP3
            call hbook1m(ID,'P3 (sel. obs. point)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=STOKES(4,IOBFR)/STOKES(1,IOBFR)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP23
            call hbook1m(ID,'P23 (sel. obs. point)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=SQRT((STOKES(3,IOBFR)/STOKES(1,IOBFR))**2
     &          +(STOKES(4,IOBFR)/STOKES(1,IOBFR))**2)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRG3
            call hbook1m(ID,'G3 (sel. obs. point) x 1.E-6 '
     &                    ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=STOKES(4,IOBFR)/STOKES(1,IOBFR)*STOKES(4,IOBFR)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight*1.0d-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRG23
            call hbook1m(ID,'G23 (sel. obs. point) x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IOBFR=1+NOBSV*(ifrq-1)
              IF (STOKES(1,IOBFR).NE.0.0)
     &          WEIGHT=((STOKES(3,IOBFR)/STOKES(1,IOBFR))**2
     &          +(STOKES(4,IOBFR)/STOKES(1,IOBFR))**2)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight*1.0d-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            IF (IEFOLD.NE.0) THEN

              ID=ICFRS0E
              call hbook1m(ID,'S0_E (sel. obs. point) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(WSTOKESE(1,ifrq)*1.0d-6))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRS1E
              call hbook1m(ID,'S1_E (sel. obs. point) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(wstokESE(2,ifrq)*1.0d-6))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRS2E
              call hbook1m(ID,'S2_E (sel. obs. point) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(wstokESE(3,ifrq)*1.0d-6))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRS3E
              call hbook1m(ID,'S3_E (sel. obs. point) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(wstokESE(4,ifrq)*1.0d-6))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRPE
              call hbook1m(ID,'P_E (sel. obs. point)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=SQRT
     &            ((WSTOKESE(2,ifrq)/WSTOKESE(1,ifrq))**2
     &            +(WSTOKESE(3,ifrq)/WSTOKESE(1,ifrq))**2
     &            +(WSTOKESE(4,ifrq)/WSTOKESE(1,ifrq))**2)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP1E
              call hbook1m(ID,'P1_E (sel. obs. point)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(2,ifrq)/WSTOKESE(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP2E
              call hbook1m(ID,'P2_E (sel. obs. point)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(3,ifrq)/WSTOKESE(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP3E
              call hbook1m(ID,'P3_E (sel. obs. point)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(4,ifrq)/WSTOKESE(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP23E
              call hbook1m(ID,'P23_E (sel. obs. point)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=SQRT(
     &            (WSTOKESE(3,ifrq)/WSTOKESE(1,ifrq))**2
     &            +(WSTOKESE(4,ifrq)/WSTOKESE(1,ifrq))**2)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRG3E
              call hbook1m(ID,'G3_E (sel. obs. point) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(4,ifrq)/WSTOKESE(1,ifrq)*WSTOKESE(4,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight*1.0d-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRG23E
              call hbook1m(ID,'G23_E (sel. obs. point) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(3,ifrq)/WSTOKESE(1,ifrq)*WSTOKESE(3,ifrq)
     &            +WSTOKESE(4,ifrq)/WSTOKESE(1,ifrq)*WSTOKESE(4,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight*1.0d-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

            ENDIF !IEFOLD

            IF (IBRILL.NE.0) THEN

              ID=ICFRB0
              call hbook1m(ID,'SELECTED B0 x 1.E-12'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(brillC(1,ifrq)*1.0d-12))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

              ID=ICFRB1
              call hbook1m(ID,'SELECTED B1 x 1.E-12'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(brillC(2,ifrq)*1.0d-12))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

              ID=ICFRB2
              call hbook1m(ID,'SELECTED B2 x 1.E-12'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(brillC(3,ifrq)*1.0d-12))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

              ID=ICFRB3
              call hbook1m(ID,'SELECTED B3 x 1.E-12'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(brillC(4,ifrq)*1.0d-12))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

              IF (IEFOLD.NE.0) THEN

                ID=ICFRB0E
                call hbook1m(ID,'SELECTED B0_E x 1.E-12'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(brillCE(1,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                ID=ICFRB1E
                call hbook1m(ID,'SELECTED B1_E x 1.E-12'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(brillCE(2,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                ID=ICFRB2E
                call hbook1m(ID,'SELECTED B2_E x 1.E-12'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(BRILLCE(3,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                ID=ICFRB3E
                call hbook1m(ID,'SELECTED B3_E x 1.E-12'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(BRILLCE(4,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ENDIF !IEFOLD

              IF (IFOLD.EQ.2) THEN

                ID=ICFRB0F
                call hbook1m(ID,'SELECTED B0 x 1.E-12 (FOLDED)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(BRILLCF(1,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

                ID=ICFRB1F
                call hbook1m(ID,'SELECTED B1 x 1.E-12 (FOLDED)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(BRILLCF(2,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

                ID=ICFRB2F
                call hbook1m(ID,'SELECTED B2 x 1.E-12 (FOLDED)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(BRILLCF(3,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

                ID=ICFRB3F
                call hbook1m(ID,'SELECTED B3 x 1.E-12 (FOLDED)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(BRILLCF(4,ifrq)*1.0d-12))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

                IF (IEFOLD.NE.0) THEN

                  ID=ICFRB0EF
                  call hbook1m(ID,'SELECTED B0_E x 1.E-12 (FOLDED)'
     &              ,NFREQ,FLOW,FHIG,VMX)
                  DO ifrq=1,NFREQ,IHFREQ
                    CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &                dble(BRILLCEF(1,ifrq)*1.0d-12))
                  ENDDO   !NFREQ
                  CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                  ID=ICFRB1EF
                  call hbook1m(ID,'SELECTED B1_E x 1.E-12 (FOLDED)'
     &              ,NFREQ,FLOW,FHIG,VMX)
                  DO ifrq=1,NFREQ,IHFREQ
                    CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &                dble(BRILLCEF(2,ifrq)*1.0d-12))
                  ENDDO   !NFREQ
                  CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                  ID=ICFRB2EF
                  call hbook1m(ID,'SELECTED B2_E x 1.E-12 (FOLDED)'
     &              ,NFREQ,FLOW,FHIG,VMX)
                  DO ifrq=1,NFREQ,IHFREQ
                    CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &                dble(BRILLCEF(3,ifrq)*1.0d-12))
                  ENDDO   !NFREQ
                  CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                  ID=ICFRB3EF
                  call hbook1m(ID,'SELECTED B3_E x 1.E-12 (FOLDED)'
     &              ,NFREQ,FLOW,FHIG,VMX)
                  DO ifrq=1,NFREQ,IHFREQ
                    CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &                dble(BRILLCEF(4,ifrq)*1.0d-12))
                  ENDDO   !NFREQ
                  CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                ENDIF !IEFOLD
              ENDIF !IFOLD.NE.2

            ENDIF !IBRILL

          ENDIF !ISTOKES

        ELSE  !IPIN

          ID=IDFREQ
          call hbook1m(ID,'PHOTON FLUX (pinhole)',NFREQ,FLOW,FHIG,VMX)
          DO ifrq=1,NFREQ,IHFREQ
            CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,WFLUXT(ifrq))
          ENDDO   !NFREQ
          CALL MHROUT(ID,ICYCLE,' ')
         call hdeletm(ID)

          IF (IFOLD.NE.0) THEN
            ID=IDFREQF
            call hbook1m(ID,'PHOTON FLUX (pinhole, folded)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,WFLUXTF(ifrq))
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)
          ENDIF   !IFOLD

          IF (NSOURCE.GT.10) THEN
            JSOURCE=10
            WRITE(6,*)
            WRITE(6,*)'--- Information from HFREQ: More than 10 sources.'
            WRITE(6,*)'--- Generating flux histograms for every 10th source only'
            WRITE(6,*)
            WRITE(lungfo,*)
            WRITE(lungfo,*)'--- Information from HFREQ: More than 10 sources.'
            WRITE(lungfo,*)'--- Generating flux histograms for every 10th source only'
            WRITE(lungfo,*)
          else
            jsource=1
          ENDIF

          DO ISOUR=1,NSOURCE,JSOURCE

            ID=IDFREQ+200000+ISOUR
            call hbook1m(ID,'PHOTON FLUX (pinhole)',NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          WFLUX( ISOUR+NSOURCE*(ifrq-1)))
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
         call hdeletm(ID)

            IF (IFOLD.NE.0) THEN
              ID=IDFREQF+200000+ISOUR
              call hbook1m(ID,'PHOTON FLUX (pinhole, folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            WFLUXF(ISOUR+NSOURCE*(ifrq-1)))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)
            ENDIF   !IFOLD

          ENDDO !ISOURCE

          IF (ISTOKES.NE.0) THEN

            ID=IDFRS0
            call hbook1m(ID,'S0 (pinhole)',NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          dble(WSTOKES(1,ifrq)))
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=IDFRS1
            call hbook1m(ID,'S1 (pinhole)',NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          dble(WSTOKES(2,ifrq)))
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=IDFRS2
            call hbook1m(ID,'S2 (pinhole)',NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          dble(WSTOKES(3,ifrq)))
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=IDFRS3
            call hbook1m(ID,'S3 (pinhole)',NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &          dble(WSTOKES(4,ifrq)))
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=IDFRP
            call hbook1m(ID,'P (pinhole)',NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (WSTOKES(1,ifrq).NE.0.0)
     &          WEIGHT=SQRT
     &          (WSTOKES(2,ifrq)**2+WSTOKES(3,ifrq)**2
     &          +WSTOKES(4,ifrq)**2)
     &          /WSTOKES(1,ifrq)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=IDFRP1
            call hbook1m(ID,'P1 (pinhole)',NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (WSTOKES(1,ifrq).NE.0.0)
     &          WEIGHT=WSTOKES(2,ifrq)/WSTOKES(1,ifrq)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=IDFRP2
            call hbook1m(ID,'P2 (pinhole)',NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (WSTOKES(1,ifrq).NE.0.0)
     &          WEIGHT=WSTOKES(3,ifrq)/WSTOKES(1,ifrq)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=IDFRP3
            call hbook1m(ID,'P3 (pinhole)',NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (WSTOKES(1,ifrq).NE.0.0)
     &          WEIGHT=WSTOKES(4,ifrq)/WSTOKES(1,ifrq)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=IDFRP23
            call hbook1m(ID,'P23 (pinhole)',NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (WSTOKES(1,ifrq).NE.0.0)
     &          WEIGHT=SQRT
     &          (WSTOKES(3,ifrq)**2+WSTOKES(4,ifrq)**2)
     &          /WSTOKES(1,ifrq)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=IDFRG3
            call hbook1m(ID,'G3 (pinhole)',NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (WSTOKES(1,ifrq).NE.0.0)
     &          WEIGHT=WSTOKES(4,ifrq)**2/WSTOKES(1,ifrq)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=IDFRG23
            call hbook1m(ID,'G23 (pinhole)',NFREQ,FLOW,FHIG,VMX)
            DO ifrq=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (WSTOKES(1,ifrq).NE.0.0)
     &          WEIGHT=
     &          (WSTOKES(3,ifrq)**2+WSTOKES(4,ifrq)**2)
     &          /WSTOKES(1,ifrq)
              CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            IF (IFOLD.NE.0) THEN

              ID=IDFRS0F
              call hbook1m(ID,'S0 (pinhole, folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(WSTOKESF(1,ifrq)))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRS1F
              call hbook1m(ID,'S1  (pinhole, folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(WSTOKESF(2,ifrq)))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRS2F
              call hbook1m(ID,'S2 (pinhole, folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(WSTOKESF(3,ifrq)))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRS3F
              call hbook1m(ID,'S3 (pinhole, folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(WSTOKESF(4,ifrq)))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRPF
              call hbook1m(ID,'P (pinhole, folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESF(1,ifrq).NE.0.0)
     &            WEIGHT=SQRT
     &            (WSTOKESF(2,ifrq)**2+WSTOKESF(3,ifrq)**2
     &            +WSTOKESF(4,ifrq)**2)
     &            /WSTOKESF(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRP1F
              call hbook1m(ID,'P1 (pinhole, folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESF(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESF(2,ifrq)/WSTOKESF(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRP2F
              call hbook1m(ID,'P2 (pinhole, folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESF(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESF(3,ifrq)/WSTOKESF(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRP3F
              call hbook1m(ID,'P3 (pinhole, folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESF(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESF(4,ifrq)/WSTOKESF(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRP23F
              call hbook1m(ID,'P23 (pinhole, folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESF(1,ifrq).NE.0.0)
     &            WEIGHT=SQRT
     &            (WSTOKESF(3,ifrq)**2+WSTOKESF(4,ifrq)**2)
     &            /WSTOKESF(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRG3F
              call hbook1m(ID,'G3 (pinhole, folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESF(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESF(4,ifrq)**2/WSTOKESF(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRG23F
              call hbook1m(ID,'G23 (pinhole, folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESF(1,ifrq).NE.0.0)
     &            WEIGHT=(WSTOKESF(3,ifrq)**2+WSTOKESF(4,ifrq)**2)
     &            /WSTOKESF(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

            ENDIF   !IFOLD

            IF (IEFOLD.NE.0) THEN

              ID=IDFRS0E
              call hbook1m(ID,'S0_E (pinhole)',NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(WSTOKESE(1,ifrq)))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRS1E
              call hbook1m(ID,'S1_E (pinhole)',NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(WSTOKESE(2,ifrq)))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRS2E
              call hbook1m(ID,'S2_E (pinhole)',NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(WSTOKESE(3,ifrq)))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRS3E
              call hbook1m(ID,'S3_E (pinhole)',NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &            dble(WSTOKESE(4,ifrq)))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRPE
              call hbook1m(ID,'P_E (pinhole)',NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=SQRT
     &            (WSTOKESE(2,ifrq)**2+WSTOKESE(3,ifrq)**2
     &            +WSTOKESE(4,ifrq)**2)
     &            /WSTOKESE(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRP1E
              call hbook1m(ID,'P1_E (pinhole)',NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(2,ifrq)/WSTOKESE(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRP2E
              call hbook1m(ID,'P2_E (pinhole)',NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(3,ifrq)/WSTOKESE(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRP3E
              call hbook1m(ID,'P3_E (pinhole)',NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(4,ifrq)/WSTOKESE(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRP23E
              call hbook1m(ID,'P23_E (pinhole)',NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=SQRT
     &            (WSTOKESE(3,ifrq)**2+WSTOKESE(4,ifrq)**2)
     &            /WSTOKESE(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRG3E
              call hbook1m(ID,'G3_E (pinhole)',NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=WSTOKESE(4,ifrq)**2/WSTOKESE(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=IDFRG23E
              call hbook1m(ID,'G23_E (pinhole)',NFREQ,FLOW,FHIG,VMX)
              DO ifrq=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (WSTOKESE(1,ifrq).NE.0.0)
     &            WEIGHT=
     &            (WSTOKESE(3,ifrq)**2+WSTOKESE(4,ifrq)**2)
     &            /WSTOKESE(1,ifrq)
                CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              IF (IFOLD.NE.0) THEN

                ID=IDFRS0EF
                call hbook1m(ID,'S0_E (pinhole, folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(WSTOKESEF(1,ifrq)))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
                 call hdeletm(ID)

                ID=IDFRS1EF
                call hbook1m(ID,'S1_E  (pinhole, folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(WSTOKESEF(2,ifrq)))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
                 call hdeletm(ID)

                ID=IDFRS2EF
                call hbook1m(ID,'S2_E (pinhole, folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(WSTOKESEF(3,ifrq)))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
                 call hdeletm(ID)

                ID=IDFRS3EF
                call hbook1m(ID,'S3_E (pinhole, folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,
     &              dble(WSTOKESEF(4,ifrq)))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
                 call hdeletm(ID)

                ID=IDFRPEF
                call hbook1m(ID,'P_E (pinhole, folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (WSTOKESEF(1,ifrq).NE.0.0)
     &              WEIGHT=SQRT
     &              (WSTOKESEF(2,ifrq)**2+WSTOKESEF(3,ifrq)**2
     &              +WSTOKESEF(4,ifrq)**2)
     &              /WSTOKESEF(1,ifrq)
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
                 call hdeletm(ID)

                ID=IDFRP1EF
                call hbook1m(ID,'P1_E (pinhole, folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (WSTOKESEF(1,ifrq).NE.0.0)
     &              WEIGHT=WSTOKESEF(2,ifrq)/WSTOKESEF(1,ifrq)
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
                 call hdeletm(ID)


                ID=IDFRP2EF
                call hbook1m(ID,'P2_E (pinhole, folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (WSTOKESEF(1,ifrq).NE.0.0)
     &              WEIGHT=WSTOKESEF(3,ifrq)/WSTOKESEF(1,ifrq)
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
                 call hdeletm(ID)

                ID=IDFRP3EF
                call hbook1m(ID,'P3_E (pinhole, folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (WSTOKESEF(1,ifrq).NE.0.0)
     &              WEIGHT=WSTOKESEF(4,ifrq)/WSTOKESEF(1,ifrq)
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
                 call hdeletm(ID)

                ID=IDFRP23EF
                call hbook1m(ID,'P23_E (pinhole, folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (WSTOKESEF(1,ifrq).NE.0.0)
     &              WEIGHT=SQRT
     &              (WSTOKESEF(3,ifrq)**2+WSTOKESEF(4,ifrq)**2)
     &              /WSTOKESEF(1,ifrq)
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
                 call hdeletm(ID)

                ID=IDFRG3EF
                call hbook1m(ID,'G3_E (pinhole, folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (WSTOKESEF(1,ifrq).NE.0.0)
     &              WEIGHT=WSTOKESEF(4,ifrq)**2/WSTOKESEF(1,ifrq)
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
                 call hdeletm(ID)

                ID=IDFRG23EF
                call hbook1m(ID,'G23_E (pinhole, folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO ifrq=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (WSTOKESEF(1,ifrq).NE.0.0)
     &              WEIGHT=(WSTOKESEF(3,ifrq)**2+WSTOKESEF(4,ifrq)**2)
     &              /WSTOKESEF(1,ifrq)
                  CALL hfillm(ID,SNGL(FREQ(ifrq)),0.,weight)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
                 call hdeletm(ID)

              ENDIF   !IFOLD

            ENDIF   !IEFOLD

          ENDIF   !ISTOKES

        ENDIF !IPIN

      ENDIF !ifreq2P

C--- NTUPLE

100   CONTINUE

      CALL HFREQC

      IF (IPIN.NE.0) THEN
        DO IOBSV=1,NOBSV
          FILL(IOBSV)=0.0d0
        ENDDO
        TIT='DIST. IN PINHOLE'
        CALL HSPEC2(IDSPEC,TIT)
        TIT='HORIZ. CUT OF DIST. IN PINH.'
        CALL HSPEC1(IDSPEC-1,TIT,1)
        TIT='VERT. CUT OF DIST. IN PINH.'
        CALL HSPEC1(IDSPEC-2,TIT,2)
        IF (IPHASE.NE.0) THEN
          TIT='DIST. IN SOURCE PLANE'
          CALL HPHASE2(IDPHASE,TIT,PHFILL)
        ENDIF
      ENDIF

      IF (I47.EQ.1) THEN

        if (iroottrees.ge.0) then
          CALL hcdirm(OLDDIR,'R')
        endif

        FILE47='3700_'//FILEHB(1:123)

        if (iroottrees.ge.0) then
          CALL hropenm(47,'SPEC',FILE47,'NQ',1024,ISTAT)
          CALL hcdirm('//SPEC',' ')
        endif

        CALL MHROUT(IDCODE,ICYCLE,' ')

        CALL MHROUT(ICFREQ,ICYCLE,' ')

        CALL MHROUT(IDFREQ,ICYCLE,' ')

        CALL MHROUT(IDSPEC,ICYCLE,' ')
        CALL MHROUT(IDSPEC-1,ICYCLE,' ')
        CALL MHROUT(IDSPEC-2,ICYCLE,' ')
        call hdeletm(idspec)
        call hdeletm(idspec-1)
        call hdeletm(idspec-2)

+self,if=-mhbook.
        CALL hbookm(NIDSPEC,'ARRAYS SPECT, REAIMA',31
     &    ,'//SPEC',1024,CHSPEC)
        if (mpinr.ne.0) then
          CALL hbookm(NIDSPECRPHI,'ARRAYS SPECT AND SPECPOW, REAIMARPHI',33
     &      ,'//SPEC',1024,CHSPECRPHI)
        endif
+self,if=mhbook.
        CALL hbookm(NIDSPEC,'ARRAYS SPECT, REAIMA',34
     &    ,'//SPEC',nobsv*nfreq*nsource,CHSPEC)
        if (mpinr.ne.0) then
          CALL hbookm(NIDSPECRPHI,'ARRAYS SPECT AND SPECPOW, REAIMARPHI',33
     &      ,'//SPEC',nobsv*nfreq*nsource,CHSPECRPHI)
        endif
+self.
      ELSE !I47

+self,if=-mhbook.
        CALL hbookm(NIDSPEC,'ARRAYS SPECT, REAIMA',34
     &    ,'//WAVE',1024,CHSPEC)
        if (mpinr.ne.0) then
          CALL hbookm(NIDSPECRPHI,'ARRAYS SPECT, REAIMARPHI',33
     &      ,'//WAVE',1024,CHSPECRPHI)
          endif
+self,if=mhbook.
          CALL hbookm(NIDSPEC,'ARRAYS SPECT, REAIMA',34
     &    ,'//WAVE',nobsv*nfreq*nsource,CHSPEC)
        if (mpinr.ne.0) then
          CALL hbookm(NIDSPECRPHI,'ARRAYS SPECT, REAIMARPHI',33
     &      ,'//WAVE',nobsv*nfreq*nsource,CHSPECRPHI)
          endif
+self.

       ENDIF !I47

      smax=0.0d0
      do ifrq=1,nfreq
        DO iobsv=1,nobsv
          iobfr=iobsv+nobsv*(ifrq-1)
          if (spec(iobfr).gt.smax) then
            smax=spec(iobfr)
            reanor=
     &        reaima(1,1,iobfr)**2+reaima(1,2,iobfr)**2+
     &        reaima(2,1,iobfr)**2+reaima(2,2,iobfr)**2+
     &        reaima(3,1,iobfr)**2+reaima(3,2,iobfr)**2
          endif
        enddo
      enddo

      reanor=sqrt(smax/reanor)

      DO ISOUR=1,NSOURCE

        if (ispecdip.le.0) then
          censoux=(min(sourceeo(1,1,isour),xiend)
     &      +max(sourceao(1,1,isour),xianf))/2.d0
          censouy=sourceeo(2,1,isour)
          censouz=sourceeo(3,1,isour)
        else
          censoux=x0dip(isour)
          censouy=y0dip(isour)
          censouz=z0dip(isour)
        endif

        dist0=sqrt(
     &    ((pincen(3)-censouz)**2+
     &    (pincen(2)-censouy)**2)+
     &    (pincen(1)-censoux)**2)

        DO IOBSV=1,NOBSV

          IF (IPIN.NE.0) THEN
            IOBSVY=(IOBSV-1)/NOBSVZ+1
            IOBSVZ=IOBSV-NOBSVZ*(IOBSVY-1)
          ELSE
            IOBSVY=0
            IOBSVZ=0
          ENDIF
          DO ifrq=1,NFREQ,IHFREQ
            FSPEC(1)=ISOUR
            FSPEC(2)=IOBSV
            FSPEC(3)=OBSV(1,IOBSV)
            FSPEC(4)=OBSV(2,IOBSV)
            FSPEC(5)=OBSV(3,IOBSV)
            if (abs(fspec(4)).lt.1.0d-15) fspec(4)=0.0d0
            if (abs(fspec(5)).lt.1.0d-15) fspec(5)=0.0d0
            FSPEC(6)=FREQ(ifrq)
            FSPEC(7)=SPEC(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(ifrq-1)))
            FSPEC(8)=IOBSVZ
            FSPEC(9)=IOBSVY
            FSPEC(10)=ifrq
            IOBFR=IOBSV+NOBSV*(ifrq-1)
c            IF (ISPECMODE.EQ.3) THEN

              FSPEC(11)=reanor*reaIMA(1,1,IOBFR)
              FSPEC(12)=reanor*reaIMA(1,2,IOBFR)
              FSPEC(13)=reanor*reaIMA(2,1,IOBFR)
              FSPEC(14)=reanor*reaIMA(2,2,IOBFR)
              FSPEC(15)=reanor*reaIMA(3,1,IOBFR)
              FSPEC(16)=reanor*reaIMA(3,2,IOBFR)

              FSPEC(17)=reanor*reaIMA(4,1,IOBFR)
              FSPEC(18)=reanor*reaIMA(4,2,IOBFR)
              FSPEC(19)=reanor*reaIMA(5,1,IOBFR)
              FSPEC(20)=reanor*reaIMA(5,2,IOBFR)

              e(1)=dcmplx(fspec(11),fspec(12))
              e(2)=dcmplx(fspec(13),fspec(14))
              e(3)=dcmplx(fspec(15),fspec(16))

              FSPEC(21)=reanor*reaIMA(6,1,IOBFR)
              FSPEC(22)=reanor*reaIMA(6,2,IOBFR)
              FSPEC(23)=reanor*reaIMA(7,1,IOBFR)
              FSPEC(24)=reanor*reaIMA(7,2,IOBFR)
              FSPEC(25)=reanor*reaIMA(8,1,IOBFR)
              FSPEC(26)=reanor*reaIMA(8,2,IOBFR)

              b(1)=dcmplx(fspec(21),fspec(22))
              b(2)=dcmplx(fspec(23),fspec(24))
              b(3)=dcmplx(fspec(25),fspec(26))

              FSPEC(27)=reanor*reaIMA(9,1,IOBFR)
              FSPEC(28)=reanor*reaIMA(9,2,IOBFR)
              FSPEC(29)=reanor*reaIMA(10,1,IOBFR)
              FSPEC(30)=reanor*reaIMA(10,2,IOBFR)

              rn(1)=real(e(2)*conjg(b(3))-e(3)*conjg(b(2)))
              rn(2)=real(e(3)*conjg(b(1))-e(1)*conjg(b(3)))
              rn(3)=real(e(1)*conjg(b(2))-e(2)*conjg(b(1)))

              rn=rn/norm2(rn)
              fspec(32:34)=rn(1:3)

              dist=sqrt(
     &          ((obsv(3,iobsv)-censouz)**2+
     &          (obsv(2,iobsv)-censouy)**2)+
     &          (obsv(1,iobsv)-censoux)**2)

              ddist=dist-dist0

              wlen=clight1*hbarev1*twopi1/freq(ifrq)
              waves=ddist/wlen
              dphase=waves*twopi1

              FSPEC(31)=dphase

              CALL hfm(NIDSPEC,FSPEC)

          ENDDO   !NFREQ
        ENDDO   !IOBSV
      ENDDO   !ISOUR

      IF (MPINR.NE.0) THEN
        DO ISOUR=1,NSOURCE
          DO IOBSV=1,NOBSVRPHI
            IF (IPIN.NE.0) THEN
              IOBSVPHI=(IOBSV-1)/NOBSVR+1
              IOBSVR=IOBSV-NOBSVR*(IOBSVPHI-1)
            ELSE
              IOBSVR=0
              IOBSVPHI=0
            ENDIF
            DO ifrq=1,NFREQ,IHFREQ
              FSPEC(1)=ISOUR
              FSPEC(2)=IOBSV
              FSPEC(3)=OBSVRPHI(1,IOBSV)
              FSPEC(4)=OBSVRPHI(2,IOBSV)*SIN(OBSVRPHI(3,IOBSV))
              FSPEC(5)=OBSVRPHI(2,IOBSV)*COS(OBSVRPHI(3,IOBSV))
              FSPEC(6)=OBSVRPHI(2,IOBSV)
              FSPEC(7)=OBSVRPHI(3,IOBSV)
              FSPEC(8)=FREQ(ifrq)
              FSPEC(9)=SPECRPHI(ISOUR+NSOURCE*(IOBSV-1+NOBSVRPHI*(ifrq-1)))
              FSPEC(10)=IOBSVR
              FSPEC(11)=IOBSVPHI
              FSPEC(12)=ifrq
              IOBFR=IOBSV+NOBSVRPHI*(ifrq-1)
              FSPEC(13)=reanor*reaIMARPHI(1,1,IOBFR)
              FSPEC(14)=reanor*reaIMARPHI(1,2,IOBFR)
              FSPEC(15)=reanor*reaIMARPHI(2,1,IOBFR)
              FSPEC(16)=reanor*reaIMARPHI(2,2,IOBFR)
              FSPEC(17)=reanor*reaIMARPHI(3,1,IOBFR)
              FSPEC(18)=reanor*reaIMARPHI(3,2,IOBFR)
              FSPEC(19)=reanor*reaIMARPHI(4,1,IOBFR)
              FSPEC(20)=reanor*reaIMARPHI(4,2,IOBFR)
              FSPEC(21)=reanor*reaIMARPHI(5,1,IOBFR)
              FSPEC(22)=reanor*reaIMARPHI(5,2,IOBFR)

              FSPEC(23)=reanor*reaIMARPHI(6,1,IOBFR)
              FSPEC(24)=reanor*reaIMARPHI(6,2,IOBFR)
              FSPEC(25)=reanor*reaIMARPHI(7,1,IOBFR)
              FSPEC(26)=reanor*reaIMARPHI(7,2,IOBFR)
              FSPEC(27)=reanor*reaIMARPHI(8,1,IOBFR)
              FSPEC(28)=reanor*reaIMARPHI(8,2,IOBFR)
              FSPEC(29)=reanor*reaIMARPHI(9,1,IOBFR)
              FSPEC(30)=reanor*reaIMARPHI(9,2,IOBFR)
              FSPEC(31)=reanor*reaIMARPHI(10,1,IOBFR)
              FSPEC(32)=reanor*reaIMARPHI(10,2,IOBFR)

              h2=(obsvr(iobsvr)/dist0)**2

              if (h2.lt.0.01) then
                ddist=dist0*(h2/2.0d0-h2**2/8.0d0)
              else
                ddist=dist0*(sqrt(1.0d0+h2)-1.0d0)
              endif

              dphase=ddist/freq(ifrq)*wtoe1*1.0d9*twopi1

              FSPEC(33)=dphase

              CALL hfm(NIDSPECRPHI,FSPEC)

            ENDDO   !NFREQ
          ENDDO   !IOBSV
        ENDDO   !ISOUR
      ENDIF !MPINR

      IF (I47.EQ.1) THEN

        CALL MHROUT(NIDSPEC,ICYCLE,' ')
        if (mpinr.ne.0) then
          CALL MHROUT(NIDSPECRPHI,ICYCLE,' ')
        endif

        if (iroottrees.ge.0) then
          CALL hrendm('SPEC')
        endif
        CLOSE(47)

        if (iroottrees.ge.0) then
          CALL hcdirm(OLDDIR,' ')
        endif

      ENDIF !I47

+self,if=-mhbook.
      CALL hbookm(NIDSPEC+2,'BRILLIANCE',17
     &  ,'//WAVE',1024,CHBRILL)
+self,if=mhbook.
      CALL hbookm(NIDSPEC+2,'BRILLIANCE',17
     &  ,'//WAVE',nobsv*nfreq*nsource,CHBRILL)
+self.

C BRILLIANCE
      DO ifrq=1,NFREQ,IHFREQ
        FSPEC(1)=FREQ(ifrq)
        DO I=2,16
          FSPEC(I)=0.
        ENDDO
        IF (IBRILL.NE.0) THEN
          FSPEC(2)=BRILLC(1,ifrq)
          FSPEC(3)=BRILLC(2,ifrq)
          FSPEC(4)=BRILLC(3,ifrq)
          FSPEC(5)=BRILLC(4,ifrq)
          IF (IFOLD.NE.0) THEN
            FSPEC(6)=BRILLCF(1,ifrq)
            FSPEC(7)=BRILLCF(2,ifrq)
            FSPEC(8)=BRILLCF(3,ifrq)
            FSPEC(9)=BRILLCF(4,ifrq)
          ENDIF
          IF (IEFOLD.NE.0) THEN
            FSPEC(10)= BRILLCE(1,ifrq)
            FSPEC(11)=BRILLCE(2,ifrq)
            FSPEC(12)=BRILLCE(3,ifrq)
            FSPEC(13)=BRILLCE(4,ifrq)
          ENDIF
          IF (IEFOLD.NE.0.AND.IFOLD.NE.0) THEN
            FSPEC(14)= BRILLCEF(1,ifrq)
            FSPEC(15)=BRILLCEF(2,ifrq)
            FSPEC(16)=BRILLCEF(3,ifrq)
            FSPEC(17)=BRILLCEF(4,ifrq)
          ENDIF
        ENDIF  !IBRILL
        CALL hfm(NIDSPEC+2,FSPEC)
      ENDDO   !NFREQ

      IF (ISPECINT.NE.0) THEN

+self,if=-mhbook.
        CALL hbookm(NIDPOW-1,'POWER DENSITY FROM SPECTRUM',8
     &    ,'//WAVE',1000,CHPOW)
+self,if=mhbook.
        CALL hbookm(NIDPOW-1,'POWER DENSITY FROM SPECTRUM',8
     &    ,'//WAVE',nobsv*nsource,CHPOW)
+self.
        DO ISOUR=1,NSOURCE
          DO IOBSV=1,NOBSV

            IF (IPIN.NE.0) THEN
              IOBSVY=(IOBSV-1)/NOBSVZ+1
              IOBSVZ=IOBSV-NOBSVZ*(IOBSVY-1)
            ELSE
              IOBSVY=1
              IOBSVZ=1
            ENDIF

            FSPEC(1)=OBSV(1,IOBSV)
            FSPEC(2)=OBSV(2,IOBSV)
            FSPEC(3)=OBSV(3,IOBSV)
            if (abs(fspec(2)).lt.1.0d-15) fspec(2)=0.0d0
            if (abs(fspec(3)).lt.1.0d-15) fspec(3)=0.0d0
            FSPEC(4)=SPECI(ISOUR+NSOURCE*(IOBSV-1))
            FSPEC(5)=IOBSVZ
            FSPEC(6)=IOBSVY
            FSPEC(7)=IOBSV
            FSPEC(8)=ISOUR

            CALL hfm(NIDPOW-1,FSPEC)

          ENDDO   !IOBSV
        ENDDO   !ISOUR

+self,if=-mhbook.
        CALL hbookm(NIDPOW-2,'HORIZ. POWER DENSITY FROM SPECTRUM(VERT. INT.)',5
     &    ,'//WAVE',1000,CHPOWV)
+self,if=mhbook.
        CALL hbookm(NIDPOW-2,'HORIZ. POWER DENSITY FROM SPECTRUM(VERT. INT.)',5
     &    ,'//WAVE',nobsv*nsource,CHPOWV)
+self.
        DO ISOUR=1,NSOURCE
          DO IOBSVZ=1,NOBSVZ

            FSPEC(1)=OBSV(1,IOBSVZ)
            FSPEC(2)=OBSV(3,IOBSVZ)
            if (abs(fspec(2)).lt.1.0d-15) fspec(2)=0.0d0
            FSPEC(3)=SPECIV(ISOUR+NSOURCE*(IOBSVZ-1))
            FSPEC(4)=IOBSVZ
            FSPEC(5)=ISOUR

            CALL hfm(NIDPOW-2,FSPEC)

          ENDDO   !IOBSV
        ENDDO   !ISOUR

        IF (IFOLD.NE.0) THEN

+self,if=-mhbook.
          CALL hbookm(NIDPOW-10,'POWER DENSITY FROM SPECTRUM (FOLDED)',8
     &      ,'//WAVE',1000,CHPOW)
+self,if=mhbook.
          CALL hbookm(NIDPOW-10,'POWER DENSITY FROM SPECTRUM (FOLDED)',8
     &      ,'//WAVE',nobsv*nsource,CHPOW)
+self.

          DO ISOUR=1,NSOURCE
            DO IOBSV=1,NOBSV

              IF (IPIN.NE.0) THEN
                IOBSVY=(IOBSV-1)/NOBSVZ+1
                IOBSVZ=IOBSV-NOBSVZ*(IOBSVY-1)
              ELSE
                IOBSVY=1
                IOBSVZ=1
              ENDIF

              FSPEC(1)=OBSV(1,IOBSV)
              FSPEC(2)=OBSV(2,IOBSV)
              FSPEC(3)=OBSV(3,IOBSV)
              if (abs(fspec(2)).lt.1.0d-15) fspec(2)=0.0d0
              if (abs(fspec(3)).lt.1.0d-15) fspec(3)=0.0d0
              FSPEC(4)=SPECIF(ISOUR+NSOURCE*(IOBSV-1))
              FSPEC(5)=IOBSVZ
              FSPEC(6)=IOBSVY
              FSPEC(7)=IOBSV
              FSPEC(8)=ISOUR
              CALL hfm(NIDPOW-10,FSPEC)

            ENDDO   !IOBSV
          ENDDO   !ISOUR

        ENDIF  !IFOLD

      ENDIF !ISPECINT

+self,if=-mhbook.
      CALL hbookm(NIDPOW,'POWER DENSITY',9
     &  ,'//WAVE',1000,CHPOWF)
+self,if=mhbook.
      CALL hbookm(NIDPOW,'POWER DENSITY',9
     &  ,'//WAVE',nobsv*nsource,CHPOWF)
+self.

      DO ISOUR=1,NSOURCE
        DO IOBSV=1,NOBSV

          IF (IPIN.NE.0) THEN
            IOBSVY=(IOBSV-1)/NOBSVZ+1
            IOBSVZ=IOBSV-NOBSVZ*(IOBSVY-1)
          ELSE
            IOBSVY=1
            IOBSVZ=1
          ENDIF

          FSPEC(1)=OBSV(1,IOBSV)
          FSPEC(2)=OBSV(2,IOBSV)
          FSPEC(3)=OBSV(3,IOBSV)
          if (abs(fspec(2)).lt.1.0d-15) fspec(2)=0.0d0
          if (abs(fspec(3)).lt.1.0d-15) fspec(3)=0.0d0
          FSPEC(4)=SPECPOW(ISOUR+NSOURCE*(IOBSV-1))
          if (ifold.ne.0) then
            FSPEC(5)=SPECPOWf(ISOUR+NSOURCE*(IOBSV-1))
          else
            FSPEC(5)=0.0d0
          endif
          FSPEC(6)=IOBSVZ
          FSPEC(7)=IOBSVY
          FSPEC(8)=IOBSV
          FSPEC(9)=ISOUR
          CALL hfm(NIDPOW,FSPEC)

        ENDDO   !IOBSV
      ENDDO   !ISOUR

+self,if=-mhbook.
      CALL hbookm(NIDPOW+1,'HORIZ. POWER DENSITY (VERT. INT.)',5
     &  ,'//WAVE',1000,CHPOWV)
+self,if=mhbook.
      CALL hbookm(NIDPOW+1,'HORIZ. POWER DENSITY (VERT. INT.)',5
     &  ,'//WAVE',nobsv*nsource,CHPOWV)
+self.

      DO ISOUR=1,NSOURCE
        DO IOBSVZ=1,NOBSVZ

          FSPEC(1)=OBSV(1,IOBSVZ)
          FSPEC(2)=OBSV(3,IOBSVZ)
          if (abs(fspec(3)).lt.1.0d-15) fspec(3)=0.0d0
          FSPEC(3)=SPECPOWV(ISOUR+NSOURCE*(IOBSVZ-1))
          FSPEC(4)=IOBSVZ
          FSPEC(5)=ISOUR
          CALL hfm(NIDPOW+1,FSPEC)

        ENDDO   !IOBSV
      ENDDO   !ISOUR

      IF(IPIN.EQ.0) THEN

        ND=NIDFREQ
+self,if=-mhbook.
        CALL hbookm(ND,'PHOTON FLUX DENSITY',5,
     &    '//WAVE',1000,CHTAGS)
+self,if=mhbook.
        CALL hbookm(ND,'PHOTON FLUX DENSITY',5,
     &    '//WAVE',nobsv*nfreq,CHTAGS)
+self.
        DO IOBSV=1,NOBSV
          DO ifrq=1,NFREQ,IHFREQ
            FSTUPLE(1)=OBSV(1,IOBSV)
            FSTUPLE(2)=OBSV(2,IOBSV)
            FSTUPLE(3)=OBSV(3,IOBSV)
            if (abs(fspec(2)).lt.1.0d-15) fspec(2)=0.0d0
            if (abs(fspec(3)).lt.1.0d-15) fspec(3)=0.0d0
            FSTUPLE(4)=FREQ(ifrq)
            FSTUPLE(5)=SPECTOT(IOBSV+NOBSV*(ifrq-1))
            CALL hfm(ND,FSTUPLE)
          ENDDO   !NFREQ
        ENDDO !IOBSV

      ELSE  !IPIN

+self,if=-mhbook.
        CALL hbookm(NIDFREQP,'PHOTON FLUX THROUGH PINHOLE',20,
     &      '//WAVE',1000,CHTAGSf)
+self,if=mhbook.
        CALL hbookm(NIDFREQP,'PHOTON FLUX THROUGH PINHOLE',20,
     &      '//WAVE',nfreq,CHTAGSf)
+self.
          fstuple=0.0
          DO ifrq=1,NFREQ,IHFREQ
            FSTUPLE(1)=ifrq
            FSTUPLE(2)=FREQ(ifrq)
            FSTUPLE(3)=WFLUXT(ifrq)
            if (ifold.ne.0) FSTUPLE(4)=WFLUXTF(ifrq)
            if (istokes.ne.0) then
              FSTUPLE(5)=wstokes(1,ifrq)
              FSTUPLE(6)=wstokes(2,ifrq)
              FSTUPLE(7)=wstokes(3,ifrq)
              FSTUPLE(8)=wstokes(4,ifrq)
              if (ifold.ne.0) then
                FSTUPLE(9)=wstokesf(1,ifrq)
                FSTUPLE(10)=wstokesf(2,ifrq)
                FSTUPLE(11)=wstokesf(3,ifrq)
                FSTUPLE(12)=wstokesf(4,ifrq)
              endif
              if (iefold.ne.0) then
                FSTUPLE(13)=wstokese(1,ifrq)
                FSTUPLE(14)=wstokese(2,ifrq)
                FSTUPLE(15)=wstokese(3,ifrq)
                FSTUPLE(16)=wstokese(4,ifrq)
              endif
              if (ifold*iefold.ne.0) then
                FSTUPLE(17)=wstokesef(1,ifrq)
                FSTUPLE(18)=wstokesef(2,ifrq)
                FSTUPLE(19)=wstokesef(3,ifrq)
                FSTUPLE(20)=wstokesef(4,ifrq)
              endif
            endif !istokes
            CALL hfm(NIDFREQP,FSTUPLE)
          ENDDO   !NFREQ

        ENDIF !IPIN

+self,if=-mhbook.
        CALL hbookm(NIDFREQP+1,'Photon flux-density for selected point',36,
     &    '//WAVE',1000,CHTAGSfd)
+self,if=mhbook.
        CALL hbookm(NIDFREQP+1,'Photon flux-density for selected point',36,
     &    '//WAVE',nfreq,CHTAGSfd)
+self.
        fstuple=0.0
        DO ifrq=1,NFREQ,IHFREQ
          FSTUPLE(1)=ifrq
          FSTUPLE(2)=FREQ(ifrq)
          FSTUPLE(3)=SPECTOT(ICBRILL+NOBSV*(ifrq-1))
          if (ifold.ne.0) FSTUPLE(4)=SPECTOTF(ICBRILL+NOBSV*(ifrq-1))
          if (istokes.ne.0) then
            FSTUPLE(5)=stokec(1,ifrq)
            FSTUPLE(6)=stokec(2,ifrq)
            FSTUPLE(7)=stokec(3,ifrq)
            FSTUPLE(8)=stokec(4,ifrq)
            if (ifold.ne.0) then
              FSTUPLE(9)=stokecf(1,ifrq)
              FSTUPLE(10)=stokecf(2,ifrq)
              FSTUPLE(11)=stokecf(3,ifrq)
              FSTUPLE(12)=stokecf(4,ifrq)
            endif
            if (iefold.ne.0) then
              FSTUPLE(13)=stokece(1,ifrq)
              FSTUPLE(14)=stokece(2,ifrq)
              FSTUPLE(15)=stokece(3,ifrq)
              FSTUPLE(16)=stokece(4,ifrq)
            endif
            if (ifold*iefold.ne.0) then
              FSTUPLE(17)=stokecef(1,ifrq)
              FSTUPLE(18)=stokecef(2,ifrq)
              FSTUPLE(19)=stokecef(3,ifrq)
              FSTUPLE(20)=stokecef(4,ifrq)
            endif
            if (ibrill.ne.0) then
              FSTUPLE(21)=brillc(1,ifrq)
              FSTUPLE(22)=brillc(2,ifrq)
              FSTUPLE(23)=brillc(3,ifrq)
              FSTUPLE(24)=brillc(4,ifrq)
              if (ifold.ne.0) then
                FSTUPLE(25)=brillcf(1,ifrq)
                FSTUPLE(26)=brillcf(2,ifrq)
                FSTUPLE(27)=brillcf(3,ifrq)
                FSTUPLE(28)=brillcf(4,ifrq)
              endif
              if (iefold.ne.0) then
                FSTUPLE(29)=brillce(1,ifrq)
                FSTUPLE(30)=brillce(2,ifrq)
                FSTUPLE(31)=brillce(3,ifrq)
                FSTUPLE(32)=brillce(4,ifrq)
              endif
              if (ifold*iefold.ne.0) then
                FSTUPLE(33)=brillcef(1,ifrq)
                FSTUPLE(34)=brillcef(2,ifrq)
                FSTUPLE(35)=brillcef(3,ifrq)
                FSTUPLE(36)=brillcef(4,ifrq)
              endif
            endif !ibrill
          endif !istokes
          CALL hfm(NIDFREQP+1,FSTUPLE)
        ENDDO   !NFREQ

        IF (IHFIL.NE.0) THEN
          chtags(2)='muph'
          CALL hbookm(NIDFIL,'PHOTON ABSORPTION COEFF. [M**2/KG]',2,
     &      '//WAVE',1000,CHTAGS)
          chtags(2)='muen'
          CALL hbookm(NIDMUEN,'ENERGY ABSORPTION COEFF. [m**2/kg]'
     &      ,2,'//WAVE',1000,CHTAGS)

          DO ifrq=1,NFREQ,IHFREQ
            FSTUPLE(1)=FREQ(ifrq)
            IF (IFILMUL.EQ.0) THEN
              FSTUPLE(2)=ABSMU(ifrq)
            ELSE
              FSTUPLE(2)=ABSMUTOT(ifrq)
            ENDIF
            CALL hfm(NIDFIL,FSTUPLE)
          ENDDO   !NFREQ

          DO ifrq=1,NFREQ,IHFREQ
            FSTUPLE(1)=FREQ(ifrq)
            FSTUPLE(2)=ABSMUEN(ifrq)
            CALL hfm(NIDMUEN,FSTUPLE)
          ENDDO   !NFREQ

        ENDIF !IHFIL

        IF (IFOLD.NE.0) THEN

          IF (I47.EQ.1) THEN

            if (iroottrees.ge.0) then
              CALL hcdirm(OLDDIR,'R')
            endif

            FILE47='3701_'//FILEHB(1:123)

            if (iroottrees.ge.0) then
              CALL hropenm(47,'SPECF',FILE47,'NQ',1024,ISTAT)
              CALL hcdirm('//SPECF',' ')
            endif

            CALL MHROUT(IDCODE,ICYCLE,' ')

            CALL MHROUT(ICFREQF,ICYCLE,' ')

            CALL MHROUT(IDFREQF,ICYCLE,' ')

            CALL MHROUT(IDSPEC,ICYCLE,' ')
            CALL MHROUT(IDSPEC-1,ICYCLE,' ')
            CALL MHROUT(IDSPEC-2,ICYCLE,' ')
            call hdeletm(idspec)
            call hdeletm(idspec-1)
            call hdeletm(idspec-2)

+self,if=mhbook.
            CALL hbookm(NIDSPECF,'ARRAYS SPECF',18
     &        ,'//SPECF',nobsv*nfreq*nsource,CHSPECF)

          ELSE !I47

            CALL hbookm(NIDSPECF,'ARRAYS SPECF',18
     &        ,'//WAVE',nobsv*nfreq*nsource,CHSPECF)
+self,if=-mhbook.
            CALL hbookm(NIDSPECF,'ARRAYS SPECF',18
     &        ,'//SPECF',1024,CHSPECF)

          ELSE !I47

            CALL hbookm(NIDSPECF,'ARRAYS SPECF',18
     &        ,'//WAVE',1024,CHSPECF)
+self.
          ENDIF !I47

          DO ISOUR=1,NSOURCE
            DO IOBSV=1,NOBSV
              IF (IPIN.NE.0) THEN
                IOBSVY=(IOBSV-1)/NOBSVZ+1
                IOBSVZ=IOBSV-NOBSVZ*(IOBSVY-1)
              ELSE
                IOBSVY=1
                IOBSVZ=1
              ENDIF
              DO ifrq=1,NFREQ,IHFREQ
                FSPEC(1)=ISOUR
                FSPEC(2)=IOBSV
                FSPEC(3)=OBSV(1,IOBSV)
                FSPEC(4)=OBSV(2,IOBSV)
                FSPEC(5)=OBSV(3,IOBSV)
                if (abs(fspec(4)).lt.1.0d-15) fspec(4)=0.0d0
                if (abs(fspec(5)).lt.1.0d-15) fspec(5)=0.0d0
                FSPEC(6)=FREQ(ifrq)
                FSPEC(7)=SPECF(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(ifrq-1)))
                FSPEC(8)=IOBSVZ
                FSPEC(9)=IOBSVY
                FSPEC(10)=ifrq

                IOBFR=IOBSV+NOBSV*(ifrq-1)

                FSPEC(11)=reanor*reaIMA(4,1,IOBFR)
                FSPEC(12)=reanor*reaIMA(4,2,IOBFR)
                FSPEC(13)=reanor*reaIMA(5,1,IOBFR)
                FSPEC(14)=reanor*reaIMA(5,2,IOBFR)

c                FSPEC(15)=reanor*reaIMA(6,1,IOBFR)
c                FSPEC(16)=reanor*reaIMA(6,2,IOBFR)
c                FSPEC(17)=reanor*reaIMA(7,1,IOBFR)
c                FSPEC(18)=reanor*reaIMA(7,2,IOBFR)
c                FSPEC(19)=reanor*reaIMA(8,1,IOBFR)
c                FSPEC(20)=reanor*reaIMA(8,2,IOBFR)

                FSPEC(15)=reanor*reaIMA(9,1,IOBFR)
                FSPEC(16)=reanor*reaIMA(9,2,IOBFR)
                FSPEC(17)=reanor*reaIMA(10,1,IOBFR)
                FSPEC(18)=reanor*reaIMA(10,2,IOBFR)

c                FSPEC(21)=reanor*reaIMA(9,1,IOBFR)
c                FSPEC(22)=reanor*reaIMA(9,2,IOBFR)
c                FSPEC(23)=reanor*reaIMA(10,1,IOBFR)
c                FSPEC(24)=reanor*reaIMA(10,2,IOBFR)

                CALL hfm(NIDSPECF,FSPEC)
              ENDDO   !NFREQ
            ENDDO   !IOBSV
        ENDDO   !ISOUR

        IF (I47.EQ.1) THEN
          CALL MHROUT(NIDSPECF,ICYCLE,' ')
          if (iroottrees.ge.0) then
            CALL hrendm('SPECF')
          endif
          CLOSE(47)
          if (iroottrees.ge.0) then
            CALL hcdirm(OLDDIR,' ')
          endif
        ENDIF !I47

      ENDIF !IFOLD

      IF (ISTOKES.NE.0) THEN

        IF (I47.EQ.1) THEN

          if (iroottrees.ge.0) then
            CALL hcdirm(OLDDIR,'R')
          endif

          FILE47='4700_'//FILEHB(1:123)

          if (iroottrees.ge.0) then
            CALL hropenm(47,'STOKES',FILE47,'NQ',1024,ISTAT)
            CALL hcdirm('//STOKES',' ')
          endif

          CALL MHROUT(IDCODE,ICYCLE,' ')

          CALL MHROUT(ICFRS0,ICYCLE,' ')
          CALL MHROUT(ICFRS1,ICYCLE,' ')
          CALL MHROUT(ICFRS2,ICYCLE,' ')
          CALL MHROUT(ICFRS3,ICYCLE,' ')

          CALL MHROUT(ICFRP,ICYCLE,' ')
          CALL MHROUT(ICFRP1,ICYCLE,' ')
          CALL MHROUT(ICFRP2,ICYCLE,' ')
          CALL MHROUT(ICFRP3,ICYCLE,' ')
          CALL MHROUT(ICFRP23,ICYCLE,' ')

          CALL MHROUT(ICFRG3,ICYCLE,' ')
          CALL MHROUT(ICFRG23,ICYCLE,' ')

          IF (IBRILL.NE.0) THEN
            CALL MHROUT(ICFRB0,ICYCLE,' ')
            CALL MHROUT(ICFRB1,ICYCLE,' ')
            CALL MHROUT(ICFRB2,ICYCLE,' ')
            CALL MHROUT(ICFRB3,ICYCLE,' ')
          ENDIF

          CALL MHROUT(IDFRS0,ICYCLE,' ')
          CALL MHROUT(IDFRS1,ICYCLE,' ')
          CALL MHROUT(IDFRS2,ICYCLE,' ')
          CALL MHROUT(IDFRS3,ICYCLE,' ')

          CALL MHROUT(IDFRP,ICYCLE,' ')
          CALL MHROUT(IDFRP1,ICYCLE,' ')
          CALL MHROUT(IDFRP2,ICYCLE,' ')
          CALL MHROUT(IDFRP3,ICYCLE,' ')
          CALL MHROUT(IDFRP23,ICYCLE,' ')

          CALL MHROUT(IDFRG3,ICYCLE,' ')
          CALL MHROUT(IDFRG23,ICYCLE,' ')

          CALL MHROUT(IDSPEC,ICYCLE,' ')
          CALL MHROUT(IDSPEC-1,ICYCLE,' ')
          CALL MHROUT(IDSPEC-2,ICYCLE,' ')
          call hdeletm(idspec)
          call hdeletm(idspec-1)
          call hdeletm(idspec-2)

+self,if=-mhbook.
          CALL hbookm(NIDSTOK,'STOKES ARRAYS',12
     &      ,'//STOKES',1000,CHSTOK)

        ELSE !I47

          CALL hbookm(NIDSTOK,'STOKES ARRAYS',12
     &      ,'//WAVE',1000,CHSTOK)
+self,if=mhbook.
          CALL hbookm(NIDSTOK,'STOKES ARRAYS',12
     &      ,'//STOKES',nobsv*nfreq*nsource,CHSTOK)

        ELSE !I47

          CALL hbookm(NIDSTOK,'STOKES ARRAYS',12
     &      ,'//WAVE',nobsv*nfreq*nsource,CHSTOK)
+self.
        ENDIF !I47

        DO IOBSV=1,NOBSV
          IF (IPIN.NE.0) THEN
            IOBSVY=(IOBSV-1)/NOBSVZ+1
            IOBSVZ=IOBSV-NOBSVZ*(IOBSVY-1)
          ELSE
            IOBSVY=1
            IOBSVZ=1
          ENDIF
          DO ifrq=1,NFREQ,IHFREQ
            FSPEC(1)=IOBSV
            FSPEC(2)=OBSV(1,IOBSV)
            FSPEC(3)=OBSV(2,IOBSV)
            FSPEC(4)=OBSV(3,IOBSV)
            if (abs(fspec(3)).lt.1.0d-15) fspec(3)=0.0d0
            if (abs(fspec(4)).lt.1.0d-15) fspec(4)=0.0d0
            FSPEC(5)=FREQ(ifrq)
            IOBFR=IOBSV+NOBSV*(ifrq-1)
            FSPEC(6)=STOKES(1,IOBFR)
            FSPEC(7)=STOKES(2,IOBFR)
            FSPEC(8)=STOKES(3,IOBFR)
            FSPEC(9)=STOKES(4,IOBFR)
            FSPEC(10)=IOBSVZ
            FSPEC(11)=IOBSVY
            FSPEC(12)=ifrq
            CALL hfm(NIDSTOK,FSPEC)
            ENDDO   !NFREQ
          ENDDO   !IOBSV

          IF (I47.EQ.1) THEN

            CALL MHROUT(NIDSTOK,ICYCLE,' ')

            if (iroottrees.ge.0) then
              CALL hrendm('STOKES')
            endif
            CLOSE(47)

            if (iroottrees.ge.0) then
              CALL hcdirm(OLDDIR,' ')
            endif

          ENDIF !I47

        ENDIF  !ISTOKES

        IF (ISTOKES.NE.0.AND.IFOLD.EQ.1) THEN

          IF (I47.EQ.1) THEN

            if (iroottrees.ge.0) then
              CALL hcdirm(OLDDIR,'R')
            endif

            FILE47='4701_'//FILEHB(1:123)

            if (iroottrees.ge.0) then
              CALL hropenm(47,'STOKESF',FILE47,'NQ',1024,ISTAT)
              CALL hcdirm('//STOKESF',' ')
            endif

            CALL MHROUT(IDCODE,ICYCLE,' ')

            CALL MHROUT(ICFRS0F,ICYCLE,' ')
            CALL MHROUT(ICFRS1F,ICYCLE,' ')
            CALL MHROUT(ICFRS2F,ICYCLE,' ')
            CALL MHROUT(ICFRS3F,ICYCLE,' ')

            CALL MHROUT(ICFRPF,ICYCLE,' ')
            CALL MHROUT(ICFRP1F,ICYCLE,' ')
            CALL MHROUT(ICFRP2F,ICYCLE,' ')
            CALL MHROUT(ICFRP3F,ICYCLE,' ')
            CALL MHROUT(ICFRP23F,ICYCLE,' ')

            CALL MHROUT(ICFRG3F,ICYCLE,' ')
            CALL MHROUT(ICFRG23F,ICYCLE,' ')

            IF (IBRILL.NE.0) THEN
              CALL MHROUT(ICFRB0F,ICYCLE,' ')
              CALL MHROUT(ICFRB1F,ICYCLE,' ')
              CALL MHROUT(ICFRB2F,ICYCLE,' ')
              CALL MHROUT(ICFRB3F,ICYCLE,' ')
            ENDIF

            CALL MHROUT(IDFRS0F,ICYCLE,' ')
            CALL MHROUT(IDFRS1F,ICYCLE,' ')
            CALL MHROUT(IDFRS2F,ICYCLE,' ')
            CALL MHROUT(IDFRS3F,ICYCLE,' ')

            CALL MHROUT(IDFRPF,ICYCLE,' ')
            CALL MHROUT(IDFRP1F,ICYCLE,' ')
            CALL MHROUT(IDFRP2F,ICYCLE,' ')
            CALL MHROUT(IDFRP3F,ICYCLE,' ')
            CALL MHROUT(IDFRP23F,ICYCLE,' ')

            CALL MHROUT(IDFRG3F,ICYCLE,' ')
            CALL MHROUT(IDFRG23F,ICYCLE,' ')

            CALL MHROUT(IDSPEC,ICYCLE,' ')
            CALL MHROUT(IDSPEC-1,ICYCLE,' ')
            CALL MHROUT(IDSPEC-2,ICYCLE,' ')
            call hdeletm(idspec)
            call hdeletm(idspec-1)
            call hdeletm(idspec-2)

+self,if=-mhbook.
            CALL hbookm(NIDSTOKF,'STOKES ARRAYS (FOLDED)',12
     &        ,'//STOKESF',1000,CHSTOK)

          ELSE !I47

            CALL hbookm(NIDSTOKF,'STOKES ARRAYS (FOLDED)',12
     &        ,'//WAVE',1000,CHSTOK)
+self,if=mhbook.
            CALL hbookm(NIDSTOKF,'STOKES ARRAYS (FOLDED)',12
     &        ,'//STOKESF',nobsv*nfreq*nsource,CHSTOK)

          ELSE !I47

            CALL hbookm(NIDSTOKF,'STOKES ARRAYS (FOLDED)',12
     &        ,'//WAVE',nobsv*nfreq*nsource,CHSTOK)
+self.
          ENDIF !I47

          DO IOBSV=1,NOBSV
            IF (IPIN.NE.0) THEN
              IOBSVY=(IOBSV-1)/NOBSVZ+1
              IOBSVZ=IOBSV-NOBSVZ*(IOBSVY-1)
            ELSE
              IOBSVY=1
              IOBSVZ=1
            ENDIF
            DO ifrq=1,NFREQ,IHFREQ
              FSPEC(1)=IOBSV
              FSPEC(2)=OBSV(1,IOBSV)
              FSPEC(3)=OBSV(2,IOBSV)
              FSPEC(4)=OBSV(3,IOBSV)
              if (abs(fspec(3)).lt.1.0d-15) fspec(3)=0.0d0
              if (abs(fspec(4)).lt.1.0d-15) fspec(4)=0.0d0
              FSPEC(5)=FREQ(ifrq)
              IOBFR=IOBSV+NOBSV*(ifrq-1)
              FSPEC(6)=STOKESF(1,IOBFR)
              FSPEC(7)=STOKESF(2,IOBFR)
              FSPEC(8)=STOKESF(3,IOBFR)
              FSPEC(9)=STOKESF(4,IOBFR)
              FSPEC(10)=IOBSVZ
              FSPEC(11)=IOBSVY
              FSPEC(12)=ifrq
              CALL hfm(NIDSTOKF,FSPEC)
            ENDDO   !NFREQ
          ENDDO   !IOBSV

          IF (I47.EQ.1) THEN

            CALL MHROUT(NIDSTOKF,ICYCLE,' ')

            if (iroottrees.ge.0) then
              CALL hrendm('STOKESF')
            endif
            CLOSE(47)

            if (iroottrees.ge.0) then
              CALL hcdirm(OLDDIR,' ')
            endif

        ENDIF !I47

        ENDIF  !ISTOKES,FOLD

        IF (ISTOKES.NE.0.AND.IEFOLD.ne.0) THEN

          IF (I47.EQ.1) THEN

            if (iroottrees.ge.0) then
              CALL hcdirm(OLDDIR,'R')
            endif

            FILE47='4702_'//FILEHB(1:123)

            if (iroottrees.ge.0) then
              CALL hropenm(47,'STOKESE',FILE47,'NQ',1024,ISTAT)
              CALL hcdirm('//STOKESE',' ')
            endif

            CALL MHROUT(IDCODE,ICYCLE,' ')

            CALL MHROUT(ICFRS0E,ICYCLE,' ')
            CALL MHROUT(ICFRS1E,ICYCLE,' ')
            CALL MHROUT(ICFRS2E,ICYCLE,' ')
            CALL MHROUT(ICFRS3E,ICYCLE,' ')

            CALL MHROUT(ICFRPE,ICYCLE,' ')
            CALL MHROUT(ICFRP1E,ICYCLE,' ')
            CALL MHROUT(ICFRP2E,ICYCLE,' ')
            CALL MHROUT(ICFRP3E,ICYCLE,' ')
            CALL MHROUT(ICFRP23E,ICYCLE,' ')

            CALL MHROUT(ICFRG3E,ICYCLE,' ')
            CALL MHROUT(ICFRG23E,ICYCLE,' ')

            IF (IBRILL.NE.0) THEN
              CALL MHROUT(ICFRB0E,ICYCLE,' ')
              CALL MHROUT(ICFRB1E,ICYCLE,' ')
              CALL MHROUT(ICFRB2E,ICYCLE,' ')
              CALL MHROUT(ICFRB3E,ICYCLE,' ')
            ENDIF

            CALL MHROUT(IDFRS0E,ICYCLE,' ')
            CALL MHROUT(IDFRS1E,ICYCLE,' ')
            CALL MHROUT(IDFRS2E,ICYCLE,' ')
            CALL MHROUT(IDFRS3E,ICYCLE,' ')

            CALL MHROUT(IDFRPE,ICYCLE,' ')
            CALL MHROUT(IDFRP1E,ICYCLE,' ')
            CALL MHROUT(IDFRP2E,ICYCLE,' ')
            CALL MHROUT(IDFRP3E,ICYCLE,' ')
            CALL MHROUT(IDFRP23E,ICYCLE,' ')

            CALL MHROUT(IDFRG3E,ICYCLE,' ')
            CALL MHROUT(IDFRG23E,ICYCLE,' ')

            CALL MHROUT(IDSPEC,ICYCLE,' ')
            CALL MHROUT(IDSPEC-1,ICYCLE,' ')
            CALL MHROUT(IDSPEC-2,ICYCLE,' ')
            call hdeletm(idspec)
            call hdeletm(idspec-1)
            call hdeletm(idspec-2)

+self,if=-mhbook.
            CALL hbookm(NIDSTOKE,'STOKES ARRAYS (E-FOLDED)',12
     &        ,'//STOKESE',1000,CHSTOK)

          ELSE !I47

            CALL hbookm(NIDSTOKE,'STOKES ARRAYS (E-FOLDED)',12
     &        ,'//WAVE',1000,CHSTOK)
+self,if=mhbook.
            CALL hbookm(NIDSTOKE,'STOKES ARRAYS (E-FOLDED)',12
     &        ,'//STOKESE',nobsv*nfreq*nsource,CHSTOK)

          ELSE !I47

            CALL hbookm(NIDSTOKE,'STOKES ARRAYS (E-FOLDED)',12
     &        ,'//WAVE',nobsv*nfreq*nsource,CHSTOK)
+self.
          ENDIF !I47

          DO IOBSV=1,NOBSV
            IF (IPIN.NE.0) THEN
              IOBSVY=(IOBSV-1)/NOBSVZ+1
              IOBSVZ=IOBSV-NOBSVZ*(IOBSVY-1)
            ELSE
              IOBSVY=1
              IOBSVZ=1
            ENDIF
            DO ifrq=1,NFREQ,IHFREQ
              FSPEC(1)=IOBSV
              FSPEC(2)=OBSV(1,IOBSV)
              FSPEC(3)=OBSV(2,IOBSV)
              FSPEC(4)=OBSV(3,IOBSV)
              if (abs(fspec(3)).lt.1.0d-15) fspec(3)=0.0d0
              if (abs(fspec(4)).lt.1.0d-15) fspec(4)=0.0d0
              FSPEC(5)=FREQ(ifrq)
              IOBFR=IOBSV+NOBSV*(ifrq-1)
              FSPEC(6)=STOKESE(1,IOBFR)
              FSPEC(7)=STOKESE(2,IOBFR)
              FSPEC(8)=STOKESE(3,IOBFR)
              FSPEC(9)=STOKESE(4,IOBFR)
              FSPEC(10)=IOBSVZ
              FSPEC(11)=IOBSVY
              FSPEC(12)=ifrq
              CALL hfm(NIDSTOKE,FSPEC)
            ENDDO   !NFREQ
          ENDDO   !IOBSV

          IF (I47.EQ.1) THEN

            CALL MHROUT(NIDSTOKE,ICYCLE,' ')

            if (iroottrees.ge.0) then
              CALL hrendm('STOKESE')
            endif
            CLOSE(47)

            if (iroottrees.ge.0) then
              CALL hcdirm(OLDDIR,' ')
            endif

          ENDIF !I47

        ENDIF  !ISTOKES,EFOLD

        IF (ISTOKES.NE.0.AND.IEFOLD.ne.0.AND.IFOLD.EQ.1) THEN

          IF (I47.EQ.1) THEN

            if (iroottrees.ge.0) then
              CALL hcdirm(OLDDIR,'R')
            endif

            FILE47='4703_'//FILEHB(1:123)

            if (iroottrees.ge.0) then
              CALL hropenm(47,'STOKESEF',FILE47,'NQ',1024,ISTAT)
              CALL hcdirm('//STOKESEF',' ')
            endif

            CALL MHROUT(IDCODE,ICYCLE,' ')

            CALL MHROUT(ICFRS0EF,ICYCLE,' ')
            CALL MHROUT(ICFRS1EF,ICYCLE,' ')
            CALL MHROUT(ICFRS2EF,ICYCLE,' ')
            CALL MHROUT(ICFRS3EF,ICYCLE,' ')

            CALL MHROUT(ICFRPEF,ICYCLE,' ')
            CALL MHROUT(ICFRP1EF,ICYCLE,' ')
            CALL MHROUT(ICFRP2EF,ICYCLE,' ')
            CALL MHROUT(ICFRP3EF,ICYCLE,' ')
            CALL MHROUT(ICFRP23EF,ICYCLE,' ')

            CALL MHROUT(ICFRG3EF,ICYCLE,' ')
            CALL MHROUT(ICFRG23EF,ICYCLE,' ')

            IF (IBRILL.NE.0) THEN
              CALL MHROUT(ICFRB0EF,ICYCLE,' ')
              CALL MHROUT(ICFRB1EF,ICYCLE,' ')
              CALL MHROUT(ICFRB2EF,ICYCLE,' ')
              CALL MHROUT(ICFRB3EF,ICYCLE,' ')
            ENDIF

            CALL MHROUT(IDFRS0EF,ICYCLE,' ')
            CALL MHROUT(IDFRS1EF,ICYCLE,' ')
            CALL MHROUT(IDFRS2EF,ICYCLE,' ')
            CALL MHROUT(IDFRS3EF,ICYCLE,' ')

            CALL MHROUT(IDFRPEF,ICYCLE,' ')
            CALL MHROUT(IDFRP1EF,ICYCLE,' ')
            CALL MHROUT(IDFRP2EF,ICYCLE,' ')
            CALL MHROUT(IDFRP3EF,ICYCLE,' ')
            CALL MHROUT(IDFRP23EF,ICYCLE,' ')

            CALL MHROUT(IDFRG3EF,ICYCLE,' ')
            CALL MHROUT(IDFRG23EF,ICYCLE,' ')

            CALL MHROUT(IDSPEC,ICYCLE,' ')
            CALL MHROUT(IDSPEC-1,ICYCLE,' ')
            CALL MHROUT(IDSPEC-2,ICYCLE,' ')
            call hdeletm(idspec)
            call hdeletm(idspec-1)
            call hdeletm(idspec-2)

+self,if=-mhbook.
            CALL hbookm(NIDSTOKEF,'STOKES ARRAYS (EMIT, E-FOLDED)',12
     &        ,'//STOKESEF',1000,CHSTOK)

          ELSE !I47

            CALL hbookm(NIDSTOKEF,'STOKES ARRAYS (EMIT, E-FOLDED)',12
     &        ,'//WAVE',1000,CHSTOK)
+self,if=mhbook.
            CALL hbookm(NIDSTOKEF,'STOKES ARRAYS (EMIT, E-FOLDED)',12
     &        ,'//STOKESEF',nobsv*nfreq*nsource,CHSTOK)

          ELSE !I47

            CALL hbookm(NIDSTOKEF,'STOKES ARRAYS (EMIT, E-FOLDED)',12
     &        ,'//WAVE',nobsv*nfreq*nsource,CHSTOK)
+self.
          ENDIF !I47

          DO IOBSV=1,NOBSV
            IF (IPIN.NE.0) THEN
              IOBSVY=(IOBSV-1)/NOBSVZ+1
              IOBSVZ=IOBSV-NOBSVZ*(IOBSVY-1)
            ELSE
              IOBSVY=1
              IOBSVZ=1
            ENDIF
            DO ifrq=1,NFREQ,IHFREQ
              FSPEC(1)=IOBSV
              FSPEC(2)=OBSV(1,IOBSV)
              FSPEC(3)=OBSV(2,IOBSV)
              FSPEC(4)=OBSV(3,IOBSV)
              if (abs(fspec(3)).lt.1.0d-15) fspec(3)=0.0d0
              if (abs(fspec(4)).lt.1.0d-15) fspec(4)=0.0d0
              FSPEC(5)=FREQ(ifrq)
              IOBFR=IOBSV+NOBSV*(ifrq-1)
              FSPEC(6)=STOKESEF(1,IOBFR)
              FSPEC(7)=STOKESEF(2,IOBFR)
              FSPEC(8)=STOKESEF(3,IOBFR)
              FSPEC(9)=STOKESEF(4,IOBFR)
              FSPEC(10)=IOBSVZ
              FSPEC(11)=IOBSVY
              FSPEC(12)=ifrq
              CALL hfm(NIDSTOKEF,FSPEC)
            ENDDO   !NFREQ
          ENDDO   !IOBSV

          IF (I47.EQ.1) THEN

            CALL MHROUT(NIDSTOKEF,ICYCLE,' ')

            if (iroottrees.ge.0) then
              CALL hrendm('STOKESEF')
            endif
            CLOSE(47)

            if (iroottrees.ge.0) then
              CALL hcdirm(OLDDIR,' ')
            endif

          ENDIF !I47

        ENDIF  !ISTOKES,EFOLD,IFOLD

        deallocate(phfill)

        if(ibunch.ne.0.and.icluster.gt.0) call wpampntup

        RETURN
      END
+DECK,HFREQC.
*CMZ :  4.00/13 07/12/2021  18.47.10  by  Michael Scheer
*CMZ :  3.03/02 07/12/2015  17.18.10  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.66/03 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.65/01 08/10/2009  09.58.11  by  Michael Scheer
*CMZ :  2.63/05 14/09/2009  15.19.42  by  Michael Scheer
*CMZ :  2.61/03 27/03/2007  13.23.57  by  Michael Scheer
*CMZ :  2.53/03 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.53/02 25/01/2005  18.15.44  by  Michael Scheer
*CMZ :  2.52/13 09/12/2004  13.09.09  by  Michael Scheer
*CMZ :  2.52/00 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.48/04 17/03/2004  13.47.13  by  Michael Scheer
*CMZ :  2.40/02 14/03/2002  15.46.20  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  14.22.45  by  Michael Scheer
*CMZ :  2.16/07 01/09/2000  14.36.07  by  Michael Scheer
*CMZ :  2.16/04 28/06/2000  17.43.04  by  Michael Scheer
*CMZ :  2.16/01 15/06/2000  15.47.11  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  16.17.53  by  Michael Scheer
*CMZ :  2.13/04 24/01/2000  16.35.38  by  Michael Scheer
*CMZ :  2.13/03 10/01/2000  17.32.03  by  Michael Scheer
*CMZ :  2.13/00 02/12/99  13.23.58  by  Michael Scheer
*CMZ :  1.03/00 16/01/98  11.16.49  by  Michael Scheer
*CMZ :  1.00/00 24/09/97  10.31.27  by  Michael Scheer
*CMZ : 00.01/06 14/02/95  10.59.52  by  Michael Scheer
*CMZ : 00.01/05 31/01/95  17.02.40  by  Michael Scheer
*CMZ : 00.01/04 30/01/95  13.06.10  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  16.43.29  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.52.08  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.39  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE HFREQC
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,OBSERVF90U.

C--- HISTOGRAMS FOR SPECTRA OF SINGLE OBSERVATION POINTS OR PINHOLE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,whbook.
+seq,pawcmn.

+SEQ,SPECT.
+SEQ,FREQS.
+SEq,observf90.

      IF (IUNIT.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING SR HFREQC: NO HISTOGRAMS FOR IUNIT.NE.0'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)
        RETURN
      ENDIF

c      IF (IFREQ2P.LE.1) THEN
c
c        WRITE(LUNGFO,*)
c        WRITE(LUNGFO,*)'*** WARNING SR HFREQC ***'
c        WRITE(LUNGFO,*)'PARAMETER IFREQ2P .LE. 1, NO HISTOGRAM BOOKED'
c        WRITE(LUNGFO,*)
c
c      ELSE IF (IFREQ2P.EQ.2) THEN
      IF (IFREQ2P.EQ.2) THEN

        call hfreqc2

      ELSE  !IFREQ2P

        call hfreqc1

      ENDIF !IFREQ2P

      RETURN
      END
+DECK,HISEND.
*CMZ :  4.01/00 09/01/2023  20.52.32  by  Michael Scheer
*CMZ :  4.00/14 22/12/2021  13.31.15  by  Michael Scheer
*CMZ :  4.00/13 20/12/2021  16.32.19  by  Michael Scheer
*CMZ :  4.00/11 22/04/2021  18.57.39  by  Michael Scheer
*CMZ :  4.00/06 09/12/2019  14.35.09  by  Michael Scheer
*CMZ :  4.00/04 23/08/2019  15.23.40  by  Michael Scheer
*CMZ :  3.03/00 17/08/2015  10.09.12  by  Michael Scheer
*CMZ :  3.02/05 08/06/2015  13.40.53  by  Michael Scheer
*CMZ :  3.02/04 18/03/2015  09.33.03  by  Michael Scheer
*CMZ :  3.02/00 24/09/2014  11.52.00  by  Michael Scheer
*CMZ :  3.01/07 23/06/2014  13.59.37  by  Michael Scheer
*CMZ :  3.01/05 13/06/2014  11.42.17  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.13.36  by  Michael Scheer
*CMZ :  2.70/06 03/01/2013  13.47.56  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  15.31.59  by  Michael Scheer
*CMZ :  2.70/00 08/11/2012  12.29.49  by  Michael Scheer
*CMZ :  2.68/05 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.68/02 26/06/2012  11.55.39  by  Michael Scheer
*CMZ :  2.67/01 01/03/2012  16.47.26  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  13.32.15  by  Michael Scheer
*CMZ :  2.63/05 03/08/2009  08.58.29  by  Michael Scheer
*CMZ :  2.41/13 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  1.00/00 24/09/97  17.11.48  by  Michael Scheer
*CMZ : 00.01/09 06/10/95  10.20.31  by  Michael Scheer
*CMZ : 00.01/08 18/07/95  10.46.26  by  Michael Scheer
*CMZ : 00.01/04 30/01/95  16.00.05  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.29  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE HISEND
+seq,gplhint.

C--- TERMINATES HBOOK AND WRITE HISTOS TO FILE

+SEQ,TRACKF90U.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,REARGF90U.
+SEQ,WFOLDF90U.
+SEQ,AFREQF90U.
+SEQ,AMPLIF90U.

      use bunchmod
+self,if=mhbook.
      use mhbook_mod
+self.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,TRACK.
+SEQ,OPTIC.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,SPECDIP.
+SEQ,COLLI.
+SEq,wfoldf90.
+SEQ,WUSEM.
+SEQ,AMPLI.
+SEQ,USERVAR.
+SEQ,PHYCON.
+seq,whbook.
+seq,pawcmn.
+SEq,phasef90.
+seq,ntuple2.
+seq,datetime.
+seq,wvers.

      INTEGER ICYCLE,ISCRATCH

      INTEGER I
      integer :: iline=0
      BYTE I1(96)

      CHARACTER(32) LINE_1,LINE_2,LINE_3
      CHARACTER(1) LINE32_1(32),LINE32_2(32),LINE32_3(32)
      CHARACTER(96) C96,EMPTY
      CHARACTER(1) C1(96)

      EQUIVALENCE(I1,C1,C96)
      EQUIVALENCE(LINE_1,LINE32_1)
      EQUIVALENCE(LINE_2,LINE32_2)
      EQUIVALENCE(LINE_3,LINE32_3)

      COMMON/CLINEc/LINE_1,LINE_2,LINE_3

      integer jday,jtim,ius

      DATA EMPTY/' '/

      fillp=-9999.

      call date_and_time(dtday,dttime,dtzone,idatetime)
      read(dtday(3:8),*)jday
      read(dttime(1:6),*)jtim

      fillp(1)=dmyenergy
      fillp(2)=dmycur
      if (ispec.ne.0) then
        fillp(3)=ipin
        fillp(4)=ipincirc
        fillp(5)=pincen(1)
        fillp(6)=pincen(2)
        fillp(7)=pincen(3)
        fillp(8)=pinw
        fillp(9)=pinh
        fillp(10)=pinr
        if (ipin.eq.3) then
          fillp(11)=mpinzorig
          fillp(12)=mpinyorig
        else
          fillp(11)=mpinz
          fillp(12)=mpiny
        endif
        fillp(13)=mpinr
        fillp(14)=mpinphi
        fillp(15)=icbrill
        fillp(16)=obsv(1,icbrill)
        fillp(17)=obsv(2,icbrill)
        fillp(18)=obsv(3,icbrill)
      endif
      fillp(19)=phcenx
      fillp(20)=bsigz(1)
      fillp(21)=bsigy(1)
      fillp(22)=bsigzp(1)
      fillp(23)=bsigyp(1)
      fillp(24)=espread
      if (ispec.ne.0) then
        fillp(25)=ifreq2p
        fillp(26)=nintfreq
        fillp(27)=freqlow
        fillp(28)=freqhig
      endif
      fillp(29)=ispec
      if (ispec.ne.0) then
        fillp(30)=ispecmode
        fillp(31)=ispecdip
        fillp(32)=nlpoi
        fillp(33)=banwid
      endif
      fillp(34)=ibunch
      fillp(35)=nbunch
      fillp(36)=neinbunch
      if (ispec.ne.0) then
        fillp(37)=iampli
      endif
      fillp(38)=ieneloss
      fillp(39)=ifold
      fillp(40)=iefold
      fillp(41)=icode
      fillp(42)=jday
      fillp(43)=jtim
      fillp(44)=wversion
      fillp(45)=istokes
      fillp(46)=nobsvy
      fillp(47)=nobsvz
      fillp(48)=wall(1)
      fillp(49)=wall(2)
      fillp(50)=xabsorb
      fillp(51)=zabsorb(1)
      fillp(52)=zabsorb(2)
      if (ispec.ne.0) then
        fillp(53)=ibrill
      endif
      fillp(54)=ihbeta
      fillp(55)=kampli

      call hfm(nid222,fillp)

      do ius=1,ntupusp
        fillu(ius)=user(ius)
      enddo

      call hfm(nid223,fillu)

      CALL MHROUT(0,ICYCLE,' ')

      if (iroottrees.lt.0) return

      IF (IHOUTP.NE.0) THEN

        CALL hbntm(IDOUTP,'OUTPUT FILE WAVE.OUT',' ')
        CALL hbnamcm(IDOUTP,'LINE',LINE_1
     &    ,'LINE_1:C*32,LINE_2:C*32,LINE_3:C*32')

        REWIND(LUNGFO)

100     C96=EMPTY
        READ (LUNGFO,'(A96)',END=90) C96

C- FILL CWN BUFFER

        DO I=1,32
          LINE32_1(I)=C1(I)
          LINE32_2(I)=C1(I+32)
          LINE32_3(I)=C1(I+64)
        ENDDO

        CALL hfntm(IDOUTP)
        iline=iline+1
        GOTO 100

90      CONTINUE

+self,if=-nohbook.
        call hrout(idoutp,icycle,chopt)
+self.,if=-nohbook.
+self,if=mshhbook.
        call msh_hrout(int8(idoutp))
+self.

        DO ISCRATCH=1,ICYCLE-1
          CALL HSCRm(IDOUTP,ISCRATCH,' ')
        ENDDO

        CALL hdeletnomh(IDOUTP)

        rewind(lungfo)

+self,if=mhbook.
        write(luns_mh(kfile_mh),'(a)')" ! ------------------------------------------------"
        write(luns_mh(kfile_mh),'(a)')"                   16                    4    ! id and kind of histogram of Ntuple"
        write(luns_mh(kfile_mh),'(a)')"          20     ! length of title"
        write(luns_mh(kfile_mh),'(a)')"OUTPUT FILE WAVE.OUT"
        write(luns_mh(kfile_mh),'(a)')"                    6           3          11    ! length of pathname, number of variables, and length of variable names"
        write(luns_mh(kfile_mh),'(a)')"//WAVE"
        write(luns_mh(kfile_mh),'(a)')"LINE_1:C*32"
        write(luns_mh(kfile_mh),'(a)')"LINE_2:C*32"
        write(luns_mh(kfile_mh),'(a)')"LINE_3:C*32"
        write(luns_mh(kfile_mh),*)iline," ! number of entries"

        do i=1,iline
          read (lungfo,'(a96)') c96
          write(luns_mh(kfile_mh),'(a)')c96
        enddo
+self.

        close(lungfo)

        open(unit=lungfo,file=filegfo,status='old',access='append')

      ENDIF !IHOUTP

      IF (IHINDEX.NE.0) then
        open(unit=99,file='wave_index.his')
        CALL HOUTPUm(99)
        CALL HLDIRm(' ','IT')
        close(99)
        call houtpum(6)
+self,if=linux.
c obsolete          call system('mv fort.99 wave_index.his')
+self.
        print*,' '
        print*,'      Index of histograms written to wave_index.his'
        print*,' '
      endif

      if (iroottrees.ge.0) then
        CALL hrendm('WAVE')
      endif

      CLOSE(LUNHB)

+self,if=mhbook.
        call mh_end
+self.

      RETURN
      END
+DECK,HISINI.
*CMZ :  4.01/02 14/05/2023  13.16.19  by  Michael Scheer
*CMZ :  4.01/00 09/01/2023  20.53.38  by  Michael Scheer
*CMZ :  4.00/15 08/04/2022  17.00.19  by  Michael Scheer
*CMZ :  4.00/14 31/12/2021  08.37.37  by  Michael Scheer
*CMZ :  4.00/13 20/12/2021  16.34.10  by  Michael Scheer
*CMZ :  4.00/11 22/04/2021  19.01.32  by  Michael Scheer
*CMZ :  4.00/06 09/12/2019  14.36.37  by  Michael Scheer
*CMZ :  4.00/04 21/08/2019  14.35.31  by  Michael Scheer
*CMZ :  3.05/10 13/08/2018  14.40.26  by  Michael Scheer
*CMZ :  3.03/02 26/02/2016  10.43.50  by  Michael Scheer
*CMZ :  3.03/00 17/08/2015  10.03.05  by  Michael Scheer
*CMZ :  3.02/06 08/06/2015  13.41.37  by  Michael Scheer
*CMZ :  3.02/05 07/04/2015  15.57.59  by  Michael Scheer
*CMZ :  3.02/04 18/03/2015  09.26.30  by  Michael Scheer
*CMZ :  3.02/02 16/10/2014  10.56.27  by  Michael Scheer
*CMZ :  3.02/00 24/09/2014  11.52.00  by  Michael Scheer
*CMZ :  3.01/07 23/06/2014  13.59.37  by  Michael Scheer
*CMZ :  3.01/06 20/06/2014  16.49.38  by  Michael Scheer
*CMZ :  3.01/05 13/06/2014  11.46.51  by  Michael Scheer
*CMZ :  3.00/00 18/09/2013  12.33.23  by  Michael Scheer
*CMZ :  2.70/08 14/01/2013  17.46.40  by  Michael Scheer
*CMZ :  2.70/07 14/01/2013  16.55.40  by  Michael Scheer
*CMZ :  2.70/06 03/01/2013  13.55.49  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  15.10.55  by  Michael Scheer
*CMZ :  2.70/03 14/12/2012  16.42.06  by  Michael Scheer
*CMZ :  2.70/00 08/11/2012  12.18.50  by  Michael Scheer
*CMZ :  2.68/05 16/10/2012  17.25.52  by  Michael Scheer
*CMZ :  2.68/02 26/06/2012  11.55.39  by  Michael Scheer
*CMZ :  2.68/01 29/05/2012  16.43.49  by  Michael Scheer
*CMZ :  2.67/06 23/05/2012  15.50.53  by  Michael Scheer
*CMZ :  2.67/04 11/05/2012  11.51.59  by  Michael Scheer
*CMZ :  2.67/02 09/05/2012  09.56.14  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  13.01.28  by  Michael Scheer
*CMZ :  2.66/12 24/06/2010  12.50.52  by  Michael Scheer
*CMZ :  2.66/07 10/03/2010  09.23.32  by  Michael Scheer
*CMZ :  2.66/06 24/11/2009  09.57.50  by  Michael Scheer
*CMZ :  2.65/02 23/09/2009  08.34.24  by  Michael Scheer
*CMZ :  2.61/06 12/04/2007  13.36.22  by  Michael Scheer
*CMZ :  2.61/03 27/03/2007  13.00.05  by  Michael Scheer
*CMZ :  2.52/16 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.48/04 17/03/2004  13.52.09  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.36/00 06/11/2001  16.31.58  by  Michael Scheer
*CMZ :  2.17/00 02/11/2000  16.12.50  by  Michael Scheer
*CMZ :  2.16/08 20/10/2000  11.44.49  by  Michael Scheer
*CMZ :  2.16/04 26/06/2000  16.57.45  by  Michael Scheer
*CMZ :  2.13/11 20/03/2000  12.32.30  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.26.25  by  Michael Scheer
*CMZ :  2.12/00 27/05/99  10.11.30  by  Michael Scheer
*CMZ :  2.10/01 24/02/99  12.04.52  by  Michael Scheer
*CMZ :  1.04/00 16/10/98  10.54.26  by  Michael Scheer
*CMZ :  1.03/06 29/09/98  14.00.01  by  Michael Scheer
*CMZ :  1.03/03 27/03/98  13.37.41  by  Michael Scheer
*CMZ :  1.00/00 24/09/97  10.31.28  by  Michael Scheer
*CMZ : 00.02/00 25/11/96  14.46.50  by  Michael Scheer
*CMZ : 00.01/08 18/07/95  11.55.34  by  Michael Scheer
*CMZ : 00.01/07 10/03/95  13.17.24  by  Michael Scheer
*CMZ : 00.01/04 30/01/95  11.29.57  by  Michael Scheer
*CMZ : 00.00/05 29/04/94  19.50.41  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  18.06.58  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.28  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE HISINI
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SELF.

      use bunchmod
+self,if=mhbook.
      use mhbook_mod
+self.
      use clustermod

C--- INITIALIZES HBOOK

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+seq,whbook.
+seq,pawcmn.
+SEQ,KLOTZ.
+SEq,phasef90.
+seq,sourcef90.
+SEq,observf90.
+SEQ,photon.
+SEQ,uservar.
+seq,ntuple2.
+seq,freqs.

      INTEGER ISTAT,ICYCLE,ISCRATCH,LREC

      INTEGER IGL,I,J,iopen,last,iline,iblank
      BYTE I1(96)

      CHARACTER(32) LINE_1,LINE_2,LINE_3
      CHARACTER(1) LINE32_1(32),LINE32_2(32),LINE32_3(32)
      CHARACTER(96) C96,EMPTY,cwavein(5000)
      CHARACTER(1) C1(96)
      CHARACTER(4) CHTAGS(41),chtagsg1(100) !if you change the dimension of chtags here, check all routines with NIDBUNCH
      character(4) chtagsus(ntupusp)

      EQUIVALENCE(I1,C1,C96)
      EQUIVALENCE(LINE_1,LINE32_1)
      EQUIVALENCE(LINE_2,LINE32_2)
      EQUIVALENCE(LINE_3,LINE32_3)

      DATA EMPTY/' '/
      data iopen/0/,icycle/0/

      COMMON/CLINEc/LINE_1,LINE_2,LINE_3

      data chtags/'ibun','iel','nel'
     &  ,'xbun','xi','yi','zi','ypi','zpi'
     &  ,'xe','ye','ze','ype','zpe','ei','ee','xobs','yobs','zobs',
     &  'iene','ener','spec','s0','s1','s2','s3','pow','isou','te',
     &  'exr','exi','eyr','eyi','ezr','ezi',
     &  'bxr','bxi','byr','byi','bzr','bzi'
     &  /

      data chtagsus /
     &  'u1  ',
     &  'u2  ',
     &  'u3  ',
     &  'u4  ',
     &  'u5  ',
     &  'u6  ',
     &  'u7  ',
     &  'u8  ',
     &  'u9  ',
     &  'u10 '
     &  /

      character(4) chtagsip(ntupip) /
     &  'ebea',
     &  'curr',
     &  'ipin',
     &  'icir',
     &  'pinx',
     &  'piny',
     &  'pinz',
     &  'pinw',
     &  'pinh',
     &  'pinr',
     &  'mpiz',
     &  'mpiy',
     &  'mpir',
     &  'mpip',
     &  'icbr',
     &  'selx',
     &  'sely',
     &  'selz',
     &  'phax',
     &  'sigz',
     &  'sigy',
     &  'sgzp',
     &  'sgyp',
     &  'espr',
     &  'if2p',
     &  'nfrq',
     &  'flow',
     &  'fhig',
     &  'ispe',
     &  'ispm',
     &  'idip',
     &  'nlpo',
     &  'bw',
     &  'ibun',
     &  'nbun',
     &  'neib',
     &  'iamp',
     &  'ielo',
     &  'ifol',
     &  'iefo',
     &  'irun',
     &  'idat',
     &  'itim',
     &  'vers',
     &  'isto',
     &  'noby',
     &  'nobz',
     &  'wal1',
     &  'wal2',
     &  'xabs',
     &  'zab1',
     &  'zab2',
     &  'ibri',
     &  'ibet',
     &  'kamp'
     &  /

      IF (IHISINI_C.gt.0) RETURN

      VMX=0.

      IDCODE=1
      IDINPUT=12+ABS(IHINPUT)
      IDOUTP=16

      IDTRACKZ=1100  !TRAJECTORY (Z-COORDINATE)
      IDTRACKY=1200  !TRAJECTORY (Y-COORDINATE)

      IDTRCKSZ=1100  !TRAJECTORY OF SOURCE POINTS (Z-COORDINATE)
      IDTRCKSY=1200  !TRAJECTORY OF SOURCE POINTS (Y-COORDINATE)

      IDBX=2100   !MAGNETIC FIELD (X-COMPONENT)
      IDBY=2200   !MAGNETIC FIELD (Y-COMPONENT)
      IDBZ=2300   !MAGNETIC FIELD (Z-COMPONENT)

      IDSBX=2100  !MAGNETIC FIELD OF SOURCE (X-COMPONENT)
      IDSBY=2200  !MAGNETIC FIELD OF SOURCE (Y-COMPONENT)
      IDSBZ=2300  !MAGNETIC FIELD OF SOURCE (Z-COMPONENT)

      IDAX=4100   !MAGNETIC VECTOR POTENTIAL (X-COMPONENT)
      IDAY=4200   !MAGNETIC VECTOR POTENTIAL (Y-COMPONENT)
      IDAZ=4300   !MAGNETIC VECTOR POTENTIAL (Z-COMPONENT)

      IDBETAH= 3100  !HORIZONTAL BETA-FUNCTION, NUMERICALLY
      IDBETAV= 3200  !VERTICAL BETA-FUNCTION, NUMERICALLY
      IDBETHPC=3110  !HORIZONTAL BETA-FUNCTION, ANALYTICALLY WITH
C            ! BETA=(BETA0+X**2/BETA0)*(COS(THETA))**2
      IDBETHP=3120  !HORIZONTAL BETA-FUNCTION, ANALYTICALLY WITH
C           ! BETA=(BETA0+X**2/BETA0)
      IDBETAPH=3300  !DERIVATIVE OF HORIZONTAL BETA-FUNCTION
      IDBPHPC= 3310  !DERIVATIVE OF
C            !HORIZONTAL BETA-FUNCTION, ANALYTICALLY WITH
C            ! BETA=(BETA0+X**2/BETA0)*(COS(THETA))**2
      IDBPHP= 3320  !DERIVATIVE OF
C            !HORIZONTAL BETA-FUNCTION, ANALYTICALLY WITH
C            ! BETA=(BETA0+X**2/BETA0)
      IDBETAPV=3400  !DERIVATIVE OF VERTICAL BETA-FUNCTION
      IDETA=   3450  !DISPERSION
      IDHS=    3800  !H(s), CHROMATIC VARIABLE
      IDHX=    3801  !H(x), CHROMATIC VARIABLE
      IDHSR3=  3802  !H(s)/abs(rho)**3, NUMERICALLY
      IDHXR3=  3803  !H(x)/abs(rho)**3, ANALYTICALLY WITH PARABOLIC ANSATZ

      IDSPEC=11000   !INTENSITY IN PINHOLE
      IDSPECH=12000  !INTENSITY IN ORBIT PLANE
      IDSPECV=13000  !INTENSITY VERTICAL TO ORBIT PLANE

      IDSPECF= 21000 !FOLDED INTENSITY IN PINHOLE
      IDSPECFH=22000 !FOLDED INTENSITY IN ORBIT PLANE
      IDSPECFV=23000 !FOLDED INTENSITY VERTICAL TO ORBIT PLANE
      IDFOLFNZ=24000 !HORIZONTAL FOLDING FUNCTION
      IDFOLFNY=25000 !VERTICAL FOLDING FUNCTION

      IDSTOKES0=31000   !STOKES S0 IN PINHOLE
      IDSTOKES1=31100   !STOKES S1 IN PINHOLE
      IDSTOKES2=31200   !STOKES S2 IN PINHOLE
      IDSTOKES3=31300   !STOKES S3 IN PINHOLE

      IDSTOKFS0=41000   !STOKES S0 IN PINHOLE (FOLDED)
      IDSTOKFS1=41100   !STOKES S1 IN PINHOLE (FOLDED)
      IDSTOKFS2=41200   !STOKES S2 IN PINHOLE (FOLDED)
      IDSTOKFS3=41300   !STOKES S3 IN PINHOLE (FOLDED)


      IDFREQ=48000  !SPECTRUM
      IDFREQF=49000  !FOLDED SPECTRUM

      IDFRS0=50000   !SPECTRUM OF S0
      IDFRS1=51000   !SPECTRUM OF S1
      IDFRS2=52000   !SPECTRUM OF S2
      IDFRS3=53000   !SPECTRUM OF S3
      IDFRP =54000   !SPECTRUM OF P
      IDFRP1=54500   !SPECTRUM OF P1
      IDFRP2=55000   !SPECTRUM OF P2
      IDFRP3=56000   !SPECTRUM OF P3
      IDFRP23=57000   !SPECTRUM OF P23
      IDFRG3=58000   !SPECTRUM OF S0*P3**2
      IDFRG23=59000   !SPECTRUM OF S0*P23**2

      IDFRS0F=60000  !FOLDED SPECTRUM OF S0
      IDFRS1F=61000  !FOLDED SPECTRUM OF S1
      IDFRS2F=62000  !FOLDED SPECTRUM OF S2
      IDFRS3F=63000  !FOLDED SPECTRUM OF S3
      IDFRPF =64000  !FOLDED SPECTRUM OF P
      IDFRP1F=64500  !FOLDED SPECTRUM OF P1
      IDFRP2F=65000  !FOLDED SPECTRUM OF P2
      IDFRP3F=66000  !FOLDED SPECTRUM OF P3
      IDFRP23F=67000  !FOLDED SPECTRUM OF P23
      IDFRG3F=68000  !FOLDED SPECTRUM OF S0*P3**2
      IDFRG23F=69000  !FOLDED SPECTRUM OF S0*P23**2

      IDFRS0E=70000 !SPECTRUM OF S0, E-FOLDED
      IDFRS1E=71000 !SPECTRUM OF S1, E-FOLDED
      IDFRS2E=72000 !SPECTRUM OF S2, E-FOLDED
      IDFRS3E=73000 !SPECTRUM OF S3, E-FOLDED
      IDFRPE =74000 !SPECTRUM OF P, E-FOLDED
      IDFRP1E=74500 !SPECTRUM OF P1, E-FOLDED
      IDFRP2E=75000 !SPECTRUM OF P2, E-FOLDED
      IDFRP3E=76000 !SPECTRUM OF P3, E-FOLDED
      IDFRP23E=77000 !SPECTRUM OF P23, E-FOLDED
      IDFRG3E=78000 !SPECTRUM OF S0*P3**2, E-FOLDED
      IDFRG23E=79000 !SPECTRUM OF S0*P23**2, E-FOLDED

      IDFRS0EF=80000  !FOLDED SPECTRUM OF S0, E-FOLDED
      IDFRS1EF=81000  !FOLDED SPECTRUM OF S1, E-FOLDED
      IDFRS2EF=82000  !FOLDED SPECTRUM OF S2, E-FOLDED
      IDFRS3EF=83000  !FOLDED SPECTRUM OF S3, E-FOLDED
      IDFRPEF =84000  !FOLDED SPECTRUM OF P , E-FOLDED
      IDFRP1EF=84500  !FOLDED SPECTRUM OF P1, E-FOLDED
      IDFRP2EF=85000  !FOLDED SPECTRUM OF P2, E-FOLDED
      IDFRP3EF=86000  !FOLDED SPECTRUM OF P3, E-FOLDED
      IDFRP23EF=87000  !FOLDED SPECTRUM OF P23, E-FOLDED
      IDFRG3EF=88000  !FOLDED SPECTRUM OF S0*P3**2, E-FOLDED
      IDFRG23EF=89000  !FOLDED SPECTRUM OF S0*P23**2, E-FOLDED

      ICFREQ=148000  !SPECTRUM
      ICFREQF=149000  !FOLDED SPECTRUM

      ICFRS0=150000   !CENTRAL SPECTRUM OF S0
      ICFRS1=151000   !CENTRAL SPECTRUM OF S1
      ICFRS2=152000   !CENTRAL SPECTRUM OF S2
      ICFRS3=153000   !CENTRAL SPECTRUM OF S3
      ICFRP =154000   !CENTRAL SPECTRUM OF P
      ICFRP1=154500   !CENTRAL SPECTRUM OF P1
      ICFRP2=155000   !CENTRAL SPECTRUM OF P2
      ICFRP3=156000   !CENTRAL SPECTRUM OF P3
      ICFRP23=157000   !CENTRAL SPECTRUM OF P23
      ICFRG3=158000   !CENTRAL SPECTRUM OF S0*P3**2
      ICFRG23=159000   !CENTRAL SPECTRUM OF S0*P23**2

      ICFRS0F=160000  !FOLDED CENTRAL SPECTRUM OF S0
      ICFRS1F=161000  !FOLDED CENTRAL SPECTRUM OF S1
      ICFRS2F=162000  !FOLDED CENTRAL SPECTRUM OF S2
      ICFRS3F=163000  !FOLDED CENTRAL SPECTRUM OF S3
      ICFRP1F=164500  !FOLDED CENTRAL SPECTRUM OF P1
      ICFRPF =164000  !FOLDED CENTRAL SPECTRUM OF P
      ICFRP2F=165000  !FOLDED CENTRAL SPECTRUM OF P2
      ICFRP3F=166000  !FOLDED CENTRAL SPECTRUM OF P3
      ICFRP23F=167000  !FOLDED CENTRAL SPECTRUM OF P23
      ICFRG3F=168000  !FOLDED CENTRAL SPECTRUM OF S0*P3**2
      ICFRG23F=169000  !FOLDED CENTRAL SPECTRUM OF S0*P23**2

      ICFRS0E=170000 !CENTRAL SPECTRUM OF S0, E-FOLDED
      ICFRS1E=171000 !CENTRAL SPECTRUM OF S1, E-FOLDED
      ICFRS2E=172000 !CENTRAL SPECTRUM OF S2, E-FOLDED
      ICFRS3E=173000 !CENTRAL SPECTRUM OF S3, E-FOLDED
      ICFRPE =174000 !CENTRAL SPECTRUM OF P, E-FOLDED
      ICFRP1E=174500 !CENTRAL SPECTRUM OF P, E-FOLDED
      ICFRP2E=175000 !CENTRAL SPECTRUM OF P2, E-FOLDED
      ICFRP3E=176000 !CENTRAL SPECTRUM OF P3, E-FOLDED
      ICFRP23E=177000 !CENTRAL SPECTRUM OF P23, E-FOLDED
      ICFRG3E=178000 !CENTRAL SPECTRUM OF S0*P3**2, E-FOLDED
      ICFRG23E=179000 !CENTRAL SPECTRUM OF S0*P23**2, E-FOLDED

      ICFRS0EF=180000  !FOLDED CENTRAL SPECTRUM OF S0, E-FOLDED
      ICFRS1EF=181000  !FOLDED CENTRAL SPECTRUM OF S1, E-FOLDED
      ICFRS2EF=182000  !FOLDED CENTRAL SPECTRUM OF S2, E-FOLDED
      ICFRS3EF=183000  !FOLDED CENTRAL SPECTRUM OF S3, E-FOLDED
      ICFRPEF =184000  !FOLDED CENTRAL SPECTRUM OF P , E-FOLDED
      ICFRP1EF=184500  !FOLDED CENTRAL SPECTRUM OF P1, E-FOLDED
      ICFRP2EF=185000  !FOLDED CENTRAL SPECTRUM OF P2, E-FOLDED
      ICFRP3EF=186000  !FOLDED CENTRAL SPECTRUM OF P3, E-FOLDED
      ICFRP23EF=187000  !FOLDED CENTRAL SPECTRUM OF P23, E-FOLDED
      ICFRG3EF=188000  !FOLDED CENTRAL SPECTRUM OF S0*P3**2, E-FOLDED
      ICFRG23EF=189000  !FOLDED CENTRAL SPECTRUM OF S0*P23**2, E-FOLDED

      ICFRB0=190000   !CENTRAL BRILLIANCE
      ICFRB1=191000   !CENTRAL BRILLIANCE
      ICFRB2=192000   !CENTRAL BRILLIANCE
      ICFRB3=193000   !CENTRAL BRILLIANCE

      ICFRB0E=194000   !CENTRAL BRILLIANCE
      ICFRB1E=195000   !CENTRAL BRILLIANCE
      ICFRB2E=196000   !CENTRAL BRILLIANCE
      ICFRB3E=197000   !CENTRAL BRILLIANCE

      ICFRB0F=190500   !CENTRAL BRILLIANCE
      ICFRB1F=191500   !CENTRAL BRILLIANCE
      ICFRB2F=192500   !CENTRAL BRILLIANCE
      ICFRB3F=193500   !CENTRAL BRILLIANCE

      ICFRB0EF=194500   !CENTRAL BRILLIANCE
      ICFRB1EF=195500   !CENTRAL BRILLIANCE
      ICFRB2EF=196500   !CENTRAL BRILLIANCE
      ICFRB3EF=197500   !CENTRAL BRILLIANCE

      NIDTRACK=10   !NTUPLE CONTAINS ARRAY WTRA
      NIDMINI=11   !NTUPLE CONTAINS MINI-TRAJECTORIES
      NIDSOURCE=12   !NTUPLE CONTAINS INTEGRANTS OF SOURCES
      NIDTRCKG=20  !NTUPLE CONTAINS ARRAY WTRA
      NIDPHANA=21  !NTUPLE PHASE ERROR ANALYSIS
      nidbunch=30  !ntuple of bunch electrons

      NIDTRAC=500   !X,XP,Y,YP AT START AND STOP OF TRAJECTORIES IN SR OPTI
      NIDFREQ=3500  !SPECTRUM FOR SINGLE OBSERVATION POINTS, NTUPLE
      NIDFREQP=3600  !SPECTRUM FOR PINHOLE, NTUPLE
      NIDSPEC=3700  !SPECTRUM-ARRAY FOR ALL OBSERVATION POINTS, NTUPLE
      NIDSPECRPHI=5700  !SPECTRUM-ARRAY FOR ALL OBSERVATION POINTS, NTUPLE
      NIDSPECF=3701  !FOLDED SPECTRUM-ARRAY FOR ALL OBSERVATION POINTS, NTUPLE
      NIDPOW=2000  !NTUPLE FOR POWER-DENSITY
      NIDSTOK=4700  !STOKES-ARRAYS FOR ALL OBSERVATION POINTS, NTUPLE
      NIDSTOKF=4701  !FOLDED STOKES-ARRAYS FOR ALL OBSERVATION POINTS, NTUPLE
      NIDSTOKE=4702  !E-FOLDED STOKES-ARRAYS FOR ALL OBSERVATION POINTS, NTUPLE
      NIDSTOKEF=4703  !FOLDED AND E-FOLDED STOKES-ARRAYS FOR ALL OBSERVATION POINTS, NTUPLE

      IDPOWER=40000  !POWER DENSITY ALONG BEAMLINE

      NIDFIL=5000    !PHOTO ABSORPTION COEFFICIENTS OF ABSORBING FILTER
      NIDMUEN=5001   !ENERGY ABSORPTION COEFFICIENTS
      NIDPHASE=6000   !PHASE
      IDPHASE=206000 !PHASE
      NIDGEO=6100   !PHASE SPACE FROM GEOMETRICAL OPTIC
      IDSEL=206100   !PHASE SPACE RATIO

C*** THIS 600 IS USED IN SR BMESSINI AS 599 (600-1), CHANGE ACCORDINGLY
C    IF NECESSARY
      NIDBPOLY=600 !field map and fitted field of SR BPOLY3DFIT

C---    THE PARAMETER NDPAWCP INQUIRES THE WORK SPACE FOR HBOOK
C     HISTOGRAM 1 IS USED TO IDENTIFY THE HISTOGRAM FILE, IT CONTAINS
C     THE RUN NUMBER OF WAVE

c      IF (IHLIMIT_C.EQ.0..and.iroottrees.ge.0) then
      IF (IHLIMIT_C.EQ.0) THEN
+self,if=mhbook.
        CALL hlimitm(mhbookp)
        if (icluster.lt.0) then
          open(newunit=nscr7777,file='msh_hbook_ntuple_7777.scr')
          open(newunit=nscr3600,file='msh_hbook_ntuple_3600.scr')
          open(newunit=nscr3601,file='msh_hbook_ntuple_3601.scr')
          open(newunit=nscr3700,file='msh_hbook_ntuple_3700.scr')
          open(newunit=nscr4600,file='msh_hbook_ntuple_4600.scr')
          open(newunit=nscr4700,file='msh_hbook_ntuple_4700.scr')
          open(newunit=nscr30,file='msh_hbook_ntuple_30.scr')
        endif
+self,if=-mhbook.
        CALL hlimitm(NDPAWC)
        IQUEST(10)=2**17
        LREC=1024
+self.
        IHLIMIT_C=1
      ENDIF

      if (iopen.eq.0) then
        if (iroottrees.ge.0) then
          CALL hropenm(LUNHB,'WAVE',FILEHB,'NQ',LREC,ISTAT)
          CALL htitlem(CODE)
        endif
        last=len_trim(CODE)
        call hbook1m(IDCODE,CODE(1:last)//'',2,0.5,2.5,0.)
        CALL hfillm(IDCODE,1.,0.,0.0d0)
        CALL hfillm(IDCODE,2.,0.,ABS(dble(ICODE)))
        CALL MHROUT(IDCODE,ICYCLE,' ')
        iopen=1
      endif

      if (ihisini_c.eq.-2) then
        idg1=777777
        nidphotons=7777
        chtagsg1(1)='trck'
        chtagsg1(2)='step'
        chtagsg1(3)='x'
        chtagsg1(4)='y'
        chtagsg1(5)='z'
        chtagsg1(6)='pxe'
        chtagsg1(7)='pye'
        chtagsg1(8)='pze'
        chtagsg1(9)='ee'
        chtagsg1(10)='pxg'
        chtagsg1(11)='pyg'
        chtagsg1(12)='pzg'
        chtagsg1(13)='eg'
        chtagsg1(14)='ec'
+self,if=-mhbook.
        call hbookm(nidphotons,
     &    'quantum fluctuation photons',14,'//WAVE',1024,chtagsg1)
+self,if=mhbook.
        call hbookm(nidphotons,
     &    'quantum fluctuation photons',14,'//WAVE',2**16,chtagsg1)
+self.
        ihisini_c=-1
        return
      endif

      if (ihisini_c.gt.0) return

      nid222=222
      CALL hbookm(nid222,'Input Parameters',ntupip,'//WAVE',1024,CHTAGSip)
      nid223=223
      CALL hbookm(nid223,'Variables of user common block',ntupusp,
     &  '//WAVE',1024,CHTAGSus)

      if (iroottrees.ge.0) then
        IF (IHINPUT.NE.0) then
          CALL hbntm(IDINPUT,'INPUT FILE WAVE.IN',' ')
        endif
        IF (ABS(IHINPUT).EQ.1) THEN
          CALL hbnamcm(IDINPUT,'LINE',
     &      LINE_1,'LINE_1:C*32')
        ELSE IF (ABS(IHINPUT).EQ.2) THEN
          CALL hbnamcm(IDINPUT,'LINE',
     &      LINE_1,'LINE_1:C*32,LINE_2:C*32')
        ELSE IF (ABS(IHINPUT).EQ.3) THEN
          CALL hbnamcm(IDINPUT,'LINE',
     &      LINE_1,'LINE_1:C*32,LINE_2:C*32,LINE_3:C*32')
        ELSE
          GOTO 999
        ENDIF
      endif
C        OPEN(UNIT=LUNGFI,FILE=FILEI,STATUS='OLD',READONLY)

      REWIND(LUNGFI)

      iline=0
100   C96=EMPTY

      IF (IHINPUT.ne.0) THEN

        READ (LUNGFI,'(A96)',END=90) C96

C- SCAN LINES FOR COMMENTS ETC.

        IGL=96
        DO I=1,96
          IF (C1(I).EQ.'=') THEN
            IGL=I
            GOTO 9
          ENDIF
        ENDDO

9       CONTINUE

        DO I=1,IGL-1
          IF (C1(I).EQ.'') GOTO 15
          IF (C1(I).EQ.'!'.and.ihinput.lt.0) GOTO 100
        ENDDO

15      CONTINUE

C- REPLACE TAB BY ONE BLANK

        iblank=1
        DO I=1,96
          IF (I1(I).EQ.9) C1(I)=' '
          if (c1(i).ne.' ') iblank=0
        ENDDO

        if (iblank.eq.1) goto 100

C- SUPRESS MULTIPLE BLANKS

        J=0
        C1(96)=' '
        DO I=1,96-1
          IF (C1(I).NE.' '.OR.C1(I+1).NE.' ') THEN
            J=J+1
            C1(J)=C1(I)
          ENDIF
        ENDDO

        do i=j+1,96
          C1(i)=' '
        enddo

C- FILL CWN BUFFER

20      CONTINUE

        DO I=1,32
          LINE32_1(I)=C1(I)
          LINE32_2(I)=C1(I+32)
          LINE32_3(I)=C1(I+64)
        ENDDO

        if(iroottrees.ge.0) CALL hfntm(IDINPUT)

        iline=iline+1

+self,if=mhbook.
        if (abs(ihinput).eq.1) then
          cwavein(iline)=trim(line_1)
        else if (abs(ihinput).eq.2) then
          cwavein(iline)=trim(line_1) // trim(line_2)
        else if (abs(ihinput).eq.3) then
          cwavein(iline)=trim(line_1) // trim(line_2) // trim(line_3)
        endif
+self.

        GOTO 100

90      CONTINUE

+self,if=-nohbook.
        call hrout(idinput,icycle,chopt)
+self.,if=-nohbook.
+self,if=mshhbook.
        call msh_hrout(int8(idinput))
+self.
c        CALL MHROUT(IDINPUT,ICYCLE,' ')

        if (iroottrees.ge.0) then
          DO ISCRATCH=1,ICYCLE-1
            CALL HSCRm(IDINPUT,ISCRATCH,' ')
          ENDDO
          CALL hdeletnomh(IDINPUT)
        endif

        CLOSE(LUNGFI)

+self,if=mhbook.
        write(luns_mh(kfile_mh),'(a)')" ! ------------------------------------------------"
        write(luns_mh(kfile_mh),'(a)')"                   15                    4    ! id and kind of histogram of Ntuple"
        write(luns_mh(kfile_mh),'(a)')"          18    ! length of title"
        write(luns_mh(kfile_mh),'(a)')"INPUT FILE WAVE.IN"
        if (abs(ihinput).eq.1) then
          write(luns_mh(kfile_mh),'(a)')"                    6           1          11    ! length of pathname, number of variables, and length of variable names"
          write(luns_mh(kfile_mh),'(a)')"//WAVE"
          write(luns_mh(kfile_mh),'(a)')"LINE_1:C*32"
        else if (abs(ihinput).eq.2) then
          write(luns_mh(kfile_mh),'(a)')"                    6           2          11    ! length of pathname, number of variables, and length of variable names"
          write(luns_mh(kfile_mh),'(a)')"//WAVE"
          write(luns_mh(kfile_mh),'(a)')"LINE_1:C*32"
          write(luns_mh(kfile_mh),'(a)')"LINE_2:C*32"
        else if (abs(ihinput).eq.3) then
          write(luns_mh(kfile_mh),'(a)')"                    6           3          11    ! length of pathname, number of variables, and length of variable names"
          write(luns_mh(kfile_mh),'(a)')"//WAVE"
          write(luns_mh(kfile_mh),'(a)')"LINE_1:C*32"
          write(luns_mh(kfile_mh),'(a)')"LINE_2:C*32"
          write(luns_mh(kfile_mh),'(a)')"LINE_3:C*32"
        endif
        write(luns_mh(kfile_mh),*)iline," ! number of entries"

        do i=1,iline
          if (abs(ihinput).eq.1) then
            write(luns_mh(kfile_mh),'(a)') cwavein(i)(1:32)
          else if (abs(ihinput).eq.2) then
            write(luns_mh(kfile_mh),'(a)') cwavein(i)(1:64)
          else if (abs(ihinput).eq.3) then
            write(luns_mh(kfile_mh),'(a)') cwavein(i)(1:96)
          endif
        enddo
+self.

      ENDIF !IHINPUT.GT.0


999   CONTINUE

      nidbunch=30
      if (ihbunch.ne.0.and.ispec.ne.0) then
+self,if=-mhbook.
        call hbookm(nidbunch,'beam electrons',41,'//WAVE',1024,chtags)
+self,if=mhbook.
        call hbookm(nidbunch,'beam electrons',41,'//WAVE',nbunch*neinbunch*nintfreq,
     &    chtags)
+self.
      endif

      IF (XSTARTH.EQ.9999.) XSTARTH=XSTART
      IF (XSTOPH.EQ.9999.)  XSTOPH=XSTOP

      IHISINI_C=1

      RETURN
      END
+DECK,hphase2.
*CMZ :  4.01/05 31/12/2023  11.56.26  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.13.36  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.70/00 11/12/2012  12.00.31  by  Michael Scheer
*CMZ :  2.68/05 28/09/2012  09.13.47  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  10.38.43  by  Michael Scheer
*CMZ :  2.49/00 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.16/00 08/06/2000  12.11.00  by  Michael Scheer
*CMZ :  1.03/06 23/09/98  17.08.00  by  Michael Scheer
*CMZ :  1.00/00 24/09/97  10.31.28  by  Michael Scheer
*CMZ : 00.01/06 13/02/95  13.14.40  by  Michael Scheer
*CMZ : 00.01/04 30/01/95  10.41.22  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  16.53.40  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.52.27  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.49  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE HPHASE2(ID,TIT,FILL)
+seq,gplhint.

C--- STORE RESULTS OF SPECTRUM CALCULATION ON HISTOGRAM FILE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,FREQS.
+SEq,phasef90.
+seq,whbook.
+seq,pawcmn.

      INTEGER IOB,IOBZ,IOBY,ID
      INTEGER ICYCLE,ICYCLE1

      REAL*4 ZMIN,ZMAX,YMIN,YMAX,ZFILL,YFILL,DZ,DY
      REAL*8 FILL(MPHASEZ*MPHASEY)

      CHARACTER(80) TIT,TIT1

      IF (mphaseZ.GT.1.AND.mphaseY.GT.1) THEN

        DZ=PHWID/(nphaseZ-1)
        DY=PHHIG/(nphaseY-1)
        ZMIN=PHCENZ-(mphasez-1)*dz/2.0d0
        ZMax=PHCENZ+(mphasez-1)*dz/2.0d0
        yMIN=PHCENy-(mphasey-1)*dy/2.0d0
        yMax=PHCENy+(mphasey-1)*dy/2.0d0

        call hbook2m(ID,TIT,mphaseZ,ZMIN,ZMAX,mphaseY,YMIN,YMAX,VMX)
        TIT1=TIT(1:40)//'(HORIZONTAL CUT)'
        call hbook1m(ID-1,TIT1,mphaseZ,ZMIN,ZMAX,VMX)
        TIT1=TIT(1:40)//'(VERTICAL CUT)'
        call hbook1m(ID-2,TIT1,mphaseY,YMIN,YMAX,VMX)

        IOB=0
        DO IOBY=1,mphaseY
          DO IOBZ=1,mphaseZ

            ZFILL=PHCENZ-PHWID/2.+(IOBZ-1)*DZ
            YFILL=PHCENY-PHHIG/2.+(IOBY-1)*DY
            IOB=IOB+1

            CALL hfillm(ID,ZFILL,YFILL,FILL(IOB))
            IF (IOBZ.EQ.mphaseZ/2+1) CALL hfillm(ID-2,YFILL,0.,FILL(IOB))
            IF (IOBY.EQ.mphaseY/2+1) CALL hfillm(ID-1,ZFILL,0.,FILL(IOB))

          ENDDO !IOBZ
        ENDDO !IOBY

        ICYCLE1=ICYCLE
        CALL MHROUT(ID,ICYCLE,' ')
        CALL hdeletm(ID)
        CALL MHROUT(ID-1,ICYCLE1,' ')
        ICYCLE1=ICYCLE
        CALL hdeletm(ID-1)
        CALL MHROUT(ID-2,ICYCLE1,' ')
        CALL hdeletm(ID-2)

      ELSE IF (mphaseZ.GT.1) THEN

        DZ=PHWID/(mphaseZ-1)
        ZMIN=PHCENZ-PHWID/2.-DZ/2.
        ZMAX=PHCENZ+PHWID/2.+DZ/2.

        TIT1=TIT(1:40)//'(HORIZONTAL CUT)'
        call hbook1m(ID-1,TIT1,mphaseZ,ZMIN,ZMAX,VMX)

        DO IOBZ=1,mphaseZ
          ZFILL=PHCENZ-PHWID/2.+(IOBZ-1)*DZ
          CALL hfillm(ID-1,ZFILL,0.,FILL(IOBZ))
        ENDDO !IOBZ

        CALL MHROUT(ID-1,ICYCLE,' ')
        CALL hdeletm(ID-1)

      ELSE IF (mphaseY.GT.1) THEN

        DY=PHHIG/(mphaseY-1)
        YMIN=PHCENY-PHHIG/2.-DY/2.
        YMAX=PHCENY+PHHIG/2.+DY/2.

        TIT1=TIT(1:40)//'(VERTICAL CUT)'
        call hbook1m(ID-2,TIT1,mphaseY,YMIN,YMAX,VMX)

        DO IOBY=1,mphaseY
            YFILL=PHCENY-PHHIG/2.+(IOBY-1)*DY
            CALL hfillm(ID-2,YFILL,0.,FILL(IOBY))
        ENDDO !IOBY

        CALL MHROUT(ID-2,ICYCLE,' ')
        CALL hdeletm(ID-2)

      ENDIF !mphaseZ, mphaseY

      RETURN
      END
+DECK,HSOURCE.
*CMZ :  4.00/15 13/02/2022  18.53.40  by  Michael Scheer
*CMZ :  4.00/14 30/12/2021  15.41.22  by  Michael Scheer
*CMZ :  4.00/13 07/12/2021  18.47.10  by  Michael Scheer
*CMZ :  3.02/03 23/10/2014  13.43.13  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.10.30  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.68/05 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  10.38.43  by  Michael Scheer
*CMZ :  2.64/05 02/09/2009  09.39.09  by  Michael Scheer
*CMZ :  2.41/10 12/08/2009  08.49.28  by  Michael Scheer
*CMZ :  2.20/01 20/11/2000  16.56.14  by  Michael Scheer
*CMZ :  2.17/00 03/11/2000  14.52.16  by  Michael Scheer
*CMZ :  2.16/08 25/10/2000  12.21.53  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.16/03 16/06/2000  12.15.50  by  Michael Scheer
*CMZ :  2.13/00 02/12/99  11.42.16  by  Michael Scheer
*CMZ :  1.03/03 27/03/98  13.56.06  by  Michael Scheer
*CMZ :  1.00/00 24/09/97  10.31.28  by  Michael Scheer
*CMZ : 00.01/06 13/02/95  10.25.06  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.52.22  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.31  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE HSOURCE
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SOURCEF90U.
+SELF.
+SEQ,TRACKF90U,IF=F90.

C--- HISTOGRAM OF SOURCES

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,whbook.
+seq,pawcmn.

+SEQ,TRACK.
+seq,sourcef90.

      INTEGER NTUPP,IROI,IROIO,nallo
      PARAMETER (NTUPP=10)
      REAL*8 TUP(NTUPP)

      CHARACTER(3) CHTAGS(NTUPP)
      data chtags/'x','y','z','bx','by','bz','is','ir','roi','bou'/

      INTEGER I,NBIN,ISOUR
      INTEGER ICYCLE
      REAL*4 XI,XE,X
      REAL*8 Z,Y,BX,BY,BZ

      nallo=nco/ihtrsmp+1024
      CALL hbookm(NIDMINI,'SOURCES',NTUPP,'//WAVE',nallo,CHTAGS)

      IROIO=0
      DO ISOUR=1,NSOURCE
        DO I=1,NCO
          X=WTRA(1,1,I)
          IF (X.GE.SOURCEA(1,1,ISOUR).AND.X.LE.SOURCEE(1,1,ISOUR)
     &        .AND.
     &        X.GE.XIANF.AND.X.LE.XIEND) THEN
            TUP(1)=WTRA(1,1,I)
            TUP(2)=WTRA(2,1,I)
            TUP(3)=WTRA(3,1,I)
            TUP(4)=WTRA(1,3,I)
            TUP(5)=WTRA(2,3,I)
            TUP(6)=WTRA(3,3,I)
            TUP(7)=ISOUR
            TUP(8)=0.0
            DO IROI=1,NROIA-1
              IF (TUP(1).GE.ROIX(IROI).AND.TUP(1).LT.ROIX(IROI+1)) THEN
                TUP(8)=IROI
                TUP(9)=ROIP(IROI)
                GOTO 10
              ENDIF
            ENDDO
10          IF (IROI.NE.IROIO) THEN
              TUP(10)=1.0d0
            ELSE
              TUP(10)=0.0d0
            ENDIF
            CALL hfm(NIDMINI,TUP)
            IROIO=IROI
          ENDIF
        ENDDO !I
      ENDDO   !ISOUR

      IF (IHTRACKM.LT.0) RETURN

      IF(NSOURCE.GT.99) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN HSOURCE ***'
        WRITE(LUNGFO,*)'TO MUCH SOURCES, HISTOGRAM IDs COLLIDE'
        WRITE(LUNGFO,*)'CHANGE HISTOGRAM IDENTIFIER AND THIS CHECK'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN HSOURCE ***'
        WRITE(6,*)'TO MUCH SOURCES, HISTOGRAM IDs COLLIDE'
        WRITE(6,*)'CHANGE HISTOGRAM IDENTIFIER AND THIS CHECK'
        WRITE(6,*)
        STOP
      ENDIF !NSOURCE

      IF (XSTARTH.EQ.9999.) THEN
        XI=WTRA(1,1,1)-DS0/2.
      ELSE
        XI=XSTARTH-DS0/2.
      ENDIF !XSTARTH

      IF (XSTOPH.EQ.9999.) THEN
        XE=WTRA(1,1,NCO)+DS0/2.
      ELSE
        XE=XSTOPH+DS0/2.
      ENDIF !XSTARTH
      NBIN=(XE-XI)/DS0
      XE=DS0*NBIN+XI

C--- LOOP OVER ALL SOURCES

      DO ISOUR=1,NSOURCE

      call hbook1m(IDTRCKSZ+ISOUR,'Z OF SOURCE',NBIN,XI,XE,VMX)
      call hbook1m(IDTRCKSY+ISOUR,'Y OF SOURCE',NBIN,XI,XE,VMX)

      call hbook1m(IDSBX+ISOUR,'Bx OF SOURCE',NBIN,XI,XE,VMX)
      call hbook1m(IDSBY+ISOUR,'By OF SOURCE',NBIN,XI,XE,VMX)
      call hbook1m(IDSBZ+ISOUR,'Bz OF SOURCE',NBIN,XI,XE,VMX)

      XI=WTRA(1,1,1)-DS0
      DO I=1,NCO
          X=DS0*I+XI
          IF (X.GE.SOURCEA(1,1,ISOUR).AND.X.LE.SOURCEE(1,1,ISOUR)) THEN

             Y=WTRA(2,1,I)
             Z=WTRA(3,1,I)
             BX=WTRA(1,3,I)
             BY=WTRA(2,3,I)
             BZ=WTRA(3,3,I)

          ELSE    !X

             Y=-9.
             Z=-9.
             BX=-99.
             BY=-99.
             BZ=-99.
          ENDIF   !X

          CALL hfillm(IDTRCKSZ+ISOUR,X,0.,Z)
          CALL hfillm(IDTRCKSY+ISOUR,X,0.,Y)
          CALL hfillm(IDSBX+ISOUR,X,0.,BX)
          CALL hfillm(IDSBY+ISOUR,X,0.,BY)
          CALL hfillm(IDSBZ+ISOUR,X,0.,BZ)

      ENDDO !I

        CALL MHROUT(IDTRCKSZ+ISOUR,ICYCLE,' ')
        CALL MHROUT(IDTRCKSY+ISOUR,ICYCLE,' ')
        CALL MHROUT(IDSBX+ISOUR,ICYCLE,' ')
        CALL MHROUT(IDSBY+ISOUR,ICYCLE,' ')
        CALL MHROUT(IDSBZ+ISOUR,ICYCLE,' ')

      CALL hdeletm(IDTRCKSZ+ISOUR)
      CALL hdeletm(IDTRCKSY+ISOUR)
      CALL hdeletm(IDSBX+ISOUR)
      CALL hdeletm(IDSBY+ISOUR)
      CALL hdeletm(IDSBZ+ISOUR)

      ENDDO   !ISOUR

      RETURN
      END
+DECK,HSPEC.
*CMZ :  4.01/00 27/12/2022  15.30.01  by  Michael Scheer
*CMZ :  4.00/14 30/12/2021  15.41.22  by  Michael Scheer
*CMZ :  4.00/13 07/12/2021  14.43.50  by  Michael Scheer
*CMZ :  3.02/06 15/04/2015  11.57.06  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.68/05 28/09/2012  11.24.36  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  10.38.44  by  Michael Scheer
*CMZ :  2.52/13 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.51/02 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.51/00 26/05/2004  15.43.28  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  17.29.35  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.35  by  Michael Scheer
*CMZ :  2.13/07 10/02/2000  15.57.32  by  Michael Scheer
*CMZ :  2.13/03 12/01/2000  16.31.33  by  Michael Scheer
*CMZ :  1.00/00 24/09/97  10.31.28  by  Michael Scheer
*CMZ : 00.02/00 11/12/96  14.52.22  by  Michael Scheer
*CMZ : 00.01/12 16/10/96  15.22.18  by  Michael Scheer
*CMZ : 00.01/06 13/02/95  14.10.51  by  Michael Scheer
*CMZ : 00.01/04 30/01/95  14.13.04  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  16.53.40  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.52.27  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.49  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE HSPEC
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,WFOLDF90U.

C--- STORE RESULTS OF SPECTRUM CALCULATION ON HISTOGRAM FILE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,COLLI.
+seq,whbook.
+seq,pawcmn.
+SEq,wfoldf90.
+SEQ,PHYCON.

      INTEGER IOB,IOBZ,IOBY,IFREQ,ISOUR,ID
      INTEGER IFO,IFOUR,ICYCLE

      DOUBLE PRECISION X

      DOUBLE PRECISION XFOLD,YFOLD,DXFOLD

      DOUBLE PRECISION FOUFUNX

      CHARACTER(80) TIT

      !      stop '*** Teststop'
      IF (NSOURCE.GE.10) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING SR HSPEC ***'
        WRITE(LUNGFO,*)'TOO MANY SOURCE POINTS'
        WRITE(LUNGFO,*)'HISTOGRAM IDENTIFIER WILL OVERLAP'
        WRITE(LUNGFO,*)'BE CAREFUL OR USE CORRESPONDING NTUPLE!!'
        WRITE(LUNGFO,*)
        WRITE(6,*)'*** WARNING SR HSPEC ***'
      ENDIF

      IF(NOBSVY*NOBSVZ.EQ.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN HSPEC ***'
        WRITE(LUNGFO,*)
     &    'OBSERVATION POINTS NOT EQUIDISTANT'
        WRITE(6,*)'*** ERROR IN HSPEC ***'
        WRITE(6,*)
     &    'OBSERVATION POINTS NOT EQUIDISTANT'
        STOP
      ENDIF

C--- SCAN OBSERVATION POINTS

      X=OBSV(1,1)
      DO IOB=1,NOBSV
        IF(OBSV(1,IOB).NE.X) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN HSPEC ***'
          WRITE(LUNGFO,*)
     &      'X-POSITION OF OBSERVATION POINTS NOT IDENTICAL'
          WRITE(6,*)'*** ERROR IN HSPEC ***'
          WRITE(6,*)
     &      'X-POSITION OF OBSERVATION POINTS NOT IDENTICAL'
          STOP
        ENDIF
      ENDDO !IOB

      IF (NFREQ.GT.99) THEN   !OTHERWISE PROBLEMS WITH IDENTIFIER
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN HSPEC ***'
        WRITE(LUNGFO,*)'MORE THEN 99 PHOTON ENERGIES, IS TOO MUCH!'
        WRITE(LUNGFO,*)'CHECK PARAMETER NINTFREQ IN NAMELIST FREQN'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN HSPEC ***'
        WRITE(6,*)'MORE THEN 99 PHOTON ENERGIES, IS TOO MUCH!'
        WRITE(6,*)'CHECK PARAMETER NINTFREQ IN NAMELIST FREQN'
        WRITE(6,*)
        STOP
      ENDIF !NFREQ

      DO IFREQ=1,NFREQ,IHFREQ

        ID=IDSPECH+IFREQ
        TIT='TOTAL INTENSITY FOR CENTRAL Y'
        DO IOBZ=1,NOBSVZ
          IOB=NOBSVZ*(NOBSVY/2)+IOBZ
          FILL(IOBZ)=SPECTOT(IOB+NOBSV*(IFREQ-1))
        ENDDO
        CALL HSPEC1(ID,TIT,1)

        ID=IDSPECV+IFREQ
        TIT='TOTAL INTENSITY FOR CENTRAL Z'
        DO IOBY=1,NOBSVY
          IOB=NOBSVZ*(IOBY-1)+NOBSVZ/2+1
          FILL(IOBY)=SPECTOT(IOB+NOBSV*(IFREQ-1))
        ENDDO
        CALL HSPEC1(ID,TIT,2)

        IF (IFOLD.NE.0) THEN

           ID=IDSPECFH+IFREQ
           TIT='TOTAL INTENSITY FOR CENTRAL Y (FOLDED)'
           DO IOBZ=1,NOBSVZ
              IOB=NOBSVZ*(NOBSVY/2)+IOBZ
              FILL(IOBZ)=SPECTOTF(IOB+NOBSV*(IFREQ-1))
           ENDDO
           CALL HSPEC1(ID,TIT,1)

           ID=IDSPECFV+IFREQ
           TIT='TOTAL INTENSITY FOR CENTRAL Z (FOLDED)'
           DO IOBY=1,NOBSVY
              IOB=NOBSVZ*(IOBY-1)+NOBSVZ/2+1
              FILL(IOBY)=SPECTOTF(IOB+NOBSV*(IFREQ-1))
           ENDDO
           CALL HSPEC1(ID,TIT,2)

         ENDIF !IFOLD

         DO ISOUR=1,NSOURCE

           ID=IDSPECH+IFREQ+100*ISOUR
           TIT='INTENSITY FOR CENTRAL Y'
           DO IOBZ=1,NOBSVZ
              IOB=NOBSVZ*(NOBSVY/2)+IOBZ
              FILL(IOBZ)=SPEC(ISOUR+NSOURCE*(IOB-1+NOBSV*(IFREQ-1)))
           ENDDO
           CALL HSPEC1(ID,TIT,1)

           ID=IDSPECV+IFREQ+100*ISOUR
           TIT='INTENSITY FOR CENTRAL Z'
           DO IOBY=1,NOBSVY
              IOB=NOBSVZ*(IOBY-1)+NOBSVZ/2+1
              FILL(IOBY)=SPEC(ISOUR+NSOURCE*(IOB-1+NOBSV*(IFREQ-1)))
           ENDDO
           CALL HSPEC1(ID,TIT,2)

           IF (IFOLD.NE.0) THEN

             ID=IDSPECFH+IFREQ+100*ISOUR
             TIT='INTENSITY FOR CENTRAL Y (FOLDED)'
             DO IOBZ=1,NOBSVZ
                IOB=NOBSVZ*(NOBSVY/2)+IOBZ
                FILL(IOBZ)=SPECF(ISOUR+NSOURCE*(IOB-1+NOBSV*(IFREQ-1)))
             ENDDO
             CALL HSPEC1(ID,TIT,1)

             ID=IDSPECFV+IFREQ+100*ISOUR
             TIT='INTENSITY FOR CENTRAL Z (FOLDED)'
             DO IOBY=1,NOBSVY
                IOB=NOBSVZ*(IOBY-1)+NOBSVZ/2+1
                FILL(IOBY)=SPECF(ISOUR+NSOURCE*(IOB-1+NOBSV*(IFREQ-1)))
             ENDDO
             CALL HSPEC1(ID,TIT,2)

           ENDIF !IFOLD

         ENDDO !ISOUR

      ENDDO !IFREQ


C--- FOLDING FUNCTION

      IF (IFOLD.NE.0) THEN

        DO ISOUR=1,NSOURCE

          if (if1dim.eq.0)
     &      call hbook1m(IDFOLFNZ+ISOUR*100,'HORIZONTAL FOLDING FUNCTION'
     &      ,1000,-SNGL(DSIGZ(ISOUR)),SNGL(DSIGZ(ISOUR)),VMX)

          call hbook1m(IDFOLFNY+ISOUR*100,'VERTICAL FOLDING FUNCTION'
     &                ,1000,-SNGL(DSIGY(ISOUR)),SNGL(DSIGY(ISOUR)),VMX)

        DXFOLD=2.*DSIGZ(ISOUR)/1000.
        XFOLD=-DSIGZ(ISOUR)-DXFOLD/2.

        DO IFO=1,1000

          XFOLD=XFOLD+DXFOLD

          IF (IUSEM.EQ.0) THEN

            IF (IFOLD.EQ.-1.OR.IFOLD.EQ.-2) THEN
              YFOLD=GCOEFH(1,ISOUR)
              DO IFOUR=2,NGFOURZ
                YFOLD=YFOLD+GCOEFH(IFOUR,ISOUR)
     &            *DCOS(XKGAUSS(IFOUR-1,1)*XFOLD)
              ENDDO !IFOUR
            ELSE
              YFOLD=1.0D0/SQRT(2.0D0*PI1)/WSIGZ(ISOUR)*
     &          EXP(-(XFOLD/WSIGZ(ISOUR))**2/2.0D0)
            ENDIF !IFOLD

          ELSE  !IUSEM
            YFOLD=FOUFUNX(XFOLD,WSIGZ(ISOUR))
          ENDIF !IUSEM

          if (if1dim.eq.0) CALL hfillm(IDFOLFNZ+100*ISOUR,SNGL(XFOLD),0.,YFOLD)

        ENDDO   !IFO

        DXFOLD=2.*DSIGY(ISOUR)/1000.
        XFOLD=-DSIGY(ISOUR)-DXFOLD/2.
        DO IFO=1,1000
          XFOLD=XFOLD+DXFOLD

          IF (IUSEM.EQ.0) THEN

            IF (IFOLD.EQ.-1.OR.IFOLD.EQ.-2) THEN
              YFOLD=GCOEFV(1,ISOUR)
              DO IFOUR=2,NGFOURY
                YFOLD=YFOLD+GCOEFV(IFOUR,ISOUR)
     &            *DCOS(YKGAUSS(IFOUR-1,1)*XFOLD)
              ENDDO !IFOUR
            ELSE
              YFOLD=1.0D0/SQRT(2.0D0*PI1)/WSIGY(ISOUR)*
     &          EXP(-(XFOLD/WSIGY(ISOUR))**2/2.0D0)
            ENDIF !IFOLD

          ELSE  !IUSEM
            YFOLD=FOUFUNX(XFOLD,WSIGY(ISOUR))
          ENDIF !IUSEM

          CALL hfillm(IDFOLFNY+100*ISOUR,SNGL(XFOLD),0.,YFOLD)

        ENDDO   !IFO

        if (if1dim.eq.0) then
          CALL MHROUT(IDFOLFNZ+100*ISOUR,ICYCLE,' ')
          CALL hdeletm(IDFOLFNZ+100*ISOUR)
        endif

        CALL MHROUT(IDFOLFNY+100*ISOUR,ICYCLE,' ')
        CALL hdeletm(IDFOLFNY+100*ISOUR)

      ENDDO   !ISOUR

      ENDIF   !IFOLD

C--- 2D-HISTOS

      IF (IPIN.NE.2) THEN

        TIT='TOTAL INTENSITY IN PINHOLE'
        DO IFREQ=1,NFREQ,IHFREQ
          DO IOB=1,NOBSV
            FILL(IOB)=SPECTOT(IOB+NOBSV*(IFREQ-1))
          ENDDO !IOB
          CALL HSPEC2(IDSPEC+IFREQ,TIT)
        ENDDO !IFREQ

        IF (IFOLD.NE.0) THEN
          TIT='TOTAL INTENSITY IN PINHOLE (FOLDED)'
          DO IFREQ=1,NFREQ,IHFREQ
            DO IOB=1,NOBSV
              FILL(IOB)=SPECTOTF(IOB+NOBSV*(IFREQ-1))
            ENDDO !IOB
            CALL HSPEC2(IDSPECF+IFREQ,TIT)
          ENDDO !IFREQ
        ENDIF   !IFOLD

        IF (ISTOKES.NE.0) THEN

          TIT='STOKES S0 IN PINHOLE'
          DO IFREQ=1,NFREQ,IHFREQ
            DO IOB=1,NOBSV
              FILL(IOB)=STOKES(1,IOB+NOBSV*(IFREQ-1))
            ENDDO !IOB
            CALL HSPEC2(IDSTOKES0+IFREQ,TIT)
          ENDDO !IFREQ

          TIT='STOKES S1 IN PINHOLE'
          DO IFREQ=1,NFREQ,IHFREQ
            DO IOB=1,NOBSV
              FILL(IOB)=STOKES(2,IOB+NOBSV*(IFREQ-1))
            ENDDO !IOB
            CALL HSPEC2(IDSTOKES1+IFREQ,TIT)
          ENDDO !IFREQ

          TIT='STOKES S2 IN PINHOLE'
          DO IFREQ=1,NFREQ,IHFREQ
            DO IOB=1,NOBSV
              FILL(IOB)=STOKES(3,IOB+NOBSV*(IFREQ-1))
            ENDDO !IOB
            CALL HSPEC2(IDSTOKES2+IFREQ,TIT)
          ENDDO !IFREQ

          TIT='STOKES S3 IN PINHOLE'
          DO IFREQ=1,NFREQ,IHFREQ
            DO IOB=1,NOBSV
              FILL(IOB)=STOKES(4,IOB+NOBSV*(IFREQ-1))
            ENDDO !IOB
            CALL HSPEC2(IDSTOKES3+IFREQ,TIT)
          ENDDO !IFREQ

          IF (IFOLD.NE.0) THEN

            TIT='STOKES S0 IN PINHOLE (FOLDED)'
            DO IFREQ=1,NFREQ,IHFREQ
              DO IOB=1,NOBSV
                FILL(IOB)=STOKESF(1,IOB+NOBSV*(IFREQ-1))
              ENDDO !IOB
              CALL HSPEC2(IDSTOKFS0+IFREQ,TIT)
            ENDDO !IFREQ

            TIT='STOKES S1 IN PINHOLE (FOLDED)'
            DO IFREQ=1,NFREQ,IHFREQ
              DO IOB=1,NOBSV
                FILL(IOB)=STOKESF(2,IOB+NOBSV*(IFREQ-1))
              ENDDO !IOB
              CALL HSPEC2(IDSTOKFS1+IFREQ,TIT)
            ENDDO !IFREQ

            TIT='STOKES S2 IN PINHOLE (FOLDED)'
            DO IFREQ=1,NFREQ,IHFREQ
              DO IOB=1,NOBSV
                FILL(IOB)=STOKESF(3,IOB+NOBSV*(IFREQ-1))
              ENDDO !IOB
              CALL HSPEC2(IDSTOKFS2+IFREQ,TIT)
            ENDDO !IFREQ

            TIT='STOKES S3 IN PINHOLE (FOLDED)'
            DO IFREQ=1,NFREQ,IHFREQ
              DO IOB=1,NOBSV
                FILL(IOB)=STOKESF(4,IOB+NOBSV*(IFREQ-1))
              ENDDO !IOB
              CALL HSPEC2(IDSTOKFS3+IFREQ,TIT)
            ENDDO !IFREQ

          ENDIF   !IFOLD

        ENDIF   !ISTOKES

        DO ISOUR=1,NSOURCE

          TIT='INTENSITY IN PINHOLE'
          DO IFREQ=1,NFREQ,IHFREQ
            DO IOB=1,NOBSV
              FILL(IOB)=SPEC(ISOUR+NSOURCE*(IOB-1+NOBSV*(IFREQ-1)))
            ENDDO !IOB
            CALL HSPEC2(IDSPEC+100*ISOUR+IFREQ,TIT)
          ENDDO !IFREQ

        ENDDO   !NSOURCE

        IF (IFOLD.NE.0) THEN
          TIT='INTENSITY IN PINHOLE (FOLDED)'
          DO ISOUR=1,NSOURCE

            DO IFREQ=1,NFREQ,IHFREQ
              DO IOB=1,NOBSV
                FILL(IOB)=SPECF(ISOUR+NSOURCE*(IOB-1+NOBSV*(IFREQ-1)))
              ENDDO !IOB
              CALL HSPEC2(IDSPECF+100*ISOUR+IFREQ,TIT)
            ENDDO !IFREQ

          ENDDO   !NSOURCE
        ENDIF   !IFOLD

      ENDIF !IPIN.NE.2

      RETURN
      END
+DECK,HSPEC1.
*CMZ :  4.00/04 23/08/2019  16.19.15  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  10.12.46  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  10.38.44  by  Michael Scheer
*CMZ :  2.52/16 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.41/10 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  17.29.35  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  14.43.04  by  Michael Scheer
*CMZ :  1.00/00 24/09/97  10.31.28  by  Michael Scheer
*CMZ : 00.01/06 15/02/95  12.34.02  by  Michael Scheer
*CMZ : 00.01/04 30/01/95  10.41.22  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  16.53.40  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.52.27  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.49  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE HSPEC1(ID,TIT,MODE)
+seq,gplhint.

+SELF,IF=F90.
+SEQ,OBSERVF90U.
+SELF.

C--- STORE RESULTS OF SPECTRUM CALCULATION ON HISTOGRAM FILE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,FREQS.
+SEq,observf90.
+seq,whbook.
+seq,pawcmn.

      INTEGER IOBZ,IOBY,ID
      INTEGER ICYCLE,MODE

      REAL*4 ZMIN,ZMAX,YMIN,YMAX,ZFILL,YFILL

      CHARACTER(80) TIT

      data icycle/0/

      ZMIN=OBSVZ(1)-OBSVDZ/2.
      ZMAX=OBSVZ(NOBSVZ)+OBSVDZ/2.
      YMIN=OBSVY(1)-OBSVDY/2.
      YMAX=OBSVY(NOBSVY)+OBSVDY/2.

      IF (MODE.EQ.1) THEN

         call hbook1m(ID,TIT,NOBSVZ,ZMIN,ZMAX,VMX)

         DO IOBZ=1,NOBSVZ
             ZFILL=OBSVZ(IOBZ)
             CALL hfillm(ID,ZFILL,0.,FILL(IOBZ))
         ENDDO !IOBZ

      ELSE IF(MODE.EQ.2) THEN

         call hbook1m(ID,TIT,NOBSVY,YMIN,YMAX,VMX)

         DO IOBY=1,NOBSVY
             YFILL=OBSVY(IOBY)
             CALL hfillm(ID,YFILL,0.,FILL(IOBY))
         ENDDO !IOBZ

      ELSE
         WRITE(6,*) '*** ERROR IN HSPEC1: MODE WRONG ***'
         STOP
      ENDIF

      CALL MHROUT(ID,ICYCLE,' ')
c      IF (ID.NE.IDSPEC-1.AND.ID.NE.IDSPEC-2) CALL hdeletm(ID)
      CALL hdeletm(ID)

      RETURN
      END
+DECK,HSPEC2.
*CMZ :  4.00/04 23/08/2019  16.18.53  by  Michael Scheer
*CMZ :  3.02/02 21/10/2014  14.17.24  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  09.20.56  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  10.38.44  by  Michael Scheer
*CMZ :  2.52/16 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.41/10 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.17/00 03/11/2000  11.30.56  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  17.26.04  by  Michael Scheer
*CMZ :  2.13/00 08/10/99  15.13.00  by  Michael Scheer
*CMZ :  1.00/00 24/09/97  10.31.28  by  Michael Scheer
*CMZ : 00.01/06 13/02/95  13.14.40  by  Michael Scheer
*CMZ : 00.01/04 30/01/95  10.41.22  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  16.53.40  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.52.27  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.49  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE HSPEC2(ID,TIT)
+seq,gplhint.

+SELF,IF=F90.
+SEQ,OBSERVF90U.
+SELF.

C--- STORE RESULTS OF SPECTRUM CALCULATION ON HISTOGRAM FILE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,FREQS.
+SEq,observf90.
+seq,whbook.
+seq,pawcmn.

      INTEGER IOB,IOBZ,IOBY,ID
      INTEGER ICYCLE

      REAL*4 ZMIN,ZMAX,YMIN,YMAX,ZFILL,YFILL

      CHARACTER(80) TIT

      data icycle/0/

      ZMIN=OBSVZ(1)-OBSVDZ/2.
      ZMAX=OBSVZ(NOBSVZ)+OBSVDZ/2.
      YMIN=OBSVY(1)-OBSVDY/2.
      YMAX=OBSVY(NOBSVY)+OBSVDY/2.

      call hbook2m(ID,TIT,NOBSVZ,ZMIN,ZMAX,NOBSVY,YMIN,YMAX,VMX)

      IOB=0
      DO IOBY=1,NOBSVY
        DO IOBZ=1,NOBSVZ

          IOB=IOB+1

          ZFILL=OBSV(3,IOB)
          YFILL=OBSV(2,IOB)

          CALL hfillm(ID,ZFILL,YFILL,FILL(IOB))

        ENDDO !IOBZ
      ENDDO !IOBY

      CALL MHROUT(ID,ICYCLE,' ')

c      IF (ID.NE.IDSPEC) then
        CALL hdeletm(ID)
c      endif

      RETURN
      END
+DECK,HTRACK.
*CMZ :  4.00/15 17/05/2022  08.32.28  by  Michael Scheer
*CMZ :  4.00/14 30/12/2021  15.41.22  by  Michael Scheer
*CMZ :  4.00/13 07/12/2021  18.47.10  by  Michael Scheer
*CMZ :  3.02/04 18/03/2015  09.49.00  by  Michael Scheer
*CMZ :  3.02/03 04/11/2014  16.10.50  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  10.40.59  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.68/05 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.67/02 26/04/2012  14.52.47  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  10.38.44  by  Michael Scheer
*CMZ :  2.64/01 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.63/05 12/08/2009  08.49.28  by  Michael Scheer
*CMZ :  2.62/04 03/01/2008  17.15.05  by  Michael Scheer
*CMZ :  2.47/12 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.36/00 08/11/2001  11.40.47  by  Michael Scheer
*CMZ :  2.16/08 25/10/2000  12.21.53  by  Michael Scheer
*CMZ :  2.15/00 16/05/2000  13.53.47  by  Michael Scheer
*CMZ :  2.13/11 20/03/2000  13.17.03  by  Michael Scheer
*CMZ :  2.13/02 09/12/99  10.41.02  by  Michael Scheer
*CMZ :  2.12/00 02/06/99  12.03.53  by  Michael Scheer
*CMZ :  1.00/00 24/09/97  10.31.28  by  Michael Scheer
*CMZ : 00.01/09 19/10/95  15.35.33  by  Michael Scheer
*CMZ : 00.01/07 09/03/95  12.30.05  by  Michael Scheer
*CMZ : 00.01/06 13/02/95  14.15.56  by  Michael Scheer
*CMZ : 00.00/05 29/04/94  19.22.28  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.30  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE HTRACK
+seq,gplhint.

+SEQ,TRACKF90U,IF=F90.

C--- HISTOGRAM FOR REFERENCE ORBIT AND MAGNETIC FIELD

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,whbook.
+seq,pawcmn.

+SEQ,TRACK.
+SEQ,WBTAB.
+SEQ,BERROR.
+SEQ,PHYCON.

      DOUBLE PRECISION, DIMENSION (:), ALLOCATABLE :: XPHANA,PHPHANA,RESPHANA,
     &  pherr
      DOUBLE PRECISION XLENDEV2,A0,A1,CHI2
      DOUBLE PRECISION XPAR(3),YPAR(3),A(3),YPPAR(3),XOPT,AOPT,XG,XG2
      DOUBLE PRECISION PHASEMEAN,OMEGAR,FREQR,DXG,
     &  erra,errb

      INTEGER IFAIL,IXG,J,I1,IXG1,IXG2,IDIXG,nallo

      INTEGER I,NBIN
      INTEGER ICYCLE,IFILL
      REAL*4 XI,XE,X
      REAL*8 Z,Y,BX,BY,BZ,AX,AY,AZ

      INTEGER NTUPP,NPHANA
      PARAMETER (NTUPP=15,NPHANA=3)
      REAL*8 TUP(NTUPP),TUPPHANA(NPHANA)

      CHARACTER(2) CHTAGS(NTUPP)
      data chtags/'x','y','z','bx','by','bz','vx','vy','vz'
     &  ,'ax','ay','az','t','ph','pr'/

      CHARACTER(2) CHPHANA(NPHANA)
      DATA CHPHANA/'x','ph','dp'/

      IF (XSTARTH.EQ.9999.) THEN
         XI=WTRA(1,1,1)-DS0/2.
      ELSE
         XI=XSTARTH-DS0/2.
      ENDIF !XSTARTH

      IF (XSTOPH.EQ.9999.) THEN
        XE=WTRA(1,1,NCO)+DS0/2.
      ELSE
        XE=XSTOPH+DS0/2.
      ENDIF !XSTARTH

      NBIN=(XE-XI)/DS0
      XE=DS0*NBIN+XI

      IF (IHTRACK.GT.0) THEN

        call hbook1m(IDTRACKZ,'Z OF REF. ORBIT',NBIN,XI,XE,VMX)
        call hbook1m(IDTRACKY,'Y OF REF. ORBIT',NBIN,XI,XE,VMX)

        call hbook1m(IDBX,'Bx',NBIN,XI,XE,VMX)
        call hbook1m(IDBY,'By',NBIN,XI,XE,VMX)
        call hbook1m(IDBZ,'Bz',NBIN,XI,XE,VMX)

        call hbook1m(IDAX,'Ax',NBIN,XI,XE,VMX)
        call hbook1m(IDAY,'Ay',NBIN,XI,XE,VMX)
        call hbook1m(IDAZ,'Az',NBIN,XI,XE,VMX)

      ENDIF !IHTRACK

      IF (IHTRSMP.EQ.0) IHTRSMP=1

+self,if=mhbook.
      nallo=nco/ihtrsmp+1024
      CALL hbookm(NIDTRACK,'TRAJECTORY',NTUPP,'//WAVE',nallo,CHTAGS)
      if (abs(ihtrsmp).eq.9999) then
        nallo=NPWBTAB+1024
      else
        nallo=nint(nco*ds0/(abs(ihtrack)*0.0005))+1024
      endif
      CALL hbookm(NIDTRCKG,'TRAJECTORY ON GRID',NTUPP,'//WAVE',nallo,
     &  CHTAGS)
      IF (NCO.GE.3.AND.IBERROR.NE.0) THEN
        CALL hbookm(NIDPHANA,'PHASE ADVANCE',NPHANA,'//WAVE',nco+1024,CHPHANA)
      endif
+self,if=-mhbook.
      CALL hbookm(NIDTRACK,'TRAJECTORY',NTUPP,'//WAVE',1024,CHTAGS)
      CALL hbookm(NIDTRCKG,'TRAJECTORY ON GRID',NTUPP,'//WAVE',1024,CHTAGS)
      IF (NCO.GE.3.AND.IBERROR.NE.0) THEN
        CALL hbookm(NIDPHANA,'PHASE ADVANCE',NPHANA,'//WAVE',1024,CHPHANA)
      endif
+self.
      nallo=max((XSTOP-XSTART)/ZLENERR*2.,dble(nberror))+10

      ALLOCATE(XPHANA(nallo))
      ALLOCATE(PHPHANA(nallo))
      ALLOCATE(RESPHANA(nallo))
      ALLOCATE(pherr(nallo))

      xphana=0.0d0
      phphana=0.0d0
      resphana=0.0d0
      pherr=0.0d0

      XI=WTRA(1,1,1)-DS0
      IF (IHTRSMP.EQ.0) IHTRSMP=1

      DO I=1,NCO,IHTRSMP

        X=DS0*I+XI
        Y=WTRA(2,1,I)
        Z=WTRA(3,1,I)
        BX=WTRA(1,3,I)
        BY=WTRA(2,3,I)
        BZ=WTRA(3,3,I)
        AX=WTRA(1,4,I)
        AY=WTRA(2,4,I)
        AZ=WTRA(3,4,I)

        IF (IHTRACK.GT.0) THEN
          CALL hfillm(IDTRACKZ,X,0.,Z)
          CALL hfillm(IDTRACKY,X,0.,Y)
          CALL hfillm(IDBX,X,0.,BX)
          CALL hfillm(IDBY,X,0.,BY)
          CALL hfillm(IDBZ,X,0.,BZ)
          CALL hfillm(IDAX,X,0.,AX)
          CALL hfillm(IDAY,X,0.,AY)
          CALL hfillm(IDAZ,X,0.,AZ)
        ENDIF  !IHTRACK

        TUP(1)=WTRA(1,1,I)
        TUP(2)=WTRA(2,1,I)
        TUP(3)=WTRA(3,1,I)
        TUP(4)=WTRA(1,3,I)
        TUP(5)=WTRA(2,3,I)
        TUP(6)=WTRA(3,3,I)
        TUP(7)=WTRA(1,2,I)
        TUP(8)=WTRA(2,2,I)
        TUP(9)=WTRA(3,2,I)
        TUP(10)=WTRA(1,4,I)
        TUP(11)=WTRA(2,4,I)
        TUP(12)=WTRA(3,4,I)
        TUP(13)=WTIM0(I)
        TUP(14)=HTRA2(I)
        TUP(15)=WTRA2(I)
        CALL hfm(NIDTRACK,TUP)

      ENDDO !NCO

      IF (NCO.GE.3.AND.IBERROR.NE.0) THEN

        I1=1
        IFILL=0

        XLENDEV2=ZLENERR/2.D0*(NBERROR-1)/2.D0
        DO IXG=1,NBERROR+1

          XG=XCENERR-XLENDEV2+ZLENERR/2.D0*(IXG-1)

          XG2=XG*XG

          DO I=I1,NCO
            IF (WTRA(1,1,I).GE.XG) THEN
              I1=I
              GOTO 20
            ENDIF
          ENDDO

20        IF (I.EQ.1) THEN
            XPAR(1)=WTRA(1,1,1)
            XPAR(2)=WTRA(1,1,2)
            XPAR(3)=WTRA(1,1,3)
          ELSE IF (I.LT.NCO) THEN
            XPAR(1)=WTRA(1,1,I-1)
            XPAR(2)=WTRA(1,1,I)
            XPAR(3)=WTRA(1,1,I+1)
          ELSE
            XPAR(1)=WTRA(1,1,NCO-2)
            XPAR(2)=WTRA(1,1,NCO-1)
            XPAR(3)=WTRA(1,1,NCO)
          ENDIF

          IF (I.EQ.1) THEN
            YPAR(1)=HTRA2(1)
            YPAR(2)=HTRA2(2)
            YPAR(3)=HTRA2(3)
          ELSE IF (I.LT.NCO) THEN
            YPAR(1)=HTRA2(I-1)
            YPAR(2)=HTRA2(I)
            YPAR(3)=HTRA2(I+1)
          ELSE
            YPAR(1)=HTRA2(NCO-2)
            YPAR(2)=HTRA2(NCO-1)
            YPAR(3)=HTRA2(NCO)
          ENDIF
          CALL UTIL_PARABEL(XPAR,YPAR,A,YPPAR,XOPT,AOPT,IFAIL)

          IFILL=IFILL+1
          if (ifill.le.nallo) then
            XPHANA(IFILL)=XG
            PHPHANA(IFILL)=A(1)+A(2)*XG+A(3)*XG2
            !PHPHANA(IFILL)=phphana(ifill)-phphana(1)
          else
            write(lungfo,*)'*** ERROR IN HTRACK: ARRAY SIZE TO SMALL'
            write(lungfo,*)'*** Check namelist BERRORN'
            write(6,*)'*** WARNING IN HTRACK: ARRAY SIZE TO SMALL'
            write(6,*)'*** Check namelist BERRORN'
            stop '*** Program WAVE aborted ***'
          endif

        ENDDO  !NCO

C FIT A STRAIGHT LINE

cmsh 20150318 99      CALL DLSQP1(IFILL,XPHANA,PHPHANA,A0,A1,CHI2,IFAIL)
99      CALL util_straight_line_fit(ifill,xphana,phphana,pherr,
     &    a1,a0,chi2,erra,errb,ifail)

        IF (IFAIL.NE.0) THEN
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN HTRACK: STRAIGHT '//
     &      'LINE FIT OF PHASE ADVANCE FAILED ***'
          WRITE(6,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN HTRACK: STRAIGHT '//
     &      'LINE FIT OF PHASE ADVANCE FAILED ***'
          WRITE(LUNGFO,*)
        ENDIF  !IFAIL

        PHASEMEAN=A1*ZLENERR/CLIGHT1
        OMEGAR=2.D0*PI1/PHASEMEAN
        FREQR=OMEGAR*HBAREV1

        RESRMS=0.0D0
        DO I=1,IFILL
          RESPHANA(I)=
     &      (PHPHANA(I)-(A0+A1*XPHANA(I)))/CLIGHT1*OMEGAR/PI1/2.0d0 !
          RESRMS=RESRMS+RESPHANA(I)**2
          TUPPHANA(1)=XPHANA(I)
          TUPPHANA(2)=PHPHANA(I)/CLIGHT1*OMEGAR/PI1/2.0d0
          TUPPHANA(3)=RESPHANA(I)
          CALL hfm(NIDPHANA,TUPPHANA)
        ENDDO  !IFILL
        RESRMS=SQRT(RESRMS/IFILL)

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'      Phase error analysis of magnetic field'
        WRITE(LUNGFO,*)'      (phase is sampled according to ZLENERR/2'
        WRITE(LUNGFO,*)'       in namelist BERRORN):'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '      first harmonic (eV) corresponding to mean phase advance:'
        WRITE(LUNGFO,*)
     &    '      ',FREQR
        WRITE(LUNGFO,*)
     &    '      rms phase error for 1. harmonical (rad, deg.):'
        WRITE(LUNGFO,*)
     &    '      ',SNGL(RESRMS*PI1*2.0d0),' ',SNGL(RESRMS*360.D0)
        WRITE(LUNGFO,*)
     &    '      rel. rms phase error for 1. harmonical (per pole, per period):'
        WRITE(LUNGFO,*)
     &    '      ',SNGL(RESRMS/2.0d0),' ',SNGL(RESRMS)
        WRITE(LUNGFO,*)

      ENDIF !NCO.GE.3.AND.IBERROR.NE.0

      IF (NCO.GE.3) THEN

        I1=1

        IF (IABS(IHTRACK).EQ.9999) THEN
          IDIXG=1
          IF (BTABS.EQ.9999.) BTABS=WSXYZ(1,1)
          IF (BTABE.EQ.9999.) BTABE=WSXYZ(1,NCO) !DO NOT USE XSTOP
          IF (NPWBTAB.EQ.9999.) NPWBTAB=NCO
          DXG=(BTABE-BTABS)/(NPWBTAB-1)
          IXG1=NINT(BTABS/DXG)
          IXG2=NINT(BTABE/DXG)
        ELSE
          DXG=1.D0/2000.D0
          IXG1=NINT(XSTART/DXG)
          IXG2=NINT(XSTOP/DXG)
          IDIXG=IABS(IHTRACK)
        ENDIF

        DO IXG=IXG1,IXG2,IDIXG

          XG=FLOAT(IXG)*DXG
          XG2=XG*XG
          TUP(1)=XG

          DO I=I1,NCO
            IF (WTRA(1,1,I).GE.XG) THEN
              I1=I
              GOTO 10
            ENDIF
          ENDDO
+SELF,IF=HTRACKPAR.
10        IF (I.EQ.1) THEN
            XPAR(1)=WTRA(1,1,1)
            XPAR(2)=WTRA(1,1,2)
            XPAR(3)=WTRA(1,1,3)
          ELSE IF (I.LT.NCO) THEN
            XPAR(1)=WTRA(1,1,I-1)
            XPAR(2)=WTRA(1,1,I)
            XPAR(3)=WTRA(1,1,I+1)
          ELSE
            XPAR(1)=WTRA(1,1,NCO-2)
            XPAR(2)=WTRA(1,1,NCO-1)
            XPAR(3)=WTRA(1,1,NCO)
          ENDIF

          DO J=2,3
            IF (I.EQ.1) THEN
              YPAR(1)=WTRA(J,1,1)
              YPAR(2)=WTRA(J,1,2)
              YPAR(3)=WTRA(J,1,3)
            ELSE IF (I.LT.NCO) THEN
              YPAR(1)=WTRA(J,1,I-1)
              YPAR(2)=WTRA(J,1,I)
              YPAR(3)=WTRA(J,1,I+1)
            ELSE
              YPAR(1)=WTRA(J,1,NCO-2)
              YPAR(2)=WTRA(J,1,NCO-1)
              YPAR(3)=WTRA(J,1,NCO)
            ENDIF
            CALL UTIL_PARABEL(XPAR,YPAR,A,YPPAR,XOPT,AOPT,IFAIL)
            TUP(J)=A(1)+A(2)*XG+A(3)*XG2
          ENDDO   !J

          DO J=1,3
            IF (I.EQ.1) THEN
              YPAR(1)=WTRA(J,3,1)
              YPAR(2)=WTRA(J,3,2)
              YPAR(3)=WTRA(J,3,3)
            ELSE IF (I.LT.NCO) THEN
              YPAR(1)=WTRA(J,3,I-1)
              YPAR(2)=WTRA(J,3,I)
              YPAR(3)=WTRA(J,3,I+1)
            ELSE
              YPAR(1)=WTRA(J,3,NCO-2)
              YPAR(2)=WTRA(J,3,NCO-1)
              YPAR(3)=WTRA(J,3,NCO)
            ENDIF
            CALL UTIL_PARABEL(XPAR,YPAR,A,YPPAR,XOPT,AOPT,IFAIL)
            TUP(3+J)=A(1)+A(2)*XG+A(3)*XG2
          ENDDO   !J

          DO J=1,3
            IF (I.EQ.1) THEN
              YPAR(1)=WTRA(J,2,1)
              YPAR(2)=WTRA(J,2,2)
              YPAR(3)=WTRA(J,2,3)
            ELSE IF (I.LT.NCO) THEN
              YPAR(1)=WTRA(J,2,I-1)
              YPAR(2)=WTRA(J,2,I)
              YPAR(3)=WTRA(J,2,I+1)
            ELSE
              YPAR(1)=WTRA(J,2,NCO-2)
              YPAR(2)=WTRA(J,2,NCO-1)
              YPAR(3)=WTRA(J,2,NCO)
            ENDIF
            CALL UTIL_PARABEL(XPAR,YPAR,A,YPPAR,XOPT,AOPT,IFAIL)
            TUP(6+J)=A(1)+A(2)*XG+A(3)*XG2
          ENDDO   !J

          DO J=1,3
            IF (I.EQ.1) THEN
              YPAR(1)=WTRA(J,4,1)
              YPAR(2)=WTRA(J,4,2)
              YPAR(3)=WTRA(J,4,3)
            ELSE IF (I.LT.NCO) THEN
              YPAR(1)=WTRA(J,4,I-1)
              YPAR(2)=WTRA(J,4,I)
              YPAR(3)=WTRA(J,4,I+1)
            ELSE
              YPAR(1)=WTRA(J,4,NCO-2)
              YPAR(2)=WTRA(J,4,NCO-1)
              YPAR(3)=WTRA(J,4,NCO)
            ENDIF
            CALL UTIL_PARABEL(XPAR,YPAR,A,YPPAR,XOPT,AOPT,IFAIL)
            TUP(9+J)=A(1)+A(2)*XG+A(3)*XG2
          ENDDO   !J

          IF (I.EQ.1) THEN
            YPAR(1)=WTIM0(1)
            YPAR(2)=WTIM0(2)
            YPAR(3)=WTIM0(3)
          ELSE IF (I.LT.NCO) THEN
            YPAR(1)=WTIM0(I-1)
            YPAR(2)=WTIM0(I)
            YPAR(3)=WTIM0(I+1)
          ELSE
            YPAR(1)=WTIM0(NCO-2)
            YPAR(2)=WTIM0(NCO-1)
            YPAR(3)=WTIM0(NCO)
          ENDIF
          CALL UTIL_PARABEL(XPAR,YPAR,A,YPPAR,XOPT,AOPT,IFAIL)
          TUP(13)=A(1)+A(2)*XG+A(3)*XG2

          IF (I.EQ.1) THEN
            YPAR(1)=HTRA2(1)
            YPAR(2)=HTRA2(2)
            YPAR(3)=HTRA2(3)
          ELSE IF (I.LT.NCO) THEN
            YPAR(1)=HTRA2(I-1)
            YPAR(2)=HTRA2(I)
            YPAR(3)=HTRA2(I+1)
          ELSE
            YPAR(1)=HTRA2(NCO-2)
            YPAR(2)=HTRA2(NCO-1)
            YPAR(3)=HTRA2(NCO)
          ENDIF
          CALL UTIL_PARABEL(XPAR,YPAR,A,YPPAR,XOPT,AOPT,IFAIL)
          TUP(14)=A(1)+A(2)*XG+A(3)*XG2

          IF (I.EQ.1) THEN
            YPAR(1)=WTRA2(1)
            YPAR(2)=WTRA2(2)
            YPAR(3)=WTRA2(3)
          ELSE IF (I.LT.NCO) THEN
            YPAR(1)=WTRA2(I-1)
            YPAR(2)=WTRA2(I)
            YPAR(3)=WTRA2(I+1)
          ELSE
            YPAR(1)=WTRA2(NCO-2)
            YPAR(2)=WTRA2(NCO-1)
            YPAR(3)=WTRA2(NCO)
          ENDIF
          CALL UTIL_PARABEL(XPAR,YPAR,A,YPPAR,XOPT,AOPT,IFAIL)
          TUP(15)=A(1)+A(2)*XG+A(3)*XG2
+SELF,IF=-HTRACKPAR.
10        IF (I.EQ.1) THEN
            XPAR(1)=WTRA(1,1,1)
            XPAR(2)=WTRA(1,1,2)
           ELSEIF (I.GT.NCO) THEN
            XPAR(1)=WTRA(1,1,NCO-1)
            XPAR(2)=WTRA(1,1,NCO)
          ELSE
            XPAR(1)=WTRA(1,1,I-1)
            XPAR(2)=WTRA(1,1,I)
          ENDIF

          DO J=2,3
            IF (I.EQ.1) THEN
              YPAR(1)=WTRA(J,1,1)
              YPAR(2)=WTRA(J,1,2)
           ELSEIF (I.GT.NCO) THEN
              YPAR(1)=WTRA(J,1,NCO-1)
              YPAR(2)=WTRA(J,1,NCO)
          ELSE
              YPAR(1)=WTRA(J,1,I-1)
              YPAR(2)=WTRA(J,1,I)
          ENDIF
            TUP(J)=YPAR(1)+(YPAR(2)-YPAR(1))/(XPAR(2)-XPAR(1))*(XG-XPAR(1))
          ENDDO   !J

          DO J=1,3
            IF (I.EQ.1) THEN
              YPAR(1)=WTRA(J,3,1)
              YPAR(2)=WTRA(J,3,2)
           ELSEIF (I.GT.NCO) THEN
              YPAR(1)=WTRA(J,3,NCO-1)
              YPAR(2)=WTRA(J,3,NCO)
            ELSE
              YPAR(1)=WTRA(J,3,I-1)
              YPAR(2)=WTRA(J,3,I)
            ENDIF
            TUP(3+J)=YPAR(1)+(YPAR(2)-YPAR(1))/(XPAR(2)-XPAR(1))*(XG-XPAR(1))
          ENDDO   !J

          DO J=1,3
            IF (I.EQ.1) THEN
              YPAR(1)=WTRA(J,2,1)
              YPAR(2)=WTRA(J,2,2)
           ELSEIF (I.GT.NCO) THEN
              YPAR(1)=WTRA(J,2,NCO-1)
              YPAR(2)=WTRA(J,2,NCO)
            ELSE
              YPAR(1)=WTRA(J,2,I-1)
              YPAR(2)=WTRA(J,2,I)
            ENDIF
            TUP(6+J)=YPAR(1)+(YPAR(2)-YPAR(1))/(XPAR(2)-XPAR(1))*(XG-XPAR(1))
          ENDDO   !J

          DO J=1,3
            IF (I.EQ.1) THEN
              YPAR(1)=WTRA(J,4,1)
              YPAR(2)=WTRA(J,4,2)
           ELSEIF (I.GT.NCO) THEN
              YPAR(1)=WTRA(J,4,NCO-1)
              YPAR(2)=WTRA(J,4,NCO)
            ELSE
              YPAR(1)=WTRA(J,4,I-1)
              YPAR(2)=WTRA(J,4,I)
            ENDIF
            TUP(9+J)=YPAR(1)+(YPAR(2)-YPAR(1))/(XPAR(2)-XPAR(1))*(XG-XPAR(1))
          ENDDO   !J

          IF (I.EQ.1) THEN
            YPAR(1)=WTIM0(1)
            YPAR(2)=WTIM0(2)
           ELSEIF (I.GT.NCO) THEN
              YPAR(1)=WTIM0(NCO-1)
              YPAR(2)=WTIM0(NCO)
          ELSE
            YPAR(1)=WTIM0(I-1)
            YPAR(2)=WTIM0(I)
          ENDIF
          TUP(13)=YPAR(1)+(YPAR(2)-YPAR(1))/(XPAR(2)-XPAR(1))*(XG-XPAR(1))

          IF (I.EQ.1) THEN
            YPAR(1)=HTRA2(1)
            YPAR(2)=HTRA2(2)
          ELSE IF (I.GT.NCO) THEN
            YPAR(1)=HTRA2(NCO-1)
            YPAR(2)=HTRA2(NCO)
          ELSE
            YPAR(1)=HTRA2(I-1)
            YPAR(2)=HTRA2(I)
          ENDIF
          TUP(14)=YPAR(1)+(YPAR(2)-YPAR(1))/(XPAR(2)-XPAR(1))*(XG-XPAR(1))

          IF (I.EQ.1) THEN
            YPAR(1)=WTRA2(1)
            YPAR(2)=WTRA2(2)
          ELSE IF (I.GT.NCO) THEN
            YPAR(1)=WTRA2(NCO-1)
            YPAR(2)=WTRA2(NCO)
          ELSE
            YPAR(1)=WTRA2(I-1)
            YPAR(2)=WTRA2(I)
          ENDIF
          TUP(15)=YPAR(1)+(YPAR(2)-YPAR(1))/(XPAR(2)-XPAR(1))*(XG-XPAR(1))
+SELF. -HTRACKPAR
          CALL hfm(NIDTRCKG,TUP)

        ENDDO  !IXG

      ELSE  !NCO.GE.3
        WRITE(6,*)
     &    'WARNING IN HTRACK: NCO.LT.3, NO NTUPLE OF TRACKJETROY ON GRID'
      ENDIF !NCO.GE.3

      IF (IHTRACK.GT.0) THEN
        CALL MHROUT(IDTRACKZ,ICYCLE,' ')
        CALL MHROUT(IDTRACKY,ICYCLE,' ')
        CALL MHROUT(IDBX,ICYCLE,' ')
        CALL MHROUT(IDBY,ICYCLE,' ')
        CALL MHROUT(IDBZ,ICYCLE,' ')
        CALL MHROUT(IDAX,ICYCLE,' ')
        CALL MHROUT(IDAY,ICYCLE,' ')
        CALL MHROUT(IDAZ,ICYCLE,' ')

        CALL hdeletm(IDTRACKZ)
        CALL hdeletm(IDTRACKY)
        CALL hdeletm(IDBX)
        CALL hdeletm(IDBY)
        CALL hdeletm(IDBZ)
        CALL hdeletm(IDAX)
        CALL hdeletm(IDAY)
        CALL hdeletm(IDAZ)

      ENDIF

      DEALLOCATE(XPHANA)
      DEALLOCATE(PHPHANA)
      DEALLOCATE(RESPHANA)

      RETURN
      END
+DECK,IGETFIRSTCHAR,T=F77.
*CMZ :  3.02/00 24/09/2014  11.50.26  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.02  by  Michael Scheer
*CMZ :  1.00/00 22/11/2001  16.14.10  by  Michael Scheer
*CMZ :  0.01/01 19/11/2001  15.17.00  by  Michael Scheer
*CMZ :  0.01/00 16/11/2001  17.38.53  by  Michael Scheer
*-- Author :    Michael Scheer   09/11/2001

      FUNCTION IGETFIRSTCHAR(N1,N,CLINE,C)
+seq,gplhint.

      IMPLICIT NONE

      INTEGER N1,I,N,IGETFIRSTCHAR,IC
      CHARACTER(*) CLINE
      CHARACTER C,C1

      EQUIVALENCE (IC,C1)
        data ic/0/

      IGETFIRSTCHAR=-1

      DO I=N1,N
          C1=CLINE(I:I)
          IF (C1.NE.' '.AND.IC.NE.9) THEN !NO BLANKS, NO TABS
              IGETFIRSTCHAR=I
              C=CLINE(I:I)
              RETURN
          ENDIF
      ENDDO

      RETURN
      END
+DECK,IGETLASTCHAR,T=F77.
*CMZ :  3.02/00 24/09/2014  11.50.26  by  Michael Scheer
*CMZ :  2.68/03 29/08/2012  11.53.24  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.02  by  Michael Scheer
*CMZ :  1.00/00 22/11/2001  16.14.10  by  Michael Scheer
*CMZ :  0.01/02 20/11/2001  15.36.03  by  Michael Scheer
*CMZ :  0.01/01 19/11/2001  15.17.00  by  Michael Scheer
*CMZ :  0.01/00 16/11/2001  17.38.53  by  Michael Scheer
*-- Author :    Michael Scheer   09/11/2001

      FUNCTION IGETLASTCHAR(N1,N,CLINE,C)
+seq,gplhint.

      IMPLICIT NONE

      INTEGER N1,I,N,IGETLASTCHAR,IC
      CHARACTER(*) CLINE
      CHARACTER C,C1

+self,if=-obsolete.
        ic=len_trim(cline)
        igetlastchar=ic
        c=cline(ic:ic)
+self,if=obsolete.
      EQUIVALENCE (IC,C1)
        data ic/0/

      IGETLASTCHAR=-1

      DO I=N,N1,-1
          C1=CLINE(I:I)
          IF (C1.NE.' '.AND.IC.NE.9) THEN !NO BLANKS, NO TABS
              IGETLASTCHAR=I
              C=CLINE(I:I)
              RETURN
          ENDIF
      ENDDO

+self. if=obsolete.
      RETURN
      END
+DECK,LININT.
*CMZ :  3.02/00 24/09/2014  13.51.08  by  Michael Scheer
*CMZ :  3.01/03 19/03/2014  12.24.14  by  Michael Scheer
*CMZ :  2.66/19 07/06/2011  14.03.07  by  Michael Scheer
*CMZ :  2.63/03 07/05/2008  14.17.54  by  Michael Scheer
*CMZ :  2.36/00 07/11/2001  14.20.47  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ : 00.01/02 24/11/94  15.21.38  by  Michael Scheer
*CMZ : 00.01/01 21/06/94  20.13.12  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.46.24  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.34  by  Michael Scheer
*-- Author : Michael Scheer

      SUBROUTINE LININT(XA,YA,N,X,Y,IERR)
+seq,gplhint.

      IMPLICIT NONE
      INTEGER NOLD,N,KLO,KHI,KLOLD,K,IERR
      DOUBLE PRECISION Y,X,XA1OLD,XANOLD,H,YA1OLD,YANOLD

      DOUBLE PRECISION XA(*),YA(*)

      save klold,nold,xa1old,xanold,ya1old,yanold

      DATA KLOLD/1/,NOLD/-99/
      DATA XA1OLD/-9999.D0/,XANOLD/-9999./
      DATA YA1OLD/-9999.D0/,YANOLD/-9999./

      IF(     XA(1).LT.XA(N).AND.(X.LT.XA(1).OR.X.GT.XA(N))
     &    .OR.
     &    XA(N).LT.XA(1).AND.(X.LT.XA(N).OR.X.GT.XA(1))) THEN
        WRITE(6,*)
        WRITE(6,*) '***ERROR IN LININT: X OUT OF RANGE ***'
        WRITE(6,*)
        WRITE(6,*) 'X-RANGE:',XA(1),'-',XA(N)
        WRITE(6,*) 'X:      ',X
        WRITE(6,*)
        IERR=1
        RETURN
      ENDIF

      IF( XA(N).LT.XA(1)) THEN
        WRITE(6,*)
        WRITE(6,*) '***ERROR IN LININT: X NOT INCREASING ***'
        WRITE(6,*)
        IERR=1
        RETURN
      ENDIF

      IF (NOLD.EQ.N) THEN
        IF (
     &      XA(1).EQ.XA1OLD
     &      .AND. XA(N).EQ.XANOLD
     &      .AND. YA(1).EQ.YA1OLD
     &      .AND. YA(N).EQ.YANOLD
     &      .AND. X.GT.XA(KLOLD)
     &      ) THEN
          KLO=KLOLD
        ELSE
          KLO=1
        ENDIF
      ELSE
        KLO=1
      ENDIF

      IF (X.LT.XA(KLO+1)) THEN
      KHI=KLO+1
      GOTO 2
      ENDIF

      KHI=N
1     IF (KHI-KLO.GT.1) THEN
        K=(KHI+KLO)/2
        IF(XA(K).GT.X)THEN
          KHI=K
        ELSE
          KLO=K
        ENDIF
      GOTO 1
      ENDIF

2     H=XA(KHI)-XA(KLO)

C LINEAR INTERPOLATION

      IF (H.NE.0.) THEN
            Y=YA(KLO)+(X-XA(KLO))/H*(YA(KHI)-YA(KLO))
      ELSE
C           IF (YA(KLO).NE.YA(KHI)) STOP '*** SR LININT: Bad Input ***'
            Y=YA(KLO)
      ENDIF

      KLOLD=KLO
      NOLD=N
      XA1OLD=XA(1)
      XANOLD=XA(N)
      YA1OLD=YA(1)
      YANOLD=YA(N)

      RETURN
      END
+DECK,math1.
*CMZ :  2.50/00 13/04/2004  14.46.45  by  Michael Scheer
*-- Author :    Michael Scheer   05/04/2004
      subroutine math1(a0,a1,a2,a3,ph0,ph1,ph2,w,th,tl,fint)
+seq,gplhint.

      implicit none

      double complex zi,fint,finth,fintl
      double precision a0,a1,a2,a3,ph0,ph1,ph2,w,t,th,tl,pi

      parameter (pi=3.141592653589793D0)
      parameter (zi=(0.0d0,1.0d0))

      t=th
      finth=
     &  (
     &  exp(-zi*(ph0+ph1*(t-tl))*w)*
     &  (zi*a0*ph1*w + a1*(1.0d0 + zi*ph1*(t-tl)*w))
     &  )/
     &  (ph1*w)**2

      t=tl
      fintl=
     &  (
     &  exp(-zi*(ph0+ph1*(t-tl))*w)*
     &  (zi*a0*ph1*w + a1*(1.0d0 + zi*ph1*(t-tl)*w))
     &  )/
     &  (ph1*w)**2

      fint=finth-fintl

      return
      end
+DECK,MHROUT.
*CMZ :  4.00/14 01/01/2022  22.11.28  by  Michael Scheer
*CMZ :  4.00/13 20/12/2021  14.08.18  by  Michael Scheer
*CMZ :  4.00/04 17/05/2019  14.22.20  by  Michael Scheer
*CMZ :  3.03/04 02/01/2018  15.10.10  by  Michael Scheer
*CMZ :  3.02/06 15/04/2015  12.10.51  by  Michael Scheer
*CMZ :  3.02/05 22/03/2015  19.10.31  by  Michael Scheer
*CMZ :  3.02/03 10/11/2014  14.50.57  by  Michael Scheer
*CMZ :  3.02/00 24/09/2014  11.50.26  by  Michael Scheer
*CMZ :  3.01/07 23/06/2014  16.07.32  by  Michael Scheer
*CMZ :  3.01/06 20/06/2014  16.51.11  by  Michael Scheer
*CMZ :  3.01/05 13/06/2014  09.06.46  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  10.40.59  by  Michael Scheer
*CMZ :  2.70/11 22/02/2013  14.43.36  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  12.35.44  by  Michael Scheer
*CMZ :  2.68/05 24/09/2012  12.06.38  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  16.02.29  by  Michael Scheer
*CMZ :  2.63/03 10/06/2008  14.12.49  by  Michael Scheer
*CMZ :  2.48/04 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.48/03 03/03/2004  12.49.39  by  Michael Scheer
*CMZ :  2.42/02 12/09/2002  11.04.58  by  Michael Scheer
*CMZ :  2.41/13 22/08/2002  17.13.40  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.41/05 18/04/2002  11.45.24  by  Michael Scheer
*CMZ :  2.40/02 14/03/2002  16.22.32  by  Michael Scheer
*CMZ :  2.40/00 11/03/2002  16.44.01  by  Michael Scheer
*CMZ :  2.17/00 02/11/2000  16.36.28  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.25.04  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  15.07.22  by  Michael Scheer
*CMZ :  1.00/00 30/09/97  11.38.28  by  Michael Scheer
*-- Author :    Michael Scheer   24/09/97
      SUBROUTINE MHROUT(JD,ICYCLE,CHOPT)
+seq,gplhint.

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,cmpara.
+seq,whbook.
+seq,pawcmn.
+SEq,rootc,if=-noroot.

      INTEGER NVARMXP,NDIMTP
      PARAMETER (NDIMTP=10)   !SEE ALSO CHARACTER(10) CHTAG
      PARAMETER (NVARMXP=100)

      INTEGER ID,ICYCLE,NID,IDVECT(10000),I,JD,KIND(32),LUNU,ic
      INTEGER IX,IY,JHISASCII,ivar,NVAR,NEVENT,IERR,IJ,II,III,N,NTAGMX
      INTEGER I1DIM,I2DIM,INTUP,ICAL,J,NX,NY,LOC,NWT,INOHEADER
      INTEGER ITIT,JTIT,IGETLASTCHAR
      integer kdcode,istat

      REAL*4 X,Y,XMI,XMA,YMI,YMA,DX,HIm,DY,HIJM
      REAL*4 XNTUP(NVARMXP),RLOW(NVARMXP),RHIGH(NVARMXP)

      CHARACTER(1) CHOPT,C
      CHARACTER(10) CHTAG(NVARMXP),CHDUM
      CHARACTER(16) CRUN,CID
      CHARACTER(80) TIT,TIT1,CHVAR,CLINE
      CHARACTER(128) FILE,FILE1
      character(1024) cwrite
      EXTERNAL IGETLASTCHAR
      equivalence(c,ic)
      data ic/0/

      DATA ICAL/0/
      DATA INOHEADER/0/
      DATA LUNU/99/
      data kdcode/0/

      IF (IHISASCII.NE.0.and.mhbookp.eq.0) THEN

        IF (ICAL.EQ.0) THEN
          JHISASCII=ABS(IHISASCII)
          IF (IHISASCII.LT.0) THEN
            INOHEADER=1
          ENDIF
          I1DIM=(JHISASCII-JHISASCII/10*10)/1
          I2DIM=(JHISASCII-JHISASCII/100*100)/10
          INTUP=(JHISASCII-JHISASCII/1000*1000)/100
          CALL miztoc(ABS(ICODE),CRUN)
          ICAL=1
        ENDIF

        IF (JD.EQ.0) THEN
          CALL hidallm(IDVECT,NID)
        ELSE   !JD.EQ.0
          NID=1
          IDVECT(1)=JD
        ENDIF  !JD.EQ.0

        DO I=1,NID
          ID=IDVECT(I)
          IF (ID.EQ.16) THEN
            LUNGFO=6
          ELSE
            LUNGFO=16
          ENDIF
          call hkindm(ID,KIND,'A')

          CID='          '
          CALL miztoc(ID,CID)
          JTIT=IGETLASTCHAR(1,10,CID,C)

          IF (KIND(1).NE.0) THEN
            IF (I1DIM.NE.0) THEN
              CALL hgivem(ID,TIT,NX,XMI,XMA,NY,YMI,YMA,NWT,LOC)
              DO ITIT=1,IGETLASTCHAR(1,80,TIT,C)
                C=TIT(ITIT:ITIT)
                IF (C.GE.'A'.AND.C.LE.'Z') ic=ic+32
                IF (
     &              C.GE.'A'.AND.C.LE.'Z'
     &              .OR.C.GE.'a'.AND.C.LE.'z'
     &              .OR.C.GE.'0'.AND.C.LE.'9'
     &              .OR.C.EQ.'('.AND.C.EQ.')'
     &              ) THEN
                  TIT1(ITIT:ITIT)=c
                ELSE
                  TIT1(ITIT:ITIT)='_'
                ENDIF
              ENDDO
              ITIT=IGETLASTCHAR(1,80,TIT,C)
              do while (tit1(itit:itit).eq.'_')
                itit=itit-1
              enddo
              FILE=TIT1(1:ITIT)//'_'//CID(1:JTIT)//'.wvh'
              ITIT=IGETLASTCHAR(1,128,FILE,C)
              IF (ITIT.GE.50) THEN
                J=0
                DO II=1,ITIT
                  IF (FILE(II:II).NE.'_') THEN
                    J=J+1
                    FILE1(J:J)=FILE(II:II)
                  ENDIF
                ENDDO
                FILE=FILE1
              ENDIF   !(ITIT.GT.80)

              OPEN(UNIT=LUNU,FILE=FILE)

              IF (INOHEADER.EQ.0) THEN
                WRITE(LUNU,*)CHISASCII//' HBOOK1'
                CLINE(1:1)=CHISASCII
                CLINE(2:2)=' '
                WRITE(CLINE(3:10),'(I8)')ICODE
                CLINE=CLINE(1:10)//' | '//CODE
                WRITE(LUNU,*)CLINE
                WRITE(CLINE(3:10),'(I8)')ID
                CLINE=CLINE(1:10)//' | '//TIT(1:ITIT)
                WRITE(LUNU,*)CLINE
              ENDIF
              DX=(XMA-XMI)/NX
              X=XMI-0.5*DX
              DO IX=1,NX
                X=X+DX
                WRITE(LUNU,*)X,HIm(ID,IX)
              ENDDO   !IX
              CLOSE(LUNU)
            ENDIF !I1DIM
          ELSE IF  (KIND(2).NE.0) THEN
            IF  (I2DIM.NE.0) THEN
              CALL hgivem(ID,TIT,NX,XMI,XMA,NY,YMI,YMA,NWT,LOC)
              DO ITIT=1,IGETLASTCHAR(1,80,TIT,C)
                C=TIT(ITIT:ITIT)
                IF (C.GE.'A'.AND.C.LE.'Z') ic=ic+32
                IF (
     &              C.GE.'A'.AND.C.LE.'Z'
     &              .OR.C.GE.'a'.AND.C.LE.'z'
     &              .OR.C.GE.'0'.AND.C.LE.'9'
     &              .OR.C.EQ.'('.AND.C.EQ.')'
     &              ) THEN
                  TIT1(ITIT:ITIT)=c
                ELSE
                  TIT1(ITIT:ITIT)='_'
                ENDIF
              ENDDO
              ITIT=IGETLASTCHAR(1,80,TIT,C)
              do while (tit1(itit:itit).eq.'_')
                itit=itit-1
              enddo
              FILE=TIT1(1:ITIT)//'_'//CID(1:JTIT)//'.wvh'
              ITIT=IGETLASTCHAR(1,128,FILE,C)
              IF (ITIT.GE.50) THEN
                J=0
                DO II=1,ITIT
                  IF (FILE(II:II).NE.'_') THEN
                    J=J+1
                    FILE1(J:J)=FILE(II:II)
                  ENDIF
                ENDDO
                FILE=FILE1
              ENDIF   !(ITIT.GT.80)

              OPEN(UNIT=LUNU,FILE=FILE)

              IF (INOHEADER.EQ.0) THEN
                WRITE(LUNU,*)CHISASCII//' HBOOK2'
                CLINE(1:1)=CHISASCII
                CLINE(2:2)=' '
                WRITE(CLINE(3:10),'(I8)')ICODE
                CLINE=CLINE(1:10)//' | '//CODE
                WRITE(LUNU,*)CLINE
                WRITE(CLINE(3:10),'(I8)')ID
                CLINE=CLINE(1:10)//' | '//TIT(1:ITIT)
                WRITE(LUNU,*)CLINE
              ENDIF
              DX=(XMA-XMI)/NX
              DY=(YMA-YMI)/NX
              Y=YMI-0.5*DY
              DO IY=1,NY
                Y=Y+DY
                X=XMI-0.5*DX
                DO IX=1,NX
                  X=X+DX
                  WRITE(LUNU,*)X,Y,HIJM(ID,IX,IY)
                ENDDO   !IX
              ENDDO   !IY
              CLOSE(LUNU)
            ENDIF  ! I2DIM
          ELSE IF  (KIND(4).NE.0) THEN
            IF  (INTUP.NE.0) THEN
              IF  (ID.NE.15.AND.ID.NE.16) THEN
                DO IJ=1,NVARMXP
                  CHTAG(IJ)='          '
                ENDDO   !IJ
                CALL HGNPARm(ID,'MHROUT')
                CALL hnoentm(ID,NEVENT)
                NVAR=NVARMXP
                CALL hgivenm(ID,TIT,NVAR,CHTAG,RLOW,RHIGH)
                DO ITIT=1,IGETLASTCHAR(1,80,TIT,C)
                  C=TIT(ITIT:ITIT)
                  IF (C.GE.'A'.AND.C.LE.'Z') ic=ic+32
                  IF (
     &                C.GE.'A'.AND.C.LE.'Z'
     &                .OR.C.GE.'a'.AND.C.LE.'z'
     &                .OR.C.GE.'0'.AND.C.LE.'9'
     &                .OR.C.EQ.'('.AND.C.EQ.')'
     &                ) THEN
                    TIT1(ITIT:ITIT)=c
                  ELSE
                    TIT1(ITIT:ITIT)='_'
                  ENDIF
                ENDDO
                ITIT=IGETLASTCHAR(1,80,TIT,C)
                do while (tit1(itit:itit).eq.'_')
                  itit=itit-1
                enddo
                FILE=TIT1(1:ITIT)//'_'//CID(1:JTIT)//'.wvh'
                ITIT=IGETLASTCHAR(1,128,FILE,C)
                IF (ITIT.GE.50) THEN
                  J=0
                  DO II=1,ITIT
                    IF (FILE(II:II).NE.'_') THEN
                      J=J+1
                      FILE1(J:J)=FILE(II:II)
                    ENDIF
                  ENDDO
                  FILE=FILE1
                ENDIF !(ITIT.GT.80)
                IF (NVAR.GT.NVARMXP) THEN
                  WRITE(6,*)
     &              '*** ERROR IN MHROUT: DIMENSION NVARMXP EXCEEDED ***'
                  WRITE(6,*)'*** NTUPLE: ',ID,TIT
                  STOP
                ENDIF
                NTAGMX=0
                DO 10 II=1,NVARMXP
                  DO IJ=1,NDIMTP
                    CHDUM=CHTAG(II)
                    IF (CHDUM(IJ:IJ).EQ.' ') THEN
                      IF (IJ.GE.NTAGMX) THEN
                        NTAGMX=IJ
                        GOTO 10
                      ENDIF
                    ENDIF
                  ENDDO  !IJ
10              CONTINUE !II

                if (nvar.le.5) then
                  OPEN(UNIT=LUNU,FILE=FILE,recl=256)
                else if (nvar.le.10) then
                  OPEN(UNIT=LUNU,FILE=FILE,recl=512)
                else if (nvar.le.20) then
                  OPEN(UNIT=LUNU,FILE=FILE,recl=1024)
                else if (nvar.le.50) then
                  OPEN(UNIT=LUNU,FILE=FILE,recl=2048)
                else
                  OPEN(UNIT=LUNU,FILE=FILE)
                endif

                IF (INOHEADER.EQ.0) THEN
                  WRITE(LUNU,*)CHISASCII//' hbookn'
                  CLINE(1:1)=CHISASCII
                  CLINE(2:2)=' '
                  WRITE(CLINE(3:10),'(I8)')ICODE
                  CLINE=CLINE(1:10)//' | '//CODE
                  WRITE(LUNU,*)CLINE
                  WRITE(CLINE(3:10),'(I8)')ID
                  CLINE=CLINE(1:10)//' | '//TIT(1:ITIT)
                  WRITE(LUNU,*)CLINE
                  WRITE(LUNU,*)CHISASCII,' ',NVAR,NTAGMX-1,nevent
                  WRITE(LUNU,*)CHISASCII,' ',(CHtag(ivar)(1:ntagmx),ivar=1,nvar)
                  WRITE(LUNU,*)CHISASCII
                ENDIF   !INOHEADER
                DO IX=1,NEVENT
                  CALL hgnfm(ID,IX,XNTUP,IERR)
                  IF (IERR.NE.0) THEN
                    WRITE(LUNGFO,*)
                    WRITE(LUNGFO,*)'*** WARNING IN MHROUT:'
                    WRITE(LUNGFO,*)'ERROR WHILE READING NTUPLE'
                    WRITE(LUNGFO,*)'NTUPLE, EVENT:', ID,IX
                    WRITE(6,*)
                    WRITE(6,*)'*** WARNING IN MHROUT:'
                    WRITE(6,*)'ERROR WHILE READING NTUPLE'
                    WRITE(6,*)'NTUPLE, EVENT:', ID,IX
                  ENDIF  !IERR
                  WRITE(cwrite,*)(XNTUP(N),N=1,NVAR)
                  write(lunu,*)cwrite(2:len_trim(cwrite))
                ENDDO   !NEVENT
                CLOSE(LUNU)
              ELSE IF (INTUP.NE.0.AND.ID.EQ.15) THEN !ID
                OPEN(UNIT=LUNU,FILE=FILE)

                IF (INOHEADER.EQ.0) THEN
                  WRITE(LUNU,*)'! NTUPLE 15 OF WAVE.IN'
                  WRITE(LUNU,*)'!',ICODE,CODE
                  WRITE(LUNU,*)'!'
                ENDIF   !INOHEADER
                REWIND(LUNGFI)
100             READ(LUNGFI,'(A)',END=900)TIT
                WRITE(LUNU,*)TIT
                GOTO 100
900             CLOSE(LUNU)
              ELSE IF (INTUP.NE.0.AND.ID.EQ.16) THEN !ID
                OPEN(UNIT=LUNU,FILE=FILE)
                IF (INOHEADER.EQ.0) THEN
                  WRITE(LUNU,*)'! NTUPLE 16 OF WAVE.OUT'
                  WRITE(LUNU,*)'!',ICODE,CODE
                  WRITE(LUNU,*)'!'
                ENDIF   !INOHEADER
                REWIND(16)
101             READ(16,'(A)',END=901)TIT
                WRITE(LUNU,*)TIT
                GOTO 101
901             CLOSE(LUNU)
              ELSE  !ID
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'*** WARNING IN MHROUT:'
                WRITE(LUNGFO,*)'UNKNOWN HISTOGRAM TYPE'
                WRITE(LUNGFO,*)'CANNOT WRITE ASCII FILE FOR ID',ID
                WRITE(LUNGFO,*)
                WRITE(6,*)
                WRITE(6,*)'*** WARNING IN MHROUT:'
                WRITE(6,*)'UNKNOWN HISTOGRAM TYPE'
                WRITE(6,*)'CANNOT WRITE ASCII FILE FOR ID',ID
                WRITE(6,*)
              ENDIF !ID
            ENDIF !INTUP
          ELSE
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** WARNING IN MHROUT:'
            WRITE(LUNGFO,*)'UNKNOWN HISTOGRAM TYPE'
            WRITE(LUNGFO,*)'CANNOT WRITE ASCII FILE FOR ID',ID
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)'*** WARNING IN MHROUT:'
            WRITE(6,*)'UNKNOWN HISTOGRAM TYPE'
            WRITE(6,*)'CANNOT WRITE ASCII FILE FOR ID',ID
            WRITE(6,*)
          ENDIF   !KIND
        ENDDO  !I
      else IF (IHISASCII.NE.0.and.mhbookp.ne.0) THEN
        call mh_ascii(jd,ihisascii,icode,chisascii,code)
      ENDIF !IHISASCII

      if (iroottrees.ge.0) CALL HROUTm(JD,ICYCLE,CHOPT)

      LUNGFO=16

      if (iroottrees.ne.0) then
+self,if=-noroot.

        if (jd.eq.0) then
          nid=0
          do i=1,nhismaxp
            if (kindhis(i).gt.0) then
              nid=nid+1
              idvect(nid)=i
            endif
          enddo
        else   !jd.eq.0
          nid=1
          idvect(1)=jd
        endif  !jd.eq.0

        do i=1,nid
          id=idvect(i)
          kind(1)=kindhis(id)
          if (id.eq.idcode) then
            if (kdcode.eq.0) then
              call mshrootout(id,kind(1))
              kdcode=1
            endif
          else
            call mshrootout(id,kind(1))
          endif
        enddo
+self.,if=-noroot.

      endif !iroottrees

      RETURN
      END
+DECK,modulator.
*CMZ :  2.63/03 02/06/2009  16.19.23  by  Michael Scheer
*CMZ :  2.61/04 29/03/2007  16.12.06  by  Michael Scheer
*CMZ :  2.57/05 14/12/2006  10.19.14  by  Michael Scheer
*CMZ :  2.52/09 29/10/2004  11.46.00  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.35  by  Michael Scheer
*CMZ :  1.03/06 06/08/98  18.01.12  by  Michael Scheer
*CMZ :  1.02/00 18/12/97  11.55.12  by  Michael Scheer
*CMZ :  1.01/00 28/10/97  18.46.16  by  Michael Scheer
*CMZ :  1.00/00 06/06/97  18.18.12  by  Michael Scheer
*-- Author :    Michael Scheer   05/06/97

      SUBROUTINE MODULATOR(GRARAD)
+seq,gplhint.

C--- INPUT REC-MODULATOR VIA THIS ROUTINE AT THE END OF SR REC_INIT

      IMPLICIT NONE

+SELF,IF=LINUX.
      EXTERNAL DCOSD,DSIND
      DOUBLE PRECISION DCOSD,DSIND
+SELF.

+SEQ,KLOTZ.
+SEQ,MODULATOR.

      DOUBLE PRECISION XMOD(NMAGMODP*NSLICEP)
     &  ,YMOD(NMAGMODP*NSLICEP)
     &  ,ZMOD(NMAGMODP*NSLICEP)
     &  ,DXMOD(NMAGMODP*NSLICEP)
     &  ,DYMOD(NMAGMODP*NSLICEP)
     &  ,DZMOD(NMAGMODP*NSLICEP)
     &  ,THEMOD(NMAGMODP*NSLICEP)
     &  ,PHIMOD(NMAGMODP*NSLICEP)
     &  ,BCBCMOD(NMAGMODP*NSLICEP)

      DOUBLE PRECISION Y,DLY,Y2,Y1,BCCOS,BCSIN,RHO2,GRARAD

      INTEGER IMAG,I,KMAG,LMAG,ICAL,IREAD,JMAG

      DATA ICAL/0/

      IF (NMAGMOD.LT.0) THEN
        IREAD=1
        OPEN(UNIT=99,FILE='therot.dat',STATUS='OLD')
        read(99,*)nmagmod
      ELSE
        IREAD=0
      ENDIF

      IF (NSLICE.GT.NSLICEP) THEN
        WRITE(6,*) '*** DIMENSION NSLICEP EXCEEDED ***'
        STOP
      ENDIF

      IF (NMAGMOD.GT.NMAGMODP) THEN
        WRITE(6,*)'*** DIMENSION NMAGMODP EXCEEDED ***'
        STOP
      ENDIF

      IF (2*NMAGMOD*NSLICE+IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)'*** ERROR IN MODULATOR: DIMENSION NKLOTZ EXCEEDED ***'
        STOP
      ENDIF

      IF (ICAL.EQ.0) THEN
        IF (IREAD.GT.0) THEN
          DO IMAG=1,NMAGMOD
            READ(99,*)RADIMOD(IMAG),ZLENMOD(IMAG),
     &        CENMODX(IMAG),CENMODY(IMAG),CENMODZ(IMAG),
     &        THEROT(IMAG),BCMOD(IMAG)
          ENDDO
          CLOSE(99)
        ENDIF !IREAD

        IF (ITHEMSYM.EQ.1.OR.ITHEMSYM.EQ.2) THEN

          IF (NMAGMOD*2*ITHEMSYM.GT.NMAGMODP) THEN
            WRITE(6,*)'*** DIMENSION NMAGMODP EXCEEDED ***'
            STOP
          ENDIF

          IF (2*NMAGMOD*2*ITHEMSYM*NSLICE+IMAGTOT.GT.NKLOTZ) THEN
            WRITE(6,*)'*** ERROR IN MODULATOR: DIMENSION NKLOTZ EXCEEDED ***'
            STOP
          ENDIF

          IF (ITHEMSYM.EQ.1) THEN !cerror? 2jun09

            DO IMAG=1,NMAGMOD
              JMAG=IMAG+NMAGMOD
              RADIMOD(JMAG)=RADIMOD(IMAG)
              ZLENMOD(JMAG)=ZLENMOD(IMAG)
              CENMODX(JMAG)=CENMODX(IMAG)
              CENMODY(JMAG)=-CENMODY(IMAG)
              CENMODZ(JMAG)=CENMODZ(IMAG)
              THEROT(JMAG)=THEROT(IMAG)
              BCMOD(JMAG)=BCMOD(IMAG)
            ENDDO !IMAG=1,NMAGMOD

          NMAGMOD=NMAGMOD*2

          ENDIF

          IF (ITHEMSYM.EQ.2) THEN

            DO IMAG=1,NMAGMOD
              JMAG=IMAG+NMAGMOD
              RADIMOD(JMAG)=RADIMOD(IMAG)
              ZLENMOD(JMAG)=ZLENMOD(IMAG)
              CENMODX(JMAG)=-CENMODX(IMAG)
              CENMODY(JMAG)=CENMODY(IMAG)
              CENMODZ(JMAG)=CENMODZ(IMAG)
              THEROT(JMAG)=THEROT(IMAG)
              BCMOD(JMAG)=BCMOD(IMAG)
            ENDDO !IMAG=1,NMAGMOD

            NMAGMOD=NMAGMOD*2

          ENDIF !ITHESMSYM

        ENDIF !ITHESMSYM

        IF (ITHESYML.EQ.-1) THEN
          DO IMAG=1,NMAGMOD
            IF (CENMODY(IMAG).LT.0.0D0) THEROT(IMAG)=-THEROT(IMAG)
          ENDDO   !IMAG=1,NMAGMOD
        ENDIF !ITHESYMU

        IF (ITHESYMD.EQ.-1) THEN
          DO IMAG=1,NMAGMOD
            IF (CENMODZ(IMAG).GT.0.0D0) THEROT(IMAG)=-THEROT(IMAG)
          ENDDO   !IMAG=1,NMAGMOD
        ENDIF !ITHESYMD

        DO IMAG=1,NMAGMOD

          RADIMOD(IMAG)=RADIMOD(IMAG)*SCALRAD
          THEROT(IMAG)=THEROT(IMAG)*SCALTHE

          IF (CENMODY(IMAG).LT.0.0D0) THEN
            IF (CENMODX(IMAG).GE.0.0D0) THEN
              THEROT(IMAG)=THEROT(IMAG)+ITHESYML*ITHESYMD*THEGROTL
            ELSE
              THEROT(IMAG)=THEROT(IMAG)+ITHESYML*THEGROTL
            ENDIF
          ELSE
            IF (CENMODX(IMAG).GE.0.0D0) THEN
              THEROT(IMAG)=THEROT(IMAG)+ITHESYMD*THEGROTU
            ELSE
              THEROT(IMAG)=THEROT(IMAG)+THEGROTL
            ENDIF
          ENDIF

        ENDDO  !IMAG=1,NMAGMOD

        ICAL=1

      ENDIF !(ICAL.EQ.0)

      DO IMAG=1,NMAGMOD

        BCCOS=BCMOD(IMAG)*DCOSD(THEROT(IMAG))*SCALMOD
        IF (ABS(BCCOS).LT.1.0D-10) BCCOS=0.0D0
        BCSIN=BCMOD(IMAG)*DSIND(THEROT(IMAG))*SCALMOD
        IF (ABS(BCSIN).LT.1.0D-10) BCSIN=0.0D0

        RHO2=RADIMOD(IMAG)*RADIMOD(IMAG)
        DLY=2.D0*RADIMOD(IMAG)/NSLICE

        DO I=1,NSLICE

          KMAG=IMAG+I-1
          LMAG=KMAG+NSLICE

          Y2=CENMODY(IMAG)-RADIMOD(IMAG)+DLY*I
          Y1=Y2-DLY
          Y=(Y2+Y1)/2.D0

          XMOD(KMAG)=CENMODX(IMAG)
          DXMOD(KMAG)=2.D0*DSQRT(RHO2-(Y-CENMODY(IMAG))**2)
          YMOD(KMAG)=Y
          DYMOD(KMAG)=DLY
          ZMOD(KMAG)=CENMODZ(IMAG)
          DZMOD(KMAG)=ZLENMOD(IMAG)
          BCBCMOD(KMAG)=BCCOS
          THEMOD(KMAG)=0.D0
          PHIMOD(KMAG)=0.D0

          XMOD(LMAG)=XMOD(KMAG)
          YMOD(LMAG)=YMOD(KMAG)
          ZMOD(LMAG)=ZMOD(KMAG)
          DXMOD(LMAG)=DXMOD(KMAG)
          DYMOD(LMAG)=DYMOD(KMAG)
          DZMOD(LMAG)=DZMOD(KMAG)
          BCBCMOD(LMAG)=BCSIN
          THEMOD(LMAG)=90.D0
          PHIMOD(LMAG)=0.D0

          IMAGTOT=IMAGTOT+1
          DX(IMAGTOT)=XMOD(KMAG)
          DY(IMAGTOT)=YMOD(KMAG)
          DZ(IMAGTOT)=ZMOD(KMAG)
          XLEN(IMAGTOT)=DXMOD(KMAG)
          YLEN(IMAGTOT)=DYMOD(KMAG)
          ZLEN(IMAGTOT)=DZMOD(KMAG)
          THETA(IMAGTOT)=THEMOD(KMAG)*GRARAD
          PHI(IMAGTOT)=PHIMOD(KMAG)*GRARAD
          BC(IMAGTOT)=BCBCMOD(KMAG)

          IMAGTOT=IMAGTOT+1
          DX(IMAGTOT)=XMOD(LMAG)
          DY(IMAGTOT)=YMOD(LMAG)
          DZ(IMAGTOT)=ZMOD(LMAG)
          XLEN(IMAGTOT)=DXMOD(LMAG)
          YLEN(IMAGTOT)=DYMOD(LMAG)
          ZLEN(IMAGTOT)=DZMOD(LMAG)
          THETA(IMAGTOT)=THEMOD(LMAG)*GRARAD
          PHI(IMAGTOT)=PHIMOD(LMAG)*GRARAD
          BC(IMAGTOT)=BCBCMOD(LMAG)

        ENDDO   !NSLICE

      ENDDO !NMAGMOD

      RETURN
      END
+DECK,MYBFELD.
*CMZ :  4.01/04 27/11/2023  12.51.04  by  Michael Scheer
*CMZ :  4.00/17 04/10/2022  08.10.22  by  Michael Scheer
*CMZ :  4.00/16 22/07/2022  08.40.59  by  Michael Scheer
*CMZ :  4.00/15 28/04/2022  15.43.36  by  Michael Scheer
*CMZ :  4.00/13 09/11/2021  09.50.16  by  Michael Scheer
*CMZ :  4.00/11 17/05/2021  12.32.15  by  Michael Scheer
*CMZ :  4.00/09 12/08/2020  12.58.53  by  Michael Scheer
*CMZ :  4.00/07 09/07/2020  16.53.44  by  Michael Scheer
*CMZ :  4.00/04 17/05/2019  14.17.20  by  Michael Scheer
*CMZ :  4.00/03 07/05/2019  14.19.31  by  Michael Scheer
*CMZ :  3.07/01 29/03/2019  10.40.58  by  Michael Scheer
*CMZ :  3.05/10 13/08/2018  14.40.26  by  Michael Scheer
*CMZ :  3.05/03 16/05/2018  15.26.02  by  Michael Scheer
*CMZ :  3.05/00 26/04/2018  11.52.54  by  Michael Scheer
*CMZ :  3.03/04 29/11/2017  10.16.03  by  Michael Scheer
*CMZ :  3.03/02 08/01/2016  19.14.53  by  Michael Scheer
*CMZ :  3.02/03 04/11/2014  12.27.30  by  Michael Scheer
*CMZ :  3.01/03 07/03/2014  13.20.05  by  Michael Scheer
*CMZ :  2.70/12 18/09/2013  12.33.23  by  Michael Scheer
*CMZ :  2.68/03 03/08/2012  09.40.49  by  Michael Scheer
*CMZ :  2.68/02 31/07/2012  14.28.27  by  Michael Scheer
*CMZ :  2.67/02 03/05/2012  09.16.43  by  Michael Scheer
*CMZ :  2.66/20 22/11/2011  10.35.21  by  Michael Scheer
*CMZ :  2.66/07 09/12/2009  10.50.24  by  Michael Scheer
*CMZ :  2.66/06 26/11/2009  19.35.32  by  Michael Scheer
*CMZ :  2.64/01 20/08/2009  11.50.48  by  Michael Scheer
*CMZ :  2.63/05 22/07/2009  08.28.26  by  Michael Scheer
*CMZ :  2.63/02 07/03/2008  10.34.54  by  Michael Scheer
*CMZ :  2.61/05 11/04/2007  11.58.07  by  Michael Scheer
*CMZ :  2.59/01 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.57/05 09/01/2007  16.55.37  by  Michael Scheer
*CMZ :  2.56/02 21/10/2005  16.31.31  by  Michael Scheer
*CMZ :  2.54/05 19/05/2005  09.11.03  by  Michael Scheer
*CMZ :  2.53/05 16/02/2005  14.45.59  by  Michael Scheer
*CMZ :  2.52/13 16/12/2004  18.11.37  by  Michael Scheer
*CMZ :  2.47/23 17/02/2004  10.36.15  by  Michael Scheer
*CMZ :  2.47/08 15/05/2003  15.38.12  by  Michael Scheer
*CMZ :  2.46/01 18/12/2002  11.40.26  by  Michael Scheer
*CMZ :  2.46/00 17/12/2002  15.37.28  by  Michael Scheer
*CMZ :  2.45/03 17/12/2002  14.53.11  by  Michael Scheer
*CMZ :  2.45/02 16/12/2002  14.32.25  by  Michael Scheer
*CMZ :  2.44/01 11/12/2002  11.12.28  by  Michael Scheer
*CMZ :  2.44/00 06/11/2002  11.28.41  by  Michael Scheer
*CMZ :  2.41/05 17/04/2002  15.14.11  by  Michael Scheer
*CMZ :  2.15/00 15/05/2000  16.34.53  by  Michael Scheer
*CMZ :  2.13/08 29/02/2000  15.51.27  by  Michael Scheer
*CMZ :  2.13/00 03/12/99  16.04.43  by  Michael Scheer
*CMZ :  2.12/04 27/08/99  13.24.54  by  Michael Scheer
*CMZ :  2.11/00 12/05/99  11.47.07  by  Michael Scheer
*CMZ :  2.02/00 05/02/99  15.05.53  by  Michael Scheer
*CMZ :  1.02/03 09/01/98  19.39.53  by  Michael Scheer
*CMZ :  1.02/00 06/01/98  15.13.36  by  Michael Scheer
*CMZ :  1.00/00 26/06/97  10.31.19  by  Michael Scheer
*CMZ : 00.02/04 18/02/97  16.35.49  by  Michael Scheer
*CMZ : 00.02/03 24/01/97  14.20.47  by  Michael Scheer
*CMZ : 00.02/00 21/11/96  14.21.30  by  Michael Scheer
*CMZ : 00.01/10 04/06/96  18.05.02  by  Michael Scheer
*CMZ : 00.01/09 06/05/96  14.23.34  by  Michael Scheer
*CMZ : 00.01/08 22/06/95  09.51.54  by  Michael Scheer
*CMZ : 00.01/07 16/03/95  14.22.58  by  Michael Scheer
*CMZ : 00.01/03 28/11/94  11.33.22  by  Michael Scheer
*CMZ : 00.00/05 29/04/94  19.28.03  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.55  by  Michael Scheer
*-- Author : Michael Scheer
C*******************************************************************************
      Subroutine MYBFELD(XIII,YIII,ZIII,BX,BY,BZ,AX,AY,AZ)
C*******************************************************************************

+seq,gplhint.
      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,B0SCGLOB.
+SEQ,efield.
+SEQ,TRACK.
+seq,undumagc.
+seq,debugwave.

      DOUBLE PRECISION XII,YII,ZII,SIGX,SIGY,SIGZ,DMODFULL,DMODHALF,PERHALF
      DOUBLE PRECISION XI,YI,ZI,X,Y,Z,BX,BY,BZ,AX,AY,AZ,BZD,BYD,AZD,AYD,ZD
     &                  ,YD,BB,PERQUAD,PER3QUAD,DMODQUAD,XIII,YIII,ZIII

      DOUBLE PRECISION BXM,BYM,BZM,BXE,BYE,BZE,AXE,AYE,AZE
      DOUBLE PRECISION BXSUPER,BYSUPER,BZSUPER,AXSUPER,AYSUPER,AZSUPER
     &  ,BMASK(3,10000),BXX,dum,xr,yr,zr

      real g(3)
      INTEGER ICAL,NBMASK,I,IWARN,ifail,iwarnu

      DATA ICAL/0/,IWARN/0/,iwarnu/0/

      if (kampli.gt.0) then
        CALL BELLIP(Xiii,Yiii,Ziii,BX,BY,BZ,AX,AY,AZ)
        bx=bx*b0scglob
        by=by*b0scglob
        bz=bz*b0scglob
        return
      endif

      iwarnmyb=0

      XII=XIII
      YII=YIII
      ZII=ZIII

      if (iefield.ne.0) then
        call efield(xii,yii,zii,efieldx,efieldy,efieldz)
      endif

      IF (IMAGSPLN.EQ.-999) THEN !FIELD TO BE CALCULATED BY SPLINE INTERPOLATION
        CALL BMAGSPLN(XII,YII,ZII,BX,BY,BZ)
        if (ibmasksp.ge.0) return
      ENDIF !IMAGSPLN

      IF (ICAL.EQ.0) THEN
        PERHALF=PERIODG/2.D0
        PERQUAD=PERHALF/2.D0
        PER3QUAD=PERHALF+PERQUAD
        IF (DABS(CROTD**2+SROTD**2-1.D0).GT.1.D-10) THEN
          WRITE(LUNGFO,*)
     &      '*** ERROR IN MYBFELD: CALLED BEFORE CALL TO GFINIT'
          WRITE(6,*)
     &      '*** ERROR IN MYBFELD: CALLED BEFORE CALL TO GFINIT'
          STOP
        ENDIF
      ENDIF

      IF (IMAGSPLN.GT.0.OR.IMAGSPLN.EQ.-1111) THEN !FIELD TO BE CALCULATED BY SPLINE INTERPOLATION
        CALL BMAGSPLN(XII,YII,ZII,BX,BY,BZ)
        GOTO 1000
      ENDIF !IMAGSPLN

      XII=XIII+XSHIFT
      YII=YIII+VSHIFT
      ZII=ZIII+HSHIFT

      ZD= CROTD*ZII-SROTD*YII
      YD= SROTD*ZII+CROTD*YII
      ZII=ZD
      YII=YD

      XI=XII
      YI=YII
      ZI=ZII

      SIGX=1.D0
      SIGY=1.D0
      SIGZ=1.D0

      IF (IPERIODG.GT.0) THEN
C OLD MODE, KEPT FOR COMPATIBILITY
        DMODFULL=DMOD(XII-PEROFFG,PERIODG)
        IF (DMODFULL.LT.0.0D0) DMODFULL=DMODFULL+PERIODG
        IF(SIGNG.GE.0.D0) THEN
          SIGX=SIGNG
          SIGY=SIGNG
          SIGZ=SIGNG
          XI=PEROFFG+DMODFULL
        ELSE
          IF (DMODFULL.GT.PERHALF) THEN
            XI=PEROFFG+DMODFULL-PERHALF
            SIGX=SIGNG
            SIGY=SIGNG
            SIGZ=SIGNG
          ELSE
            SIGX=-SIGNG
            SIGY=-SIGNG
            SIGZ=-SIGNG
            XI=PEROFFG+DMODFULL
          ENDIF
        ENDIF   !SIGNG

        IF(SIGNG2.NE.0.0D0) THEN

          DMODFULL=DMOD(XII-PEROFFG,2.0d0*PERIODG)
          IF (DMODFULL.LT.0.0D0) DMODFULL=DMODFULL+2.0d0*PERIODG

          IF (DMODFULL.Ge.PERIODG) then
            SIGX=SIGX*SIGNG2
            SIGY=SIGY*SIGNG2
            SIGZ=SIGZ*SIGNG2
          else
            SIGX=-SIGX*SIGNG2
            SIGY=-SIGY*SIGNG2
            SIGZ=-SIGZ*SIGNG2
          ENDIF !(DMODFULL.GT.PERIODG) THEN

          DMODFULL=DMOD(XII-PEROFFG,PERIODG)
          IF (DMODFULL.LT.0.0D0) DMODFULL=DMODFULL+PERIODG
          XI=PEROFFG+DMODFULL

        ENDIF   !SIGN2

      ELSE IF (IPERIODG.EQ.-1) THEN
c FULL PERIOD
        IF(XII.GE.XPERWMN.AND.XII.LE.XPERWMX) THEN
          DMODFULL=DMOD(XII-PEROFFG,PERIODG)
          IF (DMODFULL.LT.0.0D0) DMODFULL=DMODFULL+PERIODG
          XI=PEROFFG+DMODFULL
        else if(XII.GT.XPERWMX) THEN
          XI=XII-(XPERWMX-XPERWMN)
        ENDIF
      else if (IPERIODG.EQ.-2) THEN
c HALF PERIOD
        IF(XII.GE.XPERWMN.AND.XII.LE.XPERWMX) THEN
          DMODFULL=DMOD(XII-PEROFFG,PERIODG)
          IF (DMODFULL.LT.0.0D0) DMODFULL=DMODFULL+PERIODG
          DMODHALF=DMOD(DMODFULL,PERHALF)
          XI=PEROFFG+DMODHALF
          IF (DMODFULL.GT.PERHALF) THEN
            SIGX=-1.D0
            SIGY=-1.D0
            SIGZ=-1.D0
          ENDIF
        else if(XII.GT.XPERWMX) THEN
          XI=XII-(XPERWMX-XPERWMN)
        ENDIF
      else if (IPERIODG.EQ.-3) THEN
c QUARTER PERIOD, COSINE-LIKE
        IF(XII.GE.XPERWMN.AND.XII.LE.XPERWMX) THEN
          DMODFULL=DMOD(XII-PEROFFG,PERIODG)
          IF (DMODFULL.LT.0.0D0) DMODFULL=DMODFULL+PERIODG
          DMODHALF=DMOD(DMODFULL,PERHALF)
          DMODQUAD=DMOD(DMODHALF,PERQUAD)
          XI=PEROFFG+DMODFULL
          IF(DMODFULL.GE.PER3QUAD) THEN
            XI=PEROFFG+PERQUAD-DMODQUAD
            SIGX=-1.D0
          else if(DMODFULL.GE.PERHALF) THEN
            XI=PEROFFG+DMODQUAD
            SIGX=-1.D0
            SIGY=-1.D0
            SIGZ=-1.D0
          else if(DMODFULL.GE.PERQUAD) THEN
            XI=PEROFFG+PERQUAD-DMODQUAD
            SIGY=-1.D0
            SIGZ=-1.D0
          ENDIF
        else if(XII.GT.XPERWMX) THEN
          XI=XII-(XPERWMX-XPERWMN)
        ENDIF
      else if (IPERIODG.EQ.-4) THEN
c QUARTER PERIOD, SINE-LIKE
        IF(XII.GE.XPERWMN.AND.XII.LE.XPERWMX) THEN
          DMODFULL=DMOD(XII-PEROFFG,PERIODG)
          IF (DMODFULL.LT.0.0D0) DMODFULL=DMODFULL+PERIODG
          DMODHALF=DMOD(DMODFULL,PERHALF)
          DMODQUAD=DMOD(DMODHALF,PERQUAD)
          XI=PEROFFG+DMODFULL
          IF(DMODFULL.GE.PER3QUAD) THEN
            XI=PEROFFG+PERQUAD-DMODQUAD
            SIGY=-1.D0
            SIGZ=-1.D0
          ELSE IF(DMODFULL.GE.PERHALF) THEN
            XI=PEROFFG+DMODQUAD
            SIGX=-1.D0
            SIGY=-1.D0
            SIGZ=-1.D0
          ELSE IF(DMODFULL.GE.PERQUAD) THEN
            XI=PEROFFG+PERQUAD-DMODQUAD
            SIGX=-1.D0
          ENDIF
        else if(XII.GT.XPERWMX) THEN
          XI=XII-(XPERWMX-XPERWMN)
        ENDIF
      ENDIF !IPERIOD

      IF(IBSYM.NE.0) THEN
        X=ABS(XI-XBSYM)
      ELSE
        X=XI
      ENDIF

      IF(IBSYMY.NE.0) THEN
        Y=ABS(YI)
      ELSE
        Y=YI
      ENDIF

      IF(IBSYMZ.NE.0) THEN
        Z=ABS(ZI)
      ELSE
        Z=ZI
      ENDIF

      BX=0.0d0
      BY=0.0d0
      BZ=0.0d0

      AX=0.0d0
      AY=0.0d0
      AZ=0.0d0

      IF (ibmasksp.lt.0) THEN
        CALL BFELD(BXM,BYM,BZM,X,Y,Z)
        bx=bx+bxm
        by=by+bym
        bz=bz+bzm
        IF (KMAGSEQ.lt.0) THEN
          CALL BMAGSEQ(X,Y,Z,BXm,BYm,BZm,dum,dum,dum)
          bx=bx+bxm
          by=by+bym
          bz=bz+bzm
        endif
        goto 100
      ENDIF !(IBMASKSP.NE.0)

      x=x+xbshift

      IF (IBSUPER.EQ.0) THEN

          IF (KHALBA.NE.0) THEN
            CALL BHALBA(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (Kundugap.NE.0) THEN
            CALL Bundugap(X,Y,Z,BX,BY,BZ,AX,AY,AZ,0)
          ELSE IF (KHALBASY.NE.0) THEN
            CALL BHALBASY(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (IRFILF.EQ.1) THEN
            CALL BFOUR(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (IFOURBTABZY.EQ.1) THEN
            CALL BFOURtabzy(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (IRBTAB.ne.0) THEN
            CALL BTAB(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (IRBTABZY.ne.0) THEN
            CALL BTABZY(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (IRBTABXYZ.ne.0) THEN
            CALL BTABXYZ(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (KBEXTERN.EQ.1) THEN
            CALL BEXTERN(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (KUCROSS.EQ.1) THEN
            CALL BUCROSS(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (KELLIP.EQ.1) THEN
            CALL BELLIP(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (KELLANA.EQ.1) THEN
            CALL BELLANA(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (KBREC.EQ.1) THEN
            CALL BREC(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (kbundumag.EQ.1.or.kbundumag.eq.3) THEN
            CALL undumagwav(X,Y,Z,BX,BY,BZ,ifail)
          ELSE IF (KBPOLYMAG.GT.0) THEN
            CALL BPOLYEDER(X,Y,Z,BX,BY,BZ)
          ELSE IF (KMAGSEQ.ne.0) THEN
            CALL BMAGSEQ(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (KBPOLYH.EQ.1) THEN
            CALL BPOLYHARM(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (KBPOLY3D.EQ.1) THEN
            CALL BPOLY3D(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (KBPOLY2DH.EQ.1) THEN
            CALL BPOLY2DH(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (KBPHARM.EQ.1) THEN
            CALL BPHARM(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (IWSECTMAGS.LT.0) THEN
            CALL BSECTMAGS(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
          ELSE IF (KBFELD.EQ.1) THEN
            CALL BFELD( BX, BY, BZ,X,Y,Z)
          ELSE IF (IRFILB0.NE.0 .OR. IRFILB.EQ.1) THEN
            CALL BMESS(X,Y,Z,BX,BY,BZ)
            if (iwarnbmap.ne.0) then
              bx=0.0d0
              by=0.0d0
              bz=0.0d0
c              iwarnmyb=1
            endif
          ELSE IF (IRFILP.EQ.1.AND.ISPLINE.EQ.1) THEN
            CALL BPAND(X,Y,Z,BX,BY,BZ)
          ELSE IF (IRFILP.EQ.1.AND.ISPLINE.NE.1) THEN
            CALL BPANDOLD(X,Y,Z,BX,BY,BZ)
          ELSE IF (KBAMWLS.NE.0) THEN
            CALL BBAMWLS(X,Y,Z,BX,BY,BZ)

+SELF,IF=BHELM.
          ELSE IF (IBHELM.EQ.1) THEN
            CALL BHELM(X,Y,Z,BX,BY,BZ)
+SELF.

          ELSE IF (KBGENESIS.NE.0) THEN
            CALL BGENESIS(X,Y,Z,BX,BY,BZ,AX,AY,AZ)

          ELSE IF (ibmasksp.NE.0) THEN

          ELSE

            STOP '*** SR MYBFELD: NO MAGNETIC FIELD DEFINED ***'

          ENDIF

        ELSE   !IBSUPER

          BXSUPER=0.D0
          BYSUPER=0.D0
          BZSUPER=0.D0

          AXSUPER=0.D0
          AYSUPER=0.D0
          AZSUPER=0.D0

          IF (KHALBA.NE.0) THEN
            CALL BHALBA(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (KHALBASY.NE.0) THEN
            CALL BHALBASY(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (kundugap.NE.0) THEN
            CALL Bundugap(X,Y,Z,BX,BY,BZ,AX,AY,AZ,0)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (IRFILF.EQ.1) THEN
            CALL BFOUR(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (IRBTAB.ne.0) THEN
            CALL BTAB(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (IRBTABZY.ne.0) THEN
            CALL BTABZY(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (IfourBTABZY.ne.0) THEN
            CALL BfourTABZY(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (IRBTABXYZ.ne.0) THEN
            CALL BTABXYZ(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (KBEXTERN.EQ.1) THEN
            CALL BEXTERN(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (KUCROSS.EQ.1) THEN
            CALL BUCROSS(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (KELLIP.EQ.1) THEN
            CALL BELLIP(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (KELLANA.EQ.1) THEN
            CALL BELLANA(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (kbundumag.EQ.1.or.kbundumag.eq.3) THEN
            CALL undumagwav(X,Y,Z,BX,BY,BZ,ifail)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
          endif

          IF (KBREC.EQ.1) THEN
            CALL BREC(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (KBPOLYMAG.GT.0) THEN
            CALL BPOLYEDER(X,Y,Z,BX,BY,BZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (KMAGSEQ.ne.0) THEN
            CALL BMAGSEQ(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (KBPOLYH.EQ.1) THEN
            CALL BPOLYHARM(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (KBPOLY3D.EQ.1) THEN
            CALL BPOLY3D(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (KBPOLY2DH.EQ.1) THEN
            CALL BPOLY2DH(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (KBPHARM.EQ.1) THEN
            CALL BPHARM(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (KBFELD.EQ.1) THEN
            CALL BFELD( BX, BY, BZ,X,Y,Z)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (KBAMWLS.NE.0) THEN
            CALL BBAMWLS(X,Y,Z,BX,BY,BZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
          ENDIF

          IF (IWSECTMAGS.LT.0) THEN
            CALL BSECTMAGS(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (IRFILB0.NE.0 .OR. IRFILB.EQ.1) THEN
            CALL BMESS(X,Y,Z,BX,BY,BZ)
            if (iwarnbmap.ne.0) then
              bx=0.0d0
              by=0.0d0
              bz=0.0d0
c              iwarnmyb=1
            endif
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (IRFILP.EQ.1.AND.ISPLINE.EQ.1) THEN
            CALL BPAND(X,Y,Z,BX,BY,BZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          IF (IRFILP.EQ.2.AND.ISPLINE.NE.1) THEN
            CALL BPANDOLD(X,Y,Z,BX,BY,BZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

+SELF,IF=BHELM.
          IF (IBHELM.EQ.1) THEN
            CALL BHELM(X,Y,Z,BX,BY,BZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

+SELF.

          IF (KBGENESIS.NE.0) THEN
            CALL BGENESIS(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
            BXSUPER=BXSUPER+BX
            BYSUPER=BYSUPER+BY
            BZSUPER=BZSUPER+BZ
            AXSUPER=AXSUPER+AX
            AYSUPER=AYSUPER+AY
            AZSUPER=AZSUPER+AZ
          ENDIF

          BX=BXSUPER
          BY=BYSUPER
          BZ=BZSUPER

          AX=AXSUPER
          AY=AYSUPER
          AZ=AZSUPER

        ENDIF  !IBSUPER

        AX=SIGX*AX
        AY=SIGY*AY
        AZ=SIGZ*AZ

        BXNERR=BX
        BYNERR=BY
        BZNERR=BZ
        AXNERR=AX
        AYNERR=AY
        AZNERR=AZ

        IF (IBERROR.NE.0) THEN
          CALL BERROR(X,Y,Z,BXE,BYE,BZE,AXE,AYE,AZE)
          BX=BX+BXE
          BY=BY+BYE
          BZ=BZ+BZE
          AX=AX+AXE
          AY=AY+AYE
          AZ=AZ+AZE
        ENDIF  !IBERROR

        IF (IBMASK.EQ.100) THEN

          IF (ICAL.EQ.0) THEN
            OPEN(UNIT=99,FILE='wave.bmask',STATUS='OLD')
            NBMASK=0
1           READ(99,*,END=9)BXX
            NBMASK=NBMASK+1
            IF (NBMASK.GT.10000) STOP '*** ERROR FOR BMASK: DIMENSION EXCEEDED'
            GOTO 1
9           REWIND(99)
            DO I=1,NBMASK
              READ(99,*)BMASK(1,I),BMASK(2,I),BMASK(3,I)
            ENDDO
            CLOSE(99)
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'      BMASK:'
            WRITE(LUNGFO,*)
            DO I=1,NBMASK
              WRITE(LUNGFO,*)BMASK(1,I),BMASK(2,I),BMASK(3,I)
            ENDDO
            WRITE(LUNGFO,*)
            DO I=1,NBMASK-1
              IF(BMASK(2,I).GT.BMASK(1,I+1)) THEN
                PRINT*,'*** WARNING FOR BMASK: OVERLAPPING INTERVALS'
                WRITE(LUNGFO,*)'*** WARNING FOR BMASK: OVERLAPPING INTERVALS'
              ENDIF
            ENDDO
          ENDIF !ICAL

          DO I=1,NBMASK
            IF (X.GE.BMASK(1,I).AND.X.LE.BMASK(2,I)) THEN
              BX=BX*BMASK(3,I)
              BY=BY*BMASK(3,I)
              BZ=BZ*BMASK(3,I)
            ENDIF
          ENDDO

        ELSE IF (IBMASK.eq.-100) THEN

          call ubmask(x,y,z,bxm,bym,bzm)

          BX=BX*BxM
          BY=BY*ByM
          BZ=BZ*BzM

        ELSE IF (IBMASK.eq.-200) THEN

          call ubmask(x,y,z,bxm,bym,bzm)

          BX=BX+BxM
          BY=BY+ByM
          BZ=BZ+BzM

        ELSE IF (IBMASK.LT.0) THEN

          CALL BFELD(BXM,BYM,BZM,X,Y,Z)
C MASK IS BYM! (BXM, BZM ARE ZERO)
          BY=BY+BYM

        ELSE IF (IBMASK.eq.10) THEN

          CALL BTAP(X,Y,Z,BXm,BYm,BZm,dum,dum,dum)

          Bx=Bx*BYM
          BY=BY*BYM
          Bz=Bz*BYM

        ELSE IF (IBMASK.gt.0) THEN

          CALL BFELD(BXM,BYM,BZM,X,Y,Z)
          Bx=Bx*BYM
          BY=BY*BYM
          Bz=Bz*BYM

        ELSE IF (ibmasksp.ne.0) THEN

          CALL BFELD(BXM,BYM,BZM,X,Y,Z)
          bx=bx+bxm
          by=by+bym
          bz=bz+bzm
          IF (KMAGSEQ.lt.0) THEN
            CALL BMAGSEQ(X,Y,Z,BXm,BYm,BZm,dum,dum,dum)
            bx=bx+bxm
            by=by+bym
            bz=bz+bzm
          endif
        ENDIF  !(IBMASK.NE.0)

100     BX=SIGX*BX
        BY=SIGY*BY+BYGOFF
        BZ=SIGZ*BZ+BZGOFF

C CHANGES HERE ACCORDING TO BFOUR (TAKE CARE OF DIFFERENT COORD.SYST.){

+SELF,IF=DIPAXAZ.
        AX=AX+0.5*BYGOFF*Z
        AZ=AZ-0.5*BYGOFF*X
        IF (ICAL.EQ.0.AND.BZGOFF.NE.0.) THEN
          WRITE(LUNGFO,*)
     &      '*** WARNING IN MYBFELD: BZGOFF NOT ZERO'
          WRITE(LUNGFO,*)
     &      '*** NOT IMPLEMENTED FOR THIS VECTOR-POTENTIAL ***'
          WRITE(LUNGFO,*)
     &      '*** SEE MYBFELD FOR DETAILS'
          WRITE(6,*)
     &      '*** WARNING IN MYBFELD: BZGOFF NOT ZERO'
          WRITE(6,*)
     &      '*** NOT IMPLEMENTED FOR THIS VECTOR-POTENTIAL ***'
          WRITE(6,*)
     &      '*** SEE MYBFELD FOR DETAILS'
        ENDIF
+SELF.

+SELF,IF=DIPAZ.
        AX=AX+BYGOFF*Z
        AX=AX+BZGOFF*Y
        IF (ICAL.EQ.0.AND.BZGOFF.NE.0.) THEN
          WRITE(LUNGFO,*)
     &      '*** WARNING IN MYBFELD: BZGOFF NOT ZERO'
          WRITE(LUNGFO,*)
     &      '*** NOT YET TESTED FOR THIS VECTOR-POTENTIAL ***'
          WRITE(LUNGFO,*)
     &      '*** SEE MYBFELD FOR DETAILS'
          WRITE(6,*)
     &      '*** WARNING IN MYBFELD: BZGOFF NOT ZERO'
          WRITE(6,*)
     &      '*** NOT YET TESTED FOR THIS VECTOR-POTENTIAL ***'
          WRITE(6,*)
     &      '*** SEE MYBFELD FOR DETAILS'
        ENDIF
+SELF.

+SELF,IF=-DIPAXAZ,IF=-DIPAZ.
        AZ=AZ-BYGOFF*X
        AZ=AZ-BZGOFF*X
        IF (ICAL.EQ.0.AND.BZGOFF.NE.0.) THEN
          WRITE(LUNGFO,*)
     &      '*** WARNING IN MYBFELD: BZGOFF NOT ZERO'
          WRITE(LUNGFO,*)
     &      '*** NOT YET TESTED FOR THIS VECTOR-POTENTIAL ***'
          WRITE(LUNGFO,*)
     &      '*** SEE MYBFELD FOR DETAILS'
          WRITE(6,*)
     &      '*** WARNING IN MYBFELD: BZGOFF NOT ZERO'
          WRITE(6,*)
     &      '*** NOT YET TESTED FOR THIS VECTOR-POTENTIAL ***'
          WRITE(6,*)
     &      '*** SEE MYBFELD FOR DETAILS'
        ENDIF
+SELF.


C CHANGES HERE ACCORDING TO BFOUR }

        BX=BX*B0SCGLOB
        BY=BY*B0SCGLOB*B0SCGLOBY
        BZ=BZ*B0SCGLOB*B0SCGLOBZ

        AX=AX*A0SCGLOB
        AY=AY*A0SCGLOB*B0SCGLOBY
        AZ=AZ*A0SCGLOB*B0SCGLOBZ

        IF(IBSYM.NE.0.AND.(XI-XBSYM).LT.0.0) THEN
          AX= AX
          AY=-AY
          AZ=-AZ
          BX=-BX
          BY= BY
          BZ= BZ
        ENDIF

        IF(IBSYMY.NE.0.AND.YI.LT.0.0) THEN
          AX=-AX
          AY= AY
          AZ=-AZ
          BX= BX
          BY=-BY
          BZ= BZ
        ENDIF

        IF(IBSYMZ.NE.0.AND.ZI.LT.0.0) THEN
          AX=-AX
          AY=-AY
          AZ= AZ
          BX= BX
          BY= BY
          BZ=-BZ
        ENDIF

        IF(IBSYM.LT.0.AND.XI.LT.0.0) THEN
          AX=-AX
          AY=-AY
          AZ=-AZ
          BX=-BX
          BY=-BY
          BZ=-BZ
        ENDIF

        IF(IBSYMY.LT.0.AND.YI.LT.0.0) THEN
          AX=-AX
          AY=-AY
          AZ=-AZ
          BX=-BX
          BY=-BY
          BZ=-BZ
        ENDIF

        IF(IBSYMZ.LT.0.AND.ZI.LT.0.0) THEN
          AX=-AX
          AY=-AY
          AZ=-AZ
          BX=-BX
          BY=-BY
          BZ=-BZ
        ENDIF

1000  continue

      IF (JBMASK.EQ.100) THEN

        x=xiii

        IF (ICAL.EQ.0) THEN
          OPEN(UNIT=99,FILE='wave.bmask',STATUS='OLD')
          NBMASK=0
11        READ(99,*,END=91)BXX
          NBMASK=NBMASK+1
          IF (NBMASK.GT.10000) STOP '*** ERROR FOR BMASK: DIMENSION EXCEEDED'
          GOTO 11
91        REWIND(99)
          DO I=1,NBMASK
            READ(99,*)BMASK(1,I),BMASK(2,I),BMASK(3,I)
          ENDDO
          CLOSE(99)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'      BMASK:'
          WRITE(LUNGFO,*)
          DO I=1,NBMASK
            WRITE(LUNGFO,*)BMASK(1,I),BMASK(2,I),BMASK(3,I)
          ENDDO
          WRITE(LUNGFO,*)
          DO I=1,NBMASK-1
            IF(BMASK(2,I).GT.BMASK(1,I+1)) THEN
              PRINT*,'*** WARNING FOR BMASK: OVERLAPPING INTERVALS'
              WRITE(LUNGFO,*)'*** WARNING FOR BMASK: OVERLAPPING INTERVALS'
            ENDIF
          ENDDO
        ENDIF !ICAL

        DO I=1,NBMASK
          IF (X.GE.BMASK(1,I).AND.X.LE.BMASK(2,I)) THEN
            BX=BX*BMASK(3,I)
            BY=BY*BMASK(3,I)
            BZ=BZ*BMASK(3,I)
          ENDIF
        ENDDO

      ELSE IF (JBMASK.eq.-100) THEN

        call ubmask(x,y,z,bxm,bym,bzm)

        BX=BX*BxM
        BY=BY*ByM
        BZ=BZ*BzM

      ELSE IF (JBMASK.eq.-200) THEN

        call ubmask(x,y,z,bxm,bym,bzm)

        BX=BX+BxM
        BY=BY+ByM
        BZ=BZ+BzM

      ELSE IF (JBMASK.LT.0) THEN

        CALL BFELD(BXM,BYM,BZM,X,Y,Z)
C MASK IS BYM! (BXM, BZM ARE ZERO)
        BY=BY+BYM

      ELSE IF (ibmasksp.ne.0) THEN

        CALL BFELD(BXM,BYM,BZM,X,Y,Z)
        bx=bx+bxm
        by=by+bym
        bz=bz+bzm
        IF (KMAGSEQ.lt.0) THEN
          CALL BMAGSEQ(X,Y,Z,BXm,BYm,BZm,dum,dum,dum)
          bx=bx+bxm
          by=by+bym
          bz=bz+bzm
        endif
      ENDIF !(JBMASK.NE.0)

      ZD= CROTD*Z+SROTD*Y
      YD=-SROTD*Z+CROTD*Y
      Z=ZD
      Y=YD

      BZD= CROTD*BZ+SROTD*BY
      BYD=-SROTD*BZ+CROTD*BY
      BZ=BZD
      BY=BYD

      AZD= CROTD*AZ+SROTD*AY
      AYD=-SROTD*AZ+CROTD*AY
      AZ=AZD
      AY=AYD

      by=by*(1.0d0+btaperv*(xiii-xtaper))
      bz=bz*(1.0d0+btaperh*(xiii-xtaper))
      ay=ay*(1.0d0+btaperv*(xiii-xtaper))
      az=az*(1.0d0+btaperh*(xiii-xtaper))

      BB=BX*BX+BY*BY+BZ*BZ

      IF (BB.GT.BMAXGL2) THEN
        XBMAXGL=XIII
        YBMAXGL=YIII
        ZBMAXGL=ZIII
        BMAXGL2=BB
      ENDIF

      ICAL=1

      IF (IWARN.EQ.0) THEN
        IF (ABS(BX).GT.100.0D0
     &      .OR.
     &      ABS(BY).GT.100.0D0
     &      .OR.
     &      ABS(BZ).GT.100.0D0) THEN
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN MYBFELD:'
          WRITE(6,*)'MAGNETIC FIELD ABOVE 100 TESLA FOUND!'
          WRITE(6,*)'X:',XIII
          WRITE(6,*)'Y:',YIII
          WRITE(6,*)'Z:',ZIII
          WRITE(6,*)'BX:',BX
          WRITE(6,*)'BY:',BY
          WRITE(6,*)'BZ:',BZ
          WRITE(6,*)
          WRITE(6,*)'Tracking position and velocity vector:'
          WRITE(6,*)
          WRITE(6,*)'STEP:',ITRACK
          WRITE(6,*)'XTRACK:',XTRACK
          WRITE(6,*)'YTRACK:',YTRACK
          WRITE(6,*)'ZTRACK:',ZTRACK
          WRITE(6,*)'VXTRACK:',VXTRACK
          WRITE(6,*)'VYTRACK:',VYTRACK
          WRITE(6,*)'VZTRACK:',VZTRACK
          WRITE(6,*)'YPTRACK:',VYTRACK/VXTRACK
          WRITE(6,*)'ZPTRACK:',VZTRACK/VXTRACK
          WRITE(6,*)

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN MYBFELD:'
          WRITE(LUNGFO,*)'MAGNETIC FIELD ABOVE 100 TESLA FOUND!'
          WRITE(LUNGFO,*)'X:',XIII
          WRITE(LUNGFO,*)'Y:',YIII
          WRITE(LUNGFO,*)'Z:',ZIII
          WRITE(LUNGFO,*)'BX:',BX
          WRITE(LUNGFO,*)'BY:',BY
          WRITE(LUNGFO,*)'BZ:',BZ
          WRITE(LUNGFO,*)
          IWARN=1
        ENDIF
      ENDIF

      RETURN
      END
+DECK,MYBMOVE.
*CMZ :  2.53/01 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  11.03.35  by  Michael Scheer
*CMZ :  2.20/01 12/12/2000  12.09.19  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  2.12/00 27/05/99  18.01.14  by  Michael Scheer
*CMZ :  2.10/01 07/05/99  12.21.34  by  Michael Scheer
*CMZ : 00.01/10 20/08/96  12.00.15  by  Michael Scheer
*CMZ : 00.01/08 21/06/95  17.17.07  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  15.22.06  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.48.13  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.17  by  Michael Scheer
*-- Author : Michael Scheer
C*******************************************************************************
      Subroutine MYBMOVE(XI,YI,ZI,VXI,VYI,VZI,BXIN,BYIN,BZIN,DT,
     &             XO,YO,ZO,VXO,VYO,VZO,VXP,VYP,VZP,GAMMA,ICHARGE,BMOVECUT)
C*******************************************************************************
+seq,gplhint.
C
C
C     *** BESCHLEUNIGUNG AM ENDE DES INTERVALLS
C
C
C BERECHNET DIE EXAKTE 3-DIM Trajektorie EINES TEILCHENS IN EINEM
C 3-DIM HOMOGENEN Magnetfeld
C
C LAENGEN IN METERN
C GeschwindigkeitEN IN M/SEC
C ZEIT IN SEKUNDEN
C B-FELDER IN TESLA V SEC/M**2
C
C*******************************************************************

      IMPLICIT NONE

+SEQ,PHYCON.

      DOUBLE PRECISION XI,YI,ZI,VXI,VYI,VZI,BX,BY,BZ,DT,
     &                   XO,YO,ZO,VXO,VYO,VZO,VXP,VYP,VZP,GAMMA,
     &                   V,B,EBX,EBY,EBZ,ERX,ERY,ERZ,
     &                   EPX,EPY,EPZ,PPER,RHO,PHI,COSPHI,SINPHI,
     &                   XC,YC,ZC,FRX,FRY,FRZ,FPX,FPY,FPZ,VPAR,VPER,
     &                   V1,B1,OM,APER,ER
C     &                  ,VMX,VMY,VMZ
     &,CONST,BXIN,BYIN,BZIN

        DOUBLE PRECISION BMOVECUT

      INTEGER ICHARGE

        IF (ICHARGE.GT.0) THEN
            BX=-BXIN
            BY=-BYIN
            BZ=-BZIN
        ELSE
            BX=BXIN
            BY=BYIN
            BZ=BZIN
        ENDIF

      V=SQRT(VXI*VXI+VYI*VYI+VZI*VZI)
      B=SQRT(BX*BX+BY*BY+BZ*BZ)

      V1=1.D0/V
      IF (B.GT.BMOVECUT) THEN
         B1=1.D0/B
      ELSE
              XO=XI+VXI*DT
              YO=YI+VYI*DT
              ZO=ZI+VZI*DT
              VXO=VXI
              VYO=VYI
              VZO=VZI
              VXP=0.D0
              VYP=0.D0
              VZP=0.D0
              GOTO 999    !RETURN
      ENDIF

      EBX=BX*B1
      EBY=BY*B1
      EBZ=BZ*B1

      ERX=VYI*EBZ-VZI*EBY
      ERY=VZI*EBX-VXI*EBZ
      ERZ=VXI*EBY-VYI*EBX

      ER=1.D0/SQRT(ERX*ERX+ERY*ERY+ERZ*ERZ)
      ERX=ERX*ER
      ERY=ERY*ER
      ERZ=ERZ*ER

      EPX=EBY*ERZ-EBZ*ERY
      EPY=EBZ*ERX-EBX*ERZ
      EPZ=EBX*ERY-EBY*ERX

C VELOCITY PARALLEL TO B

      VPAR=VXI*EBX+VYI*EBY+VZI*EBZ

C VELOCITY PERPENDICULAR TO B

      VPER=VXI*EPX+VYI*EPY+VZI*EPZ

C MOMENTUM PERPENDICULAR TO B [GEV]

      PPER=GAMMA*EMASSE1*VPER/CLIGHT1
      RHO=PPER/(CLIGHT1*B)
      OM=VPER/RHO
      PHI=OM*DT
      APER=VPER*OM
      COSPHI=COS(PHI)
      SINPHI=SIN(PHI)

      XC=XI-RHO*ERX
      YC=YI-RHO*ERY
      ZC=ZI-RHO*ERZ

      FRX=ERX*COSPHI+EPX*SINPHI
      FRY=ERY*COSPHI+EPY*SINPHI
      FRZ=ERZ*COSPHI+EPZ*SINPHI

      FPX=-ERX*SINPHI+EPX*COSPHI
      FPY=-ERY*SINPHI+EPY*COSPHI
      FPZ=-ERZ*SINPHI+EPZ*COSPHI

      XO=XC+RHO*FRX+VPAR*EBX*DT
      YO=YC+RHO*FRY+VPAR*EBY*DT
      ZO=ZC+RHO*FRZ+VPAR*EBZ*DT

      VXO=VPER*FPX+VPAR*EBX
      VYO=VPER*FPY+VPAR*EBY
      VZO=VPER*FPZ+VPAR*EBZ

C     VMX=(VXI+VXO)*0.5D0
C     VMY=(VYI+VYO)*0.5D0
C     VMZ=(VZI+VZO)*0.5D0

C     CONST=-ECHARGE1/(GAMMA*EMASSKG1)
C     VXP=(VMY*BZ-VMZ*BY)*CONST
C     VYP=(VMZ*BX-VMX*BZ)*CONST
C     VZP=(VMX*BY-VMY*BX)*CONST

      CONST=-ECHARGE1/(GAMMA*EMASSKG1)
      VXP=(VYO*BZ-VZO*BY)*CONST
      VYP=(VZO*BX-VXO*BZ)*CONST
      VZP=(VXO*BY-VYO*BX)*CONST


999   RETURN
      END
+DECK,NLPOIWIN.
*CMZ :  3.05/06 17/07/2018  11.15.16  by  Michael Scheer
*CMZ :  2.67/04 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.16/08 12/08/2009  08.49.28  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.35  by  Michael Scheer
*CMZ :  2.00/00 16/12/98  14.36.03  by  Michael Scheer
*-- Author :    Michael Scheer   15/12/98
      SUBROUTINE NLPOIWIN
+seq,gplhint.

+SEQ,TRACKF90U,IF=F90.


C--- NLPOIWIN ESTIMATES VALUES FOR NLPOI AND WGWINFC
C--- FORMULA FROM X-RAY DATA BOOKLET

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,FREQS.
+SEQ,COLLI.
+SEQ,B0SCGLOB.
+SEQ,TRACK.
+seq,phycon.

      INTEGER NLPOIMX,NLPERMN,NLPOIMN
      DOUBLE PRECISION B0DIP,YLOW,YHIGH,WGLOW,WGHIGH,ECDIP,PHIDEFL,DEFLEC,DLENG,DNPER

      DATA NLPOIMX/250000/,NLPERMN/50/

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SR NLPOIWIN CALLED:'
      WRITE(LUNGFO,*)

      PHIDEFL=(PHIMX-PHIMN)/2.
      B0DIP=DSQRT(DABS(BMAXGL2))
      DEFLEC=PHIDEFL*DMYGAMMA
      DLENG=DEFLEC/93.4/B0DIP
      IF (DLENG.EQ.0.0) DLENG=(XMX-XMN)
      DNPER=(XMX-XMN)/DLENG
      IF (DNPER.LT.1.D0) DNPER=1.D0
      NLPOIMN=NLPERMN*DNPER*DEFLEC

      IF (B0DIP.EQ.0.D0) THEN
          WRITE(LUNGFO,*)'*** ERROR IN NLPOIWIN: B0DIP.EQ.0  ***'
          WRITE(LUNGFO,*)'CHECK MAG. FIELD'
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
          WRITE(6,*)'*** ERROR IN NLPOIWIN: B0DIP.EQ.0  ***'
          WRITE(6,*)'CHECK MAG. FIELD'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
          STOP
      ENDIF

      ECDIP=ecdipev1*DMYENERGY**2*B0DIP

      WRITE(LUNGFO,*)
     &'     mag. field [T], Ec [eV]:',SNGL(B0DIP),SNGL(ECDIP)
      WRITE(LUNGFO,*)

      YLOW=FREQ(1)/ECDIP
      YHIGH=FREQ(NFREQ)/ECDIP

      IF (YLOW.LT.1.) THEN
          WGLOW=0.408/DMYENERGY*YLOW**(-0.354)/1000.
      ELSE
          WGLOW=0.408/DMYENERGY*YLOW**(-0.549)/1000.
      ENDIF

      IF (YHIGH.LT.1.) THEN
          WGHIGH=0.408/DMYENERGY*YHIGH**(-0.354)/1000.
      ELSE
          WGHIGH=0.408/DMYENERGY*YHIGH**(-0.549)/1000.
      ENDIF

      WRITE(LUNGFO,*)'      WGWINFC low/high: '
     & ,SNGL(WGLOW*DMYGAMMA),SNGL(WGHIGH*DMYGAMMA)
      WRITE(LUNGFO,*)

      IF (WGWINFC.EQ.9999.) THEN
          WGWINFC=WGLOW*20.*DMYGAMMA
          WRITE(LUNGFO,*)'      WGWINFC set to: ',WGWINFC
      ENDIF

      IF (WGLOW.GT.PHIDEFL) THEN
          WGLOW=PHIDEFL
          WGWINFC=PHIDEFL*DMYGAMMA*1.1 !1.1 TO HAVE SOME OVERLAP
          WRITE(LUNGFO,*)
     &'      WGWINFC corresponds to angle greater than max. deflection'
          WRITE(LUNGFO,*)'      WGWINFC set to: ',WGWINFC
      ENDIF

      IF (WGHIGH.GT.PHIDEFL) THEN
          WGHIGH=PHIDEFL
      ENDIF

      IF (NLPOI.EQ.-9999) THEN
          NLPOI=1000*WGWINFC*WGLOW/WGHIGH
          IF (NLPOI.LT.NLPOIMN) THEN
         NLPOI=NLPOIMN
          ENDIF
          WRITE(LUNGFO,*)'      NLPOI set to: ',NLPOI
          IF (NLPOI.GT.NLPOIMX) THEN
          NLPOI=NLPOIMX
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN NLPOIWIN: NLPOI VERY LARGE'
          WRITE(LUNGFO,*)'      NLPOI limited to: ',NLPOI
          WRITE(6,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN NLPOIWIN: NLPOI VERY LARGE'
          WRITE(6,*)'      NLPOI limited to: ',NLPOI
          WRITE(6,*)
          ENDIF
      ENDIF


      WRITE(LUNGFO,*)


      RETURN
      END
+DECK,OPTI.
*CMZ :  4.00/14 22/12/2021  16.40.21  by  Michael Scheer
*CMZ :  4.00/11 22/11/2020  13.38.35  by  Michael Scheer
*CMZ :  4.00/07 09/06/2020  09.56.54  by  Michael Scheer
*CMZ :  3.04/00 19/01/2018  15.53.17  by  Michael Scheer
*CMZ :  3.03/04 19/12/2017  10.39.56  by  Michael Scheer
*CMZ :  3.02/03 03/11/2014  10.45.00  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  10.43.52  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  12.29.06  by  Michael Scheer
*CMZ :  2.68/05 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.67/00 05/10/2012  08.15.04  by  Michael Scheer
*CMZ :  2.66/07 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.63/05 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  2.61/01 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.61/00 29/01/2007  17.00.55  by  Michael Scheer
*CMZ :  2.54/07 16/06/2005  12.05.48  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.39/02 22/01/2002  11.29.06  by  Michael Scheer
*CMZ :  2.34/07 05/09/2001  12.06.28  by  Michael Scheer
*CMZ :  2.34/05 23/08/2001  17.35.48  by  Michael Scheer
*CMZ :  2.16/04 23/08/2001  15.27.45  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.35  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.24.35  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  14.43.01  by  Michael Scheer
*CMZ : 00.02/00 22/11/96  16.22.27  by  Michael Scheer
*CMZ : 00.01/10 02/09/96  16.02.38  by  Michael Scheer
*CMZ : 00.01/08 03/04/95  10.04.39  by  Michael Scheer
*CMZ : 00.01/07 23/03/95  12.23.36  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  17.02.55  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.52.48  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.48  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE OPTI(X0,Y0,Z0,BETX0,BETY0,BETZ0,
     &  XF0,YF0,ZF0,BETXF0,BETYF0,BETZF0,
     &  DTIM,BSHIFT,GAMMA)
+seq,gplhint.

C     TRACKS A SET OF PARTICLES AND WRITES INITIAL
C     AND FINAL COORDINATES TO FILE "FILEO"
C     THE FILE IS READ BY THE PROGRAM TRANPOLY TO CALCULATE THE
C     GENERATING FUNCTION OF THE DEVICE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,OPTIC.
+SEQ,depola.
+SEQ,TRACKF90.
+seq,whbook.
+seq,pawcmn.

      INTEGER ICOUNT,ICOUNT10,KCOUNT,K10,IZFAIL,IYFAIL,IZ,IY,IZP,IYP,I,J,NTOT
      INTEGER IOPEND,IOPNF,JERZFUN,nkoef,luni,istat,ntread

+SEQ,B0SCGLOB.
+SEQ,GENFUN.
+SEQ,PHYCON.

      DOUBLE PRECISION OPTBUF(23,MAXTRA),BSHIFT,DTIM,GAMMA
     &  ,AX1,AY1,AZ1,AX2,AY2,AZ2,dgam
     &  ,AXIO,AYIO,AZIO,AXFO,AYFO,AZFO
     &  ,BX1,BY1,BZ1,BX2,BY2,BZ2
     &  ,BXIO,BYIO,BZIO,BXFO,BYFO,BZFO
     &  ,AXFIRST,AYFIRST,AZFIRST,BXFIRST,BYFIRST,BZFIRST
     &  ,XFIRST,YFIRST,ZFIRST,YPFIRST,ZPFIRST
     &  ,X1,Y1,Z1,ZP1,YP1,X2,Y2,Z2,ZP2,YP2
     &  ,XIO,YIO,ZIO,ZPIO,YPIO,XFO,YFO,ZFO,ZPFO,YPFO
     &  ,X0,Y0,Z0,ZP0,YP0,XF0,YF0,ZF0,ZPF0,YPF0,
     &  bxf0,byf0,bzf0,axf0,ayf0,azf0
     &  ,VX1,VY1,VZ1,VX2,VY2,VZ2,V0,VF
     &  ,VX0,VY0,VZ0,VXF0,VYF0,VZF0
     &  ,VXIO,VYIO,VZIO,VXFO,VYFO,VZFO
     &  ,BETX0,BETY0,BETZ0,BETXF0,BETYF0,BETZF0
     &  ,W0,WS1,WZ1,WY1,EWS(3),EWY(3),EWZ(3),S1,S1S,Y1S,Z1S
     &  ,EWSF(3),EWYF(3),EWZF(3),EN
     &  ,GAMMALOSS,phi,dum

      DOUBLE PRECISION BETA0H,betahh,ALPHAH,alphav,GAMMAH,EPSAH,EPSBH,EPSHZ,EPSHY
      DOUBLE PRECISION BETA0L,BETAL,ALPHAL,GAMMAL,EPSAL,EPSBL,EPSLZ,EPSLY
      DOUBLE PRECISION ZAPERTP,YAPERTP
      DOUBLE PRECISION XBMAXI,YBMAXI,ZBMAXI,VXBMAXI,VYBMAXI,VZBMAXI,BOLD
      DOUBLE PRECISION BSTORE,XSTORE,YSTORE,ZSTORE,VN

      DOUBLE PRECISION EPS
      DATA EPS/1.D-5/

      REAL*4 RNDM,rr

      INTEGER NTUP
      PARAMETER (NTUP=23)
      CHARACTER(4) CHTAGS(NTUP)
      REAL*8 TUP(NTUP)
      DATA CHTAGS/
     &  'xi',
     &  'zi','zpi',
     &  'yi','ypi',
     &  'bxi','byi','bzi',
     &  'axi','ayi','azi',
     &  'xf',
     &  'zf','zpf',
     &  'yf','ypf',
     &  'bxf','byf','bzf',
     &  'axf','ayf','azf',
     &  'dl'
     &  /

      INTEGER NTUP1
      PARAMETER (NTUP1=4)
      CHARACTER(4) CHTAGS1(NTUP1)
      DATA CHTAGS1/
     &  'zi','zpi',
     &  'yi','ypi'
     &  /

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SUBROUTINE OPTI'
      WRITE(LUNGFO,*)'     ==============='

      IF (IENELOSS.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    ' *** WARNING IN OPTI: IENELOSS .NE. 0, NOT YET FULLY IMPLEMENTED ***'
        WRITE(LUNGFO,*)
     &    ' *** BE CAREFUL!! ***'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)
     &    ' *** WARNING IN OPTI: IENELOSS .NE. 0, NOT YET FULLY IMPLEMENTED ***'
        WRITE(6,*)
     &    ' *** BE CAREFUL!! ***'
        WRITE(6,*)
      ENDIF

      if (ioptic.eq.-2) then
        optbuf=0.0d0
        icount=0
        open(newunit=luni,file="wave_opti_in.dat",status='old')
        call util_skip_comment(luni)
        do ntread=1,maxtra
          read(luni,*,end=123)i,
     &      x1,y1,z1,vx1,vy1,vz1,
     &      x2,y2,z2,vx2,vy2,vz2,
     &      istat
          if (istat.ne.0) cycle
          icount=icount+1
          optbuf(1,icount)=x1
          optbuf(2,icount)=z1
          optbuf(3,icount)=vz1/vx1
          optbuf(4,icount)=y1
          optbuf(5,icount)=vy1/vx1
          optbuf(12,icount)=x2
          optbuf(13,icount)=z2
          optbuf(14,icount)=vz2/vx2
          optbuf(15,icount)=y2
          optbuf(16,icount)=vy2/vx2
        enddo
123     close(luni)
      endif

      BSTORE=BMAXGL2
      XSTORE=XBMAXGL
      YSTORE=YBMAXGL
      ZSTORE=ZBMAXGL

      BMAXGL2=-1.D30
      BOLD=BMAXGL2

      IF (IHPHSPAC.NE.0) THEN
+self,if=-mhbook.
        CALL hbookm(NIDTRAC,'ZI,ZPI,YI,YPI ON GRID$',NTUP1,'//WAVE',1024,CHTAGS1)
        CALL hbookm(NIDTRAC+1,'TRANS. TRACKS$',NTUP,'//WAVE',1024,CHTAGS)
+self,if=mhbook.
        CALL hbookm(NIDTRAC,'ZI,ZPI,YI,YPI ON GRID$',NTUP1,'//WAVE',
     &    (nzopt*2+1)*(nyopt*2+1)*(nzpopt*2+1)*(nypopt*2+1),
     &    CHTAGS1)
        CALL hbookm(NIDTRAC+1,'TRANS. TRACKS$',NTUP,'//WAVE',
     &    (nzopt*2+1)*(nyopt*2+1)*(nzpopt*2+1)*(nypopt*2+1),
     &    CHTAGS)
+self.
      ENDIF

C--- DEFAULTS

      IF (DLAPER.EQ.9999.) DLAPER=XF0-X0

      IF (DZOPT.EQ.9999.) DZOPT=ZAPERT/DFLOAT(NZOPT)
      IF (DZPOPT.EQ.9999.) DZPOPT=ZAPERT/DLAPER/DFLOAT(NZPOPT)
      IF (DYOPT.EQ.9999.) DYOPT=YAPERT/DFLOAT(NYOPT)
      IF (DYPOPT.EQ.9999.) DYPOPT=YAPERT/DLAPER/DFLOAT(NYPOPT)

      IF(KHALBA**2+IBHELM**2
     &  +KBFELD**2+IRFILB**2+IRFILP**2 .GT.1) STOP
     &  '*** ERROR IN OPTI: IERZFUN**2+IBHTRACK**2+... .GT.1 ***'

      JERZFUN=IERZFUN
      IF (IERZFUN.EQ.100) IERZFUN=1
      IF(IERZANA**2+IERZFUN**2+IBHTRACK**2+IBHARD**2 .GT.1) STOP
     &  '*** ERROR IN OPTI: IERZANA+IERZFUN+IBHTRACK+IBHARD .GT.1 ***'
      IERZFUN=JERZFUN

      ZP0=BETZ0/BETX0
      YP0=BETY0/BETX0
      V0=CLIGHT1*DSQRT( (1.D0-1.D0/GAMMA)*(1.D0+1.D0/GAMMA) )
      VX0=BETX0*CLIGHT1
      VY0=BETY0*CLIGHT1
      VZ0=BETZ0*CLIGHT1
      ZPF0=BETZF0/BETXF0
      YPF0=BETYF0/BETXF0
      VXF0=BETXF0*CLIGHT1
      VYF0=BETYF0*CLIGHT1
      VZF0=BETZF0*CLIGHT1
      NTOT=(NZOPT+1)*(NYOPT+1)*(NZPOPT+1)*(NYPOPT+1)

C--- FIND STARTING POINT

C- DEFAULTS

      IF (OPSTARTX.EQ.9999.) THEN
        OPSTARTX=X0
        OPSTARTY=Y0
        OPSTARTZ=Z0
      ENDIF

      IF (OPENDX.EQ.9999.)  THEN
        IOPEND=9999
        OPENDX=XF0
        OPENDY=YF0
        OPENDZ=ZF0
      ELSE
        IOPEND=0
      ENDIF

      IF(OPNX.EQ.9999.) THEN
        OPNX=VX0
        OPNY=VY0
        OPNZ=VZ0
      ENDIF

      EN=DSQRT(OPNX**2+OPNY**2+OPNZ**2)
      OPNX=OPNX/EN
      OPNY=OPNY/EN
      OPNZ=OPNZ/EN

      IF (OPNFX.EQ.9999) THEN
        IOPNF=9999
        OPNFX=VXF0
        OPNFY=VYF0
        OPNFZ=VZF0
      ELSE
        IOPNF=0
      ENDIF

      EN=DSQRT(OPNFX**2+OPNFY**2+OPNFZ**2)
      OPNFX=OPNFX/EN
      OPNFY=OPNFY/EN
      OPNFZ=OPNFZ/EN

      IF (OPENDX.LE.OPSTARTX) THEN
        WRITE(LUNGFO,*)'*** ERROR IN OPTI ***'
        WRITE(LUNGFO,*)'OPENDX .LE. OPSTARTX'
        WRITE(LUNGFO,*)'CHECK INPUT FILE'
        WRITE(6,*)'*** ERROR IN OPTI ***'
        WRITE(6,*)'OPENDX .LE. OPSTARTX'
        WRITE(6,*)'CHECK INPUT FILE'
        STOP
      ENDIF

      XIO=OPSTARTX
      YIO=OPSTARTY
      ZIO=OPSTARTZ
      VXIO=V0*OPNX
      VYIO=V0*OPNY
      VZIO=V0*OPNZ
      ZPIO=VZIO/VXIO
      YPIO=VYIO/VXIO

      CALL TRACK(XIO,YIO,ZIO,VXIO,VYIO,VZIO,
     &  OPENDX,OPENDY,OPENDZ,OPNFX,OPNFY,OPNFZ,
     &  XFO,YFO,ZFO,VXFO,VYFO,VZFO,DTIM,BSHIFT,GAMMA,GAMMALOSS)

      dgam=gammaloss

      IF (IOPEND.EQ.0) THEN
        XFO=OPENDX
        YFO=OPENDY
        ZFO=OPENDZ
      ENDIF   !(IOPEND.EQ.9999)

      IF (IOPNF.EQ.0) THEN
        VXFO=V0*OPNFX
        VYFO=V0*OPNFY
        VZFO=V0*OPNFZ
      ENDIF   !(IOPNF.EQ.9999)

      ZPFO=VZFO/VXFO
      YPFO=VYFO/VXFO

C- VECTOR-POTENTIALS

      CALL MYBFELD(XIO,YIO,ZIO,
     &  BXIO,BYIO,BZIO,AXIO,AYIO,AZIO)
c18.1.2019{
      CALL MYBFELD(XF0,YF0,ZF0,
     &  BXF0,BYF0,BZF0,AXF0,AYF0,AZF0)
c18.1.2019}
      CALL MYBFELD(XFO,YFO,ZFO,
     &  BXFO,BYFO,BZFO,AXFO,AYFO,AZFO)

C--- COORDINATE SYSTEM OF THE REFERENCE ORBIT (STARTING POINT)

      EWS(1)=VXIO/V0 !UNIT-VECTOR EWS
      EWS(2)=VYIO/V0
      EWS(3)=VZIO/V0

C        UNIT-VECTOR EWZ~[EWS,(0,1,0)] (CROSS-PRODUCT)

      EWZ(1)=-EWS(3)/DSQRT(EWS(3)*EWS(3)+EWS(1)*EWS(1))
      EWZ(2)= 0.
      EWZ(3)= EWS(1)/DSQRT(EWS(3)*EWS(3)+EWS(1)*EWS(1))

      EWY(1)= EWZ(2)*EWS(3) - EWZ(3)*EWS(2)  !UNIT-VECTOR EWY=[EWZ,EWS]
      EWY(2)= EWZ(3)*EWS(1) - EWZ(1)*EWS(3)
      EWY(3)= EWZ(1)*EWS(2) - EWZ(2)*EWS(1)


C--- CHECK ENTRANCE PLANE: ENTRANCE PLANE SHOULD BE PERPENDICULAR
C                          TO REFERENCE ORBIT

      IF (
     &    ABS(EWS(1)-OPNX).GT.1.D-10
     &    .OR.
     &    ABS(EWS(2)-OPNY).GT.1.D-10
     &    .OR.
     &    ABS(EWS(3)-OPNZ).GT.1.D-10
     &    ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN OPTI ***'
        WRITE(6,*)'START VECTOR OF REFERENCE ORBIT AND NORMAL VECTOR'
        WRITE(6,*)'OF ENTRANCE PLANE OF DEVICE ARE DIFFERENT'
        WRITE(6,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN OPTI ***'
        WRITE(LUNGFO,*)'START VECTOR OF REFERENCE ORBIT AND NORMAL VECTOR'
        WRITE(LUNGFO,*)'OF ENTRANCE PLANE OF DEVICE ARE DIFFERENT'
        WRITE(LUNGFO,*)
      ENDIF

C--- COORDINATE SYSTEM OF THE REFERENCE ORBIT (EXIT PLAIN)

      VF=DSQRT(VXFO*VXFO+VYFO*VYFO+VZFO*VZFO)
      EWSF(1)=VXFO/VF
      EWSF(2)=VYFO/VF
      EWSF(3)=VZFO/VF

      EWZF(1)=-EWSF(3)/DSQRT(EWSF(3)*EWSF(3)+EWSF(1)*EWSF(1))
      EWZF(2)= 0.
      EWZF(3)= EWSF(1)/DSQRT(EWSF(3)*EWSF(3)+EWSF(1)*EWSF(1))

      EWYF(1)= EWZF(2)*EWSF(3) - EWZF(3)*EWSF(2)
      EWYF(2)= EWZF(3)*EWSF(1) - EWZF(1)*EWSF(3)
      EWYF(3)= EWZF(1)*EWSF(2) - EWZF(2)*EWSF(1)

      IF (I2DIM.NE.0 .AND. (DABS( EWY(2)-1.D0).GT.1.D-15
     &                   .OR. DABS(EWYF(2)-1.D0).GT.1.D-15)) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN OPTI ***'
          WRITE(LUNGFO,*)
     &      'FLAG I2DIM SET, BUT REFERENCE ORBIT NOT IN X,Z - PLANE'
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN OPTI ***'
          WRITE(6,*)
     &      'FLAG I2DIM SET, BUT REFERENCE ORBIT NOT IN X,Z - PLANE'
          STOP
      ENDIF

      IF (
     &  ABS(EWSF(1)-OPNFX).GT.1.D-10
     &  .OR.
     &  ABS(EWSF(2)-OPNFY).GT.1.D-10
     &  .OR.
     &  ABS(EWSF(3)-OPNFZ).GT.1.D-10
     &    ) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN OPTI ***'
          WRITE(LUNGFO,*)'START VECTOR OF REFERENCE ORBIT AND NORMAL VECTOR '
          WRITE(LUNGFO,*)'ENTRANCE PLANE OF DEVICE ARE DIFFERENT'
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN OPTI ***'
          WRITE(6,*)'START VECTOR OF REFERENCE ORBIT AND NORMAL VECTOR '
          WRITE(6,*)'ENTRANCE PLANE OF DEVICE ARE DIFFERENT'
      ENDIF

      if (ioptic.eq.-2) goto 1301

C- CHECK NUMBER OF TRAJECTORIES THAT PASS APERTURE
C  (ROUGH CHECK, TRAJECTORIES ASSUMED TO BE STRAIGHT LINES)

      ICOUNT=0
      IZFAIL=0
      IYFAIL=0

      DO IZ=-NZOPT,NZOPT,2
        DO IZP=-NZPOPT,NZPOPT,2
          DO IY=-NYOPT,NYOPT,2
            DO IYP=-NYPOPT,NYPOPT,2

              RR=real(IZ+IZP+IY+IYP)
              S1 =0.

              if (ioptic.gt.0) then

                Z1 =DZOPT *(DFLOAT (IZ) -DRANDO+2.D0*DRANDO*DBLE(RNDM(RR)))
                Y1 =DYOPT *(DFLOAT (IY) -DRANDO+2.D0*DRANDO*DBLE(RNDM(RR)))
                ZP1=DZPOPT*(DFLOAT (IZP)-DRANDO+2.D0*DRANDO*DBLE(RNDM(RR)))
                YP1=DYPOPT*(DFLOAT (IYP)-DRANDO+2.D0*DRANDO*DBLE(RNDM(RR)))

              else if (ioptic.eq.-1) then

c phasespace ellipse (alpha=0): gammah*z**2+2*alphah*z*zp+betah*zp**2=eps0h

                phi=DBLE(RNDM(RR))*twopi1
                alphah=-betaph/2.0d0
                z1= sqrt(eps0h*betah)*cos(phi)
                zp1=-sqrt(eps0h/betah)*(alphah*cos(phi)+sin(phi))

                phi=DBLE(RNDM(RR))*twopi1
                alphav=-betapv/2.0d0
                y1= sqrt(eps0v*betav)*cos(phi)
                yp1=-sqrt(eps0v/betav)*(alphav*cos(phi)+sin(phi))

              endif

              IF (I2DIM.NE.0) THEN
                Y1=0.
                YP1=0.
              ENDIF

              IF (IPHASPAC.NE.0) THEN

C--- HORIZONTAL HIGH BETA  (BETA0ZH)

                BETA0H=BETA0ZH
                betahh=BETA0H+DLAPER/BETA0H**2
                ALPHAH=DLAPER/BETA0H
                GAMMAH=(1.D0+ALPHAH**2)/betahh
                EPSBH=ZAPERT**2/betahh
                ZAPERTP=ZAPERT/2.D0/DLAPER
                EPSAH=(2.D0*ZAPERTP)**2/GAMMAH
                EPSHZ=DMIN1(EPSAH,EPSBH)

C--- HORIZONTAL LOW BETA  (BETA0ZL)

                BETA0L=BETA0ZL
                BETAL=BETA0L+DLAPER/BETA0L**2
                ALPHAL=DLAPER/BETA0L
                GAMMAL=(1.D0+ALPHAL**2)/BETAL
                EPSBL=ZAPERT**2/BETAL
                ZAPERTP=ZAPERT/2.D0/DLAPER
                EPSAL=(2.D0*ZAPERTP)**2/GAMMAL
                EPSLZ=DMIN1(EPSAL,EPSBL)

                IF(
     &              Z1**2*GAMMAH+2.D0*ALPHAH*Z1*ZP1+betahh*ZP1**2.GT.EPSHZ
     &              .OR.
     &              Z1**2*GAMMAL+2.D0*ALPHAL*Z1*ZP1+BETAL*ZP1**2.GT.EPSLZ
     &              ) THEN
                  IZFAIL=IZFAIL+1
                  GOTO 131 !I.E. SKIP
                ENDIF

C--- VERTICAL HIGH BETA  (BETA0YH)

                BETA0H=BETA0YH
                betahh=BETA0H+DLAPER/BETA0H**2
                ALPHAH=DLAPER/BETA0H
                GAMMAH=(1.D0+ALPHAH**2)/betahh
                EPSBH=YAPERT**2/betahh
                YAPERTP=YAPERT/2.D0/DLAPER
                EPSAH=(2.D0*YAPERTP)**2/GAMMAH
                EPSHY=DMIN1(EPSAH,EPSBH)

C--- VERTICAL LOW BETA  (BETA0YL)

                BETA0L=BETA0YL
                BETAL=BETA0L+DLAPER/BETA0L**2
                ALPHAL=DLAPER/BETA0L
                GAMMAL=(1.D0+ALPHAL**2)/BETAL
                EPSBL=YAPERT**2/BETAL
                YAPERTP=YAPERT/2.D0/DLAPER
                EPSAL=(2.D0*YAPERTP)**2/GAMMAL
                EPSLY=DMIN1(EPSAL,EPSBL)

                IF(
     &              Y1**2*GAMMAH+2.D0*ALPHAH*Y1*YP1+betahh*YP1**2.GT.EPSHY
     &              .OR.
     &              Y1**2*GAMMAL+2.D0*ALPHAL*Y1*YP1+BETAL*YP1**2.GT.EPSLY
     &              ) THEN
                  IYFAIL=IYFAIL+1
                  GOTO 131 !I.E. SKIP
                ENDIF

              ELSE   !IPHASPAC

                IF       (DABS(Z1)           .GT.DABS(ZAPERT+EPS)
     &              .OR.  DABS(Z1+ZP1*DLAPER).GT.DABS(ZAPERT+EPS)) THEN
                  IZFAIL=IZFAIL+1
                  GOTO 131 !I.E. SKIP
                ENDIF

                IF       (DABS(Y1)           .GT.DABS(YAPERT+EPS)
     &              .OR.  DABS(Y1+YP1*DLAPER).GT.DABS(YAPERT+EPS)) THEN
                  IYFAIL=IYFAIL+1
                  GOTO 131 !I.E. SKIP
                ENDIF

              ENDIF  !IPHASPAC

              ICOUNT=ICOUNT+1

              IF (icount.GT.MAXTRA) THEN
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'*** Error in OPTI ***'
                WRITE(LUNGFO,*)'TOO MANY TRACKS'
                WRITE(LUNGFO,*)'INCREASE PARAMETER MAXTRA IN FILE GENFUN.CMN'
                WRITE(LUNGFO,*)
                WRITE(6,*)
                WRITE(6,*)'*** ERROR  in OPTI ***'
                WRITE(6,*)'TOO MANY TRACKS'
                WRITE(6,*)'INCREASE PARAMETER MAXTRA IN FILE GENFUN.CMN'
                WRITE(6,*)
                STOP
              ENDIF

              if (ioptic.lt.0) then
                optbuf(2,icount)=z1
                optbuf(3,icount)=zp1
                optbuf(4,icount)=y1
                optbuf(5,icount)=yp1
              endif

131           continue
            ENDDO
          ENDDO
        ENDDO
      ENDDO

132   WRITE(6,*)
      WRITE(6,*)
      WRITE(6,*)'*** MESSAGE SR OPTI ***'
      WRITE(6,*)
     &  'NUMBER OF PARTICLES TO BE TRACKED:',ICOUNT
      WRITE(6,*)
     &  'LOSSES DUE TO HORI. AND VERT. APERTURE:'
     &  ,IZFAIL,IYFAIL
      WRITE(6,*)
      WRITE(6,*)

      ICOUNT10=ICOUNT/10
      KCOUNT=1

      IF(ICOUNT.GT.MAXTRA) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** SR OPTI ***'
        WRITE(LUNGFO,*)'TOO MANY TRAJECTORIES'
        WRITE(LUNGFO,*)'INCREASE MAXTRA IN FILE GENFUN.CMN'
        WRITE(6,*)
        WRITE(6,*)'*** SR OPTI ***'
        WRITE(6,*)'TOO MANY TRAJECTORIES'
        WRITE(6,*)'INCREASE MAXTRA IN FILE GENFUN.CMN'
        STOP
      ENDIF

C---LOOP OVER RASTER

      ICOUNT=0
      IZFAIL=0
      IYFAIL=0
      DO 100 IZ=-NZOPT,NZOPT,2
        DO 110 IZP=-NZPOPT,NZPOPT,2
          DO 120 IY=-NYOPT,NYOPT,2
            DO 130 IYP=-NYPOPT,NYPOPT,2

C--- START OF TRAJEKTORY

              RR=real(IZ+IZP+IY+IYP)
              S1 =0.

              if (ioptic.ge.0) then

                Z1 =DZOPT *(DFLOAT(IZ) -DRANDO+2.D0*DRANDO*DBLE(RNDM(RR)))
                Y1 =DYOPT *(DFLOAT(IY) -DRANDO+2.D0*DRANDO*DBLE(RNDM(RR)))
                ZP1=DZPOPT*(DFLOAT(IZP)-DRANDO+2.D0*DRANDO*DBLE(RNDM(RR)))
                YP1=DYPOPT*(DFLOAT(IYP)-DRANDO+2.D0*DRANDO*DBLE(RNDM(RR)))

              else if (ioptic.eq.-1) then

                icount=icount+1
                z1=optbuf(2,icount)
                zp1=optbuf(3,icount)
                y1=optbuf(4,icount)
                yp1=optbuf(5,icount)
                icount=icount-1

              endif

              IF (I2DIM.NE.0) THEN
                Y1=0.
                YP1=0.
              ENDIF

              IF (IPHASPAC.NE.0) THEN

C--- HORIZONTAL HIGH BETA  (BETA0ZH)

                BETA0H=BETA0ZH
                betahh=BETA0H+DLAPER/BETA0H**2
                ALPHAH=DLAPER/BETA0H
                GAMMAH=(1.D0+ALPHAH**2)/betahh
                EPSBH=ZAPERT**2/betahh
                ZAPERTP=ZAPERT/2.D0/DLAPER
                EPSAH=(2.D0*ZAPERTP)**2/GAMMAH
                EPSHZ=DMIN1(EPSAH,EPSBH)

C--- HORIZONTAL LOW BETA  (BETA0ZL)

                BETA0L=BETA0ZL
                BETAL=BETA0L+DLAPER/BETA0L**2
                ALPHAL=DLAPER/BETA0L
                GAMMAL=(1.D0+ALPHAL**2)/BETAL
                EPSBL=ZAPERT**2/BETAL
                ZAPERTP=ZAPERT/2.D0/DLAPER
                EPSAL=(2.D0*ZAPERTP)**2/GAMMAL
                EPSLZ=DMIN1(EPSAL,EPSBL)

                IF(
     &              Z1**2*GAMMAH+2.D0*ALPHAH*Z1*ZP1+betahh*ZP1**2.GT.EPSHZ
     &              .OR.
     &              Z1**2*GAMMAL+2.D0*ALPHAL*Z1*ZP1+BETAL*ZP1**2.GT.EPSLZ
     &              ) THEN
                  IZFAIL=IZFAIL+1
                  GOTO 130 !I.E. SKIP
                ENDIF

C--- VERTICAL HIGH BETA  (BETA0YH)

                BETA0H=BETA0YH
                betahh=BETA0H+DLAPER/BETA0H**2
                ALPHAH=DLAPER/BETA0H
                GAMMAH=(1.D0+ALPHAH**2)/betahh
                EPSBH=YAPERT**2/betahh
                YAPERTP=YAPERT/2.D0/DLAPER
                EPSAH=(2.D0*YAPERTP)**2/GAMMAH
                EPSHY=DMIN1(EPSAH,EPSBH)

C--- VERTICAL LOW BETA  (BETA0YL)

                BETA0L=BETA0YL
                BETAL=BETA0L+DLAPER/BETA0L**2
                ALPHAL=DLAPER/BETA0L
                GAMMAL=(1.D0+ALPHAL**2)/BETAL
                EPSBL=YAPERT**2/BETAL
                YAPERTP=YAPERT/2.D0/DLAPER
                EPSAL=(2.D0*YAPERTP)**2/GAMMAL
                EPSLY=DMIN1(EPSAL,EPSBL)

                IF(
     &              Y1**2*GAMMAH+2.D0*ALPHAH*Y1*YP1+betahh*YP1**2.GT.EPSHY
     &              .OR.
     &              Y1**2*GAMMAL+2.D0*ALPHAL*Y1*YP1+BETAL*YP1**2.GT.EPSLY
     &              ) THEN
                  IYFAIL=IYFAIL+1
                  GOTO 130 !I.E. SKIP
                ENDIF

              ELSE   !IPHASPAC

                IF       (DABS(Z1)           .GT.DABS(ZAPERT+EPS)
     &              .OR.  DABS(Z1+ZP1*DLAPER).GT.DABS(ZAPERT+EPS)) THEN
                  IZFAIL=IZFAIL+1
                  GOTO 130 !I.E. SKIP
                ENDIF

                IF       (DABS(Y1)           .GT.DABS(YAPERT+EPS)
     &              .OR.  DABS(Y1+YP1*DLAPER).GT.DABS(YAPERT+EPS)) THEN
                  IYFAIL=IYFAIL+1
                  GOTO 130 !I.E. SKIP
                ENDIF

              ENDIF  !IPHASPAC

              IF (IHPHSPAC.NE.0) THEN

                TUP(1)=Z1
                TUP(2)=ZP1
                TUP(3)=Y1
                TUP(4)=YP1
                CALL hfm(NIDTRAC,TUP)

              ENDIF

              ICOUNT=ICOUNT+1

              IF(ICOUNT.EQ.KCOUNT) THEN

                CALL ZEIT(6)
                WRITE(6,*)'OPTI: NUMBER OF TRACKS CALCULATED SO FAR:',ICOUNT

                IF (KCOUNT.LT.ICOUNT10) THEN
                  KCOUNT=KCOUNT*10
                  K10=KCOUNT
                ELSE
                  KCOUNT=KCOUNT+K10
                ENDIF

              ENDIF

              IF(ICOUNT.GT.MAXTRA) THEN
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'*** SUBROUTINE OPTI ***'
                WRITE(LUNGFO,*)'TOO MANY TRAJECTORIES'
                WRITE(LUNGFO,*)'INCREASE MAXTRA IN FILE GENFUN.CMN'
                WRITE(6,*)
                WRITE(6,*)'*** SUBROUTINE OPTI ***'
                WRITE(6,*)'TOO MANY TRAJECTORIES'
                WRITE(6,*)'INCREASE MAXTRA IN FILE GENFUN.CMN'
                STOP
              ENDIF

              IF ((IERZFUN.EQ.0 .or. IERZFUN.EQ.100) .AND. IERZANA.EQ.0) THEN

C--- KINEMATICS IN THE TRAJEKTORY SYSTEM

                W0=V0

C        VELOCITY IN THE REFERENCE ORBIT SYSTEM

                WS1=W0/DSQRT(1.D0+ZP1*ZP1+YP1*YP1)
                WZ1=WS1*ZP1
                WY1=WS1*YP1

C--- TRANSFORM VELOCITY-VECTOR W INTO LAB.SYSTEM

                VX1=EWS(1)*WS1+EWY(1)*WY1+EWZ(1)*WZ1
                VY1=EWS(2)*WS1+EWY(2)*WY1+EWZ(2)*WZ1
                VZ1=EWS(3)*WS1+EWY(3)*WY1+EWZ(3)*WZ1

C--- REDEFINE ZP1,YP1

                ZP1=VZ1/VX1
                YP1=VY1/VX1

C--- TRANSFORM COORDINATES INTO LAB.SYSTEM

                S1S=S1
                Y1S=Y1
                Z1S=Z1

                X1=XIO+EWS(1)*S1S+EWY(1)*Y1S+EWZ(1)*Z1S
                Y1=YIO+EWS(2)*S1S+EWY(2)*Y1S+EWZ(2)*Z1S
                Z1=ZIO+EWS(3)*S1S+EWY(3)*Y1S+EWZ(3)*Z1S

C--- NOW WE ARE IN THE LAB

                XFIRST=X1
                YFIRST=Y1
                ZFIRST=Z1
                ZPFIRST=ZP1
                YPFIRST=YP1

C--- CALCULATE VECTOR POTENTIAL AT THE BEGINNING

                CALL MYBFELD(X1,Y1,Z1,BX1,BY1,BZ1,AX1,AY1,AZ1)

              ELSE

                CALL MYBFELD(OPENDX,Y1,Z1,BX1,BY1,BZ1,AX1,AY1,AZ1)

              ENDIF !(IERZFUN)

              AXFIRST=AX1
              AYFIRST=AY1
              AZFIRST=AZ1

              BXFIRST=BX1
              BYFIRST=BY1
              BZFIRST=BZ1

              IF (IERZFUN.NE.0.AND.IERZFUN.NE.100) THEN

                X1=OPSTARTX
                CALL ERZFUN(GAMMA,X1,BX1,BY1,BZ1,BX2,BY2,BZ2,
     &            AX1,AY1,AZ1,AX2,AY2,AZ2,Z1,ZP1,Y1,YP1,
     &            Z2,ZP2,Y2,YP2,OPSTARTX,OPENDX)
                X2=OPENDX

              ELSE IF (ABS(IERZFUN).EQ.100) THEN

                CALL IDTRMSHGF(
     &            X1,Y1,Z1,VX1,VY1,VZ1,
     &            X2,Y2,Z2,VX2,VY2,VZ2,
     &            X0,Y0,Z0,VX0,VY0,VZ0,
     &            XF0,YF0,ZF0,VXF0,VYF0,VZF0,"wave_erzfun.in")

                ZP2=VZ2/VX2
                YP2=VY2/VX2

                CALL MYBFELD(X2,Y2,Z2,BX2,BY2,BZ2,AX2,AY2,AZ2)

              ELSE IF (KBFELD.NE.0.AND.IBHARD.NE.0) THEN

C        CALL BHARD(X0,XSTOP,GAMMA,Z1,ZP1,Y1,YP1,Z2,ZP2,Y2,YP2)

                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'*** ERROR IN OPTI ***'
                WRITE(LUNGFO,*)'SR BHARD HERE NOT AVAILABLE'
                WRITE(LUNGFO,*)'CHECK INPUT FILE (FLAG IBHARD)'
                WRITE(6,*)
                WRITE(6,*)'*** ERROR IN OPTI ***'
                WRITE(6,*)'SR BHARD HERE NOT AVAILABLE'
                WRITE(6,*)'CHECK INPUT FILE (FLAG IBHARD)'
                STOP

              ELSE IF (IERZANA.NE.0) THEN

C START- AND END PLANE OF MAGNET ARE OVERWRITTEN IN SR ERZANA

                CALL ERZANA(OPSTARTX,OPENDX,
     &            OPNX,OPNY,OPNZ,
     &            OPNFX,OPNFY,OPNFZ,
     &            Z1,ZP1,Y1,YP1,Z2,ZP2,Y2,YP2,
     &            BX1,BY1,BZ1,BX2,BY2,BZ2,
     &            AX1,AY1,AZ1,AX2,AY2,AZ2)

              ELSE IF (KBFELD.NE.0.AND.IBHTRACK.NE.0) THEN

C CHECK OPSTART, OPEND
C     CALL BHTRACK (GAMMA,X1,Y1,Z1,V0,VX1,VY1,VZ1,
C     &                       X2,Y2,Z2,ZP2,YP2)

                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'*** ERROR IN OPTI ***'
                WRITE(LUNGFO,*)'SR BHTRACK HERE NOT AVAILABLE'
                WRITE(LUNGFO,*)'CHECK INPUT FILE (FLAG IBHTRACK)'
                WRITE(6,*)
                WRITE(6,*)'*** ERROR IN OPTI ***'
                WRITE(6,*)'SR BHTRACK HERE NOT AVAILABLE'
                WRITE(6,*)'CHECK INPUT FILE (FLAG IBHTRACK)'
                STOP

              ELSE !IERZFUN

C NORMAL CASE

                CALL TRACK(X1,Y1,Z1,VX1,VY1,VZ1,
     &            XFO,YFO,ZFO,OPNFX,OPNFY,OPNFZ,
     &            X2,Y2,Z2,VX2,VY2,VZ2,DTIM,BSHIFT,GAMMA,GAMMALOSS)

                if (iwarnmyb.ne.0) then
                  icount=icount-1
                  goto 130
                endif

                IF (BMAXGL2.GT.BOLD) THEN
                  BOLD=BMAXGL2
                  XBMAXI=X1
                  YBMAXI=Y1
                  ZBMAXI=Z1
                  VXBMAXI=VX1
                  VYBMAXI=VY1
                  VZBMAXI=VZ1
                ENDIF

                ZP2=VZ2/VX2
                YP2=VY2/VX2

                CALL MYBFELD(X2,Y2,Z2,BX2,BY2,BZ2,AX2,AY2,AZ2)

              ENDIF  !IERZFUN

              IF (IERZFUN.EQ.0 .AND. IERZANA.EQ.0) THEN

                OPTBUF(1,ICOUNT)=XFIRST
                OPTBUF(2,ICOUNT)=ZFIRST
                OPTBUF(3,ICOUNT)=ZPFIRST
                OPTBUF(4,ICOUNT)=YFIRST
                OPTBUF(5,ICOUNT)=YPFIRST
                OPTBUF(6,ICOUNT)=BXFIRST
                OPTBUF(7,ICOUNT)=BYFIRST
                OPTBUF(8,ICOUNT)=BZFIRST
                OPTBUF(9,ICOUNT)=AXFIRST
                OPTBUF(10,ICOUNT)=AYFIRST
                OPTBUF(11,ICOUNT)=AZFIRST

              ELSE   !IERZFUN

                OPTBUF(1,ICOUNT)=X1
                OPTBUF(2,ICOUNT)=Z1
                OPTBUF(3,ICOUNT)=ZP1
                OPTBUF(4,ICOUNT)=Y1
                OPTBUF(5,ICOUNT)=YP1
                OPTBUF(6,ICOUNT)=BX1
                OPTBUF(7,ICOUNT)=BY1
                OPTBUF(8,ICOUNT)=BZ1
                OPTBUF(9,ICOUNT)=AX1
                OPTBUF(10,ICOUNT)=AY1
                OPTBUF(11,ICOUNT)=AZ1

              ENDIF !IERZFUN

              OPTBUF(12,ICOUNT)=X2
              OPTBUF(13,ICOUNT)=Z2
              OPTBUF(14,ICOUNT)=ZP2
              OPTBUF(15,ICOUNT)=Y2
              OPTBUF(16,ICOUNT)=YP2
              OPTBUF(17,ICOUNT)=BX2
              OPTBUF(18,ICOUNT)=BY2
              OPTBUF(19,ICOUNT)=BZ2
              OPTBUF(20,ICOUNT)=AX2
              OPTBUF(21,ICOUNT)=AY2
              OPTBUF(22,ICOUNT)=AZ2
              OPTBUF(23,ICOUNT)=WTRA2IC
c              OPTBUF(24,ICOUNT)=tint

130         CONTINUE
120       CONTINUE
110     CONTINUE
100   CONTINUE

1301  NTOT=ICOUNT

      OPEN(UNIT=LUNO,FILE=FILEO,STATUS='unknown',recl=1024) !,FORM='UNFORMATTED')

      write(luno,*)CODE
      write(luno,*)ICODE
      write(luno,*)GAMMA,dgam
      write(luno,*)NTOT

      IF (IERZFUN.NE.0) THEN

          XIO=OPSTARTX
          YIO=0.
          ZIO=0.
          ZPIO=0.
          YPIO=0.
          BXIO=0.
          BYIO=0.
          BZIO=0.
          AXIO=0.
          AYIO=0.
          AZIO=0.

          XFO=OPENDX
          YFO=0.
          ZFO=0.
          ZPFO=0.
          YPFO=0.
          BXFO=0.
          BYFO=0.
          BZFO=0.
          AXFO=0.
          AYFO=0.
          AZFO=0.

          OPNX=1.
          OPNY=0.
          OPNZ=0.

          OPNFX=1.
          OPNFY=0.
          OPNFZ=0.

      ENDIF

      IF (IERZANA.NE.0) THEN

          XIO=OPSTARTX
          YIO=0.
          ZIO=0.
          ZPIO=0.
          YPIO=0.
          XFO=OPENDX

          CALL ERZANA(OPSTARTX,OPENDX,OPNX,OPNY,OPNZ, !REFERENCE ORBIT
     &                  OPNFX,OPNFY,OPNFZ,
     &                  ZIO,ZPIO,YIO,YPIO,ZFO,ZPFO,YFO,YPFO,
     &                  BXIO,BYIO,BZIO,BXFO,BYFO,BZFO,
     &                  AXIO,AYIO,AZIO,AXFO,AYFO,AZFO)

      ENDIF

      write(luno,*)XIO,YIO,ZIO,ZPIO,YPIO,BXIO,BYIO,BZIO,AXIO,AYIO,AZIO
      write(luno,*)XFO,YFO,ZFO,ZPFO,YPFO,BXFO,BYFO,BZFO,AXFO,AYFO,AZFO
      write(luno,*)xf0,yf0,zf0,vzf0/vxf0,vyf0/vxf0,axf0,ayf0,azf0 !18.1.2018
      write(luno,*)OPNX,OPNY,OPNZ
      write(luno,*)OPNFX,OPNFY,OPNFZ
      write(luno,*)ZAPERT,YAPERT,DLAPER,bint0

      DO I=1,NTOT
        write(luno,*) (OPTBUF(J,I),J=1,23)
c        write(luno,*) (OPTBUF(J,I),J=1,11)
c        write(luno,*) (OPTBUF(J,I),J=12,23)
        IF (IHPHSPAC.NE.0) THEN
          DO J=1,23
            TUP(J)=OPTBUF(J,I)
          ENDDO
          CALL hfm(NIDTRAC+1,TUP)
        ENDIF
      ENDDO

      CLOSE(LUNO)

C     WRITE(6,*)'*** SR OPTI:',ICOUNT,' ANFANGS- UND ENDZUSTAENDE AUF',
C     &            FILEO,' GESCHRIEBEN ***'
C     WRITE(6,*)
C     WRITE(6,*) 'VERLUSTE DURCH HORZ. UND VERT. APERTUR:',IZFAIL,IYFAIL
C     WRITE(6,*)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Number of tracks written to file:',ICOUNT
      WRITE(LUNGFO,*)'     Filename: ',FILEO

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &'     Reference point of entrance plane (OPSTARTX,OPSTARTY,OPSTARTZ):'
      WRITE(LUNGFO,*)'     ',SNGL(OPSTARTX),SNGL(OPSTARTY),SNGL(OPSTARTZ)
      WRITE(LUNGFO,*)
     &  '     Normal vector of entrance plane (OPNX,OPNY,OPNZ):'
      WRITE(LUNGFO,*)'     ',SNGL(OPNX),SNGL(OPNY),SNGL(OPNZ)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Reference point of exit plane (OPENDX,OPENDY,OPENDZ):'
      WRITE(LUNGFO,*)'     ',SNGL(OPENDX),SNGL(OPENDY),SNGL(OPENDZ)
      WRITE(LUNGFO,*)
     &  '     Normal vector of exit plane (OPNFX,OPNFY,OPNFZ):'
      WRITE(LUNGFO,*)'     ',SNGL(OPNFX),SNGL(OPNFY),SNGL(OPNFZ)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &'     Parameter NZOPT, NYOPT, NZPOPT, NYPOPT to define number of grid points:'
      WRITE(LUNGFO,*)'     ',NZOPT, NYOPT, NZPOPT, NYPOPT
      WRITE(LUNGFO,*)
     &'     Mash sizes 2.*DZOPT, 2.*DYOPT, 2.*DZPOPT, 2.*DYPOPT of grid:'
      WRITE(LUNGFO,*)'     ',SNGL(2.*DZOPT), SNGL(2.*DYOPT),
     &                         SNGL(2.*DZPOPT),SNGL(2.*DYPOPT)

      WRITE(LUNGFO,*)
      IF (IPHASPAC.NE.0) THEN
      WRITE(LUNGFO,*)
     &'     Horizontal low and high beta functions:',SNGL(BETA0ZL),SNGL(BETA0ZH)
      WRITE(LUNGFO,*)
     &'     Vertical low and high beta functions:',SNGL(BETA0YL),SNGL(BETA0YH)
      WRITE(LUNGFO,*)
      ENDIF
      WRITE(LUNGFO,*)
     &'     Losses due to hori. and vert. aperture cut:',IZFAIL,IYFAIL
      WRITE(LUNGFO,*)
     &'     Hori. and vert. aperture and collimator length (ZAPERT,YAPERT,DLAPER):'
      WRITE(LUNGFO,*)'     ',SNGL(ZAPERT),SNGL(YAPERT),SNGL(DLAPER)
      WRITE(LUNGFO,*)

      IF (IERZANA.NE.0.AND.IERZFUN.EQ.0) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     BMAXGL found while in SR OPTI:'
     &    ,DSQRT(DABS(BOLD))
        WRITE(LUNGFO,*)
     &    'start of corresponding track:'
        WRITE(LUNGFO,*)'     XBMAXI, YBMAXI, ZBMAXI:'
        WRITE(LUNGFO,*)'     ',XBMAXI, YBMAXI, ZBMAXI
        WRITE(LUNGFO,*)'     VXBMAXI, VYBMAXI, VZBMAXI:'
        VN=DSQRT(VXBMAXI**2+VYBMAXI**2+VZBMAXI**2)
        WRITE(LUNGFO,*)'     ',VXBMAXI/VN, VYBMAXI/VN, VZBMAXI/VN
        WRITE(LUNGFO,*)

        BMAXGL2=BSTORE
        XBMAXGL=XSTORE
        YBMAXGL=YSTORE
        ZBMAXGL=ZSTORE

      ENDIF

      RETURN
      END
+DECK,OUTDUM.
*CMZ : 00.01/04 25/01/95  17.27.39  by  Michael Scheer
*-- Author :    Michael Scheer   25/01/95
      SUBROUTINE OUTDUM
+seq,gplhint.

      RETURN
      END
+DECK,PARABEL.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.63/02 05/02/2008  14.00.22  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.35  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.52  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE PARABEL(x1,y1,x2,y2,x3,y3,A)

+seq,gplhint.
C--- CALCULATES A(1), A(2), A(3) OF PARABOLA Y=A1+A2*X+A3*X**2 FROM COORDINATES
C    OF THREE POINTS

      IMPLICIT NONE

        DOUBLE PRECISION x1,x2,x3,y1,y2,y3,a(3)
        DOUBLE PRECISION x(3),y(3),yp(3),xopt,yopt
        integer ifail

        x(1)=x1
        x(2)=x2
        x(3)=x3

        y(1)=y1
        y(2)=y2
        y(3)=y3

        call UTIL_PARABEL(X,Y,A,YP,XOPT,yopt,IFAIL)

        if (ifail.ne.0) then
          print*,'*** Warning in PARABEL: IFAIL .ne. 0'
        endif

      RETURN
      END
+DECK,phase.
*CMZ :  4.01/03 10/06/2023  09.57.38  by  Michael Scheer
*CMZ :  4.00/14 07/02/2022  16.17.00  by  Michael Scheer
*CMZ :  3.02/05 22/03/2015  19.55.19  by  Michael Scheer
*CMZ :  3.02/03 23/10/2014  13.43.13  by  Michael Scheer
*CMZ :  3.02/00 15/10/2014  09.29.12  by  Michael Scheer
*CMZ :  3.01/05 12/06/2014  08.52.10  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.13.36  by  Michael Scheer
*CMZ :  2.70/09 15/01/2013  14.58.32  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  15.34.39  by  Michael Scheer
*CMZ :  2.70/03 14/12/2012  14.29.48  by  Michael Scheer
*CMZ :  2.70/02 14/12/2012  10.34.16  by  Michael Scheer
*CMZ :  2.70/01 12/12/2012  15.50.01  by  Michael Scheer
*CMZ :  2.70/00 11/12/2012  17.05.31  by  Michael Scheer
*CMZ :  2.68/05 28/09/2012  12.06.21  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  09.55.57  by  Michael Scheer
*CMZ :  2.63/05 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.49/00 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.48/04 12/03/2004  15.40.31  by  Michael Scheer
*CMZ :  2.47/21 03/12/2003  09.40.09  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.41/07 13/06/2002  15.07.39  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.20/01 03/01/2001  13.40.19  by  Michael Scheer
*CMZ :  2.16/08 27/10/2000  14.30.15  by  Michael Scheer
*CMZ :  2.16/04 24/06/2000  17.20.05  by  Michael Scheer
*CMZ :  2.16/00 07/06/2000  23.23.42  by  Michael Scheer
*CMZ :  2.15/00 02/05/2000  18.08.47  by  Michael Scheer
*CMZ :  2.13/07 10/02/2000  16.43.36  by  Michael Scheer
*CMZ :  2.13/04 21/01/2000  12.37.13  by  Michael Scheer
*CMZ :  2.13/03 18/01/2000  18.06.22  by  Michael Scheer
*CMZ :  2.13/00 01/12/99  17.14.49  by  Michael Scheer
*CMZ :  2.10/01 30/04/99  13.59.54  by  Michael Scheer
*CMZ :  1.04/00 27/11/98  12.44.48  by  Michael Scheer
*CMZ :  1.03/06 29/09/98  14.43.55  by  Michael Scheer
*-- Author :    Michael Scheer   18/09/98
      SUBROUTINE PHASE
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,PHASEF90U.
+SEQ,PHASEWSF90U.
+SEQ,WBETAF90U.
+SEQ,WBETAF90U.

* ROUTINE TO PROPAGATE COMPLEXE AMPLITUDE FROM PINHOLE BACK TO
* LOCATION OF EFFECTIVE SOURCE AT (PHCENX,PHCENY,PHCENZ)


      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+seq,reargf90.
+SEQ,PHYCON.
+seq,sourcef90.
+SEQ,SPECT.
+SEQ,FREQS.
+SEq,observf90.
+SEq,phasef90.
+seq,track.
+SEQ,depola.
+SEQ,wfoldf90.
+seq,wbetaf90.
+seq,whbook.
+seq,pawcmn.

      CHARACTER(8) OLDDIR

      INTEGER ICYCLE,NTUP_P,IOBS,IPHZ,IPHY,ifrq,IEPS,I,NGEO_P,ISOUR
      INTEGER NIDGEO1,ISTAT,NIDGEO2,NBEAM_P,J,IELEM,NSIZE_P
      INTEGER IOBSY,IOBSZ,K,ix

      PARAMETER(NTUP_P=15,NGEO_P=16,NBEAM_P=16,NSIZE_P=4)

      CHARACTER(5) CHTAGS(NTUP_P),CHGEO(NGEO_P),CHBEAM(NBEAM_P)
      CHARACTER(5) CHSIZE(NSIZE_P)

      REAL*8 TUP(NTUP_P),TGEO(NGEO_P),SELGEO,TBEAM(NGEO_P),TSIZ(NSIZE_P)
      REAL*4 FLOW,FHIG,DF

      DOUBLE PRECISION XPH,YPH,ZPH,XOBS,YOBS,ZOBS,DX,DY,DZ,DZY2,ANS
     &  ,OMC,DOMC,DR,DRRED,DX2,DMASHZ,DMASHY,PHLOWZ,PHLOWY,EPS(6)
     &  ,FOCUS,RLAMBDA1,smax,sfmax

      DOUBLE PRECISION XSOUR,YSOUR,ZSOUR,DR2PH,DR2SOUR,THETA,PHI,TANTHE,TANPHI
     &  ,DXPH,DA,EPSBEAM
     &  ,XBEAM,YBEAM,ZBEAM,TANTHEB,TANPHIB,OPTMAT(4,4),BEAM(4)
     &  ,TOTMAT(4,4),DUMMAT(4,4)

      DOUBLE PRECISION W
      DOUBLE PRECISION XA(NDOBSVZP)
     &  ,YAR1(NDOBSVZP)
     &  ,YAR2(NDOBSVZP)
     &  ,YAR3(NDOBSVZP)
     &  ,YAI1(NDOBSVZP)
     &        ,YAI2(NDOBSVZP)
     &  ,YAI3(NDOBSVZP)
     &  ,RESULT(3,2)

      DOUBLE PRECISION XAY(NDOBSVYP)
     &  ,YAR1Y(NDOBSVYP)
     &  ,YAR2Y(NDOBSVYP)
     &  ,YAR3Y(NDOBSVYP)
     &  ,YAI1Y(NDOBSVYP)
     &  ,YAI2Y(NDOBSVYP)
     &  ,YAI3Y(NDOBSVYP)
     &  ,RESULTY(3,2)

      DOUBLE PRECISION WS1(NDOBSVZP+NDOBSVYP),WS2(NDOBSVZP+NDOBSVYP)
      DOUBLE PRECISION WS3(NDOBSVZP+NDOBSVYP),WS4(NDOBSVZP+NDOBSVYP)
      DOUBLE PRECISION COEFF(NDOBSVZP+NDOBSVYP)

      double precision, dimension (:,:), allocatable :: phspecfy
      double precision, dimension (:), allocatable :: zphw,yphw,
     &  specwz,specwy,specfwz,specfwy,phws1,phws2,phcoef,phws3,phws4
      double precision phgsigz,phgsigy,wlen,sigrp,sigr

      integer is0

      character(8) chphase
      integer lenchphase

      DATA CHTAGS
     &  /'x','y','z','e','ie','iy','iz',
     &  're_x','im_x','re_y','im_y','re_z','im_z','spec','specf'/
      data chgeo
     &  /'x','y','z','yp','zp','e','ie','is','xs','ys','zs','spec'
     &  ,'xo','yo','zo','speco'/
      data chbeam
     &  /'x','y','z','yp','zp','e','ie','is','xs','ys','zs','spec'
     &  ,'xo','yo','zo','speco'/
      data chsize /'ie','is','zrms','yrms'/

      DATA EPSBEAM/0.001D0/

+SELF,IF=NOCMPLX.
      stop '*** SR PHASE: +SELF,IF=NOCMPLX NOT AVAILABLE ANYMORE IN SR PHASE! ***'
+self.

      if (mhbookp.eq.0) then
        chphase='//PHASE'
        lenchphase=7
      else
        chphase='//WAVE'
        lenchphase=6
      endif

      if (iemit.eq.1) then
        do ix=1,nco-1
          if (wbeta(1,ix).le.phcenx.and.wbeta(1,ix+1).gt.phcenx) then
            is0=ix
          endif
        enddo
      endif

      if (iphfold.ne.0) then
        if (phbeth.eq.-9999.0d0) then
          phbeth=wbeta(2,is0)
        endif
        if (phbetv.eq.-9999.0d0) then
          phbetv=wbeta(4,is0)
        endif
      endif

      wlen=wtoe1/freqlow/1.0d9
      sigrp=sqrt(wlen/(sourceeo(1,1,1)-sourceao(1,1,1)))
      sigr=wlen/twopi1/sigrp
      if (phwid.eq.-9999.0d0) then
        phwid=10.0d0*sqrt(sigr**2+
     &    ((phcenx-sourcen(1,1,1))*sigrp)**2)
      endif
      if (phhig.eq.-9999.0d0) then
        phhig=10.0d0*sqrt(sigr**2+
     &    ((phcenx-sourcen(1,1,1))*sigrp)**2)
      endif

      nphasez=(nphasez/2)*2+1
      nphasey=(nphasey/2)*2+1

      IF (NPHASEZ.GT.1) THEN
        DMASHZ=PHWID/(NPHASEZ-1)
      ELSE
        PHWID=0.D0
        DMASHZ=0.D0
      ENDIF
      IF (NPHASEY.GT.1) THEN
        DMASHY=PHHIG/(NPHASEY-1)
      ELSE
        PHHIG=0.D0
        DMASHY=0.D0
      ENDIF

      DA=PINW/(MOBSVZ-1)*PINH/(MOBSVY-1)

      if (phceny.eq.-9999.) phceny=ystart+vyin/vxin*(phcenx-xstart)
      if (phcenz.eq.-9999.) phcenz=zstart+vzin/vxin*(phcenx-xstart)

      if (iphfold.ne.0) then

        if (phbeth.le.0.0d0.or.phbetv.le.0.0d0) then
          write(lungfo,*)' '
          write(lungfo,*)
     &      '*** PHBETH or PHBETV lower or equal zero, WAVE aborted ***'
          write(lungfo,*)' '
          write(6,*)' '
          write(6,*)
     &      '*** PHBETH or PHBETV lower or equal zero, WAVE aborted ***'
          write(6,*)' '
        endif

        phgsigz=eps0h*phbeth
        phgsigy=eps0v*phbetv

        if (phgsigz.gt.0.0d0) then
          phgsigz=sqrt(phgsigz)
        else
          phgsigz=0.0d0
        endif

        if (phgsigy.gt.0.0d0) then
          phgsigy=sqrt(phgsigy)
        else
          phgsigy=0.0d0
        endif

      endif

      if (mphasez.eq.-9999) then
        if (dmashz.gt.0.0d0) then
          mphasez=nphasez+(dgsigz(1)*phgsigz/dmashz+1)*4
        else
          mphasez=0
        endif
      endif

      if (mphasey.eq.-9999) then
        if (dmashy.gt.0.0d0) then
          mphasey=nphasey+(dgsigy(1)*phgsigy/dmashy+1)*4
        else
          mphasey=0
        endif
      endif

      if (mphasez.lt.nphasez) mphasez=nphasez
      if (mphasey.lt.nphasey) mphasey=nphasey

      mphasez=(mphasez/2)*2+1
      mphasey=(mphasey/2)*2+1

      ALLOCATE(WSUM(NSOURCE*NFREQ))
      ALLOCATE(PHMEANZ(NSOURCE*NFREQ))
      ALLOCATE(PHMEANY(NSOURCE*NFREQ))
      ALLOCATE(PHSIGZ(NSOURCE*NFREQ))
      ALLOCATE(PHSIGY(NSOURCE*NFREQ))
      ALLOCATE(PHSHIFT(NOBSV))
      ALLOCATE(AMPLI(3,mphasez,mphasey,NFREQ))
      ALLOCATE(phspec(mphasez,mphasey))
      ALLOCATE(phspecf(mphasez,mphasey))
      ALLOCATE(phspecfy(mphasez,mphasey))
      ALLOCATE(zphw(mphasez))
      ALLOCATE(specwz(mphasez))
      ALLOCATE(specfwz(mphasez))
      ALLOCATE(yphw(mphasey))
      ALLOCATE(specwy(mphasey))
      ALLOCATE(specfwy(mphasey))
      allocate(phcoef(max(mphasez,mphasey)))
      allocate(phws1(max(mphasez,mphasey)))
      allocate(phws2(max(mphasez,mphasey)))
      allocate(phws3(max(mphasez,mphasey)))
      allocate(phws4(max(mphasez,mphasey)))
      ALLOCATE(EXPOM(NOBSV*NFREQ))
      ALLOCATE(DEXPOM(NOBSV))

      ampli=(0.0d0,0.0d0)
      specwz=0.0d0
      specwy=0.0d0
      phspec=0.0d0
      phspecf=0.0d0
      phspecfy=0.0d0

      if (mhbookp.eq.0 .and. iroottrees.ge.0) then
        CALL hcdirm(OLDDIR,'R')
        CALL hropenm(LUNPH,'PHASE',FILEPH,'N',1024,ISTAT)
        CALL hcdirm(chphase(1:lenchphase),' ')
        IF (ISTAT.NE.0) THEN
          WRITE(6,*)'*** ERROR IN hropenm (SR PHASE) ***'
          WRITE(LUNGFO,*)'*** ERROR IN hropenm (SR PHASE) ***'
          STOP
        ENDIF
        CALL MHROUT(IDCODE,ICYCLE,' ')
      endif

      DO ifrq=1,NFREQ
        PHGEOSUM(ifrq)=0.D0
        PHGEOSEL(ifrq)=0.D0
        PHBEAM(ifrq)=0.D0
        DO ISOUR=1,NSOURCE
          ILIFR=ISOUR+NSOURCE*(ifrq-1)
          WSUM(ILIFR)=0.D0
          PHMEANZ(ILIFR)=0.D0
          PHMEANY(ILIFR)=0.D0
          PHSIGZ(ILIFR)=0.D0
          PHSIGY(ILIFR)=0.D0
        ENDDO
      ENDDO

+self,if=-mhbook.
      CALL hbookm(NIDPHASE,'PHASE',NTUP_P,chphase(1:lenchphase),1024,CHTAGS)
+self,if=mhbook.
      CALL hbookm(NIDPHASE,'PHASE',NTUP_P,chphase(1:lenchphase),
     &  mphasez*mphasey*nfreq,CHTAGS)
+self.
      XPH=PHCENX
      XOBS=PINCEN(1)
      DX=XOBS-XPH
      DX2=DX*DX

      IF (DX.EQ.0.0D0) THEN
        WRITE(LUNGFO,*)'*** ERROR IN PHASE: PHCENX=PINCEN(1)  ***'
        WRITE(LUNGFO,*)'CHECK INPUT FILE'
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
        WRITE(6,*)'*** ERROR IN PHASE: PHCENX=PINCEN(1)  ***'
        WRITE(6,*)'CHECK INPUT FILE'
        WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
        STOP
      ENDIF

      PHLOWZ=PHCENZ-PHWID/2.D0
      PHLOWY=PHCENY-PHHIG/2.D0
      YPH=PHLOWY-DMASHY

      OMC=FREQ(1)/(HBAREV1*CLIGHT1)
      IF (ifreq2p.GT.2) THEN
        DOMC=(FREQ(2)-FREQ(1))/(HBAREV1*CLIGHT1)
      ELSE
        DOMC=OMC
      ENDIF !(ifreq2p.GT.2)

      DO iphy=(mphasey-nphasey)/2+1,(mphasey-nphasey)/2+NPHASEY

        YPH=YPH+DMASHY
        ZPH=PHLOWZ-DMASHZ

        DO IPHZ=(mphasez-nphasez)/2+1,nphasez+(mphasez-nphasez)/2

          ZPH=ZPH+DMASHZ

          DO IOBS=1,NOBSV

            XOBS=OBSV(1,IOBS)
            YOBS=OBSV(2,IOBS)
            ZOBS=OBSV(3,IOBS)

            DY=YOBS-YPH
            DZ=ZOBS-ZPH
            DZY2=DZ*DZ+DY*DY

C     TO MAKE SURE THAT TAYLOR-EXPANSION IS VALID

            IF (DZY2.GT.0.01D0*DX2) THEN
              WRITE(LUNGFO,*)'*** ERROR IN PHASE: DZY2.GT.0.01D0*DX2  ***'
              WRITE(LUNGFO,*)'CHECK INPUT FILE AND INCREASE PINCEN(1)'
              WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
              WRITE(6,*)'*** ERROR IN PHASE: PHCENX=PINCEN(1)  ***'
              WRITE(6,*)'CHECK INPUT FILE AND INCREASE PINCEN(1)'
              WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
              STOP
            ENDIF

            EPS(1)=DZY2/DX2
            DO IEPS=2,6
              EPS(IEPS)=EPS(IEPS-1)*EPS(1)
            ENDDO !IEPS

c      TAYLOR-EXPANSION DONE WITH REDUCE
c     IN "WTAY1.RED";
c     on rounded;
c     on numval;
c     precision 13;
c     F:=SQRT(1+EPS);
c     DR:=TAY1(F,EPS,6);
c     ON FORT;
c     OUT "RED.FOR";
c     DR;
c     SHUT "RED.FOR";
C ans is actually reduce by 1.0 to avoid large overall phase

            ans=-0.0205078125D0*eps(6)+0.02734375D0*eps(5)
     &        -0.0390625D0*eps(4)+
     &        0.0625D0*eps(3)-0.125D0*eps(2)+0.5D0*eps(1)

            DR=DABS(DX*(ANS+1.D0))
            DRRED=-DABS(DX*ANS)

            IF (DR.NE.0.D0) THEN
              EXPOM(IOBS)=CDEXP(DCMPLX(0.D0,DRRED*OMC))/DR
            ELSE
              EXPOM(IOBS)=1.D0
            ENDIF
            DEXPOM(IOBS)=CDEXP(DCMPLX(0.D0,DRRED*DOMC))

          ENDDO   !NOBS

          DO ifrq=1,NFREQ

            RLAMBDA1=FREQ(ifrq)/WTOE1*1.D9   !1/lambda[m]=1/(wtoe1/freq*1.e-9)

            IF (IPHASE.GT.0) THEN

              DO IOBS=1,NOBSV

                IOBFR=IOBS+NOBSV*(ifrq-1)

                IF (ifrq.EQ.1) THEN

                  PHSHIFT(IOBS)=EXPOM(IOBFR)
                ELSE
                  PHSHIFT(IOBS)=PHSHIFT(IOBS)*DEXPOM(IOBS)
                ENDIF   !(ifrq.EQ.1)

                IF (DX.GE.0) THEN

                  ampli(1,iphz,iphy,ifrq)=ampli(1,iphz,iphy,ifrq)+
     &              DCMPLX(REAIMA(1,1,IOBFR),REAIMA(1,2,IOBFR))
     &              *PHSHIFT(IOBS)
                  ampli(2,iphz,iphy,ifrq)=ampli(2,iphz,iphy,ifrq)+
     &              DCMPLX(REAIMA(2,1,IOBFR),REAIMA(2,2,IOBFR))
     &              *PHSHIFT(IOBS)
                  ampli(3,iphz,iphy,ifrq)=ampli(3,iphz,iphy,ifrq)+
     &              DCMPLX(REAIMA(3,1,IOBFR),REAIMA(3,2,IOBFR))
     &              *PHSHIFT(IOBS)

                ELSE

                  ampli(1,iphz,iphy,ifrq)=ampli(1,iphz,iphy,ifrq)+
     &              DCMPLX(REAIMA(1,1,IOBFR),-REAIMA(1,2,IOBFR))
     &              *PHSHIFT(IOBS)
                  ampli(2,iphz,iphy,ifrq)=ampli(2,iphz,iphy,ifrq)+
     &              DCMPLX(REAIMA(2,1,IOBFR),-REAIMA(2,2,IOBFR))
     &              *PHSHIFT(IOBS)
                  ampli(3,iphz,iphy,ifrq)=ampli(3,iphz,iphy,ifrq)+
     &              DCMPLX(REAIMA(3,1,IOBFR),-REAIMA(3,2,IOBFR))
     &              *PHSHIFT(IOBS)

                ENDIF !(DX.GE.0)


              ENDDO  !NOBSV

              ampli(1,iphz,iphy,ifrq)=ampli(1,iphz,iphy,ifrq)*DA*RLAMBDA1
              ampli(2,iphz,iphy,ifrq)=ampli(2,iphz,iphy,ifrq)*DA*RLAMBDA1
              ampli(3,iphz,iphy,ifrq)=ampli(3,iphz,iphy,ifrq)*DA*RLAMBDA1

            ELSE  !IPHASE.GT.0

              IOBS=0
              DO IOBSY=1,NOBSVY
                DO IOBSZ=1,NOBSVZ

                  IOBS=IOBS+1

                  IF (ifrq.EQ.1) THEN
                    PHSHIFT(IOBS)=EXPOM(IOBS+NOBSV*(ifrq-1))
                  ELSE
                    PHSHIFT(IOBS)=PHSHIFT(IOBS)*DEXPOM(IOBS)
                  ENDIF !(ifrq.EQ.1)

                  IOBFR=IOBS+NOBSV*(ifrq-1)
c+seq,dummy.
                  IF (DX.GE.0) THEN

                    ampli(1,iphz,iphy,ifrq)=
     &                DCMPLX(REAIMA(1,1,IOBFR),REAIMA(1,2,IOBFR))
     &                *PHSHIFT(IOBS)
                    ampli(2,iphz,iphy,ifrq)=
     &                DCMPLX(REAIMA(2,1,IOBFR),REAIMA(2,2,IOBFR))
     &                *PHSHIFT(IOBS)
                    ampli(3,iphz,iphy,ifrq)=
     &                DCMPLX(REAIMA(3,1,IOBFR),REAIMA(3,2,IOBFR))
     &                *PHSHIFT(IOBS)

                  ELSE

                    ampli(1,iphz,iphy,ifrq)=
     &                DCMPLX(REAIMA(1,1,IOBFR),-REAIMA(1,2,IOBFR))
     &                *PHSHIFT(IOBS)
                    ampli(2,iphz,iphy,ifrq)=
     &                DCMPLX(REAIMA(2,1,IOBFR),-REAIMA(2,2,IOBFR))
     &                *PHSHIFT(IOBS)
                    ampli(3,iphz,iphy,ifrq)=
     &                DCMPLX(REAIMA(3,1,IOBFR),-REAIMA(3,2,IOBFR))
     &                *PHSHIFT(IOBS)

                  ENDIF !(DX.GE.0)

                  XA(IOBSZ)=OBSVZ(IOBSZ)

                  YAR1(IOBSZ)=DREAL(ampli(1,iphz,iphy,ifrq))
                  YAR2(IOBSZ)=DREAL(ampli(2,iphz,iphy,ifrq))
                  YAR3(IOBSZ)=DREAL(ampli(3,iphz,iphy,ifrq))

                  YAI1(IOBSZ)=DIMAG(ampli(1,iphz,iphy,ifrq))
                  YAI2(IOBSZ)=DIMAG(ampli(2,iphz,iphy,ifrq))
                  YAI3(IOBSZ)=DIMAG(ampli(3,iphz,iphy,ifrq))

                ENDDO   !NOBSVZ

                CALL UTIL_SPLINE_INTEGRAL
     &            (XA,YAR1,NOBSVZ,RESULT(1,1),COEFF,WS1,WS2,WS3,WS4)
                CALL UTIL_SPLINE_INTEGRAL
     &            (XA,YAI1,NOBSVZ,RESULT(1,2),COEFF,WS1,WS2,WS3,WS4)

                CALL UTIL_SPLINE_INTEGRAL
     &            (XA,YAR2,NOBSVZ,RESULT(2,1),COEFF,WS1,WS2,WS3,WS4)
                CALL UTIL_SPLINE_INTEGRAL
     &            (XA,YAI2,NOBSVZ,RESULT(2,2),COEFF,WS1,WS2,WS3,WS4)

                CALL UTIL_SPLINE_INTEGRAL
     &            (XA,YAR3,NOBSVZ,RESULT(3,1),COEFF,WS1,WS2,WS3,WS4)
                CALL UTIL_SPLINE_INTEGRAL
     &            (XA,YAI3,NOBSVZ,RESULT(3,2),COEFF,WS1,WS2,WS3,WS4)

                XAY(IOBSY)=OBSVY(IOBSY)
                YAR1Y(IOBSY)=RESULT(1,1)
                YAI1Y(IOBSY)=RESULT(1,2)
                YAR2Y(IOBSY)=RESULT(2,1)
                YAI2Y(IOBSY)=RESULT(2,2)
                YAR3Y(IOBSY)=RESULT(3,1)
                YAI3Y(IOBSY)=RESULT(3,2)

              ENDDO !NOBSVY

              CALL UTIL_SPLINE_INTEGRAL
     &          (XAY,YAR1Y,NOBSVY,RESULTY(1,1),COEFF,WS1,WS2,WS3,WS4)
              CALL UTIL_SPLINE_INTEGRAL
     &          (XAY,YAI1Y,NOBSVY,RESULTY(1,2),COEFF,WS1,WS2,WS3,WS4)

              CALL UTIL_SPLINE_INTEGRAL
     &          (XAY,YAR2Y,NOBSVY,RESULTY(2,1),COEFF,WS1,WS2,WS3,WS4)
              CALL UTIL_SPLINE_INTEGRAL
     &          (XAY,YAI2Y,NOBSVY,RESULTY(2,2),COEFF,WS1,WS2,WS3,WS4)

              CALL UTIL_SPLINE_INTEGRAL
     &          (XAY,YAR3Y,NOBSVY,RESULTY(3,1),COEFF,WS1,WS2,WS3,WS4)
              CALL UTIL_SPLINE_INTEGRAL
     &          (XAY,YAI3Y,NOBSVY,RESULTY(3,2),COEFF,WS1,WS2,WS3,WS4)


              ampli(1,iphz,iphy,ifrq)=DCMPLX(RESULTY(1,1),RESULTY(1,2))*RLAMBDA1
              ampli(2,iphz,iphy,ifrq)=DCMPLX(RESULTY(2,1),RESULTY(2,2))*RLAMBDA1
              ampli(3,iphz,iphy,ifrq)=DCMPLX(RESULTY(3,1),RESULTY(3,2))*RLAMBDA1

            ENDIF !IPHASE.GT.0

          ENDDO   !NFREQ

        ENDDO  !NPHASEZ
      ENDDO !NPHAZEY

      do iphz=1,mphasez
        zphw(iphz)=-(mphasez-1)*dmashz/2.0+(iphz-1)*dmashz
      enddo
      do iphy=1,mphasey
        yphw(iphy)=-(mphasey-1)*dmashy/2.0+(iphy-1)*dmashy
      enddo

      smax=-1.0d30
      do ifrq=1,nfreq

        YPH=PHLOWY-DMASHY
        DO iphy=(mphasey-nphasey)/2+1,(mphasey-nphasey)/2+NPHASEY

          YPH=YPH+DMASHY
          ZPH=PHLOWZ-DMASHZ

          DO IPHZ=(mphasez-nphasez)/2+1,(mphasez-nphasez)/2+NPHASEZ
            ZPH=ZPH+DMASHZ
            PHSPEC(iphz,iphy)=
     &        DREAL(ampli(1,iphz,iphy,ifrq))*DREAL(ampli(1,iphz,iphy,ifrq))+
     &        DIMAG(ampli(1,iphz,iphy,ifrq))*DIMAG(ampli(1,iphz,iphy,ifrq))+
     &        DREAL(ampli(2,iphz,iphy,ifrq))*DREAL(ampli(2,iphz,iphy,ifrq))+
     &        DIMAG(ampli(2,iphz,iphy,ifrq))*DIMAG(ampli(2,iphz,iphy,ifrq))+
     &        DREAL(ampli(3,iphz,iphy,ifrq))*DREAL(ampli(3,iphz,iphy,ifrq))+
     &        DIMAG(ampli(3,iphz,iphy,ifrq))*DIMAG(ampli(3,iphz,iphy,ifrq))

            if (phspec(iphz,iphy).gt.smax) smax=phspec(iphz,iphy)

          ENDDO   !NPHASEZ

        ENDDO  !NPHAZEY

        if (iphfold.ne.0) then

          do iphy=(mphasey-nphasey)/2+1,(mphasey-nphasey)/2+nphasey
c          do iphy=1,mphasey
            specwz=phspec(1:mphasez,iphy)
            if (dgsigz(1).gt.0.0d0.and.phgsigz.gt.0.0d0) then
              if (iphfold.lt.0) then
                call util_fold_function_gauss_lin(
     &            mphasez,zphw,specwz,phgsigz,dgsigz(1),specfwz,phws1,phws2)
              else
                call util_fold_function_gauss(
     &            mphasez,zphw,specwz,phgsigz,dgsigz(1),specfwz,
     &            phcoef,phws1,phws2,phws3,phws4)
              endif
            else
              specfwz=specwz
            endif
            phspecfy(1:mphasez,iphy)=specfwz
          enddo !iphy

c          do iphz=(mphasez-nphasez)/2+1,(mphasez-nphasez)/2+nphasez
          do iphz=1,mphasez
            specwy=phspecfy(iphz,1:mphasey)
            if (dgsigy(1).gt.0.0d0.and.phgsigy.gt.0.0d0) then
              if (iphfold.lt.0) then
                call util_fold_function_gauss_lin(
     &            mphasey,yphw,specwy,phgsigy,dgsigy(1),specfwy,phws1,phws2)
              else
                call util_fold_function_gauss(
     &            mphasey,yphw,specwy,phgsigy,dgsigy(1),specfwy,phcoef,
     &            phws1,phws2,phws3,phws4)
              endif
            else
              specfwy=specwy
            endif
            phspecf(iphz,1:mphasey)=specfwy
          enddo !iphz

c          phspecf=phspecf*specnor

        endif !iphfold

c        print*,'PHASE, SPECNOR: ',SPECNOR
c        phspec=phspec*specnor
c        smax=smax*specnor

c        YPH=PHLOWY-DMASHY
c        DO iphy=(mphasey-nphasey)/2+1,(mphasey-nphasey)/2+NPHASEY

        sfmax=-1.0d30

        DO iphy=1,mphasey

c          YPH=YPH+DMASHY
c          ZPH=PHLOWZ-DMASHZ

c          DO IPHZ=(mphasez-nphasez)/2+1,(mphasez-nphasez)/2+NPHASEZ
          DO IPHZ=1,mphasez
            zPH=zPH+DMASHz
            TUP(1)=XPH
c            TUP(2)=YPH
c            TUP(3)=ZPH
            TUP(2)=YPHw(iphy)
            TUP(3)=ZPHw(iphz)
            TUP(4)=FREQ(ifrq)
            TUP(5)=ifrq
            TUP(6)=IPHY
            TUP(7)=IPHZ
            TUP(8)=DREAL(ampli(1,iphz,iphy,ifrq))
            TUP(9)=DIMAG(ampli(1,iphz,iphy,ifrq))
            TUP(10)=DREAL(ampli(2,iphz,iphy,ifrq))
            TUP(11)=DIMAG(ampli(2,iphz,iphy,ifrq))
            TUP(12)=DREAL(ampli(3,iphz,iphy,ifrq))
            TUP(13)=DIMAG(ampli(3,iphz,iphy,ifrq))
            TUP(14)=PHSPEC(iphz,iphy)
            TUP(15)=PHSPECf(iphz,iphy)
            if (phspecf(iphz,iphy).gt.sfmax) sfmax=phspecf(iphz,iphy)
            CALL hfm(NIDPHASE,TUP)
          ENDDO   !mPHASEZ
        ENDDO  !MPHASEY

      enddo !nfreq

      if (iphfold.ne.0.and.sfmax.ge.smax) then
        write(lungfo,*)' '
        write(lungfo,*)
     &    '*** Warning in PHASE: Max. of folded intensity higher than unfolded one!'
        write(lungfo,*)'   Be careful with results, they are probably wrong'
        write(lungfo,*)'   Try different parameters of tiny beam current to investigate the problem.'
        write(lungfo,*)'   Max. of raw and folded intensities:'
        write(lungfo,*)'   ',smax,sfmax
        write(lungfo,*)' '
        write(6,*)' '
        write(6,*)
     &    '*** Warning in PHASE: Max. of folded intensity higher than unfolded one!'
        write(6,*)'   Be careful with results, they are probably wrong'
        write(6,*)'   Try different parameters of tiny beam current to investigate the problem.'
        write(6,*)'   Max. of raw and folded intensities:'
        write(6,*)'   ',smax,sfmax
        write(6,*)' '
      endif

      CALL MHROUT(NIDPHASE,ICYCLE,' ')
      CALL hdeletm(NIDPHASE)

      IF (mPHASEZ.GT.1.AND.mPHASEY.GT.1) THEN

        call hbook2m(NIDPHASE-1,'PHASE',
     &    mPHASEZ,
     &    SNGL(PHCENZ-(mphasez-1)*dmashz/2.-PHWID/(NPHASEZ-1)/2.),
     &    SNGL(PHCENZ+(mphasez-1)*dmashz/2.+PHWID/(NPHASEZ-1)/2.),
     &    mPHASEY,
     &    SNGL(PHCENY-(mphasey-1)*dmashy/2.-PHHIG/(NPHASEY-1)/2.),
     &    SNGL(PHCENY+(mphasey-1)*dmashy/2.+PHHIG/(NPHASEY-1)/2.),
     &    0.0)
        CALL MHROUT(NIDPHASE-1,ICYCLE,' ')
        CALL hdeletm(NIDPHASE-1)

        call hbook1m(NIDPHASE-2,'PHASE (HORIZONTAL CUT)',
     &    mPHASEZ,
     &    SNGL(PHCENZ-(mphasez-1)*dmashz/2.-PHWID/(NPHASEZ-1)/2.),
     &    SNGL(PHCENZ+(mphasez-1)*dmashz/2.+PHWID/(NPHASEZ-1)/2.),
     &    0.0)
        CALL MHROUT(NIDPHASE-2,ICYCLE,' ')
        CALL hdeletm(NIDPHASE-2)

        call hbook1m(NIDPHASE-3,'PHASE (VERTICAL CUT)',
     &    mPHASEY,
     &    SNGL(PHCENY-(mphasey-1)*dmashy/2.-PHHIG/(NPHASEY-1)/2.),
     &    SNGL(PHCENY+(mphasey-1)*dmashy/2.+PHHIG/(NPHASEY-1)/2.),
     &    0.0)
        CALL MHROUT(NIDPHASE-3,ICYCLE,' ')
        CALL hdeletm(NIDPHASE-3)

      ELSE IF (NPHASEZ.GT.1) THEN

        call hbook1m(NIDPHASE-2,'PHASE (HORIZONTAL CUT)',
     &    mPHASEZ,
     &    SNGL(PHCENZ-(mphasez-1)*dmashz/2.-PHWID/(NPHASEZ-1)/2.),
     &    SNGL(PHCENZ+(mphasez-1)*dmashz/2.+PHWID/(NPHASEZ-1)/2.),
     &    0.0)
        CALL MHROUT(NIDPHASE-2,ICYCLE,' ')
        CALL hdeletm(NIDPHASE-2)

      ELSE IF (NPHASEY.GT.1) THEN

        call hbook1m(NIDPHASE-3,'PHASE (VERTICAL CUT)',
     &    mPHASEY,
     &    SNGL(PHCENY-(mphasey-1)*dmashy/2.-PHHIG/(NPHASEY-1)/2.),
     &    SNGL(PHCENY+(mphasey-1)*dmashy/2.+PHHIG/(NPHASEY-1)/2.),
     &    0.0)
        CALL MHROUT(NIDPHASE-3,ICYCLE,' ')
        CALL hdeletm(NIDPHASE-3)

      ENDIF !(NPHASEZ.GT.1.AND.NPHASEY.GT.1) THEN

      if (mhbookp.eq.0.and.iroottrees.ge.0) then
        CALL hrendm('PHASE')
        CLOSE(LUNPH)
      endif

      if (mhbookp.eq.0.and.iroottrees.ge.0) then
        CALL hropenm(LUNPH,'PHASE','GEO_'//FILEPH,'N',1024,ISTAT)
        CALL hcdirm(chphase(1:lenchphase),' ')
        IF (ISTAT.NE.0) THEN
          WRITE(6,*)'*** ERROR IN hropenm (SR PHASE) ***'
          WRITE(LUNGFO,*)'*** ERROR IN hropenm (SR PHASE) ***'
          STOP
        ENDIF
        CALL MHROUT(IDCODE,ICYCLE,' ')
      endif

      IF (ABS(IPHASE).GT.1) THEN

C PHASE SPACE FORM GEOMETRICAL OPTIC. ONLY CORRECT IF DIFFRACTION IS
C NEGLIGIBLE (TO BE CHECKED BY TRANSFORMED PHASE)
+self,if=-mhbook.
        CALL hbookm(NIDGEO,'PHASE SPACE DIST. (GEO. OPTIC)'
     &    ,NGEO_P,chphase(1:lenchphase),1024,CHGEO)

        NIDGEO1=NIDGEO+1
        CALL hbookm(NIDGEO1,'SEL. PHASE SPACE DIST. (GEO. OPTIC)'
     &    ,NGEO_P,chphase(1:lenchphase),1024,CHGEO)

        NIDGEO2=NIDGEO+2
        CALL hbookm(NIDGEO2,
     &    'SELECTED PHASE SPACE DIST. AT END OF BEAMLINE'
     &    ,NBEAM_P,chphase(1:lenchphase),1024,CHBEAM)

        CALL hbookm(NIDGEO+3,'SOURCE SIZE (GEO. OPTIC THROUGH APERTURE)'
     &    ,NSIZE_P,chphase(1:lenchphase),1024,CHSIZE)
+self,if=mhbook.
        CALL hbookm(NIDGEO,'PHASE SPACE DIST. (GEO. OPTIC)'
     &    ,NGEO_P,chphase(1:lenchphase),nphelem*nsource*nobsv,CHGEO)

        NIDGEO1=NIDGEO+1
        CALL hbookm(NIDGEO1,'SEL. PHASE SPACE DIST. (GEO. OPTIC)'
     &    ,NGEO_P,chphase(1:lenchphase),nphelem*nsource*nobsv*nfreq,CHGEO)

        NIDGEO2=NIDGEO+2
        CALL hbookm(NIDGEO2,
     &    'SELECTED PHASE SPACE DIST. AT END OF BEAMLINE'
     &    ,NBEAM_P,chphase(1:lenchphase),nphelem*nsource*nobsv*nfreq,CHBEAM)

        CALL hbookm(NIDGEO+3,'SOURCE SIZE (GEO. OPTIC THROUGH APERTURE)'
     &    ,NSIZE_P,chphase(1:lenchphase),nphelem*nsource*nobsv*nfreq,CHSIZE)
+self.
C--- GET FOCUSSING

        DO J=1,4
          DO I=1,4
            TOTMAT(I,J)=0.0D0
            DUMMAT(I,J)=0.0D0
          ENDDO
        ENDDO

        TOTMAT(1,1)=1.0D0
        TOTMAT(2,2)=1.0D0
        TOTMAT(3,3)=1.0D0
        TOTMAT(4,4)=1.0D0

        DO IELEM=1,NPHELEM
          DO J=1,4
            DO I=1,4
              DO K=1,4
                DUMMAT(I,J)=DUMMAT(I,J)+TOTMAT(I,K)*PHELEM(K,J,IELEM)
              ENDDO
            ENDDO
          ENDDO
          DO J=1,4
            DO I=1,4
              TOTMAT(I,J)=DUMMAT(I,J)
              DUMMAT(I,J)=0.0D0
            ENDDO
          ENDDO
        ENDDO   !IELEM

        ZBEAM=EPSBEAM
        TANPHIB=0.0
        YBEAM=EPSBEAM
        TANTHEB=0.0

        DO IELEM=1,NPHELEM

          BEAM(1)=ZBEAM
          BEAM(2)=TANPHIB
          BEAM(3)=YBEAM
          BEAM(4)=TANTHEB

          DO J=1,4
            DO I=1,4
              OPTMAT(I,J)=PHELEM(I,J,IELEM)
            ENDDO
          ENDDO

          IF (OPTMAT(2,1).GT.0.0) THEN
            WRITE(6,*)'*** WARNING IN PHASE: PHELEM(2,1,N).GT.0'
            WRITE(6,*)'PHELEM(2,1,N) IS -1/fx !'
            WRITE(6,*)'CHECK ELEMENT ',IELEM
            WRITE(LUNGFO,*)'*** WARNING IN PHASE: PHELEM(2,1,N).GT.0'
            WRITE(LUNGFO,*)'PHELEM(2,1,N) IS -1/fx !'
            WRITE(LUNGFO,*)'CHECK ELEMENT ',IELEM
          ENDIF

          IF (OPTMAT(4,3).GT.0.0) THEN
            WRITE(6,*)'*** WARNING IN PHASE: PHELEM(4,3,N).GT.0'
            WRITE(6,*)'PHELEM(4,3,N) IS -1/fx !'
            WRITE(6,*)'CHECK ELEMENT ',IELEM
            WRITE(LUNGFO,*)'*** WARNING IN PHASE: PHELEM(2,1,N).GT.0'
            WRITE(LUNGFO,*)'PHELEM(4,3,N) IS -1/fy !'
            WRITE(LUNGFO,*)'CHECK ELEMENT ',IELEM
          ENDIF

          ZBEAM=
     &      OPTMAT(1,1)*BEAM(1)
     &      +OPTMAT(1,2)*BEAM(2)
     &      +OPTMAT(1,3)*BEAM(3)
     &      +OPTMAT(1,4)*BEAM(4)

          TANPHIB=
     &      OPTMAT(2,1)*BEAM(1)
     &      +OPTMAT(2,2)*BEAM(2)
     &      +OPTMAT(2,3)*BEAM(3)
     &      +OPTMAT(2,4)*BEAM(4)

          YBEAM=
     &      OPTMAT(3,1)*BEAM(1)
     &      +OPTMAT(3,2)*BEAM(2)
     &      +OPTMAT(3,3)*BEAM(3)
     &      +OPTMAT(3,4)*BEAM(4)

          TANTHEB=
     &      OPTMAT(4,1)*BEAM(1)
     &      +OPTMAT(4,2)*BEAM(2)
     &      +OPTMAT(4,3)*BEAM(3)
     &      +OPTMAT(4,4)*BEAM(4)

        ENDDO   !NELEM

        IF (ZBEAM*YBEAM.NE.0.D0) THEN
          FOCUS=(EPSBEAM*EPSBEAM)/DABS(ZBEAM*YBEAM)
        ELSE
          WRITE(6,*)
     &      '*** ERROR IN PHASE: IMAGE IS IN FOCAL PLANE, CHECK INPUT ***'
          WRITE(LUNGFO,*)
     &      '*** ERROR IN PHASE: IMAGE IS IN FOCAL PLANE, CHECK INPUT ***'
          STOP
        ENDIF

        DO IOBS=1,NOBSV

          XOBS=OBSV(1,IOBS)
          YOBS=OBSV(2,IOBS)
          ZOBS=OBSV(3,IOBS)

          DO ISOUR=1,NSOURCE

            XSOUR=SOURCEN(1,1,ISOUR)
            IF (XOBS.LE.XSOUR) THEN
              WRITE(LUNGFO,*)'*** ERROR IN PHASE: Bad PINCEN(1)   ***'
              WRITE(LUNGFO,*)'CHECK INPUT FILE'
              WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
              WRITE(6,*)'*** ERROR IN PHASE: Bad PINCEN(1)  ***'
              WRITE(6,*)'CHECK INPUT FILE'
              WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
              STOP
            ENDIF

            YSOUR=SOURCEN(2,1,ISOUR)
            ZSOUR=SOURCEN(3,1,ISOUR)

            DX=(XSOUR-XOBS)
            DY=(YSOUR-YOBS)
            DZ=(ZSOUR-ZOBS)

            TANPHI=DZ/DX
            TANTHE=DY/DX

            PHI=ATAN2(DZ,DX)
            THETA=ATAN2(DY,DX)

            XPH=PHCENX
            DXPH=(XPH-XOBS)
            YPH=YOBS+TANTHE*DXPH
            ZPH=ZOBS+TANPHI*DXPH

            DR2PH=(XSOUR-XPH)**2+(YSOUR-YPH)**2+(ZSOUR-ZPH)**2
            DR2SOUR=DX**2+DY**2+DZ**2

            DO ifrq=1,NFREQ

              TGEO(1)=XPH
              TGEO(2)=YPH
              TGEO(3)=ZPH
              TGEO(4)=-TANTHE
              TGEO(5)=-TANPHI
              TGEO(6)=FREQ(ifrq)
              TGEO(7)=ifrq
              TGEO(8)=ISOUR
              TGEO(9)=XSOUR
              TGEO(10)=YSOUR
              TGEO(11)=ZSOUR
              ILIOBFR=ISOUR+NSOURCE*(IOBS-1+NOBSV*(ifrq-1))
              TGEO(12)=SPEC(ILIOBFR)
     &          *DR2SOUR/DR2PH
              TGEO(13)=XOBS
              TGEO(14)=YOBS
              TGEO(15)=ZOBS
              TGEO(16)=SPEC(ILIOBFR)
              CALL hfm(NIDGEO,TGEO)

              PHGEOSUM(ifrq)=PHGEOSUM(ifrq)+SPEC(ILIOBFR)*DA
            ENDDO !ifrq=1,NFREQ

            IF (
     &          TANTHE.LE.PHAPERYPP
     &          .AND.
     &          TANTHE.GE.PHAPERYPM
     &          .AND.
     &          TANPHI.LE.PHAPERZPP
     &          .AND.
     &          TANPHI.GE.PHAPERZPM
     &          .AND.
     &          YPH.LE.PHAPERYP
     &          .AND.
     &          YPH.GE.PHAPERYM
     &          .AND.
     &          ZPH.LE.PHAPERZP
     &          .AND.
     &          ZPH.GE.PHAPERZM
     &          ) THEN

              DO ifrq=1,NFREQ

                TGEO(1)=XPH
                TGEO(2)=YPH
                TGEO(3)=ZPH
                TGEO(4)=-TANTHE
                TGEO(5)=-TANPHI
                TGEO(6)=FREQ(ifrq)
                TGEO(7)=ifrq
                TGEO(8)=ISOUR
                TGEO(9)=XSOUR
                TGEO(10)=YSOUR
                TGEO(11)=ZSOUR
                ILIOBFR=ISOUR+NSOURCE*(IOBS-1+NOBSV*(ifrq-1))
                TGEO(12)=SPEC(ILIOBFR)
     &            *DR2SOUR/DR2PH
                TGEO(13)=XOBS
                TGEO(14)=YOBS
                TGEO(15)=ZOBS
                TGEO(16)=SPEC(ILIOBFR)
                CALL hfm(NIDGEO1,TGEO)

                PHGEOSEL(ifrq)=PHGEOSEL(ifrq)+SPEC(ILIOBFR)*DA
                ILIFR=ISOUR+NSOURCE*(ifrq-1)
                W=SPEC(ILIOBFR)
                PHMEANZ(ILIFR)=PHMEANZ(ILIFR)
     &            +ZPH*W
                PHSIGZ(ILIFR)=PHSIGZ(ILIFR)
     &            +ZPH*ZPH*W
                PHMEANY(ILIFR)=PHMEANY(ILIFR)
     &            +YPH*W
                PHSIGY(ILIFR)=PHSIGY(ILIFR)
     &            +YPH*YPH*W
                WSUM(ILIFR)=WSUM(ILIFR)+W

              ENDDO   !ifrq


C--- APPLY MATRICES OF BEAMLINE

              XBEAM=XPH
              YBEAM=YPH
              ZBEAM=ZPH
              TANTHEB=-TANTHE
              TANPHIB=-TANPHI

              DO J=1,4
                DO I=1,4
                  OPTMAT(I,J)=0.
                ENDDO
              ENDDO

              DO IELEM=1,NPHELEM

                BEAM(1)=ZBEAM
                BEAM(2)=TANPHIB
                BEAM(3)=YBEAM
         BEAM(4)=TANTHEB
                DO J=1,4
                  DO I=1,4
                    OPTMAT(I,J)=PHELEM(I,J,IELEM)
                  ENDDO
                ENDDO

                IF (
     &              BEAM(1).LT.PHELEM(5,1,IELEM)
     &              .OR.
     &              BEAM(1).GT.PHELEM(5,2,IELEM)
     &              .OR.
     &              BEAM(2).LT.PHELEM(5,3,IELEM)
     &              .OR.
     &              BEAM(2).GT.PHELEM(5,4,IELEM)
     &              ) THEN
                  GOTO 90   !OUT OF APERTURE, SKIP BEAM
                ELSE    !APERTURE CUT

                  ZBEAM=
     &              OPTMAT(1,1)*BEAM(1)
     &              +OPTMAT(1,2)*BEAM(2)
     &              +OPTMAT(1,3)*BEAM(3)
     &              +OPTMAT(1,4)*BEAM(4)

                  TANPHIB=
     &              OPTMAT(2,1)*BEAM(1)
     &              +OPTMAT(2,2)*BEAM(2)
     &              +OPTMAT(2,3)*BEAM(3)
     &              +OPTMAT(2,4)*BEAM(4)

                  YBEAM=
     &              OPTMAT(3,1)*BEAM(1)
     &              +OPTMAT(3,2)*BEAM(2)
     &              +OPTMAT(3,3)*BEAM(3)
     &              +OPTMAT(3,4)*BEAM(4)

                  TANTHEB=
     &              OPTMAT(4,1)*BEAM(1)
     &              +OPTMAT(4,2)*BEAM(2)
     &              +OPTMAT(4,3)*BEAM(3)
     &              +OPTMAT(4,4)*BEAM(4)

                  XBEAM=XBEAM+PHELEM(1,2,IELEM)

                ENDIF   !APERTURE CUT

              ENDDO   !NELEM

              DO ifrq=1,NFREQ

                TBEAM(1)=XBEAM
                TBEAM(2)=YBEAM
                TBEAM(3)=ZBEAM
                TBEAM(4)=TANTHEB
                TBEAM(5)=TANPHIB
                TBEAM(6)=FREQ(ifrq)
                TBEAM(7)=ifrq
                TBEAM(8)=ISOUR
                TBEAM(9)=XSOUR
                TBEAM(10)=YSOUR
                TBEAM(11)=ZSOUR
                ILIOBFR=ISOUR+NSOURCE*(IOBS-1+NOBSV*(ifrq-1))
                TBEAM(12)=SPEC(ILIOBFR)*DR2SOUR/DR2PH*FOCUS
                TBEAM(13)=XOBS
                TBEAM(14)=YOBS
                TBEAM(15)=ZOBS
                TBEAM(16)=SPEC(ILIOBFR)
                CALL hfm(NIDGEO2,TBEAM)
                PHBEAM(ifrq)=PHBEAM(ifrq)+SPEC(ILIOBFR)*DA
              ENDDO   !ifrq

90          CONTINUE

          ENDIF   !CUTS

        ENDDO  !ISOUR=1,NSOURCE

      ENDDO !IOBS=1,NOBSV

      CALL MHROUT(NIDGEO,ICYCLE,' ')
      CALL hdeletm(NIDGEO)
      CALL MHROUT(NIDGEO1,ICYCLE,' ')
      CALL hdeletm(NIDGEO1)
      CALL MHROUT(NIDGEO2,ICYCLE,' ')
      CALL hdeletm(NIDGEO2)

      DO ifrq=1,NFREQ
        DO ISOUR=1,NSOURCE
            ILIFR=ISOUR+NSOURCE*(ifrq-1)
            IF (WSUM(ILIFR).NE.0.D0) THEN
              W=1.D0/WSUM(ILIFR)
              PHMEANZ(ILIFR)=PHMEANZ(ILIFR)*W
              PHMEANY(ILIFR)=PHMEANY(ILIFR)*W
              PHSIGZ(ILIFR)=DSQRT(DABS(
     &          PHSIGZ(ILIFR)*W
     &          -PHMEANZ(ILIFR)*PHMEANZ(ILIFR)))
              PHSIGY(ILIFR)=DSQRT(DABS(
     &          PHSIGY(ILIFR)*W
     &          -PHMEANY(ILIFR)*PHMEANY(ILIFR)))
            ENDIF   !(WSUM(ILIFR))
          ENDDO
        ENDDO

      ENDIF !ABS(IPHASE.GT.1)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'      SR PHASE:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'      PHCENX, PHCENY, PHCENZ:'
      WRITE(LUNGFO,*)'      ', PHCENX, PHCENY, PHCENZ
      WRITE(LUNGFO,*)'       PHWID, PHHIG:'
      WRITE(LUNGFO,*)'      ', PHWID, PHHIG
      WRITE(LUNGFO,*)'      NPHASEZ, NPHASEY:', NPHASEZ, NPHASEY
      WRITE(LUNGFO,*)'      MPHASEZ, MPHASEY:', MPHASEZ, MPHASEY
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'      PHAPERZM,  PHAPERZP: ',PHAPERZM, PHAPERZP
      WRITE(LUNGFO,*)'      PHAPERYM,  PHAPERYP: ',PHAPERYM, PHAPERYP
      WRITE(LUNGFO,*)'      PHAPERZPM, PHAPERZPP:',PHAPERZPM, PHAPERZPP
      WRITE(LUNGFO,*)'      PHAPERYPM, PHAPERYPP:',PHAPERYPM, PHAPERYPP
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'      IPHFOLD:         ',iphfold
      WRITE(LUNGFO,*)'      PHBETH, PHBETV:  ',PHBETH,PHBETV
      WRITE(LUNGFO,*)'      PHGSIGZ, PHGSIGY:',PHGSIGZ,PHGSIGY
      WRITE(LUNGFO,*)

      IF (ABS(IPHASE).GT.1) THEN

        WRITE(LUNGFO,*)'      NPHELEM: ',NPHELEM
        DO IELEM=1,NPHELEM
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'      ',(SNGL(PHELEM(1,I,IELEM)),I=1,4)
          WRITE(LUNGFO,*)'      ',(SNGL(PHELEM(2,I,IELEM)),I=1,4)
          WRITE(LUNGFO,*)'      ',(SNGL(PHELEM(3,I,IELEM)),I=1,4)
          WRITE(LUNGFO,*)'      ',(SNGL(PHELEM(4,I,IELEM)),I=1,4)
          WRITE(LUNGFO,*)'      ',(SNGL(PHELEM(5,I,IELEM)),I=1,4)
        ENDDO  !NPHELEM

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'      focus factor:',SNGL(FOCUS)
        WRITE(LUNGFO,*)

        WRITE(LUNGFO,*)'      resulting matrix:'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'      ',(SNGL(TOTMAT(1,I)),I=1,4)
        WRITE(LUNGFO,*)'      ',(SNGL(TOTMAT(2,I)),I=1,4)
        WRITE(LUNGFO,*)'      ',(SNGL(TOTMAT(3,I)),I=1,4)
        WRITE(LUNGFO,*)'      ',(SNGL(TOTMAT(4,I)),I=1,4)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '         photon energy, total intensity, selected intensity, ratio'
        WRITE(LUNGFO,*)
     &    '         (values refere to observation plane):'
        WRITE(LUNGFO,*)
        DO ifrq=1,NFREQ

          IF (PHGEOSUM(ifrq).NE.0.D0) THEN
            SELGEO=PHGEOSEL(ifrq)/PHGEOSUM(ifrq)
          ELSE
            SELGEO=0.
          ENDIF
          WRITE(LUNGFO,*)'      ',SNGL(FREQ(ifrq))
     &      ,SNGL(PHGEOSUM(ifrq))
     &      ,SNGL(PHGEOSEL(ifrq))
     &      ,SELGEO
        ENDDO


        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '         photon energy, selected intensity, beamline intensity, ratio'
        WRITE(LUNGFO,*)
     &    '         (values refere to image plane):'
        WRITE(LUNGFO,*)
        DO ifrq=1,NFREQ

          IF (PHGEOSEL(ifrq).NE.0.D0) THEN
            SELGEO=PHBEAM(ifrq)/PHGEOSEL(ifrq)
          ELSE
            SELGEO=0.
          ENDIF
          WRITE(LUNGFO,*)'      ',SNGL(FREQ(ifrq))
     &      ,SNGL(PHGEOSEL(ifrq))
     &      ,SNGL(PHBEAM(ifrq))
     &      ,SELGEO
        ENDDO
        WRITE(LUNGFO,*)

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'      Effective source size in phase plane:'
        WRITE(LUNGFO,*)'      ifrq     ISOURCE     Zrms     Yrms'
        WRITE(LUNGFO,*)
        DO ifrq=1,NFREQ
          DO ISOUR=1,NSOURCE
            ILIFR=ISOUR+NSOURCE*(ifrq-1)
            WRITE(LUNGFO,*)'      ',ifrq,ISOUR
     &        ,SNGL(PHSIGZ(ILIFR))
     &        ,SNGL(PHSIGY(ILIFR))
            TSIZ(1)=ifrq
            TSIZ(2)=ISOUR
            TSIZ(3)=PHSIGZ(ILIFR)
            TSIZ(4)=PHSIGY(ILIFR)
            CALL hfm(NIDGEO+3,TSIZ)
          ENDDO
        ENDDO
        CALL MHROUT(NIDGEO+3,ICYCLE,' ')
        CALL hdeletm(NIDGEO+3)

      ENDIF !ABS(IPHASE.GT.1)

      WRITE(LUNGFO,*)

      IF (IHSEL.NE.0) THEN

        IF (ifreq2p.EQ.2) THEN

          FLOW=DLOG10(FREQ(1)/1.5)
          FHIG=DLOG10(FREQ(NFREQ)*1.5)

          call hbook1m(IDSEL,'INTEGRATED PHASESPACE (GEOM. OPTIC)',
     &      NFREQ,FLOW,FHIG,0.)
          call hbook1m(IDSEL+1,
     &      'INTEGRATED ACCEPTED PHASESPACE (GEOM. OPTIC)',
     &      NFREQ,FLOW,FHIG,0.)
          call hbook1m(IDSEL+2,
     &      'RATIO OF INTEGRATED AND ACCEPTED PHASESPACE',
     &      NFREQ,FLOW,FHIG,0.)
          call hbook1m(IDSEL+10,
     &      'INTEGRATED ACCEPTED PHASESPACE AT END OF BEAMLINE',
     &      NFREQ,FLOW,FHIG,0.)
          call hbook1m(IDSEL+11,
     &      'RATIO OF INTEGRATED AND PHASESPACE AFTER BEAMLINE',
     &      NFREQ,FLOW,FHIG,0.)

          DO ifrq=1,NFREQ
            IF (PHGEOSUM(ifrq).GT.0.D0)
     &        CALL hfillm
     &        (IDSEL,SNGL(FREQ(ifrq)),0.,DLOG10(PHGEOSUM(ifrq)))
            IF (PHGEOSEL(ifrq).GT.0.D0)
     &        CALL hfillm
     &        (IDSEL+1,SNGL(FREQ(ifrq)),0.,DLOG10(PHGEOSEL(ifrq)))
            IF (PHBEAM(ifrq).GT.0.D0)
     &        CALL hfillm
     &        (IDSEL+10,SNGL(FREQ(ifrq)),0.,DLOG10(PHBEAM(ifrq)))
          ENDDO

        ELSE

          DF=FREQ(2)-FREQ(1)
          IF (DF.EQ.0.) DF=1.

          FLOW=FREQ(1)-DF/2.
          FHIG=FREQ(NFREQ)+DF/2.

          call hbook1m(IDSEL,'INTEGRATED PHASESPACE (GEOM. OPTIC)',
     &      NFREQ,FLOW,FHIG,0.)
          call hbook1m(IDSEL+1,
     &      'INTEGRATED ACCEPTED PHASESPACE (GEOM. OPTIC)',
     &      NFREQ,FLOW,FHIG,0.)
          call hbook1m(IDSEL+2,
     &      'RATIO OF INTEGRATED AND ACCEPTED PHASESPACE',
     &      NFREQ,FLOW,FHIG,0.)
          call hbook1m(IDSEL+10,
     &      'INTEGRATED ACCEPTED PHASESPACE AT END OF BEAMLINE',
     &      NFREQ,FLOW,FHIG,0.)
          call hbook1m(IDSEL+11,
     &      'RATIO OF INTEGRATED AND PHASESPACE AFTER BEAMLINE',
     &      NFREQ,FLOW,FHIG,0.)

          DO ifrq=1,NFREQ
            CALL hfillm
     &        (IDSEL,SNGL(FREQ(ifrq)),0.,PHGEOSUM(ifrq))
            CALL hfillm
     &        (IDSEL+1,SNGL(FREQ(ifrq)),0.,PHGEOSEL(ifrq))
            CALL hfillm
     &        (IDSEL+10,SNGL(FREQ(ifrq)),0.,PHBEAM(ifrq))
          ENDDO

        ENDIF  !ifreq2p

        CALL hoperam(IDSEL+1,'/',IDSEL,IDSEL+2,1.,1.)
        CALL hoperam(IDSEL+10,'/',IDSEL,IDSEL+11,1.,1.)

        CALL MHROUT(IDSEL,ICYCLE,' ')
        CALL MHROUT(IDSEL+1,ICYCLE,' ')
        CALL MHROUT(IDSEL+2,ICYCLE,' ')
        CALL MHROUT(IDSEL+10,ICYCLE,' ')
        CALL MHROUT(IDSEL+11,ICYCLE,' ')
        CALL hdeletm(IDSEL)
        CALL hdeletm(IDSEL+1)
        CALL hdeletm(IDSEL+2)
        CALL hdeletm(IDSEL+10)
        CALL hdeletm(IDSEL+11)

      ENDIF !IHSEL.NE.0

      if (mhbookp.eq.0.and.iroottrees.ge.0) then
        CALL hrendm('PHASE')
        CLOSE(LUNPH)
        CALL hcdirm(OLDDIR,' ')
      endif

      DEALLOCATE(WSUM)
      DEALLOCATE(PHMEANZ)
      DEALLOCATE(PHMEANY)
      DEALLOCATE(PHSIGZ)
      DEALLOCATE(PHSIGY)
      DEALLOCATE(PHSHIFT)
      DEALLOCATE(AMPLI)
      DEALLOCATE(phspec)
      DEALLOCATE(phspecf,phspecfy)
      deALLOCATE(specwz)
      deALLOCATE(specfwz)
      deALLOCATE(yphw)
      deALLOCATE(specwy)
      deALLOCATE(specfwy)
      DEALLOCATE(EXPOM)
      DEALLOCATE(DEXPOM)
      DEALLOCATE(phws1)
      DEALLOCATE(phws2)
      DEALLOCATE(phws3)
      DEALLOCATE(phws4)
      DEALLOCATE(phcoef)

      RETURN
      END
+DECK,PHASEANA.
*CMZ :  3.00/00 11/03/2013  15.13.36  by  Michael Scheer
*CMZ :  2.16/08 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.15/00 10/05/2000  16.54.10  by  Michael Scheer
*CMZ :  2.13/04 21/01/2000  14.59.11  by  Michael Scheer
*CMZ :  2.13/03 18/01/2000  17.55.50  by  Michael Scheer
*CMZ :  1.03/06 25/09/98  11.35.13  by  Michael Scheer
*-- Author :    Michael Scheer   18/09/98

      SUBROUTINE PHASEANA
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SELF.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,reargf90.
+SEQ,PHYCON.
+seq,sourcef90.
+SEQ,SPECT.
+SEQ,FREQS.
+SEq,observf90.
+SEq,phasef90.

+SELF,IF=-NEWWAVE.
      INTEGER I,J
+SELF,IF=NEWWAVE.
      INTEGER I
+SELF.

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'*** PHASEANA CALLED!! ***'
      WRITE(LUNGFO,*)'ARRAY REAIMA OVERWRITTEN!!'
      WRITE(LUNGFO,*)

      WRITE(6,*)
      WRITE(6,*)'*** PHASEANA CALLED!! ***'
      WRITE(6,*)'ARRAY REAIMA OVERWRITTEN!!'
      WRITE(6,*)

+SELF,IF=-NEWWAVE.
      DO J=1,NDFREQP
      DO I=1,NDOBSV
          REANULL(1,1,I,J)=0.D0
          REANULL(2,1,I,J)=0.D0
          REANULL(3,1,I,J)=0.D0
          REANULL(1,2,I,J)=0.D0
          REANULL(2,2,I,J)=0.D0
          REANULL(3,2,I,J)=0.D0
      ENDDO
      ENDDO
+SELF,IF=NEWWAVE,IF=-F90.
      DO I=1,NOBFRP
+SELF,IF=NEWWAVE,IF=F90.
      DO I=1,NOBSV*NFREQ
+SELF.
          REAIMA(1,1,I)=0.D0
          REAIMA(2,1,I)=0.D0
          REAIMA(3,1,I)=0.D0
          REAIMA(1,2,I)=0.D0
          REAIMA(2,2,I)=0.D0
          REAIMA(3,2,I)=0.D0
      ENDDO
+SELF,IF=-NEWWAVE.
      REAIMA(2,1,NOBSV/2+1,1)=1.D0
+SELF,IF=NEWWAVE.
      REAIMA(2,1,NOBSV/2+1)=1.D0
+SELF.

      RETURN
      END
+DECK,PHASE_BAHRDT.
*CMZ :  4.00/15 14/03/2022  09.02.26  by  Michael Scheer
*CMZ :  3.02/00 28/08/2014  08.52.10  by  Michael Scheer
*CMZ :  3.01/02 24/02/2014  16.33.26  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.66/17 23/11/2010  09.49.12  by  Michael Scheer
*CMZ :  2.63/05 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.16/08 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.16/07 08/09/2000  17.05.43  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.35  by  Michael Scheer
*CMZ :  2.13/03 12/01/2000  11.08.59  by  Michael Scheer
*CMZ :  2.10/01 03/03/99  17.22.37  by  Michael Scheer
*-- Author :    Michael Scheer   24/02/99

      SUBROUTINE PHASE_BAHRDT
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,OBSERVF90U.
+SELF.

      IMPLICIT NONE

+seq,strings.

      INTEGER I,J,K,IFREQ,ifirst,ilast
      DOUBLE PRECISION X,Y,Z,W
      character(64) file,cfreq

+SEQ,CMPARA.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,FREQS.

      DO IFREQ=1,NFREQ

        write(cfreq,*)ifreq
c        ifirst=icfnbl(cfreq,1,len(cfreq))
c        ilast=len_trim(cfreq)
        cfreq=adjustl(cfreq)
        ifirst=1
        ilast=len_trim(cfreq)

        file='eyre-'//cfreq(ifirst:ilast)//'.dat'
        open(unit=99,FILE=file,status='new')

        write(99,*)nobsvz,nobsvy

        do i=1,nobsvy
          do j=1,nobsvz
            k=j+(i-1)*nobsvz
            x=obsv(3,k)
            y=obsv(2,k)
+SELF,IF=-NEWWAVE.
            z=reaima(2,1,k,ifreq)
+SELF,IF=NEWWAVE.
            iobfr=k+nobsv*(ifreq-1)
            z=reaima(2,1,iobfr)
+SELF.
            write(99,*)x*1000.0d0,y*1000.0d0,z
          enddo
        enddo
        close(99)

        file='eyim-'//cfreq(ifirst:ilast)//'.dat'
        open(unit=99,FILE=file,status='new')

        write(99,*)nobsvz,nobsvy
        do i=1,nobsvy
          do j=1,nobsvz
            k=j+(i-1)*nobsvz
            x=obsv(3,k)
            y=obsv(2,k)
+SELF,IF=-NEWWAVE.
            w=reaima(2,2,k,ifreq)
+SELF,IF=NEWWAVE.
            iobfr=k+nobsv*(ifreq-1)
            w=reaima(2,2,iobfr)
+SELF.
            write(99,*)x*1000.0d0,y*1000.0d0,w
          enddo
        enddo
        close(99)

        file='ey2-'//cfreq(ifirst:ilast)//'.dat'
        open(unit=99,FILE=file,status='new')
        write(99,*)nobsvz,nobsvy
        do i=1,nobsvy
          do j=1,nobsvz
            k=j+(i-1)*nobsvz
+SELF,IF=-NEWWAVE.
            write(99,*)obsv(3,k),obsv(2,k),
     &        reaima(2,1,k,ifreq)**2+reaima(2,2,k,ifreq)**2
+SELF,IF=NEWWAVE.
            iobfr=k+nobsv*(ifreq-1)
            write(99,*)obsv(3,k),obsv(2,k),
     &        reaima(2,1,iobfr)**2+reaima(2,2,iobfr)**2
+SELF.
          enddo
        enddo
        close(99)

        file='ezre-'//cfreq(ifirst:ilast)//'.dat'
        open(unit=99,FILE=file,status='new')
        write(99,*)nobsvz,nobsvy
        do i=1,nobsvy
          do j=1,nobsvz
            k=j+(i-1)*nobsvz
            x=obsv(3,k)
            y=obsv(2,k)
+SELF,IF=-NEWWAVE.
            z=reaima(3,1,k,ifreq)
+SELF,IF=NEWWAVE.
            iobfr=k+nobsv*(ifreq-1)
            z=reaima(3,1,iobfr)
+SELF.
            write(99,*)x*1000.0d0,y*1000.0d0,z
          enddo
        enddo
        close(99)

        file='ezim-'//cfreq(ifirst:ilast)//'.dat'
        open(unit=99,FILE=file,status='new')
        write(99,*)nobsvz,nobsvy
        do i=1,nobsvy
          do j=1,nobsvz
            k=j+(i-1)*nobsvz
            x=obsv(3,k)
            y=obsv(2,k)
+SELF,IF=-NEWWAVE.
            w=reaima(3,2,k,ifreq)
+SELF,IF=NEWWAVE.
            iobfr=k+nobsv*(ifreq-1)
            w=reaima(3,2,iobfr)
+SELF.
            write(99,*)x*1000.0d0,y*1000.0d0,w
          enddo
        enddo
        close(99)

      ENDDO

      RETURN
      END
+DECK,pincenin.
*CMZ :  3.02/00 28/08/2014  08.42.42  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.69/00 26/10/2012  11.36.41  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  11.44.11  by  Michael Scheer
*CMZ :  2.62/03 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.62/02 16/07/2007  07.15.46  by  Michael Scheer
*CMZ :  2.34/09 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  14.22.45  by  Michael Scheer
*CMZ :  1.04/03 11/12/98  16.34.58  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  14.47.16  by  Michael Scheer
*CMZ : 00.02/04 24/02/97  12.37.49  by  Michael Scheer
*CMZ : 00.02/00 19/11/96  14.57.13  by  Michael Scheer
*CMZ : 00.01/08 22/06/95  17.29.50  by  Michael Scheer
*CMZ : 00.01/06 01/02/95  16.35.43  by  Michael Scheer
*CMZ : 00.01/04 29/11/94  10.17.51  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  17.07.25  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.52.56  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.26  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE PINCENIN
+seq,gplhint.

+SELF,IF=F90.
+SEQ,OBSERVF90U.
+SEQ,trackF90U.
+SELF.

C--- INITIALIZE PINCEN

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,CMPARA.
+SEq,observf90.
+seq,trackf90.

      integer i

      IF (IPINCIRC.NE.0.OR.IF1DIM.EQ.2) THEN

        PINW=2.D0*PINR
        PINH=2.D0*PINR

      ENDIF !IPINCIRC

      IF (PINCEN(2).EQ.9999.) THEN
        IF     (IPBRILL.EQ.0) THEN
          PINCEN(2)=0.0
        ELSE IF (IPBRILL.EQ.1) THEN
          PINCEN(2)=PINH/2.D0
        ELSE IF (IPBRILL.EQ.2) THEN
          PINCEN(2)=PINH/2.D0
        ELSE IF (IPBRILL.EQ.3) THEN
          PINCEN(2)=-PINH/2.D0
        ELSE IF (IPBRILL.EQ.4) THEN
          PINCEN(2)=-PINH/2.D0
        ENDIF
      ELSE IF (PINCEN(2).EQ.-9999.) THEN
        PINCEN(2)=YSTART+VYIN/VXIN*(PINCEN(1)-XSTART)
      ELSE IF (PINCEN(2).EQ.-8888.) THEN
        PINCEN(2)=yoffstr+yslopetr*PINCEN(1)
       else IF (PINCEN(2).EQ.-9000.) THEN
         pincen(2)=0.0d0
         do i=1,nco
           PINCEN(2)=pincen(2)+
     &       wtra(2,1,i)+wtra(2,2,i)/wtra(1,2,i)*(PINCEN(1)-wtra(1,1,i))
         enddo
         pincen(2)=pincen(2)/nco
      ENDIF

      IF (PINCEN(3).EQ.9999.) THEN
        IF     (IPBRILL.EQ.0) THEN
          PINCEN(3)=0.0
        ELSE IF (IPBRILL.EQ.1) THEN
          PINCEN(3)=PINW/2.D0
        ELSE IF (IPBRILL.EQ.2) THEN
          PINCEN(3)=-PINW/2.D0
        ELSE IF (IPBRILL.EQ.3) THEN
          PINCEN(3)=-PINW/2.D0
        ELSE IF (IPBRILL.EQ.4) THEN
          PINCEN(3)=PINW/2.D0
        ENDIF
      ELSE IF (PINCEN(3).EQ.-9999.) THEN
        PINCEN(3)=ZSTART+VZIN/VXIN*(PINCEN(1)-XSTART)
      ELSE IF (PINCEN(3).EQ.-8888.) THEN
        PINCEN(3)=zoffstr+zslopetr*PINCEN(1)
      else IF (PINCEN(3).EQ.-9000.) THEN
        pincen(3)=0.0d0
        do i=1,nco
          PINCEN(3)=pincen(3)+
     &      wtra(3,1,i)+wtra(3,2,i)/wtra(1,2,i)*(PINCEN(1)-wtra(1,1,i))
        enddo
        pincen(3)=pincen(3)/nco
      ENDIF

      RETURN
      END
+DECK,POWER.
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  12.39.05  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  16.46.29  by  Michael Scheer
*CMZ :  2.51/00 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.46/02 07/03/2003  10.27.39  by  Michael Scheer
*CMZ :  2.16/08 01/11/2000  18.19.09  by  Michael Scheer
*CMZ :  2.13/07 17/02/2000  15.11.12  by  Michael Scheer
*CMZ :  2.13/03 11/01/2000  18.01.43  by  Michael Scheer
*CMZ :  2.12/03 07/07/99  12.30.49  by  Michael Scheer
*CMZ :  2.10/01 25/02/99  16.08.38  by  Michael Scheer
*-- Author :    Michael Scheer   25/02/99

      SUBROUTINE POWER(ISOUR)
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.

        IMPLICIT NONE

        INTEGER ISOUR,ICAL,IOBSV,IOBSVZ

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,sourcef90.
+SEQ,SPECT.
+SEq,observf90.
+seq,phycon.

        DATA ICAL/0/

        IF (ICAL.EQ.0) THEN

          DO IOBSV=1,NOBSV
            SPECPOWT(IOBSV)=0.D0
          ENDDO

          DO IOBSVZ=1,NOBSVZ
            SPECPOWVT(IOBSVZ)=0.D0
          ENDDO

          SPECPOWVHT=0.D0

          ICAL=1

        ENDIF  !ICAL

        IF (IPIN.NE.0.AND.IPIN.NE.2.and.ipin.ne.3) THEN

          DO IOBSVZ=1,NOBSVZ
            CALL BLENDEPOWV(ISOUR,IOBSVZ)
          ENDDO

          CALL BLENDEPOWVH(ISOUR)

          DO IOBSV=1,NOBSV
            SPECPOWT(IOBSV)=
     &        SPECPOWT(IOBSV)+SPECPOW(ISOUR+NSOURCE*(IOBSV-1))
          ENDDO

          DO IOBSVZ=1,NOBSVZ
            ILIOBZ=ISOUR+NSOURCE*(IOBSVZ-1)
            SPECPOWVT(IOBSVZ)=SPECPOWVT(IOBSVZ)+SPECPOWV(ILIOBZ)
          ENDDO

          SPECPOWVHT=SPECPOWVHT+SPECPOWVH(ISOUR)

        ELSE   !IPIN

          DO IOBSV=1,NOBSV

            SPECPOWT(IOBSV)=SPECPOWT(IOBSV)+
     &        SPECPOW(ISOUR+NSOURCE*(IOBSV-1))

            if (ipin.eq.3) then
              if (ipincirc.eq.0) then
                specpowvh(isour)=specpowvh(isour)+
     &            SPECPOW(ISOUR+NSOURCE*(IOBSV-1))
     &            *pinw*pinh
              else
                specpowvh(isour)=specpowvh(isour)+
     &            SPECPOW(ISOUR+NSOURCE*(IOBSV-1))
     &            *pinr*twopi1
              endif
            endif

          ENDDO   !NOBSV

          SPECPOWVHT=SPECPOWVHT+SPECPOWVH(ISOUR)

        ENDIF  !IPIN

      RETURN
      END
+DECK,POWERCIRC.
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.37/02 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.34/00 11/05/2001  15.42.20  by  Michael Scheer
*CMZ :  2.16/08 01/11/2000  18.19.09  by  Michael Scheer
*CMZ :  2.13/07 17/02/2000  15.11.12  by  Michael Scheer
*CMZ :  2.13/03 11/01/2000  18.01.43  by  Michael Scheer
*CMZ :  2.12/03 07/07/99  12.30.49  by  Michael Scheer
*CMZ :  2.10/01 25/02/99  16.08.38  by  Michael Scheer
*-- Author :    Michael Scheer   25/02/99

      SUBROUTINE POWERCIRC(ISOUR)
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SELF.

      IMPLICIT NONE

      INTEGER ISOUR,ICAL,IOBSV,IOBSVZ

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,sourcef90.
+SEQ,SPECT.
+SEq,observf90.

      DATA ICAL/0/

      IF (ICAL.EQ.0) THEN

         DO IOBSV=1,NOBSV
             SPECPOWT(IOBSV)=0.D0
         ENDDO

         DO IOBSVZ=1,NOBSVZ
             SPECPOWVT(IOBSVZ)=0.D0
         ENDDO

         SPECPOWVHT=0.D0

         ICAL=1

      ENDIF !ICAL

      IF (IRPHI.EQ.0) THEN
          CALL CIRCPOW(ISOUR,NSOURCE)
      ELSE  !(IRPHI.EQ.0)
                   CALL CIRCPOWRP(ISOUR)
      ENDIF !(IRPHI.EQ.0)

      DO IOBSV=1,NOBSV
+SELF,IF=-NEWWAVE.
          SPECPOWT(IOBSV)=SPECPOWT(IOBSV)+SPECPOW(ISOUR,IOBSV)
+SELF,IF=NEWWAVE.
          SPECPOWT(IOBSV)=SPECPOWT(IOBSV)+SPECPOW(ISOUR+NSOURCE*(IOBSV-1))
+SELF.
      ENDDO

      DO IOBSVZ=1,NOBSVZ
+SELF,IF=-NEWWAVE.
          SPECPOWVT(IOBSVZ)=SPECPOWVT(IOBSVZ)+SPECPOWV(ISOUR,IOBSVZ)
          SPECPOWT(IOBSVZ)=SPECPOWT(IOBSVZ)+SPECPOW(ISOUR,IOBSVZ)
+SELF,IF=NEWWAVE.
            ILIOBZ=ISOUR+NSOURCE*(IOBSVZ-1)
          SPECPOWVT(IOBSVZ)=SPECPOWVT(IOBSVZ)+SPECPOWV(ILIOBZ)
          SPECPOWT(IOBSVZ)=SPECPOWT(IOBSVZ)+SPECPOW(ILIOBZ)
+SELF.
      ENDDO

      SPECPOWVHT=SPECPOWVHT+SPECPOWVH(ISOUR)

      RETURN
      END
+DECK,POWINT.
*CMZ :  3.00/00 11/03/2013  10.40.59  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.16/08 12/11/2009  16.27.11  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  17.08.53  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  18.02.58  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.27  by  Michael Scheer
*-- Author : Michael Scheer
C****************************************************************************
      SUBROUTINE POWINT(X,Y,IWALL,IMODE,IPOL,ISTART,N)
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SELF.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,whbook.
+seq,pawcmn.
+SEQ,SPECT.

      INTEGER IWALL,IPOL,IMODE,IWALLO,IMODEO,IPOLO,N,ISTART

      DATA IMODEO/0/
      DATA IPOLO/0/
      DATA IWALLO/0/

      REAL*4 X,Y

C--- SPLINE COEFFICIENTS

      IF (
     &      IWALLO.NE.IWALL
     &  .OR.
     &      IPOLO.NE.IPOL
     &  .OR.
     &      IMODEO.NE.IMODE
     &  ) THEN

          CALL POWSPL(IWALL,IMODE,IPOL,ISTART,N,1.D30,1.D30)
          IWALLO=IWALL
          IPOLO=IPOL
          IMODEO=IMODE

      ENDIF !ICAL

          CALL POWSPI(X,Y,IWALL,IMODE,IPOL,ISTART,N)

      RETURN
      END
+DECK,POWSPI.
*CMZ :  3.00/00 11/03/2013  10.40.59  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.41/13 12/11/2009  16.27.11  by  Michael Scheer
*CMZ :  2.16/08 20/10/2000  11.29.02  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.35  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  14.43.04  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.53.04  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.27  by  Michael Scheer
*-- Author : Michael Scheer
C****************************************************************************
      SUBROUTINE POWSPI(X,Y,IWALL,IMODE,IPOL,ISTART,N)
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SELF.

C--- EVALUATES SPLINE-COEFFCIENTS (POWS2). SEE NUMERICAL RECIPIES, PAGE 88

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,whbook.
+seq,pawcmn.
+SEQ,SPECT.


      INTEGER KHI,KLO,K,IPOL,IMODE,IWALL,N,IS,ISTART
      REAL*4 X,Y
      DOUBLE PRECISION XI,XE,HH,AA,BB

      IS=ISTART-1
      XI=RADPOW(IWALL,IPOL,IS+1)
      XE=RADPOW(IWALL,IPOL,IS+N)

      IF (
     &       XE.GT.XI.AND.X.GE.XI.AND.X.LE.XE
     &  .OR.
     &       XI.GT.XE.AND.X.GE.XE.AND.X.LE.XI) THEN

      KLO=IS+1
      KHI=IS+N
1     IF (KHI-KLO.GT.1) THEN
        K=(KHI+KLO)/2
        IF(RADPOW(IWALL,IPOL,K).GT.X)THEN
          KHI=K
        ELSE
          KLO=K
        ENDIF
      GOTO 1
      ENDIF

      HH=RADPOW(IWALL,IPOL,KHI)-RADPOW(IWALL,IPOL,KLO)
      IF (HH.EQ.0.) THEN
          WRITE(6,*) '*** ERROR IN POWSPI ***'
          STOP
      ENDIF
      AA=(RADPOW(IWALL,IPOL,KHI)-X)/HH
      BB=(X-RADPOW(IWALL,IPOL,KLO))/HH
      Y=   AA*RADPOW(IWALL+2*IMODE+2,IPOL,KLO)
     &    +BB*RADPOW(IWALL+2*IMODE+2,IPOL,KHI)
     &    +((AA**3-AA)*POWS2(KLO-IS)+(BB**3-BB)*POWS2(KHI-IS))
     &    *(HH**2)/6.


      ELSE
          Y=0.
      ENDIF

      RETURN
      END
+DECK,POWSPL.
*CMZ :  3.00/00 11/03/2013  10.40.59  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.16/08 12/11/2009  16.27.11  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.35  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.53.11  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.27  by  Michael Scheer
*-- Author : Michael Scheer
C****************************************************************************
      SUBROUTINE POWSPL(IWALL,IMODE,IPOL,ISTART,N,YP1,YPN)
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SELF.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,whbook.
+seq,pawcmn.
+SEQ,SPECT.


      INTEGER IPOL,IMODE,IWALL,K,N,I,ISTART,IS

+SELF,IF=-F90.
       DOUBLE PRECISION POWSPLU(NWMAXP)
+SELF.
       DOUBLE PRECISION QN,SIG,P,UN,YP1,YPN

+SELF,IF=F90.
      ALLOCATE(POWSPLU(N))
+SELF.

      IS=ISTART-1

      IF (N.LT.3) THEN
          POWS2(1)=YP1
          POWS2(N)=YPN
          GOTO 9999
      ENDIF


      IF (YP1.GT..99D30) THEN
        POWS2(1)=0.
        POWSPLU(1)=0.
      ELSE
        POWS2(1)=-0.5D0
        POWSPLU(1)=(3.D0/(RADPOW(IWALL,IPOL,IS+2)
     &  -RADPOW(IWALL,IPOL,IS+1)))
     &  *((RADPOW(IWALL+2+2*IMODE,IPOL,IS+2)
     &   -RADPOW(IWALL+2+2*IMODE,IPOL,IS+1))
     &  /(RADPOW(IWALL,IPOL,IS+2)
     &   -RADPOW(IWALL,IPOL,IS+1))-YP1)
      ENDIF
      DO 11 I=2,N-1
        SIG=(RADPOW(IWALL,IPOL,IS+I)-RADPOW(IWALL,IPOL,IS+I-1))
     &  /(RADPOW(IWALL,IPOL,IS+I+1)-RADPOW(IWALL,IPOL,IS+I-1))
        P=SIG*POWS2(I-1)+2.D0
        POWS2(I)=(SIG-1.)/P
        POWSPLU(I)=(
     &       6.D0*(
     &                (RADPOW(IWALL+2+2*IMODE,IPOL,IS+I+1)
     &                -RADPOW(IWALL+2+2*IMODE,IPOL,IS+I))
     &                /
     &                 (RADPOW(IWALL,IPOL,IS+I+1)-RADPOW(IWALL,IPOL,IS+I))
     &                -
     &                 (RADPOW(IWALL+2+2*IMODE,IPOL,IS+I)
     &                 -RADPOW(IWALL+2+2*IMODE,IPOL,IS+I-1))
     &                /
     &                 (RADPOW(IWALL,IPOL,IS+I)-RADPOW(IWALL,IPOL,IS+I-1))
     &            )
     &      /
     &       (RADPOW(IWALL,IPOL,IS+I+1)-RADPOW(IWALL,IPOL,IS+I-1))
     &      -
     &       SIG*POWSPLU(I-1)
     &      )/P
11    CONTINUE
      IF (YPN.GT..99D30) THEN
        QN=0.
        UN=0.
      ELSE
        QN=0.5D0
        UN=(3.D0/(RADPOW(IWALL,IPOL,IS+N)-RADPOW(IWALL,IPOL,IS+N-1)))
     &     *(YPN-(RADPOW(IWALL+2+2*IMODE,IPOL,IS+N)
     &     -RADPOW(IWALL+2+2*IMODE,IPOL,IS+N-1))
     &     /(RADPOW(IWALL,IPOL,IS+N)-
     &     RADPOW(IWALL,IPOL,IS+N-1)))
      ENDIF
      POWS2(N)=(UN-QN*POWSPLU(N-1))/(QN*POWS2(N-1)+1.D0)
      DO 12 K=N-1,1,-1
        POWS2(K)=POWS2(K)*POWS2(K+1)+POWSPLU(K)
12    CONTINUE

C-----------------------------------------------------------------

9999  CONTINUE

+SELF,IF=F90.
      DEALLOCATE(POWSPLU)
+SELF.

      RETURN
      END
+DECK,PSPLINE.
*CMZ :  3.07/00 11/03/2019  13.47.13  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.16/08 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.35  by  Michael Scheer
*CMZ :  2.13/03 15/12/99  16.42.06  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.53.15  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.52  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE PSPLINE(ISOUR,IFREQ)
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SELF.

C--- CALCULATES COEFFICIENTS OF CUBIC SPLINES THAT INTERPOLATE THE
C    INTENSITY INSIDE THE PINHOLE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.

      INTEGER ISOUR,IFREQ,IOBSV,IZ,IY

      DOUBLE PRECISION S(NSPLINEP),S2(NSPLINEP)
      DOUBLE PRECISION YPP0,YPPN

C- SPLINES IN Z

      IOBSV=0
      DO IY=1,NOBSVY

        DO IZ=1,NOBSVZ
          IOBSV=IOBSV+1
          S(IZ)=SPEC(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))
        ENDDO      !IZ

c        YPP0=1.D30
c        YPPN=1.D30

C       CALL FSPLINEZ(OBSVZ,S,NOBSVZ,YPP0,YPPN,S2)
C060793    CALL FSPLINDX(OBSVZ, S,NOBSVZ,YPP0,YPPN,S2)
        CALL FSPLINDX(OBSVDZ,S,NOBSVZ,0.D0,0.D0,S2)

        DO IZ=1,NOBSVZ
          SPCOEF(IZ+(IY-1)*NOBSVZ)=S2(IZ)
        ENDDO      !IZ
      ENDDO      !IY

      RETURN
      END
+DECK,PSPLINEF.
*CMZ :  3.08/01 04/04/2019  09.21.15  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.16/08 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.35  by  Michael Scheer
*CMZ :  2.13/03 20/12/99  17.19.59  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.53.19  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.53  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE PSPLINEF(ISOUR,IFREQ)
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SELF.

C--- CALCULATES COEFFICIENTS OF CUBIC SPLINES THAT INTERPOLATE THE
C    FOLDED INTENSITY INSIDE THE PINHOLE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.

      INTEGER ISOUR,IFREQ,IOBSV,IZ,IY,IIZ

      DOUBLE PRECISION S(NSPLINEP),S2(NSPLINEP)
      DOUBLE PRECISION YPP0,YPPN

      DOUBLE PRECISION OBSVZF(NSPLINEP)

C- SPLINES IN Z

      DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY

        IIZ=0
        DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
          IIZ=IIZ+1
          IOBSV=(IY-1)*NOBSVZ+IZ
          OBSVZF(IIZ)=OBSVZ(IZ)
          S(IIZ)=SPECF(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))
        ENDDO      !IZ

        YPP0=1.D30   !OTHERWISE PROBLEMS IN FSPLINE
        YPPN=1.D30

C       CALL FSPLINEZ(OBSVZF,S,MOBSVZ,YPP0,YPPN,S2)
C060793    CALL FSPLINDX(OBSVZF,S,MOBSVZ,YPP0,YPPN,S2)
        CALL FSPLINDX(OBSVDZ,S,MOBSVZ,0.0D0,0.0D0,S2)

        IIZ=0
        DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
          IOBSV=(IY-1)*NOBSVZ+IZ
          IIZ=IIZ+1
          SPCOEFM(IOBSV)=S2(IIZ)
        ENDDO      !IZ

      ENDDO      !IY

      RETURN
      END
+DECK,PSPLSTOF.
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.16/08 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.35  by  Michael Scheer
*CMZ :  2.13/03 12/01/2000  16.34.43  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.07  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE PSPLSTOF(ISTOK,IFREQ)
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SELF.

C--- CALCULATES COEFFICIENTS OF CUBIC SPLINES THAT INTERPOLATE THE
C    FOLDED INTENSITY INSIDE THE PINHOLE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.

      INTEGER ISTOK,IFREQ,IOBSV,IZ,IY,IIZ

      DOUBLE PRECISION S(NSPLINEP),S2(NSPLINEP)


C- SPLINES IN Z

        DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY

        IIZ=0
        DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ

          IIZ=IIZ+1
          IOBSV=(IY-1)*NOBSVZ+IZ
+SELF,IF=-NEWWAVE.
          S(IIZ)=STOKESF(ISTOK,IOBSV,IFREQ)
+SELF,IF=NEWWAVE.
          S(IIZ)=STOKESF(ISTOK,IOBSV+NOBSV*(IFREQ-1))
+SELF.

        ENDDO      !IZ

        CALL FSPLINDX(OBSVDZ,S,MOBSVZ,0.D0,0.D0,S2)

        IIZ=0
        DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ

          IOBSV=(IY-1)*NOBSVZ+IZ
          IIZ=IIZ+1
          SPCOEFM(IOBSV)=S2(IIZ)


        ENDDO      !IZ
        ENDDO      !IY

      RETURN
      END
+DECK,READBP.
*CMZ :  3.05/10 13/08/2018  14.40.26  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.48/04 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  16.03.23  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  13.48.26  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  17.11.07  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.53.27  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.09  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE READBP
+seq,gplhint.

C     READBP LIEST PANDIRA OUTPUT IN ARRAYS EIN

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.

+SEQ,PANDIR.

      INTEGER LTOPR, KTOPR,LLO,LU,LO,KL,KR,KMIN,KTOP,LMIN,LTOP,LL
     &         ,LDUM,KDUM,IREAD,L,K,IL,IK
      REAL X,Y,BX,BY

C      DATA BPAN/0./

      NXPAN=NXPANP
      NYPAN=NYPANP

+SELF,IF=VMS.
      OPEN (
     1 UNIT=LUNP,
     1   FILE = FILEP,
     1   STATUS = 'OLD',
     1   READONLY,
     1   FORM = 'FORMATTED')
+SELF.

+SELF,IF=LINUX,WINDOWS,HPUX,TRUE64.
      OPEN (
     1 UNIT=LUNP,
     1   FILE = FILEP,
     1   STATUS = 'OLD',
     1   FORM = 'FORMATTED')
+SELF.

      READ(LUNP,'(1A32)') PANTIT
      READ(LUNP,*) KMIN,KTOP,LMIN,LTOP

      IF (KTOP-KMIN.LT.1 .OR. 2*KTOP-1.GT.NXPAN .OR.
     &      LTOP-LMIN.LT.1 .OR. 2*LTOP-1.GT.NYPAN) THEN
         WRITE(6,*)
         WRITE(6,*) '*** S/R READBP:'
         WRITE(6,*)
     & 'KMIN.LT.3 .OR. 2*KTOP-1.GT.NXPAN .OR. LMIN.LT.3 .OR. 2*LTOP-1.GT.NYPAN'
         WRITE(16,*)
         WRITE(16,*) '*** S/R READBP:'
         WRITE(16,*)
     & 'KMIN.LT.3 .OR. 2*KTOP-1.GT.NXPAN .OR. LMIN.LT.3 .OR. 2*LTOP-1.GT.NYPAN'
         STOP
      ENDIF

C--- H-SHAPED MAGNET SYMMETRIE

      DO IL=1,2*LTOP-1
         DO IK=1,2*KTOP-1
         LPANB(IK,IL)=-1
         ENDDO
      ENDDO

      K=0
      L=1
      DO IREAD=1,(KTOP-KMIN+1)*(LTOP-LMIN+1)
         READ (LUNP,*,END=900)
     &            KDUM,LDUM,X,Y,BX,BY

C--- SCALIEREN (17.07.91)
C        BX=BX*BPANSC
C        BY=BY*BPANSC
C---
              K=K+1
         IF(K.GT.KTOP) THEN
             K=1
             L=L+1
         ENDIF

         KR=KTOP-1+K
         KL=KTOP+1-K
         LO=LTOP-1+L
         LU=LTOP+1-L

         BXPAN(KR,LO)=BX
         BYPAN(KR,LO)=BY
         XPAN(KR,LO)=X
         YPAN(KR,LO)=Y
         LPANB(KR,LO)=1

         BXPAN(KL,LO)=-BX  !VORZEICHEN KORRIGIERT 3.4.91
         BYPAN(KL,LO)=BY
         XPAN(KL,LO)=-X
         YPAN(KL,LO)=Y
         LPANB(KL,LO)=1

         BXPAN(KR,LU)=-BX  !VORZEICHEN KORRIGIERT 3.4.91
         BYPAN(KR,LU)=BY
         XPAN(KR,LU)=X
         YPAN(KR,LU)=-Y
         LPANB(KR,LU)=1

         BXPAN(KL,LU)=BX
         BYPAN(KL,LU)=BY
         XPAN(KL,LU)=-X
         YPAN(KL,LU)=-Y
         LPANB(KL,LU)=1
      ENDDO

900   CLOSE(LUNP)

      KTOP=2*KTOP-1
      LTOP=2*LTOP-1

C--- NORMIEREN

CN    DO IL=1,LTOP
C        IL=LTOP/2+1 !CN
C        DO IK=1,KTOP
C           BPAN=AMAX1(BPAN,
C     & SQRT(BYPAN(IK,IL)*BYPAN(IK,IL)+BXPAN(IK,IL)*BXPAN(IK,IL)))
C        ENDDO
CN    ENDDO
C     BP=BPANMX/BPAN
C     DO IL=1,LTOP
C        DO IK=1,KTOP
C        BXPAN(IK,IL)=BXPAN(IK,IL)*BP
C        BYPAN(IK,IL)=BYPAN(IK,IL)*BP
C        ENDDO
C     ENDDO

      WRITE(6,*)
      WRITE(6,*)'*** S/R READBP: B-FELD VON PANDIRA GELESEN ***'
      WRITE(6,*)
      WRITE(16,*)
      WRITE(16,*)'*** S/R READBP: B-FELD VON PANDIRA GELESEN ***'
      WRITE(16,*)
      WRITE(16,*)'PANDIRA-TITLE:',PANTIT
      WRITE(16,*)
     &'VIERER-SYMMETRIE VORAUSGESETZT, KTOP,LTOP VERDOPPELT'
      WRITE(16,*)'IREAD,KMIN,KTOP,LMIN,LTOP:',IREAD,KMIN,KTOP,LMIN,LTOP
      WRITE(16,*)'BX(KMIN,LMIN), BY(KMIN,LMIN):',
     &              BXPAN(KMIN,LMIN),BYPAN(KMIN,LMIN)

C-------12.12.90, REDUKTION VON BXPAN,BYPAN-> BXPANR,BYPANR

      DO 100 L=1,LTOP
          LLO=L
          DO 101 K=1,KTOP
                IF (LPANB(K,L).LT.0) GOTO 100
101       CONTINUE
            GOTO 200
100   CONTINUE
200   CONTINUE

      DO 300 L=LLO,LTOP-LLO+1
          LL=L-LLO+1
          DO 301 K=1,KTOP
         BXPANR(K,LL)=BXPAN(K,L)
         BYPANR(K,LL)=BYPAN(K,L)
         XPANR(K,LL)=XPAN(K,L)
         YPANR(K,LL)=YPAN(K,L)
301       CONTINUE
300   CONTINUE

      KTOPR=KTOP
      LTOPR=LTOP-2*LLO+2

      IF (LTOPR.LT.3) THEN
         WRITE(6,*)
         WRITE(6,*) '*** S/R READBP: LTOPR.LT.3 ***'
         WRITE(6,*)
         WRITE(16,*)
         WRITE(16,*) '*** S/R READBP: LTOPR.LT.3 ***'
         WRITE(16,*)
         STOP
      ENDIF


      WRITE(6,*)
      WRITE(6,*)'*** S/R REABDP: BXPAN,BYPAN REDUZIERT ***'
      WRITE(6,*)'KTOPR,LTOPR: ',KTOPR,LTOPR
      WRITE(16,*)
      WRITE(16,*)'*** S/R REABDP: BXPAN,BYPAN REDUZIERT ***'
      WRITE(16,*)'KTOPR,LTOPR: ',KTOPR,LTOPR

C     DO L=1,LTOPR
C     DO K=1,KTOPR
C        WRITE(88,1000)K,XPANR(K,L),YPANR(K,L),BXPANR(K,L),BYPANR(K,L)
C     ENDDO
C     WRITE(88,*)
C     WRITE(88,*)
C     WRITE(88,*)
C     ENDDO
C1000    FORMAT(I5,4F10.6)

C     WRITE(16,*)
C     WRITE(16,*)'SCALENFAKTOR FUER PANDIRA B-FELD:',BPANSC
C     WRITE(16,*)

      RETURN
      END
+DECK,rearg.
*CMZ :  4.00/13 07/11/2021  15.08.37  by  Michael Scheer
*CMZ :  4.00/04 29/07/2019  16.45.12  by  Michael Scheer
*CMZ :  3.05/28 19/12/2018  10.06.30  by  Michael Scheer
*CMZ :  3.05/03 16/05/2018  16.01.42  by  Michael Scheer
*CMZ :  3.05/01 07/05/2018  16.35.20  by  Michael Scheer
*CMZ :  3.03/02 07/12/2015  17.18.10  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.66/18 30/11/2010  14.43.20  by  Michael Scheer
*CMZ :  2.65/02 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.54/04 14/09/2009  15.19.42  by  Michael Scheer
*CMZ :  2.54/03 18/04/2005  08.54.26  by  Michael Scheer
*CMZ :  2.50/03 10/05/2004  14.40.44  by  Michael Scheer
*CMZ :  2.50/00 28/04/2004  12.39.19  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  15.58.48  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.35  by  Michael Scheer
*CMZ :  2.14/02 26/04/2000  16.42.15  by  Michael Scheer
*CMZ :  2.12/02 15/06/99  10.22.13  by  Michael Scheer
*CMZ :  2.11/01 21/05/99  10.11.03  by  Michael Scheer
*CMZ :  2.10/01 04/03/99  10.05.14  by  Michael Scheer
*CMZ :  2.02/00 05/02/99  14.51.22  by  Michael Scheer
*CMZ :  2.01/00 19/01/99  11.16.08  by  Michael Scheer
*CMZ :  2.00/00 04/01/99  14.07.05  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  14.43.04  by  Michael Scheer
*CMZ :  1.03/01 26/01/98  17.10.38  by  Michael Scheer
*CMZ :  1.03/00 16/01/98  13.56.25  by  Michael Scheer
*CMZ :  1.02/03 13/01/98  17.27.39  by  Michael Scheer
*CMZ : 00.02/05 04/03/97  13.43.34  by  Michael Scheer
*CMZ : 00.02/01 12/12/96  16.16.58  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  17.12.46  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.53.31  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.45  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE REARG(ISOUR,IOBSV)
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,REARGF90U.
+SELF.


C--- CALCULATES REAL PARTS OF INTEGRALS FOR A GIVEN OBSERVATION POINT
C    THE TIME STARTS BY ZERO, I.E. EACH SOURCE HAS ITS OWN TIME BASE
C    SOURCES ARE ADDED INCOHERENTLY

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,REARG,IF=-F90.
+SEq,observf90.
+SEQ,PHYCON.
+seq,sourcef90.
+SEQ,COLLI.

      INTEGER ISOUR,IOBSV,IPOI,IPOIR,INSIDE,INOLD,ICHANGE
      INTEGER IWARN,IRANGE,IAPERT,IWARNBET1N

      DOUBLE PRECISION C1,DT,BET1N,BET1NO
      DOUBLE PRECISION X,Y,Z,T,BX,BY,BZ,BPX,BPY,BPZ,ZP,YP,OPANG,TOPANG
      DOUBLE PRECISION XOB,YOB,ZOB,RX,RY,RZ
      DOUBLE PRECISION RNX,RNY,RNZ,RNBX,RNBY,RNBZ,R,R1,PX,PY,PZ,DOM1,DOM2
      DOUBLE PRECISION APX,APY,APZ,APERW2,APERH2,RARGV2(3)
      double precision br2,rnr2,br4,rnr4,b3

      DOUBLE PRECISION R0
      DATA R0/1.D30/

      DATA IWARN/0/
      DATA IWARNBET1N/1/ ! 7.12.2015, since warning is boring

      integer, save :: ksouro=-1

      save iwarn,iwarnbet1n

      IF (ISOUR.NE.ksouro) IWARN=0

      C1=1.D0/CLIGHT1

C--- LOOP OVER TIME INTERVALS

CV2--------------------------------------------------------------
CORR  IF (ISOUR.NE.ksouro) T=0.0d0
C      R0=OBSV(1,IOBSV)-SOURCEEO(1,1,ISOUR)   !C150793
      R0=OBSV(1,1)-SOURCEAO(1,1,ISOUR)   !C210599
      T=TBUFF(IOBSV)
CV2--------------------------------------------------------------

CV2   T=0.0d0

      OPANG=DABS(WGWINFC/DMYGAMMA)
      TOPANG=DTAN(OPANG)
      IPOIR=0
      INSIDE=0
      INOLD=0
      ICHANGE=0

      XOB=OBSV(1,IOBSV)
      YOB=OBSV(2,IOBSV)
      ZOB=OBSV(3,IOBSV)

      DO IPOI=1,IPOISOU(ISOUR)

        X=WSOU(1,1,IPOI)
        Y=WSOU(2,1,IPOI)
        Z=WSOU(3,1,IPOI)

        DT=WSOU(1,4,IPOI)

C DT FOR STEP FROM X(I-1) TO X(I) IS WSOU(1,4,I)
C HENCE TIME OF X(I) SHOULD BE:

        T=T+DT

        IF (T/DT.GT.1.D7) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN REARG ***'
          WRITE(LUNGFO,*)
     &      'T/DT.GT.1.D7 (TIME INTERVALL OF TRACKING STEP TOO SMALL)'
          WRITE(LUNGFO,*)'CHECK PROBLEM USING DEBUGGER'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN REARG ***'
          WRITE(6,*)
     &      'T/DT.GT.1.D7 (TIME INTERVALL OF TRACKING STEP TOO SMALL)'
          WRITE(6,*)'CHECK PROBLEM USING DEBUGGER'
          WRITE(6,*)
          WRITE(6,*)
        ENDIF    !T/DT

        BX=WSOU(1,2,IPOI)*C1
        BY=WSOU(2,2,IPOI)*C1
        BZ=WSOU(3,2,IPOI)*C1

        BPX=WSOU(1,3,IPOI)*C1
        BPY=WSOU(2,3,IPOI)*C1
        BPZ=WSOU(3,3,IPOI)*C1

        RX=XOB-X
        RY=YOB-Y
        RZ=ZOB-Z

        R=DSQRT(RX*RX+RY*RY+RZ*RZ)
        R1=1.D0/R

        RNX=RX*R1
        RNY=RY*R1
        RNZ=RZ*R1

C--- THE DISTANCE R IS INTRODUCED HERE EXPLICITLY (S. PROGRAM OF CHAOEN WANG

        BET1N=(1.0D0-BX*RNX)-BY*RNY-BZ*RNZ

c 20090928{
        br2=by**2+bz**2
        rnr2=rny**2+rnz**2
        b3=dmybeta**3
        br4=br2**2
        rnr4=rnr2**2

        if(br2.lt.1.0d-4.and.rnr2.lt.1.0d-4) then
          bet1n=
     &      1.0d0/(1+dmybeta)/dmygamma**2
     &      +dmybeta*(rnr2/2.0d0
     &      +rnr4/8.0d0)
     &      +(br2/2.0d0
     &      -br2*rnr2/4.0d0
     &      -br2*rnr4/16.0d0)/dmybeta
     &      +b3*br4*(1.0d0/8.0d0
     &      -rnr2/16.0d0
     &      -rnr4/64.0d0)
     &      -by*rny
     &      -bz*rnz
        endif
c }20090928
+self,if=iwarnbet1n.
        IF (IPOI.EQ.1) THEN
          BET1NO=BET1N
        ELSE IF (iundulator.eq.0
     &      .and.(BET1N-BET1NO)/BET1N.GT.0.05.AND.IWARNBET1N.EQ.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN REARG  ***'
          WRITE(LUNGFO,*)'DISCONTINUITY IN INTEGRAND'
          WRITE(LUNGFO,*)
     &      'Check results carefully, change BMOVECUT, MYINUM, NLPOI etc.'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'ISTEP, X,BET1N,BET1NO:',IPOI,SNGL(X),SNGL(BET1N),SNGL(BET1NO)
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN REARG  ***'
          WRITE(6,*)'DISCONTINUITY IN INTEGRAND'
          WRITE(6,*)
     &      'Check results carefully, change BMOVECUT, MYINUM, NLPOI etc.'
          WRITE(6,*)
          WRITE(6,*)'ISTEP,X,BET1N,BET1NO:',IPOI,SNGL(X),SNGL(BET1N),SNGL(BET1NO)
          WRITE(6,*)
          IWARNBET1N=1
        ENDIF

        BET1NO=BET1N
+self.
        DOM1=1.D0/(R*BET1N*BET1N)

        RNBX=RNX-BX
        RNBY=RNY-BY
        RNBZ=RNZ-BZ

        PX=(RNBY*BPZ-RNBZ*BPY)
        PY=(RNBZ*BPX-RNBX*BPZ)
        PZ=(RNBX*BPY-RNBY*BPX)

        ZP=BZ/BX
        YP=BY/BX

        IF(
     &      Z+(ZP+TOPANG)/(1.D0-ZP*TOPANG)*RX.GE.ZOB
     &      .AND.
     &      Z+(ZP-TOPANG)/(1.D0+ZP*TOPANG)*RX.LE.ZOB
     &      .AND.
     &      Y+(YP+TOPANG)/(1.D0-YP*TOPANG)*RX.GE.YOB
     &      .AND.
     &      Y+(YP-TOPANG)/(1.D0+YP*TOPANG)*RX.LE.YOB)
     &      THEN

          IPOIR=IPOIR+1

          IF(IPOIR.GT.NDARGU) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN REARG ***'
            WRITE(LUNGFO,*)'INCREASE PARAMETER NDARGUP IN CMPARA.CMN'
            WRITE(LUNGFO,*)
            WRITE(6,*) '*** ERROR IN REARG ***'
            STOP
          ENDIF

          INSIDE=1

          APX=(APERX-X)
          APZ=Z+RZ/RX*APX
          APY=Y+RY/RX*APX
          APERW2=APERWID/2.D0
          APERH2=APERHIG/2.D0

          IF (X.GE.XIANF.AND.X.LE.XIEND) THEN
            IRANGE=1
          ELSE
            IRANGE=0
          ENDIF

          IF (
     &        APZ.LE.(APERZ+APERW2)
     &        .AND.
     &        APZ.GE.(APERZ-APERW2)
     &        .AND.
     &        APY.LE.(APERY+APERH2)
     &        .AND.
     &        APY.GE.(APERY-APERH2)
     &        ) THEN
            IAPERT=1
          ELSE
            IAPERT=0
          ENDIF


          IF (IRANGE.EQ.1.AND.IAPERT.EQ.1) THEN


            IF (IVELOFIELD.EQ.0) THEN
              DOM2=CLIGHT1*DOM1*R1/(DMYGAMMA*DMYGAMMA)
              REARGUM(1,IPOIR)=(RNY*PZ-RNZ*PY)*DOM1+(RNX-BX)*DOM2
              REARGUM(2,IPOIR)=(RNZ*PX-RNX*PZ)*DOM1+(RNY-BY)*DOM2
              REARGUM(3,IPOIR)=(RNX*PY-RNY*PX)*DOM1+(RNZ-BZ)*DOM2
            ELSE IF (IVELOFIELD.EQ.1) THEN
              REARGUM(1,IPOIR)=(RNY*PZ-RNZ*PY)*DOM1
              REARGUM(2,IPOIR)=(RNZ*PX-RNX*PZ)*DOM1
              REARGUM(3,IPOIR)=(RNX*PY-RNY*PX)*DOM1
            ELSE IF (IVELOFIELD.EQ.2) THEN !approximation, see souintana
              REARGUM(1,IPOIR)=RNBX*R1
              REARGUM(2,IPOIR)=RNBY*R1
              REARGUM(3,IPOIR)=RNBZ*R1
            ELSE IF (IVELOFIELD.LT.0) THEN
              DOM2=CLIGHT1*DOM1*R1/(DMYGAMMA*DMYGAMMA)
              REARGUM(1,IPOIR)=(RNX-BX)*DOM2
              REARGUM(2,IPOIR)=(RNY-BY)*DOM2
              REARGUM(3,IPOIR)=(RNZ-BZ)*DOM2
            ELSE  !IVELOFIELD
              PRINT*, '*** ERROR IN REARG: BAD VALUE OF IVELOFIELD'
              STOP
            ENDIF !IVELOFIELD

C150793             REARGUM(4,IPOIR)=T+R*C1
            REARGUM(4,IPOIR)=T+(R-R0)*C1

            IF (IVELOFIELD.NE.2) THEN

              REARGUM(5,IPOIR)=(
     &          REARGUM(1,IPOIR)*REARGUM(1,IPOIR)
     &          +REARGUM(2,IPOIR)*REARGUM(2,IPOIR)
     &          +REARGUM(3,IPOIR)*REARGUM(3,IPOIR)
     &          )/BET1N

            ELSE

              DOM2=CLIGHT1*DOM1*R1/(DMYGAMMA*DMYGAMMA)
              RARGV2(1)=(RNY*PZ-RNZ*PY)*DOM1+(RNX-BX)*DOM2
              RARGV2(2)=(RNZ*PX-RNX*PZ)*DOM1+(RNY-BY)*DOM2
              RARGV2(3)=(RNX*PY-RNY*PX)*DOM1+(RNZ-BZ)*DOM2

              REARGUM(5,IPOIR)=(
     &          RARGV2(1)*RARGV2(1)
     &          +RARGV2(2)*RARGV2(2)
     &          +RARGV2(3)*RARGV2(3)
     &          )/BET1N

            ENDIF

            REARGUM(6,IPOIR)=DT
            REARGUM(7,IPOIR)=BET1N
            REARGUM(8,IPOIR)=-CLIGHT1*R1
     &        *((BX*BX-(BX*RNX+BY*RNY+BZ*RNZ)**2)+BY*BY+BZ*BZ)
     &        -(RNX*BPX+RNY*BPY+RNZ*BPZ)/2.0D0

          ELSE

            IF (IAPERT.EQ.0.AND.IWARN.EQ.0) THEN

              WRITE(LUNGFO,*)'*** WARNING REARG:'
              WRITE(LUNGFO,*)
     &          'APERTURE AFFECTS SPECTRUM CALCULATION FOR SOURCE'
     &          ,ISOUR
              WRITE(LUNGFO,*)
              WRITE(6,*)'*** WARNING REARG:'
              WRITE(6,*)
     &          'APERTURE AFFECTS SPECTRUM CALCULATION FOR SOURCE'
     &          ,ISOUR
              WRITE(6,*)
              IWARN=1

            ENDIF    !IAPERT

            REARGUM(1,IPOIR)=0.0d0
            REARGUM(2,IPOIR)=0.0d0
            REARGUM(3,IPOIR)=0.0d0

            REARGUM(4,IPOIR)=T+(R-R0)*C1
            REARGUM(5,IPOIR)=0.0d0
            REARGUM(6,IPOIR)=DT

            REARGUM(7,IPOIR)=0.0d0
            REARGUM(8,IPOIR)=0.0d0

          ENDIF    !IRANGE, IAPERT

          IF (IPOIR.NE.1) THEN
            IF ((R-R0)*C1/T.GT.1.D7) THEN

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'*** WARNING REARG ***'
              WRITE(LUNGFO,*)
     &          '(R-R0)*C1/T.GT.1.D7'
              WRITE(LUNGFO,*)'CHECK PROBLEM USING DEBUGGER'
              WRITE(LUNGFO,*)
              WRITE(6,*)
              WRITE(6,*)
              WRITE(6,*)'*** WARNING REARG ***'
              WRITE(6,*)
     &          '(R-R0)*C1/T.GT.1.D7'
              WRITE(6,*)'CHECK PROBLEM USING DEBUGGER'
              WRITE(6,*)
              WRITE(6,*)

            ENDIF    !T/(R-R0)*C1
          ENDIF    !IPOIR.NE.1

        ELSE

          INSIDE=0

        ENDIF   !INSIDE WGWINFC CONE

        IF(INOLD.NE.INSIDE) THEN
          ICHANGE=ICHANGE+1
        ENDIF

        IF(ICHANGE.GT.2) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN REARG ***'
          WRITE(LUNGFO,*)'SOURCE POINT NOT COHERENT FOR OBSERVATION POINT'
          WRITE(LUNGFO,*)'X-START AND  X-END OF SOURCE:'
          WRITE(LUNGFO,*)SOURCEAO(1,1,ISOUR),SOURCEEO(1,1,ISOUR)
          WRITE(LUNGFO,*)'X,Y,Z OF OBSERVATION POINT:'
          WRITE(LUNGFO,*)XOB,YOB,ZOB
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'CHECK OBSERVATION POINTS, OR INCREASE MYINUM,'
          WRITE(LUNGFO,*)'OR CHANGE WGWINFC, OR CHANGE COLLIMATOR ...'
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN REARG ***'
          WRITE(6,*)'SOURCE POINT NOT COHERENT FOR OBSERVATION POINT'
          WRITE(6,*)'X-START AND  X-END OF SOURCE:'
          WRITE(6,*)SOURCEAO(1,1,ISOUR),SOURCEEO(1,1,ISOUR)
          WRITE(6,*)'X,Y,Z OF OBSERVATION POINT:'
          WRITE(6,*)XOB,YOB,ZOB
          WRITE(6,*)
          WRITE(6,*)'CHECK OBSERVATION POINTS OR INCREASE MYINUM,'
          WRITE(6,*)'OR CHANGE WGWINFC, OR CHANGE COLLIMATOR ...'
          WRITE(6,*)
          STOP
        ENDIF

        INOLD=INSIDE

      ENDDO !LOOP OVER TIME INTERVALLS

      IARGUM=IPOIR
CV2------------------------------------------------------------
      IF (ISOUR.NE.ksouro) NARGUM(IOBSV,ISOUR)=0
      NARGUM(IOBSV,ISOUR)=NARGUM(IOBSV,ISOUR)+IARGUM
      TBUFF(IOBSV)=T
CV2------------------------------------------------------------
CV2   NARGUM(IOBSV,ISOUR)=IARGUM

      ksouro=isour

      RETURN
      END
+DECK,REC_BFELD.
*CMZ :  4.00/07 04/06/2020  15.49.41  by  Michael Scheer
*CMZ :  3.03/02 04/03/2016  18.10.04  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.66/07 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.57/05 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  2.42/04 30/01/2004  09.51.57  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.35  by  Michael Scheer
*CMZ :  2.14/02 20/04/2000  14.28.53  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  14.43.04  by  Michael Scheer
*CMZ :  1.00/00 02/06/97  10.56.40  by  Michael Scheer
*CMZ : 00.01/08 22/06/95  11.22.17  by  Michael Scheer
*CMZ : 00.01/07 09/03/95  16.17.03  by  Michael Scheer
*CMZ : 00.00/00 03/03/95  15.50.11  by  Johannes Bahrdt
*-- Author : Michael Scheer
c****************************************************************

      subroutine REC_bfeld(xb,yb,zb,bx,by,bz)
+seq,gplhint.

C *** INSIDE THIS ROUTINE UNITS OF XB,YB,ZB ... ARE [mm]

      IMPLICIT NONE

      INTEGER IMAG,IMAGOLD,IMAG1,ISET

      DOUBLE PRECISION XB,YB,ZB,BX,BY,BZ,XBOLD
      DOUBLE PRECISION XMUE0,PI,SMALL,GR
      DOUBLE PRECISION XXLEN,XXXLEN
      DOUBLE PRECISION YYLEN,YYYLEN
      DOUBLE PRECISION ZZLEN,ZZZLEN
      DOUBLE PRECISION X,Y,Z,X1,Y1,Z1,X2,Y2,Z2
      DOUBLE PRECISION X1P,Y1P,Z1P,X2P,Y2P,Z2P
      DOUBLE PRECISION X11,Y11,Z11,X12,Y12,Z12
      DOUBLE PRECISION C1,S1,S2,S3,S4,S5,S6,S7,S8,RR1,RR2
      DOUBLE PRECISION BXX,BYY,BZZ,BXXX,BYYY,BZZZ,CURRENT
      DOUBLE PRECISION COSPHI,SINPHI,SINTHE,COSTHE

c--------new 25.10.2002 Johannes Bahrdt
      DOUBLE PRECISION zz1(4),zz2(4),zz1exp(4),zz2exp(4)
      INTEGER I,IZ1,IZ2

+SEQ,CMPARA.
+SEQ,KLOTZ.
+SEQ,PHYCON.

      DATA IMAG1/1/
      DATA IMAGOLD/1/
      DATA XBOLD/1.D30/
      DATA xmue0/1.2566d-6/
      DATA SMALL/1.0d-8/

      pi=PI1
      gr=pi/180.d0

      bx=0.
      by=0.
      bz=0.

c************ Loop over magnets ******************************

      IF (XB.LT.XBOLD) THEN
        IMAGOLD=1
        IMAG1=1
      ENDIF

      ISET=0

      do imag=IMAGOLD,IMAGTOT

        IF (DX(IMAG).LT.XB-WINREC*500.D0) cycle
        IF (BC(IMAG).EQ.0.0) cycle
        IF (DX(IMAG).GT.XB+WINREC*500.D0) exit

        IF (ISET.EQ.0) THEN
          IMAG1=IMAG
          ISET=1
        ENDIF

C22MAY97 IF (
C22MAY97     &      DABS(DABS(THETA(IMAG)-  0.D0*GR)).GT.SMALL
C22MAY97     & .AND.DABS(DABS(THETA(IMAG)- 90.D0*GR)).GT.SMALL
C22MAY97     & .AND.DABS(DABS(THETA(IMAG)-180.D0*GR)).GT.SMALL
C22MAY97     & .AND.DABS(DABS(THETA(IMAG)-270.D0*GR)).GT.SMALL
C22MAY97     & ) THEN
C22MAY97     WRITE(6,*) THETA(IMAG)
C22MAY97     STOP '*** ERROR IN REC_BFELD: THETA WRONG (+/- 0.,90.,180.,270.) ***'
C22MAY97 ENDIF

+self,if=nofixcos.

        IF (
     &      DABS(DABS(THETA(IMAG))-  0.D0*GR).GT.SMALL
     &      .AND.DABS(DABS(THETA(IMAG))- 90.D0*GR).GT.SMALL
     &      .AND.DABS(DABS(THETA(IMAG))-180.D0*GR).GT.SMALL
     &      .AND.DABS(DABS(THETA(IMAG))-270.D0*GR).GT.SMALL
     &      ) THEN
          WRITE(6,*) THETA(IMAG)
          WRITE(6,*) '*** ERROR IN REC_BFELD: THETA WRONG (+/- 0.,90.,180.,270.) ***'
          STOP
        ENDIF

        IF (
     &      DABS(DABS(PHI(IMAG))-  0.D0*GR).GT.SMALL
     &      .AND.DABS(DABS(PHI(IMAG))- 90.D0*GR).GT.SMALL
     &      .AND.DABS(DABS(PHI(IMAG))-180.D0*GR).GT.SMALL
     &      .AND.DABS(DABS(PHI(IMAG))-270.D0*GR).GT.SMALL
     &      ) THEN
          WRITE(6,*) PHI(IMAG)
C22MAY97     STOP '*** ERROR IN REC_BFELD: PHI WRONG (+/- 0.,90.,180.,270.) ***'
          WRITE(6,*) '*** ERROR IN REC_BFELD: PHI WRONG (+/- 0.,90.,180.,270.) ***'
          STOP
        ENDIF

C      xxlen=xlen(IMAG)
C      yylen=ylen(IMAG)
C      zzlen=zlen(IMAG)

        COSPHI=DCOS(PHI(IMAG))
        SINPHI=DSIN(PHI(IMAG))
        COSTHE=DCOS(THETA(IMAG))
        SINTHE=DSIN(THETA(IMAG))

+self,if=-nofixcos.
        IF (DABS(THETA(IMAG)-  0.D0*GR).LT.SMALL) THEN
          COSTHE=1.0D0
          SINTHE=0.0D0
        ELSE IF (DABS(THETA(IMAG)-  90.D0*GR).LT.SMALL) THEN
          COSTHE=0.0D0
          SINTHE=1.0D0
        ELSE IF (DABS(THETA(IMAG)+  90.D0*GR).LT.SMALL) THEN
          COSTHE=0.0D0
          SINTHE=-1.0D0
        ELSE IF (DABS(THETA(IMAG)-  180.D0*GR).LT.SMALL) THEN
          COSTHE=-1.0D0
          SINTHE=0.0D0
        ELSE IF (DABS(THETA(IMAG)+  180.D0*GR).LT.SMALL) THEN
          COSTHE=-1.0D0
          SINTHE=0.0D0
        ELSE IF (DABS(THETA(IMAG)-  270.D0*GR).LT.SMALL) THEN
          COSTHE=0.0D0
          SINTHE=-1.0D0
        ELSE IF (DABS(THETA(IMAG)+  270.D0*GR).LT.SMALL) THEN
          COSTHE=0.0D0
          SINTHE=-1.0D0
        ELSE
          WRITE(6,*) THETA(IMAG)
          WRITE(6,*) '*** ERROR IN REC_BFELD: THETA WRONG (+/- 0.,90.,180.,270.) ***'
          STOP
        ENDIF

        IF (DABS(PHI(IMAG)-  0.D0*GR).LT.SMALL) THEN
          COSPHI=1.0D0
          SINPHI=0.0D0
        ELSE IF (DABS(PHI(IMAG)-  90.D0*GR).LT.SMALL) THEN
          COSPHI=0.0D0
          SINPHI=1.0D0
        ELSE IF (DABS(PHI(IMAG)+  90.D0*GR).LT.SMALL) THEN
          COSPHI=0.0D0
          SINPHI=-1.0D0
        ELSE IF (DABS(PHI(IMAG)-  180.D0*GR).LT.SMALL) THEN
          COSPHI=-1.0D0
          SINPHI=0.0D0
        ELSE IF (DABS(PHI(IMAG)+  180.D0*GR).LT.SMALL) THEN
          COSPHI=-1.0D0
          SINPHI=0.0D0
        ELSE IF (DABS(PHI(IMAG)-  270.D0*GR).LT.SMALL) THEN
          COSPHI=0.0D0
          SINPHI=-1.0D0
        ELSE IF (DABS(PHI(IMAG)+  270.D0*GR).LT.SMALL) THEN
          COSPHI=0.0D0
          SINPHI=-1.0D0
          WRITE(6,*) PHI(IMAG)
C22MAY97     STOP '*** ERROR IN REC_BFELD: PHI WRONG (+/- 0.,90.,180.,270.) ***'
          WRITE(6,*) '*** ERROR IN REC_BFELD: PHI WRONG (+/- 0.,90.,180.,270.) ***'
          STOP
        ENDIF

C      xxlen=xlen(IMAG)
C      yylen=ylen(IMAG)
C      zzlen=zlen(IMAG)

+self.

c     Drehung um phi(imag)

        XXLEN=XLEN(IMAG)*cosphi+ZLEN(IMAG)*sinphi
        YYLEN=YLEN(IMAG)
        ZZLEN=ZLEN(IMAG)*cosphi-XLEN(IMAG)*sinphi

c     Drehung um theta(imag)

        XXXLEN=XXLEN*costhe-YYLEN*sinthe
        YYYLEN=YYLEN*costhe+XXLEN*sinthe
        ZZZLEN=ZZLEN

      XXXLEN=DABS(XXXLEN)
      YYYLEN=DABS(YYYLEN)
      ZZZLEN=DABS(ZZZLEN)

C      xxxlen=xxlen
C      yyylen=yylen
C      zzzlen=zzlen

C22MAY97      if(   ( (dabs(dabs(theta(imag))-90.D0*GR).lt.small).or.
C22MAY97     &          (dabs(dabs(theta(imag))-270.D0*GR).lt.small)  ).and.
C22MAY97     &        ( (dabs(dabs(phi(imag))).lt.small).or.
C22MAY97     &          (dabs(dabs(phi(imag))-180.D0*GR).lt.small)  ) ) then

C           xxxlen=yylen
C           yyylen=xxlen
C           zzzlen=zzlen

C22MAY97      endif

C22MAY97      if(   ( (dabs(dabs(theta(imag))-90.D0*GR).lt.small).or.
C22MAY97     &          (dabs(dabs(theta(imag))-270.D0*GR).lt.small)  ).and.
C22MAY97     &        ( (dabs(dabs(phi(imag))-90.D0*GR).lt.small).or.
C22MAY97     &          (dabs(dabs(phi(imag))-270.D0*GR).lt.small)  ) ) then

CERROR  xxxlen=xxlen
CERROR   yyylen=zzlen
CERROR   zzzlen=yylen

C     xxxlen=yylen
C     yyylen=zzlen
C     zzzlen=xxlen

C22MAY97      endif

        X1=-XXXLEN/2.
        Y1=-YYYLEN/2.
        Z1=-ZZZLEN/2.

        X2=+XXXLEN/2.
        Y2=+YYYLEN/2.
        Z2=+ZZZLEN/2.

c     Verschiebung des Klotzes in den Koordinatenursprung
c     Neuberechnung des Aufpunktes

        x11=xb-dx(IMAG)
        y11=yb-dy(IMAG)
        z11=zb-dz(IMAG)

c     Drehung des Koordinatensystems
c     Neuberechnung des Aufpunktes
c     Drehung um phi(imag)

        x12=x11*cosphi+z11*sinphi
        y12=y11
        z12=z11*cosphi-x11*sinphi

c     Drehung um theta(imag)

        x=x12*costhe-y12*sinthe
        y=y12*costhe+x12*sinthe
        z=z12

        X1P=X-X1
        Y1P=Y-Y1
        Z1P=Z-Z1
C
        X2P=X-X2
        Y2P=Y-Y2
        Z2P=Z-Z2

        if(dabs(x1p).lt.small)x1p=small
        if(dabs(y1p).lt.small)y1p=small
        if(dabs(z1p).lt.small)z1p=small
        if(dabs(x2p).lt.small)x2p=small
        if(dabs(y2p).lt.small)y2p=small
        if(dabs(z2p).lt.small)z2p=small

C
        current=BC(IMAG)/XMUE0
        C1=(XMUE0/(4.D0*PI))*current
C
        S1=DSQRT(X2P*X2P+Y2P*Y2P+Z2P*Z2P)
        S2=DSQRT(X2P*X2P+Y1P*Y1P+Z2P*Z2P)
        S3=DSQRT(X2P*X2P+Y2P*Y2P+Z1P*Z1P)
        S4=DSQRT(X2P*X2P+Y1P*Y1P+Z1P*Z1P)
        S5=DSQRT(X1P*X1P+Y2P*Y2P+Z2P*Z2P)
        S6=DSQRT(X1P*X1P+Y1P*Y1P+Z2P*Z2P)
        S7=DSQRT(X1P*X1P+Y2P*Y2P+Z1P*Z1P)
        S8=DSQRT(X1P*X1P+Y1P*Y1P+Z1P*Z1P)
C
C  BX
C
        rr1=(Z1P+S3)*(Z2P+S2)*(Z2P+S5)*(Z1P+S8)
        rr2=(Z2P+S1)*(Z1P+S4)*(Z1P+S7)*(Z2P+S6)

        if((dabs(rr1).lt.small).and.(dabs(rr2).lt.small))then
          bxx=0.d0
        else
          BXX=C1*DLOG(rr1/rr2)
        endif

C
C    BY
C
        BYY=-C1*( DATAN(Z2P*Y2P/(X2P*S1))
     &    - DATAN(Z2P*Y1P/(X2P*S2))
     &    - DATAN(Z1P*Y2P/(X2P*S3))
     &    + DATAN(Z1P*Y1P/(X2P*S4)))
     &    +C1*( DATAN(Z2P*Y2P/(X1P*S5))
     &       - DATAN(Z2P*Y1P/(X1P*S6))
     &    - DATAN(Z1P*Y2P/(X1P*S7))
     &    + DATAN(Z1P*Y1P/(X1P*S8)))
     &    +C1*( DATAN(X2P*Y2P/(Z1P*S3))
     &    - DATAN(X1P*Y2P/(Z1P*S7))
     &    - DATAN(X2P*Y1P/(Z1P*S4))
     &    + DATAN(X1P*Y1P/(Z1P*S8)))
     &    -C1*( DATAN(X2P*Y2P/(Z2P*S1))
     &    - DATAN(X1P*Y2P/(Z2P*S5))
     &    - DATAN(X2P*Y1P/(Z2P*S2))
     &    + DATAN(X1P*Y1P/(Z2P*S6)))
C
C   BZ
C

c--------new 25.10.2002 Johannes Bahrdt
c     rr1=(X2P+S3)*(X1P+S8)*(X2P+S2)*(X1P+S5)
c     rr2=(X2P+S4)*(X1P+S7)*(X2P+S1)*(X1P+S6)
        zz1(1)=X2P+S3
        zz1(2)=X1P+S8
        zz1(3)=X2P+S2
        zz1(4)=X1P+S5

        zz2(1)=X2P+S4
        zz2(2)=X1P+S7
        zz2(3)=X2P+S1
        zz2(4)=X1P+S6

c     expansion of zz1 etc
c     zz1exp(1)=(Y2P*Y2P+Z1P*Z1P)/(2.*x2p)
c     zz1exp(2)=(Y1P*Y1P+Z1P*Z1P)/(2.*x1p)
c     zz1exp(3)=(Y1P*Y1P+Z2P*Z2P)/(2.*x2p)
c     zz1exp(4)=(Y2P*Y2P+Z2P*Z2P)/(2.*x1p)

c     zz2exp(1)=(Y1P*Y1P+Z1P*Z1P)/(2.*x2p)
c     zz2exp(2)=(Y2P*Y2P+Z1P*Z1P)/(2.*x1p)
c     zz2exp(3)=(Y2P*Y2P+Z2P*Z2P)/(2.*x2p)
c     zz2exp(4)=(Y1P*Y1P+Z2P*Z2P)/(2.*x1p)

        zz1exp(1)=1.d0/x2p
        zz1exp(2)=1.d0/x1p
        zz1exp(3)=1.d0/x2p
        zz1exp(4)=1.d0/x1p

        zz2exp(1)=1.d0/x2p
        zz2exp(2)=1.d0/x1p
        zz2exp(3)=1.d0/x2p
        zz2exp(4)=1.d0/x1p

        iz1=0
        iz2=0
        do i=1,4
          if(dabs(zz1(i)).lt.small)then
            iz1=iz1+1
            zz1(i)=zz1exp(i)
          endif
          if(dabs(zz2(i)).lt.small)then
            iz2=iz2+1
            zz2(i)=zz2exp(i)
          endif
        enddo

        if(iz1.eq.iz2)then
          rr1=zz1(1)*zz1(2)*zz1(3)*zz1(4)
          rr2=zz2(1)*zz2(2)*zz2(3)*zz2(4)
        endif
        if(iz1.gt.iz2)then
          rr1=0.
          rr2=1.
        endif
        if(iz1.lt.iz2)then
          rr1=0.
          rr2=0.
          WRITE(6,*)
          WRITE(6,*) '*** WARNING IN REC_BFELD'
          WRITE(6,*) 'BZ SET TO ZERO'
          WRITE(6,*)
        endif

c-------------- end changes 25.10.2002

        rr1=(X2P+S3)*(X1P+S8)*(X2P+S2)*(X1P+S5)
        rr2=(X2P+S4)*(X1P+S7)*(X2P+S1)*(X1P+S6)

        if((dabs(rr1).lt.small).and.(dabs(rr2).lt.small))then
          bzz=0.d0
        else
          BZZ=C1*DLOG(rr1/rr2)
        endif

c     Rueckdrehung des Koordinatensystems
c     Drehung um theta(imag)
        Bxxx=Bxx*costhe+Byy*sinthe
        Byyy=Byy*costhe-Bxx*sinthe
        Bzzz=Bzz

c     Rueckdrehung um phi(imag)
        Bx=Bx+Bxxx*cosphi-Bzzz*sinphi
        By=By+Byyy
        Bz=Bz+Bzzz*cosphi+Bxxx*sinphi

c      print*,xb,imag,bxxx,byyy,bzzz

      enddo

      XBOLD=XB
      IMAGOLD=IMAG1

      return
      end
+DECK,REC_HELI.
*CMZ :  4.00/15 27/04/2022  08.30.53  by  Michael Scheer
*CMZ :  3.06/00 15/02/2019  17.36.39  by  Michael Scheer
*CMZ :  3.03/02 04/03/2016  18.30.51  by  Michael Scheer
*CMZ :  3.00/01 26/03/2013  20.22.51  by  Michael Scheer
*CMZ :  2.42/00 06/09/2002  14.55.56  by  Michael Scheer
*CMZ :  2.41/13 03/09/2002  13.42.24  by  Michael Scheer
*CMZ :  2.41/11 20/08/2002  17.46.17  by  Michael Scheer
*CMZ :  2.16/04 20/06/2000  17.41.11  by  Michael Scheer
*CMZ :  2.16/00 24/05/2000  18.51.59  by  Michael Scheer
*CMZ :  2.15/00 19/05/2000  10.49.29  by  Michael Scheer
*CMZ :  2.14/02 25/04/2000  17.26.31  by  Michael Scheer
*CMZ :  2.14/00 18/04/2000  17.48.40  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE REC_HELI(IUREC,GRARAD,ISIDE,ISHIFT,JSHIFT)
+seq,gplhint.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,KLOTZ.

      DOUBLE PRECISION RECEND,TOTLEN,TOTLEN2,GRARAD,DX1,BCS(NKLOTZ)

      REAL XRAN(NKLOTZ),YRAN(NKLOTZ),rr(2)
      INTEGER IPER,IUREC,ISIDE,JSHIFT,ISHIFT,I,N,IMAGTOTO,IMAGTOTS

      IMAGTOTS=IMAGTOT

      TOTLEN=(2+KRECPER(IUREC))*4.D0*URECLX(IUREC)
      TOTLEN2=TOTLEN/2.D0
      RECEND=URECCX(IUREC)-TOTLEN2

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF

      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=270.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*ISHIFT
      DX1=DX(IMAGTOT)
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=(URECCZ(IUREC)-(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      BC(IMAGTOT)=-URECBC(IUREC)/4.D0
      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=90.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*JSHIFT
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)))
      DZ(IMAGTOT)=(URECCZ(IUREC)+(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      DX(IMAGTOT)=DX(IMAGTOT)+URSHADD(IUREC)
      BC(IMAGTOT)=-URECBC(IUREC)/4.D0
      RECEND=RECEND+XLEN(IMAGTOT)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=0.D0
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*ISHIFT
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=(URECCZ(IUREC)-(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      BC(IMAGTOT)=-URECBC(IUREC)/4.D0
      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=0.D0
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*JSHIFT
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)))
      DZ(IMAGTOT)=(URECCZ(IUREC)+(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      DX(IMAGTOT)=DX(IMAGTOT)+URSHADD(IUREC)
      BC(IMAGTOT)=-URECBC(IUREC)/4.D0
      RECEND=RECEND+XLEN(IMAGTOT)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=90.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*ISHIFT
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=(URECCZ(IUREC)-(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      BC(IMAGTOT)=-URECBC(IUREC)/4.D0
      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=270.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*JSHIFT
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)))
      DZ(IMAGTOT)=(URECCZ(IUREC)+(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      DX(IMAGTOT)=DX(IMAGTOT)+URSHADD(IUREC)
      BC(IMAGTOT)=-URECBC(IUREC)/4.D0
      RECEND=RECEND+XLEN(IMAGTOT)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=90.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*ISHIFT
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=(URECCZ(IUREC)-(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      BC(IMAGTOT)=-URECBC(IUREC)*0.75D0
      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=270.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*JSHIFT
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)))
      DZ(IMAGTOT)=(URECCZ(IUREC)+(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      DX(IMAGTOT)=DX(IMAGTOT)+URSHADD(IUREC)
      BC(IMAGTOT)=-URECBC(IUREC)*0.75D0
      RECEND=RECEND+XLEN(IMAGTOT)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=180.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*ISHIFT
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=(URECCZ(IUREC)-(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      BC(IMAGTOT)=-URECBC(IUREC)*0.75D0
      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=180.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*JSHIFT
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)))
      DZ(IMAGTOT)=(URECCZ(IUREC)+(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      DX(IMAGTOT)=DX(IMAGTOT)+URSHADD(IUREC)
      BC(IMAGTOT)=-URECBC(IUREC)*0.75D0
      RECEND=RECEND+XLEN(IMAGTOT)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=270.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*ISHIFT
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=(URECCZ(IUREC)-(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      BC(IMAGTOT)=-URECBC(IUREC)*0.75D0
      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=90.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*JSHIFT
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)))
      DZ(IMAGTOT)=(URECCZ(IUREC)+(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      DX(IMAGTOT)=DX(IMAGTOT)+URSHADD(IUREC)
      BC(IMAGTOT)=-URECBC(IUREC)*0.75D0
      RECEND=RECEND+XLEN(IMAGTOT)

      IMAGTOTO=IMAGTOT
      DO IPER=1,KRECPER(IUREC)

          IMAGTOT=IMAGTOT+1
            IF(IMAGTOT.GT.NKLOTZ) THEN
                WRITE(6,*)
                WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
                WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
                WRITE(6,*)
                STOP
            ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=90.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*ISHIFT
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=(URECCZ(IUREC)-(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      BC(IMAGTOT)=URECBC(IUREC)

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF

      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=270.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*JSHIFT
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)))
      DZ(IMAGTOT)=(URECCZ(IUREC)+(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      DX(IMAGTOT)=DX(IMAGTOT)+URSHADD(IUREC)
      BC(IMAGTOT)=URECBC(IUREC)
      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)
      RECEND=RECEND+XLEN(IMAGTOT)

        IMAGTOT=IMAGTOT+1
        IF(IMAGTOT.GT.NKLOTZ) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
          WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
          WRITE(6,*)
          STOP
        ENDIF

      XLEN(IMAGTOT)=URECLX(IUREC)
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=180.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*ISHIFT
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=(URECCZ(IUREC)-(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      BC(IMAGTOT)=URECBC(IUREC)

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF

      XLEN(IMAGTOT)=URECLX(IUREC)
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=180.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*JSHIFT
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)))
      DZ(IMAGTOT)=(URECCZ(IUREC)+(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      DX(IMAGTOT)=DX(IMAGTOT)+URSHADD(IUREC)
      BC(IMAGTOT)=URECBC(IUREC)
      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)
      RECEND=RECEND+XLEN(IMAGTOT)

        IMAGTOT=IMAGTOT+1
        IF(IMAGTOT.GT.NKLOTZ) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
          WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
          WRITE(6,*)
          STOP
        ENDIF

        XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=270.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*ISHIFT
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=(URECCZ(IUREC)-(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      BC(IMAGTOT)=URECBC(IUREC)
      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

        IMAGTOT=IMAGTOT+1
        IF(IMAGTOT.GT.NKLOTZ) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
          WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
          WRITE(6,*)
          STOP
        ENDIF

        XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=90.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*JSHIFT
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)))
      DZ(IMAGTOT)=(URECCZ(IUREC)+(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      DX(IMAGTOT)=DX(IMAGTOT)+URSHADD(IUREC)
      BC(IMAGTOT)=URECBC(IUREC)

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      RECEND=RECEND+XLEN(IMAGTOT)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF

      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=270.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*ISHIFT
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=(URECCZ(IUREC)-(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      BC(IMAGTOT)=URECBC(IUREC)

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF

      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=90.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*JSHIFT
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)))
      DZ(IMAGTOT)=(URECCZ(IUREC)+(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      DX(IMAGTOT)=DX(IMAGTOT)+URSHADD(IUREC)
      BC(IMAGTOT)=URECBC(IUREC)

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      RECEND=RECEND+XLEN(IMAGTOT)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF

      XLEN(IMAGTOT)=URECLX(IUREC)
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=0.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*ISHIFT
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=(URECCZ(IUREC)-(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      BC(IMAGTOT)=URECBC(IUREC)
      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

        IMAGTOT=IMAGTOT+1
        IF(IMAGTOT.GT.NKLOTZ) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
          WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
          WRITE(6,*)
          STOP
        ENDIF

        XLEN(IMAGTOT)=URECLX(IUREC)
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=0.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*JSHIFT
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)))
      DZ(IMAGTOT)=(URECCZ(IUREC)+(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      DX(IMAGTOT)=DX(IMAGTOT)+URSHADD(IUREC)
      BC(IMAGTOT)=URECBC(IUREC)
      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)
      RECEND=RECEND+XLEN(IMAGTOT)

        IMAGTOT=IMAGTOT+1
        IF(IMAGTOT.GT.NKLOTZ) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
          WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
          WRITE(6,*)
          STOP
        ENDIF

        XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=90.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*ISHIFT
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=(URECCZ(IUREC)-(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      BC(IMAGTOT)=URECBC(IUREC)
        dmupar(IMAGTOT)=URECmupar(IUREC)
        dmuper(IMAGTOT)=URECmuper(IUREC)

        IMAGTOT=IMAGTOT+1
        IF(IMAGTOT.GT.NKLOTZ) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
          WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
          WRITE(6,*)
          STOP
        ENDIF

        XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=270.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*JSHIFT
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)))
      DZ(IMAGTOT)=(URECCZ(IUREC)+(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      DX(IMAGTOT)=DX(IMAGTOT)+URSHADD(IUREC)
      BC(IMAGTOT)=URECBC(IUREC)

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      RECEND=RECEND+XLEN(IMAGTOT)

      ENDDO !KRECPER

      IF (NURANMOD.EQ.1) THEN
        CALL RNORML(XRAN,NKLOTZ,rr)
        DO I=1,NKLOTZ
1         IF (ABS(XRAN(I)).GT.BCRANSIG) THEN
            CALL RNORML(XRAN(I),1,rr)
            GOTO 1
          ENDIF
        ENDDO
        IF (BCRAN.GE.0.D0) THEN
          DO I=1,NKLOTZ
            YRAN(I)=XRAN(I)*BCRAN
          ENDDO
        ELSE
          DO I=1,NKLOTZ
            YRAN(I)=-BCRAN
          ENDDO
        ENDIF
        DO I=IMAGTOTO+1,IMAGTOTO+6
          XRAN(I)=YRAN(I+6)/2.
          YRAN(I)=0.D0
        ENDDO  !IMAG
        DO I=IMAGTOT-5,IMAGTOT
          YRAN(I)=0.D0
        ENDDO  !IMAG
        DO I=IMAGTOTO+7,IMAGTOT-6
          XRAN(I)=YRAN(I)+YRAN(I-6)/2.+YRAN(I+6)/2. ! "+" due to angles
        ENDDO  !IMAG
        DO I=IMAGTOT-5,IMAGTOT
          XRAN(I)=YRAN(I-6)/2.
        ENDDO  !IMAG
        DO I=IMAGTOTO+1,IMAGTOT
          IF (DX(I)-XLEN(I)/2.D0.GE.BCSTART
     &        .AND.DX(I)+XLEN(I)/2.D0.LE.BCEND) THEN
            BC(I)=BC(I)*(1.+XRAN(I))
          ENDIF
        ENDDO  !IMAG
      ELSE IF (NURANMOD.EQ.2) THEN
        CALL RNORML(XRAN,NKLOTZ,rr)
        DO I=1,NKLOTZ
11        IF (ABS(XRAN(I)).GT.BCRANSIG) THEN
            CALL RNORML(XRAN(I),1,rr)
            GOTO 11
          ENDIF
        ENDDO
        IF (BCRAN.GE.0.D0) THEN
          DO I=1,NKLOTZ
            YRAN(I)=XRAN(I)*BCRAN
          ENDDO
        ELSE
          DO I=1,NKLOTZ
            YRAN(I)=-BCRAN
          ENDDO
        ENDIF
        DO I=IMAGTOT-5,IMAGTOT
          YRAN(I)=0.D0
        ENDDO  !IMAG
        DO I=IMAGTOTO+1,IMAGTOT-6
          XRAN(I)=YRAN(I)+YRAN(I+6) ! "+" due to angles
        ENDDO  !IMAG
        DO I=IMAGTOT-5,IMAGTOT
          XRAN(I)=YRAN(I-6)
        ENDDO  !IMAG
        DO I=IMAGTOTO+1,IMAGTOT
          IF (DX(I)-XLEN(I)/2.D0.GE.BCSTART
     &        .AND.DX(I)+XLEN(I)/2.D0.LE.BCEND) THEN
            BC(I)=BC(I)*(1.+XRAN(I))
          ENDIF
        ENDDO  !IMAG
      ENDIF !(NRANMOD.EQ.1)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=90.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*ISHIFT
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=(URECCZ(IUREC)-(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      BC(IMAGTOT)=URECBC(IUREC)*0.75D0

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=270.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*JSHIFT
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)))
      DZ(IMAGTOT)=(URECCZ(IUREC)+(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      DX(IMAGTOT)=DX(IMAGTOT)+URSHADD(IUREC)
      BC(IMAGTOT)=URECBC(IUREC)*0.75D0

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      RECEND=RECEND+XLEN(IMAGTOT)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF

      XLEN(IMAGTOT)=URECLX(IUREC)
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=180.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*ISHIFT
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=(URECCZ(IUREC)-(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      BC(IMAGTOT)=URECBC(IUREC)*0.75D0

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=180.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*JSHIFT
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)))
      DZ(IMAGTOT)=(URECCZ(IUREC)+(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      DX(IMAGTOT)=DX(IMAGTOT)+URSHADD(IUREC)
      BC(IMAGTOT)=URECBC(IUREC)*0.75D0

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      RECEND=RECEND+XLEN(IMAGTOT)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=270.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*ISHIFT
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=(URECCZ(IUREC)-(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      BC(IMAGTOT)=URECBC(IUREC)*0.75D0

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=90.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*JSHIFT
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)))
      DZ(IMAGTOT)=(URECCZ(IUREC)+(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      DX(IMAGTOT)=DX(IMAGTOT)+URSHADD(IUREC)
      BC(IMAGTOT)=URECBC(IUREC)*0.75D0

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      RECEND=RECEND+XLEN(IMAGTOT)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=270.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*ISHIFT
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=(URECCZ(IUREC)-(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      BC(IMAGTOT)=URECBC(IUREC)/4.D0

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=90.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*JSHIFT
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)))
      DZ(IMAGTOT)=(URECCZ(IUREC)+(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      DX(IMAGTOT)=DX(IMAGTOT)+URSHADD(IUREC)
      BC(IMAGTOT)=URECBC(IUREC)/4.D0

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      RECEND=RECEND+XLEN(IMAGTOT)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=0.D0
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*ISHIFT
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=(URECCZ(IUREC)-(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      BC(IMAGTOT)=URECBC(IUREC)/4.D0

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=0.D0
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*JSHIFT
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)))
      DZ(IMAGTOT)=(URECCZ(IUREC)+(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      DX(IMAGTOT)=DX(IMAGTOT)+URSHADD(IUREC)
      BC(IMAGTOT)=URECBC(IUREC)/4.D0

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      RECEND=RECEND+XLEN(IMAGTOT)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=90.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*ISHIFT
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=(URECCZ(IUREC)-(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      BC(IMAGTOT)=URECBC(IUREC)/4.D0

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=270.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0+URSHIFT(IUREC)*JSHIFT
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+(URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)))
      DZ(IMAGTOT)=(URECCZ(IUREC)+(URECLZ(IUREC)+URSPLIT(IUREC))/2.D0)*ISIDE
      DX(IMAGTOT)=DX(IMAGTOT)+URSHADD(IUREC)
      BC(IMAGTOT)=URECBC(IUREC)/4.D0

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      RECEND=RECEND+XLEN(IMAGTOT)

      IF (BCRAN.NE.0.D0) THEN

C--- NURANMOD.EQ.3.OR.NURANMOD.EQ.4

        IF (NURANMOD.EQ.3.OR.NURANMOD.EQ.4) THEN

          N=0
          DO I=IMAGTOTS+1,IMAGTOT,2
            N=N+1
            BCS(N)=BC(I)
          ENDDO

          CALL REC_UBCERROR(N,BCS,NURANMOD,BCRAN,BCRANSIG)

          N=0
          DO I=IMAGTOTS+1,IMAGTOT,2
            N=N+1
            BC(I)=BCS(N)
          ENDDO

          N=0
          DO I=IMAGTOTS+2,IMAGTOT,2
            N=N+1
            BCS(N)=BC(I)
          ENDDO

          CALL REC_UBCERROR(N,BCS,NURANMOD,BCRAN,BCRANSIG)

          N=0
          DO I=IMAGTOTS+2,IMAGTOT,2
            N=N+1
            BC(I)=BCS(N)
          ENDDO

        ENDIF  !(NURANMOD.EQ.3.OR.NURANMOD.EQ.4)
      ENDIF !(BCRAN.NE.0.D0)

      IF (UBANGERR(IUREC).NE.0) THEN

C--- NURANMOD.EQ.3.OR.NURANMOD.EQ.4

      IF (NURANMOD.EQ.3.OR.NURANMOD.EQ.4) THEN

            IF(IMAGTOTS+2*(IMAGTOT-IMAGTOTS).GT.NKLOTZ) THEN
                WRITE(6,*)
                WRITE(6,*)'*** ERROR IN REC_HELI: DIMENSION EXCEEDED ***'
                WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
                WRITE(6,*)
                STOP
            ENDIF

          N=IMAGTOT
          DO I=IMAGTOTS+1,IMAGTOT
         N=N+1
                XLEN(N)=XLEN(I)
                YLEN(N)=YLEN(I)
                ZLEN(N)=ZLEN(I)
                DX(N)=DX(I)
                DY(N)=DY(I)
                DZ(N)=DZ(I)
                THETA(N)=90.D0*GRARAD
                PHI(N)=90.D0*GRARAD
                BC(N)=BC(I)
          ENDDO

          N=IMAGTOT-IMAGTOTS
          IMAGTOTS=IMAGTOTS+N
          IMAGTOT=IMAGTOTS+N

          N=0
          DO I=IMAGTOTS+1,IMAGTOT,2
         N=N+1
                BCS(N)=BC(I)
          ENDDO

            CALL REC_UBANGERROR(N,BCS,NURANMOD,UBANGERR(IUREC),
     &        ubansig(iurec),USIGOFFY(IUREC))

          N=0
          DO I=IMAGTOTS+1,IMAGTOT,2
         N=N+1
                BC(I)=BCS(N)
          ENDDO

          N=0
          DO I=IMAGTOTS+2,IMAGTOT,2
         N=N+1
                BCS(N)=BC(I)
          ENDDO

            CALL REC_UBANGERROR(N,BCS,NURANMOD,UBANGERR(IUREC),
     &        ubansig(iurec),USIGOFFY(IUREC))

          N=0
          DO I=IMAGTOTS+2,IMAGTOT,2
         N=N+1
                BC(I)=BCS(N)
          ENDDO

      ENDIF !(NURANMOD.EQ.3.OR.NURANMOD.EQ.4)
      ENDIF !(BCRAN.NE.0.D0)

      RETURN
      END
+DECK,REC_INIT.
*CMZ :  4.00/15 27/04/2022  08.35.57  by  Michael Scheer
*CMZ :  4.00/13 10/11/2021  16.56.28  by  Michael Scheer
*CMZ :  4.00/07 04/06/2020  16.23.19  by  Michael Scheer
*CMZ :  4.00/04 17/05/2019  14.22.20  by  Michael Scheer
*CMZ :  3.06/00 18/02/2019  17.12.04  by  Michael Scheer
*CMZ :  3.05/10 13/08/2018  14.40.26  by  Michael Scheer
*CMZ :  3.03/04 29/11/2017  11.56.17  by  Michael Scheer
*CMZ :  3.03/02 04/03/2016  18.03.53  by  Michael Scheer
*CMZ :  3.02/03 03/11/2014  12.08.57  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.63/05 22/07/2009  07.54.21  by  Michael Scheer
*CMZ :  2.63/04 22/07/2009  07.39.04  by  Michael Scheer
*CMZ :  2.63/03 02/06/2009  16.18.47  by  Michael Scheer
*CMZ :  2.62/02 06/06/2007  11.45.09  by  Michael Scheer
*CMZ :  2.61/05 12/04/2007  09.30.49  by  Michael Scheer
*CMZ :  2.61/04 29/03/2007  16.05.58  by  Michael Scheer
*CMZ :  2.58/00 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.57/05 14/12/2006  10.21.21  by  Michael Scheer
*CMZ :  2.48/04 12/03/2004  15.40.31  by  Michael Scheer
*CMZ :  2.42/00 03/09/2002  15.19.21  by  Michael Scheer
*CMZ :  2.41/13 03/09/2002  14.27.45  by  Michael Scheer
*CMZ :  2.41/12 22/08/2002  10.56.13  by  Michael Scheer
*CMZ :  2.41/11 21/08/2002  10.55.08  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.02  by  Michael Scheer
*CMZ :  2.41/08 14/08/2002  17.00.53  by  Michael Scheer
*CMZ :  2.39/00 14/01/2002  14.35.25  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.20/10 04/04/2001  18.24.16  by  Michael Scheer
*CMZ :  2.20/09 03/04/2001  14.30.31  by  Michael Scheer
*CMZ :  2.15/01 28/03/2001  13.23.50  by  Michael Scheer
*CMZ :  2.20/05 13/03/2001  13.41.14  by  Michael Scheer
*CMZ :  2.16/07 22/09/2000  10.44.05  by  Michael Scheer
*CMZ :  2.16/04 20/06/2000  17.04.46  by  Michael Scheer
*CMZ :  2.15/00 19/05/2000  11.01.39  by  Michael Scheer
*CMZ :  2.14/02 25/04/2000  17.04.16  by  Michael Scheer
*CMZ :  2.14/01 19/04/2000  13.47.47  by  Michael Scheer
*CMZ :  2.14/00 18/04/2000  18.12.12  by  Michael Scheer
*CMZ :  2.13/11 19/03/2000  12.48.34  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  11.45.40  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.26.25  by  Michael Scheer
*CMZ :  1.03/06 05/08/98  17.54.46  by  Michael Scheer
*CMZ :  1.02/03 14/01/98  10.03.25  by  Michael Scheer
*CMZ :  1.02/00 18/12/97  11.55.11  by  Michael Scheer
*CMZ :  1.01/00 28/10/97  18.46.15  by  Michael Scheer
*CMZ :  1.00/00 10/07/97  17.39.21  by  Michael Scheer
*CMZ : 00.01/10 02/06/96  12.33.40  by  Michael Scheer
*CMZ : 00.01/08 29/06/95  10.57.36  by  Michael Scheer
*CMZ : 00.01/07 22/03/95  15.54.56  by  Michael Scheer
*CMZ : 00.00/01 03/03/95  15.56.37  by  Michael Scheer
*CMZ : 00.00/00 03/03/95  15.50.11  by  Johannes Bahrdt
*-- Author : Michael Scheer
      SUBROUTINE REC_INIT
+seq,gplhint.

C*****************************************************************
c       Berechnung des Magnetfeldes eines Arrays von
c       mehreren Permanentmagnetkloetzen
c*****************************************************************

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,MYFILES.
+SEQ,CONTRL.
+SEQ,KLOTZ.
+SEQ,MODULATOR.

      INTEGER IANZX,IANZZ,I,IMAG,IIMOD,II,ICAL,IUREC

C        DOUBLE PRECISION bxfield(501,41),byfield(501,41),bzfield(501,41)
      DOUBLE PRECISION XMUE0,PI,GRARAD,XSHIFT,YSHIFT,ZSHIFT
      DOUBLE PRECISION XMIN,XMAX,ZMIN,ZMAX,DELTAX,DELTAZ
      DOUBLE PRECISION OFFX,OFFX_I,OFFX_E

      INTEGER IMAGUP_I,IMAGLO_I,IMAGNET_I,IMOD_I
      DOUBLE PRECISION XLEN_I,YLEN_I,ZLEN_I,SHIFT_IU,SHIFT_ID
      DOUBLE PRECISION DUP_I,DLO_I
      DOUBLE PRECISION DX0_I(NKLOTZ),DY0_I(NKLOTZ),DZ0_I(NKLOTZ)
      DOUBLE PRECISION THETA0_I(NKLOTZ),PHI0_I(NKLOTZ),BC0_I(NKLOTZ)
      DOUBLE PRECISION DDX_I(NKLOTZ),DDY_I(NKLOTZ),DDZ_I(NKLOTZ)

      INTEGER IMAGUP_E,IMAGLO_E,IMAGNET_E,IMOD_E
      DOUBLE PRECISION XLEN_E,YLEN_E,ZLEN_E,SHIFT_EU,SHIFT_ED
      DOUBLE PRECISION DUP_E,DLO_E
      DOUBLE PRECISION DX0_E(NKLOTZ),DY0_E(NKLOTZ),DZ0_E(NKLOTZ)
      DOUBLE PRECISION THETA0_E(NKLOTZ),PHI0_E(NKLOTZ),BC0_E(NKLOTZ)
      DOUBLE PRECISION DDX_E(NKLOTZ),DDY_E(NKLOTZ),DDZ_E(NKLOTZ)

      INTEGER IMAGTOTS
      DOUBLE PRECISION XLENS(NKLOTZ),YLENS(NKLOTZ),ZLENS(NKLOTZ)
      DOUBLE PRECISION DXS(NKLOTZ),DYS(NKLOTZ),DZS(NKLOTZ)
      DOUBLE PRECISION THETAS(NKLOTZ),PHIS(NKLOTZ),BCS(NKLOTZ)
      DOUBLE PRECISION FTX(NKLOTZ),FTY(NKLOTZ),FT2(NKLOTZ),XSCL,TSCL,DYFT
      DOUBLE PRECISION F1(NKLOTZ),F2(NKLOTZ),F3(NKLOTZ),F4(NKLOTZ)

      DOUBLE PRECISION XLEN_A,YLEN_A,ZLEN_A,COSPHI,SINPHI,SINTHE,COSTHE

      REAL xran(1),xranO,VBX,VBY,VBZ,B0,rr(2)
      INTEGER NTOTIN,NTOT2IN,NFUNTAP

      CHARACTER(2) CSTAR
      CHARACTER(80) COMTAP

      DATA ICAL/0/
      DATA PI/3.141592653589793D0/

      IF (ICAL.NE.0) RETURN

      irecsolve=0

      ICAL=1

      IF (BCSTART.EQ.9999.) BCSTART=-1.D10
      IF (BCEND.EQ.9999.) BCEND=1.D10
      IF (BCRANSIG.LE.0.0) BCRANSIG=1.E10

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'      SR REC_INIT: REC-structure read from file'
      WRITE(LUNGFO,*)'      ',FILEREC
      WRITE(LUNGFO,*)'      WINREC,RANGREC:'
      WRITE(LUNGFO,*)'      ',WINREC,RANGREC
      WRITE(LUNGFO,*)'      BCRAN, BCRANSIG:'
      WRITE(LUNGFO,*)'      ',BCRAN,BCRANSIG
      WRITE(LUNGFO,*)'      K90270:'
      WRITE(LUNGFO,*)'      ',K90270
      WRITE(LUNGFO,*)'      IRECSEED, NURANMOD:'
      WRITE(LUNGFO,*)'      ',IRECSEED,NURANMOD
      WRITE(LUNGFO,*)'      BCSTART, BCEND:'
      WRITE(LUNGFO,*)'      ',BCSTART, BCEND
      WRITE(LUNGFO,*)'      SCALKL,SCALADD:'
      WRITE(LUNGFO,*)'      ',SCALKL,SCALADD
      WRITE(LUNGFO,*)'      RECGAP:',RECGAP
      WRITE(LUNGFO,*)'      USHIFT,DSHIFT:'
      WRITE(LUNGFO,*)'      ',USHIFT,DSHIFT
      WRITE(LUNGFO,*)

      IF (IRECSEED.NE.0) CALL RMARIN(IRECSEED,NTOTIN,NTOT2IN) !CERN V113

      IF (IRECU.NE.0) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'      Parameter for additional undulators:'
        WRITE(LUNGFO,*)

        DO IUREC=1,IRECU

          IF (ubansig(iurec).LE.0.0) ubansig(iurec)=1.0E10

          IF (USIGOFFY(IRECU).EQ.0.D0) THEN
            USIGOFFY(IRECU)=1.D30
          ENDIF

          if (urecmupar(irecu).eq.0.0d0) urecmupar(irecu)=1.0d0
          if (urecmuper(irecu).eq.0.0d0) urecmuper(irecu)=1.0d0

c          if (urecmupar(irecu).ne.1.0d0) irecsolve=1
c          if (urecmuper(irecu).ne.1.0d0) irecsolve=1

          WRITE(LUNGFO,*)'      KRECPER:',KRECPER(IRECU)
          WRITE(LUNGFO,*)'      URECLX:',URECLX(IRECU)
          WRITE(LUNGFO,*)'      URECLY:',URECLY(IRECU)
          WRITE(LUNGFO,*)'      URECLZ:',URECLZ(IRECU)
          WRITE(LUNGFO,*)'      URECGAP:',URECGAP(IRECU)
          WRITE(LUNGFO,*)'      UTAPER:',UTAPER(IRECU)
          WRITE(LUNGFO,*)'      URECCX:',URECCX(IRECU)
          WRITE(LUNGFO,*)'      URECCZ:',URECCZ(IRECU)
          WRITE(LUNGFO,*)'      URECBC:',URECBC(IRECU)
c         WRITE(LUNGFO,*)'      URECMUPAR:',URECmupar(IRECU)
c          WRITE(LUNGFO,*)'      URECMUPER:',URECmuper(IRECU)
          WRITE(LUNGFO,*)'      UBANGERR:',UBANGERR(IRECU)
          WRITE(LUNGFO,*)'      UBANSIG:',UBANSIG(IRECU)
          WRITE(LUNGFO,*)'      USIGOFFY:',USIGOFFY(IRECU)
          WRITE(LUNGFO,*)'      IUHELI:',IUHELI(IRECU)
          WRITE(LUNGFO,*)'      URSPLIT:',URSPLIT(IRECU)
          WRITE(LUNGFO,*)'      URSHIFT:',URSHIFT(IRECU)
          WRITE(LUNGFO,*)'      URSHADD:',URSHADD(IRECU)
        ENDDO

      ENDIF

      xmue0=1.2566d-6
      grarad=pi/180.d0

      IF (IKRESTOR.LE.0) THEN

        IF (SCALADD.NE.0.D0.OR.SCALKL.NE.0.D0) THEN
+SELF,IF=VMS.
          open(unit=LUNREC,file=FILEREC,status='old',readonly)
+SELF.

+SELF,IF=LINUX,WINDOWS,HPUX,TRUE64.
          open(unit=LUNREC,file=FILEREC,status='old')
+SELF.

          call util_skip_comment(lunrec)
          read(LUNREC,*)xmin,xmax,ianzx
          call util_skip_comment(lunrec)
          read(LUNREC,*)zmin,zmax,ianzz
          if(ianzx.eq.1)then
            deltax=0.
          else
            deltax=(xmax-xmin)/FLOAT(ianzx-1)
          endif
          if(ianzz.eq.1)then
            deltaz=0.
          else
            deltaz=(zmax-zmin)/FLOAT(ianzz-1)
          endif
          call util_skip_comment(lunrec)
          read(LUNREC,*)xlen(1),ylen(1),zlen(1)
          call util_skip_comment(lunrec)
          read(LUNREC,*)shift_U
          IF (SHIFT_U.EQ.9999.) THEN
            SHIFT_U=USHIFT
          ELSE IF (SHIFT_U.EQ.-9999.) THEN
            SHIFT_U=-USHIFT
          ENDIF
          call util_skip_comment(lunrec)
          read(LUNREC,*)imagup
          IF(IMAGUP.GT.NKLOTZ) THEN
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN REC_INIT: DIMENSION EXCEEDED ***'
            WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
            WRITE(6,*)
            STOP
          ENDIF
          call util_skip_comment(lunrec)
          read(LUNREC,*)dup
          IF (DUP.EQ.9999.) DUP=RECGAP
          IF (DUP.EQ.-9999.) DUP=-RECGAP
          do i=1,imagup
            call util_skip_comment(lunrec)
            read(LUNREC,*)theta0(i),phi0(i),bc0(i)
            BC0(I)=BC0(I)*SCALKL
            theta0(i)=theta0(i)*grarad
            phi0(i)=phi0(i)*grarad
            call util_skip_comment(lunrec)
            read(LUNREC,*)dx0(i),dy0(i),dz0(i)
            dy0(i)=dy0(i)+(dup+0.5*ylen(1))/ylen(1)
          enddo

          call util_skip_comment(lunrec)
          read(LUNREC,*)shift_D
          IF (SHIFT_D.EQ.9999.) THEN
            SHIFT_D=DSHIFT
          ELSE IF (SHIFT_D.EQ.-9999.) THEN
            SHIFT_D=-DSHIFT
          ELSE IF (SHIFT_D.EQ.8888.) THEN
            SHIFT_D=-2.D0*SHIFT_U
          ENDIF
          call util_skip_comment(lunrec)
          read(LUNREC,*)imaglo
          IF(IMAGUP+IMAGLO.GT.NKLOTZ) THEN
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN REC_INIT: DIMENSION EXCEEDED ***'
            WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
            WRITE(6,*)
            STOP
          ENDIF
          call util_skip_comment(lunrec)
          read(LUNREC,*)dlo
          IF (DLO.EQ.9999.) DLO=RECGAP
          IF (DLO.EQ.-9999.) DLO=-RECGAP
          do i=1,imaglo
            call util_skip_comment(lunrec)
            read(LUNREC,*)theta0(i+imagup),phi0(i+imagup),bc0(i+imagup)
            BC0(I+IMAGUP)=BC0(I+IMAGUP)*SCALKL
            theta0(i+imagup)=theta0(i+imagup)*grarad
            phi0(i+imagup)=phi0(i+imagup)*grarad
            call util_skip_comment(lunrec)
            read(LUNREC,*)dx0(i+imagup),dy0(i+imagup),dz0(i+imagup)
            dy0(i+imagup)=dy0(i+imagup)+(dlo-0.5*ylen(1))/ylen(1)
          enddo

          do i=1,imagup/2
            dx0(i)=dx0(i)+shift_U/XLEN(1)
          enddo

          do i=imagup+imaglo/2+1,imagup+imaglo
            dx0(i)=dx0(i)+shift_U/XLEN(1)+SHIFT_D/XLEN(1)
          enddo

          imagnet=imagup+imaglo

          call util_skip_comment(lunrec)
          read(LUNREC,*)imod,OFFX
          IF(IMAGNET*IMOD.GT.NKLOTZ) THEN
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN REC_INIT: DIMENSION EXCEEDED ***'
            WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
            WRITE(6,*)
            STOP
          ENDIF
          do i=1,imod
            call util_skip_comment(lunrec)
            read(LUNREC,*)ddx(i),ddy(i),ddz(i)
            DDX(I)=DDX(I)+OFFX/XLEN(1)
          enddo

c************************************************************

c End poles

          IMAGTOT=IMOD*IMAGNET

          call util_skip_comment(lunrec)
          READ(LUNREC,*)XLEN_I,YLEN_I,ZLEN_I
          call util_skip_comment(lunrec)
          READ(LUNREC,*)SHIFT_IU
          IF (SHIFT_IU.EQ.9999.) THEN
            SHIFT_IU=USHIFT
          ELSE IF (SHIFT_IU.EQ.-9999.) THEN
            SHIFT_IU=-USHIFT
          ENDIF

          call util_skip_comment(lunrec)
          READ(LUNREC,*)IMAGUP_I
          IF(IMAGTOT+IMAGUP_I.GT.NKLOTZ) THEN
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN REC_INIT: DIMENSION EXCEEDED ***'
            WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
            WRITE(6,*)
            STOP
          ENDIF
          call util_skip_comment(lunrec)
          READ(LUNREC,*)DUP_I
          IF (DUP_I.EQ.9999.) DUP_I=RECGAP
          IF (DUP_I.EQ.-9999.) DUP_I=-RECGAP
          DO I=1,IMAGUP_I
            call util_skip_comment(lunrec)
            READ(LUNREC,*)THETA0_I(I),PHI0_I(I),BC0_I(I)
            BC0_I(I)=BC0_I(I)*SCALKL
            THETA0_I(I)=THETA0_I(I)*GRARAD
            PHI0_I(I)=PHI0_I(I)*GRARAD
            call util_skip_comment(lunrec)
            READ(LUNREC,*)DX0_I(I),DY0_I(I),DZ0_I(I)
            DY0_I(I)=DY0_I(I)+(DUP_I+0.5D0*YLEN_I)/YLEN_I
          ENDDO   !IMAGUP_I

          call util_skip_comment(lunrec)
          READ(LUNREC,*)SHIFT_ID
          IF (SHIFT_ID.EQ.9999.) THEN
            SHIFT_ID=DSHIFT
          ELSE IF (SHIFT_ID.EQ.-9999.) THEN
            SHIFT_ID=-DSHIFT
          ELSE IF (SHIFT_ID.EQ.8888.) THEN
            SHIFT_ID=-2.D0*SHIFT_U
          ENDIF
          call util_skip_comment(lunrec)
          READ(LUNREC,*)IMAGLO_I
          IF(IMAGTOT+IMAGUP_I+IMAGLO_I.GT.NKLOTZ) THEN
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN REC_INIT: DIMENSION EXCEEDED ***'
            WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
            WRITE(6,*)
            STOP
          ENDIF
          call util_skip_comment(lunrec)
          READ(LUNREC,*)DLO_I
          IF (DLO_I.EQ.9999.) DLO_I=RECGAP
          IF (DLO_I.EQ.-9999.) DLO_I=-RECGAP
          DO I=1,IMAGLO_I
            call util_skip_comment(lunrec)
            READ(LUNREC,*)THETA0_I(I+IMAGUP_I),PHI0_I(I+IMAGUP_I),BC0_I(I+IMAGUP_I)
            BC0_I(I+IMAGUP_I)=BC0_I(I+IMAGUP_I)*SCALKL
            THETA0_I(I+IMAGUP_I)=THETA0_I(I+IMAGUP_I)*GRARAD
            PHI0_I(I+IMAGUP_I)=PHI0_I(I+IMAGUP_I)*GRARAD
            call util_skip_comment(lunrec)
            READ(LUNREC,*)DX0_I(I+IMAGUP_I),DY0_I(I+IMAGUP_I),DZ0_I(I+IMAGUP_I)
            DY0_I(I+IMAGUP_I)=DY0_I(I+IMAGUP_I)+(DLO_I-0.5D0*YLEN_I)/YLEN_I
          ENDDO   !IMAGLO_I

          DO I=1,IMAGUP_I/2
            DX0_I(I)=DX0_I(I)+SHIFT_IU/XLEN_I
          ENDDO

          DO I=IMAGUP_I+IMAGLO_I/2+1,IMAGUP_I+IMAGLO_I
            DX0_I(I)=DX0_I(I)+SHIFT_IU/XLEN_I+SHIFT_ID/XLEN_I
          ENDDO

          IMAGNET_I=IMAGUP_I+IMAGLO_I

          call util_skip_comment(lunrec)
          READ(LUNREC,*)IMOD_I,OFFX_I
          IF(IMAGTOT+IMAGNET_I*IMOD_I.GT.NKLOTZ) THEN
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN REC_INIT: DIMENSION EXCEEDED ***'
            WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
            WRITE(6,*)
            STOP
          ENDIF
          DO I=1,IMOD_I
            call util_skip_comment(lunrec)
            READ(LUNREC,*)DDX_I(I),DDY_I(I),DDZ_I(I)
            DDX_I(I)=DDX_I(I)+OFFX_I/XLEN_I
          ENDDO

          call util_skip_comment(lunrec)
          READ(LUNREC,*)XLEN_E,YLEN_E,ZLEN_E
          call util_skip_comment(lunrec)
          READ(LUNREC,*)SHIFT_EU
          IF (SHIFT_EU.EQ.9999.) THEN
            SHIFT_EU=USHIFT
          ELSE IF (SHIFT_EU.EQ.-9999.) THEN
            SHIFT_EU=-USHIFT
          ENDIF

          call util_skip_comment(lunrec)
          READ(LUNREC,*)IMAGUP_E
          IF(IMAGTOT+IMAGNET_I*IMOD_I+IMAGUP_E.GT.NKLOTZ) THEN
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN REC_INIT: DIMENSION EXCEEDED ***'
            WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
            WRITE(6,*)
            STOP
          ENDIF
          call util_skip_comment(lunrec)
          READ(LUNREC,*)DUP_E
          IF (DUP_E.EQ.9999.) DUP_E=RECGAP
          IF (DUP_E.EQ.-9999.) DUP_E=-RECGAP
          DO I=1,IMAGUP_E
            call util_skip_comment(lunrec)
            READ(LUNREC,*)THETA0_E(I),PHI0_E(I),BC0_E(I)
            BC0_E(I)=BC0_E(I)*SCALKL
            THETA0_E(I)=THETA0_E(I)*GRARAD
            PHI0_E(I)=PHI0_E(I)*GRARAD
            call util_skip_comment(lunrec)
            READ(LUNREC,*)DX0_E(I),DY0_E(I),DZ0_E(I)
            DY0_E(I)=DY0_E(I)+(DUP_E+0.5D0*YLEN_E)/YLEN_E
          ENDDO   !IMAGUP_E

          call util_skip_comment(lunrec)
          READ(LUNREC,*)SHIFT_ED
          IF (SHIFT_ED.EQ.9999.) THEN
            SHIFT_ED=DSHIFT
          ELSE IF (SHIFT_ED.EQ.-9999.) THEN
            SHIFT_ED=-DSHIFT
          ELSE IF (SHIFT_ED.EQ.8888.) THEN
            SHIFT_ED=-2.D0*SHIFT_U
          ENDIF
          call util_skip_comment(lunrec)
          READ(LUNREC,*)IMAGLO_E
          IF(IMAGTOT+IMAGNET_I*IMOD_I+IMAGUP_E+IMAGLO_I.GT.NKLOTZ) THEN
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN REC_INIT: DIMENSION EXCEEDED ***'
            WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
            WRITE(6,*)
            STOP
          ENDIF
          call util_skip_comment(lunrec)
          READ(LUNREC,*)DLO_E
          IF (DLO_E.EQ.9999.) DLO_E=RECGAP
          IF (DLO_E.EQ.-9999.) DLO_E=-RECGAP
          DO I=1,IMAGLO_E
            call util_skip_comment(lunrec)
            READ(LUNREC,*)THETA0_E(I+IMAGUP_E),PHI0_E(I+IMAGUP_E),BC0_E(I+IMAGUP_E)
            BC0_E(I+IMAGUP_E)=BC0_E(I+IMAGUP_E)*SCALKL
            THETA0_E(I+IMAGUP_E)=THETA0_E(I+IMAGUP_E)*GRARAD
            PHI0_E(I+IMAGUP_E)=PHI0_E(I+IMAGUP_E)*GRARAD
            call util_skip_comment(lunrec)
            READ(LUNREC,*)DX0_E(I+IMAGUP_E),DY0_E(I+IMAGUP_E),DZ0_E(I+IMAGUP_E)
            DY0_E(I+IMAGUP_E)=DY0_E(I+IMAGUP_E)+(DLO_E-0.5D0*YLEN_E)/YLEN_E
          ENDDO   !IMAGLO_E

          DO I=1,IMAGUP_E/2
            DX0_E(I)=DX0_E(I)+SHIFT_EU/XLEN_E
          ENDDO

          DO I=IMAGUP_E+IMAGLO_E/2+1,IMAGUP_E+IMAGLO_E
            DX0_E(I)=DX0_E(I)+SHIFT_EU/XLEN_E+SHIFT_ED/XLEN_E
          ENDDO

          IMAGNET_E=IMAGUP_E+IMAGLO_E

          call util_skip_comment(lunrec)
          READ(LUNREC,*)IMOD_E,OFFX_E
          IF(IMAGTOT+IMAGNET_I*IMOD_I+IMAGNET_E*IMOD_E.GT.NKLOTZ) THEN
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN REC_INIT: DIMENSION EXCEEDED ***'
            WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
            WRITE(6,*)
            STOP
          ENDIF
          DO I=1,IMOD_E
            call util_skip_comment(lunrec)
            READ(LUNREC,*)DDX_E(I),DDY_E(I),DDZ_E(I)
            DDX_E(I)=DDX_E(I)+OFFX_E/XLEN_E
          ENDDO

c************ Loop over modules ******************************

          do iimod=1,imod

            xshift=ddx(iimod)
            yshift=ddy(iimod)
            zshift=ddz(iimod)

c************ Loop over magnets ******************************

            do imag=1,imagnet

              XLEN((IIMOD-1)*IMAGNET+IMAG)=XLEN(1)
              YLEN((IIMOD-1)*IMAGNET+IMAG)=YLEN(1)
              ZLEN((IIMOD-1)*IMAGNET+IMAG)=ZLEN(1)

              bc((IIMOD-1)*IMAGNET+IMAG)=bc0(imag)
              dx((IIMOD-1)*IMAGNET+IMAG)=dx0(imag)*xlen(1)+xshift*xlen(1)
              dy((IIMOD-1)*IMAGNET+IMAG)=dy0(imag)*ylen(1)+yshift*ylen(1)
              dz((IIMOD-1)*IMAGNET+IMAG)=dz0(imag)*zlen(1)+zshift*zlen(1)
              theta((IIMOD-1)*IMAGNET+IMAG)=theta0(imag)
              phi((IIMOD-1)*IMAGNET+IMAG)=phi0(imag)


            ENDDO   !MAGNETS

          ENDDO   !MODULES


c************************************************************

c End poles

          do iimod=1,imod_I

            xshift=ddx_I(iimod)
            yshift=ddy_I(iimod)
            zshift=ddz_I(iimod)

            do imag=1,imagnet_I

              II=IMAGTOT+(IIMOD-1)*IMAGNET_I+IMAG

              XLEN(II)=XLEN_I
              YLEN(II)=YLEN_I
              ZLEN(II)=ZLEN_I

              bc(II)=bc0_I(imag)
              dx(II)=dx0_I(imag)*xlen_I+xshift*xlen_I
              dy(II)=dy0_I(imag)*ylen_I+yshift*ylen_I
              dz(II)=dz0_I(imag)*zlen_I+zshift*zlen_I
              theta(II)=theta0_I(imag)
              phi(II)=phi0_I(imag)

            ENDDO   !MAGNETS

          ENDDO   !MODULES

          IMAGTOT=IMAGTOT+IMAGNET_I*IMOD_I

          do iimod=1,imod_E

            xshift=ddx_E(iimod)
            yshift=ddy_E(iimod)
            zshift=ddz_E(iimod)

            do imag=1,imagnet_E

              II=IMAGTOT+(IIMOD-1)*IMAGNET_E+IMAG

              XLEN(II)=XLEN_E
              YLEN(II)=YLEN_E
              ZLEN(II)=ZLEN_E

              bc(II)=bc0_E(imag)
              dx(II)=dx0_E(imag)*xlen_E+xshift*xlen_E
              dy(II)=dy0_E(imag)*ylen_E+yshift*ylen_E
              dz(II)=dz0_E(imag)*zlen_E+zshift*zlen_E
              theta(II)=theta0_E(imag)
              phi(II)=phi0_E(imag)

            ENDDO   !MAGNETS

          ENDDO   !MODULES

          IMAGTOT=IMAGTOT+IMAGNET_E*IMOD_E

C COPY ARRAY IN ORDER TO SAVE THEM{

          DO I=1,IMAGTOT
            BCS(I)=BC(I)
            XLENS(I)=XLEN(I)
            YLENS(I)=YLEN(I)
            ZLENS(I)=ZLEN(I)
            THETAS(I)=THETA(I)
            PHIS(I)=PHI(I)
            DXS(I)=DX(I)
            DYS(I)=DY(I)
            DZS(I)=DZ(I)
          ENDDO

          IMAGTOTS=IMAGTOT
          IMAGTOT=0

C COPY ARRAY IN ORDER TO SAVE THEM}

C****************************************************
C { WHOLE STORY AGAIN FOR SECOND DEVICE

          call util_skip_comment(lunrec)
          read(lunrec,*)xlen(1),ylen(1),zlen(1)
          call util_skip_comment(lunrec)
          read(lunrec,*)shift_U
          IF (SHIFT_U.EQ.9999.) THEN
            SHIFT_U=USHIFT
          ELSE IF (SHIFT_U.EQ.-9999.) THEN
            SHIFT_U=-USHIFT
          ENDIF
          call util_skip_comment(lunrec)
          read(lunrec,*)imagup
          IF(IMAGUP.GT.NKLOTZ) THEN
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN REC_INIT: DIMENSION EXCEEDED ***'
            WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
            WRITE(6,*)
            STOP
          ENDIF
          call util_skip_comment(lunrec)
          read(lunrec,*)dup
          IF (DUP.EQ.9999.) DUP=RECGAP
          IF (DUP.EQ.-9999.) DUP=-RECGAP
          do i=1,imagup
            call util_skip_comment(lunrec)
            read(lunrec,*)theta0(i),phi0(i),bc0(i)
            BC0(I)=BC0(I)*SCALKL
            theta0(i)=theta0(i)*grarad
            phi0(i)=phi0(i)*grarad
            call util_skip_comment(lunrec)
            read(lunrec,*)dx0(i),dy0(i),dz0(i)
C03JUN97    DUMZ=DABS(DZ0(I))-1.D0
C03JUN97    DZ0(I)=DSIGN (ZLENS(1)/ZLEN(1)+DUMZ,DZ0(I))
            dy0(i)=dy0(i)+(dup+0.5*ylen(1))/ylen(1)
          enddo

          call util_skip_comment(lunrec)
          read(lunrec,*)shift_D
          IF (SHIFT_D.EQ.9999.) THEN
            SHIFT_D=DSHIFT
          ELSE IF (SHIFT_D.EQ.-9999.) THEN
            SHIFT_D=-DSHIFT
          ELSE IF (SHIFT_D.EQ.8888.) THEN
            SHIFT_D=-2.D0*SHIFT_U
          ENDIF
          call util_skip_comment(lunrec)
          read(lunrec,*)imaglo
          IF(IMAGUP+IMAGLO.GT.NKLOTZ) THEN
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN REC_INIT: DIMENSION EXCEEDED ***'
            WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
            WRITE(6,*)
            STOP
          ENDIF
          call util_skip_comment(lunrec)
          read(lunrec,*)dlo
          IF (DLO.EQ.9999.) DLO=RECGAP
          IF (DLO.EQ.-9999.) DLO=-RECGAP
          do i=1,imaglo
            call util_skip_comment(lunrec)
            read(lunrec,*)theta0(i+imagup),phi0(i+imagup),bc0(i+imagup)
            BC0(I+imagup)=BC0(I+imagup)*SCALKL
            theta0(i+imagup)=theta0(i+imagup)*grarad
            phi0(i+imagup)=phi0(i+imagup)*grarad
            call util_skip_comment(lunrec)
            read(lunrec,*)dx0(i+imagup),dy0(i+imagup),dz0(i+imagup)
C03JUN97    DUMZ=DABS(DZ0(I+imagup))-1.D0
C03JUN97    DZ0(I+imagup)=DSIGN (ZLENS(1)/ZLEN(1)+DUMZ,DZ0(I+imagup))
            dy0(i+imagup)=dy0(i+imagup)+(dlo-0.5*ylen(1))/ylen(1)
          enddo

          do i=1,imagup/2
            dx0(i)=dx0(i)+shift_U/XLEN(1)
          enddo

          do i=imagup+imaglo/2+1,imagup+imaglo
            dx0(i)=dx0(i)+shift_U/XLEN(1)+SHIFT_D/XLEN(1)
          enddo

          imagnet=imagup+imaglo

          call util_skip_comment(lunrec)
          read(lunrec,*)imod,OFFX
          IF(IMAGNET*IMOD.GT.NKLOTZ) THEN
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN REC_INIT: DIMENSION EXCEEDED ***'
            WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
            WRITE(6,*)
            STOP
          ENDIF
          do i=1,imod
            call util_skip_comment(lunrec)
            read(lunrec,*)ddx(i),ddy(i),ddz(i)
            DDX(I)=DDX(I)+OFFX/XLEN(1)
          enddo

c************************************************************

c End poles

          IMAGTOT=IMOD*IMAGNET

          call util_skip_comment(lunrec)
          read(lunrec,*)XLEN_I,YLEN_I,ZLEN_I
          call util_skip_comment(lunrec)
          read(lunrec,*)SHIFT_IU
          IF (SHIFT_IU.EQ.9999.) THEN
            SHIFT_IU=USHIFT
          ELSE IF (SHIFT_IU.EQ.-9999.) THEN
            SHIFT_IU=-USHIFT
          ENDIF

          call util_skip_comment(lunrec)
          read(lunrec,*)IMAGUP_I
          IF(IMAGTOT+IMAGUP_I.GT.NKLOTZ) THEN
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN REC_INIT: DIMENSION EXCEEDED ***'
            WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
            WRITE(6,*)
            STOP
          ENDIF
          call util_skip_comment(lunrec)
          read(lunrec,*)DUP_I
          IF (DUP_I.EQ.9999.) DUP_I=RECGAP
          IF (DUP_I.EQ.-9999.) DUP_I=-RECGAP
          DO I=1,IMAGUP_I
            call util_skip_comment(lunrec)
            read(lunrec,*)THETA0_I(I),PHI0_I(I),BC0_I(I)
            BC0_I(I)=BC0_I(I)*SCALKL
            THETA0_I(I)=THETA0_I(I)*GRARAD
            PHI0_I(I)=PHI0_I(I)*GRARAD
            call util_skip_comment(lunrec)
            read(lunrec,*)DX0_I(I),DY0_I(I),DZ0_I(I)
C03JUN97    DUMZ=DABS(DZ0_I(I))-1.D0
C03JUN97    DZ0_I(I)=DSIGN (ZLENS(1)/ZLEN_I+DUMZ,DZ0_I(I))
            DY0_I(I)=DY0_I(I)+(DUP_I+0.5D0*YLEN_I)/YLEN_I
          ENDDO   !IMAGUP_I

          call util_skip_comment(lunrec)
          read(lunrec,*)SHIFT_ID
          IF (SHIFT_ID.EQ.9999.) THEN
            SHIFT_ID=DSHIFT
          ELSE IF (SHIFT_ID.EQ.-9999.) THEN
            SHIFT_ID=-DSHIFT
          ELSE IF (SHIFT_ID.EQ.8888.) THEN
            SHIFT_ID=-2.D0*SHIFT_U
          ENDIF
          call util_skip_comment(lunrec)
          read(lunrec,*)IMAGLO_I
          IF(IMAGTOT+IMAGUP_I+IMAGLO_I.GT.NKLOTZ) THEN
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN REC_INIT: DIMENSION EXCEEDED ***'
            WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
            WRITE(6,*)
            STOP
          ENDIF
          call util_skip_comment(lunrec)
          read(lunrec,*)DLO_I
          IF (DLO_I.EQ.9999.) DLO_I=RECGAP
          IF (DLO_I.EQ.-9999.) DLO_I=-RECGAP
          DO I=1,IMAGLO_I
            call util_skip_comment(lunrec)
            read(lunrec,*)THETA0_I(I+IMAGUP_I),PHI0_I(I+IMAGUP_I),BC0_I(I+IMAGUP_I)
            BC0_I(I+IMAGUP_I)=BC0_I(I+IMAGUP_I)*SCALKL
            THETA0_I(I+IMAGUP_I)=THETA0_I(I+IMAGUP_I)*GRARAD
            PHI0_I(I+IMAGUP_I)=PHI0_I(I+IMAGUP_I)*GRARAD
            call util_skip_comment(lunrec)
            read(lunrec,*)DX0_I(I+IMAGUP_I),DY0_I(I+IMAGUP_I),DZ0_I(I+IMAGUP_I)
C03JUN97    DUMZ=DABS(DZ0_I(I+IMAGUP_I))-1.D0
C03JUN97    DZ0_I(I+IMAGUP_I)=DSIGN (ZLENS(1)/ZLEN_I+DUMZ,DZ0_I(I+IMAGUP_I))
            DY0_I(I+IMAGUP_I)=DY0_I(I+IMAGUP_I)+(DLO_I-0.5D0*YLEN_I)/YLEN_I
          ENDDO   !IMAGLO_I

          DO I=1,IMAGUP_I/2
            DX0_I(I)=DX0_I(I)+SHIFT_IU/XLEN_I
          ENDDO

          DO I=IMAGUP_I+IMAGLO_I/2+1,IMAGUP_I+IMAGLO_I
            DX0_I(I)=DX0_I(I)+SHIFT_IU/XLEN_I+SHIFT_ID/XLEN_I
          ENDDO

          IMAGNET_I=IMAGUP_I+IMAGLO_I

          call util_skip_comment(lunrec)
          read(lunrec,*)IMOD_I,OFFX_I
          IF(IMAGTOT+IMAGNET_I*IMOD_I.GT.NKLOTZ) THEN
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN REC_INIT: DIMENSION EXCEEDED ***'
            WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
            WRITE(6,*)
            STOP
          ENDIF
          DO I=1,IMOD_I
            call util_skip_comment(lunrec)
            read(lunrec,*)DDX_I(I),DDY_I(I),DDZ_I(I)
            DDX_I(I)=DDX_I(I)+OFFX_I/XLEN_I
          ENDDO

          call util_skip_comment(lunrec)
          read(lunrec,*)XLEN_E,YLEN_E,ZLEN_E
          call util_skip_comment(lunrec)
          read(lunrec,*)SHIFT_EU
          IF (SHIFT_EU.EQ.9999.) THEN
            SHIFT_EU=USHIFT
          ELSE IF (SHIFT_EU.EQ.-9999.) THEN
            SHIFT_EU=-USHIFT
          ENDIF

          call util_skip_comment(lunrec)
          read(lunrec,*)IMAGUP_E
          IF(IMAGTOT+IMAGNET_I*IMOD_I+IMAGUP_E.GT.NKLOTZ) THEN
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN REC_INIT: DIMENSION EXCEEDED ***'
            WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
            WRITE(6,*)
            STOP
          ENDIF
          call util_skip_comment(lunrec)
          read(lunrec,*)DUP_E
          IF (DUP_E.EQ.9999.) DUP_E=RECGAP
          IF (DUP_E.EQ.-9999.) DUP_E=-RECGAP
          DO I=1,IMAGUP_E
            call util_skip_comment(lunrec)
            read(lunrec,*)THETA0_E(I),PHI0_E(I),BC0_E(I)
            BC0_E(I)=BC0_E(I)*SCALKL
            THETA0_E(I)=THETA0_E(I)*GRARAD
            PHI0_E(I)=PHI0_E(I)*GRARAD
            call util_skip_comment(lunrec)
            read(lunrec,*)DX0_E(I),DY0_E(I),DZ0_E(I)
C03JUN97    DUMZ=DABS(DZ0_E(I))-1.D0
C03JUN97    DZ0_E(I)=DSIGN (ZLENS(1)/ZLEN_E+DUMZ,DZ0_E(I))
            DY0_E(I)=DY0_E(I)+(DUP_E+0.5D0*YLEN_E)/YLEN_E
          ENDDO   !IMAGUP_E

          call util_skip_comment(lunrec)
          read(lunrec,*)SHIFT_ED
          IF (SHIFT_ED.EQ.9999.) THEN
            SHIFT_ED=DSHIFT
          ELSE IF (SHIFT_ED.EQ.-9999.) THEN
            SHIFT_ED=-DSHIFT
          ELSE IF (SHIFT_ED.EQ.8888.) THEN
            SHIFT_ED=-2.D0*SHIFT_U
          ENDIF
          call util_skip_comment(lunrec)
          read(lunrec,*)IMAGLO_E
          IF(IMAGTOT+IMAGNET_I*IMOD_I+IMAGUP_E+IMAGLO_I.GT.NKLOTZ) THEN
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN REC_INIT: DIMENSION EXCEEDED ***'
            WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
            WRITE(6,*)
            STOP
          ENDIF
          call util_skip_comment(lunrec)
          read(lunrec,*)DLO_E
          IF (DLO_E.EQ.9999.) DLO_E=RECGAP
          IF (DLO_E.EQ.-9999.) DLO_E=-RECGAP
          DO I=1,IMAGLO_E
            call util_skip_comment(lunrec)
            read(lunrec,*)THETA0_E(I+IMAGUP_E),PHI0_E(I+IMAGUP_E),BC0_E(I+IMAGUP_E)
            BC0_E(I+IMAGUP_E)=BC0_E(I+IMAGUP_E)*SCALKL
            THETA0_E(I+IMAGUP_E)=THETA0_E(I+IMAGUP_E)*GRARAD
            PHI0_E(I+IMAGUP_E)=PHI0_E(I+IMAGUP_E)*GRARAD
            call util_skip_comment(lunrec)
            read(lunrec,*)DX0_E(I+IMAGUP_E),DY0_E(I+IMAGUP_E),DZ0_E(I+IMAGUP_E)
C03JUN97    DUMZ=DABS(DZ0_E(I+IMAGUP_E))-1.D0
C03JUN97    DZ0_E(I+IMAGUP_E)=DSIGN (ZLENS(1)/ZLEN_E+DUMZ,DZ0_E(I+IMAGUP_E))
            DY0_E(I+IMAGUP_E)=DY0_E(I+IMAGUP_E)+(DLO_E-0.5D0*YLEN_E)/YLEN_E
          ENDDO   !IMAGLO_E

          DO I=1,IMAGUP_E/2
            DX0_E(I)=DX0_E(I)+SHIFT_EU/XLEN_E
          ENDDO

          DO I=IMAGUP_E+IMAGLO_E/2+1,IMAGUP_E+IMAGLO_E
            DX0_E(I)=DX0_E(I)+SHIFT_EU/XLEN_E+SHIFT_ED/XLEN_E
          ENDDO

          IMAGNET_E=IMAGUP_E+IMAGLO_E

          call util_skip_comment(lunrec)
          read(lunrec,*)IMOD_E,OFFX_E
          IF(IMAGTOT+IMAGNET_I*IMOD_I+IMAGNET_E*IMOD_E.GT.NKLOTZ) THEN
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN REC_INIT: DIMENSION EXCEEDED ***'
            WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
            WRITE(6,*)
            STOP
          ENDIF
          DO I=1,IMOD_E
            call util_skip_comment(lunrec)
            read(lunrec,*)DDX_E(I),DDY_E(I),DDZ_E(I)
            DDX_E(I)=DDX_E(I)+OFFX_E/XLEN_E
          ENDDO

c************ Loop over modules ******************************

          do iimod=1,imod

            xshift=ddx(iimod)
            yshift=ddy(iimod)
            zshift=ddz(iimod)

c************ Loop over magnets ******************************

            do imag=1,imagnet

              XLEN((IIMOD-1)*IMAGNET+IMAG)=XLEN(1)
              YLEN((IIMOD-1)*IMAGNET+IMAG)=YLEN(1)
              ZLEN((IIMOD-1)*IMAGNET+IMAG)=ZLEN(1)

              bc((IIMOD-1)*IMAGNET+IMAG)=bc0(imag)
              dx((IIMOD-1)*IMAGNET+IMAG)=dx0(imag)*xlen(1)+xshift*xlen(1)
              dy((IIMOD-1)*IMAGNET+IMAG)=dy0(imag)*ylen(1)+yshift*ylen(1)
              dz((IIMOD-1)*IMAGNET+IMAG)=dz0(imag)*zlen(1)+zshift*zlen(1)
              theta((IIMOD-1)*IMAGNET+IMAG)=theta0(imag)
              phi((IIMOD-1)*IMAGNET+IMAG)=phi0(imag)

            ENDDO   !MAGNETS

          ENDDO   !MODULES

c************************************************************

c End poles

          do iimod=1,imod_I

            xshift=ddx_I(iimod)
            yshift=ddy_I(iimod)
            zshift=ddz_I(iimod)

            do imag=1,imagnet_I

              II=IMAGTOT+(IIMOD-1)*IMAGNET_I+IMAG

              XLEN(II)=XLEN_I
              YLEN(II)=YLEN_I
              ZLEN(II)=ZLEN_I

              bc(II)=bc0_I(imag)
              dx(II)=dx0_I(imag)*xlen_I+xshift*xlen_I
              dy(II)=dy0_I(imag)*ylen_I+yshift*ylen_I
              dz(II)=dz0_I(imag)*zlen_I+zshift*zlen_I
              theta(II)=theta0_I(imag)
              phi(II)=phi0_I(imag)

            ENDDO   !MAGNETS

          ENDDO   !MODULES

          IMAGTOT=IMAGTOT+IMAGNET_I*IMOD_I

          do iimod=1,imod_E

            xshift=ddx_E(iimod)
            yshift=ddy_E(iimod)
            zshift=ddz_E(iimod)

            do imag=1,imagnet_E

              II=IMAGTOT+(IIMOD-1)*IMAGNET_E+IMAG

              XLEN(II)=XLEN_E
              YLEN(II)=YLEN_E
              ZLEN(II)=ZLEN_E

              bc(II)=bc0_E(imag)
              dx(II)=dx0_E(imag)*xlen_E+xshift*xlen_E
              dy(II)=dy0_E(imag)*ylen_E+yshift*ylen_E
              dz(II)=dz0_E(imag)*zlen_E+zshift*zlen_E
              theta(II)=theta0_E(imag)
              phi(II)=phi0_E(imag)

            ENDDO   !MAGNETS

          ENDDO   !MODULES

          IMAGTOT=IMAGTOT+IMAGNET_E*IMOD_E

C WHOLE STORY AGAIN }
C****************************************************

C MERGE FIRST AND SECOND DEVICE

          IF(IMAGTOTS+IMAGTOT.GT.NKLOTZ) THEN
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN REC_INIT: DIMENSION EXCEEDED ***'
            WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
            WRITE(6,*)
            STOP
          ENDIF

          DO IMAG=1,IMAGTOTS
            BC(IMAGTOT+IMAG)=BCS(IMAG)
            XLEN(IMAGTOT+IMAG)=XLENS(IMAG)
            YLEN(IMAGTOT+IMAG)=YLENS(IMAG)
            ZLEN(IMAGTOT+IMAG)=ZLENS(IMAG)
            THETA(IMAGTOT+IMAG)=THETAS(IMAG)
            PHI(IMAGTOT+IMAG)=PHIS(IMAG)
            DX(IMAGTOT+IMAG)=DXS(IMAG)
            DY(IMAGTOT+IMAG)=DYS(IMAG)
            DZ(IMAGTOT+IMAG)=DZS(IMAG)
          ENDDO   !IMAG

          IMAGTOT=IMAGTOTS+IMAGTOT

          IF (SCALKL.EQ.0.D0) IMAGTOT=0

C****************************************************
C ADDITIONAL MAGNETS

          call util_skip_comment(lunrec)
          read(lunrec,*)IMAGADD

          IF(IMAGTOT+IMAGADD.GT.NKLOTZ) THEN
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN REC_INIT: DIMENSION EXCEEDED ***'
            WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
            WRITE(6,*)
            STOP
          ENDIF

          DO IMAG=1,IMAGADD
            call util_skip_comment(lunrec)
            read(lunrec,*)XLEN_A,YLEN_A,ZLEN_A
            XLEN(IMAGTOT+IMAG)=XLEN_A
            YLEN(IMAGTOT+IMAG)=YLEN_A
            ZLEN(IMAGTOT+IMAG)=ZLEN_A
            call util_skip_comment(lunrec)
            read(lunrec,*)THETA(IMAGTOT+IMAG),PHI(IMAGTOT+IMAG),BC(IMAGTOT+IMAG)
            call util_skip_comment(lunrec)
            read(lunrec,*)DX(IMAGTOT+IMAG),DY(IMAGTOT+IMAG),DZ(IMAGTOT+IMAG)
            BC(IMAGTOT+IMAG)=BC(IMAGTOT+IMAG)*SCALADD
          ENDDO

          DO IMAG=IMAGTOT+1,IMAGTOT+IMAGADD
C03JUN97  DX(IMAG)=XLEN_A*DX(IMAG)
C03JUN97  DY(IMAG)=YLEN_A*DY(IMAG)
C03JUN97  DZ(IMAG)=ZLEN_A*DZ(IMAG)
            THETA(IMAG)=THETA(IMAG)*GRARAD
            PHI(IMAG)=PHI(IMAG)*GRARAD
          ENDDO

          IF (SCALADD.EQ.0.D0) IMAGADD=0
          IMAGTOT=IMAGTOT+IMAGADD

C****************************************************

          close(LUNREC)
        ENDIF !(SCALADD.NE.0.D0.OR.SCALKL.NE.0.D0)

C--- GENERATE FIELD ERRORS{

        IF (BCRAN.NE.0.D0) THEN

          DO I=1,IMAGTOT
            IF (DX(I).GE.BCSTART.AND.DX(I).LE.BCEND) THEN
              IF (K90270.NE.0) THEN
                IF (ABS(ABS(THETA(I)/GRARAD)-90.D0).LT.1.
     &              .OR.ABS(ABS(THETA(I)/GRARAD)-270.D0).LT.1.)  THEN
                  IF(BCRAN.GT.0.D0) THEN
                    CALL RNORML(xran,1,rr) !RANDOM NOISE OFF FIELD
1                   IF (ABS(xran(1)).GT.BCRANSIG) THEN
                      CALL RNORML(xran,1,rr) !RANDOM NOISE OFF FIELD
                      GOTO 1
                    ENDIF
                    BC(I)=BC(I)*(1.+BCRAN*xran(1))
                  ELSE IF(BCRAN.LT.0.D0) THEN
                    BC(I)=BC(I)*(1.-BCRAN)
                  ENDIF
                ENDIF
              ELSE
                IF(BCRAN.GT.0.D0) THEN
                  CALL RNORML(xran,1,rr) !RANDOM NOISE OFF FIELD
11                IF (ABS(xran(1)).GT.BCRANSIG) THEN
                    CALL RNORML(xran,1,rr) !RANDOM NOISE OFF FIELD
                    GOTO 11
                  ENDIF
                  BC(I)=BC(I)*(1.+BCRAN*xran(1))
                ELSE IF(BCRAN.LT.0.D0) THEN
                  BC(I)=BC(I)*(1.-BCRAN)
                ENDIF
              ENDIF
            ENDIF
          ENDDO

        ENDIF  !BCRAN.NE.0.D0

C--- GENERATE FIELD ERRORS}

C--- SIMPLE PLANAR UNDULATOR{

        IF (IRECU.GT.IURECP) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN REC_INIT: DIMENSION EXCEEDED ***'
          WRITE(6,*)'INCREASE PARAMETER IURECP IN FILE KLOTZ.CMN'
          WRITE(6,*)
          STOP
        ENDIF

        IF (IRECU.NE.0) THEN

          DO IUREC=1,IRECU

            IF (IUHELI(IUREC).EQ.0) THEN

              CALL REC_PLAN(IUREC,GRARAD)

            ELSE    !UHELI=0

              IF(IMAGTOT.GT.NKLOTZ) THEN
                WRITE(6,*)
                WRITE(6,*)'*** ERROR IN REC_INIT: DIMENSION EXCEEDED ***'
                WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
                WRITE(6,*)
                STOP
              ENDIF

              IF (IUHELI(IUREC).GT.0) THEN

                IMAGTOTS=IMAGTOT
                CALL REC_HELI(IUREC,GRARAD,1,0,0)

                IF (BCRAN.NE.0.D0) THEN
                  IF (NURANMOD.EQ.0) THEN
                    xranO=xran(1)
                    DO I=IMAGTOTS+1,IMAGTOT
                      IF (DX(I).GE.BCSTART.AND.DX(I).LE.BCEND) THEN
                        IF (K90270.NE.0) THEN
                          IF (ABS(ABS(THETA(I)/GRARAD)-90.D0).LT.1.
     &                        .OR.ABS(ABS(THETA(I)/GRARAD)-270.D0).LT.1.)  THEN
                            IF(BCRAN.GT.0.D0) THEN
                              CALL RNORML(xran,1,rr) !RANDOM NOISE OFF FIELD
111                           IF (ABS(xran(1)).GT.BCRANSIG) THEN
                                CALL RNORML(xran,1,rr) !RANDOM NOISE OFF FIELD
                                GOTO 111
                              ENDIF
                              BC(I)=BC(I)*(1.+BCRAN*xran(1))
                            ELSE IF(BCRAN.LT.0.D0) THEN
                              BC(I)=BC(I)*(1.-BCRAN)
                            ENDIF
                          ENDIF
                        ELSE
                          IF(BCRAN.GT.0.D0) THEN
                            CALL RNORML(xran,1,rr) !RANDOM NOISE OFF FIELD
1111                        IF (ABS(xran(1)).GT.BCRANSIG) THEN
                              CALL RNORML(xran,1,rr) !RANDOM NOISE OFF FIELD
                              GOTO 1111
                            ENDIF
                            BC(I)=BC(I)*(1.+BCRAN*xran(1))
                          ELSE IF(BCRAN.LT.0.D0) THEN
                            BC(I)=BC(I)*(1.-BCRAN)
                          ENDIF
                        ENDIF
                      ENDIF
                    ENDDO
                  ENDIF   !NURANMOD
                ENDIF   !BCRAN

                IMAGTOTS=IMAGTOT
                CALL REC_HELI(IUREC,GRARAD,-1,-1,-1)

                IF (BCRAN.NE.0.D0) THEN
                  IF (NURANMOD.EQ.0) THEN
                    xran(1)=xranO
                    DO I=IMAGTOTS+1,IMAGTOT
                      IF (DX(I).GE.BCSTART.AND.DX(I).LE.BCEND) THEN
                        IF (K90270.NE.0) THEN
                          IF (ABS(ABS(THETA(I)/GRARAD)-90.D0).LT.1.
     &                        .OR.ABS(ABS(THETA(I)/GRARAD)-270.D0).LT.1.)  THEN
                            IF(BCRAN.GT.0.D0) THEN
                              CALL RNORML(xran,1,rr) !RANDOM NOISE OFF FIELD
2                             IF (ABS(xran(1)).GT.BCRANSIG) THEN
                                CALL RNORML(xran,1,rr) !RANDOM NOISE OFF FIELD
                                GOTO 2
                              ENDIF
                              BC(I)=BC(I)*(1.+BCRAN*xran(1))
                            ELSE IF(BCRAN.LT.0.D0) THEN
                              BC(I)=BC(I)*(1.-BCRAN)
                            ENDIF
                          ENDIF
                        ELSE
                          IF(BCRAN.GT.0.D0) THEN
                            CALL RNORML(xran,1,rr) !RANDOM NOISE OFF FIELD
22                          IF (ABS(xran(1)).GT.BCRANSIG) THEN
                              CALL RNORML(xran,1,rr) !RANDOM NOISE OFF FIELD
                              GOTO 22
                            ENDIF
                            BC(I)=BC(I)*(1.+BCRAN*xran(1))
                          ELSE IF(BCRAN.LT.0.D0) THEN
                            BC(I)=BC(I)*(1.-BCRAN)
                          ENDIF
                        ENDIF
                      ENDIF
                    ENDDO
                  ENDIF   !NURANMOD
                ENDIF   !BCRAN

              ELSE    !UHELI.GT.0

                IMAGTOTS=IMAGTOT

                CALL REC_HELI(IUREC,GRARAD,-1,0,0)

                IF (BCRAN.NE.0.D0) THEN
                  IF (NURANMOD.EQ.0) THEN
                    xranO=xran(1)
                    DO I=IMAGTOTS+1,IMAGTOT
                      IF (DX(I).GE.BCSTART.AND.DX(I).LE.BCEND) THEN
                        IF (K90270.NE.0) THEN
                          IF (ABS(ABS(THETA(I)/GRARAD)-90.D0).LT.1.
     &                        .OR.ABS(ABS(THETA(I)/GRARAD)-270.D0).LT.1.)  THEN
                            IF(BCRAN.GT.0.D0) THEN
                              CALL RNORML(xran,1,rr) !RANDOM NOISE OFF FIELD
222                           IF (ABS(xran(1)).GT.BCRANSIG) THEN
                                CALL RNORML(xran,1,rr) !RANDOM NOISE OFF FIELD
                                GOTO 222
                              ENDIF
                              BC(I)=BC(I)*(1.+BCRAN*xran(1))
                            ELSE IF(BCRAN.LT.0.D0) THEN
                              BC(I)=BC(I)*(1.-BCRAN)
                            ENDIF
                          ENDIF
                        ELSE
                          IF(BCRAN.GT.0.D0) THEN
                            CALL RNORML(xran,1,rr) !RANDOM NOISE OFF FIELD
21                          IF (ABS(xran(1)).GT.BCRANSIG) THEN
                              CALL RNORML(xran,1,rr) !RANDOM NOISE OFF FIELD
                              GOTO 21
                            ENDIF
                            BC(I)=BC(I)*(1.+BCRAN*xran(1))
                          ELSE IF(BCRAN.LT.0.D0) THEN
                            BC(I)=BC(I)*(1.-BCRAN)
                          ENDIF
                        ENDIF
                      ENDIF
                    ENDDO
                  ENDIF   !NURANMOD
                ENDIF   !BCRAN

                CALL REC_HELI(IUREC,GRARAD,1,-1,1)

                IF (BCRAN.NE.0.D0) THEN
                  IF (NURANMOD.EQ.0) THEN
                    xran(1)=xranO
                    DO I=IMAGTOTS+1,IMAGTOT
                      IF (DX(I).GE.BCSTART.AND.DX(I).LE.BCEND) THEN
                        IF (K90270.NE.0) THEN
                          IF (ABS(ABS(THETA(I)/GRARAD)-90.D0).LT.1.
     &                        .OR.ABS(ABS(THETA(I)/GRARAD)-270.D0).LT.1.)  THEN
                            IF(BCRAN.GT.0.D0) THEN
                              CALL RNORML(xran,1,rr) !RANDOM NOISE OFF FIELD
211                           IF (ABS(xran(1)).GT.BCRANSIG) THEN
                                CALL RNORML(xran,1,rr) !RANDOM NOISE OFF FIELD
                                GOTO 211
                              ENDIF
                              BC(I)=BC(I)*(1.+BCRAN*xran(1))
                            ELSE IF(BCRAN.LT.0.D0) THEN
                              BC(I)=BC(I)*(1.-BCRAN)
                            ENDIF
                          ENDIF
                        ELSE
                          IF(BCRAN.GT.0.D0) THEN
                            CALL RNORML(xran,1,rr) !RANDOM NOISE OFF FIELD
221                         IF (ABS(xran(1)).GT.BCRANSIG) THEN
                              CALL RNORML(xran,1,rr) !RANDOM NOISE OFF FIELD
                              GOTO 221
                            ENDIF
                            BC(I)=BC(I)*(1.+BCRAN*xran(1))
                          ELSE IF(BCRAN.LT.0.D0) THEN
                            BC(I)=BC(I)*(1.-BCRAN)
                          ENDIF
                        ENDIF
                      ENDIF
                    ENDDO
                  ENDIF   !NURANMOD
                ENDIF   !(BCRAN.NE.0.D0)

              ENDIF

            ENDIF   !UHELI

          ENDDO   !IRECU

        ENDIF  !(IRECU.NE.0)

C--- SIMPLE PLANAR UNDULATOR}

        IF (IRECMODU.NE.0) THEN


cerror? 2jun09          IF (ITHEMSYM.EQ.0) ITHEMSYM=1
cerror? 2jun09          IF (ITHESYML.EQ.0) ITHESYML=1
cerror? 2jun09          IF (ITHESYMD.EQ.0) ITHESYMD=1

          CALL MODULATOR(GRARAD)

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     SR MODULATOR:'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     NMAGMOD, NSLICE: ',NMAGMOD,NSLICE
          WRITE(LUNGFO,*)'     SCALMOD, SCALRAD, SCALTHE:'
     &      ,SNGL(SCALMOD),SNGL(SCALRAD),SNGL(SCALTHE)
          WRITE(LUNGFO,*)'     ITHEMSYM,ITHESYML,ITHESYML:',
     &      ITHEMSYM,ITHESYML,ITHESYML
          WRITE(LUNGFO,*)'     THEGROTU,THEGROTL:'
     &      ,SNGL(SCALMOD),SNGL(THEGROTU),SNGL(THEGROTL)
          WRITE(LUNGFO,*)
     &      '     RADIMOD, ZLENMOD, CENMODX, CENMODY, CENMODZ, THEROT, BCMOD:'
          DO I=1,NMAGMOD
            WRITE(LUNGFO,*)
     &        SNGL(RADIMOD(I)),SNGL(ZLENMOD(I)),SNGL(CENMODX(I))
     &        ,SNGL(CENMODY(I))
     &        ,SNGL(CENMODZ(I))
     &        ,SNGL(THEROT(I)),SNGL(BCMOD(I))
          ENDDO
        ENDIF

C APPLY TAPERFUNCTION {

        IF (IHTAPER.NE.0) THEN

          OPEN(unit=LUNFT,file=FILEFTH,status='old')
          READ(LUNFT,'(A80)')COMTAP
          READ(LUNFT,*)XSCL,TSCL
          I=1
100       IF (I.GT.NKLOTZ) THEN
            WRITE(6,*)
     &        '*** ERROR IN REC_INIT: DIMENSION NKLOTZ EXCEEDED  ***'
            WRITE(6,*)
     &        '*** (OPTION IHTAPER)'
            WRITE(LUNGFO,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
            WRITE(LUNGFO,*)
     &        '*** ERROR IN REC_INIT: DIMENSION NKLOTZ EXCEEDED  ***'
            WRITE(LUNGFO,*)
     &        '*** (OPTION IHTAPER)'
            WRITE(LUNGFO,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
            STOP
          ENDIF
          READ(LUNFT,*,END=900)FTX(I),FTY(I)
          FTX(I)=FTX(I)*XSCL
          FTY(I)=FTY(I)*TSCL
          I=I+1
          GOTO 100
900       NFUNTAP=I-1
          CLOSE(LUNFT)

          WRITE(LUNGFO,*)' '
          WRITE(LUNGFO,*)'      taper function applied form file:'
          WRITE(LUNGFO,*)'      ',FILEFTH
          WRITE(LUNGFO,*)'      user comment on file:'
          WRITE(LUNGFO,*)'      ',COMTAP
          WRITE(LUNGFO,*)' '

          CALL UTIL_SPLINE_COEF(FTX,FTY,NFUNTAP,-9999.0d0,-9999.0d0,FT2,F1,F2,F3,F4)

          DO I=1,IMAGTOT

            CALL UTIL_SPLINE_INTER(FTX,FTY,FT2,NFUNTAP,DX(I),DYFT,0)
c REALLY ASKING FOR DY!!
            IF (DY(I).GE.0.D0) DZ(I)=DZ(I)+DYFT
            IF (DY(I).LT.0.D0) DZ(I)=DZ(I)-DYFT

          ENDDO

        ENDIF  !IHTAPER

C APPLY TAPERFUNCTION }

C APPLY TAPERFUNCTION {

        IF (IVTAPER.NE.0) THEN

          OPEN(unit=LUNFT,file=FILEFTV,status='old')
          READ(LUNFT,'(A80)')COMTAP
          READ(LUNFT,*)XSCL,TSCL
          I=1
101       IF (I.GT.NKLOTZ) THEN
            WRITE(6,*)
     &        '*** ERROR IN REC_INIT: DIMENSION NKLOTZ EXCEEDED  ***'
            WRITE(6,*)
     &        '*** (OPTION IVTAPER)'
            WRITE(LUNGFO,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
            WRITE(LUNGFO,*)
     &        '*** ERROR IN REC_INIT: DIMENSION NKLOTZ EXCEEDED  ***'
            WRITE(LUNGFO,*)
     &        '*** (OPTION IVTAPER)'
            WRITE(LUNGFO,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
            STOP
          ENDIF
          READ(LUNFT,*,END=901)FTX(I),FTY(I)
          FTX(I)=FTX(I)*XSCL
          FTY(I)=FTY(I)*TSCL
          I=I+1
          GOTO 101
901       NFUNTAP=I-1
          CLOSE(LUNFT)

          WRITE(LUNGFO,*)' '
          WRITE(LUNGFO,*)'      taper function applied form file:'
          WRITE(LUNGFO,*)'      ',FILEFTV
          WRITE(LUNGFO,*)'      user comment on file:'
          WRITE(LUNGFO,*)'      ',COMTAP
          WRITE(LUNGFO,*)' '

          CALL UTIL_SPLINE_COEF(FTX,FTY,NFUNTAP,-9999.0d0,-9999.0d0,FT2,F1,F2,F3,F4)

          DO I=1,IMAGTOT

            CALL UTIL_SPLINE_INTER(FTX,FTY,FT2,NFUNTAP,DX(I),DYFT,0)
            IF (DY(I).GE.0.D0) DY(I)=DY(I)+DYFT
            IF (DY(I).LT.0.D0) DY(I)=DY(I)-DYFT

          ENDDO

        ENDIF  !IVTAPER

C APPLY TAPERFUNCTION }


C SORT MAGNETS {

        DO I=1,IMAGTOT
          DXS(I)=DX(I)
        ENDDO

        CALL UTIL_SORT_FUNC(IMAGTOT,DX,DY)

        DO I=1,IMAGTOT
          DX(I)=DXS(I)
        ENDDO
        CALL UTIL_SORT_FUNC(IMAGTOT,DX,DZ)

        DO I=1,IMAGTOT
          DX(I)=DXS(I)
        ENDDO
        CALL UTIL_SORT_FUNC(IMAGTOT,DX,THETA)

        DO I=1,IMAGTOT
          DX(I)=DXS(I)
        ENDDO
        CALL UTIL_SORT_FUNC(IMAGTOT,DX,PHI)

        DO I=1,IMAGTOT
          DX(I)=DXS(I)
        ENDDO

        CALL UTIL_SORT_FUNC(IMAGTOT,DX,BC)
        DO I=1,IMAGTOT
          DX(I)=DXS(I)
        ENDDO

        CALL UTIL_SORT_FUNC(IMAGTOT,DX,XLEN)
        DO I=1,IMAGTOT
          DX(I)=DXS(I)
        ENDDO

        CALL UTIL_SORT_FUNC(IMAGTOT,DX,YLEN)
        DO I=1,IMAGTOT
          DX(I)=DXS(I)
        ENDDO

        CALL UTIL_SORT_FUNC(IMAGTOT,DX,ZLEN)

      ENDIF   !IKRESTOR

      IF (IKRESTOR.LT.0) THEN

        open(unit=99,FILE='rec.store',STATUS='NEW')

        WRITE(99,'(I10,A80)')ICODE,CODE
        WRITE(99,*)IMAGTOT
        DO IMAG=1,IMAGTOT
          WRITE(99,*)XLEN(IMAG),YLEN(IMAG),ZLEN(IMAG)
          WRITE(99,*)THETA(IMAG),PHI(IMAG),BC(IMAG)
          WRITE(99,*)DX(IMAG),DY(IMAG),DZ(IMAG)
        ENDDO

        CLOSE(99)

      ELSE IF (IKRESTOR.GT.0) THEN

        open(unit=99,FILE='rec.restore',STATUS='OLD')

        READ(99,*)IMAGTOT
        READ(99,*)IMAGTOT
        DO IMAG=1,IMAGTOT
          READ(99,*)XLEN(IMAG),YLEN(IMAG),ZLEN(IMAG)
          READ(99,*)THETA(IMAG),PHI(IMAG),BC(IMAG)
          READ(99,*)DX(IMAG),DY(IMAG),DZ(IMAG)
        ENDDO

        CLOSE(99)

      ENDIF !IKRESTOR

      IF (KBPOLYMAG.LT.0) THEN

        CSTAR='* '

        open(unit=99,FILE='wave_to_polymag.dat',STATUS='NEW',RECL=128)

        WRITE(99,*)'*** ------------------------------------------------'
        WRITE(99,*)'*** Begin of wave_to_polymag.dat'

        WRITE(99,*)CSTAR,ICODE,CODE(1:64)
        WRITE(99,*)IMAGTOT,' ! number of magnets'

        DO IMAG=1,IMAGTOT

          COSPHI=DCOS(PHI(IMAG))
          SINPHI=DSIN(PHI(IMAG))
          COSTHE=DCOS(THETA(IMAG))
          SINTHE=DSIN(THETA(IMAG))

          IF (ABS(COSTHE).LT.1.0E-12) COSTHE=0.0D0
          IF (ABS(COSPHI).LT.1.0E-12) COSPHI=0.0D0
          IF (ABS(SINTHE).LT.1.0E-12) SINTHE=0.0D0
          IF (ABS(SINPHI).LT.1.0E-12) SINPHI=0.0D0

          IF (ABS(COSTHE-1.0D0).LT.1.0E-12) COSTHE=1.0D0
          IF (ABS(SINTHE-1.0D0).LT.1.0E-12) SINTHE=1.0D0
          IF (ABS(COSPHI-1.0D0).LT.1.0E-12) COSPHI=1.0D0
          IF (ABS(SINPHI-1.0D0).LT.1.0E-12) SINPHI=1.0D0

          IF (ABS(COSTHE+1.0D0).LT.1.0E-12) COSTHE=-1.0D0
          IF (ABS(SINTHE+1.0D0).LT.1.0E-12) SINTHE=-1.0D0
          IF (ABS(COSPHI+1.0D0).LT.1.0E-12) COSPHI=-1.0D0
          IF (ABS(SINPHI+1.0D0).LT.1.0E-12) SINPHI=-1.0D0

          B0=BC(IMAG)

          VBX=COSPHI*SINTHE
          VBY=       COSTHE
          VBZ=SINPHI*SINTHE

          IF (B0.LT.0) THEN
            VBX=-VBX
            VBY=-VBY
            VBZ=-VBZ
            B0=-B0
          ENDIF

          write(99,*)'* magnet ',imag
          WRITE(99,*)sngl(DX(IMAG)),sngl(DY(IMAG)),sngl(DZ(IMAG)),
     &      ' !position of magnet'
          WRITE(99,*)B0,VBX,VBY,VBZ,
     &      ' !length bc and components of mag. vector (after rotation)'
          WRITE(99,*)'-6 1'
          WRITE(99,*)SNGL(ABS(XLEN(IMAG))),SNGL(ABS(YLEN(IMAG))),
     &      SNGL(ABS(ZLEN(IMAG))),
     &      ' !x,y,z dimensions of rectangular magnet'
          write(99,*)'*'
        ENDDO

        WRITE(99,*)'*** End of wave_to_polymag.dat'
        WRITE(99,*)'*** ------------------------------------------------'

        CLOSE(99)

      ENDIF !IKBPOLYMAG
C DEFAULT TRACKING RANGE

      DO I=1,IMAGTOT

        IF (XSTART.EQ.9999..AND.BC(I).NE.0.0)
     &    XSTART=DX(I)/1000.D0-RANGREC
        IF (XSTOP.EQ.9999..AND.BC(IMAGTOT+1-I).NE.0.0)
     &    XSTOP= DX(IMAGTOT+1-I)/1000.D0+RANGREC

      ENDDO

C SORT MAGNETS }

      IF (IPLREC.NE.0) CALL REC_PLOTM
      IF (IPLREC.EQ.9999.OR.IPLREC.EQ.-9999)
     &  STOP '*** WAVE TERMINATED DUE TO IPLREC***'

      RETURN
      end
+DECK,REC_PLAN.
*CMZ :  4.00/15 27/04/2022  08.36.21  by  Michael Scheer
*CMZ :  3.06/00 15/02/2019  17.36.39  by  Michael Scheer
*CMZ :  3.03/02 04/03/2016  18.30.51  by  Michael Scheer
*CMZ :  3.02/03 03/11/2014  12.08.57  by  Michael Scheer
*CMZ :  2.41/13 03/09/2002  14.04.33  by  Michael Scheer
*CMZ :  2.41/12 22/08/2002  10.53.09  by  Michael Scheer
*CMZ :  2.41/11 21/08/2002  10.56.44  by  Michael Scheer
*CMZ :  2.16/04 20/06/2000  17.34.04  by  Michael Scheer
*CMZ :  2.16/00 24/05/2000  18.51.09  by  Michael Scheer
*CMZ :  2.15/00 19/05/2000  10.21.20  by  Michael Scheer
*CMZ :  2.14/00 18/04/2000  11.44.03  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE REC_PLAN(IUREC,GRARAD)
+seq,gplhint.

C EACH UNDULATOR POLE CONSIST OF 3 UPPER AND 3 LOWER MAGNETS
C
C     HALF LENGTH | FULL LENGTH | HALF LENGTH
C       -----------   -----------   -----------
C     HALF LENGTH | FULL LENGTH | HALF LENGTH
C
C THE ENDPOLES CONSISTS OF A FULL PERIOD. THE TWO ENDPOLES HAVE OPPOSITE FIELD.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,KLOTZ.
+SEQ,USERVAR.

      INTEGER IPER,IUREC,IMAGTOTO,I,IMAGTOTS,NPOLMAIN,NPOLTOT,J,NMAGNETS

      DOUBLE PRECISION RECEND,TOTLEN,TOTLEN2,GRARAD,DX1,BDIFF
     &  ,BCORRI,BCORRE,UBCSUM,UBCSUM2,BCSIGN,B0,B0V
     &  ,XLENS(NKLOTZ),YLENS(NKLOTZ),ZLENS(NKLOTZ)
     &  ,DXS(NKLOTZ),DYS(NKLOTZ),DZS(NKLOTZ)
     &  ,THETAS(NKLOTZ),PHIS(NKLOTZ),BCS(NKLOTZ),ANGERR

      REAL xran(NKLOTZ),YRAN(NKLOTZ),XWALK,XCORR,rr(2)

      IMAGTOTS=IMAGTOT
      UBCSUM=0.D0
      UBCSUM2=0.D0

C--- UPPER AND LOWER POLES ARE CONSIDERED AS ONE!! POLE

      NMAGNETS=(KRECPER(IUREC)+2)*12
      NPOLMAIN=2*KRECPER(IUREC)
      NPOLTOT=NPOLMAIN+2*2

      TOTLEN=(2+KRECPER(IUREC))*4.D0*URECLX(IUREC)
      TOTLEN2=TOTLEN/2.D0
      RECEND=URECCX(IUREC)-TOTLEN2

C--- FIRST ENDPOLE{

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF

      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=270.D0*GRARAD
      PHI(IMAGTOT)=0.D0*GRARAD
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
      DX1=DX(IMAGTOT)
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)
      DZ(IMAGTOT)=URECCZ(IUREC)
      BC(IMAGTOT)=-URECBC(IUREC)/4.D0
      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=90.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=URECCZ(IUREC)
      BC(IMAGTOT)=-URECBC(IUREC)/4.D0
      RECEND=RECEND+XLEN(IMAGTOT)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=0.D0
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)
      DZ(IMAGTOT)=URECCZ(IUREC)
      BC(IMAGTOT)=-URECBC(IUREC)/4.D0
      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=0.D0
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=URECCZ(IUREC)
      BC(IMAGTOT)=-URECBC(IUREC)/4.D0
      RECEND=RECEND+XLEN(IMAGTOT)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=90.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)
      DZ(IMAGTOT)=URECCZ(IUREC)
      BC(IMAGTOT)=-URECBC(IUREC)/4.D0
      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=270.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=URECCZ(IUREC)
      BC(IMAGTOT)=-URECBC(IUREC)/4.D0
      RECEND=RECEND+XLEN(IMAGTOT)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=90.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)
      DZ(IMAGTOT)=URECCZ(IUREC)
      BC(IMAGTOT)=-URECBC(IUREC)*0.75D0
      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=270.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=URECCZ(IUREC)
      BC(IMAGTOT)=-URECBC(IUREC)*0.75D0
      RECEND=RECEND+XLEN(IMAGTOT)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=180.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)
      DZ(IMAGTOT)=URECCZ(IUREC)
      BC(IMAGTOT)=-URECBC(IUREC)*0.75D0
      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=180.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=URECCZ(IUREC)
      BC(IMAGTOT)=-URECBC(IUREC)*0.75D0
      RECEND=RECEND+XLEN(IMAGTOT)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=270.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)
      DZ(IMAGTOT)=URECCZ(IUREC)
      BC(IMAGTOT)=-URECBC(IUREC)*0.75D0
      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=90.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=URECCZ(IUREC)
      BC(IMAGTOT)=-URECBC(IUREC)*0.75D0
      RECEND=RECEND+XLEN(IMAGTOT)

C--- FIRST ENDPOLE}

      IMAGTOTO=IMAGTOT
      DO IPER=1,KRECPER(IUREC)

        IMAGTOT=IMAGTOT+1
        IF(IMAGTOT.GT.NKLOTZ) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
          WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
          WRITE(6,*)
          STOP
        ENDIF

        XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
        YLEN(IMAGTOT)=URECLY(IUREC)
        ZLEN(IMAGTOT)=URECLZ(IUREC)
        THETA(IMAGTOT)=90.D0*GRARAD
        PHI(IMAGTOT)=0.D0
        DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
        DY(IMAGTOT)=URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)
        DZ(IMAGTOT)=URECCZ(IUREC)
        BC(IMAGTOT)=URECBC(IUREC)

        dmupar(IMAGTOT)=URECmupar(IUREC)
        dmuper(IMAGTOT)=URECmuper(IUREC)

        IMAGTOT=IMAGTOT+1
        IF(IMAGTOT.GT.NKLOTZ) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
          WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
          WRITE(6,*)
          STOP
        ENDIF
        XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
        YLEN(IMAGTOT)=URECLY(IUREC)
        ZLEN(IMAGTOT)=URECLZ(IUREC)
        THETA(IMAGTOT)=270.D0*GRARAD
        PHI(IMAGTOT)=0.D0
        DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
        DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
        DZ(IMAGTOT)=URECCZ(IUREC)
        BC(IMAGTOT)=URECBC(IUREC)

        dmupar(IMAGTOT)=URECmupar(IUREC)
        dmuper(IMAGTOT)=URECmuper(IUREC)

        RECEND=RECEND+XLEN(IMAGTOT)

        IMAGTOT=IMAGTOT+1
        IF(IMAGTOT.GT.NKLOTZ) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
          WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
          WRITE(6,*)
          STOP
        ENDIF
        XLEN(IMAGTOT)=URECLX(IUREC)
        YLEN(IMAGTOT)=URECLY(IUREC)
        ZLEN(IMAGTOT)=URECLZ(IUREC)
        THETA(IMAGTOT)=180.D0*GRARAD
        PHI(IMAGTOT)=0.D0
        DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
        DY(IMAGTOT)=URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)
        DZ(IMAGTOT)=URECCZ(IUREC)
        BC(IMAGTOT)=URECBC(IUREC)

        dmupar(IMAGTOT)=URECmupar(IUREC)
        dmuper(IMAGTOT)=URECmuper(IUREC)

        IMAGTOT=IMAGTOT+1
        IF(IMAGTOT.GT.NKLOTZ) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
          WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
          WRITE(6,*)
          STOP
        ENDIF
        XLEN(IMAGTOT)=URECLX(IUREC)
        YLEN(IMAGTOT)=URECLY(IUREC)
        ZLEN(IMAGTOT)=URECLZ(IUREC)
        THETA(IMAGTOT)=180.D0*GRARAD
        PHI(IMAGTOT)=0.D0
        DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
        DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
        DZ(IMAGTOT)=URECCZ(IUREC)
        BC(IMAGTOT)=URECBC(IUREC)

        dmupar(IMAGTOT)=URECmupar(IUREC)
        dmuper(IMAGTOT)=URECmuper(IUREC)

        RECEND=RECEND+XLEN(IMAGTOT)

        IMAGTOT=IMAGTOT+1
        IF(IMAGTOT.GT.NKLOTZ) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
          WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
          WRITE(6,*)
          STOP
        ENDIF
        XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
        YLEN(IMAGTOT)=URECLY(IUREC)
        ZLEN(IMAGTOT)=URECLZ(IUREC)
        THETA(IMAGTOT)=270.D0*GRARAD
        PHI(IMAGTOT)=0.D0
        DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
        DY(IMAGTOT)=URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)
        DZ(IMAGTOT)=URECCZ(IUREC)
        BC(IMAGTOT)=URECBC(IUREC)

        dmupar(IMAGTOT)=URECmupar(IUREC)
        dmuper(IMAGTOT)=URECmuper(IUREC)

        IMAGTOT=IMAGTOT+1
        IF(IMAGTOT.GT.NKLOTZ) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
          WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
          WRITE(6,*)
          STOP
        ENDIF
        XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
        YLEN(IMAGTOT)=URECLY(IUREC)
        ZLEN(IMAGTOT)=URECLZ(IUREC)
        THETA(IMAGTOT)=90.D0*GRARAD
        PHI(IMAGTOT)=0.D0
        DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
        DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
        DZ(IMAGTOT)=URECCZ(IUREC)
        BC(IMAGTOT)=URECBC(IUREC)
      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)
        RECEND=RECEND+XLEN(IMAGTOT)

        IMAGTOT=IMAGTOT+1
        IF(IMAGTOT.GT.NKLOTZ) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
          WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
          WRITE(6,*)
          STOP
        ENDIF
        XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
        YLEN(IMAGTOT)=URECLY(IUREC)
        ZLEN(IMAGTOT)=URECLZ(IUREC)
        THETA(IMAGTOT)=270.D0*GRARAD
        PHI(IMAGTOT)=0.D0
        DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
        DY(IMAGTOT)=URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)
        DZ(IMAGTOT)=URECCZ(IUREC)
        BC(IMAGTOT)=URECBC(IUREC)

        dmupar(IMAGTOT)=URECmupar(IUREC)
        dmuper(IMAGTOT)=URECmuper(IUREC)

        IMAGTOT=IMAGTOT+1
        IF(IMAGTOT.GT.NKLOTZ) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
          WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
          WRITE(6,*)
          STOP
        ENDIF
        XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
        YLEN(IMAGTOT)=URECLY(IUREC)
        ZLEN(IMAGTOT)=URECLZ(IUREC)
        THETA(IMAGTOT)=90.D0*GRARAD
        PHI(IMAGTOT)=0.D0
        DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
        DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
        DZ(IMAGTOT)=URECCZ(IUREC)
        BC(IMAGTOT)=URECBC(IUREC)

        dmupar(IMAGTOT)=URECmupar(IUREC)
        dmuper(IMAGTOT)=URECmuper(IUREC)

        RECEND=RECEND+XLEN(IMAGTOT)

        IMAGTOT=IMAGTOT+1
        IF(IMAGTOT.GT.NKLOTZ) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
          WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
          WRITE(6,*)
          STOP
        ENDIF
        XLEN(IMAGTOT)=URECLX(IUREC)
        YLEN(IMAGTOT)=URECLY(IUREC)
        ZLEN(IMAGTOT)=URECLZ(IUREC)
        THETA(IMAGTOT)=0.D0*GRARAD
        PHI(IMAGTOT)=0.D0
        DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
        DY(IMAGTOT)=URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)
        DZ(IMAGTOT)=URECCZ(IUREC)
        BC(IMAGTOT)=URECBC(IUREC)

        dmupar(IMAGTOT)=URECmupar(IUREC)
        dmuper(IMAGTOT)=URECmuper(IUREC)

        IMAGTOT=IMAGTOT+1
        IF(IMAGTOT.GT.NKLOTZ) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
          WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
          WRITE(6,*)
          STOP
        ENDIF
        XLEN(IMAGTOT)=URECLX(IUREC)
        YLEN(IMAGTOT)=URECLY(IUREC)
        ZLEN(IMAGTOT)=URECLZ(IUREC)
        THETA(IMAGTOT)=0.D0*GRARAD
        PHI(IMAGTOT)=0.D0
        DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
        DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
        DZ(IMAGTOT)=URECCZ(IUREC)
        BC(IMAGTOT)=URECBC(IUREC)

        dmupar(IMAGTOT)=URECmupar(IUREC)
        dmuper(IMAGTOT)=URECmuper(IUREC)

        RECEND=RECEND+XLEN(IMAGTOT)

        IMAGTOT=IMAGTOT+1
        IF(IMAGTOT.GT.NKLOTZ) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
          WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
          WRITE(6,*)
          STOP
        ENDIF
        XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
        YLEN(IMAGTOT)=URECLY(IUREC)
        ZLEN(IMAGTOT)=URECLZ(IUREC)
        THETA(IMAGTOT)=90.D0*GRARAD
        PHI(IMAGTOT)=0.D0
        DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
        DY(IMAGTOT)=URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)
        DZ(IMAGTOT)=URECCZ(IUREC)
        BC(IMAGTOT)=URECBC(IUREC)

        dmupar(IMAGTOT)=URECmupar(IUREC)
        dmuper(IMAGTOT)=URECmuper(IUREC)

        IMAGTOT=IMAGTOT+1
        IF(IMAGTOT.GT.NKLOTZ) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
          WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
          WRITE(6,*)
          STOP
        ENDIF
        XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
        YLEN(IMAGTOT)=URECLY(IUREC)
        ZLEN(IMAGTOT)=URECLZ(IUREC)
        THETA(IMAGTOT)=270.D0*GRARAD
        PHI(IMAGTOT)=0.D0
        DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
        DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
        DZ(IMAGTOT)=URECCZ(IUREC)
        BC(IMAGTOT)=URECBC(IUREC)

        dmupar(IMAGTOT)=URECmupar(IUREC)
        dmuper(IMAGTOT)=URECmuper(IUREC)

        RECEND=RECEND+XLEN(IMAGTOT)

      ENDDO !KRECPER

      IF (BCRAN.NE.0.D0) THEN
        IF (NURANMOD.EQ.1) THEN
          CALL RNORML(xran,NMAGNETS,rr)
          DO I=1,NKLOTZ
12          IF (ABS(xran(I)).GT.BCRANSIG) THEN
              CALL RNORML(xran(I),1,rr)
              GOTO 12
            ENDIF
          ENDDO
          DO I=1,NKLOTZ
            IF (DX(I)-XLEN(I)/2.D0.LT.BCSTART
     &          .OR.DX(I)+XLEN(I)/2.D0.GT.BCEND) THEN
              xran(I)=0.
            ENDIF
          ENDDO
          IF (BCRAN.GE.0.D0) THEN
            DO I=1,NKLOTZ
              YRAN(I)=xran(I)*BCRAN
            ENDDO
          ELSE
            DO I=1,NKLOTZ
              YRAN(I)=-BCRAN
            ENDDO
          ENDIF
          DO I=IMAGTOTO+1,IMAGTOTO+6
            xran(I)=YRAN(I+6)/2.
            YRAN(I)=0.D0
          ENDDO   !IMAG
          DO I=IMAGTOT-5,IMAGTOT
            YRAN(I)=0.D0
          ENDDO   !IMAG
          DO I=IMAGTOTO+7,IMAGTOT-6
            xran(I)=YRAN(I)+YRAN(I-6)/2.+YRAN(I+6)/2. ! "+" due to angles
          ENDDO   !IMAG
          DO I=IMAGTOT-5,IMAGTOT
            xran(I)=YRAN(I-6)/2.
          ENDDO   !IMAG
          DO I=IMAGTOTO+1,IMAGTOT
            BC(I)=BC(I)*(1.+xran(I))
          ENDDO   !IMAG
        ELSE IF (NURANMOD.EQ.2) THEN
          CALL RNORML(xran,NMAGNETS,rr)
          DO I=1,NKLOTZ
22          IF (ABS(xran(I)).GT.BCRANSIG) THEN
              CALL RNORML(xran(I),1,rr)
              GOTO 22
            ENDIF
          ENDDO
          DO I=1,NKLOTZ
            IF (DX(I)-XLEN(I)/2.D0.LT.BCSTART
     &          .OR.DX(I)+XLEN(I)/2.D0.GT.BCEND) THEN
              xran(I)=0.
            ENDIF
          ENDDO
          IF (BCRAN.GE.0.D0) THEN
            DO I=1,NKLOTZ
              YRAN(I)=xran(I)*BCRAN
            ENDDO
          ELSE
            DO I=1,NKLOTZ
              YRAN(I)=-BCRAN
            ENDDO
          ENDIF
          DO I=IMAGTOT-5,IMAGTOT
            YRAN(I)=0.D0
          ENDDO   !IMAG
          DO I=IMAGTOTO+1,IMAGTOT-6
            xran(I)=YRAN(I)+YRAN(I+6) ! "+" due to angles
          ENDDO   !IMAG
          DO I=IMAGTOT-5,IMAGTOT
            xran(I)=YRAN(I-6)
          ENDDO   !IMAG
          DO I=IMAGTOTO+1,IMAGTOT
            IF (DX(I)-XLEN(I)/2.D0.GE.BCSTART
     &          .AND.DX(I)+XLEN(I)/2.D0.LE.BCEND) THEN
              BC(I)=BC(I)*(1.+xran(I))
            ENDIF
          ENDDO   !IMAG
        ENDIF  !(NRANMOD.EQ...)
      ENDIF !(BCRAN.NE.0.D0)

C--- LAST ENDPOLE{

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=90.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)
      DZ(IMAGTOT)=URECCZ(IUREC)
      BC(IMAGTOT)=URECBC(IUREC)*0.75D0

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=270.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=URECCZ(IUREC)
      BC(IMAGTOT)=URECBC(IUREC)*0.75D0

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      RECEND=RECEND+XLEN(IMAGTOT)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=180.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)
      DZ(IMAGTOT)=URECCZ(IUREC)
      BC(IMAGTOT)=URECBC(IUREC)*0.75D0

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=180.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=URECCZ(IUREC)
      BC(IMAGTOT)=URECBC(IUREC)*0.75D0

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      RECEND=RECEND+XLEN(IMAGTOT)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=270.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)
      DZ(IMAGTOT)=URECCZ(IUREC)
      BC(IMAGTOT)=URECBC(IUREC)*0.75D0

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=90.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=URECCZ(IUREC)
      BC(IMAGTOT)=URECBC(IUREC)*0.75D0

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      RECEND=RECEND+XLEN(IMAGTOT)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=270.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)
      DZ(IMAGTOT)=URECCZ(IUREC)
      BC(IMAGTOT)=URECBC(IUREC)/4.D0

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=90.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=URECCZ(IUREC)
      BC(IMAGTOT)=URECBC(IUREC)/4.D0

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      RECEND=RECEND+XLEN(IMAGTOT)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=0.D0
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)
      DZ(IMAGTOT)=URECCZ(IUREC)
      BC(IMAGTOT)=URECBC(IUREC)/4.D0

      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=0.D0
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=URECCZ(IUREC)
      BC(IMAGTOT)=URECBC(IUREC)/4.D0
      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)
      RECEND=RECEND+XLEN(IMAGTOT)

      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=90.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
      DY(IMAGTOT)=URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC)
      DZ(IMAGTOT)=URECCZ(IUREC)
      BC(IMAGTOT)=URECBC(IUREC)/4.D0
      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)
      IMAGTOT=IMAGTOT+1
      IF(IMAGTOT.GT.NKLOTZ) THEN
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
        WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
        WRITE(6,*)
        STOP
      ENDIF
      XLEN(IMAGTOT)=URECLX(IUREC)/2.D0
      YLEN(IMAGTOT)=URECLY(IUREC)
      ZLEN(IMAGTOT)=URECLZ(IUREC)
      THETA(IMAGTOT)=270.D0*GRARAD
      PHI(IMAGTOT)=0.D0
      DX(IMAGTOT)=RECEND+XLEN(IMAGTOT)/2.D0
      DY(IMAGTOT)=-(URECLY(IUREC)/2.D0+URECGAP(IUREC)+(DX(IMAGTOT)-DX1)*UTAPER(IUREC))
      DZ(IMAGTOT)=URECCZ(IUREC)
      BC(IMAGTOT)=URECBC(IUREC)/4.D0
      dmupar(IMAGTOT)=URECmupar(IUREC)
      dmuper(IMAGTOT)=URECmuper(IUREC)
      RECEND=RECEND+XLEN(IMAGTOT)

C--- LAST ENDPOLE}

      B0=BC(IMAGTOTS+15)

      IF (BCRAN.NE.0.D0) THEN
        IF (NURANMOD.EQ.0) THEN
          CALL RNORML(xran,NMAGNETS,rr) !RANDOM NOISE OFF FIELD
          DO I=1,NKLOTZ
111         IF (ABS(xran(I)).GT.BCRANSIG) THEN
              CALL RNORML(xran(I),1,rr)
              GOTO 111
            ENDIF
          ENDDO
          DO I=IMAGTOTS+1,IMAGTOT
            IF (DX(I).GE.BCSTART.AND.DX(I).LE.BCEND) THEN
              IF (K90270.NE.0) THEN
                IF (ABS(ABS(THETA(I)/GRARAD)-90.D0).LT.1.
     &              .OR.ABS(ABS(THETA(I)/GRARAD)-270.D0).LT.1.)  THEN
                  IF(BCRAN.GT.0.D0) THEN
                    BC(I)=BC(I)*(1.+BCRAN*xran(I))
                  ELSE IF(BCRAN.LT.0.D0) THEN
                    BC(I)=BC(I)*(1.-BCRAN)
                  ENDIF !BCRAN
                ENDIF    !THETA
              ELSE  !K90270
                IF(BCRAN.GT.0.D0) THEN
                  BC(I)=BC(I)*(1.+BCRAN*xran(I))
                ELSE IF(BCRAN.LT.0.D0) THEN
                  BC(I)=BC(I)*(1.-BCRAN)
                ENDIF   !BCRAN
              ENDIF !K90270
            ENDIF   !BCSTART
          ENDDO !I

        ELSE IF (NURANMOD.EQ.3.OR.NURANMOD.EQ.4) THEN

          DO I=1,IMAGTOT
            BCS(I)=BC(I)
          ENDDO

          CALL RNORML(xran,NMAGNETS,rr) !RANDOM NOISE OFF FIELD
          DO I=1,NKLOTZ
222         IF (ABS(xran(I)).GT.BCRANSIG) THEN
              CALL RNORML(xran(I),1,rr)
              GOTO 222
            ENDIF
          ENDDO
          DO I=IMAGTOTS+14+1,IMAGTOT+1-14,6
            BC(I-2)=BC(I-2)*(1.+BCRAN*xran(I))
            BC(I-1)=BC(I-1)*(1.+BCRAN*xran(I))
            BC(I)=BC(I)*(1.+BCRAN*xran(I))
            BC(I+1)=BC(I+1)*(1.+BCRAN*xran(I))
            BC(I+2)=BC(I+2)*(1.+BCRAN*xran(I))
            BC(I+3)=BC(I+3)*(1.+BCRAN*xran(I))
          ENDDO !I

          IF (UBANGERR(IUREC).EQ.0.D0) THEN

C--- COMPENSATE THE KICK

            BDIFF=0.D0
            DO I=IMAGTOTS+15,IMAGTOT+1-16,12
              BDIFF=BDIFF-BC(I)-BC(I+1)+BC(I+6)+BC(I+7)
            ENDDO !I

            BCORRI=1.D0-BDIFF/2./B0
            BCORRE=1.D0+BDIFF/2./B0

            DO I=1,12
              BC(IMAGTOTS+I)=BC(IMAGTOTS+I)*BCORRI
            ENDDO

            DO I=1,12
              BC(IMAGTOT+1-I)=BC(IMAGTOT+1-I)*BCORRE
            ENDDO

C--- ENDPOLES

            IF (NURANMOD.EQ.4) THEN

C--- COMPENSATE OFFSET WITH BY ENDPOLE

              UBCSUM2=0.D0
              DO I=1,NPOLTOT
                IF (I.EQ.1) THEN
                  BCSIGN=1.D0
                ELSE IF(I.EQ.2) THEN
                  BCSIGN=-1.D0
                ELSE IF(I.EQ.NPOLTOT-1) THEN
                  BCSIGN=-1.D0
                ELSE IF(I.EQ.NPOLTOT) THEN
                  BCSIGN=1.D0
                ELSE
                  BCSIGN=(-1.D0)**I
                ENDIF
                J=-3+I*6
                UBCSUM2=UBCSUM2+(NPOLTOT+1-I)*BCSIGN*(BC(J)+BC(J+1))
              ENDDO !I

              BCORRI=1.D0-UBCSUM2/(NPOLTOT-2)/B0

              DO I=1,12
                BC(IMAGTOTS+I)=BC(IMAGTOTS+I)*BCORRI
              ENDDO

              BCORRE=BCORRI

              DO I=1,12
                BC(IMAGTOT+1-I)=BC(IMAGTOT+1-I)*BCORRE
              ENDDO
            ENDIF   !NURANMOD.EQ.4

C--- FINAL FIRST INTEGRAL
C
C     UBCSUM=0.D0
C     UBCSUM=BC(IMAGTOTS + 3)+BC(IMAGTOTS + 4)
C     &            -BC(IMAGTOTS + 9)-BC(IMAGTOTS +10)
C     &            -BC(IMAGTOT+1-10)-BC(IMAGTOT+1- 9)
C     &            +BC(IMAGTOT+1- 4)+BC(IMAGTOT+1- 3)
C
C     DO I=IMAGTOTS+15,IMAGTOT+1-16,12
C        UBCSUM=UBCSUM-BC(I)-BC(I+1)+BC(I+6)+BC(I+7)
C     ENDDO !I

          ENDIF  !NURANMOD
        ENDIF !(UBANGERR(IUREC.EQ.0.D0)
      ENDIF !(BCRAN.NE.0.D0)

C--- NOW THE ANGLE ERRORS

      IF (UBANGERR(IUREC).NE.0.D0) THEN

        IMAGTOT=IMAGTOT+NMAGNETS

        IF(IMAGTOT.GT.NKLOTZ) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN REC_PLAN: DIMENSION EXCEEDED ***'
          WRITE(6,*)'INCREASE PARAMETER NKLOTZ IN FILE KLOTZ.CMN'
          WRITE(6,*)
          STOP
        ENDIF

        DO I=IMAGTOTS+1,IMAGTOTS+NMAGNETS
          XLENS(2*I-1)=XLEN(I)
          XLENS(2*I)=XLEN(I)
          YLENS(2*I-1)=YLEN(I)
          YLENS(2*I)=YLEN(I)
          ZLENS(2*I-1)=ZLEN(I)
          ZLENS(2*I)=ZLEN(I)
          DXS(2*I-1)=DX(I)
          DXS(2*I)=DX(I)
          DYS(2*I-1)=DY(I)
          DYS(2*I)=DY(I)
          DZS(2*I-1)=DZ(I)
          DZS(2*I)=DZ(I)
          THETAS(2*I-1)=THETA(I)
          THETAS(2*I)=THETA(I)
          PHIS(2*I-1)=PHI(I)
          PHIS(2*I)=PHI(I)
          BCS(2*I-1)=BC(I)
          BCS(2*I)=BC(I)
        ENDDO

        DO I=IMAGTOTS+1,IMAGTOTS+2*NMAGNETS
          XLEN(I)=XLENS(I)
          YLEN(I)=YLENS(I)
          ZLEN(I)=ZLENS(I)
          DX(I)=DXS(I)
          DY(I)=DYS(I)
          DZ(I)=DZS(I)
        ENDDO

        XWALK=0.D0
        XCORR=0.D0
        DO I=1,NMAGNETS,6

123       CALL RNORML(xran,1,rr)
          if (abs(xran(1)).gt.ubansig(iurec)) goto 123
          XWALK=XWALK+(xran(1)-XCORR)
          IF (ABS(XWALK).GT.USIGOFFY(IUREC)) THEN
            XCORR=XWALK/2.D0
          ENDIF
          J=IMAGTOTS+(I+2)*2-1

          ANGERR=(xran(1)-XCORR)*UBANGERR(IUREC)*GRARAD
          BCORRI=SQRT(1.D0+ANGERR**2)

          IF (I.LE.12.OR.I.GT.NMAGNETS-12) THEN

            THETA(J-4)=THETAS(J-4)
            PHI(J-4)=PHIS(J-4)
            BC(J-4)=BCS(J-4)/2.D0
            THETA(J-3)=THETAS(J-3)
            PHI(J-3)=PHIS(J-3)
            BC(J-3)=BCS(J-3)/2.D0

            THETA(J-2)=THETAS(J-2)
            PHI(J-2)=PHIS(J-2)
            BC(J-2)=BCS(J-2)/2.D0
            THETA(J-1)=THETAS(J-1)
            PHI(J-1)=PHIS(J-1)
            BC(J-1)=BCS(J-1)/2.D0

            THETA(J)=THETAS(J)
            PHI(J)=PHIS(J)
            BC(J)=BCS(J)/2.D0
            THETA(J+1)=THETAS(J+1)
            PHI(J+1)=PHIS(J+1)
            BC(J+1)=BCS(J+1)/2.D0

            THETA(J+2)=THETAS(J+2)
            PHI(J+2)=PHIS(J+2)
            BC(J+2)=BCS(J+2)/2.D0
            THETA(J+3)=THETAS(J+3)
            PHI(J+3)=PHIS(J+3)
            BC(J+3)=BCS(J+3)/2.D0

            THETA(J+4)=THETAS(J+4)
            PHI(J+4)=PHIS(J+4)
            BC(J+4)=BCS(J+4)/2.D0
            THETA(J+5)=THETAS(J+5)
            PHI(J+5)=PHIS(J+5)
            BC(J+5)=BCS(J+5)/2.D0

            THETA(J+6)=THETAS(J+6)
            PHI(J+6)=PHIS(J+6)
            BC(J+6)=BCS(J+6)/2.D0
            THETA(J+7)=THETAS(J+7)
            PHI(J+7)=PHIS(J+7)
            BC(J+7)=BCS(J+7)/2.D0

          ELSE

            THETA(J-4)=THETAS(J-4)
            PHI(J-4)=PHIS(J-4)
            BC(J-4)=BCS(J-4)/BCORRI
            THETA(J-3)=90.D0*GRARAD
            PHI(J-3)=90.D0*GRARAD
            BC(J-3)=BCS(J-3)*ANGERR/BCORRI

            THETA(J-2)=THETAS(J-2)
            PHI(J-2)=PHIS(J-2)
            BC(J-2)=BCS(J-2)/BCORRI
            THETA(J-1)=90.D0*GRARAD
            PHI(J-1)=90.D0*GRARAD
            BC(J-1)=BCS(J-1)*ANGERR/BCORRI

            THETA(J)=THETAS(J)
            PHI(J)=PHIS(J)
            BC(J)=BCS(J)/BCORRI
            THETA(J+1)=90.D0*GRARAD
            PHI(J+1)=90.D0*GRARAD
            BC(J+1)=BCS(J+1)*ANGERR/BCORRI

            THETA(J+2)=THETAS(J+2)
            PHI(J+2)=PHIS(J+2)
            BC(J+2)=BCS(J+2)/BCORRI
            THETA(J+3)=90.D0*GRARAD
            PHI(J+3)=90.D0*GRARAD
            BC(J+3)=BCS(J+3)*ANGERR/BCORRI

            THETA(J+4)=THETAS(J+4)
            PHI(J+4)=PHIS(J+4)
            BC(J+4)=BCS(J+4)/BCORRI
            THETA(J+5)=90.D0*GRARAD
            PHI(J+5)=90.D0*GRARAD
            BC(J+5)=BCS(J+5)*ANGERR/BCORRI

            THETA(J+6)=THETAS(J+6)
            PHI(J+6)=PHIS(J+6)
            BC(J+6)=BCS(J+6)/BCORRI
            THETA(J+7)=90.D0*GRARAD
            PHI(J+7)=90.D0*GRARAD
            BC(J+7)=BCS(J+7)*ANGERR/BCORRI

          ENDIF

c     DX(J-3)=DX(J-3)+100.
c     DX(J-1)=DX(J-1)+100.
c     DX(J+1)=DX(J+1)+100.
c     DX(J+3)=DX(J+3)+100.
cc    DX(J+5)=DX(J+5)+100.
c     DX(J+7)=DX(J+7)+100.

        ENDDO

        IF (NURANMOD.EQ.3.OR.NURANMOD.EQ.4) THEN

C--- COMPENSATE THE HORIZONTAL KICK

          BDIFF=0.D0
          DO I=IMAGTOTS+30,IMAGTOT+1-32,24
            BDIFF=BDIFF
     &        -BC(I-1)-BC(I+1)+BC(I+11)+BC(I+13)
          ENDDO !I

          BCORRI=1.D0-BDIFF/2./B0
          BCORRE=1.D0+BDIFF/2./B0

          DO I=1,24
            BC(IMAGTOTS+I)=BC(IMAGTOTS+I)*BCORRI
          ENDDO

          DO I=1,24
            BC(IMAGTOT+1-I)=BC(IMAGTOT+1-I)*BCORRE
          ENDDO

C--- COMPENSATE THE VERTICAL KICK

          BDIFF=0.D0
          DO I=IMAGTOTS+30,IMAGTOT+1-32,24
            BDIFF=BDIFF+BC(I)+BC(I+12)
          ENDDO !I
          B0V=BDIFF

          DO I=1,24,2
            BC(IMAGTOTS+I)=BC(IMAGTOTS+I)*2.D0
          ENDDO

          DO I=2,12,2
            THETA(IMAGTOTS+I)=90.D0*GRARAD
            PHI(IMAGTOTS+I)=90.D0*GRARAD
            BC(IMAGTOTS+I)=+BDIFF/4.D0
          ENDDO

          DO I=14,24,2
            THETA(IMAGTOTS+I)=90.D0*GRARAD
            PHI(IMAGTOTS+I)=90.D0*GRARAD
            BC(IMAGTOTS+I)=-BDIFF*3.D0/4.D0
          ENDDO

          DO I=1,24,2
            BC(IMAGTOT+1-I-1)=BC(IMAGTOT+1-I-1)*2.D0
          ENDDO

          DO I=1,12,2
            THETA(IMAGTOT+1-I)=90.D0*GRARAD
            PHI(IMAGTOT+1-I)=90.D0*GRARAD
            BC(IMAGTOT+1-I)=BDIFF/4.D0
          ENDDO

          DO I=13,24,2
            THETA(IMAGTOT+1-I)=90.D0*GRARAD
            PHI(IMAGTOT+1-I)=90.D0*GRARAD
            BC(IMAGTOT+1-I)=-BDIFF*3.D0/4.D0
          ENDDO

          IF (NURANMOD.EQ.4) THEN

C--- COMPENSATE HORIZONTAL OFFSET WITH BY ENDPOLE

            UBCSUM2=0.D0

            UBCSUM2=UBCSUM2
     &        +NPOLTOT    *(BC(5)+BC(7))
     &        -(NPOLTOT-1)*(BC(17)+BC(19))

            DO I=3,NPOLTOT-2
              BCSIGN=(-1.D0)**I
              J=-7+I*12
              UBCSUM2=UBCSUM2+(NPOLTOT+1-I)*BCSIGN*(BC(J)+BC(J+2))
            ENDDO !I

            J=NPOLTOT*12+1
            UBCSUM2=UBCSUM2
     &        +(BC(J-6)+BC(J-8))
     &        -2.D0*(BC(J-18)+BC(J-20))

            BCORRI=1.D0-UBCSUM2/(NPOLTOT-2)/B0

            DO I=1,24,2
              BC(IMAGTOTS+I)=BC(IMAGTOTS+I)*BCORRI
            ENDDO

            BCORRE=BCORRI

            DO I=1,24,2
              BC(IMAGTOT+1-I-1)=BC(IMAGTOT+1-I-1)*BCORRE
            ENDDO

C--- COMPENSATE VERTICAL OFFSET WITH BY ENDPOLE

            UBCSUM2=0.D0
            DO I=1,NPOLTOT
              J=-7+I*12+1
              UBCSUM2=UBCSUM2+(NPOLTOT+1-I)*(BC(J)+BC(J+2))
            ENDDO !I

            IF (UBCSUM2.NE.0.D0) THEN
              BCORRI=1.D0-UBCSUM2/(NPOLTOT-1)/BC(6)/2.D0
              BCORRE=1.D0+UBCSUM2/(NPOLTOT-1)/BC(IMAGTOT+1-5)/2.D0
            ELSE
              BCORRI=1.D0
              BCORRE=1.D0
            ENDIF

            DO I=1,12,2
              BC(IMAGTOTS+I+1)=BC(IMAGTOTS+I+1)*BCORRI
            ENDDO


            DO I=1,12,2
              BC(IMAGTOT+1-I)=BC(IMAGTOT+1-I)*BCORRE
            ENDDO

          ENDIF   !NURANMOD.EQ.4

        ENDIF  !NURANMOD
      ENDIF !(BANGERR.NE.0.D0)

      RETURN
      END
+DECK,REC_PLOTK.
*CMZ :  3.06/00 15/02/2019  14.50.44  by  Michael Scheer
*CMZ :  3.03/02 08/12/2015  13.47.21  by  Michael Scheer
*CMZ :  3.02/00 10/10/2014  12.26.46  by  Michael Scheer
*CMZ :  3.01/09 12/08/2014  15.15.26  by  Michael Scheer
*CMZ :  3.01/08 11/08/2014  21.00.00  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.57/05 05/12/2006  10.21.08  by  Michael Scheer
*CMZ :  2.52/09 29/10/2004  11.41.44  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.14/00 17/04/2000  15.08.07  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  14.43.04  by  Michael Scheer
*CMZ :  1.00/00 02/06/97  10.57.45  by  Michael Scheer
*CMZ : 00.01/08 21/06/95  10.07.32  by  Michael Scheer
*CMZ : 00.01/07 09/03/95  14.40.13  by  Michael Scheer
*CMZ : 00.00/01 03/03/95  15.54.17  by  Michael Scheer
*-- Author : Michael Scheer
C*****************************************************************
      SUBROUTINE REC_PLOTK(IMAG,XLEFT,XRIGHT,YDOWN,YUP,
     &  THETA,PHI,MODE,ISIGN,PSCAL)
+seq,gplhint.

      IMPLICIT NONE

      INTEGER MODE,ISIGN,IMAG

      real xmin_ps,xmax_ps,ymin_ps,ymax_ps,rmsiz

      REAL*4 XLEFT,XRIGHT,YDOWN,YUP,THETA,PHI
      REAL*4 DX,DY,XP(2),YP(2),dxp
      REAL*4 XLEF,XRIG,YDOW,YU
      REAL*4 DOT,CIRC
      REAL*4 DOT0,CIRC0,rmtyp20,rmtyp24,rmtyp31
      REAL*4 PSCAL

      DATA CIRC0/2./
      DATA DOT0/1./

+self,if=higz.
      data dot0/10./
      data circ0/10./
      data rmtyp20/20./
      data rmtyp24/24./
      data rmtyp31/31./
+self,if=-higz.
      data dot0/25./
      data circ0/5./
      data rmtyp20/20./
      data rmtyp24/-9999./
      data rmtyp31/31./
+self.

      call mshplt_get_frame(xmin_ps,xmax_ps,ymin_ps,ymax_ps)

      IF (THETA.NE.0.
     &    .AND.THETA.NE.90.
     &    .AND.THETA.NE.180.
     &    .AND.THETA.NE.270.) THEN
        CALL REC_PLOTTILT(IMAG,MODE)
C01JUN97 RETURN
C22MAY97         STOP '*** ERROR IN REC_PLOTK: WRONG ANGLE THETA (MUST BE 0 OR 90) ***'
        WRITE(6,*)
     &    '*** ERROR IN REC_PLOTK: WRONG ANGLE THETA (MUST BE 0, 90, 180 or 270) ***'
        STOP
      ENDIF

      IF (PHI.NE.0.AND.PHI.NE.90) THEN
        WRITE(6,*) '*** WARNING SR REC_PLOTK: WRONG ANGLE PHI (MUST BE 0 OR 90) ***'
C01JUN97   RETURN
        STOP
      ENDIF

      DX=0.0
      DY=0.0

      DOT=DOT0*PSCAL
      CIRC=CIRC0*PSCAL

      XLEF=XLEFT+DX
      YDOW=YDOWN+DY
      XRIG=XRIGHT+DX
      YU=YUP+DY

      XP(1)=XLEF
      XP(2)=XRIG
      YP(1)=YDOW
      YP(2)=YDOW

      dxp=(xmax_ps-xmin_ps)*0.02 !clip

      xp(1)=min(xp(1),xmax_ps)
      xp(2)=min(xp(2),xmax_ps)
      xp(1)=max(xp(1),xmin_ps)
      xp(2)=max(xp(2),xmin_ps)
      yp(1)=min(yp(1),ymax_ps)
      yp(2)=min(yp(2),ymax_ps)
      yp(1)=max(yp(1),ymin_ps)
      yp(2)=max(yp(2),ymin_ps)
      call mshplt_pline(2,xp,yp)

      XP(1)=XRIG
      XP(2)=XRIG
      YP(1)=YDOW
      YP(2)=YU

      if (xp(1).ge.xmin_ps+dxp.and.xp(1).le.xmax_ps-dxp) then
        yp(1)=min(yp(1),ymax_ps)
        yp(2)=min(yp(2),ymax_ps)
        yp(1)=max(yp(1),ymin_ps)
        yp(2)=max(yp(2),ymin_ps)
        call mshplt_pline(2,xp,yp)
      endif

      XP(1)=XRIG
      XP(2)=XLEF
      YP(1)=YU
      YP(2)=YU

      xp(1)=min(xp(1),xmax_ps)
      xp(2)=min(xp(2),xmax_ps)
      xp(1)=max(xp(1),xmin_ps)
      xp(2)=max(xp(2),xmin_ps)
      yp(1)=min(yp(1),ymax_ps)
      yp(2)=min(yp(2),ymax_ps)
      yp(1)=max(yp(1),ymin_ps)
      yp(2)=max(yp(2),ymin_ps)
      call mshplt_pline(2,xp,yp)

      XP(1)=XLEF
      XP(2)=XLEF
      YP(1)=YU
      YP(2)=YDOW

      if (xp(1).ge.xmin_ps+dxp.and.xp(1).le.xmax_ps-dxp) then
        yp(1)=min(yp(1),ymax_ps)
        yp(2)=min(yp(2),ymax_ps)
        yp(1)=max(yp(1),ymin_ps)
        yp(2)=max(yp(2),ymin_ps)
        call mshplt_pline(2,xp,yp)
      endif

      XP(1)=XLEF+(XRIG-XLEF)/2.
      YP(1)=YDOW+(YU-YDOW)/2.

      call mshplt_get_marker_size(rmsiz)

      IF(MODE.EQ.0) THEN

c        print*,imag,phi,theta,isign

        IF (PHI.EQ.0.0) THEN

          IF(THETA.EQ.0.0.AND.ISIGN.EQ.1.OR.THETA.EQ.180.AND.ISIGN.EQ.-1) THEN

            if (xp(1).ge.xmin_ps+dxp.and.xp(1).le.xmax_ps-dxp.and.
     &        (yp(1).gt.ymin_ps+rmsiz.and.yp(2).lt.ymax_ps+rmsiz.or.
     &        yp(2).gt.ymin_ps+rmsiz.and.yp(1).lt.ymax_ps+rmsiz)
     &          ) then
c              call mshplt_set_marker_type(1)
c              call mshplt_marker(1,xp,yp)
c              call mshplt_set_marker_type(9)
              call mgset('MTYP',rmtyp20)
              call mgset('MSCF',pscal)
              call mpm(1,xp,yp)
            endif

          ELSE IF(THETA.EQ.180.AND.ISIGN.EQ.1.OR.THETA.EQ.0.AND.ISIGN.EQ.-1) THEN

            if (xp(1).ge.xmin_ps+dxp.and.xp(1).le.xmax_ps-dxp.and.
     &        (yp(1).gt.ymin_ps+rmsiz.and.yp(2).lt.ymax_ps+rmsiz.or.
     &        yp(2).gt.ymin_ps+rmsiz.and.yp(1).lt.ymax_ps+rmsiz)
     &          ) then
              yp(1)=min(yp(1),ymax_ps)
              yp(2)=min(yp(2),ymax_ps)
              yp(1)=max(yp(1),ymin_ps)
              yp(2)=max(yp(2),ymin_ps)
c              call mshplt_scale_marker_size(1.5)
c              call mshplt_set_marker_type(6)
c              call mshplt_marker(1,xp,yp)
c              call mshplt_scale_marker_size(1./1.5)
c              call mshplt_set_marker_type(9)
              call mgset('MTYP',rmtyp31)
              call mgset('MSCF',pscal)
              call mpm(1,xp,yp)
            endif
          ELSE !THETA
            CALL ARROW(XLEF,XRIG,YU,YDOW,THETA-ISIGN*90.)
          ENDIF     !THETA
        ELSE IF(PHI.EQ.90.) THEN
          IF (THETA.EQ.90. .AND.ISIGN.GT.0 .OR.
     &        THETA.EQ.270..AND.ISIGN.LT.0) THEN
            CALL ARROW(XLEF,XRIG,YU,YDOW,270.)
          ELSE IF(THETA.EQ.270..AND.ISIGN.GT.0 .OR.
     &        THETA.EQ.90. .AND.ISIGN.LT.0) THEN
            CALL ARROW(XLEF,XRIG,YU,YDOW,90.)
          ELSE
            WRITE(6,*) '*** ERROR IN REC_PLOTK: WRONG ANGLE THETA FOR PHI=90. ***'
            RETURN
C             STOP
          ENDIF !THETA
        ENDIF    !PHI

      ENDIF   !MODE

      RETURN
      END
+DECK,REC_PLOTM.
*CMZ :  3.06/00 15/02/2019  13.33.23  by  Michael Scheer
*CMZ :  3.03/02 08/12/2015  15.33.15  by  Michael Scheer
*CMZ :  3.02/00 10/10/2014  13.45.06  by  Michael Scheer
*CMZ :  3.01/10 19/08/2014  11.16.18  by  Michael Scheer
*CMZ :  3.01/09 12/08/2014  17.18.45  by  Michael Scheer
*CMZ :  3.01/08 11/08/2014  19.17.31  by  Michael Scheer
*CMZ :  3.01/05 12/06/2014  09.31.15  by  Michael Scheer
*CMZ :  3.01/02 28/01/2014  17.00.03  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  10.40.59  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.70/11 20/02/2013  15.08.59  by  Michael Scheer
*CMZ :  2.57/05 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.53/05 11/02/2005  15.24.43  by  Michael Scheer
*CMZ :  2.52/09 29/10/2004  11.38.57  by  Michael Scheer
*CMZ :  2.52/05 13/08/2004  08.50.14  by  Michael Scheer
*CMZ :  2.48/04 16/03/2004  10.48.47  by  Michael Scheer
*CMZ :  2.48/03 03/03/2004  12.49.39  by  Michael Scheer
*CMZ :  2.48/00 26/02/2004  14.13.15  by  Michael Scheer
*CMZ :  2.47/19 01/12/2003  08.23.40  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.02  by  Michael Scheer
*CMZ :  2.40/00 11/03/2002  17.29.02  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.20/05 13/03/2001  13.41.14  by  Michael Scheer
*CMZ :  2.20/01 10/11/2000  11.27.21  by  Michael Scheer
*CMZ :  2.16/07 22/09/2000  10.44.05  by  Michael Scheer
*CMZ :  2.14/02 19/04/2000  17.02.46  by  Michael Scheer
*CMZ :  2.14/00 16/04/2000  14.58.50  by  Michael Scheer
*CMZ :  2.13/11 19/03/2000  11.30.34  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  16.17.28  by  Michael Scheer
*CMZ :  1.03/06 30/06/98  12.42.25  by  Michael Scheer
*CMZ :  1.02/03 14/01/98  10.02.58  by  Michael Scheer
*CMZ :  1.01/00 27/11/97  15.36.37  by  Michael Scheer
*CMZ :  1.00/00 23/07/97  14.06.18  by  Michael Scheer
*CMZ : 00.02/00 25/11/96  14.10.09  by  Michael Scheer
*CMZ : 00.01/08 23/06/95  20.54.17  by  Michael Scheer
*CMZ : 00.01/07 22/03/95  12.25.18  by  Michael Scheer
*CMZ : 00.00/01 03/03/95  15.54.17  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE REC_PLOTM
+seq,gplhint.

C--- TO PLOT MAGNET CONFIGURATION

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,KLOTZ.
+SEQ,BFORCE.
+seq,mplot.

      INTEGER NXZON,NYZON,IFIRST,I,ISIGN,lundum

      CHARACTER(60) CHOPT
      CHARACTER(1) GANS
      CHARACTER(60) XTIT,YTIT
      CHARACTER(80) TITLE
      character(16) c16
      character c1
      byte ic1

      REAL*4 XP(5),YP(5),X1,X2,Y1,Y2,Z1,Z2,XMIN,XMAX,ZMIN,ZMAX
      REAL*4 XLEFT,XRIGHT,YUP,YDOWN,ZUP,ZDOWN,THE,SPHI,PI

      REAL*4 PSCAL,hpic,hgap,hbase

      real xleft_ps,ybottom_ps,xright_ps,ytop_ps,xsiz_ps,ysiz_ps
      real xlefto_ps,ybottomo_ps,xrighto_ps,ytopo_ps,xsizo_ps,ysizo_ps

      equivalence(ic1,c1)

      DATA GANS/'"'/

      DATA PI/3.141592653589793D0/

      if (iplrec.eq.0) return

      write(c16,*)icode
      do i=1,16
        c1=c16(i:i)
        if (ic1.ne.32) goto 1
      enddo

1     continue

      title='Run '//c16(i:len_trim(c16))//' '//CODE(1:min(70,len_trim(code)))

      lundum=223344
      call util_get_free_lun(lundum)

      fileeps_mshplt='rec_plotm.eps'
      viewer_mshplt=''

      call mshplt_set_box(0)
      call mshplt_set_scale(20.)
      call mshplt_init(lundum,-20.,-20.,0,0,575,575,'rec_plotm.eps','','',0.0)
      call mshplt_set_title_offset(-3.,1.5)
      call mshplt_hplset('GSIZ',0.4)
      call mshplt_title(title(1:len_trim(title)))

      hpic=1.9
      hbase=1.
      hgap=1.

      call mshplt_zone(1,3,1,'')

      X1=1.E30
      X2=-1.E30
      Y1=1.E30
      Y2=-1.E30
      Z1=1.E30
      Z2=-1.E30

      DO I=1,IMAGTOT
        IF (BC(I).NE.0.0) THEN
          XLEFT=DX(I)-XLEN(I)/2.D0
          XRIGHT=DX(I)+XLEN(I)/2.D0
          YDOWN=DY(I)-YLEN(I)/2.D0
          YUP=DY(I)+YLEN(I)/2.D0
          ZDOWN=DZ(I)-ZLEN(I)/2.D0
          ZUP=DZ(I)+ZLEN(I)/2.D0
          IF (XLEFT.LT.X1) X1=XLEFT
          IF (XRIGHT.GT.X2) X2=XRIGHT
          IF (YDOWN.LT.Y1) Y1=YDOWN
          IF (YUP.GT.Y2) Y2=YUP
          IF (ZDOWN.LT.Z1) Z1=ZDOWN
          IF (ZUP.GT.Z2) Z2=ZUP
        ENDIF
      ENDDO   !IMAGTOT

      XMIN=X1-0.1*(X2-X1)
      XMAX=X2+0.1*(X2-X1)
      ZMIN=Z1-0.15*(Z2-Z1)
      ZMAX=Z2+0.15*(Z2-Z1)

      IF (RPLXMN.EQ.-9999.) THEN
        XMIN=XSTART*1000.
      ELSE IF (RPLXMN.NE.9999.) THEN
        XMIN=RPLXMN
      ENDIF
      IF (RPLXMX.EQ.-9999.) THEN
        XMAX=XSTOP*1000.
      ELSE IF (RPLXMX.NE.9999.) THEN
        XMAX=RPLXMX
      ENDIF

      IF (RPLZMN.NE.9999.) ZMIN=RPLZMN
      IF (RPLZMX.NE.9999.) ZMAX=RPLZMX

      PSCAL=500./(XMAX-XMIN)

      IF (PSCAL.GT.20.) PSCAL=20.

c      call mshplt_set_character_height(0.23)
c      call mshplt_set_tic_size(0.065)

      call mshplt_frame(xmin,xmax,zmin,zmax,'','','LBrtc')

      XP(1)=XMIN
      XP(2)=XMAX
      YP(1)=0.
      YP(2)=0.

      call mshplt_pline(2,xp,yp)
      call mshplt_set_line_color(2,0,0,0)

      DO I=1,IMAGTOT
        XLEFT=DX(I)-XLEN(I)/2.D0
        XRIGHT=DX(I)+XLEN(I)/2.D0
        YDOWN=DY(I)-YLEN(I)/2.D0
        YUP=DY(I)+YLEN(I)/2.D0
        ZDOWN=DZ(I)-ZLEN(I)/2.D0
        ZUP=DZ(I)+ZLEN(I)/2.D0
        THE=180.D0/PI*THETA(I)
        SPHI=180.D0/PI*PHI(I)
        IF (BC(I).GT.0) THEN
          ISIGN=1
        ELSE
          ISIGN=-1
        ENDIF
        IF(YDOWN.GE.0.D0) THEN
          IF (BC(I).NE.0.0)
     &      CALL REC_PLOTK(I,XLEFT,XRIGHT,ZDOWN,ZUP,THE,SPHI,0,ISIGN,PSCAL)
        ELSE IF (YUP.GT.0.0.AND.YDOWN.LT.0.0) THEN
          WRITE(16,*)
          WRITE(16,*)'*** WARNING SR REC_PLOTM: STRANGE INPUT ON FILE REC.PAR***'
          WRITE(16,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING SR REC_PLOTM: STRANGE INPUT ON FILE REC.PAR***'
          WRITE(6,*)
        ENDIF
      ENDDO !IMAGTOT

      call mshplt_set_line_color(1,0,0,0)

      IF (IBFORCE.NE.0) THEN
        XP(1)=(BFCENX-BFLENX/2.)*1000.
        YP(1)=(BFCENZ-BFLENZ/2.)*1000.
        XP(3)=(BFCENX+BFLENX/2.)*1000.
        YP(3)=(BFCENZ+BFLENZ/2.)*1000.
        XP(2)=XP(3)
        YP(2)=YP(1)
        XP(4)=XP(1)
        YP(4)=YP(3)
        XP(5)=XP(1)
        YP(5)=YP(1)
        call mshplt_set_line_color(3,0,0,0)
        call mshplt_pline(5,xp,yp)
        call mshplt_set_line_color(1,0,0,0)
      ENDIF !IBFORCE

      call mshplt_reset_clipping
      call mshplt_set_character_height(0.35)
      call mshplt_text_NDC(0.8,-0.3,'long. coord. [mm]')
      call mshplt_set_text_angle(90.)
      call mshplt_text_NDC(-0.08,0.1,'trans. coord. [mm]')
      call mshplt_set_text_angle(0.)
      call mshplt_set_character_height(0.4)
      call mshplt_text_NDC(0.4,-0.3,'upper magnets')

      call mshplt_frame(xmin,xmax,zmin,zmax,'','','LBrtc')

      XP(1)=XMIN
      XP(2)=XMAX
      YP(1)=0.
      YP(2)=0.

      call mshplt_pline(2,xp,yp)
      call mshplt_set_line_color(4,0,0,0)

      DO I=1,IMAGTOT
        XLEFT=DX(I)-XLEN(I)/2.D0
        XRIGHT=DX(I)+XLEN(I)/2.D0
        YDOWN=DY(I)-YLEN(I)/2.D0
        YUP=DY(I)+YLEN(I)/2.D0
        ZDOWN=DZ(I)-ZLEN(I)/2.D0
        ZUP=DZ(I)+ZLEN(I)/2.D0
        THE=180.D0/PI*THETA(I)
        SPHI=180.D0/PI*PHI(I)
        IF (BC(I).GT.0) THEN
          ISIGN=1
        ELSE
          ISIGN=-1
        ENDIF
        IF(YUP.LE.0.D0) THEN
          IF (BC(I).NE.0.0)
     &      CALL REC_PLOTK(I,XLEFT,XRIGHT,ZDOWN,ZUP,THE,SPHI,0,ISIGN,PSCAL)
        ENDIF
      ENDDO !IMAGTOT
      call mshplt_set_line_color(1,0,0,0)

      IF (IBFORCE.NE.0) THEN
        XP(1)=(BFCENX-BFLENX/2.)*1000.
        YP(1)=(BFCENZ-BFLENZ/2.)*1000.
        XP(3)=(BFCENX+BFLENX/2.)*1000.
        YP(3)=(BFCENZ+BFLENZ/2.)*1000.
        XP(2)=XP(3)
        YP(2)=YP(1)
        XP(4)=XP(1)
        YP(4)=YP(3)
        XP(5)=XP(1)
        YP(5)=YP(1)
        call mshplt_set_line_color(3,0,0,0)
        call mshplt_pline(5,xp,yp)
        call mshplt_set_line_color(1,0,0,0)
      ENDIF !IBFORCE

      YP(2)=AMAX1(ABS(Y1),ABS(Y2))*1.3
      YP(1)=-YP(2)

      IF (RPLYMN.NE.9999.) YP(1)=RPLYMN
      IF (RPLYMX.NE.9999.) YP(2)=RPLYMX

      call mshplt_reset_clipping
      call mshplt_set_character_height(0.35)
      call mshplt_text_NDC(0.8,-0.3,'long. coord. [mm]')
      call mshplt_set_text_angle(90.)
      call mshplt_text_NDC(-0.08,0.1,'trans. coord. [mm]')
      call mshplt_set_text_angle(0.)
      call mshplt_set_character_height(0.4)
      call mshplt_text_NDC(0.4,-0.3,'lower magnets')

      call mshplt_frame(xmin,xmax,yp(1),yp(2),'','','LBrtc')

      XP(1)=XMIN
      XP(2)=XMAX
      YP(1)=0.
      YP(2)=0.
      call mshplt_pline(2,xp,yp)

      DO I=1,IMAGTOT
        XLEFT=DX(I)-XLEN(I)/2.D0
        XRIGHT=DX(I)+XLEN(I)/2.D0
        YDOWN=DY(I)-YLEN(I)/2.D0
        YUP=DY(I)+YLEN(I)/2.D0
        ZDOWN=DZ(I)-ZLEN(I)/2.D0
        ZUP=DZ(I)+ZLEN(I)/2.D0
        THE=180.D0/PI*THETA(I)
        SPHI=180.D0/PI*PHI(I)
        IF(DZ(I).LT.0.0D0) THEN
          call mshplt_set_line_style(1)
        ELSE IF(DZ(I).GT.0.D0) THEN
          call mshplt_set_line_style(3)
        ENDIF
        IF (BC(I).NE.0.0) then
          if (ydown.gt.0) then
            call mshplt_set_line_color(2,0,0,0)
          else
            call mshplt_set_line_color(4,0,0,0)
          endif
          CALL REC_PLOTK(I,XLEFT,XRIGHT,YDOWN,YUP,THE,SPHI,1,0,PSCAL)
        endif
      ENDDO !IMAGTOT
      call mshplt_set_line_color(1,0,0,0)

      IF (IBFORCE.NE.0) THEN
        XP(1)=(BFCENX-BFLENX/2.)*1000.
        YP(1)=(BFCENY-BFLENY/2.)*1000.
        XP(3)=(BFCENX+BFLENX/2.)*1000.
        YP(3)=(BFCENY+BFLENY/2.)*1000.
        XP(2)=XP(3)
        YP(2)=YP(1)
        XP(4)=XP(1)
        YP(4)=YP(3)
        XP(5)=XP(1)
        YP(5)=YP(1)
        call mshplt_set_line_color(3,0,0,0)
        call mshplt_pline(5,xp,yp)
        call mshplt_set_line_color(1,0,0,0)
      ENDIF !IBFORCE

      call mshplt_reset_clipping
      call mshplt_set_character_height(0.35)
      call mshplt_text_NDC(0.8,-0.3,'long. coord. [mm]')
      call mshplt_set_text_angle(90.)
      call mshplt_text_NDC(-0.08,0.1,'vert. coord. [mm]')
      call mshplt_set_text_angle(0.)
      call mshplt_set_character_height(0.4)
      call mshplt_text_NDC(0.45,-0.3,'side view')

C- TERMINATE PLOTTING

9999  call mshplt_end

      RETURN
      END
+DECK,REC_PLOTTILT.
*CMZ :  3.01/09 12/08/2014  15.10.10  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  14.43.05  by  Michael Scheer
*CMZ :  1.00/00 23/05/97  12.32.14  by  Michael Scheer
*CMZ : 00.01/08 21/06/95  10.07.32  by  Michael Scheer
*CMZ : 00.01/07 09/03/95  14.40.13  by  Michael Scheer
*CMZ : 00.00/01 03/03/95  15.54.17  by  Michael Scheer
*-- Author : Michael Scheer
C*****************************************************************
      SUBROUTINE REC_PLOTTILT(IMAG,MODE)
+seq,gplhint.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,KLOTZ.

      INTEGER IMAG,MODE
      REAL*4 X(8),Y(8),Z(8),XP(2),YP(2),X0,Y0,Z0
      REAL*4 XXXLEN,YYYLEN,XXLEN,YYLEN
        REAL*4 SINTHE,COSTHE
      IF (PHI(IMAG).NE.0.0) THEN
        WRITE(6,*) '*** ERROR IN REC_PLOTTILT: PHI NOT ZERO ***'
        STOP
      ENDIF

      X0=DX(IMAG)
      Y0=DY(IMAG)
      Z0=DZ(IMAG)

      XXLEN=XLEN(IMAG)
      YYLEN=YLEN(IMAG)

      SINTHE=DSIN(THETA(IMAG))
      COSTHE=DCOS(THETA(IMAG))
      XXXLEN=ABS(XXLEN*costhe-YYLEN*sinthe)
      YYYLEN=ABS(YYLEN*costhe+XXLEN*sinthe)
      X(1)=X0-XXXLEN/2.
      Y(1)=Y0-YYYLEN/2.
      X(6)=X0+XXXLEN/2.
      Y(6)=Y0+YYYLEN/2.

      SINTHE=DSIN(-THETA(IMAG))
      COSTHE=DCOS(-THETA(IMAG))
      XXXLEN=ABS(XXLEN*costhe-YYLEN*sinthe)
      YYYLEN=ABS(YYLEN*costhe+XXLEN*sinthe)
      X(2)=X0+XXXLEN/2.
      Y(2)=Y0-YYYLEN/2.
      X(5)=X0-XXXLEN/2.
      Y(5)=Y0+YYYLEN/2.

      X(4)=X(1)
      Y(4)=Y(1)
      X(8)=X(5)
      Y(8)=Y(5)
      X(3)=X(2)
      Y(3)=Y(2)
      X(7)=X(6)
      Y(7)=Y(6)

      Z(1)=Z0+ZLEN(IMAG)/2.
      Z(4)=Z0-ZLEN(IMAG)/2.
      Z(2)=Z(1)
      Z(5)=Z(1)
      Z(6)=Z(1)
      Z(3)=Z(4)
      Z(7)=Z(4)
      Z(8)=Z(4)

      IF (MODE.EQ.0) THEN
          XP(1)=X(1)
          YP(1)=Z(1)
          XP(2)=X(4)
          YP(2)=Z(4)
          call mshplt_pline(2,xp,yp)
          XP(1)=X(2)
          YP(1)=Z(2)
          XP(2)=X(3)
          YP(2)=Z(3)
          call mshplt_pline(2,xp,yp)
          XP(1)=X(5)
          YP(1)=Z(5)
          XP(2)=X(8)
          YP(2)=Z(8)
          call mshplt_pline(2,xp,yp)
          XP(1)=X(6)
          YP(1)=Z(6)
          XP(2)=X(7)
          YP(2)=Z(7)
          call mshplt_pline(2,xp,yp)
          XP(1)=X(1)
          YP(1)=Z(1)
          XP(2)=X(2)
          YP(2)=Z(2)
          call mshplt_pline(2,xp,yp)
          XP(1)=X(3)
          YP(1)=Z(3)
          XP(2)=X(4)
          YP(2)=Z(4)
          call mshplt_pline(2,xp,yp)
          XP(1)=X(5)
          YP(1)=Z(5)
          XP(2)=X(6)
          YP(2)=Z(6)
          call mshplt_pline(2,xp,yp)
          XP(1)=X(7)
          YP(1)=Z(7)
          XP(2)=X(8)
          YP(2)=Z(8)
          call mshplt_pline(2,xp,yp)
        ELSE   !MODE
          XP(1)=X(1)
          YP(1)=Y(1)
          XP(2)=X(2)
          YP(2)=Y(2)
          call mshplt_pline(2,xp,yp)
          XP(1)=X(6)
          YP(1)=Y(6)
          XP(2)=X(2)
          YP(2)=Y(2)
          call mshplt_pline(2,xp,yp)
          XP(1)=X(5)
          YP(1)=Y(5)
          XP(2)=X(6)
          YP(2)=Y(6)
          call mshplt_pline(2,xp,yp)
          XP(1)=X(1)
          YP(1)=Y(1)
          XP(2)=X(5)
          YP(2)=Y(5)
          call mshplt_pline(2,xp,yp)
      ENDIF !MODE

      RETURN
      END
+DECK,REC_UBANGERROR.
*CMZ :  4.00/15 27/04/2022  09.02.34  by  Michael Scheer
*CMZ :  3.03/02 20/01/2016  12.04.25  by  Michael Scheer
*CMZ :  3.02/03 03/11/2014  12.08.30  by  Michael Scheer
*CMZ :  2.44/00 30/10/2002  13.51.40  by  Michael Scheer
*CMZ :  2.42/04 28/10/2002  11.43.42  by  Michael Scheer
*CMZ :  2.42/00 09/09/2002  18.30.24  by  Michael Scheer
*-- Author :    Michael Scheer   04/09/2002

      SUBROUTINE REC_UBANGERROR(N,BC,NURANMOD,UBANGERR,ubansig,USIGOFFY)
+seq,gplhint.

      INTEGER N,NURANMOD,I,NPOLTOT,J
      DOUBLE PRECISION BC(N),UBANGERR,BDIFF,BCORRI,BCORRE,UBCSUM2
     &                  ,USIGOFFY,GRARAD,ANGERR,ubansig
      REAL xran(1),XWALK,XCORR,rr(2)

      PARAMETER (GRARAD=0.0174532925199D0)

      IF (N.LE.6) THEN
          RETURN
      ELSEIF (MOD(N,3).NE.0) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN REC_UBCERROR: ZERO MAGNET STRENGTH  ***'
          STOP
      ENDIF

      IF (BC(8).EQ.0.D0) THEN
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN REC_UBCERROR: ZERO MAGNET STRENGTH  ***'
          WRITE(6,*)'*** LEAVING...NO ERRORS GENERATED'
          WRITE(6,*)
          RETURN
      ENDIF

      DO I=1,6
          BC(I)=0.D0
      ENDDO !I

      DO I=1,6
          BC(N+1-I)=0.D0
      ENDDO !I

        DO I=6+1,N-6,3
123       CALL RNORML(XRAN,1,rr)
          if (abs(xran(1)).gt.ubansig) goto 123
           XWALK=XWALK+(xran(1)-XCORR)
           IF (ABS(XWALK).GT.USIGOFFY) THEN
             XCORR=XWALK/2.D0
           ENDIF
           J=(I+2)*2-1
           ANGERR=(xran(1)-XCORR)*UBANGERR*GRARAD
           BC(I)=BC(I)*ANGERR
           BC(I+1)=BC(I+1)*ANGERR
           BC(I+2)=BC(I+2)*ANGERR
        ENDDO

      BDIFF=0.D0
      DO I=6+1,N-6,3
                BDIFF=BDIFF+BC(I)
      ENDDO !I

      DO I=1,3
                BC(I)=+BDIFF/4.D0
      ENDDO

      DO I=4,6
                BC(I)=-BDIFF*3.D0/4.D0
      ENDDO

      DO I=1,3
                BC(N+1-I)=+BDIFF/4.D0
      ENDDO

      DO I=4,6
                BC(N+1-I)=-BDIFF*3.D0/4.D0
      ENDDO

C--- COMPENSATE VERTICAL OFFSET WITH ENDPOLE

      IF (NURANMOD.EQ.4) THEN

          UBCSUM2=0.D0
        NPOLTOT=N/3
        DO I=1,NPOLTOT
          J=-1+I*3
          UBCSUM2=UBCSUM2+(NPOLTOT+1-I)*BC(J)
        ENDDO !I

        IF (UBCSUM2.NE.0.D0) THEN
                    BCORRI=1.D0-UBCSUM2/(NPOLTOT-1)/BC(2)
                    BCORRE=1.D0+UBCSUM2/(NPOLTOT-1)/BC(N+1-2)
        ELSE
                    BCORRI=1.D0
                    BCORRE=1.D0
        ENDIF

        DO I=1,3
                    BC(I)=BC(I)*BCORRI
        ENDDO


        DO I=1,3
                    BC(N+1-I)=BC(N+1-I)*BCORRE
        ENDDO

      ENDIF   !NURANMOD.EQ.4

      RETURN
      END
+DECK,REC_UBCERROR.
*CMZ :  4.00/15 27/04/2022  09.00.10  by  Michael Scheer
*CMZ :  3.02/03 03/11/2014  12.00.05  by  Michael Scheer
*CMZ :  2.42/00 05/09/2002  18.59.21  by  Michael Scheer
*-- Author :    Michael Scheer   04/09/2002
+seq,gplhint.

      SUBROUTINE REC_UBCERROR(N,BC,NURANMOD,BCRAN,BCRANSIG)

      INTEGER N,NURANMOD,I,NPOLTOT
      DOUBLE PRECISION BC(N),BCRAN,BERR,BDIFF,BCORRI,BCORRE,UBCSUM2,BCSIGN
      REAL BCRANSIG,xran(1),rr(2)

      IF (N.LE.6) THEN
          RETURN
      ELSE IF (MOD(N,3).NE.0) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN REC_UBCERROR: ZERO MAGNET STRENGTH  ***'
          STOP
      ENDIF

      IF (BC(8).EQ.0.D0) THEN
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN REC_UBCERROR: ZERO MAGNET STRENGTH  ***'
          WRITE(6,*)'*** LEAVING...NO ERRORS GENERATED'
          WRITE(6,*)
          RETURN
      ENDIF

      DO I=6+1,N-6,3
1         CALL RNORML(xran(1),1,rr)
          IF (ABS(xran(1)).GT.BCRANSIG) GOTO 1
          BERR=(1.+BCRAN*xran(1))
          BC(I)=BC(I)*BERR
          BC(I+1)=BC(I+1)*BERR
          BC(I+2)=BC(I+2)*BERR
      ENDDO !I

C--- COMPENSATE THE KICK

      BDIFF=0.D0
      DO I=6+1+1,N-6,6
            BDIFF=BDIFF-BC(I)+BC(I+3)
      ENDDO !I

      BCORRI=1.D0-BDIFF/BC(8)
      BCORRE=1.D0+BDIFF/BC(8)

      DO I=1,6
            BC(I)=BC(I)*BCORRI
            BC(N+1-I)=BC(N+1-I)*BCORRE
      ENDDO

      IF (NURANMOD.EQ.4) THEN

C--- COMPENSATE OFFSET WITH BY ENDPOLE

           UBCSUM2=0.D0
           NPOLTOT=N/3

           DO I=1,NPOLTOT
                    IF (I.EQ.1) THEN
                        BCSIGN=1.D0
                    ELSEIF(I.EQ.2) THEN
                        BCSIGN=-1.D0
                    ELSEIF(I.EQ.NPOLTOT-1) THEN
                        BCSIGN=-1.D0
                    ELSEIF(I.EQ.NPOLTOT) THEN
                        BCSIGN=1.D0
                    ELSE
                        BCSIGN=(-1.D0)**I
                    ENDIF
                    UBCSUM2=UBCSUM2+(NPOLTOT+1-I)*BCSIGN*BC(I*3-1)
                ENDDO !I

                BCORRI=1.D0-UBCSUM2/(NPOLTOT-2)/BC(8)*2.D0

                DO I=1,6
                    BC(I)=BC(I)*BCORRI
                ENDDO

                BCORRE=BCORRI

                DO I=1,6
                    BC(N+1-I)=BC(N+1-I)*BCORRE
                ENDDO

            ENDIF   !NURANMOD.EQ.4

      RETURN
      END
+DECK,RFILFR.
*CMZ :  4.00/15 07/04/2022  07.14.03  by  Michael Scheer
*CMZ :  4.00/04 10/05/2019  16.57.06  by  Michael Scheer
*CMZ :  3.03/04 03/08/2017  14.10.45  by  Michael Scheer
*CMZ :  3.03/02 03/12/2015  17.38.18  by  Michael Scheer
*CMZ :  3.02/07 03/12/2015  17.37.47  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.69/00 26/10/2012  13.26.40  by  Michael Scheer
*CMZ :  2.67/02 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.66/12 22/05/2010  16.51.50  by  Michael Scheer
*CMZ :  2.66/09 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.52/01 18/11/2009  10.22.04  by  Michael Scheer
*CMZ :  2.52/00 24/06/2004  17.38.38  by  Michael Scheer
*CMZ :  2.20/10 16/04/2004  09.24.47  by  Michael Scheer
*CMZ :  2.20/01 21/11/2000  19.24.54  by  Michael Scheer
*CMZ :  2.16/08 25/10/2000  12.21.53  by  Michael Scheer
*CMZ :  2.16/07 14/09/2000  17.12.07  by  Michael Scheer
*CMZ :  2.16/06 30/08/2000  13.39.46  by  Michael Scheer
*CMZ :  2.16/05 02/08/2000  13.39.56  by  Michael Scheer
*CMZ :  2.16/04 21/07/2000  10.14.36  by  Michael Scheer
*CMZ :  2.15/00 03/05/2000  16.31.03  by  Michael Scheer
*CMZ : 00.02/00 19/11/96  14.56.43  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  17.14.45  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.53.37  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.43  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE RFILFR
+seq,gplhint.

+SEQ,TRACKF90U,IF=F90.

+SELF,IF=F90.
+SEQ,OBSERVF90U.
+SEQ,WFOLDF90U.
+SELF.

C--- SUBROUTINE READS FREQUENCES FOR WHICH PHOTON FLUX IS CALCULATED

+SEQ,TRACKF90U,IF=F90.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,FREQS.
+SEq,wfoldf90.
+SEQ,B0SCGLOB.
+SEQ,TRACK.
+SEq,observf90.
+SEQ,KLOTZ.
+SEQ,PHYCON.

      INTEGER IFR,I,J

C260194 {
      DOUBLE PRECISION DFREQ,DUM
C260194 }
C24.394 {
      INTEGER INCREAS,NFREQO,IFREQ
      DOUBLE PRECISION DEXTEND,PHIDEFL,B0DIP,DEFLEC,DLENG,HARM,DNPER,HARMWIDTH
      DOUBLE PRECISION WAVE,df
C24.394 }

      double precision frscaleo,freql,freqh

      frscaleo=frscale
      frscale=abs(frscale)

      if (pinwsc.le.0.0d0) pinwsc=1.0d0
      if (pinhsc.le.0.0d0) pinhsc=1.0d0

      IF (FRSCALE.EQ.0.D0) FRSCALE=1.D0

      PHIDEFL=ANGRMS*SQRT(2.)
      B0DIP=BRMS*SQRT(2.)
      DEFLEC=PHIDEFL*DMYGAMMA

      IF (B0DIP.NE.0.D0) THEN
        DLENG=DEFLEC/93.4/B0DIP
      ELSE
        DLENG=0.D0
      ENDIF

      IF (DLENG.EQ.0.0) DLENG=(XMX-XMN)

      HARM=0.95D3*DMYENERGY**2/(1.D0+DEFLEC**2/2.D0)/DLENG/100.d0

      IF (KBREC.EQ.0) THEN
        DNPER=(XMX-XMN)/DLENG
      ELSE  !KBREC
        DNPER=(XMX-XMN-2.D0*RANGREC)/DLENG
      ENDIF !KBREC

      IF (DNPER.LT.1.D0) THEN
        DNPER=1.D0
        HARMWIDTH=HARM*0.5
      ELSE
        HARMWIDTH=HARM/DNPER
      ENDIF

      WAVE=WTOE1/HARM*1.D-9/FRSCALE

      IF (IUNDULATOR.NE.0) THEN
        IF (FREQLOW.EQ.-9999.) THEN
          FREQLOW=HARM-HARMWIDTH
        ENDIF   !FREQLOW
        IF (FREQHIG.EQ.-9999.) THEN
          FREQHIG=HARM+HARMWIDTH
        ENDIF   !FREQLOW
        IF (PINW.EQ.9999..AND.IPIN.NE.0) THEN
          IF (IAMPLI.GT.0) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '*** ERROR IN RFILRF: PINW=9999. AND IAMPLI GREATER THAN ZERO***'
            WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
            WRITE(6,*)
            WRITE(6,*)
     &        '*** ERROR IN RFILRF: PINW=9999. AND IAMPLI GREATER THAN ZERO***'
            WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
            STOP
          ENDIF   !IAMPLI
          PINW=5.D0*SQRT(WAVE/(DLENG*DNPER))*(PINCEN(1)-DLENG*DNPER/2.)
          if (iampli.lt.0) pinw=pinw/(-iampli)
        ENDIF   !PINW

        IF (PINH.EQ.9999..AND.IPIN.NE.0) THEN
          IF (IAMPLI.GT.0) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '*** ERROR IN RFILRF: PINH=9999. AND IAMPLI GREATER THAN ZERO***'
            WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
            WRITE(6,*)
            WRITE(6,*)
     &        '*** ERROR IN RFILRF: PINH=9999. AND IAMPLI GREATER THAN ZERO***'
            WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
            STOP
          ENDIF   !IAMPLI
          PINH=5.D0*SQRT(WAVE/(DLENG*DNPER))*(PINCEN(1)-DLENG*DNPER/2.)
          if (iampli.lt.0) pinh=pinh/(-iampli)
        ENDIF   !PINH
      ELSE  !IUNDULATOR.NE.0
        IF (FREQLOW.EQ.-9999.) THEN
          WRITE(6,*)'*** ERROR IN RFILFR: DEFAULT FOR FREQLOW NOT ALLOWED'
          WRITE(6,*)'                     SINCE FLAG IUNDULATOR IS NOT SET'
          WRITE(6,*)'                     CHECK NAMELIST $FREQN'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
          WRITE(LUNGFO,*)'*** ERROR IN RFILFR: DEFAULT FOR FREQLOW NOT ALLOWED'
          WRITE(LUNGFO,*)'                     SINCE FLAG IUNDULATOR IS NOT SET'
          WRITE(LUNGFO,*)'                     CHECK NAMELIST $FREQN'
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
          STOP
        ENDIF   !FREQLOW
        IF (FREQHIG.EQ.-9999.) THEN
          WRITE(6,*)'*** ERROR IN RFILFR: DEFAULT FOR FREQHIG NOT ALLOWED'
          WRITE(6,*)'                     SINCE FLAG IUNDULATOR IS NOT SET'
          WRITE(6,*)'                     CHECK NAMELIST $FREQN'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
          WRITE(LUNGFO,*)'*** ERROR IN RFILFR: DEFAULT FOR FREQHIG NOT ALLOWED'
          WRITE(LUNGFO,*)'                     SINCE FLAG IUNDULATOR IS NOT SET'
          WRITE(LUNGFO,*)'                     CHECK NAMELIST $FREQN'
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
          STOP
        ENDIF   !FREQHIG

        IF (PINW.EQ.9999..AND.IPIN.NE.0) THEN
          WRITE(6,*)'*** ERROR IN RFILFR: DEFAULT FOR PINW NOT ALLOWED'
          WRITE(6,*)'                     SINCE FLAG IUNDULATOR IS NOT SET'
          WRITE(6,*)'                     CHECK NAMELIST $PINHOLE'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
          WRITE(LUNGFO,*)'*** ERROR IN RFILFR: DEFAULT FOR PINW NOT ALLOWED'
          WRITE(LUNGFO,*)'                     SINCE FLAG IUNDULATOR IS NOT SET'
          WRITE(LUNGFO,*)'                     CHECK NAMELIST $PINHOLE'
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
          STOP
        ENDIF   !PINW

        IF (PINH.EQ.9999..AND.IPIN.NE.0) THEN
          WRITE(6,*)'*** ERROR IN RFILFR: DEFAULT FOR PINH NOT ALLOWED'
          WRITE(6,*)'                     SINCE FLAG IUNDULATOR IS NOT SET'
          WRITE(6,*)'                     CHECK NAMELIST $PINHOLE'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
          WRITE(LUNGFO,*)'*** ERROR IN RFILFR: DEFAULT FOR PINH NOT ALLOWED'
          WRITE(LUNGFO,*)'                     SINCE FLAG IUNDULATOR IS NOT SET'
          WRITE(LUNGFO,*)'                     CHECK NAMELIST $PINHOLE'
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
          STOP
        ENDIF   !PINH
      ENDIF !(IUNDULATOR.NE.0)

      pinw=pinw*PINwsC
      pinh=pinh*PINHSC

C- SPECIAL CASES (FREQUENCES ARE READ FROM NAMELIST FREQN)

      IF (freqhig.le.freqlow) THEN
        IF (IFREQ2P.EQ.1) THEN
          freqhig=2.0d0*freqlow
        else IF (IFREQ2P.EQ.-1) THEN
          freqhig=1.5*freqlow
          freqlow=0.5*freqlow
         endif
      endif

      IF (IFREQ2P.EQ.0) THEN

        OPEN (UNIT=LUNFR,FILE=FILEFR,STATUS='OLD',FORM='FORMATTED',ERR=999)
c        READ(LUNFR,*,ERR=99) NFREQ

        nfreq=0
1       continue
        read(lunfr,*,end=9) freq(1)
        nfreq=nfreq+1
        goto 1
9       rewind(lunfr)

        IF(NFREQ.GT.NDFREQ) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN SR RFILFR ***'
          WRITE(LUNGFO,*)'TOO MANY FREQUENCES ON FILEFR'
          WRITE(LUNGFO,*)'INCREASE PARAMETER NDFREQP IN CMPARA.CMN'
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN SR RFILFR ***'
          WRITE(6,*)'TOO MANY FREQUENCES ON FILEFR'
          WRITE(6,*)'INCREASE PARAMETER NDFREQP IN CMPARA.CMN'
          STOP
        ENDIF

        DO IFR=1,NFREQ
          READ(LUNFR,*,ERR=99) DUM
          IF (IUNIT.EQ.0) THEN    ! 260194
            FREQ(IFR)=DUM
          ELSE
            FREQ(IFR)=WTOE1/DUM !260194
          ENDIF
        ENDDO

        CLOSE(LUNFR)

        nintfreq=nfreq
        freqlow=freq(1)
        freqhig=freq(nfreq)

C260194 {
        DO I=1,NFREQ
          DO J=I+1,NFREQ
            IF (IUNIT.EQ.0) THEN
              IF (FREQ(J).LT.FREQ(I)) THEN
                DUM=FREQ(J)
                FREQ(J)=FREQ(I)
                FREQ(I)=DUM
              ENDIF
            ELSE
              IF (FREQ(J).GT.FREQ(I)) THEN
                DUM=FREQ(J)
                FREQ(J)=FREQ(I)
                FREQ(I)=DUM
              ENDIF
            ENDIF
          ENDDO
        ENDDO

      else IF(IFREQ2P.GT.1) THEN

        IF(2.GT.NDFREQ) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN SR RFILFR ***'
          WRITE(LUNGFO,*)'TOO MANY FREQUENCES TO BE CALCULATED'
          WRITE(LUNGFO,*)'INCREASE PARAMETER NDFREQP IN CMPARA.CMN'
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN SR RFILFR ***'
          WRITE(6,*)'TOO MANY FREQUENCES TO BE CALCULATED'
          WRITE(6,*)'INCREASE PARAMETER NDFREQP IN CMPARA.CMN'
          STOP
        ENDIF

        IF (FRSCALEo.lT.0.D0) THEN
          FREQLOW=FREQLOW*frscale
          FREQHIG=FREQhig*frscale
          nintfreq=nintfreq*frscale
        else IF (FRSCALE.GT.0.D0) THEN
          FREQHIG=FREQHIG-FREQLOW
          FREQLOW=FREQLOW+FREQHIG/2.D0
          FREQLOW=FREQLOW*FRSCALE-FREQHIG/2.D0
          FREQHIG=FREQLOW+FREQHIG
        ENDIF

        NFREQ=NINTFREQ
        NFREQ0=NFREQ
        NFREQ0M=1
        NFREQ0P=NFREQ

        IF (IUNIT.EQ.0) THEN

          FREQ(1)=FREQLOW
          FREQ(2)=FREQHIG

        ELSE

          FREQ(1)=WTOE1/FREQHIG
          FREQ(2)=WTOE1/FREQLOW

        ENDIF

        IF(IFREQ2P.EQ.2)  THEN

          IF (2.D0*FREQ(1).GT.FREQ(2)) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN SR RFILFR ***'
            WRITE(LUNGFO,*)'PHOTON ENERGIES ON NAMELIST FREQN INCOMPATIBLE'
            WRITE(LUNGFO,*)'WITH FLAG IFREQ2P.'
            WRITE(LUNGFO,*)'FIRST PHOTON ENERGY MUST NOT BE HIGHER THAN'
            WRITE(LUNGFO,*)'HALF THE SECOND ONE'
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN SR RFILFR ***'
            WRITE(6,*)'PHOTON ENERGIES ON NAMELIST FREQN INCOMPATIBLE'
            WRITE(6,*)'WITH FLAG IFREQ2P.'
            WRITE(6,*)'FIRST PHOTON ENERGY MUST NOT BE HIGHER THAN'
            WRITE(6,*)'HALF THE SECOND ONE'
            STOP
          ENDIF

          NFREQ=DLOG(FREQ(2)/FREQ(1))/DLOG(2.D0)+1
          NFREQ0=NFREQ
          NFREQ0M=1
          NFREQ0P=NFREQ

        ELSE IF(IFREQ2P.GT.2) THEN

          IF (FREQ(1).GE.FREQ(2)) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN SR RFILFR ***'
            WRITE(LUNGFO,*)'PHOTON ENERGIES ON NAMELIST FREQN INCOMPATIBLE'
            WRITE(LUNGFO,*)'WITH FLAG IFREQ2P.'
            WRITE(LUNGFO,*)'FIRST PHOTON ENERGY MUST BE LOWER THAN'
            WRITE(LUNGFO,*)'THE SECOND ONE'
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN SR RFILFR ***'
            WRITE(6,*)'PHOTON ENERGIES ON NAMELIST FREQN INCOMPATIBLE'
            WRITE(6,*)'WITH FLAG IFREQ2P.'
            WRITE(6,*)'FIRST PHOTON ENERGY MUST BE LOWER THAN'
            WRITE(6,*)'THE SECOND ONE'
            STOP
          ENDIF !FREQ(1)

          NFREQ=NINTFREQ
          NFREQ0=NFREQ
          NFREQ0M=1
          NFREQ0P=NFREQ

        ENDIF   !IFREQ2P

        IF(NFREQ.GT.NDFREQ) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN SR RFILFR ***'
          WRITE(LUNGFO,*)'TOO MANY FREQUENCES TO BE CALCULATED'
          WRITE(LUNGFO,*)'INCREASE PARAMETER NDFREQP IN CMPARA.CMN'
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN SR RFILFR ***'
          WRITE(6,*)'TOO MANY FREQUENCES TO BE CALCULATED'
          WRITE(6,*)'INCREASE PARAMETER NDFREQP IN CMPARA.CMN'
          STOP
        ENDIF   !NFREQ

        DFREQ=(FREQ(2)-FREQ(1))/(NFREQ-1)
        DO IFR=1,NFREQ-1
          IF(IFREQ2P.EQ.2) THEN
            FREQ(IFR+1)=FREQ(IFR)*2.D0
          ELSE
            FREQ(IFR+1)=FREQ(IFR)+DFREQ
          ENDIF
        ENDDO

C260194      RETURN

      ENDIF !IFREQ2P.GT.1

      IF(iabs(IFREQ2P).EQ.1) THEN   !260194

        IF (IUNIT.EQ.0) THEN
          if (ifreq2p.eq.1) then !20220407
            FREQ(1)=FREQLOW
          else
            FREQ(1)=(FREQLOW+freqhig)/2.0d0
          endif
        ELSE
          if (ifreq2p.eq.1) then !20220407
            FREQ(1)=WTOE1/FREQLOW
          else
            FREQ(1)=(wtoe1/FREQLOW+wtoe1/freqhig)/2.0d0
          endif
        ENDIF

        nintfreq=1
        NFREQ=1
        NFREQ0=NFREQ
        NFREQ0M=1
        NFREQ0P=NFREQ

        nintfreq=nfreq
C260194  ELSE

      ENDIF !IFREQ2P

C24.3.94{
      IF (IEFOLD.NE.0.AND.IEFOLD.NE.2) THEN

        NFREQO=NFREQ
        NFREQ0=NFREQ

        IF (IFREQ2P.eq.2) THEN
          dfreq=2.0d0*ESPREAD*NSIGE*FREQlow
          IF (FREQlow-dfreq.gt.0.0d0) THEN
            freql=freqlow
            do while (freql.gt.freq(1)-dfreq)
              freql=freql/2.0d0
            enddo
            nfreq=1
            freq(1)=freql
            dfreq=2.0d0*ESPREAD*NSIGE*FREQhig
            do while (freq(nfreq).lt.freqhig+dfreq)
              nfreq=nfreq+1
              if (nfreq.gt.ndfreqp) then
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'*** ERROR IN SR RFILFR ***'
                WRITE(LUNGFO,*)'TOO MANY FREQUENCES TO BE CALCULATED'
                WRITE(LUNGFO,*)'INCREASE PARAMETER NDFREQP IN CMPARA.CMN'
                WRITE(6,*)
                WRITE(6,*)'*** ERROR IN SR RFILFR ***'
                WRITE(6,*)'TOO MANY FREQUENCES TO BE CALCULATED'
                WRITE(6,*)'INCREASE PARAMETER NDFREQP IN CMPARA.CMN'
                STOP
              endif
              freq(nfreq)=freq(nfreq-1)*2.0d0
            enddo
          else
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN RFILRF ***'
            WRITE(LUNGFO,*)
     &        'NEGATIVE OR ZERO PHOTON ENERGY OCCURED WHILE EXTENDING ENERGY RANGE DUE TO FLAG IEFOLD'
            WRITE(LUNGFO,*)'CHECK INPUT FILE, INCREASE FREQLOW OR NINTFREQ'
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN RFILRF ***'
            WRITE(6,*)
     &        'NEGATIVE OR ZERO PHOTON ENERGY OCCURED WHILE EXTENDING ENERGY RANGE DUE TO FLAG IEFOLD'
            WRITE(6,*)'CHECK INPUT FILE, INCREASE FREQLOW OR NINTFREQ'
            WRITE(6,*)
            STOP
          ENDIF
        else IF (IFREQ2P.eq.1.or.freqlow.eq.freqhig) THEN
          dfreq=2.0d0*ESPREAD*NSIGE*FREQlow
          freq(1)=freqlow-dfreq
          dfreq=dfreq/5.0d0
          nfreq=11
          do ifreq=2,nfreq
            freq(ifreq)=freq(ifreq-1)+dfreq
          enddo
        else IF (IFREQ2P.eq.-1) THEN
          dfreq=2.0d0*ESPREAD*NSIGE*(FREQlow+freqhig)/2.
          freq(1)=(freqlow+freqhig)/2.-dfreq
          dfreq=dfreq/5.0d0
          nfreq=11
          do ifreq=2,nfreq
            freq(ifreq)=freq(ifreq-1)+dfreq
          enddo
        else !ifreq2p

          DFREQ=FREQ(nfreq)-FREQ(nfreq-1)
          DEXTEND=2.0d0*ESPREAD*NSIGE*FREQ(NFREQ)
          INCREAS=DMAX1(2.D0,DEXTEND/DFREQ+1.D0)
          NFREQEP=INCREAS
          NFREQ=NFREQ+INCREAS

          IF(NFREQ.GT.NDFREQ) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN SR RFILFR ***'
            WRITE(LUNGFO,*)'TOO MANY FREQUENCES TO BE CALCULATED'
            WRITE(LUNGFO,*)'INCREASE PARAMETER NDFREQP IN CMPARA.CMN'
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN SR RFILFR ***'
            WRITE(6,*)'TOO MANY FREQUENCES TO BE CALCULATED'
            WRITE(6,*)'INCREASE PARAMETER NDFREQP IN CMPARA.CMN'
            STOP
          ENDIF   !NFREQ

          DO IFREQ=1,INCREAS
            FREQ(NFREQO+IFREQ)=FREQ(NFREQO)+DFREQ*IFREQ
          ENDDO

          DFREQ=FREQ(2)-FREQ(1)
          DEXTEND=2.0d0*ESPREAD*NSIGE*FREQ(1)
          INCREAS=DMAX1(2.D0,DEXTEND/DFREQ+1.D0)
          NFREQEM=INCREAS
          NFREQ0M=NFREQEM+1
          NFREQ0P=NFREQ0M+NFREQ0-1
          NFREQO=NFREQ
          NFREQ=NFREQ+INCREAS

          IF(NFREQ.GT.NDFREQ) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN SR RFILFR ***'
            WRITE(LUNGFO,*)'TOO MANY FREQUENCES TO BE CALCULATED'
            WRITE(LUNGFO,*)'INCREASE PARAMETER NDFREQP IN CMPARA.CMN'
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN SR RFILFR ***'
            WRITE(6,*)'TOO MANY FREQUENCES TO BE CALCULATED'
            WRITE(6,*)'INCREASE PARAMETER NDFREQP IN CMPARA.CMN'
            STOP
          ENDIF   !NFREQ

          DO IFREQ=NFREQO,1,-1
            FREQ(IFREQ+INCREAS)=FREQ(IFREQ)
          ENDDO
          DO IFREQ=1,INCREAS
            FREQ(INCREAS+1-IFREQ)=FREQ(INCREAS+1)-DFREQ*IFREQ
            IF (FREQ(INCREAS+1-IFREQ).LE.0.0) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'*** ERROR IN RFILRF ***'
              WRITE(LUNGFO,*)
     &          'NEGATIVE OR ZERO PHOTON ENERGY OCCURED WHILE EXTENDING ENERGY RANGE DUE TO FLAG IEFOLD'
              WRITE(LUNGFO,*)'CHECK INPUT FILE'
              WRITE(LUNGFO,*)
              WRITE(6,*)
              WRITE(6,*)'*** ERROR IN RFILRF ***'
              WRITE(6,*)
     &          'NEGATIVE OR ZERO PHOTON ENERGY OCCURED WHILE EXTENDING ENERGY RANGE DUE TO FLAG IEFOLD'
              WRITE(6,*)'CHECK INPUT FILE'
              WRITE(6,*)
              STOP
            ENDIF
          ENDDO
        ENDIF !ifreq2p

      ENDIF   !IEFOLD
C24.3.94}

      DO IFR=1,NFREQ
        WELLEN(IFR)=WTOE1/FREQ(IFR)
      ENDDO

C260194 }


      RETURN

999   CONTINUE

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'*** ERROR IN SR RFILFR ***'
      WRITE(LUNGFO,*)'FILE OPENING ERROR '
      WRITE(LUNGFO,*)'FILE, UNIT:'
      WRITE(LUNGFO,*)FILEFR, LUNFR
      WRITE(6,*)
      WRITE(6,*)'*** ERROR IN SR RFILFR ***'
      WRITE(6,*)'FILE OPENING ERROR '
      WRITE(6,*)'FILE, UNIT:'
      WRITE(6,*)FILEFR, LUNFR
      STOP
99    CONTINUE
      WRITE(6,*)
      WRITE(6,*)'*** ERROR IN SR RFILFR ***'
      WRITE(6,*)'FILE READING ERROR '
      WRITE(6,*)'FILE, UNIT:'
      WRITE(6,*)FILEFR, LUNFR
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'*** ERROR IN SR RFILFR ***'
      WRITE(LUNGFO,*)'FILE READING ERROR '
      WRITE(LUNGFO,*)'FILE, UNIT:'
      WRITE(LUNGFO,*)FILEFR, LUNFR
      STOP
      END
+DECK,RFILL0.
*CMZ :  3.00/00 11/03/2013  15.10.30  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.52/13 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.38/00 16/04/2004  09.24.47  by  Michael Scheer
*CMZ :  2.33/01 03/05/2001  12.28.19  by  Michael Scheer
*CMZ :  2.16/08 25/10/2000  12.21.53  by  Michael Scheer
*CMZ :  1.03/06 06/08/98  18.35.07  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  17.16.26  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.53.41  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.38  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE RFILL0
+seq,gplhint.

+SEQ,TRACKF90U,IF=F90.

+SELF,IF=F90.
+SEQ,SOURCEF90U.
+SELF.

C--- SOURCE POINTS ARE READ FROM FILE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,TRACK.
+seq,sourcef90.
+SEQ,COLLI.
+SEQ,SPECDIP.

      INTEGER ICODL0,ISOUR,I,J

C--- READ FILE FILEL0

      OPEN (UNIT=LUNL0,FILE = FILEL0,FORM = 'FORMATTED',STATUS = 'OLD')

      READ(LUNL0,*)ICODL0
      READ(LUNL0,*)NSOURCE
      READ(LUNL0,*)WGWINFC,WBL0CUT,WBL0HYS
      READ(LUNL0,*)CX1,CY1,CZ1,WID1,HIG1
      READ(LUNL0,*)CX2,CY2,CZ2,WID2,HIG2

+SELF,IF=-F90.
      IF (NSOURCE.GT.LIDIM) THEN
              WRITE(LUNGFO,*)
            WRITE(LUNGFO,*) '*** ERROR IN SR RFILL0 ***'
            WRITE(LUNGFO,*) '    BAD BUFFERSIZE,'
            WRITE(LUNGFO,*) '    INCREASE LIDIMP IN CMPARA.CMN'
              WRITE(LUNGFO,*)
            STOP
      ENDIF
+SELF,IF=F90.
        IF (ISPECDIP.GT.0.AND.NDIP.GT.NSOURCE) NSOURCE=NDIP
      ALLOCATE(SOURCEA(3,4,NSOURCE))
      ALLOCATE(SOURCEE(3,4,NSOURCE))
      ALLOCATE(SOURCEAO(3,4,NSOURCE))
      ALLOCATE(SOURCEEO(3,4,NSOURCE))
      ALLOCATE(SOURCEN(3,4,NSOURCE))
      ALLOCATE(SOURCET(3,NSOURCE))
+SELF.

      DO ISOUR=1,NSOURCE
        READ(LUNL0,*)   ((SOURCEA(I,J,ISOUR),I=1,3),J=1,4)
        READ(LUNL0,*)   ((SOURCEE(I,J,ISOUR),I=1,3),J=1,4)
      ENDDO

      CLOSE(LUNL0)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     *** SR RFILL0: SOURCE READ FROM FILE ***'
      WRITE(LUNGFO,*)'     FILE:,',FILEL0
      WRITE(LUNGFO,*)'     RUN NUMBER:',ICODL0
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     ATTENTION: INPUT PARAMETERS OVERWRITTEN'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     PARAMETERS:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     WGWINFC:',WGWINFC
      WRITE(LUNGFO,*)'     WBL0CUT:',WBL0CUT
      WRITE(LUNGFO,*)'     WBL0HYS:',WBL0HYS
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     PINHOLES OF COLLIMATOR:'
      WRITE(LUNGFO,*)'     (X,Y,Z), WIDTH, HIGHT:'
      WRITE(LUNGFO,*)'     ',SNGL(CX1),SNGL(CY1),SNGL(CZ1)
     &                        ,SNGL(WID1),SNGL(HIG1)
      WRITE(LUNGFO,*)'     ',SNGL(CX2),SNGL(CY2),SNGL(CZ2)
     &                       ,SNGL(WID2),SNGL(HIG2)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     NUMBER OF SOURCES:',NSOURCE
      WRITE(LUNGFO,*)'     BEGIN AND END OF SOURCES (XYZ):'
      DO ISOUR=1,NSOURCE
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     ',(SOURCEA(I,1,ISOUR),I=1,3)
        WRITE(LUNGFO,*)'     ',(SOURCEE(I,1,ISOUR),I=1,3)
      ENDDO
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &'     INTEGRATION IS LIMITED TO X BETWEEN XIANF AND XIEND'
      WRITE(LUNGFO,*)'     XIANF, XIEND:',SNGL(XIANF),SNGL(XIEND)
      WRITE(LUNGFO,*)
      DO ISOUR=1,NSOURCE
      WRITE(LUNGFO,*)'     SLOPES AT BEGIN AND END OF SOURCES (HOR.,VER.):'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &     '     ',SOURCEA(3,2,ISOUR)/SOURCEA(1,2,ISOUR)
     &    ,SOURCEA(2,2,ISOUR)/SOURCEA(1,2,ISOUR)
        WRITE(LUNGFO,*)
     &     '     ',SOURCEE(3,2,ISOUR)/SOURCEE(1,2,ISOUR)
     &    ,SOURCEE(2,2,ISOUR)/SOURCEE(1,2,ISOUR)
      ENDDO
      WRITE(LUNGFO,*)

      RETURN
      END
+DECK,RFILOB.
*CMZ :  4.00/11 09/06/2021  14.32.44  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.67/02 19/04/2012  08.52.32  by  Michael Scheer
*CMZ :  2.17/00 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.16/08 24/10/2000  11.19.57  by  Michael Scheer
*CMZ : 00.02/00 19/11/96  14.56.18  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  17.17.17  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.53.48  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.41  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE RFILOB
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,WFOLDF90U.
+SELF.

C--- SUBROUTINE READS OBSERVATION POINTS FOR WHICH PHOTON FLUX IS CALCULATED

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEq,observf90.
+SEQ,DEPOLA.
+SEq,wfoldf90.
+seq,sourcef90.

      INTEGER IOB,IC,ipos(2,8),nwords,istat,ieof
      character(256) cline

      OBSVDZ=0.
      OBSVDY=0.

C--- ONE SINGLE OBSERVATION POINT

      IF (IRFILOB.EQ.0) THEN
        NOBSV=1
        NOBSVZ=1
        NOBSVY=1
        OBSV(1,1)=OBS1X
        OBSV(2,1)=OBS1Y
        OBSV(3,1)=OBS1Z
        RETURN
      ENDIF !IRFILOB

      OPEN (UNIT=LUNOB,FILE=FILEOB,STATUS='OLD',FORM='FORMATTED',ERR=999)

      call util_skip_comment_end(lunob,ieof)

      read(lunob,'(a)') cline
      call util_string_split(cline,8,nwords,ipos,istat)

      IF(IHPIN.NE.0) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'*** ERROR IN SR RFILOB ***'
         WRITE(LUNGFO,*)'CONTROL FLAG IHPIN IS NOT COMPATIBLE WITH'
         WRITE(LUNGFO,*)'IRFILOB'
         WRITE(6,*)
         WRITE(6,*)'*** ERROR IN SR RFILOB ***'
         WRITE(6,*)'CONTROL FLAG IHPIN IS NOT COMPATIBLE WITH'
         WRITE(6,*)'IRFILOB'
      ENDIF

      if (nwords.eq.1) then
        READ(LUNOB,*,ERR=99) NOBSV
      else
        nobsv=0
        rewind(lunob)
        do while (.true.)
          call util_skip_comment_end(lunob,ieof)
          if (ieof.ne.0) exit
          read(lunob,'(a)',end=9,err=9) cline
          nobsv=nobsv+1
        enddo
9       rewind(lunob)
      endif

      IF(NOBSV.GT.NDOBSV) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN SR RFILOB ***'
        WRITE(LUNGFO,*)'TOO MANY OBSERVATION POINTS ON FILEOB'
        WRITE(LUNGFO,*)'INCREASE PARAMETER NDOBSVP IN CMPARA.CMN'
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN SR RFILOB ***'
        WRITE(6,*)'TOO MANY OBSERVATION POINTS ON FILEOB'
        WRITE(6,*)'INCREASE PARAMETER NDOBSVP IN CMPARA.CMN'
        STOP
      ENDIF

+SELF,IF=F90.
      IF (IOBSV_A.NE.NOBSV) THEN
          IF (IOBSV_A.NE.0) DEALLOCATE(OBSV)
          ALLOCATE(OBSV(3,NOBSV))
          IOBSV_A=NOBSV
      ENDIF !(IOBSV_A.LT.NOBSV)
      IF (IOBSVZ_A.NE.NOBSVZ) THEN
          IF (IOBSVZ_A.NE.0) DEALLOCATE(OBSVZ)
          ALLOCATE(OBSVZ(NOBSVZ))
          IOBSVZ_A=NOBSVZ
      ENDIF !(IOBSVY_A.LT.NOBSVY)
      IF (IOBSVY_A.NE.NOBSVY) THEN
          IF (IOBSVY_A.NE.0) DEALLOCATE(OBSVY)
          ALLOCATE(OBSVY(NOBSVY))
          IOBSVY_A=NOBSVY
      ENDIF !(IOBSV_A.LT.NOBSV)
+SELF.

      DO IOB=1,NOBSV
          call util_skip_comment_end(lunob,ieof)
          READ(LUNOB,*,ERR=99) (OBSV(IC,IOB),IC=1,3)
      ENDDO
      CLOSE(LUNOB)

      RETURN

999   CONTINUE
      WRITE(6,*)
      WRITE(6,*)'*** ERROR IN SR RFILOB ***'
      WRITE(6,*)'FILE OPENING ERROR '
      WRITE(6,*)'FILE, UNIT:'
      WRITE(6,*)FILEOB, LUNOB
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'*** ERROR IN SR RFILOB ***'
      WRITE(LUNGFO,*)'FILE OPENING ERROR '
      WRITE(LUNGFO,*)'FILE, UNIT:'
      WRITE(LUNGFO,*)FILEOB, LUNOB
      STOP
99    CONTINUE
      WRITE(6,*)
      WRITE(6,*)'*** ERROR IN SR RFILOB ***'
      WRITE(6,*)'FILE READING ERROR '
      WRITE(6,*)'FILE, UNIT:'
      WRITE(6,*)FILEOB, LUNOB
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'*** ERROR IN SR RFILOB ***'
      WRITE(LUNGFO,*)'FILE READING ERROR '
      WRITE(LUNGFO,*)'FILE, UNIT:'
      WRITE(LUNGFO,*)FILEOB, LUNOB
      STOP
      END
+DECK,RFILSP0.
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.41/10 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  14.22.45  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.24.35  by  Michael Scheer
*CMZ :  2.13/03 10/01/2000  17.17.14  by  Michael Scheer
*CMZ :  2.00/00 05/01/99  16.19.21  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  14.47.16  by  Michael Scheer
*CMZ : 00.02/04 24/02/97  12.37.49  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  17.18.53  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.53.53  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.17  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE RFILSP0
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SELF.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,FREQS.
+seq,sourcef90.
+SEQ,MYFILES.

      CHARACTER(60) CODSP0
      INTEGER ICODSP0,IO,IX,IFR,IS,N2POWY,N2POWZ,IY,IZ,IOBSV,
     &          NOBSVZN,NOBSVYN,NOBSVN,IOO

         OPEN(UNIT=LUNSP0,FILE=FILESP0,STATUS='OLD')

         READ(LUNSP0,'(I12,A60)')ICODSP0,CODSP0
         READ(LUNSP0,*)

         IF (IUSEM .NE. 0) THEN


         DO IS=1,NSOURCE
         DO IO=1,NOBSV
         DO IFR=1,NFREQ
+SELF,IF=-NEWWAVE.
             SPEC(IS,IO,IFR)=0.0
+SELF,IF=NEWWAVE.
             SPEC(IS+NSOURCE*(IO-1+NOBSV*(IFR-1)))=0.0
+SELF.
         ENDDO
         ENDDO
         ENDDO

         READ(LUNSP0,*)NSOURCE,NOBSVN,NFREQ,IFREQ2P
         READ(LUNSP0,*)NOBSVZN,NOBSVYN,MOBSVZ,MOBSVY
         READ(LUNSP0,*)MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY
         READ(LUNSP0,*)
         READ(LUNSP0,*)PINW,PINH,PINR
         READ(LUNSP0,*)OBSVDZ,OBSVDY
         READ(LUNSP0,*)

           IF (NOBSVZN/2*2.NE.NOBSVZN) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)'*** ERROR IN RFILSP0 ***'
             WRITE(LUNGFO,*)
     &'FLAG IUSEM IS SET, BUT NUMBER OF HORIZONTAL GRID POINTS IS NOT EVEN!'
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(6,*)
             WRITE(6,*)'*** ERROR IN RFILSP0 ***'
             WRITE(6,*)
     &'FLAG IUSEM IS SET, BUT NUMBER OF HORIZONTAL GRID POINTS IS NOT EVEN!'
             WRITE(6,*)
             WRITE(6,*)
             STOP
           ENDIF  !NOBSVZN
           IF (NOBSVYN/2*2.NE.NOBSVYN) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)'*** ERROR IN RFILSP0 ***'
             WRITE(LUNGFO,*)
     &'FLAG IUSEM IS SET, BUT NUMBER OF VERTICAL GRID POINTS IS NOT EVEN!'
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(6,*)
             WRITE(6,*)'*** ERROR IN RFILSP0 ***'
             WRITE(6,*)
     &'FLAG IUSEM IS SET, BUT NUMBER OF VERTICAL GRID POINTS IS NOT EVEN!'
             WRITE(6,*)
             WRITE(6,*)
             STOP
           ENDIF  !NOBSVYN

           N2POWZ=NINT(ALOG(FLOAT(NOBSVZN-1))/ALOG(2.))
           IF(NOBSVZN .GT. 2**N2POWZ) N2POWZ=N2POWZ+1
           NOBSVZ=2**N2POWZ

           N2POWY=NINT(ALOG(FLOAT(NOBSVYN-1))/ALOG(2.))
           IF(NOBSVYN .GT. 2**N2POWY) N2POWY=N2POWY+1
           NOBSVY=2**N2POWY

           NOBSV=NOBSVZ*NOBSVY

           IF (NOBSVZ.GT.NDOBSVZP) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)'*** ERROR IN RFILSP0 ***'
             WRITE(LUNGFO,*)
     &'DIMENSION EXCEEDED, INCREASE PARAMETER NDOBSVZP IN CMPARA.CMN'
             WRITE(LUNGFO,*)'MUST BE AT LEAST:',NOBSVZ
             WRITE(LUNGFO,*)
             WRITE(6,*)
             WRITE(6,*)
             WRITE(6,*)'*** ERROR IN RFILSP0 ***'
             WRITE(6,*)
     &'DIMENSION EXCEEDED, INCREASE PARAMETER NDOBSVZP IN CMPARA.CMN'
             WRITE(6,*)'MUST BE AT LEAST:',NOBSVZ
             WRITE(6,*)
             WRITE(6,*)
             STOP
           ENDIF      !NOBVZP

           IF (NOBSVY.GT.NDOBSVYP) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)'*** ERROR IN RFILSP0 ***'
             WRITE(LUNGFO,*)
     &'DIMENSION EXCEEDED, INCREASE PARAMETER NDOBSVYP IN CMPARA.CMN'
             WRITE(LUNGFO,*)'MUST BE AT LEAST:',NOBSVY
             WRITE(LUNGFO,*)
             WRITE(6,*)
             WRITE(6,*)
             WRITE(6,*)'*** ERROR IN RFILSP0 ***'
             WRITE(6,*)
     &'DIMENSION EXCEEDED, INCREASE PARAMETER NDOBSVYP IN CMPARA.CMN'
             WRITE(6,*)'MUST BE AT LEAST:',NOBSVY
             WRITE(6,*)
             WRITE(6,*)
             STOP
           ENDIF      !NOBVZP

             MEDGEZ=(NOBSVZ-MOBSVZ)/2
             MEDGEY=(NOBSVY-MOBSVY)/2
             MMEDGEZ=0
             MMEDGEY=0

         READ(LUNSP0,*)(OBSVZ(IO),
     &              IO=(NOBSVZ-NOBSVZN)/2+1,(NOBSVZ-NOBSVZN)/2+NOBSVZN)
         READ(LUNSP0,*)
         READ(LUNSP0,*)(OBSVY(IO),
     &              IO=(NOBSVY-NOBSVYN)/2+1,(NOBSVY-NOBSVYN)/2+NOBSVYN)
         READ(LUNSP0,*)

         DO IO=1,NOBSVN

            IZ=MOD(IO-1,NOBSVZN)+1
            IY=(IO-1)/NOBSVZN+1
            IOO=((NOBSVY-NOBSVYN)/2+IY-1)*NOBSVZ+((NOBSVZ-NOBSVZN)/2+IZ)
            READ(LUNSP0,*)(OBSV(IX,IOO),IX=1,3)

         DO IFR=1,NFREQ

+SELF,IF=-NEWWAVE.
            READ(LUNSP0,*)FREQ(IFR),(SPEC(IS,IOO,IFR),IS=1,NSOURCE)
     &                        ,SPECTOT(IOO,IFR)
+SELF,IF=NEWWAVE.
            READ(LUNSP0,*)FREQ(IFR)
     &      ,(SPEC(IS+NSOURCE*(IOO-1+NOBSV*(IFR-1))),IS=1,NSOURCE)
     &                        ,SPECTOT(IOO+NOBSV*(IFR-1))
+SELF.

         ENDDO
         ENDDO

         IOBSV=0
         DO IY=1,NOBSVY
         DO IZ=1,NOBSVZ
             IOBSV=IOBSV+1
             OBSVZ(IZ)=-DFLOAT(NOBSVZ-1)/2.*OBSVDZ+(IZ-1)*OBSVDZ
             OBSVY(IY)=-DFLOAT(NOBSVY-1)/2.*OBSVDY+(IY-1)*OBSVDY
             OBSV(3,IOBSV)=-DFLOAT(NOBSVZ-1)/2.*OBSVDZ+(IZ-1)*OBSVDZ
             OBSV(2,IOBSV)=-DFLOAT(NOBSVY-1)/2.*OBSVDY+(IY-1)*OBSVDY
         ENDDO
         ENDDO

         ELSE  !IUSEM

         READ(LUNSP0,*)NSOURCE,NOBSV,NFREQ,IFREQ2P
         READ(LUNSP0,*)NOBSVZ,NOBSVY,MOBSVZ,MOBSVY
         READ(LUNSP0,*)MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY
         READ(LUNSP0,*)
         READ(LUNSP0,*)PINW,PINH,PINR
         READ(LUNSP0,*)OBSVDZ,OBSVDY
         READ(LUNSP0,*)

         READ(LUNSP0,*)(OBSVZ(IO),IO=1,NOBSVZ)
         READ(LUNSP0,*)
         READ(LUNSP0,*)(OBSVY(IO),IO=1,NOBSVY)
         READ(LUNSP0,*)

         DO IO=1,NOBSV
            READ(LUNSP0,*)(OBSV(IX,IO),IX=1,3)
         DO IFR=1,NFREQ
+SELF,IF=-NEWWAVE.
            READ(LUNSP0,*)FREQ(IFR),(SPEC(IS,IO,IFR),IS=1,NSOURCE)
     &                        ,SPECTOT(IO,IFR)
+SELF,IF=NEWWAVE.
            READ(LUNSP0,*)FREQ(IFR)
     &      ,(SPEC(IS+NSOURCE*(IO-1+NOBSV*(IFR-1))),IS=1,NSOURCE)
     &                        ,SPECTOT(IO+NOBSV*(IFR-1))
+SELF.

         ENDDO
         ENDDO

         ENDIF !IUSEM

         CLOSE(LUNSP0)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'*** MESSAGE SR RFILSP0 ***'
      WRITE(LUNGFO,*)'DATA OF SPECTRUM CALCULATIONS READ FROM FILE:'
      WRITE(LUNGFO,*)FILESP0
      WRITE(LUNGFO,*)
     &  'OLD DATA OF NSOURCE,NOBSV,NFREQ,OBSV,FREQ,SPEC,SPECTOT ETC. OVERWRITTEN'
      WRITE(LUNGFO,*)'CHECK RESULTS CAREFULLY'
      WRITE(LUNGFO,*)'JOBNUMBER, USER COMMENT:'
      WRITE(LUNGFO,*)ICODSP0,'; ',CODSP0
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

      IF (IUSEM.NE.0) THEN

C--- CHECK IF NUMBER OF GRID POINTS ARE POWERS OF 2

      N2POWZ=NINT(ALOG(FLOAT(NOBSVZ-1))/ALOG(2.))

      IF (NOBSVZ.NE.2**N2POWZ) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN RFILSP0 ***'
          WRITE(LUNGFO,*)
     &      'Number of horizontal observation points not power of 2'
          WRITE(LUNGFO,*)'Check input file WAVE.IN'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN RFILSP0 ***'
          WRITE(6,*)
     &      'Number of horizontal observation points not power of 2'
          WRITE(6,*)'Check input file WAVE.IN'
          WRITE(6,*)
          STOP
      ENDIF

      N2POWY=NINT(ALOG(FLOAT(NOBSVY-1))/ALOG(2.))

      IF (NOBSVY.NE.2**N2POWY) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN RFILSP0 ***'
          WRITE(LUNGFO,*)
     &      'Number of horizontal observation points not power of 2'
          WRITE(LUNGFO,*)'Check input file WAVE.IN'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN RFILSP0 ***'
          WRITE(6,*)
     &      'Number of horizontal observation points not power of 2'
          WRITE(6,*)'Check input file WAVE.IN'
          WRITE(6,*)
          STOP
      ENDIF
      ENDIF !IUSEM

      RETURN
      END
+DECK,RFILSTO.
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.41/10 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  14.22.45  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.24.35  by  Michael Scheer
*CMZ :  2.13/03 12/01/2000  14.27.55  by  Michael Scheer
*CMZ :  2.00/00 05/01/99  17.24.24  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  14.47.16  by  Michael Scheer
*CMZ : 00.02/04 24/02/97  12.37.49  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  17.20.38  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.53.58  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.19  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE RFILSTO
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SELF.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,FREQS.
+seq,sourcef90.
+SEQ,MYFILES.

      CHARACTER(60) CODSTO
      INTEGER ICODSTO,IO,IX,IFR,IS,N2POWY,N2POWZ,IZ,IY,IOO
     &         ,NOBSVN,NOBSVZN,NOBSVYN,IOBSV

         OPEN(UNIT=LUNSTO,FILE=FILESTO,STATUS='OLD')

         READ(LUNSTO,'(I12,A60)')ICODSTO,CODSTO
         READ(LUNSTO,*)

         IF (IUSEM.NE.0) THEN

         DO IS=1,4
         DO IO=1,NOBSV
         DO IFR=1,NFREQ
+SELF,IF=-NEWWAVE.
             STOKES(IS,IO,IFR)=0.0
+SELF,IF=NEWWAVE.
             STOKES(IS,IO+NOBSV*(IFR-1))=0.0
+SELF.
         ENDDO
         ENDDO
         ENDDO

         READ(LUNSTO,*)NSOURCE,NOBSVN,NFREQ,IFREQ2P
         READ(LUNSTO,*)NOBSVZN,NOBSVYN,MOBSVZ,MOBSVY
         READ(LUNSTO,*)MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY
         READ(LUNSTO,*)
         READ(LUNSTO,*)PINW,PINH,PINR
         READ(LUNSTO,*)OBSVDZ,OBSVDY
         READ(LUNSTO,*)

           IF (NOBSVZN/2*2.NE.NOBSVZN) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)'*** ERROR IN RFILSTO ***'
             WRITE(LUNGFO,*)
     &'FLAG IUSEM IS SET, BUT NUMBER OF HORIZONTAL GRID POINTS IS NOT EVEN!'
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(6,*)
             WRITE(6,*)'*** ERROR IN RFILSTO ***'
             WRITE(6,*)
     &'FLAG IUSEM IS SET, BUT NUMBER OF HORIZONTAL GRID POINTS IS NOT EVEN!'
             WRITE(6,*)
             WRITE(6,*)
             STOP
           ENDIF  !NOBSVZN
           IF (NOBSVYN/2*2.NE.NOBSVYN) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)'*** ERROR IN RFILSTO ***'
             WRITE(LUNGFO,*)
     &'FLAG IUSEM IS SET, BUT NUMBER OF VERTICAL GRID POINTS IS NOT EVEN!'
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(6,*)
             WRITE(6,*)'*** ERROR IN RFILSTO ***'
             WRITE(6,*)
     &'FLAG IUSEM IS SET, BUT NUMBER OF VERTICAL GRID POINTS IS NOT EVEN!'
             WRITE(6,*)
             WRITE(6,*)
             STOP
           ENDIF  !NOBSVYN

           N2POWZ=NINT(ALOG(FLOAT(NOBSVZN-1))/ALOG(2.))
           IF(NOBSVZN .GT. 2**N2POWZ) N2POWZ=N2POWZ+1
           NOBSVZ=2**N2POWZ

           N2POWY=NINT(ALOG(FLOAT(NOBSVYN-1))/ALOG(2.))
           IF(NOBSVYN .GT. 2**N2POWY) N2POWY=N2POWY+1
           NOBSVY=2**N2POWY

           NOBSV=NOBSVZ*NOBSVY

           IF (NOBSVZ.GT.NDOBSVZP) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)'*** ERROR IN RFILSTO ***'
             WRITE(LUNGFO,*)
     &'DIMENSION EXCEEDED, INCREASE PARAMETER NDOBSVZP IN CMPARA.CMN'
             WRITE(LUNGFO,*)'MUST BE AT LEAST:',NOBSVZ
             WRITE(LUNGFO,*)
             WRITE(6,*)
             WRITE(6,*)
             WRITE(6,*)'*** ERROR IN RFILSTO ***'
             WRITE(6,*)
     &'DIMENSION EXCEEDED, INCREASE PARAMETER NDOBSVZP IN CMPARA.CMN'
             WRITE(6,*)'MUST BE AT LEAST:',NOBSVZ
             WRITE(6,*)
             WRITE(6,*)
             STOP
           ENDIF      !NOBVZP

           IF (NOBSVY.GT.NDOBSVYP) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)'*** ERROR IN RFILSTO ***'
             WRITE(LUNGFO,*)
     &'DIMENSION EXCEEDED, INCREASE PARAMETER NDOBSVYP IN CMPARA.CMN'
             WRITE(LUNGFO,*)'MUST BE AT LEAST:',NOBSVY
             WRITE(LUNGFO,*)
             WRITE(6,*)
             WRITE(6,*)
             WRITE(6,*)'*** ERROR IN RFILSTO ***'
             WRITE(6,*)
     &'DIMENSION EXCEEDED, INCREASE PARAMETER NDOBSVYP IN CMPARA.CMN'
             WRITE(6,*)'MUST BE AT LEAST:',NOBSVY
             WRITE(6,*)
             WRITE(6,*)
             STOP
           ENDIF      !NOBVZP

             MEDGEZ=(NOBSVZ-MOBSVZ)/2
             MEDGEY=(NOBSVY-MOBSVY)/2
             MMEDGEZ=0
             MMEDGEY=0

         READ(LUNSTO,*)(OBSVZ(IO),
     &              IO=(NOBSVZ-NOBSVZN)/2+1,(NOBSVZ-NOBSVZN)/2+NOBSVZN)
         READ(LUNSTO,*)
         READ(LUNSTO,*)(OBSVY(IO),
     &              IO=(NOBSVY-NOBSVYN)/2+1,(NOBSVY-NOBSVYN)/2+NOBSVYN)
         READ(LUNSTO,*)

         DO IO=1,NOBSVN

            IZ=MOD(IO-1,NOBSVZN)+1
            IY=(IO-1)/NOBSVZN+1
            IOO=((NOBSVY-NOBSVYN)/2+IY-1)*NOBSVZ+((NOBSVZ-NOBSVZN)/2+IZ)
            READ(LUNSTO,*)(OBSV(IX,IOO),IX=1,3)

         DO IFR=1,NFREQ

+SELF,IF=-NEWWAVE.
            READ(LUNSTO,*)FREQ(IFR),(STOKES(IS,IOO,IFR),IS=1,4)
+SELF,IF=NEWWAVE.
            READ(LUNSTO,*)FREQ(IFR),(STOKES(IS,IOO+NOBSV*(IFR-1)),IS=1,4)
+SELF.
         ENDDO
         ENDDO

         IOBSV=0
         DO IY=1,NOBSVY
         DO IZ=1,NOBSVZ
             IOBSV=IOBSV+1
             OBSVZ(IZ)=-DFLOAT(NOBSVZ-1)/2.*OBSVDZ+(IZ-1)*OBSVDZ
             OBSVY(IY)=-DFLOAT(NOBSVY-1)/2.*OBSVDY+(IY-1)*OBSVDY
             OBSV(3,IOBSV)=-DFLOAT(NOBSVZ-1)/2.*OBSVDZ+(IZ-1)*OBSVDZ
             OBSV(2,IOBSV)=-DFLOAT(NOBSVY-1)/2.*OBSVDY+(IY-1)*OBSVDY
         ENDDO
         ENDDO

         ELSE  !IUSEM

         READ(LUNSTO,*)NSOURCE,NOBSV,NFREQ,IFREQ2P
         READ(LUNSTO,*)NOBSVZ,NOBSVY,MOBSVZ,MOBSVY
         READ(LUNSTO,*)MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY
         READ(LUNSTO,*)
         READ(LUNSTO,*)PINW,PINH,PINR
         READ(LUNSTO,*)OBSVDZ,OBSVDY
         READ(LUNSTO,*)

         READ(LUNSTO,*)(OBSVZ(IO),IO=1,NOBSVZ)
         READ(LUNSTO,*)
         READ(LUNSTO,*)(OBSVY(IO),IO=1,NOBSVY)
         READ(LUNSTO,*)

         DO IO=1,NOBSV
            READ(LUNSTO,*)(OBSV(IX,IO),IX=1,3)
         DO IFR=1,NFREQ
+SELF,IF=-NEWWAVE.
            READ(LUNSTO,*)FREQ(IFR),(STOKES(IS,IO,IFR),IS=1,4)
+SELF,IF=NEWWAVE.
            READ(LUNSTO,*)FREQ(IFR),(STOKES(IS,IO+NOBSV*(IFR-1)),IS=1,4)
+SELF.
         ENDDO
         ENDDO

         ENDIF !IUSEM

         CLOSE(LUNSTO)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'*** MESSAGE SR RFILSTO ***'
      WRITE(LUNGFO,*)'DATA OF SPECTRUM CALCULATIONS READ FROM FILE:'
      WRITE(LUNGFO,*)FILESTO
      WRITE(LUNGFO,*)
     &  'OLD DATA OF NSOURCE,NOBSV,NFREQ,OBSV,FREQ,STOKES ETC. OVERWRITTEN'
      WRITE(LUNGFO,*)'CHECK RESULTS CAREFULLY'
      WRITE(LUNGFO,*)'JOBNUMBER, USER COMMENT:'
      WRITE(LUNGFO,*)ICODSTO,'; ',CODSTO
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

      IF (IUSEM.NE.0) THEN

C--- CHECK IF NUMBER OF GRID POINTS ARE POWERS OF 2

      N2POWZ=NINT(ALOG(FLOAT(NOBSVZ-1))/ALOG(2.))

      IF (NOBSVZ.NE.2**N2POWZ) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN RFILSTO ***'
          WRITE(LUNGFO,*)
     &      'Number of horizontal observation points not power of 2'
          WRITE(LUNGFO,*)'Check input file WAVE.IN'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN RFILSTO ***'
          WRITE(6,*)
     &      'Number of horizontal observation points not power of 2'
          WRITE(6,*)'Check input file WAVE.IN'
          WRITE(6,*)
          STOP
      ENDIF

      N2POWY=NINT(ALOG(FLOAT(NOBSVY-1))/ALOG(2.))

      IF (NOBSVY.NE.2**N2POWY) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN RFILSTO ***'
          WRITE(LUNGFO,*)
     &      'Number of horizontal observation points not power of 2'
          WRITE(LUNGFO,*)'Check input file WAVE.IN'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN RFILSTO ***'
          WRITE(6,*)
     &      'Number of horizontal observation points not power of 2'
          WRITE(6,*)'Check input file WAVE.IN'
          WRITE(6,*)
          STOP
      ENDIF
      ENDIF !IUSEM


      RETURN
      END
+DECK,SETNLPOI.
*CMZ :  3.05/06 17/07/2018  11.15.16  by  Michael Scheer
*CMZ :  3.05/02 09/05/2018  11.13.36  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.10.30  by  Michael Scheer
*CMZ :  2.67/04 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.63/05 12/08/2009  08.49.28  by  Michael Scheer
*CMZ :  2.63/02 24/01/2008  15.09.06  by  Michael Scheer
*CMZ :  2.52/09 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.52/01 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.51/00 25/05/2004  18.17.34  by  Michael Scheer
*CMZ :  2.50/00 29/04/2004  18.11.18  by  Michael Scheer
*CMZ :  2.47/05 16/04/2004  09.24.47  by  Michael Scheer
*CMZ :  2.16/08 25/10/2000  12.21.53  by  Michael Scheer
*CMZ :  2.16/07 14/09/2000  17.12.07  by  Michael Scheer
*CMZ :  2.16/05 28/07/2000  16.14.29  by  Michael Scheer
*CMZ :  2.16/04 20/07/2000  12.23.59  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.35  by  Michael Scheer
*CMZ :  2.12/03 17/06/99  13.51.34  by  Michael Scheer
*CMZ :  2.10/01 18/03/99  11.30.11  by  Michael Scheer
*CMZ :  2.02/00 15/02/99  10.19.37  by  Michael Scheer
*CMZ :  2.00/00 05/01/99  14.45.11  by  Michael Scheer
*-- Author :    Michael Scheer   15/12/98
      SUBROUTINE SETNLPOI
+seq,gplhint.

+SEQ,TRACKF90U.
+SEQ,SOURCEF90U.

C--- SETNLPOI ESTIMATES VALUES FOR NLPOI
C--- FORMULA FROM X-RAY DATA BOOKLET

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,FREQS.
+SEQ,COLLI.
+SEQ,B0SCGLOB.
+SEQ,TRACK.
+seq,sourcef90.
+seq,phycon.

      INTEGER NLPOIMX,NLPERMN,NLPOIMN,ISOUR,NLSOUMN
      DOUBLE PRECISION B0DIP,YLOW,YHIGH,WGLOW,WGHIGH,ECDIP,PHIDEFL,
     &  DEFLEC,DLENG,SOULEN,DNPER,HARM,HARMWIDTH

      DATA NLPOIMX/2000000/,NLPERMN/100/,NLSOUMN/10/

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SR SETNLPOI CALLED:'
      WRITE(LUNGFO,*)

        PHIDEFL=ANGRMS*SQRT(2.)
        B0DIP=BRMS*SQRT(2.)
        DEFLEC=PHIDEFL*DMYGAMMA

        IF (B0DIP.NE.0.D0) THEN
          DLENG=DEFLEC/93.4/B0DIP
        ELSE
          DLENG=0.D0
        ENDIF

        IF (DLENG.EQ.0.0) DLENG=(XMX-XMN)

        HARM=0.95D3*DMYENERGY**2/(1.D0+DEFLEC**2/2.D0)/DLENG/100.d0

        IF (DLENG.EQ.0.0) DLENG=(XMX-XMN)

        DNPER=(XMX-XMN)/DLENG

        IF (DNPER.LT.1.D0) DNPER=1.D0

        NLPOIMN=NLPERMN*DNPER*DEFLEC
        HARMWIDTH=HARM/DNPER

        IF (B0DIP.EQ.0.D0) THEN
          WRITE(LUNGFO,*)'*** WARNING IN SETNLPOI:  ***'
          WRITE(LUNGFO,*)'ZERO MAG. FIELD'
          WRITE(6,*)'*** WARNING IN SETNLPOI:  ***'
          WRITE(6,*)'ZERO MAG. FIELD'
          NLPOI=1000
          GOTO 9999
        ENDIF

        ECDIP=ecdipev1*DMYENERGY**2*B0DIP

        WRITE(LUNGFO,*)
     &    '     mag. field [T], Ec [eV]:',SNGL(B0DIP),SNGL(ECDIP)
        WRITE(LUNGFO,*)
     &    '     first harmonical [eV] (estimate):'
        WRITE(LUNGFO,*)
     &    '     ',SNGL(HARM)
     &    ,SNGL(HARM-HARMWIDTH),' -> ',SNGL(HARM+HARMWIDTH)
        WRITE(LUNGFO,*)
     &    '     K, lx, N of effective periodical device:'
        WRITE(LUNGFO,*)
     &    '     ',SNGL(DEFLEC),SNGL(DLENG),SNGL(DNPER)
        WRITE(LUNGFO,*)

        YLOW=FREQ(1)/ECDIP
        YHIGH=FREQ(NFREQ)/ECDIP

        IF (YLOW.LT.1.) THEN
          WGLOW=0.408/DMYENERGY*YLOW**(-0.354)/1000.
        ELSE
          WGLOW=0.408/DMYENERGY*YLOW**(-0.549)/1000.
        ENDIF

        IF (YHIGH.LT.1.) THEN
          WGHIGH=0.408/DMYENERGY*YHIGH**(-0.354)/1000.
        ELSE
          WGHIGH=0.408/DMYENERGY*YHIGH**(-0.549)/1000.
        ENDIF

        WRITE(LUNGFO,*)
     &    '      low and high size of radiaton cone [1/gamma]: '
        WRITE(LUNGFO,*)'     '
     &    ,SNGL(WGLOW*DMYGAMMA),SNGL(WGHIGH*DMYGAMMA)
        WRITE(LUNGFO,*)

        IF (WGLOW.GT.PHIDEFL) THEN
          WGLOW=PHIDEFL
        ENDIF

        IF (WGHIGH.GT.PHIDEFL) THEN
          WGHIGH=PHIDEFL
        ENDIF

        IF (NLPOI.EQ.-9999) THEN

          NLPOI=100*WGWINFC*WGLOW/WGHIGH
          IF (NLPOI.LT.NLPOIMN) THEN
            NLPOI=NLPOIMN
          ENDIF

          SOULEN=-1.D30
          DO ISOUR=1,NSOURCE
            IF (SOULEN.LT.SOURCEE(1,1,ISOUR)-SOURCEA(1,1,ISOUR)) THEN
              SOULEN=SOURCEE(1,1,ISOUR)-SOURCEA(1,1,ISOUR)
            ENDIF
          ENDDO

          IF (SOULEN.LE.0.D0) THEN
            WRITE(LUNGFO,*)'*** ERROR IN SETNLPOI: ZERO SOURCE LENGTH  ***'
            WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
            WRITE(6,*)'*** ERROR IN SETNLPOI: ZERO SOURCE LENGTH  ***'
            WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
            STOP
          ENDIF

          IF (NLPOI/SOULEN.LT.MYINUM) THEN
            NLPOI=NLSOUMN*MYINUM*SOULEN
          ENDIF

          IF (IUNDULATOR.NE.0) THEN
            NLPOI=NLPOIMN
            IF (NLPOI/SOULEN.LT.MYINUM) THEN
              NLPOI=MYINUM*SOULEN*1.1
            ENDIF
          ENDIF

          IF (NLPOI.GT.NLPOIMX) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** WARNING IN SETNLPOI: NLPOI VERY LARGE'
            WRITE(LUNGFO,*)'    NLPOI: ',NLPOI
            WRITE(LUNGFO,*)'    NLPOI limited to: ',NLPOIMX
            WRITE(6,*)
            WRITE(6,*)
            WRITE(6,*)'*** WARNING IN SETNLPOI: NLPOI VERY LARGE'
            WRITE(6,*)'    NLPOI: ',NLPOI
            WRITE(6,*)'    NLPOI limited to: ',NLPOIMX
            WRITE(6,*)
            NLPOI=NLPOIMX
          ENDIF

        ENDIF

9999  WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'      NLPOI set to: ',NLPOI
      WRITE(LUNGFO,*)

      RETURN
      END
+DECK,SETWGWIN.
*CMZ :  4.01/03 08/06/2023  15.01.10  by  Michael Scheer
*CMZ :  3.05/06 17/07/2018  11.15.16  by  Michael Scheer
*CMZ :  3.01/00 17/06/2013  09.14.35  by  Michael Scheer
*CMZ :  2.67/04 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.16/08 12/08/2009  08.49.28  by  Michael Scheer
*CMZ :  2.16/04 19/07/2000  11.26.53  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  2.00/00 05/01/99  14.47.39  by  Michael Scheer
*-- Author :    Michael Scheer   15/12/98
      SUBROUTINE SETWGWIN
+seq,gplhint.

+SEQ,TRACKF90U,IF=F90.

C--- ESTIMATES VALUE FOR WGWINFC
C--- FORMULA FROM X-RAY DATA BOOKLET

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,FREQS.
+SEQ,COLLI.
+SEQ,B0SCGLOB.
+SEQ,TRACK.
+seq,phycon.

      DOUBLE PRECISION B0DIP,YLOW,WGLOW,ECDIP,PHIDEFL,WGEXPAND

      DATA WGEXPAND/20.D0/

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SR SETWGWIN CALLED:'
      WRITE(LUNGFO,*)

      if (kellip.ne.0.or.khalba.ne.0.or.khalbasy.ne.0.or.kundugap.ne.0
     &    .or.kellana.ne.0.or.kbundumag.ne.0) then
        wgwinfc=pi1/4.0d0*dmygamma
        WRITE(LUNGFO,*)'      WGWINFC set to: ',WGWINFC
        WRITE(LUNGFO,*)
        return
      endif

C        PHIDEFL=(PHIMX-PHIMN)/2.
C     B0DIP=DSQRT(DABS(BMAXGL2))
      PHIDEFL=ANGRMS*SQRT(2.)
      B0DIP=BRMS*SQRT(2.)

      IF (B0DIP.EQ.0.D0) THEN
          WRITE(LUNGFO,*)'*** ERROR IN SETWGWIN: B0DIP.EQ.0  ***'
          WRITE(LUNGFO,*)'CHECK MAG. FIELD'
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
          WRITE(6,*)'*** ERROR IN SETWGWIN: B0DIP.EQ.0  ***'
          WRITE(6,*)'CHECK MAG. FIELD'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
          STOP
      ENDIF

      ECDIP=ecdipev1*DMYENERGY**2*B0DIP

      WRITE(LUNGFO,*)
     &'     mag. field [T], Ec [eV]:',SNGL(B0DIP),SNGL(ECDIP)
      WRITE(LUNGFO,*)

      YLOW=FREQ(1)/ECDIP

      IF (YLOW.LT.1.) THEN
          WGLOW=0.408/DMYENERGY*YLOW**(-0.354)/1000.
      ELSE
          WGLOW=0.408/DMYENERGY*YLOW**(-0.549)/1000.
      ENDIF

      IF (WGLOW*WGEXPAND.GT.PHIDEFL) THEN
          WGLOW=PHIDEFL
            WGWINFC=PHIDEFL*DMYGAMMA*1.2  !1.2 TO HAVE SOME OVERLAP
            WRITE(LUNGFO,*)
     &'    WGWINFC corresponds to angle greater than max. deflection'
      ENDIF

      IF (WGWINFC.EQ.9999.) THEN
          WGWINFC=WGLOW*WGEXPAND*DMYGAMMA
      ENDIF

      WRITE(LUNGFO,*)'      WGWINFC set to: ',WGWINFC
      WRITE(LUNGFO,*)

      RETURN
      END
+DECK,SOUADD.
*CMZ :  4.00/13 26/08/2021  09.23.14  by  Michael Scheer
*CMZ :  3.08/01 04/04/2019  07.58.25  by  Michael Scheer
*CMZ :  3.05/06 17/07/2018  11.15.16  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  16.48.27  by  Michael Scheer
*CMZ :  2.67/04 11/05/2012  11.20.42  by  Michael Scheer
*CMZ :  2.52/01 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.51/00 24/05/2004  20.37.45  by  Michael Scheer
*CMZ :  2.34/00 11/05/2001  15.24.39  by  Michael Scheer
*CMZ :  2.33/00 02/05/2001  15.58.03  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  14.22.45  by  Michael Scheer
*CMZ :  2.13/03 10/01/2000  17.17.14  by  Michael Scheer
*CMZ :  2.13/00 29/11/99  12.18.03  by  Michael Scheer
*CMZ :  2.12/03 07/07/99  12.27.14  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.47  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE SOUADD
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.

C--- SUMS UP THE CONTRIBUTIONS OF ALL SOURCES

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,sourcef90.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,FREQS.
+seq,phycon.

      INTEGER kfreq,IOBSV,ISOUR

C--- LOOP OVER ALL FREQUENCES

      DO kfreq=1,NFREQ

C--- LOOP OVER ALL OBSERVATION POINTS

        DO IOBSV=1,NOBSV

C--- LOOP OVER ALL SOURCES

          SPECTOT(IOBSV+NOBSV*(kfreq-1))=0.0d0
          DO ISOUR=1,NSOURCE

            IF (kfreq.EQ.1.AND.IOBSV.EQ.1.AND.IPIN.NE.2) THEN
              IF (IPINCIRC.EQ.0.or.ipin.eq.3) THEN
                CALL POWER(ISOUR)
              ELSE
                CALL POWERCIRC(ISOUR)
              ENDIF
            ENDIF !(kfreq.EQ.1.AND.IOBSV.EQ.1)

            ILIOBFR=ISOUR+NSOURCE*(IOBSV-1+NOBSV*(kfreq-1))

            IF( ISPECDIP.EQ.0.AND.SPECCUT.GT.0.0) then
              if(FREQ(kfreq).GT.SPECCUT*ecdipev1*DMYENERGY**2*ECMAX(ISOUR)) THEN
                SPEC(ILIOBFR)=0.0D0
              ENDIF
            ENDIF

            IOBFR=IOBSV+NOBSV*(kfreq-1)
            SPECTOT(IOBFR)=
     &        SPECTOT(IOBFR)+SPEC(ILIOBFR)

          ENDDO !LOOP OVER ALL SOURCES

        ENDDO !LOOP OVER ALL OBSERVATION POINTS
      ENDDO !LOOP OVER ALL FREQUENCES

      RETURN
      END
+DECK,SOUASYEXP.
*CMZ :  2.50/00 28/09/2009  13.02.09  by  Michael Scheer
*CMZ :  2.31/01 24/04/2001  17.56.57  by  Michael Scheer
*CMZ :  2.20/12 11/04/2001  16.40.07  by  Michael Scheer
*CMZ :  2.20/11 11/04/2001  15.48.38  by  Michael Scheer
*CMZ :  2.20/10 10/04/2001  11.24.36  by  Michael Scheer
*CMZ :  2.20/09 03/04/2001  10.29.02  by  Michael Scheer
*CMZ :  2.15/01 30/03/2001  19.35.06  by  Michael Scheer
*CMZ :  2.20/07 18/03/2001  16.50.02  by  Michael Scheer
*CMZ :  2.20/05 15/03/2001  14.46.11  by  Michael Scheer
*CMZ :  2.20/04 09/03/2001  16.47.40  by  Michael Scheer
*CMZ :  2.20/03 23/02/2001  15.04.13  by  Michael Scheer
*CMZ :  2.20/02 21/02/2001  11.30.46  by  Michael Scheer
*CMZ :  2.20/01 20/02/2001  14.18.37  by  Michael Scheer
*-- Author : Michael Scheer

      SUBROUTINE SOUASYEXP(IVELOFIELD,IROIASY
     &                     ,X2,Y2,Z2,VX2,VY2,VZ2,OBSVX,OBSVY,OBSVZ
     &                     ,BET1N,EXPOMR,EXPOMI,OM,BETP,BETPP,C,DMYGAMMA
     &                     ,A1R,A1I,A2R,A2I)
+seq,gplhint.

C--- EVALUATE ASYMPTOTIC EXPANSION UP TO SECOND ORDER

         IMPLICIT NONE

      DOUBLE PRECISION AI1R,AI1I,AI2R,AI2I,A1R(3),A1I(3),A2R(3),A2I(3)
        DOUBLE PRECISION RX,RY,RZ,RNX,RNY,RNZ,EXPOMR,EXPOMI,OM,C,DMYGAMMA
      DOUBLE PRECISION X2,Y2,Z2,VX2,VY2,VZ2,OBSVX,OBSVY,OBSVZ

      DOUBLE PRECISION RN(3),BET(3),BETP(3),BETPP(3),RP,RNBET(3),RNP(3),V(3)
     &                  ,VDUM1(3),VDUM2(3),VDUM3(3)
     &                  ,F(3),F1(3),F2,F3,F1P(3),F2P,F3P
     &                  ,FP(3),F23,F23P,RNPBETP(3),BET1N,BET1NP,FPPHIP(3)
     &                  ,R,R1,FV(3),FVP(3),FV1(3),FV1P(3),FVPPHIP(3)

      INTEGER ICOMP,IVELOFIELD,IROIASY

+SELF,IF=-NEWWAVE.
      WRITE(6,*)
     &'*** SOUASYEXP CALLED, BUT ONLY AVAILABLE FOR +SELF,IF=NEWWAVE  ***'
      WRITE(6,*) '*** PROGRAM WAVE ABORTED  ***'
      STOP
+SELF.

+SELF,IF=NOCMPLX.
      WRITE(6,*)
     &'*** SOUASYEXP CALLED, BUT ONLY AVAILABLE FOR +SELF,IF=-NOCMPLX  ***'
      WRITE(6,*) '*** PROGRAM WAVE ABORTED  ***'
      STOP
+SELF.

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION {

C REAL PART OF INTEGRAND {

          RX=OBSVX-X2
          RY=OBSVY-Y2
          RZ=OBSVZ-Z2

          R=SQRT(RX*RX+RY*RY+RZ*RZ)
          R1=1.D0/R

          RNX=RX*R1
          RNY=RY*R1
          RNZ=RZ*R1

C--- THE DISTANCE R IS INTRODUCED HERE EXPLICITLY (S. PROGRAM OF CHAOEN WANG

          RN(1)=RNX
          RN(2)=RNY
          RN(3)=RNZ

          V(1)=VX2
          V(2)=VY2
          V(3)=VZ2

          BET(1)=V(1)/C
          BET(2)=V(2)/C
          BET(3)=V(3)/C

          RP=-RN(1)*V(1)-RN(2)*V(2)-RN(3)*V(3)

          RNP(1)=(-V(1)-RN(1)*RP)/R;
          RNP(2)=(-V(2)-RN(2)*RP)/R;
          RNP(3)=(-V(3)-RN(3)*RP)/R;

          RNBET(1)=RN(1)-BET(1)
          RNBET(2)=RN(2)-BET(2)
          RNBET(3)=RN(3)-BET(3)

          RNPBETP(1)=RNP(1)-BETP(1)
          RNPBETP(2)=RNP(2)-BETP(2)
          RNPBETP(3)=RNP(3)-BETP(3)

          F2=R
          F3=BET1N*BET1N
          F23=F2*F3

          CALL UTIL_VCROSS_VCROSS(RN,RNBET,BETP,F1)

          F(1)=F1(1)/F23
          F(2)=F1(2)/F23
          F(3)=F1(3)/F23

          CALL UTIL_VCROSS_VCROSS(RNP,RNBET,BETP,VDUM1)
          CALL UTIL_VCROSS_VCROSS(RN,RNPBETP,BETP,VDUM2)
          CALL UTIL_VCROSS_VCROSS(RN,RNBET,BETPP,VDUM3)

          F1P(1)=VDUM1(1)+VDUM2(1)+VDUM3(1)
          F1P(2)=VDUM1(2)+VDUM2(2)+VDUM3(2)
          F1P(3)=VDUM1(3)+VDUM2(3)+VDUM3(3)

          F2P=RP
          BET1NP=
     &                 (-BETP(1)*RN(1)-BETP(2)*RN(2)-BETP(3)*RN(3)
     &                   -BET(1)*RNP(1)-BET(2)*RNP(2)-BET(3)*RNP(3))
          F3P=2.D0*BET1N*BET1NP
          F23P=F2P*F3+F2*F3P

          FP(1)=(F1P(1)*F23-F1(1)*F23P)/(F23*F23)
          FP(2)=(F1P(2)*F23-F1(2)*F23P)/(F23*F23)
          FP(3)=(F1P(3)*F23-F1(3)*F23P)/(F23*F23)

          FPPHIP(1)=(FP(1)*BET1N-F(1)*BET1NP)/F3
          FPPHIP(2)=(FP(2)*BET1N-F(2)*BET1NP)/F3
          FPPHIP(3)=(FP(3)*BET1N-F(3)*BET1NP)/F3

          FV1(1)=RNBET(1)*C/DMYGAMMA/DMYGAMMA/F2
          FV1(2)=RNBET(2)*C/DMYGAMMA/DMYGAMMA/F2
          FV1(3)=RNBET(3)*C/DMYGAMMA/DMYGAMMA/F2

          FV(1)=FV1(1)/F23
          FV(2)=FV1(2)/F23
          FV(3)=FV1(3)/F23

          FV1P(1)=C/DMYGAMMA/DMYGAMMA*
     &                      (RNPBETP(1)*F2-RNBET(1)*F2P)/F2/F2
          FV1P(2)=C/DMYGAMMA/DMYGAMMA*
     &                      (RNPBETP(2)*F2-RNBET(2)*F2P)/F2/F2
          FV1P(3)=C/DMYGAMMA/DMYGAMMA*
     &                      (RNPBETP(3)*F2-RNBET(3)*F2P)/F2/F2

          FVP(1)=(FV1P(1)*F23-FV1(1)*F23P)/(F23*F23)
          FVP(2)=(FV1P(2)*F23-FV1(2)*F23P)/(F23*F23)
          FVP(3)=(FV1P(3)*F23-FV1(3)*F23P)/(F23*F23)

          FVPPHIP(1)=(FVP(1)*BET1N-FV(1)*BET1NP)/F3
          FVPPHIP(2)=(FVP(2)*BET1N-FV(2)*BET1NP)/F3
          FVPPHIP(3)=(FVP(3)*BET1N-FV(3)*BET1NP)/F3

                 DO ICOMP=1,3

             IF (IVELOFIELD.EQ.0) THEN
              AI1R=(F(ICOMP)+FV(ICOMP))/BET1N*EXPOMI/OM
              AI1I=-(F(ICOMP)+FV(ICOMP))/BET1N*EXPOMR/OM
              AI2R=(FPPHIP(ICOMP)+FVPPHIP(ICOMP))/BET1N/OM*EXPOMR/OM
              AI2I=(FPPHIP(ICOMP)+FVPPHIP(ICOMP))/BET1N/OM*EXPOMI/OM
                   ELSE IF (IVELOFIELD.EQ.1) THEN
              AI1R=F(ICOMP)/BET1N*EXPOMI/OM
              AI1I=-F(ICOMP)/BET1N*EXPOMR/OM
              AI2R=FPPHIP(ICOMP)/BET1N/OM*EXPOMR/OM
              AI2I=FPPHIP(ICOMP)/BET1N/OM*EXPOMI/OM
                   ELSE IF (IVELOFIELD.LT.0) THEN
              AI1R=FV(ICOMP)/BET1N*EXPOMI/OM
              AI1I=-FV(ICOMP)/BET1N*EXPOMR/OM
              AI2R=FVPPHIP(ICOMP)/BET1N/OM*EXPOMR/OM
              AI2I=FVPPHIP(ICOMP)/BET1N/OM*EXPOMI/OM
             ELSE    !IVELOFIELD
                     WRITE(6,*)
     &                 '*** ERROR IN SOUASYEXP: BAD VALUE OF IVELOFIELD  ***'
                     WRITE(6,*) '*** PROGRAM WAVE ABORTED  ***'
                     STOP
                   ENDIF   !IVELOFIELD

                A1R(ICOMP)=AI1R
                A1I(ICOMP)=AI1I

             IF (ABS(IROIASY).GT.1) THEN
                  A2R(ICOMP)=AI2R
                  A2I(ICOMP)=AI2I
             ELSE
                  A2R(ICOMP)=0.D0
                  A2I(ICOMP)=0.D0
             ENDIF

           ENDDO  !ICOMP

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION }

         RETURN
      END
+DECK,SOUINT.
*CMZ :  4.00/14 22/12/2021  18.07.25  by  Michael Scheer
*CMZ :  4.00/07 28/04/2020  21.30.22  by  Michael Scheer
*CMZ :  3.08/01 02/04/2019  15.33.15  by  Michael Scheer
*CMZ :  3.07/01 21/03/2019  15.31.19  by  Michael Scheer
*CMZ :  3.05/14 28/09/2018  13.00.20  by  Michael Scheer
*CMZ :  3.05/01 08/05/2018  16.09.00  by  Michael Scheer
*CMZ :  3.02/06 15/04/2015  11.35.50  by  Michael Scheer
*CMZ :  3.02/03 06/11/2014  14.24.54  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  14.04.56  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  09.55.57  by  Michael Scheer
*CMZ :  2.50/00 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.49/00 22/03/2004  14.04.26  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  14.22.45  by  Michael Scheer
*CMZ :  2.12/00 27/05/99  10.08.55  by  Michael Scheer
*CMZ :  2.10/01 24/02/99  10.20.40  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  11.18.17  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.54.05  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.44  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE SOUINT(ISOUR,IBUFF)

+seq,gplhint.

+SEQ,OBSERVF90U.
+SEQ,SOURCEF90U.
+SEQ,reargF90U.
+SEQ,afreqF90U.
+self,if=omp.
      use ompmod
+self.
C--- EVALUATE INTEGRALES FOR A SINGLE SOURCE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEq,observf90.
+seq,sourcef90.
+seq,datetime.

      INTEGER ISOUR,IBUFF,IOBSV,JX10,JDX10,IX10,ICAL,NNBUFF,ICYCLE

      INTEGER NTUPP
      PARAMETER (NTUPP=22)
      CHARACTER(4) CTUP(NTUPP)

      DATA ICAL/0/

      data ctup /'t','x','y','z','rx','ry','rz','rt','p','rea','ima','roi'
     &            ,'iob','ie','yob','zob','betn','dtom','emod','dmod'
     &            ,'spec','te'/

+self,if=omp.
      if (iomp.eq.1.and.ipin.ne.0) then
        !print*,"******************* OMP ****************"
        call souint_omp(isour,ibuff)
        return
      endif
+self.,if=omp.

      IF (ICAL.EQ.0.AND.IBUFF.EQ.1)  THEN
        IX10=1
        JDX10=NBUFF*NOBSV/10
        JX10=JDX10
        NNBUFF=1
        IF (IWFILINT.EQ.-ISOUR)
+self,if=-mhbook.
     &    CALL hbookm(NIDSOURCE,'RADIATION INTEGRAL$',NTUPP
     &    ,'//WAVE',1024,CTUP)
+self,if=mhbook.
     &    CALL hbookm(NIDSOURCE,'RADIATION INTEGRAL',NTUPP
     &    ,'//WAVE',nlpoi/jwfilint+2*jwfilint,CTUP)
+self.
      ENDIF

      IF (JDX10.LT.1) JDX10=1

      IF (ISOUR.EQ.1.AND.IBUFF.EQ.1.AND.NOBSV.GT.1) THEN
        WRITE(6,*)' '
        WRITE(6,*)
     &    '      counting from 1 to 10 for first source to show progress:'
        WRITE(6,*)' '
      ENDIF

C--- LOOP OVER ALL OBSERVATION POINTS

      DO IOBSV=1,NOBSV

C- CALCULATE FREQUENCE INDEPENDENT PARTS OF INTEGRANTES,STORE RESULT IN ARRAYS

        CALL REARG(ISOUR,IOBSV)  !REAL PARTS OF INTEGRANTS

C--- INTEGRATION FOR ALL FREQUENCES

        CALL ARGSUM(ISOUR,IOBSV,IBUFF)

        IF(IWFILINT.EQ.ISOUR.AND.IOBSV.EQ.1) CALL WFILINT

        NNBUFF=NNBUFF+1

        IF (ICAL.EQ.0.AND.NNBUFF.EQ.JX10.AND.IX10.LE.10.AND.NOBSV.GT.1) THEN
          JX10=JX10+JDX10
          CALL date_and_time(dtday,dttime,dtzone,idatetime)
          WRITE(6,*)' ',IX10,' ',dttime(1:2),':',dttime(3:4),':',dttime(5:6)
          IX10=IX10+1
        ENDIF

      ENDDO !LOOP OVER ALL OBSERVATION POINTS


      IF (IBUFF.EQ.NBUFF) THEN
        IF (IWFILINT.EQ.-ISOUR) THEN
          CALL MHROUT(NIDSOURCE,ICYCLE,' ')
          CALL hdeletm(NIDSOURCE)
        ENDIF
        ICAL=1
      ENDIF

      RETURN
      END
+DECK,souintall.
*CMZ :  4.01/05 26/04/2024  14.26.24  by  Michael Scheer
*CMZ :  4.01/03 29/06/2023  11.47.09  by  Michael Scheer
*CMZ :  4.00/15 27/04/2022  08.35.33  by  Michael Scheer
*CMZ :  4.00/05 29/11/2019  13.11.04  by  Michael Scheer
*CMZ :  4.00/04 17/05/2019  14.22.20  by  Michael Scheer
*CMZ :  3.08/01 02/04/2019  15.33.15  by  Michael Scheer
*CMZ :  3.06/00 26/02/2019  17.25.55  by  Michael Scheer
*CMZ :  3.05/04 27/06/2018  14.21.59  by  Michael Scheer
*CMZ :  3.05/03 17/05/2018  15.20.37  by  Michael Scheer
*CMZ :  3.05/02 14/05/2018  12.06.08  by  Michael Scheer
*CMZ :  3.03/04 19/10/2017  15.16.22  by  Michael Scheer
*CMZ :  3.03/03 10/07/2017  09.04.23  by  Michael Scheer
*CMZ :  3.02/06 12/06/2015  14.16.15  by  Michael Scheer
*CMZ :  3.02/03 06/11/2014  18.17.54  by  Michael Scheer
*CMZ :  3.02/00 09/09/2014  16.46.27  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 05/03/2013  13.13.47  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  14.04.56  by  Michael Scheer
*CMZ :  2.70/00 07/12/2012  18.23.27  by  Michael Scheer
*CMZ :  2.69/02 08/11/2012  09.32.00  by  Michael Scheer
*CMZ :  2.69/01 31/10/2012  10.40.22  by  Michael Scheer
*CMZ :  2.69/00 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.68/05 18/10/2012  15.12.59  by  Michael Scheer
*CMZ :  2.68/03 07/08/2012  16.06.17  by  Michael Scheer
*CMZ :  2.68/02 05/07/2012  15.46.52  by  Michael Scheer
*CMZ :  2.68/01 28/05/2012  15.48.19  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  13.34.13  by  Michael Scheer
*CMZ :  2.67/02 16/03/2012  14.39.05  by  Michael Scheer
*CMZ :  2.66/20 06/07/2011  11.58.46  by  Michael Scheer
*CMZ :  2.66/13 25/06/2010  15.54.28  by  Michael Scheer
*CMZ :  2.66/12 24/06/2010  12.50.52  by  Michael Scheer
*CMZ :  2.66/09 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.66/07 10/03/2010  09.23.32  by  Michael Scheer
*CMZ :  2.66/05 27/11/2009  15.57.31  by  Michael Scheer
*CMZ :  2.66/04 16/11/2009  16.16.20  by  Michael Scheer
*CMZ :  2.66/03 11/11/2009  16.07.50  by  Michael Scheer
*CMZ :  2.65/03 28/10/2009  15.52.52  by  Michael Scheer
*CMZ :  2.65/00 18/09/2009  08.42.36  by  Michael Scheer
*CMZ :  2.64/06 14/09/2009  15.19.42  by  Michael Scheer
*CMZ :  2.64/05 08/09/2009  14.20.10  by  Michael Scheer
*CMZ :  2.63/05 12/08/2009  08.49.28  by  Michael Scheer
*CMZ :  2.61/02 16/01/2008  12.30.01  by  Michael Scheer
*CMZ :  2.52/11 08/12/2004  12.14.22  by  Michael Scheer
*CMZ :  2.52/02 08/07/2004  10.27.29  by  Michael Scheer
*CMZ :  2.52/00 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.51/00 26/05/2004  12.21.57  by  Michael Scheer
*CMZ :  2.50/02 30/04/2004  15.27.49  by  Michael Scheer
*CMZ :  2.50/00 29/04/2004  17.45.51  by  Michael Scheer
*CMZ :  2.41/09 14/08/2002  17.09.37  by  Michael Scheer
*CMZ :  2.41/05 16/04/2002  16.54.59  by  Michael Scheer
*CMZ :  2.41/04 16/04/2002  14.28.11  by  Michael Scheer
*CMZ :  2.36/01 08/11/2001  16.00.32  by  Michael Scheer
*CMZ :  2.36/00 08/11/2001  11.32.45  by  Michael Scheer
*CMZ :  2.33/08 05/11/2001  15.31.11  by  Michael Scheer
*CMZ :  2.33/00 03/05/2001  11.22.25  by  Michael Scheer
*CMZ :  2.32/01 25/04/2001  18.59.57  by  Michael Scheer
*CMZ :  2.31/01 25/04/2001  10.48.33  by  Michael Scheer
*CMZ :  2.30/01 12/04/2001  14.35.13  by  Michael Scheer
*CMZ :  2.20/12 11/04/2001  16.38.33  by  Michael Scheer
*CMZ :  2.20/11 11/04/2001  12.20.03  by  Michael Scheer
*CMZ :  2.20/10 05/04/2001  12.44.17  by  Michael Scheer
*CMZ :  2.20/08 18/03/2001  20.51.21  by  Michael Scheer
*CMZ :  2.20/04 09/03/2001  15.08.55  by  Michael Scheer
*CMZ :  2.20/03 22/02/2001  18.37.06  by  Michael Scheer
*CMZ :  2.20/01 11/02/2001  19.28.38  by  Michael Scheer
*CMZ :  2.16/08 31/10/2000  14.40.08  by  Michael Scheer
*CMZ :  2.16/07 21/09/2000  11.21.00  by  Michael Scheer
*CMZ :  2.16/06 28/08/2000  14.39.42  by  Michael Scheer
*CMZ :  2.16/05 02/08/2000  13.53.32  by  Michael Scheer
*CMZ :  2.16/04 19/06/2000  14.27.19  by  Michael Scheer
*CMZ :  2.16/03 16/06/2000  14.35.02  by  Michael Scheer
*CMZ :  2.15/00 05/05/2000  19.25.24  by  Michael Scheer
*CMZ :  2.14/02 26/04/2000  16.40.34  by  Michael Scheer
*CMZ :  2.13/07 17/02/2000  15.11.13  by  Michael Scheer
*CMZ :  2.13/03 18/01/2000  17.44.41  by  Michael Scheer
*CMZ :  2.12/03 21/07/99  10.47.09  by  Michael Scheer
*CMZ :  2.12/01 10/06/99  17.49.00  by  Michael Scheer
*CMZ :  2.12/00 04/06/99  10.43.55  by  Michael Scheer
*CMZ :  2.11/01 20/05/99  17.44.32  by  Michael Scheer
*CMZ :  2.10/01 24/02/99  10.20.40  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  11.18.17  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.54.05  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.44  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE SOUINTALL(ISOUR)
+seq,gplhint.

+SEQ,TRACKF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,SPECTF90U.
+SEQ,WFOLDF90U.
+SEQ,AFREQF90U.
+SEQ,AMPLIF90U.

      use bunchmod
      use ompmod
      use wbetaf90m
      use souintmod

C--- EVALUATE INTEGRALES FOR A SINGLE SOURCE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,PHYCON.
+SEQ,TRACK.
+seq,sourcef90.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,FREQS.
+SEQ,AMPLI.
+SEq,wfoldf90.
+seq,depola.
+seq,tralin.
+seq,b0scglob.
+SEQ,USERVAR.
+SEQ,STRINGS.
+SEQ,ustep.
+seq,datetime.

      DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE :: RESRAN
      DOUBLE PRECISION :: RMS,RESPOW,vx1,vy1,vz1,vn,schwingungen,
     &  yy,zz,yyp,zzp,
     &  tfmh(2,2),tfmv(2,2),tfmhi(2,2),tfmvi(2,2),
     &  tfmdeh(2,2),tfmdev(2,2),tfmdehi(2,2),tfmdevi(2,2),tfm1(2,2),
     &  w22(2,2),dum22(2,2),
     &  x1,y1,z1,x2,wx1,dxb
     &  ,alpha0(2),beta0(2),alphah,alphav,
     &  xub,yub,zub,ypub,zpub,gammaub,tphase,
     &  beta0h,s0h,beta0v,s0v,gammah,gammav,
     &  xco,yco,zco,ypco,zpco,egammaco,dpp=0.0d0,
     &  xfirst,yfirst,zfirst,ypfirst,zpfirst,egammafirst
+self,if=-tralinshort.
     &  ,rm,rq,alpha,beta
     &  ,psi,spsi,cpsi
+self.

      real xran(5),rr(2)

      INTEGER IOBSV,ISOUR,JX10,JDX10,IX10,INSIDE,nutracko
      INTEGER NTOTIN,NTOT2IN,IREP,KINSIDE
      INTEGER JEFOLD,JFOLD,JPIN,ICAL,IFREQ,ICOUNT,nelec,kobsv,jobunch,
     &  iw2(2),ifail,i1,icen,ierr,i2

      common/souintc/jpin

      DATA tfm1(1,1),tfm1(1,2),tfm1(2,1),tfm1(2,2)/1.0d0,0.0d0,0.0d0,1.0d0/
      DATA tfmhi(1,1),tfmhi(1,2),tfmhi(2,1),tfmhi(2,2)/1.0d0,0.0d0,0.0d0,1.0d0/
      DATA tfmvi(1,1),tfmvi(1,2),tfmvi(2,1),tfmvi(2,2)/1.0d0,0.0d0,0.0d0,1.0d0/
      DATA ICAL/0/

      allocate(ampzmax(nfreq),kobs(nfreq))

      IF (ICAL.EQ.0) THEN

        if (bunchcharge.eq.0.0d0) then
          bunchcharge=neinbunch*echarge1
        endif

        if (ibunch.eq.0) then
          ibunphase=0
          iobunch=0
        else if (abs(ibunch).ne.1) then
                write(LUNGFO,*)
     &            '*** Error in SOUINTALL: Bad value of IBUNCH (not -1,0,1)!  ***'
                write(6,*)
     &            '*** Error in SOUINTALL: Bad value of IBUNCH (not -1,0,1)!  ***'
                stop '*** Program WAVE aborted ***'
        endif

        if (iwbunch.gt.0) then
          open(unit=22,file='wave_phasespace_bunch.dat',status='old',
     &      iostat=ierr)
          if (ierr.eq.0) close(22,status='delete')
          open(unit=22,file='wave_phasespace_bunch.dat',status='new')
        endif

        if (mpinr.eq.0) then
          if (ibunphase.eq.0) iobunch=icbrill
          jobunch=icbrill
          if (iobunch.eq.0) then
            iobunch=icbrill
          endif
        else
          if (ibunphase.eq.0) iobunch=1
          jobunch=1
          if (iobunch.eq.0) then
            iobunch=1
          endif
        endif

        if (ibunch.eq.0) then
          neinbunch=1
          nbunch=1
          if (iobunch.eq.-9999) then
            if (mpinr.ne.0) then
              jobunch=icbrill
            else
              jobunch=1
            endif
          else
            jobunch=iobunch
          endif
        else if (iobunch.ne.-9999) then
          jobunch=iobunch
        endif

        nelec=nbunch*neinbunch

        IF (IAMPSEED.NE.0) CALL RMARIN(IAMPSEED,NTOTIN,NTOT2IN)

        if (jobunch.gt.nobsv) then
          write(6,*)' '
          write(6,*)' *** WARNING IN SOUINTALL: IOBUNCH.GT.NOBSV'
          write(6,*)' SET ACCORDING TO SELECTED POINT'
          write(6,*)' '
          write(lungfo,*)' '
          write(lungfo,*)' *** WARNING IN SOUINTALL: IOBUNCH.GT.NOBSV'
          write(lungfo,*)' SET ACCORDING TO SELECTED POINT'
          write(lungfo,*)' '
        endif

        allocate(wbetasub(16,3))

        ICAL=1
      ENDIF !ICAL

      xub=sourceao(1,1,isour)
      yub=sourceao(2,1,isour)
      zub=sourceao(3,1,isour)
      ypub=sourceao(2,2,isour)/sourceao(1,2,isour)
      zpub=sourceao(3,2,isour)/sourceao(1,2,isour)
      gammaub=sourceg(1,1,isour)

      xco=xub
      yco=yub
      zco=zub
      ypco=ypub
      zpco=zpub
      egammaco=gammaub

      xfirst=xco
      yfirst=yco
      zfirst=zco
      ypfirst=ypco
      zpfirst=zpco
      egammafirst=egammaco

      xelec=xco
      yelec=yco
      zelec=zco
      ypelec=ypco
      zpelec=zpco
      egamma=egammaco

      if (ibunch.ne.0) then

        if (iemit.eq.0.and.ilintra.lt.0) then
          nutracko=nutrack
          allocate(wbeta(16,nco))
          allocate(wbetak(3,nco))
c calculate transfer matrix from entrance to center
          call wbetfn
          nutrack=nutracko
        endif

        if (ilintra.lt.0) then

          tfmh=tfm1
          tfmv=tfm1
          tfmdeh=tfm1
          tfmdev=tfm1

          x1=sourceao(1,1,isour)
          y1=sourceao(2,1,isour)
          z1=sourceao(3,1,isour)
          x2=sourceeo(1,1,isour)

          dxb=(wbeta(1,nco)-wbeta(1,1))/(nco-1)

          wx1=wbeta(1,1)

          i1=nint((x1-wx1)/dxb)
          i2=nint((x2-wx1)/dxb)

          if (i1.lt.1) then
            if (i1.lt.0) then
              write(6,*)
     &          '*** Error in SOUTINALL: No horizontal beta function for first point of source found ***'
              write(6,*)
     &          'Taking value from x = ',wbeta(1,1)
            endif
            i1=1
          endif

          if (i2.gt.nco) then
              write(6,*)
     &          '*** Error in SOUTINALL: No horizontal beta function for last point of source found ***'
              write(6,*)
     &          'Taking value from x = ',wbeta(1,nco)
            i2=nco
          endif

          if (xlintra.eq.-9999.0d9) then
            icen=nint(((x1+x2)/2.0d0-wx1)/dxb)
          else
            icen=nint(xlintra/dxb)+1
            if (icen.le.i1.or.icen.gt.i2) then
              write(6,*)
     &          '*** Error in SOUINTALL: Bad XLINTRA, please check input *** '
              write(6,*)
     &          '*** XLINTRA MUST BE INSIDE SOURCE! *** '
              stop '*** WAVE aborted'
            endif
          endif

          wbetasub(1:16,1)=wbeta(1:16,i1)
          wbetasub(1:16,2)=wbeta(1:16,icen)
          wbetasub(1:16,3)=wbeta(1:16,i2)

          alpha0(1)=-wbeta(3,i1)/2.d0
          alpha0(2)=-wbeta(5,i1)/2.d0
          beta0(1)=wbeta(2,i1)
          beta0(2)=wbeta(4,i1)

+self,if=-tralinshort.
          alpha=-wbeta(3,icen)/2.d0
          beta=  wbeta(2,icen)
          psi=   wbeta(8,icen)

          cpsi=cos(psi)
          spsi=sin(psi)
          rq=sqrt(beta/beta0(1))
          rm=sqrt(beta*beta0(1))
          tfmh(1,1) = rq * (cpsi+alpha0(1)*spsi)
          tfmh(1,2) = rm * spsi
          tfmh(2,1)=
     &      ((alpha0(1)-alpha)*cpsi - (1.0d0+alpha0(1)*alpha)*spsi) / rm
          tfmh(2,2)=
     &      (cpsi-alpha*spsi) / rq

          alpha=-wbeta(5,icen)/2.d0
          beta=  wbeta(4,icen)
          psi=   wbeta(9,icen)

          cpsi=cos(psi)
          spsi=sin(psi)
          rq=sqrt(beta/beta0(2))
          rm=sqrt(beta*beta0(2))
          tfmv(1,1) = rq * (cpsi+alpha0(2)*spsi)
          tfmv(1,2) = rm * spsi
          tfmv(2,1)=
     &      ((alpha0(2)-alpha)*cpsi - (1.0d0+alpha0(2)*alpha)*spsi) / rm
          tfmv(2,2)=
     &      (cpsi-alpha*spsi) / rq

+self,if=tralinshort.
          call tralinshort(x1,y1,z1,0.0d0,0.0d0,(x1+x2)/2.0d0,dmygamma,
     &      tfmh,tfmv,tfmdeh,tfmdev)
+self.

          tfmdeh=tfmh
          tfmdev=tfmv

+self,if=-tralinshort,if=wbetdeltae.

          alpha0(1)=-wbeta(12,i1)/2.d0
          alpha0(2)=-wbeta(14,i1)/2.d0
          beta0(1)=wbeta(11,i1)
          beta0(2)=wbeta(13,i1)

          alpha=-wbeta(12,icen)/2.d0
          beta=  wbeta(11,icen)
          psi=   wbeta(15,icen)

          cpsi=cos(psi)
          spsi=sin(psi)
          rq=sqrt(beta/beta0(1))
          rm=sqrt(beta*beta0(1))

          tfmdeh(1,1) = rq * (cpsi+alpha0(1)*spsi)
          tfmdeh(1,2) = rm * spsi
          tfmdeh(2,1)=
     &      ((alpha0(1)-alpha)*cpsi - (1.0d0+alpha0(1)*alpha)*spsi) / rm
          tfmdeh(2,2)=
     &      (cpsi-alpha*spsi) / rq

          alpha=-wbeta(14,icen)/2.d0
          beta=  wbeta(13,icen)
          psi=   wbeta(16,icen)

          cpsi=cos(psi)
          spsi=sin(psi)
          rq=sqrt(beta/beta0(2))
          rm=sqrt(beta*beta0(2))

          tfmdev(1,1) = rq * (cpsi+alpha0(2)*spsi)
          tfmdev(1,2) = rm * spsi
          tfmdev(2,1)=
     &      ((alpha0(2)-alpha)*cpsi - (1.0d0+alpha0(2)*alpha)*spsi) / rm
          tfmdev(2,2)=
     &      (cpsi-alpha*spsi) / rq

+self.

        endif !(ilintra.eq.0) then

        if(ilintra.gt.0) then

          open(unit=99,file='wave_lintra.dat',status='old')
          call util_skip_comment(99)
          read(99,*)tfmh(1,1),tfmh(1,2)
          read(99,*)tfmh(2,1),tfmh(2,2)
          read(99,*)tfmv(1,1),tfmv(1,2)
          read(99,*)tfmv(2,1),tfmv(2,2)
          read(99,*)wbetasub(1:16,1)
          read(99,*)wbetasub(1:16,2)
          read(99,*)wbetasub(1:16,3)
          close(99)

          tfmdeh=tfmh
          tfmdev=tfmv

          write(lungfo,*)' '
          write(lungfo,*)'      SOUTINALL:'
          write(lungfo,*)' '
          write(lungfo,*)'      Horizontal lineare transfer-matrix:'
          write(lungfo,*)' '
          write(lungfo,*)'      ',tfmh(1,1),tfmh(1,2)
          write(lungfo,*)'      ',tfmh(2,1),tfmh(2,2)
          write(lungfo,*)' '
          write(lungfo,*)'      Vertical lineare transfer-matrix:'
          write(lungfo,*)' '
          write(lungfo,*)'      ',tfmv(1,1),tfmv(1,2)
          write(lungfo,*)'      ',tfmv(2,1),tfmv(2,2)
          write(lungfo,*)' '

        else if(ilintra.lt.0) then

          open(unit=99,file='wave_lintra.dat',status='unknown',recl=256)
          write(99,*)'* ',icode,code(1:len_trim(code))
          write(99,*)tfmh(1,1),tfmh(1,2)
          write(99,*)tfmh(2,1),tfmh(2,2)
          write(99,*)tfmv(1,1),tfmv(1,2)
          write(99,*)tfmv(2,1),tfmv(2,2)
          write(99,*)wbetasub(1:16,1)
          write(99,*)wbetasub(1:16,2)
          write(99,*)wbetasub(1:16,3)
          close(99)

        endif !(ilintra.eq.0) then

        if (ilintra.ne.0) then !(ilintra.ne.0) then

          w22=tfmh

          dum22(1,1)=1.0d0
          dum22(1,2)=0.0d0
          dum22(2,1)=0.0d0
          dum22(2,2)=1.0d0

          call deqinv(2,w22,2,iw2,ifail,2,dum22)

          if (ifail.ne.0) then
            write(6,*)'*** Error in SOUINTALL: Matrix invertation failed'
            write(6,*)'Please check horizontal beta functions.'
            write(lungfo,*)'*** Error in SOUINTALL: Matrix invertation failed'
            write(lungfo,*)'Please check horizontal beta functions.'
            stop '*** Program WAVE aborted ***'
          endif

          tfmhi=w22

          w22=tfmv

          dum22(1,1)=1.0d0
          dum22(1,2)=0.0d0
          dum22(2,1)=0.0d0
          dum22(2,2)=1.0d0

          call deqinv(2,w22,2,iw2,ifail,2,dum22)

          if (ifail.ne.0) then
            write(6,*)'*** Error in SOUINTALL: Matrix invertation failed'
            write(6,*)'Please check vertical beta functions.'
            write(lungfo,*)'*** Error in SOUINTALL: Matrix invertation failed'
            write(lungfo,*)'Please check vertical beta functions.'
            stop '*** Program WAVE aborted ***'
          endif

          tfmvi=w22

          tfmdehi=tfmhi
          tfmdevi=tfmvi

+self,if=-tralinshort,if=wbetdeltae.
          w22=tfmdeh

          dum22(1,1)=1.0d0
          dum22(1,2)=0.0d0
          dum22(2,1)=0.0d0
          dum22(2,2)=1.0d0

          call deqinv(2,w22,2,iw2,ifail,2,dum22)

          if (ifail.ne.0) then
            write(6,*)'*** Error in SOUINTALL: Matrix invertation failed'
            write(6,*)'Please check horizontal beta functions.'
            write(lungfo,*)'*** Error in SOUINTALL: Matrix invertation failed'
            write(lungfo,*)'Please check horizontal beta functions.'
            stop '*** Program WAVE aborted ***'
          endif

          tfmdehi=w22

          w22=tfmdev

          dum22(1,1)=1.0d0
          dum22(1,2)=0.0d0
          dum22(2,1)=0.0d0
          dum22(2,2)=1.0d0

          call deqinv(2,w22,2,iw2,ifail,2,dum22)

          if (ifail.ne.0) then
            write(6,*)'*** Error in SOUINTALL: Matrix invertation failed'
            write(6,*)'Please check vertical beta functions.'
            write(lungfo,*)'*** Error in SOUINTALL: Matrix invertation failed'
            write(lungfo,*)'Please check vertical beta functions.'
            stop '*** Program WAVE aborted ***'
          endif

          tfmdevi=w22
+self.

        endif !(ilintra.eq.0) then

      endif !ibunch.ne.0

      if (mpinr.ne.0) then
        allocate(phaserphi(nobsvrphi));
        allocate(expom1rphi(nobsvrphi));
        allocate(afferphi(6,nobsvrphi*nfreq))
        allocate(unphrphi(6,nobsvrphi*nfreq))
        phaserphi=0.0d0
        expom1rphi=(0.0d0,0.0d0)
        afferphi=(0.0d0,0.0d0)
        unphrphi=(0.0d0,0.0d0)
      else
        allocate(affe(6,nobsv*nfreq))
        affe=(0.0d0,0.0d0)
      endif

      allocate(ampz(nfreq))
      ampz=0.0d0
      allocate(azcos(nfreq))
      allocate(azsin(nfreq))
      allocate(phrnrn(nfreq))
      allocate(phexp(nfreq))
      azcos=1.0d0
      azsin=0.0d0
      phrnrn=0.0d0
      phexp=0.0d0

      JPIN=IPIN
      if (ipin.eq.3) ipin=0
      JFOLD=IFOLD
      JEFOLD=IEFOLD

      IF (IAMPLI.LT.0) THEN
        IF (ISOUR.EQ.1) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'      repetition of amplitude activated:'
          WRITE(LUNGFO,*)
     &      '      A -> A * (1 + exp(i*phi) + exp(i*2*phi)...'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'      IAMPLI:',IAMPLI
          WRITE(LUNGFO,*)
        ENDIF !ISOUR
        IF (AMPRAN.NE.0.D0) THEN
          IF (ISOUR.EQ.1) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'      phase errors for repetition activated:'
            WRITE(LUNGFO,*)
     &        '      A -> A * (1 + exp(i*phi*xran1) + exp(i*2*phi*xran2)...'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'      IAMPSEED: ',IAMPSEED
            WRITE(LUNGFO,*)
          ENDIF !ISOUR
c          ALLOCATE(XRANA(-IAMPLI))
          CALL RNORML(XRANA,-IAMPLI,rr)
          RMS=0.D0
          DO IREP=1,-IAMPLI
            XRANA(IREP)=AMPRAN*XRANA(IREP)
            RMS=RMS+XRANA(IREP)**2
          ENDDO
          RMS=SQRT(RMS/(-IAMPLI))
          WRITE(LUNGFO,*)
     &      '      rel. rms phase AMPRAN (input): ',SNGL(AMPRAN)
          WRITE(LUNGFO,*)
     &      '      rel. rms phase error 1. source (from generated errors): '
     &      ,SNGL(RMS)
        ENDIF   !(AMPRAN.NE.0.D0)

        IF (ABS(IMAMPLI).EQ.3) THEN
C--- WRITE FILES FOR PROGRAM PHASE OF JOHANNES BAHRDT
          CALL PHASE_BAHRDT
        ENDIF

      ENDIF   !IAMPLI

      JDX10=NOBSV/10
      JX10=JDX10

      IF (JDX10.LT.1) JDX10=1

      IF (ISOUR.EQ.1.AND.NOBSV.GT.1) THEN
        WRITE(6,*)' '
        WRITE(6,*)
     &    '      counting from 1 to 10 for first source to show progress:'
        WRITE(6,*)' '
        WRITE(6,*)' '
      ENDIF

      IF (ISPECMODE.EQ.1) CALL TRASOU(ISOUR)

      IF (JPIN.NE.2) THEN

C CALCULATE DISTRIBUTION IN PINHOLE {

        IX10=1
        KINSIDE=0

        ielec=0
        phrnrn=0.0
        phexp=cdexp(dcmplx(0.0d0,dble(phrnrn*twopi1)))

        egamma=sourceg(1,1,isour)

        do ibun=1,nbunch

          do isub=1,neinbunch

            ielec=ielec+1
            ampz=0.0d0

            if (ibunch.ne.0) then

c5.2.2013 bug?              if (iubunch.eq.0.or.iubunch.eq.1.or.ibunch.eq.1) then
              if (iubunch.eq.0.or.iubunch.eq.1) then

                if (bunchlen.eq.0.0d0) then
                  CALL GRNDMm(phrnrn,1)
                  phrnrn=phrnrn(1)
c                  CALL GRNDMm(phrnrn,nfreq)
c                  phexp=cdexp(dcmplx(0.0d0,dble(phrnrn*twopi1)))
                  phexp=cdexp(dcmplx(0.0d0,dble(phrnrn(1)*twopi1)))
                else if (bunchlen.gt.0.0d0)  then !(bunchlen.eq.0.0d0) then
c                  CALL RNORML(phrnrn,nfreq)
                  CALL RNORML(phrnrn,1,rr)
                  phrnrn=phrnrn(1)
                  do ifreq=1,nfreq
                    schwingungen = bunchlen*1.0d9 /
c     &                (WTOE1/freq(ifreq)) * phrnrn(ifreq)
     &                (WTOE1/freq(ifreq)) * phrnrn(1)
                    schwingungen=mod(schwingungen,1.0d0)
                    phexp(ifreq)=cdexp(dcmplx(0.0d0,schwingungen*twopi1))
                  enddo
                else ! bunchlen
                  phrnrn=0.0d0
                  phexp=(1.0d0,0.0d0)
                endif !(bunchlen.eq.0.0d0) then

                bunchx=phrnrn(1)*bunchlen !long. position in bunch

              else if (iubunch.eq.2.or.iubunch.eq.3.or.iubunch.eq.4) then

c here for all frequencies have the same phase
                if (nsource.gt.1) then
                  write(6,*)'*** WARNING IN SOUINTALL: USE OF IBUNCH IS RATHER'
                  write(6,*)'*** TRICKY SINCE MULTIPLE SOURCES ARE NOT YET FULLY'
                  write(6,*)'*** IMPLEMENTED! ELECTRONS ON FILE wave_phasespace.dat'
                  write(6,*)'*** ARE READ FOR EACH SOURCE AND ALL VARIABLES MUST'
                  write(6,*)'*** MUST MATCH THE SOURCE, GOOD LUCK...'
                  write(6,*)'*** TYPICAL PROBLEMS: NUMBER OF STEPS IN SOURCES SEEMS TO BE EXCEEDED'
                  write(6,*)'*** OR END OF FILE FOR wave_phasespace.dat IS REACHED AND SO ON!'
                endif
                call bunch(tphase)
                bunchx=tphase*clight1 !long. position in bunch

                do ifreq=1,nfreq
                  phexp(ifreq)=cdexp(dcmplx(0.0d0,tphase*freq(ifreq)/hbarev1))
                enddo !ifreq

              else if (iubunch.eq.-2) then
                write(6,*)
     &            '*** Error in souintall: IUBUNCH=-2 is not supported anymore ***'
                write(6,*)'*** Program WAVE aborted ***'
                write(lungfo,*)
     &            '*** Error in souintall: IUBUNCH=-2 is not supported anymore ***'
                write(lungfo,*)'*** Program WAVE aborted ***'
                stop

              else if (iubunch.eq.-1) then

                call ubunch(xub,yub,zub,ypub,zpub,gammaub,tphase)
                bunchx=tphase*clight1 !long. position in bunch
                egamma=gammaub
                xelec=xub
                yelec=yub
                zelec=zub
                ypelec=ypub
                zpelec=zpub

                do ifreq=1,nfreq
                  schwingungen = bunchlen*1.0d9*clight1 /
     &              (freq(ifreq)/hbarev1) * tphase
                  schwingungen=mod(schwingungen,1.0d0)
                  phexp(ifreq)=cdexp(dcmplx(0.0d0,schwingungen*twopi1))
                enddo !ifreq

              else !if (iubunch.eq.0) then

                write(LUNGFO,*)
     &            '*** Error in SOUINTALL: Bad value of IUBUNCH (not -1,0,1,2,3,4)!  ***'
                write(6,*)
     &            '*** Error in SOUINTALL: Bad value of IUBUNCH (not -1,0,1,2,3,4)!  ***'
                stop '*** Program WAVE aborted ***'

              endif !iubunch

              if (iubunch.ne.3.and.iubunch.ne.-1) then

                xelec=SOURCEAO(1,1,ISOUR)
                yelec=SOURCEAO(2,1,ISOUR)
                zelec=SOURCEAO(3,1,ISOUR)

                vx1=SOURCEAO(1,2,ISOUR)
                vy1=SOURCEAO(2,2,ISOUR)
                vz1=SOURCEAO(3,2,ISOUR)

                ypelec=vy1/VX1
                zpelec=vz1/VX1
                egamma=sourceg(1,1,isour)

                xco=xelec
                yco=yelec
                zco=zelec
                ypco=ypelec
                zpco=zpelec
                egammaco=egamma

              endif !(iubunch.ne.3.and.iubunch.ne.1) then

              if (iubunch.ne.3.and.iubunch.ne.4.and.iubunch.ne.-1) then

                CALL RNORML(XRAN,5,rr)

                if (espread.gt.0.0d0.and.iefold.eq.0) then
                  dpp=espread*xran(1)
                  egamma=egamma*(1.0d0+dpp)
                endif

                if (iubunch.ne.1) then

                  if (ifold.eq.0) then
                    if (bsigy(isour).gt.0.0d0) then
                      yy=bsigy(isour)*xran(2)
                    else
                      yy=0.0d0
                    endif
                    if (bsigyp(isour).gt.0.0d0) then
                      yyp=bsigyp(isour)*xran(3)
                    else
                      yyp=0.0d0
                    endif
                    if (bsigz(isour).gt.0.0d0) then
                      zz=bsigz(isour)*xran(4)
                    else
                      zz=0.0d0
                    endif
                    if (bsigzp(isour).gt.0.0d0) then
                      zzp=bsigzp(isour)*xran(5)
                    else
                      zzp=0.0d0
                    endif

+self,if=-notfmi,if=wbetdeltae.
                    dum22=tfmhi+(tfmdehi-tfmhi)*(egamma-dmygamma)/(deltae*dmygamma)
                    zelec= dum22(1,1)*zz+dum22(1,2)*zzp
                    zpelec=dum22(2,1)*zz+dum22(2,2)*zzp
                    dum22=tfmvi+(tfmdevi-tfmvi)*(egamma-dmygamma)/(deltae*dmygamma)
                    yelec= dum22(1,1)*yy+dum22(1,2)*yyp
                    ypelec=dum22(2,1)*yy+dum22(2,2)*yyp
+self,if=-notfmi,if=-wbetdeltae.
                    zelec= tfmhi(1,1)*zz+tfmhi(1,2)*zzp
                    zpelec=tfmhi(2,1)*zz+tfmhi(2,2)*zzp
                    yelec= tfmvi(1,1)*yy+tfmvi(1,2)*yyp
                    ypelec=tfmvi(2,1)*yy+tfmvi(2,2)*yyp
+self,if=notfmi.
+self.
                  endif !ifold

c simple treatment of closed orbit, assume small angles
c bug 4.5.2018!?                  zelec=zz+zco
c                  zpelec=zzp+zpco
c                  yelec=yy+yco
c                  ypelec=yyp+ypco
c                  print*,"debug all:",ielec,zelec
                  zelec=zelec+zco
                  zpelec=zpelec+zpco
                  yelec=yelec+yco
                  ypelec=ypelec+ypco

                else !iubunch.ne.1

c phasespace ellipse: gammah*z**2+2*alphah*z*zp+betah*zp**2=eps0h

                  CALL RNORML(XRAN,5,rr)

c26.4.2024                  if (espread.gt.0.0d0.and.iefold.eq.0) then
c                    egamma=egamma*(1.0d0+espread*xran(1))
c                  endif

                  if (ifold.eq.0) then

                    ! assume beta(s)=beta0(s)+s**2/beta(0) and alpha0=-s/beta(0)
                    ! and a drift transfer-matrix ((1,s),(1,0))

                    alphah=-betaph/2.0d0
                    gammah=(1.0d0+alphah**2)/betah
                    beta0h=1.0d0/gammah
                    s0h=alphah/gammah

                    zz=sqrt(eps0h*beta0h)*xran(2)
                    zzp=-sqrt(eps0h/beta0h)*xran(3)
                    zelec=zz-s0h*zzp !inverse transformation
                    zpelec=zzp

                    alphav=-betapv/2.0d0
                    gammav=(1.0d0+alphav**2)/betav
                    beta0v=1.0d0/gammav
                    s0v=alphav/gammah

                    yy=sqrt(eps0v*beta0v)*xran(4)
                    yyp=-sqrt(eps0v/beta0v)*xran(5)
                    yelec=yy-s0v*yyp
                    ypelec=yyp

c simple treatment of closed orbit, assume small angles

                    xelec=sourceao(1,1,isour)
                    yelec=yelec+sourceao(2,1,isour)
                    zelec=zelec+sourceao(3,1,isour)
                    ypelec=ypelec+sourceao(2,2,isour)/sourceao(1,2,isour)
                    zpelec=zpelec+sourceao(3,2,isour)/sourceao(1,2,isour)

                  else !if (ifold.eq.0) then
                    write(6,*)
     &                '*** Error in souintall: IFOLD.ne.0.and.IUBUNCH.eq.1 are incompatible'
                    write(6,*)'*** Program WAVE aborted ***'
                    write(lungfo,*)
     &                '*** Error in souintall: IFOLD.ne.0.and.IUBUNCH.eq.1 are incompatible'
                    write(lungfo,*)'*** Program WAVE aborted ***'
                    stop
                  endif !(ifold.eq.0) then

                endif !(iubunch.ne.1) then

              endif !iubunch.ne.3.and.iubunch.ne.4.and.iubunch.ne.-1

              if (ielec.eq.1.and.ibunch.eq.-1) then
                egamma=egammafirst
                xelec=xfirst
                yelec=yfirst
                zelec=zfirst
                ypelec=ypfirst
                zpelec=zpfirst
              endif

              if (iwbunch.gt.0) then
                write(22,'(7e20.10)')egamma,bunchx,
     &            xelec,yelec,zelec,ypelec,zpelec
              endif

            endif !ibunch

            vn=clight1*dsqrt((1.0d0-1.0d0/egamma)*(1.0d0+1.0d0/egamma))

            zelec=zelec+dpp*disp0
            zpelec=zpelec+dpp*ddisp0

            vxelec=vn/sqrt(1.0d0+ypelec**2+zpelec**2)
            vyelec=vxelec*ypelec
            vzelec=vxelec*zpelec

            kobsv=nobsv

            call tracks(isour)

            if (mpinr.ne.0) then

              call souintrphi(isour,inside)

            else

              do iobsv=1,kobsv

                if (isour.eq.1.and.iobsv.eq.1.and.nobsv.eq.1.and.ielec.eq.1) then
                  write(6,*)' '
                  write(6,*)
     &              '      counting from 1 to 10 for first source to show progress:'
                  write(6,*)' '
                  write(6,*)' '
                endif

                if (iobsv.eq.1)  then
                  inside=1
                  if (jpin.eq.3) inside=-3
                  call souintana(isour,jobunch,inside)
                  inside=1
                else if (iobsv.eq.jobunch) then
                  call souintana(isour,1,inside)
                else
                  call souintana(isour,iobsv,inside)
                endif

                if (inside.eq.0) then
                  kinside=1
                  write(lungfo,*)
                  write(lungfo,*)
     &              '      found observation point outside radiation cone;'
                  write(lungfo,*)
     &              '      number of source, number and (X,Y,Z) of observation point:'
                  write(lungfo,*)
     &              '      ',isour,iobsv,sngl(obsv(1,iobsv)),
     &              sngl(obsv(2,iobsv)),sngl(obsv(3,iobsv))
                  write(lungfo,*)
                endif   !inside

              enddo !nobsv

            endif !mpinr

          enddo !isub=1,neinbunch
        enddo !ibun=1,nbunch

C CALCULATE DISTRIBUTION IN PINHOLE }

      ELSE !JPIN.NE.2

        if (mpinr.gt.0)
     &    stop '*** Error in SOUINTALL: MPINR NOT ALLOWED FOR IPIN.EQ.2'

      ENDIF !JPIN.NE.2

      IF (ISPECMODE.EQ.1.AND.ISOUR.EQ.NSOURCE) THEN
        DEALLOCATE(DWT)
        DEALLOCATE(DWX)
        DEALLOCATE(DWX2P)
        DEALLOCATE(DWB)
        DEALLOCATE(DWB2P)
        DEALLOCATE(DWY)
        DEALLOCATE(DWY2P)
        DEALLOCATE(DWZ)
        DEALLOCATE(DWZ2P)
      ENDIF

      IF (AMPRAN.NE.0.D0.AND.IAMPLI.LT.0) THEN
        DEALLOCATE(XRANA)
      ENDIF   !(AMPRAN.NE.0.D0)

      IF (ISOUR.EQ.NSOURCE.AND.KINSIDE.NE.0) THEN
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN SOUINTALL:'
        WRITE(6,*)'there are observation points outside radiation cone'
        WRITE(6,*)'maybe WGWINFC, WBL0CUT... or collimators not suitable'
        WRITE(6,*)'see output file WAVE.OUT for details'
        WRITE(6,*)
      ENDIF !KINSIDE

      IPIN=JPIN
      IFOLD=JFOLD
      IEFOLD=JEFOLD

      deallocate(phrnrn)
      deallocate(phexp)
      if (mpinr.ne.0) then
        deallocate(phaserphi);
        deallocate(expom1rphi);
        deallocate(afferphi)
        deallocate(unphrphi)
      else
        deallocate(affe)
      endif
      deallocate(ampz)
      deallocate(azcos)
      deallocate(azsin)

      if (ibunch.ne.0.and.isour.eq.nsource.and.ilintra.lt.0) then
        deallocate(wbeta)
        deallocate(wbetak)
      endif !ibunch.ne.0

      deallocate(ampzmax,kobs)

      RETURN
      END subroutine souintall
+DECK,SOUINTANA.
*CMZ :  4.01/07 11/05/2024  13.54.34  by  Michael Scheer
*CMZ :  4.01/05 21/04/2024  11.34.30  by  Michael Scheer
*CMZ :  4.01/04 15/11/2023  12.38.14  by  Michael Scheer
*CMZ :  4.01/03 02/06/2023  13.01.26  by  Michael Scheer
*CMZ :  4.01/02 14/05/2023  12.29.56  by  Michael Scheer
*CMZ :  4.00/17 15/11/2022  10.09.14  by  Michael Scheer
*CMZ :  4.00/15 11/04/2022  09.38.38  by  Michael Scheer
*CMZ :  4.00/14 22/12/2021  18.07.25  by  Michael Scheer
*CMZ :  4.00/13 07/11/2021  15.08.37  by  Michael Scheer
*CMZ :  4.00/07 29/04/2020  16.22.00  by  Michael Scheer
*CMZ :  4.00/04 25/11/2019  15.59.31  by  Michael Scheer
*CMZ :  3.08/01 03/04/2019  11.44.00  by  Michael Scheer
*CMZ :  3.06/00 27/02/2019  13.41.29  by  Michael Scheer
*CMZ :  3.05/06 17/07/2018  11.15.16  by  Michael Scheer
*CMZ :  3.05/04 27/06/2018  13.51.32  by  Michael Scheer
*CMZ :  3.05/03 22/05/2018  07.13.27  by  Michael Scheer
*CMZ :  3.05/02 14/05/2018  14.03.28  by  Michael Scheer
*CMZ :  3.03/03 11/07/2017  12.22.55  by  Michael Scheer
*CMZ :  3.03/02 22/03/2016  12.44.00  by  Michael Scheer
*CMZ :  3.02/06 12/06/2015  14.30.32  by  Michael Scheer
*CMZ :  3.02/05 10/04/2015  16.29.41  by  Michael Scheer
*CMZ :  3.02/04 22/01/2015  14.17.40  by  Michael Scheer
*CMZ :  3.02/03 06/11/2014  15.42.04  by  Michael Scheer
*CMZ :  3.02/00 10/09/2014  14.15.19  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/06 03/01/2013  10.16.23  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  14.04.56  by  Michael Scheer
*CMZ :  2.70/04 21/12/2012  12.27.29  by  Michael Scheer
*CMZ :  2.70/01 12/12/2012  15.52.08  by  Michael Scheer
*CMZ :  2.69/02 06/11/2012  19.26.50  by  Michael Scheer
*CMZ :  2.69/01 31/10/2012  16.59.26  by  Michael Scheer
*CMZ :  2.69/00 26/10/2012  14.09.11  by  Michael Scheer
*CMZ :  2.68/05 19/10/2012  14.08.39  by  Michael Scheer
*CMZ :  2.68/03 22/08/2012  12.57.49  by  Michael Scheer
*CMZ :  2.68/02 30/05/2012  09.18.41  by  Michael Scheer
*CMZ :  2.68/01 29/05/2012  16.26.31  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  12.54.41  by  Michael Scheer
*CMZ :  2.67/04 11/05/2012  11.18.26  by  Michael Scheer
*CMZ :  2.67/00 13/02/2012  10.58.17  by  Michael Scheer
*CMZ :  2.66/20 06/07/2011  10.04.15  by  Michael Scheer
*CMZ :  2.66/18 08/12/2010  09.41.12  by  Michael Scheer
*CMZ :  2.66/13 25/06/2010  15.12.53  by  Michael Scheer
*CMZ :  2.66/12 24/05/2010  06.45.59  by  Michael Scheer
*CMZ :  2.66/10 04/05/2010  10.01.49  by  Michael Scheer
*CMZ :  2.66/09 04/05/2010  10.01.19  by  Michael Scheer
*CMZ :  2.66/07 10/03/2010  09.23.32  by  Michael Scheer
*CMZ :  2.66/06 27/11/2009  16.13.00  by  Michael Scheer
*CMZ :  2.66/05 18/11/2009  10.22.04  by  Michael Scheer
*CMZ :  2.66/04 17/11/2009  10.09.32  by  Michael Scheer
*CMZ :  2.66/03 11/11/2009  16.56.29  by  Michael Scheer
*CMZ :  2.66/01 28/10/2009  15.52.52  by  Michael Scheer
*CMZ :  2.66/00 14/10/2009  11.40.12  by  Michael Scheer
*CMZ :  2.65/03 02/10/2009  14.50.50  by  Michael Scheer
*CMZ :  2.65/02 29/09/2009  09.25.19  by  Michael Scheer
*CMZ :  2.65/00 18/09/2009  08.33.28  by  Michael Scheer
*CMZ :  2.64/07 17/09/2009  15.35.15  by  Michael Scheer
*CMZ :  2.64/06 14/09/2009  15.19.42  by  Michael Scheer
*CMZ :  2.64/05 08/09/2009  13.24.51  by  Michael Scheer
*CMZ :  2.64/04 21/08/2009  17.39.13  by  Michael Scheer
*CMZ :  2.64/03 21/08/2009  17.32.56  by  Michael Scheer
*CMZ :  2.64/02 21/08/2009  17.25.00  by  Michael Scheer
*CMZ :  2.64/01 19/08/2009  09.03.30  by  Michael Scheer
*CMZ :  2.64/00 17/08/2009  08.23.14  by  Michael Scheer
*CMZ :  2.63/05 12/08/2009  16.16.13  by  Michael Scheer
*CMZ :  2.63/01 16/01/2008  13.13.26  by  Michael Scheer
*CMZ :  2.63/00 11/01/2008  16.35.30  by  Michael Scheer
*CMZ :  2.61/02 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.54/04 19/04/2005  08.39.39  by  Michael Scheer
*CMZ :  2.53/02 25/01/2005  12.24.49  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  13.27.56  by  Michael Scheer
*CMZ :  2.52/16 18/01/2005  19.11.04  by  Michael Scheer
*CMZ :  2.52/11 08/12/2004  13.38.02  by  Michael Scheer
*CMZ :  2.52/04 12/07/2004  09.05.41  by  Michael Scheer
*CMZ :  2.52/02 06/07/2004  12.52.18  by  Michael Scheer
*CMZ :  2.51/03 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.51/01 17/06/2004  15.54.40  by  Michael Scheer
*CMZ :  2.51/00 25/05/2004  16.11.36  by  Michael Scheer
*CMZ :  2.50/03 10/05/2004  14.35.07  by  Michael Scheer
*CMZ :  2.50/02 30/04/2004  14.42.38  by  Michael Scheer
*CMZ :  2.50/01 30/04/2004  10.51.02  by  Michael Scheer
*CMZ :  2.50/00 29/04/2004  18.32.51  by  Michael Scheer
*CMZ :  2.41/10 16/04/2004  09.24.47  by  Michael Scheer
*CMZ :  2.37/07 11/12/2001  16.39.59  by  Michael Scheer
*CMZ :  2.37/01 14/11/2001  10.46.31  by  Michael Scheer
*CMZ :  2.37/00 13/11/2001  17.04.47  by  Michael Scheer
*CMZ :  2.36/00 08/11/2001  13.57.12  by  Michael Scheer
*CMZ :  2.34/09 21/09/2001  11.57.57  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  11.10.08  by  Michael Scheer
*CMZ :  2.33/00 03/05/2001  11.31.36  by  Michael Scheer
*CMZ :  2.31/01 25/04/2001  10.54.42  by  Michael Scheer
*CMZ :  2.31/00 24/04/2001  15.51.02  by  Michael Scheer
*CMZ :  2.30/03 20/04/2001  12.19.22  by  Michael Scheer
*CMZ :  2.30/02 12/04/2001  19.10.52  by  Michael Scheer
*CMZ :  2.30/01 12/04/2001  18.17.23  by  Michael Scheer
*CMZ :  2.20/12 11/04/2001  17.02.34  by  Michael Scheer
*CMZ :  2.20/11 11/04/2001  16.11.52  by  Michael Scheer
*CMZ :  2.20/10 10/04/2001  11.26.41  by  Michael Scheer
*CMZ :  2.20/09 03/04/2001  14.23.18  by  Michael Scheer
*CMZ :  2.15/01 30/03/2001  20.02.21  by  Michael Scheer
*CMZ :  2.20/08 18/03/2001  20.48.35  by  Michael Scheer
*CMZ :  2.20/07 18/03/2001  17.08.58  by  Michael Scheer
*CMZ :  2.20/06 15/03/2001  17.20.08  by  Michael Scheer
*CMZ :  2.20/05 15/03/2001  16.57.30  by  Michael Scheer
*CMZ :  2.20/04 09/03/2001  16.47.40  by  Michael Scheer
*CMZ :  2.20/03 23/02/2001  15.04.13  by  Michael Scheer
*CMZ :  2.20/02 21/02/2001  11.30.46  by  Michael Scheer
*CMZ :  2.20/01 20/02/2001  14.18.37  by  Michael Scheer
*-- Author : Michael Scheer

      SUBROUTINE SOUINTANA(ISOUR,IOBSV,INSIDE)

+seq,gplhint.
+SEQ,TRACKF90U.
+SEQ,WORKF90U.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,AFREQF90U.
+SEQ,AMPLIF90U.
+SEQ,WFOLDF90U.

      use bunchmod
      use wbetaf90m
      use souintmod
      !use waveenv
      use clustermod

C--- EVALUATE INTEGRALES FOR A SINGLE SOURCE
C---- RESULTS ARE STORE IN AFREQ AND SPECPOW

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,PHYCON.
+SEQ,TRACK.
+seq,sourcef90.
+SEQ,COLLI.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,FREQS.
+SEQ,AMPLI.
+SEQ,B0SCGLOB.
+SEQ,PRIMKIN.
+SEq,wfoldf90.
+seq,ustep.
+SEQ,uservar.
+seq,tralin.
+seq,whbook.
+seq,pawcmn.
+seq,specdip.
+seq,datetime.
+seq,waveenv.

      REAL*8 FSPEC(31)

      double precision h2,ddist,dist0,dist02
     & ,vn,dgamma,fnor,sqnor

      COMPLEX*16 ZIOM,ZI,ZIDOM,ZONE,ZICR1,ZIC,daff(3),baff(3)
      COMPLEX*16 EXPOM1,EXPOM,DEXPOMPH1,DEXPOMPH,DDEXPOMPH,DEXPOM,EXPOMV2
      COMPLEX*16 APOL,APOLH,APOLR,APOLL,APOL45
     &  ,DMODU,DMODU0,DDMODU,AX,AY,AZ,AX0,AY0,AZ0,bx0,by0,bz0,bxc,byc,bzc

      DOUBLE PRECISION T0,T1,T2,TENDSOU,X0,X1,X2,X10,Y1,Y2,Z1,Z2,XENDSOU,R0
     &  ,T,DT,DT2,DT0,DTIM00,DTIM01,VXP,VYP,VZP,TENDSOU1
     &  ,R02
c     &  ,H2,H2R2
     &  ,PHI,FREQR,CORRR0,R00,R2,POW,powpow
     &  ,X2B,Y2B,Z2B
     &  ,DGAMSUM,BETA,GAMGAM,GAMGAM0,AMPDT,sqnphsp
     &  ,xn1,slopein,slope,drn1,drn2,zn1,yn1,wi,
     &  zz,yy,zzp,yyp,zzi,yyi,yypi,zzpi,
     &  yeleco,zeleco,zpeleco,ypeleco
      double precision, save :: soura(3,4),soure(3,4)

      DOUBLE PRECISION VX1,VY1,VZ1,BX1,BY1,BZ1
      DOUBLE PRECISION VX2,VY2,VZ2,BX2,BY2,BZ2,AX2D,AY2D,AZ2D
      DOUBLE PRECISION ECDUM,BS,BSQ,ECMAXS,BS1
      DOUBLE PRECISION TS,DPHASE,DPHSOUR(2,2)
      DOUBLE PRECISION C1,OM,DOM,GAMMA

      DOUBLE PRECISION BX,BY,BZ,RX,RY,RZ,PX,PY,PZ,RNBX,RNBY,RNBZ
      DOUBLE PRECISION R1,RNX,RNY,RNZ,DOM1,DOM2,BET1N,DUM11,R,BPX,BPY,BPZ
      DOUBLE PRECISION WGANG,OPANG

      DOUBLE PRECISION RARG(5),PHASE,C

      DOUBLE PRECISION DROIX,DTPHASE,DXEXI,CENXEXI,roi(nroip)
      DOUBLE PRECISION STOK1,STOK2,STOK3,STOK4,BET1NO,sqnbunch
      double precision br2,rnr2,br4,rnr4,b3
     &  ,are(6),aim(6),yp2zp2i,robsv,phiobsv,
     &  f(3),yp(3),ypp,a(3),fdt(3),filo,fihi,dfdt,xobsv,yobsv,zobsv,speck,
     &  tfmh(2,2),tfmv(2,2),tfm1(2,2),
     &  w22(2,2),dum22(2,2),
     &  tfmhi(2,2),tfmvi(2,2),
     &  tfmdehi(2,2),tfmdevi(2,2),
     &  tfmdeh(2,2),tfmdev(2,2),
     &  tfmhc(2,2),tfmvc(2,2),
     &  tfmdehc(2,2),tfmdevc(2,2),
     &  tfmhtoti(2,2),tfmvtoti(2,2),
     &  tfmdehtoti(2,2),tfmdevtoti(2,2)
+self,if=-tralinshort.
     &  ,rq,cpsi,alpha,spsi,rm,betafun,psi
+self.
     &  ,alpha0(2),beta0(2)
+self,if=blind.
     &  ,rest
+self.

      real*8 fillb(41)
      real rnrn(2)
      INTEGER IINSIDE,JINSIDE,INSIDE,iw2(2),ifail
      INTEGER ISOUR,isourold,IOBSV,kfreq,JFREQ,IZAEHL,NZAEHL,IX10,I,ICAL,ICOMP
+self,if=-windows.
      INTEGER*8
+self,if=windows.
      INTEGER
+self.
     &  NZAEHL10,MZAEHL,KZAEHL,iizaehl
      INTEGER ICSPL,IROI,II,IZTOTS,IWARNBET1N,LSTEP,IR1,IR2
      integer nelec,jobunch,job,jfrob,norad,iwarnwi,lun10
+self,if=blind.
     &  ,isec
+self.

      INTEGER NTUPP,IC,jpin
      PARAMETER (NTUPP=38)
      REAL*8 FILLT(NTUPP)
      CHARACTER(5) CTUP(NTUPP)

      DOUBLE PRECISION wth,wta,
     &                H6,H26,A2,A21H6,A3AH26,B,B2,B21H6,B3BH26,DT10
      integer icount,mode,klo,khi,k

      common/souintc/jpin

      data ctup /'t','x','y','z','rx','ry','rz','rt','p','expr','expi','roi'
     &  ,'iob','ie','yob','zob','bet1n','om','dt','by2','isou'
     &  ,'spec','reax','imax','reay','imay','reaz','imaz','dom1',
     &  'betx','bety','betz','betxp','betyp','betzp','nx','ny','nz'/

      DATA isourold/0/
      DATA ICAL/0/
      DATA tfm1(1,1),tfm1(1,2),tfm1(2,1),tfm1(2,2)/1.0d0,0.0d0,0.0d0,1.0d0/
      DATA ZI/(0.0D0,1.0D0)/
      DATA ZONE/(1.0D0,0.0D0)/
      DATA IWARNBET1N/0/

      save

      IF (ICAL.EQ.0) THEN

c        open(unit=111,file='fort.111',recl=512)

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'       SUBROUTINE SOUINTANA:'
        WRITE(LUNGFO,*)

        IF (NFREQ.GT.NDFREQ) THEN
          WRITE(LUNGFO,*)
     &      '*** ERROR IN SOUINTANA: NUMBER OF MAXIMUM PHOTON ENERGIES EXCEEDED'
          WRITE(LUNGFO,*)
     &      'INCREASE PARAMETER NDFREQP IN CMPARA.CMN'
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED  ***'
          WRITE(6,*)
     &      '*** ERROR IN SOUINTANA: NUMBER OF MAXIMUM PHOTON ENERGIES EXCEEDED'
          WRITE(6,*)
     &      'INCREASE PARAMETER NDFREQP IN CMPARA.CMN'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED  ***'
          STOP
        ENDIF    !(NFREQ.GT.NDFREQP)

        if (icluster.lt.0.and.ibunch.ne.0.and.iubunch.eq.3) then
          soura(1:3,1:4)=sourceaclu(1:3,1:4)
          soure(1:3,1:4)=sourceeclu(1:3,1:4)
        else
          soura(1:3,1:4)=sourceao(1:3,1:4,isour)
          soure(1:3,1:4)=sourceeo(1:3,1:4,isour)
        endif

        DO II=1,NSOURCE
          DO I=1,NROIA
            IWARNROI(I,II)=0
          ENDDO
        ENDDO

        C=CLIGHT1
        C1=1.D0/CLIGHT1

        DOM=(FREQ(2)-FREQ(1))/HBAREV1
c        DOM=0.0d0
        OM=FREQ(1)/HBAREV1
        ZIDOM=ZI*DOM
        ZIOM=ZI*OM
        ZIC=ZI*CLIGHT1

        IF (IWFILINT.LT.0) THEN
+self,if=-mhbook.
          CALL hbookm(NIDSOURCE,'RADIATION INTEGRALS$',NTUPP
     &      , '//WAVE',1024,CTUP)
+self,if=mhbook.
          CALL hbookm(NIDSOURCE,'RADIATION INTEGRALS',NTUPP
     &      , '//WAVE',nlpoi/jwfilint+2*jwfilint,CTUP)
+self.
        ENDIF !(IWFILINT.LT.0)

        jobunch=icbrill
        if (iobunch.ne.-9999) then
          jobunch=iobunch
        endif

        nphsp=nbunch
        nelec=neinbunch*nphsp

c Flux density is normalized to number of electrons per bunch or bunch charge
c and dmycurr. The field is normalized such, that flux dens = ABS(field)**2
        if (ibunch.ne.0.and.bunchcharge.ne.0.0d0) then
          sqnbunch=nbunch
          sqnphsp=sqrt(bunchcharge/echarge1)
     &      *neinbunch
     &      /(bunchcharge/echarge1)
          if (jpin.ne.3) then
            bunnor=1.0d0/nbunch
          else
            bunnor=1.0d0
          endif
        else
          sqnbunch=nbunch
          sqnphsp=sqrt(dble(neinbunch))
          bunnor=1.0d0/nbunch
        endif

        if (iobsv.ne.jobunch) then
          print*,'****************************************************'
          print*,
     &      '*** SEVERE ERROR IN SOUINTANA: IOBSV.NE.iobunch FOR FIRST CALL'
          print*,'*** Programm WAVE aborted ***'
          print*,'****************************************************'
          stop
        endif

      ENDIF !ICAL

      IF (ISPECMODE.EQ.1) THEN
        DTIM00=DTMCO
      ELSE
        DTIM00=DTIM0
      ENDIF

      DTIM01=1.D0/DTIM00

      ypeleco=vyelec/vxelec
      zpeleco=vzelec/vxelec
      zeleco=zelec
      yeleco=yelec

c Transfermatrices

      if (ibunch.ne.0.and.iampli.lt.0.and.isour.ne.isourold) then

        tfmh=tfm1
        tfmv=tfm1
        tfmhc=tfm1
        tfmvc=tfm1
        tfmhtoti=tfm1
        tfmvtoti=tfm1

        tfmdeh=tfm1
        tfmdev=tfm1
        tfmdehc=tfm1
        tfmdevc=tfm1
        tfmdehtoti=tfm1
        tfmdevtoti=tfm1

        x1=soura(1,1)
        y1=soura(2,1)
        z1=soura(3,1)

        x2=soure(1,1)

        alpha0(1)=-wbetasub(3,1)/2.d0
        alpha0(2)=-wbetasub(5,1)/2.d0
        beta0(1)=wbetasub(2,1)
        beta0(2)=wbetasub(4,1)

        if (alpha0(1).gt.0.001) then
          write(6,*)' '
          write(6,*)'*** Warning in SOUINTANA: Derivative of hori. beta function'
          write(6,*)'beginnning of the source is greater than 0.001!'
          write(6,*)' '
        endif

        if (alpha0(2).gt.0.001) then
          write(lungfo,*)' '
          write(lungfo,*)'*** Warning in SOUINTANA: Derivative of vert. beta function'
          write(lungfo,*)'in source center is greater than 0.001!'
          write(lungfo,*)'source center:',(x1+x2)/2.0d0
          write(lungfo,*)'beta, alpha:',beta0(2),alpha0(2)
          write(lungfo,*)'Maybe it is useful, to set IBL0CUT'
          write(lungfo,*)' '
          write(6,*)' '
          write(6,*)'*** Warning in SOUINTANA: Derivative of vert. beta function'
          write(6,*)'in source center is greater than 0.001!'
          write(6,*)'source center:',(x1+x2)/2.0d0
          write(6,*)'beta, alpha:',beta0(2),alpha0(2)
          write(6,*)'Maybe it is useful, to set IBL0CUT'
          write(6,*)' '
        endif

+self,if=-tralinshort.

        alpha=-wbetasub(3,3)/2.0d0
        betafun=  wbetasub(2,3)
        psi=   wbetasub(8,3)

        cpsi=cos(psi)
        spsi=sin(psi)
        rq=sqrt(betafun/beta0(1))
        rm=sqrt(betafun*beta0(1))

        tfmhc(1,1) = rq * (cpsi+alpha0(1)*spsi)
        tfmhc(1,2) = rm * spsi
        tfmhc(2,1)=
     &    ((alpha0(1)-alpha)*cpsi - (1.0d0+alpha0(1)*alpha)*spsi) / rm
        tfmhc(2,2)=
     &    (cpsi-alpha*spsi) / rq

        alpha=-wbetasub(5,3)/2.d0
        betafun=  wbetasub(4,3)
        psi=   wbetasub(9,3)

        cpsi=cos(psi)
        spsi=sin(psi)
        rq=sqrt(betafun/beta0(2))
        rm=sqrt(betafun*beta0(2))

        tfmvc(1,1) = rq * (cpsi+alpha0(2)*spsi)
        tfmvc(1,2) = rm * spsi
        tfmvc(2,1)=
     &    ((alpha0(2)-alpha)*cpsi - (1.0d0+alpha0(2)*alpha)*spsi) / rm
        tfmvc(2,2)=
     &    (cpsi-alpha*spsi) / rq

+self,if=tralinshort.
        call tralinshort(x1,y1,z1,0.0d0,0.0d0,(x1+x2)/2.0d0,dmygamma,
     &    tfmhc,tfmvc,tfmdehc,tfmdevc)
+self.

+self,if=-tralinshort.
        alpha=-wbetasub(3,3)/2.d0
        betafun=  wbetasub(2,3)
        psi=   wbetasub(8,3)

        cpsi=cos(psi)
        spsi=sin(psi)
        rq=sqrt(betafun/beta0(1))
        rm=sqrt(betafun*beta0(1))

        tfmh(1,1) = rq * (cpsi+alpha0(1)*spsi)
        tfmh(1,2) = rm * spsi
        tfmh(2,1)=
     &    ((alpha0(1)-alpha)*cpsi - (1.0d0+alpha0(1)*alpha)*spsi) / rm
        tfmh(2,2)=
     &    (cpsi-alpha*spsi) / rq

        alpha=-wbetasub(5,3)/2.d0
        betafun=  wbetasub(4,3)
        psi=   wbetasub(9,3)

        cpsi=cos(psi)
        spsi=sin(psi)
        rq=sqrt(betafun/beta0(2))
        rm=sqrt(betafun*beta0(2))

        tfmv(1,1) = rq * (cpsi+alpha0(2)*spsi)
        tfmv(1,2) = rm * spsi
        tfmv(2,1)=
     &    ((alpha0(2)-alpha)*cpsi - (1.0d0+alpha0(2)*alpha)*spsi) / rm
        tfmv(2,2)=
     &    (cpsi-alpha*spsi) / rq

+self,if=tralinshort.
        call tralinshort(x1,y1,z1,0.0d0,0.0d0,x2,dmygamma,
     &    tfmh,tfmv,tfmdeh,tfmdev)
+self.

        w22=tfmh

        dum22(1,1)=1.0d0
        dum22(1,2)=0.0d0
        dum22(2,1)=0.0d0
        dum22(2,2)=1.0d0

        call deqinv(2,w22,2,iw2,ifail,2,dum22)

        if (ifail.ne.0) then
          write(6,*)'*** Error in SOUINTANA: Matrix invertation failed'
          write(6,*)'Please check horizontal beta functions.'
          write(lungfo,*)'*** Error in SOUINTANA: Matrix invertation failed'
          write(lungfo,*)'Please check horizontal beta functions.'
          stop '*** Program WAVE aborted ***'
        endif

        tfmhi=w22

        w22=tfmv

        dum22(1,1)=1.0d0
        dum22(1,2)=0.0d0
        dum22(2,1)=0.0d0
        dum22(2,2)=1.0d0

        call deqinv(2,w22,2,iw2,ifail,2,dum22)

        if (ifail.ne.0) then
          write(6,*)'*** Error in SOUINTANA: Matrix invertation failed'
          write(6,*)'Please check vertical beta functions.'
          write(lungfo,*)'*** Error in SOUINTANA: Matrix invertation failed'
          write(lungfo,*)'Please check vertical beta functions.'
          stop '*** Program WAVE aborted ***'
        endif

        tfmvi=w22

        tfmdehi=tfmhi
        tfmdevi=tfmvi

+self,if=wbetdeltae.
        w22=tfmdeh

        dum22(1,1)=1.0d0
        dum22(1,2)=0.0d0
        dum22(2,1)=0.0d0
        dum22(2,2)=1.0d0

        call deqinv(2,w22,2,iw2,ifail,2,dum22)

        if (ifail.ne.0) then
          write(6,*)'*** Error in SOUINTANA: Matrix invertation failed'
          write(6,*)'Please check horizontal beta functions.'
          write(lungfo,*)'*** Error in SOUINTANA: Matrix invertation failed'
          write(lungfo,*)'Please check horizontal beta functions.'
          stop '*** Program WAVE aborted ***'
        endif

        tfmdehi=w22

        w22=tfmdev

        dum22(1,1)=1.0d0
        dum22(1,2)=0.0d0
        dum22(2,1)=0.0d0
        dum22(2,2)=1.0d0

        call deqinv(2,w22,2,iw2,ifail,2,dum22)

        if (ifail.ne.0) then
          write(6,*)'*** Error in SOUINTANA: Matrix invertation failed'
          write(6,*)'Please check vertical beta functions.'
          write(lungfo,*)'*** Error in SOUINTANA: Matrix invertation failed'
          write(lungfo,*)'Please check vertical beta functions.'
          stop '*** Program WAVE aborted ***'
        endif

        tfmdevi=w22
+self.

        tfmhtoti=tfmhi
        tfmvtoti=tfmvi

        if (iampli.lt.0) then
          do i=1,-iampli/2-1
            call util_matrix_multiplication(2,2,2,tfmhtoti,tfmhi,tfmhtoti,w22)
            call util_matrix_multiplication(2,2,2,tfmvtoti,tfmvi,tfmvtoti,w22)
+self,if=wbetdeltae.
            call util_matrix_multiplication(2,2,2,tfmdehtoti,tfmdehi,tfmdehtoti,w22)
            call util_matrix_multiplication(2,2,2,tfmdevtoti,tfmdevi,tfmdevtoti,w22)
+self.
          enddo
+self,if=-wbetdeltae.
          tfmdehtoti=tfmhtoti
          tfmdevtoti=tfmhtoti
+self.
        endif

      endif !isour

      if (jpin.eq.0.or.
c20.4.2024     &    (inside.ne.-3.or.ielec.eq.1).and.icluster.lt.0.and.iwinstance.eq.1
c20.4.2024     &    .or.
c20.4.2024     &    (inside.ne.-3.or.ielec.eq.1).and.icluster.ge.0) then
     &  (inside.ne.-3.or.ielec.eq.1)) then
        xobsv=obsv(1,iobsv)
        yobsv=obsv(2,iobsv)
        zobsv=obsv(3,iobsv)
      else
        xobsv=obsv(1,iobsv)
        call grndmm(rnrn,2)  !s. 39
        yobsv=pincen(2)-pinh/2.0d0+rnrn(1)*pinh
        zobsv=pincen(3)-pinw/2.0d0+rnrn(2)*pinw
        if (ipincirc.ne.0) then
          yobsv=1.0d30
          zobsv=1.0d30
          do while (sqrt(yobsv**2+zobsv**2).gt.pinr)
            call grndmm(rnrn,2)  !s. 39
            yobsv=(rnrn(1)-0.5)*2.0d0*pinr
            zobsv=(rnrn(2)-0.5)*2.0d0*pinr
          enddo
          yobsv=pincen(2)+yobsv
          zobsv=pincen(3)+zobsv
        endif
      endif

c      if (jpin.ne.3.and.jpin.ne.0) then
c        if (mpiny.eq.1) yobsv=pincen(2)
c        if (mpinz.eq.1) zobsv=pincen(3)
c      endif

      IF (jpin.ne.3.and.ielec.eq.1.and.IOBSV.EQ.jobunch
     &    .or.jpin.eq.3.and.ielec.eq.1) THEN

        WRITE(LUNGFO,*)'            SOURCE NUMBER',ISOUR,':'
        WRITE(LUNGFO,*)

        do kfreq=1,nfreq
          ampzmax(kfreq)=0.0d0
          azcos(kfreq)=1.0d0
          azsin(kfreq)=0.0d0
        enddo

        X1=xelec

        IF (ISPECMODE.EQ.1) THEN
          XENDSOU=DWX(MCO)    !FINAL X
        ELSE
          XENDSOU=soure(1,1)    !FINAL X
        ENDIF

        IF (NROI.LT.0) THEN
          DROIX=(XENDSOU-X1)/(NROIA-1)
          DO IROI=1,NROIA
            ROIX(IROI)=X1+(IROI-1)*DROIX
            ROIP(IROI)=1.0D0
          ENDDO
        ENDIF   !(NROI.LT.0)

        ROIX(1)=ROIX(1)-1.0D-6
        ROIX(NROIA)=ROIX(NROIA)+1.0D-6

        DO IROI=1,NROIA
          IPOIROI(IROI)=0
          if (ical.eq.0) then
            roi(iroi)=roix(iroi)
          endif
        ENDDO

      ENDIF !IF (ielec.eq.1.and.IOBSV.EQ.jobunch) THEN

      ILIOB=ISOUR+NSOURCE*(IOBSV-1)
c?6.11.      if (jpin.ne.3.or.jpin.eq.3.and.ielec.eq.1) SPECPOW(ILIOB)=0.0D0

      LSTEP=0
      DGAMSUM=0.0D0

      gamma=egamma
      beta=dsqrt((1.d0-1.d0/gamma)*(1.d0+1.d0/gamma))

      WGANG=WGWINFC/GAMMA

      ICSPL=0

      if (inside.ne.-3) then
        INSIDE=1
        iinside=-1
      endif

      IINSIDE=0
      JINSIDE=0

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS     T=-R0*C1
      T=0.0D0 !WICHTIG HIER WEGEN TENDSOU-T WEITER UNTEN

c11.5.2024      R0=XOBSV-soura(1,1)
      R0=OBSV(1,icbrill)-soura(1,1)

      IF (ISPECMODE.EQ.1) THEN
        T0=DWT(1)
        T1=T0
        T2=DWT(MCO)
        XENDSOU=DWX(MCO)    !FINAL X
      ELSE
        T0=SOURCET(1,ISOUR)
        T1=T0
        T2=SOURCET(2,ISOUR)
        XENDSOU=soure(1,1)    !FINAL X
      ENDIF

      TENDSOU=T2-T1

      IF (X1.LT.ROIX(1).OR.XENDSOU.GT.ROIX(NROIA)) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN SOUINTANA: X OUTSIDE ROIS ***'
        WRITE(LUNGFO,*)'CHECK NAMELIST $ROIN'
        WRITE(LUNGFO,*)' *** PROGRAM WAVE ABORTED ***'
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN SOUINTANA: X OUTSIDE ROIS ***'
        WRITE(6,*)'CHECK NAMELIST $ROIN'
        WRITE(6,*)' *** PROGRAM WAVE ABORTED ***'
        STOP
      ENDIF   !IROI

      X1=xelec
      Y1=yelec
      Z1=zelec

      VX1=vxelec
      VY1=vyelec
      VZ1=vzelec

      BX1=soura(1,4)
      BY1=soura(2,4)
      BZ1=soura(3,4)
      BS1=SQRT(BX1**2+BY1**2+BZ1**2)

      IZTOTS=0

      X0=X1
      X2=X1
      X10=(XENDSOU-X0)/10.1D0

      NZAEHL=NLPOIO
      DT0=TENDSOU/NZAEHL

      DT=DT0

      if (ielec.eq.1) then

        KZAEHL=0

        IR1=-1
        DO IROI=1,NROIA
          IF (ROI(IROI).GT.X1.AND.ROI(IROI).LT.XENDSOU.AND.IR1.EQ.-1) THEN
            IR1=IROI
            GOTO 11
          ENDIF
        ENDDO

11      DO IROI=1,NROIA
          IR2=IROI
          IF (ROI(IROI).GT.XENDSOU) THEN
            ROI(IROI)=XENDSOU
            IR2=IR2-1
            IF (ROI(IR2).LT.X1) THEN
              ROI(IR2)=X1
            ENDIF
            GOTO 12
          ENDIF
        ENDDO

12      CONTINUE

        KZAEHL=KZAEHL+NZAEHL*ROIP(IR2)*(XENDSOU-ROI(IR2))/(XENDSOU-X1)

        IF (IR1.NE.-1) THEN

          KZAEHL=KZAEHL+NZAEHL*ROIP(IR1-1)*(ROI(IR1)-X1)/(XENDSOU-X1)

          DO IROI=IR1,IR2-1
            IF (ROI(IROI).GT.X1.OR.ROI(IROI)+1.LT.XENDSOU) THEN
              KZAEHL=KZAEHL+NZAEHL*ROIP(IROI)*(ROI(IROI+1)-ROI(IROI))/(XENDSOU-X1)
            ELSE IF (ROI(IROI).GT.X1.OR.ROI(IROI)+1.LT.XENDSOU) THEN
              KZAEHL=KZAEHL+NZAEHL*ROIP(IROI)*(ROI(IROI+1)-ROI(IROI))/(XENDSOU-X1)
            ENDIF
          ENDDO

        ENDIF

      endif !ibun.eq.nphsp

      X2=X1
      Y2=Y1
      Z2=Z1

      VX2=VX1
      VY2=VY1
      VZ2=VZ1

      BX2=BX1
      BY2=BY1
      BZ2=BZ1
      BS=BS1

C--- LOOP OVER STEPS

      IROI=1
      DO I=1,NROIA
        IF (X1.GE.ROIX(I)) THEN
          IROI=I
        ENDIF !(X1.GE.ROIX(I))
      ENDDO   !IROI

      DT=DT0/ROIP(IROI)

      NZAEHL=MAX(5,NINT((TENDSOU-T)/DT))
      DT=(TENDSOU-T)/NZAEHL

      TENDSOU1=TENDSOU-DT
      DT2=DT/2.D0

C- CHECK STEPS SIZE

      IF (IWARNROI(IROI,ISOUR).EQ.0) THEN
        IF (DT-DTIM00.ge.dtim00*0.001) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '*** WARNING IN SOUINTANA, SOURCE, ROI:',ISOUR,IROI
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
          WRITE(LUNGFO,*)'SIZE FOR TRAJECTORY!'
          WRITE(LUNGFO,*)
          write(lungfo,*)'Step size for source point:',dt*clight1
          write(lungfo,*)'Step size for trajectory:',dtim00*clight1
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
          WRITE(6,*)
          WRITE(6,*)
     &      '*** WARNING IN SOUINTANA, SOURCE, ROI:',ISOUR,IROI
          WRITE(6,*)
          WRITE(6,*)'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
          WRITE(6,*)'SIZE FOR TRAJECTORY!'
          WRITE(6,*)
          write(6,*)'Step size for source point:',dt*clight1
          write(6,*)'Step size for trajectory:',dtim00*clight1
          WRITE(6,*)
          WRITE(6,*)
     &      'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
          WRITE(6,*)
          IWARNROI(IROI,ISOUR)=1
        ENDIF !DT
      ENDIF !IWARNROI

      IROI=IROI+1

      IZAEHL=0 !LOOP COUNTER for each track

      nutrack=ielec
      nustep=izaehl

      if (jpin.ne.3.and.ielec.eq.1.and.iobsv.eq.jobunch
     &    .or.jpin.eq.3.and.ielec.eq.1) then
        iizaehl=0 !total number of steps in souintana
        NZAEHL10=KZAEHL*nelec*nobsv/10
        MZAEHL=NZAEHL10
c        mzaehl=0
        IX10=1
      endif

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS     T=-R0*C1

      T=-DT
      TS=-DT

c11.5.2024      r=sqrt((xobsv-x1)**2+((yobsv-y1)**2+(zobsv-z1)**2))

      h2=((yobsv-y1)**2+(zobsv-z1)**2)/(xobsv-x1)**2
      if (h2.lt.0.01) then
        r=abs(xobsv-x1)*(1.0d0+(((((-0.0205078125D0*h2+0.02734375D0)*h2
     &    -0.0390625D0)*h2+0.0625D0)*h2-0.125D0)*h2+0.5D0)*h2)
      else
        r=sqrt((xobsv-x1)**2+((yobsv-y1)**2+(zobsv-z1)**2))
      endif

      PHASE=(r-r0)*c1 ! needed for phase of field amplitude

      EXPOM1=ZONE
      DEXPOMPH1=ZONE

      IF (ifreq2p.EQ.0) THEN
        DO JFREQ=1,NFREQ
          EXPOM2P0(1,JFREQ)=ZONE
        ENDDO
      ENDIF

      yp2zp2i=0.0D0
      f=0.0d0

      powpow=0.0d0

1000  IZAEHL=IZAEHL+1

      nustep=izaehl
      IIZAEHL=IIZAEHL+1 !total step counter

      IF (ISOUR.eq.1.and.IIZAEHL.GE.MZAEHL.and.ix10.lt.11
     &    ) THEN
        CALL date_and_time(dtday,dttime,dtzone,idatetime)
        WRITE(6,*)' ',IX10,' ',dttime(1:2),':',dttime(3:4),':',dttime(5:6)
        if (icluster.lt.0) then
          open(newunit=lun10,file="wave.n10")
          WRITE(lun10,'(a)')dttime(1:2)//':'//dttime(3:4)//':'//dttime(5:6)
          write(lun10,*)ix10
          flush(lun10)
          close(lun10)
        endif
        IX10=IX10+1
        MZAEHL=MZAEHL+NZAEHL10
      ENDIF

      IF (IROI.LE.NROIA) THEN

        IF (X2.GE.ROIX(IROI)) THEN

          DT=DT0/ROIP(IROI)
          NZAEHL=NINT((TENDSOU-T)/DT)

          IF (ISPECMODE.EQ.1) THEN
            DT=(TENDSOU-T)/(NZAEHL-1)
          ELSE
            DT=(TENDSOU-T)/NZAEHL
          ENDIF

          TENDSOU1=TENDSOU-DT

          DT2=DT/2.D0

          IF (IWARNROI(IROI,ISOUR).EQ.0) THEN

            IF (DT-DTIM00.ge.dtim00*0.001) THEN

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          '*** WARNING IN SOUINTANA, SOURCE, ROI:',ISOUR,IROI
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
              WRITE(LUNGFO,*)'SIZE FOR TRAJECTORY!'
              WRITE(LUNGFO,*)
              write(lungfo,*)'Step size for source point:',dt*clight1
              write(lungfo,*)'Step size for trajectory:',dtim00*clight1
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
              WRITE(6,*)
              WRITE(6,*)
     &          '*** WARNING IN SOUINTANA, SOURCE, ROI:',ISOUR,IROI
              WRITE(6,*)
              WRITE(6,*)'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
              WRITE(6,*)'SIZE FOR TRAJECTORY!'
              WRITE(6,*)
              write(6,*)'Step size for source point:',dt*clight1
              write(6,*)'Step size for trajectory:',dtim00*clight1
              WRITE(6,*)
              WRITE(6,*)
     &          'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
              WRITE(6,*)

              IWARNROI(IROI,ISOUR)=1

            ENDIF !DT

          ENDIF !IWARNROI

          IROI=IROI+1

        ENDIF   !X2

      ENDIF   !IROI

      if (ibun.eq.1.and.isub.eq.1) IPOIROI(IROI)=IPOIROI(IROI)+1

      T=T+DT

      IF (LSTEP.EQ.1) THEN

        IF (X2.LE.XENDSOU) THEN

          DT=(MIN(XENDSOU,XIEND)-X2)/VX2
          DT2=DT/2.0D0

        ELSE

          TS=TS-DT
          T=T-DT

          DT=(MIN(XENDSOU,XIEND)-X1)/VX2
          DT2=DT/2.0D0

          X2=X1
          Y2=Y1
          Z2=Z1

          VX2=VX1
          VY2=VY1
          VZ2=VZ1

          BX2=BX1
          BY2=BY1
          BZ2=BZ1
          BS=BS1

        ENDIF !X2

      ENDIF !LSTEP

      X1=X2
      Y1=Y2
      Z1=Z2

      VX1=VX2
      VY1=VY2
      VZ1=VZ2

      BX1=BX2
      BY1=BY2
      BZ1=BZ2
      BS1=BS

      IF (ISPECMODE.NE.1) THEN

C GET MAGNETIC FIELD {

        X2B=X1+VX1*DT2
        Y2B=Y1+VY1*DT2
        Z2B=Z1+VZ1*DT2
        norad=0
        if (ibmasksp.ne.0) then
          ibmasksp=-abs(ibmasksp)
          call mybfeld(x2b,y2b,z2b,bx2,by2,bz2,ax2d,ay2d,az2d)
          if ((bx2**2+by2**2+bz2**2).ne.0.0d0) then
            norad=1
          endif
          ibmasksp=-ibmasksp
        endif

        X2=WSOU(1,1,IZAEHL)
        Y2=WSOU(2,1,IZAEHL)
        Z2=WSOU(3,1,IZAEHL)

        VX2=WSOU(1,2,IZAEHL)
        VY2=WSOU(2,2,IZAEHL)
        VZ2=WSOU(3,2,IZAEHL)

        VXP=WSOU(1,3,IZAEHL)
        VYP=WSOU(2,3,IZAEHL)
        VZP=WSOU(3,3,IZAEHL)

        DT=   WSOU(1,4,IZAEHL)
        BETA= wsou(2,4,IZAEHL)
        GAMMA=wsou(3,4,IZAEHL)

        BX2=WSOU(1,5,IZAEHL)
        BY2=WSOU(2,5,IZAEHL)
        BZ2=WSOU(3,5,IZAEHL)

        BX=VX2*C1
        BY=VY2*C1
        BZ=VZ2*C1

        BPX=VXP*C1
        BPY=VYP*C1
        BPZ=VZP*C1

C MOVE ONE STEP }

      ELSE  !ISPECMODE

c{wave_track_inter, inline

c        CALL WAVE_TRACK_INTER(TS,X2,Y2,Z2,VX2,VY2,VZ2,VXP,VYP,VZP,BS,ICSPL,
c     &    GAMMA)

        IF (ICOUNT.EQ.0) THEN
          MODE=0
          DT=(DWT(2)-DWT(1))
          DT10=DT*1.D-10
          DO I=2,MCO
         IF (ABS(DWT(I)-DWT(I-1)-DT).GT.DT10) THEN
           MODE=1
           GOTO 19
                ENDIF
          ENDDO
19        KLO=1
          KHI=MCO
          ICOUNT=1
        ENDIF

      IF (MODE.EQ.1) THEN

        IF (KLO.GE.MCO.OR.KLO.LT.1.OR.KHI.GT.MCO.OR.KHI.LT.2) THEN
          KLO=1
          KHI=MCO
        ENDIF

          IF (T.GE.DWT(KLO).AND.T.LT.DWT(KLO+1)) THEN
            KHI=KLO+1
            GOTO 2
          ELSE IF (T.LT.DWT(KLO).OR.T.GE.DWT(KHI)) THEN
            KLO=1
            KHI=MCO
          ENDIF

          K=1
111       K=K*2
          KHI=KLO+K
          IF (KHI.GE.MCO) GOTO 122
          IF (T.GT.DWT(KHI)) THEN
            KLO=KHI
            GOTO 111
          ELSE
            GOTO 1
          ENDIF

122       KHI=MCO

1         IF (KHI-KLO.GT.1) THEN
            K=(KHI+KLO)/2
            IF(DWT(K).GT.T)THEN
              KHI=K
            ELSE
              KLO=K
            ENDIF
            GOTO 1
          ENDIF

        ELSE !MODE

          IF (T.GE.DWT(1).AND.T.LT.DWT(MCO)) THEN
            KLO=T/DT+1
            KHI=KLO+1
            IF (KHI.GT.MCO) THEN
              KHI=MCO
              KLO=KHI-1
            ENDIF
          ELSE IF (T.LT.DWT(1)) THEN
            KLO=1
            KHI=2
          ELSE IF (T.GE.DWT(MCO)) THEN
            KLO=MCO-1
            KHI=MCO
          ENDIF

        ENDIF !MODE

2       wtH=DWT(KHI)-DWT(KLO)

        IF (wtH.EQ.0.) THEN
          WRITE(6,*) '*** ERROR IN WAVE_TRACK_INTER: BAD INPUT ***'
          STOP
        ENDIF

        H6=wtH/6.D0
        H26=H6*wtH
        wta=(DWT(KHI)-T)/wtH
        A2=wta*wta
        A3AH26=(A2-1.D0)*wta*H26
        A21H6=(-3.D0*A2+1.D0)*H6
        B=(T-DWT(KLO))/wtH
        B2=B*B
        B21H6=(3.D0*B2-1.D0)*H6
        B3BH26=(B2-1.D0)*B*H26

        X2=wta*DWX(KLO)+B*DWX(KHI)+A3AH26*DWX2P(KLO)+B3BH26*DWX2P(KHI)
        VX2=(-DWX(KLO)+DWX(KHI))/wtH+A21H6*DWX2P(KLO)+B21H6*DWX2P(KHI)
        VXP=wta*DWX2P(KLO)+B*DWX2P(KHI)

        Y2=wta*DWY(KLO)+B*DWY(KHI)+A3AH26*DWY2P(KLO)+B3BH26*DWY2P(KHI)
        VY2=(-DWY(KLO)+DWY(KHI))/wtH+A21H6*DWY2P(KLO)+B21H6*DWY2P(KHI)
        VYP=wta*DWY2P(KLO)+B*DWY2P(KHI)

        Z2=wta*DWZ(KLO)+B*DWZ(KHI)+A3AH26*DWZ2P(KLO)+B3BH26*DWZ2P(KHI)
        VZ2=(-DWZ(KLO)+DWZ(KHI))/wtH+A21H6*DWZ2P(KLO)+B21H6*DWZ2P(KHI)
        VZP=wta*DWZ2P(KLO)+B*DWZ2P(KHI)

        BS=wta*DWB(KLO)+B*DWB(KHI)+A3AH26*DWB2P(KLO)+B3BH26*DWB2P(KHI)

        GAMMA=(TRAGAM(KLO)+TRAGAM(KHI))/2.0D0

c}wave_track_inter, inline
        norad=0
        if (ibmasksp.ne.0) then
          ibmasksp=-abs(ibmasksp)
          call mybfeld(x2b,y2b,z2b,bx2,by2,bz2,ax2d,ay2d,az2d)
          if ((bx2**2+by2**2+bz2**2).ne.0.0d0) then
            norad=1
          endif
          ibmasksp=-ibmasksp
        endif

        IF (IENELOSS.NE.0) THEN
          BETA=DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))
        ENDIF

        BSQ=BS*BS
        BY2=BSQ

        BX=VX2*C1
        BY=VY2*C1
        BZ=VZ2*C1
        BPX=VXP*C1
        BPY=VYP*C1
        BPZ=VZP*C1

      ENDIF !ISPECMODE

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION {

C REAL PART OF INTEGRAND {

      RX=XOBSV-X2
      RY=YOBSV-Y2
      RZ=ZOBSV-Z2

      R=SQRT(RX*RX+RY*RY+RZ*RZ)
      R1=1.D0/R
      ZICR1=ZIC*R1

      RNX=RX*R1
      RNY=RY*R1
      RNZ=RZ*R1

C--- THE DISTANCE R IS INTRODUCED HERE EXPLICITLY (S. PROGRAM OF CHAOEN WANG

      BET1N=(1.D0-BX*RNX)-BY*RNY-BZ*RNZ

c 20090928{
      br2=by**2+bz**2
      rnr2=rny**2+rnz**2
      b3=beta**3
      br4=br2**2
      rnr4=rnr2**2

      if(br2.lt.1.0d-4.and.rnr2.lt.1.0d-4) then
        bet1n=
     &    1.0d0/(1.0d0+beta)/gamma**2
     &    +beta*(rnr2/2.0d0
     &    +rnr4/8.0d0)
     &    +(br2/2.0d0
     &    -br2*rnr2/4.0d0
     &    -br2*rnr4/16.0d0)/beta
     &    +b3*br4*(1.0d0/8.0d0
     &    -rnr2/16.0d0
     &    -rnr4/64.0d0)
     &    -by*rny
     &    -bz*rnz
      endif
c }20090928

      OPANG=BX/BETA*RNX+BY/BETA*RNY+BZ/BETA*RNZ

      IF (ABS(OPANG).LE.1.0D0) THEN
        OPANG=ACOS(OPANG)
      ELSE IF (OPANG.GT.1.0D0) THEN
        OPANG=0.0D0
      ELSE
        OPANG=-PI1
      ENDIF

      DUM11=1.D0/BET1N
      DOM1=1.D0/(R*BET1N*BET1N)

      IF (IZAEHL.EQ.1) THEN
        BET1NO=BET1N
      ELSE IF (iundulator.eq.0
     &    .and.(BET1N-BET1NO)/BET1N.GT.0.05.AND.IWARNBET1N.EQ.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN SOUINTANA  ***'
        WRITE(LUNGFO,*)'DISCONTINUITY IN INTEGRAND'
        WRITE(LUNGFO,*)
     &    'Check results carefully, change BMOVECUT, MYINUM, NLPOI etc.'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'ISTEP,X,BET1N,BET1NO:',IZAEHL,SNGL(X1),SNGL(BET1N),SNGL(BET1NO)
        WRITE(LUNGFO,*)'FURTHER WARNINGS ARE SUPPRESSED!'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN SOUINTANA  ***'
        WRITE(6,*)'DISCONTINUITY IN INTEGRAND'
        WRITE(6,*)
     &    'Check results carefully, change BMOVECUT, MYINUM, NLPOI etc.'
        WRITE(6,*)
        WRITE(6,*)'ISTEP,X,BET1N,BET1NO:',IZAEHL,SNGL(X1),SNGL(BET1N),SNGL(BET1NO)
        WRITE(6,*)
        WRITE(6,*)'FURTHER WARNINGS ARE SUPPRESSED!'
        WRITE(6,*)
        IWARNBET1N=1
      ENDIF

      BET1NO=BET1N

      RNBX=RNX-BX
      RNBY=RNY-BY
      RNBZ=RNZ-BZ

      PX=(RNBY*BPZ-RNBZ*BPY)
      PY=(RNBZ*BPX-RNBX*BPZ)
      PZ=(RNBX*BPY-RNBY*BPX)

      IF (IVELOFIELD.EQ.0) THEN !2 WEGEN POWER
        DOM2=C*DOM1*R1/GAMMA**2
        RARG(1)=(RNY*PZ-RNZ*PY)*DOM1+(RNX-BX)*DOM2
        RARG(2)=(RNZ*PX-RNX*PZ)*DOM1+(RNY-BY)*DOM2
        RARG(3)=(RNX*PY-RNY*PX)*DOM1+(RNZ-BZ)*DOM2
      ELSE IF (IVELOFIELD.EQ.1) THEN
        RARG(1)=(RNY*PZ-RNZ*PY)*DOM1
        RARG(2)=(RNZ*PX-RNX*PZ)*DOM1
        RARG(3)=(RNX*PY-RNY*PX)*DOM1
      ELSE IF (IVELOFIELD.LT.0) THEN
        DOM2=C*DOM1*R1/GAMMA**2
        RARG(1)=(RNX-BX)*DOM2
        RARG(2)=(RNY-BY)*DOM2
        RARG(3)=(RNZ-BZ)*DOM2
      ELSE  !IVELOFIELD
        WRITE(6,*)
     &    '*** ERROR IN SOUINTANA: BAD VALUE OF IVELOFIELD  ***'
        WRITE(6,*) '*** PROGRAM WAVE ABORTED  ***'
        STOP
      ENDIF !IVELOFIELD

      IF (IINSIDE.EQ.0.AND.OPANG.LE.WGANG) THEN
        if (ibun.eq.1.and.isub.eq.neinbunch) then
          DPHSOUR(1,1)=BET1N*DT*FREQ(1)/HBAREV1
          DPHSOUR(1,2)=BET1N*DT*FREQ(NFREQ)/HBAREV1
        endif
        IINSIDE=1
        INSIDE=1
        JINSIDE=JINSIDE+1
        IF (JINSIDE.GT.1.and.ielec.eq.1) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN SOUINTANA  ***'
          WRITE(LUNGFO,*)'*** SOURCE:',ISOUR
          WRITE(LUNGFO,*)'STRANGE SOURCE, CONTAINS SEVERAL SOURCES'
          WRITE(LUNGFO,*)'SOURCE AND OBSERVATION POINT:'
          WRITE(LUNGFO,*)ISOUR,XOBSV,YOBSV,ZOBSV
          WRITE(LUNGFO,*)
     &      'RESULTS OF SPECTRUM CALCULATIONS MAY BE UNRELIABLE'
          WRITE(LUNGFO,*)'*** CHECK COLLIMATOR, PINHOLE, WGWINFC ... ***'
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN SOUINTANA  ***'
          WRITE(6,*)'*** SOURCE:',ISOUR
          WRITE(6,*)'*** STRANGE SOURCE, CONTAINS SEVERAL SOURCES'
          WRITE(6,*)'SOURCE AND OBSERVATION POINT:'
          WRITE(6,*)ISOUR,XOBSV,YOBSV,ZOBSV
          WRITE(6,*)'*** CHECK COLLIMATOR, PINHOLE, WGWINFC ... ***'
          WRITE(6,*)'WARNING OF SPECTRUM CALCULATIONS ARE UNRELIABLE'
          JINSIDE=JINSIDE-1   !SUPRESS LOTS OF WARNINGS
        ENDIF  !JINSIDE
      ELSE IF (IINSIDE.EQ.1.AND.OPANG.GT.WGANG) THEN
        IINSIDE=0
      ENDIF   !IINSIDE

      IF (IINSIDE.NE.0) THEN

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS      RARG(4)=T+R*C1

        DPHASE=BET1N*DT

        RARG(4)=PHASE
        RARG(5)=(RARG(1)*RARG(1)+RARG(2)*RARG(2)+RARG(3)*RARG(3))*DUM11/
     &    (nphsp*neinbunch)

        if (norad.ne.0) rarg=0.0d0

C REAL PART OF INTEGRAND }

C COMPLEX PART OF INTEGRAND {

C    ASSUMES FREQ(I+1)=2*FREQ(I)   FOR ifreq2p=2
C    OR FREQ(I+1)=FREQ(I)+DELTA    FOR ifreq2p>2

C--- LOOP OVER ALL FREQUENCES

        kfreq=1

        if (nelec.gt.1) then
          dexpbunch=phexp(kfreq)
        else
          dexpbunch=(1.0d0,0.0d0)
        endif

        IFROB=kfreq+NFREQ*(IOBSV-1)

        OM=FREQ(kfreq)/HBAREV1
        ZIOM=ZI*OM

        if (izaehl.eq.1) then
          EXPOM1=CDEXP(DCMPLX(0.D0,phase*OM))
        endif

        EXPOM=EXPOM1
        DEXPOMPH1=EXP(ZIOM*DPHASE)
        DEXPOMPH=DEXPOMPH1

        IF(ifreq2p.GT.2) THEN
          DEXPOM=EXP(ZIDOM*PHASE)
          DDEXPOMPH=EXP(ZIDOM*DPHASE)
        ELSE IF(ifreq2p.EQ.0) THEN
          EXPOM2P0(2,kfreq)=EXP(ZIOM*DPHASE)
          EXPOM=EXPOM2P0(1,kfreq)
        ENDIF  !ifreq2p

        IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN

          pow=rarg(5)*dt
          powpow=powpow+pow
          SPECPOW(ILIOB)=SPECPOW(ILIOB)+pow

          DO ICOMP=1,3
            daff(icomp)=
     &        RARG(ICOMP)/BET1N/OM*EXPOM*(ZONE-DEXPOMPH)*DEXPbunch/sqnphsp
            affe(icomp,ifrob)=affe(icomp,ifrob)+daff(icomp)
          ENDDO   !ICOMP

c          baff(1)=conjg(rny*daff(3)-rnz*daff(2))
c          baff(2)=conjg(rnz*daff(1)-rnx*daff(3))
c          baff(3)=conjg(rnx*daff(2)-rny*daff(1))

          baff(1)=(rny*daff(3)-rnz*daff(2))
          baff(2)=(rnz*daff(1)-rnx*daff(3))
          baff(3)=(rnx*daff(2)-rny*daff(1))

          affe(4:6,ifrob)=affe(4:6,ifrob)+baff(1:3)/clight1

        ENDIF  !XIANF

        IF (ibun.eq.1.and.isub.eq.neinbunch) THEN
          IF (IWFILINT.NE.0) THEN
            IF (MOD(IZAEHL,JWFILINT).EQ.0) THEN
              IF (IWFILINT.LT.0) THEN
                FILLT(1)=T
                FILLT(2)=X2
                FILLT(3)=Y2
                FILLT(4)=Z2
                FILLT(5)=RARG(1)
                FILLT(6)=RARG(2)
                FILLT(7)=RARG(3)
                FILLT(8)=RARG(4)
                FILLT(9)=RARG(5)
                FILLT(10)=DREAL(EXPOM*DEXPBUNCH)
                FILLT(11)=DIMAG(EXPOM*DEXPBUNCH)
                FILLT(12)=IROI-1
                FILLT(13)=IOBSV
                FILLT(14)=kfreq
                FILLT(15)=YOBSV
                FILLT(16)=ZOBSV
                FILLT(17)=BET1N
                FILLT(18)=OM
                FILLT(19)=DT
                FILLT(20)=BY2
                FILLT(21)=ISOUR
                FILLT(22)=
     &            (
     &            DREAL(affe(1,ifrob))*DREAL(affe(1,ifrob))
     &            +DIMAG(affe(1,ifrob))*DIMAG(affe(1,ifrob))
     &            +DREAL(affe(2,ifrob))*DREAL(affe(2,ifrob))
     &            +DIMAG(affe(2,ifrob))*DIMAG(affe(2,ifrob))
     &            +DREAL(affe(3,ifrob))*DREAL(affe(3,ifrob))
     &            +DIMAG(affe(3,ifrob))*DIMAG(affe(3,ifrob))
     &            )*specnor*bunnor
                FILLT(23)=DREAL(affe(4,ifrob))*specnor*bunnor
                FILLT(24)=DIMAG(affe(4,ifrob))*specnor*bunnor
                FILLT(25)=DREAL(affe(5,ifrob))*specnor*bunnor
                FILLT(26)=DIMAG(affe(5,ifrob))*specnor*bunnor
                FILLT(27)=DREAL(affe(6,ifrob))*specnor*bunnor
                FILLT(28)=DIMAG(affe(6,ifrob))*specnor*bunnor
                FILLT(29)=DOM1
                FILLT(30)=bx
                FILLT(31)=by
                FILLT(32)=bz
                FILLT(33)=bpx
                FILLT(34)=bpy
                FILLT(35)=bpz
                FILLT(36)=rnx
                FILLT(37)=rny
                FILLT(38)=rnz

                CALL hfm(NIDSOURCE,FILLT)

              ELSE IF (ISOUR.EQ.IWFILINT.AND.IOBSV.EQ.1) THEN

                WRITE(LUNINT,*) IZAEHL,kfreq,X2
                WRITE(LUNINT,*) (RARG(1),IC=1,3)
                WRITE(LUNINT,*) RARG(4)*OM,RARG(5)
                WRITE(LUNINT,*)REAL(EXPOM),IMAG(EXPOM)
                WRITE(LUNINT,*)RARG(1)*REAL(EXPOM*DEXPBUNCH),RARG(1)*IMAG(EXPOM*DEXPBUNCH)
                WRITE(LUNINT,*)RARG(2)*REAL(EXPOM*DEXPBUNCH),RARG(2)*IMAG(EXPOM*DEXPBUNCH)
                WRITE(LUNINT,*)RARG(3)*REAL(EXPOM*DEXPBUNCH),RARG(3)*IMAG(EXPOM*DEXPBUNCH)

              ENDIF !IWFILINT.LT.0
            ENDIF !JFILINT
          ENDIF !IWFILINT.NE.0
        ENDIF !ibun

        DO kfreq=2,NFREQ

          IFROB=kfreq+NFREQ*(IOBSV-1)

          IF    (ifreq2p.GT.2) THEN
            OM=OM+DOM
            EXPOM=EXPOM*DEXPOM
            DEXPOMPH=DEXPOMPH*DDEXPOMPH
          ELSE IF(ifreq2p.EQ.2) THEN
            OM=OM*2.0D0
            EXPOM=EXPOM*EXPOM
            DEXPOMPH=DEXPOMPH*DEXPOMPH
          ELSE IF(ifreq2p.EQ.0) THEN
            OM=FREQ(kfreq)/HBAREV1
            ZIOM=ZI*OM
            EXPOM2P0(2,kfreq)=EXP(ZIOM*DPHASE)
            EXPOM=EXPOM2P0(1,kfreq)
            DEXPOMPH=EXPOM2P0(2,kfreq)
          ELSE
            OM=FREQ(kfreq)/HBAREV1
            ZIOM=ZI*OM
            DEXPOMPH=EXP(ZIOM*DPHASE)
          ENDIF

          if (nelec.gt.1) then
            dexpbunch=phexp(kfreq)
          endif

          IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN

            EXPOMV2=1.0D0/BET1N/OM*EXPOM*(ZONE-DEXPOMPH)

            DO ICOMP=1,3
              daff(icomp)=RARG(ICOMP)*EXPOMV2*DEXPbunch/sqnphsp
              affe(icomp,ifrob)=affe(icomp,ifrob)+daff(icomp)
            ENDDO

c            baff(1)=conjg(rny*daff(3)-rnz*daff(2))
c            baff(2)=conjg(rnz*daff(1)-rnx*daff(3))
c            baff(3)=conjg(rnx*daff(2)-rny*daff(1))

            baff(1)=(rny*daff(3)-rnz*daff(2))
            baff(2)=(rnz*daff(1)-rnx*daff(3))
            baff(3)=(rnx*daff(2)-rny*daff(1))

            affe(4:6,ifrob)=affe(4:6,ifrob)+baff(1:3)/clight1

          ENDIF !XIEND

          IF (ibun.eq.1.and.isub.eq.neinbunch) then
            IF (IWFILINT.NE.0) THEN
              IF (MOD(IZAEHL,JWFILINT).EQ.0) THEN
                IF (IWFILINT.LT.0) THEN
                  FILLT(1)=T
                  FILLT(2)=X2
                  FILLT(3)=Y2
                  FILLT(4)=Z2
                  FILLT(5)=RARG(1)
                  FILLT(6)=RARG(2)
                  FILLT(7)=RARG(3)
                  FILLT(8)=RARG(4)
                  FILLT(9)=RARG(5)
                  FILLT(10)=DREAL(EXPOM*DEXPBUNCH)
                  FILLT(11)=DIMAG(EXPOM*DEXPBUNCH)
                  FILLT(12)=IROI-1
                  FILLT(13)=IOBSV
                  FILLT(14)=kfreq
                  FILLT(15)=YOBSV
                  FILLT(16)=ZOBSV
                  FILLT(17)=BET1N
                  FILLT(18)=OM
                  FILLT(19)=DT
                  FILLT(20)=BY2
                  FILLT(21)=ISOUR
                  FILLT(22)=
     &              (
     &              DREAL(affe(1,ifrob))*DREAL(affe(1,ifrob))
     &              +DIMAG(affe(1,ifrob))*DIMAG(affe(1,ifrob))
     &              +DREAL(affe(2,ifrob))*DREAL(affe(2,ifrob))
     &              +DIMAG(affe(2,ifrob))*DIMAG(affe(2,ifrob))
     &              +DREAL(affe(3,ifrob))*DREAL(affe(3,ifrob))
     &              +DIMAG(affe(3,ifrob))*DIMAG(affe(3,ifrob))
     &              )*specnor*bunnor
                  FILLT(23)=DREAL(affe(1,ifrob))*specnor*bunnor
                  FILLT(24)=DIMAG(affe(1,ifrob))*specnor*bunnor
                  FILLT(25)=DREAL(affe(2,ifrob))*specnor*bunnor
                  FILLT(26)=DIMAG(affe(2,ifrob))*specnor*bunnor
                  FILLT(27)=DREAL(affe(3,ifrob))*specnor*bunnor
                  FILLT(28)=DIMAG(affe(3,ifrob))*specnor*bunnor
                  FILLT(29)=DOM1
                  FILLT(30)=bx
                  FILLT(31)=by
                  FILLT(32)=bz
                  FILLT(33)=bpx
                  FILLT(34)=bpy
                  FILLT(35)=bpz
                  FILLT(36)=rnx
                  FILLT(37)=rny
                  FILLT(38)=rnz

                  CALL hfm(NIDSOURCE,FILLT)

                ELSE IF (ISOUR.EQ.IWFILINT.AND.IOBSV.EQ.1) THEN

                  WRITE(LUNINT,*) IZAEHL,kfreq,X2
                  WRITE(LUNINT,*) (RARG(1),IC=1,3)
                  WRITE(LUNINT,*) RARG(4)*OM,RARG(5)
                  WRITE(LUNINT,*)REAL(EXPOM*DEXPBUNCH),IMAG(EXPOM*DEXPBUNCH)
                  WRITE(LUNINT,*)RARG(1)*REAL(EXPOM*DEXPBUNCH),RARG(1)*IMAG(EXPOM*DEXPBUNCH)
                  WRITE(LUNINT,*)RARG(2)*REAL(EXPOM*DEXPBUNCH),RARG(2)*IMAG(EXPOM*DEXPBUNCH)
                  WRITE(LUNINT,*)RARG(3)*REAL(EXPOM*DEXPBUNCH),RARG(3)*IMAG(EXPOM*DEXPBUNCH)

                ENDIF !IWFILINT.LT.0
              ENDIF !JWFILINT
            ENDIF !IWFILINT.NE.0
          ENDIF !ibun

        ENDDO   !LOOP OVER ALL FREQUENCES

      ENDIF   !IINSIDE

C COMPLEX PART OF INTEGRAND }

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION }

      PHASE=PHASE+DPHASE
      EXPOM1=EXPOM1*DEXPOMPH1

      IF(ifreq2p.EQ.0) THEN

        DO JFREQ=1,NFREQ
          OM=FREQ(JFREQ)/HBAREV1
          ZIOM=ZI*OM
          EXPOM2P0(1,JFREQ)=EXPOM2P0(1,JFREQ)*EXPOM2P0(2,JFREQ)
        ENDDO
      ENDIF

      TS=TS+DT

C--- END OF LOOP OVER TIME STEPS

c      yp2zp2ia=yp2zp2ia
c     &  +((vy1/vx1)**2+(vy2/vx2)**2+(vz1/vx1)**2+(vz2/vx2)**2)*beta*clight1*dt2

      f(3)=((vy2/vx2)**2+(vz2/vx2)**2)
      fdt(3)=dt

      if (lstep.eq.1) then
        yp(1)=(f(2)-f(1))/fdt(2)
        yp(3)=(f(3)-f(2))/fdt(3)
        yp(2)=(yp(3)+yp(1))/2.0d0
        ypp=(yp(3)-yp(1))/(fdt(2)+fdt(3))*2.0d0
        a(3)=ypp/2.0d0
        a(2)=yp(2)-2.0d0*a(3)*fdt(2)
        a(1)=f(2)-a(2)*fdt(2)-a(3)*fdt(2)**2
        dfdt=fdt(2)+fdt(3)
        fihi=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        dfdt=0.0d0
        filo=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        yp2zp2i=yp2zp2i+fihi-filo
        yp2zp2i=yp2zp2i*beta*clight1
      else if (izaehl.ge.3) then
        yp(1)=(f(2)-f(1))/fdt(2)
        yp(3)=(f(3)-f(2))/fdt(3)
        yp(2)=(yp(3)+yp(1))/2.0d0
        ypp=(yp(3)-yp(1))/(fdt(2)+fdt(3))*2.0d0
        a(3)=ypp/2.0d0
        a(2)=yp(2)-2.0d0*a(3)*fdt(2)
        a(1)=f(2)-a(2)*fdt(2)-a(3)*fdt(2)**2
        dfdt=fdt(2)+fdt(3)
        fihi=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        dfdt=fdt(2)
        filo=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        yp2zp2i=yp2zp2i+fihi-filo
      endif

      f(1)=f(2)
      fdt(1)=fdt(2)
      f(2)=f(3)
      fdt(2)=fdt(3)

      if (ispecmode.eq.2) then
        if (izaehl.lt.ipoisou(isour)) goto 1000
      else
        IF (X2.LT.XENDSOU-VX2*DT.AND.X2.LT.(XIEND-VX2*DT).AND.LSTEP.EQ.0)
     &    GOTO 1000
        IF (LSTEP.EQ.0) THEN
          LSTEP=1
          GOTO 1000
        ENDIF
      endif

      IF (ISOUR.eq.1.and.ix10.eq.10.and.ielec.eq.nelec.and.iobsv.eq.nobsv
     &    ) THEN
        CALL date_and_time(dtday,dttime,dtzone,idatetime)
        WRITE(6,*)' ',IX10,' ',dttime(1:2),':',dttime(3:4),':',dttime(5:6)
      ENDIF

      if (ibun.eq.1.and.isub.eq.neinbunch) then

        IF (IINSIDE.NE.0) THEN
          DPHSOUR(2,1)=BET1N*DT*FREQ(1)/HBAREV1
          DPHSOUR(2,2)=BET1N*DT*FREQ(NFREQ)/HBAREV1
        ENDIF

C- STORE NUMBER OF POINTS FOR INTEGRATION

        IF (IOBSV.EQ.ICBRILL) IZTOT(ISOUR)=IZAEHL

      endif !ibun.eq.1

      IF (IAMPLI.LT.0) THEN

        DXEXI=MIN(soure(1,1),XIEND)
     &    -MAX(soura(1,1),XIANF)
        if (ampr2corr.eq.-9999.0d0) ampr2corr=dxexi
        CENXEXI=(MIN(soure(1,1),XIEND)
     &    +MAX(soura(1,1),XIANF))/2.D0
c        GAMGAM0=(SOURCEG(1,1,ISOUR))**2
c        GAMGAM=((SOURCEG(1,1,ISOUR)+SOURCEG(2,2,ISOUR)))**2
        GAMGAM0=(SOURCEG(1,1,ISOUR)*(egamma/dmygamma))**2
        GAMGAM=(
     &    (SOURCEG(1,1,ISOUR)+SOURCEG(2,2,ISOUR))*(egamma/dmygamma)
     &    )**2

c        DTPHASE=(WTRA2IS(ISOUR)+(1.0D0/GAMGAM0)*DXEXI/2.D0)/CLIGHT1
c     &    *GAMGAM0/GAMGAM

        slopein=sqrt(vyin**2+vzin**2)/vxin
        slope=sqrt(vyelec**2+vzelec**2)/vxelec

        if (myinum.gt.nlpoi/dxexi) then
          WI=(WTRA2IS(ISOUR)
     &      -DXEXI/2.0D0*slopein**2) !wi is detour for on-axis particle
     &      *(dmygamma/egamma)**2
        else
          if (iwarnwi.eq.0) then
            write(lungfo,*)
            write(lungfo,*)'*** Warning in SOUINTANA:'
            write(lungfo,*)'*** MYINUM is rather small with respect to NLPOI'
            write(lungfo,*)'*** Length of trajectories are now calculated by simple'
            write(lungfo,*)'*** integration with SOUINTANA, which might be poor'
            write(lungfo,*)
            write(lungfo,*)
            write(6,*)'*** Warning in SOUINTANA:'
            write(6,*)'*** MYINUM is rather small with respect to NLPOI'
            write(6,*)'*** Length of trajectories are now calculated by simple'
            write(6,*)'*** integration with SOUINTANA, which might be poor'
            write(6,*)
            iwarnwi=1
          endif
          wi=(yp2zp2i/2.0d0
     &      -DXEXI/2.0D0*slopein**2) !wi is detour for on-axis particle
     &      *(dmygamma/egamma)**2
        endif

        xn1=cenxexi
        yn1=(xn1-cenxexi)*vyelec/vxelec
        zn1=(xn1-cenxexi)*vzelec/vxelec

        drn2=(
     &    (yn1+dxexi*vyelec/vxelec)**2+
     &    (zn1+dxexi*vzelec/vxelec)**2
     &    )/
     &    (2.0d0*(xobsv-xn1-dxexi))

        drn1=(
     &    yn1**2+
     &    zn1**2
     &    )/
     &    (2.0d0*(xobsv-xn1))

        DTPHASE=(
     &    WI+DXEXI*(slope**2/2.0d0+1.0d0/(2.0D0*GAMGAM0))
     &    +drn2-drn1)
     &    /CLIGHT1*GAMGAM0/GAMGAM

        AMPDT=AMPSHIFT(1)/CLIGHT1/2.0D0/GAMGAM0
        FREQR=2.D0*PI1/DTPHASE*HBAREV1
        POW=SPECPOW(ILIOB)

        if (jpin.ne.3.or.jpin.eq.3.and.ielec.eq.1) SPECPOW(ILIOB)=0.0D0

        DO I=1,-IAMPLI
          R02=(XOBSV-CENXEXI)**2+YOBSV**2+ZOBSV**2
          R2=(XOBSV-CENXEXI-DXEXI*(I-ABS(IAMPLI)/2+1))**2
     &      +YOBSV**2+ZOBSV**2
          SPECPOW(ILIOB)=SPECPOW(ILIOB)+POW*R02/R2
     &      *R2/(sqrt(R2)-ampr2corr/2.0d0)**2/nelec
        ENDDO

      ENDIF  !endif iampli.lt.0

      DO kfreq=1,NFREQ

        ILIOBFR=ISOUR+NSOURCE*(IOBSV-1+NOBSV*(kfreq-1))
        IFROB=kfreq+NFREQ*(IOBSV-1)
        IOBFR=IOBSV+NOBSV*(kfreq-1)

        OM=FREQ(kfreq)/HBAREV1

        IF (IAMPLI.LT.0) THEN

          BX0=affe(4,ifrob)
          BY0=affe(5,ifrob)
          BZ0=affe(6,ifrob)

          BXc=BX0
          BYc=BY0
          BZc=BZ0

          AX0=affe(1,ifrob)
          AY0=affe(2,ifrob)
          AZ0=affe(3,ifrob)

          AX=AX0
          AY=AY0
          AZ=AZ0

          affe(1:6,ifrob)=(0.0D0,0.0D0)

          R0=OBSV(1,NOBSV/2+1)-CENXEXI
          R02=R0*R0
          R00=R0

c          H2=(YOBSV-vyelec)**2+(ZOBSV-vzelec)**2
c          H2R2=H2/R02
c
c          DTPHASE=(WTRA2IS(ISOUR)+(H2R2+1.0D0/GAMGAM0)*DXEXI/2.D0)/CLIGHT1
c     &      *GAMGAM0/GAMGAM
c     &      +AMPDT

          xn1=cenxexi
          yn1=(xn1-cenxexi)*vyelec/vxelec
          zn1=(xn1-cenxexi)*vzelec/vxelec

          drn2=(
     &      (yn1+dxexi*vyelec/vxelec-yobsv)**2+
     &      (zn1+dxexi*vzelec/vxelec-zobsv)**2
     &      )/
     &      (2.0d0*(xobsv-xn1-dxexi))

          drn1=(
     &      (yn1-yobsv)**2+
     &      (zn1-zobsv)**2
     &      )/
     &      (2.0d0*(xobsv-xn1))

          DTPHASE=(
     &      WI+DXEXI*(slope**2/2.0d0+1.0d0/(2.0D0*GAMGAM0))
     &      +drn2-drn1)
     &      /CLIGHT1*GAMGAM0/GAMGAM
     &      +AMPDT

          PHI=2.D0*PI1*FREQ(kfreq)*ECHARGE1/HPLANCK1*DTPHASE

          DMODU=EXP(ZI*PHI)
          DMODU0=DMODU
          DDMODU=ZONE

          if (ibunch.ne.0) then

            zzi=zeleco
            yyi=yeleco
            zzpi=zpeleco
            yypi=ypeleco

+self,if=notfmtot.
            zz=zzi
            zzp=zzpi
            yy=yyi
            yyp=yypi
+self,if=-notfmtot,if=wbetdeltae.
c  transform to beginning of first section
            dum22=tfmhtoti+(tfmdehtoti-tfmhtoti)*(egamma-dmygamma)
     &        /(deltae*dmygamma)
            zz=dum22(1,1)*zzi+dum22(1,2)*zzpi
            zzp=dum22(2,1)*zzi+dum22(2,2)*zzpi
            dum22=tfmvtoti+(tfmdevtoti-tfmvtoti)*(egamma-dmygamma)
     &        /(deltae*dmygamma)
            yy=dum22(1,1)*yyi+dum22(1,2)*yypi
            yyp=dum22(2,1)*yyi+dum22(2,2)*yypi
+self,if=-notfmtot,if=-wbetdeltae.
c  transform to beginning of first section
            zz=tfmhtoti(1,1)*zzi+tfmhtoti(1,2)*zzpi
            zzp=tfmhtoti(2,1)*zzi+tfmhtoti(2,2)*zzpi
            yy=tfmvtoti(1,1)*yyi+tfmvtoti(1,2)*yypi
            yyp=tfmvtoti(2,1)*yyi+tfmvtoti(2,2)*yypi
+self.

          endif !ibunch

          DO I=1,-IAMPLI

            if (ibunch.ne.0) then

+self,if=-notfmc,if=wbetdeltae.
c  transform to center of section, no closed orbit!
              dum22=tfmhci+(tfmdehci-tfmhci)*(egamma-dmygamma)
     &          /(deltae*dmygamma)
                zelec=dum22(1,1)*zz+dum22(1,2)*zzp
                zpelec=dum22(2,1)*zz+dum22(2,2)*zzp
              dum22=tfmhvi+(tfmdehvi-tfmhvi)*(egamma-dmygamma)
     &          /(deltae*dmygamma)
                yelec=dum22(1,1)*yy+dum22(1,2)*yyp
                ypelec=dum22(2,1)*yy+dum22(2,2)*yyp
+self,if=-notfmc,if=-wbetdeltae.
c  transform to center of section, no closed orbit!
                zelec=tfmhc(1,1)*zz+tfmhc(1,2)*zzp
                zpelec=tfmhc(2,1)*zz+tfmhc(2,2)*zzp
                yelec=tfmvc(1,1)*yy+tfmvc(1,2)*yyp
                ypelec=tfmvc(2,1)*yy+tfmvc(2,2)*yyp
+self,if=notfmc.
                zelec=zz
                zpelec=zzp
                yelec=yy
                ypelec=yyp
+self.

+self,if=-notfmtot,if=wbetdelate.
c  transform to beginning of next section

              zzi=zz
              yyi=yy
              zzpi=zzp
              yypi=yyp

              dum22=tfmh+(tfmdeh-tfmh)*(egamma-dmygamma)
     &          /(deltae*dmygamma)
              zz=dum22(1,1)*zzi+dum22(1,2)*zzpi
              zzp=dum22(2,1)*zzi+dum22(2,2)*zzpi
              dum22=tfmv+(tfmdev-tfmv)*(egamma-dmygamma)
     &          /(deltae*dmygamma)
              yy=dum22(1,1)*yyi+dum22(1,2)*yypi
              yyp=dum22(2,1)*yyi+dum22(2,2)*yypi

+self,if=-notfmtot,if=-wbetdelate.
c  transform to beginning of next section

              zzi=zz
              yyi=yy
              zzpi=zzp
              yypi=yyp

              zz=tfmh(1,1)*zzi+tfmh(1,2)*zzpi
              zzp=tfmh(2,1)*zzi+tfmh(2,2)*zzpi
              yy=tfmv(1,1)*yyi+tfmv(1,2)*yypi
              yyp=tfmv(2,1)*yyi+tfmv(2,2)*yypi

+self.
            endif !ibunch

            R0=OBSV(1,NOBSV/2+1)+DXEXI/2.D0*(-IAMPLI-2*(I-1)-1)-CENXEXI
            CORRR0=R00/R0
            !corrects for mistake of averaging over 1/r2, if e.g.
            !the repeated device is a long undulator
     &        *(R0/(R0-ampr2corr/2.0d0))**2

            R02=R0*R0
c            H2=(YOBSV)**2+(ZOBSV)**2
c            H2R2=H2/R02

c            DTPHASE=(WTRA2IS(ISOUR)+(H2R2+1.0D0/GAMGAM0)*DXEXI/2.D0)/CLIGHT1
c     &        *GAMGAM0/GAMGAM
c     &        +AMPDT

c            slope=sqrt(vyelec**2+vzelec**2)/vxelec

+self,if=noslopescal.
            slope=sqrt(ypelec**2+zpelec**2)
+self,if=-noslopescal.
            slope=sqrt(ypelec**2+zpelec**2)*gamgam0/gamgam
+self.

+self,if=-notralinshort.
            slope=sqrt(ypelec**2+zpelec**2)
+self.

            xn1=cenxexi-dxexi/2.d0*(-iampli-2*(i-1)-1)
     &          /(R0/(R0-ampr2corr/2.0d0))**2 !empirically
            yn1=(xn1-cenxexi)*ypelec
            zn1=(xn1-cenxexi)*zpelec

            yn1=yelec
            zn1=zelec

            drn2=(
     &        (yn1+dxexi*ypelec-yobsv)**2+
     &        (zn1+dxexi*zpelec-zobsv)**2
     &        )/
     &        (2.0d0*(xobsv-xn1-dxexi))

            drn1=(
     &        (yn1-yobsv)**2+
     &        (zn1-zobsv)**2
     &        )/
     &        (2.0d0*(xobsv-xn1))

            DTPHASE=(
     &        WI+DXEXI*(slope**2/2.0d0+1.0d0/(2.0D0*GAMGAM0))
     &        +drn2-drn1)
     &        /CLIGHT1*GAMGAM0/GAMGAM
     &        +AMPDT

            PHI=2.D0*PI1*FREQ(kfreq)*ECHARGE1/HPLANCK1*DTPHASE

            DMODU=EXP(ZI*PHI)
            DMODU0=DMODU
            DDMODU=ZONE

+self,if=blind.
            xn1=cenxexi-dxexi/2.d0*(-iampli-2*(i-1)-1)
            rest=mod(abs(xn1)+5.0196d0/2.0d0,6.1337625d0)
            if (abs(rest).le.5.0196d0) then
+self.
              affe(1,ifrob)=affe(1,ifrob)+AX
              affe(2,ifrob)=affe(2,ifrob)+AY
              affe(3,ifrob)=affe(3,ifrob)+AZ
              affe(4,ifrob)=affe(4,ifrob)+BXc
              affe(5,ifrob)=affe(5,ifrob)+BYc
              affe(6,ifrob)=affe(6,ifrob)+BZc
+self,if=blind.
c            if (kfreq.eq.1) write(77,*)i,isec,xn1,rest
            endif
+self.

            IF (AMPRAN.NE.0.0D0) THEN
              PHI=2.D0*PI1*XRANA(I)/FREQR*FREQ(kfreq)
              DDMODU=EXP(ZI*PHI)
            ENDIF   !(AMPRAN.NE.0.0D0)


            DMODU=DMODU0*DDMODU

            BX0=BX0*DMODU0
            BY0=BY0*DMODU0
            BZ0=BZ0*DMODU0

            BXc=BX0*CORRR0
            BYc=BY0*CORRR0
            BZc=BZ0*CORRR0

            BXc=BXc*DMODU
            BYc=BYc*DMODU
            BZc=BZc*DMODU

            AX0=AX0*DMODU0
            AY0=AY0*DMODU0
            AZ0=AZ0*DMODU0

            AX=AX0*CORRR0
            AY=AY0*CORRR0
            AZ=AZ0*CORRR0

            !DMODU=DMODU0*DDMODU

            AX=AX*DMODU
            AY=AY*DMODU
            AZ=AZ*DMODU

          ENDDO !IAMPLI

          zelec=zeleco
          yelec=yeleco

        ENDIF  !(IAMPLI.LT.0)

        if (jpin.eq.3) then

          FSPEC(1)=ISOUR
          FSPEC(2)=IOBSV
          FSPEC(3)=xobsv
          FSPEC(4)=yobsv
          FSPEC(5)=zobsv
          FSPEC(6)=FREQ(kfreq)
          FSPEC(7)=
     &      (
     &      DREAL(affe(1,ifrob))*DREAL(affe(1,ifrob))
     &      +DIMAG(affe(1,ifrob))*DIMAG(affe(1,ifrob))
     &      +DREAL(affe(2,ifrob))*DREAL(affe(2,ifrob))
     &      +DIMAG(affe(2,ifrob))*DIMAG(affe(2,ifrob))
     &      +DREAL(affe(3,ifrob))*DREAL(affe(3,ifrob))
     &      +DIMAG(affe(3,ifrob))*DIMAG(affe(3,ifrob))
     &      )*specnor*bunnor
          FSPEC(8)=1
          FSPEC(9)=1
          FSPEC(10)=kfreq
          FSPEC(11)=dreal(affe(1,ifrob))*sqrt(specnor*bunnor)
          FSPEC(12)=dimag(affe(1,ifrob))*sqrt(specnor*bunnor)
          FSPEC(13)=dreal(affe(2,ifrob))*sqrt(specnor*bunnor)
          FSPEC(14)=dimag(affe(2,ifrob))*sqrt(specnor*bunnor)
          FSPEC(15)=dreal(affe(3,ifrob))*sqrt(specnor*bunnor)
          FSPEC(16)=dimag(affe(3,ifrob))*sqrt(specnor*bunnor)
          FSPEC(17)=0.0d0
          FSPEC(18)=0.0d0
          FSPEC(19)=0.0d0
          FSPEC(20)=0.0d0
          FSPEC(21)=dreal(affe(4,ifrob))*sqrt(specnor*bunnor)
          FSPEC(22)=dimag(affe(4,ifrob))*sqrt(specnor*bunnor)
          FSPEC(23)=dreal(affe(5,ifrob))*sqrt(specnor*bunnor)
          FSPEC(24)=dimag(affe(5,ifrob))*sqrt(specnor*bunnor)
          FSPEC(25)=dreal(affe(6,ifrob))*sqrt(specnor*bunnor)
          FSPEC(26)=dimag(affe(6,ifrob))*sqrt(specnor*bunnor)
          FSPEC(27)=0.0d0
          FSPEC(28)=0.0d0
          FSPEC(29)=0.0d0
          FSPEC(30)=0.0d0

          if (ispecdip.le.0) then
            cenxexi=(min(soure(1,1),xiend)
     &        +max(soura(1,1),xianf))/2.d0
          else
            cenxexi=x0dip(isour)
          endif

          dist0=pincen(1)-cenxexi
          dist02=dist0**2

          h2=(yobsv**2+zobsv**2)/dist02
          if (h2.lt.0.01) then
            ddist=dist0*(h2/2.0d0-h2**2/8.0d0)
          else
            ddist=dist0*(sqrt(1.0d0+h2)-1.0d0)
          endif

          dphase=ddist/freq(kfreq)*wtoe1*1.0d9*twopi1

          FSPEC(31)=dphase

          call hfm(nidspec,fspec)

          FSPEC(1)=xobsv
          FSPEC(2)=yobsv
          FSPEC(3)=zobsv
          FSPEC(4)=powpow*pownor
          FSPEC(5)=0.0d0
          FSPEC(6)=1.0d0
          FSPEC(7)=1.0d0
          FSPEC(8)=iobsv
          FSPEC(9)=ISOUR

          call hfm(nidpow,fspec)

          if (istokes.ne.0) then

            APOLH=
     &        affe(1,IFROB)*CONJG(VSTOKES(1,1))
     &        +affe(2,IFROB)*CONJG(VSTOKES(1,2))
     &        +affe(3,IFROB)*CONJG(VSTOKES(1,3))

            APOLR=
     &        affe(1,IFROB)*CONJG(VSTOKES(2,1))
     &        +affe(2,IFROB)*CONJG(VSTOKES(2,2))
     &        +affe(3,IFROB)*CONJG(VSTOKES(2,3))

            APOLL=
     &        affe(1,IFROB)*CONJG(VSTOKES(3,1))
     &        +affe(2,IFROB)*CONJG(VSTOKES(3,2))
     &        +affe(3,IFROB)*CONJG(VSTOKES(3,3))

            APOL45=
     &        affe(1,IFROB)*CONJG(VSTOKES(4,1))
     &        +affe(2,IFROB)*CONJG(VSTOKES(4,2))
     &        +affe(3,IFROB)*CONJG(VSTOKES(4,3))

            STOK1=
     &        APOLR*CONJG(APOLR)+
     &        APOLL*CONJG(APOLL)

            STOK2=-STOK1+
     &        2.0d0*APOLH*CONJG(APOLH)

            STOK3=
     &        2.0d0*APOL45*CONJG(APOL45)-
     &        STOK1

            STOK4=
     &        APOLR*CONJG(APOLR)-
     &        APOLL*CONJG(APOLL)

            FSPEC(1)=IOBSV
            FSPEC(2)=xobsv
            FSPEC(3)=yobsv
            FSPEC(4)=zobsv
            FSPEC(5)=FREQ(kfreq)
            FSPEC(6)=STOK1*specnor*bunnor
            FSPEC(7)=STOK2*specnor*bunnor
            FSPEC(8)=STOK3*specnor*bunnor
            FSPEC(9)=STOK4*specnor*bunnor
            FSPEC(10)=1.0d0
            FSPEC(11)=1.0d0
            FSPEC(12)=kfreq

            CALL hfm(NIDSTOK,FSPEC)

          ENDIF   !ISTOKES

        endif !ipin.eq.3

        if (ihbunch.ne.0) then
c          if (mod(ielec,ihbunch).eq.0.and.iobsv.eq.icbrill) then
          if (mod(ielec,ihbunch).eq.0) then
            if (jpin.ne.3) then
              fnor=specnor*bunnor*nelec
            else
              fnor=specnor*bunnor
            endif
            sqnor=sqrt(fnor)
            fillb(1)=ibun
            fillb(2)=isub
            fillb(3)=ielec
            fillb(4)=bunchx
            fillb(5)=xelec
            fillb(6)=yelec
            fillb(7)=zelec
            fillb(8)=vyelec/vxelec
            fillb(9)=vzelec/vxelec
            fillb(10)=x2
            fillb(11)=y2
            fillb(12)=z2
            fillb(13)=vy2/vx2
            fillb(14)=vz2/vx2
            fillb(15)=egamma*emassg1
            fillb(16)=gamma*emassg1
            fillb(17)=xobsv
            fillb(18)=yobsv
            fillb(19)=zobsv
            fillb(20)=kfreq
            fillb(21)=freq(kfreq)
            if (jpin.eq.3) then
              speck=
     &          DREAL(
     &          affe(1,IFROB)*CONJG(affe(1,IFROB))
     &          +affe(2,IFROB)*CONJG(affe(2,IFROB))
     &          +affe(3,IFROB)*CONJG(affe(3,IFROB))
     &          )*specnor*bunnor/nelec
            else
              speck=
     &          DREAL(
     &          affe(1,IFROB)*CONJG(affe(1,IFROB))
     &          +affe(2,IFROB)*CONJG(affe(2,IFROB))
     &          +affe(3,IFROB)*CONJG(affe(3,IFROB))
     &          )*specnor*bunnor
            endif
            fillb(22)=speck*nelec

            if (istokes.ne.0) then

              APOLH=
     &          affe(1,IFROB)*CONJG(VSTOKES(1,1))
     &          +affe(2,IFROB)*CONJG(VSTOKES(1,2))
     &          +affe(3,IFROB)*CONJG(VSTOKES(1,3))

              APOLR=
     &          affe(1,IFROB)*CONJG(VSTOKES(2,1))
     &          +affe(2,IFROB)*CONJG(VSTOKES(2,2))
     &          +affe(3,IFROB)*CONJG(VSTOKES(2,3))

              APOLL=
     &          affe(1,IFROB)*CONJG(VSTOKES(3,1))
     &          +affe(2,IFROB)*CONJG(VSTOKES(3,2))
     &          +affe(3,IFROB)*CONJG(VSTOKES(3,3))

              APOL45=
     &          affe(1,IFROB)*CONJG(VSTOKES(4,1))
     &          +affe(2,IFROB)*CONJG(VSTOKES(4,2))
     &          +affe(3,IFROB)*CONJG(VSTOKES(4,3))

              STOK1=
     &          APOLR*CONJG(APOLR)+
     &          APOLL*CONJG(APOLL)

              STOK2=-STOK1+
     &          2.0d0*APOLH*CONJG(APOLH)

              STOK3=
     &          2.0d0*APOL45*CONJG(APOL45)-
     &          STOK1

              STOK4=
     &          APOLR*CONJG(APOLR)-
     &          APOLL*CONJG(APOLL)

              fillb(23)=stok1*fnor
              fillb(24)=stok2*fnor
              fillb(25)=stok3*fnor
              fillb(26)=stok4*fnor

            else
              fillb(23)=fillb(22)
              fillb(24:26)=0.0d0
            endif !istokes

            if (jpin.ne.3) then
                fillb(27)=powpow*pownor*nelec
            else
                fillb(27)=powpow*pownor
            endif
            fillb(28)=isour
            fillb(29)=t2

            fillb(30)=dreal(affe(1,ifrob))*sqnor
            fillb(31)=dimag(affe(1,ifrob))*sqnor
            fillb(32)=dreal(affe(2,ifrob))*sqnor
            fillb(33)=dimag(affe(2,ifrob))*sqnor
            fillb(34)=dreal(affe(3,ifrob))*sqnor
            fillb(35)=dimag(affe(3,ifrob))*sqnor
            fillb(36)=dreal(affe(4,ifrob))*sqnor
            fillb(37)=dimag(affe(4,ifrob))*sqnor
            fillb(38)=dreal(affe(5,ifrob))*sqnor
            fillb(39)=dimag(affe(5,ifrob))*sqnor
            fillb(40)=dreal(affe(6,ifrob))*sqnor
            fillb(41)=dimag(affe(6,ifrob))*sqnor

            call hfm(nidbunch,fillb)
          endif
        endif

        if (ibunphase.eq.1) then

          are(1:6)=dreal(affe(1:6,ifrob))
          aim(1:6)=dimag(affe(1:6,ifrob))

          if (iobunch.eq.-9999.and.ielec.eq.1) then
            ampz(kfreq)=sqrt(are(3)**2+aim(3)**2)
            if (ampz(kfreq).gt.ampzmax(kfreq)) then
              ampzmax(kfreq)=ampz(kfreq)
              kobs(kfreq)=iobsv
            endif
          else if (iobsv.eq.iobunch) then
            ampz(kfreq)=sqrt(are(3)**2+aim(3)**2)
            if (ampz(kfreq).ne.0.0d0) then
              azcos(kfreq)=are(3)/ampz(kfreq)
              azsin(kfreq)=aim(3)/ampz(kfreq)
            else
              azcos(kfreq)=1.0d0
              azsin(kfreq)=0.0d0
            endif
          endif

          if (iobsv.eq.nobsv.and.kfreq.eq.nfreq) then

            do jfreq=1,nfreq

              jfrob=jfreq+nfreq*(kobs(jfreq)-1)
              are(1:6)=dreal(affe(1:6,jfrob))
              aim(1:6)=dimag(affe(1:6,jfrob))

              ampz(jfreq)=sqrt(are(3)**2+aim(3)**2)

              if (ampz(jfreq).ne.0.0d0) then
                azcos(jfreq)=are(3)/ampz(jfreq)
                azsin(jfreq)=aim(3)/ampz(jfreq)
              else
                azcos(jfreq)=1.0d0
                azsin(jfreq)=0.0d0
              endif

            enddo !jfreq

            do job=1,nobsv
              do jfreq=1,nfreq

                jfrob=jfreq+nfreq*(job-1)

                are(1:6)=dreal(affe(1:6,jfrob))
                aim(1:6)=dimag(affe(1:6,jfrob))

                affe(1:6,jfrob)=dcmplx(
     &            azcos(jfreq)*are(1:6)+azsin(jfreq)*aim(1:6),
     &            -azsin(jfreq)*are(1:6)+azcos(jfreq)*aim(1:6)
     &            )

                AFREQ(1:6,jfrob)=AFREQ(1:6,jfrob)+affe(1:6,jfrob)

                affe(1:6,jfrob)=(0.0D0,0.0D0)

              enddo
            enddo

          endif !iobsv.eq.nobsv

        else !ibunphase

          if (iobsv.eq.nobsv.and.kfreq.eq.nfreq) then
            AFREQ=AFREQ+affe
            affe=(0.0D0,0.0D0)
          endif

        endif !ibunphase

      ENDDO !kfreq

      if (isub.eq.neinbunch.and.iobsv.eq.nobsv) then

        do job=1,nobsv
          do kfreq=1,nfreq

            ifrob=kfreq+nfreq*(job-1)
            iliobfr=isour+nsource*(job-1+nobsv*(kfreq-1))
            iobfr=job+nobsv*(kfreq-1)

            IF(SPECCUT.GT.0.0D0) THEN
              ECMAXS=ECMAX(ISOUR)
              IF(FREQ(kfreq).GT.SPECCUT*ecdipev1*DMYENERGY**2*ECMAXS) THEN
                AFREQ(1,IFROB)=(0.0D0,0.0D0)
                AFREQ(2,IFROB)=(0.0D0,0.0D0)
                AFREQ(3,IFROB)=(0.0D0,0.0D0)
              ENDIF
            ENDIF

            AFREQ(1:3,IFROB)=AFREQ(1:3,IFROB)*REFLEC(1:3)
            AFREQ(4:6,IFROB)=AFREQ(4:6,IFROB)*REFLEC(1:3)

            IF (IPOLA.EQ.0) THEN

              speck=
     &          DREAL(
     &          AFREQ(1,IFROB)*CONJG(AFREQ(1,IFROB))
     &          +AFREQ(2,IFROB)*CONJG(AFREQ(2,IFROB))
     &          +AFREQ(3,IFROB)*CONJG(AFREQ(3,IFROB))
     &          )*specnor*bunnor

              SPEC(ILIOBFR)=SPEC(ILIOBFR)+speck

              REAIMA(1:3,1,IOBFR)=REAIMA(1:3,1,IOBFR)+
     &          DREAL(AFREQ(1:3,IFROB))/sqnbunch
              REAIMA(1:3,2,IOBFR)=REAIMA(1:3,2,IOBFR)+
     &          DIMAG(AFREQ(1:3,IFROB))/sqnbunch
              REAIMA(6:8,1,IOBFR)=REAIMA(6:8,1,IOBFR)+
     &          DREAL(AFREQ(4:6,IFROB))/sqnbunch
              REAIMA(6:8,2,IOBFR)=REAIMA(6:8,2,IOBFR)+
     &          DIMAG(AFREQ(4:6,IFROB))/sqnbunch

            ELSE    !IPOLA

              APOL=
     &          AFREQ(1,IFROB)*CONJG(VPOLA(1))
     &          +AFREQ(2,IFROB)*CONJG(VPOLA(2))
     &          +AFREQ(3,IFROB)*CONJG(VPOLA(3))

              SPEC(ILIOBFR)=SPEC(ILIOBFR)+
     &          DREAL(APOL*CONJG(APOL))*specnor*bunnor


              REAIMA(1:3,1,IOBFR)=REAIMA(1:3,1,IOBFR)+
     &          DREAL(AFREQ(1:3,IFROB))/sqnbunch
              REAIMA(1:3,2,IOBFR)=REAIMA(1:3,2,IOBFR)+
     &          DIMAG(AFREQ(1:3,IFROB))/sqnbunch
              REAIMA(6:8,1,IOBFR)=REAIMA(6:8,1,IOBFR)+
     &          DREAL(AFREQ(1:3,IFROB))/sqnbunch
              REAIMA(6:8,2,IOBFR)=REAIMA(6:8,2,IOBFR)+
     &          DIMAG(AFREQ(1:3,IFROB))/sqnbunch

            ENDIF   !IPOLA

            IF (ISTOKES.NE.0) THEN

              APOLH=
     &          AFREQ(1,IFROB)*CONJG(VSTOKES(1,1))
     &          +AFREQ(2,IFROB)*CONJG(VSTOKES(1,2))
     &          +AFREQ(3,IFROB)*CONJG(VSTOKES(1,3))

              APOLR=
     &          AFREQ(1,IFROB)*CONJG(VSTOKES(2,1))
     &          +AFREQ(2,IFROB)*CONJG(VSTOKES(2,2))
     &          +AFREQ(3,IFROB)*CONJG(VSTOKES(2,3))

              APOLL=
     &          AFREQ(1,IFROB)*CONJG(VSTOKES(3,1))
     &          +AFREQ(2,IFROB)*CONJG(VSTOKES(3,2))
     &          +AFREQ(3,IFROB)*CONJG(VSTOKES(3,3))

              APOL45=
     &          AFREQ(1,IFROB)*CONJG(VSTOKES(4,1))
     &          +AFREQ(2,IFROB)*CONJG(VSTOKES(4,2))
     &          +AFREQ(3,IFROB)*CONJG(VSTOKES(4,3))

              STOK1=
     &          APOLR*CONJG(APOLR)+
     &          APOLL*CONJG(APOLL)

              STOK2=-STOK1+
     &          2.0d0*APOLH*CONJG(APOLH)

              STOK3=
     &          2.0d0*APOL45*CONJG(APOL45)-
     &          STOK1

              STOK4=
     &          APOLR*CONJG(APOLR)-
     &          APOLL*CONJG(APOLL)

              STOKES(1,IOBFR)=STOKES(1,IOBFR)+
     &          STOK1*specnor*bunnor

              STOKES(2,IOBFR)=STOKES(2,IOBFR)+
     &          STOK2*specnor*bunnor

              STOKES(3,IOBFR)=STOKES(3,IOBFR)+
     &          STOK3*specnor*bunnor

              STOKES(4,IOBFR)=STOKES(4,IOBFR)+
     &          STOK4*specnor*bunnor

            ENDIF !ISTOKES

            AFREQ(1:6,IFROB)=(0.0d0,0.0d0)

          enddo !kfreq
        enddo !job

      endif !isub.eq.neinbunch

      if (ibun.eq.nbunch.and.isub.eq.neinbunch) then
        ILIOB=ISOUR+NSOURCE*(IOBSV-1)
        SPECPOW(ILIOB)=SPECPOW(ILIOB)*POWNOR
      endif

      IF (
     &    jpin.ne.0.and.jpin.ne.3.and.IOBSV.EQ.jobunch
     &    .or.
     &    (jpin.eq.3.or.jpin.eq.0).and.ielec.eq.1
     &    ) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '       phase advance per step at beginning and end of source for'
        if (jpin.ne.3) then
          WRITE(LUNGFO,*)
     &      '       lowest and highest photon energy at selected observation point:'
        else
          WRITE(LUNGFO,*)
     &      '       lowest and highest photon energy for first electron:'
        endif
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'       beginning:',SNGL(DPHSOUR(1,1)),SNGL(DPHSOUR(1,2))
        WRITE(LUNGFO,*)'       end:      ',SNGL(DPHSOUR(2,1)),SNGL(DPHSOUR(2,2))
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'       ROIs (boundary, precision, points):'
        WRITE(LUNGFO,*)

        DO IROI=1,NROIA-1
          WRITE(LUNGFO,*)
     &      IROI,SNGL(ROIX(IROI)),SNGL(ROIP(IROI)),IPOIROI(IROI+1)
        ENDDO
        WRITE(LUNGFO,*)
     &    NROI,SNGL(ROIX(NROIA))

      ENDIF !IOBSV

      IF (
     &    jpin.ne.0.and.jpin.ne.3.and.IOBSV.EQ.NOBSV
     &    .or.
     &    (jpin.eq.0.or.jpin.eq.3).and.ielec.eq.1) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'       SOURCE, TOTAL NUMBER OF STEPS:',ISOUR,IZAEHL
        WRITE(LUNGFO,*)'       (controlled by NLPOI and namelist $ROIN)'
        WRITE(LUNGFO,*)
      ENDIF

      isourold=isour

      ICAL=1

c      print*,"souintana:",spec(25)


      RETURN
      END subroutine souintana
+DECK,SOUINTEST.
*CMZ :  2.20/04 23/02/2001  15.47.54  by  Michael Scheer
*CMZ :  2.20/01 11/02/2001  19.28.08  by  Michael Scheer
*CMZ :  2.17/00 06/11/2000  17.35.03  by  Michael Scheer
*CMZ :  2.16/08 31/10/2000  14.40.08  by  Michael Scheer
*CMZ :  2.16/07 21/09/2000  11.21.09  by  Michael Scheer
*CMZ :  2.16/05 02/08/2000  13.54.04  by  Michael Scheer
*CMZ :  2.16/03 16/06/2000  14.35.01  by  Michael Scheer
*CMZ :  2.15/00 04/05/2000  14.40.34  by  Michael Scheer
*CMZ :  2.14/02 26/04/2000  16.42.15  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  16.16.47  by  Michael Scheer
*CMZ :  2.13/08 18/02/2000  14.23.55  by  Michael Scheer
*CMZ :  2.13/07 17/02/2000  15.11.13  by  Michael Scheer
*CMZ :  2.13/04 21/01/2000  11.59.50  by  Michael Scheer
*CMZ :  2.13/03 18/01/2000  17.32.13  by  Michael Scheer
*CMZ :  2.13/02 13/12/99  13.53.49  by  Michael Scheer
*CMZ :  2.13/00 30/11/99  11.53.43  by  Michael Scheer
*CMZ :  2.12/03 21/07/99  10.46.43  by  Michael Scheer
*CMZ :  2.12/01 09/06/99  14.24.23  by  Michael Scheer
*CMZ :  2.12/00 04/06/99  10.43.55  by  Michael Scheer
*CMZ :  2.11/01 20/05/99  17.44.32  by  Michael Scheer
*CMZ :  2.10/01 24/02/99  10.20.40  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  11.18.17  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.54.05  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.44  by  Michael Scheer
*-- Author : Michael Scheer

      SUBROUTINE SOUINTEST(ISOUR)
+seq,gplhint.

      INTEGER ISOUR

      ISOUR=ISOUR

      RETURN
      END
+DECK,SOUINTLIN.
*CMZ :  4.00/14 22/12/2021  18.07.25  by  Michael Scheer
*CMZ :  3.08/01 02/04/2019  15.33.15  by  Michael Scheer
*CMZ :  3.02/03 06/11/2014  14.24.54  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  14.04.56  by  Michael Scheer
*CMZ :  2.68/05 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  09.55.57  by  Michael Scheer
*CMZ :  2.66/04 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.66/03 12/11/2009  16.27.11  by  Michael Scheer
*CMZ :  2.50/00 28/10/2009  15.52.52  by  Michael Scheer
*CMZ :  2.41/10 16/04/2004  09.24.47  by  Michael Scheer
*CMZ :  2.41/09 14/08/2002  17.11.32  by  Michael Scheer
*CMZ :  2.20/04 09/03/2001  14.23.38  by  Michael Scheer
*CMZ :  2.20/03 22/02/2001  18.37.06  by  Michael Scheer
*CMZ :  2.20/01 11/02/2001  19.28.38  by  Michael Scheer
*CMZ :  2.16/08 31/10/2000  14.40.08  by  Michael Scheer
*CMZ :  2.16/07 21/09/2000  11.21.00  by  Michael Scheer
*CMZ :  2.16/06 28/08/2000  14.39.42  by  Michael Scheer
*CMZ :  2.16/05 02/08/2000  13.53.32  by  Michael Scheer
*CMZ :  2.16/04 19/06/2000  14.27.19  by  Michael Scheer
*CMZ :  2.16/03 16/06/2000  14.35.02  by  Michael Scheer
*CMZ :  2.15/00 05/05/2000  19.25.24  by  Michael Scheer
*CMZ :  2.14/02 26/04/2000  16.40.34  by  Michael Scheer
*CMZ :  2.13/07 17/02/2000  15.11.13  by  Michael Scheer
*CMZ :  2.13/03 18/01/2000  17.44.41  by  Michael Scheer
*CMZ :  2.12/03 21/07/99  10.47.09  by  Michael Scheer
*CMZ :  2.12/01 10/06/99  17.49.00  by  Michael Scheer
*CMZ :  2.12/00 04/06/99  10.43.55  by  Michael Scheer
*CMZ :  2.11/01 20/05/99  17.44.32  by  Michael Scheer
*CMZ :  2.10/01 24/02/99  10.20.40  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  11.18.17  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.54.05  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.44  by  Michael Scheer
*-- Author : Michael Scheer

      SUBROUTINE SOUINTLIN(ISOUR)
+seq,gplhint.

+SEQ,TRACKF90U,IF=F90.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,AFREQF90U.
+SELF.

C--- EVALUATE INTEGRALES FOR A SINGLE SOURCE

         IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,PHYCON.
+SEQ,TRACK.
+seq,sourcef90.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,FREQS.
+SEQ,USERVAR.
+seq,datetime.

+SELF,IF=-F90.
      INTEGER IPOIROI(NROIP)
+SELF.
      INTEGER NUMSTEP0,NUMSTEP

      INTEGER ISOUR,IZAEHL,ITIM0,IWARN,IOBSV,ICOMP,IFREQ,IROI
      INTEGER IEXPOMT,IEXPDOMT,IX10

      INTEGER ICAL,NTUPP,ICYCLE,IC,I
      PARAMETER (NTUPP=22)
        REAL*8 FILLT(NTUPP)
      CHARACTER(4) CTUP(NTUPP)

      DOUBLE PRECISION X1,TS,X0,X10
      DOUBLE PRECISION X2,Y2,Z2
      DOUBLE PRECISION XENDSOU,DT,DT0,DTIM01,DT2,DROIX,DTE,TE,DDTS,DT1
      DOUBLE PRECISION RARGOM,RARGDOM,RARGOMO,RARGDOMO
      DOUBLE PRECISION ARG,ARGO,ARG2,ARG4,DARG,DARG2,DARG4

      DOUBLE PRECISION BX,BY,BZ,DUM1,DUM11,DOM1,DOM2,R0,C1,PX,PY,PZ,BPX,BPY,BPZ
      DOUBLE PRECISION RNBX,RNBY,RNBZ,T,R,RNX,RNY,RNZ,R1,RX,RY,RZ,RARG(5)

      DOUBLE PRECISION CGG

+SEL,IF=-F90.
      DOUBLE PRECISION DWTRA(3,6,NWMAXP+1)
+SELF.

+SELF,IF=-NEWWAVE.
      COMPLEX*16 APOL
      COMPLEX*16 AFREQ(3,NDFREQP,NDOBSVP)
      COMPLEX*16 EXPOM,DEXPOM,DEXPOMT,DEXPDOMT,DARGEXPO(6,NDOBSVP)
      COMPLEX*8 APOLH,APOLR,APOLL,APOL45
+SELF,IF=NEWWAVE,IF=-NOCMPLX,IF=-F90.
      COMPLEX*16 APOL
      COMPLEX*16 AFREQ(3,NOBFRP)
      COMPLEX*16 EXPOM,DEXPOM,DEXPOMT,DEXPDOMT,DARGEXPO(6,NDOBSVP)
      COMPLEX*8 APOLH,APOLR,APOLL,APOL45
+SELF,IF=NEWWAVE,IF=-NOCMPLX,IF=F90.
      COMPLEX*16 APOL
      COMPLEX*16 EXPOM,DEXPOM,DEXPOMT,DEXPDOMT
      COMPLEX*8 APOLH,APOLR,APOLL,APOL45
+SELF,IF=NEWWAVE,IF=NOCMPLX,IF=-F90.
        DOUBLE PRECISION AFREQR(3,NOBFRP),OMO
        DOUBLE PRECISION EXPOMR,DEXPOMR,DEXPOMTR,DEXPDOMTR,DARGEXPOR(6,NDOBSVP)
        DOUBLE PRECISION APOLR,APOLI,COMR,COMI
        DOUBLE PRECISION AFREQI(3,NOBFRP)
        DOUBLE PRECISION EXPOMI,DEXPOMI,DEXPOMTI,DEXPDOMTI,DARGEXPOI(6,NDOBSVP)
        REAL APOLHR,APOLRR,APOLLR,APOL45R
        REAL APOLHI,APOLRI,APOLLI,APOL45I
+SELF.

+SELF,IF=NEWWAVE,IF=NOCMPLX,IF=F90.
        DOUBLE PRECISION OMO
        DOUBLE PRECISION EXPOMR,DEXPOMR,DEXPOMTR,DEXPDOMTR
        DOUBLE PRECISION APOLR,APOLI,COMR,COMI
        DOUBLE PRECISION EXPOMI,DEXPOMI,DEXPOMTI,DEXPDOMTI
        REAL APOLHR,APOLRR,APOLLR,APOL45R
        REAL APOLHI,APOLRI,APOLLI,APOL45I
+SELF.

      DOUBLE PRECISION OM,DOM
      REAL*4 STOK1,STOK2,STOK3,STOK4

      DATA ICAL/0/
      data ctup /'t','x','y','z','rx','ry','rz','rt','p','rea','ima','roi'
     &            ,'iob','ie','yob','zob','betn','dtom','emod','dmod'
     &            ,'spec','te'/

      DATA IWARN/0/

      IF (ICAL.EQ.0) THEN

          CGG=CLIGHT1/(DMYGAMMA*DMYGAMMA)
          DOM=(FREQ(2)-FREQ(1))/HBAREV1
          OM=FREQ(1)/HBAREV1
          C1=1.D0/CLIGHT1
          IF (IWFILINT.LT.0)
+self,if=-mhbook.
     &      CALL hbookm(NIDSOURCE,'RADIATION INTEGRAL$',NTUPP
     &     ,'//WAVE',1024,CTUP)
+self,if=mhbook.
     &      CALL hbookm(NIDSOURCE,'RADIATION INTEGRAL',NTUPP
     &     ,'//WAVE',nlpoi/jwfilint+2*jwfilint,CTUP)
+self.

          DTIM01=1.D0/DTIM0

+SELF,IF=F90.
          ALLOCATE(DWTRA(3,6,NCO+1))
+SELF.

          DO ITIM0=1,NCO

         DWTRA(1,1,ITIM0)=WTRA(1,1,ITIM0)
         DWTRA(2,1,ITIM0)=WTRA(2,1,ITIM0)
         DWTRA(3,1,ITIM0)=WTRA(3,1,ITIM0)

         DWTRA(1,3,ITIM0)=WTRA(1,2,ITIM0)*C1
         DWTRA(2,3,ITIM0)=WTRA(2,2,ITIM0)*C1
         DWTRA(3,3,ITIM0)=WTRA(3,2,ITIM0)*C1

          ENDDO   !NCO

         DWTRA(1,5,1)=(WTRA(1,2,2)-WTRA(1,2,1))*C1*DTIM01
         DWTRA(2,5,1)=(WTRA(2,2,2)-WTRA(2,2,1))*C1*DTIM01
         DWTRA(3,5,1)=(WTRA(3,2,2)-WTRA(3,2,1))*C1*DTIM01

          DO ITIM0=2,NCO-1

         DWTRA(1,5,ITIM0)=((WTRA(1,2,ITIM0+1)-WTRA(1,2,ITIM0-1))*C1*DTIM01)/2.D0
         DWTRA(2,5,ITIM0)=((WTRA(2,2,ITIM0+1)-WTRA(2,2,ITIM0-1))*C1*DTIM01)/2.D0
         DWTRA(3,5,ITIM0)=((WTRA(3,2,ITIM0+1)-WTRA(3,2,ITIM0-1))*C1*DTIM01)/2.D0

          ENDDO   !NCO

         DWTRA(1,5,NCO)=DWTRA(1,5,NCO-1)+DWTRA(1,5,NCO-1)-DWTRA(1,5,NCO-2)
         DWTRA(2,5,NCO)=DWTRA(2,5,NCO-1)+DWTRA(2,5,NCO-1)-DWTRA(2,5,NCO-2)
         DWTRA(3,5,NCO)=DWTRA(3,5,NCO-1)+DWTRA(3,5,NCO-1)-DWTRA(3,5,NCO-2)

         DWTRA(1,5,NCO+1)=DWTRA(1,5,NCO)+DWTRA(1,5,NCO)-DWTRA(1,5,NCO-1)
         DWTRA(2,5,NCO+1)=DWTRA(2,5,NCO)+DWTRA(2,5,NCO)-DWTRA(2,5,NCO-1)
         DWTRA(3,5,NCO+1)=DWTRA(3,5,NCO)+DWTRA(3,5,NCO)-DWTRA(3,5,NCO-1)

         DWTRA(1,1,NCO+1)=DWTRA(1,1,NCO)+DWTRA(1,1,NCO)-DWTRA(1,1,NCO-1)
         DWTRA(2,1,NCO+1)=DWTRA(2,1,NCO)+DWTRA(2,1,NCO)-DWTRA(2,1,NCO-1)
         DWTRA(3,1,NCO+1)=DWTRA(3,1,NCO)+DWTRA(3,1,NCO)-DWTRA(3,1,NCO-1)

         DWTRA(1,3,NCO+1)=DWTRA(1,3,NCO)+DWTRA(1,3,NCO)-DWTRA(1,3,NCO-1)
         DWTRA(2,3,NCO+1)=DWTRA(2,3,NCO)+DWTRA(2,3,NCO)-DWTRA(2,3,NCO-1)
         DWTRA(3,3,NCO+1)=DWTRA(3,3,NCO)+DWTRA(3,3,NCO)-DWTRA(3,3,NCO-1)

          DO ITIM0=1,NCO

         DWTRA(1,2,ITIM0)=DWTRA(1,1,ITIM0+1)-DWTRA(1,1,ITIM0)
         DWTRA(2,2,ITIM0)=DWTRA(2,1,ITIM0+1)-DWTRA(2,1,ITIM0)
         DWTRA(3,2,ITIM0)=DWTRA(3,1,ITIM0+1)-DWTRA(3,1,ITIM0)

         DWTRA(1,4,ITIM0)=DWTRA(1,3,ITIM0+1)-DWTRA(1,3,ITIM0)
         DWTRA(2,4,ITIM0)=DWTRA(2,3,ITIM0+1)-DWTRA(2,3,ITIM0)
         DWTRA(3,4,ITIM0)=DWTRA(3,3,ITIM0+1)-DWTRA(3,3,ITIM0)

         DWTRA(1,6,ITIM0)=DWTRA(1,5,ITIM0+1)-DWTRA(1,5,ITIM0)
         DWTRA(2,6,ITIM0)=DWTRA(2,5,ITIM0+1)-DWTRA(2,5,ITIM0)
         DWTRA(3,6,ITIM0)=DWTRA(3,5,ITIM0+1)-DWTRA(3,5,ITIM0)

          ENDDO   !NCO

          ICAL=1

      ENDIF !ICAL

      DO IOBSV=1,NOBSV

+SELF,IF=-NEWWAVE.
          SPECPOW(ISOUR,IOBSV)=0.D0
+SELF,IF=NEWWAVE.
          SPECPOW(ISOUR+NSOURCE*(IOBSV-1))=0.D0
+SELF.

+SELF,IF=-NOCMPLX.
          DARGEXPO(1,IOBSV)=(1.D0,0.D0)   !DEXPOMT
          DARGEXPO(2,IOBSV)=(1.D0,0.D0)   !DEXPDOMT
          DARGEXPO(3,IOBSV)=(0.D0,0.D0)   !(RARGOM,RARGOMO)
          DARGEXPO(4,IOBSV)=(1.D0,0.D0)   !EXPOM
          DARGEXPO(5,IOBSV)=(0.D0,0.D0)   !(ARG,ARG)
          DARGEXPO(6,IOBSV)=(1.D0,0.D0)   !DEXPOM
+SELF,IF=NOCMPLX.
            DARGEXPOR(1,IOBSV)=1.D0   !DEXPOMT
            DARGEXPOR(2,IOBSV)=1.D0   !DEXPDOMT
            DARGEXPOR(3,IOBSV)=0.D0   !(RARGOM,RARGOMO)
            DARGEXPOR(4,IOBSV)=1.D0   !EXPOM
            DARGEXPOR(5,IOBSV)=0.D0   !(ARG,ARG)
            DARGEXPOR(6,IOBSV)=1.D0   !DEXPOM
            DARGEXPOI(1,IOBSV)=0.D0   !DEXPOMT
            DARGEXPOI(2,IOBSV)=0.D0   !DEXPDOMT
            DARGEXPOI(3,IOBSV)=0.D0   !(RARGOM,RARGOMO)
            DARGEXPOI(4,IOBSV)=0.D0   !EXPOM
            DARGEXPOI(5,IOBSV)=0.D0   !(ARG,ARG)
            DARGEXPOI(6,IOBSV)=0.D0   !DEXPOM
+SELF.

      DO IFREQ=1,NFREQ

+SELF,IF=-NEWWAVE.
          AFREQ(1,IFREQ,IOBSV)=(0.D0,0.D0)
          AFREQ(2,IFREQ,IOBSV)=(0.D0,0.D0)
          AFREQ(3,IFREQ,IOBSV)=(0.D0,0.D0)
+SELF,IF=NEWWAVE,IF=-NOCMPLX.
            IFROB=IFREQ+NFREQ*(IOBSV-1)
            AFREQ(1,IFROB)=(0.,0.)
            AFREQ(2,IFROB)=(0.,0.)
            AFREQ(3,IFROB)=(0.,0.)
+SELF,IF=NEWWAVE,IF=NOCMPLX.
            IFROB=IFREQ+NFREQ*(IOBSV-1)
            AFREQR(1,IFROB)=0.D0
            AFREQR(2,IFROB)=0.D0
            AFREQR(3,IFROB)=0.D0
            AFREQI(1,IFROB)=0.D0
            AFREQI(2,IFROB)=0.D0
            AFREQI(3,IFROB)=0.D0
+SELF.

      ENDDO   !IFREQ
      ENDDO   !IOBSV

      TS=SOURCET(1,ISOUR)
      ITIM0=TS*DTIM01+1

      R0=OBSV(1,1)-SOURCEAO(1,1,ISOUR)
C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS  T=-R0*C1
      T=0.D0

      X1=SOURCEAO(1,1,ISOUR)

      IZTOT(ISOUR)=0

      XENDSOU=SOURCEEO(1,1,ISOUR)    !FINAL X

        X0=X1
        X2=X1
        X10=(XENDSOU-X0)/10.1D0

      DT0=(XENDSOU-X1)/NLPOIO/CLIGHT1
      DT=DT0
      DT2=DT/2.D0
      DT1=1.D0/DT

      IF (NROI.LT.0) THEN
          DROIX=(XENDSOU-X1)/(NROIA-1)
          DO IROI=1,NROIA
         ROIX(IROI)=X1+(IROI-1)*DROIX
         ROIP(IROI)=1.D0
          ENDDO
      ENDIF !

      ROIX(1)=ROIX(1)-1.D-6
      ROIX(NROIA)=ROIX(NROIA)+1.D-6

        IF (X1.LT.ROIX(1).OR.XENDSOU.GT.ROIX(NROIA)) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN SOUINTLIN: X OUTSIDE ROIS ***'
            WRITE(LUNGFO,*)'CHECK NAMELIST $ROIN'
            WRITE(LUNGFO,*)' *** PROGRAM WAVE ABORTED ***'
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN SOUINTLIN: X OUTSIDE ROIS ***'
            WRITE(6,*)'CHECK NAMELIST $ROIN'
            WRITE(6,*)' *** PROGRAM WAVE ABORTED ***'
            STOP
        ENDIF   !IROI

C- CHECK NUMBER OF STEPS

      IF (IWARN.EQ.0) THEN

          NUMSTEP0=NLPOIO/(SOURCEEO(1,1,NSOURCE)-SOURCEAO(1,1,1))

          DO IROI=1,NROIA-1

         NUMSTEP=(ROIX(IROI+1)-ROIX(IROI))*NUMSTEP0

         IF (NUMSTEP.LT.MYINUM) THEN

             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)'*** WARNING IN SOUINTLIN, ROI:',IROI
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
             WRITE(LUNGFO,*)'SIZE FOR TRAJECTORY!'
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &              'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
             WRITE(LUNGFO,*)
             WRITE(6,*)
             WRITE(6,*)'*** WARNING IN SOUINTLIN, ROI:',IROI
             WRITE(6,*)
             WRITE(6,*)'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
             WRITE(6,*)'SIZE FOR TRAJECTORY!'
             WRITE(6,*)
             WRITE(6,*)
     &              'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
             WRITE(6,*)

           ENDIF

          ENDDO   !IROI

         IWARN=1

      ENDIF

      IZAEHL=0 !LOOP COUNTER

C--- LOOP OVER STEPS

      DO IROI=1,NROIA
          IPOIROI(IROI)=0
      ENDDO

        IROI=1
        DO I=1,NROIA
            IF (X1.GE.ROIX(I)) THEN
                IROI=I
            ENDIF
        ENDDO   !IROI

        IX10=1

        IF (ISOUR.EQ.1) THEN
            WRITE(6,*)' '
            WRITE(6,*)
     &      '      counting from 1 to 10 for first source to show progress:'
            WRITE(6,*)' '
        ENDIF   !NSOURCE

        IZAEHL=0 !LOOP COUNTER

1000    IZAEHL=IZAEHL+1

        IF (ISOUR.EQ.1) THEN
            IF (X2.GE.X0+X10*IX10) THEN
         CALL date_and_time(dtday,dttime,dtzone,idatetime)
                WRITE(6,*)' ',IX10,' ',dttime(1:2),':',dttime(3:4),':',dttime(5:6)
                IX10=IX10+1
            ENDIF   !X1
        ENDIF   !NSOURCE

      IF (IROI.LE.NROIA) THEN
          IF (X2.GE.ROIX(IROI)) THEN
         DT=DT0/ROIP(IROI)
         DT2=DT/2.D0
         DT1=1.D0/DT
         IROI=IROI+1
          ENDIF   !IROI
      ENDIF !IROI

      IPOIROI(IROI)=IPOIROI(IROI)+1

      T=T+DT

      DDTS=DTIM01*(TS+DT-(ITIM0-1)*DTIM0)

      X2=DWTRA(1,1,ITIM0)+DWTRA(1,2,ITIM0)*DDTS
      Y2=DWTRA(2,1,ITIM0)+DWTRA(2,2,ITIM0)*DDTS
      Z2=DWTRA(3,1,ITIM0)+DWTRA(3,2,ITIM0)*DDTS

      BX=DWTRA(1,3,ITIM0)+DWTRA(1,4,ITIM0)*DDTS
      BY=DWTRA(2,3,ITIM0)+DWTRA(2,4,ITIM0)*DDTS
      BZ=DWTRA(3,3,ITIM0)+DWTRA(3,4,ITIM0)*DDTS

      BPX=DWTRA(1,5,ITIM0)+DWTRA(1,6,ITIM0)*DDTS
      BPY=DWTRA(2,5,ITIM0)+DWTRA(2,6,ITIM0)*DDTS
      BPZ=DWTRA(3,5,ITIM0)+DWTRA(3,6,ITIM0)*DDTS

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION {

C REAL PART OF INTEGRAND {

      DO IOBSV=1,NOBSV

          RX=OBSV(1,IOBSV)-X2
          RY=OBSV(2,IOBSV)-Y2
          RZ=OBSV(3,IOBSV)-Z2

          R=DSQRT(RX*RX+RY*RY+RZ*RZ)
          R1=1.D0/R

          RNX=RX*R1
          RNY=RY*R1
          RNZ=RZ*R1

C--- THE DISTANCE R IS INTRODUCED HERE EXPLICITLY (S. PROGRAM OF CHAOEN WANG

          DUM1=(1.D0-BX*RNX)-BY*RNY-BZ*RNZ
          DUM11=1.D0/DUM1
          DOM1=1.D0/(R*DUM1*DUM1)

          DTE=DT*DUM1

          RNBX=RNX-BX
          RNBY=RNY-BY
          RNBZ=RNZ-BZ

          PX=(RNBY*BPZ-RNBZ*BPY)
          PY=(RNBZ*BPX-RNBX*BPZ)
          PZ=(RNBX*BPY-RNBY*BPX)

            IF (IVELOFIELD.EQ.0) THEN
              DOM2=CGG*DOM1*R1
              RARG(1)=(RNY*PZ-RNZ*PY)*DOM1+(RNX-BX)*DOM2
              RARG(2)=(RNZ*PX-RNX*PZ)*DOM1+(RNY-BY)*DOM2
              RARG(3)=(RNX*PY-RNY*PX)*DOM1+(RNZ-BZ)*DOM2
            ELSE IF (IVELOFIELD.EQ.1) THEN
              RARG(1)=(RNY*PZ-RNZ*PY)*DOM1
              RARG(2)=(RNZ*PX-RNX*PZ)*DOM1
              RARG(3)=(RNX*PY-RNY*PX)*DOM1
            ELSE IF (IVELOFIELD.LT.0) THEN
              DOM2=CGG*DOM1*R1
              RARG(1)=(RNX-BX)*DOM2
              RARG(2)=(RNY-BY)*DOM2
              RARG(3)=(RNZ-BZ)*DOM2
            ELSE  !IVELOFIELD
              WRITE(6,*)
     &          '*** ERROR IN SOUINTLIN: BAD VALUE OF IVELOFIELD  ***'
              WRITE(6,*) '*** PROGRAM WAVE ABORTED  ***'
              STOP
            ENDIF !IVELOFIELD

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS      RARG(4)=T+R*C1

          TE=T+(R-R0)*C1
          RARG(4)=TE

          RARG(5)=
     &      (RARG(1)*RARG(1)+RARG(2)*RARG(2)+RARG(3)*RARG(3))*DUM11

        IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN
+SELF,IF=-NEWWAVE.
          SPECPOW(ISOUR,IOBSV)=SPECPOW(ISOUR,IOBSV)+RARG(5)*DT
+SELF,IF=NEWWAVE.
            ILIOB=ISOUR+NSOURCE*(IOBSV-1)
          SPECPOW(ILIOB)=SPECPOW(ILIOB)+RARG(5)*DT
+SELF.
        ENDIF  !XIANF

C REAL PART OF INTEGRAND }

C COMPLEX PART OF INTEGRAND {

C    ASSUMES FREQ(I+1)=2*FREQ(I)   FOR IFREQ2P=2
C    OR FREQ(I+1)=FREQ(I)+DELTA    FOR IFREQ2P>2

        RARGOM=RARG(4)*OM

+SELF,IF=-NOCMPLX.

        RARGOMO=DREAL(DARGEXPO(3,IOBSV))
        ARG=RARGOM-RARGOMO
        ARGO=DREAL(DARGEXPO(5,IOBSV))
        DARG=ARG-ARGO
        DARGEXPO(5,IOBSV)=DCMPLX(ARG,DIMAG(DARGEXPO(5,IOBSV)))

        IF (DABS(ARG).LT.0.1D0) THEN
           ARG2=ARG*ARG
           ARG4=ARG2*ARG2
           DEXPOMT=DCMPLX(1.D0-ARG2/2.D0+ARG4/24.D0,
     &                    ARG*(1.D0-ARG2/6.D0+ARG4/120.D0))
                IEXPOMT=1
        ELSEIF (DABS(DARG).LT.0.1D0) THEN
           DARG2=DARG*DARG
           DARG4=DARG2*DARG2
                DEXPOMT=DARGEXPO(1,IOBSV)*
     &            DCMPLX(1.D0-DARG2/2.D0+DARG4/24.D0,
     &            DARG*(1.D0-DARG2/6.D0+DARG4/120.D0))
                IEXPOMT=2
        ELSE
                DEXPOMT=CDEXP(DCMPLX(0.D0,ARG))
                IEXPOMT=3
        ENDIF

          IF(IFREQ2P.GT.2) THEN

          EXPOM=DARGEXPO(4,IOBSV)*DEXPOMT
          DARGEXPO(4,IOBSV)=EXPOM    !STORE IT HERE, WILL CHANGE FURTHER DOWN

          RARGDOM=RARG(4)*DOM
          RARGDOMO=DIMAG(DARGEXPO(3,IOBSV))
          ARG=RARGDOM-RARGDOMO
          ARG2=ARG*ARG
          ARGO=DIMAG(DARGEXPO(5,IOBSV))
          DARG=ARG-ARGO
          DARGEXPO(5,IOBSV)=DCMPLX(DREAL(DARGEXPO(5,IOBSV)),ARG)

          IF (DABS(ARG).LT.0.1D0) THEN
           ARG2=ARG*ARG
           ARG4=ARG2*ARG2
           DEXPDOMT=DCMPLX(1.D0-ARG2/2.D0+ARG4/24.D0,
     &                     ARG*(1.D0-ARG2/6.D0+ARG4/120.D0))
                IEXPDOMT=1
          ELSEIF (DABS(DARG).LT.0.1D0) THEN
           DARG2=DARG*DARG
           DARG4=DARG2*DARG2
                DEXPDOMT=DARGEXPO(2,IOBSV)*
     &            DCMPLX(1.D0-DARG2/2.D0+DARG4/24.D0,
     &            DARG*(1.D0-DARG2/6.D0+DARG4/120.D0))
                IEXPDOMT=2
          ELSE
           DEXPDOMT=CDEXP(DCMPLX(0.D0,ARG))
                IEXPDOMT=3
          ENDIF

          DEXPOM=DARGEXPO(6,IOBSV)*DEXPDOMT

        ELSEIF (IFREQ2P.GT.0) THEN

          EXPOM=DARGEXPO(4,IOBSV)*DEXPOMT
          DARGEXPO(4,IOBSV)=EXPOM    !STORE IT HERE, WILL CHANGE FURTHER DOWN

        ELSE   !IFREQ2P

          EXPOM=CDEXP(DCMPLX(0.D0,RARG(4)*OM))
          DARGEXPO(4,IOBSV)=EXPOM    !STORE IT HERE, WILL CHANGE FURTHER DOWN

        ENDIF  !IFREQ2P

+SELF,IF=NOCMPLX.

          EXPOMR=DARGEXPOR(4,IOBSV)*DEXPOMTR-DARGEXPOI(4,IOBSV)*DEXPOMTI
          EXPOMI=DARGEXPOI(4,IOBSV)*DEXPOMTR+DARGEXPOR(4,IOBSV)*DEXPOMTI
          DARGEXPOR(4,IOBSV)=EXPOMR    !STORE IT HERE, WILL CHANGE FURTHER DOWN
          DARGEXPOI(4,IOBSV)=EXPOMI    !STORE IT HERE, WILL CHANGE FURTHER DOWN

          RARGOMO=DARGEXPOR(3,IOBSV)
          ARG=RARGOM-RARGOMO
          ARGO=DARGEXPOR(5,IOBSV)
          DARG=ARG-ARGO
          DARGEXPOR(5,IOBSV)=ARG

          IF (DABS(ARG).LT.0.1D0) THEN
                  ARG2=ARG*ARG
                  ARG4=ARG2*ARG2
                  DEXPOMTR=1.D0-ARG2/2.D0+ARG4/24.D0
                  DEXPOMTI=ARG*(1.D0-ARG2/6.D0+ARG4/120.D0)
                  IEXPOMT=1
          ELSEIF (DABS(DARG).LT.0.1D0) THEN
                  DARG2=DARG*DARG
                  DARG4=DARG2*DARG2
                  DEXPOMTR=
     &            DARGEXPOR(1,IOBSV)*(1.D0-DARG2/2.D0+DARG4/24.D0)
     &           -DARGEXPOI(1,IOBSV)*DARG*(1.D0-DARG2/6.D0+DARG4/120.D0)
                  DEXPOMTI=
     &            DARGEXPOI(1,IOBSV)*(1.D0-DARG2/2.D0+DARG4/24.D0)
     &           +DARGEXPOR(1,IOBSV)*DARG*(1.D0-DARG2/6.D0+DARG4/120.D0)
                  IEXPOMT=2
          ELSE
                  DEXPOMTR=COS(ARG)
                  DEXPOMTI=SIN(ARG)
                  IEXPOMT=3
          ENDIF

          EXPOMR=DARGEXPOR(4,IOBSV)*DEXPOMTR-DARGEXPOI(4,IOBSV)*DEXPOMTI
          EXPOMI=DARGEXPOI(4,IOBSV)*DEXPOMTR+DARGEXPOR(4,IOBSV)*DEXPOMTI
          DARGEXPOR(4,IOBSV)=EXPOMR    !STORE IT HERE, WILL CHANGE FURTHER DOWN
          DARGEXPOI(4,IOBSV)=EXPOMI    !STORE IT HERE, WILL CHANGE FURTHER DOWN

          IF(IFREQ2P.GT.2) THEN

            RARGDOM=RARG(4)*DOM
            RARGDOMO=DARGEXPOI(3,IOBSV)
            ARG=RARGDOM-RARGDOMO
            ARG2=ARG*ARG
            ARGO=DARGEXPOI(5,IOBSV)
            DARG=ARG-ARGO
            DARGEXPOI(5,IOBSV)=ARG

            IF (DABS(ARG).LT.0.1D0) THEN
                  ARG2=ARG*ARG
                  ARG4=ARG2*ARG2
                  DEXPDOMTR=1.D0-ARG2/2.D0+ARG4/24.D0
                  DEXPDOMTI=ARG*(1.D0-ARG2/6.D0+ARG4/120.D0)
                  IEXPDOMT=1
            ELSEIF (DABS(DARG).LT.0.1D0) THEN
                  DARG2=DARG*DARG
                  DARG4=DARG2*DARG2
                  DEXPDOMTR=
     &            DARGEXPOR(2,IOBSV)*(1.D0-DARG2/2.D0+DARG4/24.D0)
     &           -DARGEXPOI(2,IOBSV)*DARG*(1.D0-DARG2/6.D0+DARG4/120.D0)
                  DEXPDOMTI=
     &            DARGEXPOI(2,IOBSV)*(1.D0-DARG2/2.D0+DARG4/24.D0)
     &           +DARGEXPOR(2,IOBSV)*DARG*(1.D0-DARG2/6.D0+DARG4/120.D0)
                  IEXPDOMT=2
            ELSE
                  DEXPDOMTR=COS(ARG)
                  DEXPDOMTI=SIN(ARG)
                  IEXPDOMT=3
            ENDIF

            DEXPOMR=DARGEXPOR(6,IOBSV)*DEXPDOMTR-DARGEXPOI(6,IOBSV)*DEXPDOMTI
            DEXPOMI=DARGEXPOI(6,IOBSV)*DEXPDOMTR+DARGEXPOR(6,IOBSV)*DEXPDOMTI

        ELSE   !IFREQ2P

                OMO=RARG(4)*OM
                EXPOMR=COS(OMO)
                EXPOMI=SIN(OMO)
              DARGEXPOR(4,IOBSV)=EXPOMR    !STORE IT HERE, WILL CHANGE FURTHER DOWN
              DARGEXPOI(4,IOBSV)=EXPOMI    !STORE IT HERE, WILL CHANGE FURTHER DOWN

          ENDIF !IFREQ2P

+SELF.

+SELF,IF=-NEWWAVE.
        IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN
             DO ICOMP=1,3
               AFREQ(ICOMP,1,IOBSV)=AFREQ(ICOMP,1,IOBSV)
     &         +DCMPLX(RARG(ICOMP))*EXPOM*REFLEC(ICOMP)*DT
+SELF,IF=NEWWAVE,IF=-NOCMPLX.
        IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN
                IFROB=1+NFREQ*(IOBSV-1)
             DO ICOMP=1,3
                AFREQ(ICOMP,IFROB)=AFREQ(ICOMP,IFROB)
     &          +DCMPLX(RARG(ICOMP))*EXPOM*REFLEC(ICOMP)*DT
+SELF,IF=NEWWAVE,IF=NOCMPLX.
        IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN
                IFROB=1+NFREQ*(IOBSV-1)
             DO ICOMP=1,3
                AFREQR(ICOMP,IFROB)=AFREQR(ICOMP,IFROB)+RARG(ICOMP)*DT*
     &         (EXPOMR*REFLECR(ICOMP)-EXPOMI*REFLECI(ICOMP))
                AFREQI(ICOMP,IFROB)=AFREQI(ICOMP,IFROB)+RARG(ICOMP)*DT*
     &         (EXPOMI*REFLECR(ICOMP)+EXPOMR*REFLECI(ICOMP))
+SELF.
             ENDDO
        ENDIF   !XIANF

      IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN
      IF (IWFILINT.NE.0) THEN
      IF (IWFILINT.EQ.-ISOUR) THEN

          IFREQ=1
          FILLT(1)=T
          FILLT(2)=X2
          FILLT(3)=Y2
          FILLT(4)=Z2
          FILLT(5)=RARG(1)
          FILLT(6)=RARG(2)
          FILLT(7)=RARG(3)
          FILLT(8)=RARG(4)
          FILLT(9)=MIN(RARG(5),1.D30)
+SELF,IF=-NOCMPLX.
            FILLT(10)=DREAL(EXPOM)
            FILLT(11)=DIMAG(EXPOM)
+SELF,IF=NOCMPLX.
            FILLT(10)=EXPOMR
            FILLT(11)=EXPOMI
+SELF.
          FILLT(12)=IROI-1
          FILLT(13)=IOBSV
          FILLT(14)=IFREQ
          FILLT(15)=OBSV(2,IOBSV)
          FILLT(16)=OBSV(3,IOBSV)
          FILLT(17)=DUM1
          FILLT(18)=RARGOM-RARGOMO
          FILLT(19)=IEXPOMT
          FILLT(20)=IEXPDOMT
+SELF,IF=-NEWWAVE.
          FILLT(21)=
     &        DREAL(
     &          AFREQ(1,IFREQ,IOBSV)*CONJG(AFREQ(1,IFREQ,IOBSV))
     &         +AFREQ(2,IFREQ,IOBSV)*CONJG(AFREQ(2,IFREQ,IOBSV))
     &         +AFREQ(3,IFREQ,IOBSV)*CONJG(AFREQ(3,IFREQ,IOBSV))
     &         )*SPECNOR
+SELF,IF=NEWWAVE,IF=-NOCMPLX.
                IFROB=IFREQ+NFREQ*(IOBSV-1)
            FILLT(21)=
     &        DREAL(
     &          AFREQ(1,IFROB)*dCONJG(AFREQ(1,IFROB))
     &         +AFREQ(2,IFROB)*dCONJG(AFREQ(2,IFROB))
     &         +AFREQ(3,IFROB)*dCONJG(AFREQ(3,IFROB))
     &         )*SPECNOR
+SELF.
+SELF,IF=NEWWAVE,IF=NOCMPLX.
                IFROB=IFREQ+NFREQ*(IOBSV-1)
            FILLT(21)=
     &         (
     &          AFREQR(1,IFROB)*AFREQR(1,IFROB)
     &         +AFREQI(1,IFROB)*AFREQI(1,IFROB)
     &         +AFREQR(2,IFROB)*AFREQR(2,IFROB)
     &         +AFREQI(2,IFROB)*AFREQI(2,IFROB)
     &         +AFREQR(3,IFROB)*AFREQR(3,IFROB)
     &         +AFREQI(3,IFROB)*AFREQI(3,IFROB)
     &         )*SPECNOR
+SELF.
          FILLT(22)=TE
          CALL hfm(NIDSOURCE,FILLT)

      ELSEIF (ISOUR.EQ.IWFILINT.AND.IOBSV.EQ.1) THEN


+SELF,IF=-NOCMPLX.
         WRITE(LUNINT,*) X2
     &    ,(SNGL(RARG(1)),IC=1,3),SNGL(RARG(4)*OM),SNGL(RARG(5))
     &    ,SNGL(DREAL(EXPOM)),SNGL(DIMAG(EXPOM))
     &    ,SNGL(DREAL(RARG(1)*EXPOM)),SNGL(DIMAG(RARG(1)*EXPOM))
     &    ,SNGL(DREAL(RARG(2)*EXPOM)),SNGL(DIMAG(RARG(2)*EXPOM))
     &    ,SNGL(DREAL(RARG(3)*EXPOM)),SNGL(DIMAG(RARG(3)*EXPOM))
+SELF,IF=NOCMPLX.
         WRITE(LUNINT,*) X2
     &    ,(SNGL(RARG(1)),IC=1,3),SNGL(RARG(4)*OM),SNGL(RARG(5))
     &    ,SNGL(EXPOMR),SNGL(EXPOMI)
     &    ,SNGL(RARG(1)*EXPOMR),SNGL(RARG(1)*EXPOMI)
     &    ,SNGL(RARG(2)*EXPOMR),SNGL(RARG(2)*EXPOMI)
     &    ,SNGL(RARG(3)*EXPOMR),SNGL(RARG(3)*EXPOMI)
+SELF.

      ENDIF
      ENDIF
      ENDIF   !XIANF

C--- LOOP OVER ALL FREQUENCES

          DO IFREQ=2,NFREQ

+SELF,IF=-NOCMPLX.

          IF    (IFREQ2P.GT.2) THEN

         EXPOM=EXPOM*DEXPOM

          ELSEIF(IFREQ2P.EQ.2) THEN

         EXPOM=EXPOM*EXPOM

          ELSE

         EXPOM=CDEXP(DCMPLX(0.D0,RARG(4)*FREQ(IFREQ)/HBAREV1))

          ENDIF


+SELF,IF=NOCMPLX.

            IF    (IFREQ2P.GT.2) THEN

                COMR=EXPOMR*DEXPOMR-EXPOMI*DEXPOMI
                COMI=EXPOMI*DEXPOMR+EXPOMR*DEXPOMI
                EXPOMR=COMR
                EXPOMI=COMI

            ELSEIF(IFREQ2P.EQ.2) THEN

                COMR=EXPOMR*EXPOMR-EXPOMI*EXPOMI
                COMI=EXPOMI*EXPOMR+EXPOMR*EXPOMI
                EXPOMR=COMR
                EXPOMI=COMI

            ELSE

                OMO=RARG(4)*FREQ(IFREQ)/HBAREV1
                EXPOMR=COS(OMO)
                EXPOMI=SIN(OMO)

            ENDIF

+SELF.

+SELF,IF=-NEWWAVE.
          IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN
         DO ICOMP=1,3
           AFREQ(ICOMP,IFREQ,IOBSV)=AFREQ(ICOMP,IFREQ,IOBSV)
     &           +DCMPLX(RARG(ICOMP))*EXPOM*REFLEC(ICOMP)*DT
+SELF,IF=NEWWAVE,IF=-NOCMPLX.
          IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN
                IFROB=IFREQ+NFREQ*(IOBSV-1)
         DO ICOMP=1,3
                AFREQ(ICOMP,IFROB)=AFREQ(ICOMP,IFROB)
     &          +DCMPLX(RARG(ICOMP))*EXPOM*REFLEC(ICOMP)*DT
+SELF,IF=NEWWAVE,IF=NOCMPLX.
          IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN
                IFROB=IFREQ+NFREQ*(IOBSV-1)
         DO ICOMP=1,3
                AFREQR(ICOMP,IFROB)=AFREQR(ICOMP,IFROB)+RARG(ICOMP)*DT*
     &         (EXPOMR*REFLECR(ICOMP)-EXPOMI*REFLECI(ICOMP))
                AFREQI(ICOMP,IFROB)=AFREQI(ICOMP,IFROB)+RARG(ICOMP)*DT*
     &         (EXPOMI*REFLECR(ICOMP)+EXPOMR*REFLECI(ICOMP))
+SELF.
         ENDDO

         IF (IWFILINT.EQ.-ISOUR) THEN

             FILLT(1)=T
             FILLT(2)=X2
             FILLT(3)=Y2
             FILLT(4)=Z2
             FILLT(5)=RARG(1)
             FILLT(6)=RARG(2)
             FILLT(7)=RARG(3)
             FILLT(8)=RARG(4)
             FILLT(9)=MIN(RARG(5),1.D30)
+SELF,IF=-NOCMPLX.
                  FILLT(10)=DREAL(EXPOM)
                  FILLT(11)=DIMAG(EXPOM)
+SELF,IF=NOCMPLX.
                  FILLT(10)=EXPOMR
                  FILLT(11)=EXPOMI
+SELF.
             FILLT(12)=IROI-1
             FILLT(13)=IOBSV
             FILLT(14)=IFREQ
             FILLT(15)=OBSV(2,IOBSV)
             FILLT(16)=OBSV(3,IOBSV)
             FILLT(17)=DUM1
             FILLT(18)=RARGOM-RARGOMO
             FILLT(19)=IEXPOMT
             FILLT(20)=IEXPDOMT
+SELF,IF=-NEWWAVE.
             FILLT(21)=
     &        DREAL(
     &          AFREQ(1,IFREQ,IOBSV)*dCONJG(AFREQ(1,IFREQ,IOBSV))
     &         +AFREQ(2,IFREQ,IOBSV)*dCONJG(AFREQ(2,IFREQ,IOBSV))
     &         +AFREQ(3,IFREQ,IOBSV)*dCONJG(AFREQ(3,IFREQ,IOBSV))
     &         )*SPECNOR
+SELF,IF=NEWWAVE,IF=-NOCMPLX.
                IFROB=IFREQ+NFREQ*(IOBSV-1)
            FILLT(21)=
     &        DREAL(
     &          AFREQ(1,IFROB)*dCONJG(AFREQ(1,IFROB))
     &         +AFREQ(2,IFROB)*dCONJG(AFREQ(2,IFROB))
     &         +AFREQ(3,IFROB)*dCONJG(AFREQ(3,IFROB))
     &         )*SPECNOR
+SELF.
+SELF,IF=NEWWAVE,IF=NOCMPLX.
                IFROB=IFREQ+NFREQ*(IOBSV-1)
            FILLT(21)=
     &         (
     &          AFREQR(1,IFROB)*AFREQR(1,IFROB)
     &         +AFREQI(1,IFROB)*AFREQI(1,IFROB)
     &         +AFREQR(2,IFROB)*AFREQR(2,IFROB)
     &         +AFREQI(2,IFROB)*AFREQI(2,IFROB)
     &         +AFREQR(3,IFROB)*AFREQR(3,IFROB)
     &         +AFREQI(3,IFROB)*AFREQI(3,IFROB)
     &         )*SPECNOR
+SELF.
             FILLT(22)=TE
             CALL hfm(NIDSOURCE,FILLT)

         ENDIF
          ENDIF   !XIANF

          ENDDO   !LOOP OVER ALL FREQUENCES


C COMPLEX PART OF INTEGRAND }

+SELF,IF=-NOCMPLX.
          DARGEXPO(1,IOBSV)=DEXPOMT
          DARGEXPO(2,IOBSV)=DEXPDOMT
          DARGEXPO(3,IOBSV)=DCMPLX(RARGOM,RARGDOM)
          DARGEXPO(6,IOBSV)=DEXPOM
+SELF,IF=NOCMPLX.
          DARGEXPOR(1,IOBSV)=DEXPOMTR
          DARGEXPOR(2,IOBSV)=DEXPDOMTR
          DARGEXPOR(3,IOBSV)=RARGOM
          DARGEXPOR(6,IOBSV)=DEXPOMR
          DARGEXPOI(1,IOBSV)=DEXPOMTI
          DARGEXPOI(2,IOBSV)=DEXPDOMTI
          DARGEXPOI(3,IOBSV)=RARGDOM
          DARGEXPOI(6,IOBSV)=DEXPOMI
+SELF.

      ENDDO !IOBSV

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION }

      TS=TS+DT
      ITIM0=TS*DTIM01+1

C--- END OF LOOP OVER TIME STEPS

      IF (X2.LT.XENDSOU)  GOTO 1000

C- STORE NUMBER OF POINTS FOR INTEGRATION

      IPOISOU(ISOUR)=IZAEHL
      IZTOT(ISOUR)=IZTOT(ISOUR)+IZAEHL

      DO IOBSV=1,NOBSV
      DO IFREQ=1,NFREQ

+SELF,IF=-NEWWAVE.
          IF (IPOLA.EQ.0) THEN

            SPEC(ISOUR,IOBSV,IFREQ)=
     &        DREAL(
     &          AFREQ(1,IFREQ,IOBSV)*CONJG(AFREQ(1,IFREQ,IOBSV))
     &         +AFREQ(2,IFREQ,IOBSV)*CONJG(AFREQ(2,IFREQ,IOBSV))
     &         +AFREQ(3,IFREQ,IOBSV)*CONJG(AFREQ(3,IFREQ,IOBSV))
C     &          ATEST(1,IFREQ,IOBSV)*CONJG(ATEST(1,IFREQ,IOBSV))
C     &         +ATEST(2,IFREQ,IOBSV)*CONJG(ATEST(2,IFREQ,IOBSV))
C     &         +ATEST(3,IFREQ,IOBSV)*CONJG(ATEST(3,IFREQ,IOBSV))
     &         )*SPECNOR

            REAIMA(1,1,IOBSV,IFREQ)=REAIMA(1,1,IOBSV,IFREQ)+
     &        DREAL(AFREQ(1,IFREQ,IOBSV))
            REAIMA(2,1,IOBSV,IFREQ)=REAIMA(2,1,IOBSV,IFREQ)+
     &        DREAL(AFREQ(2,IFREQ,IOBSV))
            REAIMA(3,1,IOBSV,IFREQ)=REAIMA(3,1,IOBSV,IFREQ)+
     &        DREAL(AFREQ(3,IFREQ,IOBSV))

            REAIMA(1,2,IOBSV,IFREQ)=REAIMA(1,2,IOBSV,IFREQ)+
     &        DIMAG(AFREQ(1,IFREQ,IOBSV))
            REAIMA(2,2,IOBSV,IFREQ)=REAIMA(2,2,IOBSV,IFREQ)+
     &        DIMAG(AFREQ(2,IFREQ,IOBSV))
            REAIMA(3,2,IOBSV,IFREQ)=REAIMA(3,2,IOBSV,IFREQ)+
     &        DIMAG(AFREQ(3,IFREQ,IOBSV))

          ELSE    !IPOLA

          APOL=
     &          AFREQ(1,IFREQ,IOBSV)*CONJG(VPOLA(1))
     &         +AFREQ(2,IFREQ,IOBSV)*CONJG(VPOLA(2))
     &         +AFREQ(3,IFREQ,IOBSV)*CONJG(VPOLA(3))

            SPEC(ISOUR,IOBSV,IFREQ)=
     &        DREAL(APOL*CONJG(APOL))*SPECNOR
            REAIMA(1,1,IOBSV,IFREQ)=REAIMA(1,1,IOBSV,IFREQ)+
     &        DREAL(AFREQ(1,IFREQ,IOBSV))
            REAIMA(2,1,IOBSV,IFREQ)=REAIMA(2,1,IOBSV,IFREQ)+
     &        DREAL(AFREQ(2,IFREQ,IOBSV))
            REAIMA(3,1,IOBSV,IFREQ)=REAIMA(3,1,IOBSV,IFREQ)+
     &        DREAL(AFREQ(3,IFREQ,IOBSV))

            REAIMA(1,2,IOBSV,IFREQ)=REAIMA(1,2,IOBSV,IFREQ)+
     &        DIMAG(AFREQ(1,IFREQ,IOBSV))
            REAIMA(2,2,IOBSV,IFREQ)=REAIMA(2,2,IOBSV,IFREQ)+
     &        DIMAG(AFREQ(2,IFREQ,IOBSV))
            REAIMA(3,2,IOBSV,IFREQ)=REAIMA(3,2,IOBSV,IFREQ)+
     &        DIMAG(AFREQ(3,IFREQ,IOBSV))
          ENDIF   !IPOLA

      IF (ISTOKES.NE.0) THEN

          APOLH=
     &          AFREQ(1,IFREQ,IOBSV)*CONJG(VSTOKES(1,1))
     &         +AFREQ(2,IFREQ,IOBSV)*CONJG(VSTOKES(1,2))
     &         +AFREQ(3,IFREQ,IOBSV)*CONJG(VSTOKES(1,3))

          APOLR=
     &          AFREQ(1,IFREQ,IOBSV)*CONJG(VSTOKES(2,1))
     &         +AFREQ(2,IFREQ,IOBSV)*CONJG(VSTOKES(2,2))
     &         +AFREQ(3,IFREQ,IOBSV)*CONJG(VSTOKES(2,3))

          APOLL=
     &          AFREQ(1,IFREQ,IOBSV)*CONJG(VSTOKES(3,1))
     &         +AFREQ(2,IFREQ,IOBSV)*CONJG(VSTOKES(3,2))
     &         +AFREQ(3,IFREQ,IOBSV)*CONJG(VSTOKES(3,3))

          APOL45=
     &          AFREQ(1,IFREQ,IOBSV)*CONJG(VSTOKES(4,1))
     &         +AFREQ(2,IFREQ,IOBSV)*CONJG(VSTOKES(4,2))
     &         +AFREQ(3,IFREQ,IOBSV)*CONJG(VSTOKES(4,3))

            STOK1=
     &        REAL(APOLR*CONJG(APOLR))+
     &        REAL(APOLL*CONJG(APOLL))

            STOK2=-STOK1+
     &        2.*REAL(APOLH*CONJG(APOLH))

            STOK3=
     &        2.*REAL(APOL45*CONJG(APOL45))-
     &        STOK1

            STOK4=
     &        REAL(APOLR*CONJG(APOLR))-
     &        REAL(APOLL*CONJG(APOLL))


            STOKES(1,IOBSV,IFREQ)=STOKES(1,IOBSV,IFREQ)+
     &                          STOK1*SPECNOR

            STOKES(2,IOBSV,IFREQ)=STOKES(2,IOBSV,IFREQ)+
     &                          STOK2*SPECNOR

            STOKES(3,IOBSV,IFREQ)=STOKES(3,IOBSV,IFREQ)+
     &                          STOK3*SPECNOR

            STOKES(4,IOBSV,IFREQ)=STOKES(4,IOBSV,IFREQ)+
     &                          STOK4*SPECNOR

      ENDIF !ISTOKES

      ENDDO !IFREQ

        SPECPOW(ISOUR,IOBSV)=SPECPOW(ISOUR,IOBSV)
     &                *ECHARGE1/16.D0/PI1/PI1/EPS01/CLIGHT1
     &                *DMYCUR     !NUMBER OF e-

      ENDDO !IOBSV

+SELF,IF=NEWWAVE,IF=-NOCMPLX.

          ILIOBFR=ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1))
          IFROB=IFREQ+NFREQ*(IOBSV-1)
          IOBFR=IOBSV+NOBSV*(IFREQ-1)

          IF (IPOLA.EQ.0) THEN

            SPEC(ILIOBFR)=
     &        DREAL(
     &          AFREQ(1,IFROB)*CONJG(AFREQ(1,IFROB))
     &         +AFREQ(2,IFROB)*CONJG(AFREQ(2,IFROB))
     &         +AFREQ(3,IFROB)*CONJG(AFREQ(3,IFROB))
     &         )*SPECNOR

            REAIMA(1,1,IOBFR)=REAIMA(1,1,IOBFR)+
     &        DREAL(AFREQ(1,IFROB))
            REAIMA(2,1,IOBFR)=REAIMA(2,1,IOBFR)+
     &        DREAL(AFREQ(2,IFROB))
            REAIMA(3,1,IOBFR)=REAIMA(3,1,IOBFR)+
     &        DREAL(AFREQ(3,IFROB))

            REAIMA(1,2,IOBFR)=REAIMA(1,2,IOBFR)+
     &        DIMAG(AFREQ(1,IFROB))
            REAIMA(2,2,IOBFR)=REAIMA(2,2,IOBFR)+
     &        DIMAG(AFREQ(2,IFROB))
            REAIMA(3,2,IOBFR)=REAIMA(3,2,IOBFR)+
     &        DIMAG(AFREQ(3,IFROB))

          ELSE    !IPOLA

          APOL=
     &          AFREQ(1,IFROB)*CONJG(VPOLA(1))
     &         +AFREQ(2,IFROB)*CONJG(VPOLA(2))
     &         +AFREQ(3,IFROB)*CONJG(VPOLA(3))

            SPEC(ILIOBFR)=
     &        DREAL(APOL*CONJG(APOL))*SPECNOR
            REAIMA(1,1,IOBFR)=REAIMA(1,1,IOBFR)+
     &        DREAL(AFREQ(1,IFROB))
            REAIMA(2,1,IOBFR)=REAIMA(2,1,IOBFR)+
     &        DREAL(AFREQ(2,IFROB))
            REAIMA(3,1,IOBFR)=REAIMA(3,1,IOBFR)+
     &        DREAL(AFREQ(3,IFROB))

            REAIMA(1,2,IOBFR)=REAIMA(1,2,IOBFR)+
     &        DIMAG(AFREQ(1,IFROB))
            REAIMA(2,2,IOBFR)=REAIMA(2,2,IOBFR)+
     &        DIMAG(AFREQ(2,IFROB))
            REAIMA(3,2,IOBFR)=REAIMA(3,2,IOBFR)+
     &        DIMAG(AFREQ(3,IFROB))

          ENDIF   !IPOLA

      IF (ISTOKES.NE.0) THEN

          APOLH=
     &          AFREQ(1,IFROB)*CONJG(VSTOKES(1,1))
     &         +AFREQ(2,IFROB)*CONJG(VSTOKES(1,2))
     &         +AFREQ(3,IFROB)*CONJG(VSTOKES(1,3))

          APOLR=
     &          AFREQ(1,IFROB)*CONJG(VSTOKES(2,1))
     &         +AFREQ(2,IFROB)*CONJG(VSTOKES(2,2))
     &         +AFREQ(3,IFROB)*CONJG(VSTOKES(2,3))

          APOLL=
     &          AFREQ(1,IFROB)*CONJG(VSTOKES(3,1))
     &         +AFREQ(2,IFROB)*CONJG(VSTOKES(3,2))
     &         +AFREQ(3,IFROB)*CONJG(VSTOKES(3,3))

          APOL45=
     &          AFREQ(1,IFROB)*CONJG(VSTOKES(4,1))
     &         +AFREQ(2,IFROB)*CONJG(VSTOKES(4,2))
     &         +AFREQ(3,IFROB)*CONJG(VSTOKES(4,3))

            STOK1=
     &        REAL(APOLR*CONJG(APOLR))+
     &        REAL(APOLL*CONJG(APOLL))

            STOK2=-STOK1+
     &        2.*REAL(APOLH*CONJG(APOLH))

             STOK3=
     &        2.*REAL(APOL45*CONJG(APOL45))-
     &        STOK1

            STOK4=
     &        REAL(APOLR*CONJG(APOLR))-
     &        REAL(APOLL*CONJG(APOLL))


            STOKES(1,IOBFR)=STOKES(1,IOBFR)+
     &                          STOK1*SPECNOR

            STOKES(2,IOBFR)=STOKES(2,IOBFR)+
     &                          STOK2*SPECNOR

            STOKES(3,IOBFR)=STOKES(3,IOBFR)+
     &                          STOK3*SPECNOR

            STOKES(4,IOBFR)=STOKES(4,IOBFR)+
     &                          STOK4*SPECNOR

      ENDIF !ISTOKES

        ENDDO !IFREQ

        ILIOB=ISOUR+NSOURCE*(IOBSV-1)
        SPECPOW(ILIOB)=SPECPOW(ILIOB)
     &                *ECHARGE1/16.D0/PI1/PI1/EPS01/CLIGHT1
     &                *DMYCUR     !NUMBER OF e-

        ENDDO !IOBSV

+SELF,IF=NEWWAVE,IF=NOCMPLX.

          ILIOBFR=ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1))
          IFROB=IFREQ+NFREQ*(IOBSV-1)
          IOBFR=IOBSV+NOBSV*(IFREQ-1)

          IF (IPOLA.EQ.0) THEN

            SPEC(ILIOBFR)=
     &         (AFREQR(1,IFROB)*AFREQR(1,IFROB)
     &         +AFREQI(1,IFROB)*AFREQI(1,IFROB)
     &         +AFREQR(2,IFROB)*AFREQR(2,IFROB)
     &         +AFREQI(2,IFROB)*AFREQI(2,IFROB)
     &         +AFREQR(3,IFROB)*AFREQR(3,IFROB)
     &         +AFREQI(3,IFROB)*AFREQI(3,IFROB)
     &         )*SPECNOR

            REAIMA(1,1,IOBFR)=REAIMA(1,1,IOBFR)+AFREQR(1,IFROB)
            REAIMA(2,1,IOBFR)=REAIMA(2,1,IOBFR)+AFREQR(2,IFROB)
            REAIMA(3,1,IOBFR)=REAIMA(3,1,IOBFR)+AFREQR(3,IFROB)

            REAIMA(1,2,IOBFR)=REAIMA(1,2,IOBFR)+AFREQI(1,IFROB)
            REAIMA(2,2,IOBFR)=REAIMA(2,2,IOBFR)+AFREQI(2,IFROB)
            REAIMA(3,2,IOBFR)=REAIMA(3,2,IOBFR)+AFREQI(3,IFROB)

          ELSE    !IPOLA

          APOLR=
     &          AFREQR(1,IFROB)*VPOLAR(1)+AFREQI(1,IFROB)*VPOLAI(1)
     &         +AFREQR(2,IFROB)*VPOLAR(2)+AFREQI(1,IFROB)*VPOLAI(2)
     &         +AFREQR(3,IFROB)*VPOLAR(3)+AFREQI(1,IFROB)*VPOLAI(3)
          APOLI=
     &          AFREQI(1,IFROB)*VPOLAR(1)-AFREQR(1,IFROB)*VPOLAI(1)
     &         +AFREQI(2,IFROB)*VPOLAR(2)-AFREQR(1,IFROB)*VPOLAI(2)
     &         +AFREQI(3,IFROB)*VPOLAR(3)-AFREQR(1,IFROB)*VPOLAI(3)

            SPEC(ILIOBFR)=(APOLR*APOLR+APOLI*APOLI)*SPECNOR

            REAIMA(1,1,IOBFR)=REAIMA(1,1,IOBFR)+AFREQR(1,IFROB)
            REAIMA(2,1,IOBFR)=REAIMA(2,1,IOBFR)+AFREQR(2,IFROB)
            REAIMA(3,1,IOBFR)=REAIMA(3,1,IOBFR)+AFREQR(3,IFROB)

            REAIMA(1,2,IOBFR)=REAIMA(1,2,IOBFR)+AFREQI(1,IFROB)
            REAIMA(2,2,IOBFR)=REAIMA(2,2,IOBFR)+AFREQI(2,IFROB)
            REAIMA(3,2,IOBFR)=REAIMA(3,2,IOBFR)+AFREQI(3,IFROB)

          ENDIF   !IPOLA


      IF (ISTOKES.NE.0) THEN

          APOLHR=
     &          AFREQR(1,IFROB)*VSTOKESR(1,1)+AFREQI(1,IFROB)*VSTOKESI(1,1)
     &         +AFREQR(2,IFROB)*VSTOKESR(1,2)+AFREQI(2,IFROB)*VSTOKESI(1,2)
     &         +AFREQR(3,IFROB)*VSTOKESR(1,3)+AFREQI(3,IFROB)*VSTOKESI(1,3)

          APOLHI=
     &          AFREQI(1,IFROB)*VSTOKESR(1,1)-AFREQR(1,IFROB)*VSTOKESI(1,1)
     &         +AFREQI(2,IFROB)*VSTOKESR(1,2)-AFREQR(2,IFROB)*VSTOKESI(1,2)
     &         +AFREQI(3,IFROB)*VSTOKESR(1,3)-AFREQR(3,IFROB)*VSTOKESI(1,3)

          APOLRR=
     &          AFREQR(1,IFROB)*VSTOKESR(2,1)+AFREQI(1,IFROB)*VSTOKESI(2,1)
     &         +AFREQR(2,IFROB)*VSTOKESR(2,2)+AFREQI(2,IFROB)*VSTOKESI(2,2)
     &         +AFREQR(3,IFROB)*VSTOKESR(2,3)+AFREQI(3,IFROB)*VSTOKESI(2,3)


          APOLRI=
     &          AFREQI(1,IFROB)*VSTOKESR(2,1)-AFREQR(1,IFROB)*VSTOKESI(2,1)
     &         +AFREQI(2,IFROB)*VSTOKESR(2,2)-AFREQR(2,IFROB)*VSTOKESI(2,2)
     &         +AFREQI(3,IFROB)*VSTOKESR(2,3)-AFREQR(3,IFROB)*VSTOKESI(2,3)

          APOLLR=
     &          AFREQR(1,IFROB)*VSTOKESR(3,1)+AFREQI(1,IFROB)*VSTOKESI(3,1)
     &         +AFREQR(2,IFROB)*VSTOKESR(3,2)+AFREQI(2,IFROB)*VSTOKESI(3,2)
     &         +AFREQR(3,IFROB)*VSTOKESR(3,3)+AFREQI(3,IFROB)*VSTOKESI(3,3)

          APOLLI=
     &          AFREQI(1,IFROB)*VSTOKESR(3,1)-AFREQR(1,IFROB)*VSTOKESI(3,1)
     &         +AFREQI(2,IFROB)*VSTOKESR(3,2)-AFREQR(2,IFROB)*VSTOKESI(3,2)
     &         +AFREQI(3,IFROB)*VSTOKESR(3,3)-AFREQR(3,IFROB)*VSTOKESI(3,3)

          APOL45R=
     &          AFREQR(1,IFROB)*VSTOKESR(3,1)+AFREQI(1,IFROB)*VSTOKESI(3,1)
     &         +AFREQR(2,IFROB)*VSTOKESR(3,2)+AFREQI(2,IFROB)*VSTOKESI(3,2)
     &         +AFREQR(3,IFROB)*VSTOKESR(3,3)+AFREQI(3,IFROB)*VSTOKESI(3,3)

          APOL45I=
     &          AFREQI(1,IFROB)*VSTOKESR(3,1)-AFREQR(1,IFROB)*VSTOKESI(3,1)
     &         +AFREQI(2,IFROB)*VSTOKESR(3,2)-AFREQR(2,IFROB)*VSTOKESI(3,2)
     &         +AFREQI(3,IFROB)*VSTOKESR(3,3)-AFREQR(3,IFROB)*VSTOKESI(3,3)

            STOK1=
     &        APOLRR*APOLRR+APOLRI*APOLRI+
     &        APOLLR*APOLLR+APOLLI*APOLLI

            STOK2=-STOK1+2.*
     &        APOLHR*APOLHR+APOLHI*APOLHI

            STOK3=2.*
     &        APOL45R*APOL45R+APOL45I*APOL45I+
     &        STOK1

            STOK4=
     &        APOLRR*APOLRR+APOLRI*APOLRI-
     &        APOLLR*APOLLR+APOLLI*APOLLI

            STOKES(1,IOBFR)=STOKES(1,IOBFR)+
     &                          STOK1*SPECNOR

            STOKES(2,IOBFR)=STOKES(2,IOBFR)+
     &                          STOK2*SPECNOR

            STOKES(3,IOBFR)=STOKES(3,IOBFR)+
     &                          STOK3*SPECNOR

            STOKES(4,IOBFR)=STOKES(4,IOBFR)+
     &                          STOK4*SPECNOR

      ENDIF !ISTOKES

        ENDDO !IFREQ

        ILIOB=ISOUR+NSOURCE*(IOBSV-1)
        SPECPOW(ILIOB)=SPECPOW(ILIOB)
     &                *ECHARGE1/16.D0/PI1/PI1/EPS01/CLIGHT1
     &                *DMYCUR     !NUMBER OF e-

        ENDDO !IOBSV
+SELF.
      IF (IWFILINT.LT.0.AND.ISOUR.EQ.NSOURCE) THEN
                CALL MHROUT(NIDSOURCE,ICYCLE,' ')
                CALL hdeletm(NIDSOURCE)
      ENDIF

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       SR SOUINTLIN, SOURCE:', ISOUR
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       ROIs:'
      WRITE(LUNGFO,*)

      DO IROI=1,NROIA
               WRITE(LUNGFO,*)
     &           IROI,SNGL(ROIX(IROI)),SNGL(ROIP(IROI)),IPOIROI(IROI+1)
      ENDDO
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       TOTAL NUMBER OF STEPS:',IZAEHL
      WRITE(LUNGFO,*)'       (controlled by NLPOI and namelist $ROIN)'

        IF (ISOUR.EQ.1.and.nsource.gt.1) THEN
                WRITE(6,*)' '
                WRITE(6,*)' '
                WRITE(6,*)' sources treated so far:'
                WRITE(6,*)' '
      ENDIF

+SELF,IF=F90.
      IF (ISOUR.EQ.NSOURCE) THEN
          DEALLOCATE(DWTRA)
      ENDIF
+SELF.

      RETURN
      END
+DECK,SOUINTLINS.
*CMZ :  4.00/14 22/12/2021  18.07.25  by  Michael Scheer
*CMZ :  3.08/01 02/04/2019  15.33.15  by  Michael Scheer
*CMZ :  3.02/03 06/11/2014  14.24.54  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  14.04.56  by  Michael Scheer
*CMZ :  2.68/05 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  09.55.58  by  Michael Scheer
*CMZ :  2.66/04 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.66/03 12/11/2009  16.27.11  by  Michael Scheer
*CMZ :  2.50/00 28/10/2009  15.52.52  by  Michael Scheer
*CMZ :  2.41/10 16/04/2004  09.24.47  by  Michael Scheer
*CMZ :  2.41/09 14/08/2002  17.12.46  by  Michael Scheer
*CMZ :  2.20/04 06/03/2001  17.42.06  by  Michael Scheer
*CMZ :  2.20/03 22/02/2001  18.37.06  by  Michael Scheer
*CMZ :  2.20/01 11/02/2001  19.28.38  by  Michael Scheer
*CMZ :  2.16/08 31/10/2000  14.40.08  by  Michael Scheer
*CMZ :  2.16/07 21/09/2000  11.21.00  by  Michael Scheer
*CMZ :  2.16/06 28/08/2000  14.39.42  by  Michael Scheer
*CMZ :  2.16/05 02/08/2000  13.53.32  by  Michael Scheer
*CMZ :  2.16/04 19/06/2000  14.27.19  by  Michael Scheer
*CMZ :  2.16/03 16/06/2000  14.35.02  by  Michael Scheer
*CMZ :  2.15/00 05/05/2000  19.25.24  by  Michael Scheer
*CMZ :  2.14/02 26/04/2000  16.40.34  by  Michael Scheer
*CMZ :  2.13/07 17/02/2000  15.11.13  by  Michael Scheer
*CMZ :  2.13/03 18/01/2000  17.44.41  by  Michael Scheer
*CMZ :  2.12/03 21/07/99  10.47.09  by  Michael Scheer
*CMZ :  2.12/01 10/06/99  17.49.00  by  Michael Scheer
*CMZ :  2.12/00 04/06/99  10.43.55  by  Michael Scheer
*CMZ :  2.11/01 20/05/99  17.44.32  by  Michael Scheer
*CMZ :  2.10/01 24/02/99  10.20.40  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  11.18.17  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.54.05  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.44  by  Michael Scheer
*-- Author : Michael Scheer

      SUBROUTINE SOUINTLINS(ISOUR,IOBSV)
+seq,gplhint.

+SEQ,TRACKF90U,IF=F90.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,AFREQF90U.
+SELF.

C--- EVALUATE INTEGRALES FOR A SINGLE SOURCE

         IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,PHYCON.
+SEQ,TRACK.
+seq,sourcef90.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,FREQS.
+SEQ,USERVAR.
+seq,datetime.

+SELF,IF=-F90.
      INTEGER IPOIROI(NROIP)
+SELF.
      INTEGER NUMSTEP0,NUMSTEP

      INTEGER ISOUR,IZAEHL,ITIM0,IWARN,IOBSV,ICOMP,IFREQ,IROI
      INTEGER IEXPOMT,IEXPDOMT,IX10

      INTEGER ICAL,NTUPP,ICYCLE,IC,I
      PARAMETER (NTUPP=22)
        REAL*8 FILLT(NTUPP)
      CHARACTER(4) CTUP(NTUPP)

      DOUBLE PRECISION X1,TS,X0,X10
      DOUBLE PRECISION X2,Y2,Z2
      DOUBLE PRECISION XENDSOU,DT,DT0,DTIM01,DT2,DROIX,DTE,TE,DDTS,DT1
      DOUBLE PRECISION RARGOM,RARGDOM,RARGOMO,RARGDOMO
      DOUBLE PRECISION ARG,ARGO,ARG2,ARG4,DARG,DARG2,DARG4

      DOUBLE PRECISION BX,BY,BZ,DUM1,DUM11,DOM1,DOM2,R0,C1,PX,PY,PZ,BPX,BPY,BPZ
      DOUBLE PRECISION RNBX,RNBY,RNBZ,T,R,RNX,RNY,RNZ,R1,RX,RY,RZ,RARG(5)

      DOUBLE PRECISION CGG

+SEL,IF=-F90.
      DOUBLE PRECISION DWTRA(3,6,NWMAXP+1)
+SELF.

+SELF,IF=-NEWWAVE.
      COMPLEX*16 APOL
      COMPLEX*16 AFREQ(3,NDFREQP,NDOBSVP)
      COMPLEX*16 EXPOM,DEXPOM,DEXPOMT,DEXPDOMT,DARGEXPO(6,NDOBSVP)
      COMPLEX*8 APOLH,APOLR,APOLL,APOL45
+SELF,IF=NEWWAVE,IF=-NOCMPLX,IF=-F90.
      COMPLEX*16 APOL
      COMPLEX*16 AFREQ(3,NOBFRP)
      COMPLEX*16 EXPOM,DEXPOM,DEXPOMT,DEXPDOMT,DARGEXPO(6,NDOBSVP)
      COMPLEX*8 APOLH,APOLR,APOLL,APOL45
+SELF,IF=NEWWAVE,IF=-NOCMPLX,IF=F90.
      COMPLEX*16 APOL
      COMPLEX*16 EXPOM,DEXPOM,DEXPOMT,DEXPDOMT
      COMPLEX*8 APOLH,APOLR,APOLL,APOL45
+SELF,IF=NEWWAVE,IF=NOCMPLX,IF=-F90.
        DOUBLE PRECISION AFREQR(3,NOBFRP),OMO
        DOUBLE PRECISION EXPOMR,DEXPOMR,DEXPOMTR,DEXPDOMTR,DARGEXPOR(6,NDOBSVP)
        DOUBLE PRECISION APOLR,APOLI,COMR,COMI
        DOUBLE PRECISION AFREQI(3,NOBFRP)
        DOUBLE PRECISION EXPOMI,DEXPOMI,DEXPOMTI,DEXPDOMTI,DARGEXPOI(6,NDOBSVP)
        REAL APOLHR,APOLRR,APOLLR,APOL45R
        REAL APOLHI,APOLRI,APOLLI,APOL45I
+SELF.

+SELF,IF=NEWWAVE,IF=NOCMPLX,IF=F90.
        DOUBLE PRECISION OMO
        DOUBLE PRECISION EXPOMR,DEXPOMR,DEXPOMTR,DEXPDOMTR
        DOUBLE PRECISION APOLR,APOLI,COMR,COMI
        DOUBLE PRECISION EXPOMI,DEXPOMI,DEXPOMTI,DEXPDOMTI
        REAL APOLHR,APOLRR,APOLLR,APOL45R
        REAL APOLHI,APOLRI,APOLLI,APOL45I
+SELF.

      DOUBLE PRECISION OM,DOM
      REAL*4 STOK1,STOK2,STOK3,STOK4

      DATA ICAL/0/
      data ctup /'t','x','y','z','rx','ry','rz','rt','p','rea','ima','roi'
     &            ,'iob','ie','yob','zob','betn','dtom','emod','dmod'
     &            ,'spec','te'/

      DATA IWARN/0/

      IF (ICAL.EQ.0) THEN

          CGG=CLIGHT1/(DMYGAMMA*DMYGAMMA)
          DOM=(FREQ(2)-FREQ(1))/HBAREV1
          OM=FREQ(1)/HBAREV1
          C1=1.D0/CLIGHT1
          IF (IWFILINT.LT.0)
+self,if=-mhbook.
     &      CALL hbookm(NIDSOURCE,'RADIATION INTEGRAL$',NTUPP
     &     ,'//WAVE',1024,CTUP)
+self,if=mhbook.
     &      CALL hbookm(NIDSOURCE,'RADIATION INTEGRAL',NTUPP
     &     ,'//WAVE',nlpoi/jwfilint+2*jwfilint,CTUP)
+self.

          DTIM01=1.D0/DTIM0

+SELF,IF=F90.
          ALLOCATE(DWTRA(3,6,NCO+1))
+SELF.

          DO ITIM0=1,NCO

         DWTRA(1,1,ITIM0)=WTRA(1,1,ITIM0)
         DWTRA(2,1,ITIM0)=WTRA(2,1,ITIM0)
         DWTRA(3,1,ITIM0)=WTRA(3,1,ITIM0)

         DWTRA(1,3,ITIM0)=WTRA(1,2,ITIM0)*C1
         DWTRA(2,3,ITIM0)=WTRA(2,2,ITIM0)*C1
         DWTRA(3,3,ITIM0)=WTRA(3,2,ITIM0)*C1

          ENDDO   !NCO

         DWTRA(1,5,1)=(WTRA(1,2,2)-WTRA(1,2,1))*C1*DTIM01
         DWTRA(2,5,1)=(WTRA(2,2,2)-WTRA(2,2,1))*C1*DTIM01
         DWTRA(3,5,1)=(WTRA(3,2,2)-WTRA(3,2,1))*C1*DTIM01

          DO ITIM0=2,NCO-1

         DWTRA(1,5,ITIM0)=((WTRA(1,2,ITIM0+1)-WTRA(1,2,ITIM0-1))*C1*DTIM01)/2.D0
         DWTRA(2,5,ITIM0)=((WTRA(2,2,ITIM0+1)-WTRA(2,2,ITIM0-1))*C1*DTIM01)/2.D0
         DWTRA(3,5,ITIM0)=((WTRA(3,2,ITIM0+1)-WTRA(3,2,ITIM0-1))*C1*DTIM01)/2.D0

          ENDDO   !NCO

         DWTRA(1,5,NCO)=DWTRA(1,5,NCO-1)+DWTRA(1,5,NCO-1)-DWTRA(1,5,NCO-2)
         DWTRA(2,5,NCO)=DWTRA(2,5,NCO-1)+DWTRA(2,5,NCO-1)-DWTRA(2,5,NCO-2)
         DWTRA(3,5,NCO)=DWTRA(3,5,NCO-1)+DWTRA(3,5,NCO-1)-DWTRA(3,5,NCO-2)

         DWTRA(1,5,NCO+1)=DWTRA(1,5,NCO)+DWTRA(1,5,NCO)-DWTRA(1,5,NCO-1)
         DWTRA(2,5,NCO+1)=DWTRA(2,5,NCO)+DWTRA(2,5,NCO)-DWTRA(2,5,NCO-1)
         DWTRA(3,5,NCO+1)=DWTRA(3,5,NCO)+DWTRA(3,5,NCO)-DWTRA(3,5,NCO-1)

         DWTRA(1,1,NCO+1)=DWTRA(1,1,NCO)+DWTRA(1,1,NCO)-DWTRA(1,1,NCO-1)
         DWTRA(2,1,NCO+1)=DWTRA(2,1,NCO)+DWTRA(2,1,NCO)-DWTRA(2,1,NCO-1)
         DWTRA(3,1,NCO+1)=DWTRA(3,1,NCO)+DWTRA(3,1,NCO)-DWTRA(3,1,NCO-1)

         DWTRA(1,3,NCO+1)=DWTRA(1,3,NCO)+DWTRA(1,3,NCO)-DWTRA(1,3,NCO-1)
         DWTRA(2,3,NCO+1)=DWTRA(2,3,NCO)+DWTRA(2,3,NCO)-DWTRA(2,3,NCO-1)
         DWTRA(3,3,NCO+1)=DWTRA(3,3,NCO)+DWTRA(3,3,NCO)-DWTRA(3,3,NCO-1)

          DO ITIM0=1,NCO

         DWTRA(1,2,ITIM0)=DWTRA(1,1,ITIM0+1)-DWTRA(1,1,ITIM0)
         DWTRA(2,2,ITIM0)=DWTRA(2,1,ITIM0+1)-DWTRA(2,1,ITIM0)
         DWTRA(3,2,ITIM0)=DWTRA(3,1,ITIM0+1)-DWTRA(3,1,ITIM0)

         DWTRA(1,4,ITIM0)=DWTRA(1,3,ITIM0+1)-DWTRA(1,3,ITIM0)
         DWTRA(2,4,ITIM0)=DWTRA(2,3,ITIM0+1)-DWTRA(2,3,ITIM0)
         DWTRA(3,4,ITIM0)=DWTRA(3,3,ITIM0+1)-DWTRA(3,3,ITIM0)

         DWTRA(1,6,ITIM0)=DWTRA(1,5,ITIM0+1)-DWTRA(1,5,ITIM0)
         DWTRA(2,6,ITIM0)=DWTRA(2,5,ITIM0+1)-DWTRA(2,5,ITIM0)
         DWTRA(3,6,ITIM0)=DWTRA(3,5,ITIM0+1)-DWTRA(3,5,ITIM0)

          ENDDO   !NCO

          ICAL=1

      ENDIF !ICAL

COBSV DO IOBSV=1,NOBSV

+SELF,IF=-NEWWAVE.
          SPECPOW(ISOUR,IOBSV)=0.D0
+SELF,IF=NEWWAVE.
          SPECPOW(ISOUR+NSOURCE*(IOBSV-1))=0.D0
+SELF.

+SELF,IF=-NOCMPLX.
          DARGEXPO(1,IOBSV)=(1.D0,0.D0)   !DEXPOMT
          DARGEXPO(2,IOBSV)=(1.D0,0.D0)   !DEXPDOMT
          DARGEXPO(3,IOBSV)=(0.D0,0.D0)   !(RARGOM,RARGOMO)
          DARGEXPO(4,IOBSV)=(1.D0,0.D0)   !EXPOM
          DARGEXPO(5,IOBSV)=(0.D0,0.D0)   !(ARG,ARG)
          DARGEXPO(6,IOBSV)=(1.D0,0.D0)   !DEXPOM
+SELF,IF=NOCMPLX.
            DARGEXPOR(1,IOBSV)=1.D0   !DEXPOMT
            DARGEXPOR(2,IOBSV)=1.D0   !DEXPDOMT
            DARGEXPOR(3,IOBSV)=0.D0   !(RARGOM,RARGOMO)
            DARGEXPOR(4,IOBSV)=1.D0   !EXPOM
            DARGEXPOR(5,IOBSV)=0.D0   !(ARG,ARG)
            DARGEXPOR(6,IOBSV)=1.D0   !DEXPOM
            DARGEXPOI(1,IOBSV)=0.D0   !DEXPOMT
            DARGEXPOI(2,IOBSV)=0.D0   !DEXPDOMT
            DARGEXPOI(3,IOBSV)=0.D0   !(RARGOM,RARGOMO)
            DARGEXPOI(4,IOBSV)=0.D0   !EXPOM
            DARGEXPOI(5,IOBSV)=0.D0   !(ARG,ARG)
            DARGEXPOI(6,IOBSV)=0.D0   !DEXPOM
+SELF.

      DO IFREQ=1,NFREQ

+SELF,IF=-NEWWAVE.
          AFREQ(1,IFREQ,IOBSV)=(0.D0,0.D0)
          AFREQ(2,IFREQ,IOBSV)=(0.D0,0.D0)
          AFREQ(3,IFREQ,IOBSV)=(0.D0,0.D0)
+SELF,IF=NEWWAVE,IF=-NOCMPLX.
            IFROB=IFREQ+NFREQ*(IOBSV-1)
            AFREQ(1,IFROB)=(0.,0.)
            AFREQ(2,IFROB)=(0.,0.)
            AFREQ(3,IFROB)=(0.,0.)
+SELF,IF=NEWWAVE,IF=NOCMPLX.
            IFROB=IFREQ+NFREQ*(IOBSV-1)
            AFREQR(1,IFROB)=0.D0
            AFREQR(2,IFROB)=0.D0
            AFREQR(3,IFROB)=0.D0
            AFREQI(1,IFROB)=0.D0
            AFREQI(2,IFROB)=0.D0
            AFREQI(3,IFROB)=0.D0
+SELF.

      ENDDO   !IFREQ
COBSV ENDDO   !IOBSV

      TS=SOURCET(1,ISOUR)
      ITIM0=TS*DTIM01+1

      R0=OBSV(1,1)-SOURCEAO(1,1,ISOUR)
C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS  T=-R0*C1
      T=0.D0

      X1=SOURCEAO(1,1,ISOUR)

      IZTOT(ISOUR)=0

      XENDSOU=SOURCEEO(1,1,ISOUR)    !FINAL X

        X0=X1
        X2=X1
        X10=(XENDSOU-X0)/10.1D0

      DT0=(XENDSOU-X1)/NLPOIO/CLIGHT1
      DT=DT0
      DT2=DT/2.D0
      DT1=1.D0/DT

      IF (NROI.LT.0) THEN
          DROIX=(XENDSOU-X1)/(NROIA-1)
          DO IROI=1,NROIA
         ROIX(IROI)=X1+(IROI-1)*DROIX
         ROIP(IROI)=1.D0
          ENDDO
      ENDIF !

      ROIX(1)=ROIX(1)-1.D-6
      ROIX(NROIA)=ROIX(NROIA)+1.D-6

        IF (X1.LT.ROIX(1).OR.XENDSOU.GT.ROIX(NROIA)) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN SOUINTLINS: X OUTSIDE ROIS ***'
            WRITE(LUNGFO,*)'CHECK NAMELIST $ROIN'
            WRITE(LUNGFO,*)' *** PROGRAM WAVE ABORTED ***'
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN SOUINTLINS: X OUTSIDE ROIS ***'
            WRITE(6,*)'CHECK NAMELIST $ROIN'
            WRITE(6,*)' *** PROGRAM WAVE ABORTED ***'
            STOP
        ENDIF   !IROI

C- CHECK NUMBER OF STEPS

      IF (IWARN.EQ.0) THEN

          NUMSTEP0=NLPOIO/(SOURCEEO(1,1,NSOURCE)-SOURCEAO(1,1,1))

          DO IROI=1,NROIA-1

         NUMSTEP=(ROIX(IROI+1)-ROIX(IROI))*NUMSTEP0

         IF (NUMSTEP.LT.MYINUM) THEN

             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)'*** WARNING IN SOUINTLINS, ROI:',IROI
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)'STEP SIZE FOR SOURCE POINT IS LOWER THAN STEP'
             WRITE(LUNGFO,*)'SIZE FOR TRAJECTORY!'
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &              'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
             WRITE(LUNGFO,*)
             WRITE(6,*)
             WRITE(6,*)'*** WARNING IN SOUINTLINS, ROI:',IROI
             WRITE(6,*)
             WRITE(6,*)'STEP SIZE FOR SOURCE POINT IS LOWER THAN STEP'
             WRITE(6,*)'SIZE FOR TRAJECTORY!'
             WRITE(6,*)
             WRITE(6,*)
     &              'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
             WRITE(6,*)

           ENDIF

          ENDDO   !IROI

         IWARN=1

      ENDIF

      IZAEHL=0 !LOOP COUNTER

C--- LOOP OVER STEPS

      DO IROI=1,NROIA
          IPOIROI(IROI)=0
      ENDDO

        IROI=1
        DO I=1,NROIA
            IF (X1.GE.ROIX(I)) THEN
                IROI=I
            ENDIF
        ENDDO   !IROI

        IX10=1

        IF (ISOUR.EQ.1.AND.IOBSV.EQ.1) THEN
            WRITE(6,*)' '
            WRITE(6,*)
     &      '      counting from 1 to 10 for first source to show progress:'
            WRITE(6,*)' '
        ENDIF   !NSOURCE

        IZAEHL=0 !LOOP COUNTER

1000    IZAEHL=IZAEHL+1

        IF (ISOUR.EQ.1.AND.IOBSV.EQ.NOBSV) THEN
            IF (X2.GE.X0+X10*IX10) THEN
                 CALL date_and_time(dtday,dttime,dtzone,idatetime)
                 WRITE(6,*)' ',IX10,' ',dttime(1:2),':',dttime(3:4),':',dttime(5:6)
                 IX10=IX10+1
            ENDIF   !X1
        ENDIF   !NSOURCE

      IF (IROI.LE.NROIA) THEN
          IF (X2.GE.ROIX(IROI)) THEN
         DT=DT0/ROIP(IROI)
         DT2=DT/2.D0
         DT1=1.D0/DT
         IROI=IROI+1
          ENDIF   !IROI
      ENDIF !IROI

      IPOIROI(IROI)=IPOIROI(IROI)+1

      T=T+DT

      DDTS=DTIM01*(TS+DT-(ITIM0-1)*DTIM0)

      X2=DWTRA(1,1,ITIM0)+DWTRA(1,2,ITIM0)*DDTS
      Y2=DWTRA(2,1,ITIM0)+DWTRA(2,2,ITIM0)*DDTS
      Z2=DWTRA(3,1,ITIM0)+DWTRA(3,2,ITIM0)*DDTS

      BX=DWTRA(1,3,ITIM0)+DWTRA(1,4,ITIM0)*DDTS
      BY=DWTRA(2,3,ITIM0)+DWTRA(2,4,ITIM0)*DDTS
      BZ=DWTRA(3,3,ITIM0)+DWTRA(3,4,ITIM0)*DDTS

      BPX=DWTRA(1,5,ITIM0)+DWTRA(1,6,ITIM0)*DDTS
      BPY=DWTRA(2,5,ITIM0)+DWTRA(2,6,ITIM0)*DDTS
      BPZ=DWTRA(3,5,ITIM0)+DWTRA(3,6,ITIM0)*DDTS

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION {

C REAL PART OF INTEGRAND {

COBSV DO IOBSV=1,NOBSV

          RX=OBSV(1,IOBSV)-X2
          RY=OBSV(2,IOBSV)-Y2
          RZ=OBSV(3,IOBSV)-Z2

          R=DSQRT(RX*RX+RY*RY+RZ*RZ)
          R1=1.D0/R

          RNX=RX*R1
          RNY=RY*R1
          RNZ=RZ*R1

C--- THE DISTANCE R IS INTRODUCED HERE EXPLICITLY (S. PROGRAM OF CHAOEN WANG

          DUM1=(1.D0-BX*RNX)-BY*RNY-BZ*RNZ
          DUM11=1.D0/DUM1
          DOM1=1.D0/(R*DUM1*DUM1)

          DTE=DT*DUM1

          RNBX=RNX-BX
          RNBY=RNY-BY
          RNBZ=RNZ-BZ

          PX=(RNBY*BPZ-RNBZ*BPY)
          PY=(RNBZ*BPX-RNBX*BPZ)
          PZ=(RNBX*BPY-RNBY*BPX)

            IF (IVELOFIELD.EQ.0) THEN
              DOM2=CGG*DOM1*R1
              RARG(1)=(RNY*PZ-RNZ*PY)*DOM1+(RNX-BX)*DOM2
              RARG(2)=(RNZ*PX-RNX*PZ)*DOM1+(RNY-BY)*DOM2
              RARG(3)=(RNX*PY-RNY*PX)*DOM1+(RNZ-BZ)*DOM2
            ELSE IF (IVELOFIELD.EQ.1) THEN
              RARG(1)=(RNY*PZ-RNZ*PY)*DOM1
              RARG(2)=(RNZ*PX-RNX*PZ)*DOM1
              RARG(3)=(RNX*PY-RNY*PX)*DOM1
            ELSE IF (IVELOFIELD.LT.0) THEN
              DOM2=CGG*DOM1*R1
              RARG(1)=(RNX-BX)*DOM2
              RARG(2)=(RNY-BY)*DOM2
              RARG(3)=(RNZ-BZ)*DOM2
            ELSE  !IVELOFIELD
              WRITE(6,*)
     &          '*** ERROR IN SOUINTLINS: BAD VALUE OF IVELOFIELD  ***'
              WRITE(6,*) '*** PROGRAM WAVE ABORTED  ***'
              STOP
            ENDIF !IVELOFIELD

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS      RARG(4)=T+R*C1

          TE=T+(R-R0)*C1
          RARG(4)=TE

          RARG(5)=
     &      (RARG(1)*RARG(1)+RARG(2)*RARG(2)+RARG(3)*RARG(3))*DUM11

        IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN
+SELF,IF=-NEWWAVE.
          SPECPOW(ISOUR,IOBSV)=SPECPOW(ISOUR,IOBSV)+RARG(5)*DT
+SELF,IF=NEWWAVE.
            ILIOB=ISOUR+NSOURCE*(IOBSV-1)
          SPECPOW(ILIOB)=SPECPOW(ILIOB)+RARG(5)*DT
+SELF.
        ENDIF  !XIANF

C REAL PART OF INTEGRAND }

C COMPLEX PART OF INTEGRAND {

C    ASSUMES FREQ(I+1)=2*FREQ(I)   FOR IFREQ2P=2
C    OR FREQ(I+1)=FREQ(I)+DELTA    FOR IFREQ2P>2

        RARGOM=RARG(4)*OM

+SELF,IF=-NOCMPLX.

        RARGOMO=DREAL(DARGEXPO(3,IOBSV))
        ARG=RARGOM-RARGOMO
        ARGO=DREAL(DARGEXPO(5,IOBSV))
        DARG=ARG-ARGO
        DARGEXPO(5,IOBSV)=DCMPLX(ARG,DIMAG(DARGEXPO(5,IOBSV)))

        IF (DABS(ARG).LT.0.1D0) THEN
           ARG2=ARG*ARG
           ARG4=ARG2*ARG2
           DEXPOMT=DCMPLX(1.D0-ARG2/2.D0+ARG4/24.D0,
     &                    ARG*(1.D0-ARG2/6.D0+ARG4/120.D0))
                IEXPOMT=1
        ELSEIF (DABS(DARG).LT.0.1D0) THEN
           DARG2=DARG*DARG
           DARG4=DARG2*DARG2
                DEXPOMT=DARGEXPO(1,IOBSV)*
     &            DCMPLX(1.D0-DARG2/2.D0+DARG4/24.D0,
     &            DARG*(1.D0-DARG2/6.D0+DARG4/120.D0))
                IEXPOMT=2
        ELSE
                DEXPOMT=CDEXP(DCMPLX(0.D0,ARG))
                IEXPOMT=3
        ENDIF

          IF(IFREQ2P.GT.2) THEN

          EXPOM=DARGEXPO(4,IOBSV)*DEXPOMT
          DARGEXPO(4,IOBSV)=EXPOM    !STORE IT HERE, WILL CHANGE FURTHER DOWN

          RARGDOM=RARG(4)*DOM
          RARGDOMO=DIMAG(DARGEXPO(3,IOBSV))
          ARG=RARGDOM-RARGDOMO
          ARG2=ARG*ARG
          ARGO=DIMAG(DARGEXPO(5,IOBSV))
          DARG=ARG-ARGO
          DARGEXPO(5,IOBSV)=DCMPLX(DREAL(DARGEXPO(5,IOBSV)),ARG)

          IF (DABS(ARG).LT.0.1D0) THEN
           ARG2=ARG*ARG
           ARG4=ARG2*ARG2
           DEXPDOMT=DCMPLX(1.D0-ARG2/2.D0+ARG4/24.D0,
     &                     ARG*(1.D0-ARG2/6.D0+ARG4/120.D0))
                IEXPDOMT=1
          ELSEIF (DABS(DARG).LT.0.1D0) THEN
           DARG2=DARG*DARG
           DARG4=DARG2*DARG2
                DEXPDOMT=DARGEXPO(2,IOBSV)*
     &            DCMPLX(1.D0-DARG2/2.D0+DARG4/24.D0,
     &            DARG*(1.D0-DARG2/6.D0+DARG4/120.D0))
                IEXPDOMT=2
          ELSE
           DEXPDOMT=CDEXP(DCMPLX(0.D0,ARG))
                IEXPDOMT=3
          ENDIF

          DEXPOM=DARGEXPO(6,IOBSV)*DEXPDOMT

        ELSEIF (IFREQ2P.GT.0) THEN

          EXPOM=DARGEXPO(4,IOBSV)*DEXPOMT
          DARGEXPO(4,IOBSV)=EXPOM    !STORE IT HERE, WILL CHANGE FURTHER DOWN

        ELSE   !IFREQ2P

          EXPOM=CDEXP(DCMPLX(0.D0,RARG(4)*OM))
          DARGEXPO(4,IOBSV)=EXPOM    !STORE IT HERE, WILL CHANGE FURTHER DOWN

        ENDIF  !IFREQ2P

+SELF,IF=NOCMPLX.

          EXPOMR=DARGEXPOR(4,IOBSV)*DEXPOMTR-DARGEXPOI(4,IOBSV)*DEXPOMTI
          EXPOMI=DARGEXPOI(4,IOBSV)*DEXPOMTR+DARGEXPOR(4,IOBSV)*DEXPOMTI
          DARGEXPOR(4,IOBSV)=EXPOMR    !STORE IT HERE, WILL CHANGE FURTHER DOWN
          DARGEXPOI(4,IOBSV)=EXPOMI    !STORE IT HERE, WILL CHANGE FURTHER DOWN

          RARGOMO=DARGEXPOR(3,IOBSV)
          ARG=RARGOM-RARGOMO
          ARGO=DARGEXPOR(5,IOBSV)
          DARG=ARG-ARGO
          DARGEXPOR(5,IOBSV)=ARG

          IF (DABS(ARG).LT.0.1D0) THEN
                  ARG2=ARG*ARG
                  ARG4=ARG2*ARG2
                  DEXPOMTR=1.D0-ARG2/2.D0+ARG4/24.D0
                  DEXPOMTI=ARG*(1.D0-ARG2/6.D0+ARG4/120.D0)
                  IEXPOMT=1
          ELSEIF (DABS(DARG).LT.0.1D0) THEN
                  DARG2=DARG*DARG
                  DARG4=DARG2*DARG2
                  DEXPOMTR=
     &            DARGEXPOR(1,IOBSV)*(1.D0-DARG2/2.D0+DARG4/24.D0)
     &           -DARGEXPOI(1,IOBSV)*DARG*(1.D0-DARG2/6.D0+DARG4/120.D0)
                  DEXPOMTI=
     &            DARGEXPOI(1,IOBSV)*(1.D0-DARG2/2.D0+DARG4/24.D0)
     &           +DARGEXPOR(1,IOBSV)*DARG*(1.D0-DARG2/6.D0+DARG4/120.D0)
                  IEXPOMT=2
          ELSE
                  DEXPOMTR=COS(ARG)
                  DEXPOMTI=SIN(ARG)
                  IEXPOMT=3
          ENDIF

          EXPOMR=DARGEXPOR(4,IOBSV)*DEXPOMTR-DARGEXPOI(4,IOBSV)*DEXPOMTI
          EXPOMI=DARGEXPOI(4,IOBSV)*DEXPOMTR+DARGEXPOR(4,IOBSV)*DEXPOMTI
          DARGEXPOR(4,IOBSV)=EXPOMR    !STORE IT HERE, WILL CHANGE FURTHER DOWN
          DARGEXPOI(4,IOBSV)=EXPOMI    !STORE IT HERE, WILL CHANGE FURTHER DOWN

          IF(IFREQ2P.GT.2) THEN

            RARGDOM=RARG(4)*DOM
            RARGDOMO=DARGEXPOI(3,IOBSV)
            ARG=RARGDOM-RARGDOMO
            ARG2=ARG*ARG
            ARGO=DARGEXPOI(5,IOBSV)
            DARG=ARG-ARGO
            DARGEXPOI(5,IOBSV)=ARG

            IF (DABS(ARG).LT.0.1D0) THEN
                  ARG2=ARG*ARG
                  ARG4=ARG2*ARG2
                  DEXPDOMTR=1.D0-ARG2/2.D0+ARG4/24.D0
                  DEXPDOMTI=ARG*(1.D0-ARG2/6.D0+ARG4/120.D0)
                  IEXPDOMT=1
            ELSEIF (DABS(DARG).LT.0.1D0) THEN
                  DARG2=DARG*DARG
                  DARG4=DARG2*DARG2
                  DEXPDOMTR=
     &            DARGEXPOR(2,IOBSV)*(1.D0-DARG2/2.D0+DARG4/24.D0)
     &           -DARGEXPOI(2,IOBSV)*DARG*(1.D0-DARG2/6.D0+DARG4/120.D0)
                  DEXPDOMTI=
     &            DARGEXPOI(2,IOBSV)*(1.D0-DARG2/2.D0+DARG4/24.D0)
     &           +DARGEXPOR(2,IOBSV)*DARG*(1.D0-DARG2/6.D0+DARG4/120.D0)
                  IEXPDOMT=2
            ELSE
                  DEXPDOMTR=COS(ARG)
                  DEXPDOMTI=SIN(ARG)
                  IEXPDOMT=3
            ENDIF

            DEXPOMR=DARGEXPOR(6,IOBSV)*DEXPDOMTR-DARGEXPOI(6,IOBSV)*DEXPDOMTI
            DEXPOMI=DARGEXPOI(6,IOBSV)*DEXPDOMTR+DARGEXPOR(6,IOBSV)*DEXPDOMTI

        ELSE   !IFREQ2P

                OMO=RARG(4)*OM
                EXPOMR=COS(OMO)
                EXPOMI=SIN(OMO)
              DARGEXPOR(4,IOBSV)=EXPOMR    !STORE IT HERE, WILL CHANGE FURTHER DOWN
              DARGEXPOI(4,IOBSV)=EXPOMI    !STORE IT HERE, WILL CHANGE FURTHER DOWN

          ENDIF !IFREQ2P

+SELF.

+SELF,IF=-NEWWAVE.
        IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN
             DO ICOMP=1,3
               AFREQ(ICOMP,1,IOBSV)=AFREQ(ICOMP,1,IOBSV)
     &         +DCMPLX(RARG(ICOMP))*EXPOM*REFLEC(ICOMP)*DT
+SELF,IF=NEWWAVE,IF=-NOCMPLX.
        IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN
                IFROB=1+NFREQ*(IOBSV-1)
             DO ICOMP=1,3
                AFREQ(ICOMP,IFROB)=AFREQ(ICOMP,IFROB)
     &          +DCMPLX(RARG(ICOMP))*EXPOM*REFLEC(ICOMP)*DT
+SELF,IF=NEWWAVE,IF=NOCMPLX.
        IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN
                IFROB=1+NFREQ*(IOBSV-1)
             DO ICOMP=1,3
                AFREQR(ICOMP,IFROB)=AFREQR(ICOMP,IFROB)+RARG(ICOMP)*DT*
     &         (EXPOMR*REFLECR(ICOMP)-EXPOMI*REFLECI(ICOMP))
                AFREQI(ICOMP,IFROB)=AFREQI(ICOMP,IFROB)+RARG(ICOMP)*DT*
     &         (EXPOMI*REFLECR(ICOMP)+EXPOMR*REFLECI(ICOMP))
+SELF.
             ENDDO
        ENDIF   !XIANF

      IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN
      IF (IWFILINT.NE.0) THEN
      IF (IWFILINT.EQ.-ISOUR) THEN

          IFREQ=1
          FILLT(1)=T
          FILLT(2)=X2
          FILLT(3)=Y2
          FILLT(4)=Z2
          FILLT(5)=RARG(1)
          FILLT(6)=RARG(2)
          FILLT(7)=RARG(3)
          FILLT(8)=RARG(4)
          FILLT(9)=MIN(RARG(5),1.D30)
+SELF,IF=-NOCMPLX.
            FILLT(10)=DREAL(EXPOM)
            FILLT(11)=DIMAG(EXPOM)
+SELF,IF=NOCMPLX.
            FILLT(10)=EXPOMR
            FILLT(11)=EXPOMI
+SELF.
          FILLT(12)=IROI-1
          FILLT(13)=IOBSV
          FILLT(14)=IFREQ
          FILLT(15)=OBSV(2,IOBSV)
          FILLT(16)=OBSV(3,IOBSV)
          FILLT(17)=DUM1
          FILLT(18)=RARGOM-RARGOMO
          FILLT(19)=IEXPOMT
          FILLT(20)=IEXPDOMT
+SELF,IF=-NEWWAVE.
          FILLT(21)=
     &        DREAL(
     &          AFREQ(1,IFREQ,IOBSV)*dCONJG(AFREQ(1,IFREQ,IOBSV))
     &         +AFREQ(2,IFREQ,IOBSV)*dCONJG(AFREQ(2,IFREQ,IOBSV))
     &         +AFREQ(3,IFREQ,IOBSV)*dCONJG(AFREQ(3,IFREQ,IOBSV))
     &         )*SPECNOR
+SELF,IF=NEWWAVE,IF=-NOCMPLX.
                IFROB=IFREQ+NFREQ*(IOBSV-1)
            FILLT(21)=
     &        DREAL(
     &          AFREQ(1,IFROB)*dCONJG(AFREQ(1,IFROB))
     &         +AFREQ(2,IFROB)*dCONJG(AFREQ(2,IFROB))
     &         +AFREQ(3,IFROB)*dCONJG(AFREQ(3,IFROB))
     &         )*SPECNOR
+SELF.
+SELF,IF=NEWWAVE,IF=NOCMPLX.
                IFROB=IFREQ+NFREQ*(IOBSV-1)
            FILLT(21)=
     &         (
     &          AFREQR(1,IFROB)*AFREQR(1,IFROB)
     &         +AFREQI(1,IFROB)*AFREQI(1,IFROB)
     &         +AFREQR(2,IFROB)*AFREQR(2,IFROB)
     &         +AFREQI(2,IFROB)*AFREQI(2,IFROB)
     &         +AFREQR(3,IFROB)*AFREQR(3,IFROB)
     &         +AFREQI(3,IFROB)*AFREQI(3,IFROB)
     &         )*SPECNOR
+SELF.
          FILLT(22)=TE
          CALL hfm(NIDSOURCE,FILLT)

      ELSEIF (ISOUR.EQ.IWFILINT.AND.IOBSV.EQ.1) THEN


+SELF,IF=-NOCMPLX.
         WRITE(LUNINT,*) X2
     &    ,(SNGL(RARG(1)),IC=1,3),SNGL(RARG(4)*OM),SNGL(RARG(5))
     &    ,SNGL(DREAL(EXPOM)),SNGL(DIMAG(EXPOM))
     &    ,SNGL(DREAL(RARG(1)*EXPOM)),SNGL(DIMAG(RARG(1)*EXPOM))
     &    ,SNGL(DREAL(RARG(2)*EXPOM)),SNGL(DIMAG(RARG(2)*EXPOM))
     &    ,SNGL(DREAL(RARG(3)*EXPOM)),SNGL(DIMAG(RARG(3)*EXPOM))
+SELF,IF=NOCMPLX.
         WRITE(LUNINT,*) X2
     &    ,(SNGL(RARG(1)),IC=1,3),SNGL(RARG(4)*OM),SNGL(RARG(5))
     &    ,SNGL(EXPOMR),SNGL(EXPOMI)
     &    ,SNGL(RARG(1)*EXPOMR),SNGL(RARG(1)*EXPOMI)
     &    ,SNGL(RARG(2)*EXPOMR),SNGL(RARG(2)*EXPOMI)
     &    ,SNGL(RARG(3)*EXPOMR),SNGL(RARG(3)*EXPOMI)
+SELF.

      ENDIF
      ENDIF
      ENDIF   !XIANF

C--- LOOP OVER ALL FREQUENCES

          DO IFREQ=2,NFREQ

+SELF,IF=-NOCMPLX.

          IF    (IFREQ2P.GT.2) THEN

         EXPOM=EXPOM*DEXPOM

          ELSEIF(IFREQ2P.EQ.2) THEN

         EXPOM=EXPOM*EXPOM

          ELSE

         EXPOM=CDEXP(DCMPLX(0.D0,RARG(4)*FREQ(IFREQ)/HBAREV1))

          ENDIF


+SELF,IF=NOCMPLX.

            IF    (IFREQ2P.GT.2) THEN

                COMR=EXPOMR*DEXPOMR-EXPOMI*DEXPOMI
                COMI=EXPOMI*DEXPOMR+EXPOMR*DEXPOMI
                EXPOMR=COMR
                EXPOMI=COMI

            ELSEIF(IFREQ2P.EQ.2) THEN

                COMR=EXPOMR*EXPOMR-EXPOMI*EXPOMI
                COMI=EXPOMI*EXPOMR+EXPOMR*EXPOMI
                EXPOMR=COMR
                EXPOMI=COMI

            ELSE

                OMO=RARG(4)*FREQ(IFREQ)/HBAREV1
                EXPOMR=COS(OMO)
                EXPOMI=SIN(OMO)

            ENDIF

+SELF.

+SELF,IF=-NEWWAVE.
          IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN
         DO ICOMP=1,3
           AFREQ(ICOMP,IFREQ,IOBSV)=AFREQ(ICOMP,IFREQ,IOBSV)
     &           +DCMPLX(RARG(ICOMP))*EXPOM*REFLEC(ICOMP)*DT
+SELF,IF=NEWWAVE,IF=-NOCMPLX.
          IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN
                IFROB=IFREQ+NFREQ*(IOBSV-1)
         DO ICOMP=1,3
                AFREQ(ICOMP,IFROB)=AFREQ(ICOMP,IFROB)
     &          +DCMPLX(RARG(ICOMP))*EXPOM*REFLEC(ICOMP)*DT
+SELF,IF=NEWWAVE,IF=NOCMPLX.
          IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN
                IFROB=IFREQ+NFREQ*(IOBSV-1)
         DO ICOMP=1,3
                AFREQR(ICOMP,IFROB)=AFREQR(ICOMP,IFROB)+RARG(ICOMP)*DT*
     &         (EXPOMR*REFLECR(ICOMP)-EXPOMI*REFLECI(ICOMP))
                AFREQI(ICOMP,IFROB)=AFREQI(ICOMP,IFROB)+RARG(ICOMP)*DT*
     &         (EXPOMI*REFLECR(ICOMP)+EXPOMR*REFLECI(ICOMP))
+SELF.
         ENDDO

         IF (IWFILINT.EQ.-ISOUR) THEN

             FILLT(1)=T
             FILLT(2)=X2
             FILLT(3)=Y2
             FILLT(4)=Z2
             FILLT(5)=RARG(1)
             FILLT(6)=RARG(2)
             FILLT(7)=RARG(3)
             FILLT(8)=RARG(4)
             FILLT(9)=MIN(RARG(5),1.D30)
+SELF,IF=-NOCMPLX.
                  FILLT(10)=DREAL(EXPOM)
                  FILLT(11)=DIMAG(EXPOM)
+SELF,IF=NOCMPLX.
                  FILLT(10)=EXPOMR
                  FILLT(11)=EXPOMI
+SELF.
             FILLT(12)=IROI-1
             FILLT(13)=IOBSV
             FILLT(14)=IFREQ
             FILLT(15)=OBSV(2,IOBSV)
             FILLT(16)=OBSV(3,IOBSV)
             FILLT(17)=DUM1
             FILLT(18)=RARGOM-RARGOMO
             FILLT(19)=IEXPOMT
             FILLT(20)=IEXPDOMT
+SELF,IF=-NEWWAVE.
             FILLT(21)=
     &        DREAL(
     &          AFREQ(1,IFREQ,IOBSV)*dCONJG(AFREQ(1,IFREQ,IOBSV))
     &         +AFREQ(2,IFREQ,IOBSV)*dCONJG(AFREQ(2,IFREQ,IOBSV))
     &         +AFREQ(3,IFREQ,IOBSV)*dCONJG(AFREQ(3,IFREQ,IOBSV))
     &         )*SPECNOR
+SELF,IF=NEWWAVE,IF=-NOCMPLX.
                IFROB=IFREQ+NFREQ*(IOBSV-1)
            FILLT(21)=
     &        DREAL(
     &          AFREQ(1,IFROB)*dCONJG(AFREQ(1,IFROB))
     &         +AFREQ(2,IFROB)*dCONJG(AFREQ(2,IFROB))
     &         +AFREQ(3,IFROB)*dCONJG(AFREQ(3,IFROB))
     &         )*SPECNOR
+SELF.
+SELF,IF=NEWWAVE,IF=NOCMPLX.
                IFROB=IFREQ+NFREQ*(IOBSV-1)
            FILLT(21)=
     &         (
     &          AFREQR(1,IFROB)*AFREQR(1,IFROB)
     &         +AFREQI(1,IFROB)*AFREQI(1,IFROB)
     &         +AFREQR(2,IFROB)*AFREQR(2,IFROB)
     &         +AFREQI(2,IFROB)*AFREQI(2,IFROB)
     &         +AFREQR(3,IFROB)*AFREQR(3,IFROB)
     &         +AFREQI(3,IFROB)*AFREQI(3,IFROB)
     &         )*SPECNOR
+SELF.
             FILLT(22)=TE
             CALL hfm(NIDSOURCE,FILLT)

         ENDIF
          ENDIF   !XIANF

          ENDDO   !LOOP OVER ALL FREQUENCES


C COMPLEX PART OF INTEGRAND }

+SELF,IF=-NOCMPLX.
          DARGEXPO(1,IOBSV)=DEXPOMT
          DARGEXPO(2,IOBSV)=DEXPDOMT
          DARGEXPO(3,IOBSV)=DCMPLX(RARGOM,RARGDOM)
          DARGEXPO(6,IOBSV)=DEXPOM
+SELF,IF=NOCMPLX.
          DARGEXPOR(1,IOBSV)=DEXPOMTR
          DARGEXPOR(2,IOBSV)=DEXPDOMTR
          DARGEXPOR(3,IOBSV)=RARGOM
          DARGEXPOR(6,IOBSV)=DEXPOMR
          DARGEXPOI(1,IOBSV)=DEXPOMTI
          DARGEXPOI(2,IOBSV)=DEXPDOMTI
          DARGEXPOI(3,IOBSV)=RARGDOM
          DARGEXPOI(6,IOBSV)=DEXPOMI
+SELF.

COBSV ENDDO !IOBSV

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION }

      TS=TS+DT
      ITIM0=TS*DTIM01+1

C--- END OF LOOP OVER TIME STEPS

      IF (X2.LT.XENDSOU)  GOTO 1000

C- STORE NUMBER OF POINTS FOR INTEGRATION

      IPOISOU(ISOUR)=IZAEHL
      IZTOT(ISOUR)=IZTOT(ISOUR)+IZAEHL

COBSV DO IOBSV=1,NOBSV
      DO IFREQ=1,NFREQ

+SELF,IF=-NEWWAVE.
          IF (IPOLA.EQ.0) THEN

            SPEC(ISOUR,IOBSV,IFREQ)=
     &        DREAL(
     &          AFREQ(1,IFREQ,IOBSV)*CONJG(AFREQ(1,IFREQ,IOBSV))
     &         +AFREQ(2,IFREQ,IOBSV)*CONJG(AFREQ(2,IFREQ,IOBSV))
     &         +AFREQ(3,IFREQ,IOBSV)*CONJG(AFREQ(3,IFREQ,IOBSV))
C     &          ATEST(1,IFREQ,IOBSV)*CONJG(ATEST(1,IFREQ,IOBSV))
C     &         +ATEST(2,IFREQ,IOBSV)*CONJG(ATEST(2,IFREQ,IOBSV))
C     &         +ATEST(3,IFREQ,IOBSV)*CONJG(ATEST(3,IFREQ,IOBSV))
     &         )*SPECNOR

            REAIMA(1,1,IOBSV,IFREQ)=REAIMA(1,1,IOBSV,IFREQ)+
     &        DREAL(AFREQ(1,IFREQ,IOBSV))
            REAIMA(2,1,IOBSV,IFREQ)=REAIMA(2,1,IOBSV,IFREQ)+
     &        DREAL(AFREQ(2,IFREQ,IOBSV))
            REAIMA(3,1,IOBSV,IFREQ)=REAIMA(3,1,IOBSV,IFREQ)+
     &        DREAL(AFREQ(3,IFREQ,IOBSV))

            REAIMA(1,2,IOBSV,IFREQ)=REAIMA(1,2,IOBSV,IFREQ)+
     &        DIMAG(AFREQ(1,IFREQ,IOBSV))
            REAIMA(2,2,IOBSV,IFREQ)=REAIMA(2,2,IOBSV,IFREQ)+
     &        DIMAG(AFREQ(2,IFREQ,IOBSV))
            REAIMA(3,2,IOBSV,IFREQ)=REAIMA(3,2,IOBSV,IFREQ)+
     &        DIMAG(AFREQ(3,IFREQ,IOBSV))

          ELSE    !IPOLA

          APOL=
     &          AFREQ(1,IFREQ,IOBSV)*CONJG(VPOLA(1))
     &         +AFREQ(2,IFREQ,IOBSV)*CONJG(VPOLA(2))
     &         +AFREQ(3,IFREQ,IOBSV)*CONJG(VPOLA(3))

            SPEC(ISOUR,IOBSV,IFREQ)=
     &        DREAL(APOL*CONJG(APOL))*SPECNOR
            REAIMA(1,1,IOBSV,IFREQ)=REAIMA(1,1,IOBSV,IFREQ)+
     &        DREAL(AFREQ(1,IFREQ,IOBSV))
            REAIMA(2,1,IOBSV,IFREQ)=REAIMA(2,1,IOBSV,IFREQ)+
     &        DREAL(AFREQ(2,IFREQ,IOBSV))
            REAIMA(3,1,IOBSV,IFREQ)=REAIMA(3,1,IOBSV,IFREQ)+
     &        DREAL(AFREQ(3,IFREQ,IOBSV))

            REAIMA(1,2,IOBSV,IFREQ)=REAIMA(1,2,IOBSV,IFREQ)+
     &        DIMAG(AFREQ(1,IFREQ,IOBSV))
            REAIMA(2,2,IOBSV,IFREQ)=REAIMA(2,2,IOBSV,IFREQ)+
     &        DIMAG(AFREQ(2,IFREQ,IOBSV))
            REAIMA(3,2,IOBSV,IFREQ)=REAIMA(3,2,IOBSV,IFREQ)+
     &        DIMAG(AFREQ(3,IFREQ,IOBSV))
          ENDIF   !IPOLA

      IF (ISTOKES.NE.0) THEN

          APOLH=
     &          AFREQ(1,IFREQ,IOBSV)*CONJG(VSTOKES(1,1))
     &         +AFREQ(2,IFREQ,IOBSV)*CONJG(VSTOKES(1,2))
     &         +AFREQ(3,IFREQ,IOBSV)*CONJG(VSTOKES(1,3))

          APOLR=
     &          AFREQ(1,IFREQ,IOBSV)*CONJG(VSTOKES(2,1))
     &         +AFREQ(2,IFREQ,IOBSV)*CONJG(VSTOKES(2,2))
     &         +AFREQ(3,IFREQ,IOBSV)*CONJG(VSTOKES(2,3))

          APOLL=
     &          AFREQ(1,IFREQ,IOBSV)*CONJG(VSTOKES(3,1))
     &         +AFREQ(2,IFREQ,IOBSV)*CONJG(VSTOKES(3,2))
     &         +AFREQ(3,IFREQ,IOBSV)*CONJG(VSTOKES(3,3))

          APOL45=
     &          AFREQ(1,IFREQ,IOBSV)*CONJG(VSTOKES(4,1))
     &         +AFREQ(2,IFREQ,IOBSV)*CONJG(VSTOKES(4,2))
     &         +AFREQ(3,IFREQ,IOBSV)*CONJG(VSTOKES(4,3))

            STOK1=
     &        REAL(APOLR*CONJG(APOLR))+
     &        REAL(APOLL*CONJG(APOLL))

            STOK2=-STOK1+
     &        2.*REAL(APOLH*CONJG(APOLH))

            STOK3=
     &        2.*REAL(APOL45*CONJG(APOL45))-
     &        STOK1

            STOK4=
     &        REAL(APOLR*CONJG(APOLR))-
     &        REAL(APOLL*CONJG(APOLL))


            STOKES(1,IOBSV,IFREQ)=STOKES(1,IOBSV,IFREQ)+
     &                          STOK1*SPECNOR

            STOKES(2,IOBSV,IFREQ)=STOKES(2,IOBSV,IFREQ)+
     &                          STOK2*SPECNOR

            STOKES(3,IOBSV,IFREQ)=STOKES(3,IOBSV,IFREQ)+
     &                          STOK3*SPECNOR

            STOKES(4,IOBSV,IFREQ)=STOKES(4,IOBSV,IFREQ)+
     &                          STOK4*SPECNOR

      ENDIF !ISTOKES

      ENDDO !IFREQ

        SPECPOW(ISOUR,IOBSV)=SPECPOW(ISOUR,IOBSV)
     &                *ECHARGE1/16.D0/PI1/PI1/EPS01/CLIGHT1
     &                *DMYCUR     !NUMBER OF e-

COBSV ENDDO !IOBSV

+SELF,IF=NEWWAVE,IF=-NOCMPLX.

          ILIOBFR=ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1))
          IFROB=IFREQ+NFREQ*(IOBSV-1)
          IOBFR=IOBSV+NOBSV*(IFREQ-1)

          IF (IPOLA.EQ.0) THEN

            SPEC(ILIOBFR)=
     &        DREAL(
     &          AFREQ(1,IFROB)*CONJG(AFREQ(1,IFROB))
     &         +AFREQ(2,IFROB)*CONJG(AFREQ(2,IFROB))
     &         +AFREQ(3,IFROB)*CONJG(AFREQ(3,IFROB))
     &         )*SPECNOR

            REAIMA(1,1,IOBFR)=REAIMA(1,1,IOBFR)+
     &        DREAL(AFREQ(1,IFROB))
            REAIMA(2,1,IOBFR)=REAIMA(2,1,IOBFR)+
     &        DREAL(AFREQ(2,IFROB))
            REAIMA(3,1,IOBFR)=REAIMA(3,1,IOBFR)+
     &        DREAL(AFREQ(3,IFROB))

            REAIMA(1,2,IOBFR)=REAIMA(1,2,IOBFR)+
     &        DIMAG(AFREQ(1,IFROB))
            REAIMA(2,2,IOBFR)=REAIMA(2,2,IOBFR)+
     &        DIMAG(AFREQ(2,IFROB))
            REAIMA(3,2,IOBFR)=REAIMA(3,2,IOBFR)+
     &        DIMAG(AFREQ(3,IFROB))

          ELSE    !IPOLA

          APOL=
     &          AFREQ(1,IFROB)*CONJG(VPOLA(1))
     &         +AFREQ(2,IFROB)*CONJG(VPOLA(2))
     &         +AFREQ(3,IFROB)*CONJG(VPOLA(3))

            SPEC(ILIOBFR)=
     &        DREAL(APOL*CONJG(APOL))*SPECNOR
            REAIMA(1,1,IOBFR)=REAIMA(1,1,IOBFR)+
     &        DREAL(AFREQ(1,IFROB))
            REAIMA(2,1,IOBFR)=REAIMA(2,1,IOBFR)+
     &        DREAL(AFREQ(2,IFROB))
            REAIMA(3,1,IOBFR)=REAIMA(3,1,IOBFR)+
     &        DREAL(AFREQ(3,IFROB))

            REAIMA(1,2,IOBFR)=REAIMA(1,2,IOBFR)+
     &        DIMAG(AFREQ(1,IFROB))
            REAIMA(2,2,IOBFR)=REAIMA(2,2,IOBFR)+
     &        DIMAG(AFREQ(2,IFROB))
            REAIMA(3,2,IOBFR)=REAIMA(3,2,IOBFR)+
     &        DIMAG(AFREQ(3,IFROB))

          ENDIF   !IPOLA

      IF (ISTOKES.NE.0) THEN

          APOLH=
     &          AFREQ(1,IFROB)*CONJG(VSTOKES(1,1))
     &         +AFREQ(2,IFROB)*CONJG(VSTOKES(1,2))
     &         +AFREQ(3,IFROB)*CONJG(VSTOKES(1,3))

          APOLR=
     &          AFREQ(1,IFROB)*CONJG(VSTOKES(2,1))
     &         +AFREQ(2,IFROB)*CONJG(VSTOKES(2,2))
     &         +AFREQ(3,IFROB)*CONJG(VSTOKES(2,3))

          APOLL=
     &          AFREQ(1,IFROB)*CONJG(VSTOKES(3,1))
     &         +AFREQ(2,IFROB)*CONJG(VSTOKES(3,2))
     &         +AFREQ(3,IFROB)*CONJG(VSTOKES(3,3))

          APOL45=
     &          AFREQ(1,IFROB)*CONJG(VSTOKES(4,1))
     &         +AFREQ(2,IFROB)*CONJG(VSTOKES(4,2))
     &         +AFREQ(3,IFROB)*CONJG(VSTOKES(4,3))

            STOK1=
     &        REAL(APOLR*CONJG(APOLR))+
     &        REAL(APOLL*CONJG(APOLL))

            STOK2=-STOK1+
     &        2.*REAL(APOLH*CONJG(APOLH))

             STOK3=
     &        2.*REAL(APOL45*CONJG(APOL45))-
     &        STOK1

            STOK4=
     &        REAL(APOLR*CONJG(APOLR))-
     &        REAL(APOLL*CONJG(APOLL))


            STOKES(1,IOBFR)=STOKES(1,IOBFR)+
     &                          STOK1*SPECNOR

            STOKES(2,IOBFR)=STOKES(2,IOBFR)+
     &                          STOK2*SPECNOR

            STOKES(3,IOBFR)=STOKES(3,IOBFR)+
     &                          STOK3*SPECNOR

            STOKES(4,IOBFR)=STOKES(4,IOBFR)+
     &                          STOK4*SPECNOR

      ENDIF !ISTOKES

        ENDDO !IFREQ

        ILIOB=ISOUR+NSOURCE*(IOBSV-1)
        SPECPOW(ILIOB)=SPECPOW(ILIOB)
     &                *ECHARGE1/16.D0/PI1/PI1/EPS01/CLIGHT1
     &                *DMYCUR     !NUMBER OF e-

COBSV        ENDDO !IOBSV

+SELF,IF=NEWWAVE,IF=NOCMPLX.

          ILIOBFR=ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1))
          IFROB=IFREQ+NFREQ*(IOBSV-1)
          IOBFR=IOBSV+NOBSV*(IFREQ-1)

          IF (IPOLA.EQ.0) THEN

            SPEC(ILIOBFR)=
     &         (AFREQR(1,IFROB)*AFREQR(1,IFROB)
     &         +AFREQI(1,IFROB)*AFREQI(1,IFROB)
     &         +AFREQR(2,IFROB)*AFREQR(2,IFROB)
     &         +AFREQI(2,IFROB)*AFREQI(2,IFROB)
     &         +AFREQR(3,IFROB)*AFREQR(3,IFROB)
     &         +AFREQI(3,IFROB)*AFREQI(3,IFROB)
     &         )*SPECNOR

            REAIMA(1,1,IOBFR)=REAIMA(1,1,IOBFR)+AFREQR(1,IFROB)
            REAIMA(2,1,IOBFR)=REAIMA(2,1,IOBFR)+AFREQR(2,IFROB)
            REAIMA(3,1,IOBFR)=REAIMA(3,1,IOBFR)+AFREQR(3,IFROB)

            REAIMA(1,2,IOBFR)=REAIMA(1,2,IOBFR)+AFREQI(1,IFROB)
            REAIMA(2,2,IOBFR)=REAIMA(2,2,IOBFR)+AFREQI(2,IFROB)
            REAIMA(3,2,IOBFR)=REAIMA(3,2,IOBFR)+AFREQI(3,IFROB)

          ELSE    !IPOLA

          APOLR=
     &          AFREQR(1,IFROB)*VPOLAR(1)+AFREQI(1,IFROB)*VPOLAI(1)
     &         +AFREQR(2,IFROB)*VPOLAR(2)+AFREQI(1,IFROB)*VPOLAI(2)
     &         +AFREQR(3,IFROB)*VPOLAR(3)+AFREQI(1,IFROB)*VPOLAI(3)
          APOLI=
     &          AFREQI(1,IFROB)*VPOLAR(1)-AFREQR(1,IFROB)*VPOLAI(1)
     &         +AFREQI(2,IFROB)*VPOLAR(2)-AFREQR(1,IFROB)*VPOLAI(2)
     &         +AFREQI(3,IFROB)*VPOLAR(3)-AFREQR(1,IFROB)*VPOLAI(3)

            SPEC(ILIOBFR)=(APOLR*APOLR+APOLI*APOLI)*SPECNOR

            REAIMA(1,1,IOBFR)=REAIMA(1,1,IOBFR)+AFREQR(1,IFROB)
            REAIMA(2,1,IOBFR)=REAIMA(2,1,IOBFR)+AFREQR(2,IFROB)
            REAIMA(3,1,IOBFR)=REAIMA(3,1,IOBFR)+AFREQR(3,IFROB)

            REAIMA(1,2,IOBFR)=REAIMA(1,2,IOBFR)+AFREQI(1,IFROB)
            REAIMA(2,2,IOBFR)=REAIMA(2,2,IOBFR)+AFREQI(2,IFROB)
            REAIMA(3,2,IOBFR)=REAIMA(3,2,IOBFR)+AFREQI(3,IFROB)

          ENDIF   !IPOLA


      IF (ISTOKES.NE.0) THEN

          APOLHR=
     &          AFREQR(1,IFROB)*VSTOKESR(1,1)+AFREQI(1,IFROB)*VSTOKESI(1,1)
     &         +AFREQR(2,IFROB)*VSTOKESR(1,2)+AFREQI(2,IFROB)*VSTOKESI(1,2)
     &         +AFREQR(3,IFROB)*VSTOKESR(1,3)+AFREQI(3,IFROB)*VSTOKESI(1,3)

          APOLHI=
     &          AFREQI(1,IFROB)*VSTOKESR(1,1)-AFREQR(1,IFROB)*VSTOKESI(1,1)
     &         +AFREQI(2,IFROB)*VSTOKESR(1,2)-AFREQR(2,IFROB)*VSTOKESI(1,2)
     &         +AFREQI(3,IFROB)*VSTOKESR(1,3)-AFREQR(3,IFROB)*VSTOKESI(1,3)

          APOLRR=
     &          AFREQR(1,IFROB)*VSTOKESR(2,1)+AFREQI(1,IFROB)*VSTOKESI(2,1)
     &         +AFREQR(2,IFROB)*VSTOKESR(2,2)+AFREQI(2,IFROB)*VSTOKESI(2,2)
     &         +AFREQR(3,IFROB)*VSTOKESR(2,3)+AFREQI(3,IFROB)*VSTOKESI(2,3)


          APOLRI=
     &          AFREQI(1,IFROB)*VSTOKESR(2,1)-AFREQR(1,IFROB)*VSTOKESI(2,1)
     &         +AFREQI(2,IFROB)*VSTOKESR(2,2)-AFREQR(2,IFROB)*VSTOKESI(2,2)
     &         +AFREQI(3,IFROB)*VSTOKESR(2,3)-AFREQR(3,IFROB)*VSTOKESI(2,3)

          APOLLR=
     &          AFREQR(1,IFROB)*VSTOKESR(3,1)+AFREQI(1,IFROB)*VSTOKESI(3,1)
     &         +AFREQR(2,IFROB)*VSTOKESR(3,2)+AFREQI(2,IFROB)*VSTOKESI(3,2)
     &         +AFREQR(3,IFROB)*VSTOKESR(3,3)+AFREQI(3,IFROB)*VSTOKESI(3,3)

          APOLLI=
     &          AFREQI(1,IFROB)*VSTOKESR(3,1)-AFREQR(1,IFROB)*VSTOKESI(3,1)
     &         +AFREQI(2,IFROB)*VSTOKESR(3,2)-AFREQR(2,IFROB)*VSTOKESI(3,2)
     &         +AFREQI(3,IFROB)*VSTOKESR(3,3)-AFREQR(3,IFROB)*VSTOKESI(3,3)

          APOL45R=
     &          AFREQR(1,IFROB)*VSTOKESR(3,1)+AFREQI(1,IFROB)*VSTOKESI(3,1)
     &         +AFREQR(2,IFROB)*VSTOKESR(3,2)+AFREQI(2,IFROB)*VSTOKESI(3,2)
     &         +AFREQR(3,IFROB)*VSTOKESR(3,3)+AFREQI(3,IFROB)*VSTOKESI(3,3)

          APOL45I=
     &          AFREQI(1,IFROB)*VSTOKESR(3,1)-AFREQR(1,IFROB)*VSTOKESI(3,1)
     &         +AFREQI(2,IFROB)*VSTOKESR(3,2)-AFREQR(2,IFROB)*VSTOKESI(3,2)
     &         +AFREQI(3,IFROB)*VSTOKESR(3,3)-AFREQR(3,IFROB)*VSTOKESI(3,3)

            STOK1=
     &        APOLRR*APOLRR+APOLRI*APOLRI+
     &        APOLLR*APOLLR+APOLLI*APOLLI

            STOK2=-STOK1+2.*
     &        APOLHR*APOLHR+APOLHI*APOLHI

            STOK3=2.*
     &        APOL45R*APOL45R+APOL45I*APOL45I+
     &        STOK1

            STOK4=
     &        APOLRR*APOLRR+APOLRI*APOLRI-
     &        APOLLR*APOLLR+APOLLI*APOLLI

            STOKES(1,IOBFR)=STOKES(1,IOBFR)+
     &                          STOK1*SPECNOR

            STOKES(2,IOBFR)=STOKES(2,IOBFR)+
     &                          STOK2*SPECNOR

            STOKES(3,IOBFR)=STOKES(3,IOBFR)+
     &                          STOK3*SPECNOR

            STOKES(4,IOBFR)=STOKES(4,IOBFR)+
     &                          STOK4*SPECNOR

      ENDIF !ISTOKES

        ENDDO !IFREQ

        ILIOB=ISOUR+NSOURCE*(IOBSV-1)
        SPECPOW(ILIOB)=SPECPOW(ILIOB)
     &                *ECHARGE1/16.D0/PI1/PI1/EPS01/CLIGHT1
     &                *DMYCUR     !NUMBER OF e-

COBSV        ENDDO !IOBSV
+SELF.
      IF (IWFILINT.LT.0.AND.ISOUR.EQ.NSOURCE) THEN
                CALL MHROUT(NIDSOURCE,ICYCLE,' ')
                CALL hdeletm(NIDSOURCE)
      ENDIF

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       SR SOUINTLINS, SOURCE:', ISOUR
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       ROIs:'
      WRITE(LUNGFO,*)

      DO IROI=1,NROIA
               WRITE(LUNGFO,*)
     &           IROI,SNGL(ROIX(IROI)),SNGL(ROIP(IROI)),IPOIROI(IROI+1)
      ENDDO
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       TOTAL NUMBER OF STEPS:',IZAEHL
      WRITE(LUNGFO,*)'       (controlled by NLPOI and namelist $ROIN)'

        IF (ISOUR.EQ.1..and.nsource.gt.1.AND.IOBSV.EQ.NOBSV) THEN
                WRITE(6,*)' '
                WRITE(6,*)' '
                WRITE(6,*)' sources treated so far:'
                WRITE(6,*)' '
      ENDIF

+SELF,IF=F90.
      IF (ISOUR.EQ.NSOURCE.AND.IOBSV.EQ.NOBSV) THEN
          DEALLOCATE(DWTRA)
      ENDIF
+SELF.

      RETURN
      END
+DECK,SOUINTWIGS.
*CMZ :  4.00/14 22/12/2021  18.07.25  by  Michael Scheer
*CMZ :  3.05/06 17/07/2018  11.15.16  by  Michael Scheer
*CMZ :  3.05/03 22/05/2018  07.13.27  by  Michael Scheer
*CMZ :  3.02/03 06/11/2014  14.54.13  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.68/05 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.67/04 11/05/2012  11.18.26  by  Michael Scheer
*CMZ :  2.67/00 13/02/2012  10.58.17  by  Michael Scheer
*CMZ :  2.65/03 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.65/02 28/09/2009  13.02.09  by  Michael Scheer
*CMZ :  2.63/05 14/09/2009  15.19.42  by  Michael Scheer
*CMZ :  2.61/02 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  10.48.09  by  Michael Scheer
*CMZ :  2.51/01 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.50/00 29/04/2004  15.29.30  by  Michael Scheer
*CMZ :  2.41/10 16/04/2004  09.24.47  by  Michael Scheer
*CMZ :  2.37/07 11/12/2001  16.39.59  by  Michael Scheer
*CMZ :  2.37/01 14/11/2001  10.46.31  by  Michael Scheer
*CMZ :  2.37/00 13/11/2001  17.04.47  by  Michael Scheer
*CMZ :  2.36/00 08/11/2001  13.57.12  by  Michael Scheer
*CMZ :  2.34/09 21/09/2001  11.57.57  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  11.10.08  by  Michael Scheer
*CMZ :  2.33/00 03/05/2001  11.31.36  by  Michael Scheer
*CMZ :  2.31/01 25/04/2001  10.54.42  by  Michael Scheer
*CMZ :  2.31/00 24/04/2001  15.51.02  by  Michael Scheer
*CMZ :  2.30/03 20/04/2001  12.19.22  by  Michael Scheer
*CMZ :  2.30/02 12/04/2001  19.10.52  by  Michael Scheer
*CMZ :  2.30/01 12/04/2001  18.17.23  by  Michael Scheer
*CMZ :  2.20/12 11/04/2001  17.02.34  by  Michael Scheer
*CMZ :  2.20/11 11/04/2001  16.11.52  by  Michael Scheer
*CMZ :  2.20/10 10/04/2001  11.26.41  by  Michael Scheer
*CMZ :  2.20/09 03/04/2001  14.23.18  by  Michael Scheer
*CMZ :  2.15/01 30/03/2001  20.02.21  by  Michael Scheer
*CMZ :  2.20/08 18/03/2001  20.48.35  by  Michael Scheer
*CMZ :  2.20/07 18/03/2001  17.08.58  by  Michael Scheer
*CMZ :  2.20/06 15/03/2001  17.20.08  by  Michael Scheer
*CMZ :  2.20/05 15/03/2001  16.57.30  by  Michael Scheer
*CMZ :  2.20/04 09/03/2001  16.47.40  by  Michael Scheer
*CMZ :  2.20/03 23/02/2001  15.04.13  by  Michael Scheer
*CMZ :  2.20/02 21/02/2001  11.30.46  by  Michael Scheer
*CMZ :  2.20/01 20/02/2001  14.18.37  by  Michael Scheer
*-- Author : Michael Scheer

      SUBROUTINE SOUINTWIGS(ISOUR,IOBSV,INSIDE)
+seq,gplhint.

+SELF,IF=F90.
+SEQ,TRACKF90U.
+SEQ,WORKF90U.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,AFREQF90U.
+SEQ,AMPLIF90U.
+SELF.

C--- EVALUATE INTEGRALES FOR A SINGLE SOURCE

         IMPLICIT NONE

+SELF,IF=F90.
+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,PHYCON.
+SEQ,TRACK.
+seq,sourcef90.
+SEQ,COLLI.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,FREQS.
+SEQ,AMPLI.
+SEQ,B0SCGLOB.
+SELF.

      COMPLEX*16 APOL
      COMPLEX*16 APOLH,APOLR,APOLL,APOL45

      INTEGER NFACP,IFAC,IFACO
      PARAMETER (NFACP=5)

      DOUBLE PRECISION AFREQR(3,NDFREQP),AFREQI(3,NDFREQP)
     &                    ,A1R(3),A1I(3),A2R(3),A2I(3)
     &  ,DGAMMA

        DOUBLE PRECISION DUMR,DUMI,FAC(NFACP)
      DOUBLE PRECISION AI1R,AE1R,AI2R,AE2R
        DOUBLE PRECISION EXPOMR,DEXPOMR,EXPOMI,DEXPOMI
      DOUBLE PRECISION AI1I,AE1I,AI2I,AE2I
     &                  ,BETP(3),BETP1(3),BETPP(3)

      DOUBLE PRECISION T0,T1,T2,TENDSOU,X0,X1,X2,X10,Y1,Y2,Z1,Z2,XENDSOU,R0
     &                  ,T,DT,DT2,DT0,DTIM00,DTIM01,VXP,VYP,VZP,TENDSOU1
     &                  ,R02,H2,H2R2,PHI,FREQR,CORRR0,R00
     &                  ,DMODUR,DMODUI,DMODU0R,DMODU0I
     &                  ,DDMODUR,DDMODUI
     &                  ,AXR,AXI,AYR,AYI,AZR,AZI
     &                  ,AX0R,AX0I,AY0R,AY0I,AZ0R,AZ0I
     &                  ,X2B,Y2B,Z2B
      DOUBLE PRECISION VX1,VY1,VZ1,BX1,BY1,BZ1
      DOUBLE PRECISION VX2,VY2,VZ2,BX2,BY2,BZ2,AX2D,AY2D,AZ2D
      DOUBLE PRECISION ECDUM,BS,BSQ,ECMAXS
      DOUBLE PRECISION TS,DPHASE,DPHSOUR(2,2)
        DOUBLE PRECISION GAMMA22,GAMMA221,GAMMA21,C1,OM,DOM,GAMMA,GAMGAM

        DOUBLE PRECISION BX,BY,BZ,RX,RY,RZ,PX,PY,PZ,RNBX,RNBY,RNBZ
      DOUBLE PRECISION R1,RNX,RNY,RNZ,DOM1,DOM2,BET1N,DUM11,R,BPX,BPY,BPZ
      DOUBLE PRECISION WGANG2,BET1N2,WGANG29
        DOUBLE PRECISION RARGOM,RARGDOM,RARG(5),PHASE,C
        double precision br2,rnr2,br4,rnr4,b3

      DOUBLE PRECISION, DIMENSION(3) :: RARGEXPOR,RARGEXPOI

        DOUBLE PRECISION EXPOMOR,EXPOMOI,DEXPOMOR,DEXPOMOI
      DOUBLE PRECISION EXPDOMR,EXPDOMI,DEXPDOMR,DEXPDOMI

      DOUBLE PRECISION DROIX,DTPHASE,DXEXI,CENXEXI

      INTEGER NOLDP
      PARAMETER (NOLDP=3)
        INTEGER IINSIDE,JINSIDE,IASYMP,IROIASY,INSIDE

        DOUBLE PRECISION STOK1,STOK2,STOK3,STOK4

      INTEGER ISOUR,IOBSV,IFREQ,IZAEHL,NZAEHL,IX10,I,ICAL,ICOMP
      INTEGER ICSPL

        INTEGER IROI,II,IZTOTS

      INTEGER NTUPP,IC,KWARN
        PARAMETER (NTUPP=29)
        REAL*8 FILLT(NTUPP)
        CHARACTER(4) CTUP(NTUPP)
        CHARACTER(4) ATUP(9)

        data ctup /'t','x','y','z','rx','ry','rz','rt','p','expr','expi','roi'
     &            ,'iob','ie','yob','zob','betn','dphi','dt','by2','isou'
     &            ,'spec','reax','imax','reay','imay','reaz','imaz','ifac'/

        data atup /'isou','iob','ie','icom','iae','a1r','a1i','a2r','a2i'/

      DATA ICAL/0/,KWARN/0/

        IF (IENELOSS.NE.0) STOP '*** SOUINTWIGS NOT READY FOR IENELOSS ***'

+SELF,IF=-F90.
      WRITE(6,*) '*** SOUINTWIGS CALLED, BUT ONLY AVAILABLE FOR FORTAN 90  ***'
      WRITE(6,*) '*** PROGRAM WAVE ABORTED  ***'
      STOP
+SELF.

+SELF,IF=-NEWWAVE.
      WRITE(6,*)
     &'*** SOUINTWIGS CALLED, BUT ONLY AVAILABLE FOR +SELF,IF=NEWWAVE  ***'
      WRITE(6,*) '*** PROGRAM WAVE ABORTED  ***'
      STOP
+SELF.

+SELF,IF=NOCMPLX.
      WRITE(6,*)
     &'*** SOUINTWIGS CALLED, BUT ONLY AVAILABLE FOR +SELF,IF=-NOCMPLX  ***'
      WRITE(6,*) '*** PROGRAM WAVE ABORTED  ***'
      STOP
+SELF.

      IF (ICAL.EQ.0) THEN

       WRITE(LUNGFO,*)
       WRITE(LUNGFO,*)'       SUBROUTINE SOUINTWIGS:'
       WRITE(LUNGFO,*)

         IF (NFREQ.GT.NDFREQP) THEN
            WRITE(LUNGFO,*)
     &'*** ERROR IN SOUINTWIGS: NUMBER OF MAXIMUM PHOTON ENERGIES EXCEEDED'
            WRITE(LUNGFO,*)
     &'INCREASE PARAMETER NDFREQP IN CMPARA.CMN'
            WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED  ***'
            WRITE(6,*)
     &'*** ERROR IN SOUINTWIGS: NUMBER OF MAXIMUM PHOTON ENERGIES EXCEEDED'
            WRITE(6,*)
     &'INCREASE PARAMETER NDFREQP IN CMPARA.CMN'
            WRITE(6,*)'*** PROGRAM WAVE ABORTED  ***'
          STOP
         ENDIF    !(NFREQ.GT.NDFREQP)

          IROIASY=0
          DO IROI=1,NROIA
         IF (IROIASYEXP(IROI).NE.0) IROIASY=1
          ENDDO   !IROI

          IF (ISPECMODE.EQ.1) THEN
             DTIM00=DTMCO
         ELSE
             DTIM00=DTIM0
          ENDIF

          DTIM01=1.D0/DTIM00

            DO II=1,NSOURCE
            DO I=1,NROIA
                IWARNROI(I,II)=0
            ENDDO
            ENDDO

          GAMGAM=DMYGAMMA*DMYGAMMA
          GAMMA21=1.D0/GAMGAM
          GAMMA=DMYGAMMA
          GAMMA22=GAMGAM*2.D0
          GAMMA221=1.D0/GAMMA22
          WGANG2=(WGWINFC/GAMMA)**2+2.D0/(GAMGAM*(1.D0+DMYBETA))
          WGANG29=(WGWINFC/GAMMA*0.9)**2+2.D0/(GAMGAM*(1.D0+DMYBETA))
          DOM=(FREQ(2)-FREQ(1))/HBAREV1
          OM=FREQ(1)/HBAREV1
          C=CLIGHT1
          C1=1.D0/CLIGHT1

            IF (IWFILINT.LT.0) THEN
+self,if=-mhbook.
             CALL hbookm(NIDSOURCE,'RADIATION INTEGRALS$',NTUPP
     &     , '//WAVE',1024,CTUP)
           IF (IROIASY.NE.0) THEN
              CALL hbookm(NIDSOURCE+1,
     &       'ASYMPTOTIC EXPANSION OF RADIATION INTEGRALS$',9
     &     ,  '//WAVE',1024,ATUP)
           ENDIF   !(IROIASY.NE.0)
+self,if=mhbook.
             CALL hbookm(NIDSOURCE,'RADIATION INTEGRALS',NTUPP
     &     , '//WAVE',nlpoi/jwfilint+2*jwfilint,CTUP)
           IF (IROIASY.NE.0) THEN
              CALL hbookm(NIDSOURCE+1,
     &       'ASYMPTOTIC EXPANSION OF RADIATION INTEGRALS',9
     &     ,  '//WAVE',nlpoi/jwfilint+2*jwfilint,ATUP)
           ENDIF   !(IROIASY.NE.0)
+self.
          ENDIF !(IWFILINT.LT.0)

          FAC(1)=1.D0/3.D0
          FAC(2)=4.D0/3.D0
          FAC(3)=2.D0/3.D0
          FAC(4)=4.D0/3.D0

          ICAL=1

      ENDIF !ICAL

      ICSPL=0
      FAC(5)=1.D0/3.D0

      IF (IOBSV.EQ.1) THEN
       WRITE(LUNGFO,*)'            SOURCE NUMBER',ISOUR,':'
       WRITE(LUNGFO,*)
      ENDIF

          IASYMP=0

          INSIDE=0
          IINSIDE=0
          JINSIDE=0
          SPECPOW(ISOUR+NSOURCE*(IOBSV-1))=0.D0

          EXPOMOR=1.D0
          EXPOMOI=0.D0
          DEXPOMOR=1.D0
          DEXPOMOI=0.D0

      DO IFREQ=1,NFREQ
          AFREQR(1,IFREQ)=0.D0
          AFREQR(2,IFREQ)=0.D0
          AFREQR(3,IFREQ)=0.D0
          AFREQI(1,IFREQ)=0.D0
          AFREQI(2,IFREQ)=0.D0
          AFREQI(3,IFREQ)=0.D0
      ENDDO   !IFREQ

      R0=OBSV(1,1)-SOURCEAO(1,1,ISOUR)

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS     T=-R0*C1
        T=0.D0

      IF (ISPECMODE.EQ.1) THEN
          T0=DWT(1)
          T1=T0
          T2=DWT(MCO)
             XENDSOU=DWX(MCO)    !FINAL X
      ELSE
          T0=SOURCET(1,ISOUR)
          T1=T0
          T2=SOURCET(2,ISOUR)
             XENDSOU=SOURCEEO(1,1,ISOUR)    !FINAL X
      ENDIF

      TENDSOU=T2-T1

        X1=SOURCEAO(1,1,ISOUR)
        Y1=SOURCEAO(2,1,ISOUR)
        Z1=SOURCEAO(3,1,ISOUR)

        VX1=SOURCEAO(1,2,ISOUR)
        VY1=SOURCEAO(2,2,ISOUR)
        VZ1=SOURCEAO(3,2,ISOUR)

        BX1=SOURCEAO(1,4,ISOUR)
        BY1=SOURCEAO(2,4,ISOUR)
        BZ1=SOURCEAO(3,4,ISOUR)

      IF (IOBSV.EQ.ICBRILL) THEN
           ECSOUR(1,ISOUR)=0.0
           ECSOUR(2,ISOUR)=0.0
           ECSOUR(3,ISOUR)=0.0
           ECSOUR(4,ISOUR)=0.0
           ECMAX(   ISOUR)=-1.D30
      ENDIF

      ECMAXS=-1.D30
        IZTOTS=0

        X0=X1
        X2=X1
        X10=(XENDSOU-X0)/10.1D0

      NZAEHL=NLPOIO/NFACP*NFACP
      IF (NZAEHL.LT.NFACP) NZAEHL=NFACP
      NZAEHL=NZAEHL/2*2+1

      IF (ISPECMODE.EQ.1) THEN
          DT0=TENDSOU/(NZAEHL-1)
      ELSE
          DT0=TENDSOU/NZAEHL
      ENDIF

        DT=DT0

        IF (NROI.LT.0) THEN
            DROIX=(XENDSOU-X1)/(NROIA-1)
            DO IROI=1,NROIA
                ROIX(IROI)=X1+(IROI-1)*DROIX
                ROIP(IROI)=1.D0
            ENDDO
        ENDIF   !(NROI.LT.0)

        ROIX(1)=ROIX(1)-1.D-6
        ROIX(NROIA)=ROIX(NROIA)+1.D-6

        IF (X1.LT.ROIX(1).OR.XENDSOU.GT.ROIX(NROIA)) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN SOUINTWIGS: X OUTSIDE ROIS ***'
            WRITE(LUNGFO,*)'CHECK NAMELIST $ROIN'
            WRITE(LUNGFO,*)' *** PROGRAM WAVE ABORTED ***'
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN SOUINTWIGS: X OUTSIDE ROIS ***'
            WRITE(6,*)'CHECK NAMELIST $ROIN'
            WRITE(6,*)' *** PROGRAM WAVE ABORTED ***'
            STOP
        ENDIF   !IROI

      T=0.D0
      TS=0.D0

        X2=X1
        Y2=Y1
        Z2=Z1

        VX2=VX1
        VY2=VY1
        VZ2=VZ1

        BX2=BX1
        BY2=BY1
        BZ2=BZ1

C--- LOOP OVER STEPS

      PHASE=0.D0

        DO IROI=1,NROIA
            IPOIROI(IROI)=0
        ENDDO

        IROI=1
        DO I=1,NROIA
            IF (X1.GE.ROIX(I)) THEN
                IROI=I
            ENDIF !(X1.GE.ROIX(I))
        ENDDO   !IROI

      DT=DT0/ROIP(IROI)
      NZAEHL=NINT((TENDSOU-T)/DT)
      IF (NZAEHL.LT.NFACP) NZAEHL=NFACP
      NZAEHL=(NZAEHL+1)/NFACP*NFACP
      NZAEHL=NZAEHL/2*2+1
      IF (ISPECMODE.EQ.1) THEN
          DT=(TENDSOU-T)/(NZAEHL-1)
      ELSE
          DT=(TENDSOU-T)/NZAEHL
      ENDIF

      TENDSOU1=TENDSOU-DT
      DT2=DT/2.D0

C- CHECK STEPS SIZE

          IF (IWARNROI(IROI,ISOUR).EQ.0) THEN
          IF (DT.GT.DTIM00) THEN
                    WRITE(LUNGFO,*)
                    WRITE(LUNGFO,*)
     &'*** WARNING IN SOUINTWIGS, SOURCE, ROI:',ISOUR,IROI
                    WRITE(LUNGFO,*)
                    WRITE(LUNGFO,*)
     &             'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
                    WRITE(LUNGFO,*)'SIZE FOR TRAJECTORY!'
                    WRITE(LUNGFO,*)
                    WRITE(LUNGFO,*)
     &         'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
                    WRITE(6,*)
                    WRITE(6,*)
     &'*** WARNING IN SOUINTWIGS, SOURCE, ROI:',ISOUR,IROI
                    WRITE(6,*)
                    WRITE(6,*)'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
                    WRITE(6,*)'SIZE FOR TRAJECTORY!'
                    WRITE(6,*)
                    WRITE(6,*)
     &         'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
                    WRITE(6,*)
                   IWARNROI(IROI,ISOUR)=1
              ENDIF !DT
              ENDIF !IWARNROI

        IROI=IROI+1

        IX10=1
      IFAC=0

        IZAEHL=0 !LOOP COUNTER
      IF (IROIASY.EQ.0) THEN
          IZAEHL=IZAEHL+NOLDP
          NZAEHL=NZAEHL+NOLDP
      ENDIF

1000    IZAEHL=IZAEHL+1

        IF (IROI.LE.NROIA) THEN

            IF (X2.GE.ROIX(IROI)) THEN

            IF (IINSIDE.NE.2) THEN
            IF (IFACO.EQ.4) THEN

         FAC(5)=FAC(5)*(DT+DT0/ROIP(IROI))/DT

         IFAC=4

            ELSEIF (IFACO.EQ.5) THEN

C- CHECK STEPS SIZE
         IF (IROIASYEXP(IROI-1).NE.0) THEN
                    WRITE(LUNGFO,*)
                    WRITE(LUNGFO,*)
     &'*** WARNING IN SOUINTWIGS, SOURCE, ROI:',ISOUR,IROI
                    WRITE(LUNGFO,*)
                    WRITE(LUNGFO,*)
     &             'STEP SIZE CHANGED DURING ASYMPTOTIC EXPANSION PRECEDURE'
                    WRITE(LUNGFO,*)'THIS IS NOT RECOMMENDED, BE CAREFUL'
                    WRITE(LUNGFO,*)

                    WRITE(6,*)
                    WRITE(6,*)
     &'*** WARNING IN SOUINTWIGS, SOURCE, ROI:',ISOUR,IROI
                    WRITE(6,*)
                    WRITE(6,*)
     &             'STEP SIZE CHANGED DURING ASYMPTOTIC EXPANSION PRECEDURE'
                    WRITE(6,*)'THIS IS NOT RECOMMENDED, BE CAREFUL'
                    WRITE(6,*)
         ENDIF !IROIASYEXP


         DT=DT0/ROIP(IROI)
         NZAEHL=NINT((TENDSOU-T)/DT)
         IF (NZAEHL.LT.NFACP) NZAEHL=NFACP
         NZAEHL=(NZAEHL+1)/NFACP*NFACP
         NZAEHL=NZAEHL/2*2
         IF (ISPECMODE.EQ.1) THEN
             DT=(TENDSOU-T)/(NZAEHL-1)
         ELSE
             DT=(TENDSOU-T)/NZAEHL
         ENDIF

         TENDSOU1=TENDSOU-DT
         DT2=DT/2.D0

                 IF (IWARNROI(IROI,ISOUR).EQ.0) THEN

                 IF (DT.GT.DTIM00) THEN

                    WRITE(LUNGFO,*)
                    WRITE(LUNGFO,*)
     &'*** WARNING IN SOUINTWIGS, SOURCE, ROI:',ISOUR,IROI
                    WRITE(LUNGFO,*)
                    WRITE(LUNGFO,*)
     &             'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
                    WRITE(LUNGFO,*)'SIZE FOR TRAJECTORY!'
                    WRITE(LUNGFO,*)
                    WRITE(LUNGFO,*)
     &         'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
                    WRITE(6,*)
                    WRITE(6,*)
     &'*** WARNING IN SOUINTWIGS, SOURCE, ROI:',ISOUR,IROI
                    WRITE(6,*)
                    WRITE(6,*)'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
                    WRITE(6,*)'SIZE FOR TRAJECTORY!'
                    WRITE(6,*)
                    WRITE(6,*)
     &         'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
                    WRITE(6,*)

                   IWARNROI(IROI,ISOUR)=1

                ENDIF !DT
            ENDIF !IWARNROI

                IROI=IROI+1

         FAC(5)=FAC(1)
         IFAC=1

            ENDIF !IFAC
            ENDIF !IINSIDE

              ENDIF   !X2

        ENDIF   !IROI

        IPOIROI(IROI)=IPOIROI(IROI)+1

        T=T+DT

        X1=X2
        Y1=Y2
        Z1=Z2

        VX1=VX2
        VY1=VY2
        VZ1=VZ2

        BX1=BX2
        BY1=BY2
        BZ1=BZ2

      IF (ISPECMODE.NE.1) THEN

C GET MAGNETIC FIELD {

          X2B=X1+VX1*DT2
          Y2B=Y1+VY1*DT2
          Z2B=Z1+VZ1*DT2
          CALL MYBFELD(X2B,Y2B,Z2B,BX2,BY2,BZ2,AX2D,AY2D,AZ2D)

C GET MAGNETIC FIELD }

        BSQ=BX2*BX2+BY2*BY2+BZ2*BZ2
        BS=SQRT(BSQ)

C MOVE ONE STEP {

      CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DT,
     &             X2,Y2,Z2,VX2,VY2,VZ2,VXP,VYP,VZP,GAMMA,ICHARGE,BMOVECUT,IUSTEP,IENELOSS,DGAMMA)

          BX=VX2*C1
          BY=VY2*C1
          BZ=VZ2*C1

          BPX=VXP*C1
          BPY=VYP*C1
          BPZ=VZP*C1

C MOVE ONE STEP }

      ELSE  !ISPECMODE

          CALL WAVE_TRACK_INTER(TS,X2,Y2,Z2,VX2,VY2,VZ2,VXP,VYP,VZP,BS,ICSPL,
     &      GAMMA)

      BSQ=BS*BS

      BX=VX2*C1
      BY=VY2*C1
      BZ=VZ2*C1
      BPX=VXP*C1
      BPY=VYP*C1
      BPZ=VZP*C1

      ENDIF !ISPECMODE

      BETP1(1)=BETP(1)
      BETP1(2)=BETP(2)
      BETP1(3)=BETP(3)
      BETP(1)=BPX
      BETP(2)=BPY
      BETP(3)=BPZ

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION {

C REAL PART OF INTEGRAND {

          RX=OBSV(1,IOBSV)-X2
          RY=OBSV(2,IOBSV)-Y2
          RZ=OBSV(3,IOBSV)-Z2

          R=SQRT(RX*RX+RY*RY+RZ*RZ)
          R1=1.D0/R

          RNX=RX*R1
          RNY=RY*R1
          RNZ=RZ*R1

C--- THE DISTANCE R IS INTRODUCED HERE EXPLICITLY (S. PROGRAM OF CHAOEN WANG

          BET1N=(1.D0-BX*RNX)-BY*RNY-BZ*RNZ
c 20090928{
      br2=by**2+bz**2
      rnr2=rny**2+rnz**2
      b3=dmybeta**3
      br4=br2**2
      rnr4=rnr2**2

      if(br2.lt.1.0d-4.and.rnr2.lt.1.0d-4) then
        bet1n=
     &    1.0d0/(1+dmybeta)/gamma**2
     &    +dmybeta*(rnr2/2.0d0
     &    +rnr4/8.0d0)
     &    +(br2/2.0d0
     &    -br2*rnr2/4.0d0
     &    -br2*rnr4/16.0d0)/dmybeta
     &    +b3*br4*(1.0d0/8.0d0
     &    -rnr2/16.0d0
     &    -rnr4/64.0d0)
     &    -by*rny
     &    -bz*rnz
      endif
c }20090928

          BET1N2=2.D0*BET1N
          DUM11=1.D0/BET1N
          DOM1=1.D0/(R*BET1N*BET1N)

          RNBX=RNX-BX
          RNBY=RNY-BY
          RNBZ=RNZ-BZ

          PX=(RNBY*BPZ-RNBZ*BPY)
          PY=(RNBZ*BPX-RNBX*BPZ)
          PZ=(RNBX*BPY-RNBY*BPX)

          IF (IVELOFIELD.EQ.0) THEN
              DOM2=C*DOM1*R1/GAMGAM
              RARG(1)=(RNY*PZ-RNZ*PY)*DOM1+(RNX-BX)*DOM2
              RARG(2)=(RNZ*PX-RNX*PZ)*DOM1+(RNY-BY)*DOM2
              RARG(3)=(RNX*PY-RNY*PX)*DOM1+(RNZ-BZ)*DOM2
            ELSE IF (IVELOFIELD.EQ.1) THEN
              RARG(1)=(RNY*PZ-RNZ*PY)*DOM1
              RARG(2)=(RNZ*PX-RNX*PZ)*DOM1
              RARG(3)=(RNX*PY-RNY*PX)*DOM1
            ELSE IF (IVELOFIELD.LT.0) THEN
              DOM2=C*DOM1*R1/GAMGAM
              RARG(1)=(RNX-BX)*DOM2
              RARG(2)=(RNY-BY)*DOM2
              RARG(3)=(RNZ-BZ)*DOM2
            ELSE  !IVELOFIELD
              WRITE(6,*)
     &          '*** ERROR IN SOUINTWIGS: BAD VALUE OF IVELOFIELD  ***'
              WRITE(6,*) '*** PROGRAM WAVE ABORTED  ***'
              STOP
            ENDIF !IVELOFIELD

          IF (IZAEHL.GE.NOLDP.AND.IINSIDE.EQ.0.AND.BET1N2.LE.WGANG2) THEN
         IF (IROIASYEXP(IROI-1).NE.0) IASYMP=1
         DPHSOUR(1,1)=BET1N*DT*FREQ(1)/HBAREV1
         DPHSOUR(1,2)=BET1N*DT*FREQ(NFREQ)/HBAREV1
         IINSIDE=1
         INSIDE=1
         JINSIDE=JINSIDE+1
         IF (JINSIDE.GT.1) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'*** WARNING IN SOUINTWIGS  ***'
           WRITE(LUNGFO,*)'*** SOURCE:',ISOUR
           WRITE(LUNGFO,*)'STRANGE SOURCE, CONTAINS SEVERAL SOURCES'
           WRITE(LUNGFO,*)'SOURCE AND OBSERVATION POINT:'
           WRITE(LUNGFO,*)ISOUR,OBSV(1,IOBSV),OBSV(2,IOBSV),OBSV(3,IOBSV)
           WRITE(LUNGFO,*)'AYMPTOTIC EXPANSION MAY BE INVALID!!'
           WRITE(LUNGFO,*)
     &           'RESULTS OF SPECTRUM CALCULATIONS MAY BE UNRELIABLE'
           WRITE(LUNGFO,*)'*** CHECK COLLIMATOR, PINHOLE, WGWINFC ... ***'
           WRITE(6,*)
           WRITE(6,*)'*** WARNING IN SOUINTWIGS  ***'
           WRITE(6,*)'*** SOURCE:',ISOUR
           WRITE(6,*)'*** STRANGE SOURCE, CONTAINS SEVERAL SOURCES'
           WRITE(6,*)'SOURCE AND OBSERVATION POINT:'
           WRITE(6,*)ISOUR,OBSV(1,IOBSV),OBSV(2,IOBSV),OBSV(3,IOBSV)
           WRITE(6,*)'*** CHECK COLLIMATOR, PINHOLE, WGWINFC ... ***'
           WRITE(6,*)'AYMPTOTIC EXPANSION IS INVALID!!'
           WRITE(6,*)'WARNING OF SPECTRUM CALCULATIONS ARE UNRELIABLE'
           JINSIDE=JINSIDE-1   !SUPRESS LOTS OF WARNINGS
           IASYMP=0  !BOUNDARY ALREADY TAKEN INTO ACCOUNT
         ENDIF !JINSIDE
              ELSEIF ((IINSIDE.EQ.1.AND.BET1N2.GT.WGANG2
     &          .OR.  IINSIDE.EQ.2).AND.IFAC.EQ.4) THEN
                IF (IROIASYEXP(IROI-1).NE.0) THEN
             IASYMP=2
         ELSEIF (IINSIDE.EQ.1) THEN
             IINSIDE=0
         ENDIF
         DPHSOUR(2,1)=BET1N*DT*FREQ(1)/HBAREV1
         DPHSOUR(2,2)=BET1N*DT*FREQ(NFREQ)/HBAREV1
          ELSE    !IINSIDE
         IASYMP=0
          ENDIF   !IINSIDE

          IF (IINSIDE.NE.0) THEN

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS      RARG(4)=T+R*C1

C         RARG(4)=T-(RNX*X2+RNY*Y2+RNZ*Z2)*C1
C         RARG(4)=T+(R-R0)*C1

          DPHASE=BET1N*DT
          PHASE=PHASE+DPHASE
          RARG(4)=PHASE

          RARG(5)=
     &      (RARG(1)*RARG(1)+RARG(2)*RARG(2)+RARG(3)*RARG(3))*DUM11
C REAL PART OF INTEGRAND }

C COMPLEX PART OF INTEGRAND {

C    ASSUMES FREQ(I+1)=2*FREQ(I)   FOR IFREQ2P=2
C    OR FREQ(I+1)=FREQ(I)+DELTA    FOR IFREQ2P>2

C--- LOOP OVER ALL FREQUENCES

        IFREQ=1
        OM=FREQ(IFREQ)/HBAREV1

c       RARGOM=RARG(4)*OM
c       EXPOMR=COS(RARGOM)
c       EXPOMI=SIN(RARGOM)

        RARGOM=OM*DPHASE
        EXPDOMR=COS(RARGOM)
        EXPDOMI=SIN(RARGOM)
        DUMR=EXPOMOR*EXPDOMR-EXPOMOI*EXPDOMI
        DUMI=EXPOMOR*EXPDOMI+EXPOMOI*EXPDOMR
        EXPOMOR=DUMR
        EXPOMOI=DUMI
        EXPOMR=DUMR
        EXPOMI=DUMI

          IF(IFREQ2P.GT.2) THEN
c         RARGDOM=RARG(4)*DOM
c         DEXPOMR=COS(RARGDOM)
c         DEXPOMI=SIN(RARGDOM)
          RARGDOM=DOM*DPHASE
          DEXPDOMR=COS(RARGDOM)
          DEXPDOMI=SIN(RARGDOM)
          DUMR=DEXPOMOR*DEXPDOMR-DEXPOMOI*DEXPDOMI
          DUMI=DEXPOMOR*DEXPDOMI+DEXPOMOI*DEXPDOMR
          DEXPOMOR=DUMR
          DEXPOMOI=DUMI
          DEXPOMR=DUMR
          DEXPOMI=DUMI
        ENDIF  !IFREQ2P

          DO ICOMP=1,3
         RARGEXPOR(ICOMP)=RARG(ICOMP)*EXPOMR
          ENDDO
          DO ICOMP=1,3
         RARGEXPOI(ICOMP)=RARG(ICOMP)*EXPOMI
          ENDDO

         IF (IASYMP.EQ.1) THEN

          IF (BET1N2.LT.WGANG29) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'*** WARNING IN SOUINTWIGS  ***'
           WRITE(LUNGFO,*)'*** SOURCE:',ISOUR
           WRITE(LUNGFO,*)'STRANGE SOURCE, SMALL ENTRANCE ANGLE'
           WRITE(LUNGFO,*)'SOURCE AND OBSERVATION POINT:'
           WRITE(LUNGFO,*)ISOUR,IOBSV,SNGL(OBSV(1,IOBSV))
     &                          ,SNGL(OBSV(2,IOBSV)),SNGL(OBSV(3,IOBSV))
           WRITE(LUNGFO,*)'AYMPTOTIC EXPANSION MAY BE INVALID!!'
           WRITE(LUNGFO,*)
     &           'RESULTS OF SPECTRUM CALCULATIONS MAY BE UNRELIABLE'
           WRITE(LUNGFO,*)'*** CHECK COLLIMATOR, PINHOLE, WGWINFC ... ***'
           IF (KWARN.EQ.0) THEN
           WRITE(6,*)
           WRITE(6,*)'*** WARNING IN SOUINTWIGS  ***'
           WRITE(6,*)'STRANGE SOURCE, SMALL DEFLECTION ANGLE'
           WRITE(6,*)'AYMPTOTIC EXPANSION MIGHT BE INVALID!!'
           WRITE(6,*)'SEE OUTPUT FILE WAVE.OUT FOR DETAILS'
           KWARN=1
           ENDIF  !KWARN
          ENDIF   !WGANG29

             BETPP(1)=(BETP(1)-BETP1(1))/DT
             BETPP(2)=(BETP(2)-BETP1(2))/DT
             BETPP(3)=(BETP(3)-BETP1(3))/DT
                    CALL SOUASYEXP(IVELOFIELD,IROIASYEXP(IROI-1)
     &             ,X2,Y2,Z2,VX2,VY2,VZ2
     &             ,OBSV(1,IOBSV),OBSV(2,IOBSV),OBSV(3,IOBSV)
     &             ,BET1N,EXPOMR,EXPOMI,OM,BETP,BETPP,C,DMYGAMMA
     &             ,A1R,A1I,A2R,A2I)

                 DO ICOMP=1,3

             AI1R=A1R(ICOMP)
             AI1I=A1I(ICOMP)
             AI2R=A2R(ICOMP)
             AI2I=A2I(ICOMP)

             IF (IROIASYEXP(IROI-1).GT.0) THEN
              FILLT(1)=ISOUR
              FILLT(2)=IFREQ
              FILLT(3)=IOBSV
              FILLT(4)=ICOMP
                     FILLT(5)=1.0d0
              FILLT(6)=AI1R
              FILLT(7)=AI1I
              FILLT(8)=AI2R
              FILLT(9)=AI2I
              CALL hfm(NIDSOURCE+1,FILLT)
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &'     ind. of ener., obs. point , and comp.:'
     &                             ,IFREQ,IOBSV,ICOMP
              WRITE(LUNGFO,*)'     first order term at entrance:'
            WRITE(LUNGFO,*)'       ',AI1R,AI1I
              WRITE(LUNGFO,*)'     second order term at entrance:'
             WRITE(LUNGFO,*)'      ',AI2R,AI2I

             ENDIF   !(IROIASYEXP(IROI-1).GT.0)

             IF (X2.GE.XIANF) THEN
                  AFREQR(ICOMP,IFREQ)=AFREQR(ICOMP,IFREQ)+AI1R+AI2R
                  AFREQI(ICOMP,IFREQ)=AFREQI(ICOMP,IFREQ)+AI1I+AI2I
             ENDIF

           ENDDO  !ICOMP

         ELSEIF (IASYMP.EQ.2) THEN

          IF (BET1N2.LT.WGANG29) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'*** WARNING IN SOUINTWIGS  ***'
           WRITE(LUNGFO,*)'*** SOURCE:',ISOUR
           WRITE(LUNGFO,*)'STRANGE SOURCE, SMALL EXIT ANGLE'
           WRITE(LUNGFO,*)'SOURCE AND OBSERVATION POINT:'
           WRITE(LUNGFO,*)ISOUR,IOBSV,SNGL(OBSV(1,IOBSV))
     &                          ,SNGL(OBSV(2,IOBSV)),SNGL(OBSV(3,IOBSV))
           WRITE(LUNGFO,*)'AYMPTOTIC EXPANSION MAY BE INVALID!!'
           WRITE(LUNGFO,*)
     &           'RESULTS OF SPECTRUM CALCULATIONS MAY BE UNRELIABLE'
           WRITE(LUNGFO,*)'*** CHECK COLLIMATOR, PINHOLE, WGWINFC ... ***'
           IF (KWARN.EQ.0) THEN
           WRITE(6,*)
           WRITE(6,*)'*** WARNING IN SOUINTWIGS  ***'
           WRITE(6,*)'STRANGE SOURCE, SMALL DEFLECTION ANGLE'
           WRITE(6,*)'AYMPTOTIC EXPANSION MIGHT BE INVALID!!'
           WRITE(6,*)'SEE OUTPUT FILE WAVE.OUT FOR DETAILS'
           KWARN=1
           ENDIF  !KWARN
          ENDIF   !WGANG29

             BETPP(1)=(BETP(1)-BETP1(1))/DT
             BETPP(2)=(BETP(2)-BETP1(2))/DT
             BETPP(3)=(BETP(3)-BETP1(3))/DT
                    CALL SOUASYEXP(IVELOFIELD,IROIASYEXP(IROI-1)
     &             ,X2,Y2,Z2,VX2,VY2,VZ2
     &             ,OBSV(1,IOBSV),OBSV(2,IOBSV),OBSV(3,IOBSV)
     &             ,BET1N,EXPOMR,EXPOMI,OM,BETP,BETPP,C,DMYGAMMA
     &             ,A1R,A1I,A2R,A2I)

                 DO ICOMP=1,3

             AE1R=A1R(ICOMP)
             AE1I=A1I(ICOMP)
             AE2R=A2R(ICOMP)
             AE2I=A2I(ICOMP)

             IF (X2.GE.XIANF) THEN
                  AFREQR(ICOMP,IFREQ)=AFREQR(ICOMP,IFREQ)-AE1R-AE2R
                  AFREQI(ICOMP,IFREQ)=AFREQI(ICOMP,IFREQ)-AE1I-AE2I
                  ENDIF

             IF (IROIASYEXP(IROI-1).GT.0) THEN
              FILLT(1)=ISOUR
              FILLT(2)=IFREQ
              FILLT(3)=IOBSV
              FILLT(4)=ICOMP
                     FILLT(5)=2.0d0
              FILLT(6)=AE1R
              FILLT(7)=AE1I
              FILLT(8)=AE2R
              FILLT(9)=AE2I
              CALL hfm(NIDSOURCE+1,FILLT)

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &'     ind. of ener., obs. point , and comp.:'
     &                             ,IFREQ,IOBSV,ICOMP
              WRITE(LUNGFO,*)'     first order term at exit:'
            WRITE(LUNGFO,*)'      ',AE1R,AE1I
              WRITE(LUNGFO,*)'     second order term at exit:'
            WRITE(LUNGFO,*)'      ',AE2R,AE2I
             ENDIF   !(IROIASYEXP(IROI-1).GT.0)

           ENDDO  !ICOMP

         ENDIF !IASYMP

        IF (X2.GE.XIANF) THEN

          IF (IOBSV.EQ.ICBRILL) THEN
               ECSOUR(1,ISOUR)=ECSOUR(1,ISOUR)+BS
               ECSOUR(4,ISOUR)=ECSOUR(4,ISOUR)+SIGN(BS,BY2)
               ECSOUR(3,ISOUR)=ECSOUR(3,ISOUR)+BSQ
               IF (ECMAX(ISOUR).LT.BS) ECMAX(ISOUR)=BS
               IZTOTS=IZTOTS+1
          ENDIF
             IF (ECMAXS.LT.BS) ECMAXS=BS

            IFAC=IFAC+1
            ILIOB=ISOUR+NSOURCE*(IOBSV-1)
              SPECPOW(ILIOB)=SPECPOW(ILIOB)+FAC(IFAC)*RARG(5)*DT
               DO ICOMP=1,3
                 AFREQR(ICOMP,IFREQ)=AFREQR(ICOMP,IFREQ)
     &         +FAC(IFAC)*RARGEXPOR(ICOMP)*DT
               ENDDO   !ICOMP
               DO ICOMP=1,3
                 AFREQI(ICOMP,IFREQ)=AFREQI(ICOMP,IFREQ)
     &         +FAC(IFAC)*RARGEXPOI(ICOMP)*DT
               ENDDO   !ICOMP
        ENDIF  !XIANF

        IF (IWFILINT.NE.0) THEN
        IF (IWFILINT.LT.0) THEN
            FILLT(1)=T
            FILLT(2)=X2
            FILLT(3)=Y2
            FILLT(4)=Z2
            FILLT(5)=RARG(1)
            FILLT(6)=RARG(2)
            FILLT(7)=RARG(3)
            FILLT(8)=RARG(4)
            FILLT(9)=RARG(5)
            FILLT(10)=EXPOMR
            FILLT(11)=EXPOMI
            FILLT(12)=IROI-1
            FILLT(13)=IOBSV
            FILLT(14)=IFREQ
            FILLT(15)=OBSV(2,IOBSV)
            FILLT(16)=OBSV(3,IOBSV)
            FILLT(17)=BET1N
            FILLT(18)=DPHASE*OM
            FILLT(19)=DT
            FILLT(20)=BY2
            FILLT(21)=ISOUR
            FILLT(22)=
     &         (
     &          AFREQR(1,IFREQ)*AFREQR(1,IFREQ)
     &         +AFREQI(1,IFREQ)*AFREQI(1,IFREQ)
     &         +AFREQR(2,IFREQ)*AFREQR(2,IFREQ)
     &         +AFREQI(2,IFREQ)*AFREQI(2,IFREQ)
     &         +AFREQR(3,IFREQ)*AFREQR(3,IFREQ)
     &         +AFREQI(3,IFREQ)*AFREQI(3,IFREQ)
     &         )*SPECNOR
            FILLT(23)=AFREQR(1,IFREQ)*SPECNOR
            FILLT(24)=AFREQI(1,IFREQ)*SPECNOR
            FILLT(25)=AFREQR(2,IFREQ)*SPECNOR
            FILLT(26)=AFREQI(2,IFREQ)*SPECNOR
            FILLT(27)=AFREQR(3,IFREQ)*SPECNOR
            FILLT(28)=AFREQI(3,IFREQ)*SPECNOR
            FILLT(29)=IFAC

            CALL hfm(NIDSOURCE,FILLT)

        ELSE IF (ISOUR.EQ.IWFILINT.AND.IOBSV.EQ.1) THEN

         WRITE(LUNINT,*) IZAEHL,IFREQ,X2
         WRITE(LUNINT,*) (RARG(1),IC=1,3)
         WRITE(LUNINT,*) RARG(4)*OM,RARG(5)
         WRITE(LUNINT,*)EXPOMR,EXPOMI
         WRITE(LUNINT,*)RARG(1)*EXPOMR,RARG(1)*EXPOMI
         WRITE(LUNINT,*)RARG(2)*EXPOMR,RARG(2)*EXPOMI
         WRITE(LUNINT,*)RARG(3)*EXPOMR,RARG(3)*EXPOMI

        ENDIF !IWFILINT.LT.0
        ENDIF !IWFILINT.NE.0

          DO IFREQ=2,NFREQ

          OM=OM+DOM

          IF    (IFREQ2P.GT.2) THEN
         DUMR=EXPOMR*DEXPOMR-EXPOMI*DEXPOMI
         DUMI=EXPOMR*DEXPOMI+EXPOMI*DEXPOMR
         EXPOMR=DUMR
         EXPOMI=DUMI
          ELSEIF(IFREQ2P.EQ.2) THEN
         DUMR=EXPOMR*EXPOMR-EXPOMI*EXPOMI
         DUMI=EXPOMR*EXPOMI+EXPOMI*EXPOMR
         EXPOMR=DUMR
         EXPOMI=DUMI
          ELSE
         OM=FREQ(IFREQ)/HBAREV1
         EXPOMR=COS(RARG(4)*OM)
         EXPOMI=SIN(RARG(4)*OM)
          ENDIF

           DO ICOMP=1,3
          RARGEXPOR(ICOMP)=RARG(ICOMP)*EXPOMR
           ENDDO
           DO ICOMP=1,3
          RARGEXPOI(ICOMP)=RARG(ICOMP)*EXPOMI
           ENDDO

         IF (IASYMP.EQ.1) THEN

             BETPP(1)=(BETP(1)-BETP1(1))/DT
             BETPP(2)=(BETP(2)-BETP1(2))/DT
             BETPP(3)=(BETP(3)-BETP1(3))/DT
                    CALL SOUASYEXP(IVELOFIELD,IROIASYEXP(IROI-1)
     &             ,X2,Y2,Z2,VX2,VY2,VZ2
     &             ,OBSV(1,IOBSV),OBSV(2,IOBSV),OBSV(3,IOBSV)
     &             ,BET1N,EXPOMR,EXPOMI,OM,BETP,BETPP,C,DMYGAMMA
     &             ,A1R,A1I,A2R,A2I)

              DO ICOMP=1,3

             AI1R=A1R(ICOMP)
             AI1I=A1I(ICOMP)
             AI2R=A2R(ICOMP)
             AI2I=A2I(ICOMP)

             IF (IROIASYEXP(IROI-1).GT.0) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &'     ind. of ener., obs. point , and comp.:'
     &                             ,IFREQ,IOBSV,ICOMP
              WRITE(LUNGFO,*)'     first order term at entrance:'
            WRITE(LUNGFO,*)'      ',AI1R,AI1I
              WRITE(LUNGFO,*)'     second order term at entrance:'
            WRITE(LUNGFO,*)'      ',AI2R,AI2I
             ENDIF   !(IROIASYEXP(IROI-1).GT.0)

             IF (X2.GE.XIANF) THEN
                  AFREQR(ICOMP,IFREQ)=AFREQR(ICOMP,IFREQ)+AI1R+AI2R
                  AFREQI(ICOMP,IFREQ)=AFREQI(ICOMP,IFREQ)+AI1I+AI2I
             ENDIF

          ENDDO   !ICOMP

         ELSEIF (IASYMP.EQ.2) THEN

             BETPP(1)=(BETP(1)-BETP1(1))/DT
             BETPP(2)=(BETP(2)-BETP1(2))/DT
             BETPP(3)=(BETP(3)-BETP1(3))/DT
                    CALL SOUASYEXP(IVELOFIELD,IROIASYEXP(IROI-1)
     &             ,X2,Y2,Z2,VX2,VY2,VZ2
     &             ,OBSV(1,IOBSV),OBSV(2,IOBSV),OBSV(3,IOBSV)
     &             ,BET1N,EXPOMR,EXPOMI,OM,BETP,BETPP,C,DMYGAMMA
     &             ,A1R,A1I,A2R,A2I)

              DO ICOMP=1,3

             AE1R=A1R(ICOMP)
             AE1I=A1I(ICOMP)
             AE2R=A2R(ICOMP)
             AE2I=A2I(ICOMP)

             IF (IROIASYEXP(IROI-1).GT.0) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &'     ind. of ener., obs. point , and comp.:'
     &                             ,IFREQ,IOBSV,ICOMP
              WRITE(LUNGFO,*)'     first order term at exit:'
            WRITE(LUNGFO,*)'      ',AE1R,AE1I
              WRITE(LUNGFO,*)'     second order term exit:'
             WRITE(LUNGFO,*)'      ',AE2R,AE2I
             ENDIF   !(IROIASYEXP(IROI-1).GT.0)

             IF (X2.GE.XIANF) THEN
                  AFREQR(ICOMP,IFREQ)=AFREQR(ICOMP,IFREQ)-AE1R-AE2R
                  AFREQI(ICOMP,IFREQ)=AFREQI(ICOMP,IFREQ)-AE1I-AE2I
             ENDIF

           ENDDO  !ICOMP

         ENDIF !(IASYMP.EQ.2)

        IF (X2.GE.XIANF) THEN
               DO ICOMP=1,3
                 AFREQR(ICOMP,IFREQ)=AFREQR(ICOMP,IFREQ)
     &         +FAC(IFAC)*RARGEXPOR(ICOMP)*DT
               ENDDO   !ICOMP
               DO ICOMP=1,3
                 AFREQI(ICOMP,IFREQ)=AFREQI(ICOMP,IFREQ)
     &         +FAC(IFAC)*RARGEXPOI(ICOMP)*DT
               ENDDO   !ICOMP
        ENDIF

        IF (IWFILINT.NE.0) THEN
        IF (IWFILINT.LT.0) THEN
            FILLT(1)=T
            FILLT(2)=X2
            FILLT(3)=Y2
            FILLT(4)=Z2
            FILLT(5)=RARG(1)
            FILLT(6)=RARG(2)
            FILLT(7)=RARG(3)
            FILLT(8)=RARG(4)
            FILLT(9)=RARG(5)
            FILLT(10)=EXPOMR
            FILLT(11)=EXPOMI
            FILLT(12)=IROI-1
            FILLT(13)=IOBSV
            FILLT(14)=IFREQ
            FILLT(15)=OBSV(2,IOBSV)
            FILLT(16)=OBSV(3,IOBSV)
            FILLT(17)=BET1N
            FILLT(18)=DPHASE*OM
            FILLT(19)=DT
            FILLT(20)=BY2
            FILLT(21)=ISOUR
            FILLT(22)=
     &         (
     &          AFREQR(1,IFREQ)*AFREQR(1,IFREQ)
     &         +AFREQI(1,IFREQ)*AFREQI(1,IFREQ)
     &         +AFREQR(2,IFREQ)*AFREQR(2,IFREQ)
     &         +AFREQI(2,IFREQ)*AFREQI(2,IFREQ)
     &         +AFREQR(3,IFREQ)*AFREQR(3,IFREQ)
     &         +AFREQI(3,IFREQ)*AFREQI(3,IFREQ)
     &         )*SPECNOR
            FILLT(23)=AFREQR(1,IFREQ)*SPECNOR
            FILLT(24)=AFREQI(1,IFREQ)*SPECNOR
            FILLT(25)=AFREQR(2,IFREQ)*SPECNOR
            FILLT(26)=AFREQI(2,IFREQ)*SPECNOR
            FILLT(27)=AFREQR(3,IFREQ)*SPECNOR
            FILLT(28)=AFREQI(3,IFREQ)*SPECNOR
            FILLT(29)=IFAC
            CALL hfm(NIDSOURCE,FILLT)

        ELSEIF (ISOUR.EQ.IWFILINT.AND.IOBSV.EQ.1) THEN

         WRITE(LUNINT,*) IZAEHL,IFREQ,X2
         WRITE(LUNINT,*) (RARG(1),IC=1,3)
         WRITE(LUNINT,*) RARG(4)*OM,RARG(5)
         WRITE(LUNINT,*)EXPOMR,EXPOMI
         WRITE(LUNINT,*)RARG(1)*EXPOMR,RARG(1)*EXPOMI
         WRITE(LUNINT,*)RARG(2)*EXPOMR,RARG(2)*EXPOMI
         WRITE(LUNINT,*)RARG(3)*EXPOMR,RARG(3)*EXPOMI

        ENDIF !IWFILINT.LT.0
        ENDIF !IWFILINT.NE.0

        ENDDO   !LOOP OVER ALL FREQUENCES

      IFACO=IFAC
      IF (IFAC.EQ.4) IFAC=2

        ENDIF   !IINSIDE

C COMPLEX PART OF INTEGRAND }

      IF (IASYMP.EQ.2) THEN
          IINSIDE=0
      ENDIF

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION }

        TS=TS+DT

C--- END OF LOOP OVER TIME STEPS

      IF (T.LT.TENDSOU1.AND.X2.LE.XIEND)  GOTO 1000

      IF (IFAC.NE.5.AND.IFAC.NE.0) THEN
          IF (IFACO.EQ.4) IFAC=4
        IINSIDE=2
        GOTO 1000
      ENDIF

      IF (IINSIDE.NE.0) THEN
         DPHSOUR(2,1)=BET1N*DT*FREQ(1)/HBAREV1
         DPHSOUR(2,2)=BET1N*DT*FREQ(NFREQ)/HBAREV1
      ENDIF

C- STORE NUMBER OF POINTS FOR INTEGRATION

        IF (IOBSV.EQ.ICBRILL) IPOISOU(ISOUR)=IZAEHL

      IF (IOBSV.EQ.ICBRILL.AND.IZTOTS.GT.0) THEN

        ECSOUR(1,ISOUR)=ECSOUR(1,ISOUR)/IZTOTS
        ECSOUR(4,ISOUR)=ECSOUR(4,ISOUR)/IZTOTS
        ECSOUR(3,ISOUR)=ECSOUR(3,ISOUR)/IZTOTS

        ECDUM=ECSOUR(3,ISOUR)-ECSOUR(1,ISOUR)**2

        IF (ECDUM.LT.0.0) ECDUM=0.

      IF (ECSOUR(1,ISOUR).NE.0.D0) THEN
           ECSOUR(3,ISOUR)=SQRT(ECDUM)/ECSOUR(1,ISOUR)
      ELSE
        ECSOUR(3,ISOUR)=0.D0
      ENDIF

        ECSOUR(2,ISOUR)=ECSOUR(1,ISOUR)*ecdipev1*DMYENERGY**2   !CRITICAL ENERGY

      ENDIF !ISPECMODE

      IF (IAMPLI.LT.0) THEN
         DXEXI=MIN(SOURCEEO(1,1,ISOUR),XIEND)
     &               -MAX(SOURCEAO(1,1,ISOUR),XIANF)
         CENXEXI=(MIN(SOURCEEO(1,1,ISOUR),XIEND)
     &                 +MAX(SOURCEAO(1,1,ISOUR),XIANF))/2.D0
         DTPHASE=(WTRA2IS(ISOUR)+GAMMA21*DXEXI/2.D0)/CLIGHT1
            FREQR=2.D0*PI1/DTPHASE*HBAREV1
      ENDIF !(IAMPLI.LT.0)

      DO IFREQ=1,NFREQ

        ILIOBFR=ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1))
          IFROB=IFREQ+NFREQ*(IOBSV-1)
          IOBFR=IOBSV+NOBSV*(IFREQ-1)

        IF (IAMPLI.LT.0) THEN

          AX0R=AFREQR(1,IFREQ)
          AX0I=AFREQI(1,IFREQ)
          AY0R=AFREQR(2,IFREQ)
          AY0I=AFREQI(2,IFREQ)
          AZ0R=AFREQR(3,IFREQ)
          AZ0I=AFREQI(3,IFREQ)

          AXR=AX0R
          AXI=AX0I
          AYR=AY0R
          AYI=AY0I
          AZR=AZ0R
          AZI=AZ0I

          AFREQR(1,IFREQ)=0.D0
          AFREQI(1,IFREQ)=0.D0
          AFREQR(2,IFREQ)=0.D0
          AFREQI(2,IFREQ)=0.D0
          AFREQR(3,IFREQ)=0.D0
          AFREQI(3,IFREQ)=0.D0

            R0=OBSV(1,NOBSV/2+1)-CENXEXI
            R02=R0*R0
          R00=R0
            H2=(OBSV(2,IOBSV))**2+(OBSV(3,IOBSV))**2
            H2R2=H2/R02

          DTPHASE=(WTRA2IS(ISOUR)+(H2R2+GAMMA21)*DXEXI/2.D0)/CLIGHT1
          PHI=2.D0*PI1*FREQ(IFREQ)*ECHARGE1/HPLANCK1*DTPHASE

          DMODUR=COS(PHI)
          DMODUI=SIN(PHI)
            DMODU0R=DMODUR
            DMODU0I=DMODUI
          DDMODUR=1.D0
          DDMODUI=0.D0

          DO I=1,-IAMPLI

          R0=OBSV(1,NOBSV/2+1)+DXEXI/2.D0*(-IAMPLI-2*(I-1))
          CORRR0=R00/R0
            R02=R0*R0
            H2=(OBSV(2,IOBSV))**2+(OBSV(3,IOBSV))**2
            H2R2=H2/R02

          DTPHASE=(WTRA2IS(ISOUR)+(H2R2+GAMMA21)*DXEXI/2.D0)/CLIGHT1
          PHI=2.D0*PI1*FREQ(IFREQ)*ECHARGE1/HPLANCK1*DTPHASE

          DMODUR=COS(PHI)
          DMODUI=SIN(PHI)
            DMODU0R=DMODUR
            DMODU0I=DMODUI
          DDMODUR=1.D0
          DDMODUI=0.D0

          AFREQR(1,IFREQ)=AFREQR(1,IFREQ)+AXR
          AFREQI(1,IFREQ)=AFREQI(1,IFREQ)+AXI
          AFREQR(2,IFREQ)=AFREQR(2,IFREQ)+AYR
          AFREQI(2,IFREQ)=AFREQI(2,IFREQ)+AYI
          AFREQR(3,IFREQ)=AFREQR(3,IFREQ)+AZR
          AFREQI(3,IFREQ)=AFREQI(3,IFREQ)+AZI

          IF (AMPRAN.NE.0.D0) THEN

             PHI=2.D0*PI1*XRANA(I)/FREQR*FREQ(IFREQ)

             DDMODUR=COS(PHI)
             DDMODUI=SIN(PHI)

          ENDIF   !(AMPRAN.NE.0.D0)

          DUMR=AX0R*DMODU0R-AX0I*DMODU0I
          DUMI=AX0R*DMODU0I+AX0I*DMODU0R
          AX0R=DUMR
          AX0I=DUMI
          DUMR=AY0R*DMODU0R-AY0I*DMODU0I
          DUMI=AY0R*DMODU0I+AY0I*DMODU0R
          AY0R=DUMR
          AY0I=DUMI
          DUMR=AZ0R*DMODU0R-AZ0I*DMODU0I
          DUMI=AZ0R*DMODU0I+AZ0I*DMODU0R
          AZ0R=DUMR
          AZ0I=DUMI
          AXR=AX0R*CORRR0
          AXI=AX0I*CORRR0
          AYR=AY0R*CORRR0
          AYI=AY0I*CORRR0
          AZR=AZ0R*CORRR0
          AZI=AZ0I*CORRR0

          DMODUR=DMODU0R*DDMODUR-DMODU0I*DDMODUI
          DMODUI=DMODU0R*DDMODUI+DMODU0I*DDMODUR

          DUMR=AXR*DMODUR-AXI*DMODUI
          DUMI=AXR*DMODUI+AXI*DMODUR
          AXR=DUMR
          AXI=DUMI
          DUMR=AYR*DMODUR-AYI*DMODUI
          DUMI=AYR*DMODUI+AYI*DMODUR
          AYR=DUMR
          AYI=DUMI
          DUMR=AZR*DMODUR-AZI*DMODUI
          DUMI=AZR*DMODUI+AZI*DMODUR
          AZR=DUMR
          AZI=DUMI

        ENDDO !IAMPLI

        ENDIF  !(IAMPLI.LT.0)

        AFREQ(1,IFROB)=DCMPLX(AFREQR(1,IFREQ),AFREQI(1,IFREQ))*REFLEC(1)
        AFREQ(2,IFROB)=DCMPLX(AFREQR(2,IFREQ),AFREQI(2,IFREQ))*REFLEC(2)
        AFREQ(3,IFROB)=DCMPLX(AFREQR(3,IFREQ),AFREQI(3,IFREQ))*REFLEC(3)


        IF(SPECCUT.GT.0.0D0) THEN
        IF (ISPECMODE.EQ.1) ECMAXS=ECMAX(ISOUR)
        IF(FREQ(IFREQ).GT.SPECCUT*ecdipev1*DMYENERGY**2*ECMAXS) THEN
          AFREQ(1,IFROB)=(0.D0,0.D0)
          AFREQ(2,IFROB)=(0.D0,0.D0)
          AFREQ(3,IFROB)=(0.D0,0.D0)
        ENDIF
        ENDIF

          IF (IPOLA.EQ.0) THEN

            SPEC(ILIOBFR)=
     &        DREAL(
     &          AFREQ(1,IFROB)*CONJG(AFREQ(1,IFROB))
     &         +AFREQ(2,IFROB)*CONJG(AFREQ(2,IFROB))
     &         +AFREQ(3,IFROB)*CONJG(AFREQ(3,IFROB))
     &         )*SPECNOR

            REAIMA(1,1,IOBFR)=REAIMA(1,1,IOBFR)+
     &        DREAL(AFREQ(1,IFROB))
            REAIMA(2,1,IOBFR)=REAIMA(2,1,IOBFR)+
     &        DREAL(AFREQ(2,IFROB))
            REAIMA(3,1,IOBFR)=REAIMA(3,1,IOBFR)+
     &        DREAL(AFREQ(3,IFROB))

            REAIMA(1,2,IOBFR)=REAIMA(1,2,IOBFR)+
     &        DIMAG(AFREQ(1,IFROB))
            REAIMA(2,2,IOBFR)=REAIMA(2,2,IOBFR)+
     &        DIMAG(AFREQ(2,IFROB))
            REAIMA(3,2,IOBFR)=REAIMA(3,2,IOBFR)+
     &        DIMAG(AFREQ(3,IFROB))

          ELSE    !IPOLA

          APOL=
     &          AFREQ(1,IFROB)*CONJG(VPOLA(1))
     &         +AFREQ(2,IFROB)*CONJG(VPOLA(2))
     &         +AFREQ(3,IFROB)*CONJG(VPOLA(3))

            SPEC(ILIOBFR)=
     &        DREAL(APOL*CONJG(APOL))*SPECNOR
            REAIMA(1,1,IOBFR)=REAIMA(1,1,IOBFR)+
     &        DREAL(AFREQ(1,IFROB))
            REAIMA(2,1,IOBFR)=REAIMA(2,1,IOBFR)+
     &        DREAL(AFREQ(2,IFROB))
            REAIMA(3,1,IOBFR)=REAIMA(3,1,IOBFR)+
     &        DREAL(AFREQ(3,IFROB))

            REAIMA(1,2,IOBFR)=REAIMA(1,2,IOBFR)+
     &        DIMAG(AFREQ(1,IFROB))
            REAIMA(2,2,IOBFR)=REAIMA(2,2,IOBFR)+
     &        DIMAG(AFREQ(2,IFROB))
            REAIMA(3,2,IOBFR)=REAIMA(3,2,IOBFR)+
     &        DIMAG(AFREQ(3,IFROB))

          ENDIF   !IPOLA

      IF (ISTOKES.NE.0) THEN

          APOLH=
     &          AFREQ(1,IFROB)*CONJG(VSTOKES(1,1))
     &         +AFREQ(2,IFROB)*CONJG(VSTOKES(1,2))
     &         +AFREQ(3,IFROB)*CONJG(VSTOKES(1,3))

          APOLR=
     &          AFREQ(1,IFROB)*CONJG(VSTOKES(2,1))
     &         +AFREQ(2,IFROB)*CONJG(VSTOKES(2,2))
     &         +AFREQ(3,IFROB)*CONJG(VSTOKES(2,3))

          APOLL=
     &          AFREQ(1,IFROB)*CONJG(VSTOKES(3,1))
     &         +AFREQ(2,IFROB)*CONJG(VSTOKES(3,2))
     &         +AFREQ(3,IFROB)*CONJG(VSTOKES(3,3))

          APOL45=
     &          AFREQ(1,IFROB)*CONJG(VSTOKES(4,1))
     &         +AFREQ(2,IFROB)*CONJG(VSTOKES(4,2))
     &         +AFREQ(3,IFROB)*CONJG(VSTOKES(4,3))

            STOK1=
     &        APOLR*CONJG(APOLR)+
     &        APOLL*CONJG(APOLL)

            STOK2=-STOK1+
     &        2.*APOLH*CONJG(APOLH)

            STOK3=
     &        2.*APOL45*CONJG(APOL45)-
     &        STOK1

            STOK4=
     &        APOLR*CONJG(APOLR)-
     &        APOLL*CONJG(APOLL)


            STOKES(1,IOBFR)=STOKES(1,IOBFR)+
     &                          STOK1*SPECNOR

            STOKES(2,IOBFR)=STOKES(2,IOBFR)+
     &                          STOK2*SPECNOR

            STOKES(3,IOBFR)=STOKES(3,IOBFR)+
     &                          STOK3*SPECNOR

            STOKES(4,IOBFR)=STOKES(4,IOBFR)+
     &                          STOK4*SPECNOR

      ENDIF !ISTOKES

      ENDDO !IFREQ

        ILIOB=ISOUR+NSOURCE*(IOBSV-1)
        SPECPOW(ILIOB)=SPECPOW(ILIOB)
     &                *ECHARGE1/16.D0/PI1/PI1/EPS01/C
     &                *DMYCUR     !NUMBER OF e-

      IF (IOBSV.EQ.ICBRILL) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &'       phase advance per step at beginning and end of source for'
        WRITE(LUNGFO,*)
     &'       lowest and highest photon energy at selected observation point:'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'       beginning:',SNGL(DPHSOUR(1,1)),SNGL(DPHSOUR(1,2))
        WRITE(LUNGFO,*)'       end:      ',SNGL(DPHSOUR(2,1)),SNGL(DPHSOUR(2,2))
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'       ROIs (boundary, precision, points, asymp. exp.:'
        WRITE(LUNGFO,*)

        DO IROI=1,NROIA-1
                 WRITE(LUNGFO,*)
     &           IROI,SNGL(ROIX(IROI)),SNGL(ROIP(IROI)),IPOIROI(IROI+1)
     &          ,IROIASYEXP(IROI)
        ENDDO
                 WRITE(LUNGFO,*)
     &           NROI,SNGL(ROIX(NROIA))

      ENDIF !IOBSV

        IF (IOBSV.EQ.NOBSV) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'       SOURCE, TOTAL NUMBER OF STEPS:',ISOUR,IZAEHL
        WRITE(LUNGFO,*)'       (controlled by NLPOI and namelist $ROIN)'
        WRITE(LUNGFO,*)

      ENDIF

      RETURN
      END
+DECK,SPBUFINT.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  1.01/01 10/12/97  13.24.52  by  Michael Scheer
*CMZ : 00.02/05 24/03/97  11.32.00  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  17.22.12  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.03  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE SPBUFINT(X,Y,N,RESULT,SIMPLE)
+seq,gplhint.

C--- INTEGRATION USING SPLINES

      IMPLICIT NONE

+SEQ,CMPARA.

      INTEGER N,IFREQ
      DOUBLE PRECISION X(N),Y(N),RESULT,S2(NDFREQP),SIMPLE,DFREQ2,YSUM

C--- SPLINE COEFFICIENTS

      CALL FSPLINEF(X,Y,N,0.D0,0.D0,S2)

C--- INTEGRATION

      RESULT=0.0D0
      SIMPLE=0.D0

      DO IFREQ=1,N-1

      DFREQ2=(X(IFREQ+1)-X(IFREQ))/2.D0
      YSUM=Y(IFREQ)+Y(IFREQ+1)
      SIMPLE=SIMPLE+YSUM*DFREQ2

      RESULT=RESULT
     &          +DFREQ2
     &          *YSUM
     &          -DFREQ2**3/3.D0
     &          *(S2(IFREQ)+S2(IFREQ+1))

      ENDDO !IFREQ


      RETURN
      END
+DECK,SPECANA.
*CMZ :  3.03/01 12/11/2015  12.12.46  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.57/03 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.36/00 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.34/09 26/09/2001  16.25.11  by  Michael Scheer
*CMZ :  2.34/00 11/05/2001  16.21.10  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  14.22.45  by  Michael Scheer
*CMZ :  2.13/04 21/01/2000  14.24.02  by  Michael Scheer
*CMZ :  2.13/03 15/12/99  16.21.34  by  Michael Scheer
*CMZ :  2.13/00 03/12/99  14.58.39  by  Michael Scheer
*CMZ : 00.02/04 25/02/97  16.04.42  by  Michael Scheer
*CMZ : 00.02/03 30/01/97  15.29.53  by  Michael Scheer
*CMZ : 00.00/07 18/05/94  14.54.15  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.54.12  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.24  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE SPECANA
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,WFOLDF90U.
+SELF.

C--- FILL ARRAY SPEC WITH USER SUPPLIED FUNCTION

      IMPLICIT NONE

      INTEGER ICONTROL
      INTEGER IFREQ,IOBSV,ISOUR

      DOUBLE PRECISION SIGY

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,WFOLDF90.
+SEQ,PHYCON.
+SEQ,USERVAR.

      DATA ICONTROL/1/
      DATA SIGY/0.0001D0/

      ICONTROL=USER(1)
      sigy=wsigy(1)

      IF (ICONTROL.EQ.1) THEN

        write(lungfo,*) ' '
        write(lungfo,*) '*** SPECANA: ICONTROL, SIG:',ICONTROL,SIGY
        write(lungfo,*) ' '

        DO IFREQ=1,NFREQ
          DO IOBSV=1,NOBSV
            DO ISOUR=1,NSOURCE
              SPEC(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))=
     &          EXP(-(OBSV(2,IOBSV)/SIGY)**2/2.D0)/SQRT(2.D0*PI1)/SIGY
              SPECPOW(ISOUR+(IOBSV-1)*NSOURCE)=
     &          SPEC(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))
            ENDDO
            STOKES(1,IOBSV+NOBSV*(IFREQ-1))=
     &        SPEC(1+IOBSV-1+NOBSV*(IFREQ-1))
          ENDDO
        ENDDO

      else IF (ICONTROL.EQ.2) THEN

        write(lungfo,*) ' '
        write(lungfo,*) '*** SPECANA: ICONTROL, SIG:',ICONTROL,SIGY
        write(lungfo,*) ' '

        DO IFREQ=1,NFREQ
          DO IOBSV=1,NOBSV
            DO ISOUR=1,NSOURCE
              SPEC(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))=
     &          EXP(-(OBSV(3,IOBSV)/SIGY)**2/2.D0)/SQRT(2.D0*PI1)/SIGY
              SPECPOW(ISOUR+(IOBSV-1)*NSOURCE)=
     &          SPEC(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))
            ENDDO
            STOKES(1,IOBSV+NOBSV*(IFREQ-1))=
     &        SPEC(1+IOBSV-1+NOBSV*(IFREQ-1))
          ENDDO
        ENDDO

      ELSE  !ICONTROL

        DO IFREQ=1,NFREQ
          DO IOBSV=1,NOBSV

            IF (ISTOKES.NE.0) THEN
              STOKES(1,IOBSV+NOBSV*(IFREQ-1))=1.
            ENDIF

            DO ISOUR=1,NSOURCE
              SPEC(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))=1.D0
              SPECPOW(ISOUR+(IOBSV-1)*NSOURCE)=1.D0
            ENDDO
          ENDDO
        ENDDO

      ENDIF !ICONTROL

      RETURN
      END
+DECK,SPECANAF.
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.16/08 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.14/02 27/04/2000  15.53.13  by  Michael Scheer
*CMZ : 00.00/07 18/05/94  14.54.44  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.54.17  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.25  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE SPECANAF
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SELF.

C--- FILL ARRAY SPECF WITH USER SUPPLIED FUNCTION

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,PHYCON.

      INTEGER IFREQ,IOBSV,ISOUR

        DO IFREQ=1,NFREQ
        DO IOBSV=1,NOBSV
        DO ISOUR=1,NSOURCE
+SELF,IF=-NEWWAVE.
            SPECF(ISOUR,IOBSV,IFREQ)=1.D0
+SELF,IF=NEWWAVE.
            SPECF(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))=1.D0
+SELF.
        ENDDO
        ENDDO
        ENDDO


      RETURN
      END
+DECK,SPECDIP.
*CMZ :  4.01/03 12/06/2023  11.25.49  by  Michael Scheer
*CMZ :  3.02/03 07/11/2014  15.50.42  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.67/04 11/05/2012  15.33.54  by  Michael Scheer
*CMZ :  2.57/05 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.57/04 01/02/2006  15.08.35  by  Michael Scheer
*CMZ :  2.34/05 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.33/03 04/05/2001  10.57.10  by  Michael Scheer
*CMZ :  2.33/02 03/05/2001  17.23.28  by  Michael Scheer
*CMZ :  2.33/01 03/05/2001  14.00.28  by  Michael Scheer
*CMZ :  2.33/00 02/05/2001  12.12.06  by  Michael Scheer
*CMZ :  2.31/00 24/04/2001  11.13.55  by  Michael Scheer
*CMZ :  2.20/01 12/12/2000  10.01.31  by  Michael Scheer
*CMZ :  2.16/08 31/10/2000  17.29.14  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  2.13/03 10/01/2000  17.17.14  by  Michael Scheer
*CMZ :  2.00/00 15/12/98  14.29.27  by  Michael Scheer
*CMZ : 00.02/02 15/01/97  15.18.41  by  Michael Scheer
*CMZ : 00.00/07 18/05/94  14.54.15  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.54.12  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.24  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE SPECDIP
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SELF.

C--- FILL ARRAY SPEC WITH DIPOL SPECTRUM FUNCTION

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,FREQS.
+seq,sourcef90.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,SPECDIP.
+SEQ,PHYCON.

      INTEGER ISOUR,IFREQ,IOBSV,IDIP,IEPS,ical

      DOUBLE PRECISION RX,RY,RZ,RR,PSI,DFDTDP,PAR,PER,POWR
      DOUBLE PRECISION BS,BRX,BRY,BRZ,BRN,RN,BX,BY,BZ,VN
      DOUBLE PRECISION OMEGAC,Y
      DOUBLE PRECISION DX2,DZY2,EPS(6),DRRED,ANS,OM,
     &  APERANG,APERV(3),APERCORR,const

      COMPLEX*16 APOL,AFREQ(3),EXPOM
      COMPLEX*16 APOLH,APOLR,APOLL,APOL45

      REAL*8 STOK1,STOK2,STOK3,STOK4

      data ical/0/

      if (ical.eq.0) then
        if (iphase.ne.0) then
          write(lungfo,*)'*** WARNING IN SPECDIP: Calculation for B-Field-Amplitude for phase propagation not yet implement ***'
          write(6,*)'*** WARNING IN SPECDIP: Calculation for B-Field-Amplitude for phase propagation not yet implement ***'
        endif
        CONST=sqrt(3.0D0)/2.0D0/pi1*ALPHA1/ECHARGE1/emassg1/banwid*0.001d0/1.0d6
c        CONST=2.457d13
        const=const*pinw/pincen(1)*1.0d3*dmyenergy
        ical=1
      endif

      IF (APERTHICK.GT.0.0D0) THEN

        APERV(2)=SIN(APERVANG)
        APERV(3)=SIN(APERHANG)
        APERV(1)=SQRT(1.0D0-(APERV(2)**2+APERV(3)**2))

      ELSE

        APERV=0.0D0
        APERHANG=0.0D0
        APERVANG=0.0D0

      ENDIF

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SR SPECDIP CALLED:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     cut-off parameter (SPECCUT): ',SNGL(SPECCUT)
      WRITE(LUNGFO,*)

      if (ispecdip.eq.2) then
        WRITE(LUNGFO,*)
     &    '     Due to ISPECDIP=2, G1 is calculated instead of photon flux'
      else
        WRITE(LUNGFO,*)
     &    '     Numer of dipole, field (proj.), bending radius ,Ec [eV], cut-off,'
        WRITE(LUNGFO,*)
     &    '     X,Y,Z-Pos. [m], velocity vector (norm.), proj. mag. field vector [T]:'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     thickness of aperture pinhole [m]:',sngl(aperthick)
        WRITE(LUNGFO,*)'     hor. and vert. angle of aperture [rad]:',
     &    sngl(aperhang),sngl(apervang)
        WRITE(LUNGFO,*)
      endif

      DO IDIP=1,NDIP

        VN=SQRT(VXDIP(IDIP)*VXDIP(IDIP)+VYDIP(IDIP)*VYDIP(IDIP)
     &    +VZDIP(IDIP)*VZDIP(IDIP))

        IF (VN.EQ.0.D0) THEN
          VXDIP(IDIP)=1.D0
          VN=1.D0
        ENDIF   !VN

        VXDIP(IDIP)=VXDIP(IDIP)/VN
        VYDIP(IDIP)=VYDIP(IDIP)/VN
        VZDIP(IDIP)=VZDIP(IDIP)/VN

        BS=BXDIP(IDIP)*VXDIP(IDIP)
     &    +BYDIP(IDIP)*VYDIP(IDIP)
     &    +BZDIP(IDIP)*VZDIP(IDIP)

        BXDIP(IDIP)=BXDIP(IDIP)-BS*VXDIP(IDIP)
        BYDIP(IDIP)=BYDIP(IDIP)-BS*VYDIP(IDIP)
        BZDIP(IDIP)=BZDIP(IDIP)-BS*VZDIP(IDIP)

        B0DIP(IDIP)=SQRT(
     &    BXDIP(IDIP)*BXDIP(IDIP)
     &    +BYDIP(IDIP)*BYDIP(IDIP)
     &    +BZDIP(IDIP)*BZDIP(IDIP))

        IF (B0DIP(IDIP).NE.0.D0) THEN
          RHODIP(IDIP)=EMOM/ABS(B0DIP(IDIP))/CLIGHT1
        ELSE
          if (ispecdip.eq.2) then
            b0dip(idip)=1.0d0
            RHODIP(IDIP)=EMOM/ABS(B0DIP(IDIP))/CLIGHT1
          else
            WRITE(LUNGFO,*)'*** ERROR IN SPECDIP ***'
            WRITE(LUNGFO,*)'zero magnetic field for dipole ',IDIP
            WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
            WRITE(6,*)'*** ERROR IN SPECDIP ***'
            WRITE(6,*)'zero magnetic field for dipole ',IDIP
            WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
            STOP
          endif
        ENDIF

        OMEGAC=1.5D0*DMYGAMMA**3*CLIGHT1/RHODIP(IDIP)
        ECDIP(IDIP)=OMEGAC*HBAR1/ECHARGE1

        if (ispecdip.eq.2) then
          ecdip(idip)=1.0d0
        else
          WRITE(LUNGFO,'(I5,4(1PE15.3))')
     &      IDIP,SNGL(B0DIP(IDIP)),SNGL(RHODIP(IDIP)),SNGL(ECDIP(IDIP))
     &      ,SNGL(ECDIP(IDIP)*SPECCUT)
          WRITE(LUNGFO,'(XXXXX,3(1PE15.3))')
     &      SNGL(X0DIP(IDIP)),SNGL(Y0DIP(IDIP)),SNGL(Z0DIP(IDIP))
          WRITE(LUNGFO,'(XXXXX,3(1PE15.3))')
     &      SNGL(VXDIP(IDIP)),SNGL(VYDIP(IDIP)),SNGL(VZDIP(IDIP))
          WRITE(LUNGFO,'(XXXXX,3(1PE15.3))')
     &      SNGL(BXDIP(IDIP)),SNGL(BYDIP(IDIP)),SNGL(BZDIP(IDIP))
        endif
      ENDDO !NDIP

      WRITE(LUNGFO,*)

+SELF,IF=-F90.
      IF (NDIP.GT.LIDIMP) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '*** ERROR IN SPECDIP: NUMBER OF DIPOLES EXCEEDS DIMENSION'
        WRITE(LUNGFO,*)'INCREASE LIDIMP IN CMPARA.CMN'
        WRITE(6,*)
        WRITE(6,*)
     &    '*** ERROR IN SPECDIP: NUMBER OF DIPOLES EXCEEDS DIMENSION'
        WRITE(6,*)'INCREASE LIDIMP IN CMPARA.CMN'
        STOP '--- PROGRAM WAVE ABORTED ---'
      ENDIF
+SELF.

      NSOURCE=NDIP

      DO IDIP=1,NDIP

        ISOUR=IDIP

        IF (APERTHICK.GT.0.0D0) THEN

          RX=OBSV(1,ICBRILL)-X0DIP(IDIP)
          RY=OBSV(2,ICBRILL)-Y0DIP(IDIP)
          RZ=OBSV(3,ICBRILL)-Z0DIP(IDIP)

          IF (RX.LE.0.D0) THEN
            WRITE(LUNGFO,*)'*** ERROR IN SPECDIP:'
            WRITE(LUNGFO,*)'BAD X-DISTANCE FROM SOURCE TO OBSERVER'
            WRITE(LUNGFO,*)'CHECK INPUT FILE'
            WRITE(6,*)'*** ERROR IN SPECDIP:'
            WRITE(6,*)'BAD X-DISTANCE FROM SOURCE TO OBSERVER'
            WRITE(6,*)'CHECK INPUT FILE'
            STOP '--- PROGRAM WAVE ABORTED ---'
          ENDIF

          RR=RX*RX+RY*RY+RZ*RZ
          RN=SQRT(RR)

          APERANG=ACOS((RX*APERV(1)+RY*APERV(2)+RZ*APERV(3))/RN)

          IF (IPINCIRC.EQ.0) THEN
            CALL THICKAPP(IPINCIRC,APERTHICK,PINW/2.0D0,APERANG,APERCORR)
          ELSE !IPINCIRC
            CALL THICKAPP(IPINCIRC,APERTHICK,PINR,APERANG,APERCORR)
          ENDIF

        ELSE !APERTHICK

          APERCORR=1.0D0

        ENDIF !APERTHICK

        DO IFREQ=1,NFREQ

          Y=FREQ(IFREQ)/ECDIP(IDIP)

          DO IOBSV=1,NOBSV

            RX=OBSV(1,IOBSV)-X0DIP(IDIP)
            RY=OBSV(2,IOBSV)-Y0DIP(IDIP)
            RZ=OBSV(3,IOBSV)-Z0DIP(IDIP)

            IF (RX.LE.0.D0) THEN
              WRITE(LUNGFO,*)'*** ERROR IN SPECDIP:'
              WRITE(LUNGFO,*)'BAD X-DISTANCE FROM SOURCE TO OBSERVER'
              WRITE(LUNGFO,*)'CHECK INPUT FILE'
              WRITE(6,*)'*** ERROR IN SPECDIP:'
              WRITE(6,*)'BAD X-DISTANCE FROM SOURCE TO OBSERVER'
              WRITE(6,*)'CHECK INPUT FILE'
              STOP '--- PROGRAM WAVE ABORTED ---'
            ENDIF

            RR=RX*RX+RY*RY+RZ*RZ
            RN=SQRT(RR)

            BS=B0DIP(IDIP)
            BX=BXDIP(IDIP)
            BY=BYDIP(IDIP)
            BZ=BZDIP(IDIP)

            BRX=BY*RZ-BZ*RY
            BRY=BZ*RX-BX*RZ
            BRZ=BX*RY-BY*RX

            BRN=SQRT(BRX*BRX+BRY*BRY+BRZ*BRZ)

            IF (BS.NE.0.D0) THEN
              PSI=ACOS(MIN(BRN/BS/RN,1.D0))
     &          *SIGN(1.D0,BX*RX+BY*RY+BZ*RZ)
            ELSE
              PSI=0.D0
            ENDIF

+SELF,IF=-NEWWAVE.
            SPEC(ISOUR,IOBSV,IFREQ)=
     &        DFDTDP(Y,PSI,DMYGAMMA,DMYCUR,BANWID,PAR,PER,POWR)/RR
     &      *APERCORR

            IF (SPECCUT.NE.0.D0.AND.Y.GT.SPECCUT) THEN
              SPEC(ISOUR,IOBSV,IFREQ)=0.D0
              PAR=0.D0
              PER=0.D0
            ENDIF   !SPECCUT

            SPECPOW(ISOUR,IOBSV)=POWR/RHODIP(IDIP)/RR
     &      *APERCORR

            AFREQ(1)=(0.D0,0.D0)
            AFREQ(2)=DCMPLX(0.D0,-SQRT(PER/RR/SPECNOR))
     &      *APERCORR
            AFREQ(3)=DCMPLX(SQRT(PAR/RR/SPECNOR),0.D0)
     &      *APERCORR

+SELF,IF=NEWWAVE.

            ILIOBFR=ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1))
            IOBFR=IOBSV+NOBSV*(IFREQ-1)

            if (ispecdip.ne.2) then
              SPEC(ILIOBFR)=
     &          DFDTDP(Y,PSI,DMYGAMMA,DMYCUR,BANWID,PAR,PER,POWR)/RR
     &          *APERCORR
            else
              SPEC(ILIOBFR)=
     &          DFDTDP(Y,PSI,DMYGAMMA,DMYCUR,BANWID,PAR,PER,POWR)/RR
     &          /const
            endif

            IF (SPECCUT.NE.0.D0.AND.Y.GT.SPECCUT) THEN
              SPEC(ILIOBFR)=0.D0
              PAR=0.D0
              PER=0.D0
            ENDIF   !SPECCUT

            SPECPOW(ISOUR+NSOURCE*(IOBSV-1))=POWR/RHODIP(IDIP)/RR
     &      *APERCORR

            EXPOM=(1.D0,0.D0)

            IF (IPIN.NE.0) THEN

              DX2=RX*RX
              DZY2=RZ*RZ+RY*RY

              OM=FREQ(IFREQ)/(HBAREV1*CLIGHT1)

C       TO MAKE SURE THAT TAYLOR-EXPANSION IS VALID

              IF (DZY2.GT.0.01D0*DX2) THEN
                WRITE(LUNGFO,*)
     &            '*** ERROR IN SPECDIPA: OBSERVATION ANGLE TO LARGE ***'
                WRITE(LUNGFO,*)'DECREASE SIZE OF PINHOLE OR WGWINFC ...'
                WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
                WRITE(6,*)
     &            '*** ERROR IN SPECDIPA: OBSERVATION ANGLE TO LARGE ***'
                WRITE(6,*)'DECREASE SIZE OF PINHOLE OR WGWINFC ...'
                WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
                STOP
              ENDIF    !(DZY2.GT.0.01D0*DX2)

              EPS(1)=DZY2/DX2

              DO IEPS=2,6
                EPS(IEPS)=EPS(IEPS-1)*EPS(1)
              ENDDO !IEPS

c        TAYLOR-EXPANSION DONE WITH REDUCE
c       IN "WTAY1.RED";
c       on rounded;
c       on numval;
c       precision 13;
c       F:=SQRT(1+EPS);
c       DR:=TAY1(F,EPS,6);
c       ON FORT;
c       OUT "RED.FOR";
c       DR;
c       SHUT "RED.FOR";
C ans is actually reduce by 1.0 to avoid large overall phase

              ans=-0.0205078125D0*eps(6)+0.02734375D0*eps(5)
     &          -0.0390625D0*eps(4)+
     &          0.0625D0*eps(3)-0.125D0*eps(2)+0.5D0*eps(1)

              DRRED=-DABS(RX*ANS)
              EXPOM=CDEXP(DCMPLX(0.D0,DRRED*OM))

            ENDIF !IPIN

            AFREQ(1)=(0.D0,0.D0)
            AFREQ(2)=DCMPLX(0.D0,-SQRT(PER/RR/SPECNOR))*EXPOM
     &      *APERCORR
            AFREQ(3)=DCMPLX(SQRT(PAR/RR/SPECNOR),0.D0)*EXPOM*SIGN(1.D0,PSI)
     &      *APERCORR

            REAIMA(1,1,IOBFR)=DREAL(AFREQ(1))
            REAIMA(1,2,IOBFR)=DIMAG(AFREQ(1))
            REAIMA(2,1,IOBFR)=DREAL(AFREQ(2))
            REAIMA(2,2,IOBFR)=DIMAG(AFREQ(2))
            REAIMA(3,1,IOBFR)=DREAL(AFREQ(3))
            REAIMA(3,2,IOBFR)=DIMAG(AFREQ(3))

            IF (IPOLA.NE.0) THEN
              APOL=
     &          AFREQ(1)*CONJG(VPOLA(1))
     &          +AFREQ(2)*CONJG(VPOLA(2))
     &          +AFREQ(3)*CONJG(VPOLA(3))
              SPEC(ILIOBFR)=
     &          DREAL(APOL*CONJG(APOL))*SPECNOR
            ENDIF !IPOLA

            IF (ISTOKES.NE.0) THEN

              APOLH=
     &          AFREQ(1)*CONJG(VSTOKES(1,1))
     &          +AFREQ(2)*CONJG(VSTOKES(1,2))
     &          +AFREQ(3)*CONJG(VSTOKES(1,3))

              APOLR=
     &          AFREQ(1)*CONJG(VSTOKES(2,1))
     &          +AFREQ(2)*CONJG(VSTOKES(2,2))
     &          +AFREQ(3)*CONJG(VSTOKES(2,3))

              APOLL=
     &          AFREQ(1)*CONJG(VSTOKES(3,1))
     &          +AFREQ(2)*CONJG(VSTOKES(3,2))
     &          +AFREQ(3)*CONJG(VSTOKES(3,3))

              APOL45=
     &          AFREQ(1)*CONJG(VSTOKES(4,1))
     &          +AFREQ(2)*CONJG(VSTOKES(4,2))
     &          +AFREQ(3)*CONJG(VSTOKES(4,3))

              STOK1=
     &          APOLR*CONJG(APOLR)+
     &          APOLL*CONJG(APOLL)

              STOK2=-STOK1+
     &          2.0d0*APOLH*CONJG(APOLH)

              STOK3=
     &          2.0d0*APOL45*CONJG(APOL45)-
     &          STOK1

              STOK4=
     &          APOLR*CONJG(APOLR)-
     &          APOLL*CONJG(APOLL)

              if (abs(stok1)*specnor.gt.1.0D-30)
     &          STOKES(1,IOBFR)=STOKES(1,IOBFR)+
     &          STOK1*SPECNOR

              if (abs(stok2)*specnor.gt.1.0D-30)
     &          STOKES(2,IOBFR)=STOKES(2,IOBFR)+
     &          STOK2*SPECNOR

              if (abs(stok3)*specnor.gt.1.0D-30)
     &          STOKES(3,IOBFR)=STOKES(3,IOBFR)+
     &          STOK3*SPECNOR

              if (abs(stok4)*specnor.gt.1.0D-30)
     &          STOKES(4,IOBFR)=STOKES(4,IOBFR)+
     &          STOK4*SPECNOR

            ENDIF !ISTOKES

+SELF.
+SELF,IF=-NEWWAVE.
            SPECTOT(IOBSV,IFREQ)=SPECTOT(IOBSV,IFREQ)
     &        +SPEC(ISOUR,IOBSV,IFREQ)
+SELF,IF=NEWWAVE.
            SPECTOT(IOBFR)=SPECTOT(IOBFR)
     &        +SPEC(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))
+SELF.

          ENDDO   !OBSV
        ENDDO  !IFREQ

      ENDDO !NDIP

      RETURN
      END
+DECK,SPECDIPA.
*CMZ :  4.01/07 29/10/2024  16.38.36  by  Michael Scheer
*CMZ :  4.01/03 12/06/2023  11.29.13  by  Michael Scheer
*CMZ :  4.00/17 04/10/2022  08.10.22  by  Michael Scheer
*CMZ :  4.00/15 13/02/2022  16.33.42  by  Michael Scheer
*CMZ :  4.00/11 15/06/2021  10.34.53  by  Michael Scheer
*CMZ :  3.08/01 02/04/2019  15.33.15  by  Michael Scheer
*CMZ :  3.02/03 07/11/2014  15.53.20  by  Michael Scheer
*CMZ :  3.02/00 18/09/2014  14.19.02  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  14.04.56  by  Michael Scheer
*CMZ :  2.69/00 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.66/04 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.66/03 12/11/2009  16.27.11  by  Michael Scheer
*CMZ :  2.63/05 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  2.57/04 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.52/03 08/07/2004  13.35.44  by  Michael Scheer
*CMZ :  2.44/01 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.41/09 14/08/2002  17.16.34  by  Michael Scheer
*CMZ :  2.41/04 21/03/2002  12.47.15  by  Michael Scheer
*CMZ :  2.41/02 21/03/2002  12.39.45  by  Michael Scheer
*CMZ :  2.41/01 20/03/2002  19.34.03  by  Michael Scheer
*CMZ :  2.41/00 20/03/2002  19.23.14  by  Michael Scheer
*CMZ :  2.34/01 01/06/2001  15.33.00  by  Michael Scheer
*CMZ :  2.33/02 03/05/2001  17.18.32  by  Michael Scheer
*CMZ :  2.33/01 03/05/2001  12.21.08  by  Michael Scheer
*CMZ :  2.33/00 03/05/2001  10.55.42  by  Michael Scheer
*CMZ :  2.32/04 26/04/2001  12.24.00  by  Michael Scheer
*CMZ :  2.32/01 25/04/2001  19.08.58  by  Michael Scheer
*CMZ :  2.31/01 25/04/2001  17.10.34  by  Michael Scheer
*CMZ :  2.31/00 24/04/2001  14.48.24  by  Michael Scheer
*CMZ :  2.20/01 12/12/2000  10.01.31  by  Michael Scheer
*CMZ :  2.16/08 31/10/2000  17.29.14  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  2.13/03 10/01/2000  17.17.14  by  Michael Scheer
*CMZ :  2.00/00 15/12/98  14.29.27  by  Michael Scheer
*CMZ : 00.02/02 15/01/97  15.18.41  by  Michael Scheer
*CMZ : 00.00/07 18/05/94  14.54.15  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.54.12  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.24  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE SPECDIPA
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,TRACKF90U.

C--- FILL ARRAY SPEC WITH DIPOL SPECTRUM FUNCTION

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,COLLI.
+SEQ,FREQS.
+seq,sourcef90.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,TRACK.
+SEQ,SPECDIP.
+SEQ,PHYCON.
+seq,datetime.
+seq,debugwave.

      INTEGER ISOUR,IFREQ,IOBSV,ISPLN,ITANG,I,IC,JC,IFAIL,J,JDX10,JX10,IX10
     &  ,IWARN,IEPS,IWARNOB,iout

      DOUBLE PRECISION T,XT,YT,ZT,VXT,VYT,VZT,VXP,VYP,VZP,BS
      DOUBLE PRECISION RX,RY,RZ,RR3,RR,PSI,DFDTDP,PAR,PER,POWR,OBANG,OBANGMN
     &  ,ANG3(3),XT3(3),YT3(3),ZT3(3),VXT3(3),VYT3(3),VZT3(3),A(3),
     &  dum3(3)
      DOUBLE PRECISION Y,OMEGAC,BX,BY,BZ,BRX,BRY,BRZ,RN,VN,DUM,BRN

      DOUBLE PRECISION DX2,DZY2,EPS(6),DRRED,ANS,OM,
     &  APERANG,APERV(3),APERCORR,
     &  RXX,RYY,RZZ,RRN,RRR,
     &  GAMMA

      REAL*8 STOK1,STOK2,STOK3,STOK4

      COMPLEX*16 APOL,AFREQ(3),EXPOM
      COMPLEX*16 APOLH,APOLR,APOLL,APOL45

      integer :: ical=0
      save ical

      DATA JX10/0/

      if (ical.eq.0.and.iphase.ne.0) then
        write(lungfo,*)'*** WARNING IN SPECDIPA: Calculation for B-Field-Amplitude for phase propagation not yet implement ***'
        write(6,*)'*** WARNING IN SPECDIPA: Calculation for B-Field-Amplitude for phase propagation not yet implement ***'
        ical=1
      endif

      IF (ISPECDIP.EQ.-4) THEN
        call specdip4
        return
      endif

      CALL date_and_time(dtday,dttime,dtzone,idatetime)

      if (ispecdip.ne.0) then
        WRITE(6,*)
        WRITE(6,*)' Starting spectrum calculations according to SCHWINGER: '
     &    ,dttime(1:2),':',dttime(3:4),':',dttime(5:6)
        WRITE(6,*)
      endif

      GAMMA=DMYGAMMA

      IF (APERTHICK.GT.0.0D0) THEN

        APERV(2)=SIN(APERVANG)
        APERV(3)=SIN(APERHANG)
        APERV(1)=SQRT(1.0D0-(APERV(2)**2+APERV(3)**2))

      ELSE

        APERV=0.0D0
        APERHANG=0.0D0
        APERVANG=0.0D0

      ENDIF

      IF (NOBSV.GT.1) THEN
        WRITE(6,*)' '
        WRITE(6,*)
     &    '      counting from 1 to 10 for first source to show progress:'
        WRITE(6,*)' '
      ENDIF

      if (ispecdip.ne.0) then
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     Subroutine SPECDIPA called to calculate spectra according to SCHWINGER'
        WRITE(LUNGFO,*)
     &    '     for found sources:'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     photon energy cut-off parameter (SPECCUT): ',SNGL(SPECCUT)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     thickness of aperture pinhole [m]:',sngl(aperthick)
        WRITE(LUNGFO,*)'     hor. and vert. angle of aperture [rad]:',
     &    sngl(aperhang),sngl(apervang)
        WRITE(LUNGFO,*)
      endif

      JDX10=NOBSV/10
      JX10=JDX10
      IX10=1

      IF (JDX10.LT.1) JDX10=1

      IF (ISPECDIP.EQ.-1) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '      center of found source is taken for as dipole source'
        WRITE(LUNGFO,*)
      ELSE IF (ISPECDIP.EQ.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '      Points of primary trajectory with lowest radiation angle'
        WRITE(LUNGFO,*)
     &    '      to observation points are taken to estimate location of source points.'
        WRITE(LUNGFO,*)
      ELSE IF (ISPECDIP.EQ.-2) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '      Points of primary trajectory with lowest radiation angle'
        WRITE(LUNGFO,*)
     &    '      to observation points are taken as dipole source.'
        WRITE(LUNGFO,*)
      ELSE
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '      Source from primary trajectory is retracked with high resolution.'
        WRITE(LUNGFO,*)
     &    '      Points with lowest radiation angle to observation points'
        WRITE(LUNGFO,*)
     &    '      are taken as dipole sources.'
        WRITE(LUNGFO,*)
      ENDIF

      WRITE(LUNGFO,*)
     &  '     number of source, number of observation point,'
      WRITE(LUNGFO,*)
     &  '     field, bending radius ,Ec [eV], cut-off (due to SPECCUT),'
      WRITE(LUNGFO,*)
     &  '      and X,Y,Z-Pos. [m] for selected observation point:'
      WRITE(LUNGFO,*)

      DO ISOUR=1,NSOURCE

        IWARN=0
        IWARNOB=0

        IF (ISPECDIP.LE.-3) THEN
          DO JC=1,4
            DO IC=1,3
              SOURCEAO(IC,JC,ISOUR)=SOURCEA(IC,JC,ISOUR)
              SOURCEEO(IC,JC,ISOUR)=SOURCEE(IC,JC,ISOUR)
            ENDDO
          ENDDO
          CALL TRASOU(ISOUR)
        ENDIF  !ISPECDIP

        DO IOBSV=1,NOBSV

          IF (ISPECDIP.EQ.-2.or.ispecdip.eq.0) THEN

            iout=0

            OBANGMN=1.D30
            IF (ISOURAE(2,ISOUR)-ISOURAE(1,ISOUR).LT.3) THEN
              ITANG=ISOURAE(1,ISOUR)+1
            ELSE  !ISOURAE
              DO I=ISOURAE(1,ISOUR)+1,ISOURAE(2,ISOUR)-1
                XT=WTRA(1,1,I)
                YT=WTRA(2,1,I)
                ZT=WTRA(3,1,I)
                VXT=WTRA(1,2,I)
                VYT=WTRA(2,2,I)
                VZT=WTRA(3,2,I)
                RX=OBSV(1,IOBSV)-XT
                RY=OBSV(2,IOBSV)-YT
                RZ=OBSV(3,IOBSV)-ZT
                IF (RX.LE.0.D0) THEN
                  WRITE(LUNGFO,*)'*** ERROR IN SPECDIPA:'
                  WRITE(LUNGFO,*)'BAD X-DISTANCE FROM SOURCE TO OBSERVER'
                  WRITE(LUNGFO,*)'CHECK INPUT FILE'
                  WRITE(6,*)'*** ERROR IN SPECDIPA:'
                  WRITE(6,*)'BAD X-DISTANCE FROM SOURCE TO OBSERVER'
                  WRITE(6,*)'CHECK INPUT FILE'
                  STOP '--- PROGRAM WAVE ABORTED ---'
                ENDIF
                RR=RX*RX+RY*RY+RZ*RZ
                RN=SQRT(RR)
                VN=SQRT(VXT*VXT+VYT*VYT+VZT*VZT)
                OBANG=ACOS(MIN((RX*VXT+RY*VYT+RZ*VZT)/RN/VN,1.D0))
                IF (ABS(OBANG).LT.OBANGMN) THEN
                  CALL MYBFELD(XT,YT,ZT,BX,BY,BZ,DUM,DUM,DUM)
                  ITANG=I
                  OBANGMN=OBANG
                ENDIF   !(ABS(OBANG).LT.OBANGMN)
              ENDDO   !ISOURAE
            ENDIF   !ISOURAE

            IF (ITANG.LT.2) ITANG=2
            IF (ITANG.GE.NCO) ITANG=NCO-1
            DO J=1,3
              I=ITANG+J-2
              XT=WTRA(1,1,I)
              YT=WTRA(2,1,I)
              ZT=WTRA(3,1,I)
              VXT=WTRA(1,2,I)
              VYT=WTRA(2,2,I)
              VZT=WTRA(3,2,I)
              RX=OBSV(1,IOBSV)-XT
              RY=OBSV(2,IOBSV)-YT
              RZ=OBSV(3,IOBSV)-ZT
              IF (RX.LE.0.D0) THEN
                WRITE(LUNGFO,*)'*** ERROR IN SPECDIPA:'
                WRITE(LUNGFO,*)'BAD X-DISTANCE FROM SOURCE TO OBSERVER'
                WRITE(LUNGFO,*)'CHECK INPUT FILE'
                WRITE(6,*)'*** ERROR IN SPECDIPA:'
                WRITE(6,*)'BAD X-DISTANCE FROM SOURCE TO OBSERVER'
                WRITE(6,*)'CHECK INPUT FILE'
                STOP '--- PROGRAM WAVE ABORTED ---'
              ENDIF
              RR=RX*RX+RY*RY+RZ*RZ
              RN=SQRT(RR)
              VN=SQRT(VXT*VXT+VYT*VYT+VZT*VZT)
              OBANG=ACOS(MIN((RX*VXT+RY*VYT+RZ*VZT)/RN/VN,1.D0))
              ANG3(J)=OBANG
              XT3(J)=XT
              YT3(J)=YT
              ZT3(J)=ZT
              VXT3(J)=VXT
              VYT3(J)=VYT
              VZT3(J)=VZT
            ENDDO   !J=1,3

            CALL UTIL_PARABEL(XT3,ANG3,A,DUM3,XT,OBANG,IFAIL)

            IF (XT.GT.XT3(3).OR.XT.LT.XT3(1)) THEN

              iout=1

              IF (IWARN.EQ.0) THEN
                WRITE(LUNGFO,*)'*** WARNING IN SPECDIPA:'
                WRITE(LUNGFO,*)'problems finding tangent point, setting flux-density zero'
                WRITE(LUNGFO,*)'source number ',ISOUR
                WRITE(LUNGFO,*)'observ. point ',sngl(obsv(1:3,iobsv))
                WRITE(LUNGFO,*)
     &            'maybe low WBL0CUT in namelist COLLIN causes problems or observation point outide radiation cone'
                WRITE(LUNGFO,*)'presumably you may ignore this warning'
                WRITE(LUNGFO,*)
     &            '... or turn option IWIGGLER off and tune parameters'
                WRITE(LUNGFO,*)
     &            'ISPECDIP, WBL0CUT ... by hand'
                WRITE(6,*)'*** WARNING IN SPECDIPA:'
                WRITE(6,*)'problems finding tangent point, setting flux-density zero'
                WRITE(6,*)'source number ',ISOUR
                WRITE(6,*)'observ. point ',sngl(obsv(1:3,iobsv))
                WRITE(6,*)
     &            'maybe low WBL0CUT in namelist COLLIN causes problems'
                WRITE(6,*)'presumably you may ignore this warning'
                WRITE(6,*)
     &            '... or turn option IWIGGLER off and tune parameters'
                WRITE(6,*)
     &            'ISPECDIP, WBL0CUT ... by hand'
                IWARN=1
              ENDIF   !IWARN

              XT=XT3(2)

            ENDIF   !XT3

            IF (IFAIL.NE.0) THEN
              WRITE(LUNGFO,*)'*** WARNING IN SPECDIPA:'
              WRITE(LUNGFO,*)'BAD RETURN OF UTIL_PARABEL'
              WRITE(LUNGFO,*)'TRY DIFFERENT ISPECDIP OR OTHER SETTING'
              WRITE(6,*)'*** WARNING IN SPECDIPA:'
              WRITE(6,*)'BAD RETURN OF UTIL_PARABEL'
              WRITE(6,*)'TRY DIFFERENT ISPECDIP OR OTHER SETTING'
            ENDIF   !IFAIL

            CALL UTIL_PARABEL(XT3,YT3,A,DUM3,DUM,DUM,IFAIL)

            IF (IFAIL.NE.0) THEN
              WRITE(LUNGFO,*)'*** WARNING IN SPECDIPA:'
              WRITE(LUNGFO,*)'BAD RETURN OF UTIL_PARABEL'
              WRITE(LUNGFO,*)'TRY DIFFERENT ISPECDIP OR OTHER SETTING'
              WRITE(6,*)'*** WARNING IN SPECDIPA:'
              WRITE(6,*)'BAD RETURN OF UTIL_PARABEL'
              WRITE(6,*)'TRY DIFFERENT ISPECDIP OR OTHER SETTING'
            ENDIF   !IFAIL

            YT=A(1)+A(2)*XT+A(3)*XT*XT

            CALL UTIL_PARABEL(XT3,ZT3,A,DUM3,DUM,DUM,IFAIL)

            IF (IFAIL.NE.0) THEN
              WRITE(LUNGFO,*)'*** WARNING IN SPECDIPA:'
              WRITE(LUNGFO,*)'BAD RETURN OF UTIL_PARABEL'
              WRITE(LUNGFO,*)'TRY DIFFERENT ISPECDIP OR OTHER SETTING'
              WRITE(6,*)'*** WARNING IN SPECDIPA:'
              WRITE(6,*)'BAD RETURN OF UTIL_PARABEL'
              WRITE(6,*)'TRY DIFFERENT ISPECDIP OR OTHER SETTING'
            ENDIF   !IFAIL

            ZT=A(1)+A(2)*XT+A(3)*XT*XT

            CALL UTIL_PARABEL(XT3,VXT3,A,DUM3,DUM,DUM,IFAIL)

            IF (IFAIL.NE.0) THEN
              WRITE(LUNGFO,*)'*** WARNING IN SPECDIPA:'
              WRITE(LUNGFO,*)'BAD RETURN OF UTIL_PARABEL'
              WRITE(LUNGFO,*)'TRY DIFFERENT ISPECDIP OR OTHER SETTING'
              WRITE(6,*)'*** WARNING IN SPECDIPA:'
              WRITE(6,*)'BAD RETURN OF UTIL_PARABEL'
              WRITE(6,*)'TRY DIFFERENT ISPECDIP OR OTHER SETTING'
            ENDIF   !IFAIL

            VXT=A(1)+A(2)*XT+A(3)*XT*XT

            CALL UTIL_PARABEL(XT3,VYT3,A,DUM3,DUM,DUM,IFAIL)

            IF (IFAIL.NE.0) THEN
              WRITE(LUNGFO,*)'*** WARNING IN SPECDIPA:'
              WRITE(LUNGFO,*)'BAD RETURN OF UTIL_PARABEL'
              WRITE(LUNGFO,*)'TRY DIFFERENT ISPECDIP OR OTHER SETTING'
              WRITE(6,*)'*** WARNING IN SPECDIPA:'
              WRITE(6,*)'BAD RETURN OF UTIL_PARABEL'
              WRITE(6,*)'TRY DIFFERENT ISPECDIP OR OTHER SETTING'
            ENDIF   !IFAIL

            VYT=A(1)+A(2)*XT+A(3)*XT*XT

            CALL UTIL_PARABEL(XT3,VZT3,A,DUM3,DUM,DUM,IFAIL)

            IF (IFAIL.NE.0) THEN
              WRITE(LUNGFO,*)'*** WARNING IN SPECDIPA:'
              WRITE(LUNGFO,*)'BAD RETURN OF UTIL_PARABEL'
              WRITE(LUNGFO,*)'TRY DIFFERENT ISPECDIP OR OTHER SETTING'
              WRITE(6,*)'*** WARNING IN SPECDIPA:'
              WRITE(6,*)'BAD RETURN OF UTIL_PARABEL'
              WRITE(6,*)'TRY DIFFERENT ISPECDIP OR OTHER SETTING'
            ENDIF   !IFAIL

            VZT=A(1)+A(2)*XT+A(3)*XT*XT

            RX=OBSV(1,IOBSV)-XT
            RY=OBSV(2,IOBSV)-YT
            RZ=OBSV(3,IOBSV)-ZT

            IF (RX.LE.0.D0) THEN
              WRITE(LUNGFO,*)'*** ERROR IN SPECDIPA:'
              WRITE(LUNGFO,*)'BAD X-DISTANCE FROM SOURCE TO OBSERVER'
              WRITE(LUNGFO,*)'CHECK INPUT FILE'
              WRITE(6,*)'*** ERROR IN SPECDIPA:'
              WRITE(6,*)'BAD X-DISTANCE FROM SOURCE TO OBSERVER'
              WRITE(6,*)'CHECK INPUT FILE'
              STOP '--- PROGRAM WAVE ABORTED ---'
            ENDIF

            RR=RX*RX+RY*RY+RZ*RZ
            RN=SQRT(RR)

            CALL MYBFELD(XT,YT,ZT,BX,BY,BZ,DUM,DUM,DUM)

            VN=SQRT(VXT*VXT+VYT*VYT+VZT*VZT)
            VXT=VXT/VN
            VYT=VYT/VN
            VZT=VZT/VN
            BS=BX*VXT+BY*VYT+BZ*VZT
            BX=BX-BS*VXT
            BY=BY-BS*VYT
            BZ=BZ-BS*VZT
            BS=SQRT(BX*BX+BY*BY+BZ*BZ)
            BRX=BY*RZ-BZ*RY
            BRY=BZ*RX-BX*RZ
            BRZ=BX*RY-BY*RX
            BRN=SQRT(BRX*BRX+BRY*BRY+BRZ*BRZ)

            IF (BS.NE.0.D0) THEN
              PSI=ACOS(MIN(BRN/BS/RN,1.D0))
     &          *SIGN(1.D0,BX*RX+BY*RY+BZ*RZ)
            ELSE
              PSI=0.D0
            ENDIF

            X0DIP(1)=XT
            Y0DIP(1)=YT
            Z0DIP(1)=ZT
            B0DIP(1)=BS

          ELSE IF (ISPECDIP.LE.-3) THEN

            OBANGMN=1.D30
            ISPLN=0

            DO I=1,MCO

              T=DWT(I)

              CALL WAVE_TRACK_INTER
     &          (T,XT,YT,ZT,VXT,VYT,VZT,VXP,VYP,VZP,BS,ISPLN,GAMMA)

              RX=OBSV(1,IOBSV)-XT
              RY=OBSV(2,IOBSV)-YT
              RZ=OBSV(3,IOBSV)-ZT

              IF (RX.LE.0.D0) THEN
                WRITE(LUNGFO,*)'*** ERROR IN SPECDIPA:'
                WRITE(LUNGFO,*)'BAD X-DISTANCE FROM SOURCE TO OBSERVER'
                WRITE(LUNGFO,*)'CHECK INPUT FILE'
                WRITE(6,*)'*** ERROR IN SPECDIPA:'
                WRITE(6,*)'BAD X-DISTANCE FROM SOURCE TO OBSERVER'
                WRITE(6,*)'CHECK INPUT FILE'
                STOP '--- PROGRAM WAVE ABORTED ---'
              ENDIF

              RR=RX*RX+RY*RY+RZ*RZ
              RN=SQRT(RR)
              VN=SQRT(VXT*VXT+VYT*VYT+VZT*VZT)
              VXT=VXT/VN
              VYT=VYT/VN
              VZT=VZT/VN
              OBANG=ACOS(MIN((RX*VXT+RY*VYT+RZ*VZT)/RN,1.D0))

              IF (OBANG.LT.OBANGMN) THEN

                OBANGMN=OBANG

                CALL MYBFELD(XT,YT,ZT,BX,BY,BZ,DUM,DUM,DUM)

                BS=BX*VXT+BY*VYT+BZ*VZT
                BX=BX-BS*VXT
                BY=BY-BS*VYT
                BZ=BZ-BS*VZT
                BS=SQRT(BX*BX+BY*BY+BZ*BZ)
                BRX=BY*RZ-BZ*RY
                BRY=BZ*RX-BX*RZ
                BRZ=BX*RY-BY*RX
                BRN=SQRT(BRX*BRX+BRY*BRY+BRZ*BRZ)

                IF (BS.NE.0.D0) THEN
                  PSI=ACOS(MIN(BRN/BS/RN,1.D0))
     &              *SIGN(1.D0,BX*RX+BY*RY+BZ*RZ)
                ELSE
                  PSI=0.D0
                ENDIF

                X0DIP(1)=XT
                Y0DIP(1)=YT
                Z0DIP(1)=ZT
                B0DIP(1)=BS
                RR3=RR

              ENDIF  !(ABS(OBANG).LT.OBANGMN)

            ENDDO   !MCO

            RR=RR3

          ELSE IF (ISPECDIP.EQ.-1) THEN

            XT=SOURCEN(1,1,ISOUR)
            YT=SOURCEN(2,1,ISOUR)
            ZT=SOURCEN(3,1,ISOUR)

            VXT=SOURCEN(1,2,ISOUR)
            VYT=SOURCEN(2,2,ISOUR)
            VZT=SOURCEN(3,2,ISOUR)
            VN=SQRT(VXT*VXT+VYT*VYT+VZT*VZT)
            VXT=VXT/VN
            VYT=VYT/VN
            VZT=VZT/VN

            RX=OBSV(1,IOBSV)-XT
            RY=OBSV(2,IOBSV)-YT
            RZ=OBSV(3,IOBSV)-ZT

            IF (RX.LE.0.D0) THEN
              WRITE(LUNGFO,*)'*** ERROR IN SPECDIPA:'
              WRITE(LUNGFO,*)'BAD X-DISTANCE FROM SOURCE TO OBSERVER'
              WRITE(LUNGFO,*)'CHECK INPUT FILE'
              WRITE(6,*)'*** ERROR IN SPECDIPA:'
              WRITE(6,*)'BAD X-DISTANCE FROM SOURCE TO OBSERVER'
              WRITE(6,*)'CHECK INPUT FILE'
              STOP '--- PROGRAM WAVE ABORTED ---'
            ENDIF

            RR=RX*RX+RY*RY+RZ*RZ
            RN=SQRT(RR)

            CALL MYBFELD(XT,YT,ZT,BX,BY,BZ,DUM,DUM,DUM)

            BS=BX*VXT+BY*VYT+BZ*VZT
            BX=BX-BS*VXT
            BY=BY-BS*VYT
            BZ=BZ-BS*VZT
            BS=SQRT(BX*BX+BY*BY+BZ*BZ)
            BRX=BY*RZ-BZ*RY
            BRY=BZ*RX-BX*RZ
            BRZ=BX*RY-BY*RX
            BRN=SQRT(BRX*BRX+BRY*BRY+BRZ*BRZ)

            IF (BS.NE.0.D0) THEN
              PSI=ACOS(MIN(BRN/BS/RN,1.D0))
     &          *SIGN(1.D0,BX*RX+BY*RY+BZ*RZ)
            ELSE
              PSI=0.D0
            ENDIF

            X0DIP(1)=XT
            Y0DIP(1)=YT
            Z0DIP(1)=ZT
            B0DIP(1)=BS

          ENDIF   !ISPECDIP

          IF (B0DIP(1).NE.0.D0) THEN
            RHODIP(1)=EMOM/B0DIP(1)/CLIGHT1
          ELSE
            WRITE(LUNGFO,*)'*** ERROR IN SPECDIPA ***'
            WRITE(LUNGFO,*)'zero magnetic field for dipole ',ISOUR
c            WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
            WRITE(6,*)'*** ERROR IN SPECDIPA ***'
            WRITE(6,*)'zero magnetic field for dipole ',ISOUR
c            WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
          ENDIF

          OMEGAC=1.5D0*GAMMA**3*CLIGHT1/RHODIP(1)
          ECDIP(1)=OMEGAC*HBAR1/ECHARGE1

c          IF (IOBSV.EQ.ICBRILL) THEN
          WRITE (LUNGFO,*)'      ',isour,iobsv
          WRITE (LUNGFO,*)'      ',
     &      SNGL(B0DIP(1)),SNGL(RHODIP(1)),SNGL(ECDIP(1))
     &      ,SNGL(ECDIP(1)*SPECCUT)
          WRITE(LUNGFO,*)'                   ',
     &      SNGL(X0DIP(1)),SNGL(Y0DIP(1)),SNGL(Z0DIP(1))
c          ENDIF !ICBRILL

          schwingercen(1,iobsv,isour)=x0dip(1)
          schwingercen(2,iobsv,isour)=y0dip(1)
          schwingercen(3,iobsv,isour)=z0dip(1)
          schwingercen(4,iobsv,isour)=b0dip(1)

          if (ispecdip.eq.0) cycle

          IF (APERTHICK.GT.0.0D0) THEN

            RXX=OBSV(1,ICBRILL)-X0DIP(ISOUR)
            RYY=OBSV(2,ICBRILL)-Y0DIP(ISOUR)
            RZZ=OBSV(3,ICBRILL)-Z0DIP(ISOUR)

            IF (RXX.LE.0.D0) THEN
              WRITE(LUNGFO,*)'*** ERROR IN SPECDIP:'
              WRITE(LUNGFO,*)'BAD X-DISTANCE FROM SOURCE TO OBSERVER'
              WRITE(LUNGFO,*)'CHECK INPUT FILE'
              WRITE(6,*)'*** ERROR IN SPECDIP:'
              WRITE(6,*)'BAD X-DISTANCE FROM SOURCE TO OBSERVER'
              WRITE(6,*)'CHECK INPUT FILE'
              STOP '--- PROGRAM WAVE ABORTED ---'
            ENDIF

            RRR=RXX*RXX+RYY*RYY+RZZ*RZZ
            RRN=SQRT(RRR)

            APERANG=ACOS((RXX*APERV(1)+RYY*APERV(2)+RZZ*APERV(3))/RRN)

            IF (IPINCIRC.EQ.0) THEN
              CALL THICKAPP(IPINCIRC,APERTHICK,PINW/2.0D0,APERANG,APERCORR)
            ELSE !IPINCIRC
              CALL THICKAPP(IPINCIRC,APERTHICK,PINR,APERANG,APERCORR)
            ENDIF

          ELSE !APERTHICK

            APERCORR=1.0D0

          ENDIF !APERTHICK

          DO IFREQ=1,NFREQ

            Y=FREQ(IFREQ)/ECDIP(1)

            ILIOBFR=ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1))
            IOBFR=IOBSV+NOBSV*(IFREQ-1)

            IF (XT.GE.XIANF.AND.XT.LE.XIEND) THEN

              SPEC(ILIOBFR)=
     &          DFDTDP(Y,PSI,GAMMA,DMYCUR,BANWID,PAR,PER,POWR)/RR
     &          *APERCORR

              IF (SPECCUT.NE.0.D0.AND.Y.GT.SPECCUT.or.iout.ne.0) THEN
                SPEC(ILIOBFR)=0.D0
                PAR=0.D0
                PER=0.D0
                powr=0.0d0
              ENDIF   !SPECCUT

              SPECPOW(ISOUR+NSOURCE*(IOBSV-1))=POWR/RHODIP(1)/RR
     &          *APERCORR

              EXPOM=(1.D0,0.D0)

              IF (IPIN.NE.0) THEN
                DX2=RX*RX
                DZY2=RZ*RZ+RY*RY
                OM=FREQ(IFREQ)/(HBAREV1*CLIGHT1)

C       TO MAKE SURE THAT TAYLOR-EXPANSION IS VALID

                IF (DZY2.GT.0.01D0*DX2) THEN
                  WRITE(LUNGFO,*)
     &              '*** ERROR IN SPECDIPA: OBSERVATION ANGLE TO LARGE ***'
                  WRITE(LUNGFO,*)'DECREASE SIZE OF PINHOLE OR WGWINFC ...'
                  WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
                  WRITE(6,*)
     &              '*** ERROR IN SPECDIPA: OBSERVATION ANGLE TO LARGE ***'
                  WRITE(6,*)'DECREASE SIZE OF PINHOLE OR WGWINFC ...'
                  WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
                  STOP
                ENDIF     !(DZY2.GT.0.01D0*DX2)

                EPS(1)=DZY2/DX2
                DO IEPS=2,6
                  EPS(IEPS)=EPS(IEPS-1)*EPS(1)
                ENDDO !IEPS

c        TAYLOR-EXPANSION DONE WITH REDUCE
c       IN "WTAY1.RED";
c       on rounded;
c       on numval;
c       precision 13;
c       F:=SQRT(1+EPS);
c       DR:=TAY1(F,EPS,6);
c       ON FORT;
c       OUT "RED.FOR";
c       DR;
c       SHUT "RED.FOR";
C ans is actually reduce by 1.0 to avoid large overall phase

                ans=-0.0205078125D0*eps(6)+0.02734375D0*eps(5)
     &            -0.0390625D0*eps(4)+
     &            0.0625D0*eps(3)-0.125D0*eps(2)+0.5D0*eps(1)

                DRRED=-DABS(RX*ANS)
                EXPOM=CDEXP(DCMPLX(0.D0,DRRED*OM))

              ENDIF !IPIN

              AFREQ(1)=(0.D0,0.D0)
              AFREQ(2)=DCMPLX(0.D0,-SQRT(PER/RR/SPECNOR))*EXPOM
     &          *APERCORR
              AFREQ(3)=DCMPLX(SQRT(PAR/RR/SPECNOR),0.D0)*EXPOM*SIGN(1.D0,PSI)
     &          *APERCORR

              IF (IWARNOB.EQ.0.AND.OBANGMN.GT.WGWINFC/GAMMA) THEN
                WRITE(LUNGFO,*)'*** WARNING IN SPECDIPA:'
                WRITE(LUNGFO,*)'problems finding tangent point'
                WRITE(LUNGFO,*)'source number ',ISOUR
                WRITE(LUNGFO,*)'observ. point ',sngl(obsv(1:3,iobsv))
                WRITE(LUNGFO,*)
     &            'maybe low WBL0CUT or WGWINFC in namelist COLLIN causes problems'
                WRITE(LUNGFO,*)
     &            '... or turn option IWIGGLER off and tune parameters'
                WRITE(LUNGFO,*)
     &            'ISPECDIP, WBL0CUT ... by hand'
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)' *** Photon flux set to zero! ***'
                WRITE(LUNGFO,*)
                WRITE(6,*)'*** WARNING IN SPECDIPA:'
                WRITE(6,*)'problems finding tangent point'
                WRITE(6,*)'observ. point ',sngl(obsv(1:3,iobsv))
                WRITE(6,*)'source number ',ISOUR
                WRITE(6,*)
     &            'maybe low WBL0CUT or WGWINFC in namelist COLLIN causes problems'
                WRITE(6,*)
     &            '... or turn option IWIGGLER off and tune parameters'
                WRITE(6,*)
     &            'ISPECDIP, WBL0CUT ... by hand'
                WRITE(6,*)
                WRITE(6,*)' *** Photon flux set to zero! ***'
                WRITE(6,*)
                IWARNOB=1
              ENDIF

              IF (OBANGMN.GT.WGWINFC/GAMMA) THEN
                AFREQ(1)=(0.D0,0.D0)
                AFREQ(2)=(0.D0,0.D0)
                AFREQ(3)=(0.D0,0.D0)
              ENDIF

              REAIMA(1,1,IOBFR)=DREAL(AFREQ(1))
              REAIMA(1,2,IOBFR)=DIMAG(AFREQ(1))
              REAIMA(2,1,IOBFR)=DREAL(AFREQ(2))
              REAIMA(2,2,IOBFR)=DIMAG(AFREQ(2))
              REAIMA(3,1,IOBFR)=DREAL(AFREQ(3))
              REAIMA(3,2,IOBFR)=DIMAG(AFREQ(3))
              IF (IPOLA.NE.0) THEN
                APOL=
     &            AFREQ(1)*CONJG(VPOLA(1))
     &            +AFREQ(2)*CONJG(VPOLA(2))
     &            +AFREQ(3)*CONJG(VPOLA(3))
                SPEC(ILIOBFR)=
     &            DREAL(APOL*CONJG(APOL))*SPECNOR
              ENDIF !IPOLA

              IF (ISTOKES.NE.0) THEN

                APOLH=
     &            AFREQ(1)*CONJG(VSTOKES(1,1))
     &            +AFREQ(2)*CONJG(VSTOKES(1,2))
     &            +AFREQ(3)*CONJG(VSTOKES(1,3))

                APOLR=
     &            AFREQ(1)*CONJG(VSTOKES(2,1))
     &            +AFREQ(2)*CONJG(VSTOKES(2,2))
     &            +AFREQ(3)*CONJG(VSTOKES(2,3))

                APOLL=
     &            AFREQ(1)*CONJG(VSTOKES(3,1))
     &            +AFREQ(2)*CONJG(VSTOKES(3,2))
     &            +AFREQ(3)*CONJG(VSTOKES(3,3))

                APOL45=
     &            AFREQ(1)*CONJG(VSTOKES(4,1))
     &            +AFREQ(2)*CONJG(VSTOKES(4,2))
     &            +AFREQ(3)*CONJG(VSTOKES(4,3))

                STOK1=
     &            APOLR*CONJG(APOLR)+
     &            APOLL*CONJG(APOLL)

                STOK2=-STOK1+
     &            2.0d0*APOLH*CONJG(APOLH)

                STOK3=
     &            2.0d0*APOL45*CONJG(APOL45)-
     &            STOK1

                STOK4=
     &            APOLR*CONJG(APOLR)-
     &            APOLL*CONJG(APOLL)

                if (abs(stok1)*specnor.gt.1.0D-30)
     &            STOKES(1,IOBFR)=STOKES(1,IOBFR)+
     &            STOK1*SPECNOR

                if (abs(stok2)*specnor.gt.1.0D-30)
     &            STOKES(2,IOBFR)=STOKES(2,IOBFR)+
     &            STOK2*SPECNOR

                if (abs(stok3)*specnor.gt.1.0D-30)
     &            STOKES(3,IOBFR)=STOKES(3,IOBFR)+
     &            STOK3*SPECNOR

                if (abs(stok4)*specnor.gt.1.0D-30)
     &           STOKES(4,IOBFR)=STOKES(4,IOBFR)+
     &            STOK4*SPECNOR

              ENDIF !ISTOKES

            ENDIF   !XIANF

            SPECTOT(IOBFR)=SPECTOT(IOBFR)
     &        +SPEC(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))

          ENDDO   !IFREQ

          IF (NOBSV.GT.1.AND.ISOUR.EQ.1.AND.IOBSV.EQ.JX10.AND.IX10.LE.10) THEN
            JX10=JX10+JDX10
            CALL date_and_time(dtday,dttime,dtzone,idatetime)
            WRITE(6,*)' ',IX10,' ',dttime(1:2),':',dttime(3:4),':',dttime(5:6)
            IX10=IX10+1
          ENDIF

        ENDDO   !IOBSV

        if (ispecdip.eq.0) cycle

        IF (ISPECDIP.LE.-3.and.isour.eq.nsource) THEN
          DEALLOCATE(DWT)
          DEALLOCATE(DWX)
          DEALLOCATE(DWX2P)
          DEALLOCATE(DWB)
          DEALLOCATE(DWB2P)
          DEALLOCATE(DWY)
          DEALLOCATE(DWY2P)
          DEALLOCATE(DWZ)
          DEALLOCATE(DWZ2P)
          DEALLOCATE(tragam)
        ENDIF

        IF (ISOUR.EQ.1.and.nsource.gt.1) THEN
          WRITE(6,*)' '
          WRITE(6,*)' '
          WRITE(6,*)' sources treated so far:'
          WRITE(6,*)' '
        ENDIF

        CALL date_and_time(dtday,dttime,dtzone,idatetime)
        WRITE(6,2000)ISOUR,NSOURCE,dttime(1:2),dttime(3:4),dttime(5:6)
2000    FORMAT(10X,I4,' of',I4,2X,A,':',A,':',A)

      ENDDO   !ISOUR

      WRITE(6,*)' '

      RETURN
      END
+DECK,SPECINT.
*CMZ :  4.01/04 27/11/2023  13.42.16  by  Michael Scheer
*CMZ :  3.05/10 13/08/2018  14.39.06  by  Michael Scheer
*CMZ :  3.05/09 10/02/2005  12.58.04  by  Michael Scheer
*CMZ :  2.52/01 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.48/04 12/03/2004  15.40.31  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.02  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.36/00 07/11/2001  14.17.58  by  Michael Scheer
*CMZ :  2.34/00 11/05/2001  17.23.02  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  14.22.45  by  Michael Scheer
*CMZ :  2.16/05 04/08/2000  11.46.38  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  2.13/03 11/01/2000  18.22.28  by  Michael Scheer
*CMZ :  2.13/02 08/12/99  18.50.05  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  13.48.27  by  Michael Scheer
*CMZ :  1.01/01 10/12/97  13.26.03  by  Michael Scheer
*CMZ :  1.00/00 30/06/97  11.25.46  by  Michael Scheer
*CMZ : 00.02/05 18/03/97  15.39.20  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  17.24.12  by  Michael Scheer
*CMZ : 00.00/07 03/06/94  10.14.21  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.54.24  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.00  by  Michael Scheer
*-- Author :
      SUBROUTINE SPECINT

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.

C     INTEGRATES POWER SPECTRA OVER ALL PHOTON ENERGIES

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,SPECT.
+SEQ,OBSERV.
+SEQ,FREQS.
+SEQ,SOURCE.
+SEQ,PHYCON.

      CHARACTER(50) CDUM
      INTEGER IY,IZ,ISOUR,IOBSV,IFREQ,IERR
      INTEGER ICAL,NMU,IMU,IWARNW,IWARNS
      DOUBLE PRECISION S2(NDFREQP),RESULT,SIMPLE
      DOUBLE PRECISION EMUDUM(1000),AMUDUM(1000),DENDUM

      DATA ICAL/0/

      IF (NFREQ0.LE.1) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING SR SPECINT ***'
        WRITE(LUNGFO,*)'INTEGRATION NOT POSSIBLE, ONLY ONE FREQUENCY'
        WRITE(LUNGFO,*)'CHANGE PARAMETER NFREQ2P IN NAMELIST CONTRL'
        WRITE(LUNGFO,*)
c        WRITE(6,*)
c        WRITE(6,*)'*** WARNING SR SPECINT ***'
c        WRITE(6,*)'INTEGRATION NOT POSSIBLE, ONLY ONE FREQUENCY'
c        WRITE(6,*)'CHANGE PARAMETER NFREQ2P IN NAMELIST CONTRL'
c        WRITE(6,*)
        ISPECINT=0
        RETURN
      ENDIF

C--- LOOP OVER ALL SOURCES

      WFLUXTI=0.0
      DO IOBSV=1,NOBSV
        SPECTOTI(IOBSV)=0.0
        ENEDOS(IOBSV)=0.0
      ENDDO !IOBSV

      IWARNS=0
      IWARNW=0
      DO ISOUR=1,NSOURCE

C--- LOOP OVER ALL OBSERVATION POINTS

        IF (IPIN.NE.0) THEN

          DO IY=1,NOBSVY
            DO IZ=1,NOBSVZ

              IOBSV=(IY-1)*NOBSVZ+IZ

C--- FILL INTEGRATION BUFFER

              DO IFREQ=NFREQ0M,NFREQ0P
                S2(IFREQ-NFREQ0M+1)=
     &            SPEC(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))
     &            /BANWID*ECHARGE1
              ENDDO !IFREQ

C--- DO INTEGRATION OF BUFFER

              CALL SPBUFINT(FREQ,S2,NFREQ0,RESULT,SIMPLE)

              IF (IWARNS.EQ.0.AND.RESULT.NE.0.0.AND.
     &              DABS((RESULT-SIMPLE)/RESULT).GT.1.D-1) THEN
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)
     &'*** WARNING SPECINT: PROBLEM WITH INTEGRATION OF SPECTUM (SPEC)'
                WRITE(LUNGFO,*)'CHECK RESULTS CAREFULLY'
                WRITE(6,*)
                WRITE(6,*)
     &'*** WARNING SPECINT: PROBLEM WITH INTEGRATION OF SPECTRUM (SPEC)'
                WRITE(6,*)'CHECK RESULTS CAREFULLY'
                IWARNS=1
              ENDIF

              ILIOB=ISOUR+NSOURCE*(IOBSV-1)
              SPECI(ILIOB)=RESULT
              SPECTOTI(IOBSV)=SPECTOTI(IOBSV)+SPECI(ILIOB)

            ENDDO !IZ
          ENDDO !IY


C--- INTEGRATION OF FLUX THROUGH PINHOLE

          DO IFREQ=NFREQ0M,NFREQ0P
            S2(IFREQ-NFREQ0M+1)=
     &        WFLUX(ISOUR+NSOURCE*(IFREQ-1))/BANWID*ECHARGE1
          ENDDO !IFREQ

          CALL SPBUFINT(FREQ,S2,NFREQ0,RESULT,SIMPLE)

          IF (IWARNW.EQ.0.AND.RESULT.NE.0.0.AND.
     &        DABS((RESULT-SIMPLE)/RESULT).GT.1.D-1) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &'*** WARNING SR SPECINT: PROBLEM WITH INTEGRATION OF SPECTRUM'
            WRITE(LUNGFO,*)
     &        '(FLUX THROUGH PINHOLE)'
            WRITE(LUNGFO,*)'CHECK RESULTS CAREFULLY'
            WRITE(6,*)
            WRITE(6,*)
     &'*** WARNING SR SPECINT: PROBLEM WITH INTEGRATION OF SPECTRUM'
            WRITE(6,*)
     &        '(FLUX THROUGH PINHOLE)'
            WRITE(6,*)'CHECK RESULTS CAREFULLY'
            IWARNW=1
          ENDIF

          WFLUXI(ISOUR)=RESULT
          WFLUXTI=WFLUXTI+WFLUXI(ISOUR)

        ELSE   !IPIN


          DO IOBSV=1,NOBSV

C--- FILL INTEGRATION BUFFER

            DO IFREQ=NFREQ0M,NFREQ0P
              S2(IFREQ-NFREQ0M+1)=
     &          SPEC(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))
     &          /BANWID*ECHARGE1
            ENDDO !IFREQ

C--- DO INTEGRATION OF BUFFER

            CALL SPBUFINT(FREQ,S2,NFREQ0,RESULT,SIMPLE)
            IF (IWARNS.EQ.0.AND.RESULT.NE.0.0.AND.
     &          DABS((RESULT-SIMPLE)/RESULT).GT.1.D-1) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &'*** WARNING SPECINT: PROBLEM WITH INTEGRATION OF SPECTRUM (SPEC)'
              WRITE(LUNGFO,*)'CHECK RESULTS CAREFULLY'
              WRITE(6,*)
              WRITE(6,*)
     &'*** WARNING SPECINT: PROBLEM WITH INTEGRATION OF SPECTRUM (SPEC)'
              WRITE(6,*)'CHECK RESULTS CAREFULLY'
              IWARNS=1
            ENDIF

            ILIOB=ISOUR+NSOURCE*(IOBSV-1)
            SPECI(ILIOB)=RESULT
            SPECTOTI(IOBSV)=SPECTOTI(IOBSV)+SPECI(ILIOB)

          ENDDO !IOBSV

        ENDIF    !IPIN

      ENDDO !ISOUR

C--- DOSE CALCULATIONS

      IF (IDOSE.NE.0) THEN

        IWARNW=0
        IWARNS=0

        IF (ICAL.EQ.0) THEN
          OPEN(UNIT=99,FILE='ABSORPDOSE.RP',STATUS='OLD')

          READ(99,'(A50)') CDUM
          READ(99,*) DENDUM
          READ(99,*) NMU
          IF (NMU.GT.1000) STOP '*** SR SPECINT: NMU EXCEEDED 1000 ***'
          DO IMU=1,NMU
            READ(99,*) EMUDUM(IMU),AMUDUM(IMU)
          ENDDO !NMU
          DO IFREQ=NFREQ0M,NFREQ0P
            CALL ABSNOSPLI
     &        (EMUDUM,AMUDUM,NMU,FREQ(IFREQ-NFREQ0M+1),
     &        ABSMUEN(IFREQ-NFREQ0M+1),IERR,IDOSE)
            IF (IERR.NE.0) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'*** ERROR IN SPECINT ***'
              WRITE(LUNGFO,*)'CALL TO SR ABSNOSPLI FAILED'
              WRITE(LUNGFO,*)
     &'CHECK PHOTONENERGIES IN NAMELIST FREQN AND FILE ABSORPDOSE.RP'
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
              WRITE(6,*)
              WRITE(6,*)'*** ERROR IN SPECINT ***'
              WRITE(6,*)'CALL TO SR ABSNOSPLI FAILED'
              WRITE(6,*)
     &'CHECK PHOTONENERGIES IN NAMELIST FREQN AND FILE ABSORPDOSE.RP'
              WRITE(6,*)
              WRITE(6,*)
              STOP
            ENDIF   !IERR
          ENDDO
          CLOSE(99)
          ICAL=1
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &'     SPECINT: MASS ENERGY ABSORPTION COEFFS READ FROM FILE'
          WRITE(LUNGFO,*)'     COMMENT ON FILE IS:'
          WRITE(LUNGFO,*)'     ',CDUM
          WRITE(LUNGFO,*)
        ENDIF !ICAL

        DO IOBSV=1,NOBSV

C--- FILL INTEGRATION BUFFER FOR ABSORBED DOSE

          DO IFREQ=NFREQ0M,NFREQ0P
            S2(IFREQ-NFREQ0M+1)=
     &        SPECTOT(IOBSV+NOBSV*(IFREQ-1))/BANWID*ECHARGE1
            S2(IFREQ-NFREQ0M+1)=
     &        S2(IFREQ-NFREQ0M+1)*ABSMUEN(IFREQ-NFREQ0M+1)
          ENDDO !IFREQ

C--- DO INTEGRATION OF BUFFER

          CALL SPBUFINT(FREQ,S2,NFREQ0,RESULT,SIMPLE)
          IF (IWARNS.EQ.0.AND.RESULT.NE.0.0.AND.
     &        DABS((RESULT-SIMPLE)/RESULT).GT.1.D-1) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &'*** WARNING SPECINT: PROBLEM WITH INTEGRATION OF SPECTRUM'
            WRITE(LUNGFO,*)
     &        '(ABSORBED DOSE)'
            WRITE(LUNGFO,*)'CHECK RESULTS CAREFULLY'
            WRITE(6,*)
            WRITE(6,*)
     &'*** WARNING SR SPECINT: PROBLEM WITH INTEGRATION OF SPECTRUM'
            WRITE(6,*)
     &        '(ABSORBED DOSE)'
            WRITE(6,*)'CHECK RESULTS CAREFULLY'
            IWARNS=1
          ENDIF

          ENEDOS(IOBSV)=ENEDOS(IOBSV)+RESULT

        ENDDO !IOBSV

        IF (IPIN.NE.0) THEN

          IWARNW=0
          DO IFREQ=NFREQ0M,NFREQ0P
            S2(IFREQ-NFREQ0M+1)=
     &        WFLUXT(IFREQ-NFREQ0M+1)/BANWID*ECHARGE1/PINW/PINH
            S2(IFREQ-NFREQ0M+1)=
     &        S2(IFREQ-NFREQ0M+1)*ABSMUEN(IFREQ-NFREQ0M+1)
          ENDDO !IFREQ

C--- DO INTEGRATION OF BUFFER

          CALL SPBUFINT(FREQ,S2,NFREQ0,PINDOS,SIMPLE)

          IF (IWARNW.EQ.0.AND.PINDOS.NE.0.0.AND.
     &        DABS((PINDOS-SIMPLE)/PINDOS).GT.1.D-1) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &'*** WARNING SPECINT: PROBLEM WITH INTEGRATION OF SPECTRUM'
            WRITE(LUNGFO,*)
     &        '(ABSORBED ENERGY DOSE THROUGH PINHOLE)'
            WRITE(LUNGFO,*)'CHECK RESULTS CAREFULLY'
            WRITE(6,*)
            WRITE(6,*)
     &'*** WARNING SPECINT: PROBLEM WITH INTEGRATION OF SPECTRUM'
            WRITE(6,*)
     &        '(ABSORBED ENERGY DOSE THROUGH PINHOLE)'
            WRITE(6,*)'CHECK RESULTS CAREFULLY'
            IWARNW=1
          ENDIF

        ENDIF !IPIN

      ENDIF !IDOSE

      IF (IPINCIRC.EQ.0) THEN
        DO ISOUR=1,NSOURCE
          DO IZ=1,NOBSVZ
            CALL BLENDSPECIV(ISOUR,IZ)
          ENDDO
        ENDDO
      ENDIF !(IPINCIRC.EQ.0)

      RETURN
      END
+DECK,SPECINTF.
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.53/05 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.52/01 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  16.27.20  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  2.13/03 11/01/2000  18.22.28  by  Michael Scheer
*CMZ :  1.01/02 12/12/97  10.25.25  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.02  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE SPECINTF
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,WFOLDF90U.

C     INTEGRATES POWER SPECTRA OVER ALL PHOTON ENERGIES FOR FOLDED INTENSITY

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,SPECT.
+SEq,observf90.
+SEQ,FREQS.
+seq,sourcef90.
+SEQ,PHYCON.
+SEq,wfoldf90.

      INTEGER IY,IZ,ISOUR,IOBSV,IFREQ,IWARNW,IWARNS
      DOUBLE PRECISION S2(NDFREQP),RESULT,SIMPLE

      IWARNS=0
      IWARNW=0

      IF (NFREQ0.LE.1) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING SR SPECINTF ***'
        WRITE(LUNGFO,*)'INTEGRATION NOT POSSIBLE, ONLY ONE FREQUENCY'
        WRITE(LUNGFO,*)'CHANGE PARAMETER NFREQ2P IN NAMELIST CONTRL'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING SR SPECINTF ***'
        WRITE(6,*)'INTEGRATION NOT POSSIBLE, ONLY ONE FREQUENCY'
        WRITE(6,*)'CHANGE PARAMETER NFREQ2P IN NAMELIST CONTRL'
        WRITE(6,*)
        RETURN
      ENDIF

C--- LOOP OVER ALL SOURCES

      WFLUXTIF=0.0
      DO IOBSV=1,NOBSV
        SPECTOTIF(IOBSV)=0.0
      ENDDO !IOBSV

      DO ISOUR=1,NSOURCE

C--- LOOP OVER ALL OBSERVATION POINTS

        IF (IPIN.NE.0) THEN

          DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
            DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ

              IOBSV=(IY-1)*NOBSVZ+IZ

C--- FILL INTEGRATION BUFFER

              DO IFREQ=NFREQ0M,NFREQ0P
                S2(IFREQ-NFREQ0M+1)=
     &            SPECF(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))
     &            /BANWID*ECHARGE1
              ENDDO  !IFREQ

C--- DO INTEGRATION OF BUFFER

              CALL SPBUFINT(FREQ,S2,NFREQ0,RESULT,SIMPLE)

              IF (IWARNW.EQ.0.AND.RESULT.NE.0.0
     &        .AND.DABS((RESULT-SIMPLE)/RESULT).GT.1.D-1) THEN
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)
     &'** WARNING SPECINTF: PROBLEM WITH INTEGRATION OF SPECTUM (SPEC)'
                WRITE(LUNGFO,*)'CHECK RESULTS CAREFULLY'
                WRITE(6,*)
                WRITE(6,*)
     &'** WARNING SPECINTF: PROBLEM WITH INTEGRATION OF SPECTRUM (SPEC)'
                WRITE(LUNGFO,*)
     &            '(FLUX THROUGH PINHOLE)'
                WRITE(6,*)'CHECK RESULTS CAREFULLY'
                IWARNW=1
              ENDIF

              ILIOB=ISOUR+NSOURCE*(IOBSV-1)
              SPECIF(ILIOB)=RESULT
              SPECTOTIF(IOBSV)=SPECTOTIF(IOBSV)+SPECIF(ILIOB)

            ENDDO !IZ
          ENDDO   !IY


C--- INTEGRATION OF FLUX THROUGH PINHOLE

          DO IFREQ=NFREQ0M,NFREQ0P
            S2(IFREQ-NFREQ0M+1)=
     &        WFLUXF(ISOUR+NSOURCE*(IFREQ-1))/BANWID*ECHARGE1
          ENDDO   !IFREQ

          CALL SPBUFINT(FREQ,S2,NFREQ0,RESULT,SIMPLE)

          CALL SPBUFINT(FREQ,S2,NFREQ0,RESULT,SIMPLE)

          IF (IWARNW.EQ.0.AND.RESULT.NE.0.0
     &    .AND.DABS((RESULT-SIMPLE)/RESULT).GT.1.D-1) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &'*** WARNING SPECINTF: PROBLEM WITH INTEGRATION OF SPECTRUM'
            WRITE(LUNGFO,*)
     &        '(FLUX THROUGH PINHOLE)'
            WRITE(LUNGFO,*)'CHECK RESULTS CAREFULLY'
            WRITE(6,*)
            WRITE(6,*)
     &'*** WARNING SPECINTF: PROBLEM WITH INTEGRATION OF SPECTRUM'
            WRITE(6,*)
     &        '(FLUX THROUGH PINHOLE)'
            WRITE(6,*)'CHECK RESULTS CAREFULLY'
            IWARNW=1
          ENDIF

          WFLUXIF(ISOUR)=RESULT
          WFLUXTIF=WFLUXTIF+WFLUXIF(ISOUR)

        ELSE    !IPIN

          DO IOBSV=1,NOBSV

C--- FILL INTEGRATION BUFFER

            DO IFREQ=NFREQ0M,NFREQ0P
              S2(IFREQ-NFREQ0M+1)=
     &          SPECF(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))
     &          /BANWID*ECHARGE1
            ENDDO !IFREQ

C--- DO INTEGRATION OF BUFFER

            CALL SPBUFINT(FREQ,S2,NFREQ0,RESULT,SIMPLE)

            IF (IWARNS.EQ.0.AND.RESULT.NE.0.0
     &      .AND.DABS((RESULT-SIMPLE)/RESULT).GT.1.D-1) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &'*** WARNING SPECINTF: PROBLEM WITH INTEGRATION OF SPECTRUM'
              WRITE(LUNGFO,*)
     &          '(FLUX THROUGH PINHOLE)'
              WRITE(LUNGFO,*)'CHECK RESULTS CAREFULLY'
              WRITE(6,*)
              WRITE(6,*)
     &'*** WARNING SPECINTF: PROBLEM WITH INTEGRATION OF SPECTRUM'
              WRITE(6,*)'CHECK RESULTS CAREFULLY'
              IWARNS=1
            ENDIF

            ILIOB=ISOUR+NSOURCE*(IOBSV-1)
            SPECIF(ILIOB)=RESULT
            SPECTOTIF(IOBSV)=SPECTOTIF(IOBSV)+SPECIF(ILIOB)

          ENDDO   !IOBSV

        ENDIF    !IPIN

      ENDDO !ISOUR

      RETURN
      END
+DECK,SPECSUM.
*CMZ :  4.00/13 12/11/2021  11.33.50  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.16/08 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  2.13/03 11/01/2000  18.22.28  by  Michael Scheer
*CMZ : 00.02/04 26/02/97  10.39.20  by  Michael Scheer
*CMZ : 00.01/09 20/10/95  15.51.37  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  17.26.21  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.54.32  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.22  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE SPECSUM
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SELF.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,PHYCON.


      INTEGER IFREQ,ISOUR,IOBSV,ICAL,ISS

+SELF,IF=-F90.
      REAL*4 SPCSMRAT(LIDIMP)
      DOUBLE PRECISION SPCSMSUM(LIDIMP)
+SELF.
      DOUBLE PRECISION DZ,DY
      DOUBLE PRECISION SUMT

      DATA ICAL/0/

+SELF,IF=F90.
      ALLOCATE(SPCSMRAT(NSOURCE))
      ALLOCATE(SPCSMSUM(NSOURCE*NOBSV))
+SELF.


      IF (IPIN.EQ.0) GOTO 9999

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SR SPECSUM:'
      WRITE(LUNGFO,*)

         IF (IPINCIRC.NE.0.AND.ICAL.NE.1) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)'*** WARNING SR SPECSUM ***'
             WRITE(LUNGFO,*)
     &'USE OF FLAG IPINCIRC NOT RECOMMENDED FOR THIS ROUTINE SINCE'
             WRITE(LUNGFO,*)
     &'SHAPE OF CIRCULARE PINHOLE IS TAKEN INTO ACCOUNT ONLY VERY ROUGHLY'
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
C            WRITE(6,*)
C            WRITE(6,*)
C            WRITE(6,*)'*** WARNING SR SPECSUM ***'
C            WRITE(6,*)
C     &'USE OF FLAG IPINCIRC NOT RECOMMENDED FOR THIS ROUTINE SINCE'
C            WRITE(6,*)
C     &'SHAPE OF CIRCULARE PINHOLE IS TAKEN INTO ACCOUNT ONLY VERY ROUGHLY'
C            WRITE(6,*)
C            WRITE(6,*)
             ICAL=1
         ENDIF !IPINCIRC

      WRITE(LUNGFO,*)
     & '     Photon energy and flux through pinhole simply summed up:'
      IF (IW_BLEN.NE.0) THEN
         WRITE(LUNGFO,*)'     (and ratio of spline and summation results)'
         WRITE(6,*)'     Ratio of spline and summation results:'
         write(6,*)
      ENDIF
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)


         DO IFREQ=1,NFREQ

         DO ISOUR=1,NSOURCE

             SPCSMSUM(ISOUR)=0.0

         DO IOBSV=1,NOBSV

+SELF,IF=NEWWAVE.
            ILIOBFR=ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1))
+SELF.
             IF (IPINCIRC.EQ.0) THEN

            IF (
     &           DABS(OBSV(2,IOBSV)-PINCEN(2))-PINH/2.D0.LT.1.D-10
     &                      .AND.
     &           DABS(OBSV(3,IOBSV)-PINCEN(3))-PINW/2.D0.LT.1.D-10
     &                      ) THEN

                  IF(DABS(
     &                           DABS(OBSV(3,IOBSV)-PINCEN(3))
     &                           -PINW/2.D0).LT.1.D-10) THEN

                DZ=OBSVDZ/2.D0

                  ELSE

                     DZ=OBSVDZ

                  ENDIF

                  IF(DABS(
     &                           DABS(OBSV(2,IOBSV)-PINCEN(2))
     &                           -PINH/2.D0).LT.1.D-10) THEN

                DY=OBSVDY/2.D0

                  ELSE

                    DY=OBSVDY

                  ENDIF

+SELF,IF=-NEWWAVE.
                  SPCSMSUM(ISOUR)=SPCSMSUM(ISOUR)
     &                      +SPEC(ISOUR,IOBSV,IFREQ)*
     &                                   DZ*DY
+SELF,IF=NEWWAVE.
                  SPCSMSUM(ISOUR)=SPCSMSUM(ISOUR)
     &                      +SPEC( ILIOBFR)*
     &                                   DZ*DY
+SELF.

            ENDIF   !OBSV

             ELSE    !IPINCIR

            IF (
     &                      (OBSV(2,IOBSV)-PINCEN(2))**2
     &                     +(OBSV(3,IOBSV)-PINCEN(3))**2
     &                       -PINR**2.LT.1.D-10) THEN

                  DZ=OBSVDZ
                  DY=OBSVDY

+SELF,IF=-NEWWAVE.
                  SPCSMSUM(ISOUR)=SPCSMSUM(ISOUR)
     &                      +SPEC(ISOUR,IOBSV,IFREQ)*
     &                                   DZ*DY
+SELF,IF=NEWWAVE.
                  SPCSMSUM(ISOUR)=SPCSMSUM(ISOUR)
     &                      +SPEC( ILIOBFR)*
     &                                   DZ*DY
+SELF.


                 ENDIF  !OBSV

             ENDIF   !IPINCIR

         ENDDO !NOBSV
         ENDDO !ISOUR

         SUMT=0.D0

         DO IOBSV=1,NOBSV

             IF (IPINCIRC.EQ.0) THEN
            IF (
     &           DABS(OBSV(2,IOBSV)-PINCEN(2))-PINH/2.D0.LT.1.D-10
     &                      .AND.
     &           DABS(OBSV(3,IOBSV)-PINCEN(3))-PINW/2.D0.LT.1.D-10
     &                      ) THEN

                  IF(DABS(
     &                           DABS(OBSV(3,IOBSV)-PINCEN(3))
     &                           -PINW/2.D0).LT.1.D-10) THEN
                DZ=OBSVDZ/2.D0

                  ELSE

                     DZ=OBSVDZ

                  ENDIF

                  IF(DABS(
     &                           DABS(OBSV(2,IOBSV)-PINCEN(2))
     &                           -PINH/2.D0).LT.1.D-10) THEN
                DY=OBSVDY/2.D0

                  ELSE

                    DY=OBSVDY

                  ENDIF

+SELF,IF=-NEWWAVE.
                  SUMT=SUMT+SPECTOT(IOBSV,IFREQ)*DY*DZ
+SELF,IF=NEWWAVE.
                  SUMT=SUMT+SPECTOT(IOBSV+NOBSV*(IFREQ-1))*DY*DZ
+SELF.

            ENDIF   !OBSV

             ELSE    !IPINCIR

            IF (
     &                      (OBSV(2,IOBSV)-PINCEN(2))**2
     &                     +(OBSV(3,IOBSV)-PINCEN(3))**2
     &                       -PINR**2.LT.1.D-10) THEN

                  DZ=OBSVDZ
                  DY=OBSVDY
+SELF,IF=-NEWWAVE.
                  SUMT=SUMT+SPECTOT(IOBSV,IFREQ)*DY*DZ
+SELF,IF=NEWWAVE.
                  SUMT=SUMT+SPECTOT(IOBSV+NOBSV*(IFREQ-1))*DY*DZ
+SELF.
                 ENDIF  !OBSV

             ENDIF   !IPINCIR

         ENDDO

      IF (IW_BLEN.EQ.0) THEN

         IF (IUNIT.EQ.0)       !260194
     &      WRITE(LUNGFO,*)
     &      '  ',SNGL(FREQ(IFREQ)),(SNGL(SPCSMSUM(ISOUR)),ISOUR=1,NSOURCE)
     &      ,SNGL(SUMT)

         IF (IUNIT.NE.0) !260194
     &      WRITE(LUNGFO,*)
     &      '  ',SNGL(WELLEN(IFREQ)),(SNGL(SPCSMSUM(ISOUR)),ISOUR=1,NSOURCE)
     &      ,SNGL(SUMT)

      ENDIF

        IF (IW_BLEN.NE.0) THEN
           DO ISS=1,NSOURCE
             SPCSMRAT(ISS)=9999.
+SELF,IF=-NEWWAVE.
             IF (SPCSMSUM(ISS).NE.0.D0) SPCSMRAT(ISS)=WFLUX(ISS,IFREQ)/SPCSMSUM(ISS)
+SELF,IF=NEWWAVE.
             IF (SPCSMSUM(ISS).NE.0.D0) SPCSMRAT(ISS)=WFLUX(ISS+NSOURCE*(IFREQ-1))
     &                                     /SPCSMSUM(ISS)
+SELF.
           ENDDO !ISS
           WRITE(LUNGFO,2584)SNGL(FREQ(IFREQ)),(SPCSMRAT(ISS),ISS=1,NSOURCE)
           WRITE(6,2584)SNGL(FREQ(IFREQ)),(SPCSMRAT(ISS),ISS=1,NSOURCE)
        ENDIF   !IW_BLEN
2584     FORMAT('     ',6(1PE12.4))

         ENDDO !IFREQ

9999  CONTINUE
+SELF,IF=F90.
      DEALLOCATE(SPCSMRAT)
      DEALLOCATE(SPCSMSUM)
+SELF.
      RETURN
      END
+DECK,SPECSUMF.
*CMZ :  4.00/13 12/11/2021  11.33.50  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.16/08 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  2.13/03 11/01/2000  18.22.28  by  Michael Scheer
*CMZ : 00.01/09 20/10/95  15.52.41  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  17.28.14  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.54.37  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.26  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE SPECSUMF
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SELF.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,PHYCON.


      INTEGER IFREQ,ISOUR,IOBSV,ICAL,ISS

      DOUBLE PRECISION DZ,DY,SUMT
+SELF,IF=-F90.
      DOUBLE PRECISION SPCSMSUM(LIDIMP)
      REAL*4 SPCSMRAT(LIDIMP)
+SELF.

      DATA ICAL/0/

+SELF,IF=F90.
          ALLOCATE(SPCSMRAT(NSOURCE))
          ALLOCATE(SPCSMSUM(NSOURCE*NOBSV))
+SELF.

      IF (IPIN.EQ.0) GOTO 9999

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SR SPECSUMF:'
      WRITE(LUNGFO,*)

         IF (IPINCIRC.NE.0.AND.ICAL.NE.1) THEN

             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)'*** WARNING SR SPECSUMF ***'
             WRITE(LUNGFO,*)
     &'USE OF FLAG IPINCIRC NOT RECOMMENDED FOR THIS ROUTINE SINCE'
             WRITE(LUNGFO,*)
     &'SHAPE OF CIRCULARE PINHOLE IS TAKEN INTO ACCOUNT ONLY VERY ROUGHLY'
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
C            WRITE(6,*)
C            WRITE(6,*)
C            WRITE(6,*)'*** WARNING SR SPECSUMF ***'
C            WRITE(6,*)
C     &'USE OF FLAG IPINCIRC NOT RECOMMENDED FOR THIS ROUTINE SINCE'
C            WRITE(6,*)
C     &'SHAPE OF CIRCULARE PINHOLE IS TAKEN INTO ACCOUNT ONLY VERY ROUGHLY'
C            WRITE(6,*)
C            WRITE(6,*)
             ICAL=1
         ENDIF !IPINCIRC

      WRITE(LUNGFO,*)
     & '     Photon energy and flux through pinhole simply summed up (with emittance effects):'
      IF (IW_BLENF.NE.0) THEN
         WRITE(LUNGFO,*)'     (and ratio of spline and summation results)'
         WRITE(6,*)'     Ratio of spline and summation results:'
         write(6,*)
      ENDIF
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)


         DO IFREQ=1,NFREQ

         DO ISOUR=1,NSOURCE

             SPCSMSUM(ISOUR)=0.0

         DO IOBSV=1,NOBSV

             IF (IPINCIRC.EQ.0) THEN

            IF (
     &           DABS(OBSV(2,IOBSV)-PINCEN(2))-PINH/2.D0.LT.1.D-10
     &                      .AND.
     &           DABS(OBSV(3,IOBSV)-PINCEN(3))-PINW/2.D0.LT.1.D-10
     &                      ) THEN

                  IF(DABS(
     &                           DABS(OBSV(3,IOBSV)-PINCEN(3))
     &                           -PINW/2.D0).LT.1.D-10) THEN

                DZ=OBSVDZ/2.D0

                  ELSE

                     DZ=OBSVDZ

                  ENDIF

                  IF(DABS(
     &                           DABS(OBSV(2,IOBSV)-PINCEN(2))
     &                           -PINH/2.D0).LT.1.D-10) THEN

                DY=OBSVDY/2.D0

                  ELSE

                    DY=OBSVDY

                  ENDIF

+SELF,IF=-NEWWAVE.
                  SPCSMSUM(ISOUR)=SPCSMSUM(ISOUR)+SPECF(ISOUR,IOBSV,IFREQ)*
     &                                   DZ*DY
+SELF,IF=NEWWAVE.
                  SPCSMSUM(ISOUR)=SPCSMSUM(ISOUR)
     &           +SPECF(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))*
     &                                   DZ*DY
+SELF.
            ENDIF   !OBSV

             ELSE    !IPINCIR

            IF (
     &                      (OBSV(2,IOBSV)-PINCEN(2))**2
     &                     +(OBSV(3,IOBSV)-PINCEN(3))**2
     &                       -PINR**2.LT.1.D-10) THEN

                  DZ=OBSVDZ
                  DY=OBSVDY
+SELF,IF=-NEWWAVE.
                  SPCSMSUM(ISOUR)=SPCSMSUM(ISOUR)+SPECF(ISOUR,IOBSV,IFREQ)*
     &                                   DZ*DY
+SELF,IF=NEWWAVE.
                  SPCSMSUM(ISOUR)=SPCSMSUM(ISOUR)
     &           +SPECF(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))*
     &                                   DZ*DY
+SELF.

                 ENDIF  !OBSV

             ENDIF   !IPINCIR

         ENDDO !NOBSV
         ENDDO !ISOUR

         SUMT=0.D0

         DO IOBSV=1,NOBSV

             IF (IPINCIRC.EQ.0) THEN
            IF (
     &           DABS(OBSV(2,IOBSV)-PINCEN(2))-PINH/2.D0.LT.1.D-10
     &                      .AND.
     &           DABS(OBSV(3,IOBSV)-PINCEN(3))-PINW/2.D0.LT.1.D-10
     &                      ) THEN

                  IF(DABS(
     &                           DABS(OBSV(3,IOBSV)-PINCEN(3))
     &                           -PINW/2.D0).LT.1.D-10) THEN
                DZ=OBSVDZ/2.D0

                  ELSE

                     DZ=OBSVDZ

                  ENDIF

                  IF(DABS(
     &                           DABS(OBSV(2,IOBSV)-PINCEN(2))
     &                           -PINH/2.D0).LT.1.D-10) THEN
                DY=OBSVDY/2.D0

                  ELSE

                    DY=OBSVDY

                  ENDIF

+SELF,IF=-NEWWAVE.
                  SUMT=SUMT+SPECTOT(IOBSV,IFREQ)*DY*DZ
+SELF,IF=NEWWAVE.
                  SUMT=SUMT+SPECTOT(IOBSV+NOBSV*(IFREQ-1))*DY*DZ
+SELF.
            ENDIF   !OBSV

             ELSE    !IPINCIR

            IF (
     &                      (OBSV(2,IOBSV)-PINCEN(2))**2
     &                     +(OBSV(3,IOBSV)-PINCEN(3))**2
     &                       -PINR**2.LT.1.D-10) THEN

                  DZ=OBSVDZ
                  DY=OBSVDY
+SELF,IF=-NEWWAVE.
                  SUMT=SUMT+SPECTOT(IOBSV,IFREQ)*DY*DZ
+SELF,IF=NEWWAVE.
                  SUMT=SUMT+SPECTOT(IOBSV+NOBSV*(IFREQ-1))*DY*DZ
+SELF.
                 ENDIF  !OBSV

             ENDIF   !IPINCIR

         ENDDO

         IF (IUNIT.EQ.0)       !260194
     &      WRITE(LUNGFO,*)
     &      '  ',SNGL(FREQ(IFREQ)),(SNGL(SPCSMSUM(ISOUR)),ISOUR=1,NSOURCE)
     &      ,SNGL(SUMT)

         IF (IUNIT.NE.0) !260194
     &      WRITE(LUNGFO,*)
     &      '  ',SNGL(WELLEN(IFREQ)),(SNGL(SPCSMSUM(ISOUR)),ISOUR=1,NSOURCE)
     &      ,SNGL(SUMT)

        IF (IW_BLENF.NE.0) THEN
           DO ISS=1,NSOURCE
             SPCSMRAT(ISS)=9999.
+SELF,IF=-NEWWAVE.
             IF (SPCSMSUM(ISS).NE.0.D0) SPCSMRAT(ISS)=WFLUXF(ISS,IFREQ)/SPCSMSUM(ISS)
+SELF,IF=NEWWAVE.
             IF (SPCSMSUM(ISS).NE.0.D0) SPCSMRAT(ISS)=WFLUXF(ISS+NSOURCE*(IFREQ-1))
     &                                     /SPCSMSUM(ISS)
+SELF.
             ENDDO !ISS
           WRITE(LUNGFO,2584)SNGL(FREQ(IFREQ)),(SPCSMRAT(ISS),ISS=1,NSOURCE)
           WRITE(6,2584)SNGL(FREQ(IFREQ)),(SPCSMRAT(ISS),ISS=1,NSOURCE)
        ENDIF   !IW_BLENF
2584     FORMAT('     ',6(1PE12.4))

         ENDDO !IFREQ

9999  CONTINUE
+SELF,IF=F90.
          DEALLOCATE(SPCSMRAT)
          DEALLOCATE(SPCSMSUM)
+SELF.
      RETURN
      END
+DECK,spectrum.
*CMZ :  4.01/07 30/09/2024  14.48.47  by  Michael Scheer
*CMZ :  4.01/05 26/04/2024  10.52.02  by  Michael Scheer
*CMZ :  4.01/04 20/11/2023  18.32.01  by  Michael Scheer
*CMZ :  4.01/03 01/07/2023  10.08.32  by  Michael Scheer
*CMZ :  4.01/02 14/05/2023  13.25.57  by  Michael Scheer
*CMZ :  4.01/00 05/12/2022  10.23.29  by  Michael Scheer
*CMZ :  4.00/17 15/11/2022  10.09.14  by  Michael Scheer
*CMZ :  4.00/15 31/05/2022  09.04.28  by  Michael Scheer
*CMZ :  4.00/13 07/12/2021  18.47.10  by  Michael Scheer
*CMZ :  4.00/11 15/06/2021  12.33.13  by  Michael Scheer
*CMZ :  4.00/10 03/09/2020  13.24.08  by  Michael Scheer
*CMZ :  4.00/07 26/06/2020  10.05.00  by  Michael Scheer
*CMZ :  4.00/05 29/11/2019  17.42.27  by  Michael Scheer
*CMZ :  4.00/04 27/08/2019  11.49.27  by  Michael Scheer
*CMZ :  3.08/01 03/04/2019  16.22.16  by  Michael Scheer
*CMZ :  3.07/01 29/03/2019  15.08.52  by  Michael Scheer
*CMZ :  3.07/00 14/03/2019  15.32.16  by  Michael Scheer
*CMZ :  3.06/00 19/02/2019  11.45.45  by  Michael Scheer
*CMZ :  3.05/14 28/09/2018  12.28.08  by  Michael Scheer
*CMZ :  3.05/10 13/08/2018  14.40.26  by  Michael Scheer
*CMZ :  3.05/06 17/07/2018  11.15.17  by  Michael Scheer
*CMZ :  3.05/03 17/05/2018  08.46.21  by  Michael Scheer
*CMZ :  3.05/02 09/05/2018  12.55.31  by  Michael Scheer
*CMZ :  3.03/02 04/05/2018  13.55.11  by  Michael Scheer
*CMZ :  3.03/01 12/11/2015  10.13.14  by  Michael Scheer
*CMZ :  3.02/07 22/06/2015  15.01.50  by  Michael Scheer
*CMZ :  3.02/06 15/04/2015  12.01.22  by  Michael Scheer
*CMZ :  3.02/03 07/11/2014  17.09.23  by  Michael Scheer
*CMZ :  3.02/00 18/09/2014  15.43.00  by  Michael Scheer
*CMZ :  3.01/00 03/07/2013  15.42.09  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.70/11 21/02/2013  10.24.53  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  14.04.56  by  Michael Scheer
*CMZ :  2.70/04 21/12/2012  12.38.11  by  Michael Scheer
*CMZ :  2.69/00 30/10/2012  14.15.43  by  Michael Scheer
*CMZ :  2.68/05 18/10/2012  14.25.09  by  Michael Scheer
*CMZ :  2.68/02 05/07/2012  11.19.57  by  Michael Scheer
*CMZ :  2.68/01 29/05/2012  09.43.05  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  16.32.34  by  Michael Scheer
*CMZ :  2.67/04 11/05/2012  15.40.01  by  Michael Scheer
*CMZ :  2.66/18 02/12/2010  14.59.07  by  Michael Scheer
*CMZ :  2.66/16 22/11/2010  14.01.42  by  Michael Scheer
*CMZ :  2.66/13 18/06/2010  14.17.37  by  Michael Scheer
*CMZ :  2.66/09 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.66/08 15/03/2010  15.14.36  by  Michael Scheer
*CMZ :  2.66/07 10/03/2010  09.03.13  by  Michael Scheer
*CMZ :  2.66/06 24/02/2010  17.11.25  by  Michael Scheer
*CMZ :  2.66/04 18/11/2009  10.22.04  by  Michael Scheer
*CMZ :  2.66/03 12/11/2009  16.27.11  by  Michael Scheer
*CMZ :  2.66/00 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  2.65/03 02/10/2009  13.09.16  by  Michael Scheer
*CMZ :  2.65/02 29/09/2009  12.00.20  by  Michael Scheer
*CMZ :  2.64/07 17/09/2009  15.40.31  by  Michael Scheer
*CMZ :  2.64/06 15/09/2009  15.08.58  by  Michael Scheer
*CMZ :  2.64/05 14/09/2009  15.19.42  by  Michael Scheer
*CMZ :  2.64/01 19/08/2009  08.45.04  by  Michael Scheer
*CMZ :  2.64/00 14/08/2009  14.25.09  by  Michael Scheer
*CMZ :  2.63/05 12/08/2009  08.49.28  by  Michael Scheer
*CMZ :  2.62/03 16/07/2007  12.15.22  by  Michael Scheer
*CMZ :  2.62/02 16/07/2007  07.31.52  by  Michael Scheer
*CMZ :  2.61/01 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.57/04 01/02/2006  12.28.09  by  Michael Scheer
*CMZ :  2.57/01 22/11/2005  13.07.59  by  Michael Scheer
*CMZ :  2.56/01 17/10/2005  14.36.43  by  Michael Scheer
*CMZ :  2.56/00 17/10/2005  13.26.33  by  Michael Scheer
*CMZ :  2.54/05 26/05/2005  08.07.59  by  Michael Scheer
*CMZ :  2.53/05 17/02/2005  14.00.32  by  Michael Scheer
*CMZ :  2.52/16 19/01/2005  10.32.23  by  Michael Scheer
*CMZ :  2.52/13 10/12/2004  10.43.51  by  Michael Scheer
*CMZ :  2.52/11 08/12/2004  13.11.32  by  Michael Scheer
*CMZ :  2.52/10 05/11/2004  15.45.33  by  Michael Scheer
*CMZ :  2.52/01 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.52/00 29/06/2004  11.53.01  by  Michael Scheer
*CMZ :  2.51/02 22/06/2004  09.06.04  by  Michael Scheer
*CMZ :  2.51/01 17/06/2004  11.33.47  by  Michael Scheer
*CMZ :  2.51/00 26/05/2004  15.54.25  by  Michael Scheer
*CMZ :  2.50/02 30/04/2004  15.27.49  by  Michael Scheer
*CMZ :  2.50/00 29/04/2004  17.07.16  by  Michael Scheer
*CMZ :  2.49/00 22/03/2004  13.30.23  by  Michael Scheer
*CMZ :  2.47/09 20/05/2003  14.31.10  by  Michael Scheer
*CMZ :  2.47/05 25/03/2003  12.09.15  by  Michael Scheer
*CMZ :  2.47/01 10/03/2003  11.54.47  by  Michael Scheer
*CMZ :  2.46/02 07/03/2003  11.02.34  by  Michael Scheer
*CMZ :  2.44/01 21/11/2002  16.45.47  by  Michael Scheer
*CMZ :  2.44/00 15/11/2002  18.31.22  by  Michael Scheer
*CMZ :  2.41/11 21/08/2002  11.23.26  by  Michael Scheer
*CMZ :  2.41/09 14/08/2002  17.20.18  by  Michael Scheer
*CMZ :  2.41/07 31/05/2002  16.37.13  by  Michael Scheer
*CMZ :  2.38/00 12/12/2001  18.21.12  by  Michael Scheer
*CMZ :  2.35/02 30/10/2001  17.06.49  by  Michael Scheer
*CMZ :  2.34/09 26/09/2001  17.14.17  by  Michael Scheer
*CMZ :  2.34/00 11/05/2001  17.06.33  by  Michael Scheer
*CMZ :  2.33/04 04/05/2001  11.31.09  by  Michael Scheer
*CMZ :  2.33/01 03/05/2001  13.48.25  by  Michael Scheer
*CMZ :  2.33/00 03/05/2001  10.49.22  by  Michael Scheer
*CMZ :  2.31/01 25/04/2001  14.38.57  by  Michael Scheer
*CMZ :  2.31/00 24/04/2001  11.16.55  by  Michael Scheer
*CMZ :  2.30/01 12/04/2001  12.43.20  by  Michael Scheer
*CMZ :  2.20/11 11/04/2001  13.15.39  by  Michael Scheer
*CMZ :  2.20/10 04/04/2001  16.52.12  by  Michael Scheer
*CMZ :  2.20/09 03/04/2001  14.51.24  by  Michael Scheer
*CMZ :  2.20/04 09/03/2001  19.13.21  by  Michael Scheer
*CMZ :  2.20/03 23/02/2001  14.46.53  by  Michael Scheer
*CMZ :  2.20/01 19/02/2001  10.53.35  by  Michael Scheer
*CMZ :  2.17/00 06/11/2000  17.32.34  by  Michael Scheer
*CMZ :  2.16/08 01/11/2000  18.52.39  by  Michael Scheer
*CMZ :  2.16/07 17/10/2000  11.06.19  by  Michael Scheer
*CMZ :  2.16/06 28/08/2000  16.04.39  by  Michael Scheer
*CMZ :  2.16/05 02/08/2000  13.56.30  by  Michael Scheer
*CMZ :  2.16/04 20/07/2000  15.20.32  by  Michael Scheer
*CMZ :  2.16/03 16/06/2000  14.59.25  by  Michael Scheer
*CMZ :  2.16/01 15/06/2000  16.12.25  by  Michael Scheer
*CMZ :  2.16/00 13/06/2000  14.00.28  by  Michael Scheer
*CMZ :  2.15/00 06/05/2000  11.15.11  by  Michael Scheer
*CMZ :  2.13/10 06/04/2000  13.55.09  by  Michael Scheer
*CMZ :  2.13/08 28/02/2000  10.59.59  by  Michael Scheer
*CMZ :  2.13/07 17/02/2000  15.11.13  by  Michael Scheer
*CMZ :  2.13/04 21/01/2000  14.49.57  by  Michael Scheer
*CMZ :  2.13/03 18/01/2000  17.58.11  by  Michael Scheer
*CMZ :  2.13/02 14/12/99  16.47.46  by  Michael Scheer
*CMZ :  2.13/00 02/12/99  13.19.08  by  Michael Scheer
*CMZ :  2.12/04 20/08/99  11.42.59  by  Michael Scheer
*CMZ :  2.12/03 08/07/99  10.46.11  by  Michael Scheer
*CMZ :  2.12/02 15/06/99  16.10.08  by  Michael Scheer
*CMZ :  2.12/01 14/06/99  15.26.07  by  Michael Scheer
*CMZ :  2.12/00 03/06/99  15.38.11  by  Michael Scheer
*CMZ :  2.11/01 18/05/99  10.04.01  by  Michael Scheer
*CMZ :  2.11/00 12/05/99  11.35.36  by  Michael Scheer
*CMZ :  2.10/01 19/03/99  11.45.33  by  Michael Scheer
*CMZ :  2.02/00 12/02/99  16.13.41  by  Michael Scheer
*CMZ :  2.00/00 06/01/99  11.58.17  by  Michael Scheer
*CMZ :  1.04/03 11/12/98  16.35.36  by  Michael Scheer
*CMZ :  1.04/02 11/12/98  11.35.23  by  Michael Scheer
*CMZ :  1.04/01 11/12/98  11.21.18  by  Michael Scheer
*CMZ :  1.04/00 05/10/98  15.04.38  by  Michael Scheer
*CMZ :  1.03/06 25/09/98  11.00.44  by  Michael Scheer
*CMZ :  1.03/03 24/02/98  12.03.00  by  Michael Scheer
*CMZ :  1.03/02 18/02/98  16.56.26  by  Michael Scheer
*CMZ :  1.03/01 16/01/98  16.52.08  by  Michael Scheer
*CMZ :  1.02/03 16/01/98  10.58.48  by  Michael Scheer
*CMZ :  1.00/00 05/08/97  15.02.55  by  Michael Scheer
*CMZ : 00.02/05 25/03/97  13.44.31  by  Michael Scheer
*CMZ : 00.02/04 26/02/97  12.24.14  by  Michael Scheer
*CMZ : 00.02/03 16/01/97  11.07.55  by  Michael Scheer
*CMZ : 00.02/02 15/01/97  13.14.58  by  Michael Scheer
*CMZ : 00.01/12 04/11/96  11.52.18  by  Michael Scheer
*CMZ : 00.01/10 16/07/96  15.25.52  by  Michael Scheer
*CMZ : 00.01/09 01/09/95  13.05.18  by  Michael Scheer
*CMZ : 00.01/08 22/06/95  18.18.43  by  Michael Scheer
*CMZ : 00.01/07 24/02/95  11.21.39  by  Michael Scheer
*CMZ : 00.01/06 02/02/95  19.03.32  by  Michael Scheer
*CMZ : 00.01/05 31/01/95  15.35.41  by  Michael Scheer
*CMZ : 00.01/04 26/01/95  16.20.02  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  18.37.44  by  Michael Scheer
*CMZ : 00.00/07 25/05/94  16.45.07  by  Michael Scheer
*CMZ : 00.00/05 29/04/94  20.07.34  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.54.43  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.39  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE SPECTRUM
+seq,gplhint.

C--- MAIN ROUTINE TO CALCULATE SYNCHROTRON RADIATION SPECTRA

+SEQ,TRACKF90U.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,REARGF90U.
+SEQ,WFOLDF90U.
+SEQ,AFREQF90U.
+SEQ,AMPLIF90U.

      use clustermod
      use bunchmod
      use ompmod
      use uradphasemod
      !use waveenv

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,TRACK.
+SEQ,OPTIC.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,SPECDIP.
+SEQ,COLLI.
+SEq,wfoldf90.
+SEQ,DEPOLA.
+SEQ,WUSEM.
+SEQ,AMPLI.
+SEQ,USERVAR.
+SEQ,PHYCON.
+SEQ,PRIMKIN.
+seq,datetime.
+seq,debugwave.
+seq,waveenv.

      INTEGER ISOUR,IS,IFR,IO,IX,IC,JC,IZ,IY,IFREQ,IOBSV,IBUFF
      INTEGER ICEN,ISTO,MSADD,IFAIL,I,ISTOK
      INTEGER NTOTIN,NTOT2IN,IREP,ipino,ibuncho,ihbuncho,mbuncho,meinbuncho

      REAL*4 POL,rr(2)
      REAL*4 THERAY,PHIRAY,RAY,ZRAY,YRAY,DRAY,RAY1,RAY2,RAY3,RAY1N,RAY2N,RAY3N

      DOUBLE PRECISION ENEDOSMX,S1,S2,S3,S4,DUM1,DUM2,RMS
      DOUBLE PRECISION WSNOBFR1(NDFREQP),WSNOBFR2(NDFREQP),SPECBUFF(NDFREQP)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SPECTRUM'
      WRITE(LUNGFO,*)'     ==========='
      WRITE(LUNGFO,*)

      ipino=ipin
      ibuncho=ibunch
      mbuncho=nbunch
      meinbuncho=neinbunch
      ihbuncho=ihbunch
      if (kampli.ne.0) then
        ibunch=0
        ihbunch=0
      endif

      if (ispecmode.ne.3.and.ispecmode.ne.1.and.ispecmode.ne.2) then
        write(6,*)
     &    '*** ERROR IN SPECTRUM: ISPECMODE must be 1, 2, or 3***'
        write(LUNGFO,*)
     &    '*** ERROR IN SPECTRUM: ISPECMODE must be 1, 2, or 3***'
        stop '*** PROGRAM WAVE ABORTED ***'
      endif

      if (ipin.eq.3.and.ispecmode.ne.1.and.ispecmode.ne.2) then
        write(LUNGFO,*)
     &    '*** ERROR IN SPECTRUM: For IPIN=3, ISPECMODE must be 1 or 2 ***'
        write(6,*)
     &    '*** ERROR IN SPECTRUM: For IPIN=3, ISPECMODE must be 1 or 2 ***'
        stop
      endif

      IF (ISPECDIP.GT.0.and.ibrill.ne.0) THEN
        write(6,*)'*** WARNING IN SPECTRUM: ISPECDIP.gt.0 and IBRILL.ne.0'
        write(6,*)'*** IBRILL SET TO ZERO ***'
        write(LUNGFO,*)'*** WARNING IN SPECTRUM: ISPECDIP.gt.0 and IBRILL.ne.0'
        write(lungfo,*)'*** IBRILL SET TO ZERO ***'
        IBRILL=0
      endif

      IF (ISPECDIP.GT.0.and.ifold.ne.0) THEN
        write(6,*)'*** WARNING IN SPECTRUM: ISPECDIP.gt.0 and IFOLD.ne.0'
        write(6,*)'*** IFOLD SET TO ZERO ***'
        write(LUNGFO,*)'*** WARNING IN SPECTRUM: ISPECDIP.gt.0 and IFOLD.ne.0'
        write(lungfo,*)'*** IFOLD SET TO ZERO ***'
        ifold=0
        ihfold=0
      endif

      IF (ISPECDIP.GT.0.and.IEFOLD.ne.0) THEN
        write(6,*)'*** WARNING IN SPECTRUM: ISPECDIP.gt.0 and IEFOLD.ne.0'
        write(6,*)'*** IEFOLD SET TO ZERO ***'
        write(LUNGFO,*)'*** WARNING IN SPECTRUM: ISPECDIP.gt.0 and IEFOLD.ne.0'
        write(lungfo,*)'*** IEFOLD SET TO ZERO ***'
        IEFOLD=0
      endif

      IF (ISPECDIP.eq.2.and.if1dim.eq.0) THEN
        write(LUNGFO,*)'*** WARNING IN SPECTRUM: ISPECDIP.eq.2 and IF1DIM.eq.0'
        write(LUNGFO,*)'*** IF1DIM SET TO ONE ***'
        write(6,*)'*** WARNING IN SPECTRUM: ISPECDIP.eq.2 and IF1DIM.eq.0'
        write(6,*)'*** IF1DIM SET TO ONE ***'
        If1dim=1
      endif

      IF (ISPECMODE.gt.2.and.mpinr.ne.0) THEN
        WRITE(LUNGFO,*)' '
        WRITE(LUNGFO,*)
     &    '*** WARNING IN SPECTRUM: ISPECMODE .gt. 2 .and. MPINR .ne. 0'
        WRITE(LUNGFO,*)'*** MPINR will be ignored and set to zero'
        WRITE(LUNGFO,*)' '
        WRITE(6,*)' '
        WRITE(6,*)
     &    '*** WARNING IN SPECTRUM: ISPECMODE .gt. 2 .and. MPINR .ne. 0'
        WRITE(6,*)'*** MPINR will be ignored and set to zero'
        WRITE(6,*)' '
c        mpinr=0
      endif
c 20150622{
c      IF (IFREQ2P.EQ.0.AND.ISPECMODE.LT.3) THEN
c
c        WRITE(LUNGFO,*)
c     &    '*** WARNING IN SPECTRUM: Option IFREQ2P=0 NOT available for ISPECMODE<3'
c        WRITE(LUNGFO,*)
c     &    '*** ISPECMODE set to 3'
c        WRITE(LUNGFO,*)''
c
c        WRITE(6,*)
c     &    '*** WARNING IN SPECTRUM: Option IFREQ2P=0 NOT available for ISPECMODE<3'
c        WRITE(6,*)
c     &    '*** ISPECMODE set to 3'
c        WRITE(6,*)''
c
c        ISPECMODE=3
c
c 20150622}      ENDIF

      IF (ibunch.ne.0) THEN
        write(lungfo,*)'      Bunch parameters:'
        write(lungfo,*)'      mode IUBUNCH:                    ',IUBUNCH
        write(lungfo,*)'      number of bunches NBUNCH:        ',NBUNCH
        write(lungfo,*)'      number of e- per bunch NEINBUNCH:',NEINBUNCH
        write(lungfo,*)'      bunch length [m]: BUNCHLEN:      ',BUNCHLEN
        write(lungfo,*)'      bunch charge [C]: BUNCHCHARGE:   ',BUNCHCHARGE
        WRITE(lungfo,*)''
        WRITE(lungfo,*)''
      endif

      IF (ISPECDIP.LE.0) THEN

        WRITE(LUNGFO,*)
     &    '     Start and end of points [m] of integration for spectrum'
        WRITE(LUNGFO,*)'     calculations (XIANF,XIEND):'
     &    ,SNGL(XIANF),SNGL(XIEND)
        WRITE(LUNGFO,*)

        IF ((XIANF.NE.XSTART.OR.XIEND.NE.XSTOP)
     &      .AND.XIANF.NE.-1.D30.AND.XIEND.NE.1.D30) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      ' *** Start or end of points (XIANF,XIEND) of integration differ'
          WRITE(LUNGFO,*)
     &      ' *** from XSTART or XSTOP respectively'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)
     &      ' *** Start or end of points (XIANF,XIEND) of integration differ'
          WRITE(6,*)
     &      ' *** from XSTART or XSTOP respectively'
          WRITE(6,*)
          WRITE(6,*)
        ENDIF

      ENDIF !ISPECDIP.LE.0

      IF (IWFILINT.GT.0) THEN
        OPEN(UNIT=LUNINT,FILE=FILEINT)
      ENDIF !IWFILINT

C--- NEW VERSION OF TRACKS REQUIRES IMAGSPLN

      IF (ISPECMODE.EQ.3) IMAGSPLN=-999

C----   FREQUENCES TO BE TREATED

      CALL RFILFR

C--- NOW WE ARE DEALING WITH PHOTON ENERGIES

C260194  IF (IUNIT.NE.0) CALL CONVUN

C---  DEFAULTS FOR WGWINFC

      if (pinr.eq.-9999.) pinr=max(pinw,pinh)/2.0d0
      if (pinr.eq.9999.) pinr=sqrt(pinw*pinh/pi1)
      IF (WGWINFC.EQ.9999.AND.IUNDULATOR.EQ.0) CALL SETWGWIN

C---  DEFAULTS FOR PINCEN

      IOBSV_A=1
      IOBSVZ_A=1
      IOBSVY_A=1

      ALLOCATE(OBSV(3,IOBSV_A))
      ALLOCATE(OBSVY(IOBSVY_A))
      ALLOCATE(OBSVZ(IOBSVZ_A))

      IF (IPIN.NE.0) THEN
        CALL PINCENIN
      ENDIF

      IF (OBS1X.EQ.-9999.) OBS1X=PINCEN(1)
      IF (aperX.EQ.-9999.) aperx=PINCEN(1)

      if (ipin.eq.0.and.obs1x.le.xstop) then
        write(6,*)
     &    '*** Error: OBS1X (x of observation point) must be bigger than XSTOP'
        write(6,*)
     &    '*** Please check input file'
        write(6,*)
     &    '*** Program WAVE aborted ***'
        stop
      else if (ipin.ne.0.and.pincen(1).le.xstop) then
        write(6,*)
     &    '*** Error: PINCEN(1) (x of pinhole) must be bigger than XSTOP'
        write(6,*)
     &    '*** Please check input file'
        write(6,*)
     &    '*** Program WAVE aborted ***'
        stop
      endif

      IF (OBS1y.EQ.-9999.) then
        OBS1y=ySTART+VyIN/VXIN*(OBS1X-XSTART)
      else IF (obs1y.EQ.-8888.) THEN
        obs1y=yoffstr+yslopetr*obs1x
      else IF (obs1y.EQ.-9000.) THEN
        obs1y=0.0d0
        do i=1,nco
          obs1y=obs1y+
     &      wtra(2,1,i)+wtra(2,2,i)/wtra(1,2,i)*(PINCEN(1)-wtra(1,1,i))
        enddo
        obs1y=obs1y/nco
      ENDIF

      IF (OBS1Z.EQ.-9999.) then
        OBS1Z=ZSTART+VZIN/VXIN*(OBS1X-XSTART)
      else IF (obs1z.EQ.-8888.) THEN
        obs1z=zoffstr+zslopetr*obs1x
      else IF (obs1z.EQ.-9000.) THEN
        obs1z=0.0d0
        do i=1,nco
          obs1z=obs1z+
     &      wtra(3,1,i)+wtra(3,2,i)/wtra(1,2,i)*(PINCEN(1)-wtra(1,1,i))
        enddo
        obs1z=obs1z/nco
      ENDIF

      IF (IPIN.EQ.0) PINCEN(1)=OBS1X

C---  SOURCES OF LIGHT. SOURCES ARE READ OR DEFINED BY COLLIMATOR

      IF (CX1.EQ.9999.) THEN
        IF (IRFILOB.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '*** DEFAULT FOR CX1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
          WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)
     &      '*** DEFAULT FOR CX1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
          WRITE(6,*)'*** CHECK INPUT FILE ***'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF
        IF (IPIN.NE.0) THEN
          CX1=PINCEN(1)-0.00001
        ELSE
          CX1=OBS1X-0.00001
        ENDIF
      ENDIF

      IF (CX2.EQ.9999.) THEN
        IF (IRFILOB.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '*** DEFAULT FOR CX2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
          WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)
     &      '*** DEFAULT FOR CX2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
          WRITE(6,*)'*** CHECK INPUT FILE ***'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF
        IF (IPIN.NE.0) THEN
          CX2=PINCEN(1)
        ELSE
          CX2=OBS1X
        ENDIF
      ENDIF

      IF (CY1.EQ.9999.) THEN
        IF (IRFILOB.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '*** DEFAULT FOR CY1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
          WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)
     &      '*** DEFAULT FOR CY1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
          WRITE(6,*)'*** CHECK INPUT FILE ***'
          WRITE(6,*)
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF
        IF (IPIN.NE.0) THEN
          CY1=PINCEN(2)
        ELSE
          CY1=OBS1Y
        ENDIF
      ENDIF !CY1

       IF (CY2.EQ.9999.) THEN
         IF (IRFILOB.NE.0) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
     &       '*** DEFAULT FOR CY2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)
     &       '*** DEFAULT FOR CY2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(6,*)'*** CHECK INPUT FILE ***'
           WRITE(6,*)
           STOP '*** PROGRAM WAVE ABORTED ***'
         ENDIF
         IF (IPIN.NE.0) THEN
           CY2=PINCEN(2)
         ELSE
           CY2=OBS1Y
         ENDIF
       ENDIF !CY2

       IF (CZ1.EQ.9999.) THEN
         IF (IRFILOB.NE.0) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
     &       '*** DEFAULT FOR CZ1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)
     &       '*** DEFAULT FOR CZ1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(6,*)'*** CHECK INPUT FILE ***'
           WRITE(6,*)
           STOP '*** PROGRAM WAVE ABORTED ***'
         ENDIF
         IF (IPIN.NE.0) THEN
           CZ1=PINCEN(3)
         ELSE
           CZ1=OBS1Z
         ENDIF
       ENDIF !CZ1

       IF (CZ2.EQ.9999.) THEN
         IF (IRFILOB.NE.0) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
     &       '*** DEFAULT FOR CZ2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)
     &       '*** DEFAULT FOR CZ2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(6,*)'*** CHECK INPUT FILE ***'
           WRITE(6,*)
           STOP '*** PROGRAM WAVE ABORTED ***'
         ENDIF
         IF (IPIN.NE.0) THEN
           CZ2=PINCEN(3)
         ELSE
           CZ2=OBS1Z
         ENDIF
       ENDIF !CZ2

       IF (WID1.EQ.9999.) THEN
         IF (IRFILOB.NE.0) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
     &       '*** DEFAULT FOR WID1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)
     &       '*** DEFAULT FOR WID1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(6,*)'*** CHECK INPUT FILE ***'
           WRITE(6,*)
           STOP '*** PROGRAM WAVE ABORTED ***'
         ENDIF
         IF (IPIN.NE.0) THEN
           WID1=PINW+4.*PINW/MPINZ
         ELSE
           WID1=0.001
         ENDIF
       ENDIF !WID1

       IF (WID2.EQ.9999.) THEN
         IF (IRFILOB.NE.0) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
     &       '*** DEFAULT FOR WID2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)
     &       '*** DEFAULT FOR WID2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(6,*)'*** CHECK INPUT FILE ***'
           WRITE(6,*)
           STOP '*** PROGRAM WAVE ABORTED ***'
         ENDIF
         IF (IPIN.NE.0) THEN
           WID2=PINW+4.*PINW/MPINZ
         ELSE
           WID2=0.001
         ENDIF
       ENDIF !WID2

       IF (HIG1.EQ.9999.) THEN
         IF (IRFILOB.NE.0) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
     &       '*** DEFAULT FOR HIG1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)
     &       '*** DEFAULT FOR HIG1 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(6,*)'*** CHECK INPUT FILE ***'
           WRITE(6,*)
           STOP '*** PROGRAM WAVE ABORTED ***'
         ENDIF
         IF (IPIN.NE.0) THEN
           HIG1=PINH+4.*PINH/MPINY
         ELSE
           HIG1=0.001
         ENDIF
       ENDIF !HIG1

       IF (HIG2.EQ.9999.) THEN
         IF (IRFILOB.NE.0) THEN
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
     &       '*** DEFAULT FOR HIG2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(LUNGFO,*)'*** CHECK INPUT FILE ***'
           WRITE(LUNGFO,*)
           WRITE(6,*)
           WRITE(6,*)
     &       '*** DEFAULT FOR HIG2 NOT ALLOWED SINCE FLAG IRFILOB IS SET ***'
           WRITE(6,*)'*** CHECK INPUT FILE ***'
           WRITE(6,*)
           STOP '*** PROGRAM WAVE ABORTED ***'
         ENDIF
         IF (IPIN.NE.0) THEN
           HIG2=PINH+4.*PINH/MPINY
         ELSE
           HIG2=0.001
         ENDIF
       ENDIF !HIG2

       IF(IRFILL0.NE.0) THEN
         CALL RFILL0
       ELSE IF (ISPECDIP.LE.0) THEN
         CALL WFILL0
       ELSE IF (ISPECDIP.GT.0) THEN
         NSOURCE=NDIP
       ENDIF

       if (nsource.gt.1.and.ibrill.ne.0) then
         write(6,*) "*** Warning: More then one source. This is not compatible with IBRILL=1"
         write(6,*) "*** IBRILL is set to zero!"
         write(LUNGFO,*) "*** Warning: More then one source. This is not compatible with IBRILL=1"
         write(LUNGFO,*) "*** IBRILL is set to zero!"
         ibrill=0
       endif

       if (nsource.gt.1.and.kampli.ne.0) then
         write(6,*) "*** Error: More then one source. This is not compatible with KAMPLI"
         stop "*** Program WAVE aborted ***"
       endif

       ALLOCATE(IPOISOU(NSOURCE))

       IF (ISPECDIP.LE.0) THEN

C        SOURCEE,SOUREA... ARE ALLOCATED IN RFILL0/WFILL0

         ALLOCATE(IWARNROI(NROIA,NSOURCE))
         ALLOCATE(IPOIROI(NROIA+1))
         ALLOCATE(IZTOT(NSOURCE))
         ALLOCATE(ECSOUR(4,NSOURCE))
         ALLOCATE(ECMAX(NSOURCE))

         DO I=1,NSOURCE
           ECSOUR(1,I)=0.0d0
           ECSOUR(2,I)=0.0d0
           ECSOUR(3,I)=0.0d0
           ECSOUR(4,I)=0.0d0
           ECMAX(I)=0.0d0
         ENDDO

C--- HISTOGRAMS OF MINITRAJECTORIES OF SOURCES

         IF (IHTRACKM.NE.0) CALL HSOURCE

C---- COHERENCE OF SOURCES

         CALL COHEREN

       ENDIF   !ISPECDIP.LE.0

C----   OBSERVATION POINTS TO BE TREATED

       IF (IPIN.NE.0) THEN

         if (ipin.eq.3) then
           call pinin3
         else
           CALL PININ
         endif

       ELSE !ipin

         MPINR=0

         IF (IFOLD.EQ.2) THEN

           CALL WSIGFOL

           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'     Horizontal emittance EPS0H [m-rad]:',EPS0H
           WRITE(LUNGFO,*)'     Vertical emittance EPS0V [m-rad]:  ',EPS0V
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'     Number of sigmas for horiz. folding:'
           WRITE(LUNGFO,*)'     ',(SNGL(DGSIGZ(IS)),IS=1,NSOURCE)
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'     Number of sigmas for vert. folding:'
           WRITE(LUNGFO,*)'     ',(SNGL(DGSIGY(IS)),IS=1,NSOURCE)
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'     Sigmas of sources for horiz. folding:'
           WRITE(LUNGFO,*)'     ',(SNGL(WSIGZ(IS)),IS=1,NSOURCE)
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'     Sigmas of sources for vert. folding:'
           WRITE(LUNGFO,*)'     ',(SNGL(WSIGY(IS)),IS=1,NSOURCE)
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'     Sigmas of horizontal beam size and divergence:'
           WRITE(LUNGFO,*)
     &       '     (if not zero, sigmas for folding are calculated from these values)'
           WRITE(LUNGFO,*)'     ',(SNGL(BSIGZ(IS)),SNGL(BSIGZP(IS)),IS=1,NSOURCE)
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'     Sigmas of vertical beam size and divergence:'
           WRITE(LUNGFO,*)
     &       '     (if not zero, sigmas for folding are calculated from these values)'
           WRITE(LUNGFO,*)'     ',(SNGL(BSIGY(IS)),SNGL(BSIGYP(IS)),IS=1,NSOURCE)
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)

           IF (ISTOKES.NE.0) THEN
             WRITE(LUNGFO,*)
     &         '     Sigmas for folding of components of STOKES vector:'
             WRITE(LUNGFO,*)
     &         '     ',SNGL(WSIGZ(ISIGSTO)),SNGL(WSIGY(ISIGSTO))
           ENDIF !ISTOKES

           WRITE(LUNGFO,*)

         ENDIF !IFOLD.EQ.2

         ICBRILL=1
         CALL RFILOB
         IF (IRFILOB.NE.0.AND.IPBRILL.NE.0) THEN
           ICBRILL=IPBRILL
           IF (ICBRILL.GT.NOBSV) THEN
             WRITE(LUNGFO,*)'*** ERROR IN SPECTRUM: BAD SELECTED POINT ***'
             WRITE(LUNGFO,*)'*** CHECK INPUT IPBRILL IN WAVE.IN'
             WRITE(6,*)'*** ERROR IN SPECTRUM: BAD SELECTED POINT ***'
             WRITE(6,*)'*** CHECK INPUT IPBRILL IN WAVE.IN'
             STOP
           ENDIF
         ENDIF
       ENDIF !ipin

       IF (NOBSVZ.GT.NDOBSVZP) THEN
         WRITE(6,*)'*** DIMENSION ERROR IN SPECTRUM FOR NDOBSVZP ***'
         WRITE(6,*)'DIMENSION IS: ',NDOBSVZP
         WRITE(6,*)'CALCULATION REQUIRES: ',NOBSVZ
         WRITE(6,*)'*** CHANGE PARAMETER NDOBSVZP IN CMPARA.CMN***'
         WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
         STOP
       ENDIF   !(NOBSVZ.GT.NDOBSVZP)

       IF (NOBSVY.GT.NDOBSVYP) THEN
         WRITE(6,*)'*** DIMENSION ERROR IN SPECTRUM FOR NDOBSVYP ***'
         WRITE(6,*)'DIMENSION IS: ',NDOBSVYP
         WRITE(6,*)'CALCULATION REQUIRES: ',NOBSVY
         WRITE(6,*)'*** CHANGE PARAMETER NDOBSVYP IN CMPARA.CMN***'
         WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
         STOP
         IF (NOBSV.GT.NDOBSVP) THEN
           WRITE(6,*)'*** DIMENSION ERROR IN SPECTRUM FOR NDOBSVP ***'
           WRITE(6,*)'DIMENSION IS: ',NDOBSVP
           WRITE(6,*)'CALCULATION REQUIRES: ',NOBSV
           WRITE(6,*)'*** CHANGE PARAMETER NDOBSVP IN CMPARA.CMN***'
           WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
           STOP
         ENDIF !(NOBSV.GT.NDOBSVP)
       ENDIF   !(NOBSVY.GT.NDOBSVYP)

       ALLOCATE(schwingercen(4,nobsv,nsource))
       ALLOCATE(SPEC(NSOURCE*NOBSV*NFREQ))
       spec=0.0d0

      IF (MPINR.NE.0) THEN
        ALLOCATE(SPECRPHI(NSOURCE*NOBSVRPHI*NFREQ))
        SPECRPHI=0.0D0
      ENDIF

      ALLOCATE(SPECI(NSOURCE*NOBSV))
      ALLOCATE(SPECIV(NSOURCE*NOBSV))
      ALLOCATE(SPECPOW(NSOURCE*NOBSV))
      if (ifold.ne.0) then
        ALLOCATE(SPECPOWF(NSOURCE*NOBSV))
        ALLOCATE(SPECPOWTF(NOBSV))
      endif
      IF (MPINR.GT.0) THEN
        ALLOCATE(SPECPOWRPHI(NSOURCE*NOBSVRPHI))
        SPECPOWRPHI=0.0D0
      ENDIF

      SPECI=0.0d0
      SPECIV=0.0d0
      SPECPOW=0.0d0

      ALLOCATE(SPECPOWV(NSOURCE*NOBSVZ))
      DO I=1,NSOURCE*NOBSVZ
        SPECPOWV(I)=0.0d0
      ENDDO

      ALLOCATE(WFLUX(NSOURCE*NFREQ))
      DO I=1,NSOURCE*NFREQ
        WFLUX(I)=0.0d0
      ENDDO

      ALLOCATE(SPECTOT(NOBSV*NFREQ))
      DO I=1,NOBSV*NFREQ
        SPECTOT(I)=0.0d0
      ENDDO

      ALLOCATE(REAIMA(14,2,NOBSV*NFREQ))
      REAIMA=0.0d0

      IF (MPINR.NE.0) THEN
        ALLOCATE(REAIMARPHI(14,2,NOBSV*NFREQ))
        REAIMARPHI=0.0d0
      ENDIF

      IF (ISTOKES.NE.0) THEN
        ALLOCATE(STOKES(4,NOBSV*NFREQ))
        STOKES=0.0D0
        IF (IEFOLD.NE.0) THEN
          ALLOCATE(STOKESE(4,NOBSV*NFREQ))
          STOKESE=0.0D0
          IF (IFOLD.NE.0) THEN
            ALLOCATE(STOKESEF(4,NOBSV*NFREQ))
            STOKESE=0.0D0
          ENDIF
        ENDIF
      ENDIF

      ALLOCATE(SPECPOWVH(NSOURCE))
      ALLOCATE(WFLUXI(NSOURCE))
      DO I=1,NSOURCE
        SPECPOWVH(I)=0.0d0
        WFLUXI(I)=0.0d0
      ENDDO

      ALLOCATE(SPECTOTI(NOBSV))
      ALLOCATE(SPECPOWT(NOBSV))
      ALLOCATE(SPECPOWTgraz(NOBSV))
      ALLOCATE(ENEDOS(NOBSV))
      ALLOCATE(SPCOEFM(NOBSV))
      ALLOCATE(WOBS1(NOBSV))
      ALLOCATE(WOBS2(NOBSV))
      ALLOCATE(WOBS3(NOBSV))
      ALLOCATE(WOBS4(NOBSV))
      ALLOCATE(WOBS5(NOBSV))
      ALLOCATE(WOBS6(NOBSV))
      ALLOCATE(WOBS7(NOBSV))
      ALLOCATE(WOBS8(NOBSV))
      ALLOCATE(SPCOEF(NOBSV))
      DO I=1,NOBSV
        SPECTOTI(I)=0.0d0
        SPECPOWT(I)=0.0d0
        SPECPOWTgraz(I)=0.0d0
        ENEDOS(I)=0.0d0
        SPCOEFM(I)=0.0d0
        WOBS1(I)=0.0d0
        WOBS2(I)=0.0d0
        WOBS3(I)=0.0d0
        WOBS4(I)=0.0d0
        WOBS5(I)=0.0d0
        WOBS6(I)=0.0d0
        WOBS7(I)=0.0d0
        WOBS8(I)=0.0d0
        SPCOEF(I)=0.0d0
      ENDDO

      ALLOCATE(SPECPOWVT(NOBSVZ))
      DO I=1,NOBSVZ
        SPECPOWVT(I)=0.0d0
      ENDDO

      ALLOCATE(WFLUXT(NFREQ))

      DO I=1,NFREQ
        WFLUXT(I)=0.0D0
      ENDDO

      IF (ISTOKES.NE.0) THEN
        ALLOCATE(WSTOKES(4,NFREQ))
        ALLOCATE(STOKEC(4,NFREQ))
        DO I=1,NFREQ
          WSTOKES(1,I)=0.0D0
          WSTOKES(2,I)=0.0D0
          WSTOKES(3,I)=0.0D0
          WSTOKES(4,I)=0.0D0
          STOKEC(1,I)=0.0D0
          STOKEC(2,I)=0.0D0
          STOKEC(3,I)=0.0D0
          STOKEC(4,I)=0.0D0
        ENDDO
      ENDIF !ISTOKES

      IF (IBRILL.NE.0) THEN
        ALLOCATE(BRILLC(4,NFREQ))
        ALLOCATE(BRILLCF(4,NFREQ))  !also for ifold.eq.0
        DO I=1,NFREQ
          BRILLC(1,I)=0.0D0
          BRILLC(2,I)=0.0D0
          BRILLC(3,I)=0.0D0
          BRILLC(4,I)=0.0D0
          BRILLCF(1,I)=0.0D0
          BRILLCF(2,I)=0.0D0
          BRILLCF(3,I)=0.0D0
          BRILLCF(4,I)=0.0D0
        ENDDO
      ENDIF !IBRILL

      IF (IEFOLD.NE.0) THEN

        IF (ISTOKES.NE.0) THEN
          ALLOCATE(WSTOKESE(4,NFREQ))
          ALLOCATE(STOKECE(4,NFREQ))
          DO I=1,NFREQ
            WSTOKESE(1,I)=0.0D0
            WSTOKESE(2,I)=0.0D0
            WSTOKESE(3,I)=0.0D0
            WSTOKESE(4,I)=0.0D0
            STOKECE(1,I)=0.0D0
            STOKECE(2,I)=0.0D0
            STOKECE(3,I)=0.0D0
            STOKECE(4,I)=0.0D0
          ENDDO
        ENDIF !ISTOKES

        IF (IBRILL.NE.0) THEN
          ALLOCATE(BRILLCE(4,NFREQ))
          ALLOCATE(BRILLCEF(4,NFREQ)) !also for ifold.eq.0
          DO I=1,NFREQ
            BRILLCE(1,I)=0.0D0
            BRILLCE(2,I)=0.0D0
            BRILLCE(3,I)=0.0D0
            BRILLCE(4,I)=0.0D0
            BRILLCEF(1,I)=0.0D0
            BRILLCEF(2,I)=0.0D0
            BRILLCEF(3,I)=0.0D0
            BRILLCEF(4,I)=0.0D0
          ENDDO
        ENDIF   !IBRILL

      ENDIF !IEFOLD

      IF (IFOLD.NE.0) THEN

        ALLOCATE(SPECF(NSOURCE*NOBSV*NFREQ))
        DO I=1,NSOURCE*NOBSV*NFREQ
          SPECF(I)=0.0d0
        ENDDO

        ALLOCATE(SPECIF(NSOURCE*NOBSV))
        DO I=1,NSOURCE*NOBSV
          SPECIF(I)=0.0d0
        ENDDO

        ALLOCATE(SPECIVF(NSOURCE*NOBSVY))
        DO I=1,NSOURCE*NOBSVY
          SPECIVF(I)=0.0d0
        ENDDO

        ALLOCATE(WFLUXF(NSOURCE*NFREQ))
        DO I=1,NSOURCE*NFREQ
          WFLUXF(I)=0.0d0
        ENDDO

        ALLOCATE(DOBUFF(NOBSV))
        ALLOCATE(DOBUFF1(NOBSV))
        ALLOCATE(DOBUFF2(NOBSV))

        ALLOCATE(SPECTOTF(NOBSV*NFREQ))
        DO I=1,NOBSV*NFREQ
          SPECTOTF(I)=0.0D0
        ENDDO

        IF (ISTOKES.NE.0) THEN
          ALLOCATE(STOKESF(4,NOBSV*NFREQ))
          DO I=1,NOBSV*NFREQ
            STOKESF(1,I)=0.0d0
            STOKESF(2,I)=0.0d0
            STOKESF(3,I)=0.0d0
            STOKESF(4,I)=0.0d0
          ENDDO
        ENDIF

        ALLOCATE(WFLUXIF(NSOURCE))
        DO I=1,NSOURCE
          WFLUXIF(I)=0.0d0
        ENDDO

        ALLOCATE(SPECTOTIF(NOBSV))
        DO I=1,NOBSV
          SPECTOTIF(I)=0.0d0
        ENDDO

        ALLOCATE(WFLUXTF(NFREQ))
        DO I=1,NFREQ
          WFLUXTF(I)=0.0D0
        ENDDO

        IF (ISTOKES.NE.0) THEN
          ALLOCATE(WSTOKESF(4,NFREQ))
          ALLOCATE(STOKECF(4,NFREQ))
          DO I=1,NFREQ
            WSTOKESF(1,I)=0.0d0
            STOKECF(1,I)=0.0d0
            WSTOKESF(2,I)=0.0d0
            STOKECF(2,I)=0.0d0
            WSTOKESF(3,I)=0.0d0
            STOKECF(3,I)=0.0d0
            WSTOKESF(4,I)=0.0d0
            STOKECF(4,I)=0.0d0
          ENDDO
        ENDIF  !ISTOKES

        IF (IEFOLD.NE.0) THEN

          IF (ISTOKES.NE.0) THEN
            ALLOCATE(WSTOKESEF(4,NFREQ))
            ALLOCATE(STOKECEF(4,NFREQ))
            DO I=1,NFREQ
              WSTOKESEF(1,I)=0.0d0
              STOKECEF(1,I)=0.0d0
              WSTOKESEF(2,I)=0.0d0
              STOKECEF(2,I)=0.0d0
              WSTOKESEF(3,I)=0.0d0
              STOKECEF(3,I)=0.0d0
              WSTOKESEF(4,I)=0.0d0
              STOKECEF(4,I)=0.0d0
            ENDDO
          ENDIF   !ISTOKES

        ENDIF  !IEFOLD
      ENDIF !IFOLD

      if (ipin.ne.3) then
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'      selected observation point:'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'      '
     &    ,SNGL(OBSV(1,ICBRILL)),SNGL(OBSV(2,ICBRILL)),SNGL(OBSV(3,ICBRILL))
        WRITE(LUNGFO,*)
      endif

      CALL CHECKOB

C--- LOOP OVER ALL SOURCES, EVALUATE INTEGRALS

      IF (IAMPSKIP.NE.0) THEN
        ALLOCATE(AFREQ(6,NOBSV*NFREQ))
        AFREQ=(0.0D0,0.0D0)
        IF (MPINR.GT.0) THEN
          ALLOCATE(AFREQRPHI(6,NOBSVRPHI*NFREQ))
          afreqrphi=(0.0d0,0.0d0)
        ENDIF
        ALLOCATE(EXPOM2P0(2,NFREQ))
      ENDIF !(IAMPSKIP.NE.0)

      IF (NLPOI.EQ.0) nlpoi=(xstop-xstart)*myinum+1

      IF (
     &    ISPECANA.EQ.0
     &    .AND.
     &    IDESYNC.EQ.0
     &    .AND.
     &    ISPECDIP.EQ.0
     &    .AND.
     &    (IRFILSP0.EQ.0.OR.IRFILSTO.EQ.0.AND.ISTOKES.NE.0)
     &    .AND.
     &    IAMPSKIP.EQ.0
     &    ) THEN

C DEFAULT FOR NLPOI

        IF (NLPOI.EQ.-9999) CALL SETNLPOI

C STORE VALUES, REINITIALIZE SOURCEE

        NDWSOU=MAX(NLPOI,NCO)+NBADDP
        NDARGU=NDWSOU
        NLPOIO=NLPOI
        NBUFF=1

        IF (ISPECMODE.EQ.3.OR.ISPECMODE.EQ.4) THEN
          ALLOCATE(REARGUM(11,NDWSOU))
        ENDIF

        IF (ISPECMODE.EQ.1.OR.ISPECMODE.EQ.3.OR.ISPECMODE.EQ.4) THEN
          ALLOCATE(WSOU(3,5,NDWSOU))
        ENDIF

C BEGIN OF RAW SPECTRUM CALCULATION

        IF (NSOURCE.GE.1.and.icluster.lt.0) THEN
          CALL date_and_time(dtday,dttime,dtzone,idatetime)
          WRITE(6,*)
          WRITE(6,*)'     Starting spectrum calculations '
     &      ,dttime(1:2),':',dttime(3:4),':',dttime(5:6)
          WRITE(6,*)
        ENDIF

        DO ISOUR=1,NSOURCE
CERR101292      DO JC=1,3

          DO JC=1,4
            DO IC=1,3
              SOURCEAO(IC,JC,ISOUR)=SOURCEA(IC,JC,ISOUR)
              SOURCEEO(IC,JC,ISOUR)=SOURCEE(IC,JC,ISOUR)
            ENDDO
          ENDDO

          DO JC=1,1
            DO IC=1,3
              SOURCEE(IC,JC,ISOUR)=SOURCEA(IC,JC,ISOUR)+
     &          (SOURCEEO(IC,JC,ISOUR)-SOURCEAO(IC,JC,ISOUR))/NBUFF
            ENDDO
          ENDDO

        ENDDO   !ISOUR

        ISOURO=0

        IF (IAMPSKIP.EQ.0) THEN
          ALLOCATE(AFREQ(6,NOBSV*NFREQ))
          AFREQ=(0.0D0,0.0D0)
          ALLOCATE(EXPOM2P0(2,NFREQ))
          IF (MPINR.GT.0) THEN
            ALLOCATE(AFREQRPHI(6,NOBSVRPHI*NFREQ))
            afreqrphi=(0.0d0,0.0d0)
          ENDIF
        ENDIF !(IAMPSKIP.EQ.0)
        ALLOCATE(TBUFF(NOBSV))
        IF (ISPECMODE.EQ.3.OR.ISPECMODE.EQ.4) THEN
          ALLOCATE(NARGUM(NOBSV,NSOURCE))
        ELSE IF (ISPECMODE.EQ.1.OR.ISPECMODE.EQ.2) THEN
          ALLOCATE(DARGEXPO(6,NOBSV))
        ENDIF

        IF (IAMPLI.LT.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'      repetition of amplitude activated:'
          WRITE(LUNGFO,*)
     &      '      A -> A * (1 + exp(i*phi) + exp(i*2*phi)...'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'      IAMPLI, AMPSHIFT(1):',IAMPLI,AMPSHIFT(1)
          WRITE(LUNGFO,*)
     &      '      Total phase-advance [nm] and corresponding photon energy [eV]:'
          WRITE(LUNGFO,*)
     &      '      ',(AMPSHIFT(1)/2.0D0/DMYGAMMAP**2+HTRA2I)*1.0D9
     &      ,CLIGHT1*HPLANCK1/ECHARGE1/(AMPSHIFT(1)/2.0D0/DMYGAMMAP**2+HTRA2I)
c          WRITE(LUNGFO,*)
c     &      '      MYINUM has to be tuned,'
c          WRITE(LUNGFO,*)
c     &      '      since phase advance is calculated form trajectory.'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'      repetition of amplitude activated:'
          WRITE(6,*)
     &      '      A -> A * (1 + exp(i*phi) + exp(i*2*phi)...'
          WRITE(6,*)
          WRITE(6,*)'      IAMPLI, AMPSHIFT(1):',IAMPLI,AMPSHIFT(1)
          WRITE(6,*)
     &      '      Total phase-advance [nm] and corresponding photon energy [eV]:'
          WRITE(6,*)
     &      '      ',(AMPSHIFT(1)/2.0D0/DMYGAMMAP**2+HTRA2I)*1.0D9
     &      ,CLIGHT1*HPLANCK1/ECHARGE1/(AMPSHIFT(1)/2.0D0/DMYGAMMAP**2+HTRA2I)
          WRITE(6,*)
c          WRITE(6,*)
c     &      '*****>>>>      MYINUM has to be tuned,'
c          WRITE(6,*)
c     &      '      since phase advance is calculated from trajectory.'
c          WRITE(6,*)
c          CALL UTIL_WAIT_1
          IF (AMPRAN.NE.0.D0) THEN
            IF (ISOUR.EQ.1) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'      phase errors for repetition activated:'
              WRITE(LUNGFO,*)
     &          '      A -> A * (1 + exp(i*phi*xran1) + exp(i*2*phi*xran2)...'
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'      IAMPSEED: ',IAMPSEED
              WRITE(LUNGFO,*)
            ENDIF !ISOUR
            ALLOCATE(XRANA(-IAMPLI))
            IF (IAMPSEED.NE.0) CALL RMARIN(IAMPSEED,NTOTIN,NTOT2IN)
            CALL RNORML(XRANA,-IAMPLI,rr)
            RMS=0.0d0
            DO IREP=1,-IAMPLI
              XRANA(IREP)=AMPRAN*XRANA(IREP)
              RMS=RMS+XRANA(IREP)**2
            ENDDO
            RMS=SQRT(RMS/(-IAMPLI))
            WRITE(LUNGFO,*)
     &        '      rel. rms phase AMPRAN (input): ',SNGL(AMPRAN)
            WRITE(LUNGFO,*)
     &        '      rel. rms phase error 1. source (from generated errors): '
     &        ,SNGL(RMS)
          ENDIF   !(AMPRAN.NE.0.D0)
        ENDIF !IAMPLI

        DO ISOUR=1,NSOURCE

          IF (ISPECMODE.EQ.1.OR.ISPECMODE.EQ.2) THEN
            if (icluster.gt.0) goto 1357
+self,if=wsou.
            IF (ISPECMODE.EQ.2) THEN
              call sourcesteps(isour,ndwsou)
              ALLOCATE(WSOU(3,5,NDWSOU))
              nsadd=1
            endif
+self,if=-wsou.
            print*,'******************************************'
            print*,'CMZ-Selection wsou not active!!'
            print*,'******************************************'
+self. if=wsou.
            if (iundulator.ne.2.and.kampli.eq.0) then
+self,if=omp.
              if (iomp.eq.0.or.(ipin.eq.0.and.mthreads.eq.0)) then
+self.
                CALL SOUINTALL(ISOUR)
+self,if=omp.
              else
                CALL SOUINTALL_omp(ISOUR)
              endif
+self.
            endif
+self,if=wsou.
            IF (ISPECMODE.EQ.2) THEN
              deALLOCATE(WSOU)
            endif
+self. if=wsou.
            GOTO 1357
          ENDIF !ISPECMODE

          IF (ISOUR.EQ.2) THEN
            WRITE(6,*)' '
            WRITE(6,*)'     sources done and time:'
            WRITE(6,*)' '
          ENDIF !NSOURCE

          DO IOBSV=1,NOBSV
            TBUFF(IOBSV)=0.0
          ENDDO   !IOBSV

          MSADD=0
          DO IBUFF=1,NBUFF

            IF (MSADD.EQ.1) THEN
              IF (AMPRAN.NE.0.D0.AND.IAMPLI.LT.0) THEN
                DEALLOCATE(XRANA)
              ENDIF   !(AMPRAN.NE.0.D0)
              GOTO 1357 !EXIT IBUFF LOOP
            ENDIF

            IF (IBUFF.EQ.NBUFF.OR.MSADD.EQ.-1) THEN
              NSADD=1
              MSADD=1
            ELSE
              NSADD=0
            ENDIF

            IF (ISPECMODE.EQ.3) THEN
              CALL TRACKS(ISOUR)   !TRACKING OF SOURCE
            ELSE IF (ISPECMODE.EQ.4) THEN
              CALL TRACKSOLD(ISOUR)   !TRACKING OF SOURCE
            ELSE
              PRINT*, '*** ERROR IN SPECTRUM: BAD ISPECMODE: ',ISPECMODE
              STOP '*** PROGRAMM WAVE ABORTED ***'
            ENDIF

            CALL SOUINT(ISOUR,IBUFF)   !INTEGRATION

            DO JC=1,1
              DO IC=1,3
C SOURCEA IS RECALCULATED IN SR TRACKS
                SOURCEE(IC,JC,ISOUR)=SOURCEA(IC,JC,ISOUR)+
     &            (SOURCEEO(IC,JC,ISOUR)-SOURCEAO(IC,JC,ISOUR))/NBUFF
              ENDDO
            ENDDO

            IF (SOURCEE(1,1,ISOUR).GT.SOURCEEO(1,1,ISOUR)) THEN

              DO JC=1,1
                DO IC=1,3
                  SOURCEE(IC,JC,ISOUR)=SOURCEEO(IC,JC,ISOUR)
                ENDDO
              ENDDO

              IF (MSADD.EQ.0) MSADD=-1

            ENDIF !(SOURCEE(1,1,ISOUR).GT.SOURCEEO(1,1,ISOUR))

            IF (MSADD.NE.1
     &          .AND.SOURCEA(1,1,ISOUR).GE.SOURCEE(1,1,ISOUR)) THEN
              WRITE(LUNGFO,*)'*** ERROR IN SPECTRUM:'
              WRITE(LUNGFO,*)'SOMETHING WRONG WITH SOURCE BUFFER'
              WRITE(LUNGFO,*)
     &          'CHANGE INTEGRATION BUFFER OR CHECK SOURCE CODE'
              WRITE(LUNGFO,*)
     &          'IBUFF,NBUFF,SOURCEA(1,1,ISOUR),SOURCEE(1,1,ISOUR)'
              WRITE(LUNGFO,*)IBUFF,NBUFF
              WRITE(LUNGFO,*)SOURCEA(1,1,ISOUR),SOURCEE(1,1,ISOUR)
              WRITE(6,*)'*** ERROR IN SPECTRUM:'
              WRITE(6,*)'SOMETHING WRONG WITH SOURCE BUFFER'
              WRITE(6,*)
     &          'CHANGE INTEGRATION BUFFER OR CHECK SOURCE CODE'
              WRITE(6,*)
     &          'IBUFF,NBUFF,SOURCEA(1,1,ISOUR),SOURCEE(1,1,ISOUR)'
              WRITE(6,*)IBUFF,NBUFF
              WRITE(6,*)SOURCEA(1,1,ISOUR),SOURCEE(1,1,ISOUR)
              STOP
            ENDIF

            ISOURO=ISOUR

          ENDDO   !IBUFF

1357    CONTINUE

        if (kampli.ne.0) then

          if (ibunch.eq.0) then
            nbunch=mbuncho
            neinbunch=meinbuncho
            ibunch=ibuncho
            ihbunch=ihbuncho
          endif

          if (ipin.eq.0) then
            call pinin ! to get pincen etc.
            nobsv=1
            nobsvz=1
            nobsvy=1
            icbrill=1
            obsv(:,1)=pincen(:)
          endif

          call amprep_omp

          pow_u=pow_u*1.0d6
          stokes_u=stokes_u*1.0d6
          if(ihbunch.ne.0) then
            fbunch_u(4:14,:)=fbunch_u(4:14,:)/1000.0d0
            fbunch_u(17:19,:)=fbunch_u(17:19,:)/1000.0d0
            fbunch_u(22:26,:)=fbunch_u(22:26,:)*1.0d3
            fbunch_u(30:41,:)=fbunch_u(30:41,:)*1.0d3
          endif

          arad_u=arad_u*1000.0d0

          specpow=pow_u
          spec(:)=stokes_u(1,:)
          stokes=stokes_u

          do iobsv=1,nobsv
            do ifr=1,nfreq
              iobfr=iobsv+nobsv*(ifr-1)
              reaima(1:3,1,iobfr)=dreal(arad_u(1:3,iobfr))
              reaima(1:3,2,iobfr)=dimag(arad_u(1:3,iobfr))
              reaima(6:8,1,iobfr)=dreal(arad_u(4:6,iobfr))
              reaima(6:8,2,iobfr)=dimag(arad_u(4:6,iobfr))
            enddo
          enddo

          if (ibunch.ne.0) then
            if (ihbunch.gt.0) then
              do i=1,nbunch*neinbunch*nfreq
                if (fbunch_u(21,i).ne.0.0d0) then
                  call hfm(nidbunch,fbunch_u(:,i))
                endif
              enddo
            else if (ihbunch.lt.0) then
              do i=1,nbunch*neinbunch*nfreq*nobsv
                if (fbunch_u(21,i).ne.0.0d0) then
                  call hfm(nidbunch,fbunch_u(:,i))
                endif
              enddo
            endif
          endif
        endif

        if (icluster.ne.0) then
          call wpamp
        endif

        IF (ISOUR.EQ.1.and.nsource.gt.1) THEN
          WRITE(6,*)' '
          WRITE(6,*)' '
          WRITE(6,*)' sources treated so far:'
          WRITE(6,*)' '
        ENDIF

c        CALL APHASE(ISOUR)

        IF (nsource.gt.1) THEN
          CALL date_and_time(dtday,dttime,dtzone,idatetime)

          WRITE(6,2000)ISOUR,NSOURCE,dttime(1:2),dttime(3:4),dttime(5:6)
2000      FORMAT(10X,I4,' of',I4,2X,A,':',A,':',A)
        ENDIF


      ENDDO !LOOP OVER SOURCES

      if (abs(ifold).eq.1) CALL AMPFOLD

C     CALL LIB$SHOW_TIMER

C RESTORE OLD VALUES

      NLPOI=NLPOIO

      IF(ISPECDIP.EQ.0.and.ipin.eq.0) THEN
        if (iundulator.eq.0) then
          CALL SPECDIPA  ! To calculate schwingercen for powgraz
        else
          DO ISOUR=1,NSOURCE
            do jc=1,nobsv
              DO IC=1,3
                schwingercen(IC,JC,ISOUR)=(SOURCEAO(IC,1,ISOUR)+
     &            SOURCEEO(IC,1,ISOUR))/2.0d0
              enddo
            enddo
          enddo
        endif
      ENDIF

      DO ISOUR=1,NSOURCE
CERR101292      DO JC=1,3
        DO JC=1,4
          DO IC=1,3
            SOURCEA(IC,JC,ISOUR)=SOURCEAO(IC,JC,ISOUR)
            SOURCEE(IC,JC,ISOUR)=SOURCEEO(IC,JC,ISOUR)
          ENDDO
        ENDDO
        IPOISOU(ISOUR)=IZTOT(ISOUR)
      ENDDO   !ISOUR

      ELSE IF(ISPECANA.NE.0)   THEN !ISPECANA

        CALL SPECANA      !USER SUPPLIED SPECTRUM
C                  !(E.G. FOR TESTING)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** MESSAGE SR SPECTRUM ***'
        WRITE(LUNGFO,*)
     &    'FLUX OVERWRITTEN BY SR SPECANA (FLAG ISPECANA)'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)

      ELSE IF(IDESYNC.NE.0)   THEN !ISPECANA

        CALL SYNC_SPEC      !SPECTRUM FROM PROGRAM DESYNC

      ELSE IF(ISPECDIP.GT.0)   THEN !ISPECANA

        CALL SPECDIP  !DIPOL SPECTRUM ACCORDING TO BESSEL FUNCTIONS

      ELSE IF(ISPECDIP.LT.0)   THEN !ISPECANA

        CALL SPECDIPA  !DIPOL SPECTRUM ACCORDING TO BESSEL FUNCTIONS FOR
                       !GIVEN SOURCES
      ELSE

        IF (IRFILSP0.NE.0) CALL RFILSP0
        IF (IRFILSTO.NE.0) CALL RFILSTO

      ENDIF !ISPECANA

C }CHANGE FROM CYLINDRICAL TO CARTHESIAN GRID

      IF (IAMPLI.gt.0.or.iamprep.lt.0) CALL ADDAMPLI
      IF (IAMPLI.LT.0) THEN
        FACAMPLI=-IAMPLI
      ELSE
        FACAMPLI=1.D0
      ENDIF

C END OF RAW SPECTRUM CALCULATION

      IF (IABEND.EQ.6) then
        iroottrees=0
        RETURN
      endif

C--- TAKE FILTER INTO ACCOUNT

      IF (IFILTER.GT.0) THEN
        IF (IFILMUL.EQ.0) THEN
          CALL FILTER !ARRAY SPEC IS OVERWRITTEN
        ELSE
          ABSMUTOT=0.0D0
          OPEN(UNIT=LUNAM,FILE=FILEAM,STATUS='OLD')
          DO I=1,IFILMUL
            READ(LUNAM,*)ABSTHI,FILEABS
            CALL FILTER !ARRAY SPEC IS OVERWRITTEN
            ABSMUTOT=ABSMUTOT+ABSMU
          ENDDO !IFILMUL
          CLOSE(LUNAM)
        ENDIF !IFILTER

      ENDIF !IFILTER

C--- TAKE PHOTO YIELD INTO ACCOUNT

      IF (IEFFI.NE.0) THEN
        CALL EFFI !ARRAY SPEC IS OVERWRITTEN
      ENDIF !IEFFI

C--- LOOP OVER ALL SOURCES, ADD UP CONTRIBUTIONS OF EVALUATED INTEGRALS

      if (iomp.eq.0) CALL SOUADD

C--- FLUX TRHOUGH PINHOLE

      IF(IPINo.GT.0) THEN

        print*
        call zeit(6)
        print*,"     Start integration over pinhole"

+self,if=omp.
        if (iomp.eq.0) then
+self.

          DO IFREQ=1,NFREQ

            IF(IPIN.NE.2.and.ipin.ne.3) THEN !SPECTOT IN SOUADD CALCULATED

              DO IY=1,NOBSVY
                DO IZ=1,NOBSVZ
                  IOBSV=(IY-1)*NOBSVZ+IZ
                  SPECTOT(IOBSV+NOBSV*(IFREQ-1))=0.0D0
                ENDDO   !IZ
              ENDDO   !IY

            ENDIF !IPIN.NE.2

            WFLUXT(IFREQ)=0.0

            DO ISOUR=1,NSOURCE

              IF(IPIN.NE.2.and.ipin.ne.3) THEN

C--- SPLINE INTERPOLATION INSIDE PINHOLE

                IF (IUSEM.EQ.0) THEN
                  IF (IPINCIRC.EQ.0.OR.IPINCIRC*IRPHI.NE.0)
     &              CALL PSPLINE(ISOUR,IFREQ)
                ENDIF

C--- INTEGRATION OF FLUX IN PINHOLE (BLENDE)

                IF (IUSEM.EQ.0) THEN

c                if (isour.eq.1.and.ifreq.eq.1) then
c                  caLL Zeit(6)
c                  print*,"     Starting integration over pinhole"
c                endif

                  CALL BLENDE(ISOUR,IFREQ)
                  IF(ISOUR.EQ.NSOURCE.AND.ISTOKES.NE.0) then
                    CALL BLENSTO(IFREQ)
                  endif

                ELSE

                  ICONV=0
                  IF (IPINCIRC.EQ.0) THEN
                    IFLUSS=1
                  ELSE  !IPINCIRC
                    IFLUSS=2
                  ENDIF !IPINCIRC
                  CALL USMCON2

                ENDIF

                DO IY=1,NOBSVY
                  DO IZ=1,NOBSVZ
                    IOBSV=(IY-1)*NOBSVZ+IZ
                    IOBFR=IOBSV+NOBSV*(IFREQ-1)
                    SPECTOT(IOBFR)=SPECTOT(IOBFR)+
     &                SPEC(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))
                  ENDDO   !IZ
                ENDDO   !IY

              else if (ipin.eq.3) then

                CALL BLENDE(ISOUR,IFREQ)
                IF(ISOUR.EQ.NSOURCE.AND.ISTOKES.NE.0)
     &            CALL BLENSTO(IFREQ)
              ENDIF !(IPIN.GT.0)

              WFLUXT(IFREQ)=WFLUXT(IFREQ)+WFLUX(ISOUR+NSOURCE*(IFREQ-1))

            ENDDO !NSOURCE
          ENDDO !IFREQ

+self,if=omp.
        else !if (iomp.eq.0) then

c          if (ipincirc.eq.0) then
            call blendfreq_omp
c          else
c            call blendcircfreq_omp
c          endif

          if (istokes.ne.0) then
            call blenstofreq_omp
          endif

        endif !iomp
+self.

C--- FOLD INTENSITY DISTRIBUTIONS

        IF (IFOLD.NE.0.AND.IFOLD.NE.2) THEN
          print*,""
          call zeit(6)
          print*,"     Starting folding procedure"
          IF (IUSEM.EQ.0) THEN
            ALLOCATE(COFOLD(4,4,NOBSV))
c            caLL Zeit(6)
c            print*,"     Starting folding procedure"
            IF (IFOLD.EQ.-2) ALLOCATE(SPCOEFU(3,NOBSV))
            IF (ABS(IFOLD).EQ.1) then
+self,if=omp.
              if (iomp.eq.0) then
+self.
                CALL WFOLD
                IF (ISTOKES.NE.0) CALL WFOLDSTO
+self,if=omp.
              else
                call wfold_omp
                IF (ISTOKES.NE.0) then
                  CALL WFOLDSTO_omp
                endif
              endif
+self.,if=omp.
            endif
            call powfold
          ELSE !IUSEM
            ICONV=0
            IFLUSS=0
            IF (ISPECANAF.NE.0) THEN
              CALL SPECANAF
            ENDIF
            CALL USMCON2
          ENDIF !IUSEM
        ENDIF !IFOLD

      print*
      call zeit(6)
      print*,"     Finished integration over pinhole"

      ENDIF !IPIN

C--- INTEGRATE SPECTRUM OVER ALL FREQUENCIES

      IF (ISPECINT.NE.0) THEN
        CALL SPECINT
        IF (IFOLD.NE.0) CALL SPECINTF
        IF (IPIN.NE.0) THEN
          CALL CRIFREQ
        ELSE
          CALL CRIFREQS(1)
        ENDIF
      ENDIF

C--- CONVERT FREQUENCES FROM ELECTRONVOLT TO NANOMETER

C260194  IF (IUNIT.EQ.1) CALL CONVUN

      IF (ISTOKES.NE.0) THEN
        ICEN=ICBRILL
        DO IFREQ=1,NFREQ
          DO IC=1,4
            STOKEC(IC,IFREQ)=STOKES(IC,ICEN+NOBSV*(IFREQ-1))
          ENDDO !IC
        ENDDO !NFREQ
      ENDIF !ISTOKES

      IF (ISTOKES.NE.0.AND.IFOLD.NE.0) THEN
        ICEN=ICBRILL
        DO IFREQ=1,NFREQ
          DO IC=1,4
            STOKECF(IC,IFREQ)=STOKESF(IC,ICEN+NOBSV*(IFREQ-1))
          ENDDO !NOBSV
        ENDDO !NFREQ
      ENDIF !ISTOKES

C--- WRITE RESULTS TO FILE

c      print*
c      call zeit(6)
c      print*,"     Writing results to files"

      IF (ISPECDIP.EQ.0) THEN

        WRITE (LUNGFO,*)
        WRITE (LUNGFO,*)
     &'     Source number, mean mag. field (sign from By), abs. mean and rel. rms'
        WRITE (LUNGFO,*)
     &'     for sources, and critical photon energy [eV] or wavelength [nm]'
        WRITE (LUNGFO,*)
     &    '     (with respect to abs. mean):'
        WRITE (LUNGFO,*)

        DO ISOUR=1,NSOURCE
          WRITE (LUNGFO,*)ISOUR
     &      ,SNGL(ECSOUR(4,ISOUR))
     &      ,SNGL(ECSOUR(1,ISOUR))
     &      ,SNGL(ECSOUR(3,ISOUR))
     &      ,SNGL(ECSOUR(2,ISOUR))
        ENDDO !ISOUR

        WRITE (LUNGFO,*)
        WRITE (LUNGFO,*)'     Photon energy cut-off (SPECCUT):',SNGL(SPECCUT)
        WRITE (LUNGFO,*)
        WRITE (LUNGFO,*)
     &    '     Max. field and photon energy cuts for source points:'
        WRITE (LUNGFO,*)
        DO ISOUR=1,NSOURCE
          WRITE (LUNGFO,*)ISOUR
     &      ,SNGL(ECMAX(ISOUR))
     &      ,SNGL(SPECCUT*ecdipev1*DMYENERGY**2*ECMAX(ISOUR))
        ENDDO !ISOUR

      ENDIF !ISPECDIP

      IF(IPIN*ISPECINT.NE.0) THEN

        WRITE (LUNGFO,*)
        WRITE (LUNGFO,*)
     &    '     Critical photon energy or wavelength of calculated flux through'

        IF (IFOLD.NE.0) THEN

          IF (IUNIT.EQ.0)
     &      WRITE (LUNGFO,*)'     pinhole (raw and folded):'
     &      ,SNGL(FREQC),SNGL(FREQCF)
          IF (IUNIT.NE.0)
     &      WRITE (LUNGFO,*)'     pinhole (raw and folded):'
     &      ,SNGL(WELLENC),SNGL(WELLENCF)

        ELSE  !IFOLD

          IF (IUNIT.EQ.0)
     &      WRITE (LUNGFO,*)'     pinhole:',SNGL(FREQC)
          IF (IUNIT.NE.0)
     &      WRITE (LUNGFO,*)'     pinhole:',SNGL(WELLENC)
        ENDIF !IFOLD

        WRITE (LUNGFO,*)

        WRITE (LUNGFO,*)

      ENDIF !IPIN*ISPECINT

      IF(IWFILSP0.NE.0) THEN

        OPEN(UNIT=LUNSP0,FILE=FILESP0)

        WRITE(LUNSP0,*)ICODE,' ',CODE
        WRITE(LUNSP0,*)
        WRITE(LUNSP0,*)NSOURCE,NOBSV,NFREQ,IFREQ2P
        WRITE(LUNSP0,*)NOBSVZ,NOBSVY,MOBSVZ,MOBSVY
        WRITE(LUNSP0,*)MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY
        WRITE(LUNSP0,*)
        WRITE(LUNSP0,*)PINW,PINH,PINR
        WRITE(LUNSP0,*)OBSVDZ,OBSVDY
        WRITE(LUNSP0,*)

        WRITE(LUNSP0,*)(OBSVZ(IO),IO=1,NOBSVZ)
        WRITE(LUNSP0,*)
        WRITE(LUNSP0,*)(OBSVY(IO),IO=1,NOBSVY)
        WRITE(LUNSP0,*)

        DO IO=1,NOBSV
          WRITE(LUNSP0,*)(OBSV(IX,IO),IX=1,3)
          DO IFR=1,NFREQ
            IF (IUNIT.EQ.0) THEN !260194
              WRITE(LUNSP0,*)FREQ(IFR),
     &          (SPEC(IS+NSOURCE*(IO-1+NOBSV*(IFR-1))),IS=1,NSOURCE)
     &          ,SPECTOT(IO+NOBSV*(IFR-1))
            ELSE !IUNIT
              WRITE(LUNSP0,*)WELLEN(IFR),
     &          (SPEC(IS+NSOURCE*(IO-1+NOBSV*(IFR-1))),IS=1,NSOURCE)
     &          ,SPECTOT(IO+NOBSV*(IFR-1))
            ENDIF !IUNIT
          ENDDO !NFREQ
        ENDDO !NOBSV

        CLOSE(LUNSP0)

      ENDIF !IWFILSP0

      IF(IPHASEANA.NE.0) THEN
        CALL PHASEANA
      ENDIF !(IPHASEANA.NE.0)

      IF(IPHASE.NE.0.and.icluster.ge.0) THEN
c        if (mthreads.eq.0) then
c          CALL PHASE
c        else
          CALL PHASE_omp
c        endif
      ENDIF !(IPHASE.NE.0)

      IF(IWFILRAY.NE.0) THEN

        OPEN(UNIT=LUNRAY,FILE=FILERAY,STATUS='NEW')

        WRITE(LUNRAY,*)MOBSVZ,MOBSVY,ICODE,SNGL(FREQ(1)),' WAVE'

        DRAY=PINCEN(1)
        DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
          YRAY=OBSVY(IY)
          THERAY=ATAN(YRAY/DRAY)*10000. !*10000 mm
          DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
            IO=(IY-1)*NOBSVZ+IZ
            ZRAY=OBSVZ(IZ)
            PHIRAY=ATAN(ZRAY/DRAY)*10000.

            RAY=STOKES(1,IO)
     &        /DMYCUR*0.1
     &        /BANWID*0.001
     &        *OBSVDZ*OBSVDY
            RAY1=STOKES(2,IO)
     &        /DMYCUR*0.1
     &        /BANWID*0.001
     &        *OBSVDZ*OBSVDY
            RAY2=STOKES(3,IO)
     &        /DMYCUR*0.1
     &        /BANWID*0.001
     &        *OBSVDZ*OBSVDY
            RAY3=STOKES(4,IO)
     &        /DMYCUR*0.1
     &        /BANWID*0.001
     &        *OBSVDZ*OBSVDY

            IF (RAY.NE.0.0) THEN
              RAY1N=RAY1/RAY
              RAY2N=RAY2/RAY
              RAY3N=RAY3/RAY
            ELSE
              RAY1N=0.0
              RAY2N=0.0
              RAY3N=0.0
            ENDIF   !RAY

C     RAY/PHIRAY/THERAY IS NUMBER OF PHOTONS PER mm**2 PER sec PER 0.001BW
C     PER 100mA IN 10m DISTANCE !?; COORDINATES VALUES IN mm ON FILE

C ABSPRACHE MIT FRANZ            WRITE(LUNRAY,7788) PHIRAY,THERAY,RAY,-RAY1N,RAY2N,RAY3N
      WRITE(LUNRAY,7788) PHIRAY,THERAY,RAY,RAY1N,RAY2N,RAY3N
7788        FORMAT(6(1PE12.4))

          ENDDO !IZ
        ENDDO !IY

        CLOSE(LUNRAY)

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     Data-file written for program RAY'
        WRITE(LUNGFO,*)'     File: ',FILERAY
        WRITE(LUNGFO,*)'     (Device center is assumed at (0,0,0)'
        IF (IUNIT.EQ.0) THEN !260194
          WRITE(LUNGFO,*)'     Photon energy:',SNGL(FREQ(1))
        ELSE
          WRITE(LUNGFO,*)'     Photon energy:',SNGL(WELLEN(1))
        ENDIF
        WRITE(LUNGFO,*)

        WRITE(6,*)
        WRITE(6,*)'     Data-file written for program RAY'
        WRITE(6,*)'     File: ',FILERAY
        WRITE(6,*)'     (Device center is assumed at (0,0,0)'
        IF (IUNIT.EQ.0) THEN !260194
          WRITE(6,*)'     Photon energy:',SNGL(FREQ(1))
        ELSE
          WRITE(6,*)'     Photon energy:',SNGL(WELLEN(1))
        ENDIF
        WRITE(6,*)

      ENDIF !IWFILRAY

      IF(IWFILSTO.NE.0.AND.ISTOKES.NE.0) THEN

        OPEN(UNIT=LUNSTO,FILE=FILESTO)

        WRITE(LUNSTO,*)ICODE,' ',CODE
        WRITE(LUNSTO,*)
        WRITE(LUNSTO,*)NSOURCE,NOBSV,NFREQ,IFREQ2P
        WRITE(LUNSTO,*)NOBSVZ,NOBSVY,MOBSVZ,MOBSVY
        WRITE(LUNSTO,*)MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY
        WRITE(LUNSTO,*)
        WRITE(LUNSTO,*)PINW,PINH,PINR
        WRITE(LUNSTO,*)OBSVDZ,OBSVDY
        WRITE(LUNSTO,*)

        WRITE(LUNSTO,*)(OBSVZ(IO),IO=1,NOBSVZ)
        WRITE(LUNSTO,*)
        WRITE(LUNSTO,*)(OBSVY(IO),IO=1,NOBSVY)
        WRITE(LUNSTO,*)

        DO IO=1,NOBSV
          WRITE(LUNSTO,*)(OBSV(IX,IO),IX=1,3)
          DO IFR=1,NFREQ
            IF (IUNIT.EQ.0) THEN !260194
              IOBFR=IO+NOBSV*(IFR-1)
              WRITE(LUNSTO,*)FREQ(IFR),(STOKES(IS,IOBFR),IS=1,4)
            ELSE
              WRITE(LUNSTO,*)WELLEN(IFR),(STOKES(IS,IOBFR),IS=1,4)
            ENDIF
          ENDDO !NFREQ
        ENDDO !NOBSV

        CLOSE(LUNSTO)

      ENDIF !IWFILSTO

      IF(IFOLD.NE.0 .AND. IWFILSPF.NE.0) THEN

        OPEN(UNIT=LUNSPF,FILE=FILESPF)

        WRITE(LUNSPF,*)ICODE,' ',CODE
        WRITE(LUNSPF,*)
        WRITE(LUNSPF,*)NSOURCE,NOBSV,NFREQ
        WRITE(LUNSPF,*)NOBSVZ,NOBSVY,MOBSVZ,MOBSVY
        WRITE(LUNSPF,*)MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY
        WRITE(LUNSPF,*)
        WRITE(LUNSPF,*)PINW,PINH,PINR
        WRITE(LUNSPF,*)OBSVDZ,OBSVDY
        WRITE(LUNSPF,*)

        WRITE(LUNSPF,*)(OBSVZ(IO),IO=1,NOBSVZ)
        WRITE(LUNSPF,*)
        WRITE(LUNSPF,*)(OBSVY(IO),IO=1,NOBSVY)
        WRITE(LUNSPF,*)

        DO IO=1,NOBSV
          WRITE(LUNSPF,*)(OBSV(IX,IO),IX=1,3)
          DO IFR=1,NFREQ
            IF (IUNIT.EQ.0) WRITE(LUNSPF,*)FREQ(IFR)
     &        ,(SPECF(IS+NSOURCE*(IO-1+NOBSV*(IFR-1))),IS=1,NSOURCE)
     &        ,SPECTOTF(IO+NOBSV*(IFR-1))
            IF (IUNIT.NE.0) WRITE(LUNSPF,*)WELLEN(IFR)
     &        ,(SPECF(IS+NSOURCE*(IO-1+NOBSV*(IFR-1))),IS=1,NSOURCE)
     &        ,SPECTOTF(IO+NOBSV*(IFR-1))
          ENDDO !NFREQ
        ENDDO !NOBSV

        CLOSE(LUNSPF)

      ENDIF !IWFILSPF

      IF(istokes.ne.0.and.IFOLD.NE.0 .AND. IWFLSTOF.NE.0) THEN

        OPEN(UNIT=LUNSTOF,FILE=FILESTOF)

        WRITE(LUNSTOF,*)ICODE,' ',CODE
        WRITE(LUNSTOF,*)
        WRITE(LUNSTOF,*)NSOURCE,NOBSV,NFREQ,IFREQ2P
        WRITE(LUNSTOF,*)NOBSVZ,NOBSVY,MOBSVZ,MOBSVY
        WRITE(LUNSTOF,*)MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY
        WRITE(LUNSTOF,*)
        WRITE(LUNSTOF,*)PINW,PINH,PINR
        WRITE(LUNSTOF,*)OBSVDZ,OBSVDY
        WRITE(LUNSTOF,*)

        WRITE(LUNSTOF,*)(OBSVZ(IO),IO=1,NOBSVZ)
        WRITE(LUNSTOF,*)
        WRITE(LUNSTOF,*)(OBSVY(IO),IO=1,NOBSVY)
        WRITE(LUNSTOF,*)

        DO IO=1,NOBSV
          WRITE(LUNSTOF,*)(OBSV(IX,IO),IX=1,3)
          DO IFR=1,NFREQ
            IF (IUNIT.EQ.0)  !260194
     &        WRITE(LUNSTOF,*)FREQ(IFR),(STOKESF(IS,IO+NOBSV*(IFR-1)),IS=1,4)
            IF (IUNIT.NE.0)
     &        WRITE(LUNSTOF,*)WELLEN(IFR),(STOKESF(IS,IO+NOBSV*(IFR-1)),IS=1,4)
          ENDDO !NFREQ
        ENDDO !NOBSV

        CLOSE(LUNSTOF)

      ENDIF !IWFLSTOF

C--- OUTPUT RESULTS

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Results of spectrum calculations'
      WRITE(LUNGFO,*)'     ================================'
      WRITE(LUNGFO,*)
      IF (IPOLA.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     Photons are polarized parallely to complex vector VPOLA:'
        DO IC=1,3
          WRITE(LUNGFO,*)'     ',CMPLX(VPOLA(IC))
        ENDDO
        WRITE(LUNGFO,*)
      ENDIF !IPOLA

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Reflectivity coefficients (complex):'
      WRITE(LUNGFO,*)
      DO IC=1,3
        WRITE(LUNGFO,*)'     ',CONJG(REFLEC(IC))
      ENDDO
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

      IF (ISPECMODE.EQ.3.OR.ISPECMODE.EQ.4) THEN
        WRITE(LUNGFO,*)
     &    '     Buffer size for integration (NDWSOU):',NDWSOU
        WRITE(LUNGFO,*)
      ENDIF

      IF (ISPECMODE.EQ.3.OR.ISPECMODE.EQ.4) THEN
        WRITE(LUNGFO,*)
     &    '     Provided number of integration steps for each source'
        WRITE(LUNGFO,*)
     &    '     (controlled by NLPOI)'
        WRITE(LUNGFO,*)
     &    '     (not necessarily used)'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)(IPOISOU(IS),IS=1,NSOURCE)
      ENDIF

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Bandwidth:',SNGL(BANWID)
      WRITE(LUNGFO,*)

      IF(IPIN.EQ.0) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)

        WRITE(LUNGFO,*)
     &    '     Photon energy [eV] or wavelength [nm] for all observation'
        WRITE(LUNGFO,*)
     &    '     points, flux per unit area [m**2] for each source,'
        WRITE(LUNGFO,*)
     &    '     total flux density:'
        WRITE(LUNGFO,*)

        WRITE(LUNGFO,*)

        if (iundulator.eq.0) call powgraz

        DO IO=1,NOBSV

          WRITE(LUNGFO,*)'          Observation point (x,y,z) [m]:'
          WRITE(LUNGFO,*)'          ',(SNGL(OBSV(IX,IO)),IX=1,3)

          IF ((ISPECMODE.EQ.3.OR.ISPECMODE.EQ.4).AND.ISPECDIP.EQ.0
     &        .and.ispecana.eq.0) THEN
            WRITE(LUNGFO,*)
     &        '          Number of integration steps for each source:'
            WRITE(LUNGFO,*)
     &        '                 (controlled by NLPOI)'
            WRITE(LUNGFO,*)'          ',(NARGUM(IO,IS),IS=1,NSOURCE)
          ENDIF

          WRITE(LUNGFO,*)
          DO IFR=1,NFREQ
            IF (IUNIT.EQ.0)  !260194
     &        WRITE(LUNGFO,*)'  ',SNGL(FREQ(IFR))
     &        ,(SNGL(SPEC(IS+NSOURCE*(IO-1+NOBSV*(IFR-1)))),IS=1,NSOURCE)
     &        ,SNGL(SPECTOT(IO+NOBSV*(IFR-1)))
            IF (IUNIT.NE.0)  !260194
     &        WRITE(LUNGFO,*)'  ',SNGL(WELLEN(IFR))
     &        ,(SNGL(SPEC(IS+NSOURCE*(IO-1+NOBSV*(IFR-1)))),IS=1,NSOURCE)
     &        ,SNGL(SPECTOT(IO+NOBSV*(IFR-1)))
          ENDDO !IFR


C maximum of spectot{

          IF (NFREQ.GT.1) THEN

            DO IFR=1,NFREQ
              SPECBUFF(IFR)=SPECTOT(IO+NOBSV*(IFR-1))
            ENDDO !IFR

            CALL UTIL_MAX_PARABEL
     &        (NFREQ,FREQ,SPECBUFF,SPECTOTMX(3),SPECTOTMX(4)
     &        ,WSNOBFR1,WSNOBFR2,IFAIL)

            IF (IFAIL.NE.0) THEN
              WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED'
              WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
            ENDIF

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Estimated maximum:'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     ',SNGL(SPECTOTMX(3)),SNGL(SPECTOTMX(4))
            WRITE(LUNGFO,*)

          ENDIF   !NFREQ

C maximum of spectot}

      IF (IFOLD.EQ.2) THEN

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)

          WRITE(LUNGFO,*)
     &      '     flux per unit area [m**2] for each source,'
          WRITE(LUNGFO,*)
     &      '     total flux density with emittance:'
          WRITE(LUNGFO,*)

          WRITE(LUNGFO,*)
          DO IFR=1,NFREQ
            SPECTOTF(IO+NOBSV*(IFR-1))=0.0D0
            DO IS=1,NSOURCE
              SPECTOTF(IO+NOBSV*(IFR-1))=
     &          SPECTOTF(IO+NOBSV*(IFR-1))+
     &          SPECF(IS+NSOURCE*(IO-1+NOBSV*(IFR-1)))
            ENDDO
            IF (IUNIT.EQ.0)  !260194
     &        WRITE(LUNGFO,*)'  ',SNGL(FREQ(IFR))
     &        ,(SNGL(SPECF(IS+NSOURCE*(IO-1+NOBSV*(IFR-1)))),IS=1,NSOURCE)
     &        ,SNGL(SPECTOTF(IO+NOBSV*(IFR-1)))
            IF (IUNIT.NE.0)  !260194
     &        WRITE(LUNGFO,*)'  ',SNGL(WELLEN(IFR))
     &        ,(SNGL(SPECF(IS+NSOURCE*(IO-1+NOBSV*(IFR-1)))),IS=1,NSOURCE)
     &        ,SNGL(SPECTOTF(IO+NOBSV*(IFR-1)))
          ENDDO !IFR

C maximum of spectot{

          IF (NFREQ.GT.1) THEN

            DO IFR=1,NFREQ
              SPECBUFF(IFR)=SPECTOTF(IO+NOBSV*(IFR-1))
            ENDDO !IFR

            CALL UTIL_MAX_PARABEL
     &        (NFREQ,FREQ,SPECBUFF,SPECTOTMX(3),SPECTOTMX(4)
     &        ,WSNOBFR1,WSNOBFR2,IFAIL)

            IF (IFAIL.NE.0) THEN
              WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED'
              WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
            ENDIF

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Estimated maximum:'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     ',SNGL(SPECTOTMX(3)),SNGL(SPECTOTMX(4))
            WRITE(LUNGFO,*)

          ENDIF   !NFREQ

        ENDIF !IFOLD.EQ.2

C maximum of spectot}

        WRITE(LUNGFO,*)' '

        WRITE(LUNGFO,*)' '
        WRITE(LUNGFO,*)
     &    '     Power density at selected point [W/m**2]:'
        WRITE(LUNGFO,*)

        if (nsource.le.5) then

          WRITE(LUNGFO,*)
     &      '     (for all sources,sum, and sum grazing)'
          IF (IAMPLI.GT.0) THEN
            WRITE(LUNGFO,*)
     &        '     (Option IAMPLI not taken into account!!)'
          ENDIF   !IAMPLI

          WRITE(LUNGFO,*)'   '
     &      ,(SNGL(SPECPOW(IS+NSOURCE*(IO-1))),IS=1,NSOURCE)
     &      ,SNGL(SPECPOWT(IO))
     &      ,SNGL(SPECPOWTgraz(IO))
        else

          WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'

          IF (IAMPLI.GT.0) THEN
            WRITE(LUNGFO,*)
     &        '     (Option IAMPLI not taken into account!!)'
          ENDIF   !IAMPLI

          WRITE(LUNGFO,*)'   '
     &      ,(SNGL(SPECPOW(IS+NSOURCE*(IO-1))),IS=1,2)
     &      ,SNGL(SPECPOW(IS+(NSOURCE/2+1)*(IO-1)))
     &      ,(SNGL(SPECPOW(IS+NSOURCE*(IO-1))),IS=NSOURCE-1,NSOURCE)
     &      ,SNGL(SPECPOWT(IO))
     &      ,SNGL(SPECPOWTgraz(IO))
        endif

        WRITE(LUNGFO,*)' '

        if (ifold.ne.0) then
          WRITE(LUNGFO,*)' '
          WRITE(LUNGFO,*)
     &      '     Power density with emittance at selected point [W/m**2]:'
          WRITE(LUNGFO,*)
          if (nsource.le.5) then
            WRITE(LUNGFO,*)
     &        '     (for all sources and sum)'
            IF (IAMPLI.GT.0) THEN
              WRITE(LUNGFO,*)
     &          '     (Option IAMPLI not taken into account!!)'
            ENDIF !IAMPLI

            WRITE(LUNGFO,*)'   '
     &        ,(SNGL(SPECPOWf(IS+NSOURCE*(IO-1))),IS=1,NSOURCE)
     &        ,SNGL(SPECPOWTf(IO))
          else
            WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
            IF (IAMPLI.GT.0) THEN
              WRITE(LUNGFO,*)
     &          '     (Option IAMPLI not taken into account!!)'
            ENDIF !IAMPLI

            WRITE(LUNGFO,*)'   '
     &        ,(SNGL(SPECPOWf(IS+NSOURCE*(IO-1))),IS=1,2)
     &        ,SNGL(SPECPOWf(IS+(NSOURCE/2+1)*(IO-1)))
     &        ,(SNGL(SPECPOWf(IS+NSOURCE*(IO-1))),IS=NSOURCE-1,NSOURCE)
     &        ,SNGL(SPECPOWTf(IO))
          endif
          WRITE(LUNGFO,*)' '
        endif !(ifold.ne.0) then

c          IF (IAMPLI.LT.0) THEN
c            WRITE(LUNGFO,*)'     scaled according to IAMPLI:'
c            WRITE(LUNGFO,*)'            '
c     &        ,(SNGL(SPECPOW(IS+NSOURCE*(IO-1))*(-IAMPLI)),IS=1,NSOURCE)
c     &        ,SNGL(SPECPOWT(IO)*(-IAMPLI))
c            WRITE(LUNGFO,*)' '
c          ENDIF  !IAMPLI

          IF (ISPECINT.NE.0) THEN

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '     Power density [W/m**2]:'
            WRITE(LUNGFO,*)
     &        '     (by integration over spectral range:',
     &        SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','

            if (nsource.le.5) then

              WRITE(LUNGFO,*)
     &          '     for all sources and sum)'
              WRITE(LUNGFO,*)'   '
     &          ,(SNGL(SPECI(IS+NSOURCE*(IO-1))),IS=1,NSOURCE)
     &          ,SNGL(SPECTOTI(IO))

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          '     Divided by total power density:'
              WRITE(LUNGFO,*)'   '
     &          ,(SNGL(SPECI(IS+NSOURCE*(IO-1))/SPECPOW(IS+NSOURCE*(IO-1))),
     &          IS=1,NSOURCE)
     &          ,SNGL(SPECTOTI(IO)/SPECPOWT(IO))

            else

              WRITE(LUNGFO,*)
     &    '     for the first two, the central, and the last sources and sum)'
              WRITE(LUNGFO,*)
     &          '   '
     &          ,(SNGL(SPECI(IS+NSOURCE*(IO-1))),IS=1,2)
     &          ,SNGL(SPECI(IS+(NSOURCE/2+1)*(IO-1)))
     &          ,(SNGL(SPECI(IS+NSOURCE*(IO-1))),IS=nsource-1,NSOURCE)
     &          ,SNGL(SPECTOTI(IO))

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          '     Divided by total power density:'
              WRITE(LUNGFO,*)'   '
     &          ,(SNGL(SPECI(IS+NSOURCE*(IO-1))/SPECPOW(IS+NSOURCE*(IO-1))),
     &          IS=1,2)
     &          ,SNGL(SPECI(IS+(NSOURCE/2+1)*(IO-1))/
     &          SPECPOW(IS+(NSOURCE/2+1)*(IO-1)))
     &          ,(SNGL(SPECI(IS+NSOURCE*(IO-1))/SPECPOW(IS+NSOURCE*(IO-1))),
     &          IS=nsource-1,NSOURCE)
     &          ,SNGL(SPECTOTI(IO)/SPECPOWT(IO))

            endif

            WRITE(LUNGFO,*)

            WRITE (LUNGFO,*)
            WRITE (LUNGFO,*)
     &        '     Critical photon energy or wavelength of calculated flux density'

            IF (IUNIT.EQ.0)
     &        WRITE (LUNGFO,*)'     first observation point:',SNGL(FREQC)
            IF (IUNIT.NE.0)
     &        WRITE (LUNGFO,*)'     first observation point:',SNGL(WELLENC)
            WRITE (LUNGFO,*)

            WRITE(LUNGFO,*)
     &        '     Total number of photons per second at critical energy'
            WRITE(LUNGFO,*)
     &        '     for first observation point:'
            WRITE(LUNGFO,*)'            ',
     &        SNGL(SNGL(SPECTOTI(1))/FREQC/ECHARGE1)

            IF (IDESYNC.NE.0) THEN

              WRITE(LUNGFO,*)
     &          '     Power density at selected point [W/m**2] * AREAM2:'
              WRITE(LUNGFO,*)
     &          '     (by integration over spectral range:',
     &          SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','
              if (nsource.le.5) then
                WRITE(LUNGFO,*)
     &            '     for all sources and sum)'
                WRITE(LUNGFO,*)'   '
     &            ,(SNGL(SPECI(IS+NSOURCE*(IO-1))*AREAM2),IS=1,NSOURCE)
     &            ,SNGL(SPECTOTI(IO)*AREAM2)
              else
                WRITE(LUNGFO,*)'     for the first two, the central, and the last sources and sum)'
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'   '
     &            ,(SNGL(SPECI(IS+NSOURCE*(IO-1))*AREAM2),IS=1,2)
     &            ,(SNGL(SPECI(IS+(NSOURCE/2+1)*(IO-1))*AREAM2))
     &            ,(SNGL(SPECI(IS+NSOURCE*(IO-1))*AREAM2),IS=nsource-1,NSOURCE)
     &            ,SNGL(SPECTOTI(IO)*AREAM2)
              endif
            ENDIF !IDESYNC
            WRITE(LUNGFO,*)

        IF (IDOSE.NE.0) THEN

          WRITE(LUNGFO,*)" "
          WRITE(LUNGFO,*)"     *** CAUTION: THE DOSE CALCULATIONS ARE NOT MEANT FOR RADITATION SAFETY PRUPOSES OR MEDICAL APPLICATIONS ***"
          WRITE(LUNGFO,*)" "

          WRITE(LUNGFO,*)
     &      '     Absorbed energy dose rate [Gy/sec]:',SNGL(ENEDOS(IO))
          WRITE(LUNGFO,*)
     &      '     Absorbed energy dose rate [mGy/h]:',SNGL(ENEDOS(IO)
     &      *1000.*3600)
          WRITE(LUNGFO,*)
     &      '     Absorbed energy dose rate [mGy/6000h]:',SNGL(ENEDOS(IO)
     &      *1000.*3600*6000)
           WRITE(LUNGFO,*)

          IF (IO.EQ.NOBSV) THEN
            ENEDOSMX=-1.D30
            DO IOBSV=1,NOBSV
              IF (ENEDOS(IOBSV).GT.ENEDOSMX) ENEDOSMX=ENEDOS(IOBSV)
            ENDDO
            WRITE(LUNGFO,*)
     &        '     Maximum absorbed energy dose rate [Gy/sec]:',SNGL(ENEDOSMX)
            WRITE(LUNGFO,*)
     &        '     Maximum absorbed energy dose rate [mGy/h]:',SNGL(ENEDOSMX
     &        *1000.*3600)
            WRITE(LUNGFO,*)
     &        '     Maximum absorbed energy dose rate [mGy/6000h]:',SNGL(ENEDOSMX
     &        *1000.*3600*6000)
            WRITE(LUNGFO,*)

          ENDIF   !IO=NOBSV

        ENDIF !IDOSE

      ENDIF !ISPECINT


        ENDDO !IO

      ENDIF  !IPIN.eq.0

      IF(IPIN.NE.0) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     Pinhole position (x,y,z) [m]:'
        WRITE(LUNGFO,*)'     ',(SNGL(PINCEN(IO)),IO=1,3)
        WRITE(LUNGFO,*)

        IF(IPIN.NE.2.and.ipin.ne.3) THEN

          WRITE(LUNGFO,*)
     &      '     Numbers defining inner vert. and hori. edges (MMEDGEY,MMEDGEZ): ',
     &      MMEDGEY,MMEDGEZ," (obsolete, MUST be zero)"
          if (mmedgey.ne.0.or.mmedgez.ne.0) stop "MMEDGEY OR MMEDGEZ NOT ZERO!"
          WRITE(LUNGFO,*)
     &      '     Numbers defining outerer vert. and hori. edges (MEDGEY,MEDGEZ): ',
     &      MEDGEY,MEDGEZ
          WRITE(LUNGFO,*)
     &      '     Total number of vert. and hori. points:          ',NOBSVY,NOBSVZ
          WRITE(LUNGFO,*)
     &      '     Number of vert. and horiz. points inside pinhole:',MOBSVY,MOBSVZ
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     Vertical and horizontal grid size [m]:     '
     &      ,SNGL(OBSVDY),SNGL(OBSVDZ)

        ENDIF !IPIN.NE.2

        IF (MPINR.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     IQAUDPHI, NOBSVR, NOBSVPHI: ',IQUADPHI,NOBSVR, NOBSVPHI
          WRITE(LUNGFO,*)
     &      '     OBSVDR, OBSVDPHI: ',SNGL(OBSVDR),SNGL(OBSVDPHI*RADGRA1)
          WRITE(LUNGFO,*)
        ENDIF

        IF(IPIN.NE.2.and.ipin.ne.3) THEN

          WRITE(LUNGFO,*)
     &      '     Vertical and horizontal size [m x m]:      '
     &      ,AMAX1(SNGL(OBSVDY),(MOBSVY-1)*SNGL(OBSVDY))
     &      ,AMAX1(SNGL(OBSVDZ),(MOBSVZ-1)*SNGL(OBSVDZ))

          WRITE(LUNGFO,*)
     &      '     Total vert. and horiz. size [m x m]:       '
     &      ,AMAX1(SNGL(OBSVDY),(NOBSVY-1)*SNGL(OBSVDY))
     &      ,AMAX1(SNGL(OBSVDZ),(NOBSVZ-1)*SNGL(OBSVDZ))

        else

          if (ipincirc.eq.0) then
            WRITE(LUNGFO,*)
     &        '     Vertical and horizontal size [m x m]:      ',
     &        SNGL(pinh),sngl(pinw)
          endif

        ENDIF !(IPIN.NE.2)

        IF (IPINCIRC.NE.0) THEN

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &'     Flux is calculated through circ. pinhole, radius [m] and area [m x m]:'
          WRITE(LUNGFO,*)'      ',SNGL(pinr),sngl(pi1*pinr**2)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)

        ENDIF

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     Photon energy or wavelength and flux through pinhole:'

        if (nsource.le.5) then
          WRITE(LUNGFO,*)'     (for all sources and sum)'
          WRITE(LUNGFO,*)

          DO IFR=1,NFREQ

            IF (IUNIT.EQ.0)
     &        WRITE(LUNGFO,*)'  ',SNGL(FREQ(IFR))
     &        ,(SNGL(WFLUX(IS+NSOURCE*(IFR-1))),IS=1,NSOURCE)
     &        ,SNGL(WFLUXT(IFR))

            IF (IUNIT.NE.0)
     &        WRITE(LUNGFO,*)'  ',SNGL(WELLEN(IFR))
     &        ,(SNGL(WFLUX(IS+NSOURCE*(IFR-1))),IS=1,NSOURCE)
     &        ,SNGL(WFLUXT(IFR))

          ENDDO !IFR
        else
          WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
          WRITE(LUNGFO,*)

          DO IFR=1,NFREQ

            IF (IUNIT.EQ.0)
     &        WRITE(LUNGFO,*)'  ',SNGL(FREQ(IFR))
     &        ,(SNGL(WFLUX(IS+NSOURCE*(IFR-1))),IS=1,2)
     &        ,SNGL(WFLUX(IS+(NSOURCE/2+1)*(IFR-1)))
     &        ,(SNGL(WFLUX(IS+NSOURCE*(IFR-1))),IS=nsource-1,NSOURCE)
     &        ,SNGL(WFLUXT(IFR))

            IF (IUNIT.NE.0)
     &        WRITE(LUNGFO,*)'  ',SNGL(WELLEN(IFR))
     &        ,(SNGL(WFLUX(IS+NSOURCE*(IFR-1))),IS=1,2)
     &        ,SNGL(WFLUX(IS+(NSOURCE/2+1)*(IFR-1)))
     &        ,(SNGL(WFLUX(IS+NSOURCE*(IFR-1))),IS=nsource-1,NSOURCE)
     &        ,SNGL(WFLUXT(IFR))

          ENDDO !IFR
        endif

        if (ipin.ne.0) then
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     RPINSPH:       ',RPINSPH
        ENDIF

C maximum of spectot{

        IF (NFREQ.GT.1) THEN

          DO IFR=1,NFREQ
            SPECBUFF(IFR)=WFLUXT(IFR)
          ENDDO   !IFR

          CALL UTIL_MAX_PARABEL
     &      (NFREQ,FREQ,SPECBUFF,SPECTOTMX(5),SPECTOTMX(6)
     &      ,WSNOBFR1,WSNOBFR2,IFAIL)

          IF (IFAIL.NE.0) THEN
            WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED'
            WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
          ENDIF

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Estimated maximum:'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     ',SNGL(SPECTOTMX(5)),SNGL(SPECTOTMX(6))
          WRITE(LUNGFO,*)

        ENDIF  !NFREQ

C maximum of spectot}

        IF (IPINALL.NE.0) THEN

          if (ipin.ne.3) then
            DO IFR=1,NFREQ

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'     Flux density at each grid point:'
              WRITE(LUNGFO,*)
              DO IY=1,NOBSVY
                IF (IF1DIM.EQ.0) WRITE(LUNGFO,*)
                DO IZ=1,NOBSVZ
                  IOBSV=(IY-1)*NOBSVZ+IZ
                  WRITE(LUNGFO,*)'           '
     &              ,(SNGL(SPEC(IS+NSOURCE*(IOBSV-1+NOBSV*(IFR-1)))),IS=1,NSOURCE)
     &              ,SNGL(SPECTOT(IOBSV+NOBSV*(IFR-1)))
                ENDDO   !IZ
              ENDDO   !IY
              WRITE(LUNGFO,*)

            ENDDO !NFREQ

          endif !ipin.ne.3

        ELSE !IPINALL.NE.0

          if (ipin.ne.3) then
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Flux density for selected point:'
            WRITE(LUNGFO,*)
          else
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Mean flux density:'
            WRITE(LUNGFO,*)
          endif

          DO IFR=1,NFREQ

            IOBSV=ICBRILL

            WRITE(LUNGFO,*)'           '
     &        ,SNGL(FREQ(IFR)),(SNGL(SPEC(IS+NSOURCE*(IOBSV-1+NOBSV*(IFR-1)))),IS=1,NSOURCE)
     &        ,SNGL(SPECTOT(IOBSV+NOBSV*(IFR-1)))

          ENDDO   !NFREQ

C maximum of spectot{

          IF (NFREQ.GT.1) THEN

            DO IFR=1,NFREQ
              SPECBUFF(IFR)=SPECTOT(ICBRILL+NOBSV*(IFR-1))
            ENDDO !IFR

            CALL UTIL_MAX_PARABEL
     &        (NFREQ,FREQ,SPECBUFF,SPECTOTMX(1),SPECTOTMX(2)
     &        ,WSNOBFR1,WSNOBFR2,IFAIL)

            IF (IFAIL.NE.0) THEN
              WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED'
              WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
            ENDIF

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Estimated maximum:'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     ',SNGL(SPECTOTMX(1)),SNGL(SPECTOTMX(2))
            WRITE(LUNGFO,*)

          ENDIF   !NFREQ

C maximum of spectot}

        ENDIF !IPINALL

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     Power through pinhole [W]:'
        if (nsource.le.5) then
          WRITE(LUNGFO,*)'     (for all sources and sum)'
          IF (IAMPLI.GT.0) THEN
            WRITE(LUNGFO,*)
     &        '     (Option IAMPLI not taken into account!!)'
          ENDIF   !IAMPLI
          WRITE(LUNGFO,*)'   '
     &      ,(SNGL(SPECPOWVH(IS)),IS=1,NSOURCE)
     &      ,SNGL(SPECPOWVHT)
          WRITE(LUNGFO,*)
        else
          WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
          IF (IAMPLI.GT.0) THEN
            WRITE(LUNGFO,*)
     &        '     (Option IAMPLI not taken into account!!)'
          ENDIF   !IAMPLI
          WRITE(LUNGFO,*)'   '
     &      ,(SNGL(SPECPOWVH(IS)),IS=1,2)
     &      ,SNGL(SPECPOWVH(nsource/2+1))
     &      ,(SNGL(SPECPOWVH(IS)),IS=nsource-1,NSOURCE)
     &      ,SNGL(SPECPOWVHT)
          WRITE(LUNGFO,*)
        endif
c        IF (IAMPLI.LT.0) THEN
c          WRITE(LUNGFO,*)'     scaled according to IAMPLI:'
c          WRITE(LUNGFO,*)'            '
c     &      ,(SNGL(SPECPOWVH(IS)*(-IAMPLI)),IS=1,NSOURCE)
c     &      ,SNGL(SPECPOWVHT*(-IAMPLI))
c          WRITE(LUNGFO,*)' '
c        ENDIF !IAMPLI

        WRITE(LUNGFO,*)
        if (ipin.ne.3) then
          WRITE(LUNGFO,*)
     &      '     Power density at selected point [W/m**2]:'
          IF (IAMPLI.GT.0) THEN
            WRITE(LUNGFO,*)
     &        '     (Option IAMPLI not taken into account!!)'
          ENDIF   !IAMPLI
        else
          WRITE(LUNGFO,*)
     &      '     Mean power density [W/m**2]:'
          IF (IAMPLI.GT.0) THEN
            WRITE(LUNGFO,*)
     &        '     (Option IAMPLI not taken into account!!)'
          ENDIF   !IAMPLI
        endif
        WRITE(LUNGFO,*)

        IOBSV=ICBRILL
        WRITE(LUNGFO,*)'            '
     &    ,(SNGL(SPECPOW(IS+NSOURCE*(IOBSV-1))),IS=1,NSOURCE)
     &    ,SNGL(SPECPOWT(IOBSV))
        WRITE(LUNGFO,*)

c        IF (IAMPLI.LT.0) THEN
c          WRITE(LUNGFO,*)'     scaled according to IAMPLI:'
c          WRITE(LUNGFO,*)'            '
c     &      ,(SNGL(SPECPOW(IS+NSOURCE*(IOBSV-1))*(-IAMPLI)),IS=1,NSOURCE)
c     &      ,SNGL(SPECPOWT(IOBSV)*(-IAMPLI))
c          WRITE(LUNGFO,*)' '
c        ENDIF !IAMPLI

        IF (ISPECINT.NE.0) THEN

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     Power [W] through pinhole or power density [W/m**2]:'
          WRITE(LUNGFO,*)
     &      '     (by integration over spectral range:',
     &      SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','
          if (nsource.le.5) then
            WRITE(LUNGFO,*)
     &        '     for all sources and sum)'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'   '
     &        ,(SNGL(WFLUXI(IS)),IS=1,NSOURCE)
     &        ,SNGL(WFLUXTI)
          else
            WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
            WRITE(LUNGFO,*)
     &        '     for all sources and sum)'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'   '
     &        ,(SNGL(WFLUXI(IS)),IS=1,2)
     &        ,SNGL(WFLUXI(nsource/2+1))
     &        ,(SNGL(WFLUXI(IS)),IS=nsource-1,NSOURCE)
     &        ,SNGL(WFLUXTI)
          endif
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     Corresponding total number of photons at critical energy:'
          WRITE(LUNGFO,*)'            ',SNGL(WFLUXTI/FREQC/ECHARGE1)
          WRITE(LUNGFO,*)

          IF (IPINALL.NE.0) THEN

            if (ipin.ne.3) then

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          '     Power density at each grid point [W/m**2]:'
              WRITE(LUNGFO,*)
     &          '     (by integration over spectral range:',
     &          SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','
              if (nsource.le.5) then
                WRITE(LUNGFO,*)
     &            '     for all sources and sum)'
                WRITE(LUNGFO,*)
                DO IY=1,NOBSVY
                  IF (IF1DIM.EQ.0) WRITE(LUNGFO,*)
                  DO IZ=1,NOBSVZ
                    IOBSV=(IY-1)*NOBSVZ+IZ
                    WRITE(LUNGFO,*)'   '
     &                ,(SNGL(SPECI(IS+NSOURCE*(IOBSV-1))),IS=1,NSOURCE)
     &                ,SNGL(SPECTOTI(IOBSV))
                  ENDDO   !IZ
                ENDDO   !IY
              else
                WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
                WRITE(LUNGFO,*)
                DO IY=1,NOBSVY
                  IF (IF1DIM.EQ.0) WRITE(LUNGFO,*)
                  DO IZ=1,NOBSVZ
                    IOBSV=(IY-1)*NOBSVZ+IZ
                    WRITE(LUNGFO,*)'   '
     &                ,(SNGL(SPECI(IS+NSOURCE*(IOBSV-1))),IS=1,2)
     &                ,SNGL(SPECI(IS+(NSOURCE/2+1)*(IOBSV-1)))
     &                ,(SNGL(SPECI(IS+NSOURCE*(IOBSV-1))),IS=nsource-1,NSOURCE)
     &                ,SNGL(SPECTOTI(IOBSV))
                  ENDDO   !IZ
                ENDDO   !IY
              endif
              WRITE(LUNGFO,*)

            endif !ipin.ne.3

          ELSE !(IPINALL.NE.0)

            WRITE(LUNGFO,*)
            if (ipin.ne.3) then
              WRITE(LUNGFO,*)
     &          '     Power density at selected point [W/m**2]:'
              WRITE(LUNGFO,*)
     &          '     (by integration over spectral range:',
     &          SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','
              if (nsource.le.5) then
                WRITE(LUNGFO,*)
     &            '     for all sources and sum)'
              else
                WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
              endif
            else
              WRITE(LUNGFO,*)
     &          '     Mean power density [W/m**2]:'
              WRITE(LUNGFO,*)
     &          '     (by integration over spectral range:',
     &          SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','
              if (nsource.le.5) then
                WRITE(LUNGFO,*)
     &            '     for all sources and sum)'
              else
                WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
              endif
            endif
            WRITE(LUNGFO,*)

            IOBSV=ICBRILL
            if (nsource.le.5) then
              WRITE(LUNGFO,*)'     '
     &          ,(SNGL(SPECI(IS+NSOURCE*(IOBSV-1))),IS=1,NSOURCE)
     &          ,SNGL(SPECTOTI(IOBSV))
            else
              WRITE(LUNGFO,*)'   '
     &          ,(SNGL(SPECI(IS+NSOURCE*(IOBSV-1))),IS=1,2)
     &          ,SNGL(SPECI(IS+(NSOURCE/2+1)*(IOBSV-1)))
     &          ,(SNGL(SPECI(IS+NSOURCE*(IOBSV-1))),IS=nsource-1,NSOURCE)
     &          ,SNGL(SPECTOTI(IOBSV))
              WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
            endif
            WRITE(LUNGFO,*)

          ENDIF !IPINALL

          WRITE(LUNGFO,*)

          IF (IDOSE.NE.0) THEN

            WRITE(LUNGFO,*)" "
            WRITE(LUNGFO,*)"     *** CAUTION: THE DOSE CALCULATIONS ARE NOT MEANT FOR RADITATION SAFETY PRUPOSES OR MEDICAL APPLICATIONS ***"
            WRITE(LUNGFO,*)" "

            DO IO=1,NOBSV

              IF (IPINALL.NE.0) THEN

                WRITE(LUNGFO,*)
     &            '     Z, Y:',SNGL(OBSVZ(IO)),SNGL(OBSVY(IO))
                WRITE(LUNGFO,*)
     &            '     Absorbed energy dose rate [mGy/h]:',SNGL(ENEDOS(IO)
     &            *1000.*3600)
                WRITE(LUNGFO,*)

              ENDIF  !IPINALL

              IF (IO.EQ.NOBSV) THEN
                ENEDOSMX=-1.D30
                DO IOBSV=1,NOBSV
                  IF (ENEDOS(IOBSV).GT.ENEDOSMX) ENEDOSMX=ENEDOS(IOBSV)
                ENDDO
                WRITE(LUNGFO,*)
     &            '     Maximum absorbed energy dose rate [Gy/sec]:',SNGL(ENEDOSMX)
                WRITE(LUNGFO,*)
     &            '     Maximum absorbed energy dose rate [mGy/h]:',SNGL(ENEDOSMX
     &            *1000.*3600)
                WRITE(LUNGFO,*)
     &            '     Maximum absorbed energy dose rate [mGy/a]:',SNGL(ENEDOSMX
     &            *1000.*3600*6000)
                WRITE(LUNGFO,*)

              ENDIF  !IO=NOBSV
            ENDDO !IO

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '      Dose rate averaged over pinhole [Gy/sec]:',SNGL(PINDOS)
            WRITE(LUNGFO,*)
     &        '      Dose rate averaged over pinhole [mGy/h]:',SNGL(PINDOS
     &        *1000.*3600)
            WRITE(LUNGFO,*)
     &        '      Dose rate averaged over pinhole [mGy/a]:',SNGL(PINDOS
     &        *1000.*3600*6000)
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Effective pinhole size [m**2]:'
     &        ,PINDOS*PINW*PINH/ENEDOSMX
            WRITE(LUNGFO,*)'     Effective pinhole height [m]:'
     &        ,PINDOS*PINH/ENEDOSMX

            if (ipincirc.ne.0) then
              print*,"Error in spectrum: Dose calculation require rectangular pinhole ***"
              print*,"*** Program WAVE aborted ***"
              stop
            endif

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '      The estimated scattered dose behind the filter is the averaged dose scaled to the full solid angle.'
            WRITE(LUNGFO,*)
     &        '      *** DO NOT USE THESE ESTIMATIONS FOR RADIATION SAFETY OF MEDICAL APPLICATONS ***'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '      Estimated scattered dose 1m behind the filter 1m distance [Gy/sec]',
     &        SNGL(PINDOS*(pinw*pinh/pincen(1)**2)/4./pi1)
            WRITE(LUNGFO,*)
     &        '      Estimated scattered dose 1m behind the filter in 1m distance [mGy/h]',
     &        SNGL(PINDOS*(pinw*pinh/pincen(1)**2)/4./pi1*1000.*3600)
            WRITE(LUNGFO,*)
     &        '      Estimated scattered dose behind the filter in 1m distance [mGy/a]',
     &        SNGL(PINDOS*(pinw*pinh/pincen(1)**2)/4./pi1*1000.*3600*6000)
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Effective pinhole size [m**2]:'
     &        ,PINDOS*PINW*PINH/ENEDOSMX
            WRITE(LUNGFO,*)'     Effective pinhole height [m]:'
     &        ,PINDOS*PINH/ENEDOSMX

          ENDIF !IDOSE

        ENDIF !ISPECINT
        WRITE(LUNGFO,*)

        if (ipin.eq.3) then

           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)'     Horizontal emittance EPS0H [m-rad]:',EPS0H
           WRITE(LUNGFO,*)'     Vertical emittance EPS0V [m-rad]:  ',EPS0V
           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Sigmas of sources for horiz. folding:'
          WRITE(LUNGFO,*)'     ',(SNGL(WSIGZ(IS)),IS=1,NSOURCE)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Sigmas of sources for vert. folding:'
          WRITE(LUNGFO,*)'     ',(SNGL(WSIGY(IS)),IS=1,NSOURCE)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Sigmas of horizontal beam size and divergence:'
          WRITE(LUNGFO,*)
     &      '     (if not zero, sigmas for folding are calculated from these values)'
          WRITE(LUNGFO,*)'     ',(SNGL(BSIGZ(IS)),SNGL(BSIGZP(IS)),IS=1,NSOURCE)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Sigmas of vertical beam size and divergence:'
          WRITE(LUNGFO,*)
     &      '     (if not zero, sigmas for folding are calculated from these values)'
          WRITE(LUNGFO,*)'     ',(SNGL(BSIGY(IS)),SNGL(BSIGYP(IS)),IS=1,NSOURCE)
          WRITE(LUNGFO,*)

        else IF (IFOLD.NE.0)   THEN

          WRITE(LUNGFO,*)

          if (ipin.ne.3) then
            IF (IFOLD.NE.2.AND.IFOLD.NE.1)
     &        WRITE(LUNGFO,*)
     &        '     Number of Fourier coefficients for folding:',NGFOURZ,NGFOURY

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Number of sigmas for horiz. folding:'
            WRITE(LUNGFO,*)'     ',(SNGL(DGSIGZ(IS)),IS=1,NSOURCE)
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Number of sigmas for vert. folding:'
            WRITE(LUNGFO,*)'     ',(SNGL(DGSIGY(IS)),IS=1,NSOURCE)
            WRITE(LUNGFO,*)
          endif
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Sigmas of sources for horiz. folding:'
          WRITE(LUNGFO,*)'     ',(SNGL(WSIGZ(IS)),IS=1,NSOURCE)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Sigmas of sources for vert. folding:'
          WRITE(LUNGFO,*)'     ',(SNGL(WSIGY(IS)),IS=1,NSOURCE)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Sigmas of horizontal beam size and divergence:'
          WRITE(LUNGFO,*)
     &      '     (if not zero, sigmas for folding are calculated from these values)'
          WRITE(LUNGFO,*)'     ',(SNGL(BSIGZ(IS)),SNGL(BSIGZP(IS)),IS=1,NSOURCE)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     Sigmas of vertical beam size and divergence:'
          WRITE(LUNGFO,*)
     &      '     (if not zero, sigmas for folding are calculated from these values)'
          WRITE(LUNGFO,*)'     ',(SNGL(BSIGY(IS)),SNGL(BSIGYP(IS)),IS=1,NSOURCE)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)

          IF (ISTOKES.NE.0) THEN
            WRITE(LUNGFO,*)
     &        '     Sigmas for folding of components of STOKES vector:'
            WRITE(LUNGFO,*)
     &        '     ',SNGL(WSIGZ(ISIGSTO)),SNGL(WSIGY(ISIGSTO))
            WRITE(LUNGFO,*)
          ENDIF !ISTOKES
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     Photon energy or wavelen. and flux through pinhole with emittance effects:'
          WRITE(LUNGFO,*)

          DO IFR=1,NFREQ

            IF (IUNIT.EQ.0)
     &        WRITE(LUNGFO,*)'  ',SNGL(FREQ(IFR))
     &        ,(SNGL(WFLUXF(IS+NSOURCE*(IFR-1))),IS=1,NSOURCE)
     &        ,SNGL(WFLUXTF(IFR))
            IF (IUNIT.NE.0)
     &        WRITE(LUNGFO,*)'  ',SNGL(WELLEN(IFR))
     &        ,(SNGL(WFLUXF(IS+NSOURCE*(IFR-1))),IS=1,NSOURCE)
     &        ,SNGL(WFLUXTF(IFR))

          ENDDO !IFR

C maximum of spectot{

          IF (NFREQ.GT.1) THEN

            DO IFR=1,NFREQ
              SPECBUFF(IFR)=WFLUXTF(IFR)
            ENDDO !IFR

            CALL UTIL_MAX_PARABEL
     &        (NFREQ,FREQ,SPECBUFF,SPECTOTMX(1),SPECTOTMX(2)
     &        ,WSNOBFR1,WSNOBFR2,IFAIL)

            IF (IFAIL.NE.0) THEN
              WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED'
              WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
            ENDIF

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     Estimated maximum:'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'     ',SNGL(SPECTOTMX(1)),SNGL(SPECTOTMX(2))
            WRITE(LUNGFO,*)

          ENDIF   !NFREQ

C maximum of spectot}

          if (ipin.ne.3) then

            IF (IPINALL.NE.0) THEN

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'     Flux density at each grid point with emittance:'
              WRITE(LUNGFO,*)

              DO IFR=1,NFREQ

                DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
                  IF (IF1DIM.EQ.0) WRITE(LUNGFO,*)
                  DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
                    IOBSV=(IY-1)*NOBSVZ+IZ
                    WRITE(LUNGFO,*)'           '
     &                ,(SNGL(SPECF(IS+NSOURCE*(IOBSV-1+NOBSV*(IFR-1)))),IS=1,NSOURCE)
     &                ,SNGL(SPECTOTF(IOBSV+NOBSV*(IFR-1)))
                  ENDDO   !IZ
                ENDDO   !IY
                WRITE(LUNGFO,*)

              ENDDO    !IFR

            ELSE !(IPINALL.NE.0)

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          '     Flux density at selected point with emittance:'
              WRITE(LUNGFO,*)

              DO IFR=1,NFREQ

                IOBSV=ICBRILL
                WRITE(LUNGFO,*)'           '
     &            ,SNGL(FREQ(IFR))
     &            ,(SNGL(SPECF(IS+NSOURCE*(IOBSV-1+NOBSV*(IFR-1)))),IS=1,NSOURCE)
     &            ,SNGL(SPECTOTF(IOBSV+NOBSV*(IFR-1)))

              ENDDO    !IFR

C maximum of spectot{

              IF (NFREQ.GT.1) THEN

                DO IFR=1,NFREQ
                  SPECBUFF(IFR)=SPECTOTF(ICBRILL+NOBSV*(IFR-1))
                ENDDO   !IFR

                CALL UTIL_MAX_PARABEL
     &            (NFREQ,FREQ,SPECBUFF,SPECTOTMX(1),SPECTOTMX(2)
     &            ,WSNOBFR1,WSNOBFR2,IFAIL)

                IF (IFAIL.NE.0) THEN
                  WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED'
                  WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
                ENDIF

                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'     Estimated maximum:'
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'     ',SNGL(SPECTOTMX(1)),SNGL(SPECTOTMX(2))
                WRITE(LUNGFO,*)

              ENDIF  !NFREQ

C maximum of spectot}

            ENDIF !IPINALL

            IF (ISPECINT.NE.0) THEN

              WRITE(LUNGFO,*)
     &          '     Power [W] or power density [W/m**2] with emittance'
              WRITE(LUNGFO,*)
     &          '     (by integration over spectral range:',
     &          SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','
              if (nsource.le.5) then
                WRITE(LUNGFO,*)
     &            '     for all sources and sum)'
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'   '
     &            ,(SNGL(WFLUXIF(IS)),IS=1,NSOURCE)
     &            ,SNGL(WFLUXTIF)
              else
                WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'   '
     &            ,(SNGL(WFLUXIF(IS)),IS=1,2)
     &            ,SNGL(WFLUXIF(nsource/2+1))
     &            ,(SNGL(WFLUXIF(IS)),IS=nsource-1,NSOURCE)
     &            ,SNGL(WFLUXTIF)
              endif
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          '     Corresponding total number of photons at critical energy:'
              WRITE(LUNGFO,*)'     ',SNGL(WFLUXTIF/FREQCF/ECHARGE1)

              IF (IPINALL.NE.0) THEN

                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)
     &            '     Power density at each grid point [W/m**2] with emittance:'
                WRITE(LUNGFO,*)
     &            '     (by integration over spectral range:',
     &            SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','
                if (nsource.le.5) then
                  WRITE(LUNGFO,*)
     &              '     for all sources and sum)'
                  WRITE(LUNGFO,*)
                  DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
                    IF (IF1DIM.EQ.0) WRITE(LUNGFO,*)
                    DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
                      IOBSV=(IY-1)*NOBSVZ+IZ
                      WRITE(LUNGFO,*)'   '
     &                  ,(SNGL(SPECIF(IS+NSOURCE*(IOBSV-1))),IS=1,NSOURCE)
     &                  ,SNGL(SPECTOTIF(IOBSV))
                    ENDDO   !IZ
                  ENDDO   !IY
                else
                  WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
                  WRITE(LUNGFO,*)
                  DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
                    IF (IF1DIM.EQ.0) WRITE(LUNGFO,*)
                    DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
                      IOBSV=(IY-1)*NOBSVZ+IZ
                      WRITE(LUNGFO,*)'   '
     &                  ,(SNGL(SPECIF(IS+NSOURCE*(IOBSV-1))),IS=1,2)
     &                  ,SNGL(SPECIF(IS+(NSOURCE/2+1)*(IOBSV-1)))
     &                  ,(SNGL(SPECIF(IS+NSOURCE*(IOBSV-1))),IS=nsource-1,NSOURCE)
     &                  ,SNGL(SPECTOTIF(IOBSV))
                    ENDDO   !IZ
                  ENDDO   !IY
                endif
                WRITE(LUNGFO,*)

              ELSE !(IPINALL.NE.0)

                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)
     &            '     Power density at selected point [W/m**2] with emittance:'
                WRITE(LUNGFO,*)
     &            '     (by integration over spectral range:',
     &            SNGL(FREQ(NFREQ0M)),SNGL(FREQ(NFREQ0P)),','
                if (nsource.le.5) then
                  WRITE(LUNGFO,*)
     &              '     for all sources and sum)'
                  WRITE(LUNGFO,*)
                  IOBSV=ICBRILL
                  WRITE(LUNGFO,*)'   '
     &              ,(SNGL(SPECIF(IS+NSOURCE*(IOBSV-1))),IS=1,NSOURCE)
     &              ,SNGL(SPECTOTIF(IOBSV))
                else
                  WRITE(LUNGFO,*)'     (for the first two, the central, and the last sources and sum)'
                  WRITE(LUNGFO,*)
     &              '     for all sources and sum)'
                  WRITE(LUNGFO,*)
                  IOBSV=ICBRILL
                  WRITE(LUNGFO,*)'   '
     &              ,(SNGL(SPECIF(IS+NSOURCE*(IOBSV-1))),IS=1,2)
     &              ,SNGL(SPECIF(IS+(NSOURCE/2+1)*(IOBSV-1)))
     &              ,(SNGL(SPECIF(IS+NSOURCE*(IOBSV-1))),IS=nsource-1,NSOURCE)
     &              ,SNGL(SPECTOTIF(IOBSV))
                endif
                WRITE(LUNGFO,*)

              ENDIF !IPINALL

            ENDIF !ISPECINT

          ENDIF !IFOLD

        endif !ipin3 and ifold

      ENDIF  !IPIN.ne.0

      IF (ISTOKES.NE.0) THEN

        IF (IPIN.EQ.0) THEN

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)

          WRITE(LUNGFO,*)
     &      '     Photon energy [eV] or wavelength [nm] for all observation'
          WRITE(LUNGFO,*)
     &      '     points, normalized components S0, S1/S0, S2/S0, S3/S0, P of'
          WRITE(LUNGFO,*)
     &      '     STOKES vector per unit area [m**2]:'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)

          DO IO=1,NOBSV

            WRITE(LUNGFO,*)'          Observation point (x,y,z) [m]:'
            WRITE(LUNGFO,*)'          ',(SNGL(OBSV(IX,IO)),IX=1,3)
            WRITE(LUNGFO,*)

            DO IFR=1,NFREQ
              IOBFR=IO+NOBSV*(IFR-1)
              IF (STOKES(1,IOBFR).EQ.0.0) STOKES(1,IOBFR)=1.E-10
              S1=STOKES(1,IOBFR)
              S2=STOKES(2,IOBFR)
              S3=STOKES(3,IOBFR)
              S4=STOKES(4,IOBFR)
              POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1
              IF (STOKES(1,IOBFR).EQ.1.E-10) POL=0.0
              IF (IUNIT.EQ.0)
     &          WRITE(LUNGFO,2584)SNGL(FREQ(IFR)),STOKES(1,IOBFR)
     &          ,(STOKES(IS,IOBFR)/STOKES(1,IOBFR),IS=2,4),POL
              IF (IUNIT.NE.0)
     &          WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &          ,(STOKES(IS,IOBFR)/STOKES(1,IOBFR),IS=2,4),POL
            ENDDO !IFR

            IF (IFOLD.EQ.2) THEN

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)

              WRITE(LUNGFO,*)
     &          '       Photon energy [eV] or wavelength [nm] for all observation'
              WRITE(LUNGFO,*)
     &          '       points, normalized components S0, S1/S0, S2/S0, S3/S0, P of'
              WRITE(LUNGFO,*)
     &          '       STOKES vector per unit area [m**2] with emittance:'
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)

              DO IFR=1,NFREQ
                IOBFR=IO+NOBSV*(IFR-1)
                IF (STOKESF(1,IOBFR).EQ.0.0) STOKESF(1,IOBFR)=1.E-10
                S1=STOKESF(1,IOBFR)
                S2=STOKESF(2,IOBFR)
                S3=STOKESF(3,IOBFR)
                S4=STOKESF(4,IOBFR)
                POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1
                IF (STOKESF(1,IOBFR).EQ.1.E-10) POL=0.0
                IF (IUNIT.EQ.0)
     &            WRITE(LUNGFO,2584)SNGL(FREQ(IFR)),STOKESF(1,IOBFR)
     &            ,(STOKESF(IS,IOBFR)/STOKESF(1,IOBFR),IS=2,4),POL
                IF (IUNIT.NE.0)
     &            WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &            ,(STOKESF(IS,IOBFR)/STOKESF(1,IOBFR),IS=2,4),POL
              ENDDO !IFR
            ENDIF !IFOLD.EQ.2

          ENDDO !NOBSV

        ELSE   !IPIN

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     Photon energy or wavelength and normalized components S0, S1/S0,'
          WRITE(LUNGFO,*)
     &      '     S2/S0, S3/S0 of STOKES vector and polarization for pinhole:'
          WRITE(LUNGFO,*)

          DO IFR=1,NFREQ

            IF (WSTOKES(1,IFR).EQ.0.0) WSTOKES(1,IFR)=1.E-10
            S1=WSTOKES(1,IFR)
            S2=WSTOKES(2,IFR)
            S3=WSTOKES(3,IFR)
            S4=WSTOKES(4,IFR)
            POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1
C         POL=SQRT(WSTOKES(2,IFR)**2+WSTOKES(3,IFR)**2+
C     &               WSTOKES(4,IFR)**2)/WSTOKES(1,IFR)

            IF (IUNIT.EQ.0)
     &        WRITE(LUNGFO,2584)SNGL(FREQ(IFR))
     &        ,WSTOKES(1,IFR)
     &        ,(WSTOKES(IS,IFR)/WSTOKES(1,IFR),IS=2,4),POL

            IF (IUNIT.NE.0)
     &        WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &        ,WSTOKES(1,IFR)
     &        ,(WSTOKES(IS,IFR)/WSTOKES(1,IFR),IS=2,4),POL
2584        FORMAT('     ',6(1PE12.4))

          ENDDO !IFR

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          if (ipin.ne.3) then
            WRITE(LUNGFO,*)
     &        '     Photon energy [eV] or wavelength [nm] for selected point'
            WRITE(LUNGFO,*)'     of pinhole, S0, S1/S0, S2/S0, S3/S0, P of'
            WRITE(LUNGFO,*)
     &        '     STOKES vector per unit area [m**2]:'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
            IO=ICBRILL
            WRITE(LUNGFO,*)'          Observation point (x,y,z) [m]:'
            WRITE(LUNGFO,*)'          ',(SNGL(OBSV(IX,IO)),IX=1,3)
            WRITE(LUNGFO,*)
          else
            WRITE(LUNGFO,*)
     &        '     Photon energy [eV] or wavelength [nm]'
            WRITE(LUNGFO,*)'     , mean densities of S0, S1/S0, S2/S0, S3/S0, P of'
            WRITE(LUNGFO,*)
     &        '     STOKES vector per unit area [m**2]:'
          endif

          DO IFR=1,NFREQ
            IF (STOKEC(1,IFR).EQ.0.0) STOKEC(1,IFR)=1.E-10
            S1=STOKEC(1,IFR)
            S2=STOKEC(2,IFR)
            S3=STOKEC(3,IFR)
            S4=STOKEC(4,IFR)
            POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1
C         POL=
C     &                   SQRT(
C     &          (STOKEC(2,IFR)**2
C     &          +STOKEC(3,IFR)**2
C     &          +STOKEC(4,IFR)**2))
C     &          /STOKEC(1,IFR)
            IF (STOKEC(1,IFR).EQ.1.E-10) POL=0.0
            IF (IUNIT.EQ.0)
     &        WRITE(LUNGFO,2584)SNGL(FREQ(IFR))
     &        ,STOKEC(1,IFR),(STOKEC(IS,IFR)/STOKEC(1,IFR),IS=2,4),POL
            IF (IUNIT.NE.0)
     &        WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &        ,STOKEC(1,IFR),(STOKEC(IS,IFR)/STOKEC(1,IFR),IS=2,4),POL
          ENDDO !IFR

          IF (IFOLD.NE.0.and.ipin.ne.3)   THEN

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '     Energy, S0, S1/S0, S2/S0, S3/S0 and P for pinhole with emittance:'
            WRITE(LUNGFO,*)

            DO IFR=1,NFREQ

              IF (WSTOKESF(1,IFR).EQ.0.0) WSTOKESF(1,IFR)=1.E-10

              S1=WSTOKESF(1,IFR)
              S2=WSTOKESF(2,IFR)
              S3=WSTOKESF(3,IFR)
              S4=WSTOKESF(4,IFR)
              POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1
C         POL=SQRT(WSTOKESF(2,IFR)**2+WSTOKESF(3,IFR)**2+
C     &               WSTOKESF(4,IFR)**2)/WSTOKESF(1,IFR)

              IF (IUNIT.EQ.0)
     &          WRITE(LUNGFO,2584)SNGL(FREQ(IFR))
     &          ,WSTOKESF(1,IFR)
     &          ,(WSTOKESF(IS,IFR)/WSTOKESF(1,IFR),IS=2,4),POL

              IF (IUNIT.NE.0)
     &          WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &          ,WSTOKESF(1,IFR)
     &          ,(WSTOKESF(IS,IFR)/WSTOKESF(1,IFR),IS=2,4),POL

            ENDDO !IFR
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '     Photon energy [eV] or wavelength [nm] for selected point'
            WRITE(LUNGFO,*)
     &        '     of pinhole, S0, S1/S0, S2/S0, S3/S0, P of with emittance'
            WRITE(LUNGFO,*)
     &        '     STOKES vector per unit area [m**2]:'
            WRITE(LUNGFO,*)

            DO IFR=1,NFREQ
              IF (STOKECF(1,IFR).EQ.0.0) STOKECF(1,IFR)=1.E-10
              S1=STOKECF(1,IFR)
              S2=STOKECF(2,IFR)
              S3=STOKECF(3,IFR)
              S4=STOKECF(4,IFR)
              POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1
C         POL=
C     &                   SQRT(
C     &          (STOKECF(2,IFR)**2
C     &          +STOKECF(3,IFR)**2
C     &          +STOKECF(4,IFR)**2))
C     &          /STOKECF(1,IFR)
              IF (STOKECF(1,IFR).EQ.1.E-10) POL=0.0
              IF (IUNIT.EQ.0)
     &          WRITE(LUNGFO,2584)SNGL(FREQ(IFR))
     &          ,STOKECF(1,IFR),(STOKECF(IS,IFR)/STOKECF(1,IFR),
     &          IS=2,4),POL
              IF (IUNIT.NE.0)
     &          WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &          ,STOKECF(1,IFR),
     &          (STOKECF(IS,IFR)/STOKECF(1,IFR),IS=2,4),POL
            ENDDO !IFR

          ENDIF !IFOLD

        ENDIF  !IPIN


      ENDIF !ISTOKES

      IF (IW_BLENF.NE.0) ISPECSUM=1

C--- USE SIMPLE SUMMATION TO EVALUATE FLUX THROUGH PINHOLE (TEST PURPOSES)

      IF (IPIN.NE.0..AND.IPIN.NE.2.and.ipin.ne.3.AND.ISPECSUM.NE.0) THEN

          IF (ISTOKES.NE.0) THEN
               CALL STOKSUM
          ELSE
               CALL SPECSUM
          ENDIF   !ISTOKES

          IF (IFOLD.NE.0.AND.IFOLD.NE.2) THEN

         IF (ISTOKES.NE.0) THEN
             CALL STOKSUMF
         ELSE
             CALL SPECSUMF
         ENDIF !ISTOKES

          ENDIF   !IFOLD

      ENDIF !IPIN AND ISPECSUM

C--- WRITE FLUX THROUGH PINHOLE TO FILE

      IF(IWFILFL0.NE.0) THEN

         OPEN(UNIT=LUNFL0,FILE=FILEFL0,STATUS='NEW')

         WRITE(LUNFL0,*)ICODE,' ',CODE
         WRITE(LUNFL0,*)NFREQ,NSOURCE

         DO IFR=1,NFREQ
            IF (IUNIT.EQ.0)
     &         WRITE(LUNFL0,*)SNGL(FREQ(IFR))
     &                        ,(SNGL(WFLUX(IS+NSOURCE*(IFR-1))),IS=1,NSOURCE)
     &                           ,SNGL(WFLUXT(IFR))
            IF (IUNIT.NE.0)
     &         WRITE(LUNFL0,*)SNGL(WELLEN(IFR))
     &                        ,(SNGL(WFLUX(IS+NSOURCE*(IFR-1))),IS=1,NSOURCE)
     &                           ,SNGL(WFLUXT(IFR))
         ENDDO

         CLOSE(LUNFL0)
      ENDIF !IWFILFL0

      IF(ipin.ne.3.and.IFOLD.NE.0.AND.IWFILFLF.NE.0) THEN

         OPEN(UNIT=LUNFLF,FILE=FILEFLF)

         WRITE(LUNFLF,*)ICODE,' ',CODE
         WRITE(LUNFLF,*)NFREQ,NSOURCE

         DO IFR=1,NFREQ
            IF (IUNIT.EQ.0)
     &         WRITE(LUNFLF,*)SNGL(FREQ(IFR))
     &        ,(SNGL(WFLUXF(IS+NSOURCE*(IFR-1))),IS=1,NSOURCE)
     &        ,SNGL(WFLUXTF(IFR))
            IF (IUNIT.NE.0)
     &         WRITE(LUNFLF,*)SNGL(WELLEN(IFR))
     &        ,(SNGL(WFLUXF(IS+NSOURCE*(IFR-1))),IS=1,NSOURCE)
     &        ,SNGL(WFLUXTF(IFR))
         ENDDO

         CLOSE(LUNFLF)
      ENDIF !IWFILFLF

      IF (IPIN.NE.0) THEN

        STOKESMAX=0.0

        IF (ISTOKES.NE.0) THEN

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '      Total absolute maxima found for Stokes-V. (z,y,Eph,fluxdens.)'
          WRITE(LUNGFO,*)

          DO ISTOK=1,4

            DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
              DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
                IO=(IY-1)*NOBSVZ+IZ
                DO IFR=1,NFREQ
                  IF (ABS(STOKES(ISTOK,IO+NOBSV*(IFR-1))).GT.
     &                STOKESMAX(4,ISTOK)) THEN
                    STOKESMAX(1,ISTOK)=OBSV(2,IO)
                    STOKESMAX(2,ISTOK)=OBSV(3,IO)
                    STOKESMAX(3,ISTOK)=FREQ(IFR)
                    STOKESMAX(4,ISTOK)=STOKES(ISTOK,IO+NOBSV*(IFR-1))
                  ENDIF
                ENDDO   !IFR
              ENDDO  !IZ
            ENDDO !IY

            WRITE(LUNGFO,'(6X,4((1PE12.4)))')STOKESMAX(1:4,ISTOK)

          ENDDO !ISTOK

        ELSE !(ISTOKES.NE.0)

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '      Total absolute maxima found for flux-density (z,y,Eph,fluxdens.)'
          WRITE(LUNGFO,*)

          DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
            DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
              IO=(IY-1)*NOBSVZ+IZ
              DO IFR=1,NFREQ
                IF (SPECTOT(IO+NOBSV*(IFR-1)).GT.STOKESMAX(4,1)) THEN
                  STOKESMAX(1,1)=OBSV(2,IO)
                  STOKESMAX(2,1)=OBSV(3,IO)
                  STOKESMAX(3,1)=FREQ(IFR)
                  STOKESMAX(4,1)=SPECTOT(IO+NOBSV*(IFR-1))
                ENDIF
              ENDDO  !IFR
            ENDDO !IZ
          ENDDO   !IY

          WRITE(LUNGFO,'(6X,4((1PE12.4)))')STOKESMAX(1:4,1)

        ENDIF !(ISTOKES.NE.0)

        STOKESMAXF=0.0

        IF (IFOLD.NE.0.and.ipin.ne.3) THEN

          IF (ISTOKES.NE.0) THEN

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '      Total absolute maxima found for Stokes-V. with emittance'
            WRITE(LUNGFO,*)
     &        '      (z,y,Eph,fluxdens.)'
            WRITE(LUNGFO,*)

            DO ISTOK=1,4

              DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
                DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
                  IO=(IY-1)*NOBSVZ+IZ
                  DO IFR=1,NFREQ
                    IF (ABS(STOKESF(ISTOK,IO+NOBSV*(IFR-1))).GT.
     &                  STOKESMAXF(4,ISTOK)) THEN
                      STOKESMAXF(1,ISTOK)=OBSV(2,IO)
                      STOKESMAXF(2,ISTOK)=OBSV(3,IO)
                      STOKESMAXF(3,ISTOK)=FREQ(IFR)
                      STOKESMAXF(4,ISTOK)=STOKESF(ISTOK,IO+NOBSV*(IFR-1))
                    ENDIF
                  ENDDO !IFR
                ENDDO   !IZ
              ENDDO  !IY

              WRITE(LUNGFO,'(6X,4((1PE12.4)))')STOKESMAXF(1:4,ISTOK)

            ENDDO !ISTOK

          ELSE !(ISTOKES.NE.0)

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '      Total absolute maxima found for flux-dens. with emit. (z,y,Eph,fluxd.)'
            WRITE(LUNGFO,*)

            DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
              DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
                IO=(IY-1)*NOBSVZ+IZ
                DO IFR=1,NFREQ
                  IF (SPECTOTF(IO+NOBSV*(IFR-1)).GT.STOKESMAXF(4,1)) THEN
                    STOKESMAXF(1,1)=OBSV(2,IO)
                    STOKESMAXF(2,1)=OBSV(3,IO)
                    STOKESMAXF(3,1)=FREQ(IFR)
                    STOKESMAXF(4,1)=SPECTOTF(IO+NOBSV*(IFR-1))
                  ENDIF
                ENDDO   !IFR
              ENDDO  !IZ
            ENDDO !IY

            WRITE(LUNGFO,'(XXXXXX,4((1PE12.4)))')STOKESMAXF(1:4,1)

          ENDIF !(ISTOKES.NE.0)

        ENDIF !IFOLD

      ENDIF !IPIN

      IF(IEFOLD.NE.0) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)

        IF (ipin.ne.3.and.IEFOLD.NE.0) THEN
          CALL EFOLD
        ELSE IF (ipin.eq.3) THEN
          WRITE(LUNGFO,*)
     &      '     Beam energy spread (ESPREAD) for energy folding:'
          WRITE(LUNGFO,*)'     ',SNGL(ESPREAD)
        ELSE IF (IEFOLD.lt.0) THEN
          WRITE(LUNGFO,*)
     &      '     Beam energy spread (ESPREAD) and number of sigmas'
          WRITE(LUNGFO,*)
     &      '     for energy folding:'
          WRITE(LUNGFO,*)'     ',SNGL(ESPREAD),NSIGE
          WRITE(LUNGFO,*)
        ENDIF

        IF (IPIN.EQ.0) THEN

          IF (NOBSV.GT.1) THEN
            WRITE(LUNGFO,*)
     &        '       Photon energy [eV] or wavelength [nm] for first observation'
            IO=1
          ELSE
            WRITE(LUNGFO,*)
     &        '       Photon energy [eV] or wavelength [nm] for selected observation'
            IO=ICBRILL
          ENDIF

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     point, normalized components S0, S1/S0, S2/S0, S3/S0, P of'
          WRITE(LUNGFO,*)
     &      '     STOKES vector per unit area [m**2] (e-folded):'
          WRITE(LUNGFO,*)

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'          Observation point (x,y,z) [m]:'
          WRITE(LUNGFO,*)'          ',(SNGL(OBSV(IX,IO)),IX=1,3)
          WRITE(LUNGFO,*)

          DO IFR=1,NFREQ
            IF (WSTOKESE(1,IFR).EQ.0.0) WSTOKESE(1,IFR)=1.E-10
            S1=WSTOKESE(1,IFR)
            S2=WSTOKESE(2,IFR)
            S3=WSTOKESE(3,IFR)
            S4=WSTOKESE(4,IFR)
            POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1
            IF (WSTOKESE(1,IFR).EQ.1.E-10) POL=0.0
            IF (IUNIT.EQ.0)
     &        WRITE(LUNGFO,2584)SNGL(FREQ(IFR)),WSTOKESE(1,IFR)
     &        ,(WSTOKESE(IS,IFR)/WSTOKESE(1,IFR),IS=2,4),POL
            IF (IUNIT.NE.0)
     &        WRITE(LUNGFO,2584)SNGL(WELLEN(IFR)),WSTOKESE(1,IFR)
     &        ,(WSTOKESE(IS,IFR)/WSTOKESE(1,IFR),IS=2,4),POL
          ENDDO !IFR

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          IF (IFOLD.EQ.2) THEN
            IF (NOBSV.GT.1) THEN
              WRITE(LUNGFO,*)
     &          '       Photon energy [eV] or wavelength [nm] for first observation'
              IO=1
            ELSE
              WRITE(LUNGFO,*)
     &          '       Photon energy [eV] or wavelength [nm] for selected observation'
              IO=ICBRILL
            ENDIF

            WRITE(LUNGFO,*)
     &        '     point, normalized components S0, S1/S0, S2/S0, S3/S0, P of'
            WRITE(LUNGFO,*)
     &        '     STOKES vector per unit area [m**2] with emittance (e-folded):'
            WRITE(LUNGFO,*)

            DO IFR=1,NFREQ
              IF (WSTOKESEF(1,IFR).EQ.0.0) WSTOKESEF(1,IFR)=1.E-10
              S1=WSTOKESEF(1,IFR)
              S2=WSTOKESEF(2,IFR)
              S3=WSTOKESEF(3,IFR)
              S4=WSTOKESEF(4,IFR)
              POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1
              IF (WSTOKESEF(1,IFR).EQ.1.E-10) POL=0.0
              IF (IUNIT.EQ.0)
     &          WRITE(LUNGFO,2584)SNGL(FREQ(IFR)),WSTOKESEF(1,IFR)
     &          ,(WSTOKESEF(IS,IFR)/WSTOKESEF(1,IFR),IS=2,4),POL
              IF (IUNIT.NE.0)
     &          WRITE(LUNGFO,2584)SNGL(WELLEN(IFR)),WSTOKESEF(1,IFR)
     &          ,(WSTOKESEF(IS,IFR)/WSTOKESEF(1,IFR),IS=2,4),POL
            ENDDO !IFR
          ENDIF !IFOLD.EQ.2

        ELSE   !IPIN

          IF(IWFLSTOE.NE.0.AND.IEFOLD.NE.0) THEN

            OPEN(UNIT=LUNSTO,FILE=FILESTOE)

            WRITE(LUNSTO,*)ICODE,' ',CODE
            WRITE(LUNSTO,*)
            WRITE(LUNSTO,*)NSOURCE,NOBSV,NFREQ,IFREQ2P
            WRITE(LUNSTO,*)NOBSVZ,NOBSVY,MOBSVZ,MOBSVY
            WRITE(LUNSTO,*)MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY
            WRITE(LUNSTO,*)
            WRITE(LUNSTO,*)PINW,PINH,PINR
            WRITE(LUNSTO,*)OBSVDZ,OBSVDY
            WRITE(LUNSTO,*)

            WRITE(LUNSTO,*)(OBSVZ(IO),IO=1,NOBSVZ)
            WRITE(LUNSTO,*)
            WRITE(LUNSTO,*)(OBSVY(IO),IO=1,NOBSVY)
            WRITE(LUNSTO,*)

            DO IO=1,NOBSV
              WRITE(LUNSTO,*)(OBSV(IX,IO),IX=1,3)
              DO IFR=1,NFREQ
                IF (IUNIT.EQ.0) THEN !260194
                  IOBFR=IO+NOBSV*(IFR-1)
                  WRITE(LUNSTO,*)FREQ(IFR),(STOKESE(IS,IOBFR),IS=1,4)
                ELSE
                  WRITE(LUNSTO,*)WELLEN(IFR),(STOKESE(IS,IOBFR),IS=1,4)
                ENDIF
              ENDDO !NFREQ
            ENDDO !NOBSV

            CLOSE(LUNSTO)

          ENDIF !IWFLSTOE

          IF(IWFLSTOEF.NE.0.AND.IEFOLD.NE.0.AND.IFOLD.NE.0) THEN

            OPEN(UNIT=LUNSTO,FILE=FILESTOEF)

            WRITE(LUNSTO,*)ICODE,' ',CODE
            WRITE(LUNSTO,*)
            WRITE(LUNSTO,*)NSOURCE,NOBSV,NFREQ,IFREQ2P
            WRITE(LUNSTO,*)NOBSVZ,NOBSVY,MOBSVZ,MOBSVY
            WRITE(LUNSTO,*)MEDGEZ,MEDGEY,MMEDGEZ,MMEDGEY
            WRITE(LUNSTO,*)
            WRITE(LUNSTO,*)PINW,PINH,PINR
            WRITE(LUNSTO,*)OBSVDZ,OBSVDY
            WRITE(LUNSTO,*)

            WRITE(LUNSTO,*)(OBSVZ(IO),IO=1,NOBSVZ)
            WRITE(LUNSTO,*)
            WRITE(LUNSTO,*)(OBSVY(IO),IO=1,NOBSVY)
            WRITE(LUNSTO,*)

            DO IO=1,NOBSV
              WRITE(LUNSTO,*)(OBSV(IX,IO),IX=1,3)
              DO IFR=1,NFREQ
                IF (IUNIT.EQ.0) THEN !260194
                  IOBFR=IO+NOBSV*(IFR-1)
                  WRITE(LUNSTO,*)FREQ(IFR),(STOKESEF(IS,IOBFR),IS=1,4)
                ELSE
                  WRITE(LUNSTO,*)WELLEN(IFR),(STOKESEF(IS,IOBFR),IS=1,4)
                ENDIF
              ENDDO !NFREQ
            ENDDO !NOBSV

            CLOSE(LUNSTO)

          ENDIF !IWFLSTOEF

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     Photon energy or wavelength and normalized components S0, S1/S0,'
          WRITE(LUNGFO,*)
     &      '     S2/S0, S3/S0 of STOKES vector and polarization for pinhole'
          WRITE(LUNGFO,*)
     &      '     (e-folded):'
          WRITE(LUNGFO,*)

          DO IFR=1,NFREQ

            IF (WSTOKESE(1,IFR).EQ.0.0) WSTOKESE(1,IFR)=1.E-10

            S1=WSTOKESE(1,IFR)
            S2=WSTOKESE(2,IFR)
            S3=WSTOKESE(3,IFR)
            S4=WSTOKESE(4,IFR)
            POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1

            IF (IUNIT.EQ.0)
     &        WRITE(LUNGFO,2584)SNGL(FREQ(IFR))
     &        ,WSTOKESE(1,IFR)
     &        ,(WSTOKESE(IS,IFR)/WSTOKESE(1,IFR),IS=2,4),POL

            IF (IUNIT.NE.0)
     &        WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &        ,WSTOKESE(1,IFR)
     &        ,(WSTOKESE(IS,IFR)/WSTOKESE(1,IFR),IS=2,4),POL

          ENDDO !IFR

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '     Photon energy or wavelength and normalized components S0, S1/S0,'
          WRITE(LUNGFO,*)
     &      '     S2/S0, S3/S0 of STOKES vector and polarization for selected point of'
          WRITE(LUNGFO,*)
     &      '     pinhole (e-folded):'
          WRITE(LUNGFO,*)

          DO IFR=1,NFREQ

            IF (STOKECE(1,IFR).EQ.0.0) STOKECE(1,IFR)=1.E-10

            S1=STOKECE(1,IFR)
            S2=STOKECE(2,IFR)
            S3=STOKECE(3,IFR)
            S4=STOKECE(4,IFR)
            POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1

            IF (IUNIT.EQ.0)
     &        WRITE(LUNGFO,2584)SNGL(FREQ(IFR))
     &        ,STOKECE(1,IFR)
     &        ,(STOKECE(IS,IFR)/STOKECE(1,IFR),IS=2,4),POL

            IF (IUNIT.NE.0)
     &        WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &        ,STOKECE(1,IFR)
     &        ,(STOKECE(IS,IFR)/STOKECE(1,IFR),IS=2,4),POL

          ENDDO !IFR

          STOKESMAXE=0.0

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '      Total absolute maxima found for Stokes-V. with'
          WRITE(LUNGFO,*)
     &      '      e-spread (z,y,Eph,fluxdens.)'
          WRITE(LUNGFO,*)

          DO ISTOK=1,4

            DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
              DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
                IO=(IY-1)*NOBSVZ+IZ
                DO IFR=1,NFREQ
                  IF (ABS(STOKESE(ISTOK,IO+NOBSV*(IFR-1))).GT.
     &                STOKESMAXE(4,ISTOK)) THEN
                    STOKESMAXE(1,ISTOK)=OBSV(2,IO)
                    STOKESMAXE(2,ISTOK)=OBSV(3,IO)
                    STOKESMAXE(3,ISTOK)=FREQ(IFR)
                    STOKESMAXE(4,ISTOK)=STOKESE(ISTOK,IO+NOBSV*(IFR-1))
                  ENDIF
                ENDDO   !IFR
              ENDDO  !IZ
            ENDDO !IY

            WRITE(LUNGFO,'(6X,4((1PE12.4)))')STOKESMAXE(1:4,ISTOK)

          ENDDO !ISTOK

          IF (IFOLD.NE.0.and.ipin.ne.3)   THEN

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '     Energy, S0, S1/S0, S2/S0, S3/S0 and P for pinhole with emittance'
            WRITE(LUNGFO,*)
     &        '     (e-folded):'
            WRITE(LUNGFO,*)

            DO IFR=1,NFREQ

              IF (WSTOKESEF(1,IFR).EQ.0.0) WSTOKESEF(1,IFR)=1.E-10

              S1=WSTOKESEF(1,IFR)
              S2=WSTOKESEF(2,IFR)
              S3=WSTOKESEF(3,IFR)
              S4=WSTOKESEF(4,IFR)
              POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1

              IF (IUNIT.EQ.0)
     &          WRITE(LUNGFO,2584)SNGL(FREQ(IFR))
     &          ,WSTOKESEF(1,IFR)
     &          ,(WSTOKESEF(IS,IFR)/WSTOKESEF(1,IFR),IS=2,4),POL

              IF (IUNIT.NE.0)
     &          WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &          ,WSTOKESEF(1,IFR)
     &          ,(WSTOKESEF(IS,IFR)/WSTOKESEF(1,IFR),IS=2,4),POL

            ENDDO !IFR

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &        '     Energy, S0, S1/S0, S2/S0, S3/S0 and P for selected point of pinhole'
            WRITE(LUNGFO,*)
     &        '     with emittance (e-folded):'
            WRITE(LUNGFO,*)

            DO IFR=1,NFREQ

              IF (STOKECEF(1,IFR).EQ.0.0) STOKECEF(1,IFR)=1.E-10

              S1=STOKECEF(1,IFR)
              S2=STOKECEF(2,IFR)
              S3=STOKECEF(3,IFR)
              S4=STOKECEF(4,IFR)
              POL=DSQRT(S2*S2+S3*S3+S4*S4)/S1

              IF (IUNIT.EQ.0)
     &          WRITE(LUNGFO,2584)SNGL(FREQ(IFR))
     &          ,STOKECEF(1,IFR)
     &          ,(STOKECEF(IS,IFR)/STOKECEF(1,IFR),IS=2,4),POL

              IF (IUNIT.NE.0)
     &          WRITE(LUNGFO,2584)SNGL(WELLEN(IFR))
     &          ,STOKECEF(1,IFR)
     &          ,(STOKECEF(IS,IFR)/STOKECEF(1,IFR),IS=2,4),POL

            ENDDO !IFR

          ENDIF !IFOLD

        ENDIF  !IPIN

        STOKESMAXEF=0.0

        IF (ipin.ne.3.and.IFOLD.NE.0) THEN

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '      Total absolute maxima found for Stokes-V. with'
          WRITE(LUNGFO,*)
     &      '      emit. and e-spread (z,y,Eph,fluxdens.)'
          WRITE(LUNGFO,*)

          DO ISTOK=1,4

            DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
              DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
                IO=(IY-1)*NOBSVZ+IZ
                DO IFR=1,NFREQ
                  IF (ABS(STOKESEF(ISTOK,IO+NOBSV*(IFR-1))).GT.
     &                STOKESMAXEF(4,ISTOK)) THEN
                    STOKESMAXEF(1,ISTOK)=OBSV(2,IO)
                    STOKESMAXEF(2,ISTOK)=OBSV(3,IO)
                    STOKESMAXEF(3,ISTOK)=FREQ(IFR)
                    STOKESMAXEF(4,ISTOK)=STOKESEF(ISTOK,IO+NOBSV*(IFR-1))
                  ENDIF
                ENDDO   !IFR
              ENDDO  !IZ
            ENDDO !IY

            WRITE(LUNGFO,'(6X,4((1PE12.4)))')STOKESMAXEF(1:4,ISTOK)

          ENDDO !ISTOK

        ENDIF !IFOLD

      ENDIF !IEFOLD

      IF(IWFILS.NE.0.AND.ISTOKES.NE.0) THEN

        OPEN(UNIT=LUNS,FILE=FILES)

        WRITE(LUNS,*)ICODE,' ',CODE
        WRITE(LUNS,*)NFREQ

        DO IFR=1,NFREQ
          IF (IUNIT.EQ.0)
     &      WRITE(LUNS,*)SNGL(FREQ(IFR))
     &      ,((WSTOKES(IS,IFR)),IS=1,4)
          IF (IUNIT.NE.0)
     &      WRITE(LUNS,*)SNGL(WELLEN(IFR))
     &      ,((WSTOKES(IS,IFR)),IS=1,4)
        ENDDO

        CLOSE(LUNS)
      ENDIF !IWFILS

      IF(IFOLD.NE.0.AND.IWFILSF.NE.0.AND.ISTOKES.NE.0) THEN

        OPEN(UNIT=LUNSF,FILE=FILESF)

        WRITE(LUNSF,*)ICODE,' ',CODE
        WRITE(LUNSF,*)NFREQ

        DO IFR=1,NFREQ
          IF (IUNIT.EQ.0)
     &      WRITE(LUNSF,*)SNGL(FREQ(IFR))
     &      ,((WSTOKESF(IS,IFR)),IS=1,4)
          IF (IUNIT.NE.0)
     &      WRITE(LUNSF,*)SNGL(WELLEN(IFR))
     &      ,((WSTOKESF(IS,IFR)),IS=1,4)
        ENDDO

        CLOSE(LUNSF)
      ENDIF !IWFILSF

      IF(IEFOLD.NE.0.AND.IWFILSE.NE.0.AND.ISTOKES.NE.0) THEN

        OPEN(UNIT=LUNSE,FILE=FILESE)

        WRITE(LUNSE,*)ICODE,' ',CODE
        WRITE(LUNSE,*)NFREQ

        DO IFR=1,NFREQ
          IF (IUNIT.EQ.0)
     &      WRITE(LUNSE,*)SNGL(FREQ(IFR))
     &      ,((WSTOKESE(IS,IFR)),IS=1,4)
          IF (IUNIT.NE.0)
     &      WRITE(LUNSE,*)SNGL(WELLEN(IFR))
     &      ,((WSTOKESE(IS,IFR)),IS=1,4)
        ENDDO

        CLOSE(LUNSE)
      ENDIF !IWFILSE

      IF(IEFOLD.NE.0.AND.IFOLD.NE.0.AND.IWFILSEF.NE.0.AND.ISTOKES.NE.0) THEN

        OPEN(UNIT=LUNSEF,FILE=FILESEF)

        WRITE(LUNSEF,*)ICODE,' ',CODE
        WRITE(LUNSEF,*)NFREQ

        DO IFR=1,NFREQ
          IF (IUNIT.EQ.0)
     &      WRITE(LUNSEF,*)SNGL(FREQ(IFR))
     &      ,((WSTOKESEF(IS,IFR)),IS=1,4)
          IF (IUNIT.NE.0)
     &      WRITE(LUNSEF,*)SNGL(WELLEN(IFR))
     &      ,((WSTOKESEF(IS,IFR)),IS=1,4)
        ENDDO

        CLOSE(LUNSEF)
      ENDIF !IWFILSEF

      IF(IWFILB.NE.0.AND.ISTOKES.NE.0) THEN

        OPEN(UNIT=LUNC,FILE=FILEC)

        WRITE(LUNC,*)ICODE,' ',CODE
        WRITE(LUNC,*)nintFREQ

        DO IFR=1,NFREQ
           if (freq(ifr).ge.freqlow-(freq(2)-freq(1))/2.0d0
     &         .and.freq(ifr).le.freqhig+(freq(2)-freq(1))/2.0d0) then
          IF (IUNIT.EQ.0)
     &      WRITE(LUNC,*)SNGL(FREQ(IFR))
     &      ,((STOKEC(IS,IFR)),IS=1,4)
          IF (IUNIT.NE.0)
     &      WRITE(LUNC,*)SNGL(WELLEN(IFR))
     &      ,((STOKEC(IS,IFR)),IS=1,4)
          endif
        ENDDO

        CLOSE(LUNC)
      ENDIF !IWFILB

      IF(IFOLD.NE.0.AND.IWFILBF.NE.0.AND.ISTOKES.NE.0) THEN

        OPEN(UNIT=LUNCF,FILE=FILECF)

        WRITE(LUNCF,*)ICODE,' ',CODE
        WRITE(LUNCF,*)NintFREQ

        DO IFR=1,NFREQ
           if (freq(ifr).ge.freqlow-(freq(2)-freq(1))/2.0d0
     &         .and.freq(ifr).le.freqhig+(freq(2)-freq(1))/2.0d0) then
          IF (IUNIT.EQ.0)
     &      WRITE(LUNCF,*)SNGL(FREQ(IFR))
     &      ,((STOKECF(IS,IFR)),IS=1,4)
          IF (IUNIT.NE.0)
     &      WRITE(LUNCF,*)SNGL(WELLEN(IFR))
     &      ,((STOKECF(IS,IFR)),IS=1,4)
          endif
        ENDDO

        CLOSE(LUNCF)
      ENDIF !IWFILBF

      IF(IEFOLD.NE.0.AND.IWFILBE.NE.0.AND.ISTOKES.NE.0) THEN

         OPEN(UNIT=LUNCE,FILE=FILECE)

         WRITE(LUNCE,*)ICODE,' ',CODE
         WRITE(LUNCE,*)nintFREQ

         DO IFR=1,NFREQ
           if (freq(ifr).ge.freqlow-(freq(2)-freq(1))/2.0d0
     &         .and.freq(ifr).le.freqhig+(freq(2)-freq(1))/2.0d0) then
           IF (IUNIT.EQ.0)
     &       WRITE(LUNCE,*)SNGL(FREQ(IFR))
     &       ,((STOKECE(IS,IFR)),IS=1,4)
           IF (IUNIT.NE.0)
     &       WRITE(LUNCE,*)SNGL(WELLEN(IFR))
     &       ,((STOKECE(IS,IFR)),IS=1,4)
           endif
         ENDDO

         CLOSE(LUNCE)
       ENDIF !IWFILBE

       IF(IEFOLD.NE.0.AND.IFOLD.NE.0.AND.IWFILBEF.NE.0.AND.ISTOKES.NE.0) THEN

         OPEN(UNIT=LUNCEF,FILE=FILECEF)

         WRITE(LUNCEF,*)ICODE,' ',CODE
         WRITE(LUNCEF,*)NintFREQ

         DO IFR=1,NFREQ
           if (freq(ifr).ge.freqlow-(freq(2)-freq(1))/2.0d0
     &         .and.freq(ifr).le.freqhig+(freq(2)-freq(1))/2.0d0) then
           IF (IUNIT.EQ.0)
     &       WRITE(LUNCEF,*)SNGL(FREQ(IFR))
     &       ,((STOKECEF(IS,IFR)),IS=1,4)
           IF (IUNIT.NE.0)
     &       WRITE(LUNCEF,*)SNGL(WELLEN(IFR))
     &       ,((STOKECEF(IS,IFR)),IS=1,4)
           endif
         ENDDO

         CLOSE(LUNCEF)
       ENDIF !IWFILBEF

       IF (ISTOKES.NE.0) THEN

         DO ISTO=1,4

           DO IFREQ=1,NFREQ
             SPECBUFF(IFREQ)=ABS(STOKEC(ISTO,IFREQ))
           ENDDO  !IFR
           CALL UTIL_MAX_PARABEL
     &       (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
           STOKCMX(ISTO,1)=DUM1
           STOKCMX(ISTO,2)=DUM2

           IF (IFAIL.NE.0) THEN
             WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S',ISTO
             WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
           ENDIF

           IF (IFOLD.NE.0) THEN
             DO IFREQ=1,NFREQ
               SPECBUFF(IFREQ)=ABS(STOKECF(ISTO,IFREQ))
             ENDDO   !IFR
             CALL UTIL_MAX_PARABEL
     &         (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
             STOKCMXF(ISTO,1)=DUM1
             STOKCMXF(ISTO,2)=DUM2
             IF (IFAIL.NE.0) THEN
               WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S',ISTO
               WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
             ENDIF
           ENDIF

           IF (IEFOLD.NE.0) THEN
             DO IFREQ=1,NFREQ
               SPECBUFF(IFREQ)=ABS(STOKECE(ISTO,IFREQ))
             ENDDO   !IFR
             CALL UTIL_MAX_PARABEL
     &         (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
             STOKCMXE(ISTO,1)=DUM1
             STOKCMXE(ISTO,2)=DUM2
             IF (IFAIL.NE.0) THEN
               WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S',ISTO
               WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
             ENDIF
           ENDIF

           IF (IFOLD.NE.0.AND.IEFOLD.NE.0) THEN
             DO IFREQ=1,NFREQ
               SPECBUFF(IFREQ)=ABS(STOKECEF(ISTO,IFREQ))
             ENDDO   !IFR
             CALL UTIL_MAX_PARABEL
     &         (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
             STOKCMXEF(ISTO,1)=DUM1
             STOKCMXEF(ISTO,2)=DUM2
             IF (IFAIL.NE.0) THEN
               WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S',ISTO
               WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
             ENDIF
           ENDIF

         ENDDO !ISTO

       ENDIF   !ISTOKES

       IF (NFREQ.GT.1) THEN

         IF (ISTOKES.NE.0) THEN

           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
          if (ipin.ne.3) then
            WRITE(LUNGFO,*)
     &        '      Estimated maxima of s0, s1, s2 ,s3 for selected point:'
          else
            WRITE(LUNGFO,*)
     &        '      Estimated maxima of mean densities of s0, s1, s2 ,s3:'
          endif
           DO ISTO=1,4
             WRITE(LUNGFO,*)'      ',STOKCMX(ISTO,1),STOKCMX(ISTO,2)
           ENDDO  !ISTO

           IF (IFOLD.NE.0) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &         '      Estimated maxima of s0, s1, s2 ,s3 for selected point with emittance:'
             DO ISTO=1,4
               WRITE(LUNGFO,*)'      ',STOKCMXF(ISTO,1),STOKCMXF(ISTO,2)
             ENDDO   !ISTO
           ENDIF  !IFOLD

           IF (IEFOLD.NE.0) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &         '      Estimated maxima of s0, s1, s2 ,s3 for selected point with energy spread:'
             DO ISTO=1,4
               WRITE(LUNGFO,*)'      ',STOKCMXE(ISTO,1),STOKCMXE(ISTO,2)
             ENDDO   !ISTO
           ENDIF  !IFOLD

           IF (IFOLD.NE.0.AND.IEFOLD.NE.0) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &         '      Estimated maxima of s0, s1, s2 ,s3 for selected point'
             WRITE(LUNGFO,*)
     &         '      with emittance and energy spread:'
             DO ISTO=1,4
               WRITE(LUNGFO,*)'      ',STOKCMXEF(ISTO,1),STOKCMXEF(ISTO,2)
             ENDDO   !ISTO
           ENDIF

           DO IFREQ=1,NFREQ
             S1=STOKEC(1,IFREQ)
             S2=STOKEC(2,IFREQ)
             S3=STOKEC(3,IFREQ)
             S4=STOKEC(4,IFREQ)
             IF (S1.NE.0.0) THEN
               POL=S4/S1*S4
             ELSE
               POL=0.0d0
             ENDIF
             SPECBUFF(IFREQ)=ABS(POL)
           ENDDO  !IFR
           CALL UTIL_MAX_PARABEL
     &       (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
           G3CMX(1)=DUM1
           G3CMX(2)=DUM2
           IF (IFAIL.NE.0) THEN
             WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S'
             WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
           ENDIF

           IF (IFOLD.NE.0) THEN
             DO IFREQ=1,NFREQ
               S1=STOKECF(1,IFREQ)
               S2=STOKECF(2,IFREQ)
               S3=STOKECF(3,IFREQ)
               S4=STOKECF(4,IFREQ)
               IF (S1.NE.0.0) THEN
                 POL=S4/S1*S4
               ELSE
                 POL=0.0d0
               ENDIF
               SPECBUFF(IFREQ)=ABS(POL)
             ENDDO   !IFR
             CALL UTIL_MAX_PARABEL
     &         (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
             G3CMXF(1)=DUM1
             G3CMXF(2)=DUM2
             IF (IFAIL.NE.0) THEN
               WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S3*S3/S0'
               WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
             ENDIF
           ENDIF

           IF (IEFOLD.NE.0) THEN
             DO IFREQ=1,NFREQ
               S1=STOKECE(1,IFREQ)
               S2=STOKECE(2,IFREQ)
               S3=STOKECE(3,IFREQ)
               S4=STOKECE(4,IFREQ)
               IF (S1.NE.0.0) THEN
                 POL=S4/S1*S4
               ELSE
                 POL=0.0d0
               ENDIF
               SPECBUFF(IFREQ)=ABS(POL)
             ENDDO   !IFR
             CALL UTIL_MAX_PARABEL
     &         (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
             G3CMXE(1)=DUM1
             G3CMXE(2)=DUM2
             IF (IFAIL.NE.0) THEN
               WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S3*S3/S0'
               WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
             ENDIF
           ENDIF

           IF (IFOLD.NE.0.AND.IEFOLD.NE.0) THEN

             DO IFREQ=1,NFREQ
               S1=STOKECEF(1,IFREQ)
               S2=STOKECEF(2,IFREQ)
               S3=STOKECEF(3,IFREQ)
               S4=STOKECEF(4,IFREQ)
               IF (S1.NE.0.0) THEN
                 POL=S4/S1*S4
               ELSE
                 POL=0.0d0
               ENDIF
               SPECBUFF(IFREQ)=ABS(POL)
             ENDDO   !IFREQ

             CALL UTIL_MAX_PARABEL
     &         (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
             G3CMXEF(1)=DUM1
             G3CMXEF(2)=DUM2
             IF (IFAIL.NE.0) THEN
               WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S3*S3/S0'
               WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
             ENDIF

           ENDIF  !IFOLD,IEFOLD

           WRITE(LUNGFO,*)
           WRITE(LUNGFO,*)
           if (ipin.ne.3) then
             WRITE(LUNGFO,*)
     &         '      Estimated maximum of s3*s3/s0 for selected point:'
           else
             WRITE(LUNGFO,*)
     &         '      Estimated maximum of mean density s3*s3/s0:'
           endif
           WRITE(LUNGFO,*)'      ',G3CMX(1),G3CMX(2)

           IF (IFOLD.NE.0) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &         '      Estimated maximum of s3*s3/s0 for selected point with emittance:'
             WRITE(LUNGFO,*)'      ',G3CMXF(1),G3CMXF(2)
           ENDIF!IFOLD

           IF (IEFOLD.NE.0) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &         '      Estimated maximum of s3*s3/s0 for selected point with energy spread:'
             WRITE(LUNGFO,*)'      ',G3CMXE(1),G3CMXE(2)
           ENDIF  !IEFOLD

           IF (IFOLD.NE.0.AND.IEFOLD.NE.0) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &         '      Estimated maximum of s3*s3/s0 for selected point'
             WRITE(LUNGFO,*)
     &         '      with emittance and energy spread:'
             WRITE(LUNGFO,*)'      ',G3CMXEF(1),G3CMXEF(2)
           ENDIF !IFOLD,IEFOLD

           IF (IPIN.NE.0) THEN

             DO ISTO=1,4

               DO IFREQ=1,NFREQ
                 SPECBUFF(IFREQ)=ABS(WSTOKES(ISTO,IFREQ))
c                 print*,"spectrum:",isto,ifreq,wstokes(isto,ifreq)
               ENDDO !IFR
               CALL UTIL_MAX_PARABEL
     &           (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
               WSTOKMX(ISTO,1)=DUM1
               WSTOKMX(ISTO,2)=DUM2
               IF (IFAIL.NE.0) THEN
                 WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S',ISTO
                 WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
               ENDIF


               IF (IFOLD.NE.0) THEN
                 DO IFREQ=1,NFREQ
                   SPECBUFF(IFREQ)=ABS(WSTOKESF(ISTO,IFREQ))
                 ENDDO  !IFR
                 CALL UTIL_MAX_PARABEL
     &             (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
                 WSTOKMXF(ISTO,1)=DUM1
                 WSTOKMXF(ISTO,2)=DUM2
                 IF (IFAIL.NE.0) THEN
                   WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S',ISTO
                   WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
                 ENDIF
               ENDIF !IFOLD

               IF (IEFOLD.NE.0) THEN
                 DO IFREQ=1,NFREQ
                   SPECBUFF(IFREQ)=ABS(WSTOKESE(ISTO,IFREQ))
                 ENDDO  !IFR
                 CALL UTIL_MAX_PARABEL
     &             (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
                 WSTOKMXE(ISTO,1)=DUM1
                 WSTOKMXE(ISTO,2)=DUM2
                 IF (IFAIL.NE.0) THEN
                   WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S',ISTO
                   WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
                 ENDIF
               ENDIF !IEFOLD

               IF (IFOLD.NE.0.AND.IEFOLD.NE.0) THEN
                 DO IFREQ=1,NFREQ
                   SPECBUFF(IFREQ)=ABS(WSTOKESEF(ISTO,IFREQ))
                 ENDDO  !IFR
                 CALL UTIL_MAX_PARABEL
     &             (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
                 WSTOKMXEF(ISTO,1)=DUM1
                 WSTOKMXEF(ISTO,2)=DUM2
                 IF (IFAIL.NE.0) THEN
                   WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S',ISTO
                   WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
                 ENDIF
               ENDIF !IFOLD,IEFOLD

             ENDDO   !ISTO

             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &         '      Estimated maxima of fluxes s0, s1, s2 ,s3:'
             DO ISTO=1,4
               WRITE(LUNGFO,*)'      ',WSTOKMX(ISTO,1),WSTOKMX(ISTO,2)
             ENDDO   !ISTO

             IF (IFOLD.NE.0) THEN
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
     &           '      Estimated maxima of fluxes s0, s1, s2 ,s3 with emittance:'
               DO ISTO=1,4
                 WRITE(LUNGFO,*)'      ',WSTOKMXF(ISTO,1),WSTOKMXF(ISTO,2)
               ENDDO !ISTO
             ENDIF

             IF (IEFOLD.NE.0) THEN
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
     &           '      Estimated maxima of fluxes s0, s1, s2 ,s3 with energy spread:'
               DO ISTO=1,4
                 WRITE(LUNGFO,*)'      ',WSTOKMXE(ISTO,1),WSTOKMXE(ISTO,2)
               ENDDO !ISTO
             ENDIF

             IF (IFOLD.NE.0.AND.IEFOLD.NE.0) THEN
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
     &           '      Estimated maxima of fluxes s0, s1, s2 ,s3'
               WRITE(LUNGFO,*)
     &           '      with emittance and energy spread:'
               DO ISTO=1,4
                 WRITE(LUNGFO,*)'      ',WSTOKMXEF(ISTO,1),WSTOKMXEF(ISTO,2)
               ENDDO !ISTO
             ENDIF

             DO IFREQ=1,NFREQ
               S1=WSTOKES(1,IFREQ)
               S2=WSTOKES(2,IFREQ)
               S3=WSTOKES(3,IFREQ)
               S4=WSTOKES(4,IFREQ)
               IF (S1.NE.0.0) THEN
                 POL=S4/S1*S4
               ELSE
                 POL=0.0d0
               ENDIF
               SPECBUFF(IFREQ)=ABS(POL)
             ENDDO   !IFR
             CALL UTIL_MAX_PARABEL
     &         (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
             WG3MX(1)=DUM1
             WG3MX(2)=DUM2
             IF (IFAIL.NE.0) THEN
               WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S3*S3/S0'
               WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
             ENDIF

             IF (IEFOLD.NE.0) THEN
               DO IFREQ=1,NFREQ
                 S1=WSTOKESE(1,IFREQ)
                 S2=WSTOKESE(2,IFREQ)
                 S3=WSTOKESE(3,IFREQ)
                 S4=WSTOKESE(4,IFREQ)
                 IF (S1.NE.0.0) THEN
                   POL=S4/S1*S4
                 ELSE
                   POL=0.0d0
                 ENDIF
                 SPECBUFF(IFREQ)=ABS(POL)
               ENDDO !IFR
               CALL UTIL_MAX_PARABEL
     &           (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
               WG3MXE(1)=DUM1
               WG3MXE(2)=DUM2
               IF (IFAIL.NE.0) THEN
                 WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S3*S3/S0'
                 WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
               ENDIF
             ENDIF   !IEFOLD

             IF (IFOLD.NE.0) THEN
               DO IFREQ=1,NFREQ
                 S1=WSTOKESF(1,IFREQ)
                 S2=WSTOKESF(2,IFREQ)
                 S3=WSTOKESF(3,IFREQ)
                 S4=WSTOKESF(4,IFREQ)
                 IF (S1.NE.0.0) THEN
                   POL=S4/S1*S4
                 ELSE
                   POL=0.0d0
                 ENDIF
                 SPECBUFF(IFREQ)=ABS(POL)
               ENDDO !IFR
               CALL UTIL_MAX_PARABEL
     &           (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
               WG3MXF(1)=DUM1
               WG3MXF(2)=DUM2
               IF (IFAIL.NE.0) THEN
                 WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S3*S3/S0'
                 WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
               ENDIF
             ENDIF   !IFOLD

             IF (IFOLD.NE.0.AND.IEFOLD.NE.0) THEN
               DO IFREQ=1,NFREQ
                 S1=WSTOKESEF(1,IFREQ)
                 S2=WSTOKESEF(2,IFREQ)
                 S3=WSTOKESEF(3,IFREQ)
                 S4=WSTOKESEF(4,IFREQ)
                 IF (S1.NE.0.0) THEN
                   POL=S4/S1*S4
                 ELSE
                   POL=0.0d0
                 ENDIF
                 SPECBUFF(IFREQ)=ABS(POL)
               ENDDO !IFR
               CALL UTIL_MAX_PARABEL
     &           (NFREQ,FREQ,SPECBUFF,DUM1,DUM2,WSNOBFR1,WSNOBFR2,IFAIL)
               WG3MXEF(1)=DUM1
               WG3MXEF(2)=DUM2
               IF (IFAIL.NE.0) THEN
                 WRITE(LUNGFO,*)'*** WARNING: CALL TO UTIL_MAX_PARABEL FAILED FOR S3*S3/S0'
                 WRITE(LUNGFO,*)'*** CHECK VALUES CAREFULLY'
               ENDIF
             ENDIF   !IFOLD,IEFOLD

             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &         '      Estimated maxima of fluxes s3*s3/s0:'
             WRITE(LUNGFO,*)'      ',WG3MX(1),WG3MX(2)

             IF (IFOLD.NE.0) THEN
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
     &           '      Estimated maxima of fluxes s3*s3/s0 with emittance:'
               WRITE(LUNGFO,*)'      ',WG3MXF(1),WG3MXF(2)
             ENDIF

             IF (IEFOLD.NE.0) THEN
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
     &           '      Estimated maxima of fluxes s3*s3/s0 with energy spread:'
               WRITE(LUNGFO,*)'      ',WG3MXE(1),WG3MXE(2)
             ENDIF

             IF (IFOLD.NE.0.AND.IEFOLD.NE.0) THEN
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
               WRITE(LUNGFO,*)
     &           '      Estimated maxima of fluxes s3*s3/s0'
               WRITE(LUNGFO,*)
     &           '      with emittance and energy spread:'
               WRITE(LUNGFO,*)'      ',WG3MXEF(1),WG3MXEF(2)
             ENDIF

           ENDIF  !ISTOKES

         ENDIF !IPIN

      ENDIF !NFREQ

C---BRILLIANCE


      IF (IBRILL.NE.0) CALL BRILL

C--- STORE RESULT IN HISTOGRAMS

      ALLOCATE(FILL(NOBSV))
      DO I=1,NOBSV
        FILL(I)=0.0d0
      ENDDO

      IF(IHPIN.GT.0) THEN
        CALL HSPEC
      ELSE IF (IHFOLD.NE.0) THEN
        CALL HFOLD
      ENDIF

      !{ Fold power density
      !Baustelle
      !} Fold power density

      IF(IWFILPOW.NE.0) THEN

         OPEN(UNIT=LUNPOW,FILE=FILEPOW)

         IF (IWFILPOW.GT.0) THEN
           WRITE(LUNPOW,*)ICODE,' ',CODE
         ENDIF

         if (ipin.ne.0) then
           DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
             DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
               IO=(IY-1)*NOBSVZ+IZ
               DUM1=0.0d0
               IF(IFOLD.NE.0) DUM1=SPECTOTIF(IO)
               WRITE(LUNPOW,'(7(1PE13.5))')(OBSV(IX,IO)*1.E3,IX=1,3)
     &           ,SPECPOWT(IO)/1.0E6,SPECTOTI(IO)/1.E6,DUM1/1.E6
     &           ,SPECPOWTgraz(IO)/1.0e6
             ENDDO
           ENDDO
         else
           dum1=0.0d0
           do iobsv=1,nobsv
             write(lunpow,'(7(1pe13.5))')(obsv(ix,iobsv)*1.e3,ix=1,3)
     &         ,specpowt(iobsv)/1.0e6,spectoti(iobsv)/1.e6,dum1/1.e6
     &         ,SPECPOWTgraz(iobsv)/1.0e6
           enddo
         endif

         CLOSE(LUNPOW)

      ENDIF !IWFILPOW

      if (iphoton.ne.0.and.ecphoton.gt.0.0d0) call uout_photon

      IF(IHFREQ.NE.0) CALL HFREQ

      RETURN
      END
+DECK,SPLINE.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  2.13/09 08/03/2000  17.54.36  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.23  by  Michael Scheer
*-- Author : Michael Scheer
C************************************************************************
      SUBROUTINE SPLINE(X,Y,N,YP1,YPN,Y2)
+seq,gplhint.

      IMPLICIT NONE

      INTEGER I,NMAX,K,N
      DOUBLE PRECISION X,Y,Y2,U,UN,QN,YPN,P,YP1,SIG

      PARAMETER (NMAX=100)
      DIMENSION X(N),Y(N),Y2(N),U(NMAX)
      IF (YP1.GT..99E30) THEN
        Y2(1)=0.
        U(1)=0.
      ELSE
        Y2(1)=-0.5
        U(1)=(3./(X(2)-X(1)))*((Y(2)-Y(1))/(X(2)-X(1))-YP1)
      ENDIF
      DO 11 I=2,N-1
        SIG=(X(I)-X(I-1))/(X(I+1)-X(I-1))
        P=SIG*Y2(I-1)+2.
        Y2(I)=(SIG-1.)/P
        U(I)=(6.*((Y(I+1)-Y(I))/(X(I+1)-X(I))-(Y(I)-Y(I-1))
     *      /(X(I)-X(I-1)))/(X(I+1)-X(I-1))-SIG*U(I-1))/P
11    CONTINUE
      IF (YPN.GT..99E30) THEN
        QN=0.
        UN=0.
      ELSE
        QN=0.5
        UN=(3./(X(N)-X(N-1)))*(YPN-(Y(N)-Y(N-1))/(X(N)-X(N-1)))
      ENDIF
      Y2(N)=(UN-QN*U(N-1))/(QN*Y2(N-1)+1.)
      DO 12 K=N-1,1,-1
        Y2(K)=Y2(K)*Y2(K+1)+U(K)
12    CONTINUE
      RETURN
      END
+DECK,SPLINETB.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.47/07 14/04/2003  15.17.05  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  18.39.21  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.54.51  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.36  by  Michael Scheer
*-- Author : Michael Scheer
C**********************************************************************
      SUBROUTINE SPLINETB(X,Y,N,YP1,YPN,Y2)
+seq,gplhint.

C VERSION 06.07.1993

      IMPLICIT NONE

+SEQ,CMPARA.

      INTEGER N,J
      DOUBLE PRECISION  X(N),Y(N),Y2(N)
      DOUBLE PRECISION  C(NBTABP)
      DOUBLE PRECISION AA(NBTABP)
      DOUBLE PRECISION BB(NBTABP)
      DOUBLE PRECISION CC(NBTABP)

      DOUBLE PRECISION YP1,YPN

      Y2(1)=YP1
      Y2(N)=YPN

      IF (N.LT.3) RETURN

      C(1)=YP1
      C(N)=YPN

      BB(1)=1.D0
      CC(1)=0.D0

      DO J=2,N-1
          AA(J)=(X(J  )-X(J-1))/6.D0
          BB(J)=(X(J+1)-X(J-1))/3.D0
          CC(J)=(X(J+1)-X(J  ))/6.D0
          C(J)=(Y(J+1)-Y(J  ))/(X(J+1)-X(J  ))
     &          -(Y(J  )-Y(J-1))/(X(J  )-X(J-1))
      ENDDO !J

      DO J=2,N-1

          BB(J)=BB(J)-AA(J)*CC(J-1)
           C(J)= C(J)-AA(J)* C(J-1)
C030414          AA(J)=AA(J)-AA(J)*BB(J-1)

          CC(J)=CC(J)/BB(J)
           C(J)= C(J)/BB(J)
          BB(J)=1.D0

      ENDDO !J

      DO J=N-1,2,-1
         Y2(J)=C(J)-CC(J)*Y2(J+1)
      ENDDO

      RETURN
      END
+DECK,SPLINT.
*CMZ :  3.02/00 24/09/2014  13.51.08  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.66/19 07/06/2011  14.08.31  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  2.13/09 08/03/2000  17.55.40  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  15.14.32  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.54.55  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.23  by  Michael Scheer
*-- Author : Michael Scheer
C************************************************************************
      SUBROUTINE SPLINT(XA,YA,Y2A,N,X,Y)
+seq,gplhint.

      IMPLICIT NONE

      INTEGER N,KLO,KHI,K
      DOUBLE PRECISION XA,YA,Y2A,X,Y,H,A,B

      DIMENSION XA(*),YA(*),Y2A(*)

      IF(     XA(1).LT.XA(N).AND.(X.LT.XA(1).OR.X.GT.XA(N))
     &        .OR.
     &         XA(N).LT.XA(1).AND.(X.LT.XA(N).OR.X.GT.XA(1))) THEN
         STOP '***S/R SPLINT: X OUT OF RANGE ***'
      ENDIF

      KLO=1
      KHI=N
1     IF (KHI-KLO.GT.1) THEN
        K=(KHI+KLO)/2
        IF(XA(K).GT.X)THEN
          KHI=K
        ELSE
          KLO=K
        ENDIF
      GOTO 1
      ENDIF
      H=XA(KHI)-XA(KLO)
      IF (H.LE.0.) THEN
        WRITE(6,*) 'Bad XA input.'
        STOP
      ENDIF
      A=(XA(KHI)-X)/H
      B=(X-XA(KLO))/H
      Y=A*YA(KLO)+B*YA(KHI)+
     *      ((A**3-A)*Y2A(KLO)+(B**3-B)*Y2A(KHI))*(H**2)/6.
      RETURN
      END
+DECK,SPLINTB.
*CMZ :  4.00/11 17/05/2021  11.31.37  by  Michael Scheer
*CMZ :  4.00/07 10/07/2020  08.29.01  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.66/19 07/06/2011  14.08.31  by  Michael Scheer
*CMZ :  2.41/13 22/08/2002  17.16.36  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  2.13/10 25/03/2000  14.36.03  by  Michael Scheer
*CMZ :  2.11/00 11/05/99  18.02.35  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  15.14.32  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  18.40.22  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.36  by  Michael Scheer
*-- Author : Michael Scheer
C************************************************************************
      SUBROUTINE SPLINTB(N,X,Y)
+seq,gplhint.

      IMPLICIT NONE
      INTEGER N,KLO,KHI,K,KD
      DOUBLE PRECISION Y,X,H,A,B

+SEQ,CMPARA.
      DOUBLE PRECISION XA(NBTABP),YA(NBTABP),Y2A(NBTABP)
      COMMON/BTABC/XA,YA,Y2A

      DATA KLO/1/

      IF(     XA(1).LT.XA(N).AND.(X.LT.XA(1).OR.X.GT.XA(N))
     &  .OR.
     &  XA(N).LT.XA(1).AND.(X.LT.XA(N).OR.X.GT.XA(1)))
     &  STOP '***SR SPLINTB: X OUT OF RANGE ***'


      IF (X.GE.XA(KLO)) THEN

C HUNT UP
        KD=1
11      KHI=MIN(KLO+KD,N)
        IF (X.GT.XA(KHI)) THEN
          KD=2*KD
          KLO=KHI
          GOTO 11
        ENDIF

      ELSE    !(X.GE.XA(KLO))

C HUNT DOWN
        KD=1
        KHI=KLO
22      KLO=MAX(KHI-KD,1)
        IF (X.LT.XA(KLO)) THEN
          KD=2*KD
          KHI=KLO
          GOTO 22
        ENDIF

      ENDIF

1     IF (KHI-KLO.GT.1) THEN
        K=(KHI+KLO)/2
        IF(XA(K).GT.X)THEN
          KHI=K
        ELSE
          KLO=K
        ENDIF
        GOTO 1
      ENDIF

      H=XA(KHI)-XA(KLO)

      IF (H.LE.0.) THEN
        WRITE(6,*) 'Bad XA input.'
        STOP
      ENDIF

      A=(XA(KHI)-X)/H
      B=(X-XA(KLO))/H
      Y=A*YA(KLO)+B*YA(KHI)+
     &  (A*(A*A-1.0d0)*Y2A(KLO)+B*(B*b-1.0d0)*Y2A(KHI))*(H**2)/6.

      RETURN
      END
+DECK,SPLINTBz.
*CMZ :  4.00/11 17/05/2021  11.31.37  by  Michael Scheer
*CMZ :  3.01/03 19/03/2014  12.24.14  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.66/19 07/06/2011  14.08.31  by  Michael Scheer
*CMZ :  2.63/03 07/05/2008  14.17.54  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  15.14.32  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  18.41.04  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.55.02  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.59  by  Michael Scheer
*-- Author : Michael Scheer
C************************************************************************
      SUBROUTINE SPLINTBz(N,X,Y)
+seq,gplhint.

      INTEGER NOLD,N,KLO,KHI,KLOLD,K
      DOUBLE PRECISION Y,X,XA1OLD,XANOLD,H,A,B

+SEQ,CMPARA.
      DOUBLE PRECISION XA(NBTABP),YA(NBTABP),Y2A(NBTABP)

      COMMON/BTABCz/XA,YA,Y2A

      save klold,nold,xa1old,xanold

      DATA KLOLD/1/,NOLD/-99/
      DATA XA1OLD/-9999.D0/,XANOLD/-9999./

      IF(     XA(1).LT.XA(N).AND.(X.LT.XA(1).OR.X.GT.XA(N))
     &  .OR.
     &  XA(N).LT.XA(1).AND.(X.LT.XA(N).OR.X.GT.XA(1)))
     &  STOP '***SR SPLINTBz: X OUT OF RANGE ***'

      IF (NOLD.ne.N) then
        klo=1
      else IF (
     &    XA(1).EQ.XA1OLD
     &    .AND. XA(N).EQ.XANOLD
     &    .AND. X.GT.XA(KLOLD)
     &    ) THEN
        KLO=KLOLD
      ELSE
        KLO=1
      ENDIF

      IF (X.LT.XA(KLO+1)) THEN
      KHI=KLO+1
      GOTO 2
      ENDIF

      KHI=N
1     IF (KHI-KLO.GT.1) THEN
        K=(KHI+KLO)/2
        IF(XA(K).GT.X)THEN
          KHI=K
        ELSE
          KLO=K
        ENDIF
      GOTO 1
      ENDIF

2     H=XA(KHI)-XA(KLO)
      IF (H.LE.0.) THEN
        WRITE(6,*) 'Bad XA input.'
        STOP
      ENDIF
      A=(XA(KHI)-X)/H
      B=(X-XA(KLO))/H
      Y=A*YA(KLO)+B*YA(KHI)+
     *      ((A**3-A)*Y2A(KLO)+(B**3-B)*Y2A(KHI))*(H**2)/6.

      KLOLD=KLO
      NOLD=N
      XA1OLD=XA(1)
      XANOLD=XA(N)


      RETURN
      END
+DECK,SPLINZY.
*CMZ :  4.00/16 10/09/2022  10.11.26  by  Michael Scheer
*CMZ :  4.00/13 06/11/2021  14.55.44  by  Michael Scheer
*CMZ :  3.07/00 14/03/2019  15.09.16  by  Michael Scheer
*CMZ :  3.01/03 19/03/2014  12.24.14  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.69/00 24/10/2012  15.43.29  by  Michael Scheer
*CMZ :  2.66/19 07/06/2011  14.08.31  by  Michael Scheer
*CMZ :  2.63/05 22/07/2009  07.43.29  by  Michael Scheer
*CMZ :  2.63/03 07/05/2008  14.17.54  by  Michael Scheer
*CMZ :  2.48/04 12/03/2004  15.40.31  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.33  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  16.33.46  by  Michael Scheer
*CMZ : 00.01/04 28/11/94  18.35.44  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  18.42.47  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.57  by  Michael Scheer
*-- Author : Michael Scheer
C***************************************************************
      SUBROUTINE SPLINZY(N,XIN,Y,XA,YA,Y2A,KLO)
+seq,gplhint.

      IMPLICIT NONE
      INTEGER NOLD,N,KLO,KHI,KLOLD,K
      DOUBLE PRECISION XIN,Y,X,XA1OLD,XANOLD,H,A,B

      save klold,nold,xa1old,xanold

+SEQ,CMPARA.

+SELF,IF=HPUX,TRUE64.
      DOUBLE PRECISION XA(NDOBSVZP+NDOBSVYP)
     &      ,YA(NDOBSVZP+NDOBSVYP)
     &      ,Y2A(NDOBSVZP+NDOBSVYP)
+SELF.

+SELF,IF=VMS,LINUX,WINDOWS.
      INTEGER max
      DOUBLE PRECISION XA(*)
     &      ,YA(*)
     &      ,Y2A(*)
+SELF.

      DATA KLOLD/0/
      DATA NOLD/-99/
      DATA XA1OLD/-9999.D0/,XANOLD/-9999./

      IF (DABS(XIN-XA(1)).LT.1D-15) THEN
          X=XA(1)
      ELSE IF (DABS(XIN-XA(N)).LT.1D-15) THEN
          X=XA(N)
      ELSE
          X=XIN
      ENDIF

      IF(     XA(1).LT.XA(N).AND.(X.LT.XA(1).OR.X.GT.XA(N))
     &        .OR.
     &         XA(N).LT.XA(1).AND.(X.LT.XA(N).OR.X.GT.XA(1))) THEN
          WRITE(6,*) '*** ERROR IN SPLINZY: ARGUMENT OUT OF RANGE ***'
          STOP
      ENDIF

      IF (NOLD.EQ.N) THEN
        IF(
     &      XA(1).EQ.XA1OLD
     &      .AND. XA(N).EQ.XANOLD
     &      .AND. X.GT.XA(KLOLD)
     &      ) THEN
          KLO=KLOLD
        ELSE
          KLO=1
        ENDIF
      ELSE
        KLO=1
      ENDIF

      IF (X.LT.XA(KLO+1)) THEN
        KHI=KLO+1
        GOTO 2
      ENDIF

      KHI=N
1     IF (KHI-KLO.GT.1) THEN
        K=(KHI+KLO)/2
        IF(XA(K).GT.X)THEN
          KHI=K
        ELSE
          KLO=K
        ENDIF
      GOTO 1
      ENDIF

2     H=XA(KHI)-XA(KLO)
      IF (H.LE.0.) THEN
        WRITE(6,*) '*** ERROR IN SPLINZY: BAD XA INPUT'
        STOP
      ENDIF
      A=(XA(KHI)-X)/H
      B=(X-XA(KLO))/H
      Y=A*YA(KLO)+B*YA(KHI)+
     &  ((A**3-A)*Y2A(KLO)+(B**3-B)*Y2A(KHI))*(H**2)/6.0d0

      KLOLD=KLO
      NOLD=N
      XA1OLD=XA(1)
      XANOLD=XA(N)

      RETURN
      END
+DECK,SPLITMAGCYL.
*CMZ :  2.41/10 14/08/2002  17.34.02  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  1.03/06 06/08/98  18.01.12  by  Michael Scheer
*CMZ :  1.00/00 03/06/97  13.54.04  by  Michael Scheer
*CMZ : 00.00/04 07/09/95  10.59.03  by  Michael Scheer
*-- Author :    Michael Scheer   05/09/95

      SUBROUTINE SPLITMAGCYL
     &  (ZLEN,BC,RHO,CENX,CENY,DZ0,THEROT,NCYL,LUNMAG,FILENAME)
+seq,gplhint.

      IMPLICIT NONE

+SELF,IF=LINUX.
      EXTERNAL DCOSD,DSIND
      DOUBLE PRECISION DCOSD,DSIND
+SELF.

      CHARACTER(72) FILENAME

      INTEGER I,NCYL,LUNMAG

      DOUBLE PRECISION RHO,CENY,CENX,THETA,Y0,Y,RHO2,BCSIN,BCCOS
      DOUBLE PRECISION THEROT,PHI,BC,XLEN,YLEN,ZLEN,DX0,DY0,DZ0
      DOUBLE PRECISION DX,X1,X2,DY,Y1,Y2

      DATA THETA/0.0D0/
      DATA PHI/0.0D0/

      BCCOS=BC*DCOSD(THEROT)
      BCSIN=BC*DSIND(THEROT)

      OPEN(UNIT=LUNMAG,FILE=FILENAME,STATUS='NEW')

      WRITE(LUNMAG,*)2*NCYL

      RHO2=RHO*RHO
      DY=2.D0*RHO/NCYL
      Y0=CENY-RHO
      DX0=CENX
      YLEN=DY
      DO I=1,NCYL
          Y2=Y0+DY*I
          Y1=Y2-DY
          Y=(Y2+Y1)/2.D0
          DX=DSQRT(RHO2-(Y-CENY)**2)
          X1=CENX-DX
          X2=CENX+DX
          XLEN=2.D0*DX
          DY0=Y
          WRITE(LUNMAG,1000)XLEN,YLEN,ZLEN
          WRITE(LUNMAG,1000)THETA,PHI,BCCOS
          WRITE(LUNMAG,1000)DX0,DY0,DZ0
          WRITE(LUNMAG,1000)XLEN,YLEN,ZLEN
          WRITE(LUNMAG,1000)THETA+90.D0,PHI,BCSIN
          WRITE(LUNMAG,1000)DX0,DY0,DZ0
      ENDDO !NCYL

      CLOSE(LUNMAG)

      RETURN

1000  FORMAT (3(1PD25.13))

      END
+DECK,STOKSUM.
*CMZ :  4.00/13 12/11/2021  11.33.50  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.16/08 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  2.13/03 12/01/2000  14.27.55  by  Michael Scheer
*CMZ : 00.01/09 01/09/95  16.15.29  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  18.44.15  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.55.09  by  Michael Scheer
*CMZ : 00.00/03 29/04/94  10.19.33  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.24  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE STOKSUM
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SELF.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,PHYCON.


      INTEGER IFREQ,ISTOK,IOBSV,IS,ICAL

      REAL*4 RAT(4)
      DOUBLE PRECISION DZ,DY
      DOUBLE PRECISION SUM(4),POL

      DATA ICAL/0/

      IF (IPIN.EQ.0) RETURN

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SR STOKSUM:'
      WRITE(LUNGFO,*)

         IF (IPINCIRC.NE.0.AND.ICAL.NE.1) THEN

             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)'*** WARNING SR STOKSUM ***'
             WRITE(LUNGFO,*)
     &'USE OF FLAG IPINCIRC NOT RECOMMENDED FOR THIS ROUTINE SINCE'
             WRITE(LUNGFO,*)
     &'SHAPE OF CIRCULARE PINHOLE IS TAKEN INTO ACCOUNT ONLY VERY ROUGHLY'
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
C            WRITE(6,*)
C            WRITE(6,*)
C            WRITE(6,*)'*** WARNING SR STOKSUM ***'
C            WRITE(6,*)
C     &'USE OF FLAG IPINCIRC NOT RECOMMENDED FOR THIS ROUTINE SINCE'
C            WRITE(6,*)
C     &'SHAPE OF CIRCULARE PINHOLE IS TAKEN INTO ACCOUNT ONLY VERY ROUGHLY'
C            WRITE(6,*)
C            WRITE(6,*)
             ICAL=1
         ENDIF !IPINCIRC

      WRITE(LUNGFO,*)
     & '     Photon energy, S0,S1/S0,S2/S0,S3/S0 and polarization simply summed up:'
      IF (IW_BLEN.NE.0) THEN
        WRITE(LUNGFO,*)'     (and ratio of spline and summation results)'
        WRITE(6,*)'     Ratio of spline and summation results:'
        write(6,*)
      ENDIF
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

         DO IFREQ=1,NFREQ

         DO ISTOK=1,4

             SUM(ISTOK)=0.0

         DO IOBSV=1,NOBSV

             IF (IPINCIRC.EQ.0) THEN

            IF (
     &           DABS(OBSV(2,IOBSV)-PINCEN(2))-PINH/2.D0.LT.1.D-10
     &                      .AND.
     &           DABS(OBSV(3,IOBSV)-PINCEN(3))-PINW/2.D0.LT.1.D-10
     &                      ) THEN

                  IF(DABS(
     &                           DABS(OBSV(3,IOBSV)-PINCEN(3))
     &                           -PINW/2.D0).LT.1.D-10) THEN

                DZ=OBSVDZ/2.D0

                  ELSE

                     DZ=OBSVDZ

                  ENDIF

                  IF(DABS(
     &                           DABS(OBSV(2,IOBSV)-PINCEN(2))
     &                           -PINH/2.D0).LT.1.D-10) THEN

                DY=OBSVDY/2.D0

                  ELSE

                    DY=OBSVDY

                  ENDIF

+SELF,IF=-NEWWAVE.
                  SUM(ISTOK)=SUM(ISTOK)+STOKES(ISTOK,IOBSV,IFREQ)*
+SELF,IF=NEWWAVE.
                  SUM(ISTOK)=SUM(ISTOK)+STOKES(ISTOK,IOBSV+NOBSV*(IFREQ-1))*
+SELF.
     &                                   DZ*DY

            ENDIF   !OBSV

             ELSE    !IPINCIR

            IF (
     &                      (OBSV(2,IOBSV)-PINCEN(2))**2
     &                     +(OBSV(3,IOBSV)-PINCEN(3))**2
     &                       -PINR**2.LT.1.D-10) THEN

                  DZ=OBSVDZ
                  DY=OBSVDY
+SELF,IF=-NEWWAVE.
                  SUM(ISTOK)=SUM(ISTOK)+STOKES(ISTOK,IOBSV,IFREQ)*
+SELF,IF=NEWWAVE.
                  SUM(ISTOK)=SUM(ISTOK)+STOKES(ISTOK,IOBSV+NOBSV*(IFREQ-1))*
+SELF.
     &                                   DY*DZ

                 ENDIF  !OBSV

             ENDIF   !IPINCIR

         ENDDO !NOBSV
         ENDDO !ISTOK


         IF (SUM(1).EQ.0.0) SUM(1)=-9999.
         POL=SQRT(SUM(2)**2+SUM(3)**2+
     &               SUM(4)**2)/SUM(1)

         IF (IUNIT.EQ.0)       !260194
     &      WRITE(LUNGFO,2584)SNGL(FREQ(IFREQ))
     &                ,SUM(1),(SUM(IS)/SUM(1),IS=2,4),POL
         IF (IUNIT.NE.0) !260194
     &      WRITE(LUNGFO,2584)SNGL(WELLEN(IFREQ))
     &                ,SUM(1),(SUM(IS)/SUM(1),IS=2,4),POL
2584     FORMAT('     ',6(1PE12.4))

      IF (IW_BLEN.NE.0) THEN
       DO IS=1,4
       RAT(IS)=9999.
       IF (SUM(IS).NE.0.D0) RAT(IS)=WSTOKES(IS,IFREQ)/SUM(IS)
       ENDDO !IS
       WRITE(LUNGFO,2584)SNGL(FREQ(IFREQ)),(RAT(IS),IS=1,4)
       WRITE(6,2584)SNGL(FREQ(IFREQ)),(RAT(IS),IS=1,4)
      ENDIF !IW_BLEN

         ENDDO !IFREQ

      RETURN
      END
+DECK,STOKSUMF.
*CMZ :  4.00/13 12/11/2021  11.33.50  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.16/08 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  2.13/03 12/01/2000  16.31.33  by  Michael Scheer
*CMZ : 00.01/09 01/09/95  14.02.50  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  18.45.21  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.55.14  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.28  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE STOKSUMF
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SELF.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,PHYCON.


      INTEGER IFREQ,ISTOK,IOBSV,IS,ICAL

      REAL*4 RAT(4)
      DOUBLE PRECISION DZ,DY
      DOUBLE PRECISION SUM(4),POL

      DATA ICAL/0/

      IF (IPIN.EQ.0) RETURN

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SR STOKSUMF:'
      WRITE(LUNGFO,*)

         IF (IPINCIRC.NE.0.AND.ICAL.NE.1) THEN

             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)'*** WARNING SR STOKSUMF ***'
             WRITE(LUNGFO,*)
     &'USE OF FLAG IPINCIRC NOT RECOMMENDED FOR THIS ROUTINE SINCE'
             WRITE(LUNGFO,*)
     &'SHAPE OF CIRCULARE PINHOLE IS TAKEN INTO ACCOUNT ONLY VERY ROUGHLY'
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
C            WRITE(6,*)
C            WRITE(6,*)
C            WRITE(6,*)'*** WARNING SR STOKSUMF ***'
C            WRITE(6,*)
C     &'USE OF FLAG IPINCIRC NOT RECOMMENDED FOR THIS ROUTINE SINCE'
C            WRITE(6,*)
C     &'SHAPE OF CIRCULARE PINHOLE IS TAKEN INTO ACCOUNT ONLY VERY ROUGHLY'
C            WRITE(6,*)
C            WRITE(6,*)
             ICAL=1
         ENDIF !IPINCIRC

      WRITE(LUNGFO,*)
     & '     Photon energy, S0,S1/S0,S2/S0,S3/S0 and polarization simply summed up'
      WRITE(LUNGFO,*)
     & '     (with emittance effects):'
      IF (IW_BLENF.NE.0) THEN
        WRITE(LUNGFO,*)'     (and ratio of spline and summation results)'
        WRITE(6,*)'     Ratio of spline and summation results:'
        write(6,*)
      ENDIF
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

         DO IFREQ=1,NFREQ

         DO ISTOK=1,4

             SUM(ISTOK)=0.0

         DO IOBSV=1,NOBSV

             IF (IPINCIRC.EQ.0) THEN

            IF (
     &           DABS(OBSV(2,IOBSV)-PINCEN(2))-PINH/2.D0.LT.1.D-10
     &                      .AND.
     &           DABS(OBSV(3,IOBSV)-PINCEN(3))-PINW/2.D0.LT.1.D-10
     &                      ) THEN

                  IF(DABS(
     &                           DABS(OBSV(3,IOBSV)-PINCEN(3))
     &                           -PINW/2.D0).LT.1.D-10) THEN

                DZ=OBSVDZ/2.D0

                  ELSE

                     DZ=OBSVDZ

                  ENDIF

                  IF(DABS(
     &                           DABS(OBSV(2,IOBSV)-PINCEN(2))
     &                           -PINH/2.D0).LT.1.D-10) THEN

                DY=OBSVDY/2.D0

                  ELSE

                    DY=OBSVDY

                  ENDIF

+SELF,IF=-NEWWAVE.
                  SUM(ISTOK)=SUM(ISTOK)+STOKESF(ISTOK,IOBSV,IFREQ)*DZ*DY
+SELF,IF=NEWWAVE.
                  SUM(ISTOK)=SUM(ISTOK)+STOKESF(ISTOK,IOBSV+NOBSV*(IFREQ-1))*DZ*DY
+SELF.

            ENDIF   !OBSV

             ELSE    !IPINCIR

            IF (
     &                      (OBSV(2,IOBSV)-PINCEN(2))**2
     &                     +(OBSV(3,IOBSV)-PINCEN(3))**2
     &                       -PINR**2.LT.1.D-10) THEN

                  DZ=OBSVDZ
                  DY=OBSVDY
+SELF,IF=-NEWWAVE.
                  SUM(ISTOK)=SUM(ISTOK)+STOKESF(ISTOK,IOBSV,IFREQ)*DZ*DY
+SELF,IF=NEWWAVE.
                  SUM(ISTOK)=SUM(ISTOK)+STOKESF(ISTOK,IOBSV+NOBSV*(IFREQ-1))*DZ*DY
+SELF.

                 ENDIF  !OBSV

             ENDIF   !IPINCIR

         ENDDO !NOBSV
         ENDDO !ISTOK


         IF (SUM(1).EQ.0.0) SUM(1)=-9999.
         POL=SQRT(SUM(2)**2+SUM(3)**2+
     &               SUM(4)**2)/SUM(1)

         IF (IUNIT.EQ.0)       !260194
     &      WRITE(LUNGFO,2584)SNGL(FREQ(IFREQ))
     &                ,SUM(1),(SUM(IS)/SUM(1),IS=2,4),POL
         IF (IUNIT.NE.0) !260194
     &      WRITE(LUNGFO,2584)SNGL(WELLEN(IFREQ))
     &                ,SUM(1),(SUM(IS)/SUM(1),IS=2,4),POL
2584     FORMAT('     ',6(1PE12.4))

        IF (IW_BLENF.NE.0) THEN
         DO IS=1,4
         RAT(IS)=9999.
         IF (SUM(IS).NE.0.D0) RAT(IS)=WSTOKESF(IS,IFREQ)/SUM(IS)
         ENDDO !IS
         WRITE(LUNGFO,2584)SNGL(FREQ(IFREQ)),(RAT(IS),IS=1,4)
         WRITE(6,2584)SNGL(FREQ(IFREQ)),(RAT(IS),IS=1,4)
        ENDIF   !IW_BLENF

         ENDDO !IFREQ

      RETURN
      END
+DECK,SYNC_SPEC.
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.41/10 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  14.22.46  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.33  by  Michael Scheer
*CMZ :  2.13/03 17/12/99  11.43.31  by  Michael Scheer
*CMZ :  2.13/00 15/11/99  17.43.14  by  Michael Scheer
*CMZ :  1.03/03 23/02/98  14.54.49  by  Michael Scheer
*CMZ :  1.03/02 23/02/98  14.30.43  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  18.47.22  by  Michael Scheer
*CMZ : 00.00/07 25/05/94  17.53.18  by  Michael Scheer
*-- Author :    Michael Scheer   18/05/94
      SUBROUTINE SYNC_SPEC
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SELF.

C     ROUTINE TO READ FILE OF SPECTRUM OF SYNC AND TO CONVERT TO DOSE
C     FILE: DES:SYNC_SP.DAT

C     MODIFICATION: IDESYNC_N.EQ.-9999. SIMPLE VERSION FOR EGS4-OUTPUT

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,PHYCON.

      CHARACTER(65) COMLAT,COMMAG
      INTEGER NSPEC,NBIN,IBIN,JSPEC,ISEG,ILAY,ISEL
      REAL*4 CORR,EDUM,CDUM

      IF (IDESYNC.NE.-9999) THEN

      IPIN=0
      IHPIN=0
      NOBSV=1
      NOBSVZ=1
      NOBSVY=1
      OBS1X=9999.
      OBS1Y=9999.
      OBS1Z=9999.
      OBSV(1,1)=OBS1X
      OBSV(2,1)=OBS1Y
      OBSV(3,1)=OBS1Z
      OBSVZ(1)=OBS1Z
      OBSVY(1)=OBS1Y

      WRITE(6,*)' '
      WRITE(6,*)'      *** SR SYNC_SPEC:'
      WRITE(6,*)' '

      OPEN(UNIT=90,FILE='DES:SYNC_SP.DAT',STATUS='OLD')
          READ(90,'(1A65)')COMLAT
          READ(90,'(1A65)')COMMAG
          READ(90,*)EDUM,CDUM
          IF (DABS(DMYENERGY-EDUM)/EDUM.GT.1.D-3
     &        .OR.
     &        DABS(DMYCUR-CDUM)/CDUM.GT.1.D-3) THEN
              WRITE(6,*)' '
              WRITE(6,*)
     &'*** WARNING SR SYNC_SPEC: ENERGY OR CURRENT ON DATA FILE NOT CONSISTENT WITH ORIGINAL VALUE ON FILE WAVE.IN'
              WRITE(6,*)' OLD VALUES OVERWRITTEN'
              WRITE(6,*)' '
              WRITE(LUNGFO,*)' '
              WRITE(LUNGFO,*)
     &'*** WARNING SR SYNC_SPEC: ENERGY OR CURRENT ON DATA FILE NOT CONSISTENT WITH ORIGINAL VALUE ON FILE WAVE.IN'
              WRITE(LUNGFO,*)' OLD VALUES OVERWRITTEN'
              WRITE(LUNGFO,*)' '
              DMYENERGY=EDUM
              DMYCUR=CDUM
          ENDIF
          DMYGAMMA=DMYENERGY/EMASSG1
          READ(90,*)CORR,BANWID
          READ(90,*)NSPEC,NBIN
          WRITE(6,*)' '
          WRITE(6,*)' Comments on file DES:SYNC_SP.DAT:'
          WRITE(6,*)COMLAT
          WRITE(6,*)COMMAG
          WRITE(6,*)' '
          IF (IDESYNC.LT.0) THEN
100         WRITE(6,*)' Number of spectra:',NSPEC
            WRITE(6,*)' Which one do you want?'
            READ(5,*)ISEL
            IF (ISEL.GT.NSPEC.OR.ISEL.LE.0) GOTO 100
200         WRITE(6,*)' Enter area for dose calculation [mm**2]:'
            READ(5,*)AREAM2
            IF (AREAM2.LE.0.) GOTO 200
            AREAM2=AREAM2*1.E-6
          ELSE
            ISEL=IDESYNC
            IF (ISEL.GT.NSPEC) THEN
               WRITE(6,*)' '
               WRITE(6,*)
     &' *** ERROR IN SYNC_SP: IDESYNC OUT OF RANGE, CHECK INPUT FILE *** '
               WRITE(6,*)' '
               WRITE(LUNGFO,*)' '
               WRITE(LUNGFO,*)
     &         ' *** ERROR IN SYNC_SP: IDESYNC OR ISEL OUT OF RANGE ***'
               WRITE(LUNGFO,*)' '
               WRITE(LUNGFO,*)' '
               STOP
            ENDIF
          ENDIF
          DO JSPEC=1,ISEL
          READ(90,*)ISEG,ILAY
          WRITE(6,*)
          WRITE(6,*)' SEGMENT, LAYER:',ISEG,ILAY
          WRITE(6,*)
          DO IBIN=1,NBIN
             IF (IBIN.GT.NDFREQP) THEN
                WRITE(6,*)
     &          '*** SR SYNC_SP: DIMENSION NDFREQP EXCEEDED ***'
                STOP
             ENDIF
+SELF,IF=-NEWWAVE.
             READ(90,*)FREQ(IBIN),SPEC(1,1,IBIN)
             FREQ(IBIN)=FREQ(IBIN)*1000.
             SPEC(1,1,IBIN)=SPEC(1,1,IBIN)/ECHARGE1/AREAM2
+SELF,IF=NEWWAVE.
            ILIOBFR=1+NSOURCE*NOBSV*(IBIN-1)
             READ(90,*)FREQ(IBIN),SPEC(ILIOBFR)
             FREQ(IBIN)=FREQ(IBIN)*1000.
             SPEC(ILIOBFR)=SPEC(ILIOBFR)/ECHARGE1/AREAM2
+SELF.
          ENDDO !IBIN
          ENDDO   !JSPEC
      CLOSE(90)
      NFREQ=NBIN

      WRITE(LUNGFO,*)' '
      WRITE(LUNGFO,*)' '
      WRITE(LUNGFO,*)'      *** SR SYNC_SPEC:'
      WRITE(LUNGFO,*)' '

      WRITE(LUNGFO,*)' '
      WRITE(LUNGFO,*)'      Comments on file DES:SYNC_SP.DAT:'
      WRITE(LUNGFO,*)'      ',COMLAT
      WRITE(LUNGFO,*)'      ',COMMAG
      WRITE(LUNGFO,*)' '
      WRITE(LUNGFO,*)'      BEAM ENERGY, CURRENT:',EDUM,CDUM
      WRITE(LUNGFO,*)'      SEGMENT, LAYER:      ',ISEG,ILAY
      WRITE(LUNGFO,*)'      AREA [mm**2]:        ',SNGL(AREAM2)*1.E6
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

      ELSE    !IDESYNC.EQ.-9999

      IPIN=0
      IHPIN=0
      NOBSV=1
      NOBSVZ=1
      NOBSVY=1
      OBS1X=9999.
      OBS1Y=9999.
      OBS1Z=9999.
      OBSV(1,1)=OBS1X
      OBSV(2,1)=OBS1Y
      OBSV(3,1)=OBS1Z
      OBSVZ(1)=OBS1Z
      OBSVY(1)=OBS1Y

      WRITE(6,*)' '
      WRITE(6,*)'      *** SR SYNC_SPEC:'
      WRITE(6,*)' '

      OPEN(UNIT=90,FILE='KEK:KEK_EGS4_DOSE.WAV',STATUS='OLD')

          READ(90,'(1A65)')COMLAT
          READ(90,*)EDUM,CDUM

          IF (DABS(DMYENERGY-EDUM)/EDUM.GT.1.D-3
     &        .OR.
     &        DABS(DMYCUR-CDUM)/CDUM.GT.1.D-3) THEN
              WRITE(6,*)' '
              WRITE(6,*)
     &'*** WARNING SR SYNC_SPEC: ENERGY OR CURRENT ON DATA FILE NOT CONSISTENT WITH ORIGINAL VALUE ON FILE WAVE.IN'
              WRITE(6,*)' OLD VALUES OVERWRITTEN'
              WRITE(6,*)' '
              WRITE(LUNGFO,*)' '
              WRITE(LUNGFO,*)
     &'*** WARNING SR SYNC_SPEC: ENERGY OR CURRENT ON DATA FILE NOT CONSISTENT WITH ORIGINAL VALUE ON FILE WAVE.IN'
              WRITE(LUNGFO,*)' OLD VALUES OVERWRITTEN'
              WRITE(LUNGFO,*)' '
              DMYENERGY=EDUM
              DMYCUR=CDUM
          ENDIF

          DMYGAMMA=DMYENERGY/EMASSG1
          CORR=1.D0
        BANWID=1.D0
          NSPEC=1
          ISEL=1

          READ(90,*)NBIN,AREAM2
        AREAM2=AREAM2*1.E-4
           WRITE(6,*)' '
           WRITE(6,*)' Comments on file KEK:KEK_EGS4_DOSE.WAV:'
           WRITE(6,*)COMLAT
           WRITE(6,*)' '

             IF (IBIN.GT.NDFREQP) THEN
                WRITE(6,*)
     &          '*** SR SYNC_SP: DIMENSION NDFREQP EXCEEDED ***'
                STOP
             ENDIF

          DO IBIN=1,NBIN
+SELF,IF=-NEWWAVE.
             READ(90,*)FREQ(IBIN),SPEC(1,1,IBIN)
             FREQ(IBIN)=FREQ(IBIN)*1000.
             SPEC(1,1,IBIN)=SPEC(1,1,IBIN)/AREAM2
+SELF,IF=NEWWAVE.
            ILIOBFR=1+NSOURCE*NOBSV*(IBIN-1)
             READ(90,*)FREQ(IBIN),SPEC(ILIOBFR)
             FREQ(IBIN)=FREQ(IBIN)*1000.
             SPEC(ILIOBFR)=SPEC(ILIOBFR)/AREAM2
+SELF.
          ENDDO !IBIN

      CLOSE(90)
      NFREQ=NBIN

      WRITE(LUNGFO,*)' '
      WRITE(LUNGFO,*)' '
      WRITE(LUNGFO,*)'      *** SR SYNC_SPEC:'
      WRITE(LUNGFO,*)' '

      WRITE(LUNGFO,*)' '
      WRITE(LUNGFO,*)'      Comments on file KEK:KEK_EGS4_DOSE.WAV:'
      WRITE(LUNGFO,*)'      ',COMLAT
      WRITE(LUNGFO,*)' '
      WRITE(LUNGFO,*)'      BEAM ENERGY, CURRENT:',EDUM,CDUM
      WRITE(LUNGFO,*)'      AREA [mm**2]:        ',SNGL(AREAM2)*1.E6
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

      ENDIF   !IDESYNC.EQ.-9999

      RETURN
      END
+DECK,TIME_SPLINE_INTER.
*CMZ :  3.02/00 24/09/2014  13.51.08  by  Michael Scheer
*CMZ :  3.01/03 19/03/2014  12.24.14  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.66/19 07/06/2011  14.08.31  by  Michael Scheer
*CMZ :  2.63/03 07/05/2008  14.17.54  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.33  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  2.10/01 16/02/99  15.25.41  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  15.14.32  by  Michael Scheer
*CMZ :  1.00/00 06/08/97  17.48.45  by  Michael Scheer
*CMZ : 00.01/08 22/06/95  10.39.53  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  10.39.41  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.50  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE TIME_SPLINE_INTER(XA,YA,Y2A,N,X,Y,MODE,ICOUNT)
+seq,gplhint.

C---  INTERPOLATES Y(X) VIA SPLINE

C--   INPUT:

C-       N: NUMBER OF X,Y-VALUES
C-       XA:   ARRAY OF X-VALUES
C-       YA:   ARRAY OF Y-VALUES
C-       YA2:  ARRAY SPLINE COEFFICIENTS
C-       X: Y(X) IS CALCULATED
C-       MODE: CONTROL FLAG:
C-             MODE.GE.0: USE VALUES OF LAST CALL TO START WITH
C-             MODE.LT.0: NEW INITIALIZATION

C--   OUTPUT:

C-       Y: Y(X) IS CALCULATED
C-  ICOUNT: COUNTER TO CHECK CALLING

      IMPLICIT NONE

      INTEGER NOLD,N,KLO,KHI,KLOLD,K,MODE
      INTEGER ICOUNT

      DOUBLE PRECISION Y,X,XA1OLD,XANOLD,H,A,B
      save klold,nold,xa1old,xanold

      DOUBLE PRECISION XA(*),YA(*),Y2A(*)

      DATA KLOLD/1/,NOLD/-99/
      DATA XA1OLD/-9999.D0/,XANOLD/-9999./

      ICOUNT=ICOUNT+1

      IF(     XA(1).LT.XA(N).AND.(X.LT.XA(1).OR.X.GT.XA(N))
     &    .OR.
     &    XA(N).LT.XA(1).AND.(X.LT.XA(N).OR.X.GT.XA(1))) THEN
        STOP '***SR TIME_SPLINE_INTER: X OUT OF RANGE ***'
      ENDIF

      IF ( MODE.GE.0.AND.NOLD.EQ.N) THEN
        IF (XA(1).EQ.XA1OLD
     &      .AND. XA(N).EQ.XANOLD
     &      .AND. X.GT.XA(KLOLD)
     &      ) THEN
          KLO=KLOLD
        ELSE
          KLO=1
        ENDIF
      ELSE
        KLO=1
      ENDIF

      IF (X.LT.XA(KLO+1)) THEN
      KHI=KLO+1
      GOTO 2
      ENDIF

      KHI=N
1     IF (KHI-KLO.GT.1) THEN
        K=(KHI+KLO)/2
        IF(XA(K).GT.X)THEN
          KHI=K
        ELSE
          KLO=K
        ENDIF
      GOTO 1
      ENDIF

2     H=XA(KHI)-XA(KLO)

      IF (H.LE.0.) THEN
        WRITE(6,*) '*** ERROR IN TIME_SPLINE_INTER: BAD INPUT ***'
        STOP
      ENDIF

      A=(XA(KHI)-X)/H
      B=(X-XA(KLO))/H
      Y=A*YA(KLO)+B*YA(KHI)+
     *      ((A**3-A)*Y2A(KLO)+(B**3-B)*Y2A(KHI))*(H**2)/6.

      KLOLD=KLO
      NOLD=N
      XA1OLD=XA(1)
      XANOLD=XA(N)

      RETURN
      END
+DECK,track.
*CMZ :  4.00/11 22/11/2020  13.40.46  by  Michael Scheer
*CMZ :  3.07/00 04/03/2019  18.43.21  by  Michael Scheer
*CMZ :  3.06/00 21/01/2019  12.37.35  by  Michael Scheer
*CMZ :  3.05/04 28/06/2018  09.36.14  by  Michael Scheer
*CMZ :  3.03/04 18/12/2017  11.38.05  by  Michael Scheer
*CMZ :  3.02/00 27/08/2014  16.23.17  by  Michael Scheer
*CMZ :  3.01/06 20/06/2014  16.35.06  by  Michael Scheer
*CMZ :  3.01/00 26/06/2013  16.44.13  by  Michael Scheer
*CMZ :  3.00/01 28/03/2013  09.49.39  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.10.30  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.69/00 25/10/2012  15.53.04  by  Michael Scheer
*CMZ :  2.67/05 15/05/2012  14.54.44  by  Michael Scheer
*CMZ :  2.67/02 03/05/2012  14.14.09  by  Michael Scheer
*CMZ :  2.66/13 03/06/2010  08.58.45  by  Michael Scheer
*CMZ :  2.66/00 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.65/02 28/09/2009  12.44.41  by  Michael Scheer
*CMZ :  2.64/00 14/08/2009  14.46.01  by  Michael Scheer
*CMZ :  2.63/05 12/08/2009  14.40.36  by  Michael Scheer
*CMZ :  2.61/02 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.59/01 24/01/2007  13.53.39  by  Michael Scheer
*CMZ :  2.57/05 10/01/2007  13.38.27  by  Michael Scheer
*CMZ :  2.57/02 30/11/2005  11.58.01  by  Michael Scheer
*CMZ :  2.54/07 16/06/2005  11.40.58  by  Michael Scheer
*CMZ :  2.53/04 09/02/2005  11.05.58  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  10.48.09  by  Michael Scheer
*CMZ :  2.52/08 14/10/2004  14.52.40  by  Michael Scheer
*CMZ :  2.50/00 16/04/2004  09.24.47  by  Michael Scheer
*CMZ :  2.47/12 03/07/2003  09.48.54  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  11.09.32  by  Michael Scheer
*CMZ :  2.16/08 31/10/2000  17.33.47  by  Michael Scheer
*CMZ :  2.16/06 27/08/2000  19.50.51  by  Michael Scheer
*CMZ :  2.16/05 28/07/2000  17.03.57  by  Michael Scheer
*CMZ :  2.16/04 19/07/2000  10.39.46  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  2.13/10 23/03/2000  13.09.47  by  Michael Scheer
*CMZ :  2.13/11 22/03/2000  15.55.53  by  Michael Scheer
*CMZ :  2.12/01 08/06/99  15.38.34  by  Michael Scheer
*CMZ :  2.12/00 02/06/99  13.56.19  by  Michael Scheer
*CMZ :  2.11/00 11/05/99  15.47.07  by  Michael Scheer
*CMZ :  2.10/01 17/02/99  14.03.33  by  Michael Scheer
*CMZ :  1.04/00 11/12/98  10.40.37  by  Michael Scheer
*CMZ :  1.00/00 11/07/97  15.11.58  by  Michael Scheer
*CMZ : 00.01/10 16/07/96  14.53.50  by  Michael Scheer
*CMZ : 00.01/09 11/04/96  17.41.50  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  09.51.12  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.41.55  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.31  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE TRACK(X1,Y1,Z1,VX1,VY1,VZ1,
     &  XF0,YF0,ZF0,EWSFX,EWSFY,EWSFZ,
     &  X2,Y2,Z2,VX2,VY2,VZ2,DTIM,BSHIFT,GAMMA0,GAMMAL)
+seq,gplhint.

+SELF,IF=F90.
+SEQ,TRACKF90U.
+SEQ,SOURCEF90U.
+SELF.

C---     INPUT:
C     X1,Y1,Z1    coordinates of electron at the starting point
C     VX1,VY1,VZ1    velocity at the starting point
C     XF0,YF0,ZF0    point of the plane where tracking stops
C     EWSFX,EWSFY,EWSFZ normal vector of the plane
C     DTIM        time intervall of one tracking step
C     BSHIFT         fraction of step where magnetic field is
C              determined for this step
C     GAMMA       relativistic factor

C---  OUTPUT:
C     X2,Y2,Z2    final coordinates of the electron
C     VX2,VY2,VZ2    final velocity of the electron

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,OPTIC.
+SEQ,TRACK.
+seq,sourcef90.
+SEQ,B0SCGLOB.
+SEQ,PHYCON.
+SEQ,PRIMKIN.
+seq,photon.
+seq,ustep.

      INTEGER ICAL,IZAEHL,I,J,K,I1,I2,IROI1,IROI2,istat,nfit,ifit1,ifit2

      DOUBLE PRECISION X1,Y1,Z1,VX1,VY1,VZ1,X2,Y2,Z2,VX2,VY2,VZ2
     &  ,DTIM,BSHIFT,X2B,Y2B,Z2B,BX1,BY1,BZ1,BX2,BY2,BZ2
     &  ,GAMMA0,GAMMA,DT,VXDUM,VYDUM,VZDUM,VXPDUM,VYPDUM,VZPDUM
     &  ,X2INT,Y2INT,Z2INT,DDT,DDDT,DDT2
     &  ,VX2INT,VY2INT,VZ2INT,VXPINT,VYPINT,VZPINT
     &  ,VXP,VYP,VZP,XOLD,YOLD,ZOLD,VXOLD,VYOLD,VZOLD
     &  ,X3INT,Y3INT,Z3INT,VX3INT,VY3INT,VZ3INT,DDDDT,DDDDT2
     &  ,EWSFX,EWSFY,EWSFZ,XF0,YF0,ZF0,DIST1,DIST2,DISTI
     &  ,AX1,AY1,AZ1,AX2,AY2,AZ2,DXYZ,PDUM,BBMAX,phdum
     &  ,X2BOUND,Y2BOUND,Z2BOUND,VX2BOUND,VY2BOUND,VZ2BOUND
     &  ,X1SAV,Y1SAV,Z1SAV,VX1SAV,VY1SAV,VZ1SAV,BX1SAV,BY1SAV,BZ1SAV
     &  ,AX1SAV,AY1SAV,AZ1SAV,T1SAV,X2SAV,BPER(3),VN
     &  ,DGAMMA,GAMMAL,BETA,DGAMSUM,dumf

      DOUBLE PRECISION T1,T2,DW
      DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: xfit,yfit,efit
      DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE :: WVP

      DATA ICAL/0/

      nutrack=-1
      nustep=-1

      GAMMA=GAMMA0
      DGAMMA=0.0D0
      DGAMSUM=0.0D0

      VXP=0.0D0
      VYP=0.0D0
      VZP=0.0D0

      IF (ICAL.EQ.0) THEN

        XMX=-1.D30
        YMX=-1.D30
        ZMX=-1.D30
        BXMX=-1.D30
        BYMX=-1.D30
        BZMX=-1.D30
        XMXAE=-1.D30
        YMXAE=-1.D30
        ZMXAE=-1.D30
        BXMXAE=-1.D30
        BYMXAE=-1.D30
        BZMXAE=-1.D30
        PHIMX=-1.D30
        BBMAX=-1.D30

        XMN=1.D30
        YMN=1.D30
        ZMN=1.D30
        XMNAE=1.D30
        YMNAE=1.D30
        ZMNAE=1.D30
        BXMN=1.D30
        BYMN=1.D30
        BZMN=1.D30
        BXMNAE=1.D30
        BYMNAE=1.D30
        BZMNAE=1.D30
        PHIMN=1.D30

      ENDIF   !ICAL

+SELF,IF=F90.
      IF (ICAL.EQ.0) THEN
        ALLOCATE(WSXYZ(3,NSTEPMX))
        ALLOCATE(WVXYZ(3,NSTEPMX))
        ALLOCATE(WBXYZ(3,NSTEPMX))
        ALLOCATE(WAXYZ(3,NSTEPMX))
        ALLOCATE(WGAMMA(3,0:NSTEPMX))
        WGAMMA(2,1)=0.0D0
        ALLOCATE(WVP(3,NSTEPMX))
        ALLOCATE(WTIM0(NSTEPMX))
        ALLOCATE(HTRA2(NSTEPMX))
        ALLOCATE(WTRA2(NSTEPMX))
      ENDIF !ICAL
+SELF.

c        GAMMA22=1.0D0/(GAMMA*GAMMA*2.D0)

      IF (ICAL.EQ.0) THEN

        BINT0=0.0
        BINT1X=0.0
        BINT1Y=0.0
        BINT1Z=0.0
        BINT2X=0.0
        BINT2Y=0.0
        BINT2Z=0.0
        BINT3Y=0.0
        BINT3YA=0.0
        PINT=0.0
        B2INTY=0.0
        WTRA2I=0.0D0

      ENDIF !ICAL

      WTRA2IC=0.0D0

      DTIM0=DTIM

c        PDUM=1.D9/2./PI1*CGAM1*CLIGHT1**2/1.D18*DMYCUR*DMYENERGY**2
      PDUM=0.5d-9/PI1*CGAM1*DMYCUR*(CLIGHT1*EMASSG1)**2

      DT=DTIM*BSHIFT

      T1=0.0

      CALL MYBFELD(X1,Y1,Z1,BX1,BY1,BZ1,AX1,AY1,AZ1)

      XOLD=X1
      YOLD=Y1
      ZOLD=Z1
      VXOLD=VX1
      VYOLD=VY1
      VZOLD=VZ1

      X2=X1
      Y2=Y1
      Z2=Z1
      T2=T1

      VN=SQRT(VX1*VX1+VY1*VY1+VZ1*VZ1)

      VX2=VX1
      VY2=VY1
      VZ2=VZ1

      BX2=BX1
      BY2=BY1
      BZ2=BZ1

      IZAEHL=0

      IROI1=0
      IROI2=1

      DO I=1,NROI
        IF(X1.GE.ROIX(I)) THEN
          IROI1=I
          IROI2=IROI1+1
          GOTO 1000
        ENDIF
      ENDDO

C--- LOOP DER TRAJEKTORIE

1000  IZAEHL=IZAEHL+1

      nustep=izaehl

      IF (IZAEHL.GT.NWMAX) THEN

        WRITE(LUNGFO,*)
     &    '*** WARNING SR TRACK: TOO MANY STEPS, INCREASE PARAMETER NWMAXP IN CMPARA.CMN ***'
        WRITE(6,*)
     &    '*** WARNING SR TRACK: TOO MANY STEPS, INCREASE PARAMETER NWMAXP IN CMPARA.CMN ***'

        IZAEHL=IZAEHL-1
        XSTOP=WSXYZ(1,IZAEHL)

        WRITE(LUNGFO,*)'     NUMBER OF STEPS DONE:',IZAEHL
        WRITE(6,*)'     NUMBER OF STEPS DONE:',IZAEHL
        WRITE(LUNGFO,*)
     &    '*** XSTOP overwritten:',XSTOP,' ***'
        WRITE(6,*)
     &    '*** XSTOP overwritten:',XSTOP,' ***'

        GOTO 1001

      ENDIF !(IZAEHL.GT.NWMAX)

      IF(ICAL.EQ.0) THEN

C-- INTEGRALS OF B-FIELD

        DXYZ=DSQRT((X2-X1)*(X2-X1)+(Y2-Y1)*(Y2-Y1)+(Z2-Z1)*(Z2-Z1)) !18.12.91
        BINT0=BINT0+DXYZ

        IF (X2.NE.X1) THEN
          DW=0.5D0*(X2-X1)*(((Y2-Y1)/(X2-X1))**2+((Z2-Z1)/(X2-X1))**2)
        ELSE IF (Y2.NE.Y1.OR.Z2.NE.Z1) THEN
          DW=1.D30
        ENDIF

        WTRA2I=WTRA2I+DW

        IF (IZAEHL.EQ.1) THEN
          WTRA2(IZAEHL)=DW
          HTRA2(IZAEHL)=DW+(X2-X1)*(1.0D0/(GAMMA*GAMMA*2.D0))
        ELSE
          WTRA2(IZAEHL)=WTRA2(IZAEHL-1)+DW
          HTRA2(IZAEHL)=HTRA2(IZAEHL-1)+DW+(X2-X1)*(1.0D0/(GAMMA*GAMMA*2.D0))
        ENDIF

        BINT1X=BINT1X+BX2*DXYZ
        BINT1Y=BINT1Y+BY2*DXYZ
        BINT1Z=BINT1Z+BZ2*DXYZ
        BINT2X=BINT2X+BINT1X*DXYZ
        BINT2Y=BINT2Y+BINT1Y*DXYZ
        BINT2Z=BINT2Z+BINT1Z*DXYZ
        BINT3YA=BINT3YA+DABS(BY2*BY2*BY2)*DXYZ
        BINT3Y=BINT3Y+BY2*BY2*BY2*DXYZ

        BPER(1)=(VY2*BZ2-VZ2*BY2)/VN
        BPER(2)=(VZ2*BX2-VX2*BZ2)/VN
        BPER(3)=(VX2*BY2-VY2*BX2)/VN

        PINT=PINT+
     &    PDUM*GAMMA**2*
     &    (BPER(1)**2+BPER(2)**2+BPER(3)**2)*DXYZ !LEISTUNG/BAHN

C-- PEAK-VALUES

        PHIX=DATAN(VZ2/VX2)

        IF (PHIMX.LT.PHIX) PHIMX=PHIX
        IF (PHIMN.GT.PHIX) PHIMN=PHIX

        IF (XMX.LT.X2) XMX=X2
        IF (XMN.GT.X2) XMN=X2
        IF (YMX.LT.Y2) YMX=Y2
        IF (YMN.GT.Y2) YMN=Y2
        IF (ZMX.LT.Z2) ZMX=Z2
        IF (ZMN.GT.Z2) ZMN=Z2

        IF (BXMX.LT.BX2) BXMX=BX2
        IF (BXMN.GT.BX2) BXMN=BX2
        IF (BYMX.LT.BY2) BYMX=BY2
        IF (BYMN.GT.BY2) BYMN=BY2
        IF (BZMX.LT.BZ2) BZMX=BZ2
        IF (BZMN.GT.BZ2) BZMN=BZ2

        IF (XIANF.LE.X2 .AND. XIEND.GE.X2) THEN
          IF (XMXAE.LT.X2) XMXAE=X2
          IF (XMNAE.GT.X2) XMNAE=X2
          IF (YMXAE.LT.Y2) YMXAE=Y2
          IF (YMNAE.GT.Y2) YMNAE=Y2
          IF (ZMXAE.LT.Z2) ZMXAE=Z2
          IF (ZMNAE.GT.Z2) ZMNAE=Z2

          IF (BXMXAE.LT.BX2) BXMXAE=BX2
          IF (BXMNAE.GT.BX2) BXMNAE=BX2
          IF (BYMXAE.LT.BY2) BYMXAE=BY2
          IF (BYMNAE.GT.BY2) BYMNAE=BY2
          IF (BZMXAE.LT.BZ2) BZMXAE=BZ2
          IF (BZMNAE.GT.BZ2) BZMNAE=BZ2
        ENDIF

        BRMS=BX2*BX2+BY2*BY2+BZ2*BZ2

        IF (BRMS.GT.BBMAX) BBMAX=BRMS

        WSXYZ(1,IZAEHL)=X2
        WSXYZ(2,IZAEHL)=Y2
        WSXYZ(3,IZAEHL)=Z2

        WVXYZ(1,IZAEHL)=VX2
        WVXYZ(2,IZAEHL)=VY2
        WVXYZ(3,IZAEHL)=VZ2

        WBXYZ(1,IZAEHL)=BX2
        WBXYZ(2,IZAEHL)=BY2
        WBXYZ(3,IZAEHL)=BZ2

        WAXYZ(1,IZAEHL)=AX2
        WAXYZ(2,IZAEHL)=AY2
        WAXYZ(3,IZAEHL)=AZ2

        WVP(1,IZAEHL)=VXP
        WVP(2,IZAEHL)=VYP
        WVP(3,IZAEHL)=VZP

        WTIM0(IZAEHL)=T2

        WGAMMA(1,IZAEHL)=GAMMA !absolute value
        WGAMMA(2,IZAEHL)=WGAMMA(2,IZAEHL-1)+DGAMMA !accumulated loss
        WGAMMA(3,IZAEHL)=DGAMMA !loss per step

C        WRITE (LUNTR,*)X2,Y2,Z2,VX2,VY2,VZ2,BX2,BY2,BZ2,AX2,AY2,AZ2

      ENDIF   !ICAL

C        WRITE (LUNTR,*)X2,Y2,Z2,VX2,VY2,VZ2,BX2,BY2,BZ2,AX2,AY2,AZ2

      X1=X2
      Y1=Y2
      Z1=Z2

      T1=T2

      VX1=VX2
      VY1=VY2
      VZ1=VZ2

      AX1=AX2
      AY1=AY2
      AZ1=AZ2

      BX1=BX2
      BY1=BY2
      BZ1=BZ2

      ITRACK=IZAEHL

      XTRACK=X1
      YTRACK=Y1
      ZTRACK=Z1

      VXTRACK=VX1
      VYTRACK=VY1
      VZTRACK=VZ1

      IF (ISNORDER.EQ.0) THEN

        X2B=X1+VX1*DT
        Y2B=Y1+VY1*DT
        Z2B=Z1+VZ1*DT

      ELSE

        CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX1,BY1,BZ1,DT,
     &    X2B,Y2B,Z2B,
     &    VXDUM,VYDUM,VZDUM,VXPDUM,VYPDUM,VZPDUM,GAMMA,ICHARGE,BMOVECUT,
     &    IUSTEP,IENELOSS,DGAMMA)

      ENDIF

      CALL MYBFELD(X2B,Y2B,Z2B,BX2,BY2,BZ2,AX2,AY2,AZ2)

      CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DTIM,
     &  X2,Y2,Z2,VX2,VY2,VZ2,VXP,VYP,VZP,GAMMA,ICHARGE,BMOVECUT,
     &  IUSTEP,IENELOSS,DGAMMA)

      DXYZ=DSQRT((X2-X1)*(X2-X1)+(Y2-Y1)*(Y2-Y1)+(Z2-Z1)*(Z2-Z1))

      IF (X2.NE.X1) THEN
        DW=0.5D0*(X2-X1)*(((Y2-Y1)/(X2-X1))**2+((Z2-Z1)/(X2-X1))**2)
      ELSE IF (Y2.NE.Y1.OR.Z2.NE.Z1) THEN
        DW=1.0D30
      ENDIF

      WTRA2IC=WTRA2IC+DW

C--- BOUNDARY CROSSING {

      IF (X2.GT.ROIX(IROI2)) THEN

        X1SAV=X1
        Y1SAV=Y1
        Z1SAV=Z1

        T1SAV=T1

        VX1SAV=VX1
        VY1SAV=VY1
        VZ1SAV=VZ1

        AX1SAV=AX1
        AY1SAV=AY1
        AZ1SAV=AZ1

        BX1SAV=BX1
        BY1SAV=BY1
        BZ1SAV=BZ1

        X2SAV=X2

        DIST1=X1-ROIX(IROI2)
        DIST2=X2-ROIX(IROI2)

        DDT=DTIM*DABS(DIST1)/(DABS(DIST1)+DABS(DIST2))
        DDT2=DDT*BSHIFT

        IF(ISNORDER.EQ.0) THEN

          X2B=X1+VX1*DDT2
          Y2B=Y1+VY1*DDT2
          Z2B=Z1+VZ1*DDT2

        ELSE

          CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX1,BY1,BZ1,DDT2,
     &      X2B,Y2B,Z2B,
     &      VXDUM,VYDUM,VZDUM,VXPDUM,VYPDUM,VZPDUM,GAMMA,ICHARGE,BMOVECUT,
     &      IUSTEP,IENELOSS,DGAMMA)

        ENDIF

        CALL MYBFELD(X2B,Y2B,Z2B,BX2,BY2,BZ2,AX2,AY2,AZ2)

        CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DDT,
     &    X2INT,Y2INT,Z2INT,VX2INT,VY2INT,VZ2INT,
     &    VXPINT,VYPINT,VZPINT,GAMMA,ICHARGE,BMOVECUT,IUSTEP,IENELOSS,DGAMMA)

        DISTI=X2INT-ROIX(IROI2)

        DDDT=DDT
        IF (DIST1.NE.0.) DDDT=DDT-DDT*DISTI/DABS(DIST1)

        CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DDDT,
     &    X3INT,Y3INT,Z3INT,VX3INT,VY3INT,VZ3INT,
     &    VXPINT,VYPINT,VZPINT,GAMMA,ICHARGE,BMOVECUT,IUSTEP,IENELOSS,DGAMMA)

        DISTI=X3INT-ROIX(IROI2)
        DDDDT=DDDT
        IF (DIST1.NE.0.) DDDDT=DDDT-DDDT*DISTI/DABS(DIST1)
        DDDDT2=BSHIFT*DDDDT

        CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DDDDT,
     &    X2BOUND,Y2BOUND,Z2BOUND,VX2BOUND,VY2BOUND,VZ2BOUND,
     &    VXP,VYP,VZP,GAMMA,ICHARGE,BMOVECUT,IUSTEP,IENELOSS,DGAMMA)

        IF (IENELOSS.gt.0) THEN

          DGAMSUM=DGAMSUM+DGAMMA

          IF (ABS(DGAMSUM).GT.GAMMA*1.0D-8) THEN

            phdum=emasse1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))/vn

            GAMMA=GAMMA+DGAMSUM
            DGAMSUM=0.0D0
            BETA=DSQRT((1.D0-1.D0/GAMMA)*(1.D0+1.D0/GAMMA))
            VN=SQRT(VX2bound*VX2bound+VY2bound*VY2bound+VZ2bound*VZ2bound)

            VX2bound=VX2bound/VN*CLIGHT1*BETA
            VY2bound=VY2bound/VN*CLIGHT1*BETA
            VZ2bound=VZ2bound/VN*CLIGHT1*BETA

          ENDIF ! summe

        ELSE IF (IENELOSS.lt.0) THEN

          phdum=emasse1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))/vn

          GAMMA=GAMMA+DGAMMA
          BETA=DSQRT((1.D0-1.D0/GAMMA)*(1.D0+1.D0/GAMMA))
          VN=SQRT(VX2bound*VX2bound+VY2bound*VY2bound+VZ2bound*VZ2bound)

cerror ?? 21.1.2019
c          vx2bound=(phdum*vx2bound-pphoton(1))/(emasse1*gamma)*clight1
c          vy2bound=(phdum*vy2bound-pphoton(1))/(emasse1*gamma)*clight1
c          vz2bound=(phdum*vz2bound-pphoton(1))/(emasse1*gamma)*clight1

cerror ?? 21.1.2019
          vx2bound=(phdum*vx2bound-dpphoton(1))/(emasse1*gamma)*clight1
          vy2bound=(phdum*vy2bound-dpphoton(2))/(emasse1*gamma)*clight1
          vz2bound=(phdum*vz2bound-dpphoton(3))/(emasse1*gamma)*clight1

        ENDIF !ieneloss.ne.0

C NOW WE ARE ON THE BOUNDARY (X2BOUND) AND PRECEED TO OLD X2 (X2SAV)

        DTIM=DTIM*(X2SAV-X2BOUND)/(X2SAV-X1SAV)
        DT=DTIM*BSHIFT

        X1=X2BOUND
        Y1=Y2BOUND
        Z1=Z2BOUND

        VX1=VX2BOUND
        VY1=VY2BOUND
        VZ1=VZ2BOUND

        AX1=AX2
        AY1=AY2
        AZ1=AZ2

        BX1=BX2
        BY1=BY2
        BZ1=BZ2

        IF (ISNORDER.EQ.0) THEN

          X2B=X1+VX1*DT
          Y2B=Y1+VY1*DT
          Z2B=Z1+VZ1*DT

        ELSE

          CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX1,BY1,BZ1,DT,
     &      X2B,Y2B,Z2B,
     &      VXDUM,VYDUM,VZDUM,VXPDUM,VYPDUM,VZPDUM,GAMMA,ICHARGE,BMOVECUT,
     &      IUSTEP,IENELOSS,DGAMMA)

        ENDIF

        CALL MYBFELD(X2B,Y2B,Z2B,BX2,BY2,BZ2,AX2,AY2,AZ2)

        CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DTIM,
     &    X2,Y2,Z2,VX2,VY2,VZ2,VXP,VYP,VZP,GAMMA,ICHARGE,BMOVECUT,
     &    IUSTEP,IENELOSS,DGAMMA)

        IF (IENELOSS.NE.0) THEN

          DGAMSUM=DGAMSUM+DGAMMA

          IF (ABS(DGAMSUM).GT.GAMMA*1.0D-8) THEN

            phdum=emasse1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))/vn

            GAMMA=GAMMA+DGAMSUM
            DGAMSUM=0.0D0
            BETA=DSQRT((1.D0-1.D0/GAMMA)*(1.D0+1.D0/GAMMA))
            VN=SQRT(VX2*VX2+VY2*VY2+VZ2*VZ2)

            IF (IENELOSS.eq.-1) THEN
              vx2=(phdum*vx2-pphoton(1))/(emasse1*gamma)*clight1
              vy2=(phdum*vy2-pphoton(1))/(emasse1*gamma)*clight1
              vz2=(phdum*vz2-pphoton(1))/(emasse1*gamma)*clight1
            else
              VX2=VX2/VN*CLIGHT1*BETA
              VY2=VY2/VN*CLIGHT1*BETA
              VZ2=VZ2/VN*CLIGHT1*BETA
            endif

          ENDIF ! summe

        ENDIF !ieneloss.ne.0

        DIST1=X1-X2SAV
        DIST2=X2-X2SAV

        DDT=DTIM*DABS(DIST1)/(DABS(DIST1)+DABS(DIST2))
        DDT2=DDT*BSHIFT

        IF(ISNORDER.EQ.0) THEN

          X2B=X1+VX1*DDT2
          Y2B=Y1+VY1*DDT2
          Z2B=Z1+VZ1*DDT2

        ELSE

          CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX1,BY1,BZ1,DDT2,
     &      X2B,Y2B,Z2B,
     &      VXDUM,VYDUM,VZDUM,VXPDUM,VYPDUM,VZPDUM,GAMMA,ICHARGE,BMOVECUT,
     &      IUSTEP,IENELOSS,DGAMMA)

        ENDIF

        CALL MYBFELD(X2B,Y2B,Z2B,BX2,BY2,BZ2,AX2,AY2,AZ2)

        CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DDT,
     &    X2INT,Y2INT,Z2INT,VX2INT,VY2INT,VZ2INT,
     &    VXPINT,VYPINT,VZPINT,GAMMA,ICHARGE,BMOVECUT,IUSTEP,IENELOSS,DGAMMA)

        DISTI=X2INT-X2SAV

        DDDT=DDT
        IF (DIST1.NE.0.) DDDT=DDT-DDT*DISTI/DABS(DIST1)

        CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DDDT,
     &    X3INT,Y3INT,Z3INT,VX3INT,VY3INT,VZ3INT,
     &    VXPINT,VYPINT,VZPINT,GAMMA,ICHARGE,BMOVECUT,IUSTEP,IENELOSS,DGAMMA)

        DISTI=X3INT-X2SAV
        DDDDT=DDDT
        IF (DIST1.NE.0.) DDDDT=DDDT-DDDT*DISTI/DABS(DIST1)
        DDDDT2=BSHIFT*DDDDT

        CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DDDDT,
     &    X2,Y2,Z2,VX2,VY2,VZ2,
     &    VXP,VYP,VZP,GAMMA,ICHARGE,BMOVECUT,IUSTEP,IENELOSS,DGAMMA)

        IF (IENELOSS.NE.0) THEN

          DGAMSUM=DGAMSUM+DGAMMA

          IF (ABS(DGAMSUM).GT.GAMMA*1.0D-8) THEN

            phdum=emasse1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))/vn

            GAMMA=GAMMA+DGAMSUM
            DGAMSUM=0.0D0
            BETA=DSQRT((1.D0-1.D0/GAMMA)*(1.D0+1.D0/GAMMA))
            VN=SQRT(VX2*VX2+VY2*VY2+VZ2*VZ2)

            IF (IENELOSS.eq.-1) THEN
              vx2=(phdum*vx2-pphoton(1))/(emasse1*gamma)*clight1
              vy2=(phdum*vy2-pphoton(1))/(emasse1*gamma)*clight1
              vz2=(phdum*vz2-pphoton(1))/(emasse1*gamma)*clight1
            else
              VX2=VX2/VN*CLIGHT1*BETA
              VY2=VY2/VN*CLIGHT1*BETA
              VZ2=VZ2/VN*CLIGHT1*BETA
            endif

          ENDIF ! summe

        ENDIF !ieneloss.ne.0

        X1=X1SAV
        Y1=Y1SAV
        Z1=Z1SAV

        T1=T1SAV

        VX1=VX1SAV
        VY1=VY1SAV
        VZ1=VZ1SAV

        AX1=AX1SAV
        AY1=AY1SAV
        AZ1=AZ1SAV

        BX1=BX1SAV
        BY1=BY1SAV
        BZ1=BZ1SAV

        DTIM=DTIM0
        DT=DTIM*BSHIFT

        IROI1=IROI1+1
        IROI2=IROI1+1

      ELSE ! BOUNDARY CROSSED

        IF (IENELOSS.NE.0) THEN

          DGAMSUM=DGAMSUM+DGAMMA

          IF (ABS(DGAMSUM).GT.GAMMA*1.0D-8) THEN

            phdum=emasse1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))/vn

            GAMMA=GAMMA+DGAMSUM
            DGAMSUM=0.0D0
            BETA=DSQRT((1.D0-1.D0/GAMMA)*(1.D0+1.D0/GAMMA))
            VN=SQRT(VX2*VX2+VY2*VY2+VZ2*VZ2)

            IF (IENELOSS.eq.-1) THEN
              vx2=(phdum*vx2-pphoton(1))/(emasse1*gamma)*clight1
              vy2=(phdum*vy2-pphoton(1))/(emasse1*gamma)*clight1
              vz2=(phdum*vz2-pphoton(1))/(emasse1*gamma)*clight1
            else
              VX2=VX2/VN*CLIGHT1*BETA
              VY2=VY2/VN*CLIGHT1*BETA
              VZ2=VZ2/VN*CLIGHT1*BETA
            endif

          ENDIF ! summe

        ENDIF !ieneloss.ne.0

      ENDIF ! BOUNDARY CROSSED

C--- BOUNDARY CROSSING }

      T2=T1+DTIM

C EWSF IS NORMAL VECTOR OF PERPENDICULARE PLANE AT THE END OF THE REFERENCE ORBI
C DIST IS DISTANCE OF ELECTRON TO THIS PLANE
C TRACKING STOPS IF TRAJECTORIE HITS THIS PLANE

      DIST2=(X2-XF0)*EWSFX+(Y2-YF0)*EWSFY+(Z2-ZF0)*EWSFZ

      IF ( DIST2 .LT. 0.0  )  GOTO 1000

C--- ENDE OF TRAJECTORY, DIST2 NOT EXACTLY ZERO, CORRECT X2

      DIST1=(X1-XF0)*EWSFX+(Y1-YF0)*EWSFY+(Z1-ZF0)*EWSFZ

      DDT=DTIM*DABS(DIST1)/(DABS(DIST1)+DABS(DIST2))
      DDT2=DDT*BSHIFT

      IF(ISNORDER.EQ.0) THEN

        X2B=X1+VX1*DDT2
        Y2B=Y1+VY1*DDT2
        Z2B=Z1+VZ1*DDT2

      ELSE

        CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX1,BY1,BZ1,DDT2,X2B,Y2B,Z2B,
     &    VXDUM,VYDUM,VZDUM,VXPDUM,VYPDUM,VZPDUM,GAMMA,ICHARGE,BMOVECUT,
     &    IUSTEP,IENELOSS,DGAMMA)

      ENDIF

      CALL MYBFELD(X2B,Y2B,Z2B,BX2,BY2,BZ2,AX2,AY2,AZ2)

      CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DDT,
     &  X2INT,Y2INT,Z2INT,VX2INT,VY2INT,VZ2INT,
     &  VXPINT,VYPINT,VZPINT,GAMMA,ICHARGE,BMOVECUT,
     &  IUSTEP,IENELOSS,DGAMMA)

      DISTI=(X2INT-XF0)*EWSFX+(Y2INT-YF0)*EWSFY+(Z2INT-ZF0)*EWSFZ
      DDDT=DDT
      IF (DIST1.NE.0.) DDDT=DDT-DDT*DISTI/DABS(DIST1)

      CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DDDT,
     &  X3INT,Y3INT,Z3INT,VX3INT,VY3INT,VZ3INT,
     &  VXPINT,VYPINT,VZPINT,GAMMA,ICHARGE,BMOVECUT,IUSTEP,IENELOSS,DGAMMA)

      DISTI=(X3INT-XF0)*EWSFX+(Y3INT-YF0)*EWSFY+(Z3INT-ZF0)*EWSFZ
      DDDDT=DDDT
      IF (DIST1.NE.0.) DDDDT=DDDT-DDDT*DISTI/DABS(DIST1)
      DDDDT2=BSHIFT*DDDDT

      CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DDDDT,
     &  X2,Y2,Z2,VX2,VY2,VZ2,
     &  VXP,VYP,VZP,GAMMA,ICHARGE,BMOVECUT,IUSTEP,IENELOSS,DGAMMA)

      IF (IENELOSS.NE.0) THEN

        DGAMSUM=DGAMSUM+DGAMMA

        IF (ABS(DGAMSUM).GT.GAMMA*1.0D-8) THEN

          phdum=emasse1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))/vn

          GAMMA=GAMMA+DGAMSUM
          DGAMSUM=0.0D0
          BETA=DSQRT((1.D0-1.D0/GAMMA)*(1.D0+1.D0/GAMMA))
          VN=SQRT(VX2*VX2+VY2*VY2+VZ2*VZ2)

          IF (IENELOSS.eq.-1) THEN
            vx2=(phdum*vx2-pphoton(1))/(emasse1*gamma)*clight1
            vy2=(phdum*vy2-pphoton(1))/(emasse1*gamma)*clight1
            vz2=(phdum*vz2-pphoton(1))/(emasse1*gamma)*clight1
          else
            VX2=VX2/VN*CLIGHT1*BETA
            VY2=VY2/VN*CLIGHT1*BETA
            VZ2=VZ2/VN*CLIGHT1*BETA
          endif

        ENDIF ! summe

      ENDIF !ieneloss.ne.0

      T2=T1+DDDDT

C-- INTEGRALS OF B-FIELD

      DXYZ=DSQRT((X2-X1)*(X2-X1)+(Y2-Y1)*(Y2-Y1)+(Z2-Z1)*(Z2-Z1)) !18.12.91

      IF (ICAL.EQ.0) THEN

        BINT0=BINT0+DXYZ

        IF (X2.NE.X1) THEN
          DW=0.5D0*(X2-X1)*(((Y2-Y1)/(X2-X1))**2+((Z2-Z1)/(X2-X1))**2)
        ELSE IF (Y2.NE.Y1.OR.Z2.NE.Z1) THEN
          DW=1.D30
        ENDIF

        WTRA2I=WTRA2I+DW

        IF (IZAEHL.EQ.1) THEN
          HTRA2(IZAEHL)=DW+(X2-X1)*(1.0D0/(GAMMA*GAMMA*2.D0))
          WTRA2(IZAEHL)=DW
        ELSE
          WTRA2(IZAEHL)=WTRA2(IZAEHL-1)+DW
          HTRA2(IZAEHL)=HTRA2(IZAEHL-1)+DW+(X2-X1)*(1.0D0/(GAMMA*GAMMA*2.D0))
        ENDIF

        BINT1X=BINT1X+BX2*DXYZ
        BINT1Y=BINT1Y+BY2*DXYZ
        BINT1Z=BINT1Z+BZ2*DXYZ
        BINT2X=BINT2X+BINT1X*DXYZ
        BINT2Y=BINT2Y+BINT1Y*DXYZ
        BINT2Z=BINT2Z+BINT1Z*DXYZ
        BINT3YA=BINT3YA+DABS(BY2*BY2*BY2)*DXYZ
        BINT3Y=BINT3Y+BY2*BY2*BY2*DXYZ
cerror 26.6.2013        PINT=PINT+PDUM*(BX2*BX2+BY2*BY2+BZ2*BZ2)*DXYZ !LEISTUNG/BAHN
        PINT=PINT+PDUM*GAMMA**2*(BX2*BX2+BY2*BY2+BZ2*BZ2)*DXYZ !LEISTUNG/BAHN
        B2INTY=PINT/PDUM/GAMMA**2

C-- PEAK-VALUES

        PHIX=DATAN(VZ2/VX2)

        IF (PHIMX.LT.PHIX) PHIMX=PHIX
        IF (PHIMN.GT.PHIX) PHIMN=PHIX

        IF (XMX.LT.X2) XMX=X2
        IF (XMN.GT.X2) XMN=X2
        IF (YMX.LT.Y2) YMX=Y2
        IF (YMN.GT.Y2) YMN=Y2
        IF (ZMX.LT.Z2) ZMX=Z2
        IF (ZMN.GT.Z2) ZMN=Z2

        IF (BXMX.LT.BX2) BXMX=BX2
        IF (BXMN.GT.BX2) BXMN=BX2
        IF (BYMX.LT.BY2) BYMX=BY2
        IF (BYMN.GT.BY2) BYMN=BY2
        IF (BZMX.LT.BZ2) BZMX=BZ2
        IF (BZMN.GT.BZ2) BZMN=BZ2

      ENDIF !ICAL

      IF (X2.NE.X1) THEN
        DW=0.5D0*(X2-X1)*(((Y2-Y1)/(X2-X1))**2+((Z2-Z1)/(X2-X1))**2)
      ELSE IF (Y2.NE.Y1.OR.Z2.NE.Z1) THEN
        DW=1.D30
      ENDIF

      WTRA2IC=WTRA2IC+DW

1001  X1=XOLD
      Y1=YOLD
      Z1=ZOLD
      VX1=VXOLD
      VY1=VYOLD
      VZ1=VZOLD

      IF (ICAL.EQ.0) THEN

        NCO=IZAEHL

+SELF,IF=F90.
        ALLOCATE(WTRA(3,5,NCO))
+SELF.

        DO I=1,IZAEHL-1

          WTRA(1,1,I)=WSXYZ(1,I)
          WTRA(2,1,I)=WSXYZ(2,I)
          WTRA(3,1,I)=WSXYZ(3,I)

          WTRA(1,2,I)=WVXYZ(1,I)
          WTRA(2,2,I)=WVXYZ(2,I)
          WTRA(3,2,I)=WVXYZ(3,I)

          WTRA(1,3,I)=WBXYZ(1,I)
          WTRA(2,3,I)=WBXYZ(2,I)
          WTRA(3,3,I)=WBXYZ(3,I)

          WTRA(1,4,I)=WAXYZ(1,I)
          WTRA(2,4,I)=WAXYZ(2,I)
          WTRA(3,4,I)=WAXYZ(3,I)

          WTRA(1,5,I)=WGAMMA(1,I)
          WTRA(2,5,I)=WGAMMA(2,I)
          WTRA(3,5,I)=WGAMMA(3,I)

        ENDDO !IZAEHL

        WTIM0(IZAEHL)=T2

        WTRA(1,1,IZAEHL)=X2
        WTRA(2,1,IZAEHL)=Y2
        WTRA(3,1,IZAEHL)=Z2

        WTRA(1,2,IZAEHL)=VX2
        WTRA(2,2,IZAEHL)=VY2
        WTRA(3,2,IZAEHL)=VZ2

        WTRA(1,3,IZAEHL)=BX2
        WTRA(2,3,IZAEHL)=BY2
        WTRA(3,3,IZAEHL)=BZ2

        WTRA(1,4,IZAEHL)=AX2
        WTRA(2,4,IZAEHL)=AY2
        WTRA(3,4,IZAEHL)=AZ2

        WTRA(1,5,IZAEHL)=GAMMA
        WTRA(2,5,IZAEHL)=WTRA(2,5,IZAEHL-1)+DGAMMA
        WTRA(3,5,IZAEHL)=DGAMMA

        WVP(1,IZAEHL)=VXP
        WVP(2,IZAEHL)=VYP
        WVP(3,IZAEHL)=VZP


+SELF,IF=F90.

        DEALLOCATE(WSXYZ)
        DEALLOCATE(WVXYZ)
        DEALLOCATE(WBXYZ)
        DEALLOCATE(WAXYZ)
        DEALLOCATE(WGAMMA)

        ALLOCATE(WSXYZ(3,NCO))
        ALLOCATE(WVXYZ(3,NCO))
        ALLOCATE(WBXYZ(3,NCO))
        ALLOCATE(WAXYZ(3,NCO))
        ALLOCATE(WVPXYZ(3,NCO))

        DO I=1,IZAEHL

          WSXYZ(1,I)=WTRA(1,1,I)
          WSXYZ(2,I)=WTRA(2,1,I)
          WSXYZ(3,I)=WTRA(3,1,I)

          WVXYZ(1,I)=WTRA(1,2,I)
          WVXYZ(2,I)=WTRA(2,2,I)
          WVXYZ(3,I)=WTRA(3,2,I)

          WBXYZ(1,I)=WTRA(1,3,I)
          WBXYZ(2,I)=WTRA(2,3,I)
          WBXYZ(3,I)=WTRA(3,3,I)

          WAXYZ(1,I)=WTRA(1,4,I)
          WAXYZ(2,I)=WTRA(2,4,I)
          WAXYZ(3,I)=WTRA(3,4,I)

          WVPXYZ(1,I)=WVP(1,I)
          WVPXYZ(2,I)=WVP(2,I)
          WVPXYZ(3,I)=WVP(3,I)

        ENDDO !IZAEHL

        DO I=1,IZAEHL
          WTRA(1,1,I)=WTIM0(I)
          WTRA(2,1,I)=HTRA2(I)
          WTRA(3,1,I)=WTRA2(I)
        ENDDO  !IZAEHL

        DEALLOCATE(WVP)
        DEALLOCATE(WTIM0)
        DEALLOCATE(HTRA2)
        DEALLOCATE(WTRA2)

        ALLOCATE(WTIM0(NCO))
        ALLOCATE(HTRA2(NCO))
        ALLOCATE(WTRA2(NCO))

        DO I=1,IZAEHL
          WTIM0(I)=WTRA(1,1,I)
          HTRA2(I)=WTRA(2,1,I)
          WTRA2(I)=WTRA(3,1,I)
        ENDDO  !IZAEHL

        DO I=1,IZAEHL

          WTRA(1,1,I)=WSXYZ(1,I)
          WTRA(2,1,I)=WSXYZ(2,I)
          WTRA(3,1,I)=WSXYZ(3,I)

          WTRA(1,2,I)=WVXYZ(1,I)
          WTRA(2,2,I)=WVXYZ(2,I)
          WTRA(3,2,I)=WVXYZ(3,I)

          WTRA(1,3,I)=WBXYZ(1,I)
          WTRA(2,3,I)=WBXYZ(2,I)
          WTRA(3,3,I)=WBXYZ(3,I)

          WTRA(1,4,I)=WAXYZ(1,I)
          WTRA(2,4,I)=WAXYZ(2,I)
          WTRA(3,4,I)=WAXYZ(3,I)

        ENDDO !IZAEHL
        DO I=1,nco
          if (wsxyz(1,i).ge.xianf.and.ifit1.eq.0) ifit1=i
          if (wsxyz(1,i).le.xiend) ifit2=i
        enddo
        nfit=ifit2-ifit1+1

        ALLOCATE(xfit(nfit))
        ALLOCATE(yfit(nfit))
        ALLOCATE(efit(nfit))

        DO I=ifit1,ifit2
          xfit(i-ifit1+1)=wsxyz(1,I)
          yfit(i-ifit1+1)=wsxyz(2,I)
          efit(i-ifit1+1)=0.0d0
        enddo

        yslopetr=0.0d0
        yoffstr=0.0d0
        call util_straight_line_fit(nfit,xfit,yfit,efit,yslopetr,yoffstr,
     &    dumf,yslopeetr,yoffsetr,istat)

        if (istat.ne.0) then
          write(lungfo,*)'*** Warning in TRACK: Fit of straight line failed ***'
          write(6,*)'*** Warning in TRACK: Fit of straight line failed ***'
          yslopetr=0.0d0
          yoffstr=0.0d0
        endif

        DO I=ifit1,ifit2
          yfit(i-ifit1+1)=wsxyz(3,I)
          efit(i-ifit1+1)=0.0d0
        enddo

        call util_straight_line_fit(nfit,xfit,yfit,efit,zslopetr,zoffstr,
     &    dumf,zslopeetr,zoffsetr,istat)
        if (istat.ne.0) then
          write(lungfo,*)'*** Warning in TRACK: Fit of straight line failed ***'
          write(6,*)'*** Warning in TRACK: Fit of straight line failed ***'
          zslopetr=0.0d0
          zoffstr=0.0d0
        endif

        DO I=ifit1,ifit2
          yfit(i-ifit1+1)=wvxyz(2,I)/wvxyz(1,i)
          efit(i-ifit1+1)=0.0d0
        enddo

        call util_straight_line_fit(nfit,xfit,yfit,efit,ypslopetr,ypoffstr,
     &    dumf,ypslopeetr,ypoffsetr,istat)
        if (istat.ne.0) then
          write(lungfo,*)'*** Warning in TRACK: Fit of straight line failed ***'
          write(6,*)'*** Warning in TRACK: Fit of straight line failed ***'
          ypslopetr=0.0d0
          yoffstr=0.0d0
        endif

        DO I=ifit1,ifit2
          yfit(i-ifit1+1)=wvxyz(3,I)/wvxyz(1,i)
          efit(i-ifit1+1)=0.0d0
        enddo

        call util_straight_line_fit(nfit,xfit,yfit,efit,zpslopetr,zpoffstr,
     &    dumf,zpslopeetr,zpoffsetr,istat)
        if (istat.ne.0) then
          write(lungfo,*)'*** Warning in TRACK: Fit of straight line failed ***'
          write(6,*)'*** Warning in TRACK: Fit of straight line failed ***'
          zpslopetr=0.0d0
          zpoffstr=0.0d0
        endif

        deALLOCATE(xfit)
        deALLOCATE(yfit)
        deALLOCATE(efit)

+SELF.

        I1=1
        I2=IZAEHL
        BRMS=0.D0
        ANGRMS=0.D0

        IF (BBMAX.GT.0.0) THEN
          DO I=1,IZAEHL
            BY1=
     &        +WBXYZ(1,I)*WBXYZ(1,I)
     &        +WBXYZ(2,I)*WBXYZ(2,I)
     &        +WBXYZ(3,I)*WBXYZ(3,I)
            IF (BY1.GE.0.01*BBMAX.AND.I1.EQ.1) I1=I
            IF (BY1.GE.0.01*BBMAX) I2=I
          ENDDO   !IZAEHL
        ENDIF  !(BBMAX.GT.0.0)

        DO I=I1,I2
          BY1=
     &      +WBXYZ(1,I)*WBXYZ(1,I)
     &      +WBXYZ(2,I)*WBXYZ(2,I)
     &      +WBXYZ(3,I)*WBXYZ(3,I)
          BRMS=BRMS+BY1
          ANGRMS=ANGRMS
     &      +(WVXYZ(3,I)*WVXYZ(3,I)+WVXYZ(2,I)*WVXYZ(2,I))
     &      /(WVXYZ(1,I)*WVXYZ(1,I))
        ENDDO !I1,I2

        BRMS=SQRT(BRMS/(I2-I1+1))
        ANGRMS=SQRT(ANGRMS/(I2-I1+1))

        IF(IWFILT0.NE.0) THEN

          OPEN(UNIT=LUNTR,FILE=FILETR,STATUS='NEW')

          IF(IWFILT0.EQ.1) THEN
            WRITE(LUNTR,*)'* ',ICODE
            WRITE(LUNTR,*)'* ',CODE
          ELSE IF(IWFILT0.GT.1) THEN
            WRITE(LUNTR,*)ICODE
            WRITE(LUNTR,*)CODE
          ENDIF

          DO K=1,IZAEHL,ABS(IWFILT0)
            WRITE(LUNTR,*)((WTRA(I,J,K),I=1,3),J=1,4)
          ENDDO

          CLOSE (LUNTR)

          WRITE(6,*) 'REFERENCE ORBIT WRITTEN TO'
          WRITE(6,*) 'FILE:',FILETR

        ENDIF !WFILT0

        ICAL=1

      ENDIF ! ICAL

      HTRA2I=WTRA2I+(XSTOP-XSTART)*(1.0D0/(GAMMA*GAMMA*2.D0))
      TTRA2I=HTRA2I/CLIGHT1

      IF (BXMX.EQ.0.D0.AND.BXMN.EQ.0.D0.AND.BZMX.EQ.0.D0.AND.BZMN.EQ.0.D0) THEN
        IBYONLY=1
      ELSE
        IBYONLY=0
      ENDIF

      if (ieneloss.ne.0) then

        phdum=emasse1*DSQRT((gamma-1.0d0)*(gamma+1.0d0))/vn

        GAMMA=GAMMA+DGAMSUM
        DGAMSUM=0.0D0
        BETA=DSQRT((1.D0-1.D0/GAMMA)*(1.D0+1.D0/GAMMA))
        VN=SQRT(VX2*VX2+VY2*VY2+VZ2*VZ2)

        IF (IENELOSS.eq.-1) THEN
          vx2=(phdum*vx2-pphoton(1))/(emasse1*gamma)*clight1
          vy2=(phdum*vy2-pphoton(1))/(emasse1*gamma)*clight1
          vz2=(phdum*vz2-pphoton(1))/(emasse1*gamma)*clight1
        else
          VX2=VX2/VN*CLIGHT1*BETA
          VY2=VY2/VN*CLIGHT1*BETA
          VZ2=VZ2/VN*CLIGHT1*BETA
        endif

      endif

      GAMMAL=GAMMA0-GAMMA

      tint=t2

      RETURN
      END
+DECK,TRACKBMAG.
*CMZ :  4.01/07 18/11/2024  11.05.31  by  Michael Scheer
*CMZ :  4.00/15 05/04/2022  11.56.08  by  Michael Scheer
*CMZ :  3.04/00 04/01/2018  18.10.43  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.66/20 06/07/2011  09.41.56  by  Michael Scheer
*CMZ :  2.63/05 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.61/02 14/03/2007  15.48.38  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  10.55.32  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  11.25.52  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  2.12/00 02/06/99  13.56.19  by  Michael Scheer
*CMZ :  1.02/00 19/12/97  17.09.57  by  Michael Scheer
*CMZ : 00.02/01 18/12/96  11.40.20  by  Michael Scheer
*CMZ : 00.01/10 16/07/96  14.53.50  by  Michael Scheer
*CMZ : 00.01/09 11/04/96  17.41.50  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  09.51.12  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.41.55  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.31  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE TRACKBMAG(ISNORDER,X1,Y1,Z1,VX1,VY1,VZ1,
     &                      XF0,YF0,ZF0,EWSFX,EWSFY,EWSFZ,
     &  X2,Y2,Z2,VX2,VY2,VZ2,DTIM,BSHIFT,GAMMA,IMag,
     &  BMOVECUT,iustep,ieneloss,ifour)
+seq,gplhint.

C--- CLONE OF TRACKSHORT, BUT CALLING BDI or BDH INSTEAD OF MYBFELD


C---     INPUT:
C     ISNORDER   order of tracking
C     X1,Y1,Z1    coordinates of electron at the starting point
C     VX1,VY1,VZ1    velocity at the starting point
C     XF0,YF0,ZF0    point of the plane where tracking stops
C     EWSFX,EWSFY,EWSFZ normal vector of the plane
C     DTIM        time intervall of one tracking step
C     BSHIFT         fraction of step where magnetic field is
C              determined for this step
C     GAMMA       relativistic factor
c     ifour: dipole is of type DIF

C---  OUTPUT:
C     X2,Y2,Z2    final coordinates of the electron
C     VX2,VY2,VZ2    final velocity of the electron

      IMPLICIT NONE

      INTEGER ISNORDER
      INTEGER IM,IUSTEP,IENELOSS,imag,ifour

      DOUBLE PRECISION X1,Y1,Z1,VX1,VY1,VZ1,X2,Y2,Z2,VX2,VY2,VZ2
     &  ,DTIM,BSHIFT,X2B,Y2B,Z2B,BX1,BY1,BZ1,BX2,BY2,BZ2
     &  ,GAMMA,DT,VXDUM,VYDUM,VZDUM,VXPDUM,VYPDUM,VZPDUM
     &  ,X2INT,Y2INT,Z2INT,DDT,DDDT,DDT2
     &  ,VX2INT,VY2INT,VZ2INT,VXPINT,VYPINT,VZPINT
     &  ,VXP,VYP,VZP,XOLD,YOLD,ZOLD,VXOLD,VYOLD,VZOLD
     &  ,X3INT,Y3INT,Z3INT,VX3INT,VY3INT,VZ3INT,DDDDT,DDDDT2
     &  ,EWSFX,EWSFY,EWSFZ,XF0,YF0,ZF0,DIST1,DIST2,DISTI,BMOVECUT

      DOUBLE PRECISION T1,T2
     &  ,DGAMMA

+SEQ,B0SCGLOB.
+SEQ,PHYCON.

      IF (IENELOSS.NE.0) THEN
        WRITE(16,*)
        WRITE(16,*)
     &    ' *** WARNING IN TRACKBMAG: IENELOSS .NE. 0, NOT YET IMPLEMENTED ***'
        WRITE(16,*)
     &    ' *** BE CAREFUL!! ***'
        WRITE(16,*)
        WRITE(6,*)
        WRITE(6,*)
     &    ' *** WARNING IN TRACKBMAG: IENELOSS .NE. 0, NOT YET IMPLEMENTED ***'
        WRITE(6,*)
     &    ' *** BE CAREFUL!! ***'
        WRITE(6,*)
      ENDIF

      im=iabs(imag)

      DT=DTIM*BSHIFT

      T1=0.0

      BX1=0.D0
      BY1=0.D0
      BZ1=0.D0

      XOLD=X1
      YOLD=Y1
      ZOLD=Z1
      VXOLD=VX1
      VYOLD=VY1
      VZOLD=VZ1

      X2=X1
      Y2=Y1
      Z2=Z1
      T2=T1

      VX2=VX1
      VY2=VY1
      VZ2=VZ1

      BX2=BX1
      BY2=BY1
      BZ2=BZ1

C--- LOOP DER TRAJEKTORIE

1000  X1=X2
      Y1=Y2
      Z1=Z2

      T1=T2

      VX1=VX2
      VY1=VY2
      VZ1=VZ2

      BX1=BX2
      BY1=BY2
      BZ1=BZ2

      IF (ISNORDER.EQ.0) THEN

        X2B=X1+VX1*DT
        Y2B=Y1+VY1*DT
        Z2B=Z1+VZ1*DT

      ELSE

        CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX1,BY1,BZ1,DT,X2B,Y2B,Z2B,
     &    VXDUM,VYDUM,VZDUM,VXPDUM,VYPDUM,VZPDUM,GAMMA,ICHARGE,BMOVECUT,
     &    IUSTEP,IENELOSS,DGAMMA)

      ENDIF

      if (imag.gt.0) then
        if (ifour.eq.0) then
          CALL BDI(X2B,Y2B,Z2B,BX2,BY2,BZ2,IM)
        else
          CALL BDI(X2B,Y2B,Z2B,BX2,BY2,BZ2,-IM)
        endif
      else
        CALL BDH(X2B,Y2B,Z2B,BX2,BY2,BZ2,IM)
      endif

      CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DTIM,
     &  X2,Y2,Z2,VX2,VY2,VZ2,VXP,VYP,VZP,GAMMA,ICHARGE,BMOVECUT,
     &  IUSTEP,IENELOSS,DGAMMA)

      T2=T1+DTIM

C EWSF IS NORMAL VECTOR OF PERPENDICULARE PLANE AT THE END OF THE REFERENCE ORBI
C DIST IS DISTANCE OF ELECTRON TO THIS PLANE
C TRACKING STOPS IF TRAJECTORIE HITS THIS PLANE

      DIST2=(X2-XF0)*EWSFX+(Y2-YF0)*EWSFY+(Z2-ZF0)*EWSFZ

      IF ( DIST2 .LT. 0.0  )  GOTO 1000

C--- ENDE OF TRAJECTORY, DIST2 NOT EXACTLY ZERO, CORRECT X2

      DIST1=(X1-XF0)*EWSFX+(Y1-YF0)*EWSFY+(Z1-ZF0)*EWSFZ

      DDT=DTIM*DABS(DIST1)/(DABS(DIST1)+DABS(DIST2))
      DDT2=DDT*BSHIFT

      IF(ISNORDER.EQ.0) THEN

         X2B=X1+VX1*DDT2
         Y2B=Y1+VY1*DDT2
         Z2B=Z1+VZ1*DDT2

      ELSE

         CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX1,BY1,BZ1,DDT2,X2B,Y2B,Z2B,
     &     VXDUM,VYDUM,VZDUM,VXPDUM,VYPDUM,VZPDUM,GAMMA,ICHARGE,BMOVECUT,IUSTEP,IENELOSS,DGAMMA)

       ENDIF

       if (imag.gt.0) then
         CALL BDI(X2B,Y2B,Z2B,BX2,BY2,BZ2,IM)
       else
         CALL BDH(X2B,Y2B,Z2B,BX2,BY2,BZ2,IM)
       endif

       CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DDT,
     &   X2INT,Y2INT,Z2INT,VX2INT,VY2INT,VZ2INT,
     &   VXPINT,VYPINT,VZPINT,GAMMA,ICHARGE,BMOVECUT,IUSTEP,IENELOSS,DGAMMA)

       DISTI=(X2INT-XF0)*EWSFX+(Y2INT-YF0)*EWSFY+(Z2INT-ZF0)*EWSFZ
       DDDT=DDT
       IF (DIST1.NE.0.) DDDT=DDT-DDT*DISTI/DABS(DIST1)

       CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DDDT,
     &   X3INT,Y3INT,Z3INT,VX3INT,VY3INT,VZ3INT,
     &   VXPINT,VYPINT,VZPINT,GAMMA,ICHARGE,BMOVECUT,IUSTEP,IENELOSS,DGAMMA)

       DISTI=(X3INT-XF0)*EWSFX+(Y3INT-YF0)*EWSFY+(Z3INT-ZF0)*EWSFZ
       DDDDT=DDDT
       IF (DIST1.NE.0.) DDDDT=DDDT-DDDT*DISTI/DABS(DIST1)
       DDDDT2=BSHIFT*DDDDT

       CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DDDDT,
     &   X2,Y2,Z2,VX2,VY2,VZ2,
     &   VXP,VYP,VZP,GAMMA,ICHARGE,BMOVECUT,IUSTEP,IENELOSS,DGAMMA)

       T2=T1+DDDDT

       X1=XOLD
       Y1=YOLD
       Z1=ZOLD
       VX1=VXOLD
       VY1=VYOLD
       VZ1=VZOLD

      RETURN
      END
+DECK,TRACKS.
*CMZ :  4.00/15 05/04/2022  15.56.45  by  Michael Scheer
*CMZ :  3.06/00 06/12/2021  12.45.27  by  Michael Scheer
*CMZ :  3.05/06 17/07/2018  11.15.17  by  Michael Scheer
*CMZ :  3.05/03 16/05/2018  15.59.18  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.10.30  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.70/04 21/12/2012  11.45.01  by  Michael Scheer
*CMZ :  2.69/02 05/11/2012  13.19.45  by  Michael Scheer
*CMZ :  2.69/01 31/10/2012  10.05.04  by  Michael Scheer
*CMZ :  2.69/00 30/10/2012  15.53.37  by  Michael Scheer
*CMZ :  2.68/05 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.67/04 11/05/2012  11.18.26  by  Michael Scheer
*CMZ :  2.66/18 01/12/2010  16.35.59  by  Michael Scheer
*CMZ :  2.66/00 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.65/02 28/09/2009  12.44.41  by  Michael Scheer
*CMZ :  2.64/01 18/08/2009  11.35.40  by  Michael Scheer
*CMZ :  2.63/05 17/08/2009  14.16.11  by  Michael Scheer
*CMZ :  2.61/02 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  10.59.41  by  Michael Scheer
*CMZ :  2.52/16 21/01/2005  17.09.20  by  Michael Scheer
*CMZ :  2.50/00 16/04/2004  09.24.47  by  Michael Scheer
*CMZ :  2.41/13 14/04/2004  13.21.28  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  11.26.17  by  Michael Scheer
*CMZ :  2.16/08 25/10/2000  12.21.53  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.33  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  16.16.11  by  Michael Scheer
*CMZ :  2.12/02 15/06/99  10.22.14  by  Michael Scheer
*CMZ :  2.12/00 02/06/99  13.58.22  by  Michael Scheer
*CMZ :  2.11/01 12/05/99  17.27.41  by  Michael Scheer
*CMZ :  2.11/00 12/05/99  12.12.31  by  Michael Scheer
*CMZ :  2.10/01 18/02/99  11.14.28  by  Michael Scheer
*CMZ :  1.04/03 11/12/98  11.42.46  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  09.52.03  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.43.20  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.32  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE TRACKS(ISOUR)
+seq,gplhint.

      use bunchmod

+SEQ,TRACKF90U.

+SELF,IF=F90.
+SEQ,SOURCEF90U.
+SELF.
      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,PHYCON.
+SEQ,OPTIC.
+SEQ,TRACK.
+seq,sourcef90.
+seq,reargf90.
+SEQ,B0SCGLOB.
+SEQ,PRIMKIN.

      INTEGER ISOUR,IZAEHL,IC,JC,IWARN,iroi,kroi

      DOUBLE PRECISION X1,Y1,Z1,VX1,VY1,VZ1,BX1,BY1,BZ1,VXP,VYP,VZP
      DOUBLE PRECISION X2,Y2,Z2,VX2,VY2,VZ2,BX2,BY2,BZ2,BSQ,BS
      DOUBLE PRECISION X2B,Y2B,Z2B
      DOUBLE PRECISION VXDUM,VYDUM,VZDUM,VXPDUM,VYPDUM,VZPDUM
      DOUBLE PRECISION XENDSOU,DTIM,DT2,ECDUM,dtim00,tlen,AX2D,AY2D,AZ2D
      DOUBLE PRECISION GAMMA,DGAMSUM,DGAMMA,BETA,VN,
     &  xf,yf,zf,vxf,vyf,vzf,dtshort

      integer lstep
+self,if=trbspline.
C MYBFELD{
      INTEGER KLO,KHI,K,KD,lstep
      DOUBLE PRECISION H,A,B,A3A,B3B,H26,H1,DXXA
      DATA KLO/1/
C MYBFELD}
+self...,if=trbspline.

      DATA IWARN/0/

C--- START OF TRACKING

      if (ibunch.eq.0) then

        GAMMA=SOURCEG(1,1,ISOUR)
        BETA=DSQRT((1.D0-1.D0/GAMMA)*(1.D0+1.D0/GAMMA))

        X1=SOURCEA(1,1,ISOUR)
        Y1=SOURCEA(2,1,ISOUR)
        Z1=SOURCEA(3,1,ISOUR)

        VX1=SOURCEA(1,2,ISOUR)
        VY1=SOURCEA(2,2,ISOUR)
        VZ1=SOURCEA(3,2,ISOUR)

      else !ibunch

        gamma=egamma
        beta=dsqrt((1.0d0-1.0d0/gamma)*(1.0d0+1.0d0/gamma))

        x1=xelec
        y1=yelec
        z1=zelec

        vx1=vxelec
        vy1=vyelec
        vz1=vzelec

        xf=sourcea(1,1,isour)
        yf=sourcea(2,1,isour)
        zf=sourcea(3,1,isour)

        vxf=sourcea(1,2,isour)
        vyf=sourcea(2,2,isour)
        vzf=sourcea(3,2,isour)

        dtim=1.0/dble(myinum)/clight1

        call trackshort(0,x1,y1,z1,vx1,vy1,vz1,
     &    xf,yf,zf,vxf,vyf,vzf,
     &    x2,y2,z2,dtshort,vx2,vy2,vz2,dtim,0.5d0,egamma,bmovecut,iustep,ieneloss,
     &    dgamma)

        gamma=egamma+dgamma

        x1=x2
        y1=y2
        z1=z2

        vx1=vx2
        vy1=vy2
        vz1=vz2

      endif !ibunch

      BX1=SOURCEA(1,4,ISOUR)
      BY1=SOURCEA(2,4,ISOUR)
      BZ1=SOURCEA(3,4,ISOUR)

      lstep=0

      kroi=1
      do iroi=1,nroi
        if (x1.gt.roix(iroi)) kroi=iroi
      enddo

      IF (ISOUR.NE.ISOURO) THEN

        ECSOUR(1,ISOUR)=0.0
        ECSOUR(2,ISOUR)=0.0
        ECSOUR(3,ISOUR)=0.0
        ECSOUR(4,ISOUR)=0.0
        ECMAX(   ISOUR)=-1.D30

        IZTOT(ISOUR)=0
      ENDIF !ISOUR

C--- STEP SIZE ACCORDING TO SOURCE LENGTH AND NUMBER OF STEPS

      XENDSOU=SOURCEE(1,1,ISOUR)    !FINAL X

C- ATTENTION: STEP SIZE IS DIFFERENT FOR EACH SOURCE POINT !!

c      DTIM=(XENDSOU-X1)/(NLPOI-1)/CLIGHT1
      tlen=sourcet(2,isour)-sourcet(1,isour)
      dtim=tlen/(nlpoi-1) !in TRASOU wird hier durch NSOURCE dividiert!??
      dtim00=dtim
      DT2=DTIM/2.D0

C- CHECK NUMBER OF STEPS

      IF (IWARN.EQ.0) THEN
        IF (NLPOIO/(SOURCEEO(1,1,NSOURCE)-SOURCEAO(1,1,1)).LT.MYINUM) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN TRACKS ***'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'STEP SIZE FOR SOURCE POINT IS LOWER THAN STEP'
          WRITE(LUNGFO,*)'SIZE FOR TRAJECTORY!'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'INCREASE NLPOI OR BE AWARE OF STRANGE RESULTS!'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN TRACKS ***'
          WRITE(6,*)
          WRITE(6,*)'STEP SIZE FOR SOURCE POINT IS LOWER THAN STEP'
          WRITE(6,*)'SIZE FOR TRAJECTORY!'
          WRITE(6,*)
          WRITE(6,*)'INCREASE NLPOI OR BE AWARE OF STRANGE RESULTS!'
          WRITE(6,*)
        ENDIF
        IWARN=1
      ENDIF


      X2=X1
      Y2=Y1
      Z2=Z1

      VX2=VX1
      VY2=VY1
      VZ2=VZ1

      BX2=BX1
      BY2=BY1
      BZ2=BZ1

      IZAEHL=0 !LOOP COUNTER

C--- LOOP OVER STEPS

1000  IZAEHL=IZAEHL+1

      if (x2.gt.roix(kroi+1)) then
        kroi=kroi+1
        dtim=dtim00/roip(kroi)
      endif

      IF (LSTEP.EQ.1) THEN

        IF (X2.LE.XENDSOU) THEN

          DTIM=(XENDSOU-X2)/VX2/roip(kroi)
          DT2=DTIM/2.0D0

        ELSE

          DTIM=(XENDSOU-X1)/VX2/roip(kroi)
          DT2=DTIM/2.0D0

          X2=X1
          Y2=Y1
          Z2=Z1

          VX2=VX1
          VY2=VY1
          VZ2=VZ1

          BX2=BX1
          BY2=BY1
          BZ2=BZ1

          IZAEHL=IZAEHL-1

        ENDIF

      ENDIF !LSTEP.EQ.1

      IF (IZAEHL.GT.NDWSOU) THEN

        print*,IZAEHL,NDWSOU
        print*,X2

        WRITE(LUNGFO,*)'*** ERROR IN SR TRACKS ***'
        WRITE(LUNGFO,*)
     &    'TOO MANY STEPS, INCREASE PARAMETER NBADDP IN SOURCE.CMN'
        WRITE(6,*)'*** ERROR IN SR TRACKS ***'
        WRITE(6,*)
     &    'TOO MANY STEPS, INCREASE PARAMETER NBADDP IN SOURCE.CMN'
        STOP

      ENDIF

      X1=X2
      Y1=Y2
      Z1=Z2

      VX1=VX2
      VY1=VY2
      VZ1=VZ2

      IF (ISNORDER.EQ.0) THEN

        BX1=BX2
        BY1=BY2
        BZ1=BZ2

        X2B=X1+VX1*DT2
        Y2B=Y1+VY1*DT2
        Z2B=Z1+VZ1*DT2

      ELSE

        CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX1,BY1,BZ1,DT2,
     &    X2B,Y2B,Z2B,
     &    VXDUM,VYDUM,VZDUM,VXPDUM,VYPDUM,VZPDUM,GAMMA,ICHARGE,BMOVECUT,IUSTEP,IENELOSS,DGAMMA)

      ENDIF

+self,if=trbspline.
C MYBFELD{

      IF (X2B.LT.XAMAG(1)) THEN
        DXXA=(X2B-XAMAG(1))/(XAMAG(2)-XAMAG(1))
        IF (XAMAG(1)-X2B.LT.2.*(XAMAG(2)-XAMAG(1))) THEN
          BX2=BXAMAG(1)+(BXAMAG(2)-BXAMAG(1))*DXXA
          BY2=BYAMAG(1)+(BYAMAG(2)-BYAMAG(1))*DXXA
          BZ2=BZAMAG(1)+(BZAMAG(2)-BZAMAG(1))*DXXA
          GOTO 88
        ELSE
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN TRACKS: X OUT OF RANGE ***'
          WRITE(LUNGFO,*)'TRY TO INCREASE NPLOI OR TO DECREASE MYINUM'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN TRACKS: X OUT OF RANGE ***'
          WRITE(6,*)'TRY TO INCREASE NPLOI OR TO DECREASE MYINUM'
          WRITE(6,*)
          STOP
        ENDIF
      ENDIF

      IF (X2B.GT.XAMAG(NCO)) THEN
        DXXA=(X2B-XAMAG(NCO))/(XAMAG(NCO)-XAMAG(NCO-1))
        IF (X2B-XAMAG(NCO).LT.2.*(XAMAG(NCO)-XAMAG(NCO-1))) THEN
          BX2=BXAMAG(NCO-1)+(BX2A(NCO)-BXAMAG(NCO-1))*DXXA
          BY2=BYAMAG(NCO-1)+(BY2A(NCO)-BYAMAG(NCO-1))*DXXA
          BZ2=BZAMAG(NCO-1)+(BZ2A(NCO)-BZAMAG(NCO-1))*DXXA
          GOTO 88
        ELSE
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN TRACKS: X OUT OF RANGE ***'
          WRITE(LUNGFO,*)'TRY TO INCREASE NPLOI OR TO DECREASE MYINUM'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN TRACKS: X OUT OF RANGE ***'
          WRITE(6,*)'TRY TO INCREASE NPLOI OR TO DECREASE MYINUM'
          WRITE(6,*)
          STOP
        ENDIF
      ENDIF

C--- BMAG_SPLINE_INTER_XYZ{

      IF (XAMAG(1).LT.XAMAG(NCO).AND.(X2B.LT.XAMAG(1)
     &    .OR.X2B.GT.XAMAG(NCO))
     &    .OR.
     &    XAMAG(NCO).LT.XAMAG(1).AND.(X2B.LT.XAMAG(NCO)
     &    .OR.X2B.GT.XAMAG(1))) THEN
        STOP '*** ERROR IN TRACKS: X OUT OF RANGE ***'
      ENDIF

      IF (X2B.GE.XAMAG(KLO)) THEN

C HUNT UP
        KD=1
11      KHI=MIN(KLO+KD,NCO)
        IF (X2B.GT.XAMAG(KHI)) THEN
          KD=2*KD
          KLO=KHI
          GOTO 11
        ENDIF

      ELSE    !(X2B.GE.XAMAG(KLO))

C HUNT DOWN
        KD=1
        KHI=KLO
22      KLO=MAX(KHI-KD,1)
        IF (X2B.LT.XAMAG(KLO)) THEN
          KD=2*KD
          KHI=KLO
          GOTO 22
        ENDIF

      ENDIF

1     IF (KHI-KLO.GT.1) THEN
        K=(KHI+KLO)/2
        IF(XAMAG(K).GT.X2B)THEN
          KHI=K
        ELSE
          KLO=K
        ENDIF
        GOTO 1
      ENDIF

      H=XAMAG(KHI)-XAMAG(KLO)

      IF (H.EQ.0.) THEN
        WRITE(6,*) '*** ERROR IN TRACKS: BAD INPUT ***'
        STOP
      ENDIF

      H1=1.D0/H
      H26=H*H/6.D0
      A=(XAMAG(KHI)-X2B)*H1
      B=(X2B-XAMAG(KLO))*H1
      A3A=A*A*A-A
      B3B=B*B*B-B

      BX2=A*BXAMAG(KLO)+B*BXAMAG(KHI)+(A3A*BX2A(KLO)+B3B*BX2A(KHI))*H26
      BY2=A*BYAMAG(KLO)+B*BYAMAG(KHI)+(A3A*BY2A(KLO)+B3B*BY2A(KHI))*H26
      BZ2=A*BZAMAG(KLO)+B*BZAMAG(KHI)+(A3A*BZ2A(KLO)+B3B*BZ2A(KHI))*H26

C--- BMAG_SPLINE_INTER_XYZ}

88    CONTINUE
+self,if=-trbspline.
      CALL MYBFELD(X2B,Y2B,Z2B,BX2,BY2,BZ2,AX2D,AY2D,AZ2D)
+self. trbspline

C MYBFELD}

      CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DTIM,
     &  X2,Y2,Z2,VX2,VY2,VZ2,VXP,VYP,VZP,
     &  GAMMA,ICHARGE,BMOVECUT,IUSTEP,IENELOSS,DGAMMA)

      IF (IENELOSS.NE.0.and.lstep.eq.0) THEN
        DGAMSUM=DGAMSUM+DGAMMA
        IF (ABS(DGAMSUM).GT.GAMMA*1.0D-8) THEN
          GAMMA=GAMMA+DGAMSUM
          DGAMSUM=0.0D0
        ENDIF
        BETA=DSQRT((1.D0-1.D0/GAMMA)*(1.D0+1.D0/GAMMA))
        VN=SQRT(VX2*VX2+VY2*VY2+VZ2*VZ2)
        VX2=VX2/VN*CLIGHT1*BETA
        VY2=VY2/VN*CLIGHT1*BETA
        VZ2=VZ2/VN*CLIGHT1*BETA
      ENDIF

C- STORE POINT

      WSOU(1,1,IZAEHL)=X2
      WSOU(2,1,IZAEHL)=Y2
      WSOU(3,1,IZAEHL)=Z2

      WSOU(1,2,IZAEHL)=VX2
      WSOU(2,2,IZAEHL)=VY2
      WSOU(3,2,IZAEHL)=VZ2

      WSOU(1,3,IZAEHL)=VXP
      WSOU(2,3,IZAEHL)=VYP
      WSOU(3,3,IZAEHL)=VZP

      WSOU(1,4,IZAEHL)=DTIM
      WSOU(2,4,IZAEHL)=BETA
      WSOU(3,4,IZAEHL)=GAMMA

      WSOU(1,5,IZAEHL)=bX2
      WSOU(2,5,IZAEHL)=bY2
      WSOU(3,5,IZAEHL)=bZ2

      BSQ=BX2*BX2+BY2*BY2+BZ2*BZ2
      BS=SQRT(BSQ)

      ECSOUR(1,ISOUR)=ECSOUR(1,ISOUR)+BS
      ECSOUR(4,ISOUR)=ECSOUR(4,ISOUR)+DSIGN(BS,BY2)
      ECSOUR(3,ISOUR)=ECSOUR(3,ISOUR)+BSQ

      IF (ECMAX(ISOUR).LT.DSQRT(BSQ)) ECMAX(ISOUR)=BS

C--- END OF LOOP

c      IF (X2.LT.XENDSOU)  GOTO 1000
      IF (X2.LT.XENDSOU-2.0d0*VX2*DTIM.AND.LSTEP.EQ.0)
     &  GOTO 1000

      IF (LSTEP.EQ.0) THEN
        LSTEP=1
        GOTO 1000
      ENDIF

C- STORE NUMBER OF POINTS FOR INTEGRATION

      IPOISOU(ISOUR)=IZAEHL
CV2------------------------------------------------------
      IZTOT(ISOUR)=IZTOT(ISOUR)+IZAEHL

CERR101292      DO JC=1,3
      DO JC=1,2
        DO IC=1,3
cERR190220          SOURCEA(IC,JC,ISOUR)=WSOU(IC,JC,IZAEHL)
          SOURCEE(IC,JC,ISOUR)=WSOU(IC,JC,IZAEHL)
        ENDDO
      ENDDO

cERR190220       SOURCEA(1,4,ISOUR)=BX2
cERR190220       SOURCEA(2,4,ISOUR)=BY2
cERR190220       SOURCEA(3,4,ISOUR)=BZ2

      SOURCEE(1,4,ISOUR)=BX2
      SOURCEE(2,4,ISOUR)=BY2
      SOURCEE(3,4,ISOUR)=BZ2

CV2------------------------------------------------------


CV2------------------------------------------------------
      IF (NSADD.NE.0) THEN
CV2------------------------------------------------------

        ECSOUR(1,ISOUR)=ECSOUR(1,ISOUR)/IZTOT(ISOUR)
        ECSOUR(4,ISOUR)=ECSOUR(4,ISOUR)/IZTOT(ISOUR)
        ECSOUR(3,ISOUR)=ECSOUR(3,ISOUR)/IZTOT(ISOUR)
        ECDUM=ECSOUR(3,ISOUR)-ECSOUR(1,ISOUR)**2
        IF (ECDUM.LT.0.0) ECDUM=0.
        ECSOUR(3,ISOUR)=DSQRT(ECDUM)/ECSOUR(1,ISOUR)
        ECSOUR(2,ISOUR)=ECSOUR(1,ISOUR)*ecdipev1*DMYENERGY**2   !CRITICAL ENERGY
C260194  IF (IUNIT.NE.0)  ECSOUR(2,ISOUR)=ECSOUR(2,ISOUR)/WTOE1
        IF (IUNIT.NE.0)  ECSOUR(2,ISOUR)=WTOE1/ECSOUR(2,ISOUR)

CV2------------------------------------------------------
      ENDIF !NSADD
CV2------------------------------------------------------


      RETURN
      END
+DECK,TRACKSOLD.
*CMZ :  3.05/06 17/07/2018  11.15.17  by  Michael Scheer
*CMZ :  3.05/03 16/05/2018  16.01.42  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.10.30  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.67/04 11/05/2012  11.18.26  by  Michael Scheer
*CMZ :  2.61/02 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  10.48.09  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  11.27.13  by  Michael Scheer
*CMZ :  2.16/08 20/10/2000  11.44.50  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  2.12/02 15/06/99  10.22.14  by  Michael Scheer
*CMZ :  2.12/01 14/06/99  15.14.15  by  Michael Scheer
*CMZ :  2.10/01 18/02/99  11.14.28  by  Michael Scheer
*CMZ :  1.04/03 11/12/98  11.42.46  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  09.52.03  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.43.20  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.32  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE TRACKSOLD(ISOUR)
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SOURCEF90U.
+SELF.

         IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,PHYCON.
+SEQ,OPTIC.
+seq,sourcef90.
+SEQ,B0SCGLOB.

         INTEGER ISOUR,IZAEHL,IC,JC

          DOUBLE PRECISION X1,Y1,Z1,VX1,VY1,VZ1,BX1,BY1,BZ1,VXP,VYP,VZP
          DOUBLE PRECISION X2,Y2,Z2,VX2,VY2,VZ2,BX2,BY2,BZ2,BSQ,BS
          DOUBLE PRECISION X2B,Y2B,Z2B,AX2,AY2,AZ2
          DOUBLE PRECISION VXDUM,VYDUM,VZDUM,VXPDUM,VYPDUM,VZPDUM
          DOUBLE PRECISION XENDSOU,DTIM,DT2,ECDUM

C--- START OF TRACKING

         X1=SOURCEA(1,1,ISOUR)
         Y1=SOURCEA(2,1,ISOUR)
         Z1=SOURCEA(3,1,ISOUR)

         VX1=SOURCEA(1,2,ISOUR)
         VY1=SOURCEA(2,2,ISOUR)
         VZ1=SOURCEA(3,2,ISOUR)

CERR10.1292    BX1=SOURCEA(1,3,ISOUR)
CERR10.1292    BY1=SOURCEA(2,3,ISOUR)
CERR10.1292    BZ1=SOURCEA(3,3,ISOUR)

          BX1=SOURCEA(1,4,ISOUR)
          BY1=SOURCEA(2,4,ISOUR)
          BZ1=SOURCEA(3,4,ISOUR)

CV2------------------------------------------------------
          IF (ISOUR.NE.ISOURO) THEN
CV2------------------------------------------------------
         ECSOUR(1,ISOUR)=0.0
         ECSOUR(2,ISOUR)=0.0
         ECSOUR(3,ISOUR)=0.0
         ECSOUR(4,ISOUR)=0.0
         ECMAX(   ISOUR)=-1.D30

CV2------------------------------------------------------
          IZTOT(ISOUR)=0
          ENDIF !ISOUR
CV2------------------------------------------------------
C--- STEP SIZE ACCORDING TO SOURCE LENGTH AND NUMBER OF STEPS

         XENDSOU=SOURCEE(1,1,ISOUR)    !FINAL X

C- ATTENTION: STEP SIZE IS DIFFERENT FOR EACH SOURCE POINT !!

         DTIM=(XENDSOU-X1)/NLPOI/CLIGHT1
         DT2=DTIM/2.D0

C- CHECK NUMBER OF STEPS

         IF (NLPOI/(XENDSOU-X1).LT.MYINUM) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'*** WARNING SR TRACKSOLD ***'
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'STEP SIZE FOR SOURCE POINT IS LOWER THAN STEP'
         WRITE(LUNGFO,*)'SIZE FOR TRAJECTORY!'
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'INCREASE NLPOI OR BE AWARE OF STRANGE RESULTS!'
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)'*** WARNING SR TRACKSOLD ***'
         WRITE(6,*)
         WRITE(6,*)'STEP SIZE FOR SOURCE POINT IS LOWER THAN STEP'
         WRITE(6,*)'SIZE FOR TRAJECTORY!'
         WRITE(6,*)
         WRITE(6,*)'INCREASE NLPOI OR BE AWARE OF STRANGE RESULTS!'
         WRITE(6,*)
         ENDIF


         X2=X1
         Y2=Y1
         Z2=Z1

         VX2=VX1
         VY2=VY1
         VZ2=VZ1

         BX2=BX1
         BY2=BY1
         BZ2=BZ1

         IZAEHL=0 !LOOP COUNTER

C--- LOOP OVER STEPS

1000     IZAEHL=IZAEHL+1

         IF (IZAEHL.GT.NDWSOU) THEN

         WRITE(LUNGFO,*)'*** ERROR IN SR TRACKSOLD ***'
         WRITE(LUNGFO,*)
     &'TOO MANY STEPS, INCREASE PARAMETER NBADDP IN SOURCE.CMN'
         WRITE(6,*)'*** ERROR IN SR TRACKSOLD ***'
         WRITE(6,*)
     &'TOO MANY STEPS, INCREASE PARAMETER NBADDP IN SOURCE.CMN'
         STOP

         ENDIF

         X1=X2
         Y1=Y2
         Z1=Z2

         VX1=VX2
         VY1=VY2
         VZ1=VZ2

      IF (ISNORDER.EQ.0) THEN

         BX1=BX2
         BY1=BY2
         BZ1=BZ2

         X2B=X1+VX1*DT2
         Y2B=Y1+VY1*DT2
         Z2B=Z1+VZ1*DT2

      ELSE

         CALL BMOVE(X1,Y1,Z1,VX1,VY1,VZ1,BX1,BY1,BZ1,DT2,
     &     X2B,Y2B,Z2B,
     &     VXDUM,VYDUM,VZDUM,VXPDUM,VYPDUM,VZPDUM,DMYGAMMA,ICHARGE,BMOVECUT,IUSTEP)

      ENDIF

         CALL MYBFELD(X2B,Y2B,Z2B,BX2,BY2,BZ2,AX2,AY2,AZ2)

         CALL BMOVE(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DTIM,
     &     X2,Y2,Z2,VX2,VY2,VZ2,VXP,VYP,VZP,DMYGAMMA,ICHARGE,BMOVECUT,IUSTEP)

C- STORE POINT

          WSOU(1,1,IZAEHL)=X2
          WSOU(2,1,IZAEHL)=Y2
          WSOU(3,1,IZAEHL)=Z2
        wsou(1,4,IZAEHL)=DTIM

          WSOU(1,2,IZAEHL)=VX2
          WSOU(2,2,IZAEHL)=VY2
          WSOU(3,2,IZAEHL)=VZ2

          WSOU(1,3,IZAEHL)=VXP
          WSOU(2,3,IZAEHL)=VYP
          WSOU(3,3,IZAEHL)=VZP

          BSQ=BX2**2+BY2**2+BZ2**2
          BS=DSQRT(BSQ)
          ECSOUR(1,ISOUR)=ECSOUR(1,ISOUR)+BS
          ECSOUR(4,ISOUR)=ECSOUR(4,ISOUR)+DSIGN(BS,BY2)
          ECSOUR(3,ISOUR)=ECSOUR(3,ISOUR)+BSQ
          IF (ECMAX(ISOUR).LT.DSQRT(BSQ)) ECMAX(ISOUR)=BS

C--- END OF LOOP

      IF (X2.LT.XENDSOU)  GOTO 1000

C- STORE NUMBER OF POINTS FOR INTEGRATION

      IPOISOU(ISOUR)=IZAEHL
CV2------------------------------------------------------
          IZTOT(ISOUR)=IZTOT(ISOUR)+IZAEHL
CERR101292      DO JC=1,3
          DO JC=1,2
          DO IC=1,3
             SOURCEA(IC,JC,ISOUR)=WSOU(IC,JC,IZAEHL)
          ENDDO
          ENDDO
             SOURCEA(1,4,ISOUR)=BX2
             SOURCEA(2,4,ISOUR)=BY2
             SOURCEA(3,4,ISOUR)=BZ2
CV2------------------------------------------------------


CV2------------------------------------------------------
          IF (NSADD.NE.0) THEN
CV2------------------------------------------------------

      ECSOUR(1,ISOUR)=ECSOUR(1,ISOUR)/IZTOT(ISOUR)
      ECSOUR(4,ISOUR)=ECSOUR(4,ISOUR)/IZTOT(ISOUR)
      ECSOUR(3,ISOUR)=ECSOUR(3,ISOUR)/IZTOT(ISOUR)
      ECDUM=ECSOUR(3,ISOUR)-ECSOUR(1,ISOUR)**2
      IF (ECDUM.LT.0.0) ECDUM=0.
      ECSOUR(3,ISOUR)=DSQRT(ECDUM)/ECSOUR(1,ISOUR)
      ECSOUR(2,ISOUR)=ECSOUR(1,ISOUR)*ecdipev1*DMYENERGY**2   !CRITICAL ENERGY
C260194  IF (IUNIT.NE.0)  ECSOUR(2,ISOUR)=ECSOUR(2,ISOUR)/WTOE1
      IF (IUNIT.NE.0)  ECSOUR(2,ISOUR)=WTOE1/ECSOUR(2,ISOUR)

CV2------------------------------------------------------
          ENDIF !NSADD
CV2------------------------------------------------------


      RETURN
      END
+DECK,TRACKSPLN.
*CMZ :  2.63/03 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.16/08 16/04/2004  09.24.47  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  16.15.52  by  Michael Scheer
*CMZ :  2.10/01 17/02/99  15.53.29  by  Michael Scheer
*-- Author :    Michael Scheer   16/02/99

      SUBROUTINE TRACKSPLN(X1,DTIM,
     &                  X2,Y2,Z2,VX2,VY2,VZ2)
+seq,gplhint.

+SEQ,TRACKF90U,IF=F90.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,TRACK.

      INTEGER ICAL,I,ICOUNT

      DOUBLE PRECISION X1,DTIM,X2,Y2,Z2,VX2,VY2,VZ2,T1,T2,XDUM

      DOUBLE PRECISION S2T(NWMAXP),S2X(NWMAXP),S2Y(NWMAXP),S2Z(NWMAXP)
      DOUBLE PRECISION S2VX(NWMAXP),S2VY(NWMAXP),S2VZ(NWMAXP)
      DOUBLE PRECISION WS1(NWMAXP),WS2(NWMAXP),WS3(NWMAXP),WS4(NWMAXP)

      DOUBLE PRECISION XA(NWMAXP),YA(NWMAXP),ZA(NWMAXP)
      DOUBLE PRECISION VXA(NWMAXP),VYA(NWMAXP),VZA(NWMAXP)

      DATA ICAL/0/

+SELF,IF=F90.
      WRITE(6,*)'*** ERROR IN TRACKSPLN ***'
      WRITE(6,*)'*** ROUTINE NOT YET ADAPTED TO F90 ***'
      STOP
+SELF.

      IF (ICAL.EQ.0) THEN

            DO I=1,NCO

         XA(I)=WSXYZ(1,I)
         YA(I)=WSXYZ(2,I)
         ZA(I)=WSXYZ(3,I)

         VXA(I)=WVXYZ(1,I)
         VYA(I)=WVXYZ(2,I)
         VZA(I)=WVXYZ(3,I)

            ENDDO

            CALL util_spline_coef(XA,WTIM0,NCO,-9999.0d0,-9999.0d0,S2T,WS1,WS2,WS3,WS4)
          CALL TIME_SPLINE_INTER(XA,WTIM0,S2T,NCO,X1,T1,-1,ICOUNT)

            CALL util_spline_coef(WTIM0,XA,NCO,-9999.0d0,-9999.0d0,S2X,WS1,WS2,WS3,WS4)
            CALL util_spline_coef(WTIM0,YA,NCO,-9999.0d0,-9999.0d0,S2Y,WS1,WS2,WS3,WS4)
            CALL util_spline_coef(WTIM0,ZA,NCO,-9999.0d0,-9999.0d0,S2Z,WS1,WS2,WS3,WS4)

            CALL util_spline_coef(WTIM0,VXA,NCO,-9999.0d0,-9999.0d0,S2VX,WS1,WS2,WS3,WS4)
            CALL util_spline_coef(WTIM0,VYA,NCO,-9999.0d0,-9999.0d0,S2VY,WS1,WS2,WS3,WS4)
            CALL util_spline_coef(WTIM0,VZA,NCO,-9999.0d0,-9999.0d0,S2VZ,WS1,WS2,WS3,WS4)

          CALL XYZ_SPLINE_INTER(WTIM0,XA,S2X,NCO,T1,XDUM,-1,ICOUNT)

          ICAL=1

      ENDIF !ICAL

C--- GET T1 OF TIME X1

      CALL TIME_SPLINE_INTER(XA,WTIM0,S2T,NCO,X1,T1,0,ICOUNT)

C--- GET X2,Y2,Z2 OF TIME T2

      T2=T1+DTIM

      CALL XYZ_SPLINE_INTER(WTIM0,XA,S2X,NCO,T2,X2,0,ICOUNT)
      CALL XYZ_SPLINE_INTER(WTIM0,YA,S2Y,NCO,T2,Y2,0,ICOUNT)
      CALL XYZ_SPLINE_INTER(WTIM0,ZA,S2Z,NCO,T2,Z2,0,ICOUNT)

      CALL XYZ_SPLINE_INTER(WTIM0,VXA,S2VX,NCO,T2,VX2,0,ICOUNT)
      CALL XYZ_SPLINE_INTER(WTIM0,VYA,S2VY,NCO,T2,VY2,0,ICOUNT)
      CALL XYZ_SPLINE_INTER(WTIM0,VZA,S2VZ,NCO,T2,VZ2,0,ICOUNT)

      ICOUNT=0

      RETURN
      END



+DECK,tralin.
*CMZ :  4.00/07 07/06/2020  14.37.38  by  Michael Scheer
*CMZ :  3.05/16 09/10/2018  15.04.43  by  Michael Scheer
*CMZ :  3.05/10 08/08/2018  14.39.43  by  Michael Scheer
*CMZ :  3.04/00 12/01/2018  12.51.17  by  Michael Scheer
*CMZ :  3.03/04 04/12/2017  12.15.53  by  Michael Scheer
*CMZ :  3.00/01 02/04/2013  16.13.11  by  Michael Scheer
*CMZ :  2.68/02 01/08/2012  09.56.07  by  Michael Scheer
*CMZ :  2.66/07 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.63/05 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  2.61/01 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.61/00 30/01/2007  18.56.07  by  Michael Scheer
*CMZ :  2.59/02 24/01/2007  14.57.52  by  Michael Scheer
*CMZ :  2.59/01 24/01/2007  14.30.15  by  Michael Scheer
*CMZ :  2.58/00 16/01/2007  16.51.31  by  Michael Scheer
*CMZ :  2.48/04 12/03/2004  15.40.31  by  Michael Scheer
*CMZ :  2.47/14 01/08/2003  13.37.51  by  Michael Scheer
*CMZ :  2.47/12 01/07/2003  14.03.43  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  15.28.35  by  Michael Scheer
*CMZ :  2.34/05 23/08/2001  17.35.09  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ : 00.01/12 10/10/96  15.17.26  by  Michael Scheer
*CMZ : 00.01/10 04/06/96  10.40.08  by  Michael Scheer
*-- Author :    Michael Scheer   01/06/96
      SUBROUTINE TRALIN
+seq,gplhint.

C SIMPLE ESTIMATE OF LINEAR TRANSFER MATRIX

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,BMESSF90.
+SEQ,TRALIN.
+SEQ,DEPOLA.
+SEQ,PHASETRACK.
+SEQ,PHYCON.

      INTEGER I,IFAIL,J,IPHI,iw2(2)

      DOUBLE PRECISION DTIM,BSHIFT,DET,BETA,V0,D10
      DOUBLE PRECISION XI,YI,ZI,XF,YF,ZF,YPF,ZPF
      DOUBLE PRECISION XI0,YI0,ZI0,YPI0,ZPI0
      DOUBLE PRECISION VXI,VYI,VZI,VXF,VYF,VZF,XF0,YF0,ZF0,ZPF0,YPF0
      DOUBLE PRECISION VXI0,VYI0,VZI0,VXF0,VYF0,VZF0
      DOUBLE PRECISION WXI0,WYI0,WZI0
      DOUBLE PRECISION ERRZ,ERRZP,ERRY,ERRYP,ERRZ10,ERRZP10,ERRY10,ERRYP10
      DOUBLE PRECISION EWS(3),EWY(3),EWZ(3),EWSF(3),EWYF(3),EWZF(3)
      DOUBLE PRECISION DX,DY,DZ,DYP,DZP,WX,WY,WZ
      DOUBLE PRECISION RKXKY
      DOUBLE PRECISION XTM(4,2),eps,PHI,DPHI,CS,SN,dz0,dzp0,dy0,dyp0
     &  ,ZIPH,ZPIPH,YIPH,YPIPH,GAMMAL,a,b,g,beta0m(2,2),
     &  betahm(2,2),betavm(2,2),
     &  betahmi(2,2),betavmi(2,2),betahb,betahpb,betavb,betavpb,
     &  tfm22(2,2),tfmtr(2,2),dum22(2,2),bt(2,2),xrefold

      DATA BSHIFT/0.5D0/
      DATA D10/10.D0/

      write(lungfo,'(/a)')"      --- Entered TRALIN ---"
      write(lungfo,*)

      if (irfilb0.ne.0) then
        if (deltay*d10.gt.bmymax) then
          write(6,*)'*** Warning in TRALIN: DELTAY*10 out of range of field map ***'
          write(6,*)'*** Estimation of uncertainty of the transfer matrix will fail ***'
          write(lungfo,*)'*** Warning in TRALIN: DELTAY*10 out of range of field map ***'
          write(lungfo,*)'*** Estimation of uncertainty of the transfer matrix will fail ***'
        endif
        if (deltayp*(xstop-xstart)*d10.gt.bmymax) then
          write(6,*)'*** Warning in TRALIN: DELTAYP*(XSTOP-XSTART)*10 out of range of field map ***'
          write(6,*)'*** Estimation of uncertainty of the transfer matrix will fail ***'
          write(lungfo,*)'*** Warning in TRALIN: DELTAYP*(XSTOP-XSTART)*10 out of range of field map ***'
          write(lungfo,*)'*** Estimation of uncertainty of the transfer matrix will fail ***'
        endif
        if (deltaz*d10.gt.bmzmax) then
          write(6,*)'*** Warning in TRALIN: DELTAZ*10 out of range of field map ***'
          write(6,*)'*** Estimation of uncertainty of the transfer matrix will fail ***'
          write(lungfo,*)'*** Warning in TRALIN: DELTAZ*10 out of range of field map ***'
          write(lungfo,*)'*** Estimation of uncertainty of the transfer matrix will fail ***'
        endif
        if (deltazp*(xstop-xstart)*d10.gt.bmzmax) then
          write(6,*)'*** Warning in TRALIN: DELTAZP*(XSTOP-XSTART)*10 out of range of field map ***'
          write(6,*)'*** Estimation of uncertainty of the transfer matrix will fail ***'
          write(lungfo,*)'*** Warning in TRALIN: DELTAZP*(XSTOP-XSTART)*10 out of range of field map ***'
          write(lungfo,*)'*** Estimation of uncertainty of the transfer matrix will fail ***'
        endif
        if (deltay.gt.bmymax) then
          write(6,*)'*** Error in TRALIN: DELTAY out of range of field map ***'
          write(6,*)'*** Program WAVE aborted ***'
          write(lungfo,*)'*** Error in TRALIN: DELTAY out of range of field map ***'
          write(lungfo,*)'*** Program WAVE aborted ***'
          stop
        endif
        if (deltayp*(xstop-xstart).gt.bmymax) then
          write(6,*)'*** Error in TRALIN: DELTAYP*(XSTOP-XSTART) out of range of field map ***'
          write(6,*)'*** Program WAVE aborted ***'
          write(lungfo,*)'*** Error in TRALIN: DELTAYP*(XSTOP-XSTART) out of range of field map ***'
          write(lungfo,*)'*** Program WAVE aborted ***'
          stop
        endif
        if (deltaz.gt.bmzmax) then
          write(lungfo,*)'*** Error in TRALIN: DELTAZ out of range of field map ***'
          write(lungfo,*)'*** Program WAVE aborted ***'
          write(6,*)'*** Error in TRALIN: DELTAZ out of range of field map ***'
          write(6,*)'*** Program WAVE aborted ***'
          stop
        endif
        if (deltazp*(xstop-xstart).gt.bmzmax) then
          write(lungfo,*)'*** Error in TRALIN: DELTAZP*(XSTOP-XSTART) out of range of field map ***'
          write(lungfo,*)'*** Program WAVE aborted ***'
          write(6,*)'*** Error in TRALIN: DELTAZP*(XSTOP-XSTART) out of range of field map ***'
          write(6,*)'*** Program WAVE aborted ***'
          stop
        endif
      endif !(irfilb0.ne.0) then

      IF (IENELOSS.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    ' *** WARNING IN TRALIN: IENELOSS .NE. 0, NOT YET IMPLEMENTED ***'
        WRITE(LUNGFO,*)
     &    ' *** BE CAREFUL!! ***'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)
     &    ' *** WARNING IN TRALIN: IENELOSS .NE. 0, NOT YET IMPLEMENTED ***'
        WRITE(6,*)
     &    ' *** BE CAREFUL!! ***'
        WRITE(6,*)
      ENDIF

      IF (DELTAZ.EQ.0.D0) DELTAZ=0.00001
      IF (DELTAY.EQ.0.D0) DELTAY=0.00001
      IF (DELTAZP.EQ.0.D0) DELTAZP=0.00001
      IF (DELTAYP.EQ.0.D0) DELTAYP=0.00001

      BETA=DSQRT((1.D0-1.D0/DMYGAMMA)*(1.D0+1.D0/DMYGAMMA))
      V0=CLIGHT1*BETA
      WXI0=VXIN*V0
      WYI0=VYIN*V0
      WZI0=VZIN*V0
      DTIM=1.D0/(v0*myinum)

      XI=XSTART
      XI0=XI

C--- CLOSED ORBIT

      ZI0=ZSTART
      YI0=YSTART
      VXI0=VXIN
      VYI0=VYIN
      VZI0=VZIN
      ZPI0=VZIN/VXIN
      YPI0=VYIN/VXIN

      EWS(1)=VXI0
      EWS(2)=VYI0
      EWS(3)=VZI0

C EWS = [EWS,(0,1,0)]

      EWZ(1)=-EWS(3)
      EWZ(2)=0.D0
      EWZ(3)=+EWS(1)

C EWY = [EWZ,EWS]

      EWY(1)=EWZ(2)*EWS(3)-EWZ(3)*EWS(2)
      EWY(2)=EWZ(3)*EWS(1)-EWZ(1)*EWS(3)
      EWY(3)=EWZ(1)*EWS(2)-EWZ(2)*EWS(1)

      CALL TRACK(XI0,YI0,ZI0,WXI0,WYI0,WZI0
     &  ,XSTOP,0.D0,0.D0,1.D0,0.D0,0.D0
     &  ,XF0,YF0,ZF0,VXF0,VYF0,VZF0,DTIM,BSHIFT,DMYGAMMA,GAMMAL)

      ZPF0=VZF0/VXF0
      YPF0=VYF0/VXF0

      EWSF(1)=VXF0/V0
      EWSF(2)=VYF0/V0
      EWSF(3)=VZF0/V0

C EWSF = [EWSF,(0,1,0)]

      EWZF(1)=-EWSF(3)
      EWZF(2)=0.D0
      EWZF(3)=+EWSF(1)

C EWYF = [EWZF,EWSF]

      EWYF(1)=EWZF(2)*EWSF(3)-EWZF(3)*EWSF(2)
      EWYF(2)=EWZF(3)*EWSF(1)-EWZF(1)*EWSF(3)
      EWYF(3)=EWZF(1)*EWSF(2)-EWZF(2)*EWSF(1)

C--T(1:4,1):

      DZ=DELTAZ
      DY=0.0D0
      DZP=0.D0
      DYP=0.D0

      XI=XI0+DY*EWY(1)+DZ*EWZ(1)
      YI=YI0+DY*EWY(2)+DZ*EWZ(2)
      ZI=ZI0+DY*EWY(3)+DZ*EWZ(3)

      WX=V0/SQRT(1.D0+DZP**2+DYP**2)
      WY=DYP*WX
      WZ=DZP*WX

      VXI=WX*EWS(1)+WY*EWY(1)+WZ*EWZ(1)
      VYI=WX*EWS(2)+WY*EWY(2)+WZ*EWZ(2)
      VZI=WX*EWS(3)+WY*EWY(3)+WZ*EWZ(3)

      CALL TRACK(XI,YI,ZI,VXI,VYI,VZI
     &  ,XF0,YF0,ZF0,VXF0/V0,VYF0/V0,VZF0/V0
     &  ,XF,YF,ZF,VXF,VYF,VZF,DTIM,BSHIFT,DMYGAMMA,GAMMAL)

      DX=XF-XF0
      DY=YF-YF0
      DZ=ZF-ZF0

      XF=DX*EWSF(1)+DY*EWSF(2)+DZ*EWSF(3)
      YF=DX*EWYF(1)+DY*EWYF(2)+DZ*EWYF(3)
      ZF=DX*EWZF(1)+DY*EWZF(2)+DZ*EWZF(3)

      WX=VXF*EWSF(1)+VYF*EWSF(2)+VZF*EWSF(3)
      WY=VXF*EWYF(1)+VYF*EWYF(2)+VZF*EWYF(3)
      WZ=VXF*EWZF(1)+VYF*EWZF(2)+VZF*EWZF(3)

      ZPF=WZ/WX
      YPF=WY/WX

      TFM(1,1)=ZF/DELTAZ
      TFM(2,1)=ZPF/DELTAZ
      TFM(3,1)=YF/DELTAZ
      TFM(4,1)=YPF/DELTAZ

C--T(1:4,2):

      DZ=0.D0
      DY=0.0D0
      DZP=DELTAZP
      DYP=0.D0

      XI=XI0+DY*EWY(1)+DZ*EWZ(1)
      YI=YI0+DY*EWY(2)+DZ*EWZ(2)
      ZI=ZI0+DY*EWY(3)+DZ*EWZ(3)

      WX=V0/SQRT(1.D0+DZP**2+DYP**2)
      WY=DYP*WX
      WZ=DZP*WX

      VXI=WX*EWS(1)+WY*EWY(1)+WZ*EWZ(1)
      VYI=WX*EWS(2)+WY*EWY(2)+WZ*EWZ(2)
      VZI=WX*EWS(3)+WY*EWY(3)+WZ*EWZ(3)

      CALL TRACK(XI,YI,ZI,VXI,VYI,VZI
     &  ,XF0,YF0,ZF0,VXF0/V0,VYF0/V0,VZF0/V0
     &  ,XF,YF,ZF,VXF,VYF,VZF,DTIM,BSHIFT,DMYGAMMA,GAMMAL)

      DX=XF-XF0
      DY=YF-YF0
      DZ=ZF-ZF0

      XF=DX*EWSF(1)+DY*EWSF(2)+DZ*EWSF(3)
      YF=DX*EWYF(1)+DY*EWYF(2)+DZ*EWYF(3)
      ZF=DX*EWZF(1)+DY*EWZF(2)+DZ*EWZF(3)

      WX=VXF*EWSF(1)+VYF*EWSF(2)+VZF*EWSF(3)
      WY=VXF*EWYF(1)+VYF*EWYF(2)+VZF*EWYF(3)
      WZ=VXF*EWZF(1)+VYF*EWZF(2)+VZF*EWZF(3)

      ZPF=WZ/WX
      YPF=WY/WX

      TFM(1,2)=ZF/DELTAZP
      TFM(2,2)=ZPF/DELTAZP
      TFM(3,2)=YF/DELTAZP
      TFM(4,2)=YPF/DELTAZP

C--T(1:4,3):

      DZ=0.D0
      DY=DELTAY
      DZP=0.D0
      DYP=0.D0

      XI=XI0+DY*EWY(1)+DZ*EWZ(1)
      YI=YI0+DY*EWY(2)+DZ*EWZ(2)
      ZI=ZI0+DY*EWY(3)+DZ*EWZ(3)

      WX=V0/SQRT(1.D0+DZP**2+DYP**2)
      WY=DYP*WX
      WZ=DZP*WX

      VXI=WX*EWS(1)+WY*EWY(1)+WZ*EWZ(1)
      VYI=WX*EWS(2)+WY*EWY(2)+WZ*EWZ(2)
      VZI=WX*EWS(3)+WY*EWY(3)+WZ*EWZ(3)

      CALL TRACK(XI,YI,ZI,VXI,VYI,VZI
     &  ,XF0,YF0,ZF0,VXF0/V0,VYF0/V0,VZF0/V0
     &  ,XF,YF,ZF,VXF,VYF,VZF,DTIM,BSHIFT,DMYGAMMA,GAMMAL)

      DX=XF-XF0
      DY=YF-YF0
      DZ=ZF-ZF0

      XF=DX*EWSF(1)+DY*EWSF(2)+DZ*EWSF(3)
      YF=DX*EWYF(1)+DY*EWYF(2)+DZ*EWYF(3)
      ZF=DX*EWZF(1)+DY*EWZF(2)+DZ*EWZF(3)

      WX=VXF*EWSF(1)+VYF*EWSF(2)+VZF*EWSF(3)
      WY=VXF*EWYF(1)+VYF*EWYF(2)+VZF*EWYF(3)
      WZ=VXF*EWZF(1)+VYF*EWZF(2)+VZF*EWZF(3)

      ZPF=WZ/WX
      YPF=WY/WX

      TFM(1,3)=ZF/DELTAY
      TFM(2,3)=ZPF/DELTAY
      TFM(3,3)=YF/DELTAY
      TFM(4,3)=YPF/DELTAY

C--T(1:4,4):

      DZ=0.D0
      DY=0.0D0
      DZP=0.D0
      DYP=DELTAYP

      XI=XI0+DY*EWY(1)+DZ*EWZ(1)
      YI=YI0+DY*EWY(2)+DZ*EWZ(2)
      ZI=ZI0+DY*EWY(3)+DZ*EWZ(3)

      WX=V0/SQRT(1.D0+DZP**2+DYP**2)
      WY=DYP*WX
      WZ=DZP*WX

      VXI=WX*EWS(1)+WY*EWY(1)+WZ*EWZ(1)
      VYI=WX*EWS(2)+WY*EWY(2)+WZ*EWZ(2)
      VZI=WX*EWS(3)+WY*EWY(3)+WZ*EWZ(3)

      CALL TRACK(XI,YI,ZI,VXI,VYI,VZI
     &  ,XF0,YF0,ZF0,VXF0/V0,VYF0/V0,VZF0/V0
     &  ,XF,YF,ZF,VXF,VYF,VZF,DTIM,BSHIFT,DMYGAMMA,GAMMAL)

      DX=XF-XF0
      DY=YF-YF0
      DZ=ZF-ZF0

      XF=DX*EWSF(1)+DY*EWSF(2)+DZ*EWSF(3)
      YF=DX*EWYF(1)+DY*EWYF(2)+DZ*EWYF(3)
      ZF=DX*EWZF(1)+DY*EWZF(2)+DZ*EWZF(3)

      WX=VXF*EWSF(1)+VYF*EWSF(2)+VZF*EWSF(3)
      WY=VXF*EWYF(1)+VYF*EWYF(2)+VZF*EWYF(3)
      WZ=VXF*EWZF(1)+VYF*EWZF(2)+VZF*EWZF(3)

      ZPF=WZ/WX
      YPF=WY/WX

      TFM(1,4)=ZF/DELTAYP
      TFM(2,4)=ZPF/DELTAYP
      TFM(3,4)=YF/DELTAYP
      TFM(4,4)=YPF/DELTAYP

C--- CHECK

      DZ=DELTAZ
      DY=DELTAY
      DZP=DELTAZP
      DYP=DELTAYP

      XI=XI0+DY*EWY(1)+DZ*EWZ(1)
      YI=YI0+DY*EWY(2)+DZ*EWZ(2)
      ZI=ZI0+DY*EWY(3)+DZ*EWZ(3)

      WX=V0/SQRT(1.D0+DZP**2+DYP**2)
      WY=DYP*WX
      WZ=DZP*WX

      VXI=WX*EWS(1)+WY*EWY(1)+WZ*EWZ(1)
      VYI=WX*EWS(2)+WY*EWY(2)+WZ*EWZ(2)
      VZI=WX*EWS(3)+WY*EWY(3)+WZ*EWZ(3)

      CALL TRACK(XI,YI,ZI,VXI,VYI,VZI
     &  ,XF0,YF0,ZF0,VXF0/V0,VYF0/V0,VZF0/V0
     &  ,XF,YF,ZF,VXF,VYF,VZF,DTIM,BSHIFT,DMYGAMMA,GAMMAL)

      ZPF=VZF/VXF
      YPF=VYF/VXF

      ERRZ=( ZF-ZF0
     &-(TFM(1,1)*DELTAZ+TFM(1,2)*DELTAZP
     &+ TFM(1,3)*DELTAY+TFM(1,4)*DELTAYP))
     &/DELTAZ
      ERRZP=( ZPF-ZPF0
     &-(TFM(2,1)*DELTAZ+TFM(2,2)*DELTAZP
     &+ TFM(2,3)*DELTAY+TFM(2,4)*DELTAYP))
     &/DELTAZP
      ERRY=( YF-YF0
     &-(TFM(3,1)*DELTAZ+TFM(3,2)*DELTAZP
     &+ TFM(3,3)*DELTAY+TFM(3,4)*DELTAYP))
     &/DELTAY
      ERRYP=( YPF-YPF0
     &-(TFM(4,1)*DELTAZ+TFM(4,2)*DELTAZP
     &+ TFM(4,3)*DELTAY+TFM(4,4)*DELTAYP))
     &/DELTAYP

      DELTAZ=DELTAZ*D10
      DELTAZP=DELTAZP*D10
      DELTAY=DELTAY*D10
      DELTAYP=DELTAYP*D10

      DZ=DELTAZ
      DY=DELTAY
      DZP=DELTAZP
      DYP=DELTAYP

      XI=XI0+DY*EWY(1)+DZ*EWZ(1)
      YI=YI0+DY*EWY(2)+DZ*EWZ(2)
      ZI=ZI0+DY*EWY(3)+DZ*EWZ(3)

      WX=V0/SQRT(1.D0+DZP**2+DYP**2)
      WY=DYP*WX
      WZ=DZP*WX

      VXI=WX*EWS(1)+WY*EWY(1)+WZ*EWZ(1)
      VYI=WX*EWS(2)+WY*EWY(2)+WZ*EWZ(2)
      VZI=WX*EWS(3)+WY*EWY(3)+WZ*EWZ(3)

      CALL TRACK(XI,YI,ZI,VXI,VYI,VZI
     &  ,XF0,YF0,ZF0,VXF0/V0,VYF0/V0,VZF0/V0
     &  ,XF,YF,ZF,VXF,VYF,VZF,DTIM,BSHIFT,DMYGAMMA,GAMMAL)

      ZPF=VZF/VXF
      YPF=VYF/VXF

      ERRZ10=( ZF-ZF0
     &-(TFM(1,1)*DELTAZ+TFM(1,2)*DELTAZP
     &+ TFM(1,3)*DELTAY+TFM(1,4)*DELTAYP))
     &/DELTAZ
      ERRZP10=( ZPF-ZPF0
     &-(TFM(2,1)*DELTAZ+TFM(2,2)*DELTAZP
     &+ TFM(2,3)*DELTAY+TFM(2,4)*DELTAYP))
     &/DELTAZP
      ERRY10=( YF-YF0
     &-(TFM(3,1)*DELTAZ+TFM(3,2)*DELTAZP
     &+ TFM(3,3)*DELTAY+TFM(3,4)*DELTAYP))
     &/DELTAY
      ERRYP10=( YPF-YPF0
     &-(TFM(4,1)*DELTAZ+TFM(4,2)*DELTAZP
     &+ TFM(4,3)*DELTAY+TFM(4,4)*DELTAYP))
     &/DELTAYP

      DELTAZ=DELTAZ/D10
      DELTAZP=DELTAZP/D10
      DELTAY=DELTAY/D10
      DELTAYP=DELTAYP/D10

      CALL UTIL_DETERMINANTE(4,TFM,DET,IFAIL)

      IF (TFM(1,2).NE.0.D0) THEN
        TRAXKX=TFM(2,1)/TFM(1,2)
      ELSE
        TRAXKX=0.D0
      ENDIF

      IF (TFM(3,4).NE.0.D0) THEN
        TRAXKY=TFM(4,3)/TFM(3,4)
      ELSE
        TRAXKY=0.D0
      ENDIF

      RKXKY=TRAXKX+TRAXKY
      IF (RKXKY.NE.0.D0) THEN
        TRAXKX=TRAXKX/RKXKY
        TRAXKY=TRAXKY/RKXKY
      ENDIF

C APPLY TRANSFER MATRIX TO YSTART,ZSTART,VYIN/VXIN,VZIN/VXIN

      XTM(1,1)=PHTRZ0 ! SIGN NOT CHECKED
      XTM(2,1)=PHTRZP0 ! SIGN NOT CHECKED
      XTM(3,1)=PHTRY0
      XTM(4,1)=PHTRYP0

      DO I=1,4
        XTM(I,2)=0.D0
        DO J=1,4
          XTM(I,2)=XTM(I,2)+TFM(I,J)*XTM(J,1)
        ENDDO
      ENDDO

c{ invert transfer matrixces

      tfminv=0.0d0

      tfm22(1,1)=tfm(1,1)
      tfm22(1,2)=tfm(1,2)
      tfm22(2,1)=tfm(2,1)
      tfm22(2,2)=tfm(2,2)

      dum22(1,1)=1.0d0
      dum22(1,2)=0.0d0
      dum22(2,1)=0.0d0
      dum22(2,2)=1.0d0

      call deqinv(2,tfm22,2,iw2,ifail,2,dum22)

      tfminv(1,1)=tfm22(1,1)
      tfminv(1,2)=tfm22(1,2)
      tfminv(2,1)=tfm22(2,1)
      tfminv(2,2)=tfm22(2,2)

      tfm22(1,1)=tfm(3,3)
      tfm22(1,2)=tfm(3,4)
      tfm22(2,1)=tfm(4,3)
      tfm22(2,2)=tfm(4,4)

      dum22(1,1)=1.0d0
      dum22(1,2)=0.0d0
      dum22(2,1)=0.0d0
      dum22(2,2)=1.0d0

      call deqinv(2,tfm22,2,iw2,ifail,2,dum22)

      tfminv(3,3)=tfm22(1,1)
      tfminv(3,4)=tfm22(1,2)
      tfminv(4,3)=tfm22(2,1)
      tfminv(4,4)=tfm22(2,2)

c} invert transfer matrixces
      if (ibetback.ne.0) then

        write(lungfo,*)
        write(lungfo,*)'       IBETBACK:',ibetback
        write(lungfo,*)
C{ APPLY TRANSFER MATRIX TO BETA-MATRICES, BUT BACKWARD

        a=-betaph/2.0d0
        g=(1.0d0+a**2)/betah
        b=betah

        beta0m(1,1)=b
        beta0m(1,2)=-a
        beta0m(2,1)=-a
        beta0m(2,2)=g

        tfm22(1:2,1:2)=tfminv(1:2,1:2)

        tfmtr(1,1)=tfm22(1,1)
        tfmtr(1,2)=tfm22(2,1)
        tfmtr(2,1)=tfm22(1,2)
        tfmtr(2,2)=tfm22(2,2)

        call util_matrix_multiplication(2,2,2,tfm22,beta0m,bt,dum22)
        call util_matrix_multiplication(2,2,2,bt,tfmtr,betahmi,dum22)

c          WRITE(LUNGFO,*)
c          WRITE(LUNGFO,*)'       BETAH and BETAPH transformed backward to XSTART:'
c          WRITE(LUNGFO,*)'       ',sngl(betahmi(1,1)),sngl(betahmi(1,2)*2.0d0)
c          WRITE(LUNGFO,*)

        betah=betahmi(1,1)
        betaph=2.0d0*betahmi(1,2)

        a=-betapv/2.0d0
        g=(1.0d0+a**2)/betav
        b=betav

        beta0m(1,1)=b
        beta0m(1,2)=-a
        beta0m(2,1)=-a
        beta0m(2,2)=g

        tfm22(1:2,1:2)=tfminv(3:4,3:4)

        tfmtr(1,1)=tfm22(1,1)
        tfmtr(1,2)=tfm22(2,1)
        tfmtr(2,1)=tfm22(1,2)
        tfmtr(2,2)=tfm22(2,2)

        call util_matrix_multiplication(2,2,2,tfm22,beta0m,bt,dum22)
        call util_matrix_multiplication(2,2,2,bt,tfmtr,betavmi,dum22)

c          WRITE(LUNGFO,*)
c          WRITE(LUNGFO,*)'       BETAV and BETAPV transformed backward to XSTART:'
c          WRITE(LUNGFO,*)'       ',sngl(betavmi(1,1)),sngl(betavmi(1,2)*2.0d0)
c          WRITE(LUNGFO,*)

        betav=betavmi(1,1)
        betapv=2.0d0*betavmi(1,2)

C} APPLY TRANSFER MATRIX TO BETA-MATRICES, BUT BACKWARD

      endif

      if (betfun.eq.-9999.) then

+self,if=-wille.
C Calculate periodic solution if required:

        tfm22(1,1)=tfm(1,1)
        tfm22(1,2)=tfm(1,2)
        tfm22(2,1)=tfm(2,1)
        tfm22(2,2)=tfm(2,2)

        a=
     &    tfm22(1,1)**2*tfm22(2,2)**2-tfm22(1,1)**2-
     &    2.0d0*tfm22(1,1)*tfm22(1,2)*tfm22(2,1)*tfm22(2,2)+
     &    tfm22(1,2)**2*tfm22(2,1)**2-
     &    2.0d0*tfm22(1,2)*tfm22(2,1)-tfm22(2,2)**2+1.0d0

        if (a.gt.0.0d0) then

          betah=abs((tfm22(1,1)*tfm22(1,2)*tfm22(2,2)-tfm22(1,2)**2*tfm22(2,1)+
     &      tfm22(1,2))/sqrt(a))
          a=(tfm22(1,1)**2*tfm22(2,2)-tfm22(1,1)*tfm22(1,2)*tfm22(2,1)-
     &      tfm22(2,2))/sqrt(a)
          betaph=-2.0d0*a

        else

          write(6,*)
          write(6,*)
          write(6,*)'*** Warning in TRALIN: No periodic solution found for '
          write(6,*)'*** horizontal beta-function, old values of BETAH and BETAHP kept'
          write(lungfo,*)
          write(lungfo,*)'*** Warning in TRALIN: No periodic solution found for '
          write(lungfo,*)'*** horizontal beta-function, old values of BETAH and BETAHP kept'
          write(lungfo,*)

        endif
      endif

      if (betfunv.eq.-9999.) then

        tfm22(1,1)=tfm(3,3)
        tfm22(1,2)=tfm(3,4)
        tfm22(2,1)=tfm(4,3)
        tfm22(2,2)=tfm(4,4)

        a=
     &    tfm22(1,1)**2*tfm22(2,2)**2-tfm22(1,1)**2-
     &    2.0d0*tfm22(1,1)*tfm22(1,2)*tfm22(2,1)*tfm22(2,2)+
     &    tfm22(1,2)**2*tfm22(2,1)**2-
     &    2.0d0*tfm22(1,2)*tfm22(2,1)-tfm22(2,2)**2+1.0d0

        if (a.gt.0.0d0) then
          betav=abs((tfm22(1,1)*tfm22(1,2)*tfm22(2,2)-tfm22(1,2)**2*tfm22(2,1)+
     &      tfm22(1,2))/sqrt(a))
          a=(tfm22(1,1)**2*tfm22(2,2)-tfm22(1,1)*tfm22(1,2)*tfm22(2,1)-
     &      tfm22(2,2))/sqrt(a)
          betapv=-2.0d0*a
        else
          write(6,*)
          write(6,*)'*** Warning in TRALIN: No periodic solution found for '
          write(6,*)'*** vertical beta-function, old values of BETAV and BETAVP kept'
          write(6,*)
          write(lungfo,*)
          write(lungfo,*)'*** Warning in TRALIN: No periodic solution found for '
          write(lungfo,*)'*** vertical beta-function, old values of BETAV and BETAVP kept'
          write(lungfo,*)
        endif
      endif

+self,if=wille.
C Calculate periodic solution if required (Wille S. 107):

        tfm22(1,1)=tfm(1,1)
        tfm22(1,2)=tfm(1,2)
        tfm22(2,1)=tfm(2,1)
        tfm22(2,2)=tfm(2,2)

        a=2.0d0-tfm22(1,1)**2-2.0d0*tfm22(1,2)*tfm22(2,1)-tfm22(2,2)**2

        if (a.gt.0.) then
          betah=abs(2.0d0*tfm22(1,2)/sqrt(a))
          a=(tfm22(1,1)-tfm22(2,2))/2.0d0*betah
          betaph=-2.0d0*a
        else
          write(6,*)
          write(6,*)
          write(6,*)'*** Warning in TRALIN: No periodic solution found for '
          write(6,*)'*** horizontal beta-function, old values of BETAH and BETAHP kept'
          write(lungfo,*)
          write(lungfo,*)'*** Warning in TRALIN: No periodic solution found for '
          write(lungfo,*)'*** horizontal beta-function, old values of BETAH and BETAHP kept'
          write(lungfo,*)
        endif
      endif

      if (betfunv.eq.-9999.) then

        tfm22(1,1)=tfm(3,3)
        tfm22(1,2)=tfm(3,4)
        tfm22(2,1)=tfm(4,3)
        tfm22(2,2)=tfm(4,4)

        a=2.0d0-tfm22(1,1)**2-2.0d0*tfm22(1,2)*tfm22(2,1)-tfm22(2,2)**2

        if (a.gt.0) then

          betav=abs(2.0d0*tfm22(1,2)/sqrt(a))
          a=(tfm22(1,1)-tfm22(2,2))/2.0d0*betav
          betapv=-2.0d0*a

        else

          write(6,*)
          write(6,*)'*** Warning in TRALIN: No periodic solution found for '
          write(6,*)'*** vertical beta-function, old values of BETAV and BETAVP kept'
          write(6,*)
          write(lungfo,*)
          write(lungfo,*)'*** Warning in TRALIN: No periodic solution found for '
          write(lungfo,*)'*** vertical beta-function, old values of BETAV and BETAVP kept'
          write(lungfo,*)
        endif
      endif
+self.if=wille.


C{ APPLY TRANSFER MATRIX TO BETA-MATRICES

      a=-betaph/2.0d0
      g=(1.0d0+a**2)/betah
      b=betah

      beta0m(1,1)=b
      beta0m(1,2)=-a
      beta0m(2,1)=-a
      beta0m(2,2)=g

      tfm22(1,1)=tfm(1,1)
      tfm22(1,2)=tfm(1,2)
      tfm22(2,1)=tfm(2,1)
      tfm22(2,2)=tfm(2,2)

      tfmtr(1,1)=tfm22(1,1)
      tfmtr(1,2)=tfm22(2,1)
      tfmtr(2,1)=tfm22(1,2)
      tfmtr(2,2)=tfm22(2,2)

      call util_matrix_multiplication(2,2,2,tfm22,beta0m,bt,dum22)
      call util_matrix_multiplication(2,2,2,bt,tfmtr,betahm,dum22)

      a=-betapv/2.0d0
      g=(1.0d0+a**2)/betav
      b=betav

      beta0m(1,1)=b
      beta0m(1,2)=-a
      beta0m(2,1)=-a
      beta0m(2,2)=g

      tfm22(1,1)=tfm(3,3)
      tfm22(1,2)=tfm(3,4)
      tfm22(2,1)=tfm(4,3)
      tfm22(2,2)=tfm(4,4)

      tfmtr(1,1)=tfm22(1,1)
      tfmtr(1,2)=tfm22(2,1)
      tfmtr(2,1)=tfm22(1,2)
      tfmtr(2,2)=tfm22(2,2)

      call util_matrix_multiplication(2,2,2,tfm22,beta0m,bt,dum22)
      call util_matrix_multiplication(2,2,2,bt,tfmtr,betavm,dum22)

C} APPLY TRANSFER MATRIX TO BETA-MATRICES

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'      Linear transfer matrix (raw estimate):'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       deltaz, deltazp, deltay, deltayp:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       ',SNGL(DELTAZ),SNGL(DELTAZP),SNGL(DELTAY),SNGL(DELTAYP)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       ',(SNGL(TFM(1,I)),I=1,4)
      WRITE(LUNGFO,*)'       ',(SNGL(TFM(2,I)),I=1,4)
      WRITE(LUNGFO,*)'       ',(SNGL(TFM(3,I)),I=1,4)
      WRITE(LUNGFO,*)'       ',(SNGL(TFM(4,I)),I=1,4)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'      Relative error for track (deltaz,deltazp,deltay,deltayp)'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       ',SNGL(ERRZ),SNGL(ERRZP),SNGL(ERRY),SNGL(ERRYP)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'      Relative error for track 10 X (deltaz,deltazp,deltay,deltayp)'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       ',SNGL(ERRZ10),SNGL(ERRZP10),SNGL(ERRY10),SNGL(ERRYP10)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'      Failure flag and determinant:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       ',IFAIL,DET
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'      normalized kx, ky:',SNGL(TRAXKX),SNGL(TRAXKY)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '      Transfer Matrix applied to (PHTRZ0, PHTRZP0, PHTRY0, PHTRYP0):'
      WRITE(LUNGFO,*)'        ',(SNGL(XTM(I,2)),I=1,4)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'      Inverse linear transfer matrix (raw estimate):'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       ',(SNGL(tfminv(1,I)),I=1,4)
      WRITE(LUNGFO,*)'       ',(SNGL(tfminv(2,I)),I=1,4)
      WRITE(LUNGFO,*)'       ',(SNGL(tfminv(3,I)),I=1,4)
      WRITE(LUNGFO,*)'       ',(SNGL(tfminv(4,I)),I=1,4)
      WRITE(LUNGFO,*)

      DO I=1,2
        XTM(I,2)=0.D0
        DO J=1,2
          XTM(I,2)=XTM(I,2)+TFM(I,J)*XTM(J,1)
        ENDDO
      ENDDO

      DO I=3,4
        XTM(I,2)=0.D0
        DO J=3,4
          XTM(I,2)=XTM(I,2)+TFM(I,J)*XTM(J,1)
        ENDDO
      ENDDO
      WRITE(LUNGFO,*)
     &  '      dito but without coupling of planes:'
      WRITE(LUNGFO,*)'        ',(SNGL(XTM(I,2)),I=1,4)
      WRITE(LUNGFO,*)

      b=betah
      a=-betaph/2.0d0
      g=(1.0d0+a**2)/betah

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'         Horizontal beta matrix, i.e.:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'              ( beta  -alpha )'
      WRITE(LUNGFO,*)'              ( -alpha gamma )'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       ',SNGL(b),sngl(-a)
      WRITE(LUNGFO,*)'       ',sngl(-a),sngl(g)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       Beta, BetaP:',sngl(betah),sngl(betaph)
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'      Transformed hor. beta matrix,'
      WRITE(LUNGFO,*)'      (must be the same for the periodic solution):'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       ',(SNGL(betahm(1,I)),I=1,2)
      WRITE(LUNGFO,*)'       ',(SNGL(betahm(2,I)),I=1,2)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       Beta, BetaP:',
     &  sngl(betahm(1,1)),sngl(betahm(1,2)*2.0d0)
      WRITE(LUNGFO,*)

      b=betav
      a=-betapv/2.0d0
      g=(1.0d0+a**2)/betav

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'         Vertical beta matrix, i.e.:'
      WRITE(LUNGFO,*)'              ( beta  -alpha )'
      WRITE(LUNGFO,*)'              ( -alpha gamma )'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       ',SNGL(b),sngl(-a)
      WRITE(LUNGFO,*)'       ',sngl(-a),sngl(g)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       Beta, BetaP:',sngl(betav),sngl(betapv)
      WRITE(LUNGFO,*)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'      Transformed ver. beta matrix,'
      WRITE(LUNGFO,*)'      (must be the same for the periodic solution):'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       ',(SNGL(betavm(1,I)),I=1,2)
      WRITE(LUNGFO,*)'       ',(SNGL(betavm(2,I)),I=1,2)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       Beta, BetaP:',
     &  sngl(betavm(1,1)),sngl(betavm(1,2)*2.0d0)
      WRITE(LUNGFO,*)

      OPEN(UNIT=99,FILE='tralin.wav',STATUS='unknown')
      REWIND(99)
      WRITE(99,'(4(1PE18.10))')((TFM(I,J),J=1,4),I=1,4)
      CLOSE(99)

C-- phasespace ellipes

      if (iphellip.ne.0.0d0) then

        iphellip=abs(iphellip)

        if (phbetah.ne.0.0d0) then
          eps=phdisph**2/phbetah
          dz0=  sqrt(eps*phbetah)
          dzp0=-sqrt(eps/phbetah)
        else
          eps=0.0d0
          dz0=0.0d0
          dzp0=0.0d0
        endif

        dphi=2.0d0*pi1/iphellip

        DY=PHTRY0
        DYP=PHTRYP0

        YIPH=DY
        YPIPH=DYP

        open(unit=99,file='wave_phase_ellipse_hori.wva',
     &    status='unknown',recl=256)

        write(99,'(a,i10,a,a)')'* ',icode,' ',code
        write(99,'(a,e15.5,a,e15.5)')'* y =',PHTRY0,' yp =',PHTRYP0
        write(99,'(a)')'* Meaning of columns phi, zi, zpi, zf, zpf'

        do iphi=1,iphellip

          phi=(iphi-1)*dphi
          cs=cos(phi)
          sn=sin(phi)

          DZ=  dz0*cs
          DZP=dzp0*sn
          DY=PHTRY0
          DYP=PHTRYP0

          ZIPH=DZ
          ZPIPH=DZP

          XI=XI0+DY*EWY(1)+DZ*EWZ(1)
          YI=YI0+DY*EWY(2)+DZ*EWZ(2)
          ZI=ZI0+DY*EWY(3)+DZ*EWZ(3)

          WX=V0/SQRT(1.D0+DZP**2+DYP**2)
          WY=DYP*WX
          WZ=DZP*WX

          VXI=WX*EWS(1)+WY*EWY(1)+WZ*EWZ(1)
          VYI=WX*EWS(2)+WY*EWY(2)+WZ*EWZ(2)
          VZI=WX*EWS(3)+WY*EWY(3)+WZ*EWZ(3)

          IF (IERZFUN.EQ.0) THEN

            CALL TRACK(XI,YI,ZI,VXI,VYI,VZI
     &        ,XF0,YF0,ZF0,VXF0/V0,VYF0/V0,VZF0/V0
     &        ,XF,YF,ZF,VXF,VYF,VZF,DTIM,BSHIFT,DMYGAMMA,GAMMAL)

          ELSE !IERZFUN

            CALL IDTRMSHGF(XI,YI,ZI,VXI,VYI,VZI,XF,YF,ZF,VXF,VYF,VZF,
     &        XI0,YI0,ZI0,WXI0,WYI0,WZI0,
     &        XF0,YF0,ZF0,VXF0,VYF0,VZF0,"wave_erzfun.in")

          ENDIF

          DX=XF-XF0
          DY=YF-YF0
          DZ=ZF-ZF0

          XF=DX*EWSF(1)+DY*EWSF(2)+DZ*EWSF(3)
          YF=DX*EWYF(1)+DY*EWYF(2)+DZ*EWYF(3)
          ZF=DX*EWZF(1)+DY*EWZF(2)+DZ*EWZF(3)

          WX=VXF*EWSF(1)+VYF*EWSF(2)+VZF*EWSF(3)
          WY=VXF*EWYF(1)+VYF*EWYF(2)+VZF*EWYF(3)
          WZ=VXF*EWZF(1)+VYF*EWZF(2)+VZF*EWZF(3)

          ZPF=WZ/WX
          YPF=WY/WX

          WRITE(99,*)PHI,ZIPH,ZPIPH,ZF,ZPF

        enddo !iphi=0,iphellip

        close(99)

c vertically

        if (phbetav.ne.0.0d0) then
          eps=phdispv**2/phbetav
          dy0=  sqrt(eps*phbetav)
          dyp0=-sqrt(eps/phbetav)
        else
          eps=0.0d0
          dy0=0.0d0
          dyp0=0.0d0
        endif

        DZ=PHTRZ0
        DZP=PHTRZP0
        ZIPH=DZ
        ZPIPH=DZP

        open(unit=99,file='wave_phase_ellipse_vert.wva',
     &    status='unknown',recl=256)
        write(99,'(a,i10,a,a)')'* ',icode,' ',code
        write(99,'(a,e15.5,a,e15.5)')'* z =',PHTRZ0,' zp =',PHTRZP0
        write(99,'(a)')'* Meaning of columns phi, yi, ypi, yf, ypf'

        do iphi=1,iphellip

          phi=(iphi-1)*dphi
          cs=cos(phi)
          sn=sin(phi)

          DZ=PHTRZ0
          DZP=PHTRZP0
          DY=  dy0*cs
          DYP=dyp0*sn

          YIPH=DY
          YPIPH=DYP

          XI=XI0+DY*EWY(1)+DZ*EWZ(1)
          YI=YI0+DY*EWY(2)+DZ*EWZ(2)
          ZI=ZI0+DY*EWY(3)+DZ*EWZ(3)

          WX=V0/SQRT(1.D0+DZP**2+DYP**2)
          WY=DYP*WX
          WZ=DZP*WX

          VXI=WX*EWS(1)+WY*EWY(1)+WZ*EWZ(1)
          VYI=WX*EWS(2)+WY*EWY(2)+WZ*EWZ(2)
          VZI=WX*EWS(3)+WY*EWY(3)+WZ*EWZ(3)

          IF (IERZFUN.EQ.0) THEN

            CALL TRACK(XI,YI,ZI,VXI,VYI,VZI
     &        ,XF0,YF0,ZF0,VXF0/V0,VYF0/V0,VZF0/V0
     &        ,XF,YF,ZF,VXF,VYF,VZF,DTIM,BSHIFT,DMYGAMMA,GAMMAL)

          ELSE !IERZFUN

            CALL IDTRMSHGF(XI,YI,ZI,VXI,VYI,VZI,XF,YF,ZF,VXF,VYF,VZF,
     &        XI0,YI0,ZI0,WXI0,WYI0,WZI0,
     &        XF0,YF0,ZF0,VXF0,VYF0,VZF0,"wave_erzfun.in")

          ENDIF

          DX=XF-XF0
          DY=YF-YF0
          DZ=ZF-ZF0

          XF=DX*EWSF(1)+DY*EWSF(2)+DZ*EWSF(3)
          YF=DX*EWYF(1)+DY*EWYF(2)+DZ*EWYF(3)
          ZF=DX*EWZF(1)+DY*EWZF(2)+DZ*EWZF(3)

          WX=VXF*EWSF(1)+VYF*EWSF(2)+VZF*EWSF(3)
          WY=VXF*EWYF(1)+VYF*EWYF(2)+VZF*EWYF(3)
          WZ=VXF*EWZF(1)+VYF*EWZF(2)+VZF*EWZF(3)

          ZPF=WZ/WX
          YPF=WY/WX

          WRITE(99,*)PHI,YIPH,YPIPH,YF,YPF

        enddo !iphi=0,iphellip

        close(99)

        write(lungfo,*)
        write(lungfo,*)'      Tralin: Phasespace ellipes written to files:'

        write(lungfo,*)'      wave_phase_ellipse_hori.wva'
        write(lungfo,*)'      wave_phase_ellipse_vert.wva'

        write(lungfo,*)

        write(lungfo,*)'      PHTRZ0,PHTRZP0,PHTRY0,PHTRYP0:'
        write(lungfo,*)'      ', PHTRZ0,PHTRZP0
        write(lungfo,*)'      ', PHTRY0,PHTRYP0

        write(lungfo,*)

        write(lungfo,*)'      PHTRZ0,PHTRZP0,PHTRY0,PHTRYP0:'
        write(lungfo,*)'      ', PHTRZ0,PHTRZP0
        write(lungfo,*)'      ', PHTRY0,PHTRYP0

        write(lungfo,*)

        write(lungfo,*)'      PHDISPH,PBETAH,PHDISPV,PBETAV:'
        write(lungfo,*)'      ',PHDISPH,PHBETAH
        write(lungfo,*)'      ',PHDISPV,PHBETAV

        write(lungfo,*)

      endif !(iphellip.ne.0.0d0)

      write(lungfo,'(/a)')"      --- Leaving TRALIN ---"
      write(lungfo,*)" "

      RETURN
      END
+DECK,TRANMAP.
*CMZ :  4.00/15 27/04/2022  08.12.23  by  Michael Scheer
*CMZ :  4.00/13 29/11/2021  14.07.42  by  Michael Scheer
*CMZ :  4.00/04 27/08/2019  11.49.27  by  Michael Scheer
*CMZ :  3.05/10 13/08/2018  14.40.26  by  Michael Scheer
*CMZ :  3.02/03 03/11/2014  12.12.50  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  10.37.07  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  12.42.14  by  Michael Scheer
*CMZ :  2.52/14 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.48/04 12/03/2004  15.40.31  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.02  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.20/01 04/12/2000  14.08.56  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.33  by  Michael Scheer
*CMZ :  2.15/00 04/05/2000  15.21.41  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.24.35  by  Michael Scheer
*CMZ :  2.12/00 03/06/99  15.29.38  by  Michael Scheer
*CMZ :  1.03/06 06/08/98  18.08.02  by  Michael Scheer
*CMZ : 00.02/00 19/11/96  14.55.32  by  Michael Scheer
*CMZ : 00.01/10 29/05/96  15.22.02  by  Michael Scheer
*-- Author :    Michael Scheer   28/05/96

C************************************************************************
      SUBROUTINE TRANMAP
C************************************************************************
+seq,gplhint.

C     Calculates Taylor expansion of the mapping
C     (xi,xpi,xi,xpi) -> (xf,xpf,xf,xpf)

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,MYFILES.
+SEQ,CONTRL.
+SEQ,OPTIC.
+SEQ,TRANPO.

      CHARACTER(1) C1
      CHARACTER(55) CODEERZ,CODEREF

      INTEGER NKOEF,IE,JE,KE,LE
     &         ,LUN1,LUNAKO,LUNERZ,LUNREF,LUNTRA,LUNSTR
     &         ,IREAD,MAXTRAP,NORDNGP,MKOEFV,NTOT
     &         ,I,J,K,L,II,JJ,KK,LL,IP,JP,KP,LP,IIP,JJP,KKP,LLP
     &         ,N,IERZ,IREF,ITRANC,IFAIL1,M,NP,I1,J1,L1,K1
     &         ,I1P,J1P,K1P,L1P,IWARNE,IWARNR,ICODEERZ,ICODEREF,
     &           ITRANCE,ITRANCR

+SEQ,GENFUN.
+SEQ,PHYCON.

      DIMENSION
     &  IE(MKOEF),JE(MKOEF),KE(MKOEF),LE(MKOEF)

      REAL*4 xran(1),rr(2)

      DOUBLE PRECISION
     &  BXI(MAXTRA),BYI(MAXTRA),BXF(MAXTRA),BYF(MAXTRA)
     & ,BZI(MAXTRA),BZF(MAXTRA),AZI(MAXTRA),AZF(MAXTRA)
     & ,AXI(MAXTRA),AYI(MAXTRA),AXF(MAXTRA),AYF(MAXTRA)

      DOUBLE PRECISION
     1     XI(4,MAXTRA),XF(4,MAXTRA),
     2     AKOEFF(NORDNG,NORDNG,NORDNG,NORDNG),
     2     AKOEFFC(NORDNG,NORDNG,NORDNG,NORDNG),
     *     AERZ(NORDNG,NORDNG,NORDNG,NORDNG),
     *     AREF(NORDNG,NORDNG,NORDNG,NORDNG),
     3     BVECT(MKOEF),BVECTC(MKOEF),BVECTCC(MKOEF),
     6     GMAT(MKOEF,MKOEF),GMATC(MKOEF,MKOEF),WORK(MKOEF),
     8     XE(MAXTRA,NORDNG+1),YE(MAXTRA,NORDNG+1),
     9     PE(MAXTRA,NORDNG+1),QE(MAXTRA,NORDNG+1),
     *     TRALIN(4,4),QUADR(4,4)
     1    ,SI(MAXTRA),SF(MAXTRA)

      DOUBLE PRECISION
     &          GAMMA,BRHOABS,PEL,DUM
     &          ,X0,Y0,Z0,ZP0,YP0,BX0,BY0,BZ0,AX0,AY0,AZ0
     &          ,XF0,YF0,ZF0,ZPF0,YPF0,BXF0,BYF0,BZF0,AXF0,AYF0,AZF0
     &         ,XICAVE,XFCAVE,XFXCAVE,XFYCAVE,XIXCAVE,XIYCAVE
     &         ,DIIP,DJJP,DKKP,DLLP,DI,DJ,DK,DL
     &          ,RESB2,RESBM,RESBAV,RESAM,RESA2,RESAAV,RESAMR,RESA2R
     &         ,RES,RESA,RESAR
     &          ,A1100,A2000,A0200,A0011,A0020,A0002,DETTRA1,DETTRA2
     &         ,ZLHAL,FY,FX,R2HAL,SINZ2,ZETAZ,ZLENGE,RHOHAL,B0HAL
     &         ,XLHAL,YLHAL,T11,T33,SIHPHIX,PHIX,QUADX,QUADFX,SINPHIX
     &         ,QUADY,QUADFY,SINPHIY,PHIY
     &         ,FOCEX,FOCEY,SIHPHIY
     &                  ,RESXMK, RESXAVK, RESXK,
     &                   RESYMK, RESYAVK, RESYK,
     &                   RESPXMK,RESPXAVK,RESPXK,
     &                   RESPYMK,RESPYAVK,RESPYK,RESAKO,
     &                   RESXME, RESXAVE, RESXE,
     &                   RESYME, RESYAVE, RESYE,
     &                   RESPXME,RESPXAVE,RESPXE,
     &                   RESPYME,RESPYAVE,RESPYE,RESERZ,
     &                   RESXMR, RESXAVR, RESXR,
     &                   RESYMR, RESYAVR, RESYR,
     &                   RESPXMR,RESPXAVR,RESPXR,
     &                   RESPYMR,RESPYAVR,RESPYR,RESREF,
     &                   RSXMTK, RSXAVTK, RSXTK,
     &                   RSYMTK, RSYAVTK, RSYTK,
     &                   RSPXMTK,RSPXAVTK,RSPXTK,
     &                   RSPYMTK,RSPYAVTK,RSPYTK,RESLIN,
     &                   RSXMT, RSXAVT, RSXT,
     &                   RSYMT, RSYAVT, RSYT,
     &                   RSPXMT,RSPXAVT,RSPXT,
     &                   RSPYMT,RSPYAVT,RSPYT,RESTRA,
     &                   RSXMTQ, RSXAVTQ, RSXTQ,
     &                   RSYMTQ, RSYAVTQ, RSYTQ,
     &                   RSPXMTQ,RSPXAVTQ,RSPXTQ,
     &                   RSPYMTQ,RSPYAVTQ,RSPYTQ,RESQUAD,
     &                   RESB,RESAAVR,RESR,AK,AE,AR,AKE,AKR

C     DOUBLE PRECISION XCLOSE,PCLOSE
C     DOUBLE PRECISION PXI0,PYI0,PXF0,PYF0

      DOUBLE PRECISION V0,V0X,V0Y,V0Z,VF0X,VF0Y,VF0Z,EWS(3),EWY(3),EWZ(3),EN
     &        ,VX1,VY1,VZ1,VX2,VY2,VZ2
     &        ,PXIR0,PYIR0,PXFR0,PYFR0,W0S,W0Y,W0X,WF0S,WF0Y,WF0X
     &        ,W0,WS1,WY1,WX1,WS2,WY2,WX2
     &        ,XPR1,YPR1,XPR2,YPR2
     &        ,X1,Y1,Z1,ZP1,YP1,X2,Y2,Z2,ZP2,YP2
     &        ,EWSF(3),EWYF(3),EWZF(3),SR1,YR1,XR1,SR2,YR2,XR2

+SEQ,TTRACKS.

      DOUBLE PRECISION XKHAL,YKHAL,ZKHAL
     &,XKHALR,XKHALI,YKHALR,YKHALI,ZKHALR,ZKHALI

      DATA LUNAKO/15/
      DATA LUNERZ/13/
      DATA LUNREF/17/
      DATA LUNTRA/19/
      DATA LUNSTR/18/

      DATA IREAD/0/

      MAXTRAP=MAXTRA
      NORDNGP=NORDNG

C     PI=4.D0*DATAN(1.D0)

C--- READ AND WRITE CURRENT RUN NUMBER OF TRANPOLY

      OPEN(UNIT=LUNTRA,
     &      FILE='WAVE_TRANCODE.DAT',STATUS='OLD',
     &      FORM='FORMATTED',ERR=66)
          READ(LUNTRA,*,ERR=66)ITRANC
      CLOSE(LUNTRA)
66    ITRANC=ITRANC+1

      OPEN(UNIT=LUNTRA,FILE='WAVE_TRANCODE.DAT',
     &     STATUS='UNKNOWN',FORM='FORMATTED')
           WRITE(LUNTRA,*)ITRANC
C           IF (IGFLOAT.NE.0) ITRANC=-ITRANC
      CLOSE(LUNTRA)

      MKOEFV=MKOEF ! WEGEN UEBERGABE NACH SR DEQN

      LUN1=LUNGFO

      IF (LUN1.NE.LUNGFO)
     &OPEN(UNIT=LUN1,FILE='WAVE_TRANPOLY.OUT',STATUS='NEW',FORM='FORMATTED')

      WRITE (LUN1,*)
      WRITE (LUN1,6789)
6789  FORMAT(1H1)
      WRITE (LUN1,*) '     SR TRANMAP'
      WRITE (LUN1,*) '     ==========='
      WRITE (LUN1,*)
      WRITE (LUN1,*)

C      OPEN(UNIT=LUNGFI,FILE=FILEI,STATUS='OLD',FORM='FORMATTED')

C--- LIES FILE MIT TRAJEKTORIEN

+SELF,IF=VMS.
      OPEN(UNIT=LUNO,FILE=FILEO,STATUS='OLD',READONLY,FORM='UNFORMATTED')
+SELF.

+SELF,IF=LINUX,WINDOWS,HPUX,TRUE64.
      OPEN(UNIT=LUNO,FILE=FILEO,STATUS='OLD',FORM='UNFORMATTED')
+SELF.


      READ(LUNO)CODE
      READ(LUNO)ICODE
      READ(LUNO)GAMMA
      READ(LUNO)NTOT

      IF (NTOT.GT.MAXTRA) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN TRANMAP ***'
          WRITE(LUNGFO,*)'TOO MANY TRACKS ON FILE FILEO'
          WRITE(LUNGFO,*)'INCREASE PARAMETER MAXTRA IN FILE GENFUN.CMN'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN TRANMAP ***'
          WRITE(6,*)'TOO MANY TRACKS ON FILE FILEO'
          WRITE(6,*)'INCREASE PARAMETER MAXTRA IN FILE GENFUN.CMN'
          WRITE(6,*)
          STOP
      ENDIF

C     WRITE(6,*)
C     WRITE(6,*) 'ANZAHL DER TRAJEKTORIEN AUF DATEN-FILE:',NTOT
C     WRITE(6,*)

      MTRAJ=NTOT

      IF (MTRAJ.GT.NTOT)STOP '*** SR TRANMAP: MTRAJ.GT.NTOT ***'

      READ(LUNO)X0,Y0,Z0,ZP0,YP0,BX0,BY0,BZ0,AX0,AY0,AZ0
      READ(LUNO)XF0,YF0,ZF0,ZPF0,YPF0,BXF0,BYF0,BZF0,AXF0,AYF0,AZF0
      READ(LUNO)OPNX,OPNY,OPNZ
      READ(LUNO)OPNFX,OPNFY,OPNFZ

      DO J=1,MTRAJ
            READ(LUNO) SI(J),XI(1,J),XI(2,J),XI(3,J),XI(4,J),
     &                   BXI(J),BYI(J),BZI(J),AXI(J),AYI(J),AZI(J)
            READ(LUNO) SF(J),XF(1,J),XF(2,J),XF(3,J),XF(4,J),
     &                   BXF(J),BYF(J),BZF(J),AXF(J),AYF(J),AZF(J)
      ENDDO

      CLOSE(LUNO)

C--- SUPERIMPOSE NOISE TO SIMULATE TRACKING UNCERTAINTIES

      IF (DRAUSCHX.NE.0..OR.DRAUSCHY.NE.0.) THEN

         DO I=1,MTRAJ
             call util_random_gauss(1,XRAN,rr)
             XF(1,I)=XF(1,I)+xran(1)*DRAUSCHX
             call util_random_gauss(1,XRAN,rr)
             XF(2,I)=XF(2,I)+xran(1)*DRAUSCHX
             call util_random_gauss(1,XRAN,rr)
             XF(3,I)=XF(3,I)+xran(1)*DRAUSCHY
             call util_random_gauss(1,XRAN,rr)
             XF(4,I)=XF(4,I)+xran(1)*DRAUSCHY
         ENDDO

      ENDIF

      IF (I2DIM.NE.0) THEN

         DO I=1,MTRAJ
             IF(    XI(3,I).NE.0.
     &            .OR. XI(4,I).NE.0.
     &            .OR. XF(3,I).NE.0.
     &            .OR. XF(4,I).NE.0. ) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &              '*** ERROR IN TRANMAP ***'
            WRITE(LUNGFO,*)
     &              'FLAG I2DIM IS SET BUT TRACKS ARE NOT PLANAR'
            WRITE(LUNGFO,*)
     &              'SOMETHING IS WRONG WITH THE INPUT FILE FILEO'
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)
     &              '*** ERROR IN TRANMAP ***'
            WRITE(6,*)
     &              'FLAG I2DIM IS SET BUT TRACKS ARE NOT PLANAR'
            WRITE(6,*)
     &              'SOMETHING IS WRONG WITH THE INPUT FILE FILEO'
            WRITE(6,*)
                        STOP
                  ENDIF
         ENDDO

      ENDIF ! I2DIM

C--------------------------------------------------------------

      V0=CLIGHT1*DSQRT((1.D0-1.D0/GAMMA)*(1.D0+1.D0/GAMMA))
      W0=V0
      PEL=EMASSE1*DSQRT( (GAMMA+1.D0)*(GAMMA-1.D0) )
      BRHOABS=PEL/CLIGHT1  !ABSOLUTE VALUE

C--- REFERENCE SYSTEM AT ENTRANCE

C     IF THE ENTRANCE PLANE OF THE DEVICE IS PERPENDICULAR TO THE REFERENCE
C       ORBIT, THEN THE REFERENCE ORBIT HAS ZERO SLOPE
C     AND DISPLACEMENT IN THIS SYSTEM AND ALL VARIABLES ARE RELATIVE TO THE
C     REFERENCE ORBIT. IF IN THE OTHER CASE THE ENTRANCE PLANE IS PERPEN-
C     DICULAR TO THE LONGITUDINAL AXIS OF THE DEVICE, THE REFERENCE SYSTEM
C     IS IDENTICAL TO THE LAB.-SYSTEM. BOTH CASES ARE DESCRIBED BY THE SAME
C     FORMULAS IF WE SUBTRACT THE REFERENCE ORBIT FROM ALL VARIABLES.
C     THE CLOSED ORBIT IS THEN TAKEN OUT AND ALL CLOSED ORBIT TERMES SHOULD
C     VANISH. THE SAME IS VALID FOR THE EXIT PLANE.


C     EWS HAS DIFFERENT MEANING THAN IN SR OPTIC

      EWS(1)=OPNX
      EWS(2)=OPNY
      EWS(3)=OPNZ

      EN=1.D0/DSQRT(EWS(3)*EWS(3)+EWS(1)*EWS(1))

C        UNIT-VECTOR EWZ~[EWS,(0,1,0)] (CROSS-PRODUCT)
      EWZ(1)=-EWS(3)*EN
      EWZ(2)= 0.
      EWZ(3)= EWS(1)*EN

C     UNIT-VECTOR EWY=[EWZ,EWS]

      EWY(1)= EWZ(2)*EWS(3) - EWZ(3)*EWS(2)
      EWY(2)= EWZ(3)*EWS(1) - EWZ(1)*EWS(3)
      EWY(3)= EWZ(1)*EWS(2) - EWZ(2)*EWS(1)

      EWSF(1)=OPNFX
      EWSF(2)=OPNFY
      EWSF(3)=OPNFZ

      EN=1.D0/DSQRT(EWSF(3)*EWSF(3)+EWSF(1)*EWSF(1))
      EWZF(1)=-EWSF(3)*EN
      EWZF(2)= 0.
      EWZF(3)= EWSF(1)*EN

      EWYF(1)= EWZF(2)*EWSF(3) - EWZF(3)*EWSF(2)
      EWYF(2)= EWZF(3)*EWSF(1) - EWZF(1)*EWSF(3)
      EWYF(3)= EWZF(1)*EWSF(2) - EWZF(2)*EWSF(1)

C--- NORMALIZED VELOCITIES OF THE REFERENCE ORBIT

      V0X=1.D0/DSQRT(1.D0+ZP0*ZP0+YP0*YP0)
      V0Y=YP0*V0X
      V0Z=ZP0*V0X

      VF0X=1.D0/DSQRT(1.D0+ZPF0*ZPF0+YPF0*YPF0)
      VF0Y=YPF0*VF0X
      VF0Z=ZPF0*VF0X

C--- TRANSFORM VELOCITIES OF REFERENCE ORBIT INTO REFERENCE SYSTEM

C     FOR THE TIME BEING (7.1.1992) (W0S,W0Y,W0X)=(V0X,V0Y,V0Z) OR
C     (W0S,W0Y,W0X)=(1,0,0)

      W0S=V0X*EWS(1)+V0Y*EWS(2)+V0Z*EWS(3)
      W0Y=V0X*EWY(1)+V0Y*EWY(2)+V0Z*EWY(3)
      W0X=V0X*EWZ(1)+V0Y*EWZ(2)+V0Z*EWZ(3)

      WF0S=VF0X*EWSF(1)+VF0Y*EWSF(2)+VF0Z*EWSF(3)
      WF0Y=VF0X*EWYF(1)+VF0Y*EWYF(2)+VF0Z*EWYF(3)
      WF0X=VF0X*EWZF(1)+VF0Y*EWZF(2)+VF0Z*EWZF(3)

C--- CANONICAL VARIABLES OF REFERENCE ORBIT

      PXIR0=W0X/W0S
      PYIR0=W0Y/W0S

      PXFR0=WF0X/WF0S
      PYFR0=WF0Y/WF0S

C--- LOOP OVER TRAJECTORIES -------------------------------------------

      DO I=1,MTRAJ

C--- EVERYTHING IN THE LAB.SYSTEM

         X1= SI(I)
         Z1= XI(1,I)
         ZP1=XI(2,I)
         Y1= XI(3,I)
         YP1=XI(4,I)

         VX1=1.D0/DSQRT(1.D0+ZP1**2+YP1**2)
         VY1=YP1*VX1
         VZ1=ZP1*VX1

         X2= SF(I)
         Z2= XF(1,I)
         ZP2=XF(2,I)
         Y2= XF(3,I)
         YP2=XF(4,I)

         VX2=1.D0/DSQRT(1.D0+ZP2**2+YP2**2)
         VY2=YP2*VX2
         VZ2=ZP2*VX2

C--- TRANSFORM VELOCITIES INTO REFERENCE SYSTEM

         WS1=VX1*EWS(1)+VY1*EWS(2)+VZ1*EWS(3)
         WY1=VX1*EWY(1)+VY1*EWY(2)+VZ1*EWY(3)
         WX1=VX1*EWZ(1)+VY1*EWZ(2)+VZ1*EWZ(3)

         WS2=VX2*EWSF(1)+VY2*EWSF(2)+VZ2*EWSF(3)
         WY2=VX2*EWYF(1)+VY2*EWYF(2)+VZ2*EWYF(3)
         WX2=VX2*EWZF(1)+VY2*EWZF(2)+VZ2*EWZF(3)

C--- SLOPES IN THE REFERENCE SYSTEM

         XPR1=WX1/WS1
         YPR1=WY1/WS1

         XPR2=WX2/WS2
         YPR2=WY2/WS2

C--- TRANSFORM COORDINATES INTO REFERENCE SYSTEM

         SR1=(X1-X0)*EWS(1)+(Y1-Y0)*EWS(2)+(Z1-Z0)*EWS(3)
         YR1=(X1-X0)*EWY(1)+(Y1-Y0)*EWY(2)+(Z1-Z0)*EWY(3)
         XR1=(X1-X0)*EWZ(1)+(Y1-Y0)*EWZ(2)+(Z1-Z0)*EWZ(3)

         SR2=(X2-XF0)*EWSF(1)+(Y2-YF0)*EWSF(2)+(Z2-ZF0)*EWSF(3)
         YR2=(X2-XF0)*EWYF(1)+(Y2-YF0)*EWYF(2)+(Z2-ZF0)*EWYF(3)
         XR2=(X2-XF0)*EWZF(1)+(Y2-YF0)*EWZF(2)+(Z2-ZF0)*EWZF(3)

C--- MAPPING VARIABLES

         XIC(I)=XR1
         YIC(I)=YR1

         PXI(I)=XPR1
         PYI(I)=YPR1

         XFC(I)=XR2
         YFC(I)=YR2

         PXF(I)=XPR2
         PYF(I)=YPR2

      ENDDO

C--------------------------------------------------------------
C240991 MEAN LENGTH OF VECTORS

      XICAVE=0.D0
      XFCAVE=0.D0
      XIXCAVE=0.D0
      XIYCAVE=0.D0
      XFXCAVE=0.D0
      XFYCAVE=0.D0
      DO I=1,MTRAJ
         XICAVE=XICAVE+DSQRT(XIC(I)**2+YIC(I)**2+PXI(I)**2+PYI(I)**2)
         XFCAVE=XFCAVE+DSQRT(XFC(I)**2+YFC(I)**2+PXF(I)**2+PYF(I)**2)
         XIXCAVE=XIXCAVE+DSQRT(XIC(I)**2+PXI(I)**2)
         XIYCAVE=XIYCAVE+DSQRT(YIC(I)**2+PYI(I)**2)
         XFXCAVE=XFXCAVE+DSQRT(XFC(I)**2+PXF(I)**2)
         XFYCAVE=XFYCAVE+DSQRT(YFC(I)**2+PYF(I)**2)
      ENDDO
      XICAVE=XICAVE/MTRAJ
      XFCAVE=XFCAVE/MTRAJ
      XIXCAVE=XIXCAVE/MTRAJ
      XIYCAVE=XIYCAVE/MTRAJ
      XFXCAVE=XFXCAVE/MTRAJ
      XFYCAVE=XFYCAVE/MTRAJ

C--------------------------------------------------------------
C230891
      IF(IA11A20.NE.0) THEN
         DO M=1,MTRAJ         ! i.e. A(1,1,0,0) = 1
             XFC(M)=XFC(M)-XIC(M)   !      A(2,0,0,0) = 0
             PXI(M)=PXI(M)-PXF(M)
         ENDDO
      ENDIF
C--------------------------------------------------------------
C     CHANGE SCALE

          X0=X0*DSCALE
          Y0=Y0*DSCALE
          Z0=Z0*DSCALE
          XF0=XF0*DSCALE
          YF0=YF0*DSCALE
          ZF0=ZF0*DSCALE

      DO M=1,MTRAJ
          XIC(M)=XIC(M)*DSCALE
          XFC(M)=XFC(M)*DSCALE
          PXI(M)=PXI(M)*DSCALE
          PXF(M)=PXF(M)*DSCALE
          YIC(M)=YIC(M)*DSCALE
          YFC(M)=YFC(M)*DSCALE
          PYI(M)=PYI(M)*DSCALE
          PYF(M)=PYF(M)*DSCALE
      ENDDO

C--------------------------------------------------------------
C     SET UP SYSTEM OF EQUATIONS

C--- INDEX POINTER IE(K1,K2,K3,K4), JE(K1,....

      NKOEF=0
      DO I=1,NORDNG
      DO J=1,NORDNG
      DO K=1,NORDNG
      DO L=1,NORDNG

C---    THE SUBSEQUENT INDICES I,J,K,L RUN FROM 1...5,
C       THE CORRESPONDING MATH. INDICES i,j,k,l from 0...4

          IF (I-1 + J-1 + K-1 + L-1 .LT. NORDNG
     &      .AND.
     &      I-1 + J-1 + K-1 + L-1 .GT. 0
     &          .AND.

C         !MID-PLANE SYMMETRY
     &          ((K-1+L-1)/2*2.EQ.(K-1+L-1).OR.ISYM.EQ.0)
     &          .AND.

C         !HORI. FOCAL LENGTH = 0
     &          (IA11A20.EQ.0 .OR.
     &          (I-1.NE.2.OR.J-1.NE.0.OR.K-1.NE.0.OR.L-1.NE.0))  !A2000=0
     &          .AND.

C         !NOTE ALSO OTHER CHANGES DUE TO A1100=1
     &          (IA11A20.EQ.0 .OR.
     &          (I-1.NE.1.OR.J-1.NE.1.OR.K-1.NE.0.OR.L-1.NE.0))   !A1100=1
     &          .AND.

     &      (IA1000.EQ.0.OR.
     &          I-1.NE.1.OR.J-1.NE.0.OR.K-1.NE.0.OR.L-1.NE.0)  !A1000=0
     &          .AND.

     &      (IA0100.EQ.0.OR.
     &           I-1.NE.0.OR.J-1.NE.1.OR.K-1.NE.0.OR.L-1.NE.0) !A0100=0
     &          .AND.

     &      (IA0010.EQ.0.OR.
     &           I-1.NE.0.OR.J-1.NE.0.OR.K-1.NE.1.OR.L-1.NE.0) !A0010=0
     &          .AND.

     &      (IA0001.EQ.0.OR.
     &           I-1.NE.0.OR.J-1.NE.0.OR.K-1.NE.0.OR.L-1.NE.1) !A0001=0
     &          .AND.

C         !WLS IS HORZ. DRIFT
     &      (I-1+J-1.LT.3.OR.IWLSHOR.EQ.0)
     &          .AND.

     &      (K-1+L-1.EQ.0.OR.I2DIM.EQ.0)   !I2DIM CASE

     &        ) THEN

         NKOEF=NKOEF+1

       IF (NKOEF.GT.MKOEF) STOP
     &       '*** SR TRANMAP: NKOEF.GT.MKOEF ***'

         IE(NKOEF)=I
         JE(NKOEF)=J
         KE(NKOEF)=K
         LE(NKOEF)=L

          ENDIF

      ENDDO
      ENDDO
      ENDDO
      ENDDO

C---
      IF (MTRAJ.LT.NKOEF) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'*** ERROR IN TRANMAP ***'
         WRITE(LUNGFO,*)'NOT ENOUGH TRACKS TO FIT COEFFICIENTS'
         WRITE(LUNGFO,*)'NUMBER OF TRACKS:      ',MTRAJ
         WRITE(LUNGFO,*)'NUMBER OF COEFFICIENTS:',NKOEF
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)'*** ERROR IN TRANMAP ***'
         WRITE(6,*)'NOT ENOUGH TRACKS TO FIT COEFFICIENTS'
         WRITE(6,*)'NUMBER OF TRACKS:      ',MTRAJ
         WRITE(6,*)'NUMBER OF COEFFICIENTS:',NKOEF
         WRITE(6,*)
         STOP
      ENDIF

C--- POWER TERMS FOR MATRIX

      DO M=1,MTRAJ

         XE(M,1)=0.D0         ! x**(i-1) in math. formulas
         YE(M,1)=0.D0
         PE(M,1)=0.D0
         QE(M,1)=0.D0

         XE(M,2)=1.D0         ! x**0 in math. formulas
         YE(M,2)=1.D0
         PE(M,2)=1.D0
         QE(M,2)=1.D0

         DO I=3,NORDNG

            XE(M,I)=XE(M,I-1)*XIC(M)  ! x**i in math. formulas
            YE(M,I)=YE(M,I-1)*YIC(M)
            PE(M,I)=PE(M,I-1)*PXI(M)
            QE(M,I)=QE(M,I-1)*PYI(M)

         ENDDO

         XE(M,NORDNG+1)=0.D0  ! just formal to make GMAT loop run
         YE(M,NORDNG+1)=0.D0
         PE(M,NORDNG+1)=0.D0
         QE(M,NORDNG+1)=0.D0

      ENDDO

C--- MATRIX GMAT

      DO NP=1,NKOEF
      DO N=1,NKOEF

        I=IE(N)
        J=JE(N)
        K=KE(N)
        L=LE(N)

        IP=IE(NP)
        JP=JE(NP)
        KP=KE(NP)
        LP=LE(NP)

        DIIP=DFLOAT((I-1)*(IP-1))   ! 0*0 <= DIIP <= 4*4
        DJJP=DFLOAT((J-1)*(JP-1))
        DKKP=DFLOAT((K-1)*(KP-1))
        DLLP=DFLOAT((L-1)*(LP-1))

        II=I+1
        JJ=J+1
        KK=K+1
        LL=L+1

        I1=II-1
        J1=JJ-1
        K1=KK-1
        L1=LL-1

        IIP=IP+1
        JJP=JP+1
        KKP=KP+1
        LLP=LP+1

        I1P=IIP-1
        J1P=JJP-1
        K1P=KKP-1
        L1P=LLP-1

        DO M=1,MTRAJ

          GMAT(NP,N)=GMAT(NP,N)

     &       + DIIP * XE(M,I1)  * PE(M,JJ)  * YE(M,KK)  * QE(M,LL)
     &      * XE(M,I1P) * PE(M,JJP) * YE(M,KKP) * QE(M,LLP)
     &       + DJJP * XE(M,II)  * PE(M,J1)  * YE(M,KK)  * QE(M,LL)
     &         * XE(M,IIP) * PE(M,J1P) * YE(M,KKP) * QE(M,LLP)
     &       + DKKP * XE(M,II)  * PE(M,JJ)  * YE(M,K1)  * QE(M,LL)
     &         * XE(M,IIP) * PE(M,JJP) * YE(M,K1P) * QE(M,LLP)
     &       + DLLP * XE(M,II)  * PE(M,JJ)  * YE(M,KK)  * QE(M,L1)
     &         * XE(M,IIP) * PE(M,JJP) * YE(M,KKP) * QE(M,L1P)

        ENDDO

      ENDDO
      ENDDO

C--- INHOMOGENEITY BVECT OF EQUATION SYSTEM

      DO N=1,NKOEF

        I=IE(N)
        J=JE(N)
        K=KE(N)
        L=LE(N)

        DI=DFLOAT(I-1)
        DJ=DFLOAT(J-1)
        DK=DFLOAT(K-1)
        DL=DFLOAT(L-1)

        II=I+1
        JJ=J+1
        KK=K+1
        LL=L+1

        I1=II-1
        J1=JJ-1
        K1=KK-1
        L1=LL-1

        DO M=1,MTRAJ

          BVECT(N)=BVECT(N)
     &   + DI * PXF(M)  * XE(M,I1) * PE(M,JJ) * YE(M,KK) * QE(M,LL)
     &   + DJ * XFC(M)  * XE(M,II) * PE(M,J1) * YE(M,KK) * QE(M,LL)
     &   + DK * PYF(M)  * XE(M,II) * PE(M,JJ) * YE(M,K1) * QE(M,LL)
     &   + DL * YFC(M)  * XE(M,II) * PE(M,JJ) * YE(M,KK) * QE(M,L1)

        ENDDO

      ENDDO

C--- SAVE SYSTEM OF EQUATIONS

      DO I=1,MKOEFV
      DO J=1,MKOEFV
         GMATC(I,J)=GMAT(I,J)
      ENDDO
         BVECTC(I)=BVECT(I)
      ENDDO

C---  SOLVE SYSTEM OF EQUATION USING CERN ROUTINE F010

      CALL DEQN(NKOEF,GMAT,MKOEFV,WORK,IFAIL1,1,BVECT)
      IF (IFAIL1.NE.0) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'*** ERROR IN TRANMAP ***'
         WRITE(LUNGFO,*)
     & 'CERN ROUTINE F010 TO SOLVE SYSTEM OF EQUATIONS FAILED'
         WRITE(LUNGFO,*)
     & 'PERHAPS TOO MANY COEFFICIENTS TO FIT ??'
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)'*** ERROR IN TRANMAP ***'
         WRITE(6,*)
     & 'CERN ROUTINE F010 TO SOLVE SYSTEM OF EQUATIONS FAILED'
         WRITE(6,*)
     & 'PERHAPS TOO MANY COEFFICIENTS TO FIT ??'
         WRITE(6,*)
         STOP
      ENDIF

C--- GET RESULTS

      DO N=1,NKOEF

      I=IE(N)
      J=JE(N)
      K=KE(N)
      L=LE(N)

      AKOEFF(I,J,K,L)=BVECT(N)

      ENDDO

C--- CHECK SOLUTION OF THE EQUATION SYSTEM

      RESB2=0.D0
      RESBM=0.D0
      RESBAV=0.D0

      DO I=1,NKOEF
         BVECTCC(I)=0.D0
         DO J=1,NKOEF
         BVECTCC(I)=BVECTCC(I) +
     &            GMATC(I,J) * BVECT(J)
         ENDDO
         RES=BVECTCC(I)-BVECTC(I)
         IF(DABS(RES).GT.DABS(RESBM)) RESBM = RES
         RESBAV=RESBAV+RES
         RESB2 = RESB2 + RES*RES
      ENDDO
      RESB=DSQRT(RESB2/NKOEF)
      RESBAV=RESBAV/NKOEF

C--------------------------------------------------------------
C     RESCALING

      DO I=0,NORDNG-1
      DO J=0,NORDNG-1
      DO K=0,NORDNG-1
      DO L=0,NORDNG-1
      IF (I+J+K+L.LE.NORDNG-1)
     &   AKOEFF(I+1,J+1,K+1,L+1)=
     &   AKOEFF(I+1,J+1,K+1,L+1)*DSCALE**(I+K-1+J+L-1)
      ENDDO
      ENDDO
      ENDDO
      ENDDO

          X0=X0/DSCALE
          Y0=Y0/DSCALE
          Z0=Z0/DSCALE
          XF0=XF0/DSCALE
          YF0=YF0/DSCALE
          ZF0=ZF0/DSCALE

      DO M=1,MTRAJ
          XIC(M)=XIC(M)/DSCALE
          XFC(M)=XFC(M)/DSCALE
          PXI(M)=PXI(M)/DSCALE
          PXF(M)=PXF(M)/DSCALE
          YIC(M)=YIC(M)/DSCALE
          YFC(M)=YFC(M)/DSCALE
          PYI(M)=PYI(M)/DSCALE
          PYF(M)=PYF(M)/DSCALE
      ENDDO

C230891
      IF(IA11A20.NE.0) THEN
         AKOEFF(2,2,1,1)=1.D0 ! ADD A1100=1
         DO M=1,MTRAJ
             XFC(M)=XFC(M)+AKOEFF(2,2,1,1)*XIC(M)
             PXF(M)=PXF(M)+AKOEFF(2,2,1,1)*PXI(M)
         ENDDO
         NKOEF=NKOEF+1
         IE(NKOEF)=2
         JE(NKOEF)=2
         KE(NKOEF)=1
         LE(NKOEF)=1
      ENDIF

C--- COMPARE CALCULATED AND GIVEN COEFFICIENTS A(I,J,K,L)

      OPEN(UNIT=LUNERZ,FILE='WAVE_TRANMAP.IN',STATUS='OLD',ERR=99)

C10.6.93 READ(LUNERZ,'(I10,1A60)')ICODEERZ,CODEERZ

      READ(LUNERZ,'(2I5,1A55)')ICODEERZ,ITRANCE,CODEERZ
      READ(LUNERZ,'(A1)')C1

C10.6.93 DO IREAD=1,NKOEF

      DO IREAD=1,1000000

         READ (LUNERZ,*, END=11) I,J,K,L,DUM

         IF(I+J+K+L.LE.NORDNG-1) THEN
            AERZ(I+1,J+1,K+1,L+1)=DUM
         ELSE
            IWARNE=1
         ENDIF

      END DO

11    IERZ=IREAD-1
99    CONTINUE
      IREAD=0
C     IF (IERZ.NE.0) IKOEFF=1
      CLOSE(LUNERZ)

      OPEN(UNIT=LUNREF,FILE='WAVE_TRANMAP.REF',STATUS='OLD',ERR=88)

C10.6.93 READ(LUNREF,'(I10,1A60)')ICODEREF,CODEREF

      READ(LUNREF,'(2I5,1A55)')ICODEREF,ITRANCR,CODEREF
      READ(LUNREF,'(A1)')C1

C260891  READ(LUNREF,*)

C10.6.93 DO IREAD=1,NKOEF

      DO IREAD=1,1000000

         READ (LUNREF,*, END=22) I,J,K,L,DUM

         IF(I+J+K+L.LE.NORDNG-1) THEN
            AREF(I+1,J+1,K+1,L+1)=DUM
         ELSE
            IWARNR=1
         ENDIF
      END DO

22    IREF=IREAD-1
88    CONTINUE
C     IF (IREF.NE.0) IKOEFF=1
      CLOSE(LUNREF)

      RESAM=0.D0
      RESA2=0.D0
      RESAAV=0.D0
      RESAMR=0.D0
      RESA2R=0.D0
      RESAAVR=0.D0


      IF (IERZ.GT.0) THEN
      DO I=1,NORDNG
      DO J=1,NORDNG
      DO K=1,NORDNG
      DO L=1,NORDNG

          RES=AKOEFF(I,J,K,L)-AERZ(I,J,K,L)
          IF (DABS(RES).GT.DABS(RESAM)) RESAM=RES
          RESA2=RESA2+RES*RES
          RESAAV=RESAAV+RES
          RESR=AKOEFF(I,J,K,L)-AREF(I,J,K,L)
          IF (DABS(RESR).GT.DABS(RESAMR)) RESAMR=RESR
          RESA2R=RESA2R+RESR*RESR
          RESAAVR=RESAAVR+RESR

      ENDDO
      ENDDO
      ENDDO
      ENDDO

      RESA=DSQRT(RESA2/NKOEF)
      RESAAV=RESAAV/NKOEF
      RESAR=DSQRT(RESA2R/NKOEF)
      RESAAVR=RESAAVR/NKOEF
      ENDIF

C--- CALCULATE TRACKS FROM FITTED MAPPING (AKOEFF) AND COMPARE
C    WITH ORIGINAL TRACKING RESULTS

      CALL ARESIMAP(      AKOEFF,MAXTRAP,NORDNGP,
     &                   RESXMK, RESXAVK, RESXK,
     &                   RESYMK, RESYAVK, RESYK,
     &                   RESPXMK,RESPXAVK,RESPXK,
     &                   RESPYMK,RESPYAVK,RESPYK,RESAKO)

C--- CALCULATE TRACKS FROM GIVEN MAPPING (AERZ) AND COMPARE
C    WITH ORIGINAL TRACKING RESULTS

      IF (IERZ.GT.0)
     &   CALL ARESIMAP(  AERZ,MAXTRAP,NORDNGP,
     &                   RESXME, RESXAVE, RESXE,
     &                   RESYME, RESYAVE, RESYE,
     &                   RESPXME,RESPXAVE,RESPXE,
     &                   RESPYME,RESPYAVE,RESPYE,RESERZ)

C--- CALCULATE TRACKS FROM GIVEN MAPPING (AREF) AND COMPARE
C    WITH ORIGINAL TRACKING RESULTS

      IF (IREF.GT.0)
     &   CALL ARESIMAP(     AREF,MAXTRAP,NORDNGP,
     &                   RESXMR, RESXAVR, RESXR,
     &                   RESYMR, RESYAVR, RESYR,
     &                   RESPXMR,RESPXAVR,RESPXR,
     &                   RESPYMR,RESPYAVR,RESPYR,RESREF)


C--- CALCULATE TRACKS FROM LINEAR TERMS OF MAPPING AND COMPARE
C    WITH ORIGINAL TRACKING RESULTS

      DO I=1,NORDNG
      DO J=1,NORDNG
      DO K=1,NORDNG
      DO L=1,NORDNG

      AKOEFFC(I,J,K,L)=0.D0
      IF(I-1+J-1+K-1+L-1.LE.2) AKOEFFC(I,J,K,L)=AKOEFF(I,J,K,L)

      ENDDO
      ENDDO
      ENDDO
      ENDDO

      CALL ARESIMAP(      AKOEFFC,MAXTRAP,NORDNGP,
     &                   RSXMTK, RSXAVTK, RSXTK,
     &                   RSYMTK, RSYAVTK, RSYTK,
     &                   RSPXMTK,RSPXAVTK,RSPXTK,
     &                   RSPYMTK,RSPYAVTK,RSPYTK,RESLIN)


C--- LINEAR TRANSFER MATRIX WITHOUT COUPLING

      A1100=AKOEFF(2,2,1,1)
      A2000=AKOEFF(3,1,1,1)
      A0200=AKOEFF(1,3,1,1)

      A0011=AKOEFF(1,1,2,2)
      A0020=AKOEFF(1,1,3,1)
      A0002=AKOEFF(1,1,1,3)

      TRALIN(1,1)=AKOEFF(2,2,1,1)
      TRALIN(1,2)=AKOEFF(2,3,1,1)
      TRALIN(2,1)=AKOEFF(3,2,1,1)
      TRALIN(2,2)=AKOEFF(3,3,1,1)

      DETTRA1=TRALIN(1,1)*TRALIN(2,2)-TRALIN(2,1)*TRALIN(1,2)

      IF (I2DIM.EQ.0)  THEN

      TRALIN(3,3)=AKOEFF(1,1,2,2)
      TRALIN(3,4)=AKOEFF(1,1,2,3)
      TRALIN(4,3)=AKOEFF(1,1,3,2)
      TRALIN(4,4)=AKOEFF(1,1,3,3)

      TRALIN(1,3)=AKOEFF(2,1,2,1)
      TRALIN(1,4)=AKOEFF(2,1,3,1)
      TRALIN(2,3)=AKOEFF(3,1,2,1)
      TRALIN(2,4)=AKOEFF(3,1,3,1)

      TRALIN(3,1)=AKOEFF(1,2,1,2)
      TRALIN(3,2)=AKOEFF(1,2,1,3)
      TRALIN(4,1)=AKOEFF(1,3,1,2)
      TRALIN(4,2)=AKOEFF(1,3,1,3)

         DETTRA2=TRALIN(3,3)*TRALIN(4,4)-TRALIN(3,4)*TRALIN(4,3)

      ENDIF

      IF(TRALIN(2,1).NE.0.) FOCEX=-1.D0/TRALIN(2,1)
      IF(TRALIN(4,3).NE.0.) FOCEY=-1.D0/TRALIN(4,3)


C--- CALCULATE TRACKS FROM 2. ORDER TERMS USED FOR LINEAR TRANSFER MATRIX
C    AND COMPARE WITH ORIGINAL TRACKING RESULTS

      DO I=1,NORDNG
      DO J=1,NORDNG
      DO K=1,NORDNG
      DO L=1,NORDNG

      AKOEFFC(I,J,K,L)=0.D0
      IF (I-1+J-1+K-1+L-1 .EQ.2) AKOEFFC(I,J,K,L)=AKOEFF(I,J,K,L)
C     IF (I-1+J-1.EQ.1) AKOEFFC(I,J,K,L)=0.D0 !KILL COUPLING

      ENDDO
      ENDDO
      ENDDO
      ENDDO

      CALL ARESIMAP(      AKOEFFC,MAXTRAP,NORDNGP,
     &                   RSXMT, RSXAVT, RSXT,
     &                   RSYMT, RSYAVT, RSYT,
     &                   RSPXMT,RSPXAVT,RSPXT,
     &                   RSPYMT,RSPYAVT,RSPYT,RESTRA)


C--- CALCULATE EQUIVALENT HALBACH WIGGLER

      IF(IHALBA.NE.0.AND.I2DIM.EQ.0) THEN

C     CALCULATION OF K-VALUES OF MATRIX (REFER BETA MANUAL PAGE 13)
C     ANSATZ: LONG QUADRUPOLE, K-VALUES(FY,FX):

                FY= TRALIN(4,3)/TRALIN(3,4)   ! <0 ,LARGE, FOCUSSING
                FX= TRALIN(2,1)/TRALIN(1,2)   ! >0 ,SMALL, DEFOCUSSING

                IF (FY.GE.0.0.OR.FX+FY.GT.0.0) THEN
                WRITE(6,*)
     &'*** MESSAGE SR TRANMAP: NO EQUIVALENT HALBACH WIGGLER FOUND ***'
                WRITE(LUNGFO,*)
     &'*** MESSAGE SR TRANMAP: NO EQUIVALENT HALBACH WIGGLER FOUND ***'
            IHALBA=0
            GOTO 500
         ENDIF

         R2HAL =FX/FY                      ! R2HAL<0 !!
         SINZ2 =-TRALIN(4,3)*TRALIN(3,4)
         ZETAZ = DASIN(DSQRT(SINZ2))
         ZLENGE= ZETAZ/DSQRT(-FY)
         RHOHAL= 1.D0/DSQRT(-2.D0*(FX+FY))
         ZLHAL = ZLENGE/NPERTRA
         ZKHAL=2.D0*PI1/ZLHAL
       ZKHALR=ZKHAL
       ZKHALI=0.D0

         B0HAL=PEL/CLIGHT1/RHOHAL
       IF ((1.D0+R2HAL).GT.0.D0) THEN
               YKHAL=SQRT(ZKHAL*ZKHAL/ABS(1.D0+R2HAL))
               YKHALR=YKHAL
               YKHALI=0.D0
       ELSEIF ((1.D0+R2HAL).LT.0.D0) THEN
               YKHAL=SQRT(ZKHAL*ZKHAL/ABS(1.D0+R2HAL))
               YKHALI=YKHAL
               YKHALR=0.D0
       ELSE
               YKHAL=0.D0
               YKHALR=0.D0
               YKHALI=0.D0
       ENDIF

         IF(YKHAL.NE.0D0) THEN
         YLHAL=2.D0*PI1/YKHAL
       ELSE
         YLHAL=0.D0
       ENDIF
       IF (ZKHAL.GE.YKHAL) THEN
          XKHAL=SQRT((ZKHAL+YKHAL)*(ZKHAL-YKHAL))
        XKHALR=XKHAL
        XKHALI=0.D0
       ELSE
          XKHAL=SQRT((YKHAL+ZKHAL)*(YKHAL-ZKHAL))
        XKHALI=XKHAL
        XKHALR=0.D0
       ENDIF
         IF(XKHAL.NE.0.D0) THEN
         XLHAL=2.D0*PI1/XKHAL
       ELSE
         XLHAL=0.D0
       ENDIF

      ENDIF

C--- CALCULATE EQUIVALENT QUADRUPOLE FROM LINEAR TRANSFER MATRIX

500   CONTINUE

      IF (IQUAD.NE.0) THEN

      T11=0.5D0*(TRALIN(1,1)+TRALIN(2,2))
C     T11=DSQRT(TRALIN(1,1)*TRALIN(2,2))

      IF(T11.GT.1.D0)   THEN

         SIHPHIX=DSQRT((T11+1.D0)*(T11-1.D0))
         PHIX=DLOG(T11+SIHPHIX)

         IF(DABS(TRALIN(2,1)).GT.1.D-6) THEN

         QUADX=DSQRT(TRALIN(1,2)/TRALIN(2,1)*PHIX*PHIX)
           QUADFX=-QUADX/(PHIX*PHIX)
           QUADR(1,1)=T11
           QUADR(2,2)=QUADR(1,1)
           QUADR(1,2)=QUADX/PHIX*SIHPHIX
           QUADR(2,1)=PHIX/QUADX*SIHPHIX

         ELSE

         QUADX=0.
           QUADFX=0.
           QUADR(1,1)=T11
           QUADR(2,2)=QUADR(1,1)
           QUADR(1,2)=AKOEFF(1,3,1,1)*2.D0
           QUADR(2,1)=0.

         ENDIF

      ELSEIF (T11.GE.-1.D0) THEN

         SINPHIX=DSQRT(-(T11+1.D0)*(T11-1.D0))
         PHIX=DACOS(T11)

         IF(DABS(TRALIN(2,1)).GT.1.D-6) THEN

             QUADX=DSQRT(-TRALIN(1,2)/TRALIN(2,1)*PHIX*PHIX)
             QUADFX=QUADX/(PHIX*PHIX)
             QUADR(1,1)=T11
             QUADR(2,2)=QUADR(1,1)
             QUADR(1,2)=QUADX/PHIX*SINPHIX
             QUADR(2,1)=-PHIX/QUADX*SINPHIX

         ELSE

             QUADX=0.
             QUADFX=0.
             QUADR(1,1)=T11
             QUADR(2,2)=QUADR(1,1)
             QUADR(1,2)=AKOEFF(1,3,1,1)*2.D0
             QUADR(2,1)=0.

         ENDIF

      ENDIF !T11


      IF (I2DIM.EQ.0) THEN

         T33=0.5D0*(TRALIN(3,3)+TRALIN(4,4))
C        T33=DSQRT(TRALIN(3,3)*TRALIN(4,4))

      IF(T33.GT.1.D0) THEN

         SIHPHIY=DSQRT((T33+1.D0)*(T33-1.D0)) !SINUS-HYP.(PHI)
         PHIY=DLOG(T33+SIHPHIY)  !AREA-COSINUS-HYP.

         IF(DABS(TRALIN(4,3)).GT.1.D-6) THEN

            QUADY=DSQRT(TRALIN(3,4)/TRALIN(4,3)*PHIY*PHIY)
            QUADFY=-QUADY/(PHIY*PHIY)
            QUADR(3,3)=T33
            QUADR(4,4)=QUADR(3,3)
            QUADR(3,4)=QUADY/PHIY*SIHPHIY
            QUADR(4,3)=PHIY/QUADY*SIHPHIY

         ELSE

            QUADY=0.
            QUADFY=0.
            QUADR(3,3)=T33
            QUADR(4,4)=QUADR(3,3)
            QUADR(3,4)=AKOEFF(1,1,1,3)*2.D0
            QUADR(4,3)=0.

         ENDIF

      ELSEIF (T33.GT.-1.D0) THEN

         SINPHIY=DSQRT((T33+1.D0)*(1.D0-T33))
         PHIY=DACOS(T33)

         IF(DABS(TRALIN(4,3)).GT.1.D-6) THEN

             QUADY=DSQRT(-TRALIN(3,4)/TRALIN(4,3)*PHIY*PHIY)
             QUADFY=QUADY/(PHIY*PHIY)
             QUADR(3,3)=T33
             QUADR(4,4)=QUADR(3,3)
             QUADR(3,4)=QUADY/PHIY*SINPHIY
             QUADR(4,3)=-PHIY/QUADY*SINPHIY

         ELSE

             QUADY=0.
             QUADFY=0.
             QUADR(3,3)=T33
             QUADR(4,4)=QUADR(3,3)
             QUADR(3,4)=AKOEFF(1,1,1,3)*2.D0
             QUADR(4,3)=0.

         ENDIF

C        QUADY=DSQRT(-TRALIN(3,4)/TRALIN(4,3)*PHIY*PHIY)
C        QUADFY= QUADY/(PHIY*PHIY)
C        QUADR(3,3)=T33
C        QUADR(4,4)=QUADR(3,3)
C        QUADR(3,4)= QUADY/PHIY*SINPHIY
C        QUADR(4,3)=-PHIY/QUADY*SINPHIY

      ENDIF !T33

      ENDIF !I2DIM

      DO I=1,NORDNG
      DO J=1,NORDNG
      DO K=1,NORDNG
      DO L=1,NORDNG

      AKOEFFC(I,J,K,L)=0.D0

      ENDDO
      ENDDO
      ENDDO
      ENDDO

      IF(QUADR(2,2).NE.0) THEN

         AKOEFFC(2,2,1,1)=1.D0/QUADR(2,2)
         AKOEFFC(1,3,1,1)= QUADR(1,2)/(2.D0*QUADR(2,2))
         AKOEFFC(3,1,1,1)=-QUADR(2,1)/(2.D0*QUADR(2,2))

         IF (I2DIM.EQ.0) THEN

            AKOEFFC(1,1,2,2)=1.D0/QUADR(4,4)
            AKOEFFC(1,1,1,3)= QUADR(3,4)/(2.D0*QUADR(4,4))
            AKOEFFC(1,1,3,1)=-QUADR(4,3)/(2.D0*QUADR(4,4))

         ENDIF

         CALL ARESIMAP(AKOEFFC,MAXTRAP,NORDNGP,
     &                   RSXMTQ, RSXAVTQ, RSXTQ,
     &                   RSYMTQ, RSYAVTQ, RSYTQ,
     &                   RSPXMTQ,RSPXAVTQ,RSPXTQ,
     &                   RSPYMTQ,RSPYAVTQ,RSPYTQ,RESQUAD)

      ENDIF !QUADR(2,2)

      ENDIF !IQUAD


C7.6.93  CALL CLOSEOR(AKOEFF(1,2,1,1),AKOEFF(2,1,1,1),
C7.6.93     &               AKOEFF(2,2,1,1),
C7.6.93     &               AKOEFF(3,1,1,1),AKOEFF(1,3,1,1),
C7.6.93     &               XCLOSE,PCLOSE)


C--- OUTPUT

      WRITE (LUN1,*)
      WRITE (LUN1,*)
      WRITE (LUN1,*)
     &  '     Tracks to fit mapping read from file (FILEO):'
      WRITE (LUN1,*)'       ',FILEO
      WRITE (LUN1,*)'     User comment of FILEO:'
      WRITE (LUN1,*)'       ',CODE
      WRITE (LUN1,*)'     Run number of FILEO :  ',ICODE
      WRITE (LUN1,*)'     Run number of TRANPOLY:',ITRANC
      WRITE(LUN1,*)
      WRITE(LUN1,*)

      IF (DRAUSCHX.NE.0.0 .OR. DRAUSCHY.NE.0.0) THEN
      WRITE(LUN1,*)
     &'     Noise amplitude [m] overlaid on Z,ZP (DRAUSCHX):'
     &,SNGL(DRAUSCHX)
      WRITE(LUN1,*)
     &'     Noise amplitude [m] overlaid on Y,YP (DRAUSCHY):'
     &,SNGL(DRAUSCHY)
      WRITE(LUN1,*)
     &'     Noise amplitude on Z,ZP divided by mean length of (XF,PXI):'
     &,SNGL(DRAUSCHX/XFXCAVE)
      IF (I2DIM.EQ.0)
     &   WRITE(LUN1,*)
     &'     Noise amplitude on Y,YP divided by mean length of (YF, PYI):'
     &,SNGL(DRAUSCHY/XFYCAVE)
      ENDIF !DRAUSCH

      WRITE (LUN1,*)
      WRITE (LUN1,*)'     Start values of reference orbit (Lab.-System):'
      WRITE (LUN1,*)'     X0,Y0,Z0:   ',SNGL(X0),SNGL(Y0),SNGL(Z0)
      WRITE (LUN1,*)'     ZP0,YP0:    ',SNGL(ZP0),SNGL(YP0)
      WRITE (LUN1,*)'     BX0,BY0,BZ0:',SNGL(BX0),SNGL(BY0),SNGL(BZ0)
      WRITE (LUN1,*)'     AX0,AY0,AZ0:',SNGL(AX0),SNGL(AY0),SNGL(AZ0)
      WRITE (LUN1,*)
      WRITE (LUN1,*)'     Final values of reference orbit (Lab.-System):'
      WRITE (LUN1,*)'     XF0,YF0,ZF0:   ',SNGL(XF0),SNGL(YF0),SNGL(ZF0)
      WRITE (LUN1,*)'     ZPF0,YPF0:    ',SNGL(ZPF0),SNGL(YPF0)
      WRITE (LUN1,*)'     BXF0,BYF0,BZF0:',SNGL(BXF0),SNGL(BYF0),SNGL(BZF0)
      WRITE (LUN1,*)'     AXF0,AYF0,AZF0:',SNGL(AXF0),SNGL(AYF0),SNGL(AZF0)
      WRITE (LUN1,*)

      WRITE (LUN1,*)'     Normal vector of entrance plane:'
      WRITE (LUN1,*)'     ',SNGL(OPNX),SNGL(OPNY),SNGL(OPNZ)
      WRITE (LUN1,*)
      WRITE (LUN1,*)'     Normal vector of exit plane:    '
      WRITE (LUN1,*)'     ',SNGL(OPNFX),SNGL(OPNFY),SNGL(OPNFZ)
      WRITE (LUN1,*)

      WRITE (LUN1,*)
      WRITE (LUN1,*)'     Energy [GeV]:',SNGL(GAMMA*EMASSE1/1.D9)
      WRITE (LUN1,*)'     B*RHO [Tm]:  ',SNGL(BRHOABS)
      WRITE (LUN1,*)

      WRITE (LUN1,*)
      WRITE (LUN1,*)'     Flags:'
      WRITE (LUN1,3300)IA1000,IA0100,IA0010,IA0001
3300  FORMAT('      IA1000,IA0100,IA0010,IA0001:',4I3)
      WRITE (LUN1,3330)I2DIM,ISYM,IA11A20,IWLSHOR
3330  FORMAT('      I2DIM,ISYM,IA11A20,IWLSHOR: ',4I3)
      WRITE (LUN1,*)

      IF (I2DIM.NE.0) THEN
         WRITE (LUN1,*)
         WRITE (LUN1,*)
         WRITE (LUN1,*)
     & '     *** 2-DIMENSIONAL FIT (FLAG I2DIM.NE.0) ***'
         WRITE (LUN1,*)
         WRITE (LUN1,*)
      ENDIF

      WRITE (LUN1,*)
      WRITE (LUN1,*) '     Number of tracks:',MTRAJ
      WRITE (LUN1,*)

      IF (ISELECT.GT.0) THEN

      WRITE (LUN1,*)
      WRITE (LUN1,*)
     &'     Selection of initial parameters of tracks:'
      WRITE (LUN1,*)
     &'     ------------------------------------------'
      WRITE (LUN1,*)

      WRITE (LUN1,*)
      WRITE (LUN1,*)
     &'     Coordinates and slopes ZI(N), ZPI(N), YI(N), YPI(N):'
      WRITE (LUN1,*)

      DO I=1,MTRAJ,ISELECT
         WRITE (LUN1,1000)I,XI(1,I),XI(2,I),XI(3,I),XI(4,I)
      ENDDO

      WRITE (LUN1,*)
      WRITE (LUN1,*)
     &'     Magnetic field BXI(N), BYI(N), BZI(N)):'
      WRITE (LUN1,*)

      DO I=1,MTRAJ,ISELECT
      WRITE (LUN1,1000)I,BXI(I),BYI(I),BZI(I)
      ENDDO

      WRITE (LUN1,*)
      WRITE (LUN1,*)
      WRITE (LUN1,*)
     &'     Selection of final parameters of tracks:'
      WRITE (LUN1,*)
     &'     ----------------------------------------'
      WRITE (LUN1,*)

      WRITE (LUN1,*)
      WRITE (LUN1,*)
     &'     Coordiantes and slopes ZF(N), ZPF(N), YF(N), YPF(N):'
      WRITE (LUN1,*)
      WRITE (LUN1,*)
      DO I=1,MTRAJ,ISELECT
         WRITE (LUN1,1000)I,XF(1,I),XF(2,I),XF(3,I),XF(4,I)
      ENDDO

      WRITE (LUN1,*)
      WRITE (LUN1,*)
     &'     Magnetic field BXI(N), BYI(N), BZI(N)):'
      WRITE (LUN1,*)

      DO I=1,MTRAJ,ISELECT
      WRITE (LUN1,1000)I,BXF(I),BYF(I),BZF(I)
      ENDDO

      ENDIF !ISELECT

      WRITE (LUN1,*)
      WRITE (LUN1,*)
      WRITE (LUN1,*)
     &'     Mean length of mapping vectors (XI, PXI, YI, PYI):',
     &                 SNGL(XICAVE)
      WRITE (LUN1,*)
     &'     Mean length of mapping vectors (XF, PXF, YF, PYF):',
     &                 SNGL(XFCAVE)
      WRITE (LUN1,*)

      WRITE(LUN1,*)
     &'     Scaling factor for system of linear equations:',
     &                 SNGL(DSCALE)

      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Number of fitted coefficients:',NKOEF
      WRITE(LUN1,*)

      WRITE(LUN1,*)
     &'     Check of solution of linear equation system, i.e maximum, mean,'
      WRITE(LUN1,*)'     and rms of deviation:'
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESBM,RESBAV,RESB

      WRITE(LUN1,*)
      IF(IERZ.GT.0) THEN
         WRITE(LUN1,*)
     &'     Run numbers and user comment on file WAVE_TRANMAP.IN:'
         WRITE(LUN1,*)'     ',ICODEERZ,ITRANCE
         WRITE(LUN1,*)'          ',CODEERZ
         WRITE(LUN1,*)
     &'     Number of coefficients AERZ(I,J,K,L):',IERZ
      WRITE(LUN1,*)
      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Maximum, mean and rms of AKOEFF(I,J,K,L)-AERZ(I,J,K,L):'
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESAM,RESAAV,RESA
      ENDIF !IERZ

      IF(IREF.GT.0) THEN
      WRITE(LUN1,*)
      WRITE(LUN1,*)
         WRITE(LUN1,*)
     &'     Run numbers and user comment on file WAVE_TRANMAP.REF:'
         WRITE(LUN1,*)'     ', ICODEREF,ITRANCR
         WRITE(LUN1,*)'     ',CODEREF
         WRITE(LUN1,*)
     &'     Number of coefficients AREF(I,J,K,L):',IREF
      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Maximum, mean and rms of AKOEFF(I,J,K,L)-AREF(I,J,K,L):'
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESAMR,RESAAVR,RESAR
      ENDIF !IREF

      WRITE(LUN1,*)
      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Maximum, mean, and rms of deviation for XF, PXF, YF, PYF'
      WRITE(LUN1,*)'     recalculated using AKOEFF:'
      WRITE(LUN1,*)
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESXMK, RESXAVK, RESXK
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESPXMK,RESPXAVK,RESPXK
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESYMK, RESYAVK, RESYK
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESPYMK,RESPYAVK,RESPYK

      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     SQRT(CHI**2/N) corresponding to AKOEFF:         '
     &     ,SNGL(RESAKO)
      WRITE(LUN1,*)
     &'     Dito divided by mean length of (XI,PXI,YI,PYI):'
     &       ,SNGL(RESAKO/XFCAVE)

      IF (IERZ.GT.0) THEN
      WRITE(LUN1,*)
      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Maximum, mean, and rms of deviation for XF, PXF, YF, PYF'
      WRITE(LUN1,*)'     recalculated using AERZ:'
      WRITE(LUN1,*)
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESXME, RESXAVE, RESXE
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESPXME,RESPXAVE,RESPXE
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESYME, RESYAVE, RESYE
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESPYME,RESPYAVE,RESPYE
      WRITE(LUN1,*)

      WRITE(LUN1,*)
     &'     SQRT(CHI**2/N) corresponding to AERZ:           '
     &      ,SNGL(RESERZ)
      WRITE(LUN1,*)
     &'     Dito divided by mean length of (XI,PXI,YI,PYI):'
     &       ,SNGL(RESERZ/XFCAVE)
      ENDIF !IERZ

      IF (IREF.GT.0) THEN
      WRITE(LUN1,*)
      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Maximum, mean, and rms of deviation for XF, PXF, YF, PYF'
      WRITE(LUN1,*)'     recalculated using AREF:'
      WRITE(LUN1,*)
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESXMR, RESXAVR, RESXR
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESPXMR,RESPXAVR,RESPXR
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESYMR, RESYAVR, RESYR
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESPYMR,RESPYAVR,RESPYR
      WRITE(LUN1,*)

      WRITE(LUN1,*)
     &'     SQRT(CHI**2/N) corresponding to AREF:           '
     &     ,SNGL(RESREF)
      WRITE(LUN1,*)
     &'     Dito divided by mean length of (XI,PXI,YI,PYI):'
     &       ,SNGL(RESREF/XFCAVE)
      ENDIF !IREF

C--- WRITE COEFFICIENTS AKOEFF TO OUTPUT FILE WAVE_TRANMAP.AKO

      OPEN(UNIT=LUNAKO,FILE='WAVE_TRANMAP.AKO',STATUS='NEW',FORM='FORMATTED')

C10.6.93 WRITE (LUNAKO,'(I5,4H    ,1A66)')ICODE,CODE
      WRITE (LUNAKO,'(2I5,4H    ,1A66)')ICODE,ITRANC,CODE

      WRITE(LUNAKO,*)'COEFICIENTS REFERRE TO MAPPING NOT TO GF!'

      DO N=1,NKOEF
         I=IE(N)
         J=JE(N)
         K=KE(N)
         L=LE(N)

              WRITE(LUNAKO,*) I-1,J-1,K-1,L-1,AKOEFF(I,J,K,L)
      ENDDO
      CLOSE(LUNAKO)

      IF (IERZ.NE.0.OR.IREF.NE.0) THEN

      WRITE (LUN1,*)

      WRITE (LUN1,*)
     &'     Comparison of fitted coefficients AKOEFF with AERZ and AREF;'
      WRITE (LUN1,*)
     &'     AKOEFF, AERZ, 2*(AERZ-AKOEF)/(|AERZ|+|AKOEF|), and also for AREF'
      WRITE (LUN1,*)
     &'     (only printed if deviations larger than 1E-10)'
      WRITE (LUN1,*)

      DO N=2,NORDNG
          WRITE(LUN1,*)
          DO I=1,NORDNG
          DO J=1,NORDNG
          DO K=1,NORDNG
          DO L=1,NORDNG

      IF(I-1+J-1+K-1+L-1.EQ.N-1) THEN
C7.6.93  IF(I-1+J-1+K-1+L-1.EQ.N-1.AND.AKOEFF(I,J,K,L).NE.0.0) THEN

         AK=AKOEFF(I,J,K,L)
         AE=AERZ(I,J,K,L)
         AR=AREF(I,J,K,L)
         AKE=0.D0
         AKR=0.D0

         IF (DABS(AE)+DABS(AK).NE.0.0)
     &             AKE=2.*(AE-AK)/(DABS(AE)+DABS(AK))
         IF (DABS(AR)+DABS(AK).NE.0.0)
     &             AKR=2.*(AR-AK)/(DABS(AR)+DABS(AK))

        IF(DABS(AKE).GT.1.D-10.OR.DABS(AKR).GT.1.D-10) THEN

         WRITE(LUN1,8000) I-1,J-1,K-1,L-1,AK,AE,AKE,AR,AKR
8000    FORMAT('      ','a',4I1,1P,(2D15.7),1P,(D10.2),1P,(D15.7),1P,(D10.2))

      ENDIF
      ENDIF

          ENDDO
          ENDDO
          ENDDO
          ENDDO
      ENDDO

      ENDIF

      WRITE(LUN1,*)
      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Maximum, mean, and rms of deviation for XF, PXF, YF, PYF'
      WRITE(LUN1,*)
     &'     recalculated using only linear terms of AKOEFF, i.e. first'
      WRITE(LUN1,*)'     and second order:'
      WRITE(LUN1,*)
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RSXMTK, RSXAVTK, RSXTK
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RSPXMTK,RSPXAVTK,RSPXTK
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RSYMTK, RSYAVTK, RSYTK
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RSPYMTK,RSPYAVTK,RSPYTK
      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Corresponding SQRT(CHI**2/N):                   ',SNGL(RESLIN)
      WRITE(LUN1,*)
     &'     Dito divided by mean length of (XI,PXI,YI,PYI):',SNGL(RESLIN/XFCAVE)

      WRITE(LUN1,*)
      WRITE(LUN1,*)
      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Linear transfer matrix (without coupling):'
      WRITE(LUN1,*)
      DO I=1,4
         WRITE(LUN1,5000) (TRALIN(I,J),J=1,4)
      ENDDO
      WRITE(LUN1,*)
      WRITE(LUN1,*) '     Deviations of sub-determinants from unity:',
     &  SNGL(1.D0-DETTRA1),SNGL(1.D0-DETTRA2)
      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Horiz. and vert. focal lengths (-1/m21 and -1/m43) [1/m]:'
      WRITE(LUN1,*)'     ', SNGL(FOCEX),SNGL(FOCEY)
      WRITE(LUN1,*)

      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Maximum, mean, and rms of deviation for XF, PXF, YF, PYF recalculated'
      WRITE(LUN1,*)
     &'     using all 2. order terms of AKOEFF (including coupling):'
      WRITE(LUN1,*)
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RSXMT, RSXAVT, RSXT
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RSPXMT,RSPXAVT,RSPXT
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RSYMT, RSYAVT, RSYT
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RSPYMT,RSPYAVT,RSPYT
      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Corresponding SQRT(CHI**2/N):                   '
     &      ,SNGL(RESTRA)
      WRITE(LUN1,*)
     &'     Dito divided by mean length of (XI,PXI,YI,PYI):'
     &       ,SNGL(RESTRA/XFCAVE)

      WRITE(LUN1,*)
      WRITE(LUN1,*)
      WRITE(LUN1,*)

      IF (IQUAD.NE.0) THEN
      WRITE(LUN1,*) '     Quadrupole matrix:'
      WRITE(LUN1,*)
      DO I=1,4
         WRITE(LUN1,5000) (QUADR(I,J),J=1,4)
      ENDDO
      WRITE(LUN1,*)
      WRITE(LUN1,*) '     Deviations of sub-determinants from unity:',
     &  SNGL(1.D0-(QUADR(1,1)*QUADR(2,2)-QUADR(2,1)*QUADR(1,2))),
     &  SNGL(1.D0-(QUADR(3,3)*QUADR(4,4)-QUADR(3,4)*QUADR(4,3)))
      WRITE(LUN1,*)
      WRITE(LUN1,*)'     Hori. and vert. focal length (1/f=k*l) [m]:',
     &  SNGL(QUADFX),SNGL(QUADFY)
C     WRITE(6,*)'FOKAL-LAENGEN IN X UND Y (METER):',QUADFX,QUADFY

      WRITE(LUN1,*)

      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Maximum, mean, and rms of deviation for XF, PXF, YF, PYF'
      WRITE(LUN1,*)
     &'     recalculated using those 2. order terms of AKOEFF that'
      WRITE(LUN1,*)
     &'     have been used to determine the quadrupole matrix:'
      WRITE(LUN1,*)
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RSXMTQ, RSXAVTQ, RSXTQ
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RSPXMTQ,RSPXAVTQ,RSPXTQ
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RSYMTQ, RSYAVTQ, RSYTQ
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RSPYMTQ,RSPYAVTQ,RSPYTQ
      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Corresponding SQRT(CHI**2/N):                   ',SNGL(RESQUAD)
      WRITE(LUN1,*)
     &'     Dito divided by mean length of (XI,PXI,YI,PYI):'
     &       ,SNGL(RESQUAD/XFCAVE)
      ENDIF !IQUAD

        IF ((FY.GE.0.0.OR.FX+FY.GT.0.0) .AND. IHALBA.NE.0) THEN
         WRITE (LUN1,*)
         WRITE (LUN1,*)'*** WARNING SR TRANMAP ***'
         WRITE (LUN1,*)
     & 'EQUIVALENT HALBACH WIGGLER CAN NOT BE DETERMINED'
         WRITE (LUN1,*)
      ENDIF

      IF(IHALBA.NE.0) THEN
         WRITE(LUN1,*)
         WRITE(LUN1,*)
     &'     Parameters of equivalent Halbach wiggler, KX**2+KY**2=KZ**2 (complexe),'
         WRITE(LUN1,*)
     &'     coordinates according to Halbach, z-axis is long. axis:'
         WRITE(LUN1,*)'     RHO [m], ABS(B0) [T]:'
         WRITE(LUN1,*)'     ',SNGL(RHOHAL),SNGL(B0HAL)
         WRITE(LUN1,*)'     LX, LY, LZ, LZ/2 [m]:     '
         WRITE(LUN1,*)'     ',SNGL(XLHAL),SNGL(YLHAL),SNGL(ZLHAL),SNGL(ZLHAL/2.D0)
         WRITE(LUN1,*)'     KX, KY, KZ (complexe) [m]:'
         WRITE(LUN1,*)'     ',XKHALR,XKHALI
         WRITE(LUN1,*)'     ',YKHALR,YKHALI
         WRITE(LUN1,*)'     ',ZKHALR,YKHALI
         WRITE(LUN1,*)
         WRITE(LUN1,*)

         OPEN(UNIT=LUNH,FILE='WAVE_WLS.DAT',STATUS='NEW',FORM='FORMATTED')
         WRITE(LUNH,*)B0HAL,XLHAL,YLHAL,ZLHAL
         CLOSE(LUNH)

         OPEN(UNIT=LUNSTR,FILE='WAVE_WLS.STR',STATUS='NEW',FORM='FORMATTED')
         WRITE(LUNSTR,1234)ZLENGE,RHOHAL,ZLENGE
1234  FORMAT(' WLS  ID',E14.6,E14.6,'  0.000000E+00',E14.6)
         WRITE(LUNSTR,1235)(5.8D0-ZLENGE)/2.D0
1235  FORMAT(' DWLS SD',E14.6,'  0.000000E+00  0.000000E+00  0.000000E+00')
         CLOSE(LUNSTR)

      ENDIF

      IF(IWARNE.EQ.1) THEN
         WRITE(LUN1,*)
         WRITE(LUN1,*)
         WRITE(LUN1,*)'*** WARNING SR TRANMAP ***'
         WRITE(LUN1,*)
     &'COEFFICIENTS AERZ EXCEEDING ORDER OF MAPPING IGNORED'
         WRITE(LUN1,*)
         WRITE(LUN1,*)
         WRITE(LUN1,*)
         WRITE(6,*)
         WRITE(6,*)
         WRITE(6,*)'*** WARNING SR TRANMAP ***'
         WRITE(6,*)
     &'COEFFICIENTS AERZ EXCEEDING ORDER OF MAPPING IGNORED'
         WRITE(6,*)
         WRITE(6,*)
         WRITE(6,*)
      ENDIF

      IF(IWARNR.EQ.1) THEN
         WRITE(LUN1,*)
         WRITE(LUN1,*)
         WRITE(LUN1,*)'*** WARNING SR TRANMAP ***'
         WRITE(LUN1,*)
     &'COEFFICIENTS AREF EXCEEDING ORDER OF MAPPING IGNORED'
         WRITE(LUN1,*)
         WRITE(LUN1,*)
         WRITE(LUN1,*)
         WRITE(6,*)
         WRITE(6,*)
         WRITE(6,*)'*** WARNING SR TRANMAP ***'
         WRITE(6,*)
     &'COEFFICIENTS AREF EXCEEDING ORDER OF MAPPING IGNORED'
         WRITE(6,*)
         WRITE(6,*)
         WRITE(6,*)
      ENDIF


1000    FORMAT('      ',I4,' ',1P,(4D15.6))
2000    FORMAT(' ',I3,'   ',1P,(2D17.8))
C3000      FORMAT(' ',I3,5H     ,'a',4I1,1P,(1D17.5))
3000    FORMAT('      ','a',4I1,1P,(2D20.10),1P,(D10.2),1P,(D20.10),1P,(D10.2))
3001    FORMAT(' ','a',4I1,1P,(1D20.10),      1P,(D50.10),1P,(D10.2))
3002    FORMAT(' ','a',4I1,1P,(2D20.10),1P,(D10.2))
3003    FORMAT(' ','a',4I1,1P1D20.10)
4000      FORMAT(4I2,'  ',1P,(D27.20))
5000    FORMAT('     ',4F18.13)

C--- OUTPUT COEFFICIENTS SORTED BY ORDER OF MAPPING

      IF(IKOEFF.NE.0) THEN
          WRITE(LUN1,*)
          WRITE(LUN1,*)'     Coefficients of mapping (AKOEFF):'
          WRITE(LUN1,*)
      DO N=2,NORDNG
          WRITE(LUN1,*)
          WRITE(LUN1,*)'     Order of mapping:',N-1
          WRITE(LUN1,*)
          DO I=1,NORDNG
          DO J=1,NORDNG
          DO K=1,NORDNG
          DO L=1,NORDNG
         IF(I-1+J-1+K-1+L-1.EQ.N-1.AND.AKOEFF(I,J,K,L).NE.0.0)
     &      WRITE (LUN1,1236)I-1,J-1,K-1,L-1,AKOEFF(I,J,K,L)
1236     FORMAT('      a',4I1,1PE30.15)
          ENDDO
          ENDDO
          ENDDO
          ENDDO
      ENDDO
      ENDIF

      IF(LUN1.NE.LUNGFO) CLOSE(LUN1)

C---------------------------------------------------------------

      RETURN
      END
+DECK,TRANPOLY.
*CMZ :  4.00/15 27/04/2022  08.13.16  by  Michael Scheer
*CMZ :  4.00/13 29/11/2021  14.07.42  by  Michael Scheer
*CMZ :  4.00/04 27/08/2019  11.49.27  by  Michael Scheer
*CMZ :  3.04/00 23/01/2018  13.05.43  by  Michael Scheer
*CMZ :  3.03/04 19/12/2017  13.15.36  by  Michael Scheer
*CMZ :  3.02/03 03/11/2014  12.12.35  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  10.40.59  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  12.43.01  by  Michael Scheer
*CMZ :  2.65/01 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.61/01 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.54/07 16/06/2005  12.04.22  by  Michael Scheer
*CMZ :  2.52/14 10/02/2005  10.17.13  by  Michael Scheer
*CMZ :  2.52/09 14/10/2004  16.20.51  by  Michael Scheer
*CMZ :  2.48/04 12/03/2004  15.40.31  by  Michael Scheer
*CMZ :  2.42/03 13/09/2002  18.43.25  by  Michael Scheer
*CMZ :  2.41/13 22/08/2002  17.19.24  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.02  by  Michael Scheer
*CMZ :  2.41/07 30/07/2002  11.46.01  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.34/08 12/09/2001  10.21.17  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  17.36.52  by  Michael Scheer
*CMZ :  2.20/01 04/09/2001  16.01.39  by  Michael Scheer
*CMZ :  2.16/08 19/10/2000  15.08.24  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.33  by  Michael Scheer
*CMZ :  2.15/00 04/05/2000  15.22.24  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.24.35  by  Michael Scheer
*CMZ :  2.12/00 03/06/99  15.29.39  by  Michael Scheer
*CMZ :  1.03/06 02/10/98  15.34.39  by  Michael Scheer
*CMZ : 00.02/00 19/11/96  14.56.00  by  Michael Scheer
*CMZ : 00.01/12 24/09/96  14.03.14  by  Michael Scheer
*CMZ : 00.01/10 02/09/96  16.27.29  by  Michael Scheer
*CMZ : 00.01/08 29/05/95  18.19.37  by  Michael Scheer
*CMZ : 00.01/07 10/03/95  11.25.51  by  Michael Scheer
*CMZ : 00.01/04 09/12/94  12.35.12  by  Michael Scheer
*CMZ : 00.01/03 28/11/94  09.53.54  by  Michael Scheer
*CMZ : 00.01/02 23/11/94  18.00.19  by  Michael Scheer
*CMZ : 00.00/05 29/04/94  19.16.15  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.55.31  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.50  by  Michael Scheer
*-- Author : Michael Scheer
C************************************************************************
      SUBROUTINE TRANPOLY
C************************************************************************
+seq,gplhint.

C     Calculates Taylor expansion of the generating function by
c     fitting the coefficients from a set of particle trajectories

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,MYFILES.
+SEQ,CONTRL.
+SEQ,OPTIC.
+SEQ,TRANPO.
+SEQ,TRALIN.
+SEQ,B0SCGLOB.

      CHARACTER(55) CODEERZ,CODEREF

      INTEGER NKOEF,IE,JE,KE,LE
     &         ,LUN1,LUNAKO,LUNERZ,LUNREF,LUNTRA,LUNSTR
     &         ,IREAD,MAXTRAP,NORDNGP,MKOEFV,NTOT
     &         ,I,J,K,L,II,JJ,KK,LL,IP,JP,KP,LP,IIP,JJP,KKP,LLP
     &         ,N,IERZ,IREF,ITRANC,IFAIL1,M,NP,I1,J1,L1,K1
     &         ,I1P,J1P,K1P,L1P,IWARNE,IWARNR,ICODEERZ,ICODEREF,
     &           ITRANCE,ITRANCR,kcode

      INTEGER IDETFAIL,IDUM,KTRAJ,LTRAJ

+SEQ,GENFUN.
+SEQ,PHYCON.

      DIMENSION
     &  IE(MKOEF),JE(MKOEF),KE(MKOEF),LE(MKOEF)

      REAL*4 xran(1),rr(2)

      DOUBLE PRECISION
     &  BXI(MAXTRA),BYI(MAXTRA),BXF(MAXTRA),BYF(MAXTRA)
     & ,BZI(MAXTRA),BZF(MAXTRA),AZI(MAXTRA),AZF(MAXTRA)
     & ,AXI(MAXTRA),AYI(MAXTRA),AXF(MAXTRA),AYF(MAXTRA)
     & ,W2I(MAXTRA)

      DOUBLE PRECISION
     1     XI(4,MAXTRA),XF(4,MAXTRA),
     2     AKOEFF(NORDNG,NORDNG,NORDNG,NORDNG),
     2     AKOEFFC(NORDNG,NORDNG,NORDNG,NORDNG),
     *     AERZ(NORDNG,NORDNG,NORDNG,NORDNG),
     *     AREF(NORDNG,NORDNG,NORDNG,NORDNG),
     3     BVECT(MKOEF),BVECTC(MKOEF),BVECTCC(MKOEF),
     6     GMAT(MKOEF,MKOEF),GMATC(MKOEF,MKOEF),WORK(MKOEF),
     8     XE(MAXTRA,NORDNG+1),YE(MAXTRA,NORDNG+1),
     9     PE(MAXTRA,NORDNG+1),QE(MAXTRA,NORDNG+1),
     *     TRALIN(4,4),QUADR(4,4),DETCOP
     1    ,SI(MAXTRA),SF(MAXTRA)

      DOUBLE PRECISION
     &          GAMMA,BRHOABS,PEL,DUM,dgam
     &          ,X0,Y0,Z0,ZP0,YP0,BX0,BY0,BZ0,AX0,AY0,AZ0
     &          ,XFo,YFo,ZFo,ZPFo,YPFo,BXFo,BYFo,BZFo,AXFo,AYFo,AZFo
     &          ,XF0,YF0,ZF0,ZPF0,YPF0,BXF0,BYF0,BZF0,AXF0,AYF0,AZF0
     &         ,XICAVE,XFCAVE,XFXCAVE,XFYCAVE,XIXCAVE,XIYCAVE
     &         ,DIIP,DJJP,DKKP,DLLP,DI,DJ,DK,DL
     &          ,RESB2,RESBM,RESBAV,RESAM,RESA2,RESAAV,RESAMR,RESA2R
     &         ,RES,RESA,RESAR
     &          ,A1100,A2000,A0200,A0011,A0020,A0002,DETTRA1,DETTRA2
     &         ,ZLHAL,FY,FX,R2HAL,SINZ2,ZETAZ,ZLENGE,RHOHAL,B0HAL
     &         ,XLHAL,YLHAL,T11,T33,SIHPHIX,PHIX,QUADX,QUADFX,SINPHIX
     &         ,QUADY,QUADFY,SINPHIY,PHIY
     &         ,FOCEX,FOCEY,SIHPHIY
     &                  ,RESXMK, RESXAVK, RESXK,
     &                   RESYMK, RESYAVK, RESYK,
     &                   RESPXMK,RESPXAVK,RESPXK,
     &                   RESPYMK,RESPYAVK,RESPYK,RESAKO,
     &                   RESXME, RESXAVE, RESXE,
     &                   RESYME, RESYAVE, RESYE,
     &                   RESPXME,RESPXAVE,RESPXE,
     &                   RESPYME,RESPYAVE,RESPYE,RESERZ,
     &                   RESXMR, RESXAVR, RESXR,
     &                   RESYMR, RESYAVR, RESYR,
     &                   RESPXMR,RESPXAVR,RESPXR,
     &                   RESPYMR,RESPYAVR,RESPYR,RESREF,
     &                   RSXMTK, RSXAVTK, RSXTK,
     &                   RSYMTK, RSYAVTK, RSYTK,
     &                   RSPXMTK,RSPXAVTK,RSPXTK,
     &                   RSPYMTK,RSPYAVTK,RSPYTK,RESLIN,
     &                   RSXMT, RSXAVT, RSXT,
     &                   RSYMT, RSYAVT, RSYT,
     &                   RSPXMT,RSPXAVT,RSPXT,
     &                   RSPYMT,RSPYAVT,RSPYT,RESTRA,
     &                   RSXMTQ, RSXAVTQ, RSXTQ,
     &                   RSYMTQ, RSYAVTQ, RSYTQ,
     &                   RSPXMTQ,RSPXAVTQ,RSPXTQ,
     &                   RSPYMTQ,RSPYAVTQ,RSPYTQ,RESQUAD,
     &                   RESB,RESAAVR,RESR,AK,AE,AR,AKE,AKR

C     DOUBLE PRECISION XCLOSE,PCLOSE
C     DOUBLE PRECISION PXI0,PYI0,PXF0,PYF0

      DOUBLE PRECISION V0,V0X,V0Y,V0Z,VF0X,VF0Y,VF0Z,EWS(3),EWY(3),EWZ(3),EN
     &        ,ASR0,AYR0,AXR0,ASRF0,AYRF0,AXRF0
     &        ,VX1,VY1,VZ1,VX2,VY2,VZ2
     &        ,PXIR0,PYIR0,PXFR0,PYFR0,W0S,W0Y,W0X,WF0S,WF0Y,WF0X
     &        ,W0,WS1,WY1,WX1,WS2,WY2,WX2,ASR1,AYR1,AXR1
     &        ,ASR2,AYR2,AXR2,XPR1,YPR1,XPR2,YPR2
     &        ,X1,Y1,Z1,ZP1,YP1,X2,Y2,Z2,ZP2,YP2,AX1,AY1,AZ1,AX2,AY2,AZ2
     &        ,EWSF(3),EWYF(3),EWZF(3),SR1,YR1,XR1,SR2,YR2,XR2,sint

      DOUBLE PRECISION SINZ,COSZ

      DOUBLE PRECISION XKHAL,YKHAL,ZKHAL
     &  ,XKHALR,YKHALR,ZKHALR,XKHALI,YKHALI,ZKHALI

      double precision vx0,vxf0,vy0,vyf0,vz0,vzf0

+SEQ,TTRACKS.

+seq,pawcmn.

      DATA LUNAKO/15/
      DATA LUNERZ/13/
      DATA LUNREF/17/
      DATA LUNTRA/19/
      DATA LUNSTR/18/

      DATA IREAD/0/

      MAXTRAP=MAXTRA
      NORDNGP=NORDNG

C     PI=4.D0*DATAN(1.D0)

C--- READ AND WRITE CURRENT RUN NUMBER OF TRANPOLY

      OPEN(UNIT=LUNTRA,
     &      FILE='wave_trancode.dat',STATUS='OLD',
     &      FORM='FORMATTED',ERR=66)
          READ(LUNTRA,*,ERR=66)ITRANC
      CLOSE(LUNTRA)
66    ITRANC=ITRANC+1

      OPEN(UNIT=LUNTRA,FILE='wave_trancode.dat',
     &     STATUS='UNKNOWN',FORM='FORMATTED')
           WRITE(LUNTRA,*)ITRANC
C           IF (IGFLOAT.NE.0) ITRANC=-ITRANC
      CLOSE(LUNTRA)

      MKOEFV=MKOEF ! WEGEN UEBERGABE NACH SR DEQN

      LUN1=LUNGFO

      IF (LUN1.NE.LUNGFO)
     &OPEN(UNIT=LUN1,FILE='wave_tranpoly.out',STATUS='NEW',FORM='FORMATTED')

      WRITE (LUN1,*)
      WRITE (LUN1,*)
c      WRITE (LUN1,6789)
c6789  FORMAT(1H1)
      WRITE (LUN1,*) '     SR TRANPOLY'
      WRITE (LUN1,*) '     ==========='
      WRITE (LUN1,*)
      WRITE (LUN1,*)
+SELF,IF=NOCMPLX.
        WRITE(6,*)
     &' *** WARNING IN TRANMAP: CMZ-FLAG NOCMPLX NOT TAKEN INTO ACCOUNT.'
        WRITE(6,*)
     &' *** USING COMPLEX*16 VARIABLES FOR KX, KY, KZ OF EQUIVALENT HALBACH WIGGLER'
        WRITE(LUNGFO,*)
     &' *** WARNING IN TRANMAP: CMZ-FLAG NOCMPLX NOT TAKEN INTO ACCOUNT.'
        WRITE(LUNGFO,*)
     &' *** USING COMPLEX*16 VARIABLES FOR KX, KY, KZ OF EQUIVALENT HALBACH WIGGLER'
+SELF.


      NKOEF=0
      DO I=1,NORDNG
      DO J=1,NORDNG
      DO K=1,NORDNG
      DO L=1,NORDNG

C---    THE SUBSEQUENT INDICES I,J,K,L RUN FROM 1...5,
C       THE CORRESPONDING MATH. INDICES i,j,k,l from 0...4

          IF (I-1 + J-1 + K-1 + L-1 .LT. NORDNG
     &      .AND.
     &      I-1 + J-1 + K-1 + L-1 .GT. 0
     &          .AND.

C         !MID-PLANE SYMMETRY
     &          ((K-1+L-1)/2*2.EQ.(K-1+L-1).OR.ISYM.EQ.0)
     &          .AND.

C         !HORI. FOCAL LENGTH = 0
     &          (IA11A20.EQ.0 .OR.
     &          (I-1.NE.2.OR.J-1.NE.0.OR.K-1.NE.0.OR.L-1.NE.0))  !A2000=0
     &          .AND.

C         !NOTE ALSO OTHER CHANGES DUE TO A1100=1
     &          (IA11A20.EQ.0 .OR.
     &          (I-1.NE.1.OR.J-1.NE.1.OR.K-1.NE.0.OR.L-1.NE.0))   !A1100=1
     &          .AND.

     &      (IA1000.EQ.0.OR.
     &          I-1.NE.1.OR.J-1.NE.0.OR.K-1.NE.0.OR.L-1.NE.0)  !A1000=0
     &          .AND.

     &      (IA0100.EQ.0.OR.
     &           I-1.NE.0.OR.J-1.NE.1.OR.K-1.NE.0.OR.L-1.NE.0) !A0100=0
     &          .AND.

     &      (IA0010.EQ.0.OR.
     &           I-1.NE.0.OR.J-1.NE.0.OR.K-1.NE.1.OR.L-1.NE.0) !A0010=0
     &          .AND.

     &      (IA0001.EQ.0.OR.
     &           I-1.NE.0.OR.J-1.NE.0.OR.K-1.NE.0.OR.L-1.NE.1) !A0001=0
     &          .AND.

C         !WLS IS HORZ. DRIFT
     &      (I-1+J-1.LT.3.OR.IWLSHOR.EQ.0)
     &          .AND.

     &      (K-1+L-1.EQ.0.OR.I2DIM.EQ.0)   !I2DIM CASE

     &        ) THEN

         NKOEF=NKOEF+1

       IF (NKOEF.GT.MKOEF) STOP
     &       '*** SR TRANPOLY: NKOEF.GT.MKOEF ***'

         IE(NKOEF)=I
         JE(NKOEF)=J
         KE(NKOEF)=K
         LE(NKOEF)=L

          ENDIF

      ENDDO
      ENDDO
      ENDDO
      ENDDO

C      OPEN(UNIT=LUNGFI,FILE=FILEI,STATUS='OLD',FORM='FORMATTED')

C--- LIES FILE MIT TRAJEKTORIEN

      OPEN(UNIT=LUNO,FILE=FILEO,STATUS='OLD') !,FORM='UNFORMATTED')

      read(luno,*)CODE
      read(luno,*)kCODE
      read(luno,*)GAMMA,dgam
      read(luno,*)NTOT

      V0=CLIGHT1*DSQRT((1.0D0-1.0D0/GAMMA)*(1.0D0+1.0D0/GAMMA))

C     WRITE(6,*)
C     WRITE(6,*) 'ANZAHL DER TRAJEKTORIEN AUF DATEN-FILE:',NTOT
C     WRITE(6,*)

      MTRAJ=NTOT

      IF (NTRAJ.EQ.-9999.OR.NTRAJ.EQ.0) THEN
        NTRAJ=NTOT
      ELSE IF (NTRAJ.EQ.-1) THEN
        NTRAJ=NKOEF
      ENDIF

      KTRAJ=NTOT/NTRAJ

      IF (MTRAJ.GT.NTOT)STOP '*** SR TRANPOLY: MTRAJ.GT.NTOT ***'

      IF (MTRAJ.GT.MAXTRA) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN TRANPOLY ***'
          WRITE(LUNGFO,*)'TOO MANY TRACKS ON FILE FILEO'
          WRITE(LUNGFO,*)'INCREASE PARAMETER MAXTRA IN FILE GENFUN.CMN'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN TRANPOLY ***'
          WRITE(6,*)'TOO MANY TRACKS ON FILE FILEO'
          WRITE(6,*)'INCREASE PARAMETER MAXTRA IN FILE GENFUN.CMN'
          WRITE(6,*)
          STOP
      ENDIF

      read(luno,*)X0,Y0,Z0,ZP0,YP0,BX0,BY0,BZ0,AX0,AY0,AZ0
c18.1.2019      read(luno,*)XF0,YF0,ZF0,ZPF0,YPF0,BXF0,BYF0,BZF0,AXF0,AYF0,AZF0
c18.1.2018{
      read(luno,*)XFo,YFo,ZFo,ZPFo,YPFo,BXFo,BYFo,BZFo,AXFo,AYFo,AZFo
      read(luno,*)xf0,yf0,zf0,zpf0,ypf0,axf0,ayf0,azf0
      vxf0=v0/sqrt(1.0d0+zpf0*zpf0+ypf0*ypf0)
      vyf0=ypf0*vxf0
      vzf0=zpf0*vxf0
c18.1.2018}
      read(luno,*)OPNX,OPNY,OPNZ
      read(luno,*)OPNFX,OPNFY,OPNFZ
      read(luno,*)ZAPERT,YAPERT,DLAPER,sint

      DO J=1,NTOT
            read(luno,*) SI(J),XI(1,J),XI(2,J),XI(3,J),XI(4,J),
     &        BXI(J),BYI(J),BZI(J),AXI(J),AYI(J),AZI(J),
c            read(luno,*)
     &        SF(J),XF(1,J),XF(2,J),XF(3,J),XF(4,J),
     &        BXF(J),BYF(J),BZF(J),AXF(J),AYF(J),AZF(J),
     &        W2I(J)
      ENDDO

      CLOSE(LUNO)

C--- SUPERIMPOSE NOISE TO SIMULATE TRACKING UNCERTAINTIES

      IF (DRAUSCHX.NE.0..OR.DRAUSCHY.NE.0.) THEN

         DO I=1,NTOT
             call util_random_gauss(1,xran,rr)
             XF(1,I)=XF(1,I)+xran(1)*DRAUSCHX
             call util_random_gauss(1,xran,rr)
             XF(2,I)=XF(2,I)+xran(1)*DRAUSCHX
             call util_random_gauss(1,xran,rr)
             XF(3,I)=XF(3,I)+xran(1)*DRAUSCHY
             call util_random_gauss(1,xran,rr)
             XF(4,I)=XF(4,I)+xran(1)*DRAUSCHY
         ENDDO

      ENDIF

      IF (I2DIM.NE.0) THEN

         DO I=1,NTOT
             IF(    XI(3,I).NE.0.
     &            .OR. XI(4,I).NE.0.
     &            .OR. XF(3,I).NE.0.
     &            .OR. XF(4,I).NE.0. ) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
     &              '*** ERROR IN TRANPOLY ***'
            WRITE(LUNGFO,*)
     &              'FLAG I2DIM IS SET BUT TRACKS ARE NOT PLANAR'
            WRITE(LUNGFO,*)
     &              'SOMETHING IS WRONG WITH THE INPUT FILE FILEO'
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)
     &              '*** ERROR IN TRANPOLY ***'
            WRITE(6,*)
     &              'FLAG I2DIM IS SET BUT TRACKS ARE NOT PLANAR'
            WRITE(6,*)
     &              'SOMETHING IS WRONG WITH THE INPUT FILE FILEO'
            WRITE(6,*)
                        STOP
                  ENDIF
         ENDDO

      ENDIF ! I2DIM

C--------------------------------------------------------------

      W0=V0
      PEL=EMASSE1*DSQRT( (GAMMA+1.D0)*(GAMMA-1.D0) )
      BRHOABS=PEL/CLIGHT1  !ABSOLUTE VALUE

C--- REFERENCE SYSTEM AT ENTRANCE

C     IF THE ENTRANCE PLANE OF THE DEVICE IS PERPENDICULAR TO THE REFERENCE
C       ORBIT, THEN THE REFERENCE ORBIT HAS ZERO SLOPE
C     AND DISPLACEMENT IN THIS SYSTEM AND ALL VARIABLES ARE RELATIVE TO THE
C     REFERENCE ORBIT. IF IN THE OTHER CASE THE ENTRANCE PLANE IS PERPEN-
C     DICULAR TO THE LONGITUDINAL AXIS OF THE DEVICE, THE REFERENCE SYSTEM
C     IS IDENTICAL TO THE LAB.-SYSTEM. BOTH CASES ARE DESCRIBED BY THE SAME
C     FORMULAS IF WE SUBTRACT THE REFERENCE ORBIT FROM ALL VARIABLES.
C     THE CLOSED ORBIT IS THEN TAKEN OUT AND ALL CLOSED ORBIT TERMES SHOULD
C     VANISH. THE SAME IS VALID FOR THE EXIT PLANE.


C     EWS HAS DIFFERENT MEANING THAN IN SR OPTIC

      EWS(1)=OPNX
      EWS(2)=OPNY
      EWS(3)=OPNZ

      EN=1.D0/DSQRT(EWS(3)*EWS(3)+EWS(1)*EWS(1))

C        UNIT-VECTOR EWZ~[EWS,(0,1,0)] (CROSS-PRODUCT)
      EWZ(1)=-EWS(3)*EN
      EWZ(2)= 0.
      EWZ(3)= EWS(1)*EN

C     UNIT-VECTOR EWY=[EWZ,EWS]

      EWY(1)= EWZ(2)*EWS(3) - EWZ(3)*EWS(2)
      EWY(2)= EWZ(3)*EWS(1) - EWZ(1)*EWS(3)
      EWY(3)= EWZ(1)*EWS(2) - EWZ(2)*EWS(1)

      EWSF(1)=OPNFX
      EWSF(2)=OPNFY
      EWSF(3)=OPNFZ

      EN=1.D0/DSQRT(EWSF(3)*EWSF(3)+EWSF(1)*EWSF(1))
      EWZF(1)=-EWSF(3)*EN
      EWZF(2)= 0.
      EWZF(3)= EWSF(1)*EN

      EWYF(1)= EWZF(2)*EWSF(3) - EWZF(3)*EWSF(2)
      EWYF(2)= EWZF(3)*EWSF(1) - EWZF(1)*EWSF(3)
      EWYF(3)= EWZF(1)*EWSF(2) - EWZF(2)*EWSF(1)

C--- NORMALIZED VELOCITIES OF THE REFERENCE ORBIT

      V0X=1.D0/DSQRT(1.D0+ZP0*ZP0+YP0*YP0)
      V0Y=YP0*V0X
      V0Z=ZP0*V0X

      VF0X=1.D0/DSQRT(1.D0+ZPF0*ZPF0+YPF0*YPF0)
      VF0Y=YPF0*VF0X
      VF0Z=ZPF0*VF0X

C--- TRANSFORM VELOCITIES OF REFERENCE ORBIT INTO REFERENCE SYSTEM

C     4.9.2001: (W0X,W0Y,W0S)=(V0X,V0Y,V0Z) OR
C     (W0X,W0Y,W0S)=(0,0,1)
C     CODE NOT CHANGED, ONLY INTERPRETION HAS CHANGED

C     FOR THE TIME BEING (7.1.1992) (W0S,W0Y,W0X)=(V0X,V0Y,V0Z) OR
C     (W0S,W0Y,W0X)=(1,0,0)

      W0S=V0X*EWS(1)+V0Y*EWS(2)+V0Z*EWS(3)
      W0Y=V0X*EWY(1)+V0Y*EWY(2)+V0Z*EWY(3)
      W0X=V0X*EWZ(1)+V0Y*EWZ(2)+V0Z*EWZ(3)

      WF0S=VF0X*EWSF(1)+VF0Y*EWSF(2)+VF0Z*EWSF(3)
      WF0Y=VF0X*EWYF(1)+VF0Y*EWYF(2)+VF0Z*EWYF(3)
      WF0X=VF0X*EWZF(1)+VF0Y*EWZF(2)+VF0Z*EWZF(3)

C--- TRANSFORM VECTOR POTENTIAL OF REFERENCE ORBIT INTO REFERENCE SYSTEM

      ASR0=AX0*EWS(1)+AY0*EWS(2)+AZ0*EWS(3)
      AYR0=AX0*EWY(1)+AY0*EWY(2)+AZ0*EWY(3)
      AXR0=AX0*EWZ(1)+AY0*EWZ(2)+AZ0*EWZ(3)

      ASRF0=AXF0*EWSF(1)+AYF0*EWSF(2)+AZF0*EWSF(3)
      AYRF0=AXF0*EWYF(1)+AYF0*EWYF(2)+AZF0*EWYF(3)
      AXRF0=AXF0*EWZF(1)+AYF0*EWZF(2)+AZF0*EWZF(3)

C--- CANONICAL VARIABLES OF REFERENCE ORBIT

C     PXI0=-AZ0/BRHOABS   !COORDINATE CHANGE
C     PYI0=-AY0/BRHOABS

C     PXF0=-AZF0/BRHOABS
C     PYF0=-AYF0/BRHOABS

      IF (ICHARGE.GT.0) THEN
            PXIR0=+AXR0/BRHOABS+W0X !  THIS IS A VECTOR COMPONENT !
            PYIR0=+AYR0/BRHOABS+W0Y
            PXFR0=+AXRF0/BRHOABS+WF0X
            PYFR0=+AYRF0/BRHOABS+WF0Y
      ELSE
            PXIR0=-AXR0/BRHOABS+W0X !  THIS IS A VECTOR COMPONENT !
            PYIR0=-AYR0/BRHOABS+W0Y
            PXFR0=-AXRF0/BRHOABS+WF0X
            PYFR0=-AYRF0/BRHOABS+WF0Y
      ENDIF

C--- LOOP OVER TRAJECTORIES -------------------------------------------

      DO I=1,MTRAJ

C--- EVERYTHING IN THE LAB.SYSTEM

         X1= SI(I)
         Z1= XI(1,I)
         ZP1=XI(2,I)
         Y1= XI(3,I)
         YP1=XI(4,I)

         VX1=1.D0/DSQRT(1.D0+ZP1**2+YP1**2)
         VY1=YP1*VX1
         VZ1=ZP1*VX1

         AX1=AXI(I)
         AY1=AYI(I)
         AZ1=AZI(I)

         X2= SF(I)
         Z2= XF(1,I)
         ZP2=XF(2,I)
         Y2= XF(3,I)
         YP2=XF(4,I)

         VX2=1.D0/DSQRT(1.D0+ZP2**2+YP2**2)
         VY2=YP2*VX2
         VZ2=ZP2*VX2

         AX2=AXF(I)
         AY2=AYF(I)
         AZ2=AZF(I)

C--- TRANSFORM VELOCITIES INTO REFERENCE SYSTEM

         WS1=VX1*EWS(1)+VY1*EWS(2)+VZ1*EWS(3)
         WY1=VX1*EWY(1)+VY1*EWY(2)+VZ1*EWY(3)
         WX1=VX1*EWZ(1)+VY1*EWZ(2)+VZ1*EWZ(3)

         WS2=VX2*EWSF(1)+VY2*EWSF(2)+VZ2*EWSF(3)
         WY2=VX2*EWYF(1)+VY2*EWYF(2)+VZ2*EWYF(3)
         WX2=VX2*EWZF(1)+VY2*EWZF(2)+VZ2*EWZF(3)

C--- TRANSFORM VECTOR POTENTIALS INTO REFERENCE SYSTEM

         ASR1=AX1*EWS(1)+AY1*EWS(2)+AZ1*EWS(3)
         AYR1=AX1*EWY(1)+AY1*EWY(2)+AZ1*EWY(3)
         AXR1=AX1*EWZ(1)+AY1*EWZ(2)+AZ1*EWZ(3)

         ASR2=AX2*EWSF(1)+AY2*EWSF(2)+AZ2*EWSF(3)
         AYR2=AX2*EWYF(1)+AY2*EWYF(2)+AZ2*EWYF(3)
         AXR2=AX2*EWZF(1)+AY2*EWZF(2)+AZ2*EWZF(3)


C--- SLOPES IN THE REFERENCE SYSTEM

         XPR1=WX1/WS1
         YPR1=WY1/WS1

         XPR2=WX2/WS2
         YPR2=WY2/WS2

C--- TRANSFORM COORDINATES INTO REFERENCE SYSTEM

         SR1=(X1-X0)*EWS(1)+(Y1-Y0)*EWS(2)+(Z1-Z0)*EWS(3)
         YR1=(X1-X0)*EWY(1)+(Y1-Y0)*EWY(2)+(Z1-Z0)*EWY(3)
         XR1=(X1-X0)*EWZ(1)+(Y1-Y0)*EWZ(2)+(Z1-Z0)*EWZ(3)

         SR2=(X2-XF0)*EWSF(1)+(Y2-YF0)*EWSF(2)+(Z2-ZF0)*EWSF(3)
         YR2=(X2-XF0)*EWYF(1)+(Y2-YF0)*EWYF(2)+(Z2-ZF0)*EWYF(3)
         XR2=(X2-XF0)*EWZF(1)+(Y2-YF0)*EWZF(2)+(Z2-ZF0)*EWZF(3)

C--- CANONICAL VARIABLES  (REFERENCE ORBIT IS SUBTRACTED)

         XIC(I)=XR1
         YIC(I)=YR1
         XFC(I)=XR2
         YFC(I)=YR2

      IF (ICHARGE.GT.0) THEN
         PXI(I)=+AXR1/BRHOABS+WX1-PXIR0
         PYI(I)=+AYR1/BRHOABS+WY1-PYIR0
         PXF(I)=+AXR2/BRHOABS+WX2-PXFR0
         PYF(I)=+AYR2/BRHOABS+WY2-PYFR0
      ELSE
         PXI(I)=-AXR1/BRHOABS+WX1-PXIR0
         PYI(I)=-AYR1/BRHOABS+WY1-PYIR0
         PXF(I)=-AXR2/BRHOABS+WX2-PXFR0
         PYF(I)=-AYR2/BRHOABS+WY2-PYFR0
      ENDIF

      ENDDO

C--------------------------------------------------------------
C240991 MEAN LENGTH OF VECTORS

      XICAVE=0.D0
      XFCAVE=0.D0
      XIXCAVE=0.D0
      XIYCAVE=0.D0
      XFXCAVE=0.D0
      XFYCAVE=0.D0
      DO I=1,MTRAJ
         XICAVE=XICAVE+DSQRT(XIC(I)**2+YIC(I)**2+PXF(I)**2+PYF(I)**2)
         XFCAVE=XFCAVE+DSQRT(XFC(I)**2+YFC(I)**2+PXI(I)**2+PYI(I)**2)
         XIXCAVE=XIXCAVE+DSQRT(XIC(I)**2+PXF(I)**2)
         XIYCAVE=XIYCAVE+DSQRT(YIC(I)**2+PYF(I)**2)
         XFXCAVE=XFXCAVE+DSQRT(XFC(I)**2+PXI(I)**2)
         XFYCAVE=XFYCAVE+DSQRT(YFC(I)**2+PYI(I)**2)
      ENDDO
      XICAVE=XICAVE/MTRAJ
      XFCAVE=XFCAVE/MTRAJ
      XIXCAVE=XIXCAVE/MTRAJ
      XIYCAVE=XIYCAVE/MTRAJ
      XFXCAVE=XFXCAVE/MTRAJ
      XFYCAVE=XFYCAVE/MTRAJ

C--------------------------------------------------------------
C230891
      IF(IA11A20.NE.0) THEN
         DO M=1,MTRAJ         ! i.e. A(1,1,0,0) = 1
             XFC(M)=XFC(M)-XIC(M)   !      A(2,0,0,0) = 0
             PXI(M)=PXI(M)-PXF(M)
         ENDDO
      ENDIF
C--------------------------------------------------------------
C     CHANGE SCALE

          X0=X0*DSCALE
          Y0=Y0*DSCALE
          Z0=Z0*DSCALE
          XF0=XF0*DSCALE
          YF0=YF0*DSCALE
          ZF0=ZF0*DSCALE

      DO M=1,MTRAJ
          XIC(M)=XIC(M)*DSCALE
          XFC(M)=XFC(M)*DSCALE
          PXI(M)=PXI(M)*DSCALE
          PXF(M)=PXF(M)*DSCALE
          YIC(M)=YIC(M)*DSCALE
          YFC(M)=YFC(M)*DSCALE
          PYI(M)=PYI(M)*DSCALE
          PYF(M)=PYF(M)*DSCALE
      ENDDO

C--------------------------------------------------------------
C     SET UP SYSTEM OF EQUATIONS

C--- INDEX POINTER IE(K1,K2,K3,K4), JE(K1,....

C---
      IF (MTRAJ.LT.NKOEF) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'*** ERROR IN TRANPOLY ***'
         WRITE(LUNGFO,*)'NOT ENOUGH TRACKS TO FIT COEFFICIENTS'
         WRITE(LUNGFO,*)'NUMBER OF TRACKS:      ',MTRAJ
         WRITE(LUNGFO,*)'NUMBER OF COEFFICIENTS:',NKOEF
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)'*** ERROR IN TRANPOLY ***'
         WRITE(6,*)'NOT ENOUGH TRACKS TO FIT COEFFICIENTS'
         WRITE(6,*)'NUMBER OF TRACKS:      ',MTRAJ
         WRITE(6,*)'NUMBER OF COEFFICIENTS:',NKOEF
         WRITE(6,*)
         STOP
      ENDIF

C--- POWER TERMS FOR MATRIX

      LTRAJ=0
      DO M=1,NTOT,KTRAJ

        LTRAJ=LTRAJ+1

        IF (M.GT.NTRAJ) GOTO 1122

         XE(M,1)=0.D0         ! x**(i-1) in math. formulas
         YE(M,1)=0.D0
         PE(M,1)=0.D0
         QE(M,1)=0.D0

         XE(M,2)=1.D0         ! x**0 in math. formulas
         YE(M,2)=1.D0
         PE(M,2)=1.D0
         QE(M,2)=1.D0

         DO I=3,NORDNG

            XE(M,I)=XE(M,I-1)*XIC(M)  ! x**i in math. formulas
            YE(M,I)=YE(M,I-1)*YIC(M)
            PE(M,I)=PE(M,I-1)*PXF(M)
            QE(M,I)=QE(M,I-1)*PYF(M)

         ENDDO

         XE(M,NORDNG+1)=0.D0  ! just formal to make GMAT loop run
         YE(M,NORDNG+1)=0.D0
         PE(M,NORDNG+1)=0.D0
         QE(M,NORDNG+1)=0.D0

1122     CONTINUE

      ENDDO

C--- MATRIX GMAT

      DO NP=1,NKOEF
      DO N=1,NKOEF

        I=IE(N)
        J=JE(N)
        K=KE(N)
        L=LE(N)

        IP=IE(NP)
        JP=JE(NP)
        KP=KE(NP)
        LP=LE(NP)

        DIIP=DFLOAT((I-1)*(IP-1))   ! 0*0 <= DIIP <= 4*4
        DJJP=DFLOAT((J-1)*(JP-1))
        DKKP=DFLOAT((K-1)*(KP-1))
        DLLP=DFLOAT((L-1)*(LP-1))

        II=I+1
        JJ=J+1
        KK=K+1
        LL=L+1

        I1=II-1
        J1=JJ-1
        K1=KK-1
        L1=LL-1

        IIP=IP+1
        JJP=JP+1
        KKP=KP+1
        LLP=LP+1

        I1P=IIP-1
        J1P=JJP-1
        K1P=KKP-1
        L1P=LLP-1

        DO M=1,MTRAJ

          GMAT(NP,N)=GMAT(NP,N)

     &       + DIIP * XE(M,I1)  * PE(M,JJ)  * YE(M,KK)  * QE(M,LL)
     &      * XE(M,I1P) * PE(M,JJP) * YE(M,KKP) * QE(M,LLP)
     &       + DJJP * XE(M,II)  * PE(M,J1)  * YE(M,KK)  * QE(M,LL)
     &         * XE(M,IIP) * PE(M,J1P) * YE(M,KKP) * QE(M,LLP)
     &       + DKKP * XE(M,II)  * PE(M,JJ)  * YE(M,K1)  * QE(M,LL)
     &         * XE(M,IIP) * PE(M,JJP) * YE(M,K1P) * QE(M,LLP)
     &       + DLLP * XE(M,II)  * PE(M,JJ)  * YE(M,KK)  * QE(M,L1)
     &         * XE(M,IIP) * PE(M,JJP) * YE(M,KKP) * QE(M,L1P)

        ENDDO

      ENDDO
      ENDDO

C--- INHOMOGENEITY BVECT OF EQUATION SYSTEM

      DO N=1,NKOEF

        I=IE(N)
        J=JE(N)
        K=KE(N)
        L=LE(N)

        DI=DFLOAT(I-1)
        DJ=DFLOAT(J-1)
        DK=DFLOAT(K-1)
        DL=DFLOAT(L-1)

        II=I+1
        JJ=J+1
        KK=K+1
        LL=L+1

        I1=II-1
        J1=JJ-1
        K1=KK-1
        L1=LL-1

        DO M=1,MTRAJ

          BVECT(N)=BVECT(N)
     &   + DI * PXI(M)  * XE(M,I1) * PE(M,JJ) * YE(M,KK) * QE(M,LL)
     &   + DJ * XFC(M)  * XE(M,II) * PE(M,J1) * YE(M,KK) * QE(M,LL)
     &   + DK * PYI(M)  * XE(M,II) * PE(M,JJ) * YE(M,K1) * QE(M,LL)
     &   + DL * YFC(M)  * XE(M,II) * PE(M,JJ) * YE(M,KK) * QE(M,L1)

        ENDDO

      ENDDO

C--- SAVE SYSTEM OF EQUATIONS

      DO I=1,MKOEFV
      DO J=1,MKOEFV
         GMATC(I,J)=GMAT(I,J)
      ENDDO
         BVECTC(I)=BVECT(I)
      ENDDO

C---  SOLVE SYSTEM OF EQUATION USING CERN ROUTINE F010

      CALL DEQN(NKOEF,GMAT,MKOEFV,WORK,IFAIL1,1,BVECT)
      IF (IFAIL1.NE.0) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'*** ERROR IN TRANPOLY ***'
         WRITE(LUNGFO,*)
     & 'CERN ROUTINE F010 TO SOLVE SYSTEM OF EQUATIONS FAILED'
         WRITE(LUNGFO,*)
     & 'PERHAPS TOO MANY COEFFICIENTS TO FIT ??'
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)'*** ERROR IN TRANPOLY ***'
         WRITE(6,*)
     & 'CERN ROUTINE F010 TO SOLVE SYSTEM OF EQUATIONS FAILED'
         WRITE(6,*)
     & 'PERHAPS TOO MANY COEFFICIENTS TO FIT ??'
         WRITE(6,*)
         STOP
      ENDIF

C--- GET RESULTS

      DO N=1,NKOEF

      I=IE(N)
      J=JE(N)
      K=KE(N)
      L=LE(N)

      AKOEFF(I,J,K,L)=BVECT(N)

      ENDDO

C--- CHECK SOLUTION OF THE EQUATION SYSTEM

      RESB2=0.D0
      RESBM=0.D0
      RESBAV=0.D0

      DO I=1,NKOEF
         BVECTCC(I)=0.D0
         DO J=1,NKOEF
         BVECTCC(I)=BVECTCC(I) +
     &            GMATC(I,J) * BVECT(J)
         ENDDO
         RES=BVECTCC(I)-BVECTC(I)
         IF(DABS(RES).GT.DABS(RESBM)) RESBM = RES
         RESBAV=RESBAV+RES
         RESB2 = RESB2 + RES*RES
      ENDDO
      RESB=DSQRT(RESB2/NKOEF)
      RESBAV=RESBAV/NKOEF

C--------------------------------------------------------------
C     RESCALING

      DO I=0,NORDNG-1
      DO J=0,NORDNG-1
      DO K=0,NORDNG-1
      DO L=0,NORDNG-1
      IF (I+J+K+L.LE.NORDNG-1)
     &   AKOEFF(I+1,J+1,K+1,L+1)=
     &   AKOEFF(I+1,J+1,K+1,L+1)*DSCALE**(I+K-1+J+L-1)
      ENDDO
      ENDDO
      ENDDO
      ENDDO

          X0=X0/DSCALE
          Y0=Y0/DSCALE
          Z0=Z0/DSCALE
          XF0=XF0/DSCALE
          YF0=YF0/DSCALE
          ZF0=ZF0/DSCALE

      DO M=1,MTRAJ
          XIC(M)=XIC(M)/DSCALE
          XFC(M)=XFC(M)/DSCALE
          PXI(M)=PXI(M)/DSCALE
          PXF(M)=PXF(M)/DSCALE
          YIC(M)=YIC(M)/DSCALE
          YFC(M)=YFC(M)/DSCALE
          PYI(M)=PYI(M)/DSCALE
          PYF(M)=PYF(M)/DSCALE
      ENDDO

C230891
      IF(IA11A20.NE.0) THEN
        AKOEFF(2,2,1,1)=1.0D0 ! ADD A1100=1
        DO M=1,MTRAJ
          XFC(M)=XFC(M)+AKOEFF(2,2,1,1)*XIC(M)
          PXI(M)=PXI(M)+AKOEFF(2,2,1,1)*PXF(M)
        ENDDO
        NKOEF=NKOEF+1
        IE(NKOEF)=2
        JE(NKOEF)=2
        KE(NKOEF)=1
        LE(NKOEF)=1
      ENDIF

C--- COMPARE CALCULATED AND GIVEN COEFFICIENTS A(I,J,K,L)

      OPEN(UNIT=LUNERZ,FILE='wave_erzfun.in',STATUS='OLD',ERR=99)

C10.6.93 READ(LUNERZ,'(I10,1A60)')ICODEERZ,CODEERZ

      READ(LUNERZ,'(2I5,1A55)')ICODEERZ,ITRANCE,CODEERZ
          read(lunerz,*)idum
          read(lunerz,*)dum
          read(lunerz,*)dum
          read(lunerz,*)dum
          read(lunerz,*)dum
          read(lunerz,*)dum
          read(lunerz,*)dum
          read(lunerz,*)dum
          read(lunerz,*)dum
          read(lunerz,*)dum
          read(lunerz,*)dum
          read(lunerz,*)dum
          read(lunerz,*)dum

      DO IREAD=1,1000000

         READ (LUNERZ,*, END=11) I,J,K,L,DUM

         IF(I+J+K+L.LE.NORDNG-1) THEN
            AERZ(I+1,J+1,K+1,L+1)=DUM
         ELSE
            IWARNE=1
         ENDIF

      END DO

11    IERZ=IREAD-1
99    CONTINUE
      IREAD=0
C     IF (IERZ.NE.0) IKOEFF=1
      CLOSE(LUNERZ)

      OPEN(UNIT=LUNREF,FILE='wave_erzfun.ref',STATUS='OLD',ERR=88)

C10.6.93 READ(LUNREF,'(I10,1A60)')ICODEREF,CODEREF

      READ(LUNREF,'(2I5,1A55)')ICODEREF,ITRANCR,CODEREF
          read(lunref,*)idum
          read(lunref,*)dum
          read(lunref,*)dum
          read(lunref,*)dum
          read(lunref,*)dum
          read(lunref,*)dum
          read(lunref,*)dum
          read(lunref,*)dum
          read(lunref,*)dum
          read(lunref,*)dum
          read(lunref,*)dum
          read(lunref,*)dum
          read(lunref,*)dum

C260891  READ(LUNREF,*)

C10.6.93 DO IREAD=1,NKOEF

      DO IREAD=1,1000000

        READ (LUNREF,*, END=22) I,J,K,L,DUM

        IF(I+J+K+L.LE.NORDNG-1) THEN
          AREF(I+1,J+1,K+1,L+1)=DUM
        ELSE
          IWARNR=1
        ENDIF
      END DO

22    IREF=IREAD-1
88    CONTINUE
C     IF (IREF.NE.0) IKOEFF=1
      CLOSE(LUNREF)

      RESAM=0.D0
      RESA2=0.D0
      RESAAV=0.D0
      RESAMR=0.D0
      RESA2R=0.D0
      RESAAVR=0.D0


      IF (IERZ.GT.0) THEN
        DO I=1,NORDNG
          DO J=1,NORDNG
            DO K=1,NORDNG
              DO L=1,NORDNG

                RES=AKOEFF(I,J,K,L)-AERZ(I,J,K,L)
                IF (DABS(RES).GT.DABS(RESAM)) RESAM=RES
                RESA2=RESA2+RES*RES
                RESAAV=RESAAV+RES
                RESR=AKOEFF(I,J,K,L)-AREF(I,J,K,L)
                IF (DABS(RESR).GT.DABS(RESAMR)) RESAMR=RESR
                RESA2R=RESA2R+RESR*RESR
                RESAAVR=RESAAVR+RESR

              ENDDO
            ENDDO
          ENDDO
        ENDDO

        RESA=DSQRT(RESA2/NKOEF)
        RESAAV=RESAAV/NKOEF
        RESAR=DSQRT(RESA2R/NKOEF)
        RESAAVR=RESAAVR/NKOEF
      ENDIF

C--- CALCULATE TRACKS FROM FITTED GENERATING FUNCTION (AKOEFF) AND COMPARE
C    WITH ORIGINAL TRACKING RESULTS

      CALL ARESI(      AKOEFF,MAXTRAP,NORDNGP,
     &                   RESXMK, RESXAVK, RESXK,
     &                   RESYMK, RESYAVK, RESYK,
     &                   RESPXMK,RESPXAVK,RESPXK,
     &                   RESPYMK,RESPYAVK,RESPYK,RESAKO)

C--- CALCULATE TRACKS FROM GIVEN GENERATING FUNCTION (AERZ) AND COMPARE
C    WITH ORIGINAL TRACKING RESULTS

      IF (IERZ.GT.0)
     &  CALL ARESI(  AERZ,MAXTRAP,NORDNGP,
     &  RESXME, RESXAVE, RESXE,
     &  RESYME, RESYAVE, RESYE,
     &  RESPXME,RESPXAVE,RESPXE,
     &  RESPYME,RESPYAVE,RESPYE,RESERZ)

C--- CALCULATE TRACKS FROM GIVEN GENERATING FUNCTION (AREF) AND COMPARE
C    WITH ORIGINAL TRACKING RESULTS

      IF (IREF.GT.0)
     &   CALL ARESI(     AREF,MAXTRAP,NORDNGP,
     &  RESXMR, RESXAVR, RESXR,
     &  RESYMR, RESYAVR, RESYR,
     &  RESPXMR,RESPXAVR,RESPXR,
     &  RESPYMR,RESPYAVR,RESPYR,RESREF)


C--- CALCULATE TRACKS FROM LINEAR TERMS OF GENERATING FUNCTION AND COMPARE
C    WITH ORIGINAL TRACKING RESULTS

      DO I=1,NORDNG
        DO J=1,NORDNG
          DO K=1,NORDNG
            DO L=1,NORDNG

              AKOEFFC(I,J,K,L)=0.D0
              IF(I-1+J-1+K-1+L-1.LE.2) AKOEFFC(I,J,K,L)=AKOEFF(I,J,K,L)

            ENDDO
          ENDDO
        ENDDO
      ENDDO

      CALL ARESI(AKOEFFC,MAXTRAP,NORDNGP,
     &  RSXMTK, RSXAVTK, RSXTK,
     &  RSYMTK, RSYAVTK, RSYTK,
     &  RSPXMTK,RSPXAVTK,RSPXTK,
     &  RSPYMTK,RSPYAVTK,RSPYTK,RESLIN)

C--- LINEAR TRANSFER MATRIX FOR CANONICAL VARIABLES

      TRACOP(1,1)=(-4.D0*AKOEFF(3,1,1,1)*AKOEFF(1,3,
     & 1,1)*AKOEFF(1,1,2,2)+2.D0*AKOEFF(3,1,1,1)*
     & AKOEFF(1,2,2,1)*AKOEFF(1,2,1,2)+AKOEFF(2,2
     & ,1,1)**2.D0*AKOEFF(1,1,2,2)-AKOEFF(2,2,1,1)*
     & AKOEFF(2,1,2,1)*AKOEFF(1,2,1,2)-AKOEFF(2,2
     & ,1,1)*AKOEFF(2,1,1,2)*AKOEFF(1,2,2,1)+2.D0*
     & AKOEFF(2,1,2,1)*AKOEFF(2,1,1,2)*AKOEFF(1,3
     & ,1,1))/(AKOEFF(2,2,1,1)*AKOEFF(1,1,2,2)-
     & AKOEFF(2,1,1,2)*AKOEFF(1,2,2,1))
      TRACOP(1,2)=(2.D0*AKOEFF(1,3,1,1)*AKOEFF(1,1,2
     & ,2)-AKOEFF(1,2,2,1)*AKOEFF(1,2,1,2))/(AKOEFF
     & (2,2,1,1)*AKOEFF(1,1,2,2)-AKOEFF(2,1,1,
     & 2)*AKOEFF(1,2,2,1))
      TRACOP(1,3)=(AKOEFF(2,2,1,1)*AKOEFF(1,2,2,1
     & )*AKOEFF(1,1,2,2)-2.D0*AKOEFF(2,2,1,1)*AKOEFF(
     & 1,2,1,2)*AKOEFF(1,1,3,1)-2.D0*AKOEFF(2,1,
     & 2,1)*AKOEFF(1,3,1,1)*AKOEFF(1,1,2,2)+
     & AKOEFF(2,1,2,1)*AKOEFF(1,2,2,1)*AKOEFF(1,2
     & ,1,2)+4.D0*AKOEFF(2,1,1,2)*AKOEFF(1,3,1,1)*
     & AKOEFF(1,1,3,1)-AKOEFF(2,1,1,2)*AKOEFF(1,2
     & ,2,1)**2)/(AKOEFF(2,2,1,1)*AKOEFF(1,1,2,2)
     & -AKOEFF(2,1,1,2)*AKOEFF(1,2,2,1))
      TRACOP(1,4)=(AKOEFF(2,2,1,1)*AKOEFF(1,2,1,2
     & )-2.D0*AKOEFF(2,1,1,2)*AKOEFF(1,3,1,1))/(AKOEFF
     & (2,2,1,1)*AKOEFF(1,1,2,2)-AKOEFF(2,1,1,
     & 2)*AKOEFF(1,2,2,1))
      TRACOP(2,1)=(-2.D0*AKOEFF(3,1,1,1)*AKOEFF(1,1,
     & 2,2)+AKOEFF(2,1,2,1)*AKOEFF(2,1,1,2))/(
     & AKOEFF(2,2,1,1)*AKOEFF(1,1,2,2)-AKOEFF(2,1
     & ,1,2)*AKOEFF(1,2,2,1))
      TRACOP(2,2)=AKOEFF(1,1,2,2)/(AKOEFF(2,2,1,1
     & )*AKOEFF(1,1,2,2)-AKOEFF(2,1,1,2)*AKOEFF(1,
     & 2,2,1))
      TRACOP(2,3)=(-AKOEFF(2,1,2,1)*AKOEFF(1,1,2,
     & 2)+2.D0*AKOEFF(2,1,1,2)*AKOEFF(1,1,3,1))/(
     & AKOEFF(2,2,1,1)*AKOEFF(1,1,2,2)-AKOEFF(2,1
     & ,1,2)*AKOEFF(1,2,2,1))
      TRACOP(2,4)=(-AKOEFF(2,1,1,2))/(AKOEFF(2,2,1,
     & 1)*AKOEFF(1,1,2,2)-AKOEFF(2,1,1,2)*AKOEFF(
     & 1,2,2,1))
      TRACOP(3,1)=(4.D0*AKOEFF(3,1,1,1)*AKOEFF(1,2,2
     & ,1)*AKOEFF(1,1,1,3)-2.D0*AKOEFF(3,1,1,1)*
     & AKOEFF(1,2,1,2)*AKOEFF(1,1,2,2)-2.D0*AKOEFF(2
     & ,2,1,1)*AKOEFF(2,1,2,1)*AKOEFF(1,1,1,3)+
     & AKOEFF(2,2,1,1)*AKOEFF(2,1,1,2)*AKOEFF(1,1
     & ,2,2)+AKOEFF(2,1,2,1)*AKOEFF(2,1,1,2)*
     & AKOEFF(1,2,1,2)-AKOEFF(2,1,1,2)**2.D0*AKOEFF(1,
     & 2,2,1))/(AKOEFF(2,2,1,1)*AKOEFF(1,1,2,2)
     & -AKOEFF(2,1,1,2)*AKOEFF(1,2,2,1))
      TRACOP(3,2)=(-2.D0*AKOEFF(1,2,2,1)*AKOEFF(1,1,
     & 1,3)+AKOEFF(1,2,1,2)*AKOEFF(1,1,2,2))/(
     & AKOEFF(2,2,1,1)*AKOEFF(1,1,2,2)-AKOEFF(2,1
     & ,1,2)*AKOEFF(1,2,2,1))
      TRACOP(3,3)=(-4.D0*AKOEFF(2,2,1,1)*AKOEFF(1,1,
     & 3,1)*AKOEFF(1,1,1,3)+AKOEFF(2,2,1,1)*
     & AKOEFF(1,1,2,2)**2+2.D0*AKOEFF(2,1,2,1)*AKOEFF(
     & 1,2,2,1)*AKOEFF(1,1,1,3)-AKOEFF(2,1,2,
     & 1)*AKOEFF(1,2,1,2)*AKOEFF(1,1,2,2)-AKOEFF(
     & 2,1,1,2)*AKOEFF(1,2,2,1)*AKOEFF(1,1,2,
     & 2)+2.D0*AKOEFF(2,1,1,2)*AKOEFF(1,2,1,2)*
     & AKOEFF(1,1,3,1))/(AKOEFF(2,2,1,1)*AKOEFF(1,
     & 1,2,2)-AKOEFF(2,1,1,2)*AKOEFF(1,2,2,1))
      TRACOP(3,4)=(2.D0*AKOEFF(2,2,1,1)*AKOEFF(1,1,1
     & ,3)-AKOEFF(2,1,1,2)*AKOEFF(1,2,1,2))/(AKOEFF
     & (2,2,1,1)*AKOEFF(1,1,2,2)-AKOEFF(2,1,1,
     & 2)*AKOEFF(1,2,2,1))
      TRACOP(4,1)=(2.D0*AKOEFF(3,1,1,1)*AKOEFF(1,2,2
     & ,1)-AKOEFF(2,2,1,1)*AKOEFF(2,1,2,1))/(AKOEFF
     & (2,2,1,1)*AKOEFF(1,1,2,2)-AKOEFF(2,1,1,
     & 2)*AKOEFF(1,2,2,1))
      TRACOP(4,2)=(-AKOEFF(1,2,2,1))/(AKOEFF(2,2,1,
     & 1)*AKOEFF(1,1,2,2)-AKOEFF(2,1,1,2)*AKOEFF(
     & 1,2,2,1))
      TRACOP(4,3)=(-2.D0*AKOEFF(2,2,1,1)*AKOEFF(1,1,
     & 3,1)+AKOEFF(2,1,2,1)*AKOEFF(1,2,2,1))/(
     & AKOEFF(2,2,1,1)*AKOEFF(1,1,2,2)-AKOEFF(2,1
     & ,1,2)*AKOEFF(1,2,2,1))
      TRACOP(4,4)=AKOEFF(2,2,1,1)/(AKOEFF(2,2,1,1
     & )*AKOEFF(1,1,2,2)-AKOEFF(2,1,1,2)*AKOEFF(1,
     & 2,2,1))

      CALL UTIL_DETERMINANTE(4,TRACOP,DETCOP,IDETFAIL)

C--- LINEAR TRANSFER MATRIX WITHOUT COUPLING

      A1100=AKOEFF(2,2,1,1)
      A2000=AKOEFF(3,1,1,1)
      A0200=AKOEFF(1,3,1,1)

      A0011=AKOEFF(1,1,2,2)
      A0020=AKOEFF(1,1,3,1)
      A0002=AKOEFF(1,1,1,3)

      TRALIN(1,1)=(A1100*A1100-4.D0*A2000*A0200)/A1100
      TRALIN(1,2)=2.D0*A0200/A1100
      TRALIN(2,1)=-2.D0*A2000/A1100
      TRALIN(2,2)=1/A1100

      DETTRA1=TRALIN(1,1)*TRALIN(2,2)-TRALIN(2,1)*TRALIN(1,2)

      IF (I2DIM.EQ.0)  THEN

         TRALIN(3,3)=(A0011*A0011-4.D0*A0020*A0002)/A0011
         TRALIN(3,4)=2.D0*A0002/A0011
         TRALIN(4,3)=-2.D0*A0020/A0011
         TRALIN(4,4)=1/A0011

         DETTRA2=TRALIN(3,3)*TRALIN(4,4)-TRALIN(3,4)*TRALIN(4,3)

      ENDIF

      IF(TRALIN(2,1).NE.0.) FOCEX=-1.D0/TRALIN(2,1)
      IF(TRALIN(4,3).NE.0.) FOCEY=-1.D0/TRALIN(4,3)


C--- CALCULATE TRACKS FROM 2. ORDER TERMS USED FOR LINEAR TRANSFER MATRIX
C    AND COMPARE WITH ORIGINAL TRACKING RESULTS

      DO I=1,NORDNG
      DO J=1,NORDNG
      DO K=1,NORDNG
      DO L=1,NORDNG

      AKOEFFC(I,J,K,L)=0.D0
      IF (I-1+J-1+K-1+L-1 .EQ.2) AKOEFFC(I,J,K,L)=AKOEFF(I,J,K,L)
C     IF (I-1+J-1.EQ.1) AKOEFFC(I,J,K,L)=0.D0 !KILL COUPLING

      ENDDO
      ENDDO
      ENDDO
      ENDDO

      CALL ARESI(      AKOEFFC,MAXTRAP,NORDNGP,
     &                   RSXMT, RSXAVT, RSXT,
     &                   RSYMT, RSYAVT, RSYT,
     &                   RSPXMT,RSPXAVT,RSPXT,
     &                   RSPYMT,RSPYAVT,RSPYT,RESTRA)


C--- CALCULATE EQUIVALENT HALBACH WIGGLER

      IF(IHALBA.NE.0.AND.I2DIM.EQ.0) THEN

C     CALCULATION OF K-VALUES OF MATRIX (REFER BETA MANUAL PAGE 13)
C     ANSATZ: LONG QUADRUPOLE, K-VALUES(FY,FX):

                FY= TRALIN(4,3)/TRALIN(3,4)   ! <0 ,LARGE, FOCUSSING
                FX= TRALIN(2,1)/TRALIN(1,2)   ! >0 ,SMALL, DEFOCUSSING

                IF (FY.GE.0.0.OR.FX+FY.GT.0.0) THEN
                WRITE(6,*)
     &'*** MESSAGE SR TRANPOLY: NO EQUIVALENT HALBACH WIGGLER FOUND ***'
                WRITE(LUNGFO,*)
     &'*** MESSAGE SR TRANPOLY: NO EQUIVALENT HALBACH WIGGLER FOUND ***'
            IHALBA=0
            GOTO 500
         ENDIF

         R2HAL =FX/FY                      ! R2HAL<0 !!
         SINZ2 =-TRALIN(4,3)*TRALIN(3,4)
       SINZ  = DSIGN(DSQRT(SINZ2),TRALIN(3,4))
       COSZ  = (TRALIN(3,3)+TRALIN(4,4))/2.D0
         ZETAZ = ATAN2(SINZ,COSZ)
       IF (ZETAZ.LT.0.D0) ZETAZ=ZETAZ+2.D0*PI1
         ZLENGE= ZETAZ/DSQRT(-FY)
         RHOHAL= 1.D0/DSQRT(-2.D0*(FX+FY))
         ZLHAL = ZLENGE/NPERTRA
         ZKHAL=2.D0*PI1/ZLHAL
       ZKHALR=ZKHAL
       ZKHALI=0.D0

         B0HAL=PEL/CLIGHT1/RHOHAL
       IF (1.D0+R2HAL.GT.0.D0) THEN
          YKHAL=SQRT(ZKHAL*ZKHAL/ABS(1.D0+R2HAL))
        YKHALR=YKHAL
        YKHALI=0.D0
       ELSE IF (1.D0+R2HAL.GT.0.D0) THEN
          YKHAL=SQRT(ZKHAL*ZKHAL/ABS(1.D0+R2HAL))
        YKHALI=YKHAL
        YKHALR=0.D0
       ELSE
        YKHAL=0.D0
        YKHALR=0.D0
        YKHALI=0.D0
       ENDIF

         IF(YKHAL.NE.0.D0) YLHAL=2.D0*PI1/YKHAL
       IF (ZKHAL.GE.YKHAL) THEN
          XKHAL=SQRT((ZKHAL+YKHAL)*(ZKHAL-YKHAL))
        XKHALR=XKHAL
        XKHALI=0.D0
       ELSE
          XKHAL=SQRT((YKHAL+ZKHAL)*(YKHAL-ZKHAL))
        XKHALI=XKHAL
        XKHALR=0.D0
       ENDIF
         IF(XKHAL.NE.0.D0)XLHAL=2.D0*PI1/XKHAL

      ENDIF

C--- CALCULATE EQUIVALENT QUADRUPOLE FROM LINEAR TRANSFER MATRIX

500   CONTINUE

      IF (IQUAD.NE.0) THEN

      T11=0.5D0*(TRALIN(1,1)+TRALIN(2,2))
C     T11=DSQRT(TRALIN(1,1)*TRALIN(2,2))

      IF(T11.GT.1.D0)   THEN

         SIHPHIX=DSQRT((T11+1.D0)*(T11-1.D0))
         PHIX=DLOG(T11+SIHPHIX)

         IF(DABS(TRALIN(2,1)).GT.1.D-6) THEN

                  QUADX=DSQRT(TRALIN(1,2)/TRALIN(2,1)*PHIX*PHIX)
           QUADFX=-QUADX/(PHIX*PHIX)
           QUADR(1,1)=T11
           QUADR(2,2)=QUADR(1,1)
           QUADR(1,2)=QUADX/PHIX*SIHPHIX
           QUADR(2,1)=PHIX/QUADX*SIHPHIX

         ELSE

                  QUADX=0.
           QUADFX=0.
           QUADR(1,1)=T11
           QUADR(2,2)=QUADR(1,1)
           QUADR(1,2)=AKOEFF(1,3,1,1)*2.D0
           QUADR(2,1)=0.

         ENDIF

      ELSEIF (T11.GE.-1.D0) THEN

         SINPHIX=DSQRT(-(T11+1.D0)*(T11-1.D0))
         PHIX=DACOS(T11)

         IF(DABS(TRALIN(2,1)).GT.1.D-6) THEN

             QUADX=DSQRT(-TRALIN(1,2)/TRALIN(2,1)*PHIX*PHIX)
             QUADFX=QUADX/(PHIX*PHIX)
             QUADR(1,1)=T11
             QUADR(2,2)=QUADR(1,1)
             QUADR(1,2)=QUADX/PHIX*SINPHIX
             QUADR(2,1)=-PHIX/QUADX*SINPHIX

         ELSE

             QUADX=0.
             QUADFX=0.
             QUADR(1,1)=T11
             QUADR(2,2)=QUADR(1,1)
             QUADR(1,2)=AKOEFF(1,3,1,1)*2.D0
             QUADR(2,1)=0.

         ENDIF

      ENDIF !T11


      IF (I2DIM.EQ.0) THEN

         T33=0.5D0*(TRALIN(3,3)+TRALIN(4,4))
C        T33=DSQRT(TRALIN(3,3)*TRALIN(4,4))

      IF(T33.GT.1.D0) THEN

         SIHPHIY=DSQRT((T33+1.D0)*(T33-1.D0)) !SINUS-HYP.(PHI)
         PHIY=DLOG(T33+SIHPHIY)  !AREA-COSINUS-HYP.

         IF(DABS(TRALIN(4,3)).GT.1.D-6) THEN

            QUADY=DSQRT(TRALIN(3,4)/TRALIN(4,3)*PHIY*PHIY)
            QUADFY=-QUADY/(PHIY*PHIY)
            QUADR(3,3)=T33
            QUADR(4,4)=QUADR(3,3)
            QUADR(3,4)=QUADY/PHIY*SIHPHIY
            QUADR(4,3)=PHIY/QUADY*SIHPHIY

         ELSE

            QUADY=0.
            QUADFY=0.
            QUADR(3,3)=T33
                 QUADR(4,4)=QUADR(3,3)
                 QUADR(3,4)=AKOEFF(1,1,1,3)*2.D0
                 QUADR(4,3)=0.

         ENDIF

      ELSEIF (T33.GT.-1.D0) THEN

         SINPHIY=DSQRT((T33+1.D0)*(1.D0-T33))
         PHIY=DACOS(T33)

         IF(DABS(TRALIN(4,3)).GT.1.D-6) THEN

             QUADY=DSQRT(-TRALIN(3,4)/TRALIN(4,3)*PHIY*PHIY)
             QUADFY=QUADY/(PHIY*PHIY)
             QUADR(3,3)=T33
             QUADR(4,4)=QUADR(3,3)
             QUADR(3,4)=QUADY/PHIY*SINPHIY
             QUADR(4,3)=-PHIY/QUADY*SINPHIY

         ELSE

             QUADY=0.
             QUADFY=0.
             QUADR(3,3)=T33
             QUADR(4,4)=QUADR(3,3)
             QUADR(3,4)=AKOEFF(1,1,1,3)*2.D0
             QUADR(4,3)=0.

         ENDIF

C        QUADY=DSQRT(-TRALIN(3,4)/TRALIN(4,3)*PHIY*PHIY)
C        QUADFY= QUADY/(PHIY*PHIY)
C        QUADR(3,3)=T33
C        QUADR(4,4)=QUADR(3,3)
C        QUADR(3,4)= QUADY/PHIY*SINPHIY
C        QUADR(4,3)=-PHIY/QUADY*SINPHIY

      ENDIF !T33

      ENDIF !I2DIM

      DO I=1,NORDNG
      DO J=1,NORDNG
      DO K=1,NORDNG
      DO L=1,NORDNG

      AKOEFFC(I,J,K,L)=0.D0

      ENDDO
      ENDDO
      ENDDO
      ENDDO

      IF(QUADR(2,2).NE.0) THEN

         AKOEFFC(2,2,1,1)=1.D0/QUADR(2,2)
         AKOEFFC(1,3,1,1)= QUADR(1,2)/(2.D0*QUADR(2,2))
         AKOEFFC(3,1,1,1)=-QUADR(2,1)/(2.D0*QUADR(2,2))

         IF (I2DIM.EQ.0) THEN

            AKOEFFC(1,1,2,2)=1.D0/QUADR(4,4)
            AKOEFFC(1,1,1,3)= QUADR(3,4)/(2.D0*QUADR(4,4))
            AKOEFFC(1,1,3,1)=-QUADR(4,3)/(2.D0*QUADR(4,4))

         ENDIF

         CALL ARESI(AKOEFFC,MAXTRAP,NORDNGP,
     &                   RSXMTQ, RSXAVTQ, RSXTQ,
     &                   RSYMTQ, RSYAVTQ, RSYTQ,
     &                   RSPXMTQ,RSPXAVTQ,RSPXTQ,
     &                   RSPYMTQ,RSPYAVTQ,RSPYTQ,RESQUAD)

      ENDIF !QUADR(2,2)

      ENDIF !IQUAD


C7.6.93  CALL CLOSEOR(AKOEFF(1,2,1,1),AKOEFF(2,1,1,1),
C7.6.93     &               AKOEFF(2,2,1,1),
C7.6.93     &               AKOEFF(3,1,1,1),AKOEFF(1,3,1,1),
C7.6.93     &               XCLOSE,PCLOSE)


C--- OUTPUT

C030192  WRITE (LUN1,*)'*** WARNUNG: DIE KANONISCHEN VARIABLEN WERDEN OHNE
C030192     & BERUECKSICTIGUNG'
C030192  WRITE (LUN1,*)'             DES VEKTORPOTENTIALES BERECHNET. NUR
C030192     & KORREKT, FALLS'
C030192        WRITE (LUN1,*)'             DAS POTENTIAL NULL IST. ***'

      WRITE (LUN1,*)
      WRITE (LUN1,*)
      WRITE (LUN1,*)
     &  '     Tracks to fit generating function read from file (FILEO):'
      WRITE (LUN1,*)'       ',FILEO
      WRITE (LUN1,*)'     User comment of FILEO:'
      WRITE (LUN1,*)'       ',CODE
      WRITE (LUN1,*)'     Run number of FILEO :  ',kCODE
      WRITE (LUN1,*)'     Run number of TRANPOLY:',ITRANC
      WRITE (LUN1,*)
      WRITE (LUN1,*)'     Number of considered tracks (NTRAJ):',NTRAJ
      WRITE(LUN1,*)

      IF (DRAUSCHX.NE.0.0 .OR. DRAUSCHY.NE.0.0) THEN
      WRITE(LUN1,*)
     &'     Noise amplitude [m] overlaid on Z,ZP (DRAUSCHX):'
     &,SNGL(DRAUSCHX)
      WRITE(LUN1,*)
     &'     Noise amplitude [m] overlaid on Y,YP (DRAUSCHY):'
     &,SNGL(DRAUSCHY)
      WRITE(LUN1,*)
     &'     Noise amplitude on Z,ZP divided by mean length of (XF,PXI):'
     &,SNGL(DRAUSCHX/XFXCAVE)
      IF (I2DIM.EQ.0)
     &   WRITE(LUN1,*)
     &'     Noise amplitude on Y,YP divided by mean length of (YF, PYI):'
     &,SNGL(DRAUSCHY/XFYCAVE)
      ENDIF !DRAUSCH

C     WRITE (6,*)'CODE-WORT AUS WLS.FOR:',CODE
C     WRITE(6,*)'LAUFENDE NUMMER AUS WLS.FOR:',ICODE
C     WRITE(6,*)'LAUFENDE NUMMER AUS TRANPOLY.FOR:',ITRANC
C     WRITE(6,*)'RAUSCHAMPLITUDE IN X,XP:',SNGL(DRAUSCHX)
C     WRITE(6,*)'RAUSCHAMPLITUDE IN Y,YP:',SNGL(DRAUSCHY)

      WRITE (LUN1,*)
      WRITE (LUN1,*)'     Start values of reference orbit (Lab.-System):'
      WRITE (LUN1,*)'     X0,Y0,Z0:   ',SNGL(X0),SNGL(Y0),SNGL(Z0)
      WRITE (LUN1,*)'     ZP0,YP0:    ',SNGL(ZP0),SNGL(YP0)
      WRITE (LUN1,*)'     BX0,BY0,BZ0:',SNGL(BX0),SNGL(BY0),SNGL(BZ0)
      WRITE (LUN1,*)'     AX0,AY0,AZ0:',SNGL(AX0),SNGL(AY0),SNGL(AZ0)
      WRITE (LUN1,*)
      WRITE (LUN1,*)'     Final values of reference orbit (Lab.-System):'
      WRITE (LUN1,*)'     XF0,YF0,ZF0:   ',SNGL(XF0),SNGL(YF0),SNGL(ZF0)
      WRITE (LUN1,*)'     ZPF0,YPF0:    ',SNGL(ZPF0),SNGL(YPF0)
      WRITE (LUN1,*)'     BXF0,BYF0,BZF0:',SNGL(BXF0),SNGL(BYF0),SNGL(BZF0)
      WRITE (LUN1,*)'     AXF0,AYF0,AZF0:',SNGL(AXF0),SNGL(AYF0),SNGL(AZF0)
      WRITE (LUN1,*)

      WRITE (LUN1,*)'     Normal vector of entrance plane:'
      WRITE (LUN1,*)'     ',SNGL(OPNX),SNGL(OPNY),SNGL(OPNZ)
      WRITE (LUN1,*)
      WRITE (LUN1,*)'     Normal vector of exit plane:    '
      WRITE (LUN1,*)'     ',SNGL(OPNFX),SNGL(OPNFY),SNGL(OPNFZ)
      WRITE (LUN1,*)

      WRITE (LUN1,*)
      WRITE (LUN1,*)'     Energy [GeV]:',SNGL(GAMMA*EMASSE1/1.D9)
      WRITE (LUN1,*)'     B*RHO [Tm]:  ',SNGL(BRHOABS)
      WRITE (LUN1,*)

      WRITE (LUN1,*)
      WRITE (LUN1,*)'     Flags:'
      WRITE (LUN1,3300)IA1000,IA0100,IA0010,IA0001
3300  FORMAT('      IA1000,IA0100,IA0010,IA0001:',4I3)
      WRITE (LUN1,3330)I2DIM,ISYM,IA11A20,IWLSHOR
3330  FORMAT('      I2DIM,ISYM,IA11A20,IWLSHOR: ',4I3)
      WRITE (LUN1,*)

      IF (I2DIM.NE.0) THEN
         WRITE (LUN1,*)
         WRITE (LUN1,*)
         WRITE (LUN1,*)
     & '     *** 2-DIMENSIONAL FIT (FLAG I2DIM.NE.0) ***'
         WRITE (LUN1,*)
         WRITE (LUN1,*)
      ENDIF

      WRITE (LUN1,*)
      WRITE (LUN1,*) '     Number of tracks:',MTRAJ
      WRITE (LUN1,*)

      IF (ISELECT.GT.0) THEN

      WRITE (LUN1,*)
      WRITE (LUN1,*)
     &'     Selection of initial parameters of tracks:'
      WRITE (LUN1,*)
     &'     ------------------------------------------'
      WRITE (LUN1,*)

      WRITE (LUN1,*)
      WRITE (LUN1,*)
     &'     Coordinates and slopes ZI(N), ZPI(N), YI(N), YPI(N):'
      WRITE (LUN1,*)

      DO I=1,MTRAJ,ISELECT
         WRITE (LUN1,1000)I,XI(1,I),XI(2,I),XI(3,I),XI(4,I)
      ENDDO

      WRITE (LUN1,*)
      WRITE (LUN1,*)
     &'     Canonical variables XI(N), PXF(N), YI(N), PYF(N)):'
      WRITE (LUN1,*)

      DO I=1,MTRAJ,ISELECT
         WRITE (LUN1,1000)I,XIC(I),PXF(I),YIC(I),PYF(I)
      ENDDO

      WRITE (LUN1,*)
      WRITE (LUN1,*)
     &'     Magnetic field BXI(N), BYI(N), BZI(N)):'
      WRITE (LUN1,*)

      DO I=1,MTRAJ,ISELECT
      WRITE (LUN1,1000)I,BXI(I),BYI(I),BZI(I)
      ENDDO

      WRITE (LUN1,*)
      WRITE (LUN1,*)
     &'     XI_lab(N) and vector pot. AXI(N)/BRHO, AYI(N)/BRHO, AZI(N)/BRHO:'
      WRITE (LUN1,*)

      DO I=1,MTRAJ,ISELECT
      WRITE (LUN1,1000)I,SI(I),AXI(I)/BRHOABS,AYI(I)/BRHOABS,AZI(I)/BRHOABS
      ENDDO

      WRITE (LUN1,*)
      WRITE (LUN1,*)
      WRITE (LUN1,*)
     &'     Selection of final parameters of tracks:'
      WRITE (LUN1,*)
     &'     ----------------------------------------'
      WRITE (LUN1,*)

      WRITE (LUN1,*)
      WRITE (LUN1,*)
     &'     Coordiantes and slopes ZF(N), ZPF(N), YF(N), YPF(N):'
      WRITE (LUN1,*)
      WRITE (LUN1,*)
      DO I=1,MTRAJ,ISELECT
         WRITE (LUN1,1000)I,XF(1,I),XF(2,I),XF(3,I),XF(4,I)
      ENDDO

      WRITE (LUN1,*)
      WRITE (LUN1,*)
     &'     Canonical variables XF(N), PXI(N), YF(N), PYI(N)):'
      WRITE (LUN1,*)

      DO I=1,MTRAJ,ISELECT
         WRITE (LUN1,1000)I,XFC(I),PXI(I),YFC(I),PYI(I)
      ENDDO

      WRITE (LUN1,*)
      WRITE (LUN1,*)
     &'     Magnetic field BXI(N), BYI(N), BZI(N)):'
      WRITE (LUN1,*)

      DO I=1,MTRAJ,ISELECT
      WRITE (LUN1,1000)I,BXF(I),BYF(I),BZF(I)
      ENDDO

      WRITE (LUN1,*)
      WRITE (LUN1,*)
     &'     XF_lab(N) and vector pot. AXF(N)/BRHO, AYF(N)/BRHO, AZF(N)/BRHO:'
      WRITE (LUN1,*)

      DO I=1,MTRAJ,ISELECT
      WRITE (LUN1,1000)I,SF(I),AXF(I)/BRHOABS,AYF(I)/BRHOABS,AZF(I)/BRHOABS
      ENDDO

      ENDIF !ISELECT

      WRITE (LUN1,*)
      WRITE (LUN1,*)
      WRITE (LUN1,*)
     &'     Mean length of canonical vectors (XI, PXF, YI, PYF):',
     &                 SNGL(XICAVE)
      WRITE (LUN1,*)
     &'     Mean length of canonical vectors (XF, PXI, YF, PYI):',
     &                 SNGL(XFCAVE)
      WRITE (LUN1,*)

      WRITE(LUN1,*)
     &'     Scaling factor for system of linear equations:',
     &                 SNGL(DSCALE)

      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Number of fitted coefficients:',NKOEF
      WRITE(LUN1,*)

      WRITE(LUN1,*)
     &'     Check of solution of linear equation system, i.e maximum, mean,'
      WRITE(LUN1,*)'     and rms of deviation:'
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESBM,RESBAV,RESB

      WRITE(LUN1,*)
      IF(IERZ.GT.0) THEN
         WRITE(LUN1,*)
     &'     Run numbers and user comment on file WAVE_ERZFUN.IN:'
         WRITE(LUN1,*)'     ',ICODEERZ,ITRANCE
         WRITE(LUN1,*)'          ',CODEERZ
         WRITE(LUN1,*)
     &'     Number of coefficients AERZ(I,J,K,L):',IERZ
      WRITE(LUN1,*)
      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Maximum, mean and rms of AKOEFF(I,J,K,L)-AERZ(I,J,K,L):'
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESAM,RESAAV,RESA
      ENDIF !IERZ

      IF(IREF.GT.0) THEN
      WRITE(LUN1,*)
      WRITE(LUN1,*)
         WRITE(LUN1,*)
     &'     Run numbers and user comment on file WAVE_ERZFUN.REF:'
         WRITE(LUN1,*)'     ', ICODEREF,ITRANCR
         WRITE(LUN1,*)'     ',CODEREF
         WRITE(LUN1,*)
     &'     Number of coefficients AREF(I,J,K,L):',IREF
      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Maximum, mean and rms of AKOEFF(I,J,K,L)-AREF(I,J,K,L):'
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESAMR,RESAAVR,RESAR
      ENDIF !IREF

      WRITE(LUN1,*)
      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Maximum, mean, and rms of deviation for XF, PXI, YF, PYI'
      WRITE(LUN1,*)'     recalculated using AKOEFF:'
      WRITE(LUN1,*)
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESXMK, RESXAVK, RESXK
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESPXMK,RESPXAVK,RESPXK
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESYMK, RESYAVK, RESYK
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESPYMK,RESPYAVK,RESPYK

c     WRITE(6,*)'ANZAHL DER GEFITTETEN KOEFF., SQRT(CHI**2/N) DES FITS
c     &:',NKOEF,SNGL(RESAKO)
c     WRITE(6,*)'SQRT(CHI**2/N) DES FITS/MITTLERE LAENGE DER END-VEKTOREN
c     &:',SNGL(RESAKO/XFCAVE)

      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     SQRT(CHI**2/N) corresponding to AKOEFF:         '
     &     ,SNGL(RESAKO)
      WRITE(LUN1,*)
     &'     Dito divided by mean length of (XI,PXF,YI,PYF):'
     &       ,SNGL(RESAKO/XFCAVE)

      IF (IERZ.GT.0) THEN
      WRITE(LUN1,*)
      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Maximum, mean, and rms of deviation for XF, PXI, YF, PYI'
      WRITE(LUN1,*)'     recalculated using AERZ:'
      WRITE(LUN1,*)
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESXME, RESXAVE, RESXE
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESPXME,RESPXAVE,RESPXE
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESYME, RESYAVE, RESYE
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESPYME,RESPYAVE,RESPYE
      WRITE(LUN1,*)

      WRITE(LUN1,*)
     &'     SQRT(CHI**2/N) corresponding to AERZ:           '
     &      ,SNGL(RESERZ)
      WRITE(LUN1,*)
     &'     Dito divided by mean length of (XI,PXF,YI,PYF):'
     &       ,SNGL(RESERZ/XFCAVE)
      ENDIF !IERZ

      IF (IREF.GT.0) THEN
      WRITE(LUN1,*)
      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Maximum, mean, and rms of deviation for XF, PXI, YF, PYI'
      WRITE(LUN1,*)'     recalculated using AREF:'
      WRITE(LUN1,*)
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESXMR, RESXAVR, RESXR
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESPXMR,RESPXAVR,RESPXR
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESYMR, RESYAVR, RESYR
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RESPYMR,RESPYAVR,RESPYR
      WRITE(LUN1,*)

      WRITE(LUN1,*)
     &'     SQRT(CHI**2/N) corresponding to AREF:           '
     &     ,SNGL(RESREF)
      WRITE(LUN1,*)
     &'     Dito divided by mean length of (XI,PXF,YI,PYF):'
     &       ,SNGL(RESREF/XFCAVE)
      ENDIF !IREF

C--- WRITE COEFFICIENTS AKOEFF TO OUTPUT FILE WAVE_TRANPOLY.AKO

      OPEN(UNIT=LUNAKO,FILE='wave_tranpoly.ako',STATUS='NEW',FORM='FORMATTED')

C10.6.93 WRITE (LUNAKO,'(I5,4H    ,1A66)')ICODE,CODE
      WRITE (LUNAKO,'(I10,I5,4H    ,1A66)')ICODE,ITRANC,CODE
      WRITE(LUNAKO,*)ICHARGE,NORDNG
      WRITE(LUNAKO,*)ZAPERT,YAPERT,DLAPER,sint,gamma,dgam
      WRITE(LUNAKO,*)X0,Y0,Z0,ZP0,YP0,BX0,BY0,BZ0,AX0,AY0,AZ0
      WRITE(LUNAKO,*)XF0,YF0,ZF0,ZPF0,YPF0,BXF0,BYF0,BZF0,AXF0,AYF0,AZF0
      WRITE(LUNAKO,*)OPNX,OPNY,OPNZ
      WRITE(LUNAKO,*)OPNFX,OPNFY,OPNFZ
      WRITE(LUNAKO,*)A0SCGLOB


      DO N=1,NKOEF
         I=IE(N)
         J=JE(N)
         K=KE(N)
         L=LE(N)
         WRITE(LUNAKO,*) I-1,J-1,K-1,L-1,AKOEFF(I,J,K,L)
      ENDDO

      CLOSE(LUNAKO)

      IF (IERZ.NE.0.OR.IREF.NE.0) THEN

      WRITE (LUN1,*)

      WRITE (LUN1,*)
     &'     Comparison of fitted coefficients AKOEFF with AERZ and AREF;'
      WRITE (LUN1,*)
     &'     AKOEFF, AERZ, 2*(AERZ-AKOEF)/(|AERZ|+|AKOEF|), and also for AREF'
      WRITE (LUN1,*)
     &'     (only printed if deviations larger than 1E-10)'
      WRITE (LUN1,*)

      DO N=2,NORDNG
          WRITE(LUN1,*)
          DO I=1,NORDNG
          DO J=1,NORDNG
          DO K=1,NORDNG
          DO L=1,NORDNG

      IF(I-1+J-1+K-1+L-1.EQ.N-1) THEN
C7.6.93  IF(I-1+J-1+K-1+L-1.EQ.N-1.AND.AKOEFF(I,J,K,L).NE.0.0) THEN

         AK=AKOEFF(I,J,K,L)
         AE=AERZ(I,J,K,L)
         AR=AREF(I,J,K,L)
         AKE=0.D0
         AKR=0.D0

         IF (DABS(AE)+DABS(AK).NE.0.0)
     &             AKE=2.*(AE-AK)/(DABS(AE)+DABS(AK))
         IF (DABS(AR)+DABS(AK).NE.0.0)
     &             AKR=2.*(AR-AK)/(DABS(AR)+DABS(AK))

        IF(DABS(AKE).GT.1.D-10.OR.DABS(AKR).GT.1.D-10) THEN

         WRITE(LUN1,8000) I-1,J-1,K-1,L-1,AK,AE,AKE,AR,AKR
8000    FORMAT('      ','a',4I1,1P,(2D15.7),1P,(D10.2),1P,(D15.7),1P,(D10.2))

C7.6.93     IF (AE*AK.NE.0.D0) AKE=(AK/AE+AE/AK)/2.D0-1.D0
C7.6.93     IF (AR*AK.NE.0.D0) AKR=(AK/AR+AR/AK)/2.D0-1.D0

C7.6.93     IF( AE.NE.0.D0 .AND. AR.NE.0.D0)
C7.6.93     &     WRITE(LUN1,3000) I-1,J-1,K-1,L-1,AK,AE,AKE,AR,AKR
C7.6.93     IF( AE.EQ.0.D0 .AND. AR.NE.0.D0)
C7.6.93     &     WRITE(LUN1,3001) I-1,J-1,K-1,L-1,AK,       AR,AKR
C7.6.93     IF( AE.NE.0.D0 .AND. AR.EQ.0.D0)
C7.6.93     &     WRITE(LUN1,3002) I-1,J-1,K-1,L-1,AK,AE,AKE
C7.6.93     IF( AE.EQ.0.D0 .AND. AR.EQ.0.D0)
C7.6.93     &     WRITE(LUN1,3003) I-1,J-1,K-1,L-1,AK

      ENDIF
      ENDIF

          ENDDO
          ENDDO
          ENDDO
          ENDDO
      ENDDO

      ENDIF

      WRITE(LUN1,*)
      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Maximum, mean, and rms of deviation for XF, PXI, YF, PYI'
      WRITE(LUN1,*)
     &'     recalculated using only linear terms of AKOEFF, i.e. first'
      WRITE(LUN1,*)'     and second order:'
      WRITE(LUN1,*)
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RSXMTK, RSXAVTK, RSXTK
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RSPXMTK,RSPXAVTK,RSPXTK
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RSYMTK, RSYAVTK, RSYTK
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RSPYMTK,RSPYAVTK,RSPYTK
      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Corresponding SQRT(CHI**2/N):                   ',SNGL(RESLIN)
      WRITE(LUN1,*)
     &'     Dito divided by mean length of (XI,PXF,YI,PYF):',SNGL(RESLIN/XFCAVE)

      WRITE(LUN1,*)
      WRITE(LUN1,*)
      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Linear transfer matrix (for canonical variables):'
      WRITE(LUN1,*)
      DO I=1,4
         WRITE(LUN1,5000) (TRACOP(I,J),J=1,4)
      ENDDO
      WRITE(LUN1,*)
      WRITE(LUN1,*)'      Failure flag and determinant:',IDETFAIL,DETCOP
      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Linear transfer matrix (for canonical variables, without coupling):'
      WRITE(LUN1,*)
      DO I=1,4
         WRITE(LUN1,5000) (TRALIN(I,J),J=1,4)
      ENDDO
      WRITE(LUN1,*)
C     WRITE(LUN1,*) '     Deviations of sub-determinants from unity:',
C     &  SNGL(1.D0-DETTRA1),SNGL(1.D0-DETTRA2)
C     WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Horiz. and vert. focal lengths (-1/m21 and -1/m43) [1/m]:'
      WRITE(LUN1,*)'     ', SNGL(FOCEX),SNGL(FOCEY)
      WRITE(LUN1,*)

      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Maximum, mean, and rms of deviation for XF, PXI, YF, PYI recalculated'
      WRITE(LUN1,*)
     &'     using all 2. order terms of AKOEFF (including coupling):'
      WRITE(LUN1,*)
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RSXMT, RSXAVT, RSXT
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RSPXMT,RSPXAVT,RSPXT
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RSYMT, RSYAVT, RSYT
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RSPYMT,RSPYAVT,RSPYT
      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Corresponding SQRT(CHI**2/N):                   '
     &      ,SNGL(RESTRA)
      WRITE(LUN1,*)
     &'     Dito divided by mean length of (XI,PXF,YI,PYF):'
     &       ,SNGL(RESTRA/XFCAVE)

      WRITE(LUN1,*)
      WRITE(LUN1,*)
      WRITE(LUN1,*)

      IF (IQUAD.NE.0) THEN
      WRITE(LUN1,*) '     Quadrupole matrix (for canonical variables):'
      WRITE(LUN1,*)
      DO I=1,4
         WRITE(LUN1,5000) (QUADR(I,J),J=1,4)
      ENDDO
      WRITE(LUN1,*)
C     WRITE(LUN1,*) '     Deviations of sub-determinants from unity:',
C     &  SNGL(1.D0-(QUADR(1,1)*QUADR(2,2)-QUADR(2,1)*QUADR(1,2))),
C     &  SNGL(1.D0-(QUADR(3,3)*QUADR(4,4)-QUADR(3,4)*QUADR(4,3)))
C     WRITE(LUN1,*)
      WRITE(LUN1,*)'     Hori. and vert. focal length (1/f=k*l) [m]:',
     &  SNGL(QUADFX),SNGL(QUADFY)
C     WRITE(6,*)'FOKAL-LAENGEN IN X UND Y (METER):',QUADFX,QUADFY

C     WRITE(6,*) 'XCLOSE:  ',xclose
C     WRITE(6,*) 'PxfCLOSE:',Pclose
      WRITE(LUN1,*)

      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Maximum, mean, and rms of deviation for XF, PXI, YF, PYI'
      WRITE(LUN1,*)
     &'     recalculated using those 2. order terms of AKOEFF that'
      WRITE(LUN1,*)
     &'     have been used to determine the quadrupole matrix:'
      WRITE(LUN1,*)
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RSXMTQ, RSXAVTQ, RSXTQ
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RSPXMTQ,RSPXAVTQ,RSPXTQ
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RSYMTQ, RSYAVTQ, RSYTQ
      WRITE(LUN1,'(5H     ,1P,(3D15.3))') RSPYMTQ,RSPYAVTQ,RSPYTQ
      WRITE(LUN1,*)
      WRITE(LUN1,*)
     &'     Corresponding SQRT(CHI**2/N):                   ',SNGL(RESQUAD)
      WRITE(LUN1,*)
     &'     Dito divided by mean length of (XI,PXF,YI,PYF):'
     &       ,SNGL(RESQUAD/XFCAVE)
      ENDIF !IQUAD

        IF ((FY.GE.0.0.OR.FX+FY.GT.0.0) .AND. IHALBA.NE.0) THEN
         WRITE (LUN1,*)
         WRITE (LUN1,*)'*** WARNING SR TRANPOLY ***'
         WRITE (LUN1,*)
     & 'EQUIVALENT HALBACH WIGGLER CAN NOT BE DETERMINED'
         WRITE (LUN1,*)
      ENDIF

      IF(IHALBA.NE.0) THEN
         WRITE(LUN1,*)
         WRITE(LUN1,*)
     &'     Parameters of equivalent Halbach wiggler, KX**2+KY**2=KZ**2 (complexe),'
         WRITE(LUN1,*)
     &'     coordinates according to Halbach, z-axis is long. axis:'
         WRITE(LUN1,*)
         WRITE(LUN1,*)'     number of periods: ',NPERTRA
         WRITE(LUN1,*)'     RHO [m], ABS(B0) [T]:'
         WRITE(LUN1,*)'     ',SNGL(RHOHAL),SNGL(B0HAL)
         WRITE(LUN1,*)'     LX, LY, LZ, LZ/2 [m]:     '
         WRITE(LUN1,*)'     ',SNGL(XLHAL),SNGL(YLHAL),SNGL(ZLHAL),SNGL(ZLHAL/2.D0)
         WRITE(LUN1,*)'     KX, KY, KZ (complexe) [m]:'
         WRITE(LUN1,*)'     ',XKHALR,XKHALI
         WRITE(LUN1,*)'     ',YKHALR,YKHALI
         WRITE(LUN1,*)'     ',ZKHALR,ZKHALI
         WRITE(LUN1,*)
         WRITE(LUN1,*)

         OPEN(UNIT=LUNH,FILE='wave_wls.dat',STATUS='NEW',FORM='FORMATTED')
         WRITE(LUNH,*)B0HAL,XLHAL,YLHAL,ZLHAL
         CLOSE(LUNH)

         OPEN(UNIT=LUNSTR,FILE='wave_wls.str',STATUS='NEW',FORM='FORMATTED')
         WRITE(LUNSTR,1234)ZLENGE,RHOHAL,-(YLHAL/XLHAL)**2,ZLENGE
1234  FORMAT(' WLS  ID',E14.6,E14.6,E14.6,E14.6)
         WRITE(LUNSTR,1235)(STRAILEN-ZLENGE)/2.D0
1235  FORMAT(' DWLS SD',E14.6,'  0.000000E+00  0.000000E+00  0.000000E+00')
         CLOSE(LUNSTR)

      ENDIF

      IF(IWARNE.EQ.1) THEN
         WRITE(LUN1,*)
         WRITE(LUN1,*)
         WRITE(LUN1,*)'*** WARNING SR TRANPOLY ***'
         WRITE(LUN1,*)
     &'COEFFICIENTS AERZ EXCEEDING ORDER OF GENERATING FUNCTION IGNORED'
         WRITE(LUN1,*)
         WRITE(LUN1,*)
         WRITE(LUN1,*)
         WRITE(6,*)
         WRITE(6,*)
         WRITE(6,*)'*** WARNING SR TRANPOLY ***'
         WRITE(6,*)
     &'COEFFICIENTS AERZ EXCEEDING ORDER OF GENERATING FUNCTION IGNORED'
         WRITE(6,*)
         WRITE(6,*)
         WRITE(6,*)
      ENDIF

      IF(IWARNR.EQ.1) THEN
         WRITE(LUN1,*)
         WRITE(LUN1,*)
         WRITE(LUN1,*)'*** WARNING SR TRANPOLY ***'
         WRITE(LUN1,*)
     &'COEFFICIENTS AREF EXCEEDING ORDER OF GENERATING FUNCTION IGNORED'
         WRITE(LUN1,*)
         WRITE(LUN1,*)
         WRITE(LUN1,*)
         WRITE(6,*)
         WRITE(6,*)
         WRITE(6,*)'*** WARNING SR TRANPOLY ***'
         WRITE(6,*)
     &'COEFFICIENTS AREF EXCEEDING ORDER OF GENERATING FUNCTION IGNORED'
         WRITE(6,*)
         WRITE(6,*)
         WRITE(6,*)
      ENDIF

C7.6.93  WRITE(LUN1,*) '     X closed orbit, PXF close orbit:'
C7.6.93     &               ,SNGL(xclose),SNGL(Pclose)

1000    FORMAT('      ',I4,' ',1P,(4D15.6))
c2000    FORMAT(' ',I3,'   ',1P,(2D17.8))
C3000      FORMAT(' ',I3,5H     ,'a',4I1,1P,(1D17.5))
c3000    FORMAT('      ','a',4I1,1P,(2D20.10),1P,(D10.2),1P,(D20.10),1P,(D10.2))
c3001    FORMAT(' ','a',4I1,1P,(1D20.10),      1P,(D50.10),1P,(D10.2))
c3002    FORMAT(' ','a',4I1,1P,(2D20.10),1P,(D10.2))
c3003    FORMAT(' ','a',4I1,1P1D20.10)
c4000      FORMAT(4I2,'  ',1P,(D27.20))
5000    FORMAT('     ',4F18.13)

C--- OUTPUT COEFFICIENTS SORTED BY ORDER OF GENERATING FUNCTION

      IF(IKOEFF.NE.0) THEN
          WRITE(LUN1,*)
          WRITE(LUN1,*)'     Coefficients of generating function (AKOEFF):'
          WRITE(LUN1,*)
      DO N=2,NORDNG
          WRITE(LUN1,*)
          WRITE(LUN1,*)'     Order of generating function:',N-1
          WRITE(LUN1,*)
          DO I=1,NORDNG
          DO J=1,NORDNG
          DO K=1,NORDNG
          DO L=1,NORDNG
         IF(I-1+J-1+K-1+L-1.EQ.N-1.AND.AKOEFF(I,J,K,L).NE.0.0)
     &      WRITE (LUN1,1236)I-1,J-1,K-1,L-1,AKOEFF(I,J,K,L)
1236     FORMAT('      a',4I1,1PE30.15)
          ENDDO
          ENDDO
          ENDDO
          ENDDO
      ENDDO
      ENDIF

      IF(LUN1.NE.LUNGFO) CLOSE(LUN1)

C---------------------------------------------------------------

      vx0=v0*v0x
      vy0=v0*v0y
      vz0=v0*v0z
      call idtrmshgf(
     &  x0,y0,z0,vx0,vy0,vz0,
     &  x2,y2,z2,vx2,vy2,vz2,
     &  x0,y0,z0,vx0,vy0,vz0,
     &  xf0,yf0,zf0,vxf0,vyf0,vzf0,"wave_tranpoly.ako")

      write(lungfo,*)
      write(lungfo,*)"Closed orbit test at the end of tranpoly:"
      write(lungfo,*)
      write(lungfo,*)"idtrmshgf tracks from:"
      write(lungfo,*)
      write(lungfo,*)x0,y0,z0
      write(lungfo,*)vx0,vy0,vz0
      write(lungfo,*)
      write(lungfo,*)"to:"
      write(lungfo,*)
      write(lungfo,*)x2,y2,z2
      write(lungfo,*)vx2,vy2,vz2
      write(lungfo,*)

      RETURN
      END
+DECK,trasou.
*CMZ :  3.07/00 05/03/2019  13.36.15  by  Michael Scheer
*CMZ :  3.02/00 19/09/2014  10.44.41  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.10.30  by  Michael Scheer
*CMZ :  2.67/02 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.67/01 15/03/2012  17.06.56  by  Michael Scheer
*CMZ :  2.66/00 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.65/03 02/10/2009  13.09.16  by  Michael Scheer
*CMZ :  2.65/02 28/09/2009  12.44.41  by  Michael Scheer
*CMZ :  2.64/01 20/08/2009  11.37.22  by  Michael Scheer
*CMZ :  2.63/05 12/08/2009  08.49.28  by  Michael Scheer
*CMZ :  2.63/03 02/05/2008  14.41.00  by  Michael Scheer
*CMZ :  2.61/02 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  10.48.09  by  Michael Scheer
*CMZ :  2.52/02 08/07/2004  10.00.17  by  Michael Scheer
*CMZ :  2.34/07 16/04/2004  09.24.47  by  Michael Scheer
*CMZ :  2.31/01 24/04/2001  17.59.02  by  Michael Scheer
*CMZ :  2.30/02 12/04/2001  19.11.52  by  Michael Scheer
*CMZ :  2.30/01 12/04/2001  14.52.49  by  Michael Scheer
*CMZ :  2.20/12 11/04/2001  16.39.04  by  Michael Scheer
*CMZ :  2.20/11 11/04/2001  11.00.41  by  Michael Scheer
*CMZ :  2.20/10 10/04/2001  12.05.35  by  Michael Scheer
*CMZ :  2.20/09 03/04/2001  10.08.21  by  Michael Scheer
*CMZ :  2.15/01 30/03/2001  17.09.31  by  Michael Scheer
*CMZ :  2.20/08 18/03/2001  21.50.06  by  Michael Scheer
*CMZ :  2.20/07 18/03/2001  17.08.58  by  Michael Scheer
*CMZ :  2.20/06 15/03/2001  17.20.08  by  Michael Scheer
*CMZ :  2.20/05 15/03/2001  16.57.30  by  Michael Scheer
*CMZ :  2.20/04 09/03/2001  16.47.40  by  Michael Scheer
*CMZ :  2.20/03 23/02/2001  15.04.13  by  Michael Scheer
*CMZ :  2.20/02 21/02/2001  11.30.46  by  Michael Scheer
*CMZ :  2.20/01 20/02/2001  14.18.37  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE TRASOU(ISOUR)
+seq,gplhint.


+SEQ,TRACKF90U.
+SEQ,SOURCEF90U.

C--- EVALUATE INTEGRALES FOR A SINGLE SOURCE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,PHYCON.
+SEQ,TRACK.
+seq,sourcef90.
+SEQ,PRIMKIN.
+SEQ,B0SCGLOB.

      DOUBLE PRECISION X0,X1,X2,Y1,Y2,Z1,Z2,XENDSOU,TLEN
     &  ,T,DT,DT2,DT0,DT01,DTIM01,VXP,VYP,VZP
      DOUBLE PRECISION VX1,VY1,VZ1
      DOUBLE PRECISION VX2,VY2,VZ2,BX2,BY2,BZ2
      DOUBLE PRECISION C1,GAMMA0,GAMMA,DGAMSUM,VN,BETA,DGAMMA

      DOUBLE PRECISION X2B,Y2B,Z2B,AX2D,AY2D,AZ2D

      INTEGER ISOUR,IZAEHL,ICAL,LSTEP,MCOO

      DATA ICAL/0/
      DATA MCOO/0/

      IF (ICAL.EQ.0) THEN
        DTIM01=1.D0/DTIM0
        C1=1.D0/CLIGHT1
      ENDIF !ICAL

      GAMMA0=DMYGAMMA
      GAMMA=GAMMA0
      DGAMSUM=0.0D0

      X1=SOURCEAO(1,1,ISOUR)
      Y1=SOURCEAO(2,1,ISOUR)
      Z1=SOURCEAO(3,1,ISOUR)

      VX1=SOURCEAO(1,2,ISOUR)
      VY1=SOURCEAO(2,2,ISOUR)
      VZ1=SOURCEAO(3,2,ISOUR)

      XENDSOU=SOURCEEO(1,1,ISOUR)    !FINAL X
+self,if=bad. Versuch, unklar warum es nicht funktioniert.
      if (x1.ge.xstart.and.xendsou.le.xstop) then

        ALLOCATE(DWT(nco))
        ALLOCATE(DWX(nco))
        ALLOCATE(DWX2P(nco))
        ALLOCATE(DWB(nco))
        ALLOCATE(DWB2P(nco))
        ALLOCATE(DWY(nco))
        ALLOCATE(DWY2P(nco))
        ALLOCATE(DWZ(nco))
        ALLOCATE(DWZ2P(nco))
        ALLOCATE(TRAGAM(nco))

        mco=nco

        do izaehl=1,mco
          dwt(izaehl)= WTIM0(IZAEHL)
          x2=wtra(1,1,izaehl)
          y2=wtra(2,1,izaehl)
          z2=wtra(3,1,izaehl)
          bx2=wtra(1,3,izaehl)
          by2=wtra(2,3,izaehl)
          bz2=wtra(3,3,izaehl)
          DWB(IZAEHL)=SIGN(SQRT(BX2*BX2+BY2*BY2+BZ2*BZ2),BY2)
          tragam(izaehl)=wtra(1,5,izaehl)
        enddo

        CALL util_spline_coef_F90(DWT,DWX,nco,-9999.0d0,-9999.0d0,DWX2P)
        CALL util_spline_coef_F90(DWT,DWB,nco,-9999.0d0,-9999.0d0,DWB2P)
        CALL util_spline_coef_F90(DWT,DWY,nco,-9999.0d0,-9999.0d0,DWY2P)
        CALL util_spline_coef_F90(DWT,DWZ,nco,-9999.0d0,-9999.0d0,DWZ2P)

        return

      endif !(x1.ge.xstart.and.xendsou.le.xstop) then
+self.
      X0=X1

      TLEN=SOURCET(2,ISOUR)-SOURCET(1,ISOUR)
c 20140918      DT0=TLEN/FLOAT(NCO-1)/FLOAT(NSOURCE)
      DT0=TLEN/FLOAT(nlpoi-1)/float(nsource)
      DTMCO=DT0
      DT01=1.D0/DT0

      MCO=TLEN/DT0+1

      IF (MCOO.EQ.0) THEN

        ALLOCATE(DWT(MCO))
        ALLOCATE(DWX(MCO))
        ALLOCATE(DWX2P(MCO))
        ALLOCATE(DWB(MCO))
        ALLOCATE(DWB2P(MCO))
        ALLOCATE(DWY(MCO))
        ALLOCATE(DWY2P(MCO))
        ALLOCATE(DWZ(MCO))
        ALLOCATE(DWZ2P(MCO))
        ALLOCATE(TRAGAM(MCO))

      ELSE IF (MCOO.LT.MCO) THEN

        DEALLOCATE(DWT)
        DEALLOCATE(DWX)
        DEALLOCATE(DWX2P)
        DEALLOCATE(DWB)
        DEALLOCATE(DWB2P)
        DEALLOCATE(DWY)
        DEALLOCATE(DWY2P)
        DEALLOCATE(DWZ)
        DEALLOCATE(DWZ2P)
        DEALLOCATE(TRAGAM)

        ALLOCATE(DWT(MCO))
        ALLOCATE(DWX(MCO))
        ALLOCATE(DWX2P(MCO))
        ALLOCATE(DWB(MCO))
        ALLOCATE(DWB2P(MCO))
        ALLOCATE(DWY(MCO))
        ALLOCATE(DWY2P(MCO))
        ALLOCATE(DWZ(MCO))
        ALLOCATE(DWZ2P(MCO))
        ALLOCATE(TRAGAM(MCO))

      ENDIF

      T=0.D0

      DT=DT0
      DT2=DT/2.D0

      X2=X1
      Y2=Y1
      Z2=Z1

      VX2=VX1
      VY2=VY1
      VZ2=VZ1

C LOOP OVER TIME STEPS

      IZAEHL=1

      DWT(IZAEHL)=T
      DWX(IZAEHL)=X1
      DWY(IZAEHL)=Y1
      DWZ(IZAEHL)=Z1

C GET MAGNETIC FIELD {

      X2B=X1+VX1*DT2
      Y2B=Y1+VY1*DT2
      Z2B=Z1+VZ1*DT2
      CALL MYBFELD(X2B,Y2B,Z2B,BX2,BY2,BZ2,AX2D,AY2D,AZ2D)

C GET MAGNETIC FIELD }

      DWB(IZAEHL)=SIGN(SQRT(BX2*BX2+BY2*BY2+BZ2*BZ2),BY2)
      TRAGAM(IZAEHL)=GAMMA

      LSTEP=0
1000  IZAEHL=IZAEHL+1

      IF (IZAEHL.EQ.MCO-1) THEN
        DT=(XENDSOU-X2)/VX2
        LSTEP=1
      ENDIF

      X1=X2
      Y1=Y2
      Z1=Z2

      VX1=VX2
      VY1=VY2
      VZ1=VZ2

      T=T+DT

C GET MAGNETIC FIELD {

      X2B=X1+VX1*DT2
      Y2B=Y1+VY1*DT2
      Z2B=Z1+VZ1*DT2
      CALL MYBFELD(X2B,Y2B,Z2B,BX2,BY2,BZ2,AX2D,AY2D,AZ2D)

C GET MAGNETIC FIELD }

C MOVE ONE STEP {

      CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DT,
     &  X2,Y2,Z2,VX2,VY2,VZ2,VXP,VYP,VZP,GAMMA,ICHARGE,BMOVECUT,IUSTEP,IENELOSS,DGAMMA)

      IF (IENELOSS.NE.0) THEN
        DGAMSUM=DGAMSUM+DGAMMA
        IF (ABS(DGAMSUM).GT.GAMMA*1.0D-8) THEN
          GAMMA=GAMMA+DGAMSUM
          DGAMSUM=0.0D0
        ENDIF
        BETA=DSQRT((1.D0-1.D0/GAMMA)*(1.D0+1.D0/GAMMA))
        VN=SQRT(VX2*VX2+VY2*VY2+VZ2*VZ2)
        VX2=VX2/VN*CLIGHT1*BETA
        VY2=VY2/VN*CLIGHT1*BETA
        VZ2=VZ2/VN*CLIGHT1*BETA
      ENDIF

C MOVE ONE STEP }

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION }

C--- END OF LOOP OVER TIME STEPS

      IF (IENELOSS.NE.0) THEN
        DGAMSUM=DGAMSUM+DGAMMA
        GAMMA=GAMMA+DGAMSUM
        DGAMSUM=0.0D0
        BETA=DSQRT((1.D0-1.D0/GAMMA)*(1.D0+1.D0/GAMMA))
        VN=SQRT(VX2*VX2+VY2*VY2+VZ2*VZ2)
        VX2=VX2/VN*CLIGHT1*BETA
        VY2=VY2/VN*CLIGHT1*BETA
        VZ2=VZ2/VN*CLIGHT1*BETA
      ENDIF

      DWT(IZAEHL)=T
      DWX(IZAEHL)=X2
      DWB(IZAEHL)=SIGN(SQRT(BX2*BX2+BY2*BY2+BZ2*BZ2),BY2)
      DWY(IZAEHL)=Y2
      DWZ(IZAEHL)=Z2
      TRAGAM(IZAEHL)=GAMMA

      IF (IZAEHL.LT.MCO.AND.LSTEP.EQ.0)  GOTO 1000
      MCO=IZAEHL

      CALL util_spline_coef_F90(DWT,DWX,MCO,-9999.0d0,-9999.0d0,DWX2P)
      CALL util_spline_coef_F90(DWT,DWB,MCO,-9999.0d0,-9999.0d0,DWB2P)
      CALL util_spline_coef_F90(DWT,DWY,MCO,-9999.0d0,-9999.0d0,DWY2P)
      CALL util_spline_coef_F90(DWT,DWZ,MCO,-9999.0d0,-9999.0d0,DWZ2P)

      MCOO=MCO

      RETURN
      END
+DECK,UNAME.
*CMZ :  4.01/07 09/01/2025  16.06.19  by  Michael Scheer
*CMZ :  4.01/00 12/03/2023  14.28.40  by  Michael Scheer
*CMZ :  3.03/02 17/12/2015  15.39.51  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.63/03 08/12/2010  09.44.42  by  Michael Scheer
*CMZ :  2.63/02 14/03/2008  13.25.04  by  Michael Scheer
*CMZ :  2.62/01 19/04/2007  14.04.56  by  Michael Scheer
*CMZ :  2.62/00 16/04/2007  08.46.55  by  Michael Scheer
*CMZ :  2.61/06 12/04/2007  10.58.57  by  Michael Scheer
*CMZ :  2.61/04 29/03/2007  13.38.15  by  Michael Scheer
*CMZ :  2.61/02 20/03/2007  17.09.22  by  Michael Scheer
*CMZ :  2.61/01 01/02/2007  16.26.46  by  Michael Scheer
*CMZ :  2.58/00 15/01/2007  08.06.19  by  Michael Scheer
*CMZ :  2.57/05 12/12/2006  14.15.16  by  Michael Scheer
*CMZ :  2.56/00 05/10/2005  14.30.35  by  Michael Scheer
*CMZ :  2.54/05 01/06/2005  12.26.15  by  Michael Scheer
*CMZ :  2.54/01 14/03/2005  09.04.14  by  Michael Scheer
*CMZ : 00.00/07 24/05/94  09.53.34  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine uname

+self,if=mrad.
      use mrad_mradmod
      use mrad_lattice
+self.
      implicit none

+self,if=mrad.
      double precision vn,gamma

      integer:: isilent=1,istatus=0,iwritefiles=1
      character(64) :: cbmodel='linear'
      double precision :: strength,vin(3),fint,seclen,posi(7,5),hgap,angle,de,dlength,
     &  edge(2),ebeam,ds

+seq,contrl.
+seq,b0scglob.
+seq,phyconparam.
+seq,caller.

      caller='WAVE'
      kwave_m=1

      icharge_m=icharge
      ds_m=1.0d0/dble(myinum)
      ebeam_m=dmyenergy
      gamma=dmyenergy/emassg1

      emom=emasse1*dsqrt((gamma-1.0d0)*(gamma+1.0d0))
      brho_m=emom/clight1

      vn=sqrt(vxin**2+vyin**2+vzin**2)

      xlat_m=xstart
      zlat_m=zstart

      exlat_m=vxin/vn
      eylat_m=vyin/vn
      ezlat_m=vzin/vn

      call mrad_master(isilent,iwritefiles,istatus)
      call util_break
+self.

      return
      end
+DECK,UNAME_FIT.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.66/07 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.16/08 12/08/2009  08.49.28  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  1.03/06 06/08/98  18.01.12  by  Michael Scheer
*CMZ :  1.00/00 08/07/97  10.51.15  by  Michael Scheer
*CMZ : 00.01/10 02/06/96  12.03.03  by  Michael Scheer
*CMZ : 00.01/06 20/02/95  16.06.18  by  Michael Scheer
*CMZ : 00.01/05 01/02/95  14.05.08  by  Michael Scheer
*CMZ : 00.01/04 30/01/95  17.53.53  by  Michael Scheer
*CMZ : 00.00/07 24/05/94  09.48.27  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE UNAME_FIT
+seq,gplhint.

+SEQ,TRACKF90U,IF=F90.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,TRACK.
+SEQ,MODULATOR.
+SEQ,phycon.
+SEQ,USERVAR.

      INTEGER I
      DOUBLE PRECISION VARFIT(100)

      OPEN(UNIT=99,FILE='UNAME.FIT',STATUS='OLD')
      DO I=1,100
          READ(99,*,END=99)VARFIT(I)
            VARFIT(I)=ASIN(VARFIT(I))*radgra1
      ENDDO
99    CLOSE(99)

      DO I=1,NMAGMOD

          IF (THEROT(I).EQ.11111.) THEN
         THEROT(I)=VARFIT(1)
          else if (THEROT(I).EQ.-11111.) THEN
         THEROT(I)=-VARFIT(1)

          else if (THEROT(I).EQ.22222.) THEN
         THEROT(I)=VARFIT(2)
          else if (THEROT(I).EQ.-22222.) THEN
         THEROT(I)=-VARFIT(2)

          else if (THEROT(I).EQ.33333.) THEN
         THEROT(I)=VARFIT(3)
          else if (THEROT(I).EQ.-33333.) THEN
         THEROT(I)=-VARFIT(3)

          ENDIF

      ENDDO

      RETURN
      END
+DECK,UNCOMNAMELIST.
*CMZ :  2.50/00 23/03/2004  16.37.20  by  Michael Scheer
*CMZ :  2.48/04 16/03/2004  12.51.39  by  Michael Scheer
*CMZ :  2.48/03 03/03/2004  12.49.39  by  Michael Scheer
*CMZ :  2.47/21 03/12/2003  09.13.24  by  Michael Scheer
*CMZ :  2.47/18 27/11/2003  14.41.06  by  Michael Scheer
*-- Author :    Michael Scheer   27/11/2003
      subroutine uncomnamelist
c Program to strip WAVE.IN for WAVE under UNIX

+seq,gplhint.

+SELF,IF=-VMS.

c reads input file wave.tmp, strips comments etc. and writes wave.in.linux

      implicit none

      integer i,j,icr,iblank,iline
      byte ic

      character(132) c132
      character c1

      equivalence(ic,c1)

      data ic/0/

+SELF.
+SELF,IF=LINUX,WINDOWS.
      call system('bin/carriagereturn.exe wave.in wave.tmp')
      call system('rm wave.in.linux')
+SELF,IF=HPUX,TRUE64.
      call system('cp wave.in wave.tmp')
      call system('rm wave.in.linux')
+SELF.

+SELF,IF=-VMS.
      open(unit=21,file='wave.in.linux',status='new')
      open(unit=20,file='wave.tmp',status='old')

      iline=0
1     read(20,'(a132)',end=90)c132

      iline=iline+1

      do i=1,132
        c1=c132(i:i)
        if (ic.ge.65.and.ic.le.90) then
          ic=ic+32
          c132(i:i)=c1
        endif
      enddo
+SELF.
+self,if=LINUX,WINDOWS.
      do i=1,132
        c1=c132(i:i)
        if (ic.eq.13) then !find carriage return (13)
          icr=i-1
          goto 12
          endif
      enddo
12    backspace(20)
      read(20,'(a)',end=90)c132(1:icr)
+self,if=HPUX,TRUE64.
      do i=132,1,-1
        c1=c132(i:i)
        if (ic.ne.32) then !find last space
          icr=i
          goto 12
        endif
      enddo
12    continue
+self.
+SELF,IF=-VMS.

      j=icr
      do i=1,icr
        if (c132(i:i).eq.'!') then
          j=i-1
          goto 10
          endif
        enddo

10    continue

      iblank=1
      do i=1,j
        c1=c132(i:i)
+SELF.
+SELF,IF=LINUX,WINDOWS.
        if (c132(i:i).ne.' '.and.ic.ne.9.) then
+SELF,IF=HPUX,TRUE64.
        if (c132(i:i).ne.' '.and.ic.ne.9.and.ic.ne.13.and.ic.ne.10) then
+SELF.
+SELF,IF=-VMS.
          iblank=0
          goto 20
          endif
        enddo

20    continue

      if (iblank.ne.0) goto 1 !skip blank line

      if (j.lt.icr) then
        write(21,'(a)')c132(1:j)
      else
        write(21,'(a)')c132(1:icr)
      endif

      goto 1   !next line

90    close(20)
      close(21)

+SELF.
      return
      end
+DECK,uout.
*CMZ :  4.01/04 17/10/2023  12.50.02  by  Michael Scheer
*CMZ :  4.01/03 15/05/2023  14.11.27  by  Michael Scheer
*CMZ :  4.00/17 15/11/2022  10.13.07  by  Michael Scheer
*CMZ :  4.00/15 01/06/2022  16.47.26  by  Michael Scheer
*CMZ :  4.00/11 28/06/2021  10.33.06  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine uout

+seq,trackf90u.
+seq,spectf90u.

      use sourcef90
      use observf90
      use afreqf90
      !use waveenv

      implicit none

+self,if=uout_scheer.
      complex*16 amp0(3),amp(3),zexp

      double precision dtelec,dtpho,t0,perlen,dph,dobs(3),drn(3),cosang,
     &  dobsn(3),r0(3),r(3),dr(3),v(3),t,dt,dist,obs(3),om,fd,dist0

      double precision :: enemax=0.0d0,s0max=-1.0d30

      integer ifreq,iobsv,nper,i,lunio,iseed
      integer, parameter :: ndimsplit=100
      integer :: nwords=0, ipos(2,ndimsplit),istat=0,mode=0,io,ifr

      character(2048) cline
+self.
+seq,contrl.
+seq,cmpara.
+seq,track.
+seq,track0.
+seq,spect.
+seq,observ.
+seq,freqs.
+seq,sourcef90.
+seq,berror.
+seq,ampli.
+seq,phycon.
+seq,waveenv.
+seq,uservar.

+self,if=uout_scheer.
      if (iuout.eq.20220601) then
        enemax=spectotmx(3)
        s0max=spectotmx(4)/1.0d6
        open(newunit=lunio,file='uout.in',status='old',iostat=iseed)
        if (iseed.eq.0) then
          read(lunio,*) iseed
        else
          iseed=0
        endif
        close(lunio)
        open(newunit=lunio,file='serie_pherror.out',access='append')
        if (iberror.ne.0) then
          if (nberror.eq.0) then
            write(lunio,*) trim(chwstage)//'-1/2_1_-1/2',iseed,b0error,resrms*360.0d0,
     &        enemax,s0max
          else if (nberror.eq.1) then
            write(lunio,*) trim(chwstage)//'_1_',iseed,b0error,resrms*360.0d0,
     &        enemax,s0max
          else if (nberror.eq.2) then
            write(lunio,*) trim(chwstage)//'-1_1_',iseed,b0error,resrms*360.0d0,
     &        enemax,s0max
          endif
        else
          if (userchar(1).eq.'b0error') then
            write(lunio,*) trim(chwstage)//"_berr",iseed,'-1',user(1),resrms*360.0d0,
     &        enemax,s0max
          else
            write(lunio,*) trim(chwstage)//'_pherr',iseed,'-2',phrerror,resrms*360.0d0,
     &        enemax,s0max
          endif
        endif
        flush(lunio)
        close(lunio)
        return
      endif

      if (iuout.eq.20220516) then
c        s0max=-1.0d30
c        do io=1,nobsv
c          do ifr=1,nfreq
c            if (spectot(io+nobsv*(ifr-1)).gt.s0max) then
c              enemax=freq(ifr)
c              s0max=spectot(io+nobsv*(ifr-1))/1.0d6
c            endif
c          enddo
c        enddo
        enemax=spectotmx(3)
        s0max=spectotmx(4)/1.0d6
        open(newunit=lunio,file='uout.in',status='old',iostat=iseed)
        if (iseed.eq.0) then
          read(lunio,*) iseed
        else
          iseed=0
        endif
        close(lunio)
        open(newunit=lunio,file='serie_b0error.out',access='append')
        write(lunio,'(2I10,4(1pe15.7))') icode,iseed,b0error,resrms*360.0d0,
     &    enemax,s0max
        flush(lunio)
        close(lunio)
        return
      endif

      if (iuout.eq.20220517) then
c        s0max=-1.0d30
c        do io=1,nobsv
c          do ifr=1,nfreq
c            if (spectot(io+nobsv*(ifr-1)).gt.s0max) then
c              enemax=freq(ifr)
c              s0max=spectot(io+nobsv*(ifr-1))/1.0d6
c            endif
c          enddo
c        enddo
        enemax=spectotmx(3)
        s0max=spectotmx(4)/1.0d6
        open(newunit=lunio,file='uout.in',status='old',iostat=iseed)
        if (iseed.eq.0) then
          read(lunio,'(a)') cline
          call util_string_split(cline,ndimsplit,nwords,ipos,istat)
        else
          cline='0 unknown'
        endif
        close(lunio)
        open(newunit=lunio,file='serie_amprep.out',access='append')
        write(lunio,'(I10," ",a," ",3(1pe15.7))') icode,trim(cline),
     &    phrerror,enemax,s0max
        flush(lunio)
        close(lunio)
        return
      endif

      afreq=(0.0d0,0.0d0)
      dtelec=tftrack-t0track

      r0=[x0,y0,z0]
      dr=[xf0-x0,yf0-y0,zf0-z0]
      drn=dr/norm2(dr)

      perlen=norm2(dr)
      dtpho=perlen/clight1

      nper=100

      do iobsv=1,nobsv
        obs=obsv(1:3,iobsv)
        dist0=norm2(obs-r0)
        do ifreq=1,nfreq
          om=freq(ifreq)/hbarev1
          ifrob=iobsv+nobsv*(ifreq-1)
          amp=(0.0d0,0.0d0)
          amp0(1:3)=dcmplx(reaima(1:3,1,ifrob),reaima(1:3,2,ifrob))
          t=-dt
          do i=1-nper/2,nper-nper/2
            r=r0+i*dr
            dobs=obs-r
            dist=norm2(obs-r)
            dobsn=dobs/dist
            cosang=dot_product(drn,dobsn)
            dt=dtelec-dtpho*cosang
            t=t+dt
            dph=om*t
            zexp=cdexp(dcmplx(0.0d0,dph))
            amp=amp+amp0*zexp*dist0/dist
          enddo
          afreq(:,ifrob)=amp
          fd=sum(real(amp)**2+imag(amp)**2)*specnor
          write(66,*)sngl(obsv(:,iobsv)),sngl(freq(ifreq)),
     &      sngl(real(amp(3))),sngl(imag(amp(3))),sngl(fd)
        enddo !ifreq
      enddo !nobsv
+self.
+self,if=ivue32,if=uout_scheer.

+seq,spectf90u.
      use sourcef90
      use observf90

      implicit none
c      include 'uservar.cmn'

+seq,cmpara.
+seq,spect.
+seq,observ.
+seq,sourcef90.

      double precision sou(3),x,y,z,dx,dy,dz,cosa,dxs,dys,dzs

      integer :: iobsv,isour,lun,lunob

      open(newunit=lunob,file='observ.in',status='old',readonly)

      open(newunit=lun,file='ivue32_uout.dat',recl=512)
      write(lun,'(a)')"* Nsour, Nobs, Xsou, Ysou, Zsou, Xobs, Yobs, Zobs, PowPerp, PowGraz ( Watt and mm)"

      do isour=1,nsource

        rewind(lunob)

        do iobsv=1,nobsv

          read(lunob,*) x,y,z,dx,dy,dz

          dxs=obsv(1,iobsv)-schwingercen(1,iobsv,isour)
          dys=obsv(2,iobsv)-schwingercen(2,iobsv,isour)
          dzs=obsv(3,iobsv)-schwingercen(3,iobsv,isour)

          cosa=(dx*dxs+dy*dys+dz*dzs)/
     &      sqrt(dx**2+dy**2+dz**2)/
     &      sqrt(dxs**2+dys**2+dzs**2)

          write(lun,'(2i5,8g15.5)') nsource,iobsv,
     &      schwingercen(1:3,iobsv,isour),obsv(1:3,iobsv)*1000.0,
     &      specpowt(iobsv)/1.0e6,
     &      specpowt(iobsv)/1.0e6*sqrt(1.0d0-min(1.0d0,cosa**2))

        enddo !nobsv

      enddo ! nsource

      flush(lun)
      close(lun)
      close(lunob)

      print*,""
      print*,"     UOUT: ivue32_uout.dat written "
      print*,""
+self.

      return
      end
+DECK,UOUT_FIT.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.16/08 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.13/03 17/12/99  11.45.46  by  Michael Scheer
*CMZ :  1.00/00 10/07/97  13.57.51  by  Michael Scheer
*CMZ : 00.01/10 02/06/96  12.04.24  by  Michael Scheer
*CMZ : 00.01/06 20/02/95  16.06.00  by  Michael Scheer
*CMZ : 00.01/05 01/02/95  15.24.06  by  Michael Scheer
*CMZ : 00.01/04 26/01/95  15.55.24  by  Michael Scheer
*CMZ : 00.00/07 24/05/94  09.48.34  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE UOUT_FIT
+seq,gplhint.

+SEQ,TRACKF90U,IF=F90.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SELF.

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,CMPARA.
+SEQ,TRACK.
+SEQ,USERVAR.
+SEQ,SPECT.
      OPEN(UNIT=99,FILE='UOUT.FIT',STATUS='OLD')
+SELF,IF=-NEWWAVE.
         WRITE(99,*)SPEC(1,1,1)
+SELF,IF=NEWWAVE.
         WRITE(99,*)SPEC(1)
+SELF.
         WRITE(99,*)WTRA2I
         WRITE(99,*)WTRA(2,1,NCO)
         WRITE(99,*)WTRA(3,1,NCO)
         WRITE(99,*)WTRA(2,2,NCO)/WTRA(1,2,NCO)
         WRITE(99,*)WTRA(3,2,NCO)/WTRA(1,2,NCO)
      CLOSE(99)

      RETURN
      END
+DECK,USERASCII.
*CMZ :  4.00/04 06/08/2019  10.50.42  by  Michael Scheer
*CMZ :  3.04/01 27/03/2018  12.56.47  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.61/01 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.52/16 17/01/2005  13.26.00  by  Michael Scheer
*CMZ :  2.48/04 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.48/03 03/03/2004  12.49.39  by  Michael Scheer
*CMZ :  2.46/02 07/03/2003  11.14.26  by  Michael Scheer
*CMZ :  2.41/13 22/08/2002  17.22.10  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.02  by  Michael Scheer
*CMZ :  2.40/03 14/03/2002  16.42.48  by  Michael Scheer
*CMZ :  2.40/02 14/03/2002  15.50.44  by  Michael Scheer
*CMZ :  2.40/00 11/03/2002  19.04.35  by  Michael Scheer
*CMZ :  2.39/00 14/12/2001  18.49.49  by  Michael Scheer
*CMZ :  2.37/00 09/11/2001  11.03.31  by  Michael Scheer
*CMZ :  2.20/01 17/01/2001  11.56.16  by  Michael Scheer
*CMZ :  2.16/08 31/10/2000  14.25.16  by  Michael Scheer
*CMZ :  2.16/05 24/08/2000  12.55.21  by  Michael Scheer
*CMZ :  2.16/04 20/07/2000  15.49.30  by  Michael Scheer
*CMZ :  1.00/00 30/09/97  11.30.53  by  Michael Scheer
*CMZ : 00.01/07 28/02/95  12.32.01  by  Michael Scheer
*CMZ : 00.01/05 01/02/95  15.24.06  by  Michael Scheer
*CMZ : 00.01/04 26/01/95  15.55.24  by  Michael Scheer
*CMZ : 00.00/07 24/05/94  09.48.34  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE USERASCII
+seq,gplhint.

C WRITE USER ASCII-FILES

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,OBSERVF90U.
+SEQ,TRACKF90U.
+SELF.

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,CMPARA.
+SEQ,TRACK.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.

      INTEGER I,IFREQ,IY,IZ,IO,I1
      INTEGER IGETLASTCHAR,IGETFIRSTCHAR
      REAL A,B,C,D,E,F
      CHARACTER C1
      CHARACTER(16) C16
      CHARACTER(72) CLINE,FILE

      EXTERNAL IGETLASTCHAR,IGETFIRSTCHAR

C TRAJECTORY
      OPEN(UNIT=99,FILE='trajectory.wva')
      IF (IHISASCII.GT.0) THEN
        cline=""
        CLINE(1:1)=CHISASCII
        CLINE(2:2)=' '
        WRITE(CLINE(3:10),'(I8)')ICODE
        CLINE=CLINE(1:10)//' | '//CODE
        write(99,'(a)')cline
        write(99,'(a)')chisascii //
     &    ' Trajectory and mag. field X,Y,Z,BX,BY,BZ [m,T]'
        cline(3:72)=""
        WRITE(CLINE(3:10),'(I8)') nco
        write(99,'(a)')cline
      ENDIF
      DO I=1,NCO
        A=WSXYZ(1,I)
        B=WSXYZ(2,I)
        C=WSXYZ(3,I)
        D=WBXYZ(1,I)
        E=WBXYZ(2,I)
        F=WBXYZ(3,I)
        WRITE(99,'(6(1PE14.6))') A,B,C,D,E,F
      ENDDO !NCO
      CLOSE(99)

C STOKES SINGLE POINT
      OPEN(UNIT=99,FILE='stokes_point.wva')
      IF (IHISASCII.GT.0) THEN
        CLINE(1:1)=CHISASCII
        CLINE(2:2)=' '
        WRITE(CLINE(3:10),'(I8)')ICODE
        CLINE=CLINE(1:10)//' | '//CODE
        write(99,'(a)')cline
        write(99,'(a)')chisascii //
     &    ' S0,S1,S2,S3 [ev, phot/s/BW/mm**2]'
        cline(3:72)=""
        WRITE(CLINE(3:10),'(I8)')nfreq
        write(99,'(a)')cline
      ENDIF
      DO I=1,NFREQ
        A=FREQ(I)
        IF (ISTOKES.NE.0) THEN
          B=STOKEC(1,I)*1.E-6
          C=STOKEC(2,I)*1.E-6
          D=STOKEC(3,I)*1.E-6
          E=STOKEC(4,I)*1.E-6
        ELSE
          B=0.0
          C=0.0
          D=0.0
          E=0.0
        ENDIF
        WRITE(99,'(5(1PE14.6))') A,B,C,D,E
      ENDDO !NFREQ
      CLOSE(99)

C STOKES SINGLE POINT (FOLDED)
      OPEN(UNIT=99,FILE='stokes_point_emittance.wva')
      IF (IHISASCII.GT.0) THEN
        CLINE(1:1)=CHISASCII
        CLINE(2:2)=' '
        WRITE(CLINE(3:10),'(I8)')ICODE
        CLINE=CLINE(1:10)//' | '//CODE
        write(99,'(a)')cline
        write(99,'(a)')chisascii //
     &    ' S0,S1,S2,S3 (with emittance) [ev, phot/s/BW/mm**2]'
        cline(3:72)=""
        WRITE(CLINE(3:10),'(I8)')nfreq
        write(99,'(a)')cline
      ENDIF
      DO I=1,NFREQ
        A=FREQ(I)
        IF (ISTOKES.NE.0.AND.IFOLD.NE.0) THEN
          B=STOKECF(1,I)*1.E-6
          C=STOKECF(2,I)*1.E-6
          D=STOKECF(3,I)*1.E-6
          E=STOKECF(4,I)*1.E-6
        ELSE
          B=0.0
          C=0.0
          D=0.0
          E=0.0
        ENDIF
        WRITE(99,'(5(1PE14.6))') A,B,C,D,E
      ENDDO !NFREQ
      CLOSE(99)

C STOKES SINGLE POINT (E-FOLDED)
      OPEN(UNIT=99,FILE='stokes_point_espread.wva')
      IF (IHISASCII.GT.0) THEN
        CLINE(1:1)=CHISASCII
        CLINE(2:2)=' '
        WRITE(CLINE(3:10),'(I8)')ICODE
        CLINE=CLINE(1:10)//' | '//CODE
        write(99,'(a)')cline
        write(99,'(a)')chisascii //
     &    ' S0,S1,S2,S3 (with beam energy spread) [ev, phot/s/BW/mm**2]'
        cline(3:72)=""
        WRITE(CLINE(3:10),'(I8)')nfreq
        write(99,'(a)')cline
      ENDIF
      DO I=1,NFREQ
        A=FREQ(I)
        IF (ISTOKES.NE.0.AND.IEFOLD.NE.0) THEN
          B=STOKECE(1,I)*1.E-6
          C=STOKECE(2,I)*1.E-6
          D=STOKECE(3,I)*1.E-6
          E=STOKECE(4,I)*1.E-6
        ELSE
          B=0.0
          C=0.0
          D=0.0
          E=0.0
        ENDIF
        WRITE(99,'(5(1PE14.6))') A,B,C,D,E
      ENDDO !NFREQ
      CLOSE(99)

C STOKES SINGLE POINT (EF)
      OPEN(UNIT=99
     &  ,FILE='stokes_point_emittance_espread.wva')
      IF (IHISASCII.GT.0) THEN
        CLINE(1:1)=CHISASCII
        CLINE(2:2)=' '
        WRITE(CLINE(3:10),'(I8)')ICODE
        CLINE=CLINE(1:10)//' | '//CODE
        write(99,'(a)')cline
        write(99,'(a)')chisascii //
     &    ' S0,S1,S2,S3 (with emittance and energy spread) [ev, phot/s/BW/mm**2]'
        cline(3:72)=""
        WRITE(CLINE(3:10),'(I8)')nfreq
        write(99,'(a)')cline
      ENDIF
      DO I=1,NFREQ
        A=FREQ(I)
        IF (ISTOKES.NE.0.AND.IFOLD.NE.0.AND.IEFOLD.NE.0) THEN
          B=STOKECEF(1,I)*1.E-6
          C=STOKECEF(2,I)*1.E-6
          D=STOKECEF(3,I)*1.E-6
          E=STOKECEF(4,I)*1.E-6
        ELSE
          B=0.0
          C=0.0
          D=0.0
          E=0.0
        ENDIF
        WRITE(99,'(5(1PE14.6))') A,B,C,D,E
      ENDDO !NFREQ
      CLOSE(99)

C BRILLIANCE
      OPEN(UNIT=99,FILE='stokes_brilliance.wva')
      IF (IHISASCII.GT.0) THEN
        CLINE(1:1)=CHISASCII
        CLINE(2:2)=' '
        WRITE(CLINE(3:10),'(I8)')ICODE
        CLINE=CLINE(1:10)//' | '//CODE
        write(99,'(a)')cline
        write(99,'(a)')chisascii //
     &    ' Brilliance of S0,S1,S2,S3 [ev, phot/s/BW/mm**2/mrad**2]'
        cline(3:72)=""
        WRITE(CLINE(3:10),'(I8)')nfreq
        write(99,'(a)')cline
      ENDIF
      DO I=1,NFREQ
        A=FREQ(I)
        IF (IBRILL.NE.0) THEN
          B=BRILLC(1,I)*1.E-12
          C=BRILLC(2,I)*1.E-12
          D=BRILLC(3,I)*1.E-12
          E=BRILLC(4,I)*1.E-12
        ELSE
          B=0.0
          C=0.0
          D=0.0
          E=0.0
        ENDIF
        WRITE(99,'(5(1PE14.6))') A,B,C,D,E
      ENDDO !NFREQ
      CLOSE(99)

C BRILLIANCE (folded)
      OPEN(UNIT=99,FILE='stokes_brilliance_emittance.wva')
      IF (IHISASCII.GT.0) THEN
        CLINE(1:1)=CHISASCII
        CLINE(2:2)=' '
        WRITE(CLINE(3:10),'(I8)')ICODE
        CLINE=CLINE(1:10)//' | '//CODE
        write(99,'(a)')cline
        write(99,'(a)')chisascii //
     &    ' Brilliance of S0,S1,S2,S3 (with emittance) [ev, phot/s/BW/mm**2/mrad**2]'
        cline(3:72)=""
        WRITE(CLINE(3:10),'(I8)')nfreq
        write(99,'(a)')cline
      ENDIF
      DO I=1,NFREQ
        A=FREQ(I)
        IF (IBRILL.NE.0.AND.IFOLD.NE.0) THEN
          B=BRILLCF(1,I)*1.E-12
          C=BRILLCF(2,I)*1.E-12
          D=BRILLCF(3,I)*1.E-12
          E=BRILLCF(4,I)*1.E-12
        ELSE
          B=0.0
          C=0.0
          D=0.0
          E=0.0
        ENDIF
        WRITE(99,'(5(1PE14.6))') A,B,C,D,E
      ENDDO !NFREQ
      CLOSE(99)

C BRILLIANCE (e-spread)
      OPEN(UNIT=99,FILE='stokes_brilliance_espread.wva')
      IF (IHISASCII.GT.0) THEN
        CLINE(1:1)=CHISASCII
        CLINE(2:2)=' '
        WRITE(CLINE(3:10),'(I8)')ICODE
        CLINE=CLINE(1:10)//' | '//CODE
        write(99,'(a)')cline
        write(99,'(a)')chisascii //
     &    ' Brilliance of S0,S1,S2,S3 (with energy spread) [ev, phot/s/BW/mm**2/mrad**2]'
        cline(3:72)=""
        WRITE(CLINE(3:10),'(I8)')nfreq
        write(99,'(a)')cline
      ENDIF
      DO I=1,NFREQ
        A=FREQ(I)
        IF (IBRILL.NE.0.AND.IEFOLD.NE.0) THEN
          B=BRILLCE(1,I)*1.E-12
          C=BRILLCE(2,I)*1.E-12
          D=BRILLCE(3,I)*1.E-12
          E=BRILLCE(4,I)*1.E-12
        ELSE
          B=0.0
          C=0.0
          D=0.0
          E=0.0
        ENDIF
        WRITE(99,'(5(1PE14.6))') A,B,C,D,E
      ENDDO !NFREQ
      CLOSE(99)

C BRILLIANCE (emittance, e-spread)
      OPEN(UNIT=99,FILE='stokes_brilliance_emittance_espread.wva')

      IF (IHISASCII.GT.0) THEN
        CLINE(1:1)=CHISASCII
        CLINE(2:2)=' '
        WRITE(CLINE(3:10),'(I8)')ICODE
        CLINE=CLINE(1:10)//' | '//CODE
        write(99,'(a)')cline
        write(99,'(a)')chisascii //
     &    ' Brilliance of S0,S1,S2,S3 (w. emit. and e-spread) [ev, phot/s/BW/mm**2/mrad**2]'
        cline(3:72)=""
        WRITE(CLINE(3:10),'(I8)')nfreq
        write(99,'(a)')cline
      ENDIF
      DO I=1,NFREQ
        A=FREQ(I)
        IF (IBRILL.NE.0.AND.IEFOLD.NE.0) THEN
          B=BRILLCEF(1,I)*1.E-12
          C=BRILLCEF(2,I)*1.E-12
          D=BRILLCEF(3,I)*1.E-12
          E=BRILLCEF(4,I)*1.E-12
        ELSE
          B=0.0
          C=0.0
          D=0.0
          E=0.0
        ENDIF
        WRITE(99,'(5(1PE14.6))') A,B,C,D,E
      ENDDO !NFREQ
      CLOSE(99)

C STOKES PINHOLE
      OPEN(UNIT=99,FILE='stokes_pinhole.wva')

      IF (IHISASCII.GT.0) THEN
        CLINE(1:1)=CHISASCII
        CLINE(2:2)=' '
        WRITE(CLINE(3:10),'(I8)')ICODE
        CLINE=CLINE(1:10)//' | '//CODE
        write(99,'(a)')cline
        write(99,'(a)')chisascii //
     &    ' S0,S1,S2,S3 [ev, phot/s/BW]'
        cline(3:72)=""
        WRITE(CLINE(3:10),'(I8)')nfreq
        write(99,'(a)')cline
      ENDIF
      DO I=1,NFREQ
        A=FREQ(I)
        IF (ISTOKES.NE.0) THEN
          B=WSTOKES(1,I)
          C=WSTOKES(2,I)
          D=WSTOKES(3,I)
          E=WSTOKES(4,I)
        ELSE
          B=0.0
          C=0.0
          D=0.0
          E=0.0
        ENDIF
        WRITE(99,'(5(1PE14.6))') A,B,C,D,E
      ENDDO !NFREQ
      CLOSE(99)

C STOKES (FOLDED)
      OPEN(UNIT=99,FILE='stokes_pinhole_emittance.wva')
      IF (IHISASCII.GT.0) THEN
        CLINE(1:1)=CHISASCII
        CLINE(2:2)=' '
        WRITE(CLINE(3:10),'(I8)')ICODE
        CLINE=CLINE(1:10)//' | '//CODE
        write(99,'(a)')cline
        write(99,'(a)')chisascii //
     &    ' S0,S1,S2,S3 (with emittance) [ev, phot/s/BW]'
        cline(3:72)=""
        WRITE(CLINE(3:10),'(I8)')nfreq
        write(99,'(a)')cline
      ENDIF
      DO I=1,NFREQ
        A=FREQ(I)
        IF (ISTOKES.NE.0.AND.IFOLD.NE.0) THEN
          B=WSTOKESF(1,I)
          C=WSTOKESF(2,I)
          D=WSTOKESF(3,I)
          E=WSTOKESF(4,I)
        ELSE
          B=0.0
          C=0.0
          D=0.0
          E=0.0
        ENDIF
        WRITE(99,'(5(1PE14.6))') A,B,C,D,E
      ENDDO !NFREQ
      CLOSE(99)

C STOKES (E-FOLDED)
      OPEN(UNIT=99,FILE='stokes_pinhole_espread.wva')
      IF (IHISASCII.GT.0) THEN
        CLINE(1:1)=CHISASCII
        CLINE(2:2)=' '
        WRITE(CLINE(3:10),'(I8)')ICODE
        CLINE=CLINE(1:10)//' | '//CODE
        write(99,'(a)')cline
        write(99,'(a)')chisascii //
     &    ' S0,S1,S2,S3 (with beam energy spread) [ev, phot/s/BW]'
        cline(3:72)=""
        WRITE(CLINE(3:10),'(I8)')nfreq
        write(99,'(a)')cline
      ENDIF
      DO I=1,NFREQ
        A=FREQ(I)
        IF (ISTOKES.NE.0.AND.IEFOLD.NE.0) THEN
          B=WSTOKESE(1,I)
          C=WSTOKESE(2,I)
          D=WSTOKESE(3,I)
          E=WSTOKESE(4,I)
        ELSE
          B=0.0
          C=0.0
          D=0.0
          E=0.0
        ENDIF
        WRITE(99,'(5(1PE14.6))') A,B,C,D,E
      ENDDO !NFREQ
      CLOSE(99)

C STOKES (EF)
      OPEN(UNIT=99
     &  ,FILE='stokes_pinhole_emittance_espread.wva')
      IF (IHISASCII.GT.0) THEN
        CLINE(1:1)=CHISASCII
        CLINE(2:2)=' '
        WRITE(CLINE(3:10),'(I8)')ICODE
        CLINE=CLINE(1:10)//' | '//CODE
        write(99,'(a)')cline
        write(99,'(a)')chisascii //
     &    ' S0,S1,S2,S3 (with emittance and energy spread) [ev, phot/s/BW]'
        cline(3:72)=""
        WRITE(CLINE(3:10),'(I8)')nfreq
        write(99,'(a)')cline
      ENDIF
      DO I=1,NFREQ
        A=FREQ(I)
        IF (ISTOKES.NE.0.AND.IFOLD.NE.0.AND.IEFOLD.NE.0) THEN
          B=WSTOKESEF(1,I)
          C=WSTOKESEF(2,I)
          D=WSTOKESEF(3,I)
          E=WSTOKESEF(4,I)
        ELSE
          B=0.0
          C=0.0
          D=0.0
          E=0.0
        ENDIF
        WRITE(99,'(5(1PE14.6))') A,B,C,D,E
      ENDDO !NFREQ
      CLOSE(99)

      if (ipin.ne.0) then

C STOKES DISTRIBUTION IN PINHOLE
      DO IFREQ=1,NFREQ
        WRITE(C16,*)IFREQ
        I=IGETLASTCHAR(1,16,C16,C1)
        I1=IGETFIRSTCHAR(1,16,C16,C1)
        IF (IFREQ.EQ.1) THEN
          FILE='stokes_dist_'//C16(I1:I)//'st_energy.wva'
        ELSE IF (IFREQ.EQ.2) THEN
          FILE='stokes_dist_'//C16(I1:I)//'nd_energy.wva'
        ELSE IF (IFREQ.EQ.3) THEN
          FILE='stokes_dist_'//C16(I1:I)//'rd_energy.wva'
        ELSE
          FILE='stokes_dist_'//C16(I1:I)//'th_energy.wva'
        ENDIF
        OPEN(UNIT=99,FILE=FILE)
        IF (IHISASCII.GT.0) THEN
          CLINE(1:1)=CHISASCII
          CLINE(2:2)=' '
          WRITE(CLINE(3:10),'(I8)')ICODE
          CLINE=CLINE(1:10)//' | '//CODE
          write(99,'(a)')cline
          write(99,'(a)')chisascii //
     &      ' Z,Y,S0,S1,S2,S3 [mm, phot/s/BW/mm**2]'
          cline(3:72)=""
          write(cline(3:72),*)chisascii //' photon energy: ',SNGL(FREQ(IFREQ))
          write(99,'(a)')cline
        ENDIF

        DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
          DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ

            IO=(IY-1)*NOBSVZ+IZ
            I=IO+NOBSV*(IFREQ-1)
            A=OBSV(3,IO)*1.E3
            B=OBSV(2,IO)*1.E3
            IF (ISTOKES.NE.0) THEN
              C=STOKES(1,I)*1.E-6
              D=STOKES(2,I)*1.E-6
              E=STOKES(3,I)*1.E-6
              F=STOKES(4,I)*1.E-6
            ELSE
              C=0.0
              D=0.0
              E=0.0
              F=0.0
            ENDIF
            WRITE(99,'(6(1PE14.6))') A,B,C,D,E,F
          ENDDO   !IZ
        ENDDO  !IY
        CLOSE(99)
      ENDDO !NFREQ

C STOKES DISTRIBUTION IN PINHOLE (FOLDED)
      DO IFREQ=1,NFREQ
        WRITE(C16,*)IFREQ
        I=IGETLASTCHAR(1,16,C16,C1)
        I1=IGETFIRSTCHAR(1,16,C16,C1)
        IF (IFREQ.EQ.1) THEN
          FILE='stokes_dist_emittance_'//C16(I1:I)//'st_energy.wva'
        ELSE IF (IFREQ.EQ.2) THEN
          FILE='stokes_dist_emittance_'//C16(I1:I)//'nd_energy.wva'
        ELSE IF (IFREQ.EQ.3) THEN
          FILE='stokes_dist_emittance_'//C16(I1:I)//'rd_energy.wva'
        ELSE
          FILE='stokes_dist_emittance_'//C16(I1:I)//'th_energy.wva'
        ENDIF
        OPEN(UNIT=99,FILE=FILE)
        IF (IHISASCII.GT.0) THEN
          CLINE(1:1)=CHISASCII
          CLINE(2:2)=' '
          WRITE(CLINE(3:10),'(I8)')ICODE
          CLINE=CLINE(1:10)//' | '//CODE
          write(99,'(a)')cline
          write(99,'(a)')chisascii //
     &      ' Z,Y,S0,S1,S2,S3 (with emittance) [mm, phot/s/BW/mm**2]'
          cline(3:72)=""
          write(cline(3:72),*)chisascii //' photon energy: ',SNGL(FREQ(IFREQ))
          write(99,'(a)')cline
        ENDIF

        DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
          DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
            IO=(IY-1)*NOBSVZ+IZ
            I=IO+NOBSV*(IFREQ-1)
            A=OBSV(3,IO)*1.E3
            B=OBSV(2,IO)*1.E3
            IF (ISTOKES.NE.0.AND.IFOLD.NE.0) THEN
              C=STOKESF(1,I)*1.E-6
              D=STOKESF(2,I)*1.E-6
              E=STOKESF(3,I)*1.E-6
              F=STOKESF(4,I)*1.E-6
            ELSE
              C=0.0
              D=0.0
              E=0.0
              F=0.0
            ENDIF
            WRITE(99,'(6(1PE14.6))') A,B,C,D,E,F
          ENDDO   !IZ
        ENDDO  !IY
        CLOSE(99)
      ENDDO !NFREQ

C IRRADIATED POWER DISTRIBUTION IN PINHOLE
      FILE='irradiated_power_dist.wva'
      OPEN(UNIT=99,FILE=FILE)
      IF (IHISASCII.GT.0) THEN
        CLINE(1:1)=CHISASCII
        CLINE(2:2)=' '
        WRITE(CLINE(3:10),'(I8)')ICODE
        CLINE=CLINE(1:10)//' | '//CODE
        write(99,'(a)')cline
        write(99,'(a)')chisascii //
     &    ' Z,Y,totally irradiated power-density [mm, W/mm**2]'
      ENDIF

      DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
        DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
          IO=(IY-1)*NOBSVZ+IZ
          A=OBSV(3,IO)*1.E3
          B=OBSV(2,IO)*1.E3
          C=SPECPOWT(IO)*1.E-6
          WRITE(99,'(3(1PE14.6))') A,B,C
        ENDDO  !IZ
      ENDDO !IY
      CLOSE(99)

C POWER DISTRIBUTION IN PINHOLE
      FILE='power_dist.wva'
      OPEN(UNIT=99,FILE=FILE)
      IF (IHISASCII.GT.0) THEN
        CLINE(1:1)=CHISASCII
        CLINE(2:2)=' '
        WRITE(CLINE(3:10),'(I8)')ICODE
        CLINE=CLINE(1:10)//' | '//CODE
        write(99,'(a)')cline
        write(99,'(a)')chisascii //
     &' Z,Y,power-density (from spectrum) [mm, W/mm**2]'
      ENDIF

      DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
        DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
          IO=(IY-1)*NOBSVZ+IZ
          A=OBSV(3,IO)*1.E3
          B=OBSV(2,IO)*1.E3
          C=SPECTOTI(IO)*1.E-6
          WRITE(99,'(3(1PE14.6))') A,B,C
        ENDDO  !IZ
      ENDDO !IY
      CLOSE(99)

C POWER DISTRIBUTION IN PINHOLE (folded)
      FILE='power_dist_emittance.wva'
      OPEN(UNIT=99,FILE=FILE)
      IF (IHISASCII.GT.0) THEN
        CLINE(1:1)=CHISASCII
        CLINE(2:2)=' '
        WRITE(CLINE(3:10),'(I8)')ICODE
        CLINE=CLINE(1:10)//' | '//CODE
        write(99,'(a)')cline
        write(99,'(a)')chisascii //
     &    ' Z,Y,power-density (from spectrum, with emittance) [mm, W/mm**2]'
      ENDIF

      DO IY=(NOBSVY-MOBSVY)/2+1,(NOBSVY-MOBSVY)/2+MOBSVY
        DO IZ=(NOBSVZ-MOBSVZ)/2+1,(NOBSVZ-MOBSVZ)/2+MOBSVZ
          IO=(IY-1)*NOBSVZ+IZ
          A=OBSV(3,IO)*1.E3
          B=OBSV(2,IO)*1.E3
          IF (IFOLD.NE.0) THEN
            C=SPECTOTIF(IO)*1.E-6
          ELSE
            C=0.0
          ENDIF
          WRITE(99,'(3(1PE14.6))') A,B,C
        ENDDO  !IZ
      ENDDO !IY
      CLOSE(99)

C STOKES DISTRIBUTION IN PINHOLE
      DO IFREQ=1,NFREQ

        WRITE(C16,*)IFREQ
        I=IGETLASTCHAR(1,16,C16,C1)
        I1=IGETFIRSTCHAR(1,16,C16,C1)
        IF (IFREQ.EQ.1) THEN
          FILE='stokes_dist_espread_'//C16(I1:I)//'st_energy.wva'
        ELSE IF (IFREQ.EQ.2) THEN
          FILE='stokes_dist_espread_'//C16(I1:I)//'nd_energy.wva'
        ELSE IF (IFREQ.EQ.3) THEN
          FILE='stokes_dist_espread_'//C16(I1:I)//'rd_energy.wva'
        ELSE
          FILE='stokes_dist_espread_'//C16(I1:I)//'th_energy.wva'
        ENDIF
        OPEN(UNIT=99,FILE=FILE)
        IF (IEFOLD.NE.0) THEN
          IF (IHISASCII.GT.0) THEN
            CLINE(1:1)=CHISASCII
            CLINE(2:2)=' '
            WRITE(CLINE(3:10),'(I8)')ICODE
            CLINE=CLINE(1:10)//' | '//CODE
            write(99,'(a)')cline
            write(99,'(a)')chisascii //
     &        ' Z,Y,S0,S1,S2,S3 (with e-spread) [mm, phot/s/BW/mm**2]'
            cline(3:72)=""
            write(cline(3:72),*)chisascii //' photon energy: ',SNGL(FREQ(IFREQ))
            write(99,'(a)')cline
          ENDIF

          DO IO=1,NOBSV

            I=IO+NOBSV*(IFREQ-1)

            A=OBSV(3,IO)*1.E3
            B=OBSV(2,IO)*1.E3

            C=STOKESE(1,I)*1.E-6
            D=STOKESE(2,I)*1.E-6
            E=STOKESE(3,I)*1.E-6
            F=STOKESE(4,I)*1.E-6

            WRITE(99,'(6(1PE14.6))') A,B,C,D,E,F

          ENDDO   !NOBSV

        ENDIF !IEFOLD

        CLOSE(99)

      ENDDO !NFREQ

      DO IFREQ=1,NFREQ

        WRITE(C16,*)IFREQ
        I=IGETLASTCHAR(1,16,C16,C1)
        I1=IGETFIRSTCHAR(1,16,C16,C1)
        IF (IFREQ.EQ.1) THEN
          FILE='stokes_dist_emittance_espread_'//C16(I1:I)//'st_energy.wva'
        ELSE IF (IFREQ.EQ.2) THEN
          FILE='stokes_dist_emittance_espread_'//C16(I1:I)//'nd_energy.wva'
        ELSE IF (IFREQ.EQ.3) THEN
          FILE='stokes_dist_emittance_espread_'//C16(I1:I)//'rd_energy.wva'
        ELSE
          FILE='stokes_dist_emittance_espread_'//C16(I1:I)//'th_energy.wva'
        ENDIF
        OPEN(UNIT=99,FILE=FILE)

        IF (IFOLD.NE.0.AND.IEFOLD.NE.0) THEN

          IF (IHISASCII.GT.0) THEN
            CLINE(1:1)=CHISASCII
            CLINE(2:2)=' '
            WRITE(CLINE(3:10),'(I8)')ICODE
            CLINE=CLINE(1:10)//' | '//CODE
            write(99,'(a)')cline
            write(99,'(a)')chisascii //
     &        ' Z,Y,S0,S1,S2,S3 (with emittance and e-spread) [mm, phot/s/BW/mm**2]'
            cline(3:72)=""
            write(cline(3:72),*)chisascii //' photon energy: ',SNGL(FREQ(IFREQ))
            write(99,'(a)')cline
          ENDIF

          DO IO=1,NOBSV

            I=IO+NOBSV*(IFREQ-1)

            A=OBSV(3,IO)*1.E3
            B=OBSV(2,IO)*1.E3

            C=STOKESEF(1,I)*1.E-6
            D=STOKESEF(2,I)*1.E-6
            E=STOKESEF(3,I)*1.E-6
            F=STOKESEF(4,I)*1.E-6

            WRITE(99,'(6(1PE14.6))') A,B,C,D,E,F

          ENDDO   !NOBSV

        ENDIF !IFOLD, IEFOLD

        CLOSE(99)

      ENDDO !NFREQ

      endif !(ipin.ne.0 then

      RETURN
      END
+DECK,USMCON2.
*CMZ :  4.00/07 09/01/2020  13.42.39  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.16/08 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.33  by  Michael Scheer
*CMZ :  2.15/00 04/05/2000  15.26.42  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.18.48  by  Michael Scheer
*CMZ :  2.13/03 12/01/2000  16.31.33  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  14.47.16  by  Michael Scheer
*CMZ : 00.02/04 24/02/97  12.37.50  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  10.13.39  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.55.37  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.54  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE USMCON2
      STOP "USEM is OBSOLETE"
      RETURN
      END
+DECK,UTIL_CHECK_GFLOAT.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.48/04 12/03/2004  15.40.31  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  2.13/11 22/03/2000  14.54.41  by  Michael Scheer
*CMZ : 00.01/06 21/02/95  15.13.11  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE UTIL_CHECK_GFLOAT(IGFLOAT)
+seq,gplhint.

C--- FLAG IGFLOAT IS SET TO ONE IF ROUTINE IS COMPILED WITH G_FLOAT OPTION

+SELF,IF=VMS.
      IMPLICIT NONE

      DOUBLE PRECISION G
      INTEGER IGFLOAT

      DATA G/1./

      CALL UTIL_CHECK_GFLOAT_1(G,IGFLOAT)

+SELF,IF=LINUX,WINDOWS,HPUX,TRUE64.
      INTEGER IGFLOAT
+SELF.

      RETURN
      END
+DECK,UTIL_CHECK_GFLOAT_1.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.48/04 12/03/2004  15.40.31  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.13/11 22/03/2000  14.54.41  by  Michael Scheer
*CMZ :  1.00/00 23/05/97  11.54.46  by  Michael Scheer
*CMZ : 00.01/06 21/02/95  15.13.11  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE UTIL_CHECK_GFLOAT_1(G,IGFLOAT)
+seq,gplhint.

+SELF,IF=VMS.
      REAL*4 G,GG
      INTEGER J,JCOMP,IGFLOAT

      EQUIVALENCE(GG,J)

      DATA JCOMP/16512/

      GG=G

      IF (J.EQ.JCOMP) THEN
         IGFLOAT=0
      ELSE
         IGFLOAT=1
      ENDIF

+SELF,IF=LINUX,WINDOWS,HPUX,TRUE64.
      REAL*4 G
      INTEGER IGFLOAT
+SELF.
      RETURN
      END
+DECK,UTIL_DETERMINANTE.
*CMZ : 00.00/01 05/06/96  16.08.05  by  Michael Scheer
*-- Author :    Michael Scheer   03/06/96

      SUBROUTINE UTIL_DETERMINANTE(NDIM,A,DET,IFAIL)

C CALCULATES DETERMINANT OF MATRIX A

      IMPLICIT NONE

      INTEGER IFAIL,NDIM,NWORKP,JFAIL,I,J

      PARAMETER (NWORKP=128)

      REAL*8 STORE(NWORKP,NWORKP)
      REAL*8 A(NDIM,NDIM),DET
      INTEGER IWS(2*NWORKP)


      IFAIL=0
      DET=0.D0

      IF (NDIM.GT.NWORKP) THEN
          WRITE(6,*)'*** ERROR: DIMENSION EXCEEDED IN UTIL_DETER ***'
          IFAIL=99
          RETURN
      ENDIF

      DO I=1,NDIM
      DO J=1,NDIM
          STORE(J,I)=A(J,I)
      ENDDO
      ENDDO

      CALL DFACT(NDIM,A,NDIM,IWS,IFAIL,DET,JFAIL)

      IF (JFAIL.NE.0.OR.IFAIL.NE.0) IFAIL=10*JFAIL+IFAIL

      DO I=1,NDIM
      DO J=1,NDIM
          A(J,I)=STORE(J,I)
      ENDDO
      ENDDO

      RETURN
      END
+DECK,UTIL_FOLD_FOURIER.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.63/03 02/05/2008  14.41.00  by  Michael Scheer
*CMZ :  2.15/00 08/05/2000  22.57.47  by  Michael Scheer
*CMZ :  2.14/02 27/04/2000  17.53.26  by  Michael Scheer
*CMZ :  2.13/10 14/04/2000  17.16.53  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.25.29  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE UTIL_FOLD_FOURIER
     &  (X,Y,NX,NFOLD,AK,NKX,YFOLD,COEF,WORK1,WORK2,WORK3,WORK4,IFAIL)
+seq,gplhint.

C---  CALCULATES FOLDING SUM(INTEGRAL(F(x)*a(k)*COS((k-1)*kx0*(x-x0)),dx0),k)
C---  ATTENTION: AK(1) = a(k=0)
C---  X IS AN EQUALLY SPACED GRID
C---  2*NFOLD DEFINES WIDTH OF FOLDING FUNCTION

      IMPLICIT NONE

      INTEGER NX,NX1,NX2,IFAIL,NKX,NKXO,NFOLDO,IAKO

      INTEGER K,I,NFOLD,IX0,J,NLOCALP
      PARAMETER (NLOCALP=2**14)

      INTEGER IH,IL,KL,KH,KLA,KHA,K1L,K1H,K1LA,K1HA

      DOUBLE PRECISION X(NX),Y(NX),YFOLD(NX),ADDCOS,AK(NKX),AK1H24
      DOUBLE PRECISION COEF(NX),WORK1(NX),WORK2(NX),WORK3(NX),WORK4(NX)

      DOUBLE PRECISION XL,XH,YL,YH,YPL,YPH,HXK0,CS(0:NLOCALP),SN(0:NLOCALP)
      DOUBLE PRECISION H,XL0,XK0,PI,X0,XKK,XKK2,XKK4,AKK(NLOCALP),HO,XK0O,AKO(NLOCALP)
      DOUBLE PRECISION CSKIXL, CSKIXH,CS1X0L,CS1X0H
      DOUBLE PRECISION SN1X0L,SN1X0H

      DOUBLE PRECISION HK3XK03(NLOCALP),H2K2XK02(NLOCALP),HKXK0(NLOCALP),H2
     &        ,XK02K2(NLOCALP),YPL3,YPL6,YPH3,YPH6

      DATA PI/3.141592653589793D0/
      DATA NKXO/0/,HO/0.D0/,XK0O/0.D0/,NFOLDO/0/,AKK/NLOCALP*0.D0/

      IFAIL=0

        IF (NFOLD*NKX.GE.NLOCALP) THEN
          WRITE(6,*)'ERROR IN UTIL_FOLD_FOURIER: DIMENSION NLOCALP EXCEEDED'
          IFAIL=1
          RETURN
        ENDIF

        IF (NFOLD.LT.1) THEN
          WRITE(6,*)
     &    'ERROR IN UTIL_FOLD_FOURIER: NUMBER OF MASHES FOR FOLDING FUNCTION'
          WRITE(6,*)
     &    'LOWER THAN ONE'
          IFAIL=1
          RETURN
        ENDIF

        IF (NFOLD.GT.NX/2) THEN
          WRITE(6,*)
     &    'ERROR IN UTIL_FOLD_FOURIER: NUMBER OF MASHES FOR FOLDING FUNCTION'
          WRITE(6,*)
     &    'TOO LARGE'
          IFAIL=1
          RETURN
        ENDIF

        CALL UTIL_SPLINE_COEF(X,Y,NX,-9999.0d0,-9999.0d0,COEF,WORK1,WORK2,WORK3,WORK4)

C--- ADJUST TO MASH

        H=x(2)-x(1)
        H2=H*H
        XL0=2.D0*NFOLD*ABS(H)
        XK0=2.D0*PI/XL0
        HXK0=H*XK0

      IAKO=0
      DO K=1,NKX
          IF (AK(K).NE.AKO(K)) THEN
              IAKO=1
              GOTO 10
          ENDIF
      ENDDO

10    IF (IAKO.NE.0.OR.NFOLDO.NE.NFOLD.OR.NKXO.NE.NKX.OR.
     &      HO.NE.H.OR.XK0.NE.XK0O) THEN

              XKK=0.D0
         DO K=1,NKX-1
                  XKK=XKK+XK0
                  XKK2=XKK*XKK
                  XKK4=XKK2*XKK2
                  AKK(K+1)=AK(K+1)/(h*XKK4)
              ENDDO
              AK1H24=AK(1)*H/24.D0

              XK02K2(1)=XK0
              HKXK0(1)=HXK0

              DO K=2,NFOLD*NKX
                  XK02K2(K)=XK02K2(K-1)+XK0
                  HKXK0(K)=HKXK0(K-1)+HXK0
         ENDDO

              DO K=1,NFOLD*NKX
                  XK02K2(K)=XK02K2(K)*XK02K2(K)
                  H2K2XK02(K)=HKXK0(K)*HKXK0(K)
         ENDDO

              DO K=1,NFOLD*NKX
                  HK3XK03(K)=H2K2XK02(K)*HKXK0(K)/H2
         ENDDO

              CS(0)=1.D0
              SN(0)=0.D0
              CS(1)=COS(HKXK0(1))
              SN(1)=SIN(HKXK0(1))
              DO K=2,NFOLD*NKX
                  CS(K)=CS(K-1)*CS(1)-SN(K-1)*SN(1)
                  SN(K)=CS(K-1)*SN(1)+SN(K-1)*CS(1)
         ENDDO

      ENDIF   !OLD-VALUES

        DO I=1,NX
        YFOLD(I)=0.0D0
      ENDDO

      NX1=1+NFOLD
      NX2=NX-NFOLD

        DO IX0=NX1,NX2 !LOOP OVER FOLDING REGION

          DO J=1,2*NFOLD   !INTEGRATE FULL INTERVALS

            I=IX0-NFOLD+J-1

          IL=I
            IH=I+1

          X0=X(IX0)
          XH=X(IH)
          XL=X(IL)
          YH=Y(IH)
          YL=Y(IL)
          YPL=COEF(IL)
          YPH=COEF(IH)
          YPL3=YPL/3.D0
          YPL6=YPL/6.D0
          YPH3=YPH/3.D0
          YPH6=YPH/6.D0

              YFOLD(IX0)=YFOLD(IX0)
     &       +aK1H24*(-H2*(yph+ypl)+12.0*(yh+yl))

              KL=0
              KH=0
         DO K=1,NKX-1

              KL=KL+IX0-IL
              KH=KH+IX0-IH
              K1L=K-KL
              K1H=K+KH
              KLA=ABS(KL)
              KHA=ABS(KH)
              K1HA=ABS(K1H)
              K1LA=ABS(K1L)

              CSKIXL=CS(KLA)
              CSKIXH=CS(KHA)
              CS1X0L=CS(K1LA)
              CS1X0H=CS(K1HA)

              IF (K1L.LT.0) THEN
                 SN1X0L=SN(K1LA)
              ELSE
                 SN1X0L=-SN(K1LA)
              ENDIF

              IF (K1H.LT.0) THEN
                 SN1X0H=SN(K1HA)
              ELSE
                 SN1X0H=-SN(K1HA)
              ENDIF

      addcos=akk(K+1)*(
     & CS1X0L*(H2K2XK02(K)*yph3+XK02K2(K)*yh-yph)
     &+CS1X0H*(H2K2XK02(K)*ypl3+XK02K2(K)*yl-ypl)
     &+CSKIXH*(H2K2XK02(K)*ypl6-XK02K2(K)*yl+ypl)
     &+CSKIXL*(H2K2XK02(K)*yph6-XK02K2(K)*yh+yph)
     &+SN1X0L*(HK3XK03(K)*yh-HKXK0(K)*yph)+SN1X0H*(HK3XK03(K)*yl-HKXK0(K)*ypl))

                  YFOLD(IX0)=YFOLD(IX0)+ADDCOS

              ENDDO   !K

          ENDDO !J
          ENDDO !IX0

      NKXO=NKX
      NFOLDO=NFOLD
      HO=H
      XK0O=XK0

      DO K=1,NKX
          AKO(K)=AK(K)
      ENDDO

      RETURN
      END
+DECK,UTIL_FOLD_FUNCTION_GAUSS.
*CMZ :  3.06/00 18/02/2019  18.55.48  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.66/20 06/07/2011  12.31.20  by  Michael Scheer
*CMZ :  2.63/03 02/05/2008  14.41.00  by  Michael Scheer
*CMZ :  2.52/04 12/07/2004  16.15.58  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.24.55  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE UTIL_FOLD_FUNCTION_GAUSS(NF,XF,F,SIGMA,RNSIGMA,FG,
     &  COEF,WS1,WS2,WS3,WS4)
+seq,gplhint.

C--- SUBROUTINE TO EVALUATE THE FOLDED FUNCTION FG(X)=INT{F(XF)*G(XF-X),DXF}

C--   INPUT:

C-       NF:   NUMBER OF XF,F-VALUES
C-       XF:   ARRAY OF X-VALUES (MUST BE IN ASCENDING ORDER)
C-       F: ARRAY OF FUNCTION-VALUES
C-       SIGMA:  SIGMA OF GAUSSIAN
C-       RNSIGMA: NUMBER OF SIGMAS TO BE CONSIDERED

C--   OUTPUT:

C-       FG:   FG(X0) IS CALCULATED

      IMPLICIT NONE

+SELF,IF=LINUX.
      EXTERNAL FUNCTION DERF
+SELF.

      INTEGER NF,IH,IL,I

      REAL*8 XF(NF),F(NF),SIGMA,X0,FG(NF),RNSIGMA
      REAL*8 COEF(NF)
      REAL*8 WS1(NF),WS2(NF),WS3(NF),WS4(NF)

      REAL*8 CH,CL,CH2,CL2,CHCL,CH2CL,CHCL2,XL,XH,YL,YH,H,H61,
     &  XHXL,XH2,XL2,SN,S2,ROOT2,SNR21,DERF,FGH,FGL,R2PI1,DX,X02,S22,
     &  SQPI2,X02S2,X023S2,SR2PI1,EPS

      DATA ROOT2/1.4142135623731D0/
      DATA R2PI1/0.398942280401433D0/
      DATA SQPI2/1.2533141373155D0/

C- CHECK ASCENDING ORDER

      DO I=2,NF
        IF (XF(I).LE.XF(I-1))
     &    STOP '*** ERROR SR UTIL_FOLD_FUNCTION_GAUSS:
     &    ARRAY XF NOT IN ASCENDING ORDER ***'
      ENDDO

      EPS=(XF(NF)-XF(1))*1.0D-10

C- SPLINES OF FUNCTION F

      CALL UTIL_SPLINE_COEF(XF,F,NF,-9999.0d0,-9999.0d0,COEF,WS1,WS2,WS3,WS4)

      DO IL=1,NF-1

        IH=IL+1

        XL=XF(IL)
        XH=XF(IH)
        YL=F(IL)
        YH=F(IH)
        CL=COEF(IL)
        CH=COEF(IH)

        CL2=2.0D0*CL
        CH2=2.0D0*CH
        CHCL=CH-CL
        CHCL2=CH+CL2
        CH2CL=CH2+CL

        XHXL=XH*XL
        XH2=XH*XH
        XL2=XL*XL

        H=XH-XL

        IF (H.LE.0.0D0) THEN
          PRINT*,
     &      '*** ERROR SR UTIL_FOLD_GAUSS:'
          PRINT*,
     &      '*** ARRAY XF NOT IN ASCENDING ORDER'
          STOP
        ENDIF

        H61=1.0D0/(6.0D0*H)

        WS1(IL)=((CHCL2*XH-CH2CL*XL)*XHXL+6.0D0*(XH*YL-XL*YH))*H61
        WS2(IL)=((CH2-CL2)*XHXL-CHCL2*XH2+CH2CL*XL2+6.0D0*(YH-YL))*H61
        WS3(IL)=(-CH*XL+CL*XH)/(2.0D0*H)
        WS4(IL)=CHCL*H61

        FG(IL)=0.0D0

      ENDDO !NF-1

      FG(NF)=0.0D0

      SN=RNSIGMA*SIGMA
      S2=SIGMA*SIGMA
      S22=2.0D0*S2
      SNR21=1.0D0/(ROOT2*SIGMA)
      SR2PI1=R2PI1/SIGMA

      DO I=1,NF

        X0=XF(I)

        X02=X0*X0
        X02S2=S2+X02
        X023S2=S22+X02S2

        IF (X0-SN.GE.XF(1)-EPS.AND.X0+SN.LE.XF(NF)+EPS) THEN

C UPPER BRANCH

          DO IL=I,NF-1

            IH=IL+1

            XL=XF(IL)
            XH=XF(IH)

            IF (XL-X0.LE.SN) THEN

              IF (XH-X0.GT.SN) XH=X0+SN

              DX=XH-X0

              FGH=
     &          SR2PI1*(
     &          -EXP(-DX**2/S22)*S2*(
     &          WS2(IL)+WS3(IL)*(XH+X0)+WS4(IL)*(S22+XH**2+XH*X0+X02))
     &          +SQPI2*SIGMA*(
     &          WS1(IL)+WS3(IL)*X02S2
     &          +X0*(WS2(IL)+WS4(IL)*X023S2))*
     &          DERF(DX*SNR21))

              DX=XL-X0

              FGL=
     &          SR2PI1*(
     &          -EXP(-DX**2/S22)*S2*(
     &          WS2(IL)+WS3(IL)*(XL+X0)+WS4(IL)*(S22+XL**2+XL*X0+X02))
     &          +SQPI2*SIGMA*(
     &          WS1(IL)+WS3(IL)*X02S2
     &          +X0*(WS2(IL)+WS4(IL)*X023S2))*
     &          DERF(DX*SNR21))

              FG(I)=FG(I)+FGH-FGL

            ELSE
              GOTO 81
            ENDIF ! (X-SN.GE.XF(1).AND.X+SN.LE.XF(NF))

          ENDDO !IL

 81       CONTINUE

C LOWER BRANCH

          DO IH=I,2,-1

            IL=IH-1

            XL=XF(IL)
            XH=XF(IH)

            IF (X0-XH.LE.SN) THEN

              IF (X0-XL.GT.SN) XL=X0-SN

              DX=XH-X0

              FGH=
     &          SR2PI1*(
     &          -EXP(-DX**2/S22)*S2*(
     &          WS2(IL)+WS3(IL)*(XH+X0)+WS4(IL)*(S22+XH**2+XH*X0+X02))
     &          +SQPI2*SIGMA*(
     &          WS1(IL)+WS3(IL)*X02S2
     &          +X0*(WS2(IL)+WS4(IL)*X023S2))*
     &          DERF(DX*SNR21))

              DX=XL-X0

              FGL=
     &          SR2PI1*(
     &          -EXP(-DX**2/S22)*S2*(
     &          WS2(IL)+WS3(IL)*(XL+X0)+WS4(IL)*(S22+XL**2+XL*X0+X02))
     &          +SQPI2*SIGMA*(
     &          WS1(IL)+WS3(IL)*X02S2
     &          +X0*(WS2(IL)+WS4(IL)*X023S2))*
     &          DERF(DX*SNR21))

              FG(I)=FG(I)+FGH-FGL

            ELSE
              GOTO 82
            ENDIF ! (X-SN.GE.XF(1).AND.X+SN.LE.XF(NF))

          ENDDO !IH

 82       CONTINUE

        ELSE IF (X0+SN.GT.XF(NF)) THEN

          GOTO 88

        ENDIF ! (X-SN.GE.XF(1).AND.X+SN.LE.XF(NF))

      ENDDO !NF

 88   CONTINUE

      RETURN
      END
+DECK,UTIL_GET_MODE.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.63/02 31/01/2008  14.12.17  by  Michael Scheer
*CMZ :  2.48/04 12/03/2004  15.40.31  by  Michael Scheer
*CMZ :  2.48/01 02/03/2004  09.21.49  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.02  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  16.05.55  by  Michael Scheer
*CMZ :  1.03/06 11/06/98  18.29.04  by  Michael Scheer
*CMZ : 00.01/07 08/03/95  16.41.54  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE UTIL_GET_MODE( MTYPE )
+seq,gplhint.
+SELF,IF=VMS.
C
C     AUS LIBRARY PORT::PRG:MERLIB.TLB EXTRAHIERT (MODULE "MODE")
C
C
C*
C*                  *******************************
C*                  *******************************
C*                  **                           **
C*                  **           MODE            **
C*                  **                           **
C*                  *******************************
C*                  *******************************
C*
C*     SUBPROGRAM :
C*          GET PROCESS MODE
C*
C*     AUTHOR :
C*          ART RAGOSTA
C*          MS 219-3
C*          AMES RESEARCH CENTER
C*          MOFFETT FIELD, CA  94035
C*          (415) 604-5558
C*
C*     PURPOSE :
C*          RETRIEVE THE PROCESS MODE TYPE
C*
C*     OUTPUT ARGUMENTS :
C*          MTYPE - "INTERACTIVE", "BATCH", "DETACHED", "NETWORK"
C*
C*     SUBPROGRAM REFERENCES :
C*          SYS$GETJPIW
C*
C*     TRANSPORTABILITY LIMITATIONS :
C*          ABSOLUTELY NOT TRANSPORTABLE
C*
C*     LANGUAGE AND COMPILER :
C*          ANSI FORTRAN 77
C*
C*     CHANGE HISTORY :
C*          07-JUN-1985       INITIAL VERSION
C*          10-MAR-1989       CHANGED FOR MODE
C*
C***********************************************************************
C*
      INCLUDE '($JPIDEF)'
      INCLUDE '($SSDEF)'
      CHARACTER *(*) MTYPE
      INTEGER *2 ITEM(14)
      INTEGER *4 ITMLST(7), IOSB(2)
      EQUIVALENCE (ITEM(1),ITMLST(1))

      INTEGER ISTAT,MT,MJ,SYS$GETJPIW
C
C --- FILL ITMLST
C
      ITEM(1)   = 4
      ITEM(2)   = JPI$_MODE
      ITMLST(2) = %LOC( MT )
      ITMLST(3) = 0
      ITEM(7)   = 4
      ITEM(8)   = JPI$_JOBTYPE
      ITMLST(5) = %LOC( MJ )
      ITMLST(6) = 0
      ITMLST(7) = 0
      ISTAT     = SYS$GETJPIW ( ,,, ITMLST, IOSB,, )
C
      IF ( IOSB(1) .NE. SS$_NORMAL ) THEN
         MTYPE = 'ERROR'
      ELSE
         IF (MJ .EQ. 0) THEN
            MTYPE = 'DETACHED'
         ELSE IF (MT .EQ. 1) THEN
            MTYPE = 'NETWORK'
         ELSE IF (MT .EQ. 2) THEN
            MTYPE = 'BATCH'
         ELSE IF (MT .EQ. 3) THEN
            IF (MJ .EQ. 1) THEN
               MTYPE = 'REMOTE'
            ELSE
               MTYPE = 'INTERACTIVE'
            ENDIF
         ELSE
            MTYPE = 'OTHER'
         ENDIF
      ENDIF
+SELF.
+SELF,IF=LINUX,WINDOWS,HPUX,TRUE64.
      CHARACTER(*) MTYPE

      integer ibatch

c     WRITE(6,*)
c    &  '*** WARNING SR UTIL_GET_MODE: NOT AVAILABLE FOR LINUX/WINDOWS ***'

      mtype=''

      open(unit=99,file='wave.batch',status='old',err=99)
      read(99,*)ibatch
      close(99)

      if (ibatch.ne.0) mtype='BATCH'

+SELF.
99    RETURN
      END
+DECK,UTIL_LINEAR_FIT.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  1.00/00 02/08/2002  19.48.06by  Michael Scheer
*CMZ : 00.02/04 10/02/97  13.35.14  by  Michael Scheer
*CMZ : 00.02/03 04/02/97  16.23.52  by  Michael Scheer
*CMZ : 00.00/01 17/01/97  16.00.54  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE UTIL_LINEAR_FIT
     &  (IFAIL,NPAR,PARAM,NDIMPOI,NPOI,NARG,NFUN,A,T,FUNDATA,CURDAT)
+seq,gplhint.

C     DOUBLE PRECISION SUBROUTINE FOR MULTIDIMENSIONAL LINEAR FIT

C     INPUT:
C       ------
C     NPAR:     NUMBER OF PARAMETERS TO FIT
C     NPOI:     NUMBER OF DATAPOINTS (NPOI MUST BE .LE. NDIMPOI)
C     NDIMPOI:    DIMENSION FOR NUMBER OF DATAPOINTS
C     NARG:     NUMBER OF ARGUMENTS FOR FUNCTION
C     NFUN:     DIMENSION OF FUNCTION
C     A:     WORKINGSPACE A(NPAR,NPAR)
C     T:     WORKINGSPACE T(NFUN,NPAR)
C     FUNDATA:    DATA POINTS FUNDATA(NARG+NFUN,NDIMPOI)
C            IF A FUNCTION VALUE IS 9999. DATA IS SKIPPED
C            NUMBER OF DATA MUST BE AT LEAST NPAR

C     OUTPUT:
C     -------
C     PARAM:       PARAMETERS TO BE FITTED
C     IFAIL:       FAILURE FLAG, ZERO IF EVERYTHING SEEMS TO BE OK

C     EXAMPLE:
C     --------
C     NPAR=4
C     NPOI=10
C     NARG=3
C     NFUN=2
C     FUNDATA(NARG+NFUN,NPOI):
C         FUNDATA(1,I)=X(I)
C         FUNDATA(2,I)=Y(I)
C         FUNDATA(3,I)=Z(I)
C         FUNDATA(4,I)=BX(I)
C         FUNDATA(5,I)=BY(I)
C

C     FIT SUCH THAT
C
C         dCHI2/dP1=0
C         dCHI2/dP2=0
C         dCHI2/dP3=0
C         dCHI2/dP4=0
C
C     WITH
C
C         DO I=1,NPOI
C          CHI2=CHI2+
C         +((P1*X(I)*Y(I)*SIN(  K*Z(I)+)-BX(IPOI))**2
C         +((P2*X(I)*Y(I)*COS(  K*Z(I)+)-BX(IPOI))**2
C         +((P3*X(I)*Y(I)*SIN(3*K*Z(I)+)-BY(IPOI))**2
C         +((P4*X(I)*Y(I)*COS(3*K*Z(I)+)-BY(IPOI))**2
C         ENDDO   !IPOI
C
C     AND P1=PARAM(1), P2=....
C

      IMPLICIT NONE

      INTEGER IFAIL,NPAR,NDIMPOI,NPOI,NARG,NFUN
      INTEGER IPAR,IPOI,IFUN
      INTEGER JPAR,JPOI,IDAT

      DOUBLE PRECISION PARAM,A,T,FUNDATA,CURDAT
      DIMENSION PARAM(NPAR),A(NPAR,NPAR)
     &           ,T(NFUN,NPAR)
     & ,FUNDATA(NARG+NFUN,NDIMPOI),CURDAT(NARG+NFUN)

      IF (NPOI.GT.NDIMPOI) STOP
     &'*** ERROR IN UTIL_LINEAR_FIT: DIMENSION NDIMPOI EXCEEDED ***'

      IFAIL=0

      JPOI=0
      DO IPOI=1,NPOI
      DO IFUN=1,NFUN
          IF (FUNDATA(NARG+IFUN,IPOI).NE.9999.) JPOI=JPOI+1
      ENDDO
      ENDDO

C ATTENTION: SINCE T IS ALSO USED AS WORKINGSPACE FOR F010
C          ITS DIMENSION MUST BE AT LEAST 2*NPAR, I.E. NPOI.GE.NPAR
      IF (JPOI.LT.NPAR) THEN
          IFAIL=9999
          RETURN
      ENDIF

      DO JPAR=1,NPAR
          PARAM(JPAR)=0.D0
      DO IPAR=1,NPAR
          A(IPAR,JPAR)=0.D0
      ENDDO
      ENDDO


C--- SET UP EQUATION SYSTEM


C -- SET UP INHOMOGENITY OF EQUATION SYSTEM

      DO IPOI=1,NPOI
C    T(IFUN,IPAR)=dChi2/dIPAR for each point and function
      DO IDAT=1,NARG+NFUN
          CURDAT(IDAT)=FUNDATA(IDAT,IPOI)
      ENDDO
      CALL UTIL_LINEAR_FIT_USER(NARG,NFUN,NPAR,CURDAT,T)
      DO IPAR=1,NPAR
      DO IFUN=1,NFUN

          PARAM(IPAR)=PARAM(IPAR)
     &                 +T(IFUN,IPAR)*CURDAT(NARG+IFUN)

      ENDDO
      ENDDO
      ENDDO

C -- SET UP MATRIX OF EQUATION SYSTEM

      DO IPOI=1,NPOI
      DO IDAT=1,NARG+NFUN
          CURDAT(IDAT)=FUNDATA(IDAT,IPOI)
      ENDDO
      CALL UTIL_LINEAR_FIT_USER(NARG,NFUN,NPAR,CURDAT,T)
      DO IFUN=1,NFUN
      DO JPAR=1,NPAR
          DO IPAR=1,NPAR
         A(IPAR,JPAR)=A(IPAR,JPAR)
     &                      +(T(IFUN,IPAR)*T(IFUN,JPAR))
          ENDDO
      ENDDO
      ENDDO
      ENDDO

C--- SOLVE EQUATION SYSTEM WITH CERN-ROUTINE F010

      CALL DEQN(NPAR,A,NPAR,T,IFAIL,1,PARAM)

      RETURN
      END
+DECK,UTIL_LINEAR_FIT_USER.
*CMZ :  2.65/02 28/09/2009  08.45.56  by  Michael Scheer
*CMZ :  2.63/04 11/06/2009  12.17.42  by  Michael Scheer
*CMZ :  2.48/04 15/03/2004  16.23.51  by  Michael Scheer
*CMZ :  2.47/23 17/02/2004  12.09.11  by  Michael Scheer
*CMZ :  2.47/18 26/11/2003  18.23.46  by  Michael Scheer
*CMZ :  2.47/08 08/05/2003  12.49.51  by  Michael Scheer
*CMZ :  2.41/08 02/08/2002  19.47.58  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  14.40.26  by  Michael Scheer
*CMZ :  2.15/00 04/05/2000  17.01.34  by  Michael Scheer
*CMZ :  2.14/02 19/04/2000  17.02.46  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  11.45.40  by  Michael Scheer
*CMZ :  1.03/06 07/08/98  10.07.52  by  Michael Scheer
*CMZ : 00.02/04 12/02/97  11.01.21  by  Michael Scheer
*CMZ : 00.02/03 04/02/97  16.36.40  by  Michael Scheer
*-- Author :    Michael Scheer   23/01/97
        SUBROUTINE UTIL_LINEAR_FIT_USER(NARG,NFUN,NPAR,CURDAT,T)
+seq,gplhint.

      IMPLICIT NONE

+SEQ,BPOLY2DH.

      INTEGER ICAL
      INTEGER NARG,NFUN,NPAR,IPAR,IHV,NN
      INTEGER N
      DOUBLE PRECISION N2,N4,N6,N8,N10
      DOUBLE PRECISION CURDAT,T
      DIMENSION CURDAT(NARG+NFUN),T(NFUN,NPAR)

      DOUBLE PRECISION y,y2,y3,y4,y5,y6,Y7,Y8,Y9,Y10
      DOUBLE PRECISION YY,YY2,YY3,YY4,YY5,YY6,YY7,YY8,YY9,YY10
      DOUBLE PRECISION x,x2,x3,x4,x5,x6,X7,X8,X9,X10
      DOUBLE PRECISION XX,XX2,XX3,XX4,XX5,XX6,XX7,XX8,XX9,XX10
      DOUBLE PRECISION zl,zk,zkz,zk2,ZK4,ZK6,ZK8,ZK10
      DOUBLE PRECISION z,PI,ZOLD,XOLD,YOLD
      DOUBLE PRECISION COSZKZ(NORD2DHP+1), SINZKZ(NORD2DHP+1)
     &                  ,CCOSZKZ(NORD2DHP+1),SSINZKZ(NORD2DHP+1)

+SELF,IF=-NOCMPLX.
        COMPLEX*16 CZKZ(NORD2DHP+1)
+SELF,IF=NOCMPLX.
        DOUBLE PRECISION CZKZR(NORD2DHP+1),CZKZI(NORD2DHP+1)
+SELF.

      DATA ICAL/0/
      DATA PI/3.141592653589793D0/

      IF (ICAL.EQ.0) THEN
         ZL=PERLEN2DH
         zk=2.d0*pi/zl
         zk2=zk*zk
         ZK4=ZK2*ZK2
         ZK6=ZK4*ZK2
         ZK8=ZK6*ZK2
         ZK10=ZK8*ZK2

         XOLD=-1.D30
         YOLD=-1.D30
         ZOLD=-1.D30

         ICAL=1
      ENDIF !ICAL

      Xx=CURdat(1)
      Yy=CURdat(2)
       z=CURdat(3)

      IF (XX.NE.XOLD) THEN
         XX2=XX*XX
         XX3=XX2*XX
         XX4=XX3*XX
         XX5=XX4*XX
         XX6=XX5*XX
         XX7=XX6*XX
         XX8=XX7*XX
         XX9=XX8*XX
         XX10=XX9*XX
         XOLD=XX
      ENDIF

      IF (YY.NE.YOLD) THEN
         YY2=YY*YY
         YY3=YY2*YY
         YY4=YY3*YY
         YY5=YY4*YY
         YY6=YY5*YY
         YY7=YY6*YY
         YY8=YY7*YY
         YY9=YY8*YY
         YY10=YY9*YY
         YOLD=YY
      ENDIF

+SELF,IF=-NOCMPLX.
      IF (Z.NE.ZOLD) THEN
                zkz=zk*z
                CZKZ(1)=CDEXP(DCMPLX(0.D0,ZKZ))
                CZKZ(2)=CZKZ(1)*CZKZ(1)
         Ssinzkz(1)=DIMAG(CZKZ(1))
         Ccoszkz(1)=DREAL(CZKZ(1))
         DO N=3,NORD2DH,2
            CZKZ(N)=CZKZ(N-2)*CZKZ(2)
            Ssinzkz(N)=DIMAG(CZKZ(N))
            Ccoszkz(N)=DREAL(CZKZ(N))
         ENDDO !N
         ZOLD=Z
      ENDIF
+SELF,IF=NOCMPLX.
      WRITE(6,*)'CHECK +SELF,NOCMPLX'
      IF (Z.NE.ZOLD) THEN
         zkz=zk*z
         CZKZR(1)=COS(ZKZ)
         CZKZI(1)=SIN(ZKZ)
         CZKZR(2)=CZKZR(1)*CZKZR(1)-CZKZI(1)*CZKZI(1)
         CZKZI(2)=CZKZI(1)*CZKZR(1)+CZKZR(1)*CZKZI(1)
         Ssinzkz(1)=CZKZI(1)
         Ccoszkz(1)=CZKZR(1)
         DO N=3,NORD2DH,2
            CZKZR(N)=CZKZR(N-2)*CZKZR(2)-CZKZI(N-2)*CZKZI(2)
            CZKZI(N)=CZKZI(N-2)*CZKZR(2)+CZKZR(N-2)*CZKZI(2)
            Ssinzkz(N)=CZKZI(N)
            Ccoszkz(N)=CZKZR(N)
         ENDDO !N
         ZOLD=Z
      ENDIF
+SELF.

      IPAR=0
      DO IHV=1,2
          IF (IHV.EQ.1) THEN

         X=XX
         X2=XX2
         X3=XX3
         X4=XX4
         X5=XX5
         X6=XX6
         X7=XX7
         X8=XX8
         X9=XX9
         X10=XX10

         Y=YY
         Y2=YY2
         Y3=YY3
         Y4=YY4
         Y5=YY5
         Y6=YY6
         Y7=YY7
         Y8=YY8
         Y9=YY9
         Y10=YY10

         DO N=1,NORD2DH,2
            sinzkz(N)=SSINZKZ(N)
            coszkz(N)=CCOSZKZ(N)
         ENDDO !N
          ELSE

         Y=XX
         Y2=XX2
         Y3=XX3
         Y4=XX4
         Y5=XX5
         Y6=XX6
         Y7=XX7
         Y8=XX8
         Y9=XX9
         Y10=XX10

         X=YY
         X2=YY2
         X3=YY3
         X4=YY4
         X5=YY5
         X6=YY6
         X7=YY7
         X7=YY7
         X8=YY8
         X9=YY9
         X10=YY10

C ACHTUNG VORZEICHENWECHSEL IN PARAMETERN WG ABLEITUNGEN VON SIN - COS !?
         DO N=1,NORD2DH,2
            sinzkz(N)=CCOSZKZ(N)
            coszkz(N)=SSINZKZ(N)
         ENDDO !N
          ENDIF

      DO N=1,NORD2DH,2
      N2=N*N
      N4=N2*N2
      N6=N4*N2
      N8=N6*N2
      N10=N8*N2
      DO NN=1,NPAR2DHP

+SELF,IF=-WINDOWS.
c            INCLUDE 'red:poly2dh.for'
      tt(1,1)=-0.00000027557319224*(ZK10*n10*x10+90.0*ZK8*n
     . 8*x8+5040.0*ZK6*n6*x6+1.512e+5*ZK4*n4*x4+1.8144e+6
     . *ZK2*n2*x2+3.6288e+6)*COSZKz(n)
      tt(1,2)=0.00000055114638448*(ZK8*n8*x8+ZK8*n8*x6*y
     . 2+ZK8*n8*x4*y4+ZK8*n8*x2*y6+ZK8*n8*y8+
     . 90.0*ZK6*n6*x6+90.0*ZK6*n6*x4*y2+90.0*ZK6*n6*x
     . 2*y4+90.0*ZK6*n6*y6+5040.0*ZK4*n4*x4+5040.0*ZK4
     . *n4*x2*y2+5040.0*ZK4*n4*y4+1.512e+5*ZK2*n2*x2+
     . 1.512e+5*ZK2*n2*y2+1.8144e+6)*(x+y)*(x-y)*COSZKz(n)
      tt(1,3)=0.0000132275132275*(ZK6*n6*x10-11.25*ZK6*n6*x
     . 8*y2+0.25*ZK6*n6*y10+67.5*ZK4*n4*x8-630.0*ZK4*n
     . 4*x6*y2+22.5*ZK4*n4*y8+2520.0*ZK2*n2*x6-
     . 18900.0*ZK2*n2*x4*y2+1260.0*ZK2*n2*y6+37800.0*x4
     . -2.268e+5*x2*y2+37800.0*y4)*COSZKz(n)
      tt(1,4)=-0.00000027557319224*(25920.0*(ZK2*n2*x2+ZK2*n
     . 2*y2+28)*(x2+4.0*x*y+y2)*(x2-4.0*x*y+y2)+432.0*(
     . x8-14.0*x6*y2-14.0*x4*y4-14.0*x2*y6+y8)*ZK4*n
     . 4)*(x+y)*(x-y)*COSZKz(n)
      tt(1,5)=-0.00238095238095*(ZK2*n2*x10-30.0*ZK2*n2*x
     . 8*y2+70.0*ZK2*n2*x6*y4-15.0*ZK2*n2*x2*y8+
     . 0.666666666667*ZK2*n2*y10+30.0*x8-840.0*x6*y2+
     . 2100.0*x4*y4-840.0*x2*y6+30.0*y8)*COSZKz(n)
      tt(1,6)=0.0238095238095*(x4+4.0*x3*y-14.0*x2*y2+4.0*x
     . *y3+y4)*(x4-4.0*x3*y-14.0*x2*y2-4.0*x*y3+y4)*(
     . x+y)*(x-y)*COSZKz(n)
      tt(2,1)=0.0
      tt(2,2)=-0.0000055114638448*(ZK8*n8*y8+72.0*ZK6*n6*y
     . 6+3024.0*ZK4*n4*y4+60480.0*ZK2*n2*y2+3.6288e+5)*
     . COSZKz(n)*x*y
      tt(2,3)=-0.0000055114638448*(432.0*(ZK4*n4*x4+ZK4*n4*
     . x2*y2+ZK4*n4*y4+42.0*ZK2*n2*x2+42.0*ZK2*n2*y
     . 2+840)+6.0*(x4+y4)*(x2+y2)*ZK6*n6)*(x+y)*(x-y)*
     . COSZKz(n)*x*y
      tt(2,4)=0.0000055114638448*(5184.0*(x6-7.0*x2*y4+2.0*y
     . 6)*ZK2*n2+2.17728e+5*(x2-0.333333333333*y2)*(x2-3.0
     . *y2)+72.0*(x8-12.0*x2*y6+3.0*y8)*ZK4*n4)*COSZKz(n
     . )*x*y
      tt(2,5)=0.015873015873*(ZK2*n2*x2+ZK2*n2*y2+36)*(
     . x2+2.0*x*y-y2)*(x2-2.0*x*y-y2)*(x+y)*(x-y)*COSZKz(n)*x
     . *y
      tt(2,6)=-0.238095238095*(x4-2.0*x2*y2+0.2*y4)*(x4-
     . 10.0*x2*y2+5.0*y4)*COSZKz(n)*x*y
      tt(3,1)=0.0000000250521083854*(ZK10*n10*x10+110.0*ZK8*n
     . 8*x8+7920.0*ZK6*n6*x6+3.3264e+5*ZK4*n4*x4+
     . 6.6528e+6*ZK2*n2*x2+3.99168e+7)*SINZKz(n)*ZK*n*x
      tt(3,2)=-0.0000000501042167709*(ZK8*n8*x10-11.0*ZK8*n
     . 8*y10+110.0*ZK6*n6*x8-990.0*ZK6*n6*y8+7920.0*ZK4*
     . n4*x6-55440.0*ZK4*n4*y6+3.3264e+5*ZK2*n2*x4-
     . 1.6632e+6*ZK2*n2*y4+6.6528e+6*x2-1.99584e+7*y2)*
     . SINZKz(n)*ZK*n*x
      tt(3,3)=-0.0000012025012025*(ZK6*n6*x10-13.75*ZK6*n6*
     . x8*y2+2.75*ZK6*n6*y10+82.5*ZK4*n4*x8-990.0*ZK4*
     . n4*x6*y2+247.5*ZK4*n4*y8+3960.0*ZK2*n2*x6-
     . 41580.0*ZK2*n2*x4*y2+13860.0*ZK2*n2*y6+83160.0*x
     . 4-8.316e+5*x2*y2+4.158e+5*y4)*SINZKz(n)*ZK*n*x
      tt(3,4)=0.0000108225108225*(ZK4*n4*x10-18.3333333333*ZK
     . 4*n4*x8*y2+55.0*ZK4*n4*x2*y8-11.0*ZK4*n4*y10
     . +73.3333333333*ZK2*n2*x8-1320.0*ZK2*n2*x6*y2+
     . 3080.0*ZK2*n2*x2*y6-660.0*ZK2*n2*y8+2640.0*x6-
     . 55440.0*x4*y2+92400.0*x2*y4-18480.0*y6)*SINZKz(n)*ZK*
     . n*x
      tt(3,5)=0.0000000250521083854*(8640.0*(x10-36.6666666667*x
     . 8*y2+110.0*x6*y4-55.0*x2*y8+7.33333333333*y10)*ZK
     . 2*n2+3.168e+5*(x6-33.0*x4*y2+27.0*x2*y4-3.0*y6
     . )*(x2-3.0*y2))*SINZKz(n)*ZK*n*x
      tt(3,6)=-0.0021645021645*(x10-55.0*x8*y2+330.0*x6*y
     . 4-462.0*x4*y6+165.0*x2*y8-11.0*y10)*SINZKz(n)*ZK*n*x

+SELF,IF=WINDOWS.
C         INCLUDE 'C:\LOCAL\WAV\POLY2DH.FOR'
      tt(1,1)=-0.00000027557319224*(ZK10*n10*x10+90.0*ZK8*n
     . 8*x8+5040.0*ZK6*n6*x6+1.512e+5*ZK4*n4*x4+1.8144e+6
     . *ZK2*n2*x2+3.6288e+6)*COSZKz(n)
      tt(1,2)=0.00000055114638448*(ZK8*n8*x8+ZK8*n8*x6*y
     . 2+ZK8*n8*x4*y4+ZK8*n8*x2*y6+ZK8*n8*y8+
     . 90.0*ZK6*n6*x6+90.0*ZK6*n6*x4*y2+90.0*ZK6*n6*x
     . 2*y4+90.0*ZK6*n6*y6+5040.0*ZK4*n4*x4+5040.0*ZK4
     . *n4*x2*y2+5040.0*ZK4*n4*y4+1.512e+5*ZK2*n2*x2+
     . 1.512e+5*ZK2*n2*y2+1.8144e+6)*(x+y)*(x-y)*COSZKz(n)
      tt(1,3)=0.0000132275132275*(ZK6*n6*x10-11.25*ZK6*n6*x
     . 8*y2+0.25*ZK6*n6*y10+67.5*ZK4*n4*x8-630.0*ZK4*n
     . 4*x6*y2+22.5*ZK4*n4*y8+2520.0*ZK2*n2*x6-
     . 18900.0*ZK2*n2*x4*y2+1260.0*ZK2*n2*y6+37800.0*x4
     . -2.268e+5*x2*y2+37800.0*y4)*COSZKz(n)
      tt(1,4)=-0.00000027557319224*(25920.0*(ZK2*n2*x2+ZK2*n
     . 2*y2+28)*(x2+4.0*x*y+y2)*(x2-4.0*x*y+y2)+432.0*(
     . x8-14.0*x6*y2-14.0*x4*y4-14.0*x2*y6+y8)*ZK4*n
     . 4)*(x+y)*(x-y)*COSZKz(n)
      tt(1,5)=-0.00238095238095*(ZK2*n2*x10-30.0*ZK2*n2*x
     . 8*y2+70.0*ZK2*n2*x6*y4-15.0*ZK2*n2*x2*y8+
     . 0.666666666667*ZK2*n2*y10+30.0*x8-840.0*x6*y2+
     . 2100.0*x4*y4-840.0*x2*y6+30.0*y8)*COSZKz(n)
      tt(1,6)=0.0238095238095*(x4+4.0*x3*y-14.0*x2*y2+4.0*x
     . *y3+y4)*(x4-4.0*x3*y-14.0*x2*y2-4.0*x*y3+y4)*(
     . x+y)*(x-y)*COSZKz(n)
      tt(2,1)=0.0
      tt(2,2)=-0.0000055114638448*(ZK8*n8*y8+72.0*ZK6*n6*y
     . 6+3024.0*ZK4*n4*y4+60480.0*ZK2*n2*y2+3.6288e+5)*
     . COSZKz(n)*x*y
      tt(2,3)=-0.0000055114638448*(432.0*(ZK4*n4*x4+ZK4*n4*
     . x2*y2+ZK4*n4*y4+42.0*ZK2*n2*x2+42.0*ZK2*n2*y
     . 2+840)+6.0*(x4+y4)*(x2+y2)*ZK6*n6)*(x+y)*(x-y)*
     . COSZKz(n)*x*y
      tt(2,4)=0.0000055114638448*(5184.0*(x6-7.0*x2*y4+2.0*y
     . 6)*ZK2*n2+2.17728e+5*(x2-0.333333333333*y2)*(x2-3.0
     . *y2)+72.0*(x8-12.0*x2*y6+3.0*y8)*ZK4*n4)*COSZKz(n
     . )*x*y
      tt(2,5)=0.015873015873*(ZK2*n2*x2+ZK2*n2*y2+36)*(
     . x2+2.0*x*y-y2)*(x2-2.0*x*y-y2)*(x+y)*(x-y)*COSZKz(n)*x
     . *y
      tt(2,6)=-0.238095238095*(x4-2.0*x2*y2+0.2*y4)*(x4-
     . 10.0*x2*y2+5.0*y4)*COSZKz(n)*x*y
      tt(3,1)=0.0000000250521083854*(ZK10*n10*x10+110.0*ZK8*n
     . 8*x8+7920.0*ZK6*n6*x6+3.3264e+5*ZK4*n4*x4+
     . 6.6528e+6*ZK2*n2*x2+3.99168e+7)*SINZKz(n)*ZK*n*x
      tt(3,2)=-0.0000000501042167709*(ZK8*n8*x10-11.0*ZK8*n
     . 8*y10+110.0*ZK6*n6*x8-990.0*ZK6*n6*y8+7920.0*ZK4*
     . n4*x6-55440.0*ZK4*n4*y6+3.3264e+5*ZK2*n2*x4-
     . 1.6632e+6*ZK2*n2*y4+6.6528e+6*x2-1.99584e+7*y2)*
     . SINZKz(n)*ZK*n*x
      tt(3,3)=-0.0000012025012025*(ZK6*n6*x10-13.75*ZK6*n6*
     . x8*y2+2.75*ZK6*n6*y10+82.5*ZK4*n4*x8-990.0*ZK4*
     . n4*x6*y2+247.5*ZK4*n4*y8+3960.0*ZK2*n2*x6-
     . 41580.0*ZK2*n2*x4*y2+13860.0*ZK2*n2*y6+83160.0*x
     . 4-8.316e+5*x2*y2+4.158e+5*y4)*SINZKz(n)*ZK*n*x
      tt(3,4)=0.0000108225108225*(ZK4*n4*x10-18.3333333333*ZK
     . 4*n4*x8*y2+55.0*ZK4*n4*x2*y8-11.0*ZK4*n4*y10
     . +73.3333333333*ZK2*n2*x8-1320.0*ZK2*n2*x6*y2+
     . 3080.0*ZK2*n2*x2*y6-660.0*ZK2*n2*y8+2640.0*x6-
     . 55440.0*x4*y2+92400.0*x2*y4-18480.0*y6)*SINZKz(n)*ZK*
     . n*x
      tt(3,5)=0.0000000250521083854*(8640.0*(x10-36.6666666667*x
     . 8*y2+110.0*x6*y4-55.0*x2*y8+7.33333333333*y10)*ZK
     . 2*n2+3.168e+5*(x6-33.0*x4*y2+27.0*x2*y4-3.0*y6
     . )*(x2-3.0*y2))*SINZKz(n)*ZK*n*x
      tt(3,6)=-0.0021645021645*(x10-55.0*x8*y2+330.0*x6*y
     . 4-462.0*x4*y6+165.0*x2*y8-11.0*y10)*SINZKz(n)*ZK*n*x
+SELF.

          IPAR=IPAR+1
          IF (IHV.EQ.1) THEN
             T(1,IPAR)=TT(1,NN)
             T(2,IPAR)=TT(2,NN)
             T(3,IPAR)=TT(3,NN)
          ELSE
             T(1,IPAR)=TT(2,NN)
             T(2,IPAR)=TT(1,NN)
             T(3,IPAR)=-TT(3,NN)
          ENDIF

      ENDDO !NN
      ENDDO !N
      ENDDO !IHV


      RETURN
      END
+DECK,UTIL_MAX_PARABEL.
*CMZ :  4.00/15 29/04/2022  11.54.49  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.15/00 01/05/2000  13.23.51  by  Michael Scheer
*CMZ : 00.01/07 15/03/95  15.04.35  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE UTIL_MAX_PARABEL(NDIM,X,F,XMX,FMX,WSX,WSF,JFAIL)
+seq,gplhint.

C--- TO FIND MAXIMUM OF ARRAY FUNCTION F(X)

C     INPUT : F   ARRAY OF FUNCTION
C             X   ARRAY OF ARGUMENTS
C             WSX WORKINGSPACE
C             WSF WORKINGSPACE

C     OUTPUT:  XMX ARGUMENT WHERE FUNCTION REACHES EXTREMUM
C              FMX MAXIMUM OF FUNCTION
C              JFAIL FLAG: =0, IF OK, =1 ELSE

      IMPLICIT NONE

      INTEGER NDIM,I,IFAIL,JFAIL,IMAX,IFOUND
      DOUBLE PRECISION X(NDIM),F(NDIM),XMX,FMX,WSX(NDIM),WSF(NDIM)
      DOUBLE PRECISION XDUM(3),FDUM(3),A(3),FP(3),FMAX,XMAX

      IFOUND=0
      IMAX=0
      FMAX=-1.0D30

      if (ndim.le.0) then
        jfail=-1
        print*, "*** Error in util_max_parabel: Ndim .le. 0"
        return
      endif

      DO I=1,NDIM
        WSX(I)=X(I)
        WSF(I)=F(I)
        IF (WSF(I).NE.0.0D0) IFOUND=1
        IF (WSF(I).GT.FMAX) THEN
          FMAX=WSF(I)
          XMAX=WSX(I)
          IMAX=I
        ENDIF
      ENDDO

      if (imax.eq.0) then
        jfail=-2
        print*, "*** Error in util_max_parabel: IMAX = 0"
        return
      endif
C      CALL UTIL_SORT_FUNC(NDIM,WSF,WSX)
C      DO I=1,3
C         XDUM(I)=WSX(NDIM-I+1)
C         FDUM(I)=WSF(NDIM-I+1)
C      ENDDO

      IF (IFOUND.EQ.0) THEN
        XMX=0.D0
        FMX=0.D0
        JFAIL=0
        RETURN
      ENDIF

      IF (IMAX.EQ.1.OR.IMAX.EQ.NDIM) THEN
          JFAIL=1
          FMX=FMAX
          XMX=XMAX
          RETURN
      ENDIF

        XDUM(1)=WSX(IMAX-1)
        FDUM(1)=WSF(IMAX-1)
        XDUM(2)=WSX(IMAX)
        FDUM(2)=WSF(IMAX)
        XDUM(3)=WSX(IMAX+1)
        FDUM(3)=WSF(IMAX+1)

      CALL UTIL_PARABEL(XDUM,FDUM,A,FP,XMX,FMX,IFAIL)

      IF (IFAIL.NE.0.OR.FMX.LT.FMAX) THEN
          JFAIL=1
          FMX=FMAX
          XMX=XMAX
          RETURN
      ENDIF

      JFAIL=0

      RETURN
      END
+DECK,util_mpinit.
*CMZ :  2.14/02 27/04/2000  16.00.54  by  Michael Scheer
*-- Author :    Michael Scheer   27/04/2000
      SUBROUTINE UTIL_MPINIT
+seq,gplhint.

      IMPLICIT NONE

+SEQ,MPA.

      INTEGER LUN

      LUN=6
      MPB=MPBP    !BASE FOR REPRESENTATION
      MPT=MPTP     !WANTED NUMBER OF DIGITS PRECISION
      MPM=2**30/4
      MPMXR=MPMXRP

      MPONE(1)=1
      MPONE(2)=0
      MPONE(3)=001

      RETURN
      END
+DECK,util_parabel.
*CMZ :  4.01/07 29/11/2024  18.43.16  by  Michael Scheer
*CMZ :  4.01/05 31/10/2022  17.05.45  by  Michael Scheer
*CMZ : 00.00/16 19/03/2014  12.30.26  by  Michael Scheer
*CMZ : 00.00/15 03/09/2012  09.27.13  by  Michael Scheer
*CMZ : 00.00/07 22/03/2010  15.28.00  by  Michael Scheer
*CMZ : 00.00/02 26/03/97  10.23.11  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.27.40  by  Michael Scheer
*-- Author :
      SUBROUTINE UTIL_PARABEL(Xin,Yin,A,YP,XOPT,yopt,IFAIL)

+seq,gplhint.

C--- CALCULATES A(1),A(2),A(3), THE DERIVATIVES YP(X(1)),YP(X(2)),YP(X(3)),
C    AND THE EXTREMUM (XOPT,A(XOPT)) OF PARABOLA Y=A1+A2*X+A3*X**2
C    FROM COORDINATES OF THE THREE POINTS (X(1),Y(1)),(X(2),Y(2)),(X(3),Y(3))
C

      IMPLICIT NONE

      INTEGER IFAIL

      REAL*8 A(3),X(3),Y(3),DXM,DXP,x0,a1,a2,dxm2,dxp2,dxmax,dymax,
     &  xin(3),yin(3),DET,YP(3),XOPT,yopt,a22,fm,fp,f0

      IFAIL=0

c calculate f=a0+a1*(x-x0)+a2*(x-x0)**2
c  = a0 + a1*x - a0*x0 + a2*x**2 - 2*a2*x*x0 + a2*x0**2
c  = a0 + (a2*x0 -a0)*x0 + (a1 - 2*a2*x0 )*x+ a2*x**2

c change system: (x0,s0)->(0,0), i.e.
c calculate f=a1*dx+a2*dx**2
c  df/dx=a1+2*a2*dx_max =! 0, dx_max=-a1/2/a2

      x=xin
      y=yin

      call util_sort_func(3,x,y)

c      if (x(1).le.x(2).and.x(1).le.x(3)) then
c      endif

      x0=x(2)
      f0=y(2)

      fm=y(1)-f0
      fp=y(3)-f0

      dxm=x(1)-x0
      dxp=x(3)-x0

c fm=a1*dxm+a2*dxm**2
c fp=a1*dxp+a2*dxp**2

c (dxm dxm2) (a1) = (y(1))
c (dxp dxp2) (a2) = (y(3))

      dxm2=dxm*dxm
      dxp2=dxp*dxp

      det=dxm*dxp2-dxp*dxm2

      if (det.ne.0.0d0) then
        a1=(fm*dxp2-fp*dxm2)/det
        a2=(fp*dxm-fm*dxp)/det
      else
        ifail=1
        return
      endif

      if (a2.ne.0.0d0) then
        dxmax=-a1/(2.0d0*a2)
        dymax=(a1+a2*dxmax)*dxmax
        xopt=x0+dxmax
        yopt=f0+dymax
      endif

c calculate f=f0+a1*dx+a2*dx**2
c = a1*x - a1*x0 + a2*x**2 + a2*x0**2 - 2*a2*x*x0
c  f = f0 + (a2*x0 -a1)*x0 + (a1 - 2*a2*x0 )*x+ a2*x**2

      a22=2.0d0*a2

      a(1)=f0 + (a2*x0 -a1)*x0
      a(2)=a1 - a22*x0
      a(3)=a2

c calculate yp=a1+2*a2*dx

      yp(1)=a1+a22*dxm
      yp(2)=a1
      yp(3)=a1+a22*dxp

      RETURN
      END
+DECK,util_skip_comment.
*CMZ :  3.05/15 06/10/2018  11.26.54  by  Michael Scheer
*CMZ :  0.99/00 16/02/2004  17.22.39  by  Michael Scheer
*-- Author :    Michael Scheer   23/01/2004
      subroutine util_skip_comment(lun)
+seq,gplhint.

      implicit none

      integer lun
      character(32) com

1     read(lun,'(a)') com

      if (com(1:1).ne.'!'.and.com(1:1).ne.'*'.and.com(1:1).ne.'#'
     &    .and.com(1:1).ne.'%'.and.len_trim(com).ne.0) then
        backspace(lun)
      else
        goto 1
      endif

      return
      end
+DECK,UTIL_SORT.
*CMZ :  3.05/08 23/07/2018  11.00.36  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  16.07.48  by  Michael Scheer
*CMZ : 00.01/00 20/06/94  10.47.48  by  Michael Scheer
*-- Author :    Michael Scheer   20/06/94
      SUBROUTINE UTIL_SORT(N,RA)
+seq,gplhint.

C--- HEAPSORT ROUTINE; SEE NUMERICAL RECIPES 8.2 S 231

      IMPLICIT NONE

      INTEGER L,N,IR,J,I

      DOUBLE PRECISION RA(N),RRA


      L=N/2+1
      IR=N
10    CONTINUE
        IF(L.GT.1)THEN
          L=L-1
          RRA=RA(L)
        ELSE
          RRA=RA(IR)
          RA(IR)=RA(1)
          IR=IR-1
          IF(IR.EQ.1)THEN
            RA(1)=RRA
            RETURN
          ENDIF
        ENDIF
        I=L
        J=L+L
20      IF(J.LE.IR)THEN
          IF(J.LT.IR)THEN
            IF(RA(J).LT.RA(J+1))J=J+1
          ENDIF
          IF(RRA.LT.RA(J))THEN
            RA(I)=RA(J)
            I=J
            J=J+J
          ELSE
            J=IR+1
          ENDIF
        GO TO 20
        ENDIF
        RA(I)=RRA
      GO TO 10
      END

+DECK,util_sort_func.
*CMZ : 00.00/15 05/01/2012  13.52.39  by  Michael Scheer
*CMZ : 00.00/00 11/01/95  11.41.04  by  Michael Scheer
*-- Author :
      SUBROUTINE UTIL_SORT_FUNC(N,RA,YA)

C--- HEAPSORT ROUTINE; SEE NUMERICAL RECIPES 8.2 S 231
C--- ARRAY YA IS FUNCTION OF RA AND SORTED ACCORDINGLY

      IMPLICIT NONE

      INTEGER N,L,IR,I,J

      REAL*8 RA(N),RRA
      REAL*8 YA(N),YYA

      if (n.lt.2) return

      L=N/2+1
      IR=N
10    CONTINUE
        IF(L.GT.1)THEN
          L=L-1
          RRA=RA(L)
          YYA=YA(L)
        ELSE
          RRA=RA(IR)
          YYA=YA(IR)
          RA(IR)=RA(1)
          YA(IR)=YA(1)
          IR=IR-1
          IF(IR.EQ.1)THEN
            RA(1)=RRA
            YA(1)=YYA
            RETURN
          ENDIF
        ENDIF
        I=L
        J=L+L
20      IF(J.LE.IR)THEN
          IF(J.LT.IR)THEN
            IF(RA(J).LT.RA(J+1))J=J+1
          ENDIF
          IF(RRA.LT.RA(J))THEN
            RA(I)=RA(J)
            YA(I)=YA(J)
            I=J
            J=J+J
          ELSE
            J=IR+1
          ENDIF
        GO TO 20
        ENDIF
        RA(I)=RRA
        YA(I)=YYA
      GO TO 10
      END
+DECK,UTIL_SPLINE_COEF_DERIV.
*CMZ :  2.63/03 21/05/2008  13.37.36  by  Michael Scheer
*CMZ : 00.00/02 14/04/2004  14.25.24  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.27.48  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE UTIL_SPLINE_COEF_DERIV(X,Y,N,YP1,YPN,YP,Y2,AA,BB,CC,C)
+seq,gplhint.

C--- CALCULATES SPLINE COEFFICIENTS

C--   INPUT:

C-       N: NUMBER OF X,Y-VALUES
C-       X: ARRAY OF X-VALUES
C-       Y: ARRAY OF Y-VALUES
C-       YP1:  SECOND DERIVATIVE AT FIRST X-VALUE
C-       YPN:  SECOND DERIVATIVE AT LAST X-VALUE

C--   OUPUT:

C-       YP:   DERIVATIVES AT XA
C-       Y2:   SPLINE-COEFFICIENTS

C--   WORKINGSPACE: AA(N),BB(N),CC(N),C(N)


      IMPLICIT NONE

      INTEGER N,J,I,I1

      REAL*8  X(N),Y(N),YP(N),Y2(N),AA(N),BB(N),CC(N),C(N)
      REAL*8 YP1,YPN

      double precision a(3),yp3(3),xopt,yopt
      INTEGER ifail

      IF (N.LT.3) RETURN

      if (abs(yp1).eq.9999.0d0) then
        call UTIL_PARABEL(X(1),Y(1),A,YP3,XOPT,yopt,IFAIL)
        if (ifail.eq.0) then
          y2(1)=2.0d0*a(3)
        else
          y2(1)=0.0d0
        endif
      else
        Y2(1)=YP1
      endif

      if (abs(ypn).eq.9999.0d0) then
        call UTIL_PARABEL(X(n-2),Y(n-2),A,YP3,XOPT,yopt,IFAIL)
        if (ifail.eq.0) then
          y2(n)=2.0d0*a(3)
        else
          y2(N)=0.0d0
        endif
      else
        Y2(N)=YPN
      endif

      C(1)=Y2(1)
      C(N)=y2(n)

      BB(1)=1.D0
      CC(1)=0.D0
      CC(N)=1.D0

      DO J=2,N-1
        AA(J)=(X(J  )-X(J-1))/6.D0
        BB(J)=(X(J+1)-X(J-1))/3.D0
        CC(J)=(X(J+1)-X(J  ))/6.D0
        C(J)=(Y(J+1)-Y(J  ))/(X(J+1)-X(J  ))
     &    -(Y(J  )-Y(J-1))/(X(J  )-X(J-1))
      ENDDO !J

      DO J=2,N-1

        BB(J)=BB(J)-AA(J)*CC(J-1)
        C(J)= C(J)-AA(J)* C(J-1)

        CC(J)=CC(J)/BB(J)
        C(J)= C(J)/BB(J)
        BB(J)=1.D0

      ENDDO !J

      DO J=N-1,2,-1
        Y2(J)=C(J)-CC(J)*Y2(J+1)
      ENDDO

      DO I=1,N-1
        I1=I+1
        YP(I)=(Y(I1)-Y(I))/(X(I1)-X(I))-
     &    (Y2(I1)+2.D0*Y2(I))/6.D0*(X(I1)-X(I))
      ENDDO

      I1=N
      I=N-1

      YP(N)=(Y(I1)-Y(I))/(X(I1)-X(I))+
     &  (2.D0*Y2(I1)+Y2(I))/6.D0*(X(I1)-X(I))

      RETURN
      END
+DECK,UTIL_SPLINE_INTEGRAL.
*CMZ :  4.01/07 16/08/2024  10.07.55  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  11.03.55  by  Michael Scheer
*CMZ :  2.63/03 21/05/2008  13.37.36  by  Michael Scheer
*CMZ : 00.00/02 17/08/2004  09.47.26  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.25.29  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE UTIL_SPLINE_INTEGRAL(X,Y,N,RESULT
     &                                 ,COEF,WORK1,WORK2,WORK3,WORK4)
+seq,gplhint.

C---  CALCULATES INTEGRAL OF Y(X) VIA SPLINES

      IMPLICIT NONE

      INTEGER I,N
      REAL*8 X(N),Y(N),RESULT
      REAL*8 COEF(N),WORK1(N),WORK2(N),WORK3(N),WORK4(N)

C---  SPLINE-COEFFICIENTS

      CALL UTIL_SPLINE_COEF(X,Y,N,0.0d0,0.0d0,COEF,WORK1,WORK2,WORK3,WORK4)

C--- INTEGRATION

      RESULT=0.0D0
      DO I=1,N-1

      RESULT=RESULT
     &          +(X(I+1)-X(I))*0.5D0
     &          *(Y(I)+Y(I+1))
     &          -(X(I+1)-X(I))**3/24.D0
     &          *(COEF(I)+COEF(I+1))

      ENDDO

      RETURN
      END
+DECK,util_spline_inter.
*CMZ :  4.00/11 28/05/2021  09.17.01  by  Michael Scheer
*CMZ :  3.05/05 12/07/2018  13.12.16  by  Michael Scheer
*CMZ :  3.02/00 24/09/2014  13.51.08  by  Michael Scheer
*CMZ :  3.01/03 19/03/2014  12.24.14  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.66/19 07/06/2011  14.38.25  by  Michael Scheer
*CMZ : 00.00/08 15/12/2010  14.05.16  by  Michael Scheer
*CMZ : 00.00/07 07/05/2008  14.28.10  by  Michael Scheer
*CMZ : 00.00/02 25/08/2006  15.27.06  by  Michael Scheer
*CMZ : 00.00/01 23/02/96  14.56.50  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.27.54  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE UTIL_SPLINE_INTER(XA,YA,Y2A,N,X,Y,MODE)
+seq,gplhint.

C---  INTERPOLATES Y(X) VIA SPLINE

C--   INPUT:

C-       N: NUMBER OF X,Y-VALUES
C-       XA:   ARRAY OF X-VALUES
C-       YA:   ARRAY OF Y-VALUES
C-       YA2:  ARRAY SPLINE COEFFICIENTS
C-       X: Y(X) IS CALCULATED
C-       MODE: CONTROL FLAG:
C-             MODE.GE.0: USE VALUES OF LAST CALL TO START WITH
C-             MODE.LT.0: NEW INITIALIZATION

C--   OUTPUT:

C-       Y: Y(X) IS CALCULATED

      IMPLICIT NONE

      INTEGER NOLD,N,KLO,KHI,KLOLD,K,MODE,NORDER

      double precision Y,X,XA1OLD,XANOLD,H,A,B

      double precision XA(*),YA(*),Y2A(*),EPS,XX

c      save klold,nold,xa1old,xanold

      DATA KLOLD/1/,NOLD/-99/
      DATA XA1OLD/-9999.D0/,XANOLD/-9999./

      if (klold.lt.1.or.klold.gt.n-1) klold=1
      if (nold.lt.1.or.nold.gt.n-1) nold=1
      if (xa1old.lt.xa(1).or.xa1old.gt.xa(n-1)) xa1old=xa(1)
      if (xanold.lt.xa(2).or.xanold.gt.xa(n)) xanold=xa(n)

      EPS=ABS(XA(N)-XA(1))/1.0D10
      XX=X

      IF(XA(1).LT.XA(N)) THEN

        IF(XX.LT.XA(1).AND.XX.GT.XA(1)-EPS) THEN
          XX=XA(1)
        ELSE IF(XX.GT.XA(N).AND.XX.LT.XA(N)+EPS) THEN
          XX=XA(N)
        ENDIF

        IF(XX.LT.XA(1).OR.XX.GT.XA(N)) THEN
          WRITE(6,*)'XA(1), XA(N):',XA(1), XA(N)
          WRITE(6,*)'X:'
          WRITE(6 ,*)'***ERROR IN UTIL_SPLINE_INTER: X OUT OF RANGE ***'
          STOP
        ENDIF

      ELSE

        IF(XX.LT.XA(N).AND.XX.GT.XA(N)-EPS) THEN
          XX=XA(N)
        ELSE IF(XX.GT.XA(1).AND.XX.LT.XA(N)+EPS) THEN
          XX=XA(1)
        ENDIF

        IF(XX.LT.XA(N).OR.XX.GT.XA(1)) THEN
          WRITE(6,*)'XA(1), XA(N):',XA(1), XA(N)
          WRITE(6,*)'X:',X
          WRITE(6 ,*)'***ERROR IN UTIL_SPLINE_INTER: X OUT OF RANGE ***'
          STOP
        ENDIF

      ENDIF

      norder=1
      if (xa(n).lt.xa(1)) then
        norder=-1
      endif

      if (norder.eq.1) then

        IF (MODE.LT.0.OR.KLOLD.GE.N) THEN
          KLO=1
        ELSE IF(NOLD.EQ.N
     &      .AND. XA(1).EQ.XA1OLD
     &      .AND. XA(N).EQ.XANOLD
     &      .AND. XX.GT.XA(KLOLD)
     &      ) THEN
          KLO=KLOLD
        ELSE
          KLO=1
        ENDIF

        IF (XX.LT.XA(KLO+1)) THEN
          KHI=KLO+1
          GOTO 2
        ENDIF

        KHI=N
1       IF (KHI-KLO.GT.1) THEN
          K=(KHI+KLO)/2
          IF(XA(K).GT.XX)THEN
            KHI=K
          ELSE
            KLO=K
          ENDIF
          GOTO 1
        ENDIF

2       H=XA(KHI)-XA(KLO)

        IF (H.le.0.0D0) THEN
          WRITE(6 ,*)'*** ERROR IN UTIL_SPLINE_INTER: BAD INPUT ***'
          STOP
        ENDIF

        A=(XA(KHI)-XX)/H
        B=(XX-XA(KLO))/H
        Y=A*YA(KLO)+B*YA(KHI)+
     &    (A*(A+1.D0)*(A-1.D0)*Y2A(KLO)+B*(B+1.D0)*
     &    (B-1.D0)*Y2A(KHI))*(H**2)/6.D0

      KLOLD=KLO
      NOLD=N
      XA1OLD=XA(1)
      XANOLD=XA(N)

      else !(norder.eq.1) then

        IF (MODE.LT.0.or.nold.ne.n) THEN
          KLO=1
        ELSE IF(
     &      XA(1).EQ.XA1OLD
     &      .AND. XA(N).EQ.XANOLD
     &      .AND. XX.lt.XA(KLOLD)
     &      ) THEN
          KLO=KLOLD
        ELSE
          KLO=1
        ENDIF

        IF (XX.gt.XA(KLO+1)) THEN
          KHI=KLO+1
          GOTO 21
        ENDIF

        KHI=N
11      IF (KHI-KLO.GT.1) THEN
          K=(KHI+KLO)/2
          IF(XA(K).LT.XX)THEN
            KHI=K
          ELSE
            KLO=K
          ENDIF
          GOTO 11
        ENDIF

21      H=XA(KHI)-XA(KLO)

        IF (H.ge.0.0D0) THEN
          WRITE(6 ,*)'*** ERROR IN UTIL_SPLINE_INTER: BAD INPUT ***'
          STOP
        ENDIF

        A=(XA(KHI)-XX)/H
        B=(XX-XA(KLO))/H
        Y=A*YA(KLO)+B*YA(KHI)+
     &    (A*(A+1.D0)*(A-1.D0)*Y2A(KLO)+B*(B+1.D0)*
     &    (B-1.D0)*Y2A(KHI))*(H**2)/6.D0

        KLOLD=KLO
        NOLD=N
        XA1OLD=XA(1)
        XANOLD=XA(N)

      endif !(norder.eq.1) then

      RETURN
      END
+DECK,UTIL_TEST_BATCH.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.48/00 26/01/2004  09.37.25  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.25.51  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE UTIL_TEST_BATCH(IBATCH)
+seq,gplhint.

      CHARACTER(11) TESTBATCH
      INTEGER IBATCH

      CALL UTIL_GET_MODE(TESTBATCH)

C----------- OLD -------------------------------------------
C     CHARACTER(11) TESTBATCH
C     CALL LIB$SPAWN('@UTIL:UTIL_TEST_BATCH.COM')
C     OPEN(UNIT=10,FILE='UTIL:TEST_BATCH.DAT',STATUS='OLD')
C     READ(10,'(1A11)')TESTBATCH
C----------- OLD -------------------------------------------

      IF (TESTBATCH.EQ.'BATCH') THEN
        IBATCH=1
      ELSE
        IBATCH=0
      ENDIF

      RETURN
      END
+DECK,UTIL_VCROSS.
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  1.02/01 27/11/97  10.24.46  by  Michael Scheer
*-- Author :    Michael Scheer   27/11/97
      SUBROUTINE UTIL_VCROSS(X,Y,Z)
+seq,gplhint.

      IMPLICIT NONE

      DOUBLE PRECISION X(3),Y(3),Z(3)

C     Z=[X,Y] vector product, cross product

      Z(1)=X(2)*Y(3)-X(3)*Y(2)
      Z(2)=X(3)*Y(1)-X(1)*Y(3)
      Z(3)=X(1)*Y(2)-X(2)*Y(1)


      RETURN
      END
+DECK,UTIL_VCROSS_VCROSS.
*CMZ :  2.20/10 06/04/2001  12.56.07  by  Michael Scheer
*-- Author :    Michael Scheer   03/04/2001
      SUBROUTINE UTIL_VCROSS_VCROSS(A,B,C,V)
+seq,gplhint.


      IMPLICIT NONE

      DOUBLE PRECISION A(3),B(3),C(3),V(3),AB,AC

C     CALCULATE V = A x ( B x C)

      AC=A(1)*C(1)+A(2)*C(2)+A(3)*C(3)
      AB=A(1)*B(1)+A(2)*B(2)+A(3)*B(3)

      V(1)=B(1)*AC-C(1)*AB
      V(2)=B(2)*AC-C(2)*AB
      V(3)=B(3)*AC-C(3)*AB

      RETURN
      END
+DECK,util_vnorm.
*CMZ :  0.99/00 16/02/2004  17.22.39  by  Michael Scheer
*-- Author :    Michael Scheer   26/01/2004
      subroutine util_vnorm(ndim,vin,vout)
+seq,gplhint.

      implicit none

      double precision vin(3),vout(3),vn
      integer ndim,i

      vn=0.d0
      do i=1,ndim
        vn=vn+vin(i)*vin(i)
      enddo

      if (vn.ne.0.d0) then
        vn=1.d0/sqrt(vn)
        do i=1,ndim
          vout(i)=vin(i)*vn
        enddo
      else
        do i=1,ndim
          vout(i)=vin(i)
        enddo
        print *
        print *,'*** Warning in util_vnorm: Zero length of vector'
        print *
      endif

      return
      end
+DECK,UTIL_WARTE.
*CMZ :  4.00/04 17/05/2019  11.51.09  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.48/04 16/03/2004  10.43.05  by  Michael Scheer
*CMZ :  2.48/03 03/03/2004  12.49.39  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.02  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  18.04.15  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  16.08.41  by  Michael Scheer
*CMZ :  1.03/06 11/06/98  10.26.40  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.28.07  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE UTIL_WARTE(IBATCH)
+seq,gplhint.

      IMPLICIT NONE

      INTEGER IBATCH
      CHARACTER(5) ANS

      WRITE(6,*)
      WRITE(6,*)'PAUSE CAUSED BY ROUTINE UTIL_WARTE'
      WRITE(6,*)
      READ(5,'(1A5)',ERR=99) ANS

      IF (IBATCH.NE.0) RETURN

+SELF,IF=VMS.
      IF (ANS.EQ.'BLITZ'.OR.ANS.EQ.'blitz') THEN
         CALL LIB$SPAWN('$WAIT 00:00:1')
      ELSEIF (ANS.EQ.'SHORT'.OR.ANS.EQ.'short') THEN
         CALL LIB$SPAWN('$WAIT 00:00:15')
      ELSEIF (ANS.EQ.'LONG'.OR.ANS.EQ.'long') THEN
         CALL LIB$SPAWN('$WAIT 00:05:00')
      ELSEIF (ANS.EQ.'PAUSE'.OR.ANS.EQ.'pause') THEN
         CALL LIB$SPAWN('$WAIT 01:00:00')
      ENDIF
+SELF.

+SELF,IF=LINUX,HPUX,TRUE64.
      IF (ANS.EQ.'BLITZ'.OR.ANS.EQ.'blitz') THEN
         call sleep(1)
      ELSE IF (ANS.EQ.'SHORT'.OR.ANS.EQ.'short') THEN
         call sleep(15)
      ELSE IF (ANS.EQ.'LONG'.OR.ANS.EQ.'long') THEN
        call sleep(300)
      ELSE IF (ANS.EQ.'PAUSE'.OR.ANS.EQ.'pause') THEN
        call sleep(3600)
      ENDIF
+SELF.

+SELF,IF=WINDOWS.
      IF (ANS.EQ.'BLITZ'.OR.ANS.EQ.'blitz') THEN
         CALL SLEEP(1)
      ELSEIF (ANS.EQ.'SHORT'.OR.ANS.EQ.'short') THEN
         CALL SLEEP(15)
      ELSEIF (ANS.EQ.'LONG'.OR.ANS.EQ.'long') THEN
         CALL SLEEP(300)
      ELSEIF (ANS.EQ.'PAUSE'.OR.ANS.EQ.'pause') THEN
         CALL SLEEP(3600)
      ENDIF
+SELF.

99    RETURN
      END
+DECK,VPOT2DH.
*CMZ :  2.41/08 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.16/08 29/10/2000  17.44.31  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  1.00/00 30/06/97  11.38.41  by  Michael Scheer
*CMZ : 00.02/04 10/02/97  14.07.52  by  Michael Scheer
*CMZ : 00.02/03 04/02/97  16.50.14  by  Michael Scheer
*-- Author :    Michael Scheer   22/01/97
      SUBROUTINE VPOT2DH
+seq,gplhint.
+SELF,IF=-F90.
     &(NPOI,X,Y,Z,BX,BY,BZ,IFAIL)
+SELF,IF=F90.
     &(NPOI,IFAIL)
+SELF.

+SEQ,BPOLY2DHF90U,IF=F90.

C---  TO FIT POTENTIAL WITH TRANSVERSAL POLYNOMIAL AND
C     LONGITUDINAL SIN/COS-LIKE ANSATZ
C     OF A MAGNETIC FIELD B=(BX,BY,BZ)=-GRAD(V)
C

C--- INPUT:

C     NPOI  : NUMBER OF DATA POINTS X,Y,Z,BX,BY,BZ

C--- OUTPUT:

C     IFAIL : FAILURE FLAG

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,CMPARA.
+SEQ,MYFILES.
+SEQ,BPOLY2DH.

      INTEGER NPOI

+SELF,IF=-F90.
      DOUBLE PRECISION X(NPOI),Y(NPOI),Z(NPOI),BX(NPOI),BY(NPOI),BZ(NPOI)
+SELF.

      INTEGER IFAIL,NARG,NFUN,IPOI,IPAR,NPARP
      PARAMETER (NPARP=NPARTOTP,NFUN=3,NARG=3)

+SELF,IF=-F90.
      DOUBLE PRECISION FUNDATA(NARG+NFUN,N2DHPOIP)
+SELF.
      DOUBLE PRECISION WS(NARG+NFUN)
      DOUBLE PRECISION PARAM(NPARP),A(NPARP,NPARP),T(NFUN,NPARP)

C NOTE CHANGE COORDINATE SYSTEMS!

+SELF,IF=F90.
      ALLOCATE(FUNDATA(NARG+NFUN,NPOI))
+SELF.
      DO IPOI=1,NPOI
         fundata(1,IPOI)=-z(IPOI)
         fundata(2,IPOI)=y(IPOI)
         fundata(3,IPOI)=x(IPOI)
         fundata(4,IPOI)=-BZ(IPOI)
         fundata(5,IPOI)=BY(IPOI)
         fundata(6,IPOI)=BX(IPOI)
      ENDDO

+SELF,IF=-F90.
      CALL UTIL_LINEAR_FIT
     &  (IFAIL,NPARTOT,PARAM,N2DHPOIP,NPOI,NARG,NFUN,A,T,FUNDATA,WS)
+SELF,IF=F90.
      CALL UTIL_LINEAR_FIT
     &  (IFAIL,NPARTOT,PARAM,NPOI,NPOI,NARG,NFUN,A,T,FUNDATA,WS)
+SELF.
      IF (IFAIL.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN VPOT2DH: FIT FAILED'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'IFAIL:',IFAIL
            WRITE(LUNGFO,*) '(maybe no transversal field gradient'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** WARNING IN VPOT2DH: FIT FAILED'
          WRITE(6,*)
          WRITE(6,*)'IFAIL:',IFAIL
            WRITE(6,*) '(maybe no transversal field gradient'
          WRITE(6,*)
      ENDIF

      DO IPAR=1,NPARTOT
          PAR2DH(IPAR)=PARAM(IPAR)
      ENDDO

+SELF,IF=F90.
      DEALLOCATE(FUNDATA)
+SELF.
      RETURN
      END
+DECK,VPOT3D.
*CMZ :  2.69/00 18/09/2013  12.33.23  by  Michael Scheer
*CMZ :  2.41/10 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.33  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.02.52  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  22.20.56  by  Michael Scheer
*CMZ : 00.02/00 13/11/96  16.46.41  by  Michael Scheer
*CMZ :  1.00/03 27/09/95  17.15.24  by  Michael Scheer
*CMZ :  1.00/01 25/09/95  18.20.26  by  Michael Scheer
*CMZ :  1.00/00 21/09/95  17.13.57  by  Michael Scheer
*-- Author :    Michael Scheer   21/09/95
      SUBROUTINE VPOT3D(NPOI,X,Y,Z,BX,BY,BZ,IFAIL,COMMENT)
+seq,gplhint.

C---  TO FIT 3D POTENTIAL V=SUM( C(I,J,K) * X**(I-1) * Y**(J-1) * Z**(K-1))
C     OF A MAGNETIC FIELD B=(BX,BY,BZ)=-GRAD(V)
C

C--- INPUT:

C     NPOI  : NUMBER OF DATA POINTS X,Y,Z,BX,BY,BZ

C--- OUTPUT:

C     IFAIL : FAILURE FLAG
C     COMMENT : COMMENT ON COEF-FILE (SR VPOT3DINIT)

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,BPOLY3D.

      INTEGER NPOI,IFAIL,MCOEF

      DOUBLE PRECISION X(NPOI),Y(NPOI),Z(NPOI),BX(NPOI),BY(NPOI),BZ(NPOI)


      INTEGER NDIMP,NSTAKP
      PARAMETER (NDIMP=256,NSTAKP=16)

        CHARACTER(60) COMMENT

      INTEGER JDIMP
      PARAMETER (JDIMP=NDIMC+1)
      INTEGER ICAL,NCOEF,INDEX(4,NDIMP),ICOEF,IX,IY,IZ,IS,NS
     &         ,JX,JY,JZ,JNDEX(JDIMP,JDIMP,JDIMP)

      DOUBLE PRECISION VC(NDIMP),A(NDIMP,NDIMP),B(NDIMP),WS(2*NDIMP)
     &                  ,WA(NDIMP,NDIMP),WB(NDIMP)
     &                  ,XPOW(NDIMP),YPOW(NDIMP),ZPOW(NDIMP)
     &                  ,FSTAK(4,NSTAKP,NDIMP)


      DATA ICAL/0/

      DO IZ=1,MORD3D+1
      DO IY=1,MORD3D+1
      DO IX=1,MORD3D+1
          JNDEX(IX,IY,IZ)=-1
      ENDDO
      ENDDO
      ENDDO

      IF (ICAL.EQ.0) THEN
          CALL VPOT3DINIT(NDIMP,LORD3D,MORD3D,NDORD3D,INDEX,NCOEF,NSTAKP,FSTAK
     &                        ,LUN3DCOE,FILE3DCOE,COMMENT)
      ENDIF

      IF (NCOEF.GT.NDIMP) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'ERROR IN VPOT3D: DIMENSION NDIMP EXCEEDED ***'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'ERROR IN VPOT3D: DIMENSION NDIMP EXCEEDED ***'
          WRITE(6,*)
          STOP
      ENDIF

      CALL VPOT3DFIT(NPOI,X,Y,Z,BX,BY,BZ,NDIMP,NCOEF,MORD3D
     &                       ,INDEX,VC,NSTAKP,FSTAK,A,B,WS,WA,WB
     &                       ,XPOW,YPOW,ZPOW,IFAIL)

      DO IZ=1,NDIMC
      DO IY=1,NDIMC
      DO IX=1,NDIMC
          C(IX,IY,IZ)=0.D0
      ENDDO
      ENDDO
      ENDDO

C--- GET FITTED COEFFICIENTS

      DO ICOEF=1,NCOEF
          IX=INDEX(1,ICOEF)
          IY=INDEX(2,ICOEF)
          IZ=INDEX(3,ICOEF)
          IF (IX+1.GT.NDIMC.OR.IY+1.GT.NDIMC.OR.IZ+1.GT.NDIMC) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)'ERROR IN VPOT3D: DIMENSION NDIMC EXCEEDED ***'
             WRITE(LUNGFO,*)
             WRITE(6,*)
             WRITE(6,*)'ERROR IN VPOT3D: DIMENSION NDIMC EXCEEDED ***'
             WRITE(6,*)
             STOP
          ENDIF
          C(IX+1,IY+1,IZ+1)=VC(ICOEF)
          JNDEX(IX+1,IY+1,IZ+1)=1
      ENDDO

C--- CALCULATE OTHER COEFFICIENTS

      DO ICOEF=1,NCOEF
            NS=INDEX(4,ICOEF)
          IF (NS.GT.1) THEN
             IX=INDEX(1,ICOEF)
             IY=INDEX(2,ICOEF)
             IZ=INDEX(3,ICOEF)
             DO IS=1,NS
            JX=NINT(FSTAK(1,IS,ICOEF))
            JY=NINT(FSTAK(2,IS,ICOEF))
            JZ=NINT(FSTAK(3,IS,ICOEF))
            IF (IX.NE.JX.OR.IY.NE.JY.OR.IZ.NE.JZ) THEN
            IF (IX+1.GT.NDIMC.OR.IY+1.GT.NDIMC.OR.IZ+1.GT.NDIMC) THEN
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'ERROR IN VPOT3D: DIMENSION NDIMC EXCEEDED ***'
                WRITE(LUNGFO,*)
                WRITE(6,*)
                WRITE(6,*)'ERROR IN VPOT3D: DIMENSION NDIMC EXCEEDED ***'
                WRITE(6,*)
                STOP
            ENDIF
            C(JX+1,JY+1,JZ+1)=C(JX+1,JY+1,JZ+1)
     &                 +FSTAK(4,IS,ICOEF)*C(IX+1,IY+1,IZ+1)
            JNDEX(JX+1,JY+1,JZ+1)=1
                 ENDIF
             ENDDO   !IS
         ENDIF
      ENDDO

      MCOEF=0
      DO IZ=1,MORD3D+1
      DO IY=1,MORD3D+1
      DO IX=1,MORD3D+1
          IF (JNDEX(IX,IY,IZ).EQ.1) MCOEF=MCOEF+1
      ENDDO
      ENDDO
      ENDDO

      IF (ICAL.EQ.0) THEN
      WRITE(LUNGFO,*)'     SR VPOT3D:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     number of fitted coefficients:    ',NCOEF
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     number of fitted and calc. coeff.:',MCOEF
      WRITE(LUNGFO,*)
          ICAL=1
      ENDIF

      RETURN
      END
+DECK,VPOT3DFIT.
*CMZ :  2.13/05 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  14.58.52  by  Michael Scheer
*CMZ : 00.01/09 06/10/95  16.26.59  by  Michael Scheer
*CMZ :  1.00/01 26/09/95  16.53.15  by  Michael Scheer
*CMZ :  1.00/00 21/09/95  17.14.11  by  Michael Scheer
*-- Author :    Michael Scheer   21/09/95
      SUBROUTINE VPOT3DFIT(NPOI,X,Y,Z,BX,BY,BZ,NDIMP,N,MORD
     &                       ,INDEX,VC,NSTAKP,FSTAK,A,B,WS,WA,WB
     &                       ,XPOW,YPOW,ZPOW,IFAIL)
+seq,gplhint.

C--- FITS V=...+VC(IXYZ)*X**(INDEX(1,IXYZ))*Y**(INDEX(2,IXYZ))*Z**(INDEX(3,IXYZ)
C--- WITH (BX,BY,BZ)=-GRAD(V)

C---  INPUT:
C-    NPOI      : NUMBER OF POINTS X,F(X)
C-    NDIMP       :  DIMENSION PARAMETER OF ARRAYS A,B,WS,WA,WB,
C-    N           :  NUMBER OF COEFFICIENTS VC
C-    X,Y,Z     : ARGUMENTS OF FUNCTION F(X,Y,Z)
C-    BX,BY,BZ    :  MAGNETIC FIELD COMPONENTS
C-    MORD      :   HIGHEST ORDER OF FITTED COEFFS
C-    INDEX     :   INDEX(3,N) IS POINTER TO INDICES I,J,K
C-    NSTAKP       : STACK DIMENSION
C-    FSTAK     :   STACK OF COEFFICIENTS FSTAK(4,NSTAKP,N)

C---  OUTPUT:
C-    VC     : COEFFICIENTS VC(N) TO BE FITTED
C-    IFAIL       :  FAILURE FLAG

C---  WORKING SPACE:
C-    A  :  MATRIX OF EQUATION SYSTEM A(NDIMP,NDIMP)
C-    B  :  INHOMOGENITY OF EQUATION SYSTEM B(NDIMP)
C-    WS :  WORKING SPACE WS(2*NDIMP)
C-    WA :  WORKING SPACE WA(NDIMP,NDIMP)
C-    WB :  WORKING SPACE WB(NDIMP)
C-    XPOW  :  WORKING SPACE XPOW(N)
C-    YPOW  :  WORKING SPACE YPOW(N)
C-    ZPOW  :  WORKING SPACE ZPOW(N)

      IMPLICIT NONE

+SEQ,CONTRL.

      INTEGER NPOI,N,MORD,INDEX(4,N),IFAIL,NDIMP,NSTAKP
      INTEGER IX,IY,IZ,JX,JY,JZ,IXYZ,JXYZ,IPOI,IFIT,JFIT,NFIT,IS,NS,JS,MS
      INTEGER IDELTA

      DOUBLE PRECISION X(NPOI),Y(NPOI),Z(NPOI),BX(NPOI),BY(NPOI),BZ(NPOI)
     &                  ,VC(N),DELTA,DELTAMX
     &                  ,A(NDIMP,NDIMP),WA(NDIMP,NDIMP)
     &                  ,B(NDIMP),WS(2*NDIMP),WB(NDIMP)
     &                  ,XPOW(MORD+1),YPOW(MORD+1),ZPOW(MORD+1)
     &                  ,FSTAK(4,NSTAKP,N)

      DOUBLE PRECISION AX1,AY1,AZ1,AX2,AY2,AZ2,XPOI,YPOI,ZPOI
     &                  ,XPOW1,YPOW1,ZPOW1
     &                  ,XPOW2,YPOW2,ZPOW2
     &         ,BSUM,X99,Y99,Z99
      IFAIL=0

      IF (N.GT.NPOI) THEN
          WRITE(LUNGFO,*)
     &      '*** WARNING SR VPOT3DFIT: NOT ENOUGH DATA'
          WRITE(6,*)
     &      '*** WARNING SR VPOT3DFIT: NOT ENOUGH DATA'
          IFAIL=999
          RETURN
      ENDIF

      DO IXYZ=1,N
          B(IXYZ)=0.D0
          VC(IXYZ)=0.D0
      ENDDO

      DO IY=1,N
      DO IX=1,N
          A(IX,IY)=0.D0
      ENDDO
      ENDDO

C- DO THE FITTING

      NFIT=N

      DO IPOI=1,NPOI

          XPOI=X(IPOI)
          YPOI=Y(IPOI)
          ZPOI=Z(IPOI)

          XPOW(1)=1.D0
          DO IX=2,MORD+1
          XPOW(IX)=XPOW(IX-1)*XPOI
        ENDDO

          YPOW(1)=1.D0
          DO IY=2,MORD+1
          YPOW(IY)=YPOW(IY-1)*YPOI
        ENDDO

          ZPOW(1)=1.D0
          DO IZ=2,MORD+1
          ZPOW(IZ)=ZPOW(IZ-1)*ZPOI
        ENDDO

        IF (BX(IPOI).EQ.-9999.) THEN
          X99=0.0D0
        ELSE
          X99=1.0D0
        ENDIF

        IF (BY(IPOI).EQ.-9999.) THEN
          Y99=0.0D0
        ELSE
          Y99=1.0D0
        ENDIF

        IF (BZ(IPOI).EQ.-9999.) THEN
          Z99=0.0D0
        ELSE
          Z99=1.0D0
        ENDIF


      IFIT=0
      DO IXYZ=1,NFIT

         IFIT=IFIT+1

           NS=INDEX(4,IXYZ)

           BSUM=0.D0
           AX1=0.D0
           AY1=0.D0
           AZ1=0.D0
           DO IS=1,NS

            IX=NINT(FSTAK(1,IS,IXYZ))+1
            IY=NINT(FSTAK(2,IS,IXYZ))+1
            IZ=NINT(FSTAK(3,IS,IXYZ))+1

                      IF(IX.GT.1) THEN
                         XPOW1=XPOW(IX-1)
            ELSE
                         XPOW1=1.D0
                      ENDIF

                      IF(IY.GT.1) THEN
                         YPOW1=YPOW(IY-1)
            ELSE
                         YPOW1=1.D0
                      ENDIF

                      IF(IZ.GT.1) THEN
                         ZPOW1=ZPOW(IZ-1)
            ELSE
                         ZPOW1=1.D0
                      ENDIF

            BSUM=BSUM+FSTAK(4,IS,IXYZ)*(
     &                  -(IX-1)*BX(IPOI)*XPOW1*YPOW(IY)*ZPOW(IZ)*X99
     &         -(IY-1)*BY(IPOI)*YPOW1*XPOW(IX)*ZPOW(IZ)*Y99
     &              -(IZ-1)*BZ(IPOI)*ZPOW1*XPOW(IX)*YPOW(IY)*Z99
     &                  )

                  AX1=AX1
     &                     +X99*FSTAK(4,IS,IXYZ)*(IX-1)*XPOW1*YPOW(IY)*ZPOW(IZ)
                      AY1=AY1
     &                     +Y99*FSTAK(4,IS,IXYZ)*(IY-1)*YPOW1*XPOW(IX)*ZPOW(IZ)
            AZ1=AZ1
     &                      +Z99*FSTAK(4,IS,IXYZ)*(IZ-1)*ZPOW1*XPOW(IX)*YPOW(IY)

         ENDDO !NS

                      B(IFIT)=B(IFIT)+BSUM

      JFIT=0
      DO JXYZ=1,NFIT

         JFIT=JFIT+1

           MS=INDEX(4,JXYZ)

           AX2=0.D0
           AY2=0.D0
           AZ2=0.D0
           DO JS=1,MS

            JX=NINT(FSTAK(1,JS,JXYZ))+1
            JY=NINT(FSTAK(2,JS,JXYZ))+1
            JZ=NINT(FSTAK(3,JS,JXYZ))+1

                      IF(JX.GT.1) THEN
                         XPOW2=XPOW(JX-1)
            ELSE
                         XPOW2=1.D0
                      ENDIF

                      IF(JY.GT.1) THEN
                         YPOW2=YPOW(JY-1)
            ELSE
                         YPOW2=1.D0
                      ENDIF

                      IF(JZ.GT.1) THEN
                         ZPOW2=ZPOW(JZ-1)
            ELSE
                         ZPOW2=1.D0
                      ENDIF

                  AX2=AX2
     &                     +X99*FSTAK(4,JS,JXYZ)*(JX-1)*XPOW2*YPOW(JY)*ZPOW(JZ)
                      AY2=AY2
     &                     +Y99*FSTAK(4,JS,JXYZ)*(JY-1)*YPOW2*XPOW(JX)*ZPOW(JZ)
            AZ2=AZ2
     &                      +Z99*FSTAK(4,JS,JXYZ)*(JZ-1)*ZPOW2*XPOW(JX)*YPOW(JY)

         ENDDO !NS

         A(IFIT,JFIT)=A(IFIT,JFIT)+AX1*AX2+AY1*AY2+AZ1*AZ2

      ENDDO !JXYZ
      ENDDO !IXYZ

      ENDDO !IPOI

      DO IXYZ=1,NFIT
         WB(IXYZ)=B(IXYZ)
      ENDDO

      DO IY=1,NFIT
      DO IX=1,NFIT
              WA(IX,IY)=A(IX,IY)
      ENDDO
      ENDDO

      DO IXYZ=1,NFIT
         WB(IXYZ)=B(IXYZ)
      ENDDO

      DO IY=1,NFIT
      DO IX=1,NFIT
              WA(IX,IY)=A(IX,IY)
      ENDDO
      ENDDO

        CALL DEQN(NFIT,WA,NDIMP,WS,IFAIL,1,WB) !CERN F010

      DO IFIT=1,NFIT
         VC(IFIT)=WB(IFIT)
      ENDDO

      DELTAMX=-1.D30
      DO IX=1,NFIT
      DELTA=0.D0
      DO IY=1,NFIT
          DELTA=DELTA+A(IX,IY)*WB(IY)
      ENDDO
      DELTA=DABS(DELTA-B(IX))
      IF (DELTA.GT.DELTAMX) THEN
          DELTAMX=DELTA
          IDELTA=IX
      ENDIF
      ENDDO

      IF (DELTAMX.GT.1.D-5) THEN
          WRITE(LUNGFO,*)
     &'*** WARNING SR VPOT3DFIT: PROBABLY PROBLEM WITH LINEAR EQUATION SYSTEM'
          WRITE(6,*)
     &'*** WARNING SR VPOT3DFIT: PROBABLY PROBLEM WITH LINEAR EQUATION SYSTEM'
      WRITE(6,*)'     max. error of DEQN and corresponding coefficient:'
      WRITE(6,*)'     ',SNGL(DELTAMX),SNGL(VC(IDELTA))
     &                   ,' = C',INDEX(1,IDELTA)
     &                   ,INDEX(2,IDELTA),INDEX(3,IDELTA)
      ENDIF

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     max. error of DEQN and corresponding coefficient:'
      WRITE(LUNGFO,*)'     ',SNGL(DELTAMX),SNGL(VC(IDELTA))
     &                       ,' = C',INDEX(1,IDELTA)
     &                        ,INDEX(2,IDELTA),INDEX(3,IDELTA)
      WRITE(LUNGFO,*)

      RETURN
      END
+DECK,VPOT3DINIT.
*CMZ :  2.41/10 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.33  by  Michael Scheer
*CMZ : 00.01/09 05/10/95  16.34.35  by  Michael Scheer
*CMZ :  1.00/01 25/09/95  14.26.06  by  Michael Scheer
*CMZ :  1.00/00 21/09/95  17.14.08  by  Michael Scheer
*-- Author :    Michael Scheer   21/09/95
      SUBROUTINE VPOT3DINIT(NDIMP,LORD,MORD,NDORD,INDEX,NCOEF,NSTAKP,FSTAK
     &                        ,LUNCOEFF,FILECOEFF,COMMENT)
+seq,gplhint.

      IMPLICIT NONE

+SEQ,CONTRL.

      CHARACTER(60) FILECOEFF,COMMENT

      INTEGER NDIMP,INDEX(4,NDIMP),NSTAKP,NCOEF
     &         ,LUNCOEFF,IORD,LORD,MORD,NDORD

      INTEGER IX,IY,IZ,IS,NS,IR,IXYZ,IFOUND

      DOUBLE PRECISION FSTAK(4,NSTAKP,NDIMP)

      NCOEF=0
      OPEN(UNIT=LUNCOEFF,FILE=FILECOEFF,STATUS='OLD')

          READ(LUNCOEFF,'(A60)')COMMENT
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     SR VPOT3DINIT:'
          WRITE(LUNGFO,*)'     comment on COEF-FILE:'
          WRITE(LUNGFO,*)'     ',COMMENT
          WRITE(LUNGFO,*)
100       READ(LUNCOEFF,*,END=900) IX,IY,IZ,NS

          DO IORD=LORD,MORD,NDORD
         IF(IX+IY+IZ.EQ.IORD) GOTO 50
          ENDDO
          GOTO 100

50        NCOEF=NCOEF+1

          IF (NCOEF.GT.NDIMP) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &   '*** ERROR IN VPOT3DINIT: DIMENSION NDIMP EXCEEDED ***'
             WRITE(LUNGFO,*)
             WRITE(6,*)
             WRITE(6,*)
     &   '*** ERROR IN VPOT3DINIT: DIMENSION NDIMP EXCEEDED ***'
             WRITE(6,*)
             STOP
          ENDIF

          IF (NS.GT.NSTAKP) THEN
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)
     &   '*** ERROR IN VPOT3DINIT: DIMENSION NSTAKP EXCEEDED ***'
             WRITE(LUNGFO,*)
             WRITE(6,*)
             WRITE(6,*)
     &   '*** ERROR IN VPOT3DINIT: DIMENSION NSTAKP EXCEEDED ***'
             WRITE(6,*)
             STOP
          ENDIF

          INDEX(1,NCOEF)=IX
          INDEX(2,NCOEF)=IY
          INDEX(3,NCOEF)=IZ

          IF (NS.GT.0) THEN
         INDEX(4,NCOEF)=NS
         DO IS=1,NS
             READ(LUNCOEFF,*)(FSTAK(IR,IS,NCOEF),IR=1,4)
         ENDDO
          ELSE
         INDEX(4,NCOEF)=1
         FSTAK(1,1,NCOEF)=IX
         FSTAK(2,1,NCOEF)=IY
         FSTAK(3,1,NCOEF)=IZ
         FSTAK(4,1,NCOEF)=1.D0
          ENDIF   !IS

      GOTO 100

900   CLOSE(LUNCOEFF)


      DO IORD=LORD,MORD,NDORD
      IFOUND=0
      DO IXYZ=1,NCOEF
         IX=INDEX(1,IXYZ)
         IY=INDEX(2,IXYZ)
         IZ=INDEX(3,IXYZ)
         IF (IX+IY+IZ.EQ.IORD) IFOUND=1
      ENDDO
      IF (IFOUND.EQ.0) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)
     &'*** WARNING SR VPOT3DINIT: NO COEFFICIENTS FOUND FOR INQUIRED ORDER ***'
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'ORDER :',IORD
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)
     &'*** WARNING SR VPOT3DINIT: NO COEFFICIENTS FOUND FOR INQUIRED ORDER ***'
         WRITE(6,*)
         WRITE(6,*)'ORDER :',IORD
         WRITE(6,*)
      ENDIF
      ENDDO

      RETURN
      END
+DECK,VPOTPH.
*CMZ :  3.00/01 20/03/2013  10.20.10  by  Michael Scheer
*CMZ :  2.44/00 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.42/04 29/10/2002  10.25.44  by  Michael Scheer
*CMZ :  2.41/08 12/08/2002  16.38.26  by  Michael Scheer
*CMZ :  2.16/08 29/10/2000  17.38.47  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  1.00/00 30/06/97  11.45.36  by  Michael Scheer
*CMZ : 00.02/04 18/02/97  12.21.58  by  Michael Scheer
*CMZ : 00.02/03 04/02/97  16.50.14  by  Michael Scheer
*-- Author :    Michael Scheer   22/01/97
      SUBROUTINE VPOTPH(NPOI,IFAIL)
+seq,gplhint.

+SEQ,BPHARMF90U,IF=F90.

C--- INPUT:

C     NPOI  : NUMBER OF DATA POINTS X,Y,Z,BX,BY,BZ

C--- OUTPUT:

C     IFAIL : FAILURE FLAG

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,CMPARA.
+SEQ,MYFILES.
+SEQ,BPHARM.

      INTEGER NPOI

      INTEGER IFAIL,NARG,NFUN,IPOI,ITRANS,IHARM
      PARAMETER (NFUN=3,NARG=3)

      DOUBLE PRECISION WS(NARG+NFUN)
      DOUBLE PRECISION A(NPARPHP,NPARPHP),T(NFUN,NPARPHP)

      ALLOCATE(FUNDATA(NARG+NFUN,NPOI))

C NOTE CHANGE OF COORDINATE SYSTEMS!

      DO IPOI=1,NPOI
        fundata(1,IPOI)=-z(IPOI)
        fundata(2,IPOI)=y(IPOI)
        fundata(3,IPOI)=x(IPOI)
        fundata(4,IPOI)=-BZ(IPOI)
        fundata(5,IPOI)=BY(IPOI)
        fundata(6,IPOI)=BX(IPOI)
      ENDDO

      NPARPH=3
      DO ITRANS=NTRANS0,NTRANS,NTRANSD
        IF (NTRANS0.GT.0) THEN
          DO IHARM=NHARM0,NHARM,NHARMD
            NPARPH=NPARPH+2
          ENDDO
        ENDIF
      ENDDO

      CALL BPHARM_FIT
     &  (IFAIL,NPARPH,PARPH,NPOI,NPOI,NARG,NFUN,A,T,FUNDATA,WS)

      IF (IFAIL.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN VPOTPH: FIT FAILED'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'IFAIL:',IFAIL
        WRITE(LUNGFO,*) '(maybe no transversal field gradient'
        WRITE(LUNGFO,*) '(or XLENCPH, YLENSPH zero)'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN VPOTPH: FIT FAILED'
        WRITE(6,*)
        WRITE(6,*)'IFAIL:',IFAIL
        WRITE(6,*) '(maybe no transversal field gradient'
        WRITE(6,*) '(or XLENCPH, YLENSPH zero)'
        WRITE(6,*)
      ENDIF

      DEALLOCATE(FUNDATA)

      RETURN
      END
+DECK,wave,T=F77.
*CMZ :  4.01/02 19/04/2023  08.53.56  by  Michael Scheer
*CMZ :  4.00/17 04/11/2022  09.31.48  by  Michael Scheer
*CMZ :  4.00/16 29/09/2022  11.22.54  by  Michael Scheer
*CMZ :  4.00/13 12/11/2021  12.27.46  by  Michael Scheer
*CMZ :  4.00/07 07/06/2020  11.17.21  by  Michael Scheer
*CMZ :  3.08/01 02/04/2019  19.18.43  by  Michael Scheer
*CMZ :  3.07/01 28/03/2019  13.59.43  by  Michael Scheer
*CMZ :  3.05/06 17/07/2018  12.16.55  by  Michael Scheer
*CMZ :  3.05/01 02/05/2018  15.57.07  by  Michael Scheer
*CMZ :  3.03/04 11/07/2017  13.14.22  by  Michael Scheer
*CMZ :  3.03/02 24/11/2015  16.42.43  by  Michael Scheer
*CMZ :  3.02/03 10/11/2014  10.56.00  by  Michael Scheer
*CMZ :  3.02/00 29/08/2014  17.12.58  by  Michael Scheer
*CMZ :  3.01/06 20/06/2014  16.24.35  by  Michael Scheer
*CMZ :  3.01/05 13/06/2014  11.54.45  by  Michael Scheer
*CMZ :  3.01/00 17/06/2013  08.45.46  by  Michael Scheer
*CMZ :  3.00/01 20/03/2013  14.23.17  by  Michael Scheer
*CMZ :  2.70/06 03/01/2013  16.21.09  by  Michael Scheer
*CMZ :  2.70/00 29/11/2012  16.23.27  by  Michael Scheer
*CMZ :  2.68/02 14/06/2012  11.51.53  by  Michael Scheer
*CMZ :  2.67/04 14/05/2012  13.07.19  by  Michael Scheer
*CMZ :  2.67/02 30/04/2012  15.56.09  by  Michael Scheer
*CMZ :  2.52/16 12/11/2009  16.27.11  by  Michael Scheer
*CMZ :  2.40/00 04/03/2002  19.57.52  by  Michael Scheer
*CMZ :  2.16/08 20/10/2000  11.29.02  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  2.13/11 22/03/2000  15.25.05  by  Michael Scheer
*CMZ :  2.12/00 04/06/99  13.20.48  by  Michael Scheer
*CMZ :  2.00/00 06/01/99  11.57.36  by  Michael Scheer
*CMZ :  1.01/00 26/11/97  17.25.38  by  Michael Scheer
*CMZ : 00.01/10 29/05/96  16.48.55  by  Michael Scheer
*CMZ : 00.01/09 05/10/95  12.45.12  by  Michael Scheer
*CMZ : 00.01/04 09/12/94  11.24.52  by  Michael Scheer
*CMZ : 00.01/02 22/11/94  10.19.46  by  Michael Scheer
*CMZ : 00.01/01 23/06/94  13.26.13  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  12.02.03  by  Michael Scheer
*CMZ : 00.00/03 29/04/94  10.22.08  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.30  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE WAVE
+seq,gplhint.

      use ompmod
      use clustermod

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SELF.

C THIS IS THE PROCESSING ROUTINE OF THE PROGRAM WAVE
C IT CALLS THE INITIALIZATION ROUTINE GFINIT AND THE
C MODULES FOR THE INDIVIDUAL TASKS


      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,DEPOLA.
+SEQ,WLSOPT.
+SEQ,FOURIER.
+SEQ,HALBASY.
+SEQ,SPECT.
+SEQ,TRACK0.
+SEQ,B0SCGLOB.
+seq,gseed.
+seq,random.
+seq,wvers.

      INTEGER NPOL,irootmode,lun,lun99,i,lunpid,iutil_fexist

      DOUBLE PRECISION BETX0,BETY0,BETZ0,BETXF0,BETYF0,BETZF0,
     &            DTIM,BSHIFT,GAMMA

      DOUBLE PRECISION DUM1,DUM2,DUM3,DUM4,DUM5,DUM6,DUM7,DUM8,DUM9,DUM10
      DOUBLE PRECISION DUM11,DUM12,DUM13,DUM14,DUM15,DUM16,DUM17,DUM18,DUM19,DUM20
      DOUBLE PRECISION DUM21,DUM22,DUM23,DUM24
      real dumvers
      integer idumvers

      open(newunit=lunpid,file='wave.pid')
      kpid=getpid()
      write(lunpid,*) kpid
      close(lunpid)

      chwversion=
+seq,wversion.

+self,if=nocern.
      nocern=1
+self,if=-nocern.
      nocern=0
+self.

      do i=1,128
        if (chwversion(i:i).eq."V") then
c          print*,chwversion(i+8:i+11)
          read(chwversion(i+8:i+11),'(f4.2)')wversion
          read(chwversion(i+13:i+14),'(i2)')idumvers
          exit
        endif
      enddo

      dumvers=idumvers
      wversion=wversion+dumvers/10000.

c--- Get environment
c      call waveenvironment
c---  Check clustermod
      call waveinstances

C--- READ CONTROL-FLAGS FROM DATA-FILE AND INITIALIZE REFERENCE ORBIT

      CALL GFINIT (BETX0,BETY0,BETZ0,BETXF0,BETYF0,BETZF0,
     &             DTIM,BSHIFT,GAMMA)

C--- TERMINATE PROGRAM AFTER CALL TO UNAME

      IF (IABEND.EQ.5) goto 9999

C--- TERMINATE PROGRAM IF FOURIER COEFFICIENTS ARE WRITTEN TO FILE

      IF (IABEND.EQ.1) goto 9999

C--- TERMINATE PROGRAM ACCORDING TO WLSJUST

      IF (IABEND.EQ.2) goto 9999

C--- TERMINATE PROGRAM IF 3D POLYNOMIAL COEFFICIENTS ARE WRITTEN TO FILE

      IF (IABEND.EQ.3) THEN
c         CALL HISEND
c        RETURN
        goto 99
      ENDIF

C--- CALCULATE  A SERIES OF TRAJECTORIES AND WRITE INITIAL AND FINAL VALUES
C    ON DATA FILE

      IF (IGENFUN.GT.0) THEN
        if (iutil_fexist("wave_tranpoly.ako").ne.0) then
          print*,"*** Error in wave: File wave_tranpoly.ako already exists ***"
          print*,"*** Program WAVE aborted ***"
          print*,""
          write(lungfo,*)"*** Error in wave: File wave_tranpoly.ako already exists ***"
          write(lungfo,*)"*** Program WAVE aborted ***"
          write(lungfo,*)""
          stop
        endif
      endif

      IF (IOPTIC.NE.0) THEN
          CALL OPTI
     &            (X0,Y0,Z0,BETX0,BETY0,BETZ0,
     &            XF0,YF0,ZF0,BETXF0,BETYF0,BETZF0,
     &            DTIM,BSHIFT,GAMMA)
      ENDIF      !IOPTIC

C--- CALCULATE OPTICAL FUNCTIONS INSIDE THE DEVICE AND EMITTANCE EFFECTS

      IF (IEMIT.NE.0) CALL WBETDIS

C--- CALCULATE EMITTANCE AND POLARISATION EFFECTS OF AHW FROM ANALYTICAL
C    FORMULAS

      IF(IEMIAHW.NE.0) THEN

         CALL EMIT(   B0HALBASY,ZLHALBASY,FASYM,
     &                  DMYENERGY,RDIPOL,TAUPOL01G,BETFUN,DI2RING,DI5RING,
     &                  DUM1,DUM2,DUM3,DUM4,DUM5,DUM6,
     &                  DUM7,DUM8,DUM9,DUM10,DUM11,DUM12,DUM13,DUM14,
     &                  DUM15,DUM16,DUM17,LUNGFO,
     &                  DISP0,DUM18,DUM19,DUM20,DUM21,DUM22,
     &                  DUM23,DUM24)


      ENDIF      !IEMIAHW

C--- UM AEQUIVALENTEN WLS ZU SUCHEN, SIEHE ALTE VERSION VON WAVE.FOR ODER
C    WLS.FOR. (SIEHE Z.B. AUF BACKUP VOM 15.7.92 ODER PROGRAM LISTINGS)
C                                                       21.7.92
C    GLEICHES GILT FUER ALTE ROUTINE DISPER.FOR

C---      SEARCH OPTIMAL PARAMETERS OF SIMPLE WLS MODEL

      IF (IWLSOPT.NE.0) THEN
                 CALL WLSOPT(
     &                1,IEMICRIT,DMYENERGY,B0MIN,B0MAX,DB0,
     &                EMICRTMX,TAUCRTMX,POLLEVMN,
     &                XLAM0MN,XLAM0MX,DXLAM0,FASYMMN,FASYMMX,DFASYM,
     &                BETFUN,RDIPOL,DBHOMF,TAUPOL01G,DI2RING,DI5RING,
     &                ZMAXMX,ZMAXMN,1,LUNGFO,IWLSADI,DISP0,DXHOM)
      ENDIF      !IWLSOPT

C--- CALCULATE COEFFICIENTS OF GENERATING FUNCTION OR MAPPING

      IF (IGENFUN.GT.0) THEN
        CALL TRANPOLY
      ELSE IF (IGENFUN.LT.0) THEN
        WRITE(6,*)'*** ERROR IN WAVE: IGENFUN.LT.0 NOT YET READY ***'
C     CALL TRANMAP ! NOCH IN ENTWICKLUNG: XF,XPF,... KANN NICHT MIT
C     EINEM SATZ VON KOEFFIZIENTEN BESCHRIBEN WERDEN, SONDERN
C     JEDE GROESSE MUSS MIT EINEM SATZ GEFITTET WERDEN. VORERST AUFGEGEBEN...
      ENDIF

C--- CALCULATE SPECTRUM

      IF(ISPEC.NE.0) CALL SPECTRUM

C--- TERMINATE PROGRAM AFTER CALL ADDAMPLI

      IF (IABEND.EQ.6) goto 9999

C--- CALCULATE POWER DENSITY ALONG BEAMLINE

      IF (IPOWER.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'     RESULTS FROM SR BEAMPOW:'
          WRITE(LUNGFO,*)

          CALL BEAMPOW(NPOL)

          WRITE(LUNGFO,*)
     &'     Number of poles detected:                           ',NPOL
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &'     z-Positions of beamline walls [m]:                  '
          WRITE(LUNGFO,*)
     &'                                         ',SNGL(WALL(1)),SNGL(WALL(2))
          WRITE(LUNGFO,*)
     &'     Start and end of beamline (x) [m]:                  '
          WRITE(LUNGFO,*)
     &'                                         ',SNGL(XWALLI),SNGL(XWALLE)
          WRITE(LUNGFO,*)
     &'     Minimum distance to trajectory [m]:                 ',TOTMAX(11)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &'     x-Position of absorber:                             ',
     &      SNGL(XABSORB)
          WRITE(LUNGFO,*)
     &'     Start and end of absorber (z) [m]:                  '
          WRITE(LUNGFO,*)
     &'                                         '
     &     ,SNGL(ZABSORB(1)),SNGL(ZABSORB(2))
          WRITE(LUNGFO,*)
     &'     Minimum distance to trajectory [m]:                 ',
     &      TOTMAX(12)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &'     Number of considered points (NPWALL):              ',NPWALL
          WRITE(LUNGFO,*)
     &'     Cutoff of magnetic field (POWBCUT):                ',
     &      SNGL(POWBCUT)
C3.5.93          WRITE(LUNGFO,*)'CORRECTION FACTOR POWCOR:',SNGL(POWCOR)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &'     Integrated power on beamline walls [W]:            '
          WRITE(LUNGFO,*)
     &'                                         ',TOTGAM(3),TOTGAM(4)
          WRITE(LUNGFO,*)
     &'     Integrated power on absorber [W]:                  ',
     &      TOTGAM(6)

          WRITE(LUNGFO,*)
     &'     Maximum power densities on beamline walls [W/m**2]:'
          WRITE(LUNGFO,*)
     &'                                         ',TOTMAX(1),TOTMAX(2)
          WRITE(LUNGFO,*)
     &'     Maximum power density on absorber [W/m**2]:        ',TOTMAX(7)
          WRITE(LUNGFO,*)
     &'     Max. 1D power densities on beamline walls [W/m]:   '
          WRITE(LUNGFO,*)
     &'                                         ',TOTMAX(5),TOTMAX(6)
          WRITE(LUNGFO,*)
     &'     Max. 1D power density on absorber [W/m]:           ',TOTMAX(9)
          WRITE(LUNGFO,*)
     &'     Integrated photon rates on beamline walls:         '
          WRITE(LUNGFO,*)
     &'                                         ',TOTGAM(1),TOTGAM(2)
          WRITE(LUNGFO,*)
     &'     Integrated photon rate on absorber:                ',
     &      TOTGAM(5)
          WRITE(LUNGFO,*)
      ENDIF      !IPOWER

      IF (IBFORCE.NE.0) CALL BFORCE

C--- HBOOK

99      IF (IHBOOK.NE.0) then
          write(6,*)''
          write(6,*)"     Terminating histogramming"
          CALL ZEIT(6)
          write(6,*)''
          CALL HISEND
        endif

        if (bmaxgl.gt.2.5) then
          print*
          print*,"*** WARNING: LARGE B-FIELD DETECTED ***"
          print*
        endif

C--- USER OUTPUT ROUTINE

      IF (IUOUT.NE.0) CALL UOUT
      IF (IHISASCII.NE.0) CALL USERASCII

      if (iroottrees.ne.0) then
        irootmode=1
+self,if=-noroot.
        call rootini(irootmode)
+self.
      endif

      if (iroothdf5.ne.0) then
        print*,"SR wave: iroothdf5:",iroothdf5
        print*,' '
        print*,'--- Warning: HDF5-Data only available for old versions of WAVE, supporting CERN root ---'
        print*,' '
c+self,if=linux.
c        call roottoh5
c+self,if=-linux.
c        print*,' '
c        print*,'--- Warning: HDF5-Data only available for Linux-Version of WAVE ---'
c        print*,' '
c+self. ,if=linux.
      endif

+self,if=grndm.
      open(newunit=lun99,file="wave.gseed")
      call grndmq(igseed1,igseed2,igseq,'G')
      write(lun99,*)igseed1,igseed2,igseq
      close(lun99)
+self.,if=grndm.

      call  util_random_get_seed(irnsize,irnseed)

      !call util_get_free_lun(lun)
      open(newunit=lun,file='wave.seeds',status='unknown')
      write(lun,*)irnsize, icode
      do i=1,irnsize
        write(lun,*)i,irnseed(i)
      enddo
      flush(lun)
      close(lun)

      RETURN

9999  iroottrees=0
      return
      END
+DECK,WAVE_SIMPSON.
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  1.00/00 19/08/97  11.31.36  by  Michael Scheer
*-- Author :    Michael Scheer   19/08/97
      SUBROUTINE WAVE_SIMPSON(N,X,F,SUM)
+seq,gplhint.

      IMPLICIT NONE

      INTEGER N,I
      DOUBLE PRECISION X(N),F(N),SUM

      SUM=0.D0

      DO I=1,N-1
          SUM=SUM+(F(I+1)+F(I))*(X(I+1)-X(I))/2.D0
      ENDDO

      RETURN
      END
+DECK,WAVE_SPLINE_COEF.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.47/07 14/04/2003  15.17.05  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.55.48  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.48  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE WAVE_SPLINE_COEF(X,Y,N,YP1,YPN,Y2,AA,BB,CC,C)
+seq,gplhint.


C--- CALCULATES SPLINE COEFFICIENTS

C--   INPUT:

C-       N: NUMBER OF X,Y-VALUES
C-       X: ARRAY OF X-VALUES
C-       Y: ARRAY OF Y-VALUES
C-       YP1:  SECOND DERIVATIVE AT FIRST X-VALUE
C-       YPN:  SECOND DERIVATIVE AT LAST X-VALUE

C--   OUPUT:

C-       Y2:   SPLINE-COEFFICIENTS

C--   WORKINGSPACE: AA(N),BB(N),CC(N),C(N)


      IMPLICIT NONE

      INTEGER N,J
      DOUBLE PRECISION  X(N),Y(N),Y2(N),AA(N),BB(N),CC(N),C(N)

      DOUBLE PRECISION YP1,YPN

      Y2(1)=YP1
      Y2(N)=YPN

      IF (N.LT.3) RETURN

      C(1)=YP1
      C(N)=YPN

      BB(1)=1.D0
      CC(1)=0.D0
      CC(N)=1.D0

      DO J=2,N-1
          AA(J)=(X(J  )-X(J-1))/6.D0
          BB(J)=(X(J+1)-X(J-1))/3.D0
          CC(J)=(X(J+1)-X(J  ))/6.D0
          C(J)=(Y(J+1)-Y(J  ))/(X(J+1)-X(J  ))
     &          -(Y(J  )-Y(J-1))/(X(J  )-X(J-1))
      ENDDO !J

      DO J=2,N-1

          BB(J)=BB(J)-AA(J)*CC(J-1)
           C(J)= C(J)-AA(J)* C(J-1)
C030414          AA(J)=AA(J)-AA(J)*BB(J-1)

          CC(J)=CC(J)/BB(J)
           C(J)= C(J)/BB(J)
          BB(J)=1.D0

      ENDDO !J

      DO J=N-1,2,-1
         Y2(J)=C(J)-CC(J)*Y2(J+1)
      ENDDO

      RETURN
      END
+DECK,WAVE_SPLINE_COEF_F90.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.47/07 14/04/2003  15.17.05  by  Michael Scheer
*CMZ :  2.20/09 03/04/2001  11.03.37  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.55.48  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.48  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE WAVE_SPLINE_COEF_F90(X,Y,N,YP1,YPN,Y2)
+seq,gplhint.


C--- CALCULATES SPLINE COEFFICIENTS

C--   INPUT:

C-       N: NUMBER OF X,Y-VALUES
C-       X: ARRAY OF X-VALUES
C-       Y: ARRAY OF Y-VALUES
C-       YP1:  SECOND DERIVATIVE AT FIRST X-VALUE
C-       YPN:  SECOND DERIVATIVE AT LAST X-VALUE

C--   OUPUT:

C-       Y2:   SPLINE-COEFFICIENTS

C--   WORKINGSPACE: AA(N),BB(N),CC(N),C(N)


      IMPLICIT NONE

      INTEGER N,J
      DOUBLE PRECISION  X(N),Y(N),Y2(N)
      DOUBLE PRECISION YP1,YPN

      DOUBLE PRECISION, DIMENSION (:), ALLOCATABLE :: AA,BB,CC,C

      ALLOCATE(AA(N))
      ALLOCATE(BB(N))
      ALLOCATE(CC(N))
      ALLOCATE(C(N))

      Y2(1)=YP1
      Y2(N)=YPN

      IF (N.LT.3) GOTO 999

      C(1)=YP1
      C(N)=YPN

      BB(1)=1.D0
      CC(1)=0.D0
      CC(N)=1.D0

      DO J=2,N-1
          AA(J)=(X(J  )-X(J-1))/6.D0
          BB(J)=(X(J+1)-X(J-1))/3.D0
          CC(J)=(X(J+1)-X(J  ))/6.D0
          C(J)=(Y(J+1)-Y(J  ))/(X(J+1)-X(J  ))
     &          -(Y(J  )-Y(J-1))/(X(J  )-X(J-1))
      ENDDO !J

      DO J=2,N-1

          BB(J)=BB(J)-AA(J)*CC(J-1)
           C(J)= C(J)-AA(J)* C(J-1)
C030414          AA(J)=AA(J)-AA(J)*BB(J-1)

          CC(J)=CC(J)/BB(J)
           C(J)= C(J)/BB(J)
          BB(J)=1.D0

      ENDDO !J

      DO J=N-1,2,-1
         Y2(J)=C(J)-CC(J)*Y2(J+1)
      ENDDO

999   CONTINUE

      DEALLOCATE(AA)
      DEALLOCATE(BB)
      DEALLOCATE(CC)
      DEALLOCATE(C)

      RETURN
      END
+DECK,WAVE_SPLINE_INTEGRAL.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  11.03.55  by  Michael Scheer
*CMZ :  2.63/03 02/05/2008  14.41.00  by  Michael Scheer
*CMZ :  2.57/00 22/11/2005  10.16.01  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZU: 00.01/04 18/01/95  18.17.43  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.55.52  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.53  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE WAVE_SPLINE_INTEGRAL(X,Y,N,RESULT
     &                                 ,COEF,WORK1,WORK2,WORK3,WORK4)
+seq,gplhint.

C---  CALCULATES INTEGRAL OF Y(X) VIA SPLINES

      IMPLICIT NONE

      INTEGER I,N
      DOUBLE PRECISION X(N),Y(N),RESULT
      DOUBLE PRECISION COEF(N),WORK1(N),WORK2(N),WORK3(N),WORK4(N)

C---  SPLINE-COEFFICIENTS

      CALL util_SPLINE_COEF(X,Y,N,-9999.0d0,-9999.0d0,COEF,WORK1,WORK2,WORK3,WORK4)

C--- INTEGRATION

      RESULT=0.0D0
      DO I=1,N-1

      RESULT=RESULT
     &          +(X(I+1)-X(I))*0.5D0
     &          *(Y(I)+Y(I+1))
     &          -(X(I+1)-X(I))**3/24.D0
     &          *(COEF(I)+COEF(I+1))

      ENDDO

      RETURN
      END
+DECK,WAVE_SPLINE_INTER.
*CMZ :  3.02/00 24/09/2014  13.51.08  by  Michael Scheer
*CMZ :  3.01/03 19/03/2014  12.24.14  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.66/19 07/06/2011  14.08.31  by  Michael Scheer
*CMZ :  2.63/03 07/05/2008  14.17.54  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.33  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  15.14.32  by  Michael Scheer
*CMZ :  1.00/00 06/08/97  17.48.45  by  Michael Scheer
*CMZ : 00.01/08 22/06/95  10.39.53  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  10.39.41  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.50  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE WAVE_SPLINE_INTER(XA,YA,Y2A,N,X,Y,MODE,ICOUNT)
+seq,gplhint.

C---  INTERPOLATES Y(X) VIA SPLINE

C--   INPUT:

C-       N: NUMBER OF X,Y-VALUES
C-       XA:   ARRAY OF X-VALUES
C-       YA:   ARRAY OF Y-VALUES
C-       YA2:  ARRAY SPLINE COEFFICIENTS
C-       X: Y(X) IS CALCULATED
C-       MODE: CONTROL FLAG:
C-             MODE.GE.0: USE VALUES OF LAST CALL TO START WITH
C-             MODE.LT.0: NEW INITIALIZATION

C--   OUTPUT:

C-       Y: Y(X) IS CALCULATED
C-  ICOUNT: COUNTER TO CHECK CALLING

      IMPLICIT NONE

      INTEGER NOLD,N,KLO,KHI,KLOLD,K,MODE
      INTEGER ICOUNT

      DOUBLE PRECISION Y,X,XA1OLD,XANOLD,H,A,B

      DOUBLE PRECISION XA(*),YA(*),Y2A(*)

      save klold,nold,xa1old,xanold

      DATA KLOLD/1/,NOLD/-99/
      DATA XA1OLD/-9999.D0/,XANOLD/-9999./

      ICOUNT=ICOUNT+1

      IF(     XA(1).LT.XA(N).AND.(X.LT.XA(1).OR.X.GT.XA(N))
     &    .OR.
     &    XA(N).LT.XA(1).AND.(X.LT.XA(N).OR.X.GT.XA(1))) THEN
        STOP '***SR WAVE_SPLINE_INTER: X OUT OF RANGE ***'
      ENDIF

      IF (MODE.GE.0.AND.NOLD.EQ.N) THEN
        IF (XA(1).EQ.XA1OLD
     &      .AND. XA(N).EQ.XANOLD
     &      .AND. X.GT.XA(KLOLD)
     &      ) THEN
          KLO=KLOLD
        ELSE
          KLO=1
        ENDIF
      ELSE
        KLO=1
      ENDIF

      IF (X.LT.XA(KLO+1)) THEN
        KHI=KLO+1
        GOTO 2
      ENDIF

      KHI=N
1     IF (KHI-KLO.GT.1) THEN
        K=(KHI+KLO)/2
        IF(XA(K).GT.X)THEN
          KHI=K
        ELSE
          KLO=K
        ENDIF
      GOTO 1
      ENDIF

2     H=XA(KHI)-XA(KLO)

      IF (H.LE.0.) THEN
        WRITE(6,*) '*** ERROR IN WAVE_SPLINE_INTER: BAD INPUT ***'
        STOP
      ENDIF

      A=(XA(KHI)-X)/H
      B=(X-XA(KLO))/H
      Y=A*YA(KLO)+B*YA(KHI)+
     *      ((A**3-A)*Y2A(KLO)+(B**3-B)*Y2A(KHI))*(H**2)/6.

      KLOLD=KLO
      NOLD=N
      XA1OLD=XA(1)
      XANOLD=XA(N)

      RETURN
      END
+DECK,WAVE_TRACK_INTER.
*CMZ :  2.63/05 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.52/00 24/06/2004  15.55.45  by  Michael Scheer
*CMZ :  2.41/01 16/04/2004  09.24.47  by  Michael Scheer
*CMZ :  2.41/00 20/03/2002  19.16.55  by  Michael Scheer
*CMZ :  2.30/01 12/04/2001  15.28.59  by  Michael Scheer
*CMZ :  2.20/11 11/04/2001  15.24.21  by  Michael Scheer
*CMZ :  2.20/10 10/04/2001  11.16.57  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.33  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  15.14.32  by  Michael Scheer
*CMZ :  1.00/00 06/08/97  17.48.45  by  Michael Scheer
*CMZ : 00.01/08 22/06/95  10.39.53  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  10.39.41  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.50  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE WAVE_TRACK_INTER(
     &           T,X,Y,Z,VX,VY,VZ,VXP,VYP,VZP,BS,ICOUNT,GAMMA)
+seq,gplhint.

+SEQ,TRACKF90U.

      IMPLICIT NONE

+SEQ,TRACK.

      INTEGER KLO,KHI,K,ICOUNT,MODE,I

      DOUBLE PRECISION T,X,Y,Z,VX,VY,VZ,VXP,VYP,VZP,BS
     &                ,H,H6,H26,A,A2,A21H6,A3AH26,B,B2,B21H6,B3BH26
     &                ,DT,DT10,GAMMA

      IF (ICOUNT.EQ.0) THEN
          MODE=0
          DT=(DWT(2)-DWT(1))
          DT10=DT*1.D-10
          DO I=2,MCO
         IF (ABS(DWT(I)-DWT(I-1)-DT).GT.DT10) THEN
           MODE=1
           GOTO 19
                ENDIF
          ENDDO
19        KLO=1
          KHI=MCO
          ICOUNT=1
        ENDIF

      IF (MODE.EQ.1) THEN

        IF (KLO.GE.MCO.OR.KLO.LT.1.OR.KHI.GT.MCO.OR.KHI.LT.2) THEN
          KLO=1
          KHI=MCO
        ENDIF

        IF (T.GE.DWT(KLO).AND.T.LT.DWT(KLO+1)) THEN
          KHI=KLO+1
          GOTO 2
        ELSE IF (T.LT.DWT(KLO).OR.T.GE.DWT(KHI)) THEN
        KLO=1
        KHI=MCO
        ENDIF

      K=1
11    K=K*2
      KHI=KLO+K
      IF (KHI.GE.MCO) GOTO 12
      IF (T.GT.DWT(KHI)) THEN
          KLO=KHI
          GOTO 11
      ELSE
          GOTO 1
      ENDIF

12    KHI=MCO

1     IF (KHI-KLO.GT.1) THEN
        K=(KHI+KLO)/2
        IF(DWT(K).GT.T)THEN
          KHI=K
        ELSE
          KLO=K
        ENDIF
        GOTO 1
      ENDIF

      ELSE !MODE

      IF (T.GE.DWT(1).AND.T.LT.DWT(MCO)) THEN
         KLO=T/DT+1
         KHI=KLO+1
         IF (KHI.GT.MCO) THEN
             KHI=MCO
             KLO=KHI-1
         ENDIF
      ELSE IF (T.LT.DWT(1)) THEN
          KLO=1
          KHI=2
      ELSE IF (T.GE.DWT(MCO)) THEN
          KLO=MCO-1
          KHI=MCO
      ENDIF

      ENDIF !MODE

2     H=DWT(KHI)-DWT(KLO)

      IF (H.EQ.0.) THEN
        WRITE(6,*) '*** ERROR IN WAVE_TRACK_INTER: BAD INPUT ***'
        STOP
      ENDIF

      H6=H/6.D0
      H26=H6*H
      A=(DWT(KHI)-T)/H
      A2=A*A
      A3AH26=(A2-1.D0)*A*H26
      A21H6=(-3.D0*A2+1.D0)*H6
      B=(T-DWT(KLO))/H
      B2=B*B
      B21H6=(3.D0*B2-1.D0)*H6
      B3BH26=(B2-1.D0)*B*H26

      X=A*DWX(KLO)+B*DWX(KHI)+A3AH26*DWX2P(KLO)+B3BH26*DWX2P(KHI)
      VX=(-DWX(KLO)+DWX(KHI))/H+A21H6*DWX2P(KLO)+B21H6*DWX2P(KHI)
      VXP=A*DWX2P(KLO)+B*DWX2P(KHI)

      Y=A*DWY(KLO)+B*DWY(KHI)+A3AH26*DWY2P(KLO)+B3BH26*DWY2P(KHI)
      VY=(-DWY(KLO)+DWY(KHI))/H+A21H6*DWY2P(KLO)+B21H6*DWY2P(KHI)
      VYP=A*DWY2P(KLO)+B*DWY2P(KHI)

      Z=A*DWZ(KLO)+B*DWZ(KHI)+A3AH26*DWZ2P(KLO)+B3BH26*DWZ2P(KHI)
      VZ=(-DWZ(KLO)+DWZ(KHI))/H+A21H6*DWZ2P(KLO)+B21H6*DWZ2P(KHI)
      VZP=A*DWZ2P(KLO)+B*DWZ2P(KHI)

      BS=A*DWB(KLO)+B*DWB(KHI)+A3AH26*DWB2P(KLO)+B3BH26*DWB2P(KHI)

      GAMMA=(TRAGAM(KLO)+TRAGAM(KHI))/2.0D0

      RETURN
      END
+DECK,WBCUCOF.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  16.11.31  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.55.59  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.21  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE WBCUCOF(Y,Y1,Y2,Y12,D1,D2,C)
+seq,gplhint.

      IMPLICIT NONE

      INTEGER I,K,L,J
      REAL C,Y,Y1,Y2,Y12,CL,X,WT,D1,D2,D1D2,XX

      DIMENSION C(4,4),Y(4),Y1(4),Y2(4),Y12(4),CL(16),X(16),WT(16,16)
      DATA WT/1.,0.,-3.,2.,4*0.,-3.,0.,9.,-6.,2.,0.,-6.,
     *  4.,8*0.,3.,0.,-9.,6.,-2.,0.,6.,-4.,10*0.,9.,-6.,
     *  2*0.,-6.,4.,2*0.,3.,-2.,6*0.,-9.,6.,2*0.,6.,-4.,
     *  4*0.,1.,0.,-3.,2.,-2.,0.,6.,-4.,1.,0.,-3.,2.,8*0.,
     *  -1.,0.,3.,-2.,1.,0.,-3.,2.,10*0.,-3.,2.,2*0.,3.,
     *  -2.,6*0.,3.,-2.,2*0.,-6.,4.,2*0.,3.,-2.,0.,1.,-2.,
     *  1.,5*0.,-3.,6.,-3.,0.,2.,-4.,2.,9*0.,3.,-6.,3.,0.,
     *  -2.,4.,-2.,10*0.,-3.,3.,2*0.,2.,-2.,2*0.,-1.,1.,
     *  6*0.,3.,-3.,2*0.,-2.,2.,5*0.,1.,-2.,1.,0.,-2.,4.,
     *  -2.,0.,1.,-2.,1.,9*0.,-1.,2.,-1.,0.,1.,-2.,1.,10*0.,
     *  1.,-1.,2*0.,-1.,1.,6*0.,-1.,1.,2*0.,2.,-2.,2*0.,-1.,1./
      D1D2=D1*D2
      DO 11 I=1,4
        X(I)=Y(I)
        X(I+4)=Y1(I)*D1
        X(I+8)=Y2(I)*D2
        X(I+12)=Y12(I)*D1D2
11    CONTINUE
      DO 13 I=1,16
        XX=0.
        DO 12 K=1,16
          XX=XX+WT(I,K)*X(K)
12      CONTINUE
        CL(I)=XX
13    CONTINUE
      L=0
      DO 15 I=1,4
      DO 14 J=1,4
         L=L+1
         C(I,J)=CL(L)
14    CONTINUE
15    CONTINUE
      RETURN
      END
+DECK,WBETDIS.
*CMZ :  3.04/00 11/01/2018  10.11.29  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.09.17  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.68/05 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.66/13 07/07/2010  11.05.47  by  Michael Scheer
*CMZ :  2.66/09 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.66/07 20/01/2010  16.23.37  by  Michael Scheer
*CMZ :  2.47/12 17/12/2009  14.02.55  by  Michael Scheer
*CMZ :  2.41/13 22/08/2002  17.20.15  by  Michael Scheer
*CMZ :  2.16/08 29/10/2000  16.19.29  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.33  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  14.43.04  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  10.41.10  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.56.04  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.13  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE WBETDIS
+seq,gplhint.

+SEQ,TRACKF90U,IF=F90.
+SEQ,WBETAF90U,IF=F90.

C--- CALCULATE BETA-FUNCTIONS, DISPERSION AND THEIR DERIVATIVES
C    WRITES RESULTS TO FILES

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,DEPOLA.
+seq,wbetaf90.
+SEQ,TRACK.
+SEQ,PHYCON.

      INTEGER IP,IW,iwarn
      DOUBLE PRECISION DIS,DISP,HBET,HBETP,VBET,VBETP

      data iwarn/0/

+SELF,IF=F90.
      ALLOCATE(WBETA(16,NCO))
      ALLOCATE(WBZZPYYP(4,NCO))
      ALLOCATE(WBETAK(3,NCO))
      ALLOCATE(WLTM(2,4,NCO))
      ALLOCATE(WTUNE(2,NCO))
      wbeta=0.0d0
      wbzzpyyp=0.0d0
      wbetak=0.0d0
      wltm=0.0d0
      wtune=0.0d0
+SELF.

C--- CHECK PLANARITY OF REFERENCE ORBIT

      DO IP=1,NCO

        IF (abs(WSXYZ(2,IP)).gt.1.0d-10.and.iwarn.eq.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN WBETDIS ***'
          WRITE(LUNGFO,*)'REFERENCE ORBIT NOT PLANAR'
          WRITE(LUNGFO,*)
          WRITE(6,*) '*** WARNING IN WBETDIS ***'
          WRITE(6,*)'REFERENCE ORBIT NOT PLANAR'
          WRITE(6,*)
          iwarn=1
c          STOP
        ENDIF

      ENDDO

C--- BETA FUNCTION

      CALL WBETFN

C--- LINEARE TRANSFER MATRICES

      CALL WLINTRA

C--- DISPERSION

      CALL WDISPER

C--- RADIATION INTEGRALS

      CALL WI2I4I5

C--- TRAJECTORY IN PHASE SPACE

      CALL WZZPYYP

C--- WRITE RESULTS TO FILE


C    WBETA(2,*) HORIZONTAL BETA-FUNCTION
C    WBETA(3,*) DERIVATIVE OF HORIZONTAL BETA-FUNCTION
C    WBETA(4,*) VERTICAL BETA-FUNCTION
C    WBETA(5,*) DERIVATIVE OF VERTICAL BETA-FUNCTION

C    WBETA(6,*) DISPERTION (SR WDISPER)
C    WBETA(7,*) DERIVATIVE OF DISPERTION (SR WDISPER)

C    OPTICAL FUNCTIONS ALPA, BETA AND GAMMA
C         ALPHA=-WBETA(1+IT*2,IP)/2.D0
C         !TEMPORARY VALUE OF WBETAK(1/2,IP) IS DERIVATIVE OF WBETA(2/4,IP)
C         ALPHAP=-WBETAK(IT,IP)/2.D0
C         BETA=WBETA(2*IT,IP)
C         GAMA=(1+ALPHA**2)/BETA
C         WBETAK(IT,IP)=(ALPHAP+GAMA)/BETA
C--- RECALCULATE MAGNETIC FIELD FROM Ky+Kz=1/rho**2
C         WBETAK(3,IP)=DSQRT(WBETAK(2,IP)+WBETAK(1,IP))*EMOM/CLIGHT1

      OPEN(UNIT=LUNWB,FILE=FILEWB,STATUS='unknown',recl=256)

      DO IP=1,NCO
        WRITE(LUNWB,*)ICODE,(SNGL(WBETA(IW,IP)),IW=1,9),
     &    (SNGL(WBETAK(IW,IP)),IW=1,3)
      ENDDO   !NCO

      CLOSE(LUNWB)

C--- HBOOK

      IF (IHBETA.NE.0) CALL HBETA

C--- FUNCTIONS AT CENTER OF WLS

         HBET=WBETA(2,NCO/2)
         HBETP=WBETA(3,NCO/2)
         VBET=WBETA(4,NCO/2)
         VBETP=WBETA(5,NCO/2)
         DIS=WBETA(6,NCO/2)
         DISP=WBETA(7,NCO/2)

C090792  DO IP=1,NCO-1
C
C         IF (WBETA(1,IP)*WBETA(1,IP+1).LE.0.0) THEN
C        HBET=WBETA(2,IP)
C     &         +(WBETA(2,IP+1)-WBETA(2,IP))
C     &         /(WBETA(1,IP+1)-WBETA(1,IP))
C     &         *(0.0-WBETA(1,IP))
C        HBETP=WBETA(3,IP)
C     &         +(WBETA(3,IP+1)-WBETA(3,IP))
C     &         /(WBETA(1,IP+1)-WBETA(1,IP))
C     &         *(0.0-WBETA(1,IP))
C        VBET=WBETA(4,IP)
C     &         +(WBETA(4,IP+1)-WBETA(4,IP))
C     &         /(WBETA(1,IP+1)-WBETA(1,IP))
C     &         *(0.0-WBETA(1,IP))
C        VBETP=WBETA(5,IP)
C     &         +(WBETA(5,IP+1)-WBETA(5,IP))
C     &         /(WBETA(1,IP+1)-WBETA(1,IP))
C     &         *(0.0-WBETA(1,IP))
C        DIS=WBETA(6,IP)
C     &         +(WBETA(6,IP+1)-WBETA(6,IP))
C     &         /(WBETA(1,IP+1)-WBETA(1,IP))
C     &         *(0.0-WBETA(1,IP))
C        DISP=WBETA(7,IP)
C     &         +(WBETA(7,IP+1)-WBETA(7,IP))
C     &         /(WBETA(1,IP+1)-WBETA(1,IP))
C     &         *(0.0-WBETA(1,IP))
C        GOTO 90
C         ENDIF
C
C     ENDDO !IP


c90    WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  'HOR. BETA-FUNCTION AND DERIVATIVE AT ENTRANCE OF WLS'
      WRITE(LUNGFO,*)SNGL(WBETA(2,1)),SNGL(WBETA(3,1))
      WRITE(LUNGFO,*)
     &  'VER. BETA-FUNCTION AND DERIVATIVE AT ENTRANCE OF WLS'
      WRITE(LUNGFO,*)SNGL(WBETA(4,1)),SNGL(WBETA(5,1))
      WRITE(LUNGFO,*)
     &  'HOR. BETA-FUNCTION AND DERIVATIVE AT CENTER OF WLS'
      WRITE(LUNGFO,*)SNGL(HBET),SNGL(HBETP)
      WRITE(LUNGFO,*)
     &  'VER. BETA-FUNCTION AND DERIVATIVE AT CENTER OF WLS'
      WRITE(LUNGFO,*)SNGL(VBET),SNGL(VBETP)
      WRITE(LUNGFO,*)
     &  'DISPERSION AND DERIVATIVE AT CENTER OF WLS'
      WRITE(LUNGFO,*)SNGL(DIS),SNGL(DISP)
      WRITE(LUNGFO,*)
     &  'HOR. BETA-FUNCTION AND DERIVATIVE AT EXIT OF WLS'
      WRITE(LUNGFO,*)SNGL(WBETA(2,NCO)),SNGL(WBETA(3,NCO))
      WRITE(LUNGFO,*)
     &  'VER. BETA-FUNCTION AND DERIVATIVE AT EXIT OF WLS'
      WRITE(LUNGFO,*)SNGL(WBETA(4,NCO)),SNGL(WBETA(5,NCO))
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  'TOTAL HORIZONTAL AND VERTICAL PHASE ADVANCES:'
      WRITE(LUNGFO,*)SNGL(TUNEH),SNGL(TUNEV)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  'TOTAL HORIZONTAL AND VERTICAL PHASE ADVANCES FOR CORRESPONDING DRIFT:'
      WRITE(LUNGFO,*)SNGL(TUNEH0),SNGL(TUNEV0),
     &                 '(SAME BETA AT STARTING POINT)'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  'VERTICAL TUNE SHIFT (FROM 1/4/PI*INTEGRAL(BETA/RHO**2)):',
     &   SNGL(TUNSHI)
      WRITE(LUNGFO,*)
     &   '(ONLY CORRECT FOR INSERTION DEVICES WITHOUT TRANSVERSAL GRADIENT,'
      WRITE(LUNGFO,*)
     &   'NOT CORRECT E.G. FOR QUADRUPOLS)'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  'HORIZONTAL LINEAR TRANSFERMATRIX CALCULATED FROM BETA-FUNCTION:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)SNGL(TMH(1,1)),SNGL(TMH(1,2))
      WRITE(LUNGFO,*)SNGL(TMH(2,1)),SNGL(TMH(2,2))
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  'VERTICAL LINEAR TRANSFERMATRIX CALCULATED FROM BETA-FUNCTION:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)SNGL(TMV(1,1)),SNGL(TMV(1,2))
      WRITE(LUNGFO,*)SNGL(TMV(2,1)),SNGL(TMV(2,2))
      WRITE(LUNGFO,*)

      RETURN
      END
+DECK,WBETFN.
*CMZ :  4.01/03 29/06/2023  09.53.57  by  Michael Scheer
*CMZ :  4.00/15 05/04/2022  11.52.17  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.09.17  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.68/05 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.68/02 08/06/2012  09.23.03  by  Michael Scheer
*CMZ :  2.67/02 26/04/2012  14.49.41  by  Michael Scheer
*CMZ :  2.66/09 25/06/2010  12.15.46  by  Michael Scheer
*CMZ :  2.66/07 20/01/2010  16.25.35  by  Michael Scheer
*CMZ :  2.63/05 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  2.61/02 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  10.55.32  by  Michael Scheer
*CMZ :  2.47/12 16/04/2004  09.24.47  by  Michael Scheer
*CMZ :  2.16/08 29/10/2000  16.15.48  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.33  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.24.36  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  14.43.03  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  10.46.38  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.56.09  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.10  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE WBETFN
+seq,gplhint.

+SEQ,TRACKF90U,IF=F90.
+SEQ,WBETAF90U,IF=F90.

C--- CALCULATES BETA-FUNCTION AND DERIVATIVE FROM START-VALUES BET0,BET0P
C    IN NAMELIST DEPOLA BY TRACKING PRINCIPAL TRAJECTOIES
C    RESULTS ARE STORED IN WBETA(2,IPOINT) AND WBETA(3,IPOINT)

C    RESULTS:

C    WBETA(1,*) S-COORDINATE
C    WBETA(2,*) HORIZONTAL BETA-FUNCTION
C    WBETA(3,*) DERIVATIVE OF HORIZONTAL BETA-FUNCTION
C    WBETA(4,*) VERTICAL BETA-FUNCTION
C    WBETA(5,*) DERIVATIVE OF VERTICAL BETA-FUNCTION

C    WBETA(6,*) DISPERTION (SR WDISPER)
C    WBETA(7,*) DERIVATIVE OF DISPERTION (SR WDISPER)

C    OPTICAL FUNCTIONS ALPA, BETA AND GAMMA
C         ALPHA=-WBETA(1+IT*2,IP)/2.D0  IT=[1,2]
C         !TEMPORARY VALUE OF WBETAK(1/2,IP) IS DERIVATIVE OF WBETA(2/4,IP)
C         ALPHAP=-WBETAK(IT,IP)/2.D0
C         BETA=WBETA(2*IT,IP)
C         GAMA=(1+ALPHA**2)/BETA
C         WBETAK(IT,IP)=(ALPHAP+GAMA)/BETA
C--- RECALCULATE MAGNETIC FIELD FROM Ky+Kz=1/rho**2
C            WBETAK(3,IP)=SQRT(WBETAK(2,IP)+WBETAK(1,IP))*EMOM/CLIGHT1

      implicit none

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,DEPOLA.
+seq,wbetaf90.
+SEQ,TRACK.
+SEQ,OPTIC.
+SEQ,tralin.
+SEQ,PHYCON.
+seq,ustep.

      INTEGER IT,IP,IPP,IPP2,jfail,ical,ifail

      DOUBLE PRECISION X0,Y0,Z0,YP0,ZP0
      DOUBLE PRECISION X1,Y1,Z1,YP1,ZP1
      DOUBLE PRECISION X2,Y2,Z2,T2
      DOUBLE PRECISION XF0,YF0,ZF0
      DOUBLE PRECISION X1T,Y1T,Z1T

      DOUBLE PRECISION V0,VX0,VY0,VZ0
      DOUBLE PRECISION VX1,VY1,VZ1
      DOUBLE PRECISION VX2,VY2,VZ2
      DOUBLE PRECISION VXF0,VYF0,VZF0
      DOUBLE PRECISION VX1T,VY1T,VZ1T

      DOUBLE PRECISION UNX,UNY,UNZ
      DOUBLE PRECISION VNX,VNY,VNZ,VN
      DOUBLE PRECISION WNX,WNY,WNZ
      DOUBLE PRECISION EWSFX,EWSFY,EWSFZ,BSHIFT

      DOUBLE PRECISION EPS0HO,EPS0VO,DUMP,DUMM,SPLYP0,SPLYPN,gammal

      DOUBLE PRECISION DS2,ALPHA,ALPHAP,BETA,GAMA,
     &  betmxh,betmnh,betcenh,
     &  betmxv,betmnv,betcenv

      double precision X2E,Y2E,Z2E,VX2E,VY2E,VZ2E,GAMMAE,
     &  xpar(3),ypar(3),a(3),yp(3),xopt,yopt

      DOUBLE PRECISION, DIMENSION (:), ALLOCATABLE ::
     &  XBUFF,YBUFF,Y2BUFF,AABUFF,BBBUFF,CCBUFF,CBUFF

      DATA BSHIFT/0.5D0/,ical/0/

      if (ical.ne.0) return
      ical=1

      IF (nco.lt.12) THEN
        WRITE(6,*)
        WRITE(6,*)
     &    ' *** ERROR IN WBETFN: Trajectory must have more than 12 points ***'
        WRITE(6,*)
        write(6,*)'*** PROGRAM WAVE ABORTED ***'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    ' *** ERROR IN WBETFN: Trajectory must have more than 12 points ***'
        WRITE(LUNGFO,*)
        write(lungfo,*)'*** PROGRAM WAVE ABORTED ***'
        stop
      ENDIF

      IF (IENELOSS.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    ' *** WARNING IN WBETFN: IENELOSS .NE. 0, NOT YET IMPLEMENTED ***'
        WRITE(LUNGFO,*)
     &    ' *** BE CAREFUL!! ***'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)
     &    ' *** WARNING IN WBETFN: IENELOSS .NE. 0, NOT YET IMPLEMENTED ***'
        WRITE(6,*)
     &    ' *** BE CAREFUL!! ***'
        WRITE(6,*)
      ENDIF

      X0=WSXYZ(1,1)
      Y0=WSXYZ(2,1)
      Z0=WSXYZ(3,1)
      XF0=WSXYZ(1,NCO)

      VX0=WVXYZ(1,1)
      VY0=WVXYZ(2,1)
      VZ0=WVXYZ(3,1)
      V0=SQRT(VX0**2+VY0**2+VZ0**2)

      YP0=VY0/VX0
      ZP0=VZ0/VX0

      IF (YP0.NE.0.0 .OR. Y0.NE.0
     &   .OR.ZP0.NE.0.0 .OR. Z0.NE.0) THEN

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*) '*** WARNING IN WBETFN ***'
          WRITE(LUNGFO,*) 'START VALUES OF REFERENCE ORBIT NOT ZERO !!??'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*) '*** WARNING IN WBETFN ***'
          WRITE(6,*) 'START VALUES OF REFERENCE ORBIT NOT ZERO !!??'
          WRITE(6,*)
C         STOP '*** ERROR IN WBETFN ***'

      ENDIF

      EPS0HO=EPS0H
      EPS0VO=EPS0V

      IF (EPS0H.LT.5.D-9) THEN

          EPS0H=5.D-9

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*) '*** WARNING SR WBETFN ***'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*) 'HORIZ. EMITTANCE LOWER THAN 5.E-9'
          WRITE(LUNGFO,*) 'FOR CALCULATION OF BETA-FUNCTION SET 5.E-9'
          WRITE(LUNGFO,*) 'OLD VALUE RESTORED AFTERWARD'
          WRITE(LUNGFO,*)

      ENDIF

      IF (EPS0V.LT.5.D-9) THEN

          EPS0V=5.D-9

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*) '*** WARNING SR WBETFN ***'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*) 'VERTICAL. EMITTANCE LOWER THAN 5.E-9'
          WRITE(LUNGFO,*) 'FOR CALCULATION OF BETA-FUNCTION SET 5.E-9'
          WRITE(LUNGFO,*) 'OLD VALUE RESTORED AFTERWARD'
          WRITE(LUNGFO,*)

      ENDIF

1     continue

C--- CALCULATE PRINCIPAL TRAJECTORIES

      DO IT=1,4

C--- REFERENCE ORBIT

        X0=WSXYZ(1,1)
        Y0=WSXYZ(2,1)
        Z0=WSXYZ(3,1)

        VX0=WVXYZ(1,1)
        VY0=WVXYZ(2,1)
        VZ0=WVXYZ(3,1)

        YP0=VY0/VX0
        ZP0=VZ0/VX0

C--- NORMAL VECTOR OF ENTRANCE PLANE I.E Ex-VECTOR OF REFERENCE SYSTEM

        UNX=VX0/V0
        UNY=VY0/V0
        UNZ=VZ0/V0

C--- VECTOR Ey OF REFERENCE SYSTEM

        VN=SQRT(UNX**2+UNY**2)
        VNX=-UNY/VN
        VNY= UNX/VN
        VNZ=0.0d0

C--- VECTOR Ez OF REFERENCE SYSTEM

        WNX=UNY*VNZ-UNZ*VNY
        WNY=UNZ*VNX-UNX*VNZ
        WNZ=UNX*VNY-UNY*VNX

C COORDINATES IN REFERENCE SYSTEM

        IF (IT.EQ.1) THEN

          ALPHA=-.5D0*BETAPH

          X1=0.0d0
          Y1=0.0d0
          Z1=SQRT(EPS0H*BETAH)

          YP1=0.0d0
          ZP1=-SQRT(EPS0H/BETAH)*ALPHA

        ELSE IF (IT.EQ.2) THEN

          X1=0.0d0
          Y1=0.0d0
          Z1=0.0d0

          YP1=0.0d0
          ZP1=-SQRT(EPS0H/BETAH)

        ELSE IF (IT.EQ.3) THEN

          ALPHA=-.5D0*BETAPV

          X1=0.0d0
          Y1=SQRT(EPS0V*BETAV)
          Z1=0.0d0

          YP1=-SQRT(EPS0V/BETAV)*ALPHA
          ZP1=0.0d0

        ELSE IF (IT.EQ.4) THEN

          X1=0.0d0
          Y1=0.0d0
          Z1=0.0d0

          YP1=-SQRT(EPS0V/BETAV)
          ZP1=0.0d0

        ENDIF

C ABSOLUTE COORDINATES (LAB.-SYSTEM)

        X1T=X0+X1*UNX+Y1*VNX+Z1*WNX
        Y1T=Y0+X1*UNY+Y1*VNY+Z1*WNY
        Z1T=Z0+X1*UNZ+Y1*VNZ+Z1*WNZ

        X1=X1T
        Y1=Y1T
        Z1=Z1T

        VX1=V0/SQRT(1.D0+ZP1**2+YP1**2)
        VY1=VX1*YP1
        VZ1=VX1*ZP1

        VX1T=VX1*UNX+VY1*VNX+VZ1*WNX
        VY1T=VX1*UNY+VY1*VNY+VZ1*WNY
        VZ1T=VX1*UNZ+VY1*VNZ+VZ1*WNZ

        VX1=VX1T
        VY1=VY1T
        VZ1=VZ1T

        ZP1=VZ1/VX1
        YP1=VY1/VX1

        gammae=dmygamma*(1.0d0+deltae)

        IF (IT.LE.2) THEN
          WBETA(IT+1,1)=(X1-X0)**2+(Z1-Z0)**2
          WBETA(9+IT+1,1)=(X1-X0)**2+(Z1-Z0)**2
        ELSE
          WBETA(IT+1,1)=(X1-X0)**2+(Y1-Y0)**2
          WBETA(9+IT+1,1)=(X1-X0)**2+(Y1-Y0)**2
        ENDIF

C--- LOOP OVER POINTS

        WBETA(1,1)=x0

        DO IP=1,NCO-1

C--- MOVE PARTICLE TO PLANE THAT CORRESPOND TO NEXT POINT OF REF.ORBIT

          IPP=IP+1

          XF0=WSXYZ(1,IPP)
          YF0=WSXYZ(2,IPP)
          ZF0=WSXYZ(3,IPP)

          VXF0=WVXYZ(1,IPP)
          VYF0=WVXYZ(2,IPP)
          VZF0=WVXYZ(3,IPP)

          EWSFX=VXF0/V0
          EWSFY=VYF0/V0
          EWSFZ=VZF0/V0

C For the particle with energy deviation, we also take
c the normal reference orbit!?

          nutrack=-3

          CALL TRACKSHORT(ISNORDER,X1,Y1,Z1,VX1,VY1,VZ1,
     &      XF0,YF0,ZF0,EWSFX,EWSFY,EWSFZ,
     &      X2E,Y2E,Z2E,T2,VX2E,VY2E,VZ2E,DTIM0,BSHIFT,GAMMAE,BMOVECUT,IUSTEP,
     &      IENELOSS,GAMMAL)

          nutrack=-3

          CALL TRACKSHORT(ISNORDER,X1,Y1,Z1,VX1,VY1,VZ1,
     &      XF0,YF0,ZF0,EWSFX,EWSFY,EWSFZ,
     &      X2,Y2,Z2,T2,VX2,VY2,VZ2,DTIM0,BSHIFT,DMYGAMMA,BMOVECUT,IUSTEP,
     &      IENELOSS,GAMMAL)

          IF (IT.LE.2) THEN
            WBETA(IT+1,IPP)=(X2-XF0)**2+(Z2-ZF0)**2
            WBETA(9+IT+1,IPP)=(X2e-XF0)**2+(Z2e-ZF0)**2
          ELSE
            WBETA(IT+1,IPP)=(X2-XF0)**2+(Y2-YF0)**2
            WBETA(9+IT+1,IPP)=(X2e-XF0)**2+(Y2e-YF0)**2
          ENDIF

          if(it.eq.1) WBETA(1,IPP)=wbeta(1,ip)+(x2-x1)

          X1=X2
          Y1=Y2
          Z1=Z2

          VX1=VX2
          VY1=VY2
          VZ1=VZ2

        ENDDO !IP

      ENDDO !IT

c{30.4.2010: Correct for different step size of last step

      if (nco.gt.2) then
        x2=wbeta(1,nco-1)+ds0
        xpar(1)=wbeta(1,nco-2)
        xpar(2)=wbeta(1,nco-1)
        xpar(3)=wbeta(1,nco)
        do it=1,4
          ypar(1)=wbeta(it+1,nco-2)
          ypar(2)=wbeta(it+1,nco-1)
          ypar(3)=wbeta(it+1,nco)
          call UTIL_PARABEL(xpar,ypar,A,YP,XOPT,yopt,IFAIL)
          if (ifail.ne.0) then
            wbeta(it+1,nco)=wbeta(it+1,nco-1)+
     &        (wbeta(it+1,nco)-wbeta(it+1,nco-1))/
     &        (wbeta(1,nco)-wbeta(1,nco-1))*ds0
          else
            wbeta(it+1,nco)=a(1)+a(2)*x2+a(3)*x2**2
          endif
        enddo
        do it=10,13
          ypar(1)=wbeta(it+1,nco-2)
          ypar(2)=wbeta(it+1,nco-1)
          ypar(3)=wbeta(it+1,nco)
          call UTIL_PARABEL(xpar,ypar,A,YP,XOPT,yopt,IFAIL)
          if (ifail.ne.0) then
            wbeta(it+1,nco)=wbeta(it+1,nco-1)+
     &        (wbeta(it+1,nco)-wbeta(it+1,nco-1))/
     &        (wbeta(1,nco)-wbeta(1,nco-1))*ds0
          else
            wbeta(it+1,nco)=a(1)+a(2)*x2+a(3)*x2**2
          endif
        enddo
        wbeta(1,nco)=x2
      endif

c}30.4.2010: Correct for different step size of last step

C--- CALCULATE BETA-FUNCTIONS

      DO IP=1,NCO

C21.7.92     WBETA(1,IP)=WSXYZ(1,IP)
c16.12.2009          WBETA(1,IP)=-DFLOAT(NCO-1)*DS0/2.+DFLOAT(IP-1)*DS0
c30.4.2010        WBETA(1,IP)=x0+DFLOAT(IP-1)*DS0

        WBETA(2,IP)=(WBETA(2,IP)+WBETA(3,IP))/EPS0H
        WBETA(4,IP)=(WBETA(4,IP)+WBETA(5,IP))/EPS0V
        WBETA(11,IP)=(WBETA(11,IP)+WBETA(12,IP))/EPS0H
        WBETA(13,IP)=(WBETA(13,IP)+WBETA(14,IP))/EPS0V

      ENDDO !IP

C{ CALCULATE DERIVATIVES AND INTEGRALS

      ALLOCATE(XBUFF(NCO))
      ALLOCATE(YBUFF(NCO))
      ALLOCATE(Y2BUFF(NCO))
      ALLOCATE(AABUFF(NCO))
      ALLOCATE(BBBUFF(NCO))
      ALLOCATE(CCBUFF(NCO))
      ALLOCATE(CBUFF(NCO))

c{ e-dev

      DO IPP=0,1

        IPP2=IPP*2

        DO IP=1,NCO
          XBUFF(IP)=WBETA(1,IP)
          YBUFF(IP)=WBETA(11+IPP2,IP)
        ENDDO

        if (ipp.eq.0) then
          call util_min_parabel(nco,xbuff,ybuff,xmx,betmnh,aabuff,bbbuff,jfail)
          call util_max_parabel(nco,xbuff,ybuff,xmx,betmxh,aabuff,bbbuff,jfail)
          betcenh=ybuff(nco/2+1)
        endif

        if (ipp.eq.1) then
          call util_min_parabel(nco,xbuff,ybuff,xmx,betmnv,aabuff,bbbuff,jfail)
          call util_max_parabel(nco,xbuff,ybuff,xmx,betmxv,aabuff,bbbuff,jfail)
          betcenv=ybuff(nco/2+1)
        endif

        DUMP=(YBUFF(3)-YBUFF(2))/DS0
        DUMM=(YBUFF(2)-YBUFF(1))/DS0
        SPLYP0=(DUMP-DUMM)/DS0

        DUMP=(YBUFF(NCO)-YBUFF(NCO-1))/DS0
        DUMM=(YBUFF(NCO-1)-YBUFF(NCO-2))/DS0
        SPLYPN=(DUMP-DUMM)/DS0

        CALL UTIL_SPLINE_COEF(XBUFF,YBUFF,NCO,SPLYP0,SPLYPN,Y2BUFF,
     &    AABUFF,BBBUFF,CCBUFF,CBUFF)

        CALL UTIL_SPLINE_INTER_DERIV(XBUFF,YBUFF,Y2BUFF,NCO,
     &    XBUFF(1),WBETA(11+IPP2,1),WBETA(12+IPP2,1),-1)

        DO IP=2,NCO

          CALL UTIL_SPLINE_INTER_DERIV(XBUFF,YBUFF,Y2BUFF,NCO,
     &      XBUFF(IP),WBETA(11+IPP2,IP),WBETA(12+IPP2,IP),0)

        ENDDO

      ENDDO ! HORI and VERT

      DO IPP=0,1

        IPP2=IPP*2

        DO IP=1,NCO
          XBUFF(IP)=WBETA(1,IP)
          YBUFF(IP)=1.D0/WBETA(11+IPP2,IP)
        ENDDO

        DUMP=(YBUFF(3)-YBUFF(2))/DS0
        DUMM=(YBUFF(2)-YBUFF(1))/DS0
        SPLYP0=(DUMP-DUMM)/DS0

        DUMP=(YBUFF(NCO)-YBUFF(NCO-1))/DS0
        DUMM=(YBUFF(NCO-1)-YBUFF(NCO-2))/DS0
        SPLYPN=(DUMP-DUMM)/DS0

      ENDDO ! HORI and VERT

c} e-dev

      DO IPP=0,1

        IPP2=IPP*2

        DO IP=1,NCO
          XBUFF(IP)=WBETA(1,IP)
          YBUFF(IP)=WBETA(2+IPP2,IP)
        ENDDO

        if (ipp.eq.0) then
          call util_min_parabel(nco,xbuff,ybuff,xmx,betmnh,aabuff,bbbuff,jfail)
          call util_max_parabel(nco,xbuff,ybuff,xmx,betmxh,aabuff,bbbuff,jfail)
          betcenh=ybuff(nco/2+1)
        endif

        if (ipp.eq.1) then
          call util_min_parabel(nco,xbuff,ybuff,xmx,betmnv,aabuff,bbbuff,jfail)
          call util_max_parabel(nco,xbuff,ybuff,xmx,betmxv,aabuff,bbbuff,jfail)
          betcenv=ybuff(nco/2+1)
        endif

        DUMP=(YBUFF(3)-YBUFF(2))/DS0
        DUMM=(YBUFF(2)-YBUFF(1))/DS0
        SPLYP0=(DUMP-DUMM)/DS0

        DUMP=(YBUFF(NCO)-YBUFF(NCO-1))/DS0
        DUMM=(YBUFF(NCO-1)-YBUFF(NCO-2))/DS0
        SPLYPN=(DUMP-DUMM)/DS0

        CALL UTIL_SPLINE_COEF(XBUFF,YBUFF,NCO,SPLYP0,SPLYPN,Y2BUFF,
     &    AABUFF,BBBUFF,CCBUFF,CBUFF)

        CALL UTIL_SPLINE_INTER_DERIV(XBUFF,YBUFF,Y2BUFF,NCO,
     &    XBUFF(1),WBETA(2+IPP2,1),WBETA(3+IPP2,1),-1)

        DO IP=2,NCO

          CALL UTIL_SPLINE_INTER_DERIV(XBUFF,YBUFF,Y2BUFF,NCO,
     &      XBUFF(IP),WBETA(2+IPP2,IP),WBETA(3+IPP2,IP),0)

        ENDDO

      ENDDO ! HORI and VERT

c{e-dev
      DO IPP=0,1

        IPP2=IPP*2

        DO IP=1,NCO
          XBUFF(IP)=WBETA(1,IP)
          YBUFF(IP)=1.0D0/WBETA(11+IPP2,IP)
        ENDDO

        DUMP=(YBUFF(12)-YBUFF(2))/DS0
        DUMM=(YBUFF(11)-YBUFF(1))/DS0
        SPLYP0=(DUMP-DUMM)/DS0

        DUMP=(YBUFF(NCO)-YBUFF(NCO-1))/DS0
        DUMM=(YBUFF(NCO-1)-YBUFF(NCO-2))/DS0
        SPLYPN=(DUMP-DUMM)/DS0

        CALL UTIL_SPLINE_COEF(XBUFF,YBUFF,NCO,SPLYP0,SPLYPN,Y2BUFF,
     &    AABUFF,BBBUFF,CCBUFF,CBUFF)

        WBETA(14+IPP,1)=0.D0

        DO IP=2,NCO

          WBETA(14+IPP,IP) = WBETA(14+IPP,IP-1)
     &      +(XBUFF(IP)-XBUFF(IP-1))*0.5D0
     &      *(YBUFF(IP-1)+YBUFF(IP))
     &      -(XBUFF(IP)-XBUFF(IP-1))**3/24.D0
     &      *(Y2BUFF(IP-1)+Y2BUFF(IP))

        ENDDO

      ENDDO ! HORI and VERT

c}e-dev

      DO IPP=0,1

        IPP2=IPP*2

        DO IP=1,NCO
          XBUFF(IP)=WBETA(1,IP)
          YBUFF(IP)=1.D0/WBETA(2+IPP2,IP)
        ENDDO

        DUMP=(YBUFF(3)-YBUFF(2))/DS0
        DUMM=(YBUFF(2)-YBUFF(1))/DS0
        SPLYP0=(DUMP-DUMM)/DS0

        DUMP=(YBUFF(NCO)-YBUFF(NCO-1))/DS0
        DUMM=(YBUFF(NCO-1)-YBUFF(NCO-2))/DS0
        SPLYPN=(DUMP-DUMM)/DS0

        CALL UTIL_SPLINE_COEF(XBUFF,YBUFF,NCO,SPLYP0,SPLYPN,Y2BUFF,
     &    AABUFF,BBBUFF,CCBUFF,CBUFF)

        WBETA(8+IPP,1)=0.D0

        DO IP=2,NCO

          WBETA(8+IPP,IP) = WBETA(8+IPP,IP-1)
     &      +(XBUFF(IP)-XBUFF(IP-1))*0.5D0
     &      *(YBUFF(IP-1)+YBUFF(IP))
     &      -(XBUFF(IP)-XBUFF(IP-1))**3/24.D0
     &      *(Y2BUFF(IP-1)+Y2BUFF(IP))

        ENDDO

      ENDDO ! HORI and VERT

      DEALLOCATE(XBUFF)
      DEALLOCATE(YBUFF)
      DEALLOCATE(Y2BUFF)
      DEALLOCATE(AABUFF)
      DEALLOCATE(BBBUFF)
      DEALLOCATE(CCBUFF)
      DEALLOCATE(CBUFF)

C} CALCULATE DERIVATIVES AND INTEGRALS

      DS2=DS0*2.D0

      DO IP=3,NCO-2
        WBETAK(1,IP)=(WBETA(3,IP+1)-WBETA(3,IP-1))/DS2
        WBETAK(2,IP)=(WBETA(5,IP+1)-WBETA(5,IP-1))/DS2
      ENDDO

      WBETAK(1,2)=WBETAK(1,3)-(WBETAK(1,4)-WBETAK(1,3))
      WBETAK(1,NCO-1)=WBETAK(1,NCO-2)+(WBETAK(1,NCO-2)-WBETAK(1,NCO-3))
      WBETAK(2,2)=WBETAK(2,3)-(WBETAK(2,4)-WBETAK(2,3))
      WBETAK(2,NCO-1)=WBETAK(2,NCO-2)+(WBETAK(2,NCO-2)-WBETAK(2,NCO-3))

      WBETAK(1,1)=WBETAK(1,2)-(WBETAK(1,3)-WBETAK(1,2))
      WBETAK(1,NCO)=WBETAK(1,NCO-1)+(WBETAK(1,NCO-1)-WBETAK(1,NCO-2))
      WBETAK(2,1)=WBETAK(2,2)-(WBETAK(2,3)-WBETAK(2,2))
      WBETAK(2,NCO)=WBETAK(2,NCO-1)+(WBETAK(2,NCO-1)-WBETAK(2,NCO-2))

C--- DETERMINATION OF GRADIENT Kz=-(kz-1/rho**2)
C    AND Ky=ky=-kz

      DO IP=1,NCO
        DO IT=1,2

          ALPHA=-WBETA(1+IT*2,IP)/2.D0
          ALPHAP=-WBETAK(IT,IP)/2.D0
          BETA=WBETA(2*IT,IP)
          GAMA=(1+ALPHA**2)/BETA
          WBETAK(IT,IP)=(ALPHAP+GAMA)/BETA

        ENDDO !IT
      ENDDO !IP

C--- RECALCULATE MAGNETIC FIELD FROM Ky+Kz=1/rho**2

      DO IP=1,NCO

        IF(WBETAK(2,IP)+WBETAK(1,IP).GE.0.0d0) THEN
          WBETAK(3,IP)=SQRT(WBETAK(2,IP)+WBETAK(1,IP))*EMOM/CLIGHT1
        ELSE
          WBETAK(3,IP)=0.0d0
        ENDIF

      ENDDO !IP

      EPS0H=EPS0HO
      EPS0V=EPS0VO

      write(lungfo,*)
      write(lungfo,*)'      Subroutine WBETFN:'
      write(lungfo,*)' '

      write(lungfo,*)'      Max., min., and value of horizontal beta-function in the center:'
      write(lungfo,*)' '
      write(lungfo,*)'      ',sngl(betmxh),sngl(betmnh),sngl(betcenh)
      write(lungfo,*)' '

      write(lungfo,*)'      Max., min., and value of vertical beta-function in the center:'
      write(lungfo,*)' '
      write(lungfo,*)'      ',sngl(betmxv),sngl(betmnv),sngl(betcenv)
      write(lungfo,*)' '

      RETURN
      END
+DECK,WBMAP.
*CMZ :  4.00/15 07/03/2022  16.15.45  by  Michael Scheer
*CMZ :  4.00/14 22/12/2021  16.48.08  by  Michael Scheer
*CMZ :  4.00/04 17/05/2019  14.22.20  by  Michael Scheer
*CMZ :  3.05/05 13/07/2018  09.24.44  by  Michael Scheer
*CMZ :  3.03/04 19/10/2017  14.59.02  by  Michael Scheer
*CMZ :  3.02/03 23/10/2014  13.43.13  by  Michael Scheer
*CMZ :  3.00/00 18/09/2013  12.33.23  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  14.04.56  by  Michael Scheer
*CMZ :  2.68/05 01/10/2012  13.51.04  by  Michael Scheer
*CMZ :  2.68/02 02/07/2012  12.58.24  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  09.55.58  by  Michael Scheer
*CMZ :  2.45/03 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.44/01 10/12/2002  17.49.10  by  Michael Scheer
*CMZ :  2.44/00 07/11/2002  15.12.01  by  Michael Scheer
*CMZ :  2.42/04 14/09/2002  07.16.48  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.02  by  Michael Scheer
*CMZ :  2.39/01 15/01/2002  16.47.24  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  1.03/06 06/08/98  18.01.11  by  Michael Scheer
*CMZ :  1.00/00 24/09/97  10.31.28  by  Michael Scheer
*CMZ : 00.02/03 23/01/97  17.29.29  by  Michael Scheer
*CMZ : 00.02/00 25/11/96  09.51.41  by  Michael Scheer
*-- Author :    Michael Scheer   28/09/95
      SUBROUTINE WBMAP
+seq,gplhint.

C--- TO WRITE 3D FIELD MAP TO FILE


      IMPLICIT NONE

+SELF,IF=LINUX.
      EXTERNAL DCOSD,DSIND
      DOUBLE PRECISION DCOSD,DSIND
+SELF.

+SEQ,CONTRL.
+SEQ,CMPARA.
+SEQ,MYFILES.
+seq,whbook.
+seq,pawcmn.
+SEQ,BPOLY3D.
+SEQ,BPOLY2DH.
+SEQ,BPOLY3DG.
+SEQ,BMAP.
+seq,datetime.

      DOUBLE PRECISION DX,DY,DZ,BX,BY,BZ,AX,AY,AZ,X,Y,Z,R,PHI

      INTEGER IPOI,IX,IY,IZ

      INTEGER NTUP_P,ICYCLE
      PARAMETER (NTUP_P=6)
      REAL*8 TUP_D(NTUP_P)
      CHARACTER(3) CHTAGS_D(NTUP_P)
      character(2048) cline

      data chtags_d/'x','y','z','bx','by','bz'/
      DATA DX,DY,DZ/0.D0,0.D0,0.D0/

      IF (IWBMAP.EQ.4) THEN
        CALL WBMAP4
        RETURN
      ELSE IF (IWBMAP.EQ.5) THEN
        CALL WBMAP5
      ELSE IF (IWBMAP.EQ.7) THEN
        CALL WBMAP_FOR_SPECTRA
        return
      ENDIF

      IF (IWBMAP.EQ.3) THEN
        OPEN(UNIT=LUNBMAP,FILE=FILEBMAP,STATUS='NEW'
     &    ,FORM='UNFORMATTED')
      ELSE IF (IWBMAP.eq.6) THEN
        open(unit=lunbmap,file=filebmap,status='new',form='formatted')
        call date_and_time(dtday,dttime,dtzone,idatetime)

        write(cline,*)'! WAVE: x y z Bx By Bz with x as long. beam axis'
        write(lunbmap,'(a)')cline(2:len_trim(cline))
        write(cline,*)'@ date (yyyy.month.day) and time = ',
     &    dtday(1:4),'.',dtday(5:6),'.',dtday(7:8),' ',
     &    dttime(1:2),':',dttime(3:4),':',dttime(5:6)
        write(lunbmap,'(a)')cline(2:len_trim(cline))
        write(cline,*)'@ run =  ',icode
        write(lunbmap,'(a)')cline(2:len_trim(cline))
        write(cline,*)'@ comment = ',code
        write(lunbmap,'(a)')cline(2:len_trim(cline))
        write(cline,*)'@ scaling = 1.0 1.0 1.0 1.0 1.0 1.0'
        write(lunbmap,'(a)')cline(2:len_trim(cline))
        write(cline,*)'@ offset = 0.0, 0.0, 0.0 0.0 0.0 0.0'
        write(lunbmap,'(a)')cline(2:len_trim(cline))

      else if (iwbmap.gt.0) then
        open(unit=lunbmap,file=filebmap,status='new'
     &    ,form='formatted')
      ENDIF

      IF (IBMRADIAL.NE.0) THEN
        IF (XMAPMN.EQ.9999.) THEN
          WRITE(6,*)'*** WARNING WBMAP: DEFAULT FOR XMAPMN NOT USEFUL'
          WRITE(6,*)'(IBMRADIL IS NOT ZERO, SEE NAMELIST WBMAPN)'
          WRITE(LUNGFO,*)'*** WARNING WBMAP: DEFAULT FOR XMAPMN NOT USEFUL'
          WRITE(LUNGFO,*)'(IBMRADIL IS NOT ZERO, SEE NAMELIST WBMAPN)'
        ENDIF
        IF (XMAPMX.EQ.9999.) THEN
          WRITE(6,*)'*** WARNING WBMAP: DEFAULT FOR XMAPMX NOT USEFUL'
          WRITE(6,*)'(IBMRADIL IS NOT ZERO, SEE NAMELIST WBMAPN)'
          WRITE(LUNGFO,*)'*** WARNING WBMAP: DEFAULT FOR XMAPMX NOT USEFUL'
          WRITE(LUNGFO,*)'(IBMRADIL IS NOT ZERO, SEE NAMELIST WBMAPN)'
        ENDIF
        IF (YMAPMN.EQ.9999.) THEN
          WRITE(6,*)'*** WARNING WBMAP: DEFAULT FOR YMAPMN NOT USEFUL'
          WRITE(6,*)'(IBMRADIL IS NOT ZERO, SEE NAMELIST WBMAPN)'
          WRITE(LUNGFO,*)'*** WARNING WBMAP: DEFAULT FOR YMAPMN NOT USEFUL'
          WRITE(LUNGFO,*)'(IBMRADIL IS NOT ZERO, SEE NAMELIST WBMAPN)'
        ENDIF
        IF (YMAPMX.EQ.9999.) THEN
          WRITE(6,*)'*** WARNING WBMAP: DEFAULT FOR YMAPMX NOT USEFUL'
          WRITE(6,*)'(IBMRADIL IS NOT ZERO, SEE NAMELIST WBMAPN)'
          WRITE(LUNGFO,*)'*** WARNING WBMAP: DEFAULT FOR YMAPMX NOT USEFUL'
          WRITE(LUNGFO,*)'(IBMRADIL IS NOT ZERO, SEE NAMELIST WBMAPN)'
        ENDIF
        IF (XMAPMX.LT.0.D0.OR.XMAPMN.LT.0.D0) THEN
          WRITE(6,*)'*** ERROR WBMAP: XMAPMX.OR.XMAPMN .LT. 0'
          WRITE(6,*)'(SEE NAMELIST WBMAPN)'
          WRITE(LUNGFO,*)'*** ERROR WBMAP: XMAPMX.OR.XMAPMN .LT. 0'
          WRITE(LUNGFO,*)'(SEE NAMELIST WBMAPN)'
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF
      ENDIF !IBMRADIAL

      IF (XMAPMN.EQ.9999.) XMAPMN=XSTART
      IF (XMAPMX.EQ.9999.) XMAPMX=XSTOP

      IF (XMAPMX.LT.XMAPMN) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN WBMAP: XMAPMX.LT.XMAPMN'
        WRITE(LUNGFO,*)'CHECK NAMELIST WBMAP IN WAVE.IN'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN WBMAP: XMAPMX.LT.XMAPMN'
        WRITE(6,*)'CHECK NAMELIST WBMAP IN WAVE.IN'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (YMAPMX.LT.YMAPMN) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN WBMAP: YMAPMX.LT.YMAPMN'
        WRITE(LUNGFO,*)'CHECK NAMELIST WBMAP IN WAVE.IN'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN WBMAP: YMAPMX.LT.YMAPMN'
        WRITE(6,*)'CHECK NAMELIST WBMAP IN WAVE.IN'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (ZMAPMX.LT.ZMAPMN) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN WBMAP: ZMAPMX.LT.ZMAPMN'
        WRITE(LUNGFO,*)'CHECK NAMELIST WBMAP IN WAVE.IN'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN WBMAP: ZMAPMX.LT.ZMAPMN'
        WRITE(6,*)'CHECK NAMELIST WBMAP IN WAVE.IN'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (NMAPX.EQ.-9999) NMAPX=NINT((XSTOP-XSTART)*MYINUM)+1

      IF (NMAPX.GT.1)   DX=(XMAPMX-XMAPMN)/(NMAPX-1)
      IF (NMAPY.GT.1) DY=(YMAPMX-YMAPMN)/(NMAPY-1)
      IF (NMAPZ.GT.1) DZ=(ZMAPMX-ZMAPMN)/(NMAPZ-1)

+self,if=-mhbook.
      IF (IHBPOLY3D.NE.0.OR.IHBPOLY2DH.NE.0)
     &  CALL hbookm(NIDBPOLY-1,'WBMAP$',NTUP_P,'//WAVE',1024,CHTAGS_D)
+self,if=mhbook.
      IF (IHBPOLY3D.NE.0.OR.IHBPOLY2DH.NE.0)
     &  CALL hbookm(NIDBPOLY-1,'WBMAP',NTUP_P,'//WAVE',nmapx*nmapy*nmapz,
     &  CHTAGS_D)
+self.

      IF (IWBMAP.NE.3.and.iwbmap.ne.6) THEN

        IPOI=0
        DO IZ=1,NMAPZ
          DO IY=1,NMAPY
            DO IX=1,NMAPX
              IPOI=IPOI+1
              IF (IBMRADIAL.EQ.0) THEN
                X=XMAPMN+(IX-1)*DX
                Y=YMAPMN+(IY-1)*DY
                Z=ZMAPMN+(IZ-1)*DZ
              ELSE IF (IBMRADIAL.EQ.1) THEN
                R=XMAPMN+(IX-1)*DX
                PHI=YMAPMN+(IY-1)*DY
                X=BMRADX0+R*DCOSD(PHI)
                Y=BMRADY0+R*DSIND(PHI)
                Z=ZMAPMN+(IZ-1)*DZ
              ELSE
                R=ZMAPMN+(IZ-1)*DZ
                PHI=YMAPMN+(IY-1)*DY
                Z=BMRADX0+R*DCOSD(PHI)
                Y=BMRADY0+R*DSIND(PHI)
                X=XMAPMN+(IX-1)*DX
              ENDIF
              CALL MYBFELD(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
              IF (IBMAPX.EQ.0) THEN
                BX=-9999.D0
              ENDIF
              IF (IBMAPY.EQ.0) THEN
                BY=-9999.D0
              ENDIF
              IF (IBMAPZ.EQ.0) THEN
                BZ=-9999.D0
              ENDIF

              IF (IWBMAP.EQ.1) THEN
                WRITE(LUNBMAP,*)X,IPOI
                WRITE(LUNBMAP,*)Y
                WRITE(LUNBMAP,*)Z
                WRITE(LUNBMAP,*)BX
                WRITE(LUNBMAP,*)BY
                WRITE(LUNBMAP,*)BZ
                WRITE(LUNBMAP,*)
              ELSE IF (IWBMAP.EQ.2) THEN
                WRITE(LUNBMAP,'(6(1PD21.12))')X,Y,Z,BX,BY,BZ
              ENDIF

              IF (IHBPOLY3D.NE.0.OR.IHBPOLY2DH.NE.0) THEN
                TUP_D(1)=X
                TUP_D(2)=Y
                TUP_D(3)=Z
                TUP_D(4)=BX
                TUP_D(5)=BY
                TUP_D(6)=BZ
                CALL hfm(NIDBPOLY-1,TUP_D)
              ENDIF

            ENDDO
          ENDDO
        ENDDO

      ELSE IF (IWBMAP.EQ.6) THEN

        IPOI=0

        DO IX=1,NMAPX
          DO IY=1,NMAPY
            DO IZ=1,NMAPZ

              IPOI=IPOI+1

              IF (IBMRADIAL.EQ.0) THEN
                X=XMAPMN+(IX-1)*DX
                Y=YMAPMN+(IY-1)*DY
                Z=ZMAPMN+(IZ-1)*DZ
              ELSE IF (IBMRADIAL.EQ.1) THEN
                R=XMAPMN+(IX-1)*DX
                PHI=YMAPMN+(IY-1)*DY
                X=BMRADX0+R*DCOSD(PHI)
                Y=BMRADY0+R*DSIND(PHI)
                Z=ZMAPMN+(IZ-1)*DZ
              ELSE
                R=ZMAPMN+(IZ-1)*DZ
                PHI=YMAPMN+(IY-1)*DY
                Z=BMRADX0+R*DCOSD(PHI)
                Y=BMRADY0+R*DSIND(PHI)
                X=XMAPMN+(IX-1)*DX
              ENDIF
              CALL MYBFELD(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
              IF (IBMAPX.EQ.0) THEN
                BX=-9999.D0
              ENDIF
              IF (IBMAPY.EQ.0) THEN
                BY=-9999.D0
              ENDIF
              IF (IBMAPZ.EQ.0) THEN
                BZ=-9999.D0
              ENDIF

              WRITE(LUNBMAP,'(6(1PE21.12))')X,Y,Z,BX,BY,BZ

              IF (IHBPOLY3D.NE.0.OR.IHBPOLY2DH.NE.0) THEN
                TUP_D(1)=X
                TUP_D(2)=Y
                TUP_D(3)=Z
                TUP_D(4)=BX
                TUP_D(5)=BY
                TUP_D(6)=BZ
                CALL hfm(NIDBPOLY-1,TUP_D)
              ENDIF

            ENDDO
          ENDDO
        ENDDO

      ELSE IF (IWBMAP.EQ.3) THEN

        WRITE(LUNBMAP)ICODE,CODE
        WRITE(LUNBMAP)NMAPX,XMAPMN,XMAPMX
        WRITE(LUNBMAP)NMAPY,YMAPMN,YMAPMX
        WRITE(LUNBMAP)NMAPZ,ZMAPMN,ZMAPMX

        IPOI=0

        DO IX=1,NMAPX
          DO IY=1,NMAPY
            DO IZ=1,NMAPZ

              IPOI=IPOI+1

              IF (IBMRADIAL.EQ.0) THEN
                X=XMAPMN+(IX-1)*DX
                Y=YMAPMN+(IY-1)*DY
                Z=ZMAPMN+(IZ-1)*DZ
              ELSE IF (IBMRADIAL.EQ.1) THEN
                R=XMAPMN+(IX-1)*DX
                PHI=YMAPMN+(IY-1)*DY
                X=BMRADX0+R*DCOSD(PHI)
                Y=BMRADY0+R*DSIND(PHI)
                Z=ZMAPMN+(IZ-1)*DZ
              ELSE
                R=ZMAPMN+(IZ-1)*DZ
                PHI=YMAPMN+(IY-1)*DY
                Z=BMRADX0+R*DCOSD(PHI)
                Y=BMRADY0+R*DSIND(PHI)
                X=XMAPMN+(IX-1)*DX
              ENDIF
              CALL MYBFELD(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
              IF (IBMAPX.EQ.0) THEN
                BX=-9999.D0
              ENDIF
              IF (IBMAPY.EQ.0) THEN
                BY=-9999.D0
              ENDIF
              IF (IBMAPZ.EQ.0) THEN
                BZ=-9999.D0
              ENDIF

              WRITE(LUNBMAP)SNGL(BX),SNGL(BY),SNGL(BZ)

              IF (IHBPOLY3D.NE.0.OR.IHBPOLY2DH.NE.0) THEN
                TUP_D(1)=X
                TUP_D(2)=Y
                TUP_D(3)=Z
                TUP_D(4)=BX
                TUP_D(5)=BY
                TUP_D(6)=BZ
                CALL hfm(NIDBPOLY-1,TUP_D)
              ENDIF

            ENDDO
          ENDDO
        ENDDO

      ENDIF !IWBMAP.EQ.3

      IF (IWBMAP.GT.0) CLOSE (LUNBMAP)

      IF (IWBMAP.GT.0) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     SR WBMAP: FIELD MAP WRITTEN TO FILE'
        WRITE(LUNGFO,*)'     ',FILEBMAP
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'     SR WBMAP: FIELD MAP WRITTEN TO FILE'
        WRITE(6,*)'     ',FILEBMAP
        WRITE(6,*)

      ENDIF

      IF (IHBPOLY3D.NE.0.OR.IHBPOLY2DH.NE.0) THEN
        CALL MHROUT(NIDBPOLY-1,ICYCLE,' ')
        CALL hdeletm(NIDBPOLY-1)
      ENDIF

      RETURN
      END
+DECK,WBMAP4.
*CMZ :  2.45/03 18/09/2013  12.33.23  by  Michael Scheer
*CMZ :  2.45/01 13/12/2002  17.24.23  by  Michael Scheer
*CMZ :  2.44/02 12/12/2002  16.04.18  by  Michael Scheer
*CMZ :  2.44/01 12/12/2002  11.07.45  by  Michael Scheer
*CMZ :  2.44/00 07/11/2002  15.12.01  by  Michael Scheer
*CMZ :  2.42/04 14/09/2002  07.16.48  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.02  by  Michael Scheer
*CMZ :  2.39/01 15/01/2002  16.47.24  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  1.03/06 06/08/98  18.01.11  by  Michael Scheer
*CMZ :  1.00/00 24/09/97  10.31.28  by  Michael Scheer
*CMZ : 00.02/03 23/01/97  17.29.29  by  Michael Scheer
*CMZ : 00.02/00 25/11/96  09.51.41  by  Michael Scheer
*-- Author :    Michael Scheer   28/09/95
      SUBROUTINE WBMAP4
+seq,gplhint.

C--- TO WRITE 3D FIELD MAP IN TERMS OF POLYNOMIAL COEFFICIENTS TO FILE


      IMPLICIT NONE

+SELF,IF=LINUX.
      EXTERNAL DCOSD,DSIND
      DOUBLE PRECISION DCOSD,DSIND
+SELF.

+SEQ,CONTRL.
+SEQ,CMPARA.
+SEQ,MYFILES.
+SEQ,BPOLY3DG.
+SEQ,BMAP.

      DOUBLE PRECISION, DIMENSION (:), ALLOCATABLE:: X,Y,Z,BX,BY,BZ
     &                                                ,DXX,DYY,DZZ

      DOUBLE PRECISION DX,DY,DZ,AX,AY,AZ,SCALXYZ

      INTEGER IX,IY,IZ,NPOI,IX1,IY1,IZ1,IX2,IY2,IZ2,JX,JY,JZ,IND,IFAIL
      INTEGER LX1,LY1,LZ1,LX2,LY2,LZ2

      CHARACTER(60) COMMENT

      DATA DX,DY,DZ/0.D0,0.D0,0.D0/
      DATA SCALXYZ/100.D0/

      IF (IBMRADIAL.NE.0) THEN
          WRITE(6,*) '*** ERROR IN WBMAP4: IBMRADIAL.NE.0'
          WRITE(LUNGFO,*) '*** ERROR IN WBMAP4: IBMRADIAL.NE.0'
          STOP
      ENDIF

      LORD3DG=1
      NDORD3DG=1

        IF (NMAPX.EQ.-9999) NMAPX=NINT((XSTOP-XSTART)*MYINUM)+1

      ALLOCATE(X(NBMDATX*NBMDATY*NBMDATZ))
      ALLOCATE(Y(NBMDATX*NBMDATY*NBMDATZ))
      ALLOCATE(Z(NBMDATX*NBMDATY*NBMDATZ))
      ALLOCATE(DXX(NBMDATX*NBMDATY*NBMDATZ))
      ALLOCATE(DYY(NBMDATX*NBMDATY*NBMDATZ))
      ALLOCATE(DZZ(NBMDATX*NBMDATY*NBMDATZ))
      ALLOCATE(BX(NBMDATX*NBMDATY*NBMDATZ))
      ALLOCATE(BY(NBMDATX*NBMDATY*NBMDATZ))
      ALLOCATE(BZ(NBMDATX*NBMDATY*NBMDATZ))

        IF (XMAPMN.EQ.9999.) XMAPMN=XSTART
        IF (XMAPMX.EQ.9999.) XMAPMX=XSTOP

        IF (IWBMAPEXT.EQ.0.AND.NMAPX.LT.NBMDATX) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN WBMAP4: NMAPX.LT.NBMDATX'
            WRITE(LUNGFO,*)'CHECK NAMELISTS BMAP AND BGRIDN IN WAVE.IN'
            WRITE(6,*)
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN WBMAP4: NMAPX.LT.NBMDATX'
            WRITE(6,*)'CHECK NAMELISTS BMAP AND BGRIDN IN WAVE.IN'
            WRITE(6,*)
            STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF

        IF (IWBMAPEXT.EQ.0.AND.NMAPY.LT.NBMDATY) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN WBMAP4: NMAPY.LT.NBMDATY'
            WRITE(LUNGFO,*)'CHECK NAMELISTS BMAP AND BGRIDN IN WAVE.IN'
            WRITE(6,*)
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN WBMAP4: NMAPY.LT.NBMDATY'
            WRITE(6,*)'CHECK NAMELISTS BMAP AND BGRIDN IN WAVE.IN'
            WRITE(6,*)
            STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF

        IF (IWBMAPEXT.EQ.0.AND.NMAPZ.LT.NBMDATZ) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN WBMAP4: NMAPZ.LT.NBMDATZ'
            WRITE(LUNGFO,*)'CHECK NAMELISTS BMAP AND BGRIDN IN WAVE.IN'
            WRITE(6,*)
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN WBMAP4: NMAPZ.LT.NBMDATZ'
            WRITE(6,*)'CHECK NAMELISTS BMAP AND BGRIDN IN WAVE.IN'
            WRITE(6,*)
            STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF

        IF (XMAPMX.LT.XMAPMN) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN WBMAP4: XMAPMX.LT.XMAPMN'
            WRITE(LUNGFO,*)'CHECK NAMELIST BMAP IN WAVE.IN'
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN WBMAP4: XMAPMX.LT.XMAPMN'
            WRITE(6,*)'CHECK NAMELIST BMAP IN WAVE.IN'
            WRITE(6,*)
            STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF

        IF (YMAPMX.LT.YMAPMN) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN WBMAP4: YMAPMX.LT.YMAPMN'
            WRITE(LUNGFO,*)'CHECK NAMELIST BMAP IN WAVE.IN'
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN WBMAP4: YMAPMX.LT.YMAPMN'
            WRITE(6,*)'CHECK NAMELIST BMAP IN WAVE.IN'
            WRITE(6,*)
            STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF

        IF (ZMAPMX.LT.ZMAPMN) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN WBMAP4: ZMAPMX.LT.ZMAPMN'
            WRITE(LUNGFO,*)'CHECK NAMELIST BMAP IN WAVE.IN'
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN WBMAP4: ZMAPMX.LT.ZMAPMN'
            WRITE(6,*)'CHECK NAMELIST BMAP IN WAVE.IN'
            WRITE(6,*)
            STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF

      IF (NMAPX.EQ.-9999) NMAPX=NINT((XSTOP-XSTART)*MYINUM)+1
      IF (NMAPX.GT.1)   DX=(XMAPMX-XMAPMN)/(NMAPX-1)*SCALXYZ
      IF (NMAPY.GT.1) DY=(YMAPMX-YMAPMN)/(NMAPY-1)*SCALXYZ
      IF (NMAPZ.GT.1) DZ=(ZMAPMX-ZMAPMN)/(NMAPZ-1)*SCALXYZ

      OPEN(UNIT=LUNBMAP,FILE=FILEBMAP,STATUS='NEW'
     & ,FORM='UNFORMATTED')

      WRITE(LUNBMAP)'MAP OF COEFFS'
      WRITE(LUNBMAP)ICODE,CODE
      WRITE(LUNBMAP)NMAPX,XMAPMN,XMAPMX
      WRITE(LUNBMAP)NMAPY,YMAPMN,YMAPMX
      WRITE(LUNBMAP)NMAPZ,ZMAPMN,ZMAPMX

C DUMMY CALL TO INITIALIZE ICINDG

      NPOI=0
        DO IX=1,NBMDATX
        DO IY=1,NBMDATY
        DO IZ=1,NBMDATZ

         NPOI=NPOI+1

         X(NPOI)=IX
         Y(NPOI)=IY
         Z(NPOI)=IZ
         BX(NPOI)=0.D0
         BY(NPOI)=0.D0
         BZ(NPOI)=0.D0
      ENDDO
      ENDDO
      ENDDO

      CALL BMPOT3D4(NPOI,X,Y,Z,BX,BY,BZ,IFAIL,COMMENT)

      WRITE(LUNBMAP)NCINDG,MORD3DG
      DO IND=1,NCINDG
          WRITE(LUNBMAP)ICINDG(1,IND),ICINDG(2,IND),ICINDG(3,IND)
      ENDDO

      DO JX=1,NMAPX-1
      DO JY=1,NMAPY-1
      DO JZ=1,NMAPZ-1

          IF (IWBMAPEXT.NE.0) THEN
             IX1=-(NBMDATX-1)/2-1
             IX2=IX1+NBMDATX-1
             LX1=IX1
             LX2=IX2
            ELSE
             IX1=-(NBMDATX-1)/2-1
             LX1=IX1
             LX2=LX1+NBMDATX-1
             IF (IX1.LT.-JX) IX1=-JX
             IX2=IX1+NBMDATX-1
             IF (IX2+JX.GT.NMAPX-1) THEN
            IX2=NMAPX-1-JX
            IX1=IX2-NBMDATX+1
             ENDIF
          ENDIF

          IF (IWBMAPEXT.NE.0) THEN
             IY1=-(NBMDATY-1)/2-1
             IY2=IY1+NBMDATY-1
             LY1=IY1
             LY2=IY2
            ELSE
             IY1=-(NBMDATY-1)/2-1
             LY1=IY1
             LY2=LY1+NBMDATY-1
             IF (IY1.LT.-JY) IY1=-JY
             IY2=IY1+NBMDATY-1
             IF (IY2+JY.GT.NMAPY-1) THEN
            IY2=NMAPY-1-JY
            IY1=IY2-NBMDATY+1
             ENDIF
          ENDIF

          IF (IWBMAPEXT.NE.0) THEN
             IZ1=-(NBMDATZ-1)/2-1
             IZ2=IZ1+NBMDATZ-1
             LZ1=IZ1
             LZ2=IZ2
            ELSE
             IZ1=-(NBMDATZ-1)/2-1
             LZ1=IZ1
             LZ2=LZ1+NBMDATZ-1
             IF (IZ1.LT.-JZ) IZ1=-JZ
             IZ2=IZ1+NBMDATZ-1
             IF (IZ2+JZ.GT.NMAPZ-1) THEN
            IZ2=NMAPZ-1-JZ
            IZ1=IZ2-NBMDATZ+1
             ENDIF
          ENDIF

          NPOI=0
          DO IX=IX1,IX2
          DO IY=IY1,IY2
          DO IZ=IZ1,IZ2

         NPOI=NPOI+1

         X(NPOI)=XMAPMN+(JX+IX)*DX/SCALXYZ
         Y(NPOI)=YMAPMN+(JY+IY)*DY/SCALXYZ
         Z(NPOI)=ZMAPMN+(JZ+IZ)*DZ/SCALXYZ

         CALL MYBFELD(X(NPOI),Y(NPOI),Z(NPOI)
     &         ,BX(NPOI),BY(NPOI),BZ(NPOI),AX,AY,AZ)

            ENDDO
          ENDDO
          ENDDO

          NPOI=0
          DO IX=LX1,LX2
          DO IY=LY1,LY2
          DO IZ=LZ1,LZ2

         NPOI=NPOI+1

         DXX(NPOI)=(IX-LX1-1)*DX
         DYY(NPOI)=(IY-LY1-1)*DY
         DZZ(NPOI)=(IZ-LZ1-1)*DZ

            ENDDO
          ENDDO
          ENDDO

          CALL BMPOT3D4(NPOI,DXX,DYY,DZZ,BX,BY,BZ,IFAIL,COMMENT)

          IF (IFAIL.NE.0) THEN
             WRITE(6,*)'*** ERROR IN WBMAP4: FIT FAILED'
             WRITE(6,*)'X,Y,Z:'
             WRITE(6,*)X,Y,Z
             WRITE(6,*)'XPOI(NPOI),YPOI(NPOI),ZPOI(NPOI)'
             WRITE(6,*)'BXPOI(NPOI),BYPOI(NPOI),BZPOI(NPOI)'
             WRITE(LUNGFO,*)'*** ERROR IN WBMAP4: FIT FAILED'
             WRITE(LUNGFO,*)'X,Y,Z:'
             WRITE(LUNGFO,*)X,Y,Z
             WRITE(LUNGFO,*)'XPOI(NPOI),YPOI(NPOI),ZPOI(NPOI)'
             WRITE(LUNGFO,*)'BXPOI(NPOI),BYPOI(NPOI),BZPOI(NPOI)'
             STOP
          ENDIF

          WRITE(LUNBMAP)(CINDG4(IND),IND=1,NCINDG)

      ENDDO
      ENDDO
      ENDDO

      WRITE(LUNBMAP)SCALXYZ

      CLOSE (LUNBMAP)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SR WBMAP4: FIELD MAP WRITTEN TO FILE'
      WRITE(LUNGFO,*)'     ',FILEBMAP
      WRITE(LUNGFO,*)
      WRITE(6,*)
      WRITE(6,*)'     SR WBMAP4: FIELD MAP WRITTEN TO FILE'
      WRITE(6,*)'     ',FILEBMAP
      WRITE(6,*)

      DEALLOCATE (X)
      DEALLOCATE (Y)
      DEALLOCATE (Z)
      DEALLOCATE (BX)
      DEALLOCATE (BY)
      DEALLOCATE (BZ)

      RETURN
      END
+DECK,WBMAP5.
*CMZ :  4.00/04 17/05/2019  14.17.20  by  Michael Scheer
*CMZ :  3.05/10 13/08/2018  14.40.26  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.19.07  by  Michael Scheer
*CMZ :  2.63/05 22/07/2009  08.28.26  by  Michael Scheer
*CMZ :  2.54/07 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.47/03 12/03/2003  16.01.17  by  Michael Scheer
*CMZ :  2.45/03 16/12/2002  17.52.31  by  Michael Scheer
*CMZ :  2.44/01 10/12/2002  17.49.10  by  Michael Scheer
*CMZ :  2.44/00 07/11/2002  15.12.01  by  Michael Scheer
*CMZ :  2.42/04 14/09/2002  07.16.48  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.02  by  Michael Scheer
*CMZ :  2.39/01 15/01/2002  16.47.24  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  1.03/06 06/08/98  18.01.11  by  Michael Scheer
*CMZ :  1.00/00 24/09/97  10.31.28  by  Michael Scheer
*CMZ : 00.02/03 23/01/97  17.29.29  by  Michael Scheer
*CMZ : 00.02/00 25/11/96  09.51.41  by  Michael Scheer
*-- Author :    Michael Scheer   28/09/95
      SUBROUTINE WBMAP5
+seq,gplhint.

+SEQ,BMESSF90U,IF=F90.

C--- CONVERT COLUMN FORMAT OF FILEB0 TO BMESS-FORMAT FOR BMESS


      IMPLICIT NONE

+SELF,IF=LINUX.
      EXTERNAL DCOSD,DSIND
      DOUBLE PRECISION DCOSD,DSIND
+SELF.

+SEQ,CONTRL.
+SEQ,CMPARA.
+SEQ,MYFILES.
+SEQ,BMAP.
+SEq,bmessf90.

      DOUBLE PRECISION DX,DY,DZ,BX,BY,BZ,X,Y,Z,EPSXYZ,DXX,DYY,DZZ

      INTEGER I,IX,IY,IZ

      DATA DX,DY,DZ/0.D0,0.D0,0.D0/
      DATA EPSXYZ/1.D-6/

      IF (IBMRADIAL.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN WBMAP5: IBMRADIAL.NE.0'
          WRITE(LUNGFO,*)'CHECK NAMELIST BMAP IN WAVE.IN'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN WBMAP5: IBMRADIAL.NE.0'
          WRITE(6,*)'CHECK NAMELIST BMAP IN WAVE.IN'
          WRITE(6,*)
          STOP
      ENDIF !IBMRADIAL

      IF (NMAPX.LT.2) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN WBMAP5: NMAPX.LT.2'
          WRITE(LUNGFO,*)'CHECK NAMELIST BMAP IN WAVE.IN'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN WBMAP5: NMAPX.LT.2'
          WRITE(6,*)'CHECK NAMELIST BMAP IN WAVE.IN'
          WRITE(6,*)
          STOP
      ENDIF !NMAPX

      IF (NMAPY.LT.2) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN WBMAP5: NMAPY.LT.2'
          WRITE(LUNGFO,*)'CHECK NAMELIST BMAP IN WAVE.IN'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN WBMAP5: NMAPY.LT.2'
          WRITE(6,*)'CHECK NAMELIST BMAP IN WAVE.IN'
          WRITE(6,*)
          STOP
      ENDIF !NMAPY

      IF (NMAPZ.LT.2) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN WBMAP5: NMAPZ.LT.2'
          WRITE(LUNGFO,*)'CHECK NAMELIST BMAP IN WAVE.IN'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN WBMAP5: NMAPZ.LT.2'
          WRITE(6,*)'CHECK NAMELIST BMAP IN WAVE.IN'
          WRITE(6,*)
          STOP
      ENDIF !NMAPZ

      NBMESSX=NMAPX
      NBMESSY=NMAPY
      NBMESSZ=NMAPZ

      DX=(XMAPMX-XMAPMN)/(NMAPX-1)
      DY=(YMAPMX-YMAPMN)/(NMAPY-1)
      DZ=(ZMAPMX-ZMAPMN)/(NMAPZ-1)

        ALLOCATE(BDATA(3,NBMESSZ,NBMESSY,NBMESSX))

      DO IX=1,NBMESSX
        DO IY=1,NBMESSY
        DO IZ=1,NBMESSZ
        DO I=1,3
            BDATA(I,IZ,IY,IX)=-9999.
        ENDDO
        ENDDO
        ENDDO
        ENDDO

      OPEN(UNIT=LUNB0,FILE=FILEB0,STATUS='OLD',FORM='FORMATTED')

      I=0
1     READ(LUNB0,*,END=9)X,Y,Z,BX,BY,BZ

         I=I+1

         IX=NINT((X-XMAPMN)/DX)+1
         IY=NINT((Y-YMAPMN)/DY)+1
         IZ=NINT((Z-ZMAPMN)/DZ)+1

         DXX=X-(XMAPMN+(IX-1)*DX)
         DYY=Y-(YMAPMN+(IY-1)*DY)
         DZZ=Z-(ZMAPMN+(IZ-1)*DZ)

         IF (ABS(DXX).LT.EPSXYZ) THEN
             X=XMAPMN+(IX-1)*DX
         ENDIF

         IF (ABS(DYY).LT.EPSXYZ) THEN
             Y=YMAPMN+(IY-1)*DY
         ENDIF

         IF (ABS(DZZ).LT.EPSXYZ) THEN
             Z=ZMAPMN+(IZ-1)*DZ
         ENDIF

         IF (IX.LT.1.OR.IX.GT.NMAPX
     &         .OR.X.LT.XMAPMN-EPSXYZ.OR.X.GT.XMAPMX+EPSXYZ) THEN
             WRITE(6,*)'*** ERROR IN WBMAP5: BAD X'
             WRITE(6,*)'X: ',X
             WRITE(LUNGFO,*)'*** ERROR IN WBMAP5: BAD X'
             WRITE(LUNGFO,*)'IX,X: ',IX,X
             STOP
         ENDIF

         IF (IY.LT.1.OR.IY.GT.NMAPY
     &         .OR.Y.LT.YMAPMN-EPSXYZ.OR.Y.GT.YMAPMX+EPSXYZ) THEN
             WRITE(6,*)'*** ERROR IN WBMAP5: BAD Y'
             WRITE(6,*)'Y: ',Y
             WRITE(LUNGFO,*)'*** ERROR IN WBMAP5: BAD Y'
             WRITE(LUNGFO,*)'IY,Y: ',IY,Y
             STOP
         ENDIF

         IF (IZ.LT.1.OR.IZ.GT.NMAPZ
     &         .OR.Z.LT.ZMAPMN-EPSXYZ.OR.Z.GT.ZMAPMX+EPSXYZ) THEN
             WRITE(6,*)'*** ERROR IN WBMAP5: BAD Z'
             WRITE(6,*)'Z: ',Z
             WRITE(LUNGFO,*)'*** ERROR IN WBMAP5: BAD Z'
             WRITE(LUNGFO,*)'IZ,Z: ',IZ,Z
             STOP
         ENDIF

         BDATA(1,IZ,IY,IX)=BX
         BDATA(2,IZ,IY,IX)=BY
         BDATA(3,IZ,IY,IX)=BZ

      GOTO 1

9     CLOSE (LUNBMAP)

      IF (I.NE.NMAPX*NMAPY*NMAPZ) THEN
             WRITE(6,*)'*** ERROR IN WBMAP5: BAD NUMBER OF DATA'
             WRITE(6,*)'EXPECTED: ',NMAPX*NMAPY*NMAPZ
             WRITE(6,*)'FOUND: ',I
             WRITE(LUNGFO,*)'*** ERROR IN WBMAP5: BAD NUMBER OF DATA'
             WRITE(LUNGFO,*)'EXPECTED: ',NMAPX*NMAPY*NMAPZ
             WRITE(LUNGFO,*)'FOUND: ',I
             STOP
          ENDIF

      OPEN(UNIT=LUNBMAP,FILE=FILEBMAP,STATUS='NEW'
     &      ,FORM='UNFORMATTED')

                WRITE(LUNBMAP)ICODE,CODE
                WRITE(LUNBMAP)NMAPX,XMAPMN,XMAPMX
                WRITE(LUNBMAP)NMAPY,YMAPMN,YMAPMX
                WRITE(LUNBMAP)NMAPZ,ZMAPMN,ZMAPMX

      DO IX=1,NBMESSX
        DO IY=1,NBMESSY
        DO IZ=1,NBMESSZ
        DO I=1,3
            IF (BDATA(I,IZ,IY,IX).EQ.-9999.) THEN
             WRITE(6,*)'*** ERROR IN WBMAP5: FIELD DATA MISSING'
             WRITE(6,*)'IX,IY,IZ:'
             WRITE(6,*)IX,IY,IZ
             WRITE(6,*)'DX,DY,DZ:'
             WRITE(6,*)DX
             WRITE(6,*)DY
             WRITE(6,*)DZ
             WRITE(6,*)'X,Y,Z:'
             WRITE(6,*)XMAPMN+(IX-1)*DX
             WRITE(6,*)YMAPMN+(IY-1)*DY
             WRITE(6,*)ZMAPMN+(IZ-1)*DZ
             WRITE(LUNGFO,*)'*** ERROR IN WBMAP5: FIELD DATA MISSING'
             WRITE(LUNGFO,*)'X,Y,Z:'
             WRITE(LUNGFO,*)XMAPMN+(IX-1)*DX
             WRITE(LUNGFO,*)YMAPMN+(IY-1)*DY
             WRITE(LUNGFO,*)ZMAPMN+(IZ-1)*DZ
             STOP
          ENDIF
        ENDDO
        WRITE(LUNBMAP)(BDATA(I,IZ,IY,IX),I=1,3)
        ENDDO
        ENDDO
        ENDDO

      CLOSE (LUNB0)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &'       WBMAP5: FIELD MAP CONVERTED'
      WRITE(LUNGFO,*)'     INPUT FILE: ',FILEB0
      WRITE(LUNGFO,*)'     OUTPUT FILE: ',FILEBMAP
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     NX, XMIN, XMAX:  ',NMAPX,SNGL(XMAPMN),SNGL(XMAPMX)
      WRITE(LUNGFO,*)'     NY, YMIN, YMAX:  ',NMAPY,SNGL(YMAPMN),SNGL(YMAPMX)
      WRITE(LUNGFO,*)'     NZ, ZMIN, ZMAX:  ',NMAPZ,SNGL(ZMAPMN),SNGL(ZMAPMX)
      WRITE(LUNGFO,*)

      WRITE(6,*)
     &'       WBMAP5: FIELD MAP CONVERTED'
      WRITE(6,*)'     INPUT FILE: ',FILEB0
      WRITE(6,*)'     OUTPUT FILE: ',FILEBMAP
      WRITE(6,*)
      WRITE(6,*)
      WRITE(6,*)'     NX, XMIN, XMAX:  ',NMAPX,SNGL(XMAPMN),SNGL(XMAPMX)
      WRITE(6,*)'     NY, YMIN, YMAX:  ',NMAPY,SNGL(YMAPMN),SNGL(YMAPMX)
      WRITE(6,*)'     NZ, ZMIN, ZMAX:  ',NMAPZ,SNGL(ZMAPMN),SNGL(ZMAPMX)
      WRITE(6,*)


      RETURN
      END
+DECK,wbtab,T=F77.
*CMZ :  4.00/14 22/12/2021  16.52.22  by  Michael Scheer
*CMZ :  4.00/11 19/05/2021  09.19.51  by  Michael Scheer
*CMZ :  3.05/10 08/08/2018  14.47.17  by  Michael Scheer
*CMZ :  3.02/03 23/10/2014  13.43.13  by  Michael Scheer
*CMZ :  3.01/00 06/05/2013  13.15.56  by  Michael Scheer
*CMZ :  3.00/01 19/03/2013  17.16.39  by  Michael Scheer
*CMZ :  3.00/00 14/03/2013  10.32.05  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  10.28.51  by  Michael Scheer
*CMZ :  2.68/05 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.68/02 14/06/2012  13.07.05  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  09.55.58  by  Michael Scheer
*CMZ :  2.66/20 06/07/2011  10.03.53  by  Michael Scheer
*CMZ :  2.66/13 21/06/2010  15.29.34  by  Michael Scheer
*CMZ :  2.63/05 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.61/02 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.58/00 15/01/2007  09.59.51  by  Michael Scheer
*CMZ :  2.56/00 22/09/2005  15.19.02  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  10.48.09  by  Michael Scheer
*CMZ :  2.48/04 16/04/2004  09.24.47  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.02  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  11.29.16  by  Michael Scheer
*CMZ :  2.20/05 13/03/2001  13.41.14  by  Michael Scheer
*CMZ :  2.16/08 31/10/2000  14.25.16  by  Michael Scheer
*CMZ :  2.16/06 29/08/2000  13.18.21  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.40.46  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  2.13/11 21/03/2000  13.34.41  by  Michael Scheer
*CMZ :  2.12/00 02/06/99  13.56.19  by  Michael Scheer
*CMZ :  1.03/06 25/06/98  17.04.16  by  Michael Scheer
*CMZ :  1.02/03 14/01/98  10.03.25  by  Michael Scheer
*CMZ :  1.00/00 24/09/97  10.31.28  by  Michael Scheer
*CMZ : 00.01/12 11/09/96  17.54.03  by  Michael Scheer
*CMZ : 00.01/10 30/05/96  15.56.04  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  11.13.16  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.56.14  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.44  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE WBTAB
+seq,gplhint.

+SEQ,TRACKF90U,IF=F90.

C     WRITES MAGNETIC FIELD BY TO DATA FILE, FILE CAN BE READ FROM SR BTAB

      IMPLICIT NONE

+SEQ,B0SCGLOB.
+SEQ,HALBASY.

      INTEGER I,IT

      DOUBLE PRECISION EZ(3),EY(3),EZN,EYN
      DOUBLE PRECISION X,BX,BY,BZ,AX,AY,AZ,BI1,BI2,DX
      DOUBLE PRECISION BXU,BYU,BZU,BXL,BYL,BZL
      DOUBLE PRECISION AXM,AYM,AZM,AYINT,AZINT,AXP,AYP,AZP,BXM,BZM,BXP,BZP
      DOUBLE PRECISION BIQ,BYM,BYP
      DOUBLE PRECISION QMAX,SMAX
      DOUBLE PRECISION D2BZDZ,D2BYDZ,D2BZDY,D2BYDY
     &  ,DBYDZ,DBZDZ,VXZNNN
+SELF,IF=-WBTABPARABEL.
     &  ,DBYPDZ,DBYMDZ,DBZPDZ,DBZMDZ
     &  ,DBYUDY,DBYLDY
     &  ,DBZUDY,DBZLDY
     &  ,BEY,BEZ
     &  ,D52,D32,D21,D24
+SELF.
      DOUBLE PRECISION    DBY1DZ,D2BY1DZ
      DOUBLE PRECISION    DBZ1DZ,D2BZ1DZ
      DOUBLE PRECISION    D2BY1DY
      DOUBLE PRECISION    D2BZ1DY
      DOUBLE PRECISION    BY1,BZ1,BI11
      DOUBLE PRECISION BYDZS,BZDZS,BYDYS,BZDYS
      DOUBLE PRECISION BYDZS1,BZDZS1,BYDYS1,BZDYS1
      DOUBLE PRECISION BBYDZS,BBZDZS,BBYDYS,BBZDYS
      DOUBLE PRECISION VXN,VYN,VZN,V,DS
     &  ,DGAMMA

      DOUBLE PRECISION X2B(5),Y2B(5),Z2B(5)
     &  ,BFX(5),BFY(5),BFZ(5)
     &  ,AX2,AY2,AZ2
      DOUBLE PRECISION X1(5),Y1(5),Z1(5)
     &  ,VX1(5),VY1(5),VZ1(5),DT2,DT
     &  ,X2(5),Y2(5),Z2(5),VX2(5),VY2(5),VZ2(5)
     &  ,VXP(5),VYP(5),VZP(5)

c+self,IF=WBTABPARABEL.
      INTEGER IFAIL
      real (kind=16) XOPT,AOPT,XPAR(3),YPAR(3),APAR(3),YPPAR(3)
c+self.

c+self,IF=WBTABTUP.
      INTEGER NTUP_P,ICYCLE
      PARAMETER (NTUP_P=17)
      REAL*8 TUP_D(NTUP_P)
      CHARACTER(5) CHTAGS_D(NTUP_P)
      CHARACTER(6) CHTAGS(7)

      data chtags_d/'x','by','y','z','bi1','bi2'
     &  ,'bq','byzz','bzzz','byyy','bzyy','b2yzz'
     &  ,'b2zzz','b2yyy','b2zyy','ay','az'/

      data chtags/'x','y','z','d2bydy','d2bydz','d2bzdy','d2bzdz'/
c+self.

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,WBTAB.
+SEQ,TRACK.
+SEQ,PHYCON.

c+self,IF=-WBTABTUP.
      REAL*4 SCALE
      DATA SCALE/1./
c+self.

      IF(BTABS.EQ.9999.) BTABS=XSTART
      IF(BTABE.EQ.9999.) BTABE=XSTOP
      IF(NPWBTAB.EQ.9999) NPWBTAB=NCO

+self,if=-mhbook.
      CALL hbookm(900,'WBTAB$',NTUP_P,'//WAVE',1024,CHTAGS_D)
      CALL hbookm(901,'WBSEX$',7,'//WAVE',1024,CHTAGS)
+self,if=mhbook.
      CALL hbookm(900,'WBTAB$',NTUP_P,'//WAVE',npwbtab,CHTAGS_D)
      CALL hbookm(901,'WBSEX$',7,'//WAVE',npwbtab,CHTAGS)
+self.

c+self,IF=-WBTABPARABEL.
C     WRITE(6,*)'*** WBTAB: SELECTION IN CMZ -WBTABPARABEL ***'
c+self.
      IF (FILEWBT.EQ.FILETB.and.irbtab.ne.0.or.irbtabzy.ne.0.
     &    or.irbtabxyz.ne.0.or.ifourbtabzy.ne.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN WBTAB ****'
        WRITE(LUNGFO,*)
     &    ' FILESNAMES FOR READING AND WRITING MAGNETIC FIELD DATA IDENTICAL '
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN WBTAB ****'
        WRITE(6,*)
     &    ' FILESNAMES FOR READING AND WRITING MAGNETIC FIELD DATA IDENTICAL '
        WRITE(6,*)
        STOP
      ENDIF

c+self,IF=-WBTABTUP
      OPEN(UNIT=LUNWBT,FILE=FILEWBT,STATUS='unknown')
      OPEN(UNIT=99,FILE='wbtab_sextupole.dat',STATUS='unknown')

      WRITE(LUNWBT,*) ICODE,CODE
      WRITE(LUNWBT,*) SCALE,SCALE

      WRITE(99,*) ICODE,CODE

      IF(IWBTAB.NE.100) THEN

        WRITE(LUNWBT,*) NPWBTAB

        WRITE(99,*) NPWBTAB
c+self,IF=WBTABTUP.
c      IF(IWBTAB.NE.100) THEN
c+self.
        BI1=0.0
        BI2=0.0
        BIQ=0.0
        BYDZS=0.0
        BZDZS=0.0
        BYDYS=0.0
        BZDYS=0.0
        BBYDZS=0.0
        BBZDZS=0.0
        BBYDYS=0.0
        BBZDYS=0.0
        QMAX=0.0
        SMAX=0.0
        AZINT=0.D0
        AYINT=0.D0

        X=BTABS
        DX=(BTABE-BTABS)/(NPWBTAB-1)

        DO I=1,NPWBTAB

          CALL MYBFELD(X,BTABY,BTABZ-BTABEPS,BXM,BYM,BZM,AXM,AYM,AZM)
          CALL MYBFELD(X,BTABY,BTABZ        ,BX ,BY ,BZ ,AX ,AY ,AZ )
          CALL MYBFELD(X,BTABY,BTABZ+BTABEPS,BXP,BYP,BZP,AXP,AYP,AZP)

+self,IF=WBTABPARABEL.
          XPAR(1)=BTABZ-BTABEPS
          XPAR(2)=BTABZ
          XPAR(3)=BTABZ+BTABEPS
          YPAR(1)=BYM
          YPAR(2)=BY
          YPAR(3)=BYP
+self.
+SELF,IF=VMS,HPUX,TRUE64,IF=WBTABPARABEL.
          CALL UTIL_PARABEL_Q(XPAR,YPAR,APAR,YPPAR,XOPT,AOPT,IFAIL)
+self.
+SELF,IF=LINUX,IF=WBTABPARABEL.
          CALL UTIL_PARABEL(XPAR,YPAR,APAR,YPPAR,XOPT,AOPT,IFAIL)
+SELF.
+SELF,IF=WBTABPARABEL.
          IF (IFAIL.NE.0) THEN
            WRITE(6,*)'*** WARNING IN WBTAB: IFAIL NOT ZERO'
            WRITE(LUNGFO,*)'*** WARNING IN WBTAB: IFAIL NOT ZERO'
            WRITE(LUNGFO,*)XPAR(1),YPAR(1)
            WRITE(LUNGFO,*)XPAR(2),YPAR(2)
            WRITE(LUNGFO,*)XPAR(3),YPAR(3)
          ENDIF
          DBYDZ=YPPAR(2)
          D2BYDZ=2.D0*APAR(3)
          YPAR(1)=BZM
          YPAR(2)=BZ
          YPAR(3)=BZP
+SELF.
+SELF,IF=VMS,HPUX,TRUE64,IF=WBTABPARABEL.
          CALL UTIL_PARABEL_Q(XPAR,YPAR,APAR,YPPAR,XOPT,AOPT,IFAIL)
+SELF.
+SELF,IF=LINUX,IF=WBTABPARABEL.
          CALL UTIL_PARABEL  (XPAR,YPAR,APAR,YPPAR,XOPT,AOPT,IFAIL)
+SELF.
+SELF,IF=WBTABPARABEL.
          IF (IFAIL.NE.0) THEN
            WRITE(6,*)'*** WARNING IN WBTAB: IFAIL NOT ZERO'
            WRITE(LUNGFO,*)'*** WARNING IN WBTAB: IFAIL NOT ZERO'
            WRITE(LUNGFO,*)XPAR(1),YPAR(1)
            WRITE(LUNGFO,*)XPAR(2),YPAR(2)
            WRITE(LUNGFO,*)XPAR(3),YPAR(3)
          ENDIF
          DBZDZ=YPPAR(2)
          D2BZDZ=2.D0*APAR(3)
+SELF.
+SELF,IF=-WBTABPARABEL.
          DBYPDZ=(BYP-BY)/BTABEPS
          DBYMDZ=(BY-BYM)/BTABEPS
          DBYDZ=(DBYPDZ+DBYMDZ)/2.
          D2BYDZ=(DBYPDZ-DBYMDZ)/BTABEPS

          DBZPDZ=(BZP-BZ)/BTABEPS
          DBZMDZ=(BZ-BZM)/BTABEPS
          DBZDZ=(DBZPDZ+DBZMDZ)/2.
          D2BZDZ=(DBZPDZ-DBZMDZ)/BTABEPS
+SELF.
          CALL MYBFELD(X,BTABY-BTABEPS,BTABZ,BXL,BYL,BZL,AX,AY,AZ)
          CALL MYBFELD(X,BTABY+BTABEPS,BTABZ,BXU,BYU,BZU,AX,AY,AZ)

+SELF,IF=WBTABPARABEL.
          XPAR(1)=BTABY-BTABEPS
          XPAR(2)=BTABY
          XPAR(3)=BTABY+BTABEPS
          YPAR(1)=BYL
          YPAR(2)=BY
          YPAR(3)=BYU
+SELF,IF=VMS,HPUX,TRUE64,IF=WBTABPARABEL.
          CALL UTIL_PARABEL_Q(XPAR,YPAR,APAR,YPPAR,XOPT,AOPT,IFAIL)
+SELF.
+SELF,IF=LINUX,IF=WBTABPARABEL.
          CALL UTIL_PARABEL(XPAR,YPAR,APAR,YPPAR,XOPT,AOPT,IFAIL)
+SELF.
+SELF,IF=WBTABPARABEL.
          IF (IFAIL.NE.0) THEN
            WRITE(6,*)'*** WARNING IN WBTAB: IFAIL NOT ZERO'
            WRITE(LUNGFO,*)'*** WARNING IN WBTAB: IFAIL NOT ZERO'
            WRITE(LUNGFO,*)XPAR(1),YPAR(1)
            WRITE(LUNGFO,*)XPAR(2),YPAR(2)
            WRITE(LUNGFO,*)XPAR(3),YPAR(3)
          ENDIF
          D2BYDY=2.D0*APAR(3)
          YPAR(1)=BZL
          YPAR(2)=BZ
          YPAR(3)=BZU
+SELF.
+SELF,IF=VMS,HPUX,TRUE64,IF=WBTABPARABEL.
          CALL UTIL_PARABEL_Q(XPAR,YPAR,APAR,YPPAR,XOPT,AOPT,IFAIL)
+SELF.
+SELF,IF=LINUX,IF=WBTABPARABEL.
          CALL UTIL_PARABEL(XPAR,YPAR,APAR,YPPAR,XOPT,AOPT,IFAIL)
+SELF.
+SELF,IF=WBTABPARABEL.
          IF (IFAIL.NE.0) THEN
            WRITE(6,*)'*** WARNING IN WBTAB: IFAIL NOT ZERO'
            WRITE(LUNGFO,*)'*** WARNING IN WBTAB: IFAIL NOT ZERO'
            WRITE(LUNGFO,*)XPAR(1),YPAR(1)
            WRITE(LUNGFO,*)XPAR(2),YPAR(2)
            WRITE(LUNGFO,*)XPAR(3),YPAR(3)
          ENDIF
          D2BZDY=2.D0*APAR(3)
+SELF,IF=-WBTABPARABEL.
          DBYUDY=(BYU-BY)/BTABEPS
          DBYLDY=(BY-BYL)/BTABEPS
          D2BYDY=(DBYUDY-DBYLDY)/BTABEPS

          DBZUDY=(BZU-BZ)/BTABEPS
          DBZLDY=(BZ-BZL)/BTABEPS
          D2BZDY=(DBZUDY-DBZLDY)/BTABEPS
+SELF.

          IF (I.EQ.1) THEN
            BY1=BY
            BZ1=BZ
            DBY1DZ=DBYDZ
            D2BY1DZ=D2BYDZ
            DBZ1DZ=DBZDZ
            D2BZ1DZ=D2BZDZ
            D2BY1DY=D2BYDY
            D2BZ1DY=D2BZDY
            BI11=0.D0
            BYDZS1=0.D0
            BZDZS1=0.D0
            BYDYS1=0.D0
            BZDYS1=0.D0
          ELSE IF (I.GT.1) THEN
            BI1=BI1+(BY1+BY)/2.D0*DX
            BI2=BI2+(BI11+BI1)/2.D0*DX
            BIQ=BIQ+(DBY1DZ+DBYDZ)/2.D0*DX

            BYDZS=BYDZS+(D2BY1DZ+D2BYDZ)/2.D0*DX
            BZDZS=BZDZS+(D2BZ1DZ+D2BZDZ)/2.D0*DX
            BYDYS=BYDYS+(D2BY1DY+D2BYDY)/2.D0*DX
            BZDYS=BZDYS+(D2BZ1DY+D2BZDY)/2.D0*DX

            BBYDZS=BBYDZS+(BYDZS1+BYDZS)/2.D0*DX
            BBZDZS=BBZDZS+(BZDZS1+BZDZS)/2.D0*DX
            BBYDYS=BBYDYS+(BYDYS1+BYDYS)/2.D0*DX
            BBZDYS=BBZDYS+(BZDYS1+BZDYS)/2.D0*DX

            AYINT=AYINT+(BZ1+BZ)/2.D0*DX
            AZINT=AZINT-(BY1+BY)/2.D0*DX
            BY1=BY
            BZ1=BZ
            DBY1DZ=DBYDZ
            BI11=BI1
            D2BY1DZ=D2BYDZ
            D2BZ1DZ=D2BZDZ
            D2BY1DY=D2BYDY
            D2BZ1DY=D2BZDY

            BYDZS1=BYDZS
            BZDZS1=BZDZS
            BYDYS1=BYDYS
            BZDYS1=BZDYS
          ENDIF

          IF(DABS(DBYDZ).GT.QMAX) QMAX=DBYDZ
          IF(DABS(D2BYDZ).GT.SMAX) SMAX=D2BYDZ

c+self,IF=WBTABTUP.
          TUP_D(1)=X
          TUP_D(2)=BY
          TUP_D(3)=BTABY
          TUP_D(4)=BTABZ
          TUP_D(5)=BI1
          TUP_D(6)=BI2
          TUP_D(7)=BIQ
          TUP_D(8)=BYDZS
          TUP_D(9)=BZDZS
          TUP_D(10)=BYDYS
          TUP_D(11)=BZDYS
          TUP_D(12)=BBYDZS
          TUP_D(13)=BBZDZS
          TUP_D(14)=BBYDYS
          TUP_D(15)=BBZDYS
          TUP_D(16)=AYINT
          TUP_D(17)=AZINT
          CALL hfm(900,TUP_D)
          TUP_D(1)=X
          TUP_D(2)=BTABY
          TUP_D(3)=BTABZ
          TUP_D(4)=D2BYDY
          TUP_D(5)=D2BYDZ
          TUP_D(6)=D2BZDY
          TUP_D(7)=D2BZDZ
          CALL hfm(901,TUP_D)
c+self,IF=-WBTABTUP.
          WRITE(99,'(7(1PE15.6))')SNGL(X),SNGL(BTABY),SNGL(BTABZ)
     &      ,SNGL(D2BYDY),SNGL(D2BYDZ)
     &      ,SNGL(D2BZDY),SNGL(D2BZDZ)
          WRITE(LUNWBT,'(2(1PE14.6),13(1PE11.3),2(1PE13.5))')
     &      SNGL(X),SNGL(BY)
     &      ,SNGL(BTABY),SNGL(BTABZ)
     &      ,SNGL(BI1),SNGL(BI2)
     &      ,SNGL(BIQ)
     &      ,SNGL(BYDZS)
     &      ,SNGL(BZDZS)
     &      ,SNGL(BYDYS)
     &      ,SNGL(BZDYS)
     &      ,SNGL(BBYDZS)
     &      ,SNGL(BBZDZS)
     &      ,SNGL(BBYDYS)
     &      ,SNGL(BBZDYS)
     &      ,SNGL(AYINT),SNGL(AZINT)
c+self.

          X=X+DX

        ENDDO !I

      ELSE  ! IWBTAB=100 I.E. ALONG TRAJECTORY

        DT=(XSTOP-XSTART)/NPWBTAB/CLIGHT1
c+self,if=-wbtabntup
        WRITE(LUNWBT,*) NPWBTAB
        WRITE(99,*) NPWBTAB
c+self.
        BI1=0.0
        BI2=0.0
        BIQ=0.0
        BYDZS=0.0
        BZDZS=0.0
        BYDYS=0.0
        BZDYS=0.0
        BBYDZS=0.0
        BBZDZS=0.0
        BBYDYS=0.0
        BBZDYS=0.0
        QMAX=0.0
        SMAX=0.0
        AZINT=0.D0
        AYINT=0.D0

        DT2=DT/2.D0

        X1(2)=WTRA(1,1,1)
        Y1(2)=WTRA(2,1,1)
        Z1(2)=WTRA(3,1,1)

        VX1(2)=WTRA(1,2,1)
        VY1(2)=WTRA(2,2,1)
        VZ1(2)=WTRA(3,2,1)

        V=DSQRT(VX1(2)*VX1(2)+VY1(2)*VY1(2)+VZ1(2)*VZ1(2))
        VXN=VX1(2)/V
        VYN=VY1(2)/V
        VZN=VZ1(2)/V

        VXZNNN=DSQRT(VXN*VXN+VZN*VZN)

        X1(1)=X1(2)+BTABEPS*VZN/VXZNNN
        Y1(1)=Y1(2)
        Z1(1)=Z1(2)-BTABEPS*VXN/VXZNNN

        X1(3)=X1(2)-BTABEPS*VZN/VXZNNN
        Y1(3)=Y1(2)
        Z1(3)=Z1(2)+BTABEPS*VXN/VXZNNN

        VXZNNN=DSQRT(VXN*VXN+VYN*VYN)

        X1(5)=X1(2)-BTABEPS*VYN/VXZNNN
        Y1(5)=Y1(2)+BTABEPS*VXN/VXZNNN
        Z1(5)=Z1(2)

        X1(4)=X1(2)+BTABEPS*VYN/VXZNNN
        Y1(4)=Y1(2)-BTABEPS*VXN/VXZNNN
        Z1(4)=Z1(2)

        VX1(1)=VX1(2)
        VY1(1)=VY1(2)
        VZ1(1)=VZ1(2)
        VX1(3)=VX1(2)
        VY1(3)=VY1(2)
        VZ1(3)=VZ1(2)
        VX1(4)=VX1(2)
        VY1(4)=VY1(2)
        VZ1(4)=VZ1(2)
        VX1(5)=VX1(2)
        VY1(5)=VY1(2)
        VZ1(5)=VZ1(2)

        DO IT=1,5

          X2(IT)=X1(IT)
          Y2(IT)=Y1(IT)
          Z2(IT)=Z1(IT)

          VX2(IT)=VX1(IT)
          VY2(IT)=VY1(IT)
          VZ2(IT)=VZ1(IT)

        ENDDO  !IT

        DO I=1,NPWBTAB

          DO IT=1,5

            X1(IT)=X2(IT)
            Y1(IT)=Y2(IT)
            Z1(IT)=Z2(IT)

            VX1(IT)=VX2(IT)
            VY1(IT)=VY2(IT)
            VZ1(IT)=VZ2(IT)

            X2B(IT)=X1(IT)+VX1(IT)*DT2
            Y2B(IT)=Y1(IT)+VY1(IT)*DT2
            Z2B(IT)=Z1(IT)+VZ1(IT)*DT2

            CALL MYBFELD(X2B(IT),Y2B(IT),Z2B(IT)
     &        ,BFX(IT),BFY(IT),BFZ(IT),AX2,AY2,AZ2)
            CALL BMOVETAYL(X1(IT),Y1(IT),Z1(IT),VX1(IT),VY1(IT),VZ1(IT)
     &        ,BFX(IT),BFY(IT),BFZ(IT),DT,
     &        X2(IT),Y2(IT),Z2(IT),VX2(IT),VY2(IT),VZ2(IT)
     &        ,VXP(IT),VYP(IT),VZP(IT),DMYGAMMA,ICHARGE,BMOVECUT,IUSTEP,IENELOSS,DGAMMA)

          ENDDO   !IT

          IF(I.EQ.1.OR.I.EQ.NPWBTAB) THEN
            DS=DT*V/2.D0
          ELSE
            DS=DT*V
          ENDIF   !I

          EY(1)=X1(5)-X1(2)
          EY(2)=Y1(5)-Y1(2)
          EY(3)=Z1(5)-Z1(2)
          EYN=DSQRT(EY(1)*EY(1)+EY(2)*EY(2)+EY(3)*EY(3))
          EY(1)=EY(1)/EYN
          EY(2)=EY(2)/EYN
          EY(3)=EY(3)/EYN

          EZ(1)=X1(3)-X1(2)
          EZ(2)=Y1(3)-Y1(2)
          EZ(3)=Z1(3)-Z1(2)
          EZN=DSQRT(EZ(1)*EZ(1)+EZ(2)*EZ(2)+EZ(3)*EZ(3))
          EZ(1)=EZ(1)/EZN
          EZ(2)=EZ(2)/EZN
          EZ(3)=EZ(3)/EZN

+SELF,IF=WBTABPARABEL.

          XPAR(1)=Z1(1)
          XPAR(2)=Z1(2)
          XPAR(3)=Z1(3)
          YPAR(1)=BFX(1)*EY(1)+BFY(1)*EY(2)+BFZ(1)*EY(3)
          YPAR(2)=BFX(2)*EY(1)+BFY(2)*EY(2)+BFZ(2)*EY(3)
          YPAR(3)=BFX(3)*EY(1)+BFY(3)*EY(2)+BFZ(3)*EY(3)
+SELF.
+SELF,IF=VMS,HPUX,TRUE64,IF=WBTABPARABEL.
          CALL UTIL_PARABEL_Q(XPAR,YPAR,APAR,YPPAR,XOPT,AOPT,IFAIL)
+SELF.
+SELF,IF=LINUX,IF=WBTABPARABEL.
          CALL UTIL_PARABEL(XPAR,YPAR,APAR,YPPAR,XOPT,AOPT,IFAIL)
+SELF.
+SELF,IF=WBTABPARABEL.
          IF (IFAIL.NE.0) THEN
            WRITE(6,*)'*** WARNING IN WBTAB: IFAIL NOT ZERO'
            WRITE(LUNGFO,*)'*** WARNING IN WBTAB: IFAIL NOT ZERO'
            WRITE(LUNGFO,*)XPAR(1),YPAR(1)
            WRITE(LUNGFO,*)XPAR(2),YPAR(2)
            WRITE(LUNGFO,*)XPAR(3),YPAR(3)
          ENDIF
          DBYDZ=YPPAR(2)
          D2BYDZ=2.D0*APAR(3)

          XPAR(1)=Y1(4)
          XPAR(2)=Y1(2)
          XPAR(3)=Y1(5)
          YPAR(1)=BFX(4)*EY(1)+BFY(4)*EY(2)+BFZ(4)*EY(3)
          YPAR(2)=BFX(2)*EY(1)+BFY(2)*EY(2)+BFZ(2)*EY(3)
          YPAR(3)=BFX(5)*EY(1)+BFY(5)*EY(2)+BFZ(5)*EY(3)
+SELF.
+SELF,IF=VMS,HPUX,TRUE64,IF=WBTABPARABEL.
          CALL UTIL_PARABEL_Q(XPAR,YPAR,APAR,YPPAR,XOPT,AOPT,IFAIL)
+SELF.
+SELF,IF=LINUX,IF=WBTABPARABEL.
          CALL UTIL_PARABEL(XPAR,YPAR,APAR,YPPAR,XOPT,AOPT,IFAIL)
+SELF.
+SELF,IF=WBTABPARABEL.
          IF (IFAIL.NE.0) THEN
            WRITE(6,*)'*** WARNING IN WBTAB: IFAIL NOT ZERO'
            WRITE(LUNGFO,*)'*** WARNING IN WBTAB: IFAIL NOT ZERO'
            WRITE(LUNGFO,*)XPAR(1),YPAR(1)
            WRITE(LUNGFO,*)XPAR(2),YPAR(2)
            WRITE(LUNGFO,*)XPAR(3),YPAR(3)
          ENDIF
          D2BYDY=2.D0*APAR(3)

          XPAR(1)=Z1(1)
          XPAR(2)=Z1(2)
          XPAR(3)=Z1(3)
          YPAR(1)=BFX(1)*EZ(1)+BFY(1)*EZ(2)+BFZ(1)*EZ(3)
          YPAR(2)=BFX(2)*EZ(1)+BFY(2)*EZ(2)+BFZ(2)*EZ(3)
          YPAR(3)=BFX(3)*EZ(1)+BFY(3)*EZ(2)+BFZ(3)*EZ(3)
+SELF.
+SELF,IF=VMS,HPUX,TRUE64,IF=WBTABPARABEL.
          CALL UTIL_PARABEL_Q(XPAR,YPAR,APAR,YPPAR,XOPT,AOPT,IFAIL)
+SELF.
+SELF,IF=LINUX,IF=WBTABPARABEL.
          CALL UTIL_PARABEL(XPAR,YPAR,APAR,YPPAR,XOPT,AOPT,IFAIL)
+SELF.
+SELF,IF=WBTABPARABEL.
          IF (IFAIL.NE.0) THEN
            WRITE(6,*)'*** WARNING IN WBTAB: IFAIL NOT ZERO'
            WRITE(LUNGFO,*)'*** WARNING IN WBTAB: IFAIL NOT ZERO'
            WRITE(LUNGFO,*)XPAR(1),YPAR(1)
            WRITE(LUNGFO,*)XPAR(2),YPAR(2)
            WRITE(LUNGFO,*)XPAR(3),YPAR(3)
          ENDIF
          DBZDZ=YPPAR(2)
          D2BZDZ=2.D0*APAR(3)

          XPAR(1)=Y1(4)
          XPAR(2)=Y1(2)
          XPAR(3)=Y1(5)
          YPAR(1)=BFX(4)*EZ(1)+BFY(4)*EZ(2)+BFZ(4)*EZ(3)
          YPAR(2)=BFX(2)*EZ(1)+BFY(2)*EZ(2)+BFZ(2)*EZ(3)
          YPAR(3)=BFX(5)*EZ(1)+BFY(5)*EZ(2)+BFZ(5)*EZ(3)
+SELF.
+SELF,IF=VMS,HPUX,TRUE64,IF=WBTABPARABEL.
          CALL UTIL_PARABEL_Q(XPAR,YPAR,APAR,YPPAR,XOPT,AOPT,IFAIL)
+SELF.
+SELF,IF=LINUX,IF=WBTABPARABEL.
          CALL UTIL_PARABEL(XPAR,YPAR,APAR,YPPAR,XOPT,AOPT,IFAIL)
+SELF.
+SELF,IF=WBTABPARABEL.
          IF (IFAIL.NE.0) THEN
            WRITE(6,*)'*** WARNING IN WBTAB: IFAIL NOT ZERO'
            WRITE(LUNGFO,*)'*** WARNING IN WBTAB: IFAIL NOT ZERO'
            WRITE(LUNGFO,*)XPAR(1),YPAR(1)
            WRITE(LUNGFO,*)XPAR(2),YPAR(2)
            WRITE(LUNGFO,*)XPAR(3),YPAR(3)
          ENDIF
          D2BZDY=2.D0*APAR(3)

+SELF.
+SELF,IF=-WBTABPARABEL.

          D32=DSQRT((X1(3)-X1(2))**2+(Y1(3)-Y1(2))**2+(Z1(3)-Z1(2))**2)
          D21=DSQRT((X1(1)-X1(2))**2+(Y1(1)-Y1(2))**2+(Z1(1)-Z1(2))**2)

          BEY=
     &      (BFX(3)-BFX(2))*EY(1)+
     &      (BFY(3)-BFY(2))*EY(2)+
     &      (BFZ(3)-BFZ(2))*EY(3)
          DBYPDZ=BEY/D32

          BEY=
     &      (BFX(2)-BFX(1))*EY(1)+
     &      (BFY(2)-BFY(1))*EY(2)+
     &      (BFZ(2)-BFZ(1))*EY(3)
          DBYMDZ=BEY/D21

          BEZ=
     &      (BFX(3)-BFX(2))*EZ(1)+
     &      (BFY(3)-BFY(2))*EZ(2)+
     &      (BFZ(3)-BFZ(2))*EZ(3)
          DBZPDZ=BEZ/D32

          BEZ=
     &      (BFX(2)-BFX(1))*EZ(1)+
     &      (BFY(2)-BFY(1))*EZ(2)+
     &      (BFZ(2)-BFZ(1))*EZ(3)
          DBZMDZ=BEZ/D21

          DBYDZ=(DBYPDZ+DBYMDZ)/2.
          D2BYDZ=(DBYPDZ-DBYMDZ)/((D32+D21)/2.D0)
          DBZDZ=(DBZPDZ+DBZMDZ)/2.
          D2BZDZ=(DBZPDZ-DBZMDZ)/((D32+D21)/2.D0)

          D52=DSQRT((X1(5)-X1(2))**2+(Y1(5)-Y1(2))**2+(Z1(5)-Z1(2))**2)
          D24=DSQRT((X1(4)-X1(2))**2+(Y1(4)-Y1(2))**2+(Z1(4)-Z1(2))**2)

          BEY=
     &      (BFX(5)-BFX(2))*EY(1)+
     &      (BFY(5)-BFY(2))*EY(2)+
     &      (BFZ(5)-BFZ(2))*EY(3)
          DBYUDY=BEY/D52

          BEY=
     &      (BFX(2)-BFX(4))*EY(1)+
     &      (BFY(2)-BFY(4))*EY(2)+
     &      (BFZ(2)-BFZ(4))*EY(3)
          DBYLDY=BEY/D24

          BEZ=
     &      (BFX(5)-BFX(2))*EZ(1)+
     &      (BFY(5)-BFY(2))*EZ(2)+
     &      (BFZ(5)-BFZ(2))*EZ(3)
          DBZUDY=BEZ/D52

          BEZ=
     &      (BFX(2)-BFX(4))*EZ(1)+
     &      (BFY(2)-BFY(4))*EZ(2)+
     &      (BFZ(2)-BFZ(4))*EZ(3)
          DBZLDY=BEZ/D24

          D2BYDY=(DBYUDY-DBYLDY)/((D52+D24)/2.D0)
          D2BZDY=(DBZUDY-DBZLDY)/((D52+D24)/2.D0)

+SELF.
          IF (I.EQ.1) THEN
            BY1=BFY(2)
            BZ1=BFZ(2)
            DBY1DZ=DBYDZ
            D2BY1DZ=D2BYDZ
            DBZ1DZ=DBZDZ
            D2BZ1DZ=D2BZDZ
            D2BY1DY=D2BYDY
            D2BZ1DY=D2BZDY
            BI11=0.D0
            BYDZS1=0.D0
            BZDZS1=0.D0
            BYDYS1=0.D0
            BZDYS1=0.D0
          ELSE IF (I.GT.1) THEN
            BI1=BI1+(BY1+BFY(2))/2.D0*DS
            BI2=BI2+(BI11+BI1)/2.D0*DS
            BIQ=BIQ+(DBY1DZ+DBYDZ)/2.D0*DS

            BYDZS=BYDZS+(D2BY1DZ+D2BYDZ)/2.D0*DS
            BZDZS=BZDZS+(D2BZ1DZ+D2BZDZ)/2.D0*DS
            BYDYS=BYDYS+(D2BY1DY+D2BYDY)/2.D0*DS
            BZDYS=BZDYS+(D2BZ1DY+D2BZDY)/2.D0*DS

            BBYDZS=BBYDZS+(BYDZS1+BYDZS)/2.D0*DS
            BBZDZS=BBZDZS+(BZDZS1+BZDZS)/2.D0*DS
            BBYDYS=BBYDYS+(BYDYS1+BYDYS)/2.D0*DS
            BBZDYS=BBZDYS+(BZDYS1+BZDYS)/2.D0*DS

            AYINT=AYINT+(BZ1+BFZ(2))/2.D0*DS
            AZINT=AZINT-(BY1+BFY(2))/2.D0*DS

            BY1=BFY(2)
            BZ1=BFZ(2)
            DBY1DZ=DBYDZ
            BI11=BI1
            D2BY1DZ=D2BYDZ
            D2BZ1DZ=D2BZDZ
            D2BY1DY=D2BYDY
            D2BZ1DY=D2BZDY

            BYDZS1=BYDZS
            BZDZS1=BZDZS
            BYDYS1=BYDYS
            BZDYS1=BZDYS
          ENDIF

          IF(DABS(DBYDZ).GT.QMAX) QMAX=DBYDZ
          IF(DABS(D2BYDZ).GT.SMAX) SMAX=D2BYDZ

c+self,IF=WBTABTUP.
          TUP_D(1)=X1(2)
          TUP_D(2)=BFY(2)
          TUP_D(3)=Y1(2)
          TUP_D(4)=Z1(2)
          TUP_D(5)=BI1
          TUP_D(6)=BI2
          TUP_D(7)=BIQ
          TUP_D(8)=BYDZS
          TUP_D(9)=BZDZS
          TUP_D(10)=BYDYS
          TUP_D(11)=BZDYS
          TUP_D(12)=BBYDZS
          TUP_D(13)=BBZDZS
          TUP_D(14)=BBYDYS
          TUP_D(15)=BBZDYS
          TUP_D(16)=AYINT
          TUP_D(17)=AZINT
          CALL hfm(900,TUP_D)
          TUP_D(1)=X1(2)
          TUP_D(2)=Y1(2)
          TUP_D(3)=Z1(2)
          TUP_D(4)=D2BYDY
          TUP_D(5)=D2BYDZ
          TUP_D(6)=D2BZDY
          TUP_D(7)=D2BZDZ
          CALL hfm(901,TUP_D)
c+self,IF=-WBTABTUP.
          WRITE(99,'(7(1PE15.6))')SNGL(X1(2)),SNGL(Y1(2)),SNGL(Z1(2))
     &      ,SNGL(D2BYDY),SNGL(D2BYDZ)
     &      ,SNGL(D2BZDY),SNGL(D2BZDZ)
          WRITE(LUNWBT,'(2(1PE14.6),13(1PE11.3),2(1PE13.5))')
     &      SNGL(X1(2)),SNGL(BFY(2))
     &      ,SNGL(Y1(2)),SNGL(Z1(2))
     &      ,SNGL(BI1),SNGL(BI2)
     &      ,SNGL(BIQ)
     &      ,SNGL(BYDZS)
     &      ,SNGL(BZDZS)
     &      ,SNGL(BYDYS)
     &      ,SNGL(BZDYS)
     &      ,SNGL(BBYDZS)
     &      ,SNGL(BBZDZS)
     &      ,SNGL(BBYDYS)
     &      ,SNGL(BBZDYS)
     &      ,SNGL(AYINT),SNGL(AZINT)

c+self.
        ENDDO  !NPWBTAB

      ENDIF   !IWBTAB

      CLOSE(LUNWBT)
      CLOSE(99)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SR WBTAB: '
      WRITE(LUNGFO,*)
      IF (KHALBASY.NE.0.AND.IAHWFOUR.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN WBTAB:'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'FOR ASYMETIC HALBACH-MODEL SEXTUPOL-TERMS ARE WRONG'
        WRITE(LUNGFO,*)'SINCE IAHWFOUR=0'
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN WBTAB:'
        WRITE(6,*)
        WRITE(6,*)'FOR ASYMETIC HALBACH-MODEL SEXTUPOL-TERMS ARE WRONG'
        WRITE(6,*)'SINCE IAHWFOUR=0'
      ENDIF
      IF (IRFILF.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN WBTAB:'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    'FOR FOURIER-EXPANDED FIELDS SEXTUPOLE-TERMS ARE WRONG'
        WRITE(LUNGFO,*)'SINCE 3D-EFFECTS ARE NOT TAKEN INTO ACCOUNT, I.E.'
        WRITE(LUNGFO,*)'Kx=CONST.'
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN WBTAB:'
        WRITE(6,*)
        WRITE(6,*)
     &    'FOR FOURIER-EXPANDED FIELDS SEXTUPOLE-TERMS ARE WRONG'
        WRITE(6,*)'SINCE 3D-EFFECTS ARE NOT TAKEN INTO ACCOUNT, I.E.'
        WRITE(6,*)'Kx=CONST.'
      ENDIF
      WRITE(LUNGFO,*)
c+self,IF=-WBTABTUP.
      WRITE(LUNGFO,*)'     written to file:'
      WRITE(LUNGFO,*)'     ',FILEWBT
      WRITE(LUNGFO,*)
     &  '     For exact format please refer to wave.in, namelist WBTABN'
c+self,IF=WBTABTUP.
      WRITE(LUNGFO,*)'     written to NTUPLE'
      CALL MHROUT(900,ICYCLE,' ')
      CALL hdeletm(900)
      CALL MHROUT(901,ICYCLE,' ')
      CALL hdeletm(901)
c+self.
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     x-intervall:',SNGL(BTABS),SNGL(BTABE)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     first field integral (T m):                ',
     &  SNGL(BI1)
      WRITE(LUNGFO,*)'     second field integral (T m**2):            ',
     &  SNGL(BI2)
      WRITE(LUNGFO,*)'     quadrupole like integral (T):              ',
     &  SNGL(BIQ)
      WRITE(LUNGFO,*)'     maximum gradient (T/m):                    ',
     &  SNGL(QMAX)
      WRITE(LUNGFO,*)'     sextupole like integral d2By/dz**2 (T/m):  ',
     &  SNGL(BYDZS)
      WRITE(LUNGFO,*)'     sextupole like integral d2By/dy**2 (T/m):  ',
     &  SNGL(BYDYS)
      WRITE(LUNGFO,*)'     maximum gradient (T/m**2):                 ',
     &  SNGL(SMAX)

      IF(IWBTAB.EQ.100) THEN
        WRITE(LUNGFO,*)'     (along trajectory)'
      ELSE
        WRITE(LUNGFO,*)
     &    '     (along straight line, z =',
     &    SNGL(BTABZ),' y =',SNGL(BTABY),')'
      ENDIF !IWBTAB
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)

      RETURN
      END
+DECK,WBTRACK.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.63/05 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.61/02 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  10.48.09  by  Michael Scheer
*CMZ :  2.47/12 24/06/2003  15.45.35  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  11.29.39  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  2.12/00 02/06/99  13.56.19  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  11.14.52  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.14  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE WBTRACK(X1,Y1,Z1,VX1,VY1,VZ1,
     &  XF0,YF0,ZF0,VXF0,VYF0,VZF0,
     &  X2,Y2,Z2,VX2,VY2,VZ2,DTIM0,GAMMA,IERROR)
+seq,gplhint.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,PHYCON.
+SEQ,B0SCGLOB.

      INTEGER IZAEHL,IERROR

      DOUBLE PRECISION X1,Y1,Z1,VX1,VY1,VZ1,
     &  XF0,YF0,ZF0,VXF0,VYF0,VZF0,
     &  X2,Y2,Z2,VX2,VY2,VZ2,DTIM0,GAMMA,DSMAX
      DOUBLE PRECISION EWSFX,EWSFY,EWSFZ,V0,VXPINT,VYPINT,VZPINT
      DOUBLE PRECISION BX2,BY2,BZ2,X2B,Y2B,Z2B
      DOUBLE PRECISION AX2,AY2,AZ2,VXP,VYP,VZP
      DOUBLE PRECISION DIST2,DIST1,DT,DDT
     &  ,DGAMMA

      IERROR=0
      V0=DSQRT(VX1**2+VY1**2+VZ1**2)
      EWSFX=VXF0/V0
      EWSFY=VYF0/V0
      EWSFZ=VZF0/V0

C030293  DSMAX=DTIM0*CLIGHT1*1.D-8
      DSMAX=DMAX1(DTIM0*CLIGHT1*1.D-8,1.D-10)

      DT=DTIM0/2.D0

      X2=X1
      Y2=Y1
      Z2=Z1

      VX2=VX1
      VY2=VY1
      VZ2=VZ1

         IZAEHL=0

1000     IZAEHL=IZAEHL+1

         X1=X2
         Y1=Y2
         Z1=Z2

         VX1=VX2
         VY1=VY2
         VZ1=VZ2

         X2B=X1+VX1*DT
         Y2B=Y1+VY1*DT
         Z2B=Z1+VZ1*DT

         CALL MYBFELD(X2B,Y2B,Z2B,BX2,BY2,BZ2,AX2,AY2,AZ2)

         CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DTIM0,
     &            X2,Y2,Z2,VX2,VY2,VZ2,VXP,VYP,VZP,GAMMA,ICHARGE,BMOVECUT,IUSTEP,IENELOSS,DGAMMA)

C EWSF IS NORMAL VECTOR OF PERPENDICULARE PLANE AT THE END OF THE REFERENCE ORBI
C DIST IS DISTANCE OF ELECTRON TO THIS PLANE
C TRACKING STOPS IF TRAJECTORIE HITS THIS PLANE

         DIST2=(X2-XF0)*EWSFX+(Y2-YF0)*EWSFY+(Z2-ZF0)*EWSFZ

      IF ( DIST2 .LT. 0.0  )  GOTO 1000


C--- ENDE OF TRAJECTORY, DIST2 NOT EXACTLY ZERO, CORRECT X2

      DIST1=(X1-XF0)*EWSFX+(Y1-YF0)*EWSFY+(Z1-ZF0)*EWSFZ
      DDT=DTIM0*DABS(DIST1)/(DABS(DIST1)+DABS(DIST2))

      CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DDT,
     &  X2,Y2,Z2,VX2,VY2,VZ2,
     &  VXPINT,VYPINT,VZPINT,GAMMA,ICHARGE,BMOVECUT,IUSTEP,IENELOSS,DGAMMA)

      DIST2=(X2-XF0)*EWSFX+(Y2-YF0)*EWSFY+(Z2-ZF0)*EWSFZ

C030293  IF (DIST2.GT.DSMAX) THEN
      IF (DABS(DIST2).GT.DSMAX) THEN
          IERROR=1
      ENDIF

      END
+DECK,WDISPER.
*CMZ :  3.02/00 26/08/2014  08.51.38  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.09.17  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.68/05 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.66/13 07/07/2010  11.06.21  by  Michael Scheer
*CMZ :  2.16/08 25/06/2010  12.15.46  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.33  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.24.36  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  14.43.03  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  11.15.35  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.56.21  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.09  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE WDISPER
+seq,gplhint.

+SEQ,TRACKF90U,IF=F90.
+SEQ,WBETAF90U,IF=F90.

C--- CALCULATES LINEARE DISPERSION
C    THE INTERNAL DISPERSION OF THE WLS IS CALCULATE FROM THE TRACKING OF
C    CHROMATIC TRAJECTORIES. THE EXTERNAL DISPERSION IS CALCULATED FROM
C    THE START VALUES AND THE LINEAR TRANSFER MATRIX


      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,DEPOLA.
+seq,wbetaf90.
+SEQ,TRACK.
+SEQ,PHYCON.

+SELF,IF=-F90.
      DOUBLE PRECISION WDIS(2,NWMAXP)
+SELF.

      INTEGER IE,ICOUNT,IEE,IP,IPP,IERROR,IERRFLG,iwarn

      DOUBLE PRECISION X1,Y1,Z1,X2,Y2,Z2
      DOUBLE PRECISION XF0,YF0,ZF0,VXF0,VYF0,VZF0
      DOUBLE PRECISION VX1,VY1,VZ1,VX2,VY2,VZ2

      DOUBLE PRECISION GAMMA,DS02

      DATA IERRFLG/0/

+SELF,IF=F90.
      ALLOCATE(WDIS(2,NCO))
+SELF.

      DS02=2.D0*DS0

C---LOOP OVER CHROMATIC CLOSED ORBITS

      IEE=0

      DO IE=-1,1,2

      IEE=IEE+1
      GAMMA=DMYGAMMA+DFLOAT(IE)*DELGAM*DMYGAMMA

C--- START OF TRAJECTORY

      X1=WSXYZ(1,1)
      Y1=WSXYZ(2,1)
      Z1=WSXYZ(3,1)

      VX1=WVXYZ(1,1)
      VY1=WVXYZ(2,1)
      VZ1=WVXYZ(3,1)

      WDIS(IEE,1)=0.0

C--- LOOP OVER POINTS

      IPP=0

      DO ICOUNT=1,NCO-1

        IPP=ICOUNT+1

        IF (abs(Y1).gt.1.0d-10.and.iwarn.eq.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*) '*** WARNING IN WDISPER ***'
          WRITE(LUNGFO,*) 'ORBIT NOT PLANAR'
          WRITE(LUNGFO,*)
          WRITE(6,*) '*** WARNING IN WDISPER ***'
          iwarn=1
C            STOP
        ENDIF

        XF0=WSXYZ(1,IPP)
        YF0=WSXYZ(2,IPP)
        ZF0=WSXYZ(3,IPP)

        VXF0=WVXYZ(1,IPP)
        VYF0=WVXYZ(2,IPP)
        VZF0=WVXYZ(3,IPP)

C- ROTATE ELECTRON TO NEXT POINT SUCH THAT ALL CORRESPONDING POINTS
C I.E. WITH THE SAME ICOUNT LAY IN ONE PLANE

        CALL WBTRACK(X1,Y1,Z1,VX1,VY1,VZ1,
     &    XF0,YF0,ZF0,VXF0,VYF0,VZF0,
     &    X2,Y2,Z2,VX2,VY2,VZ2,
     &    DTIM0,GAMMA,IERROR)

        IF (IERROR.NE.0) IERRFLG=1

        WDIS(IEE,IPP)=DSIGN
     &    (
     &    DSQRT
     &    (
     &    (X2-XF0)**2+(Z2-ZF0)**2+(Y2-YF0)**2
     &    )
     &    , (Z2-ZF0)*VXF0-(X2-XF0)*VZF0    !Y-COMPONENT OFF VECTOR-PRODUCT
     &    )
     &    /(DFLOAT(IE)*DELGAM)


        X1=X2
        Y1=Y2
        Z1=Z2

        VX1=VX2
        VY1=VY2
        VZ1=VZ2

      ENDDO !ICOUNT

      ENDDO !IE

C--- CALCULATE INTERNAL DISPERSION

      DO IP=1,NCO
        WBETA(6,IP)=(WDIS(1,IP)+WDIS(2,IP))/2.D0
      ENDDO

C--- CALCULATE DERIVATIVE OF INTERNAL DISPERSION

      DO IP=2,NCO-1
        WBETA(7,IP)=(WBETA(6,IP+1)-WBETA(6,IP-1))/DS02
      ENDDO

      WBETA(7,1)=WBETA(7,2)-(WBETA(7,3)-WBETA(7,2))
      WBETA(7,NCO)=WBETA(7,NCO-1)+(WBETA(7,NCO-1)-WBETA(7,NCO-2))


C--- TOTAL DISPERSION, I.E. TRANSFORMED EXTERNAL PLUS INTERNAL

      DO IP=1,NCO

        WBETA(6,IP)=WLTM(1,1,IP)*DISP0+WLTM(1,2,IP)*DDISP0+WBETA(6,IP)
        WBETA(7,IP)=WLTM(1,3,IP)*DISP0+WLTM(1,4,IP)*DDISP0+WBETA(7,IP)

      ENDDO !NCO

      IF (IERRFLG.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*) '*** WARNING SR WDISPER ***'
        WRITE(LUNGFO,*) 'PROBLEMS WITH SR WBTRACK'
        WRITE(LUNGFO,*) 'CHANGE STEP SIZE, WATCH RESULTS'
        WRITE(LUNGFO,*)
      ENDIF

+SELF,IF=F90.
      DEALLOCATE(WDIS)
+SELF.

      RETURN
      END
+DECK,WFILINT.
*CMZ :  3.05/01 04/05/2018  19.58.00  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.10.30  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.50/00 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.20/01 29/11/2000  18.31.06  by  Michael Scheer
*CMZ :  2.16/08 01/11/2000  18.41.44  by  Michael Scheer
*CMZ :  2.15/00 04/05/2000  17.02.01  by  Michael Scheer
*CMZ :  2.12/00 27/05/99  10.26.26  by  Michael Scheer
*CMZ :  2.10/01 24/02/99  10.20.40  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  11.17.32  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.56.26  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.48  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE WFILINT
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,REARGF90U.
+SELF.

C--- DUMP INTEGRAND

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,REARG,IF=-F90
+SEQ,PHYCON.
+seq,sourcef90.
+SEQ,SPECT.
+SEQ,FREQS.

      INTEGER IPOI,IC,ICAL


+SELF,IF=-NOCMPLX.
      COMPLEX*16 AX,AY,AZ,EXPOM
+SELF,IF=NOCMPLX.
      DOUBLE PRECISION AXR,AYR,AZR,EXPOMR,AXI,AYI,AZI,EXPOMI
+SELF.
      DOUBLE PRECISION OM

      DATA ICAL/0/

      OM=FREQ(1)/HBAREV1

C-- LOOP OVER TIME STEPS (ACTUAL INTEGRATION)

      IF (ICAL.EQ.0) THEN  !CV2
C         OPEN(UNIT=LUNINT,FILE=FILEINT,STATUS='NEW')
        ICAL=1
      ENDIF !ICAL     CV2

      DO IPOI=1,IARGUM

        IF (WSOU(1,1,IPOI).GE.XIANF.AND.WSOU(1,1,IPOI).LE.XIEND) THEN

+SELF,IF=-NOCMPLX.
          EXPOM=CDEXP(DCMPLX(0.D0,REARGUM(4,IPOI)*OM))

          AX=DCMPLX(REARGUM(1,IPOI))*EXPOM
          AY=DCMPLX(REARGUM(2,IPOI))*EXPOM
          AZ=DCMPLX(REARGUM(3,IPOI))*EXPOM

          WRITE(LUNINT,*) WSOU(1,1,IPOI)
     &      ,(SNGL(REARGUM(IC,IPOI)),IC=1,3)
     &      ,SNGL(REARGUM(4,IPOI)*OM),SNGL(REARGUM(5,IPOI))
     &      ,SNGL(DREAL(EXPOM)),SNGL(DIMAG(EXPOM))
     &      ,SNGL(DREAL(AX)),SNGL(DIMAG(AX))
     &      ,SNGL(DREAL(AY)),SNGL(DIMAG(AY))
     &      ,SNGL(DREAL(AZ)),SNGL(DIMAG(AZ))

+SELF,IF=NOCMPLX.
          WRITE(6,*)'CHECK +SELF,NOCMPLX'
          EXPOMR=COS(REARGUM(4,IPOI)*OM)
          EXPOMI=SIN(REARGUM(4,IPOI)*OM)

          AXR=REARGUM(1,IPOI)*EXPOMR
          AXI=REARGUM(1,IPOI)*EXPOMI
          AYR=REARGUM(2,IPOI)*EXPOMR
          AYI=REARGUM(2,IPOI)*EXPOMI
          AZR=REARGUM(3,IPOI)*EXPOMR
          AZI=REARGUM(3,IPOI)*EXPOMI

          WRITE(LUNINT,*) WSOU(1,1,IPOI)
     &      ,(SNGL(REARGUM(IC,IPOI)),IC=1,3)
     &      ,SNGL(REARGUM(4,IPOI)*OM),SNGL(REARGUM(5,IPOI))
     &      ,SNGL(EXPOMR),SNGL(EXPOMI)
     &      ,SNGL(AXR),SNGL(AXI)
     &      ,SNGL(AYR),SNGL(AYI)
     &      ,SNGL(AZR),SNGL(AZI)

+SELF.
        ENDIF   !XIANF

      ENDDO   !LOOP OVER TIME STEPS

C      IF (NSADD.NE.0) CLOSE(LUNINT)

CV2   CLOSE(LUNINT)

      RETURN
      END
+DECK,WFOLD.
*CMZ :  3.07/00 15/03/2019  12.50.12  by  Michael Scheer
*CMZ :  3.03/02 21/03/2016  16.06.27  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.66/03 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.51/02 08/10/2009  09.58.11  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  14.22.46  by  Michael Scheer
*CMZ :  2.13/10 14/04/2000  14.26.49  by  Michael Scheer
*CMZ :  2.13/04 21/01/2000  14.54.46  by  Michael Scheer
*CMZ :  2.13/03 11/01/2000  18.22.28  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.56.38  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.16  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE WFOLD
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.

C--- CALCULATES FOLDING OF PINHOLE INTENSITIY WITH ELECTRON PHASE SPACE
C    DISTRIBUTIONS (GAUSSIAN DISTRIBUTION)

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEq,observf90.
+SEQ,FREQS.
+seq,sourcef90.
+SEQ,SPECT.

      INTEGER ISOUR,IFREQ,IZ,IY,IOBSV

C--- CALCULATE FOURIER-COEFFICIENTS OF GAUSSIAN

      CALL WGFOUR

      DO IFREQ=1,NFREQ

        DO IY=1,NOBSVY
          DO IZ=1,NOBSVZ
            IOBSV=(IY-1)*NOBSVZ+IZ
            SPECTOTF(IOBSV+NOBSV*(IFREQ-1))=0.0d0
          ENDDO   !IZ
        ENDDO   !IY

        WFLUXTF(IFREQ)=0.0

        DO ISOUR=1,NSOURCE

C--- CALCULATE 2D POLYNOMIALS OF INTENSITY DISTRIBUTION

          IF (IFOLD.EQ.-2) CALL WPOLY2(ISOUR,IFREQ)

C--- PERFORM FOLDING

          CALL WFOLINT(ISOUR,IFREQ)

C--- CALCULATE INTEGRATED INTENSITY

          IF (ISPECANAF.NE.0) THEN

            CALL SPECANAF

          ENDIF !ISPECANAF

          IF (IPINCIRC.EQ.0.OR.IPINCIRC*IRPHI.NE.0)
     &      CALL PSPLINEF(ISOUR,IFREQ)
          CALL BLENDEF(ISOUR,IFREQ)

          DO IY=1,NOBSVY
            DO IZ=1,NOBSVZ
              IOBSV=(IY-1)*NOBSVZ+IZ
              IOBFR=IOBSV+NOBSV*(IFREQ-1)
              SPECTOTF(IOBFR)=SPECTOTF(IOBFR)+
     &          SPECF(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))
            ENDDO   !IZ
          ENDDO   !IY

          WFLUXTF(IFREQ)=WFLUXTF(IFREQ)+WFLUXF(ISOUR+NSOURCE*(IFREQ-1))

C--- DELETE INTENSITY IN EDGES

          DO IY=1,NOBSVY
            DO IZ=1,NOBSVZ

              IF (IPINCIRC.EQ.0) THEN

                IF (
     &              IY.LT.(NOBSVY-MOBSVY)/2+1
     &              .OR.IY.GT.(NOBSVY-MOBSVY)/2+MOBSVY
     &              .OR.IZ.LT.(NOBSVZ-MOBSVZ)/2+1
     &              .OR.IZ.GT.(NOBSVZ-MOBSVZ)/2+MOBSVZ
     &              ) THEN
                  SPECF(ISOUR+NSOURCE*(((IY-1)*NOBSVZ+IZ)-1+NOBSV*(IFREQ-1)))=0.0d0
                ENDIF

              ELSE  !IPINCIRC

                IF (
     &              (OBSVZ(IZ)-PINCEN(3))**2
     &              +(OBSVY(IY)-PINCEN(2))**2
     &              -PINR**2
     &              .GT.1.D-10
     &              ) THEN
                  SPECF(ISOUR+NSOURCE*(((IY-1)*NOBSVZ+IZ)-1+NOBSV*(IFREQ-1)))=0.0d0
                ENDIF

              ENDIF !IPINCIRC

            ENDDO !IZ
          ENDDO !IY

        ENDDO !ISOUR
      ENDDO !IFREQ

      DO IFREQ=1,NFREQ

        DO IY=1,NOBSVY
          DO IZ=1,NOBSVZ

            IF (IPINCIRC.EQ.0) THEN

              IF (
     &            IY.LT.(NOBSVY-MOBSVY)/2+1
     &            .OR.IY.GT.(NOBSVY-MOBSVY)/2+MOBSVY
     &            .OR.IZ.LT.(NOBSVZ-MOBSVZ)/2+1
     &            .OR.IZ.GT.(NOBSVZ-MOBSVZ)/2+MOBSVZ
     &            ) THEN

                SPECTOTF((IY-1)*NOBSVZ+IZ+NOBSV*(IFREQ-1))=0.0d0

              ENDIF

            ELSE  !IPINCIRC

              IF (
     &            (OBSVZ(IZ)-PINCEN(3))**2
     &            +(OBSVY(IY)-PINCEN(2))**2
     &            -PINR**2
     &            .GT.1.D-10
     &            ) THEN

                SPECTOTF((IY-1)*NOBSVZ+IZ+NOBSV*(IFREQ-1))=0.0d0

              ENDIF

            ENDIF !IPINCIRC

          ENDDO !IZ
        ENDDO !IY
      ENDDO !IFREQ

      RETURN
      END
+DECK,WFOLDSTO.
*CMZ :  3.07/00 15/03/2019  13.09.52  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.51/02 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.17/00 03/11/2000  14.00.48  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  16.27.20  by  Michael Scheer
*CMZ :  2.13/03 12/01/2000  16.31.33  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  11.20.25  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.56.43  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.09  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE WFOLDSTO
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,WFOLDF90U.

C--- CALCULATES FOLDING OF STOKES INTENSITIY WITH ELECTRON PHASE SPACE
C    DISTRIBUTIONS (GAUSSIAN DISTRIBUTION)

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEq,observf90.
+SEQ,FREQS.
+seq,sourcef90.
+SEQ,SPECT.

      INTEGER ISTOK,KFREQ,IZ,IY

C--- CALCULATE FOURIER-COEFFICIENTS OF GAUSSIAN

C     CALL WGFOUR !ALREADY DONE, USE VALUES OF ISIGSTO

      DO kfreq=1,NFREQ

        DO ISTOK=1,4

C--- CALCULATE 2D POLYNOMIALS OF INTENSITY DISTRIBUTION


          IF (ISPECANAF.EQ.0.AND.IFOLD.EQ.-2) CALL WPOLY2ST(ISTOK,kfreq)

C--- PERFORM FOLDING

          CALL WFOLISTO(ISTOK,kfreq) !MUST ALSO BE CALLED FOR ISPECANAF

C--- CALCULATE INTEGRATED INTENSITY

          IF(ISPECANAF.NE.0) CALL SPECANAF    !MUST BE CALLED EACH TIME

          IF (IPINCIRC.EQ.0.OR.IPINCIRC*IRPHI.NE.0)
     &      CALL PSPLSTOF(ISTOK,kfreq)

          CALL BLENSTOF(ISTOK,kfreq)

        ENDDO !ISTOK

        DO ISTOK=1,4

C--- DELETE INTENSITY IN EDGES

          IF (IPINCIRC.EQ.0) THEN

            DO IY=1,NOBSVY
              DO IZ=1,NOBSVZ

                IF (
     &              IY.LT.(NOBSVY-MOBSVY)/2+1
     &              .OR.IY.GT.(NOBSVY-MOBSVY)/2+MOBSVY
     &              .OR.IZ.LT.(NOBSVZ-MOBSVZ)/2+1
     &              .OR.IZ.GT.(NOBSVZ-MOBSVZ)/2+MOBSVZ
     &              ) THEN

                  STOKESF(ISTOK,(IY-1)*NOBSVZ+IZ+NOBSV*(kfreq-1))=0.0

                ENDIF

              ENDDO !IZ
            ENDDO !IY

          ELSE  !IPINCIRC          !CIRCULARE PINHOLE


            DO IY=1,NOBSVY
              DO IZ=1,NOBSVZ

                IF (
     &              (OBSVZ(IZ)-PINCEN(3))**2
     &              +(OBSVY(IY)-PINCEN(2))**2
     &              -PINR**2
     &              .GT.1.D-10
     &              ) THEN

                  STOKESF(ISTOK,(IY-1)*NOBSVZ+IZ+NOBSV*(kfreq-1))=0.0

                ENDIF

              ENDDO !IZ
            ENDDO !IY

          ENDIF !IPINCIRC
        ENDDO !ISTOK

      ENDDO !kfreq

      RETURN
      END
+DECK,WFOLINT.
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.51/02 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.34/09 24/09/2001  16.48.01  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  16.27.20  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.33  by  Michael Scheer
*CMZ :  2.15/00 08/05/2000  13.33.58  by  Michael Scheer
*CMZ :  2.14/02 27/04/2000  17.54.22  by  Michael Scheer
*CMZ :  2.13/10 14/04/2000  17.10.49  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.24.36  by  Michael Scheer
*CMZ :  2.13/03 20/12/99  17.39.24  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  14.43.03  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  11.21.35  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  18.07.26  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.22  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE WFOLINT(ISOUR,IFREQ)
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,WFOLDF90U.

C--- FOLD SPECTRAL DENSITY IN PINHOLE

C    IFOLD.EQ.-2:
C    THE INTENSITY IS GIVEN ANALYTICALLY BY THE COEFFICINETS COFOLD
C    THE KERNEL IS GIVEN BY THE COEFFICIENTS GCOEFH, GCOEFV OF THE FOURIER
C    EXPANSION
C    IFOLD.EQ.-1: SR UTIL_FOLD_FOURIER IS USED
C    IFOLD.EQ.1: SR UTIL_FOLD_FUNCTION_GAUSS IS USED

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEq,wfoldf90.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.

      INTEGER IZA,IZE,IYA,IYE,IFREQ,ISOUR,IY,IZ,IMASH,INZ
     &       ,INY,ISY,ISZ,I,J,M,KNZ,KNY,K,MARG
     &       ,ISMASH,IMASHZ,IMASHY,II,NF,NFOLD,IFAIL,IGZY


      DOUBLE PRECISION SUM,ARG,ZKZ0,ZKDZ,YKY0,YKDY,XKM1,DZ,DY,PI,YLY0

      DOUBLE PRECISION GSNZ(NGCOEFP,NDMASHZP),GCSZ(NGCOEFP,NDMASHZP)
      DOUBLE PRECISION GZ(NGCOEFP*LIDIMP),GY(NGCOEFP*LIDIMP)
      DOUBLE PRECISION GSNY(NGCOEFP,NDMASHYP),GCSY(NGCOEFP,NDMASHYP)
      DOUBLE PRECISION ZINTK(NGCOEFP,4,NDMASHZP),ZINTKS(NGCOEFP,NDMASHZP)
      DOUBLE PRECISION YINTK(NGCOEFP,4,NDMASHYP),YINTKS(NGCOEFP,NDMASHYP)

      DOUBLE PRECISION DCPZ,DCZ,DZXKM1,DZXKM12,GCPZ,GCZ,GSZ,GSPZ
      DOUBLE PRECISION DCPY,DCY,DYXKM1,DYXKM12,GCPY,GCY,GSY,GSPY

      EQUIVALENCE (GZ,GCOEFH),(GY,GCOEFV)

      DATA PI/3.141592653589793D0/


      IF (IFOLD.EQ.1) THEN

        IYA=1+(NOBSVY-MOBSVY)/2
        IYE=NOBSVY-(NOBSVY-MOBSVY)/2

        IF (NOBSVZ.GT.1) THEN

          IZA=1+(NOBSVZ-MOBSVZ)/2
          IZE=NOBSVZ-(NOBSVZ-MOBSVZ)/2

          NF=NOBSV*(IFREQ-1)

          DO IY=1,NOBSVY

            DO IZ=1,NOBSVZ
              IMASH=IZ+(IY-1)*NOBSVZ
              WOBS1(IZ)=SPEC(ISOUR+NSOURCE*(IMASH-1+NF))
            ENDDO !IZ

            CALL UTIL_FOLD_FUNCTION_GAUSS(
     &        NOBSVZ,OBSVZ,WOBS1,WSIGZ(ISOUR),DGSIGZ(ISOUR),WOBS2,
     &        WOBS3,WOBS4,WOBS5,WOBS6,WOBS7)

            DO IZ=IZA,IZE
              IMASH=IZ+(IY-1)*NOBSVZ
              SPECF(ISOUR+NSOURCE*(IMASH-1+NF))=WOBS2(IZ)
            ENDDO

          ENDDO   !IY

        ELSE !(NOBSVZ.GT.1)

          NF=NOBSV*(IFREQ-1)

          DO IY=1,NOBSVY
            SPECF(ISOUR+NSOURCE*((IY-1)*NOBSVZ+NF))=
     &        SPEC(ISOUR+NSOURCE*((IY-1)*NOBSVZ+NF))
          ENDDO

        ENDIF !(NOBSVZ.GT.1)

        DO IZ=1,NOBSVZ

          DO IY=1,NOBSVY
            IMASH=IZ+(IY-1)*NOBSVZ
            WOBS1(IY)=SPECF(ISOUR+NSOURCE*(IMASH-1+NF))
          ENDDO   !IY

            CALL UTIL_FOLD_FUNCTION_GAUSS(
     &        NOBSVY,OBSVY,WOBS1,WSIGY(ISOUR),DGSIGY(ISOUR),WOBS2,
     &        WOBS3,WOBS4,WOBS5,WOBS6,WOBS7)

          DO IY=IYA,IYE
            IMASH=IZ+(IY-1)*NOBSVZ
            SPECF(ISOUR+NSOURCE*(IMASH-1+NF))=WOBS2(IY)
          ENDDO

        ENDDO  !IZ

      ELSE IF (IFOLD.EQ.-2) THEN

C--- ESTABLISH EDGE AROUND PINHOLE

        MOBSVZ=MOBSVZ+2*MMEDGEZ
        MOBSVY=MOBSVY+2*MMEDGEY
        MOBSV=MOBSVZ*MOBSVY

        IZA=1+(NOBSVZ-MOBSVZ)/2
        IZE=NOBSVZ-(NOBSVZ-MOBSVZ)/2

        IYA=1+(NOBSVY-MOBSVY)/2
        IYE=NOBSVY-(NOBSVY-MOBSVY)/2

        DZ=OBSVDZ
        DY=OBSVDY

C      KNZ=DSIGZ(ISOUR)/DZ    !NUMBER OF ADJACENT MASHES
C      KNY=DSIGY(ISOUR)/DY

        KNZ=IZA-1
        KNY=IYA-1

        KNZ=KNZ*2   !BOTH SIDES OF MASH POINT
        KNY=KNY*2

        IF (IF1DIM.NE.0) KNZ=-99

        IF (KNZ.GT.NDMASHZ) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*) '*** ERROR IN WFOLINT ***'
          WRITE(LUNGFO,*) 'DIMENSION EXCEEDED. INCREASE PARAMETER'
          WRITE(LUNGFO,*) 'NDMASHZP IN CMPARA.CMN'
          WRITE(6,*) '*** ERROR IN WFOLINT ***'
          STOP
        ENDIF

        IF (KNY.GT.NDMASHY) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*) '*** ERROR IN WFOLINT ***'
          WRITE(LUNGFO,*) 'DIMENSION EXCEEDED. INCREASE PARAMETER'
          WRITE(LUNGFO,*) 'NDMASHYP IN CMPARA.CMN'
          WRITE(6,*) '*** ERROR IN WFOLINT ***'
          STOP
        ENDIF

C-- SET UP SIN AND COS ARRAYS

        ZKZ0=XKGAUSS(1,ISOUR)
        ZKDZ=XKGAUSS(1,ISOUR)*OBSVDZ
        DO INZ=1,KNZ+1
          DO M=1,NGFOURZ

C--- ATTENTION: IT'S NOT CLEAR WHAT'S RIGHT, BUT DOES IT MATTER
C             IF FOLDING FUNCTION IS SYMMETRIC ??

C        MARG=(M-1)*ABS(INZ-KNZ/2-1)
            MARG=(M-1)*(INZ-KNZ/2-1)

            ARG=DFLOAT(MARG)*ZKDZ
            GSNZ(M,INZ)=GCOEFH(M,ISOUR)*DSIN(ARG)
            GCSZ(M,INZ)=GCOEFH(M,ISOUR)*DCOS(ARG)

          ENDDO !M
        ENDDO !INZ

        YKY0=YKGAUSS(1,ISOUR)
        YKDY=YKGAUSS(1,ISOUR)*OBSVDY

        DO INY=1,KNY+1
          DO M=1,NGFOURY

C--- ATTENTION: IT'S NOT CLEAR WHAT'S RIGHT, BUT DOES IT MATTER
C             IF FOLDING FUNCTION IS SYMMETRIC ??

C        MARG=(M-1)*ABS(INY-KNY/2-1)
            MARG=(M-1)*(INY-KNY/2-1)

            ARG=DFLOAT(MARG)*YKDY
            GSNY(M,INY)=GCOEFV(M,ISOUR)*DSIN(ARG)
            GCSY(M,INY)=GCOEFV(M,ISOUR)*DCOS(ARG)

          ENDDO !M
        ENDDO !INY

C--- CALCULATE ELEMENTARY INTEGRALS

        DO INZ=1,KNZ  !LOOP OVER ADJACENT INTERVALLS
          DO M=1,NGFOURZ

            XKM1=DFLOAT(M-1)*ZKZ0

            GCPZ=GCSZ(M,INZ+1)
            GCZ=GCSZ(M,INZ)
            GSPZ=GSNZ(M,INZ+1)
            GSZ=GSNZ(M,INZ)

            DCPZ=GCPZ*DZ
            DCZ=GCZ*DZ
            DZXKM1=DZ*XKM1
            DZXKM12=DZXKM1*DZXKM1

            IF(M.EQ.1) THEN
              ZINTK(M,1,INZ)=DCPZ
              ZINTK(M,2,INZ)=DCPZ/2.
              ZINTK(M,3,INZ)=DCPZ/3.
              ZINTK(M,4,INZ)=DCPZ/4.

            ELSE

              ZINTK(M,1,INZ)=(GSPZ-GSZ)/XKM1
              ZINTK(M,2,INZ)=(GSPZ*DZXKM1+GCPZ-GCZ)/(DZXKM1*XKM1)
              ZINTK(M,3,INZ)=
     &          ((DZXKM12-2.)*GSPZ+2.*GSZ+2.*GCPZ*DZXKM1)
     &          /(DZXKM12*XKM1)
              ZINTK(M,4,INZ)=
     &          (3.*(DZXKM12-2.)*GCPZ+(DZXKM12-6.)*GSPZ*DZXKM1+6.
     &          *GCZ)/(DZXKM12*DZXKM1*XKM1)

            ENDIF
          ENDDO   !M

        ENDDO !INZ

        DO INY=1,KNY
          DO M=1,NGFOURY

            XKM1=DFLOAT(M-1)*YKY0

            GCPY=GCSY(M,INY+1)
            GCY=GCSY(M,INY)
            GSPY=GSNY(M,INY+1)
            GSY=GSNY(M,INY)

            DCPY=GCPY*DY
            DCY=GCY*DY
            DYXKM1=DY*XKM1
            DYXKM12=DYXKM1*DYXKM1

            IF(M.EQ.1) THEN
              YINTK(M,1,INY)=DCPY
              YINTK(M,2,INY)=DCPY/2.
              YINTK(M,3,INY)=DCPY/3.
              YINTK(M,4,INY)=DCPY/4.

            ELSE

              YINTK(M,1,INY)=(GSPY-GSY)/XKM1
              YINTK(M,2,INY)=(GSPY*DYXKM1+GCPY-GCY)/(DYXKM1*XKM1)
              YINTK(M,3,INY)=
     &          ((DYXKM12-2.)*GSPY+2.*GSY+2.*GCPY*DYXKM1)
     &          /(DYXKM12*XKM1)

              YINTK(M,4,INY)=
     &          (3.*(DYXKM12-2.)*GCPY+(DYXKM12-6.)*GSPY*DYXKM1+6.
     &          *GCY)/(DYXKM12*DYXKM1*XKM1)

            ENDIF
          ENDDO   !M

        ENDDO !INY


C--- SUM UP ELEMENTARY INTEGRALS (I.E. INNER PART OF INTEGRATION)

        DO K=1,KNZ
          DO I=1,4
            ZINTKS(I,K)=0.0
            DO M=1,NGFOURZ
              ZINTKS(I,K)=ZINTKS(I,K)+ZINTK(M,I,K)
            ENDDO !M
          ENDDO !I
        ENDDO !K

        DO K=1,KNY
          DO I=1,4
            YINTKS(I,K)=0.0
            DO M=1,NGFOURY
              YINTKS(I,K)=YINTKS(I,K)+YINTK(M,I,K)
            ENDDO !M
          ENDDO !I
        ENDDO !K


        IF (IF1DIM.EQ.0) THEN
          II=4
        ELSE
          KNZ=1
          II=1
          ZINTKS(1,1)=1.
        ENDIF


C--- LOOP OVER ALL MASHES INSIDE PINHOLE

        DO IY=IYA,IYE
          DO IZ=IZA,IZE

            IMASH=IZ+(IY-1)*NOBSVZ

C- LOOP OVER ALL ADJACENT MASHES AND SUM UP THE CONTRIBUTIONS

            SUM=0.0

            DO ISY=1,KNY
              IMASHY=IY-KNY/2+ISY-1
              DO ISZ=1,KNZ

                IMASHZ=IZ-KNZ/2+ISZ-1
                ISMASH=IMASHZ+(IMASHY-1)*NOBSVZ
C--- LOOP OVER ALL INDICIES OF BICUBIC SPLINE

                DO I=1,II
                  DO J=1,4

                    SUM=SUM+
     &                COFOLD(I,J,ISMASH)*ZINTKS(I,ISZ)*YINTKS(J,ISY)

                  ENDDO !J
                ENDDO !I


              ENDDO !ISZ
            ENDDO !ISY

            SPECF(ISOUR+NSOURCE*(IMASH-1+NOBSV*(IFREQ-1)))=SUM

          ENDDO !IZ
        ENDDO !IY

      ELSE IF(IFOLD.EQ.-1) THEN

        IYA=1+(NOBSVY-MOBSVY)/2
        IYE=NOBSVY-(NOBSVY-MOBSVY)/2

        IF (NOBSVZ.GT.1) THEN

          IZA=1+(NOBSVZ-MOBSVZ)/2
          IZE=NOBSVZ-(NOBSVZ-MOBSVZ)/2

          ZKZ0=XKGAUSS(1,ISOUR)
          NFOLD=NINT(DSIGZ(ISOUR)/OBSVDZ)

          NF=NOBSV*(IFREQ-1)
          IGZY=1+NGCOEFP*(ISOUR-1)

          DO IY=1,NOBSVY

            DO IZ=1,NOBSVZ
              IMASH=IZ+(IY-1)*NOBSVZ
              WOBS1(IZ)=SPEC(ISOUR+NSOURCE*(IMASH-1+NF))
            ENDDO !IZ

            CALL UTIL_FOLD_FOURIER(OBSVZ,WOBS1,NOBSVZ,NFOLD
     &        ,GZ(IGZY),NGFOURZ,WOBS2,WOBS3,WOBS4,WOBS5,WOBS6,WOBS7,IFAIL)

            IF (IFAIL.NE.0) WRITE(LUNGFO,*)
     &        '*** WARNING IN WFOLINT: FAILURE IN UTIL_FOLD_FOURIER ***'

            DO IZ=IZA,IZE
              IMASH=IZ+(IY-1)*NOBSVZ
              SPECF(ISOUR+NSOURCE*(IMASH-1+NF))=WOBS2(IZ)
            ENDDO

          ENDDO   !IY

        ELSE !(NOBSVZ.GT.1)

          NF=NOBSV*(IFREQ-1)
          IGZY=1+NGCOEFP*(ISOUR-1)
          DO IY=1,NOBSVY
            SPECF(ISOUR+NSOURCE*((IY-1)*NOBSVZ+NF))=
     &        SPEC(ISOUR+NSOURCE*((IY-1)*NOBSVZ+NF))
          ENDDO

        ENDIF !(NOBSVZ.GT.1)

        YKY0=YKGAUSS(1,ISOUR)
        YLY0=2.D0*PI/YKY0
        NFOLD=NINT(DSIGY(ISOUR)/OBSVDY)

        DO IZ=1,NOBSVZ

          DO IY=1,NOBSVY
            IMASH=IZ+(IY-1)*NOBSVZ
            WOBS1(IY)=SPECF(ISOUR+NSOURCE*(IMASH-1+NF))
          ENDDO   !IY

          CALL UTIL_FOLD_FOURIER(OBSVY,WOBS1,NOBSVY,NFOLD
     &      ,GY(IGZY),NGFOURY,WOBS2,WOBS3,WOBS4,WOBS5,WOBS6,WOBS7,IFAIL)

          IF (IFAIL.NE.0) WRITE(LUNGFO,*)
     &      '*** WARNING IN WFOLINT: FAILURE IN UTIL_FOLD_FOURIER ***'

          DO IY=IYA,IYE
            IMASH=IZ+(IY-1)*NOBSVZ
            SPECF(ISOUR+NSOURCE*(IMASH-1+NF))=WOBS2(IY)
          ENDDO

        ENDDO  !IZ

      ENDIF !IFOLD

      RETURN
      END
+DECK,WFOLISTO.
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.51/02 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.34/09 26/09/2001  15.58.40  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  16.27.20  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.33  by  Michael Scheer
*CMZ :  2.15/00 08/05/2000  17.44.33  by  Michael Scheer
*CMZ :  2.13/10 14/04/2000  17.21.59  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.24.36  by  Michael Scheer
*CMZ :  2.13/03 12/01/2000  16.31.33  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  14.43.03  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  11.22.18  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  18.03.39  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.11  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE WFOLISTO(ISTOK,IFREQ)
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,WFOLDF90U.

C--- FOLD SPECTRAL DENSITY IN PINHOLE

C    THE INTENSITY IS GIVEN ANALYTICALLY BY THE COEFFICINETS COFOLD
C    THE KERNEL IS GIVEN BY THE COEFFICIENTS GCOEFH, GCOEFV OF THE FOURIER
C    EXPANSION

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEq,wfoldf90.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.

      INTEGER IZA,IZE,IYA,IYE,IFREQ,ISOUR,IY,IZ,IMASH,INZ
     &       ,INY,ISY,ISZ,I,J,M,KNZ,KNY,K,MARG
     &       ,ISMASH,IMASHZ,IMASHY,II,ISTOK,IGZY,NF,NFOLD,IFAIL


      DOUBLE PRECISION SUM,ARG,ZKZ0,ZKDZ,YKY0,YKDY,XKM1,DZ,DY

      DOUBLE PRECISION GSNZ(NGCOEFP,NDMASHZP),GCSZ(NGCOEFP,NDMASHZP)
      DOUBLE PRECISION GSNY(NGCOEFP,NDMASHYP),GCSY(NGCOEFP,NDMASHYP)
      DOUBLE PRECISION ZINTK(NGCOEFP,4,NDMASHZP),ZINTKS(NGCOEFP,NDMASHZP)
      DOUBLE PRECISION YINTK(NGCOEFP,4,NDMASHYP),YINTKS(NGCOEFP,NDMASHYP)

      DOUBLE PRECISION DCPZ,DCZ,DZXKM1,DZXKM12,GCPZ,GCZ,GSZ,GSPZ
      DOUBLE PRECISION DCPY,DCY,DYXKM1,DYXKM12,GCPY,GCY,GSY,GSPY

      DOUBLE PRECISION GZ(NGCOEFP*LIDIMP),GY(NGCOEFP*LIDIMP)
      EQUIVALENCE (GZ,GCOEFH),(GY,GCOEFV)

      ISOUR=ISIGSTO

      IF (IFOLD.EQ.1) THEN

        IYA=1+(NOBSVY-MOBSVY)/2
        IYE=NOBSVY-(NOBSVY-MOBSVY)/2

        IF (NOBSVZ.GT.1) THEN

          IZA=1+(NOBSVZ-MOBSVZ)/2
          IZE=NOBSVZ-(NOBSVZ-MOBSVZ)/2

          NF=NOBSV*(IFREQ-1)

          DO IY=1,NOBSVY

            DO IZ=1,NOBSVZ
              IMASH=IZ+(IY-1)*NOBSVZ
              WOBS1(IZ)=STOKES(ISTOK,IMASH+NF)
            ENDDO !IZ

            CALL UTIL_FOLD_FUNCTION_GAUSS(
     &        NOBSVZ,OBSVZ,WOBS1,WSIGZ(ISOUR),DGSIGZ(ISOUR),WOBS2,
     &        WOBS3,WOBS4,WOBS5,WOBS6,WOBS7)

            DO IZ=IZA,IZE
              IMASH=IZ+(IY-1)*NOBSVZ
              STOKESF(ISTOK,IMASH+NF)=WOBS2(IZ)
            ENDDO

          ENDDO   !IY

        ELSE !(NOBSVZ.GT.1)

          NF=NOBSV*(IFREQ-1)

          DO IY=1,NOBSVY
            STOKESF(ISTOK,IY+NF)=STOKES(ISTOK,IY+NF)
          ENDDO

        ENDIF !(NOBSVZ.GT.1)

        DO IZ=1,NOBSVZ

          DO IY=1,NOBSVY
            IMASH=IZ+(IY-1)*NOBSVZ
            WOBS1(IY)=STOKESF(ISTOK,IMASH+NF)
          ENDDO   !IY

            CALL UTIL_FOLD_FUNCTION_GAUSS(
     &        NOBSVY,OBSVY,WOBS1,WSIGY(ISOUR),DGSIGY(ISOUR),WOBS2,
     &        WOBS3,WOBS4,WOBS5,WOBS6,WOBS7)

           DO IY=IYA,IYE
            IMASH=IZ+(IY-1)*NOBSVZ
            STOKESF(ISTOK,IMASH+NF)=WOBS2(IY)
          ENDDO

        ENDDO  !IZ

      ELSE IF (IFOLD.EQ.-2) THEN

C--- ESTABLISH EDGE AROUND PINHOLE

      MOBSVZ=MOBSVZ+2*MMEDGEZ
      MOBSVY=MOBSVY+2*MMEDGEY
      MOBSV=MOBSVZ*MOBSVY

      IZA=1+(NOBSVZ-MOBSVZ)/2
      IZE=NOBSVZ-(NOBSVZ-MOBSVZ)/2

      IYA=1+(NOBSVY-MOBSVY)/2
      IYE=NOBSVY-(NOBSVY-MOBSVY)/2

      DZ=OBSVDZ
      DY=OBSVDY

C08052000      KNZ=DSIGZ(ISOUR)/DZ    !NUMBER OF ADJACENT MASHES
C08052000      KNY=DSIGY(ISOUR)/DY

      KNZ=IZA-1
      KNY=IYA-1

      KNZ=KNZ*2   !BOTH SIDES OF MASH POINT
      KNY=KNY*2

      IF (IF1DIM.EQ.1) KNZ=-99

      IF (KNZ.GT.NDMASHZ) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*) '*** ERROR IN WFOLISTO ***'
          WRITE(LUNGFO,*) 'DIMENSION EXCEEDED. INCREASE PARAMETER'
          WRITE(LUNGFO,*) 'NDMASHZP IN CMPARA.CMN'
          WRITE(6,*) '*** ERROR IN WFOLISTO ***'
          STOP
      ENDIF

      IF (KNY.GT.NDMASHY) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*) '*** ERROR IN WFOLISTO ***'
          WRITE(LUNGFO,*) 'DIMENSION EXCEEDED. INCREASE PARAMETER'
          WRITE(LUNGFO,*) 'NDMASHYP IN CMPARA.CMN'
          WRITE(6,*) '*** ERROR IN WFOLISTO ***'
            STOP
      ENDIF

C-- SET UP SIN AND COS ARRAYS

      ZKZ0=XKGAUSS(1,ISOUR)
      ZKDZ=XKGAUSS(1,ISOUR)*OBSVDZ

      DO INZ=1,KNZ+1
      DO M=1,NGFOURZ

C--- ATTENTION: IT'S NOT CLEAR WHAT'S RIGHT, BUT DOES IT MATTER
C             IF FOLDING FUNCTION IS SYMMETRIC ??

C        MARG=(M-1)*ABS(INZ-KNZ/2-1)
         MARG=(M-1)*(INZ-KNZ/2-1)

         ARG=DFLOAT(MARG)*ZKDZ
         GSNZ(M,INZ)=GCOEFH(M,ISOUR)*DSIN(ARG)
         GCSZ(M,INZ)=GCOEFH(M,ISOUR)*DCOS(ARG)

      ENDDO !M
      ENDDO !INZ

      YKY0=YKGAUSS(1,ISOUR)
      YKDY=YKGAUSS(1,ISOUR)*OBSVDY

      DO INY=1,KNY+1
      DO M=1,NGFOURY

C--- ATTENTION: IT'S NOT CLEAR WHAT'S RIGHT, BUT DOES IT MATTER
C             IF FOLDING FUNCTION IS SYMMETRIC ??

C        MARG=(M-1)*ABS(INY-KNY/2-1)
         MARG=(M-1)*(INY-KNY/2-1)

         ARG=DFLOAT(MARG)*YKDY
         GSNY(M,INY)=GCOEFV(M,ISOUR)*DSIN(ARG)
         GCSY(M,INY)=GCOEFV(M,ISOUR)*DCOS(ARG)

      ENDDO !M
      ENDDO !INY

C--- CALCULATE ELEMENTARY INTEGRALS

      DO INZ=1,KNZ  !LOOP OVER ADJACENT INTERVALLS
          DO M=1,NGFOURZ

         XKM1=DFLOAT(M-1)*ZKZ0

         GCPZ=GCSZ(M,INZ+1)
         GCZ=GCSZ(M,INZ)
         GSPZ=GSNZ(M,INZ+1)
         GSZ=GSNZ(M,INZ)

         DCPZ=GCPZ*DZ
         DCZ=GCZ*DZ
         DZXKM1=DZ*XKM1
         DZXKM12=DZXKM1*DZXKM1

         IF(M.EQ.1) THEN
             ZINTK(M,1,INZ)=DCPZ
             ZINTK(M,2,INZ)=DCPZ/2.
             ZINTK(M,3,INZ)=DCPZ/3.
             ZINTK(M,4,INZ)=DCPZ/4.

         ELSE

             ZINTK(M,1,INZ)=(GSPZ-GSZ)/XKM1
             ZINTK(M,2,INZ)=(GSPZ*DZXKM1+GCPZ-GCZ)/(DZXKM1*XKM1)
             ZINTK(M,3,INZ)=
     &              ((DZXKM12-2.)*GSPZ+2.*GSZ+2.*GCPZ*DZXKM1)
     &          /(DZXKM12*XKM1)
             ZINTK(M,4,INZ)=
     &              (3.*(DZXKM12-2.)*GCPZ+(DZXKM12-6.)*GSPZ*DZXKM1+6.
     &              *GCZ)/(DZXKM12*DZXKM1*XKM1)

           ENDIF
         ENDDO   !M

      ENDDO !INZ

      DO INY=1,KNY
        DO M=1,NGFOURY

          XKM1=DFLOAT(M-1)*YKY0

          GCPY=GCSY(M,INY+1)
          GCY=GCSY(M,INY)
          GSPY=GSNY(M,INY+1)
          GSY=GSNY(M,INY)

          DCPY=GCPY*DY
          DCY=GCY*DY
          DYXKM1=DY*XKM1
          DYXKM12=DYXKM1*DYXKM1

          IF(M.EQ.1) THEN
            YINTK(M,1,INY)=DCPY
            YINTK(M,2,INY)=DCPY/2.
            YINTK(M,3,INY)=DCPY/3.
            YINTK(M,4,INY)=DCPY/4.

          ELSE

            YINTK(M,1,INY)=(GSPY-GSY)/XKM1
            YINTK(M,2,INY)=(GSPY*DYXKM1+GCPY-GCY)/(DYXKM1*XKM1)
            YINTK(M,3,INY)=
     &        ((DYXKM12-2.)*GSPY+2.*GSY+2.*GCPY*DYXKM1)
     &        /(DYXKM12*XKM1)
            YINTK(M,4,INY)=
     &        (3.*(DYXKM12-2.)*GCPY+(DYXKM12-6.)*GSPY*DYXKM1+6.
     &        *GCY)/(DYXKM12*DYXKM1*XKM1)

          ENDIF
        ENDDO   !M

      ENDDO !INY


C--- SUM UP ELEMENTARY INTEGRALS (I.E. INNER PART OF INTEGRATION)

      DO K=1,KNZ
        DO I=1,4
          ZINTKS(I,K)=0.0
          DO M=1,NGFOURZ

            ZINTKS(I,K)=ZINTKS(I,K)+ZINTK(M,I,K)

          ENDDO !M
        ENDDO !I
      ENDDO !K

      DO K=1,KNY
        DO I=1,4
          YINTKS(I,K)=0.0
          DO M=1,NGFOURY

            YINTKS(I,K)=YINTKS(I,K)+YINTK(M,I,K)

          ENDDO !M
        ENDDO !I
      ENDDO !K


      IF (IF1DIM.EQ.0) THEN
        II=4
      ELSE
        KNZ=1
        II=1
        ZINTKS(1,1)=1.
      ENDIF


C--- LOOP OVER ALL MASHES INSIDE PINHOLE

      DO IY=IYA,IYE
        DO IZ=IZA,IZE

          IMASH=IZ+(IY-1)*NOBSVZ

C- LOOP OVER ALL ADJACENT MASHES AND SUM UP THE CONTRIBUTIONS

          SUM=0.0

          DO ISY=1,KNY

            IMASHY=IY-KNY/2+ISY-1

            DO ISZ=1,KNZ

              IMASHZ=IZ-KNZ/2+ISZ-1
              ISMASH=IMASHZ+(IMASHY-1)*NOBSVZ

C--- LOOP OVER ALL INDICIES OF BICUBIC SPLINE

              DO I=1,II
                DO J=1,4

                  SUM=SUM+
     &              COFOLD(I,J,ISMASH)*ZINTKS(I,ISZ)*YINTKS(J,ISY)

                ENDDO !J
              ENDDO !I


            ENDDO !ISZ
          ENDDO !ISY

          STOKESF(ISTOK,IMASH+NOBSV*(IFREQ-1))=SUM

      ENDDO !IZ
      ENDDO !IY

      ELSE IF (IFOLD.EQ.-1) THEN

        IYA=1+(NOBSVY-MOBSVY)/2
        IYE=NOBSVY-(NOBSVY-MOBSVY)/2

        IF (NOBSVZ.GT.1) THEN

          IZA=1+(NOBSVZ-MOBSVZ)/2
          IZE=NOBSVZ-(NOBSVZ-MOBSVZ)/2

          ZKZ0=XKGAUSS(1,ISOUR)
          NFOLD=NINT(DSIGZ(ISOUR)/OBSVDZ)

          NF=NOBSV*(IFREQ-1)
          IGZY=1+NGCOEFP*(ISOUR-1)

          DO IY=1,NOBSVY

            DO IZ=1,NOBSVZ
              IMASH=IZ+(IY-1)*NOBSVZ
              WOBS1(IZ)=STOKES(ISTOK,IMASH+NF)
            ENDDO !IZ

            CALL UTIL_FOLD_FOURIER(OBSVZ,WOBS1,NOBSVZ,NFOLD
     &        ,GZ(IGZY),NGFOURZ,WOBS2,WOBS3,WOBS4,WOBS5,WOBS6,WOBS7,IFAIL)

            IF (IFAIL.NE.0) WRITE(LUNGFO,*)
     &        '*** WARNING IN WFOLISTO: FAILURE IN UTIL_FOLD_FOURIER ***'

            DO IZ=IZA,IZE
              IMASH=IZ+(IY-1)*NOBSVZ
              STOKESF(ISTOK,IMASH+NF)=WOBS2(IZ)
            ENDDO

          ENDDO   !IY

        ELSE !(NOBSVZ.GT.1)

          NF=NOBSV*(IFREQ-1)
          IGZY=1+NGCOEFP*(ISOUR-1)
          DO IY=1,NOBSVY
            STOKESF(ISTOK,IY+NF)=STOKES(ISTOK,IY+NF)
          ENDDO

        ENDIF !(NOBSVZ.GT.1)

        YKY0=YKGAUSS(1,ISOUR)
        NFOLD=NINT(DSIGY(ISOUR)/OBSVDY)
        DO IZ=1,NOBSVZ

          DO IY=1,NOBSVY
            IMASH=IZ+(IY-1)*NOBSVZ
            WOBS1(IY)=STOKESF(ISTOK,IMASH+NF)
          ENDDO   !IY

          CALL UTIL_FOLD_FOURIER(OBSVY,WOBS1,NOBSVY,NFOLD
     &      ,GY(IGZY),NGFOURY,WOBS2,WOBS3,WOBS4,WOBS5,WOBS6,WOBS7,IFAIL)

          IF (IFAIL.NE.0) WRITE(LUNGFO,*)
     &      '*** WARNING IN WFOLISTO: FAILURE IN UTIL_FOLD_FOURIER ***'

          DO IY=IYA,IYE
            IMASH=IZ+(IY-1)*NOBSVZ
            STOKESF(ISTOK,IMASH+NF)=WOBS2(IY)
          ENDDO

        ENDDO  !IZ

      ENDIF !IFOLD

      RETURN
      END
+DECK,WGFOUR.
*CMZ :  3.02/08 25/06/2015  14.20.56  by  Michael Scheer
*CMZ :  3.02/05 23/03/2015  10.33.54  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.51/02 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.47/07 14/04/2003  12.01.12  by  Michael Scheer
*CMZ :  2.16/08 29/10/2000  16.30.02  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.33  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  2.14/02 27/04/2000  17.46.14  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.26.25  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  17.02.52  by  Michael Scheer
*CMZ : 00.02/00 11/12/96  14.30.51  by  Michael Scheer
*CMZ : 00.01/08 22/06/95  10.59.24  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  11.23.44  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.56.56  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.18  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE WGFOUR
+seq,gplhint.

+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,WFOLDF90U.

C--- CALCULATE FOURIER COEFFIENCE OF THE HORIZONTAL AND VERTICAL FOLDING
C    FUNCTIONS

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,PHYCON.
+SEq,wfoldf90.
+seq,sourcef90.
+SEq,observf90.

      INTEGER I,K,I1,IP,IM,NGCOEFP2,MFOUR,ISOUR,ICO
      INTEGER IGSIGZ,IGSIGY

      COMPLEX CKOEF(NGCOEFP/2+1+2)
      REAL*4  YFOUR(NGCOEFP+2+2),AKOEF(NGCOEFP/2+1+2)
      EQUIVALENCE (CKOEF,YFOUR)

      DOUBLE PRECISION XFOUR(NGCOEFP+2)
      DOUBLE PRECISION XLFOUR,DXFOUR,BY

      DOUBLE PRECISION FOUFUNX
      DOUBLE PRECISION DGSIGZO,DGSIGYO

C--- LOOP UBER NGCOEFP-PUNKTE FUER FAST-FOURIER-TRANSFORMATION

C--- DETERMINE INTERVALL FOR FFT I.E. COMPARE SPACING OF GRID
C    AND SIGMAS OF FOLDING FUNCTION AND ADJUST DGSIG

      IF (NGFOURZ.GT.NGCOEFP/2) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN WGFOUR:'
          WRITE(LUNGFO,*)'NGFOURZ.GT.NGCOEFP/2'
          WRITE(LUNGFO,*)
     &'CHECK NGFOURZ IN NAMELIST WFOLDN OR INCREASE NGCOEFP IN CMPARA.CMN'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN WGFOUR:'
          WRITE(6,*)'NGFOURZ.GT.NGCOEFP/2'
          WRITE(6,*)
     &'CHECK NGFOURZ IN NAMELIST WFOLDN OR INCREASE NGCOEFP IN CMPARA.CMN'
          WRITE(6,*)
          STOP '*** PROGRAMM ABORTED  ***'
      ENDIF

      IF (NGFOURY.GT.NGCOEFP/2) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN WGFOUR:'
          WRITE(LUNGFO,*)'NGFOURY.GT.NGCOEFP/2'
          WRITE(LUNGFO,*)
     &'CHECK NGFOURY IN NAMELIST WFOLDN OR INCREASE NGCOEFP IN CMPARA.CMN'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN WGFOUR:'
          WRITE(6,*)'NGFOURY.GT.NGCOEFP/2'
          WRITE(6,*)
     &'CHECK NGFOURY IN NAMELIST WFOLDN OR INCREASE NGCOEFP IN CMPARA.CMN'
          WRITE(6,*)
          STOP '*** PROGRAMM ABORTED  ***'
      ENDIF

C--- LOOP OVER ALL SOURCES

      DO ISOUR=1,NSOURCE

      IF (IF1DIM.EQ.0.AND.WSIGZ(ISOUR).EQ.0.D0) THEN
          WRITE(6,*)'*** ERROR IN WGFOUR ***'
          WRITE(6,*)'*** SIGMA FOR HORIZONTALFOLDING FUNCTION IS ZERO ***'
          WRITE(6,*)'*** SOURCE:',ISOUR
          WRITE(6,*)'*** TOTAL NUMBER OF SOURCES:',NSOURCE
          WRITE(6,*)'*** CHECK NAMELIST WFOLDN IN INPUT FILE ***'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
          WRITE(LUNGFO,*)'*** ERROR IN WGFOUR ***'
          WRITE(LUNGFO,*)'*** SIGMA FOR HORIZONTAL FOLDING FUNCTION IS ZERO ***'
          WRITE(LUNGFO,*)'*** SOURCE:',ISOUR
          WRITE(LUNGFO,*)'*** TOTAL NUMBER OF SOURCES:',NSOURCE
          WRITE(LUNGFO,*)'*** CHECK NAMELIST WFOLDN IN INPUT FILE ***'
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
          STOP
      ENDIF !(WSIGZ(ISOUR).EQ.0.D0)

      IF (WSIGY(ISOUR).EQ.0.D0) THEN
          WRITE(6,*)'*** ERROR IN WGFOUR ***'
          WRITE(6,*)'*** SIGMA FOR VERTICAL FOLDING FUNCTION IS ZERO ***'
          WRITE(6,*)'*** SOURCE:',ISOUR
          WRITE(6,*)'*** TOTAL NUMBER OF SOURCES:',NSOURCE
          WRITE(6,*)'*** CHECK NAMELIST WFOLDN IN INPUT FILE ***'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
          WRITE(LUNGFO,*)'*** ERROR IN WGFOUR ***'
          WRITE(LUNGFO,*)'*** SIGMA FOR VERTICAL FOLDING FUNCTION IS ZERO ***'
          WRITE(LUNGFO,*)'*** SOURCE:',ISOUR
          WRITE(LUNGFO,*)'*** TOTAL NUMBER OF SOURCES:',NSOURCE
          WRITE(LUNGFO,*)'*** CHECK NAMELIST WFOLDN IN INPUT FILE ***'
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
          STOP
      ENDIF !(WSIGZ(ISOUR).EQ.0.D0)

      IGSIGZ=NINT(DSIGZ(ISOUR)/OBSVDZ)
      IGSIGY=NINT(DSIGY(ISOUR)/OBSVDY)

C        HALF WIDTH OF FUNCTION ON BOTTOM LINE
      DSIGZ(ISOUR)=DFLOAT(IGSIGZ+1)*OBSVDZ
      DSIGY(ISOUR)=DFLOAT(IGSIGY+1)*OBSVDY

      DSIG2Z(ISOUR)=DSIGZ(ISOUR)**2
      DSIG2Y(ISOUR)=DSIGY(ISOUR)**2

      DGSIGZO=DGSIGZ(ISOUR)
      DGSIGYO=DGSIGY(ISOUR)

      IF (IF1DIM.EQ.0) DGSIGZ(ISOUR)=DSIGZ(ISOUR)/WSIGZ(ISOUR)
      DGSIGY(ISOUR)=DSIGY(ISOUR)/WSIGY(ISOUR)

      IF (DGSIGZ(ISOUR)-DGSIGZO.GT.1.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING IN WGFOUR:'
          WRITE(LUNGFO,*)
     &'ADJUSTED VALUES OF DGSIGZ(ISOUR) DIFFER MORE THEN SIGMA FROM GIVEN VALUE'
          WRITE(LUNGFO,*)'CHECK FOLDING FUNCTION AND DGSIGZ'
c20150625          WRITE(LUNGFO,*)'DGSIGZ LIMITED TO 10*WSIGZ'
c          WRITE(LUNGFO,*)
c          WRITE(6,*)
c          WRITE(6,*)'*** WARNING IN WGFOUR:'
c          WRITE(6,*)
c     &'ADJUSTED VALUES OF DGSIGZ(ISOUR) DIFFER MORE THEN SIGMA FROM GIVEN VALUE'
c          WRITE(6,*)'CHECK FOLDING FUNCTION AND DGSIGZ'
c          WRITE(6,*)
c20150625          dgsigz(isour)=10.0d0*wsigz(isour)
      ENDIF

      IF (DGSIGY(ISOUR)-DGSIGYO.GT.1.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING SR WGFOUR:'
          WRITE(LUNGFO,*)
     &'ADJUSTED VALUES OF DGSIGY(ISOUR) DIFFER MORE THEN SIGMA FROM GIVEN VALUE'
          WRITE(LUNGFO,*)'CHECK FOLDING FUNCTION AND DGSIGY'
          WRITE(LUNGFO,*)
c20150625          WRITE(LUNGFO,*)'DGSIGY LIMITED TO 10*WSIGY'
c          WRITE(6,*)
c          WRITE(6,*)'*** WARNING SR WGFOUR:'
c          WRITE(6,*)
c     &'ADJUSTED VALUES OF DGSIGY(ISOUR) DIFFER MORE THEN SIGMA FROM GIVEN VALUE'
c          WRITE(6,*)'CHECK FOLDING FUNCTION AND DGSIGY'
c          WRITE(6,*)
c20150625          dgsigy(isour)=10.0d0*wsigy(isour)
      ENDIF

C--- VERTICAL DIRECTION

      XLFOUR=2.*DSIGY(ISOUR)

      DXFOUR=XLFOUR/NGCOEFP
      NGCOEFP2=NGCOEFP/2
      MFOUR=NINT(ALOG(FLOAT(NGCOEFP))/ALOG(2.E0))

      DO I=1,NGCOEFP2+1          !SYMMETRISCHE X-WERTE
          XFOUR(I)          =-DXFOUR*(NGCOEFP2+1-I)
          XFOUR(NGCOEFP+1-I+1)=-XFOUR(I)
      END DO

      DO I=1,NGCOEFP2+1          !SYMMETRISCHE Y-WERTE

          I1=I-1
          IP=NGCOEFP2+1+I1
          IM=NGCOEFP2+1-I1

          BY=FOUFUNX(XFOUR(IP),WSIGY(ISOUR))

          YFOUR(IP)=BY
          YFOUR(IM)=BY

      END DO

      CALL RFFT(CKOEF,-MFOUR) !FFT MIT CERN-ROUTINE D703

      DO K=1,NGCOEFP2+1 !REELLE KOEFFIZIENTEN
          AKOEF(K)=(-1.)**(K-1)*2.*REAL(CKOEF(K))
      ENDDO

C--- CALCULATE COEFFICIENTS FOR FOLDING FUNCTION

      DO ICO=1,NGFOURY

          YKGAUSS(ICO,ISOUR)=2.D0*PI1/XLFOUR*DFLOAT(ICO)
          GCOEFV(ICO,ISOUR)=AKOEF(ICO)
          IF (ICO.EQ.1) GCOEFV(ICO,ISOUR)=GCOEFV(ICO,ISOUR)*0.5D0

      ENDDO !NGFOURY

C--- HORIZONTAL DIRECTION

      IF (IF1DIM.EQ.0) THEN

      XLFOUR=2.*DSIGZ(ISOUR)

      DXFOUR=XLFOUR/NGCOEFP
      NGCOEFP2=NGCOEFP/2
      MFOUR=NINT(ALOG(FLOAT(NGCOEFP))/ALOG(2.E0))

      DO I=1,NGCOEFP2+1          !SYMMETRISCHE X-WERTE
          XFOUR(I)          =-DXFOUR*(NGCOEFP2+1-I)
          XFOUR(NGCOEFP+1-I+1)=-XFOUR(I)
      END DO

      DO I=1,NGCOEFP2+1          !SYMMETRISCHE Y-WERTE

          I1=I-1
          IP=NGCOEFP2+1+I1
          IM=NGCOEFP2+1-I1

          BY=FOUFUNX(XFOUR(IP),WSIGZ(ISOUR))

          YFOUR(IP)=BY
          YFOUR(IM)=BY

      END DO

      CALL RFFT(CKOEF,-MFOUR) !FFT MIT CERN-ROUTINE D703

      DO K=1,NGCOEFP2+1 !REELLE KOEFFIZIENTEN
          AKOEF(K)=(-1.)**(K-1)*2.*REAL(CKOEF(K))
      ENDDO

C--- CALCULATE COEFFICIENTS FOR FOLDING FUNCTION

      DO ICO=1,NGFOURZ

          XKGAUSS(ICO,ISOUR)=2.D0*PI1/XLFOUR*DFLOAT(ICO)
          GCOEFH(ICO,ISOUR)=AKOEF(ICO)
          IF (ICO.EQ.1) GCOEFH(ICO,ISOUR)=GCOEFH(ICO,ISOUR)*0.5D0
      ENDDO !NGFOURZ
      ENDIF !IF1DIM

      ENDDO !ISOUR

      RETURN
      END
+DECK,WI2I4I5.
*CMZ :  4.00/14 30/12/2021  15.41.22  by  Michael Scheer
*CMZ :  3.01/00 03/07/2013  15.33.33  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.09.17  by  Michael Scheer
*CMZ :  2.68/05 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  10.38.44  by  Michael Scheer
*CMZ :  2.66/13 20/07/2010  18.26.35  by  Michael Scheer
*CMZ :  2.66/07 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.56/00 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  2.53/05 15/02/2005  12.34.54  by  Michael Scheer
*CMZ :  2.52/15 05/01/2005  16.32.31  by  Michael Scheer
*CMZ :  2.47/12 16/04/2004  09.24.47  by  Michael Scheer
*CMZ :  2.16/08 29/10/2000  16.15.48  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  2.13/11 22/03/2000  14.37.49  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  11.25.45  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  18.08.11  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.07  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE WI2I4I5
+seq,gplhint.

+SEQ,TRACKF90U,IF=F90.
+SEQ,WBETAF90U,IF=F90.

C--- CALCULATE RADIATION INTEGRALS I2,I4,I5 NUMERICALLY IN THE
C    SYSTEM OF THE LONGITUDINAL COORDINATE S ALONG THE REFERENCE ORBIT
C    AND FROM THE ANALYTICAL ANSATZ FOR THE COORDINATE X ALONG THE
C    DEVICE AXIS


      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,TRACK.
+SEQ,DEPOLA.
+seq,wbetaf90.
+SEQ,PHYCON.
+seq,whbook.
+seq,pawcmn.

      INTEGER IP,IC1,IC2

      DOUBLE PRECISION EC1
      DOUBLE PRECISION BY,R1,R12,R13,R13A,R
      DOUBLE PRECISION X,Z,VX,VZ,XOLD,DX
      DOUBLE PRECISION BETA,BETAP,ETA,ETAP,GRAD
      DOUBLE PRECISION WEMITOT,WNOR,HRHO3,DWI4,WI3,SIGEERING,SIGEETOT
      DOUBLE PRECISION ANBETA,ANBETAP,ANETA,ANETAP,ANHRHO3,ANWI5,ANWI52,ANWEMTOT
      DOUBLE PRECISION AB,BB,AI,BI,AII,BII,CII,ANETAI,AI2OPT,BETUNI,BET2UNI
      DOUBLE PRECISION BETOPT,BET2OPT,DISOPT,ANWI5OP,ANWI52OP,ANEMIOP,ANEMI2OP
      DOUBLE PRECISION S,HH,ANHH
      REAL*4 TEMP,XFILL,XI,XE
      REAL*8 WEIGHT

      IF(IHBETA.NE.0) THEN

        XI=WBETA(1,1)-DS0/2.
        XE=WBETA(1,NCO)+DS0/2.
        call hbook1m(IDHS,'CHROMATIC VARIABLE H(s)',NCO/IHTRSMP+1,XI,XE,VMX)
        call hbook1m(IDHSR3,'H(s)/ABS(RHO**3)',NCO/IHTRSMP+1,XI,XE,VMX)

        XI=WSXYZ(1,1)-DS0/2.
        XE=WSXYZ(1,NCO)+DS0/2.
        call hbook1m(IDHX,'CHROMATIC VARIABLE H(x)',NCO/IHTRSMP+1,XI,XE,VMX)
        call hbook1m(IDHXR3,'H(x)/ABS(RHO**3)',NCO/IHTRSMP+1,XI,XE,VMX)

      ENDIF !IHBETA

      EC1=CLIGHT1/EMOM

C--- INITIALIZE INTEGRATION

      WI2=0.0
      WI3=0.0
      WI4=0.0
      WI5=0.0
      ANWI5=0.0
      WI524=0.0

      AB=0.0
      BB=0.0
      AI=0.0
      BI=0.0
      AII=0.0
      BII=0.0
      CII=0.0

      XOLD=WSXYZ(1,1)-(WSXYZ(1,2)-WSXYZ(1,1))

C--- INTEGRATION

      DO IP=1,NCO

        X=WTRA(1,1,IP)
        Z=WTRA(3,1,IP)
        S=WBETA(1,IP)

        DX=X-XOLD

        VX=WTRA(1,2,IP)
        VZ=WTRA(3,2,IP)

        BY=WTRA(2,3,IP)

        R1=BY*EC1 !POSITIV FOR POSITIV FIELDS
        R12=R1**2
        R13=R1**3
        R13A=DABS(R13)

        IF (DABS(R1).GT.1.D-20) THEN
          R=1.D0/R1
        ELSE
          R=0
        ENDIF

        BETA=WBETA(2,IP)
        BETAP=WBETA(3,IP)
        ETA=WBETA(6,IP)
        ETAP=WBETA(7,IP)

        ANBETA=BETFUN+X**2/BETFUN
        ANBETAP=2.D0*X/BETFUN
        ANETA=-Z+DISP0    !ONLY CORRECT IF DDISP0=0
        ANETAI=-Z
        ANETAP=-VZ/VX

        GRAD=WBETAK(2,IP)  !ACTUALLY GRAD=Ky*RHO**2 (SEE FURTHER DOWN)

        HH=(ETA**2+(BETA*ETAP-0.5D0*BETAP*ETA)**2)/BETA
        HRHO3=HH*R13A
        ANHH=(ANETA**2+(ANBETA*ANETAP-0.5D0*ANBETAP*ANETA)**2)/ANBETA
        ANHRHO3=ANHH*R13A

        WI2=WI2+R12*DS0
        DWI4=(1.D0*R13-2.D0*GRAD*R1)*ETA*DS0
        WI3=WI3+ABS(R1)**3*DS0
        WI4=WI4+DWI4
        WI5=WI5+HRHO3*DS0
        ANWI5=ANWI5+ANHRHO3*DX

        AB=(ANETA-X*ANETAP)**2
        BB=ANETAP**2
        AI=AI+AB*R13A*DX
        BI=BI+BB*R13A*DX

        AII=AII+R13A*DX
        BII=BII+(ANETAI-X*ANETAP)*R13A*DX
        CII=CII+(ANETAI-X*ANETAP)**2*R13A*DX

        XFILL=S
        WEIGHT=HH
        IF (IHBETA.NE.0) CALL hfillm(IDHS,XFILL,0.,WEIGHT)
        WEIGHT=HRHO3
        IF (IHBETA.NE.0) CALL hfillm(IDHSR3,XFILL,0.,WEIGHT)
        XFILL=X
        WEIGHT=ANHH
        IF (IHBETA.NE.0) CALL hfillm(IDHX,XFILL,0.,WEIGHT)
        WEIGHT=ANHRHO3
        IF (IHBETA.NE.0) CALL hfillm(IDHXR3,XFILL,0.,WEIGHT)

        XOLD=X

      ENDDO !NCO


      IF (WI2.NE.WI4) WI524=WI5/(WI2-WI4)
      IF (WI2.NE.0.0) ANWI52=ANWI5/WI2

      WEMITOT=(DI5RING+WI5)/(DI2RING+WI2-DI4RING-WI4)
      ANWEMTOT=(DI5RING+ANWI5)/(DI2RING+WI2)
      WNOR=DI5RING/(DI2RING-DI4RING)

C--- OPTIMIZATION OF EXTERNAL DISPERSION AND BETA-FUNCTION
C     (USING ANALYTICAL ANSATZ)

      IF (WI2.GT.1D-10) THEN

        DISOPT=-BII/AII
        AI2OPT=AII*DISOPT**2+2.D0*BII*DISOPT+CII !AI FUER OPTIMALE DISPERSION

        BETOPT=DSQRT(AI/BI) !DIESER WERT DER BETATRON-FUNKTION MINIMIERT I5
        BET2OPT=DSQRT((AI2OPT)/BI) !DIESER WERT DER BETATRON-FUNKTION MINIMIERT I5
        ANWI5OP=1./BETOPT*AI+BETOPT*BI
        ANWI52OP=2.D0*DSQRT((CII-BII*BII/AII)*BI)

        BETUNI=-9999.

        IF(WI2.GT.1D-10.AND.ANWI5OP/WI2.LT.DI5RING/DI2RING) THEN
          BETUNI=DI5RING*WI2/(2.D0*DI2RING*BI)
     &      +DSQRT((DI5RING*WI2/(2.D0*DI2RING*BI))**2-AI/BI)
        ENDIF

        BET2UNI=-9999.

        IF(WI2.GT.1D-10.AND.ANWI52OP/WI2.LT.DI5RING/DI2RING) THEN
          BET2UNI=DI5RING*WI2/(2.D0*DI2RING*BI)
     &      +DSQRT((DI5RING*WI2/(2.D0*DI2RING*BI))**2-AI2OPT/BI)
        ENDIF

        ANEMIOP=(DI5RING+ANWI5OP)/(DI2RING+WI2)
        ANEMI2OP=(DI5RING+ANWI52OP)/(DI2RING+WI2)

      ENDIF !WI2

C-- I3

      DI3RING=2.0D0*PI1/RDIPOL**2
      SIGEERING=SQRT(CQ1*DMYGAMMA**2*DI3RING/(2.0D0*DI2RING+DI4RING))
      SIGEETOT=
     &  SQRT(CQ1*DMYGAMMA**2*(DI3RING+WI3)/(2.0D0*(DI2RING+WI2)+DI4RING))

C--- RESULTS


      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'RADIUS OF DIPOLMAGNETS:   ',SNGL(RDIPOL)
      WRITE(LUNGFO,*)'CIRCUMFERENCE OF THE RING:',SNGL(UMFANG)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'DISPERSION-FUNCTION AND DERIVATIVE FOR WLS:'
      WRITE(LUNGFO,*)SNGL(DISP0),SNGL(DDISP0)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'MOMENTUM-DEVIATION DISPERSION CALCULATIONS:',SNGL(DELGAM)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'INTEGRAL I2 OF RING:        ',SNGL(DI2RING)
      WRITE(LUNGFO,*)'INTEGRAL I3 OF RING:        ',SNGL(DI3RING)
      WRITE(LUNGFO,*)'INTEGRAL I4 OF RING:        ',SNGL(DI4RING)
      WRITE(LUNGFO,*)'INTEGRAL I5 OF RING:        ',SNGL(DI5RING)
      WRITE(LUNGFO,*)

      IC1=NCO/2
      IC2=IC1+2

      IF (
     &    DABS((WBETA(2,IC1)+WBETA(2,IC2))/2.D0/BETFUN-1.D0).GT.0.01
     &    .OR.
     &    WBETA(3,IC1)*WBETA(3,IC2).GT.0.0) THEN

        WRITE(LUNGFO,*)
        WRITE(6,*)'*** WARNING IN WI2I4I5 ***'
        WRITE(6,*)
        WRITE(6,*)
     &    'BETA-FUNCTION FOR ANALYTICAL APPROXIMATION AND NUMERICAL CALCULATION NOT COMPATIBLE'
        WRITE(6,*)'CHECK BETFUN, BETAH, BETAPH IN NAMELIST DEPOLA'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN WI2I4I5 ***'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    'BETA-FUNCTION FOR ANALYTICAL APPROXIMATION AND NUMERICAL CALCULATION NOT COMPATIBLE'
        WRITE(LUNGFO,*)'CHECK BETFUN, BETAH, BETAPH IN NAMELIST DEPOLA'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
      ENDIF

      IF (DDISP0.NE.0.0) THEN

        WRITE(LUNGFO,*)
        WRITE(6,*)'*** WARNING IN WI2I4I5 ***'
        WRITE(6,*)
        WRITE(6,*)
     &    'EXTERNAL DISPERSION NOT CONSTANT, I.E. DDISP0 IN NAMELIST DEPOLA NOT ZERO'
        WRITE(6,*)
        WRITE(6,*)
        WRITE(LUNGFO,*)'*** WARNING SR WI2I4I5 ***'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    'EXTERNAL DISPERSION NOT CONSTANT, I.E. DDISP0 IN NAMELIST DEPOLA NOT ZERO'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
      ENDIF

      IF (DABS(XSTART+XSTOP).GT.1.D-10) THEN
        WRITE(LUNGFO,*)
        WRITE(6,*)'*** WARNING IN WI2I4I5 ***'
        WRITE(6,*)
        WRITE(6,*)
     &    'CONSIDERED SETUP NOT CENTERED AROUND ORIGIN'
        WRITE(6,*)
        WRITE(6,*)
        WRITE(LUNGFO,*)'*** WARNING SR WI2I4I5 ***'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    'CONSIDERED SETUP NOT CENTERED AROUND ORIGIN'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
      ENDIF
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'EPS0H:',EPS0H
      WRITE(LUNGFO,*)'EPS0V:',EPS0V
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'RESULTS FROM ANALYTICAL ANSATZ:'
      WRITE(LUNGFO,*)'---------------------------------'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'BETFUN, BETFUNV:',SNGL(BETFUN),SNGL(BETFUNV)
      WRITE(LUNGFO,*)'BETAH, BETAPH:',SNGL(BETAH),SNGL(BETAPH)
      WRITE(LUNGFO,*)'BETAV, BETAPV:',SNGL(BETAV),SNGL(BETAPV)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '(ONLY CORRECT IF ORBIT IS PLANAR, WLS HAS NO TRANSVERSAL GRADIENT,'
      WRITE(LUNGFO,*)
     &  'WLS IS SYMMETRIC WITH RESPECT TO ORIGIN OR COORDINATE-SYSTEM'
      WRITE(LUNGFO,*)'CENTERED IN STRAIGHT SECTION, (VZ/VX)**2 << 1,'
      WRITE(LUNGFO,*)
     &  'AND DERIVATION OF EXTERNAL DISPERSION VANISHES OUTSIDE WLS)'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  'BETA-FUNCTION AT WLS CENTER, I5, I5/I2 of WLS:'
      TEMP=1.E30
      IF(WI2.GT.1D-10) TEMP=SNGL(ANWI5/WI2)
      WRITE(LUNGFO,*)SNGL(BETFUN),SNGL(ANWI5),TEMP
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'TOTAL EMITTANCE CHANGE:',SNGL(ANWEMTOT/WNOR)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  'OPTIMAL BETA-FUNCTION, CORRESPONDING I5 AND TOTAL EMITTANCE CHANGE FOR ACTUAL EXTERNAL DISPERSION :'
      WRITE(LUNGFO,*)SNGL(BETOPT),SNGL(ANWI5OP),SNGL(ANEMIOP/WNOR)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'OPTIMAL EXTERNAL DISPERSION:',SNGL(DISOPT)
      WRITE(LUNGFO,*)
     &'OPTIMAL BETA-FUNCTION, CORRESPONDING I5 AND TOTAL EMITTANCE CHANGE FOR OPTIMAL EXTERNAL DISPERSION :'
         WRITE(LUNGFO,*)SNGL(BET2OPT),SNGL(ANWI52OP),SNGL(ANEMI2OP/WNOR)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'NEUTRAL BETAFUNCTION:                 ',SNGL(BETUNI)
      WRITE(LUNGFO,*)'NEUTRAL BETAFUNCTION FOR OPT. DISP.:  ',SNGL(BET2UNI)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'ENERGY-SPREAD OF RING:',SNGL(SIGEERING)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'RESULTS OF NUMERICAL CALCULATION:'
      WRITE(LUNGFO,*)'---------------------------------'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'I2, I3, I4, I5, I5/(I2-I4) of WLS:'
      WRITE(LUNGFO,*)SNGL(WI2),SNGL(WI3),SNGL(WI4),SNGL(WI5),SNGL(WI524)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'TOTAL EMITTANCE CHANGE:',SNGL(WEMITOT/WNOR)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'TOTAL ENERGY-SPREAD:',SNGL(SIGEETOT)
      WRITE(LUNGFO,*)'CHANGE TOTAL ENERGY-SPREAD:',SNGL(SIGEETOT/SIGEERING)
      WRITE(LUNGFO,*)

      RETURN
      END
+DECK,WLINTRA.
*CMZ :  3.00/00 02/04/2013  13.39.05  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.66/09 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.66/07 17/12/2009  13.18.30  by  Michael Scheer
*CMZ :  2.16/08 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.57.05  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.12  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE WLINTRA
+seq,gplhint.

+SEQ,TRACKF90U,IF=F90.
+SEQ,WBETAF90U,IF=F90.

C--- CALCULATES LINEARE TRANSFER MATRICES WITHOUT COUPLING FROM BETA-FUNCTION
C    STORED IN ARRAY WBETA AND TUNE SHIFTS

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+seq,wbetaf90.
+SEQ,TRACK.
+SEQ,PHYCON.

      INTEGER IP,ical

      DOUBLE PRECISION ALPHA0H,ALPHAH,BETA0H,BETAH,SINPHIH,COSPHIH
      DOUBLE PRECISION ALPHA0V,ALPHAV,BETA0V,BETAV,SINPHIV,COSPHIV
      DOUBLE PRECISION T11,T12,BY,BETA

      data ical/0/

      if (ical.ne.0) return
      ical=1

C--- TUNE SHIFT

      TUNEH=0.0
      TUNEV=0.0

      WTUNE(1,1)=TUNEH
      WTUNE(2,1)=TUNEV

      DO IP=2,NCO

          TUNEH=TUNEH+2.D0/(WBETA(2,IP)+WBETA(2,IP-1))*DS0
          TUNEV=TUNEV+2.D0/(WBETA(4,IP)+WBETA(4,IP-1))*DS0

          WTUNE(1,IP)=TUNEH
          WTUNE(2,IP)=TUNEV

      ENDDO !IP


C--- LINEAR TRANSFERMATRICES

      BETA0H=WBETA(2,1)
      BETA0V=WBETA(4,1)
      ALPHA0H=-WBETA(3,1)/2.D0
      ALPHA0V=-WBETA(5,1)/2.D0

      DO IP=1,NCO

         TUNEH=WTUNE(1,IP)
         TUNEV=WTUNE(2,IP)

         COSPHIH=DCOS(TUNEH)
         COSPHIV=DCOS(TUNEV)
         SINPHIH=DSIN(TUNEH)
         SINPHIV=DSIN(TUNEV)
         BETAH  =WBETA(2,IP)
         BETAV  =WBETA(4 ,IP)
         ALPHAH =-WBETA(3,IP)/2.D0
         ALPHAV =-WBETA(5,IP)/2.D0

         WLTM(1,1,IP)=DSQRT(BETAH/BETA0H)*(COSPHIH+ALPHA0H*SINPHIH)
         WLTM(1,2,IP)=DSQRT(BETA0H*BETAH)*SINPHIH
         WLTM(1,3,IP)=1.0D0/(DSQRT(BETA0H*BETAH))
     &     *(
     &     (ALPHA0H-ALPHAH) *COSPHIH
     &     -
     &     (1.D0+ALPHA0H*ALPHAH) *SINPHIH
     &     )
         WLTM(1,4,IP)=DSQRT(BETA0H/BETAH)*(COSPHIH-ALPHAH*SINPHIH)

         WLTM(2,1,IP)=DSQRT(BETAV/BETA0V)*(COSPHIV+ALPHA0V*SINPHIV)
         WLTM(2,2,IP)=DSQRT(BETA0V*BETAV)*SINPHIV
         WLTM(2,3,IP)=1.0D0/(DSQRT(BETA0V*BETAV))
     &     *(
     &     (ALPHA0V-ALPHAV) *COSPHIV
     &     -
     &     (1.D0+ALPHA0V*ALPHAV) *SINPHIV
     &     )
         WLTM(2,4,IP)=DSQRT(BETA0V/BETAV)*(COSPHIV-ALPHAV*SINPHIV)

      ENDDO !IP

      TMH(1,1)=WLTM(1,1,NCO)
      TMH(1,2)=WLTM(1,2,NCO)
      TMH(2,1)=WLTM(1,3,NCO)
      TMH(2,2)=WLTM(1,4,NCO)

      TMV(1,1)=WLTM(2,1,NCO)
      TMV(1,2)=WLTM(2,2,NCO)
      TMV(2,1)=WLTM(2,3,NCO)
      TMV(2,2)=WLTM(2,4,NCO)

C--- VERTICAL TUNE SHIFT

      TUNSHI=0.0
      DO IP=1,NCO
        BY=WTRA(2,3,IP)
        BETA=WBETA(4,IP)
        TUNSHI=TUNSHI+BETA*BY**2
      ENDDO !IP
      TUNSHI=TUNSHI*DS0/(4.*PI1)/DMYENERGY**2*0.3**2

C--- TUNES (PHASE ADVANCE) OF CORRESPONDING DRIFT

      T11=1.D0
      T12=WTRA(1,1,NCO)-WTRA(1,1,1)
      TUNEH0=DATAN(T12/(T11*WBETA(2,1)+WBETA(3,1)/2.*T12))
      TUNEV0=DATAN(T12/(T11*WBETA(4,1)+WBETA(5,1)/2.*T12))
      IF(TUNEH0.LT.0.0)TUNEH0=TUNEH0+PI1
      IF(TUNEV0.LT.0.0)TUNEV0=TUNEV0+PI1

      RETURN
      END
+DECK,WLSJUST.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.16/04 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  11.28.35  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  18.04.09  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.20  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE WLSJUST(XI,YI)
+seq,gplhint.

C UTILITY ROUTINE THAT ESTIMATES A NEW VALUE FOR X TO
C TO BRING Y=F(X) TO ZERO. THE PREVIOUS AND CURRENT VALUES
C WRITTEN TO THE FILE FILEJ, I.E. THE FILE IS UPDATED BY THE
C CALLS TO THE ROUTINE

      IMPLICIT NONE

      INTEGER ICAL
      DOUBLE PRECISION XI,YI,X0,Y0,X1,Y1,X,Y,AAA,BBB

      DATA ICAL/0/

      DATA X0,Y0,X1,Y1,X/5*0.0/

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.

      IF (IJUST.EQ.1) THEN

          IF (ICAL.NE.0) THEN

         X0=XI
         Y0=YI

         OPEN(UNIT=LUNJ,FILE=FILEJ,STATUS='NEW',FORM='FORMATTED')
         WRITE(LUNJ,*)X0,Y0
         CLOSE(LUNJ)

          ELSE

         ICAL=1

          ENDIF

      ELSE IF (IJUST.EQ.2) THEN

          IF (ICAL.NE.0) THEN

         Y1=YI

         WRITE(LUNJ,*)X0,Y0
         WRITE(LUNJ,*)X1,Y1

         CLOSE(LUNJ)

          ELSE

         OPEN(UNIT=LUNJ,FILE=FILEJ,STATUS='OLD',FORM='FORMATTED')
         READ(LUNJ,*)X0,Y0
         REWIND (LUNJ)

         X1=X0*1.10
         XI=X1

         ICAL=1

          ENDIF

      ELSE IF (IJUST.EQ.3) THEN

          IF (ICAL.NE.0) THEN

         Y=YI

         WRITE(LUNJ,*)X1,Y1
         WRITE(LUNJ,*)X,Y

         CLOSE(LUNJ)

          ELSE

         OPEN(UNIT=LUNJ,FILE=FILEJ,STATUS='OLD',FORM='FORMATTED')
         READ(LUNJ,*)X0,Y0
         READ(LUNJ,*)X1,Y1
         REWIND (LUNJ)

         AAA=(Y1-Y0)/(X1-X0)
         BBB=Y1-AAA*X1
         X=-BBB/AAA

         XI=X

         ICAL=1

          ENDIF

      ELSE IF (IJUST.EQ.4) THEN

          IF (ICAL.EQ.0) THEN

         OPEN(UNIT=LUNJ,FILE=FILEJ,STATUS='OLD',FORM='FORMATTED')
         READ(LUNJ,*)X0,Y0
         READ(LUNJ,*)X1,Y1

         XI=X1

         CLOSE(LUNJ)

         ICAL =1

          ENDIF

      ELSE

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN WLSJUST ***'
          WRITE(LUNGFO,*)'IJUST WRONG. CHECK NAMELIST CONTRL'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN WLSJUST ***'
          WRITE(6,*)'IJUST WRONG. CHECK NAMELIST CONTRL'
          WRITE(6,*)
          STOP

      ENDIF


      RETURN
      END
+DECK,WLSOPT.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  12.43.40  by  Michael Scheer
*CMZ :  2.56/00 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.02.52  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  14.58.52  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  11.31.54  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.57.14  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.42  by  Michael Scheer
*-- Author : Michael Scheer
C*****************************************************************
      SUBROUTINE WLSOPT(IWLS,IFLAG,E,B0MIN,B0MAX,DB0,EMIKRIT,TAUKRIT,POLKRIT,
     &                    XLAM0MN,XLAM0MX,DXLAM0,FASYMMN,FASYMMX,DFASYM,
     &                    BETA0,RHODIP,DBHOM,TAU0E5,DI2RING,DI5RING,
     &                    ZMAXKRIT,ZMINKRIT,IMODE,LUN,IWLSADI,DISP0,DXHOM)
C****************************************************************
+seq,gplhint.

C   S/R WLSOPT SUCHT DURCH VARIATION DES B-FELDES, DER LAENGE UND DER
C   ASYMMETRIE DEN OPTIMALEN WLS VOM ASYMM. HALBACH-TYP
C
C   BEDEUTUNG EINIGER VARIABLER:
C
C     IWLS  .NE. 0  PROGRAMM WIRD VON WAVE.FOR GERUFEN
C     IFLAG .NE. 0  MINIMALE EMITTANZ BEZIEHT SICH AUF Emin
C                   ZUR ZEIT NUR MOEGLICH, FALLS DISP0=0
C     IMODE  =   1  SUCHE WLS FUER MINIMALE ENERGIE
C            =   2  SUCHE BESTEN AEQUIVALENTEN AHW

      IMPLICIT NONE

      DOUBLE PRECISION EMI,EMIOPT,EMIRING,EMIRINGK,EMITOTEPK,EMIOPTEP,EMITOPTEP,
     &         EMIRINGEP,EMIRINGEPK,EMITOT,EMITOPT,EMIKRIT
      DOUBLE PRECISION EMIK,EMIOPTK,EMITOTK,EMITOPTK,EMITOTEP,EMIEP,EMIEPK
      DOUBLE PRECISION B0,B0MAX,B0MIN,DB0,B0K,DBHOM,XHOMK,XHOM
      DOUBLE PRECISION RHODIP,RHO0K,GMOM
      DOUBLE PRECISION FASYM,FASYMMN,FASYMMX,DFASYM,FASYMK
      DOUBLE PRECISION E,F,CD,C2,C5,E0,EMINEM,EMINPOL,EMINEP,EMIN,EMINK,GAMMA
      DOUBLE PRECISION ZMAX,ZMAXK,ZMAXEP,ZMAXEPK
      DOUBLE PRECISION BETA0,BETOPT,BETOPTK,F0,F0K,XLP,FB0M,FBETP,B0P,F0P
      DOUBLE PRECISION XLAM0,XLAM0MN,XLAM0MX,DXLAM0,XLAM0K,XKK,XLK,XL2K,DXHOM
      DOUBLE PRECISION TAU1GEV,TAU0E5,TAUMAX,TAU1GEVK,TAUKRIT,TAU,TAUK,TAUEP,TAUEPK
      DOUBLE PRECISION POLLEV,POLLV1G,POLLV1GK,POLLEVK,POLKRIT,POLLEVEP,POLLEVEPK
      DOUBLE PRECISION DI2RING,DI5RING,B3AWLS,DI2WLS,DI2WLSEP,DI2WLSEPK,DI5WLSK
      DOUBLE PRECISION DI5WLSOPT,DI5WLSOPTK,CHI2,CHI2MIN,BETIN,DI5IN,DI2IN  !060891
      DOUBLE PRECISION DI5WLS,DI5WLSEP,DI2ADI,DI5ADI,CHI2ADI,BETOADI,DI5WLSOPTEP
      DOUBLE PRECISION TAUIN,POLLEVIN,ZMAXKRIT,ZMINKRIT,EMIIN,EMIOPTIN
     &                 ,DISP0,DISPOPT,EMI2OPT,EMIT2OPT,BET2OPT,BETUNI,
     &                  BET2UNI,DI2WLSK,
     &                  DISPOPTEP,EMI2OPTEP,EMIT2OPTEP,BET2OPTEP
     &                 ,BETUNIEP,BET2UNIEP,DI5WLS2OPTEP,BETOPTEP,
     &                  F2,F20,EMIT2OPTK,EMI2OPTK,DI5WLS2OPT,BET2OPTK,
     &                  BETUNIK,BET2UNIK,F20K,DI5WLS2OPTK,DISPOPTK,
     &                  BETOPTEPK,DISPOPTEPK,BET2OPTEPK,BETUNIEPK,
     &                  BET2UNIEPK

      INTEGER IB0,NB0,IFA,NFA,IXL,NXL,LUN,IFLAG,IEMIN0,IFOUND,IWLS,IMODE,
     &          IWLSADI

+SEQ,PHYCON.

      WRITE(LUN,*)
      WRITE(LUN,*)
      WRITE(LUN,*)'PROGRAMM WLSOPT'
      WRITE(LUN,*)'==============='
      WRITE(LUN,*)


C--- WENN SICH DIE STRAHLENERGIE AENDERT, AENDERT SICH DIE SKALIERTE
C    EXTERNE DISPERSION. DESHALB MUESSTE FUER DISP0.NE.0 UND IFLAG.NE.0
C    DAS PROGRAMM ERWEITERT WERDEN (!? 21.7.92)

      IF(IFLAG.NE.0.AND.DISP0.NE.0.0) THEN
         WRITE(LUN,*)
         WRITE(LUN,*)'*** DISP0.NE.0 UND IEMICRIT.NE.0 ***'
         WRITE(LUN,*)
     &'FUER DISP0.NE.0 MUSS SICH DIE MAX. ZULAESSIGE AENDERUNG AUF E UND NICHT AUF Emin BEZIEHEN!'
         STOP
      ENDIF

      IF(IMODE.EQ.2) THEN
        IF(IWLS.EQ.0) THEN
          WRITE(6,*)  !060891
CC       WRITE(6,*)'BETIN,DI5IN,DI2IN:'   !060891
          WRITE(6,*)'BETIN,DI5IN,DI2IN,TAUIN,POLLEVIN:'   !060891
          READ(5,*)BETIN,DI5IN,DI2IN                !060891
     &      ,TAUIN,POLLEVIN      !27.1.92
        ELSE
          READ(39,*)BETIN,DI5IN,DI2IN        !070891
     &      ,TAUIN,POLLEVIN,EMIIN,EMIOPTIN  !27.1.92
        ENDIF
      ENDIF !IMODE.EQ.2

      GAMMA=E/EMASSG1
      EMIN=E
      GMOM=DSQRT((E-EMASSG1)*(E+EMASSG1))

      IF (LUN.NE.6.AND.LUN.NE.16)
     &  OPEN(UNIT=LUN,FILE='WAVE_WLSOPT.DAT',STATUS='NEW',FORM='FORMATTED')

      CD=EMIKRIT*DI5RING/DI2RING

      NB0=NINT((B0MAX-B0MIN)    /DB0   )
      NXL=NINT((XLAM0MX-XLAM0MN)/DXLAM0)
      NFA=NINT((FASYMMX-FASYMMN)/DFASYM)

C- VARIIERE DIE PARAMETER DES AHW, UM IDEALES GERAET ZU FINDEN

      DO IFA=0,NFA
        FASYM=FASYMMN+IFA*DFASYM
        DO IB0=0,NB0
          B0=B0MIN+IB0*DB0
          DO IXL=0,NXL

            XLAM0=XLAM0MN+IXL*DXLAM0
            XHOM=DSQRT(2.*DBHOM)/(2.* PI1/XLAM0)

C- BERECHNE EMITTANZ UND POLARISATIONSZEIT DES AHW

            CALL EMIT(B0,XLAM0,FASYM,
     &        E,RHODIP,TAU0E5,BETA0,DI2RING,DI5RING,
     &        EMIRING,EMI,EMIOPT,EMITOT,EMITOPT,B3AWLS,
     &        F,F0,BETOPT,TAU,TAU1GEV,POLLEV,POLLV1G,
     &        ZMAX,DI2WLS,DI5WLS,DI5WLSOPT,0,
     &        DISP0,DISPOPT,EMI2OPT,EMIT2OPT,BET2OPT,BETUNI,
     &        BET2UNI,DI5WLS2OPT)

C- START-WERT FUER NUMERISCHE LOESUNG DER NACHFOLGENDEN GLEICHUNG
C  EMINEM IST ENERGIE,FUER DIE GESAMTEMITTANZ GLEICH DER ZULAESSIGEN
C  GESAMTEMITTANZ IST

            IF(IFLAG.NE.0) THEN !1.4.92

              EMINEM=(F*0.5*(BETA0/BETOPT+BETOPT/BETA0)*
     &          (XLAM0*0.3*B0)**3/CD)**(1./3.)

C010891         C5=F*XLAM0**4/4.*(0.3*B0)**5*BETA0/(2.*BETOPT)*(1.+1./FASYM)
              C5=F*XLAM0**4/4.*(0.3*B0)**5*
     &          0.5*(BETA0/BETOPT+BETOPT/BETA0)*(1.+1./FASYM)
              C2=XLAM0/4.*(0.3*B0)**2*(1.+1./FASYM)

C- BESTIMME EMINEM NUMERISCH NACH NEWTON-VERFAHREN. GL. S. LOGBUCH S.194

              CALL EMIN0(CD,C5,C2,DI2RING,DI5RING,E,EMINEM,E0,IEMIN0)

              IF(IEMIN0.NE.1) GOTO 900
              EMINEM=E0

            ENDIF !IFLAG

C- BESTIMME EMINPOL NUMERISCH NACH NEWTON-VERFAHREN. GL. S. LOGBUCH S.193
C  EMINPOL IST DIE ENERGIE, FUER DIE DIE KRITISCHE POLARISATIONSZEIT ERREICHT
C  WIRD

            CALL EMINP(RHODIP,B3AWLS,TAU0E5,TAUKRIT,EMINPOL)

            IF(IFLAG.NE.0) THEN
              EMINEP=DMAX1 (EMINEM,EMINPOL)  !EMITTANZCUT FUER Emin
            ELSE
              EMINEP=EMINPOL !DANN GREIFT EMITTANZCUT FUER E (S.U.)
            ENDIF

C- BERECHNE EMITTANZ UND POL.-ZEIT FUER DIE MINIMALE ENERGIE

            CALL EMIT(B0,XLAM0,FASYM,
     &        EMINEP,RHODIP,TAU0E5,BETA0,DI2RING,DI5RING,
     &        EMIRINGEP,EMIEP,EMIOPTEP,EMITOTEP,EMITOPTEP,
     &        B3AWLS,
     &        F2,F20,BETOPTEP,TAUEP,TAU1GEV,POLLEVEP,POLLV1G,
     &        ZMAXEP,DI2WLSEP,DI5WLSEP,DI5WLSOPTEP,0,
     &        DISP0,DISPOPTEP,EMI2OPTEP,EMIT2OPTEP,BET2OPTEP
     &        ,BETUNIEP,BET2UNIEP,DI5WLS2OPTEP)

            TAUMAX=TAUEP

C--- KANDIDAT GEFUNDEN ?

            IF(IMODE.EQ.2) !260291
     &        CHI2=0.0
     &        +((DI2WLS   -DI2IN)/DI2IN)**2
     &        +((EMI-EMIIN)      /EMIIN)**2
C     &          +((BETOPT   -BETIN)/BETIN)**2  !060891
C     &          +((DI5WLSOPT-DI5IN)/DI5IN)**2
C     &      CHI2=((BETOPT   -BETIN)/BETIN)**2  !060891
C     &          +((DI5WLSOPT/DI2WLS-DI5IN/DI2IN)/(DI5IN/DI2IN))**2
C     &          +((DI2WLS   -DI2IN)/DI2IN)**2
C     &     +(((POLLEV-POLLEVIN)/POLLEVIN)**2     !27.1.92
C     &          +((TAU-TAUIN)/TAUIN)**2)/2.           !27.1.92

            IF(IMODE.EQ.2.AND.CHI2.LT.CHI2MIN) THEN
              IFOUND=1
              EMIN=EMINEP
              EMINK=EMINEP
              EMIRINGK=EMIRING
              EMIRINGEPK=EMIRINGEP
              EMIK=EMI
              EMIEPK=EMIEP
              EMIOPTK=EMIOPT
              EMITOTK=EMITOT
              EMITOTEPK=EMITOTEP
              EMITOPTK=EMITOPT
              DI5WLSK=DI5WLS
              DI5WLSOPTK=DI5WLSOPT !060891

              EMI2OPTK=EMI2OPT
              EMIT2OPTK=EMIT2OPT
              DI5WLS2OPTK=DI5WLS2OPT
              DISPOPTK=DISPOPT
              DISPOPTEPK=DISPOPTEP
              BETOPTEPK=BETOPTEP
              BET2OPTEPK=BET2OPTEP
              BET2OPTK=BET2OPT
              BETUNIEPK=BETUNIEP
              BET2UNIEPK=BET2UNIEP
              BETUNIK=BETUNI
              BET2UNIK=BET2UNI
              F20K=F20
              ZMAXEPK=ZMAXEP
              DI2WLSEPK=DI2WLSEP

              DI2WLSK=DI2WLS
              B0K=B0
              RHO0K=1./(CLIGHT1*B0K/GMOM)
              FASYMK=FASYM
              XLAM0K=XLAM0
              XLK=XLAM0K/2.*(1.+FASYM)
              XL2K=XLK/2.
              XKK=2.* PI1/XLAM0K
              XHOMK=XHOM
              TAUK=TAU
              TAU1GEVK=TAU1GEV
              TAUEPK=TAUEP
              POLLEVEPK=POLLEVEP
              POLLEVK=POLLEV
              POLLV1GK=POLLV1G
              BETOPTK=BETOPT
              F0K=F0
              ZMAXK=ZMAX
              CHI2MIN=CHI2   !060891
            ENDIF !IMODE.EQ.2

            IF(IMODE.EQ.1 .AND.
     &          ZMAX.LE. ZMAXKRIT.and.
     &          ZMAX.GE. ZMINKRIT.and.
     &          XHOM.GE.DXHOM.AND.
     &          TAUMAX.LE.TAUKRIT*1.000001
     &          .AND.
     &          POLLEVEP.GE.POLKRIT
     &          .AND.
     &          (IFLAG.EQ.0.AND.EMITOT.LE.EMIKRIT*EMIRING
     &          .OR.IFLAG.NE.0.AND.EMINEM.LE.E) !DANN IST EMITTANZCUT FU
     &          .AND.
     &          EMINEP.LT.EMIN) THEN
              IFOUND=1
              EMIN=EMINEP
              EMINK=EMINEP
              EMIRINGK=EMIRING
              EMIRINGEPK=EMIRINGEP
              EMIK=EMI
              EMIEPK=EMIEP
              EMIOPTK=EMIOPT
              EMITOTK=EMITOT
              EMITOTEPK=EMITOTEP
              EMITOPTK=EMITOPT
              DI5WLSK=DI5WLS
              DI5WLSOPTK=DI5WLSOPT !060891
              DI2WLSEPK=DI2WLSEP
              DI2WLSK=DI2WLS

              EMI2OPTK=EMI2OPT
              EMIT2OPTK=EMIT2OPT
              DI5WLS2OPTK=DI5WLS2OPT
              DISPOPTK=DISPOPT
              DISPOPTEPK=DISPOPTEP
              BETOPTEPK=BETOPTEP
              BET2OPTK=BET2OPT
              BET2OPTEPK=BET2OPTEP
              BETUNIK=BETUNI
              BETUNIEPK=BETUNIEP
              BET2UNIEPK=BET2UNIEP
              BET2UNIK=BET2UNI
              F20K=F20
              ZMAXEPK=ZMAXEP

              B0K=B0
              RHO0K=1./(CLIGHT1*1.D-9*B0K/GMOM)
              FASYMK=FASYM
              XLAM0K=XLAM0
              XLK=XLAM0K/2.*(1.+FASYM)
              XL2K=XLK/2.
              XKK=2.* PI1/XLAM0K
              XHOMK=XHOM
              TAUK=TAU
              TAU1GEVK=TAU1GEV
              TAUEPK=TAUEP
              POLLEVEPK=POLLEVEP
              POLLEVK=POLLEV
              POLLV1GK=POLLV1G
              BETOPTK=BETOPT
              F0K=F0
              ZMAXK=ZMAX
              CHI2MIN=CHI2   !060891
            ENDIF

900         continue
          ENDDO !FASYM
        ENDDO !B0
      ENDDO !LAMBDA0

      IF (IFOUND.NE.1) THEN
        WRITE(LUN,*) '*** KEINEN PASSENDEN WLS GEFUNDEN ***'
        WRITE(6,*) '*** KEINEN PASSENDEN WLS GEFUNDEN ***'
        STOP
      ENDIF

      IF(IMODE.EQ.2) THEN

        IF(DABS(B0K-B0MIN)     .LT.1.D-3 .AND. B0MIN.NE.B0MAX) THEN
          WRITE(LUN,*)
          WRITE(LUN,*) '*** S/R WLSOPT: B0MIN-LIMIT REACHED ***'
          WRITE(LUN,*)
        ENDIF
        IF(DABS(B0K-B0MAX)     .LT.1.D-3 .AND. B0MIN.NE.B0MAX) THEN
          WRITE(LUN,*)
          WRITE(LUN,*)'*** S/R WLSOPT: B0MAX-LIMIT REACHED ***'
          WRITE(LUN,*)
        ENDIF
        IF(DABS(FASYMK-FASYMMN).LT.1.D-3 .AND. FASYMMN.NE.FASYMMX) THEN
          WRITE(LUN,*)
          WRITE(LUN,*)'*** S/R WLSOPT: FASYMMN-LIMIT REACHED ***'
          WRITE(6,*)'*** S/R WLSOPT: FASYMMN-LIMIT REACHED ***'
          WRITE(LUN,*)
        ENDIF
        IF(DABS(FASYMK-FASYMMX).LT.1.D-3 .AND. FASYMMN.NE.FASYMMX)  THEN
          WRITE(LUN,*)
          WRITE(LUN,*)'*** S/R WLSOPT: FASYMMX-LIMIT REACHED ***'
          WRITE(6,*)'*** S/R WLSOPT: FASYMMX-LIMIT REACHED ***'
          WRITE(LUN,*)
        ENDIF
        IF(DABS(XLAM0K-XLAM0MN).LT.1.D-3 .AND. XLAM0MN.NE.XLAM0MX) THEN
          WRITE(LUN,*)
          WRITE(LUN,*)'*** S/R WLSOPT: XLAM0MN-LIMIT REACHED ***'
          WRITE(6,*)'*** S/R WLSOPT: XLAM0MN-LIMIT REACHED ***'
          WRITE(LUN,*)
        ENDIF
        IF(DABS(XLAM0K-XLAM0MX).LT.1.D-3 .AND. XLAM0MN.NE.XLAM0MX) THEN
          WRITE(LUN,*)
          WRITE(LUN,*)'*** S/R WLSOPT: XLAM0MX-LIMIT REACHED ***'
          WRITE(6,*)'*** S/R WLSOPT: XLAM0MX-LIMIT REACHED ***'
          WRITE(LUN,*)
        ENDIF
      ENDIF
C---------------------------------------------------------------------
      IF(IWLSADI.NE.0)
     &  CALL ADI(GAMMA,B0K,XLAM0K,FASYMK,F0K,DI2WLSEPK,DI5WLSOPTK,
     &  BETOPTK,B0P,XLP,BETOADI,FB0M,F0P,FBETP,
     &  DI2ADI,DI5ADI,CHI2ADI)
C---------------------------------------------------------------------

      IF(
     &      DABS(B0K-B0MIN)     .LT.1.D-3.AND.B0MAX.NE.B0MIN.OR.
     &      DABS(B0K-B0MAX)     .LT.1.D-3.AND.B0MAX.NE.B0MIN.OR.
     &      DABS(XLAM0K-XLAM0MN).LT.1.D-3.AND.XLAM0MX.NE.XLAM0MN.OR.
     &      DABS(XLAM0K-XLAM0MX).LT.1.D-3.AND.XLAM0MX.NE.XLAM0MN.OR.
     &      DABS(FASYMK-FASYMMN).LT.1.D-3.AND.FASYMMX.NE.FASYMMN.OR.
     &      DABS(FASYMK-FASYMMX).LT.1.D-3.AND.FASYMMX.NE.FASYMMN)
     &   THEN
         WRITE(LUN,*)
         WRITE(LUN,*) '*** PARAMETER LIMIT REACHED ***'
         WRITE(LUN,*)
      ENDIF
      WRITE(LUN,*)
      WRITE(LUN,*)'VORGEGEBENE PARAMETER:'
      WRITE(LUN,*)
      WRITE(LUN,*)
      WRITE(LUN,*)'ENERGIE, GAMMA:                 ',SNGL(E),SNGL(GAMMA)
      WRITE(LUN,*)'VORGEGEBENE BETAFUNKTION:      ',SNGL(BETA0)
      WRITE(LUN,*)'VORGEGEBENE DISPERSION:        ',SNGL(DISP0)
      WRITE(LUN,*)
      WRITE(LUN,*)'B0min, B0max, dB0:              ',
     &               SNGL(B0MIN),SNGL(B0MAX),SNGL(DB0)
      WRITE(LUN,*)'FASYMMN,FASYMMX,DFASYM:         ',
     &               SNGL(FASYMMN),SNGL(FASYMMX),SNGL(DFASYM)
      WRITE(LUN,*)'LAMBD0min, LAMBDA0max, dLAMBDA0:',
     &           SNGL(XLAM0MN),SNGL(XLAM0MX),SNGL(DXLAM0)

            WRITE(LUN,*)
            WRITE(LUN,*)'RADIUS DER DIPOLE, TAU(1GEV) OHNE WLS:',
     &                   SNGL(RHODIP),SNGL(TAU0E5)
            WRITE(LUN,*)'I2(RING), I5(RING):',
     &                   SNGL(DI2RING),SNGL(DI5RING)

      IF(IMODE.EQ.2) THEN

         WRITE(LUN,*)
         WRITE(LUN,*)'BETIN, DI5IN, DI2IN:'  !060891
         WRITE(LUN,*)SNGL(BETIN),SNGL(DI5IN),SNGL(DI2IN) !060891
         WRITE(LUN,*)'TAUIN, POLLEVIN:'  !270192
         WRITE(LUN,*)SNGL(TAUIN),SNGL(POLLEVIN)  !270192

      ELSEIF (IMODE.EQ.1) THEN

            WRITE(LUN,*)
          WRITE(LUN,*)'MAX. EMI.VERSCHLECHTER.(REL.):  ',SNGL(EMIKRIT)
          IF (IFLAG.EQ.0) THEN
         WRITE(LUN,*) '(BEZIEHT SICH AUF E)'
          ELSE
         WRITE(LUN,*) '(BEZIEHT SICH AUF Emin)'
          ENDIF
          WRITE(LUN,*)
          WRITE(LUN,*)'MAX. POLARISATIONSZEIT:         ',SNGL(TAUKRIT)
          WRITE(LUN,*)'MIN. POLARISATIONSGRAD:         ',SNGL(POLKRIT)
          WRITE(LUN,*)
          WRITE(LUN,*)'OBERE GRENZE FUER ABLAGE:       ',SNGL(ZMAXKRIT)
          WRITE(LUN,*)'UNTERE GRENZE FUER ABLAGE:      ',SNGL(ZMINKRIT)

      ELSE

         STOP '*** S/R WLSOPT: IMODE FALSCH ***'

      ENDIF

      WRITE(LUN,*)
      WRITE(LUN,*)'dx (hom):                       ',SNGL(DXHOM)
      WRITE(LUN,*)'dB/B (hom):                     ',SNGL(DBHOM)
      WRITE(LUN,*)
      WRITE(LUN,*)
      WRITE(LUN,*)'DATEN DES OPTIMALEN WLS:'
      WRITE(LUN,*)'------------------------'
      WRITE(LUN,*)
      IF(IMODE.EQ.2)
     &   WRITE(LUN,*)'CHI2MIN:            ',SNGL(CHI2MIN)   !060891
      IF(NB0.LT.2) THEN
         WRITE(LUN,*)
         WRITE(LUN,*) '*** WARNUNG: B0 NICHT VARIIERT ***'
      ENDIF
      WRITE(LUN,*)'B0, RHO0:                       ',SNGL(B0K),SNGL(RHO0K)
      IF(NB0.LT.2) THEN
         WRITE(LUN,*)
      ENDIF
      IF(NFA.LT.2) THEN
         WRITE(LUN,*)
         WRITE(LUN,*) '*** WARNUNG: n NICHT VARIIERT ***'
      ENDIF
      WRITE(LUN,*)'ASYMMETRIE:                     ',SNGL(FASYMK)
      IF(NFA.LT.2) THEN
         WRITE(LUN,*)
      ENDIF
      IF(NXL.LT.2) THEN
         WRITE(LUN,*)
         WRITE(LUN,*) '*** WARNUNG: LAMBA0 NICHT VARIIERT ***'
      ENDIF
      WRITE(LUN,*)'LAMBDA0, K:                     ',SNGL(XLAM0K),SNGL(XKK)
      IF(NXL.LT.2) THEN
         WRITE(LUN,*)
      ENDIF
      WRITE(LUN,*)
      WRITE(LUN,*)
      WRITE(LUN,*)'GESAMTLAENGE, HALBE LAENGE:     ',SNGL(XLK),SNGL(XL2K)
      WRITE(LUN,*)'2*Xhom, 2*Xhom/RHO0K*GAMMA:     ',
     &              SNGL(2.*XHOMK),SNGL(2.*XHOMK/RHO0K*GAMMA)
      WRITE(LUN,*)
      WRITE(LUN,*)
      WRITE(LUN,*)'I2(WLS):                        ',SNGL(DI2WLSK)
      WRITE(LUN,*)'I5(WLS):                        ',SNGL(DI5WLSK)
      WRITE(LUN,*)'I5(WLS) FUER OPT. BETA:         ',SNGL(DI5WLSOPTK)
      WRITE(LUN,*)'I5(WLS) FUER OPT. BETA UND ETA: ',SNGL(DI5WLS2OPTK)
      WRITE(LUN,*)
      WRITE(LUN,*)
      WRITE(LUN,*)'EMI(WLS):                       ',SNGL(EMIK)
      WRITE(LUN,*)'EMI(WLS) FUER OPT. BETA:        ',SNGL(EMIOPTK)
      WRITE(LUN,*)'EMI(WLS) FUER OPT. BETA UND ETA:',SNGL(EMI2OPTK)
      WRITE(LUN,*)
      WRITE(LUN,*)'GESAMTEMITTANZ:                       ',SNGL(EMITOTK)
      WRITE(LUN,*)'GESAMTEMITTANZ BEI OPT. BETA:         ',SNGL(EMITOPTK)
      WRITE(LUN,*)'GESAMTEMITTANZ BEI OPT. BETA UND ETA: ',SNGL(EMIT2OPTK)
      WRITE(LUN,*)
      WRITE(LUN,*)
      WRITE(LUN,*)'EMITTANZAENDERUNG FUER E:                  ',
     &  SNGL(EMITOTK/EMIRINGK)
      WRITE(LUN,*)'EMITTANZAENDERUNG FUER E UND OPT. BETA:    ',
     &  SNGL(EMITOPTK/EMIRINGK)
      WRITE(LUN,*)'EMITTANZAENDERUNG FUER E,OPT. BETA UND ETA:',
     &  SNGL(EMIT2OPTK/EMIRINGK)
      WRITE(LUN,*)
      WRITE(LUN,*)
      WRITE(LUN,*)'OPT. DISPERSION:                       ',SNGL(DISPOPTK)
      WRITE(LUN,*)'OPT. BETAFUNKTION:                     ',SNGL(BETOPTK)
      WRITE(LUN,*)'OPT. BETAFUNKTION FUER OPT. DISPERSION:',SNGL(BET2OPTK)
      WRITE(LUN,*)'NEUTRALE BETAFUNKTION:                 ',SNGL(BETUNIK)
      WRITE(LUN,*)'NEUTRALE BETAFUNKTION FUER OPT. ETA:   ',SNGL(BET2UNIK)
      WRITE(LUN,*)
      WRITE(LUN,*)
      WRITE(LUN,*)'ABLAGE:                             ',SNGL(ZMAXK)
      WRITE(LUN,*)'FOKALLAENGE (FALLS 1/Fx=0;NAEH.)    ',SNGL(1./DI2WLSK)
      WRITE(LUN,*)'ABGESTRAHLTE LEISTUNG (kWATT/AMPERE)',
     &               SNGL(14.085*DI2WLSK*E**4)
      WRITE(LUN,*)
      WRITE(LUN,*)
      WRITE(LUN,*)'MIN. ENERGIE:                   ',SNGL(EMINK)
      WRITE(LUN,*)'--------------------------------'
      WRITE(LUN,*)
      WRITE(LUN,*)'POLARISATIONSZEIT:              ',SNGL(TAUK)
      WRITE(LUN,*)'POLARISATIONSGRAD:              ',SNGL(POLLEVK)
      WRITE(LUN,*)'POLARISATIONSZEIT (Emin):       ',SNGL(TAUEPK)
      WRITE(LUN,*)'POLARISATIONSGRAD (Emin):       ',SNGL(POLLEVEPK)
      WRITE(LUN,*)'POLARISATIONSZEIT (1 GeV):      ',SNGL(TAU1GEVK)
      WRITE(LUN,*)'POLARISATIONSGRAD (1 GeV):      ',SNGL(POLLV1GK)
      WRITE(LUN,*)
      WRITE(LUN,*)
      WRITE(LUN,*)'EMITTANZAENDERUNG FUER Emin:    ',
     &               SNGL(EMITOTEPK/EMIRINGEPK)
      WRITE(LUN,*)
      WRITE(LUN,*)
      WRITE(LUN,*)'OPT. DISPERSION FUER Emin:             ',SNGL(DISPOPTEPK)
      WRITE(LUN,*)'OPT. BETAFUNKTION FUER Emin:           ',SNGL(BETOPTEPK)
      WRITE(LUN,*)'OPT. BETAFUNKTION FUER OPT. DISPERSION:',SNGL(BET2OPTEPK)
      WRITE(LUN,*)'NEUTRALE BETAFUNKTION FUER Emin:       ',SNGL(BETUNIEPK)
      WRITE(LUN,*)'NEUTRALE BETAFUNKTION FUER OPT. ETA:   ',SNGL(BET2UNIEPK)
      WRITE(LUN,*)
      WRITE(LUN,*)
      WRITE(LUN,*)'ABLAGE FUER Emin:                         ',
     &  SNGL(ZMAXEPK)
      WRITE(LUN,*)'FOKALLAENGE FUER Emin (FALLS 1/Fx=0;NAEH.)',
     &  SNGL(1./DI2WLSEPK)
      WRITE(LUN,*)'ABGESTRAHLTE LEISTUNG (kWATT/AMPERE)      ',
     &               SNGL(14.085*DI2WLSEPK*EMINK**4)


      IF (IWLSADI.NE.0) THEN
      WRITE(LUN,*)'WERTE DES ADI:'
      WRITE(LUN,*)'B0, LPLUS, m:        ',SNGL(B0P),SNGL(XLP),SNGL(FB0M)
      WRITE(LUN,*)'I2(adi),I5opt(adi):  ',SNGL(DI2ADI),SNGL(DI5ADI)
      WRITE(LUN,*)'BETAopt(adi):        ',SNGL(BETOADI)
        WRITE(LUN,*)'CHI2(adi):           ',SNGL(CHI2ADI)
      WRITE(LUN,*)
      ENDIF

      IF (LUN.NE.6.AND.LUN.NE.16)CLOSE(LUN)

      IF (LUN.EQ.16) THEN
C     WRITE(6,*)
C     WRITE(6,*)'PROGRAMM WLSOPT'
C     WRITE(6,*)'==============='
C     WRITE(6,*)
C     WRITE(6,*)
      IF(
     &      DABS(B0K-B0MIN)     .LT.1.D-3.AND.B0MAX.NE.B0MIN.OR.
     &      DABS(B0K-B0MAX)     .LT.1.D-3.AND.B0MAX.NE.B0MIN.OR.
     &      DABS(XLAM0K-XLAM0MN).LT.1.D-3.AND.XLAM0MX.NE.XLAM0MN.OR.
     &      DABS(XLAM0K-XLAM0MX).LT.1.D-3.AND.XLAM0MX.NE.XLAM0MN.OR.
     &      DABS(FASYMK-FASYMMN).LT.1.D-3.AND.FASYMMX.NE.FASYMMN.OR.
     &      DABS(FASYMK-FASYMMX).LT.1.D-3.AND.FASYMMX.NE.FASYMMN)
     &   THEN
         WRITE(6,*)
         WRITE(6,*) '*** PARAMETER LIMIT REACHED ***'
         WRITE(6,*)
      ENDIF
      IF (IFOUND.NE.1) STOP '*** KEINEN PASSENDEN WLS GEFUNDEN ***'
C     WRITE(6,*)
C     WRITE(6,*)'VORGEGEBENE PARAMETER:'
C     WRITE(6,*)
C     WRITE(6,*)'ENERGIE, GAMMA:                 ',SNGL(E),SNGL(GAMMA)
      WRITE(6,*)'B0min, B0max, dB0:              ',
     &               SNGL(B0MIN),SNGL(B0MAX),SNGL(DB0)
      WRITE(6,*)'FASYMMN,FASYMMX,DFASYM:         ',
     &               SNGL(FASYMMN),SNGL(FASYMMX),SNGL(DFASYM)
      WRITE(6,*)'LAMBD0min, LAMBDA0max, dLAMBDA0:',
     &           SNGL(XLAM0MN),SNGL(XLAM0MX),SNGL(DXLAM0)

      IF(IMODE.EQ.1) THEN

         WRITE(6,*)'BETIN, DI5IN, DI2IN:'  !060891
         WRITE(6,*)SNGL(BETIN),SNGL(DI5IN),SNGL(DI2IN) !060891
         WRITE(6,*)

      ELSEIF (IMODE.EQ.2) THEN

          WRITE(6,*)'MAX. EMI.VERSCHLECHTER.(REL.):  ',SNGL(EMIKRIT)
          IF (IFLAG.EQ.0) THEN
         WRITE(6,*) '(BEZIEHT SICH AUF E)'
          ELSE
         WRITE(6,*) '(BEZIEHT SICH AUF Emin)'
          ENDIF
C         WRITE(6,*)'MAX. POLARISATIONSZEIT:         ',SNGL(TAUKRIT)
C         WRITE(6,*)'MIN. POLARISATIONSGRAD:         ',SNGL(POLKRIT)

      ELSE

         STOP '*** S/R WLSOPT: IMODE FALSCH ***'

      ENDIF

C     WRITE(6,*)'dB/B (hom):                     ',SNGL(DBHOM)
C     WRITE(6,*)
C     WRITE(6,*)'DATEN DES OPTIMALEN WLS:'
C     WRITE(6,*)
      IF(IMODE.EQ.2)
     &  WRITE(6,*)'CHI2MIN:            ',SNGL(CHI2MIN)   !060891
      IF(NB0.LT.2) THEN
         WRITE(6,*)
         WRITE(6,*) '*** WARNUNG: B0 NICHT VARIIERT ***'
      ENDIF
      WRITE(6,*)'B0, RHO0:                       ',SNGL(B0K),SNGL(RHO0K)
      IF(NFA.LT.2) THEN
         WRITE(6,*)
         WRITE(6,*) '*** WARNUNG: n NICHT VARIIERT ***'
      ENDIF
      WRITE(6,*)'ASYMMETRIE:                     ',SNGL(FASYMK)
      IF(NXL.LT.2) THEN
         WRITE(6,*)
         WRITE(6,*) '*** WARNUNG: LAMBA0 NICHT VARIIERT ***'
      ENDIF
      WRITE(6,*)'LAMBDA0, K:                     ',SNGL(XLAM0K),SNGL(XKK)
C     WRITE(6,*)'GESAMTLAENGE, HALBE LAENGE:     ',SNGL(XLK),SNGL(XL2K)
      WRITE(6,*)'2*Xhom, 2*Xhom/RHO0K*GAMMA:     ',
     &              SNGL(2.*XHOMK),SNGL(2.*XHOMK/RHO0K*GAMMA)
C     WRITE(6,*)'I2(WLS):                        ',SNGL(DI2WLSEPK)
C     WRITE(6,*)'I5(WLS), OPT. I5(WLS):          ',
C     &               SNGL(DI5WLSK),SNGL(DI5WLSOPTK)
C     WRITE(6,*)'EMI(WLS), OPT. EMI(WLS):        ',SNGL(EMIK),SNGL(EMIOPTK)
C     WRITE(6,*)'EMITTANZ, OPT. EMITTANZ:        ',
C     &               SNGL(EMITOTK),SNGL(EMITOPTK)
C     WRITE(6,*)'EMITTANZAENDERUNG FUER E:       ',SNGL(EMITOTK/EMIRINGK)
C     WRITE(6,*)'EMITTANZAENDERUNG FUER Emin:    ',
C     &               SNGL(EMITOTEPK/EMIRINGEPK)
C     WRITE(6,*)
C     WRITE(6,*)'VORGEGEBENE BETAF., OPT. BETAF.:',
C     &               SNGL(BETA0),SNGL(BETOPTK)
C     WRITE(6,*)'ABLAGE:                         ',SNGL(ZMAXK)
C     WRITE(6,*)'FOKALLAENGE (FALLS 1/Fx=0;NAEH.)',SNGL(1./DI2WLSEPK)
C     WRITE(6,*)
C     WRITE(6,*)'MIN. ENERGIE:                   ',SNGL(EMINK)
C     WRITE(6,*)'POLARISATIONSZEIT:              ',SNGL(TAUK)
C     WRITE(6,*)'POLARISATIONSGRAD:              ',SNGL(POLLEVK)
C     WRITE(6,*)'POLARISATIONSZEIT (Emin):       ',SNGL(TAUEPK)
C     WRITE(6,*)'POLARISATIONSGRAD (Emin):       ',SNGL(POLLEVEPK)
C     WRITE(6,*)'POLARISATIONSZEIT (1 GeV):      ',SNGL(TAU1GEVK)
C     WRITE(6,*)'POLARISATIONSGRAD (1 GeV):      ',SNGL(POLLV1GK)
C     WRITE(6,*)
      IF (IWLSADI.NE.0) THEN
      WRITE(6,*)'WERTE DES ADI:'
      WRITE(6,*)'B0, LPLUS, m:        ',SNGL(B0P),SNGL(XLP),SNGL(FB0M)
      WRITE(6,*)'I2(adi),I5opt(adi):  ',SNGL(DI2ADI),SNGL(DI5ADI)
      WRITE(6,*)'BETAopt(adi):        ',SNGL(BETOADI)
      WRITE(6,*)'CHI2(adi):           ',SNGL(CHI2ADI)
      WRITE(6,*)
      ENDIF
      ENDIF

      RETURN
      END
+DECK,WPOLY2.
*CMZ :  3.03/00 13/07/2015  15.41.18  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.34/09 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.17/00 03/11/2000  10.22.05  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  18.04.39  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.33  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.24.36  by  Michael Scheer
*CMZ :  2.13/03 16/12/99  10.48.38  by  Michael Scheer
*CMZ :  1.03/06 11/06/98  18.24.32  by  Michael Scheer
*CMZ : 00.01/04 28/11/94  18.44.59  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.57.19  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.20  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE WPOLY2(ISOUR,IFREQ)
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,WFOLDF90U.
+SELF.

C--- DETERMINE 2D CUBIC POLYNOMIALS WHICH DESCRIBE THE INTENSITY INSIDE A
C    MASH OF THE PINHOLE
C    THE USED SR WBCUCOF STEMS FORM NUMERICAL RECIPIES (BCUCOF)
C    THE POLYNOMIAL COEFFICIENTS OF THE MASHES ARE STORED

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,PHYCON.
+SEq,wfoldf90.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.

      INTEGER ISOUR,IFREQ,IOBSV,IZ,IY,NDIA,NPL,IPL,IDIA,I1,I2,I3,I4
      INTEGER IYY,IZZ,ISS,NOBSVZ1

      DOUBLE PRECISION YPP1(4),YPP2(4),YPP3(4),CSP,DSP,YPP0,YPPN

      REAL*4 Y(4),Y1(4),Y2(4),Y12(4),C(4,4)

+SELF,IF=F90.
      ALLOCATE(IOBUFF(NOBSV))
+SELF.

C- SPLINES IN Z

      DO IZ=1,MAX(NOBSVZ,NOBSVY)
          DOBUFF1(IZ)=DFLOAT(IZ-1)
      ENDDO !IZ

        IOBSV=0
        DO IY=1,NOBSVY

        DO IZ=1,NOBSVZ

          IOBSV=IOBSV+1
+SELF,IF=-NEWWAVE.
          DOBUFF(IZ)=SPEC(ISOUR,IOBSV,IFREQ)
+SELF,IF=NEWWAVE.
          DOBUFF(IZ)=SPEC(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))
+SELF.
        ENDDO      !IZ

           YPP0=1.D30
           YPPN=1.D30
C       CALL FSPLINEZ(DOBUFF1,DOBUFF,NOBSVZ,YPP0,YPPN,DOBUFF2)
C060793    CALL FSPLINDX(DOBUFF1,            S,NOBSVZ,YPP0,YPPN,DOBUFF2)
        CALL FSPLINDX(DOBUFF1(2)-DOBUFF1(1),DOBUFF,NOBSVZ,0.D0,0.D0,DOBUFF2)

        DO IZ=1,NOBSVZ

          SPCOEFU(1,IZ+(IY-1)*NOBSVZ)=DOBUFF2(IZ)


        ENDDO      !IZ
        ENDDO      !IY

C- SPLINES IN Y


        DO IZ=1,NOBSVZ
        DO IY=1,NOBSVY

          IOBSV=(IY-1)*NOBSVZ+IZ
+SELF,IF=-NEWWAVE.
          DOBUFF(IY)=SPEC(ISOUR,IOBSV,IFREQ)
+SELF,IF=NEWWAVE.
          DOBUFF(IY)=SPEC(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))
+SELF.

        ENDDO      !IY

           YPP0=1.D30
           YPPN=1.D30
C       CALL FSPLINEY(DOBUFF1,DOBUFF,NOBSVY,YPP0,YPPN,DOBUFF2)
C060793    CALL FSPLINDX(DOBUFF1,            S,NOBSVY,YPP0,YPPN,DOBUFF2)
        CALL FSPLINDX(DOBUFF1(2)-DOBUFF1(1),DOBUFF,NOBSVY,0.D0,0.D0,DOBUFF2)

        DO IY=1,NOBSVY

          SPCOEFU(2,IZ+(IY-1)*NOBSVZ)=DOBUFF2(IY)

        ENDDO      !IY
        ENDDO      !IZ

C- SPLINES IN YZ-DIRECTION

      DO IY=1,MAX(NOBSVY,NOBSVZ)
        DOBUFF1(IY)=DSQRT(2.D0)*DFLOAT(IY-1)
      ENDDO !IY

        NDIA=NOBSVZ+NOBSVY-1  !NUMBER OF LINES ACROSS THE PINHOLE

        DO IDIA=1,NDIA

C- NUMBER OF POINTS OF CURRENT LINE

          IF (IDIA.LE.NOBSVY) THEN
         NPL=MIN(IDIA,NOBSVZ)
         DO IPL=1,NPL
             IOBSV=NOBSVY*NOBSVZ-NOBSVZ*IDIA+(IPL-1)*NOBSVZ+IPL
             IOBUFF(IPL)=IOBSV
+SELF,IF=-NEWWAVE.
              DOBUFF(IPL)=SPEC(ISOUR,IOBSV,IFREQ)
+SELF,IF=NEWWAVE.
              DOBUFF(IPL)=SPEC(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))
+SELF.
              ENDDO   !IPL
          ELSE
         NPL=NDIA-IDIA+1

CORR 2.10.92
         NPL=MIN(NPL,NOBSVY)
CORR 2.10.92

         DO IPL=1,NPL
             IOBSV=IDIA-NOBSVY+(IPL-1)*NOBSVZ+IPL
             IOBUFF(IPL)=IOBSV
+SELF,IF=-NEWWAVE.
              DOBUFF(IPL)=SPEC(ISOUR,IOBSV,IFREQ)
+SELF,IF=NEWWAVE.
              DOBUFF(IPL)=SPEC(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))
+SELF.
              ENDDO   !IPL
          ENDIF

           YPP0=1.D30
           YPPN=1.D30
          IF (NPL.LE.NDOBSVZ) THEN
C            CALL FSPLINEZ(DOBUFF1,DOBUFF,NPL,YPP0,YPPN,DOBUFF2)
C060793         CALL FSPLINDX(DOBUFF1,            S,NPL,YPP0,YPPN,DOBUFF2)
                  CALL FSPLINDX(DOBUFF1(2)-DOBUFF1(1),DOBUFF,NPL,0.D0,0.D0,DOBUFF2)
          ELSEIF (NPL.LE.NDOBSVY) THEN
C            CALL FSPLINEY(DOBUFF1,DOBUFF,NPL,YPP0,YPPN,DOBUFF2)
C060793         CALL FSPLINDX(DOBUFF1,            S,NPL,YPP0,YPPN,DOBUFF2)
                  CALL FSPLINDX(DOBUFF1(2)-DOBUFF1(1),DOBUFF,NPL,0.D0,0.D0,DOBUFF2)
          ELSE
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)'*** ERROR IN WPOLY2 ***'
             WRITE(LUNGFO,*)
     & 'SEVERE ERROR! CHECK SOURCE CODE USING THE DEBUGGER, SORRY'
             WRITE(LUNGFO,*)
             WRITE(6,*)
             WRITE(6,*)'*** ERROR IN WPOLY2 ***'
             WRITE(6,*)
     & 'SEVERE ERROR! CHECK SOURCE CODE USING THE DEBUGGER, SORRY'
             WRITE(6,*)
             STOP
          ENDIF

          DO IPL=1,NPL

            ISS=IOBUFF(IPL)
            SPCOEFU(3,ISS)=DOBUFF2(IPL)

          ENDDO   !IPL

          ENDDO   !IDIA

C--- NOW THE COEFFICIENTS OF THE BICUBIC SPLINES (NUMERICAL RECIPIES PAGE 98)


C- LOOP OVER MASHES

        IF (IF1DIM.EQ.0) THEN
          NOBSVZ1=NOBSVZ-1
        ELSE
          NOBSVZ1=1
        ENDIF   !IF1DIM

          DO IY=1,NOBSVY-1
          DO IZ=1,NOBSVZ1

             IF (IF1DIM.EQ.0) THEN
                I1=IZ+NOBSVZ*(IY-1)
                I2=I1+1
                I4=I1+NOBSVZ
                I3=I4+1
             ELSE
                I1=IZ+NOBSVZ*(IY-1)
                I2=I1
                I4=I1+NOBSVZ
                I3=I4
             ENDIF   !IF1DIM

+SELF,IF=-NEWWAVE.
             Y(1)=SPEC(ISOUR,I1,IFREQ)    !INTENSITIES AT MASH POINTS
             Y(2)=SPEC(ISOUR,I2,IFREQ)
             Y(3)=SPEC(ISOUR,I3,IFREQ)
             Y(4)=SPEC(ISOUR,I4,IFREQ)
+SELF,IF=NEWWAVE.
             Y(1)=SPEC(ISOUR+NSOURCE*(I1-1+NOBSV*(IFREQ-1)))    !INTENSITIES AT MASH POINTS
             Y(2)=SPEC(ISOUR+NSOURCE*(I2-1+NOBSV*(IFREQ-1)))    !INTENSITIES AT MASH POINTS
             Y(3)=SPEC(ISOUR+NSOURCE*(I3-1+NOBSV*(IFREQ-1)))    !INTENSITIES AT MASH POINTS
             Y(4)=SPEC(ISOUR+NSOURCE*(I4-1+NOBSV*(IFREQ-1)))    !INTENSITIES AT MASH POINTS
+SELF.
             YPP1(1)=SPCOEFU(1,I1)    !SECOND DERIVATIVES WITH
             YPP1(2)=SPCOEFU(1,I2)    !RESPECT TO Z
             YPP1(3)=SPCOEFU(1,I3)
             YPP1(4)=SPCOEFU(1,I4)

             CSP=-2.D0/6.D0
             DSP=-1.D0/6.D0
             Y1(1)=-Y(1)+Y(2)+CSP*YPP1(1)+DSP*YPP1(2)
             Y1(4)=-Y(4)+Y(3)+CSP*YPP1(4)+DSP*YPP1(3)

             CSP=+1.D0/6.D0
             DSP=+2.D0/6.D0
             Y1(2)=-Y(1)+Y(2)+CSP*YPP1(1)+DSP*YPP1(2)
             Y1(3)=-Y(4)+Y(3)+CSP*YPP1(4)+DSP*YPP1(3)

             YPP2(1)=SPCOEFU(2,I1)    !SECOND DERIVATIVES WITH
             YPP2(2)=SPCOEFU(2,I2)    !RESPECT TO Y
             YPP2(3)=SPCOEFU(2,I3)
             YPP2(4)=SPCOEFU(2,I4)


             CSP=-2.D0/6.D0
             DSP=-1.D0/6.D0
             Y2(1)=-Y(1)+Y(4)+CSP*YPP2(1)+DSP*YPP2(4)
             Y2(2)=-Y(2)+Y(3)+CSP*YPP2(2)+DSP*YPP2(3)

             CSP=+1.D0/6.D0
             DSP=+2.D0/6.D0
             Y2(4)=-Y(1)+Y(4)+CSP*YPP2(1)+DSP*YPP2(4)
             Y2(3)=-Y(2)+Y(3)+CSP*YPP2(2)+DSP*YPP2(3)

             YPP3(1)=SPCOEFU(3,I1)    !DERIVATIVES WITH RESPECT
             YPP3(2)=SPCOEFU(3,I2)    !TO Z AND Y
             YPP3(3)=SPCOEFU(3,I3)
             YPP3(4)=SPCOEFU(3,I4)

             IF(IF1DIM.EQ.0) THEN
                Y12(1)=YPP3(1)-(YPP1(1)+YPP2(1))/2.D0
                Y12(2)=YPP3(2)-(YPP1(2)+YPP2(2))/2.D0
                Y12(3)=YPP3(3)-(YPP1(3)+YPP2(3))/2.D0
                Y12(4)=YPP3(4)-(YPP1(4)+YPP2(4))/2.D0
             ELSE
                Y12(1)=0.
                Y12(2)=0.
                Y12(3)=0.
                Y12(4)=0.
             ENDIF   !IF1DIM

             CALL WBCUCOF(Y,Y1,Y2,Y12,1.E0,1.E0,C)

             DO IYY=1,4
             DO IZZ=1,4
           COFOLD(IZZ,IYY,I1)=C(IZZ,IYY)
             ENDDO   !IZZ
             ENDDO   !IYY


          ENDDO   !IY
          ENDDO   !IZ

+SELF,IF=F90.
      DEALLOCATE(IOBUFF)
+SELF.
      RETURN
      END
+DECK,WPOLY2ST.
*CMZ :  3.03/00 13/07/2015  15.41.31  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.34/09 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  18.04.39  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.33  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.24.36  by  Michael Scheer
*CMZ :  2.13/03 12/01/2000  14.27.55  by  Michael Scheer
*CMZ :  1.03/06 11/06/98  18.24.32  by  Michael Scheer
*CMZ : 00.01/04 28/11/94  18.45.35  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.57.24  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.13  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE WPOLY2ST(ISTOK,IFREQ)
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,WFOLDF90U.
+SELF.

C--- DETERMINE 2D CUBIC POLYNOMIALS WHICH DESCRIBE THE INTENSITY INSIDE A
C    MASH OF THE PINHOLE
C    THE USED SR WBCUCOF STEMS FORM NUMERICAL RECIPIES (BCUCOF)
C    THE POLYNOMIAL COEFFICIENTS OF THE MASHES ARE STORED

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,PHYCON.
+SEq,wfoldf90.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.

      INTEGER ISTOK,IFREQ,IOBSV,IZ,IY,NDIA,NPL,IPL,IDIA,I1,I2,I3,I4
      INTEGER IYY,IZZ,ISS,NOBSVZ1

      DOUBLE PRECISION YPP1(4),YPP2(4),YPP3(4),CSP,DSP,YPP0,YPPN

      REAL*4 Y(4),Y1(4),Y2(4),Y12(4),C(4,4)

+SELF,IF=F90.
        ALLOCATE(IOBUFF(NOBSV))
+SELF.

C- SPLINES IN Z

      DO IZ=1,MAX(NOBSVZ,NOBSVY)
          DOBUFF1(IZ)=DFLOAT(IZ-1)
      ENDDO !IZ

        IOBSV=0
        DO IY=1,NOBSVY

        DO IZ=1,NOBSVZ

          IOBSV=IOBSV+1
+SELF,IF=-NEWWAVE.
          DOBUFF(IZ)=STOKES(ISTOK,IOBSV,IFREQ)
+SELF,IF=NEWWAVE.
          DOBUFF(IZ)=STOKES(ISTOK,IOBSV+NOBSV*(IFREQ-1))
+SELF.
        ENDDO      !IZ

           YPP0=1.D30
           YPPN=1.D30

C060793    CALL FSPLINDX(DOBUFF1,            S,NOBSVZ,YPP0,YPPN,DOBUFF2)
          CALL FSPLINDX(DOBUFF1(2)-DOBUFF1(1),DOBUFF,NOBSVZ,0.D0,0.D0,DOBUFF2)

        DO IZ=1,NOBSVZ

          SPCOEFU(1,IZ+(IY-1)*NOBSVZ)=DOBUFF2(IZ)


        ENDDO      !IZ
        ENDDO      !IY

C- SPLINES IN Y


        DO IZ=1,NOBSVZ
        DO IY=1,NOBSVY

          IOBSV=(IY-1)*NOBSVZ+IZ
+SELF,IF=-NEWWAVE.
          DOBUFF(IY)=STOKES(ISTOK,IOBSV,IFREQ)
+SELF,IF=NEWWAVE.
          DOBUFF(IY)=STOKES(ISTOK,IOBSV+NOBSV*(IFREQ-1))
+SELF.

        ENDDO      !IY

           YPP0=1.D30
           YPPN=1.D30

C060793    CALL FSPLINDX(DOBUFF1,            S,NOBSVY,YPP0,YPPN,DOBUFF2)
          CALL FSPLINDX(DOBUFF1(2)-DOBUFF1(1),DOBUFF,NOBSVY,0.D0,0.D0,DOBUFF2)

        DO IY=1,NOBSVY

          SPCOEFU(2,IZ+(IY-1)*NOBSVZ)=DOBUFF2(IY)

        ENDDO      !IY
        ENDDO      !IZ

C- SPLINES IN YZ-DIRECTION

      DO IY=1,MAX(NOBSVY,NOBSVZ)
        DOBUFF1(IY)=DSQRT(2.D0)*DFLOAT(IY-1)
      ENDDO !IY

        NDIA=NOBSVZ+NOBSVY-1  !NUMBER OF LINES ACROSS THE PINHOLE

        DO IDIA=1,NDIA

C- NUMBER OF POINTS OF CURRENT LINE

          IF (IDIA.LE.NOBSVY) THEN
         NPL=MIN(IDIA,NOBSVZ)
         DO IPL=1,NPL
             IOBSV=NOBSVY*NOBSVZ-NOBSVZ*IDIA+(IPL-1)*NOBSVZ+IPL
             IOBUFF(IPL)=IOBSV
+SELF,IF=-NEWWAVE.
                DOBUFF(IPL)=STOKES(ISTOK,IOBSV,IFREQ)
+SELF,IF=NEWWAVE.
                DOBUFF(IPL)=STOKES(ISTOK,IOBSV+NOBSV*(IFREQ-1))
+SELF.
              ENDDO   !IPL
          ELSE
         NPL=NDIA-IDIA+1

CORR 2.10.92
         NPL=MIN(NPL,NOBSVY)
CORR 2.10.92

         DO IPL=1,NPL
             IOBSV=IDIA-NOBSVY+(IPL-1)*NOBSVZ+IPL
             IOBUFF(IPL)=IOBSV
+SELF,IF=-NEWWAVE.
                DOBUFF(IPL)=STOKES(ISTOK,IOBSV,IFREQ)
+SELF,IF=NEWWAVE.
                DOBUFF(IPL)=STOKES(ISTOK,IOBSV+NOBSV*(IFREQ-1))
+SELF.
              ENDDO   !IPL
          ENDIF

           YPP0=1.D30
           YPPN=1.D30
          IF (NPL.LE.NDOBSVZ) THEN

C060793         CALL FSPLINDX(DOBUFF1,            S,NPL,YPP0,YPPN,DOBUFF2)
                  CALL FSPLINDX(DOBUFF1(2)-DOBUFF1(1),DOBUFF,NPL,0.D0,0.D0,DOBUFF2)

          ELSEIF (NPL.LE.NDOBSVY) THEN

C060793         CALL FSPLINDX(DOBUFF1,            S,NPL,YPP0,YPPN,DOBUFF2)
                CALL FSPLINDX(DOBUFF1(2)-DOBUFF1(1),DOBUFF,NPL,0.D0,0.D0,DOBUFF2)

          ELSE
             WRITE(LUNGFO,*)
             WRITE(LUNGFO,*)'*** ERROR IN WPOLY2ST ***'
             WRITE(LUNGFO,*)
     & 'SEVERE ERROR! CHECK SOURCE CODE USING THE DEBUGGER, SORRY'
             WRITE(LUNGFO,*)
             WRITE(6,*)
             WRITE(6,*)'*** ERROR IN WPOLY2ST ***'
             WRITE(6,*)
     & 'SEVERE ERROR! CHECK SOURCE CODE USING THE DEBUGGER, SORRY'
             WRITE(6,*)
             STOP
          ENDIF

          DO IPL=1,NPL

            ISS=IOBUFF(IPL)
            SPCOEFU(3,ISS)=DOBUFF2(IPL)

          ENDDO   !IPL

          ENDDO   !IDIA

C--- NOW THE COEFFICIENTS OF THE BICUBIC SPLINES (NUMERICAL RECIPIES PAGE 98)


C- LOOP OVER MASHES

          IF (IF1DIM.EQ.0) THEN
               NOBSVZ1=NOBSVZ-1
          ELSE
               NOBSVZ1=1
          ENDIF   !IF1DIM

          DO IY=1,NOBSVY-1
          DO IZ=1,NOBSVZ1

             IF (IF1DIM.EQ.0) THEN
                I1=IZ+NOBSVZ*(IY-1)
                I2=I1+1
                I4=I1+NOBSVZ
                I3=I4+1
             ELSE
                I1=IZ+NOBSVZ*(IY-1)
                I2=I1
                I4=I1+NOBSVZ
                I3=I4
             ENDIF   !IF1DIM

+SELF,IF=-NEWWAVE.
             Y(1)=STOKES(ISTOK,I1,IFREQ)    !INTENSITIES AT MASH POINTS
             Y(2)=STOKES(ISTOK,I2,IFREQ)
             Y(3)=STOKES(ISTOK,I3,IFREQ)
             Y(4)=STOKES(ISTOK,I4,IFREQ)
+SELF,IF=NEWWAVE.
             Y(1)=STOKES(ISTOK,I1+NOBSV*(IFREQ-1))    !INTENSITIES AT MASH POINTS
             Y(2)=STOKES(ISTOK,I2+NOBSV*(IFREQ-1))    !INTENSITIES AT MASH POINTS
             Y(3)=STOKES(ISTOK,I3+NOBSV*(IFREQ-1))    !INTENSITIES AT MASH POINTS
             Y(4)=STOKES(ISTOK,I4+NOBSV*(IFREQ-1))    !INTENSITIES AT MASH POINTS
+SELF.
             YPP1(1)=SPCOEFU(1,I1)    !SECOND DERIVATIVES WITH
             YPP1(2)=SPCOEFU(1,I2)    !RESPECT TO Z
             YPP1(3)=SPCOEFU(1,I3)
             YPP1(4)=SPCOEFU(1,I4)

             CSP=-2.D0/6.D0
             DSP=-1.D0/6.D0
             Y1(1)=-Y(1)+Y(2)+CSP*YPP1(1)+DSP*YPP1(2)
             Y1(4)=-Y(4)+Y(3)+CSP*YPP1(4)+DSP*YPP1(3)

             CSP=+1.D0/6.D0
             DSP=+2.D0/6.D0
             Y1(2)=-Y(1)+Y(2)+CSP*YPP1(1)+DSP*YPP1(2)
             Y1(3)=-Y(4)+Y(3)+CSP*YPP1(4)+DSP*YPP1(3)

             YPP2(1)=SPCOEFU(2,I1)    !SECOND DERIVATIVES WITH
             YPP2(2)=SPCOEFU(2,I2)    !RESPECT TO Y
             YPP2(3)=SPCOEFU(2,I3)
             YPP2(4)=SPCOEFU(2,I4)


             CSP=-2.D0/6.D0
             DSP=-1.D0/6.D0
             Y2(1)=-Y(1)+Y(4)+CSP*YPP2(1)+DSP*YPP2(4)
             Y2(2)=-Y(2)+Y(3)+CSP*YPP2(2)+DSP*YPP2(3)

             CSP=+1.D0/6.D0
             DSP=+2.D0/6.D0
             Y2(4)=-Y(1)+Y(4)+CSP*YPP2(1)+DSP*YPP2(4)
             Y2(3)=-Y(2)+Y(3)+CSP*YPP2(2)+DSP*YPP2(3)

             YPP3(1)=SPCOEFU(3,I1)    !DERIVATIVES WITH RESPECT
             YPP3(2)=SPCOEFU(3,I2)    !TO Z AND Y
             YPP3(3)=SPCOEFU(3,I3)
             YPP3(4)=SPCOEFU(3,I4)

             IF(IF1DIM.EQ.0) THEN
                Y12(1)=YPP3(1)-(YPP1(1)+YPP2(1))/2.D0
                Y12(2)=YPP3(2)-(YPP1(2)+YPP2(2))/2.D0
                Y12(3)=YPP3(3)-(YPP1(3)+YPP2(3))/2.D0
                Y12(4)=YPP3(4)-(YPP1(4)+YPP2(4))/2.D0
             ELSE
                Y12(1)=0.
                Y12(2)=0.
                Y12(3)=0.
                Y12(4)=0.
             ENDIF   !IF1DIM

             CALL WBCUCOF(Y,Y1,Y2,Y12,1.E0,1.E0,C)

             DO IYY=1,4
             DO IZZ=1,4
           COFOLD(IZZ,IYY,I1)=C(IZZ,IYY)
             ENDDO   !IZZ
             ENDDO   !IYY


          ENDDO   !IY
          ENDDO   !IZ

+SELF,IF=F90.
        DEALLOCATE(IOBUFF)
+SELF.

      RETURN
      END
+DECK,WSIGFOL.
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.56/00 25/06/2010  12.15.46  by  Michael Scheer
*CMZ :  2.55/00 10/08/2005  15.45.45  by  Michael Scheer
*CMZ :  2.51/00 14/05/2004  14.43.12  by  Michael Scheer
*CMZ :  2.47/20 01/12/2003  15.25.47  by  Michael Scheer
*CMZ :  2.37/04 05/12/2001  17.36.28  by  Michael Scheer
*CMZ :  2.34/09 18/09/2001  22.01.04  by  Michael Scheer
*CMZ :  2.16/08 29/10/2000  16.15.48  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.33  by  Michael Scheer
*CMZ :  2.16/00 09/06/2000  12.29.25  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  2.13/10 14/04/2000  14.31.40  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  14.43.05  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.17  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE WSIGFOL
+seq,gplhint.

+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,WFOLDF90U.
+SEQ,WBETAF90U.

C--- COMPUTES RMS OF 2D GAUSSIAN FOR FOLDING PROCEDURE
C    THE SIGMAS DEPEND ON DISTANCE OF OBSERVER AND SOURCE POINT

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+seq,wbetaf90.
+SEq,wfoldf90.
+SEQ,DEPOLA.
+seq,sourcef90.
+SEq,observf90.

      INTEGER ISOUR,ICEN

      DOUBLE PRECISION BETH,BETPH,BETV,BETPV,DIST2,DIST,ALFH,ALFV,GAMH,GAMV

      IF(NSOURCE.GT.LIDIMP) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)' *** ERROR IN WSIGFOL ***'
        WRITE(LUNGFO,*)'NSOURCE.GT.LIDIMP'
        WRITE(LUNGFO,*)'CHECK INPUT FILE WAVE.IN OR INCREASE DIMENSION'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)' *** ERROR IN WSIGFOL ***'
        WRITE(6,*)'NSOURCE.GT.LIDIMP'
        WRITE(6,*)'CHECK INPUT FILE WAVE.IN OR INCREASE DIMENSION'
        WRITE(6,*)
        STOP
      ENDIF

C--- CENTER OF SOURCE POINTS, BETA-FUNCTION

      DO ISOUR=1,NSOURCE

        IF (BSIGZ(ISOUR).NE.0.D0.OR.BSIGZP(ISOUR).NE.0.D0) THEN
          WSIGZ(ISOUR)=SQRT(BSIGZ(ISOUR)**2+(PINCEN(1)*BSIGZP(ISOUR))**2)
        ENDIF

        IF (BSIGY(ISOUR).NE.0.D0.OR.BSIGYP(ISOUR).NE.0.D0) THEN
          WSIGY(ISOUR)=SQRT(BSIGY(ISOUR)**2+(PINCEN(1)*BSIGYP(ISOUR))**2)
        ENDIF

        IF (WSIGZ(ISOUR).EQ.0.D0) THEN
          WRITE(LUNGFO,*)
     &      '*** WARNING IN WSIGFOL: WSIGZ(',ISOUR,') taken from WSIGZ(1)'
          WRITE(LUNGFO,*)
     &     '*** WILL BE WRONG IF DISTANCE FROM SOURCE TO OBSERVER DIFFERS'
          WSIGZ(ISOUR)=WSIGZ(1)
        ENDIF

        IF (WSIGY(ISOUR).EQ.0.D0) THEN
          WRITE(LUNGFO,*)
     &      '*** WARNING IN WSIGFOL: WSIGY(',ISOUR,') taken from WSIGY(1)'
          WRITE(LUNGFO,*)
     &     '*** WILL BE WRONG IF DISTANCE FROM SOURCE TO OBSERVER DIFFERS'
          WSIGY(ISOUR)=WSIGY(1)
        ENDIF

C--- USER DEFINED SIGMAS

        IF (ISIGUSR.NE.0) THEN

          WSIG2Z(ISOUR)=WSIGZ(ISOUR)**2
          WSIG2Y(ISOUR)=WSIGY(ISOUR)**2

        ELSE

C- DISTANCE FROM PINHOLE CENTER TO CENTER OF SOURCE

          DIST2=(SOURCEN(1,1,ISOUR)-PINCEN(1))**2
     &      +(SOURCEN(2,1,ISOUR)-PINCEN(2))**2
     &      +(SOURCEN(3,1,ISOUR)-PINCEN(3))**2
          DIST=DSQRT(DIST2)

C- BETA-FUNCTION AND DERIVATIVE

          ICEN=ISOURCEN(ISOUR)
          BETH=WBETA(2,ICEN)
          BETPH=WBETA(3,ICEN)
          BETV=WBETA(4,ICEN)
          BETPV=WBETA(5,ICEN)
          ALFH=-BETPH/2.
          GAMH=(1.+ALFH**2)/BETH
          ALFV=-BETPV/2.
          GAMV=(1.+ALFV**2)/BETV

          WSIG2Z(ISOUR)=EPS0H*(BETH+DIST2*GAMH-2.*DIST*ALFH)
          WSIG2Y(ISOUR)=EPS0V*(BETV+DIST2*GAMV-2.*DIST*ALFV)


          WSIGZ(ISOUR)=DSQRT(WSIG2Z(ISOUR))
          WSIGY(ISOUR)=DSQRT(WSIG2Y(ISOUR))

        ENDIF !ISGUSR

        IF (IF1DIM.EQ.1) THEN
          WSIGZ(ISOUR)=0.0
          DGSIGZ(ISOUR)=0.0
        ENDIF  !IF1DIM

        IF (DGSIGZ(ISOUR).EQ.0.D0) DGSIGZ(ISOUR)=DGSIGZ(1)
        IF (DGSIGY(ISOUR).EQ.0.D0) DGSIGY(ISOUR)=DGSIGY(1)

        DSIGZ(ISOUR)=WSIGZ(ISOUR)*DGSIGZ(ISOUR)
        DSIGY(ISOUR)=WSIGY(ISOUR)*DGSIGY(ISOUR)

        IF (  IF1DIM.EQ.0 .AND.
     &      (WSIGZ(ISOUR).EQ.0.0
     &      .OR.  DGSIGZ(ISOUR).EQ.0.0)
     &      ) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)' *** ERROR IN WSIGFOL ***'
          WRITE(LUNGFO,*)'ZERO WIDTH OF HORIZONTAL FOLDING FUNCTION'
          WRITE(LUNGFO,*)'CHECK WSIGZ AND DGSIGZ IN NAMELIST WFOLDN'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)' *** ERROR IN WSIGFOL ***'
          WRITE(6,*)'ZERO WIDTH OF HORIZONTAL FOLDING FUNCTION'
          WRITE(6,*)'CHECK WSIGZ AND DGSIGZ IN NAMELIST WFOLDN'
          WRITE(6,*)
          STOP
        ENDIF

        IF (
     &      WSIGY(ISOUR).EQ.0.0
     &      .OR.  DGSIGY(ISOUR).EQ.0.0
     &      ) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)' *** ERROR IN WSIGFOL ***'
          WRITE(LUNGFO,*)'ZERO WIDTH OF VERTICAL FOLDING FUNCTION'
          WRITE(LUNGFO,*)'CHECK WSIGY AND DGSIGY IN NAMELIST WFOLDN'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)' *** ERROR IN WSIGFOL ***'
          WRITE(6,*)'ZERO WIDTH OF VERTICAL FOLDING FUNCTION'
          WRITE(6,*)'CHECK WSIGY AND DGSIGY IN NAMELIST WFOLDN'
          WRITE(6,*)
          STOP
        ENDIF

      ENDDO !ISOUR

      IF(ISTOKES.NE.0 .AND. ISIGSTO.GT.NSOURCE) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)' *** ERROR IN WSIGFOL ***'
        WRITE(LUNGFO,*)'ISIGSTO GREATER THAN NUMBER OF SOURCE POINTS'
        WRITE(LUNGFO,*)'CHECK INPUT FILE WAVE.IN'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)' *** ERROR IN WSIGFOL ***'
        WRITE(6,*)'ISIGSTO GREATER THAN NUMBER OF SOURCE POINTS'
        WRITE(6,*)'CHECK INPUT FILE WAVE.IN'
        WRITE(6,*)
        STOP
      ENDIF

      RETURN
      END
+DECK,wzzpyyp.
*CMZ :  3.00/00 11/03/2013  15.09.17  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.66/13 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.53/05 12/08/2009  08.49.28  by  Michael Scheer
*CMZ :  2.47/14 16/04/2004  09.24.47  by  Michael Scheer
*CMZ :  2.47/12 30/06/2003  15.30.28  by  Michael Scheer
*CMZ :  2.16/08 29/10/2000  16.15.48  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.33  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.24.36  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  14.43.03  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  10.46.38  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.56.09  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.10  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE WZZPYYP
+seq,gplhint.

+SEQ,TRACKF90U,IF=F90.
+SEQ,WBETAF90U,IF=F90.

C--- CALCULATES z,z',y,y' in phase space relative to closed orbit from
c    beta-functions
c    K. Wille: Kapitel 3.11


C    RESULTS:

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,TRACK.
+SEQ,PHASETRACK.
+seq,wbetaf90.


      DOUBLE PRECISION ALPHA0(2),BETA0(2),X0(2),XP0(2)
      DOUBLE PRECISION ALPHA,BETA,PSI,CPSI,SPSI,RQ,RM

      INTEGER I,IC

      X0(1)=PHTRZ0
      XP0(1)=PHTRZP0
      X0(2)=PHTRY0
      XP0(2)=PHTRYP0

      ALPHA0(1)=-WBETA(3,1)/2.d0
      ALPHA0(2)=-WBETA(5,1)/2.d0
      BETA0(1)=WBETA(2,1)
      BETA0(2)=WBETA(4,1)

      DO I=1,NCO

        ALPHA=-WBETA(3,I)/2.d0
        BETA=  WBETA(2,I)
        PSI=   WBETA(8,I)
        CPSI=COS(PSI)
        SPSI=SIN(PSI)
        RQ=SQRT(BETA/BETA0(1))
        RM=SQRT(BETA*BETA0(1))
        WBZZPYYP(1,I) = RQ * (CPSI+ALPHA0(1)*SPSI) * X0(1) + RM*SPSI*XP0(1)
        WBZZPYYP(2,I) =
     &    ((ALPHA0(1)-ALPHA)*CPSI - (1.D0+ALPHA0(1)*ALPHA)*SPSI) * X0(1)/RM
     &    + (CPSI-ALPHA*SPSI) * XP0(1)/RQ

        ALPHA=-WBETA(5,I)/2.d0
        BETA=  WBETA(4,I)
        PSI=   WBETA(9,I)
        CPSI=COS(PSI)
        SPSI=SIN(PSI)
        RQ=SQRT(BETA/BETA0(2))
        RM=SQRT(BETA*BETA0(2))
        WBZZPYYP(3,I) = RQ * (CPSI+ALPHA0(2)*SPSI) * X0(2) + RM*SPSI*XP0(2)
        WBZZPYYP(4,I) =
     &    ((ALPHA0(2)-ALPHA)*CPSI - (1.D0+ALPHA0(2)*ALPHA)*SPSI) * X0(2)/RM
     &    + (CPSI-ALPHA*SPSI) * XP0(2)/RQ

      ENDDO

      OPEN(UNIT=LUNZZPYYP,FILE=FILEZZPYYP,STATUS='unknown')

        DO I=1,NCO
          WRITE(LUNZZPYYP,'(5((1PE15.5)))')WBETA(1,I),(WBZZPYYP(IC,I),IC=1,4)
        ENDDO

      CLOSE(LUNZZPYYP)

      RETURN
      END
+DECK,XYZ_SPLINE_INTER.
*CMZ :  3.02/00 24/09/2014  13.51.08  by  Michael Scheer
*CMZ :  3.01/03 19/03/2014  12.24.14  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.66/19 07/06/2011  14.08.31  by  Michael Scheer
*CMZ :  2.63/03 07/05/2008  14.17.54  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.33  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  2.10/01 16/02/99  15.25.59  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  15.14.32  by  Michael Scheer
*CMZ :  1.00/00 06/08/97  17.48.45  by  Michael Scheer
*CMZ : 00.01/08 22/06/95  10.39.53  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  10.39.41  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.50  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE XYZ_SPLINE_INTER(XA,YA,Y2A,N,X,Y,MODE,ICOUNT)
+seq,gplhint.

C---  INTERPOLATES Y(X) VIA SPLINE

C--   INPUT:

C-       N: NUMBER OF X,Y-VALUES
C-       XA:   ARRAY OF X-VALUES
C-       YA:   ARRAY OF Y-VALUES
C-       YA2:  ARRAY SPLINE COEFFICIENTS
C-       X: Y(X) IS CALCULATED
C-       MODE: CONTROL FLAG:
C-             MODE.GE.0: USE VALUES OF LAST CALL TO START WITH
C-             MODE.LT.0: NEW INITIALIZATION

C--   OUTPUT:

C-       Y: Y(X) IS CALCULATED
C-  ICOUNT: COUNTER TO CHECK CALLING

      IMPLICIT NONE

      INTEGER NOLD,N,KLO,KHI,KLOLD,K,MODE
      INTEGER ICOUNT

      DOUBLE PRECISION Y,X,XA1OLD,XANOLD,H,A,B

      DOUBLE PRECISION XA(*),YA(*),Y2A(*)

      save klold,nold,xa1old,xanold

      DATA KLOLD/1/,NOLD/-99/
      DATA XA1OLD/-9999.D0/,XANOLD/-9999./

      ICOUNT=ICOUNT+1

      IF(     XA(1).LT.XA(N).AND.(X.LT.XA(1).OR.X.GT.XA(N))
     &    .OR.
     &    XA(N).LT.XA(1).AND.(X.LT.XA(N).OR.X.GT.XA(1))) THEN
        STOP '***SR XYZ_SPLINE_INTER: X OUT OF RANGE ***'
      ENDIF

      IF ( MODE.GE.0.AND.NOLD.EQ.N) THEN
        IF (XA(1).EQ.XA1OLD
     &      .AND. XA(N).EQ.XANOLD
     &      .AND. X.GT.XA(KLOLD)
     &      ) THEN
          KLO=KLOLD
        ELSE
          KLO=1
        ENDIF
      ELSE
        KLO=1
      ENDIF

      IF (X.LT.XA(KLO+1)) THEN
      KHI=KLO+1
      GOTO 2
      ENDIF

      KHI=N
1     IF (KHI-KLO.GT.1) THEN
        K=(KHI+KLO)/2
        IF(XA(K).GT.X)THEN
          KHI=K
        ELSE
          KLO=K
        ENDIF
      GOTO 1
      ENDIF

2     H=XA(KHI)-XA(KLO)

      IF (H.LE.0.) THEN
        WRITE(6,*) '*** ERROR IN XYZ_SPLINE_INTER: BAD INPUT ***'
        STOP
      ENDIF

      A=(XA(KHI)-X)/H
      B=(X-XA(KLO))/H
      Y=A*YA(KLO)+B*YA(KHI)+
     *      ((A**3-A)*Y2A(KLO)+(B**3-B)*Y2A(KHI))*(H**2)/6.

      KLOLD=KLO
      NOLD=N
      XA1OLD=XA(1)
      XANOLD=XA(N)

      RETURN
      END
+DECK,YIELD.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.63/03 02/05/2008  14.41.00  by  Michael Scheer
*CMZ :  2.52/13 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.41/10 29/04/2004  15.29.30  by  Michael Scheer
*CMZ :  2.36/00 07/11/2001  14.28.25  by  Michael Scheer
*CMZ :  2.16/08 01/11/2000  18.41.44  by  Michael Scheer
*CMZ :  2.16/04 24/06/2000  21.14.53  by  Michael Scheer
*CMZ :  2.16/01 15/06/2000  17.07.13  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  2.12/03 07/07/99  16.16.04  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  15.36.14  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.46.17  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.49  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE YIELD(IEFFI,FREQ,ABSMU,ABSCOM)
+seq,gplhint.

C--- READS YIELD COEFFICIENTS FROM FILE CALCULATES COEFFICIENT FOR
C    GIVEN FREQUENCY

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.

      INTEGER I,ICAL,NCOEF,NDAFRQP,IERR,MODE,IEFFI

      PARAMETER(NDAFRQP=10000)

      CHARACTER(65) ABSCOM
      DOUBLE PRECISION AFREQ(NDAFRQP),ABSCO(NDAFRQP),FREQ,ABSMU
      DOUBLE PRECISION Y2(NDAFRQP),AA(NDAFRQP),BB(NDAFRQP),CC(NDAFRQP)
     &                ,C(NDAFRQP)

      DATA ICAL/0/

C--- READ DATA FILE


      IERR=0

      IF (ICAL.EQ.0) THEN
      OPEN(UNIT=LUNEFF,FILE=FILEFF,STATUS='OLD',FORM='FORMATTED')

      READ(LUNABS,'(A65)') ABSCOM
      READ(LUNABS,*) NCOEF

      IF (NCOEF.GT.NDAFRQP) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN YIELD ***'
          WRITE(LUNGFO,*)'DIMENSION EXCEEDED'
          WRITE(LUNGFO,*)'INCREASE PARAMETER NDAFRQP IN THIS ROUTINE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN YIELD ***'
          WRITE(6,*)'DIMENSION EXCEEDED'
          WRITE(6,*)'INCREASE PARAMETER NDAFRQP IN THIS ROUTINE'
          WRITE(6,*)
          STOP
      ENDIF !NCOEF

      DO I=1,NCOEF
          READ(LUNABS,*) AFREQ(I),ABSCO(I)
      ENDDO !I

      CLOSE(LUNABS)

      IF (IEFFI.GT.0) THEN
        CALL UTIL_SPLINE_COEF(AFREQ,ABSCO,NCOEF,-9999.0d0,-9999.0d0,
     &    Y2,AA,BB,CC,C)
      ENDIF   !IEFFI

      ENDIF !ICAL

      IF (IEFFI.GT.0) THEN

      IF (ICAL.EQ.0) THEN
          MODE=-1
      ELSE
          MODE=0
      ENDIF

      CALL UTIL_SPLINE_INTER(AFREQ,ABSCO,Y2,NCOEF,FREQ,ABSMU,MODE)

          IF (IERR.NE.0) THEN

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN YIELD ***'
            WRITE(LUNGFO,*)'CALL TO SR UTIL_SPLINE_INTER FAILED'
            WRITE(LUNGFO,*)'CHECK PHOTONENERGIES IN NAMELIST FREQN AND FILE'
            WRITE(LUNGFO,*)FILEFF
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)

            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN YIELD ***'
            WRITE(6,*)'CALL TO SR UTIL_SPLINE_INTER FAILED'
            WRITE(6,*)'CHECK PHOTONENERGIES IN NAMELIST FREQN AND FILE'
            WRITE(6,*)FILEFF
            WRITE(6,*)
            WRITE(6,*)

            STOP

          ENDIF   !IERR

      ELSE    !IEFFI

           IF (IEFFI.EQ.-1) THEN  !IEFFI
               CALL ABSNOSPLI(AFREQ,ABSCO,NCOEF,FREQ,ABSMU,IERR,1)
        ELSE   !IEFFI
               CALL ABSNOSPLI(AFREQ,ABSCO,NCOEF,FREQ,ABSMU,IERR,-1)
        ENDIF      !IEFFI

          IF (IERR.NE.0) THEN

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN YIELD ***'
            WRITE(LUNGFO,*)'CALL TO ABSNOSPLI FAILED'
            WRITE(LUNGFO,*)'CHECK PHOTONENERGIES IN NAMELIST FREQN AND FILE'
            WRITE(LUNGFO,*)FILEFF
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)

            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN YIELD ***'
            WRITE(6,*)'CALL TO ABSNOSPLI FAILED'
            WRITE(6,*)'CHECK PHOTONENERGIES IN NAMELIST FREQN AND FILE'
            WRITE(6,*)FILEFF
            WRITE(6,*)
            WRITE(6,*)

            STOP

          ENDIF   !IERR

      ENDIF   !IEFFI

      ICAL=1
      RETURN
      END
+DECK,zeit.
*CMZ :  3.01/02 25/02/2014  14.52.02  by  Michael Scheer
*CMZ :  2.70/06 07/01/2013  13.42.44  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  13.41.59  by  Michael Scheer
*CMZ :  2.66/20 18/10/2011  08.06.47  by  Michael Scheer
*CMZ :  2.66/18 01/12/2010  10.11.23  by  Michael Scheer
*CMZ :  2.66/13 23/11/2010  09.59.43  by  Michael Scheer
*CMZ :  2.63/00 10/01/2008  12.40.35  by  Michael Scheer
*CMZ :  2.58/01 17/01/2007  10.59.07  by  Michael Scheer
*CMZ :  2.57/04 13/01/2006  11.10.13  by  Michael Scheer
*CMZ :  2.57/03 09/12/2005  11.19.05  by  Michael Scheer
*CMZ :  2.52/15 03/01/2005  15.51.05  by  Michael Scheer
*CMZ :  2.47/22 03/12/2003  10.29.33  by  Michael Scheer
*CMZ :  2.46/02 21/01/2003  16.21.35  by  Michael Scheer
*CMZ :  2.41/09 14/08/2002  17.26.05  by  Michael Scheer
*CMZ :  2.39/00 03/01/2002  12.30.43  by  Michael Scheer
*CMZ :  2.20/01 02/01/2001  11.38.55  by  Michael Scheer
*CMZ :  2.15/00 01/05/2000  11.48.08  by  Michael Scheer
*CMZ :  2.13/04 24/01/2000  17.57.30  by  Michael Scheer
*CMZ :  2.13/00 06/10/99  16.32.34  by  Michael Scheer
*CMZ :  1.03/06 01/07/98  10.29.18  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.57.32  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.41  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE ZEIT(LUN)
+seq,gplhint.

C To determine date and time and write it to logical unit LUN

      IMPLICIT NONE
      INTEGER LUN

      CHARACTER SPACER(50)
+seq,datetime.

      DATA SPACER/50*' '/

      CALL date_and_time(dtday,dttime,dtzone,idatetime)

      WRITE(LUN,*)
      WRITE(LUN,*)SPACER,dttime(1:2),':',dttime(3:4),':',dttime(5:6),' '
     &,dtday(7:8),'.',dtday(5:6),'.',dtday(3:4)
      WRITE(LUN,*)

+self,if=-unlimited.
c      IF(dtday(3:4).NE.'13'.and.dtday(3:4).NE.'14') THEN
c        IF(dtday(5:6).EQ.'12') THEN
      IF(dtday(3:4).EQ.'15') THEN
        WRITE(6,*)
        WRITE(6,*)'*** WARNING:'
        WRITE(6,*)'Program WAVE will expire on 31.12.2015. Please get new version'
        WRITE(6,*)
        WRITE(6,*)
      ENDIF
c      ENDIF

      IF(dtday(3:4).NE.'13'.and.dtday(3:4).NE.'14') THEN
        WRITE(6,*)'Program WAVE expired..., terminating'
        STOP
      ENDIF
+self.

      RETURN
      END
+DECK,util_matrix_multiplication.
*CMZ :  2.52/05 11/08/2004  10.06.40  by  Michael Scheer
*-- Author :    Michael Scheer   21/07/2004
      subroutine util_matrix_multiplication(l,m,n,a,b,c,d)
+seq,gplhint.

      implicit none

      integer l,m,n,i,ll,nn

      double precision a(l,m),b(m,n),c(l,n),d(l,n)

      do nn=1,n
        do ll=1,l
          d(ll,nn)=0.0d0
          do i=1,n
            d(ll,nn)=d(ll,nn)+a(ll,i)*b(i,nn)
          enddo
        enddo
      enddo

      c=d

      return
      end
+DECK,bpolyint.
*CMZ :  3.05/00 25/04/2018  13.09.51  by  Michael Scheer
*CMZ :  2.52/06 19/08/2004  15.34.24  by  Michael Scheer
*CMZ :  2.52/05 16/08/2004  13.37.21  by  Michael Scheer
*CMZ :  1.02/01 09/08/2004  14.45.40  by  Michael Scheer
*CMZ :  1.02/00 28/07/2004  16.57.47  by  Michael Scheer
*-- Author :    Michael Scheer   27/07/2004
      subroutine bpolyint(kmag,xint,yint,zint,
     &  vxint,vyint,vzint,
     &  bxint,byint,bzint)
+seq,gplhint.

c literature: Elleaume, Chubar, Chavanne PAC97
c             Computing 3D Magnetic Fields form Insertion Devices

c calculates first magnetic integral for line defined by point
c      (xint,yint,zint) and vector (vxint,vyint,vzint)
c restrictions:
c     rectangular magnets only
c     line of integrations parallel to axis of block and block aligned to
c     axis of coordinate system (paper gives formulas for general
c     case of integration direction (not coded here))

c xint,yint,zint given in meter
c bxint,byint,bzint given in Tm

+seq,bwpolyederf90u.

      implicit none

      double precision xint,yint,zint,vxint,vyint,vzint,vnx,vny,vnz,vn,
     &  bxint,byint,bzint,
     &  vnxrot,vnyrot,vnzrot,
     &  vnxrota,vnyrota,vnzrota,
     &  xr(2),yr(2),zr(2),ts(3,3),
     &  tsinv(3,3),w(3),x12,x22,z12,z22,y12,y22

      double precision g(3,3),vmagrot(3),vmaglab(3),bint1(3),xxrot,yyrot,zzrot,
     &  xxint,yyint,zzint,tiny2,pi2inv,pi4inv

      parameter (pi2inv=0.159154943091895d0)
      parameter (pi4inv=0.0795774715459477d0)

      integer ical
      integer kmag,i,k

      data ical/0/

      if (ical.eq.0) then
        tiny2=tiny*tiny
        ical=1
      endif !ical

      xxint=xint*1000.0d0
      yyint=yint*1000.0d0
      zzint=zint*1000.0d0

      vn=sqrt(vxint*vxint+vyint*vyint+vzint*vzint)

      vnx=vxint/vn
      vny=vyint/vn
      vnz=vzint/vn

      bxint=0.d0
      byint=0.d0
      bzint=0.d0

      if (bpebc(7,kmag).eq.0.0d0) return

      if(bpebc(8,kmag).ne.-6) then !not rectangular magnet

        print*,'*** Warning in BPOLYINT: Non-rectangular magnet!'
        print*,'***                      not yet implemented!'
        print*,'***                      zero result returned'
        return

      else !bpebc(8,kmag).ne.-6

        vmaglab(1)=bpebc(4,kmag)
        vmaglab(2)=bpebc(5,kmag)
        vmaglab(3)=bpebc(6,kmag)

c transform everything to the nz=(0,0,1) system and rotate it parallel to x-axis

        do i=1,3
          do k=1,3
            ts(i,k)=bpetm(i,k,1,kmag)
            tsinv(i,k)=bpetm(i,k+3,1,kmag)
          enddo
        enddo

        xxrot=ts(1,1)*xxint+ts(1,2)*yyint+ts(1,3)*zzint
        yyrot=ts(2,1)*xxint+ts(2,2)*yyint+ts(2,3)*zzint
        zzrot=ts(3,1)*xxint+ts(3,2)*yyint+ts(3,3)*zzint

        vnxrot=ts(1,1)*vnx+ts(1,2)*vny+ts(1,3)*vnz
        vnyrot=ts(2,1)*vnx+ts(2,2)*vny+ts(2,3)*vnz
        vnzrot=ts(3,1)*vnx+ts(3,2)*vny+ts(3,3)*vnz

        vnxrota=abs(vnxrot)
        vnyrota=abs(vnyrot)
        vnzrota=abs(vnzrot)

        vmagrot(1)=
     &    ts(1,1)*vmaglab(1)+ts(1,2)*vmaglab(2)+ts(1,3)*vmaglab(3)
        vmagrot(2)=
     &    ts(2,1)*vmaglab(1)+ts(2,2)*vmaglab(2)+ts(2,3)*vmaglab(3)
        vmagrot(3)=
     &    ts(3,1)*vmaglab(1)+ts(3,2)*vmaglab(2)+ts(3,3)*vmaglab(3)

c dimensions of magnet

        w(1)=bperot(1,1,1,kmag)-bperot(1,2,1,kmag)
        w(2)=bperot(2,1,1,kmag)-bperot(2,3,1,kmag)
        w(3)=bperot(3,1,1,kmag)-bperot(3,1,3,kmag)

c distances from considered point to corners of magnet

        xr(1)=bperot(1,1,1,kmag)-xxrot
        xr(2)=bperot(1,2,1,kmag)-xxrot
        yr(1)=bperot(2,1,1,kmag)-yyrot
        yr(2)=bperot(2,3,1,kmag)-yyrot

        zr(1)=bperot(3,1,1,kmag)-zzrot
        zr(2)=bperot(3,1,3,kmag)-zzrot

        g=0.0d0

        if (vnxrota.lt.tiny2.and.vnyrota.lt.tiny2) then

          if (abs(xr(1)).lt.tiny2) then
            print*,'Warning in BPOLYINT: xr(1) too small'
            print*,'magnet:',kmag
            print*,'xr(1)',xr(1)
            if (xr(1).lt.0.0d0) then
              print*,'Set to',-tiny2
              xr(1)=-tiny2
            else
              print*,'Set to',tiny2
              xr(1)=tiny2
            endif
          endif


          if (abs(xr(2)).lt.tiny2) then
            print*,'Warning in BPOLYINT: xr(2) too small'
            print*,'magnet:',kmag
            print*,'xr(2)',xr(2)
            if (xr(2).lt.0.0d0) then
              print*,'Set to',-tiny2
              xr(2)=-tiny2
            else
              print*,'Set to',tiny2
              xr(2)=tiny2
            endif
          endif

          if (abs(yr(1)).lt.tiny2) then
            print*,'Warning in BPOLYINT: yr(1) too small'
            print*,'magnet:',kmag
            print*,'yr(1)',yr(1)
            if (yr(1).lt.0.0d0) then
              print*,'Set to',-tiny2
              yr(1)=-tiny2
            else
              print*,'Set to',tiny2
              yr(1)=tiny2
            endif
          endif


          if (abs(yr(2)).lt.tiny2) then
            print*,'Warning in BPOLYINT: yr(2) too small'
            print*,'magnet:',kmag
            print*,'yr(2)',yr(2)
            if (yr(2).lt.0.0d0) then
              print*,'Set to',-tiny2
              yr(2)=-tiny2
            else
              print*,'Set to',tiny2
              yr(2)=tiny2
            endif
          endif

          do i=1,2
            do k=1,2
              g(1,1)=g(1,1)+(-1)**(i+k)*atan(xr(i)/yr(k))
              g(2,2)=g(2,2)+(-1)**(i+k)*atan(yr(k)/xr(i))
            enddo !k
          enddo !i

          x12=xr(1)*xr(1)
          x22=xr(2)*xr(2)
          y12=yr(1)*yr(1)
          y22=yr(2)*yr(2)

          g(1,2)=w(3)*pi4inv*log((x12+y22)*(x22+y12)/((x12+y12)*(x22+y22)))
     &          *0.001d0 !Tmm -> Tm
          g(2,1)=g(1,2)

          g(1,1)=g(1,1)*w(3)*pi2inv
     &          *0.001d0 !Tmm -> Tm
          g(2,2)=g(2,2)*w(3)*pi2inv
     &          *0.001d0 !Tmm -> Tm

        else if (vnxrota.lt.tiny2.and.vnzrota.lt.tiny2) then

          if (abs(xr(1)).lt.tiny2) then
            print*,'Warning in BPOLYINT: xr(1) too small'
            print*,'magnet:',kmag
            print*,'xr(1)',xr(1)
            if (xr(1).lt.0.0d0) then
              print*,'Set to',-tiny2
              xr(1)=-tiny2
            else
              print*,'Set to',tiny2
              xr(1)=tiny2
            endif
          endif

          if (abs(xr(2)).lt.tiny2) then
            print*,'Warning in BPOLYINT: xr(2) too small'
            print*,'magnet:',kmag
            print*,'xr(2)',xr(2)
            if (xr(2).lt.0.0d0) then
              print*,'Set to',-tiny2
              xr(2)=-tiny2
            else
              print*,'Set to',tiny2
              xr(2)=tiny2
            endif
          endif

          if (abs(zr(1)).lt.tiny2) then
            print*,'Warning in BPOLYINT: zr(1) too small'
            print*,'magnet:',kmag
            print*,'zr(1)',zr(1)
            if (zr(1).lt.0.0d0) then
              print*,'Set to',-tiny2
              zr(1)=-tiny2
            else
              print*,'Set to',tiny2
              zr(1)=tiny2
            endif
          endif

          if (abs(zr(2)).lt.tiny2) then
            print*,'Warning in BPOLYINT: zr(2) too small'
            print*,'magnet:',kmag
            print*,'zr(2)',zr(2)
            if (zr(2).lt.0.0d0) then
              print*,'Set to',-tiny2
              zr(2)=-tiny2
            else
              print*,'Set to',tiny2
              zr(2)=tiny2
            endif
          endif

          do i=1,2
            do k=1,2
              g(1,1)=g(1,1)+(-1)**(i+k)*atan(xr(i)/zr(k))
              g(3,3)=g(3,3)+(-1)**(i+k)*atan(zr(k)/xr(i))
            enddo !k
          enddo !i

          x12=xr(1)*xr(1)
          x22=xr(2)*xr(2)
          z12=zr(1)*zr(1)
          z22=zr(2)*zr(2)

          g(1,3)=w(2)*pi4inv*log((x12+z22)*(x22+z12)/((x12+z12)*(x22+z22)))
     &          *0.001d0 !Tmm -> Tm
          g(3,1)=g(1,3)

          g(1,1)=g(1,1)*w(2)*pi2inv
     &          *0.001d0 !Tmm -> Tm
          g(3,3)=g(3,3)*w(2)*pi2inv
     &          *0.001d0 !Tmm -> Tm

        else if (vnyrota.lt.tiny2.and.vnzrota.lt.tiny2) then

          if (abs(yr(1)).lt.tiny2) then
            print*,'Warning in BPOLYINT: yr(1) too small'
            print*,'magnet:',kmag
            print*,'yr(1)',yr(1)
            if (yr(1).lt.0.0d0) then
              print*,'Set to',-tiny2
              yr(1)=-tiny2
            else
              print*,'Set to',tiny2
              yr(1)=tiny2
            endif
          endif

          if (abs(yr(2)).lt.tiny2) then
            print*,'Warning in BPOLYINT: yr(2) too small'
            print*,'magnet:',kmag
            print*,'yr(2)',yr(2)
            if (yr(2).lt.0.0d0) then
              print*,'Set to',-tiny2
              yr(2)=-tiny2
            else
              print*,'Set to',tiny2
              yr(2)=tiny2
            endif
          endif

          if (abs(zr(1)).lt.tiny2) then
            print*,'Warning in BPOLYINT: zr(1) too small'
            print*,'magnet:',kmag
            print*,'zr(1)',zr(1)
            if (zr(1).lt.0.0d0) then
              print*,'Set to',-tiny2
              zr(1)=-tiny2
            else
              print*,'Set to',tiny2
              zr(1)=tiny2
            endif
          endif

          if (abs(zr(2)).lt.tiny2) then
            print*,'Warning in BPOLYINT: zr(2) too small'
            print*,'magnet:',kmag
            print*,'zr(2)',zr(2)
            if (zr(2).lt.0.0d0) then
              print*,'Set to',-tiny2
              zr(2)=-tiny2
            else
              print*,'Set to',tiny2
              zr(2)=tiny2
            endif
          endif

          do i=1,2
            do k=1,2
              g(2,2)=g(2,2)+(-1)**(i+k)*atan(yr(i)/zr(k))
              g(3,3)=g(3,3)+(-1)**(i+k)*atan(zr(k)/yr(i))
            enddo !k
          enddo !i

          y12=yr(1)*yr(1)
          y22=yr(2)*yr(2)
          z12=zr(1)*zr(1)
          z22=zr(2)*zr(2)

          g(2,3)=w(1)*pi4inv*log((y12+z22)*(y22+z12)/((y12+z12)*(y22+z22)))
     &          *0.001d0 !Tmm -> Tm
          g(3,2)=g(2,3)

          g(2,2)=g(2,2)*w(1)*pi2inv
     &          *0.001d0 !Tmm -> Tm
          g(3,3)=g(3,3)*w(1)*pi2inv
     &          *0.001d0 !Tmm -> Tm

        else ! vnxrot,vnyrot,vnzot parallel to an axis

          print*,'*** Warning in BPOLYINT:'
          print*,
     &      '*** line of integration not parallel to axis of coord.-system!'
          print*,'*** not yet implemented!'
          print*,'*** zero result returned'
          return

        endif ! vnxrot,vnyrot,vnzrot parallel to an axis

        bint1(1)=(g(1,1)*vmagrot(1)+g(1,2)*vmagrot(2)+g(1,3)*vmagrot(3))
        bint1(2)=(g(2,1)*vmagrot(1)+g(2,2)*vmagrot(2)+g(2,3)*vmagrot(3))
        bint1(3)=(g(3,1)*vmagrot(1)+g(3,2)*vmagrot(2)+g(3,3)*vmagrot(3))

        bxint=tsinv(1,1)*bint1(1)+tsinv(1,2)*bint1(2)+tsinv(1,3)*bint1(3)
        byint=tsinv(2,1)*bint1(1)+tsinv(2,2)*bint1(2)+tsinv(2,3)*bint1(3)
        bzint=tsinv(3,1)*bint1(1)+tsinv(3,2)*bint1(2)+tsinv(3,3)*bint1(3)

      endif !(bpebc(8,kmag).eq.1)

      return
      end
+DECK,bpolyintnum.
*CMZ :  3.05/00 25/04/2018  13.09.51  by  Michael Scheer
*CMZ :  2.52/05 16/08/2004  13.37.21  by  Michael Scheer
*CMZ :  1.02/00 28/07/2004  15.02.40  by  Michael Scheer
*-- Author :    Michael Scheer   27/07/2004
      subroutine bpolyintnum(kmag,xint,yint,zint,
     &  vxint,vyint,vzint,
     &  bxint,byint,bzint)
+seq,gplhint.

c calculates numerically first magnetic integral for line defined by point
c      (xint,yint,zint) and vector (vxint,vyint,vzint) in the range
c      ranginti->ranginte with nstepint steps

c xint,yint,zint given in meter
c bxint,byint,bzint given in Tm

+seq,bwpolyederf90u.

      implicit none

      double precision xint,yint,zint,vxint,vyint,vzint,vnx,vny,vnz,vn,
     &  bxint,byint,bzint,xx,yy,zz,ds,ds2,bxi(4),byi(4),bzi(4),tiny2,x,y,z,
     &  bx,by,bz

      integer ical,i
      integer kmag

      data ical/0/

      if (ical.eq.0) then
        tiny2=tiny*tiny
        ical=1
      endif !ical

      vn=sqrt(vxint*vxint+vyint*vyint+vzint*vzint)

      vnx=vxint/vn
      vny=vyint/vn
      vnz=vzint/vn

      bxint=0.d0
      byint=0.d0
      bzint=0.d0

      bxi=0.0d0
      byi=0.0d0
      bzi=0.0d0

      if (nstepint.le.0.or.bpebc(7,kmag).eq.0.0d0) return

      nstepint=max(nstepint,4)/2*2+1
      ds=(ranginte-ranginti)/(nstepint-1)*0.001d0
      ds2=2.0d0*ds

      if (vnx.lt.tiny2.and.vny.lt.tiny2) then

        x=xint
        y=yint

        z=ranginti*0.001d0
        call bpolyeder1(kmag,x,y,z,bx,by,bz)
        bxi(1)=bx/3.0d0
        byi(1)=by/3.0d0
        bzi(1)=bz/3.0d0

        z=ranginte*0.001d0
        call bpolyeder1(kmag,x,y,z,bx,by,bz)
        bxi(4)=bx/3.0d0
        byi(4)=by/3.0d0
        bzi(4)=bz/3.0d0

        z=ranginti*0.001d0-ds
        do i=2,nstepint-1,2
          z=z+ds2
          call bpolyeder1(kmag,x,y,z,bx,by,bz)
          bxi(2)=bxi(2)+bx
          byi(2)=byi(2)+by
          bzi(2)=bzi(2)+bz
        enddo

        z=ranginti*0.001d0
        do i=3,nstepint-2,2
          z=z+ds2
          call bpolyeder1(kmag,x,y,z,bx,by,bz)
          bxi(3)=bxi(3)+bx
          byi(3)=byi(3)+by
          bzi(3)=bzi(3)+bz
        enddo

        bxint=
     &    (bxi(1)/3.0d0+4.0d0/3.0d0*bxi(2)+2.0d0/3.0d0*bxi(3)+bxi(4)/3.0d0)*ds
        byint=
     &    (byi(1)/3.0d0+4.0d0/3.0d0*byi(2)+2.0d0/3.0d0*byi(3)+bxi(4)/3.0d0)*ds
        bzint=
     &    (bzi(1)/3.0d0+4.0d0/3.0d0*bzi(2)+2.0d0/3.0d0*bzi(3)+bxi(4)/3.0d0)*ds

      else if (vnx.lt.tiny2.and.vnz.lt.tiny2) then

        x=xint
        z=zint

        y=ranginti*0.001d0
        call bpolyeder1(kmag,x,y,z,bx,by,bz)
        bxi(1)=bx/3.0d0
        byi(1)=by/3.0d0
        bzi(1)=bz/3.0d0

        y=ranginte*0.001d0
        call bpolyeder1(kmag,x,y,z,bx,by,bz)
        bxi(4)=bx/3.0d0
        byi(4)=by/3.0d0
        bzi(4)=bz/3.0d0

        y=ranginti*0.001d0-ds
        do i=2,nstepint-1,2
          y=y+ds2
          call bpolyeder1(kmag,x,y,z,bx,by,bz)
          bxi(2)=bxi(2)+bx
          byi(2)=byi(2)+by
          bzi(2)=bzi(2)+bz
        enddo

        y=ranginti*0.001d0
        do i=3,nstepint-2,2
          y=y+ds2
          call bpolyeder1(kmag,x,y,z,bx,by,bz)
          bxi(3)=bxi(3)+bx
          byi(3)=byi(3)+by
          bzi(3)=bzi(3)+bz
        enddo

        bxint=
     &    (bxi(1)/3.0d0+4.0d0/3.0d0*bxi(2)+2.0d0/3.0d0*bxi(3)+bxi(4)/3.0d0)*ds
        byint=
     &    (byi(1)/3.0d0+4.0d0/3.0d0*byi(2)+2.0d0/3.0d0*byi(3)+bxi(4)/3.0d0)*ds
        bzint=
     &    (bzi(1)/3.0d0+4.0d0/3.0d0*bzi(2)+2.0d0/3.0d0*bzi(3)+bxi(4)/3.0d0)*ds

      else if (vny.lt.tiny2.and.vnz.lt.tiny2) then

        y=yint
        z=zint

        x=ranginti*0.001d0
        call bpolyeder1(kmag,x,y,z,bx,by,bz)
        bxi(1)=bx/3.0d0
        byi(1)=by/3.0d0
        bzi(1)=bz/3.0d0

        x=ranginte*0.001d0
        call bpolyeder1(kmag,x,y,z,bx,by,bz)
        bxi(4)=bx/3.0d0
        byi(4)=by/3.0d0
        bzi(4)=bz/3.0d0

        x=ranginti*0.001d0-ds
        do i=2,nstepint-1,2
          x=x+ds2
          call bpolyeder1(kmag,x,y,z,bx,by,bz)
          bxi(2)=bxi(2)+bx
          byi(2)=byi(2)+by
          bzi(2)=bzi(2)+bz
        enddo

        x=ranginti*0.001d0
        do i=3,nstepint-2,2
          x=x+ds2
          call bpolyeder1(kmag,x,y,z,bx,by,bz)
          bxi(3)=bxi(3)+bx
          byi(3)=byi(3)+by
          bzi(3)=bzi(3)+bz
        enddo

        bxint=
     &    (bxi(1)/3.0d0+4.0d0/3.0d0*bxi(2)+2.0d0/3.0d0*bxi(3)+bxi(4)/3.0d0)*ds
        byint=
     &    (byi(1)/3.0d0+4.0d0/3.0d0*byi(2)+2.0d0/3.0d0*byi(3)+bxi(4)/3.0d0)*ds
        bzint=
     &    (bzi(1)/3.0d0+4.0d0/3.0d0*bzi(2)+2.0d0/3.0d0*bzi(3)+bxi(4)/3.0d0)*ds

      else ! vnxrot,vnyrot,vnzot parallel to an axis

          print*,'*** Warning in BPOLYINTNUM:'
          print*,
     & '*** line of integration not parallel to axis of coord.-system!'
          print*,'*** not yet implemented!'
          print*,'*** zero result returned'
          return

        endif ! vnxrot,vnyrot,vnzrot parallel to an axis

      return
      end
+DECK,bpolyeder1.
*CMZ :  3.05/00 25/04/2018  13.09.51  by  Michael Scheer
*CMZ :  2.63/05 22/07/2009  09.14.31  by  Michael Scheer
*CMZ :  2.52/05 17/08/2004  12.50.56  by  Michael Scheer
*CMZ :  1.02/01 09/08/2004  14.48.51  by  Michael Scheer
*CMZ :  1.02/00 27/07/2004  13.36.14  by  Michael Scheer
*CMZ :  1.01/01 22/07/2004  13.27.23  by  Michael Scheer
*CMZ :  1.00/00 26/02/2004  17.30.03  by  Michael Scheer
*CMZ :  0.99/07 16/02/2004  16.00.03  by  Michael Scheer
*CMZ :  0.99/03 12/02/2004  10.51.58  by  Michael Scheer
*CMZ :  0.99/01 11/02/2004  13.42.37  by  Michael Scheer
*CMZ :  0.99/00 29/01/2004  12.50.00  by  Michael Scheer
*CMZ :  0.00/08 23/01/2004  15.23.23  by  Michael Scheer
*CMZ :  0.00/07 20/01/2004  16.45.51  by  Michael Scheer
*CMZ :  0.00/06 16/01/2004  10.43.52  by  Michael Scheer
*CMZ :  0.00/05 23/12/2003  16.07.01  by  Michael Scheer
*CMZ :  0.00/04 23/12/2003  10.43.15  by  Michael Scheer
*CMZ :  0.00/02 15/12/2003  12.43.34  by  Michael Scheer
*CMZ :  0.00/01 10/12/2003  17.56.52  by  Michael Scheer
*-- Author :    Michael Scheer   02/12/2003
      subroutine bpolyeder1(mag1,xin,yin,zin,bxout,byout,bzout)
+seq,gplhint.
c
c single magnet (mag1) version of bpolyeder
c

+seq,bwpolyederf90u.

      implicit none

      double precision win2

      double precision xin,yin,zin,bxout,byout,bzout

      double precision r1(3),r2(3),dlab(3),blab(3)
      double precision ts(3,3),tsinv(3,3),bplan(3),bcvn,vnormlab(3)
      double precision xx,yy,zz,xxrot,yyrot,zzrot
      double precision a,b,z,qx,qy,qz,pi4inv,reverse,tiny2
      double precision q(3,3),vmagrot(3),vmaglab(3),h(3),
     &  xr(2),yr(2),zr(2),dum,dume

      parameter (pi4inv=0.0795774715459477d0)

      integer ical
      integer iout,mag1
      integer imag,iplan,icorn,i,j,k,ip2,kwarn,kwarntot,lwarn,lwarnmax,mwarn

      data ical/0/
      data lwarnmax/20/
      data lwarn/0/

      kwarntot=0
      mwarn=0

      if (ical.eq.0) then
      win2=winpm*500.d0
        tiny2=tiny*tiny
        ical=1
      endif !ical

c calculate field at (xin,yin,zin)

      xx=xin*1000.0d0
      yy=yin*1000.0d0
      zz=zin*1000.0d0

1     continue

      if (kwarn.gt.1) then
        lwarn=lwarn+1
        mwarn=mwarn+1
        if (mwarn.gt.1000) then
            print *,'*** Warning in BPOLYEDER1: Endless loop?'
            print *,'x,y,z (mm): '
            print *,xx,yy,zz
            print *,'Bx,By,Bz: '
            print *,bxout,byout,bzout
            print *,'*** Questionable data written to polymag.err'
            print *,'*** Field set to zero!'
            print *,'------------------------------------------'
            bxout=0.0d0
            byout=0.0d0
            bzout=0.0d0
            return
        endif
        xx=xx+tiny
        yy=yy+tiny
        zz=zz+tiny
      endif !kwarn.gt.1

      bxout=0.d0
      byout=0.d0
      bzout=0.d0

      imag=mag1
c1      do imag=kmag1,nmag

        if (abs(xx-bpexpos(imag)).gt.win2) goto 999

        if (bpebc(7,imag).ne.0.0d0) then !non-zero magnetization

          if(bpebc(8,imag).eq.1) then !not rectangular magnet

c check, if we are inside of magnet; we assume convex shape

            iout=-1

            do iplan=1,ibpeplan(imag)

              dlab(1)=xx-bpemag(1,1,iplan,imag)
              dlab(2)=yy-bpemag(2,1,iplan,imag)
              dlab(3)=zz-bpemag(3,1,iplan,imag)

              vnormlab(1)=bpetm(1,8,iplan,imag)
              vnormlab(2)=bpetm(2,8,iplan,imag)
              vnormlab(3)=bpetm(3,8,iplan,imag)

              if( dlab(1)*vnormlab(1)+dlab(2)*vnormlab(2)+
     &            dlab(3)*vnormlab(3).gt.0.d0) then
                iout=1
                goto 9
              endif

            enddo !iplan

9           continue

            do iplan=1,ibpeplan(imag)

              bcvn=-bpetm(1,7,iplan,imag)*pi4inv

              bplan(1)=0.d0
              bplan(2)=0.d0
              bplan(3)=0.d0

c transform everything to the nz=(0,0,1) system

              if (ibpecorn(iplan,imag).gt.0) then

                do i=1,3
                  do j=1,3
                    ts(i,j)=bpetm(i,j,iplan,imag)
                    tsinv(i,j)=bpetm(i,j+3,iplan,imag)
                  enddo
                enddo

                xxrot=ts(1,1)*xx+ts(1,2)*yy+ts(1,3)*zz
                yyrot=ts(2,1)*xx+ts(2,2)*yy+ts(2,3)*zz
                zzrot=ts(3,1)*xx+ts(3,2)*yy+ts(3,3)*zz

                do icorn=1,ibpecorn(iplan,imag)-1

                  ip2=icorn+1

                  r1(1)=bperot(1,icorn,iplan,imag)-xxrot
                  r1(2)=bperot(2,icorn,iplan,imag)-yyrot
                  r1(3)=bperot(3,icorn,iplan,imag)-zzrot

                  r2(1)=bperot(1,ip2,iplan,imag)-xxrot
                  r2(2)=bperot(2,ip2,iplan,imag)-yyrot
                  r2(3)=bperot(3,ip2,iplan,imag)-zzrot

                  if (abs(r1(1)-r2(1)).gt.tiny) then

                    a=(r2(2)-r1(2))/(r2(1)-r1(1))
                    b=r1(2)-a*r1(1)

                    if (a.lt.tiny2) then
                      a=0.0d0
                      b=r1(2)
                    endif

                    z=r1(3)

                    call bpeq(r1(1),r2(1),a,b,z,qx,qy,qz,
     &                tiny,reverse,kwarn)

                    if (kwarn.eq.1) then
                      kwarntot=1
                    else if (kwarn.gt.1) then
                      kwarntot=2
                      goto 1
                    endif

                    bplan(1)=bplan(1)-qx*bcvn
                    bplan(2)=bplan(2)-qy*bcvn
                    bplan(3)=bplan(3)-qz*bcvn

                  endif !(abs(r1(1)-r2(1)).gt.tiny)

                enddo !icorn=1,ncorn

                blab(1)=tsinv(1,1)*bplan(1)+tsinv(1,2)*bplan(2)+tsinv(1,3)*bplan(3)
                blab(2)=tsinv(2,1)*bplan(1)+tsinv(2,2)*bplan(2)+tsinv(2,3)*bplan(3)
                blab(3)=tsinv(3,1)*bplan(1)+tsinv(3,2)*bplan(2)+tsinv(3,3)*bplan(3)

                bxout=bxout+blab(1)
                byout=byout+blab(2)
                bzout=bzout+blab(3)

              endif !magnetization parallel to normal vector

            enddo ! iplan=1,nplan

            if (iout.eq.-1) then
              bxout=bxout+bpebc(4,imag)
              byout=byout+bpebc(5,imag)
              bzout=bzout+bpebc(6,imag)
                print *
                print *,'*** Error in BPOLYEDER: Inside Magnet! ***'
                print *,'imag,x,y,z (mm): ',imag,sngl(xx),sngl(yy),sngl(zz)
                print*
                stop '*** program WAVE aborted ***'
            endif !iout

          else !bpebc(8,imag) .eq. 1

c rectangular magnet
c check, if we are inside of magnet; we assume convex shape

            iout=-1

            do iplan=1,ibpeplan(imag)

              dlab(1)=xx-bpemag(1,1,iplan,imag)
              dlab(2)=yy-bpemag(2,1,iplan,imag)
              dlab(3)=zz-bpemag(3,1,iplan,imag)

              vnormlab(1)=bpetm(1,8,iplan,imag)
              vnormlab(2)=bpetm(2,8,iplan,imag)
              vnormlab(3)=bpetm(3,8,iplan,imag)

              if( dlab(1)*vnormlab(1)+dlab(2)*vnormlab(2)+
     &            dlab(3)*vnormlab(3).gt.0.d0) then
                iout=1
                goto 91
              endif

            enddo !iplan

91          continue

+self,if=-noqmat.

            vmaglab(1)=bpebc(4,imag)
            vmaglab(2)=bpebc(5,imag)
            vmaglab(3)=bpebc(6,imag)

c transform everything to the nz=(0,0,1) system and rotate it parallel to x-axis

            do i=1,3
              do j=1,3
                ts(i,j)=bpetm(i,j,1,imag)
                tsinv(i,j)=bpetm(i,j+3,1,imag)
              enddo
            enddo

            xxrot=ts(1,1)*xx+ts(1,2)*yy+ts(1,3)*zz
            yyrot=ts(2,1)*xx+ts(2,2)*yy+ts(2,3)*zz
            zzrot=ts(3,1)*xx+ts(3,2)*yy+ts(3,3)*zz

            vmagrot(1)=
     &        ts(1,1)*vmaglab(1)+ts(1,2)*vmaglab(2)+ts(1,3)*vmaglab(3)
            vmagrot(2)=
     &        ts(2,1)*vmaglab(1)+ts(2,2)*vmaglab(2)+ts(2,3)*vmaglab(3)
            vmagrot(3)=
     &        ts(3,1)*vmaglab(1)+ts(3,2)*vmaglab(2)+ts(3,3)*vmaglab(3)

            xr(1)=bperot(1,1,1,imag)-xxrot
            xr(2)=bperot(1,2,1,imag)-xxrot
            yr(1)=bperot(2,1,1,imag)-yyrot
            yr(2)=bperot(2,3,1,imag)-yyrot

            zr(1)=bperot(3,1,1,imag)-zzrot
            zr(2)=bperot(3,1,3,imag)-zzrot

            if (abs(xr(2)-xr(1)).lt.tiny) then
              print*,'abs(xr(2)-xr(1)).lt.tiny'
            endif

            if (abs(yr(2)-yr(1)).lt.tiny) then
              print*,'abs(yr(2)-yr(1)).lt.tiny'
            endif

            if (abs(zr(2)-zr(1)).lt.tiny) then
              print*,'abs(zr(2)-zr(1)).lt.tiny'
            endif

            kwarn=0

            if (
     &          abs(xr(1)).lt.tiny.or.
     &          abs(xr(2)).lt.tiny.or.
     &          abs(yr(1)).lt.tiny.or.
     &          abs(yr(2)).lt.tiny.or.
     &          abs(zr(1)).lt.tiny.or.
     &          abs(zr(2)).lt.tiny) then
              kwarn=10
              kwarntot=3
              goto 1
            endif

            q(1,1)=0.0d0
            q(2,2)=0.0d0
            q(3,3)=0.0d0

            q(1,2)=1.0d0
            q(1,3)=1.0d0
            q(2,3)=1.0d0

            do i=1,2
              do j=1,2
                do k=1,2

                  q(1,1)=q(1,1)+
     &              (-1)**(i+j+k+1)*
     &              atan(
     &              yr(j)/xr(i)*zr(k)/
     &              sqrt(xr(i)**2+yr(j)**2+zr(k)**2)
     &              )

                  q(2,2)=q(2,2)+
     &              (-1)**(i+j+k+1)*
     &              atan(
     &              xr(j)/yr(i)*zr(k)/
     &              sqrt(yr(i)**2+xr(j)**2+zr(k)**2)
     &              )

                  q(3,3)=q(3,3)+
     &              (-1)**(i+j+k+1)*
     &              atan(
     &              yr(j)/zr(i)*xr(k)/
     &              sqrt(zr(i)**2+yr(j)**2+xr(k)**2)
     &              )

                  dum=zr(k)+sqrt(xr(i)**2+yr(j)**2+zr(k)**2)
                  dume=(-1.0d0)**(i+j+k)

                  if (dum.ne.0.0d0) then
                    if (dume.gt.0.0d0) then
                      q(1,2)=q(1,2)*dum
                    else
                      q(1,2)=q(1,2)/dum
                    endif
                  endif

                  dum=yr(k)+sqrt(xr(i)**2+zr(j)**2+yr(k)**2)
                  if (dum.ne.0.0d0) then
                    if (dume.gt.0.0d0) then
                      q(1,3)=q(1,3)*dum
                    else
                      q(1,3)=q(1,3)/dum
                    endif
                  endif

                  dum=xr(k)+sqrt(zr(i)**2+yr(j)**2+xr(k)**2)
                  if (dum.ne.0.0d0) then
                    if (dume.gt.0.0d0) then
                      q(2,3)=q(2,3)*dum
                    else
                      q(2,3)=q(2,3)/dum
                    endif
                  endif

                enddo !k
              enddo !j
            enddo !i

            if (
     &          q(1,2).lt.tiny2.or.
     &          q(1,3).lt.tiny2.or.
     &          q(2,3).lt.tiny2) then
              kwarn=10
              kwarntot=10
              goto 1
            endif

            q(1,2)=log(q(1,2))
            q(1,3)=log(q(1,3))
            q(2,3)=log(q(2,3))

            q(2,1)=q(1,2)
            q(3,1)=q(1,3)
            q(3,2)=q(2,3)

            h(1)=
     &        -(q(1,1)*vmagrot(1)+q(1,2)*vmagrot(2)+q(1,3)*vmagrot(3))*
     &        pi4inv
            h(2)=
     &        -(q(2,1)*vmagrot(1)+q(2,2)*vmagrot(2)+q(2,3)*vmagrot(3))*
     &        pi4inv
            h(3)=
     &        -(q(3,1)*vmagrot(1)+q(3,2)*vmagrot(2)+q(3,3)*vmagrot(3))*
     &        pi4inv

            bplan(1)=h(1)
            bplan(2)=h(2)
            bplan(3)=h(3)

            blab(1)=tsinv(1,1)*bplan(1)+tsinv(1,2)*bplan(2)+tsinv(1,3)*bplan(3)
            blab(2)=tsinv(2,1)*bplan(1)+tsinv(2,2)*bplan(2)+tsinv(2,3)*bplan(3)
            blab(3)=tsinv(3,1)*bplan(1)+tsinv(3,2)*bplan(2)+tsinv(3,3)*bplan(3)

            bxout=bxout+blab(1)
            byout=byout+blab(2)
            bzout=bzout+blab(3)

+self,if=noqmat.

            do iplan=1,ibpeplan(imag)

              bcvn=-bpetm(1,7,iplan,imag)*pi4inv

              bplan(1)=0.d0
              bplan(2)=0.d0
              bplan(3)=0.d0

c transform everything to the nz=(0,0,1) system and rotate it parallel to x-axis

              if (ibpecorn(iplan,imag).gt.0) then

                do i=1,3
                  do j=1,3
                    ts(i,j)=bpetm(i,j,iplan,imag)
                    tsinv(i,j)=bpetm(i,j+3,iplan,imag)
                  enddo
                enddo

                xxrot=ts(1,1)*xx+ts(1,2)*yy+ts(1,3)*zz
                yyrot=ts(2,1)*xx+ts(2,2)*yy+ts(2,3)*zz
                zzrot=ts(3,1)*xx+ts(3,2)*yy+ts(3,3)*zz

                x1=bperot(1,1,iplan,imag)-xxrot
                x2=bperot(1,2,iplan,imag)-xxrot
                y1=bperot(2,1,iplan,imag)-yyrot
                y2=bperot(2,3,iplan,imag)-yyrot

                z=bperot(3,1,iplan,imag)-zzrot

                if (abs(x2-x1).gt.tiny) then

                  if (abs(z).lt.tiny) z=sign(tiny,z)

                  x12=x1*x1
                  x22=x2*x2
                  y12=y1*y1
                  y22=y2*y2
                  z2=z*z

                  x12z2=x12+z2
                  x22z2=x22+z2
                  y12z2=y12+z2
                  y22z2=y22+z2

                  sqx12z2y12=Sqrt(x12z2 + y12)
                  sqx12z2y22=Sqrt(x12z2 + y22)
                  sqx22z2y12=Sqrt(x22z2 + y12)
                  sqx22z2y22=Sqrt(x22z2 + y22)

                  qx=
     &              log(
     &              ((y1 + sqx22z2y12)*(y2 + sqx12z2y22))/
     &              ((y2 + sqx22z2y22)*(y1 + sqx12z2y12))
     &              )

                  qy=
     &              log(
     &              ((x1 + sqx12z2y22)*(x2 + sqx22z2y12))/
     &              ((x2 + sqx22z2y22)*(x1 + sqx12z2y12))
     &              )

                  qz=
     &               atan((x1*y1)/(z*sqx12z2y12))
     &              -atan((x2*y1)/(z*sqx22z2y12))
     &              -atan((x1*y2)/(z*sqx12z2y22))
     &              +atan((x2*y2)/(z*sqx22z2y22))

                  bplan(1)=bplan(1)+qx*bcvn
                  bplan(2)=bplan(2)+qy*bcvn
                  bplan(3)=bplan(3)+qz*bcvn

                endif !(abs(r1(1)-r2(1)).gt.tiny)

                blab(1)=tsinv(1,1)*bplan(1)+tsinv(1,2)*bplan(2)+tsinv(1,3)*bplan(3)
                blab(2)=tsinv(2,1)*bplan(1)+tsinv(2,2)*bplan(2)+tsinv(2,3)*bplan(3)
                blab(3)=tsinv(3,1)*bplan(1)+tsinv(3,2)*bplan(2)+tsinv(3,3)*bplan(3)

                bxout=bxout+blab(1)
                byout=byout+blab(2)
                bzout=bzout+blab(3)

              endif !magnetization parallel to normal vector

            enddo ! iplan=1,nplan

            print*,bxout
            print*,byout
            print*,bzout
            print*
+self. !if=noqmat.

            if (iout.eq.-1) then
              bxout=bxout+bpebc(4,imag)
              byout=byout+bpebc(5,imag)
              bzout=bzout+bpebc(6,imag)
              print *
              print *,'*** Error in BPOLYEDER: Inside Magnet! ***'
              print *,'imag,x,y,z (mm): ',imag,sngl(xx),sngl(yy),sngl(zz)
              print*
              stop '*** program WAVE aborted ***'
            endif !iout

          endif !(bpebc(8,imag).eq.1)

        endif !non-zero magnetization

c      enddo !imag=1,nmag

999   continue

      bxout=bxout*bscalepm
      byout=byout*bscalepm
      bzout=bzout*bscalepm

      if (kwarntot.ne.0.and.lwarn.lt.lwarnmax) then
        print *
        print *,'x,y,z (mm): '
        print *,xx,yy,zz
        print *,'Bx,By,Bz: '
        print *,bxout,byout,bzout
        print *,'*** Questionable data written to polymag.err'
        print *,'------------------------------------------'
      endif

      if (lwarn.eq.lwarnmax) then
        lwarn=lwarn+1
        print *
        print *,'*** Maximum number of printed warning reached!!'
        print *,'*** Questionable data written to polymag.err'
        print *,'------------------------------------------'
      endif

      if (kwarntot.ne.0) then
        write(34,'(6e15.5)')
     &    sngl(xin),sngl(yin),sngl(zin),
     &    sngl(bxout),sngl(byout),sngl(bzout)
      endif

      return
      end
+DECK,bpolypl2.
*CMZ :  3.06/00 15/02/2019  14.44.39  by  Michael Scheer
*CMZ :  3.05/00 25/04/2018  13.09.51  by  Michael Scheer
*CMZ :  3.02/00 09/10/2014  14.11.09  by  Michael Scheer
*CMZ :  2.52/05 16/08/2004  15.08.37  by  Michael Scheer
*-- Author :    Michael Scheer   16/08/2004
      subroutine bpolypl2(xpl,ypl,col,ixyz)
+seq,gplhint.

+seq,bwpolyederf90u.

      implicit none

+seq,bforce.

      real xpl(2), ypl(2), x(2), y(2), col,
     &  rmtyp20,rmtyp24,rmtyp31

      integer ixyz

+self,if=higz.
      data rmtyp20/20./
      data rmtyp24/24./
      data rmtyp31/31./
+self,if=-higz.
      data rmtyp20/20./
      data rmtyp24/-9999./
      data rmtyp31/31./
+self.

      if (nbforcx*nbforcy*nbforcz.eq.0) return

      call muwk(0,0)

      call mgset('PLCI',col)
      call mgset('PMCI',col)
      call mgset('MTYP',rmtyp24)
      call mgset('MSCF',0.1)

      if (ixyz.eq.12) then
        x(1)=torqcenxmm
        y(1)=torqcenymm
      else if (ixyz.eq.13) then
        x(1)=torqcenxmm
        y(1)=torqcenzmm
      else if (ixyz.eq.23) then
        x(1)=torqcenzmm
        y(1)=torqcenymm
      endif
      call mpm(1,x,y)
      call mgset('PMCI',1.)

      x(1)=xpl(1)
      x(2)=xpl(2)
      y(1)=ypl(1)
      y(2)=ypl(1)
      call mpl(2,x,y)

      x(1)=xpl(1)
      x(2)=xpl(1)
      y(1)=ypl(1)
      y(2)=ypl(2)
      call mpl(2,x,y)

      x(1)=xpl(1)
      x(2)=xpl(2)
      y(1)=ypl(2)
      y(2)=ypl(2)
      call mpl(2,x,y)

      x(1)=xpl(2)
      x(2)=xpl(2)
      y(1)=ypl(1)
      y(2)=ypl(2)
      call mpl(2,x,y)

      call muwk(0,0)

      return
      end
+DECK,UTIL_CHECK_MONOTON.
*CMZ :  2.52/09 26/10/2004  11.55.46  by  Michael Scheer
*-- Author :    Michael Scheer   26/10/2004
      SUBROUTINE UTIL_CHECK_MONOTON(N,X,IMONO)
+seq,gplhint.

C     Returns IMONO: 2 for strictly raising,
C                    1 for raising,
C                    0 not monoton or const.
C                   -1 for falling,
C                   -2 for strictly falling,


      IMPLICIT NONE

      INTEGER I,N,IMONO,IMONO0,IUP
      DOUBLE PRECISION X(N)

      IUP=0
      DO I=1,N
        IF (X(1).LT.X(I)) THEN
          IUP=1
          GOTO 1
        ELSE IF (X(1).GT.X(I)) THEN
          IUP=-1
          GOTO 1
        ENDIF
      ENDDO

1     IMONO0=0
      IMONO=0

      IF (IUP.EQ.1) THEN

        DO I=1,N-1
          IF (X(I).EQ.X(I+1)) IMONO0=1
          IF (X(I).GT.X(I+1)) RETURN
        ENDDO

        IF (IMONO0.EQ.0) THEN
          IMONO=2
        ELSE
          IMONO=1
        ENDIF

      ELSE IF (IUP.EQ.-1) THEN

        DO I=1,N-1
          IF (X(I).EQ.X(I+1)) IMONO0=1
          IF (X(I).LT.X(I+1)) RETURN
        ENDDO

        IF (IMONO0.EQ.0) THEN
          IMONO=-2
        ELSE
          IMONO=-1
        ENDIF

      ELSE

        IMONO=0

      ENDIF

      RETURN
      END
+DECK,BQF.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.66/07 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.52/11 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  1.02/00 18/12/97  13.35.57  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  15.24.44  by  Michael Scheer
*CMZ : 00.00/05 29/04/94  19.35.51  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.43  by  Michael Scheer
*-- Author : Michael Scheer
C***********************************************************************
      SUBROUTINE BQF(XI,YI,ZI,BX,BY,BZ,IMAG)
+seq,gplhint.
      IMPLICIT NONE
      INTEGER IMAG

+SEQ,MGSQC.

      DOUBLE PRECISION Y,Z,BX,BY,BZ,G,XI,YI,ZI,PHI,SPHI,CPHI,XCEN,ZCEN,DX,DZ
      DOUBLE PRECISION AY1,AY2,XLEN2,BY1,BY2,FRINGE

+SEQ,CONTRL.
+SEQ,PHYCON.

      DATA FRINGE/1000.0D0/

      PHI=PMAG(5,IMAG)
      CPHI=DCOS(PHI)
      SPHI=DSIN(PHI)
      XCEN=PMAG(3,IMAG)
      ZCEN=PMAG(4,IMAG)

      XLEN2=PMAG(1,IMAG)/2.0D0

      IF (IWFILF.NE.99) THEN

        DX=XI-XCEN
        DZ=ZI-ZCEN
        Z=-SPHI*DX+CPHI*DZ
        Y=YI

        AY1=(DX-XLEN2)*FRINGE
        AY2=(-DX-XLEN2)*FRINGE

        IF (AY1.GT.70.) THEN
          BY1=0.0D0
        ELSE IF (AY1.LT.-70.) THEN
          BY1=1.0D0
        ELSE
          BY1=1.0D0/(1.0D0+DEXP(AY1))
        ENDIF

        IF (AY2.GT.70.) THEN
          BY2=0.0D0
        ELSE IF (AY2.LT.-70.) THEN
          BY2=1.0D0
        ELSE
          BY2=1.0D0/(1.0D0+DEXP(AY2))
        ENDIF

        G=PMAG(2,IMAG)*EMOM/CLIGHT1*BY1*BY2

        BX=0.0D0
        BY=G*Z
        BZ=G*Y

      ELSE

        BX=0.0D0
        BY=0.0D0
        BZ=0.0D0

      ENDIF !IWFILF

      RETURN
      END
+DECK,SECTMAGS.
*CMZ :  2.56/00 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.52/16 06/01/2005  15.27.37  by  Michael Scheer
*CMZ :  2.52/14 22/12/2004  16.09.45  by  Michael Scheer
*CMZ :  2.52/13 16/12/2004  21.14.00  by  Michael Scheer
*-- Author :    Michael Scheer   15/12/2004
      SUBROUTINE SECTMAGS
+seq,gplhint.

C--- Approximate vertical magnetic field as sequence of sector magnets

+SEQ,TRACKF90U.

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,TRACK.
+SEQ,B0SCGLOB.
+SEQ,TRACK0.

      DOUBLE PRECISION RHO,SPHI1,PHI1,SPHI2,PHI2,DPHI,
     &  X1,Z1,X2,Z2,ZERO,BY,
     &  HMATT(2,2),VMATT(2,2),VMAT(2,2),HMAT(2,2),HFOC,VFOC,WORK22(2,2)

      INTEGER ISEC,JSEC,NSEC,IX,NSTEP,IZERO

      CHARACTER(4) CNAME,CNAME10(10)
      CHARACTER(2) CTYPE

      DATA ZERO/0.0D0/

      IF (ICHARGE.LE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING in SECTMAGS: ICHARGE NEGATIVE'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING in SECTMAGS: ICHARGE NEGATIVE'
        WRITE(6,*)
      ENDIF

      IF (IWSECTMAGS.GT.999) THEN
        WRITE(LUNGFO,*)'*** Error in SECTMAGS: Too many magnets'
        WRITE(LUNGFO,*)'*** decrease IWSECTMAGS in wave.in'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** Programm WAVE aborted ***'
        WRITE(6,*)'*** Error in SECTMAGS: Too many magnets'
        WRITE(6,*)'*** decrease IWSECTMAGS in wave.in'
        WRITE(6,*)
        WRITE(6,*)'*** Programm WAVE aborted ***'
        STOP
      ENDIF

      NSEC=IWSECTMAGS
      NSTEP=(NCO-1)/IWSECTMAGS

      IX=1

      X1=WSXYZ(1,IX)
      Z1=WSXYZ(3,IX)

      PHI1=ATAN2(WVXYZ(3,IX),WVXYZ(1,IX))
      SPHI1=SIN(PHI1)

      ISEC=0

      HMATT(1,1)=1.0D0
      HMATT(1,2)=0.0D0
      HMATT(2,1)=0.0D0
      HMATT(2,2)=1.0D0

      VMATT=HMATT

      OPEN(UNIT=99,FILE='wave.smag',status='new')
      OPEN(UNIT=98,FILE='wave.xmag',status='new')

      WRITE(99,*)ICODE
      WRITE(99,*)CODE
      WRITE(98,*)ICODE
      WRITE(98,*)CODE

      IZERO=0

1     CONTINUE

      BY=WBXYZ(2,IX)
      IF (ABS(BY).LT.1.0D-6.AND.IX.LT.NCO) THEN
        IX=IX+1
        IZERO=1
        GOTO 1
      ELSE
        IX=IX+NSTEP-IZERO
      ENDIF

        ISEC=ISEC+1

        IF (IX.GE.NCO.OR.ISEC.EQ.IWSECTMAGS) THEN
          IX=NCO
          X2=XF0
          Z2=ZF0
          PHI2=ATAN2(VZF0,VXF0)
        ELSE
          X2=WSXYZ(1,IX)
          Z2=WSXYZ(3,IX)
          PHI2=ATAN2(WVXYZ(3,IX),WVXYZ(1,IX))
        ENDIF

        SPHI2=SIN(PHI2)
        DPHI=PHI2-PHI1

        IF (IZERO.EQ.0.AND.SPHI2.NE.SPHI1) THEN

          RHO=((X2-X1)/(SPHI2-SPHI1))

          CNAME='ASEC'
          IF (ISEC.LE.9) THEN
            WRITE(CNAME(4:4),'(I1)') ISEC
          ELSE IF (ISEC.LE.99) THEN
            WRITE(CNAME(3:4),'(I2)') ISEC
          ELSE IF (ISEC.LE.999) THEN
            WRITE(CNAME(2:4),'(I3)') ISEC
          ELSE
            WRITE(CNAME,'(I4)') ISEC
          ENDIF
          CTYPE='CO'
          WRITE(99,'(1X,A4,1X,A2,2X,E12.6,2X,E12.6,2X,E12.6,2X,E12.6)')
     &      CNAME,CTYPE,-PHI1,RHO,ZERO,ZERO
          WRITE(98,'(4E16.6)')X1,X2,RHO,-PHI1

          CALL CORNER_MAT(-PHI1,RHO,HMAT,VMAT,0.0D0)
          CALL UTIL_MATRIX_MULTIPLICATION(2,2,2,HMATT,HMAT,HMATT,WORK22)
          CALL UTIL_MATRIX_MULTIPLICATION(2,2,2,VMATT,VMAT,VMATT,WORK22)

          CNAME='BSEC'
          IF (ISEC.LE.9) THEN
            WRITE(CNAME(4:4),'(I1)') ISEC
          ELSE IF (ISEC.LE.99) THEN
            WRITE(CNAME(3:4),'(I2)') ISEC
          ELSE IF (ISEC.LE.999) THEN
            WRITE(CNAME(2:4),'(I3)') ISEC
          ELSE
            WRITE(CNAME,'(I4)') ISEC
          ENDIF
          CTYPE='DI'
          WRITE(99,'(1X,A4,1X,A2,2X,E12.6,2X,E12.6,2X,E12.6,2X,E12.6)')
     &      CNAME,CTYPE,DPHI,RHO,ZERO,ZERO
          WRITE(98,'(4E16.6)')X1,X2,RHO,DPHI

          CALL SECTMAG_MAT(DPHI,RHO,HMAT,VMAT)
          CALL UTIL_MATRIX_MULTIPLICATION(2,2,2,HMATT,HMAT,HMATT,WORK22)
          CALL UTIL_MATRIX_MULTIPLICATION(2,2,2,VMATT,VMAT,VMATT,WORK22)

          CNAME='CSEC'
          IF (ISEC.LE.9) THEN
            WRITE(CNAME(4:4),'(I1)') ISEC
          ELSE IF (ISEC.LE.99) THEN
            WRITE(CNAME(3:4),'(I2)') ISEC
          ELSE IF (ISEC.LE.999) THEN
            WRITE(CNAME(2:4),'(I3)') ISEC
          ELSE
            WRITE(CNAME,'(I4)') ISEC
          ENDIF
          CTYPE='CO'
          WRITE(99,'(1X,A4,1X,A2,2X,E12.6,2X,E12.6,2X,E12.6,2X,E12.6)')
     &      CNAME,CTYPE,PHI2,RHO,ZERO,ZERO
          WRITE(98,'(4E16.6)')X1,X2,RHO,PHI2

          CALL CORNER_MAT(PHI2,RHO,HMAT,VMAT,0.0D0)
          CALL UTIL_MATRIX_MULTIPLICATION(2,2,2,HMATT,HMAT,HMATT,WORK22)
          CALL UTIL_MATRIX_MULTIPLICATION(2,2,2,VMATT,VMAT,VMATT,WORK22)

        ELSE !SPHI2.NE.SPHI1

          CNAME='DSEC'
          IF (ISEC.LE.9) THEN
            WRITE(CNAME(4:4),'(I1)') ISEC
          ELSE IF (ISEC.LE.99) THEN
            WRITE(CNAME(3:4),'(I2)') ISEC
          ELSE IF (ISEC.LE.999) THEN
            WRITE(CNAME(2:4),'(I3)') ISEC
          ELSE
            WRITE(CNAME,'(I4)') ISEC
          ENDIF
          CTYPE='SD'
          WRITE(99,'(1X,A4,1X,A2,2X,E12.6)') CNAME,CTYPE,X2-X1
          WRITE(98,'(4E16.6)')X1,X2,X2-X1,ZERO

          CALL SECTMAG_MAT(0.0D0,X2-X1,HMAT,VMAT)
          CALL UTIL_MATRIX_MULTIPLICATION(2,2,2,HMATT,HMAT,HMATT,WORK22)
          CALL UTIL_MATRIX_MULTIPLICATION(2,2,2,VMATT,VMAT,VMATT,WORK22)

        ENDIF !SPHI2.NE.SPHI1

        X1=X2
        Z1=X1

        PHI1=PHI2
        SPHI1=SPHI2

        IZERO=0

      IF (IX.LT.NCO) GOTO 1

      CLOSE(99)
      CLOSE(98)

      IF (HMATT(2,1).NE.0.0D0) THEN
        HFOC=-1.0D0/HMATT(2,1)
      ELSE
        HFOC=0.0D0
      ENDIF

      IF (VMATT(2,1).NE.0.0D0) THEN
        VFOC=-1.0D0/VMATT(2,1)
      ELSE
        VFOC=0.0D0
      ENDIF

      OPEN(UNIT=99,FILE='wave.smag',status='old')
      OPEN(UNIT=97,FILE='wave.strmag',status='new')

      WRITE(97,*)ICODE
      WRITE(97,*)CODE

      ISEC=0
      JSEC=0
      NSEC=0

      READ(99,'(1X,A4)',END=99)CNAME
      READ(99,'(1X,A4)',END=99)CNAME

11    READ(99,'(1X,A4)',END=99)CNAME

      NSEC=NSEC+1
      ISEC=ISEC+1

      CNAME10(ISEC)=CNAME

      IF (ISEC.EQ.10) THEN
        WRITE(97,'(10(1X,A4))')CNAME10
        CNAME10='NN  '
        ISEC=0
        JSEC=JSEC+1
      ENDIF

      GOTO 11

99    CONTINUE

      IF (ISEC.ne.0) THEN
        WRITE(97,'(10(1X,A4))')CNAME10
        JSEC=JSEC+1
      ENDIF

      CLOSE(97)
      CLOSE(99)

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'      SR SECTMAGS:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '      Number of elements written to wave.smag and wave.xmag:',NSEC
      WRITE(LUNGFO,*)
     &'      Number of elements lines written to wave.strmag:',JSEC
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'      Linear tranfer matrices:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'      ',SNGL(HMATT(1,1)),SNGL(HMATT(1,2))
      WRITE(LUNGFO,*)'      ',SNGL(HMATT(2,1)),SNGL(HMATT(2,2))
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'      ',SNGL(VMATT(1,1)),SNGL(VMATT(1,2))
      WRITE(LUNGFO,*)'      ',SNGL(VMATT(2,1)),SNGL(VMATT(2,2))
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'      Focal lengths:'
      WRITE(LUNGFO,*)'      ',SNGL(HFOC),SNGL(VFOC)
      WRITE(LUNGFO,*)

      RETURN
      END
+DECK,BSECTMAGS.
*CMZ :  2.61/02 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.53/05 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.52/14 22/12/2004  15.44.27  by  Michael Scheer
*CMZ :  2.52/13 16/12/2004  21.16.53  by  Michael Scheer
*-- Author :    Michael Scheer   15/12/2004
      SUBROUTINE BSECTMAGS(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
+seq,gplhint.

C--- Approximate vertical magnetic field as sequence of sector magnets

+SEQ,TRACKF90U.

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,TRACK.
+SEQ,B0SCGLOB.
+SEQ,PHYCON.

      INTEGER NDIPP,ICAL
      PARAMETER(NDIPP=999)

      DOUBLE PRECISION DX,RHO,DPHI,RHODIP,
     &  PHIDIP(NDIPP),BYDIP(NDIPP),XIDIP(NDIPP),XEDIP(NDIPP),
     &  X,Y,Z,BX,BY,BZ,AX,AY,AZ

      INTEGER NSEC,NDIP,JCODE,LCODE,IDIPO,IDIP

      CHARACTER(4) CNAME
      CHARACTER(2) CTYPE
      CHARACTER(128) CODEJ,CODEL

      DATA ICAL/0/
      DATA IDIPO/1/

      IF (ICAL.EQ.0) THEN

        Y=Y
        Z=Z

        OPEN(UNIT=98,FILE='wave.xmag',STATUS='OLD')
        OPEN(UNIT=99,FILE='wave.smag',STATUS='OLD')

        READ(98,*)LCODE
        READ(98,'(A)')CODEL
        READ(99,*)JCODE
        READ(99,'(A)')CODEJ

        IF (LCODE.NE.JCODE) THEN
          WRITE(LUNGFO,*)
     &    '*** Error in BSECTMAGS: Files wave.smag and wave.xmag do not match'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** Programm WAVE aborted ***'
          WRITE(LUNGFO,*)
          WRITE(6,*)
     &    '*** Error in BSECTMAGS: Files wave.smag and wave.xmag do not match'
          WRITE(6,*)
          WRITE(6,*)'*** Programm WAVE aborted ***'
          WRITE(6,*)
          STOP
        ENDIF

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'      Subroutine BSECTMAGS:'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'      run number on file wave.smag:',JCODE
        WRITE(LUNGFO,*)'      comment on file wave.smag:'
        WRITE(LUNGFO,*)'      ',CODEJ
        WRITE(LUNGFO,*)

        NDIP=0

1       READ(99,'(1X,A4,1X,A2,2X,E12.6,2X)',END=9)
     &      CNAME,CTYPE,DX
        READ(98,*) DX

        NSEC=NSEC+1

        IF (NSEC.GT.999) THEN
          WRITE(LUNGFO,*)'*** Error in BSECTMAGS: Too many magnets'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** Programm WAVE aborted ***'
          WRITE(6,*)'*** Error in BSECTMAGS: Too many magnets'
          WRITE(6,*)
          WRITE(6,*)'*** Programm WAVE aborted ***'
          STOP
        ENDIF

        IF (CTYPE.EQ.'DI') THEN

          NDIP=NDIP+1

          BACKSPACE(99)
          BACKSPACE(98)

          READ(99,'(1X,A4,1X,A2,2X,E12.6,2X,E12.6)')
     &      CNAME,CTYPE,PHIDIP(NDIP),RHODIP
          READ(98,*)XIDIP(NDIP),XEDIP(NDIP),RHO,DPHI

          BYDIP(NDIP)=
     &      EMASSE1*DSQRT( (DMYGAMMA+1.0D0)*(DMYGAMMA-1.0D0))/CLIGHT1/RHO

          IF (DPHI.NE.PHIDIP(NDIP).OR.RHO.NE.RHODIP) THEN
            WRITE(LUNGFO,*)
     &   '*** Error in BSECTMAGS: Files wave.smag and wave.xmag do not match'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** Programm WAVE aborted ***'
            WRITE(LUNGFO,*)
            WRITE(6,*)
     &   '*** Error in BSECTMAGS: Files wave.smag and wave.xmag do not match'
            WRITE(6,*)
            WRITE(6,*)'*** Programm WAVE aborted ***'
            WRITE(6,*)
            STOP
          ENDIF

        ENDIF !DI

        GOTO 1

9       CLOSE(99)
        CLOSE(98)

        IF (XSTART.EQ.9999.0D0) XSTART=XIDIP(1)
        IF (XSTOP.EQ.9999.0D0) XSTOP=XEDIP(NDIP)

        ICAL=1

      ENDIF !ICAL

      IF (X.LE.XEDIP(1)) THEN
        IDIPO=1
      ENDIF

      BY=0.0D0

      DO IDIP=IDIPO,NDIP
        IF (XIDIP(IDIP).LE.X.AND.XEDIP(IDIP).GE.X) THEN
          BY=BYDIP(IDIP)
          IDIPO=IDIP
          GOTO 99
        ENDIF
      ENDDO

99    BX=0.0D0
      BZ=0.0D0

      AX=0.0D0
      AY=0.0D0
      AZ=0.0D0

      RETURN
      END
+DECK,sectmag_mat.
*CMZ :  2.52/14 17/12/2004  17.27.30  by  Michael Scheer
*-- Author :    Michael Scheer   17/12/2004
      subroutine sectmag_mat(theta,rho,hmat,vmat)
+seq,gplhint.

      double precision theta,rho,vmat(2,2),hmat(2,2),cs,sn

      cs=cos(theta)
      sn=sin(theta)

      if (theta.ne.0.0d0) then

        hmat(1,1)=cs
        hmat(1,2)=rho*sn
        hmat(2,1)=-sn/rho
        hmat(2,2)=cs

        vmat(1,1)=1.0d0
        vmat(1,2)=rho*theta
        vmat(2,1)=0.0d0
        vmat(2,2)=1.0d0

      else

        hmat(1,1)=1.0d0
        hmat(1,2)=rho !we assume rho to be length of a drift, here
        hmat(2,1)=0.0d0
        hmat(2,2)=1.0d0

        vmat=hmat

      endif

      return
      end
+DECK,CORNER_MAT.
*CMZ :  2.52/14 20/12/2004  09.48.45  by  Michael Scheer
*-- Author :    Michael Scheer   17/12/2004
      subroutine corner_mat(eps,rho,hmat,vmat,b)
+seq,gplhint.

      double precision eps,rho,vmat(2,2),hmat(2,2),ts,cs,b

      cs=cos(eps)

      if (cs.eq.0.0d0) then
        print*,'*** Error in corner_mat: Cosine of corner angle is zero'
        stop '*** Program WAVE aborted ***'
      endif

      ts=tan(eps)

      if (rho.ne.0.0d0) then

        hmat(1,1)=1.0d0
        hmat(1,2)=0.0d0
        hmat(2,1)=ts/rho
        hmat(2,2)=1.0d0

        vmat(1,1)=1.0d0
        vmat(1,2)=0.0d0
        vmat(2,1)=(b/(6.0d0*rho*cs)-ts)/rho
        vmat(2,2)=1.0d0

      else

        hmat(1,1)=1.0d0
        hmat(1,2)=rho !we assume rho to be length of a drift, here
        hmat(2,1)=0.0d0
        hmat(2,2)=1.0d0

        vmat=hmat

      endif

      return
      end
+DECK,EFOLDPIN.
*CMZ :  4.00/07 06/04/2020  10.44.37  by  Michael Scheer
*CMZ :  4.00/04 10/05/2019  14.43.12  by  Michael Scheer
*CMZ :  3.03/02 03/12/2015  13.35.35  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.61/02 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.52/16 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.52/00 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.51/00 13/05/2004  12.01.48  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  16.27.20  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  2.13/03 12/01/2000  16.31.33  by  Michael Scheer
*CMZ : 00.01/06 01/02/95  16.22.16  by  Michael Scheer
*CMZ : 00.01/04 25/01/95  16.36.51  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  16.19.11  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.49.38  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.43  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE EFOLDPIN
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,OBSERVF90U.
+SEQ,WFOLDF90U.

C--- THE ROUTINE FOLDS THE STOKES VECTORS INSIDE THE PINHOLE
C      WITH A GAUSSIAN TO TAKE THE BEAM ENERGY SPREAD INTO ACCOUNT

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,SPECT.
+SEQ,FREQS.
+SEq,wfoldf90.
+SEq,observf90.

      INTEGER IFREQ
      INTEGER IOBSV
      REAL*4 F,S0,S1,S2,S3

      INTEGER NFOLDP,kmode
      PARAMETER (NFOLDP=1000)

      DOUBLE PRECISION DF,F3SIG
      DOUBLE PRECISION S0E(NDFREQP),S2E(NDFREQP),S3E(NDFREQP),S1E(NDFREQP)
      DOUBLE PRECISION S0EF(NDFREQP),S2EF(NDFREQP),S3EF(NDFREQP),S1EF(NDFREQP)

      IF (IPIN.NE.0.AND.IPIN.NE.1) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN EFOLDPIN: IPIN is not 1  ***'
        WRITE(LUNGFO,*)'leaving IEFOLDPIN'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN EFOLDPIN: IPIN is not 1  ***'
        WRITE(6,*)'leaving IEFOLDPIN'
        WRITE(6,*)
        RETURN
      ENDIF

      IF (iabs(IEFOLD).NE.1.and.iefold.ne.3) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN EFOLDPIN: IEFOLD not in [-1,1,3] ***'
        WRITE(LUNGFO,*)'leaving IEFOLDPIN'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN EFOLDPIN: IEFOLD not in [-1,1,3] ***'
        WRITE(6,*)'leaving IEFOLDPIN'
        WRITE(6,*)
        RETURN
      ENDIF

      IF (IFOLD.NE.0.AND.IFOLD.NE.1) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '*** WARNING IN EFOLDPIN: IFOLD is neither 0 or nor 1  ***'
        WRITE(LUNGFO,*)'leaving IEFOLDPIN'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)
     &    '*** WARNING IN EFOLDPIN: IFOLD is neither 0 or nor 1  ***'
        WRITE(6,*)'leaving IEFOLDPIN'
        WRITE(6,*)
        RETURN
      ENDIF

      DO IOBSV=1,NOBSV

        DO IFREQ=1,NFREQ
          F=FREQ(IFREQ)
          IOBFR=IOBSV+NOBSV*(IFREQ-1)
          S0=STOKES(1,IOBFR)
          S1=STOKES(2,IOBFR)
          S2=STOKES(3,IOBFR)
          S3=STOKES(4,IOBFR)
          S0E(IFREQ)=S0
          S1E(IFREQ)=S1
          S2E(IFREQ)=S2
          S3E(IFREQ)=S3
        ENDDO !IFREQ

        kmode=-1
        DO IFREQ=NFREQEM+1,NFREQ-NFREQEP
          IOBFR=IOBSV+NOBSV*(IFREQ-1)
          DF=FREQ(IFREQ)*ESPREAD*2.D0*NSIGE
          F3SIG=FREQ(IFREQ)*ESPREAD*2.D0
          IF(FREQ(IFREQ)-DF.GE.FREQ(1)
     &        .AND.
     &        FREQ(IFREQ)+DF.LE.FREQ(NFREQ)) THEN
            CALL EFOLD_GAUSS
     &        (NFREQ,FREQ,S1E,F3SIG,NSIGE,FREQ(IFREQ),kmode,S1EF(IFREQ))
            kmode=1
          ELSE
            S1EF(IFREQ)=9.999D-11
          ENDIF
          STOKESE(2,IOBFR)=S1EF(IFREQ)
        ENDDO !IFREQ

        kmode=-1
        DO IFREQ=NFREQEM+1,NFREQ-NFREQEP
          IOBFR=IOBSV+NOBSV*(IFREQ-1)
          DF=FREQ(IFREQ)*ESPREAD*2.D0*NSIGE
          F3SIG=FREQ(IFREQ)*ESPREAD*2.D0
          IF(FREQ(IFREQ)-DF.GE.FREQ(1)
     &        .AND.
     &        FREQ(IFREQ)+DF.LE.FREQ(NFREQ)) THEN
            CALL EFOLD_GAUSS
     &        (NFREQ,FREQ,S2E,F3SIG,NSIGE,FREQ(IFREQ),kmode,S2EF(IFREQ))
            kmode=1
          ELSE
            S2EF(IFREQ)=9.999D-11
          ENDIF
          STOKESE(3,IOBFR)=S2EF(IFREQ)
        ENDDO !IFREQ

        kmode=-1
        DO IFREQ=NFREQEM+1,NFREQ-NFREQEP
          IOBFR=IOBSV+NOBSV*(IFREQ-1)
          DF=FREQ(IFREQ)*ESPREAD*2.D0*NSIGE
          F3SIG=FREQ(IFREQ)*ESPREAD*2.D0
          IF(FREQ(IFREQ)-DF.GE.FREQ(1)
     &        .AND.
     &        FREQ(IFREQ)+DF.LE.FREQ(NFREQ)) THEN
            CALL EFOLD_GAUSS
     &        (NFREQ,FREQ,S3E,F3SIG,NSIGE,FREQ(IFREQ),kmode,S3EF(IFREQ))
            kmode=1
          ELSE
            S3EF(IFREQ)=9.999D-11
          ENDIF
          STOKESE(4,IOBFR)=S3EF(IFREQ)
        ENDDO !IFREQ

        kmode=-1
        DO IFREQ=NFREQEM+1,NFREQ-NFREQEP
          IOBFR=IOBSV+NOBSV*(IFREQ-1)
          DF=FREQ(IFREQ)*ESPREAD*2.D0*NSIGE
          F3SIG=FREQ(IFREQ)*ESPREAD*2.D0
          IF(FREQ(IFREQ)-DF.GE.FREQ(1)
     &        .AND.
     &        FREQ(IFREQ)+DF.LE.FREQ(NFREQ)) THEN
            CALL EFOLD_GAUSS
     &        (NFREQ,FREQ,S0E,F3SIG,NSIGE,FREQ(IFREQ),kmode,S0EF(IFREQ))
            kmode=1
          ELSE
            S0EF(IFREQ)=9.999D-11
          ENDIF
          STOKESE(1,IOBFR)=S0EF(IFREQ)
        ENDDO !IFREQ

      ENDDO !NOBSV

      IF (IFOLD.NE.0) THEN

C STOKES DISTRIBUTION IN PINHOLE (FOLDED)

      DO IOBSV=1,NOBSV

        DO IFREQ=1,NFREQ
          F=FREQ(IFREQ)
          IOBFR=IOBSV+NOBSV*(IFREQ-1)
          S0=STOKESF(1,IOBFR)
          S1=STOKESF(2,IOBFR)
          S2=STOKESF(3,IOBFR)
          S3=STOKESF(4,IOBFR)
          S0E(IFREQ)=S0
          S1E(IFREQ)=S1
          S2E(IFREQ)=S2
          S3E(IFREQ)=S3
        ENDDO !IFREQ

        kmode=-1
        DO IFREQ=NFREQEM+1,NFREQ-NFREQEP
          IOBFR=IOBSV+NOBSV*(IFREQ-1)
          DF=FREQ(IFREQ)*ESPREAD*2.D0*NSIGE
          F3SIG=FREQ(IFREQ)*ESPREAD*2.D0
          IF(FREQ(IFREQ)-DF.GE.FREQ(1)
     &        .AND.
     &        FREQ(IFREQ)+DF.LE.FREQ(NFREQ)) THEN
            CALL EFOLD_GAUSS
     &        (NFREQ,FREQ,S0E,F3SIG,NSIGE,FREQ(IFREQ),kmode,S0EF(IFREQ))
            kmode=1
          ELSE
            S0EF(IFREQ)=9.999D-11
          ENDIF
          STOKESEF(1,IOBFR)=S0EF(IFREQ)
        ENDDO !IFREQ

        kmode=-1
        DO IFREQ=NFREQEM+1,NFREQ-NFREQEP
          IOBFR=IOBSV+NOBSV*(IFREQ-1)
          DF=FREQ(IFREQ)*ESPREAD*2.D0*NSIGE
          F3SIG=FREQ(IFREQ)*ESPREAD*2.D0
          IF(FREQ(IFREQ)-DF.GE.FREQ(1)
     &        .AND.
     &        FREQ(IFREQ)+DF.LE.FREQ(NFREQ)) THEN
            CALL EFOLD_GAUSS
     &        (NFREQ,FREQ,S1E,F3SIG,NSIGE,FREQ(IFREQ),kmode,S1EF(IFREQ))
            kmode=1
          ELSE
            S1EF(IFREQ)=9.999D-11
          ENDIF
          STOKESEF(2,IOBFR)=S1EF(IFREQ)
        ENDDO !IFREQ

        kmode=-1
        DO IFREQ=NFREQEM+1,NFREQ-NFREQEP
          IOBFR=IOBSV+NOBSV*(IFREQ-1)
          DF=FREQ(IFREQ)*ESPREAD*2.D0*NSIGE
          F3SIG=FREQ(IFREQ)*ESPREAD*2.D0
          IF(FREQ(IFREQ)-DF.GE.FREQ(1)
     &        .AND.
     &        FREQ(IFREQ)+DF.LE.FREQ(NFREQ)) THEN
            CALL EFOLD_GAUSS
     &        (NFREQ,FREQ,S2E,F3SIG,NSIGE,FREQ(IFREQ),kmode,S2EF(IFREQ))
            kmode=1
          ELSE
            S2EF(IFREQ)=9.999D-11
          ENDIF
          STOKESEF(3,IOBFR)=S2EF(IFREQ)
        ENDDO !IFREQ

        kmode=-1
        DO IFREQ=NFREQEM+1,NFREQ-NFREQEP
          IOBFR=IOBSV+NOBSV*(IFREQ-1)
          DF=FREQ(IFREQ)*ESPREAD*2.D0*NSIGE
          F3SIG=FREQ(IFREQ)*ESPREAD*2.D0
          IF(FREQ(IFREQ)-DF.GE.FREQ(1)
     &        .AND.
     &        FREQ(IFREQ)+DF.LE.FREQ(NFREQ)) THEN
            CALL EFOLD_GAUSS
     &        (NFREQ,FREQ,S3E,F3SIG,NSIGE,FREQ(IFREQ),kmode,S3EF(IFREQ))
            kmode=1
          ELSE
            S3EF(IFREQ)=9.999D-11
          ENDIF
          STOKESEF(4,IOBFR)=S3EF(IFREQ)
        ENDDO !IFREQ

      ENDDO !NOBSV

      ENDIF !(IFOLD.NE.0)

      RETURN
      END
+DECK,BBAMWLS.
*CMZ :  4.00/04 17/05/2019  14.17.20  by  Michael Scheer
*CMZ :  2.63/05 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.56/02 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.56/01 21/10/2005  12.22.07  by  Michael Scheer
*CMZ :  2.54/05 19/05/2005  17.01.55  by  Michael Scheer
*-- Author :    Michael Scheer   22/11/96
      SUBROUTINE BBAMWLS(X,Y,Z,BX,BY,BZ)
+seq,gplhint.

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,CMPARA.
+SEQ,PHYCON.
+SEQ,BAMWLS.
+SEQ,FOURIER.

      DOUBLE PRECISION
     &  X,Y,Z,BX,BY,BZ,BXX,BYY,BZZ,
     &  XK0FOUR1,ZK0FOUR1,ZL0FOUR1,A01,A1(MAXFOUR),
     &  XKFOUR1(MAXFOUR),YKFOUR1(MAXFOUR),ZKFOUR1(MAXFOUR),
     &  XK0FOUR2,ZK0FOUR2,ZL0FOUR2,A02,A2(MAXFOUR),
     &  XKFOUR2(MAXFOUR),YKFOUR2(MAXFOUR),ZKFOUR2(MAXFOUR),
     &  AXX,AYY,AZZ,B01,B02,
     &  P1(4),B1,B2

      INTEGER ICAL,I,IK,IRFILB0O,LUNDUM,NFOUR1,NFOUR2

      DATA ICAL/0/,LUNDUM/99/
      DATA P1/-0.00150191,0.00508334,7.2303E-07,-2.2247E-08/

      IF (ICAL.EQ.0) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'      BBAMWLS:'
        WRITE(LUNGFO,*)'      MODE:',MBAMWLS
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'      CORRMS,CORRMM:',SNGL(CORRMS),SNGL(CORRMM)
        WRITE(LUNGFO,*)'      (scaling factors for neg. and. pos. field of WLS)'
        WRITE(LUNGFO,*)

C ERSTER STEERER

        OPEN(UNIT=LUNDUM,FILE='bamwls_neuer_steerer.fou',status='old')

        READ(LUNDUM,*)
        READ(LUNDUM,*)ZL0FOUR1
        READ(LUNDUM,*)NFOUR1

        IF (NFOUR1.GT.MAXFOUR) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '*** ERROR IN BFOUR ***'
          WRITE(LUNGFO,*)'NFOUR1.GT.MAXFOUR'
          WRITE(6,*)
          WRITE(6,*)
     &      '*** ERROR IN BFOUR ***'
          WRITE(6,*)'NFOUR1.GT.MAXFOUR'
          STOP
        ENDIF

        READ(LUNDUM,*)IK,A01

        DO I=1,NFOUR1-1
          READ(LUNDUM,*)IK,A1(IK-1)
        END DO

        CLOSE(LUNDUM)

        IF (XLCORRL.NE.0.0D0) THEN
          XK0FOUR1=2.D0*PI1/XLCORRL
        ELSE
          XK0FOUR1=0.0D0
        ENDIF

        ZK0FOUR1=2.D0*PI1/ZL0FOUR1

        B01=A01/2.0D0

        DO I=1,NFOUR1-1
          ZKFOUR1(I)=ZK0FOUR1*I
          XKFOUR1(I)=XK0FOUR1 !VORERST, SIEHE AUCH OBEN
          YKFOUR1(I)=DSQRT(ZKFOUR1(I)**2+XKFOUR1(I)**2)
          B01=B01+A1(I)
        END DO

        B1=P1(1)+CURRL*(P1(2)+CURRL*(P1(3)+P1(4)*CURRL))
        A01=A01/B01*B1*CORRL
        A1=A1/B01*B1*CORRL

C ZWEITER STEERER

        OPEN(UNIT=LUNDUM,FILE='bamwls_alter_steerer.fou',status='old')

        READ(LUNDUM,*)
        READ(LUNDUM,*)ZL0FOUR2
        READ(LUNDUM,*)NFOUR2

        IF (NFOUR2.GT.MAXFOUR) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '*** ERROR IN BFOUR ***'
          WRITE(LUNGFO,*)'NFOUR2.GT.MAXFOUR'
          WRITE(6,*)
          WRITE(6,*)
     &      '*** ERROR IN BFOUR ***'
          WRITE(6,*)'NFOUR2.GT.MAXFOUR'
          STOP
        ENDIF

        READ(LUNDUM,*)IK,A02

        DO I=1,NFOUR2-1
          READ(LUNDUM,*)IK,A2(IK-1)
        END DO

        CLOSE(LUNDUM)

        IF (XLCORRR.NE.0.0D0) THEN
          XK0FOUR2=2.D0*PI1/XLCORRR
        ELSE
          XK0FOUR2=0.0D0
        ENDIF

        ZK0FOUR2=2.D0*PI1/ZL0FOUR2

        DO I=1,NFOUR2-1
          ZKFOUR2(I)=ZK0FOUR2*I
          XKFOUR2(I)=XK0FOUR2 !VORERST, SIEHE AUCH OBEN
          YKFOUR2(I)=DSQRT(ZKFOUR2(I)**2+XKFOUR2(I)**2)
          B02=B02+A2(I)
        END DO

        B2=(CURRR*(-1.0957*CURRR+215.31)-6.05)/10000.
        B02=(14.436*(-1.0957*14.436+215.31)-6.05)/10000.
        A02=A02/B02*B2*CORRR
        A2=A2/B02*B2*CORRR

        WRITE(LUNGFO,*)'      CURRL,CURRR:    ',SNGL(CURRL),SNGL(CURRR)
        WRITE(LUNGFO,*)'      CORRL,CORRR:    ',SNGL(CORRL),SNGL(CORRR)
        WRITE(LUNGFO,*)'      max. fields:    ',SNGL(B1),SNGL(B2)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'      XCORRL,XCORRR:  ',SNGL(XCORRL),SNGL(XCORRR)
        WRITE(LUNGFO,*)'      XLCORRL,XLCORRR:',SNGL(XLCORRL),SNGL(XLCORRR)
        WRITE(LUNGFO,*)

        ICAL=1

      ENDIF

      IRFILB0O=IRFILB0

      BX=0.0D0
      BY=0.0D0
      BZ=0.0D0

C STEERER

      CALL BFOURMULT(X-XCORRL,Y,Z,BXX,BYY,BZZ,
     &  AXX,AYY,AZZ,
     &  NFOUR1,ZL0FOUR1,XKFOUR1,YKFOUR1,ZKFOUR1,A01,A1)

      BX=BX+BXX
      BY=BY+BYY
      BZ=BZ+BZZ

      CALL BFOURMULT(X-XCORRR,Y,Z,BXX,BYY,BZZ,
     &  AXX,AYY,AZZ,
     &  NFOUR2,ZL0FOUR1,XKFOUR2,YKFOUR2,ZKFOUR2,A02,A2)

      BX=BX+BXX
      BY=BY+BYY
      BZ=BZ+BZZ

      IF (MBAMWLS.EQ.0) THEN

C RADIA-FELDMAPPE DES WLS

        IRFILB0=-2
        CALL BMESS(ABS(X),ABS(Y),ABS(Z),BXX,BYY,BZZ)

        IF (X.LT.0.0D0) THEN
          BXX=-BXX
        ENDIF
        IF (Y.LT.0.0D0) THEN
          BXX=-BXX
          BZZ=-BZZ
        ENDIF
        IF (Z.LT.0.0D0) THEN
          BZZ=-BZZ
        ENDIF

      ELSE IF (MBAMWLS.EQ.1) THEN

        CALL BTAB(X,Y,Z,BXX,BYY,BZZ,AXX,AYY,AZZ)

      ENDIF !(MBAMWLS.EQ.0) THEN

      IF (BYY.LT.0.0D0) THEN
        BXX=BXX*CORRMS
        BYY=BYY*CORRMS
        BZZ=BZZ*CORRMS
      ELSE
        BXX=BXX*CORRMM
        BYY=BYY*CORRMM
        BZZ=BZZ*CORRMM
      ENDIF

      BX=BX+BXX
      BY=BY+BYY
      BZ=BZ+BZZ

      IRFILB0=IRFILB0O

      RETURN
      END
+DECK,bfourmult.
*CMZ :  2.55/00 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.54/05 19/05/2005  14.58.44  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BFOURMULT(XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,
     &  AXOUT,AYOUT,AZOUT,
     &  NFOUR,ZL0FOUR,XKFOUR,YKFOUR,ZKFOUR,A0,A)
+seq,gplhint.

C SEE BFOUR

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,CMPARA.
+SEQ,PHYCON.

      COMPLEX*16 CDEXPOMX,CEXPOMZ,CDEXPOMZ

      DOUBLE PRECISION A0,A(MAXFOUR),
     &  XKFOUR(MAXFOUR),YKFOUR(MAXFOUR),ZKFOUR(MAXFOUR),
     &  ZL0FOUR

      DOUBLE PRECISION XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT,
     &  DSNXKX,DCSXKX,DSHYKY,DCHYKY,DSNZKZ,DCSZKZ
     &  ,BXH,BYH,BZH,AXH,AYH,AZH,X

      DOUBLE PRECISION EXPOMY,DEXPOMY,EXPOMY1

      DOUBLE PRECISION DNULL

      INTEGER K,NFOUR

      DATA DNULL/0.D0/

      IF (NFOUR.NE.-9999.AND.(NFOUR.LT.1.OR.NFOUR.GT.MAXFOUR)) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN BFOURMULT ***'
        WRITE(LUNGFO,*)'NFOUR.LT.1.OR.NFOUR.GT.MAXFOUR'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN BFOURMULT ***'
        WRITE(6,*)'NFOUR.LT.1.OR.NFOUR.GT.MAXFOUR'
        WRITE(6,*)
        STOP
      ENDIF

      IF (DABS(XIN).GT.ZL0FOUR/2.0D0) THEN
        BXOUT=0.0D0
        BYOUT=0.0D0
        BZOUT=0.0D0
        AXOUT=0.0D0
        AYOUT=0.0D0
        AZOUT=0.0D0
        RETURN
      ELSE
        X=XIN
      ENDIF

      BXH=0.
      BYH=A0/2.D0
      BZH=0.

C IF CHANGED, CONSIDER FOLLOWING LOOP AND SR MYBFELD {

+SELF,IF=DIPAXAZ.
      AXH= A0/4.D0*  XIN
      AYH=0.
      AZH=-A0/4.D0*(-ZIN)
+SELF.

+SELF,IF=DIPAZ.
      AXH=0.
      AYH=0.
      AZH=A0/2.D0*ZIN  ! (-ZIN) IS X HERE
+SELF.

+SELF,IF=-DIPAXAZ,IF=-DIPAZ.
      AXH= A0/2.D0*  XIN !XIN IS HERE Z
      AYH=0.
      AZH=0.
+SELF.

C IF CHANGED, CONSIDER FOLLOWING LOOP AND SR MYBFELD }

      CDEXPOMX=CDEXP(DCMPLX(DNULL,XKFOUR(1)*(-ZIN)))
      DCSXKX=DREAL(CDEXPOMX)
      DSNXKX=DIMAG(CDEXPOMX)

      DEXPOMY=DEXP(YKFOUR(1)*YIN)
      EXPOMY=1.D0

      CDEXPOMZ=CDEXP(DCMPLX(DNULL,ZKFOUR(1)*    X ))
      CEXPOMZ=DCMPLX(1.D0,DNULL)

      DO K=1,NFOUR-1

        IF (XKFOUR(1).NE.0.0D0) THEN
          EXPOMY=DEXP(YKFOUR(K)*YIN)
        ELSE
          EXPOMY=EXPOMY*DEXPOMY
        ENDIF
        EXPOMY1=1.D0/EXPOMY
        DCHYKY=(EXPOMY+EXPOMY1)*0.5D0
        DSHYKY=(EXPOMY-EXPOMY1)*0.5D0

        CEXPOMZ=CEXPOMZ*CDEXPOMZ
        DCSZKZ=DREAL(CEXPOMZ)
        DSNZKZ=DIMAG(CEXPOMZ)

        BXH=BXH-A(K)*XKFOUR(K)/YKFOUR(K)*DSNXKX*DSHYKY*DCSZKZ
        BYH=BYH+A(K)*                    DCSXKX*DCHYKY*DCSZKZ
        BZH=BZH-A(K)*ZKFOUR(K)/YKFOUR(K)*DCSXKX*DSHYKY*DSNZKZ

+SELF,IF=HALAXAZ.
        AXH=AXH+0.5D0*A(K)/ZKFOUR(K)*DCSXKX*DCHYKY*DSNZKZ
        IF (XKFOUR(K).NE.0.0) THEN
          AZH=AZH-0.5D0*A(K)/XKFOUR(K)*DSNXKX*DCHYKY*DCSZKZ
        ELSE
          AZH=AZH-0.5D0*A(K)*(-ZIN)*DCHYKY*DCSZKZ
        ENDIF
+SELF.

+SELF,IF=HALAZ.
        AXH=AXH+0.0
        IF (XKFOUR(K).NE.0.0) THEN
          AZH=AZH-A(K)/XKFOUR(K)*DSNXKX*DCHYKY*DCSZKZ
        ELSE
          AZH=AZH-A(K)*(-ZIN)*DCHYKY*DCSZKZ
        ENDIF
+SELF.

+SELF,IF=-HALAXAZ,IF=-HALAZ.
        AXH=AXH+A(K)/ZKFOUR(K)*DCSXKX*DCHYKY*DSNZKZ
        AZH=AZH+0.0
+SELF.

        AYH=AYH+A(K)/ZKFOUR(K)*XKFOUR(K)/YKFOUR(K)*DSNXKX*DSHYKY*DSNZKZ

      ENDDO

      BZOUT=-BXH
      BYOUT= BYH
      BXOUT= BZH

      AZOUT=-AXH
      AYOUT= AYH
      AXOUT= AZH

      RETURN
      END
+DECK,TRACEN.
*CMZ :  2.61/02 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.57/00 25/10/2005  08.39.19  by  Michael Scheer
*CMZ :  2.54/05 01/06/2005  12.29.03  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE TRACEN(XCEN,YCEN,ZCEN,YPCEN,ZPCEN)
+seq,gplhint.

+SEQ,TRACKF90U,IF=UOUT.

+SEQ,TRACKF90U.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,TRACK.
+SEQ,TRACK0.

      DOUBLE PRECISION XCEN,YCEN,ZCEN,YPCEN,ZPCEN,
     &  XX,
     &  VZVX0,VZVX1,
     &  VYVX0,VYVX1,
     &  DX

      INTEGER I,I1,I2

      YCEN=-9999.
      YPCEN=-9999.
      ZCEN=-9999.
      ZPCEN=-9999.

      DX=WSXYZ(1,2)-WSXYZ(1,1)

      IF (XCEN.LT.WSXYZ(1,1)-DX.OR.XCEN.GT.WSXYZ(1,NCO)+DX) THEN
        RETURN
      ELSE IF (XCEN.LE.WSXYZ(1,1)) THEN
        I=1
      ELSE IF (XCEN.GE.WSXYZ(1,NCO)) THEN
        I=NCO-1
      ELSE
        I1=1
        I2=NCO
        DO WHILE (I2-I1.GT.1)
          I=(I2+I1)/2
          IF (XCEN.GE.WSXYZ(1,I)) THEN
            I1=I
          ELSE
            I2=I
          ENDIF
        ENDDO
        I=I1
      ENDIF

100   XX=(XCEN-WSXYZ(1,I))/(WSXYZ(1,I+1)-WSXYZ(1,I))

      YCEN=WSXYZ(2,I)+(WSXYZ(2,I+1)-WSXYZ(2,I))*XX

      VYVX0=WVXYZ(2,I)/WVXYZ(1,I)
      VYVX1=WVXYZ(2,I+1)/WVXYZ(1,I+1)

      YPCEN=VYVX0+(VYVX1-VYVX0)*XX

      ZCEN=WSXYZ(3,I)+(WSXYZ(3,I+1)-WSXYZ(3,I))*XX

      VZVX0=WVXYZ(3,I)/WVXYZ(1,I)
      VZVX1=WVXYZ(3,I+1)/WVXYZ(1,I+1)

      ZPCEN=VZVX0+(VZVX1-VZVX0)*XX

      RETURN
      END
+DECK,CIRCPIN1D.
*CMZ :  3.07/00 07/03/2019  14.05.52  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.63/03 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.57/03 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.57/00 22/11/2005  11.19.13  by  Michael Scheer
*CMZ :  2.34/00 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.33/09 10/05/2001  18.02.55  by  Michael Scheer
*CMZ :  2.16/08 24/10/2000  11.19.57  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  14.43.04  by  Michael Scheer
*CMZ : 00.02/04 25/02/97  17.37.15  by  Michael Scheer
*CMZ : 00.01/09 01/09/95  13.03.01  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  15.45.26  by  Michael Scheer
*CMZ : 00.00/06 29/04/94  21.43.32  by  Michael Scheer
*CMZ : 00.00/05 29/04/94  20.18.16  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.15  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE CIRCPIN1D(NY,MY,SPEC,RESULT,SUMP)
+seq,gplhint.

+SELF,IF=F90.
+SEQ,OBSERVF90U.
+SELF.

C---  SUBROUTINE TO INTEGRATE SPEC OVER CIRCULAR PINHOLE FOR IF1DIM OR VERT.
C     DIRECTION FOR IF1DIM=0
C     NZ,NY ARE ARRAY DIMENSIONS
C     INTEGRATION IS DONE FOR MY POINTS

      IMPLICIT NONE
+SEQ,CMPARA.
+SEQ,CONTRL.
+SEq,observf90.
+SEQ,FREQS.
+SEQ,PHYCON.

      INTEGER NY,IY,MY,IIY,IIY1,NB

      DOUBLE PRECISION RESULT,SUMP
     &  ,SPEC(NDOBSVYP)
     &  ,UF(NDOBSVYP)
     &  ,UY(NDOBSVYP)
     &  ,W1(NDOBSVYP),W2(NDOBSVYP),W3(NDOBSVYP),W4(NDOBSVYP),COEFF(NDOBSVYP)
     &  ,ANS1,ANS2,ANS3,ANS,YLO,YHI,FLO,FHI,YLO2,YLO3,YHI2,YHI3,R4,PINR2,
     &  F2LO,F2HI,SQRRYH2,SQRRYL2,SQLO,SQHI,ASINLO,ASINHI

      IF (MY.LT.2) THEN
        WRITE(6,*) '*** ERROR IN CIRCPIN1D: MY TOO LOW ***'
        STOP
      ENDIF

C--- LOOP OF VERTICAL DIRECTION

      RESULT=0.0D0
      PINR2=PINR**2
      R4=PINR2**2

      IF (IF1DIM.NE.0) THEN

        DO IY=1,NY
          UY(IY)=OBSVY(IY)-PINCEN(2)
          UF(IY)=SPEC(IY)
        ENDDO !IY

        NB=(NY-MY)/2
        IIY=NY

      ELSE

        IIY=0
        DO IY=(NY-MY)/2+1,(NY-MY)/2+MY
          IIY=IIY+1
          UY(IIY)=OBSVY(IY)-PINCEN(2)
          UF(IIY)=SPEC(IIY)
        ENDDO !IY

        NB=0

      ENDIF !IF1DIM

      CALL UTIL_SPLINE_COEF(UY,UF,IIY,-9999.0d0,-9999.0d0,COEFF,W1,W2,W3,W4)

      DO IIY=NB+2,NB+MY

        IIY1=IIY-1

        YLO=UY(IIY1)
        YHI=UY(IIY)
        FLO=UF(IIY1)
        FHI=UF(IIY)
        F2LO=COEFF(IIY1)
        F2HI=COEFF(IIY)

        YLO2=YLO**2
        YHI2=YHI**2
        YLO3=YLO2*YLO
        YHI3=YHI2*YHI

        SQLO=PINR2-YLO2
        SQHI=PINR2-YHI2

        IF (SQLO.GT.0.0D0) THEN
          SQRRYL2=SQRT(SQLO)
        ELSE
          SQRRYL2=0.0D0
        ENDIF

        IF (SQHI.GT.0.0D0) THEN
          SQRRYH2=SQRT(SQHI)
        ELSE
          SQRRYH2=0.0D0
        ENDIF

        SQLO=YLO/PINR
        SQHI=YHI/PINR

        IF (SQLO.LE.-1.0D0) THEN
          ASINLO=-PI1/2.D0
        ELSE
          ASINLO=ASIN(SQLO)
        ENDIF

        IF (SQHI.GE.1.0D0) THEN
          ASINHI=PI1/2.D0
        ELSE
          ASINHI=ASIN(SQHI)
        ENDIF

        ans3=-15.0d0*((4.0d0*(2.0d0*yhi-ylo)*ylo+3.0d0*PINR2)*f2lo*yhi-24.0d0*(fhi
     &    *ylo-flo*yhi)+(4.0d0*(yhi-2.0d0*ylo)*yhi-3.0d0*PINR2)*f2hi*ylo)*asinhi
     &    *PINR2

        ans2=
     &    (
     &    2.0d0*((20.0d0*yhi2-25.0d0*yhi*ylo+8.0d0*ylo2)*sqrryl2*ylo2
     &    +(7.0d0*yhi2-20.0d0*yhi*ylo+10.0d0*ylo2)*sqrryh2*yhi2-8.0d0*(
     &    sqrryh2-sqrryl2)*r4)+((80.0d0*yhi2+35.0d0*yhi*ylo-32.0d0*ylo2)
     &    *sqrryl2-(43.0d0*yhi2+80.0d0*yhi*ylo-40.0d0*ylo2)*sqrryh2)*PINR2
     &    )*f2lo+120.0d0*
     &    (
     &    ((3.0d0*yhi-2.0d0*ylo)*sqrryl2*ylo-sqrryh2*yhi2-2.0d0
     &    *(sqrryh2-sqrryl2)*PINR2)*flo-((2.0d0*yhi-3.0d0*ylo)*sqrryh2*yhi+
     &    sqrryl2*ylo2-2.0d0*(sqrryh2-sqrryl2)*PINR2)*fhi
     &    )+
     &    (
     &    2.0d0*((10.0d0*
     &    yhi2-20.0d0*yhi*ylo+7.0d0*ylo2)*sqrryl2*ylo2+(8.0d0*yhi2-
     &    25.0d0*yhi*ylo+20.0d0*ylo2)*sqrryh2*yhi2+8.0d0*(sqrryh2-sqrryl2)
     &    *r4)+((40.0d0*yhi2-80.0d0*yhi*ylo-43.0d0*ylo2)*sqrryl2-(32.0d0*
     &    yhi2-35.0d0*yhi*ylo-80.0d0*ylo2)*sqrryh2)*PINR2
     &    )*f2hi+15.0d0*
     &    (
     &    (4.0d0*(2.0d0*yhi-ylo)*ylo+3.0d0*PINR2)*
     &    f2lo*yhi-24.0d0*(fhi*ylo-flo*yhi)+
     &    (4.0d0*(yhi-2.0d0*ylo)*yhi-3.0d0*PINR2)*f2hi*ylo
     &    )*asinlo*PINR2

        ans1=-(ans2+ans3)
        ans=ans1/(720.0d0*(yhi-ylo))

        RESULT=RESULT+ans

      ENDDO !IY

      RESULT=2.0D0*RESULT !FAKTOR 2, DA NUR R IN REDUCE ALS BREITE

C NOW CHECK FOR PROBLEMS WITH SPLINES
      SUMP=RESULT

      RETURN
      END
+DECK,thickapp,T=F77.
*CMZ :  4.01/02 17/03/2023  21.47.36  by  Michael Scheer
*CMZ :  2.57/04 01/02/2006  15.08.35  by  Michael Scheer
*CMZ :  2.57/00 03/11/2005  16.29.31  by  Michael Scheer
*CMZ :  2.56/00 11/10/2005  15.29.20  by  Michael Scheer
*-- Author :    Michael Scheer   10/10/2005
      subroutine thickapp(icirc,al,ar,alpha0,corr)
+seq,gplhint.

      implicit none

      double precision pi
      parameter (PI=3.14159265359d0)

      double precision al,ar,corr,ys,xs,f,f0,phi,alpha0

      integer icirc

      if (icirc.ne.0) then

C Berechnet effektive Oeffnung durch einen Kollimator
C Ansatz: Schnittflaeche zweier verschobener Kreise

        xs=alpha0*al/2.0d0
        ys=sqrt(ar**2-xs**2)
        phi=2.0d0*acos(xs/ar)

        f0=pi*ar**2
        f=2.0d0*(f0*phi/(2.0d0*pi)-ys*xs)

        corr=f/f0

      else  !(icirc.ne.0) then

c Naeherung: Der cos wird vernachlaessigt, d.h. z.B. bei al=0 haengt die Apertur nicht
c         vom Winkel ab, was falsch ist, da sie mit cos(alpha) kleiner wird.

        corr=max(1.0d0-tan(alpha0)*al/(2.0d0*ar),0.0d0)

      endif  !(icirc.ne.0) then

      return
      end
+DECK,idtrmshgf.
*CMZ :  4.00/04 27/08/2019  11.49.27  by  Michael Scheer
*CMZ :  3.04/00 23/01/2018  12.41.22  by  Michael Scheer
*CMZ :  3.03/04 18/12/2017  12.11.39  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  10.38.36  by  Michael Scheer
*CMZ :  2.63/05 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.61/01 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.61/00 30/01/2007  19.54.23  by  Michael Scheer
*-- Author :    Michael Scheer   30/01/2007
      SUBROUTINE IDTRMSHGF(XIN,YIN,ZIN,VXI,VYI,VZI,XF,YF,ZF,VXF,VYF,VZF,
     &  XCO0,YCO0,ZCO0,VXCO0,VYCO0,VZCO0,XCOF,YCOF,ZCOF,VXCOF,VYCOF,VZCOF,
     &  coefile)
+seq,gplhint.

C--- TRACKING WITH POLYNOMIAL-EXPANSION OF GENERATING FUNCTION

C XIN,YIN,ZIN,XF,YF,ZF ARE COORDINATES IN LAB

      IMPLICIT NONE

+seq,contrl.
+seq,optic.
+seq,genfun.
+seq,b0scglob.
+seq,phycon.

      DOUBLE PRECISION
     &  EWS(3),EWY(3),EWZ(3),EN,
     &  EWSF(3),EWYF(3),EWZF(3),YW,ZW,ZPW,YPW,SPW,
     &  YIN,ZIN,YF,ZF,YPF,ZPF,YACC,X0,Y0,Z0,
     &  XIN,VXI,VYI,VZI,V0,VXINN,VYINN,VZINN,VXF,VYF,VZF,
     &  XCO0,YCO0,ZCO0,VXCO0,VYCO0,VZCO0,XCOF,YCOF,ZCOF,VXCOF,VYCOF,VZCOF,
     &  BXF,BYF,BZF,AXF,AYF,AZF,SNENN2,PAX,PAY,DXX,DYY,DFFX,FFX,FFY,DFFY,
     &  BRHOABS,SNENN,sin

      REAL*8 AKOEFF(NORDNG,NORDNG,NORDNG,NORDNG)
      REAL*8 QXPOW(NORDNG+1),PXPOW(NORDNG+1)
      REAL*8 QYPOW(NORDNG+1),PYPOW(NORDNG+1)
      REAL*8 TRANSFM(4,4)
      REAL*8 A1100,A2000,A0200,A1000,A0100,A0011,A0020,A0002
      REAL*8 PXI,QXI,QYI,PYI,PX,PY,QX,QY,DX,DY,DZ,YWF,ZWF,XF,
     &  XL,YL,ZL,RNENN,pxi0,pyi0,pxf0,pyf0

      REAL*8
     &   XF0,YF0,ZF0
     &  ,ZP0,YP0
     &  ,BX0,BY0,BZ0
     &  ,AX0,AY0,AZ0
     &  ,ZPF0,YPF0
     &  ,BXF0,BYF0,BZF0
     &  ,AXF0,AYF0,AZF0

      REAL*8 AXR0,AYR0,AZR0
      REAL*8 AXR,AYR,AZR
      REAL*8 BXI,BYI,BZI
      REAL*8 AXI,AYI,AZI
      REAL*8 AXRF0,AYRF0,AZRF0,A0SCALE,PEL

      INTEGER ICAL,LUNCOE,JCHARGE,MORDNG,JMAX,IREAD,JWRITE,IWRITE,
     &  I,J,K,L,JLOOP,IZAPER,IYAPER,
     &  I1,J1,K1,L1,
     &  I2,J2,K2,L2,IPOW,nkoef

      CHARACTER(*) COEFILE
      CHARACTER*65 CODETRA

      DATA LUNCOE/89/
      DATA ICAL/0/

      DATA QXPOW(1)/0./
      DATA PXPOW(1)/0./
      DATA QYPOW(1)/0./
      DATA PYPOW(1)/0./

      DATA QXPOW(2)/1./
      DATA PXPOW(2)/1./
      DATA QYPOW(2)/1./
      DATA PYPOW(2)/1./

      DATA JMAX/20/,YACC/1.D-10/

C--- INITIALIZATION {

      IF (ICAL.EQ.0) THEN

        PEL=EMASSE1*DSQRT( (DMYGAMMA+1.0D0)*(DMYGAMMA-1.0D0) )
        BRHOABS=PEL/CLIGHT1  !ABSOLUTE VALUE

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'      IDTRMSHGF:'
        WRITE(LUNGFO,*)

c        COEFILE='wave_erzfun.in'

C Einlesen der Koeeficenten  GF(i,j) !!!

        OPEN(UNIT=LUNCOE,FILE = COEFILE,STATUS ='OLD')

        IREAD=0

        READ(LUNCOE,'(1A65)')CODETRA
        READ(LUNCOE,*)JCHARGE,MORDNG

        IF (JCHARGE.NE.ICHARGE) THEN
          WRITE(LUNGFO,*)'*** ERROR IN IDTRMSHGF:  ***'
          WRITE(LUNGFO,*)'GENERATING FUNCTION REFERES TO CHARGE',JCHARGE
          WRITE(6,*)'*** ERROR IN IDTRMSHGF:  ***'
          WRITE(6,*)'GENERATING FUNCTION REFERES TO CHARGE',JCHARGE
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF !JCHARGE

        IF (MORDNG.GT.NORDNG) THEN
          WRITE(LUNGFO,*)'*** ERROR IN IDTRMSHGF:  ***'
          WRITE(LUNGFO,*)'*** DIMENSION NORDNG EXCEEDED'
          WRITE(LUNGFO,*)
     &    'TOO HIGH! INCREASE PARAMETER NORDNG IN GENFUN.CMN'
          WRITE(6,*)'*** ERROR IN IDTRMSHGF:  ***'
          WRITE(6,*)'*** DIMENSION NORDNG EXCEEDED'
          WRITE(6,*)
     &    'TOO HIGH! INCREASE PARAMETER NORDNG IN GENFUN.CMN'
          STOP '*** PROGRAM WAVE ABORTED ***'
        ENDIF

        READ(LUNCOE,*)ZAPERT,YAPERT,DLAPER,sin

        READ(LUNCOE,*)X0,Y0,Z0
     &    ,ZP0,YP0
     &    ,BX0,BY0,BZ0
     &    ,AX0,AY0,AZ0

        READ(LUNCOE,*)XF0,YF0,ZF0
     &    ,ZPF0,YPF0
     &    ,BXF0,BYF0,BZF0
     &    ,AXF0,AYF0,AZF0

        READ(LUNCOE,*)EWS(1),EWS(2),
     &    EWS(3)
        READ(LUNCOE,*)EWSF(1),EWSF(2),
     &    EWSF(3)
        READ(LUNCOE,*)A0SCALE

        IF (
     &      ABS(X0-XCO0).GT.YACC.OR.
     &      ABS(Y0-YCO0).GT.YACC.OR.
     &      ABS(Z0-ZCO0).GT.YACC.OR.
     &      ABS(YP0-VYCO0/VXCO0).GT.YACC.OR.
     &      ABS(ZP0-VZCO0/VXCO0).GT.YACC.OR.
     &      ABS(XF0-XCOF).GT.YACC.OR.
     &      ABS(YF0-YCOF).GT.YACC.OR.
     &      ABS(ZF0-ZCOF).GT.YACC.OR.
     &      ABS(YPF0-VYCOF/VXCOF).GT.YACC.OR.
     &      ABS(ZPF0-VZCOF/VXCOF).GT.YACC
     &      ) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '*** WARNING IN IDTRMSHGF: DISCREPANCIES OF CLOSED ORBITS'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)' REFERENCE ORBIT AT ENTRANCE:'
          WRITE(LUNGFO,*)XCO0
          WRITE(LUNGFO,*)YCO0
          WRITE(LUNGFO,*)ZCO0
          WRITE(LUNGFO,*)VYCO0/VXCO0
          WRITE(LUNGFO,*)VZCO0/VXCO0
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)' REFERENCE ORBIT AT EXIT:'
          WRITE(LUNGFO,*)XCOF
          WRITE(LUNGFO,*)YCOF
          WRITE(LUNGFO,*)ZCOF
          WRITE(LUNGFO,*)VYCOF/VXCOF
          WRITE(LUNGFO,*)VZCOF/VXCOF
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)' CLOSED ORBIT OF GF AT ENTRANCE:'
          WRITE(LUNGFO,*)X0
          WRITE(LUNGFO,*)Y0
          WRITE(LUNGFO,*)Z0
          WRITE(LUNGFO,*)YP0
          WRITE(LUNGFO,*)ZP0
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)' CLOSED ORBIT OF GF AT EXIT:'
          WRITE(LUNGFO,*)XF0
          WRITE(LUNGFO,*)YF0
          WRITE(LUNGFO,*)ZF0
          WRITE(LUNGFO,*)YPF0
          WRITE(LUNGFO,*)ZPF0
        ENDIF

11      CONTINUE

        READ (LUNCOE,*,END=99) I,J,K,L
     &    ,AKOEFF(I+1,J+1,K+1,L+1)

        IF(I+1.GT.NORDNG.OR.J+1.GT.NORDNG
     &      .OR.K+1.GT.NORDNG.OR.L+1.GT.NORDNG) THEN
          WRITE(6,*)
          WRITE(6,*)'*** ERROR SR IDTRMSHGF ***'
          WRITE(6,*)'ORDER OF COEFFICIENTS ON FILE'
          WRITE(6,*)coefile(1:len_trim(coefile))
          WRITE(6,*)
     &      'TOO HIGH INCREASE PARAMETER NORDNG IN GENFUN.CMN'
          WRITE(6,*)
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR SR IDTRMSHGF ***'
          WRITE(LUNGFO,*)'ORDER OF COEFFICIENTS ON FILE'
          WRITE(LUNGFO,*)coefile(1:len_trim(coefile))
          WRITE(LUNGFO,*)
     &      'TOO HIGH INCREASE PARAMETER NORDNG IN GENFUN.CMN'
          WRITE(LUNGFO,*)
          STOP
        ENDIF
        IREAD=IREAD+1
        GOTO 11

99      CONTINUE

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'      ',IREAD,' coeffs. read from file:'
        WRITE(LUNGFO,*)coefile(1:len_trim(coefile))
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)CODETRA
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
+self,if=coefprint.
        DO I=1,MORDNG
          DO J=1,MORDNG
            DO K=1,MORDNG
              DO L=1,MORDNG

                IF (AKOEFF(I,J,K,L).NE.0.D0) THEN
                  WRITE(LUNGFO,1000) I-1,J-1,K-1,L-1,
     &              AKOEFF(I,J,K,L)
                ENDIF
1000            FORMAT (' a(',4I1,')',1PE20.10)

                IF (AKOEFF(I,J,K,L).NE.0.D0) THEN
                  WRITE(6,1000) I-1,J-1,K-1,L-1
     &              ,AKOEFF(I,J,K,L)
                ENDIF

              ENDDO
            ENDDO
          ENDDO
        ENDDO
+self.,if=coefprint.

        CLOSE(LUNCOE)

C--- CANONICAL MOMENTUM OF REFERENCE ORBIT

C     UNIT-VECTOR EWZ=[EWS,(0,1,0)] (CROSS-PRODUCT)

        EN=1.D0/DSQRT(
     &    EWS(3)*EWS(3)
     &    +EWS(1)*EWS(1))

        EWZ(1)=-EWS(3)*EN
        EWZ(2)= 0.
        EWZ(3)=+EWS(1)*EN

C     UNIT-VECTOR EWY=[EWZ,EWS]

        EWY(1)=-EWS(2)*EWZ(3)
     &    + EWS(3)*EWZ(2)
        EWY(2)=-EWS(3)*EWZ(1)
     &    + EWS(1)*EWZ(3)
        EWY(3)=-EWS(1)*EWZ(2)
     &    + EWS(2)*EWZ(1)

        EN=1.0D0/DSQRT(
     &    EWSF(3)*EWSF(3)
     &    +EWSF(1)*EWSF(1))
        EWZF(1)=-EWSF(3)*EN
        EWZF(2)= 0.
        EWZF(3)=+EWSF(1)*EN

        EWYF(1)=-EWSF(2)*EWZF(3)
     &    + EWSF(3)*EWZF(2)
        EWYF(2)=-EWSF(3)*EWZF(1)
     &    + EWSF(1)*EWZF(3)
        EWYF(3)=-EWSF(1)*EWZF(2)
     &    + EWSF(2)*EWZF(1)

        AXR0=AX0*EWS(1)
     &    +AY0*EWS(2)
     &    +AZ0*EWS(3)

        AYR0=AX0*EWY(1)
     &    +AY0*EWY(2)
     &    +AZ0*EWY(3)

        AZR0=AX0*EWZ(1)
     &    +AY0*EWZ(2)
     &    +AZ0*EWZ(3)

        AXRF0=AXF0*EWSF(1)
     &    +AYF0*EWSF(2)
     &    +AZF0*EWSF(3)

        AYRF0=AXF0*EWYF(1)
     &    +AYF0*EWYF(2)
     &    +AZF0*EWYF(3)

        AZRF0=AXF0*EWZF(1)
     &    +AYF0*EWZF(2)
     &    +AZF0*EWZF(3)

c18.1.2018{
        if (icharge.gt.0) then
          RNENN=SQRT(1.0D0 + ZP0**2 + YP0**2)
          PXI0=AZR0/BRHOABS + ZP0/RNENN
          PYI0=AYR0/BRHOABS + YP0/RNENN
          RNENN=SQRT(1.0D0 + ZPf0**2 + YPf0**2)
          PXf0=AZRf0/BRHOABS + ZPf0/RNENN
          PYf0=AYRf0/BRHOABS + YPf0/RNENN
        else
          RNENN=SQRT(1.0D0 + ZP0**2 + YP0**2)
          PXI0=-AZR0/BRHOABS + ZP0/RNENN
          PYI0=-AYR0/BRHOABS + YP0/RNENN
          RNENN=SQRT(1.0D0 + ZPf0**2 + YPf0**2)
          PXf0=-AZRf0/BRHOABS + ZPf0/RNENN
          PYf0=-AYRf0/BRHOABS + YPf0/RNENN
        endif
c18.1.2018}

C--- LINEARE TRANSFERMATRIX OHNE KOPPLUNG-TERME

        A1100=AKOEFF(2,2,1,1)
        A2000=AKOEFF(3,1,1,1)
        A0200=AKOEFF(1,3,1,1)
        A1000=AKOEFF(2,1,1,1)
        A0100=AKOEFF(1,2,1,1)

        A0011=AKOEFF(1,1,2,2)
        A0020=AKOEFF(1,1,3,1)
        A0002=AKOEFF(1,1,1,3)

        TRANSFM(1,1)=(-4.D0*AKOEFF(3,1,1,1)
     &    *AKOEFF(1,3,1,1)*AKOEFF(1,1,2,2)
     &    +2.D0*AKOEFF(3,1,1,1)*
     &    AKOEFF(1,2,2,1)*AKOEFF(1,2,1,2)
     &    +AKOEFF(2,2,1,1)**2.D0*AKOEFF(1,1,2,2)
     &    -AKOEFF(2,2,1,1)*
     &    AKOEFF(2,1,2,1)*AKOEFF(1,2,1,2)
     &    -AKOEFF(2,2,1,1)*AKOEFF(2,1,1,2)
     &    *AKOEFF(1,2,2,1)+2.D0*
     &    AKOEFF(2,1,2,1)*AKOEFF(2,1,1,2)*AKOEFF(1,3
     &    ,1,1))/(AKOEFF(2,2,1,1)
     &    *AKOEFF(1,1,2,2)-
     &    AKOEFF(2,1,1,2)*AKOEFF(1,2,2,1))
        TRANSFM(1,2)=(2.D0*AKOEFF(1,3,1,1)
     &    *AKOEFF(1,1,2,2)-AKOEFF(1,2,2,1)
     &    *AKOEFF(1,2,1,2))/(AKOEFF
     &    (2,2,1,1)*AKOEFF(1,1,2,2)-AKOEFF(2,1,1,
     &    2)*AKOEFF(1,2,2,1))
        TRANSFM(1,3)=(AKOEFF(2,2,1,1)*AKOEFF(1,2,2,1
     &    )*AKOEFF(1,1,2,2)-2.D0
     &    *AKOEFF(2,2,1,1)*AKOEFF(
     &    1,2,1,2)*AKOEFF(1,1,3,1)
     &    -2.D0*AKOEFF(2,1,2,1)*AKOEFF(1,3,1,1)
     &    *AKOEFF(1,1,2,2)+AKOEFF(2,1,2,1)
     &    *AKOEFF(1,2,2,1)*AKOEFF(1,2,1,2)
     &    +4.D0*AKOEFF(2,1,1,2)*AKOEFF(1,3,1,1)*
     &    AKOEFF(1,1,3,1)-AKOEFF(2,1,1,2)
     &    *AKOEFF(1,2,2,1)**2)/(AKOEFF(2,2,1,1)
     &    *AKOEFF(1,1,2,2)-AKOEFF(2,1,1,2)
     &    *AKOEFF(1,2,2,1))
        TRANSFM(1,4)=(AKOEFF(2,2,1,1)*AKOEFF(1,2,1,2
     &    )-2.D0*AKOEFF(2,1,1,2)
     &    *AKOEFF(1,3,1,1))/(AKOEFF(2,2,1,1)
     &    *AKOEFF(1,1,2,2)-AKOEFF(2,1,1,
     &    2)*AKOEFF(1,2,2,1))
        TRANSFM(2,1)=(-2.D0*AKOEFF(3,1,1,1)
     &    *AKOEFF(1,1,2,2)+AKOEFF(2,1,2,1)
     &    *AKOEFF(2,1,1,2))/(
     &    AKOEFF(2,2,1,1)*AKOEFF(1,1,2,2)
     &    -AKOEFF(2,1,1,2)*AKOEFF(1,2,2,1))
        TRANSFM(2,2)=AKOEFF(1,1,2,2)/
     &    (AKOEFF(2,2,1,1)*AKOEFF(1,1,2,2)
     &    -AKOEFF(2,1,1,2)*AKOEFF(1,2,2,1))
        TRANSFM(2,3)=(-AKOEFF(2,1,2,1)*AKOEFF(1,1,2,
     &    2)+2.D0*AKOEFF(2,1,1,2)
     &    *AKOEFF(1,1,3,1))/(
     &    AKOEFF(2,2,1,1)*AKOEFF(1,1,2,2)
     &    -AKOEFF(2,1,1,2)*AKOEFF(1,2,2,1))
        TRANSFM(2,4)=(-AKOEFF(2,1,1,2))/
     &    (AKOEFF(2,2,1,1)*AKOEFF(1,1,2,2)
     &    -AKOEFF(2,1,1,2)*AKOEFF(1,2,2,1))
        TRANSFM(3,1)=(4.D0*AKOEFF(3,1,1,1)
     &    *AKOEFF(1,2,2,1)*AKOEFF(1,1,1,3)
     &    -2.D0*AKOEFF(3,1,1,1)*
     &    AKOEFF(1,2,1,2)*AKOEFF(1,1,2,2)
     &    -2.D0*AKOEFF(2,2,1,1)*AKOEFF(2,1,2,1)
     &    *AKOEFF(1,1,1,3)+
     &    AKOEFF(2,2,1,1)*AKOEFF(2,1,1,2)
     &    *AKOEFF(1,1,2,2)+AKOEFF(2,1,2,1)
     &    *AKOEFF(2,1,1,2)*AKOEFF(1,2,1,2)
     &    -AKOEFF(2,1,1,2)**2.D0*AKOEFF(1,
     &    2,2,1))/(AKOEFF(2,2,1,1)
     &    *AKOEFF(1,1,2,2)
     &    -AKOEFF(2,1,1,2)*AKOEFF(1,2,2,1))
        TRANSFM(3,2)=(-2.D0*AKOEFF(1,2,2,1)
     &    *AKOEFF(1,1,1,3)+AKOEFF(1,2,1,2)
     &    *AKOEFF(1,1,2,2))/(AKOEFF(2,2,1,1)
     &    *AKOEFF(1,1,2,2)-AKOEFF(2,1
     &    ,1,2)*AKOEFF(1,2,2,1))
        TRANSFM(3,3)=(-4.D0*AKOEFF(2,2,1,1)
     &    *AKOEFF(1,1,
     &    3,1)*AKOEFF(1,1,1,3)
     &    +AKOEFF(2,2,1,1)*
     &    AKOEFF(1,1,2,2)**2+2.D0*AKOEFF(2,1,2,1)
     &    *AKOEFF(
     &    1,2,2,1)*AKOEFF(1,1,1,3)
     &    -AKOEFF(2,1,2,1)*AKOEFF(1,2,1,2)
     &    *AKOEFF(1,1,2,2)-AKOEFF(2,1,1,2)
     &    *AKOEFF(1,2,2,1)*AKOEFF(1,1,2,
     &    2)+2.D0*AKOEFF(2,1,1,2)
     &    *AKOEFF(1,2,1,2)*
     &    AKOEFF(1,1,3,1))/(AKOEFF(2,2,1,1)
     &    *AKOEFF(1,1,2,2)-AKOEFF(2,1,1,2)
     &    *AKOEFF(1,2,2,1))
        TRANSFM(3,4)=(2.D0*AKOEFF(2,2,1,1)
     &    *AKOEFF(1,1,1,3)-AKOEFF(2,1,1,2)
     &    *AKOEFF(1,2,1,2))/(AKOEFF
     &    (2,2,1,1)*AKOEFF(1,1,2,2)
     &    -AKOEFF(2,1,1,2)*AKOEFF(1,2,2,1))
        TRANSFM(4,1)=(2.D0*AKOEFF(3,1,1,1)
     &    *AKOEFF(1,2,2,1)-AKOEFF(2,2,1,1)
     &    *AKOEFF(2,1,2,1))/(AKOEFF
     &    (2,2,1,1)*AKOEFF(1,1,2,2)
     &    -AKOEFF(2,1,1,2)*AKOEFF(1,2,2,1))
        TRANSFM(4,2)=(-AKOEFF(1,2,2,1))
     &    /(AKOEFF(2,2,1,1)*AKOEFF(1,1,2,2)
     &    -AKOEFF(2,1,1,2)*AKOEFF(1,2,2,1))
        TRANSFM(4,3)=(-2.D0*AKOEFF(2,2,1,1)
     &    *AKOEFF(1,1,3,1)+AKOEFF(2,1,2,1)
     &    *AKOEFF(1,2,2,1))/(
     &    AKOEFF(2,2,1,1)*AKOEFF(1,1,2,2)
     &    -AKOEFF(2,1,1,2)*AKOEFF(1,2,2,1))
        TRANSFM(4,4)=AKOEFF(2,2,1,1)/
     &    (AKOEFF(2,2,1,1)*AKOEFF(1,1,2,2)
     &    -AKOEFF(2,1,1,2)*AKOEFF(1,2,2,1))

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '      Linear Transfer Matrix from Generating Function'
        WRITE(LUNGFO,*)
        DO IWRITE=1,4
          WRITE(LUNGFO,*)'      ',(SNGL(TRANSFM(IWRITE,JWRITE))
     &      ,JWRITE=1,4)
        ENDDO
        WRITE(LUNGFO,*)

        ICAL=1

      ENDIF   !JCAL.EQ.0

C--- INITIALIZATION }

C --- ARE WE IN ENTRANCE PLAN?

      DX=XIN-X0
      DY=YIN-Y0
      DZ=ZIN-Z0

      IF (DX*EWS(1)+DY*EWS(2)+DZ*EWS(3) .GT. 1.0D-9) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '*** WARNING IN IDTRMSHGF: STARTING POINT NOT IN ENTRANCE PLANE'
        WRITE(LUNGFO,*)'XIN:',XIN
        WRITE(LUNGFO,*)'YIN:',YIN
        WRITE(LUNGFO,*)'ZIN:',ZIN
        WRITE(LUNGFO,*)
      ENDIF

      YW=DY
      ZW=DZ

      V0=SQRT(VXI**2+VYI**2+VZI**2)

      VXINN=VXI/V0
      VYINN=VYI/V0
      VZINN=VZI/V0

      SPW=VXINN*EWS(1)+VYINN*EWS(2)+VZINN*EWS(3)
      YPW=VXINN*EWY(1)+VYINN*EWY(2)+VZINN*EWY(3)
      ZPW=VXINN*EWZ(1)+VYINN*EWZ(2)+VZINN*EWZ(3)

      YPW=YPW/SPW
      ZPW=ZPW/SPW

      IF (IERZFUN.LT.0.0) THEN

C--- ONLY APPLY LINEAR TRANSFER MATRIX

        ZWF =   TRANSFM(1,1)*ZW + TRANSFM(1,2)*ZPW
     &    +   TRANSFM(1,3)*YW + TRANSFM(1,4)*YPW
        ZPF =  TRANSFM(2,1)*ZW + TRANSFM(2,2)*ZPW
     &    +   TRANSFM(2,3)*YW + TRANSFM(2,4)*YPW
        YWF =   TRANSFM(3,1)*ZW + TRANSFM(3,2)*ZPW
     &    +   TRANSFM(3,3)*YW + TRANSFM(3,4)*YPW
        YPF =  TRANSFM(4,1)*ZW + TRANSFM(4,2)*ZPW
     &    +   TRANSFM(4,3)*YW + TRANSFM(4,4)*YPW

        XF=XF0+ZWF*EWZF(1)+YWF*EWYF(1)
        YF=YF0+ZWF*EWZF(2)+YWF*EWYF(2)
        ZF=ZF0+ZWF*EWZF(3)+YWF*EWYF(3)

cmsh20171128 VXF=V0*EWSF(1)
cmsh20171128 VYF=VXF*YPF
cmsh20171128 VZF=VXF*ZPF

        VXF=V0*vxinn
        VYF=v0*vyinn+vxf*ypf
        VZF=v0*vzinn+vxf*zpf

        RETURN

      ENDIF !IERZFUN .LT.0

C--- HARDWARE APERTURE

      IF (DABS(ZW).GT.DABS(ZAPERT)
     &    .OR.  DABS(ZW+ZPW*DLAPER).GT.DABS(ZAPERT)) THEN
        IZAPER=1
        WRITE(6,*)'*** HORI. APERTURE WARNING IN IDTRMSHGF:'
        WRITE(6,*)'ZW,ZPW:',ZW,ZPW
      ENDIF

      IF (DABS(YW).GT.DABS(YAPERT)
     &    .OR.  DABS(YW+YPW*DLAPER).GT.DABS(YAPERT)) THEN
        IYAPER=1
        WRITE(6,*)'*** VERTICAL APERTURE WARNING IN IDTRMSHGF:'
        WRITE(6,*)'YW,YPW:',YW,YPW
      ENDIF

      IF (A0SCALE.NE.0.0D0) THEN

        CALL MYBFELD(XIN,YIN,ZIN,BXI,BYI,BZI,AXI,AYI,AZI)

      ELSE

        AXI=0.D0
        AYI=0.D0
        AZI=0.D0

      ENDIF

      AXR=AXI*EWS(1)
     &  +AYI*EWS(2)+AZI*EWS(3)
      AYR=AXI*EWY(1)
     &  +AYI*EWY(2)+AZI*EWY(3)
      AZR=AXI*EWZ(1)
     &  +AYI*EWZ(2)+AZI*EWZ(3)

C--- KANONISCHE VARIABLEN

      QXI= ZW
      QYI= YW
      RNENN=SQRT(1.0D0 + ZPW**2 + YPW**2)
c18.1.2018{
c      PXI = (AZR-AZR0)/BRHOABS + ZPW/RNENN
c      PYI = (AYR-AYR0)/BRHOABS + YPW/RNENN
c18.1.2018}
c18.1.2018{
      if (icharge.gt.0) then
        PXI=AZR/BRHOABS + ZPW/RNENN-pxi0
        PYI=AYR/BRHOABS + YPW/RNENN-pyi0
      else
        PXI=-AZR/BRHOABS + ZPW/RNENN-pxi0
        PYI=-AYR/BRHOABS + YPW/RNENN-pyi0
      endif
c18.1.2018}

C****************************************************************

C--- BERECHNE DIE SCHAETZWERTE MITTELS DER LINEAREN TRANFERMATRIX

C      XF =  TRANSFM(1,1)*X + TRANSFM(1,2)*XP
C     &   +  TRANSFM(1,3)*Z + TRANSFM(1,4)*ZP
C      XPF =  TRANSFM(2,1)*X + TRANSFM(2,2)*XP
C     &   +  TRANSFM(2,3)*Z + TRANSFM(2,4)*ZP
C      ZF =  TRANSFM(3,1)*X + TRANSFM(3,2)*XP
C     &   +  TRANSFM(3,3)*Z + TRANSFM(3,4)*ZP
C      ZPF =  TRANSFM(4,1)*X + TRANSFM(4,2)*XP
C     &   +  TRANSFM(4,3)*Z + TRANSFM(4,4)*ZP

C         RNENN = DSQRT(1.D0 + XPF**2 + ZPF**2)
C
C         PX =  XPF/RNENN
C         PY =  ZPF/RNENN
C

      PX =  TRANSFM(2,1)*QXI + TRANSFM(2,2)*PXI
     &  +  TRANSFM(2,3)*QYI + TRANSFM(2,4)*PYI
      PY =  TRANSFM(4,1)*QXI + TRANSFM(4,2)*PXI
     &  +  TRANSFM(4,3)*QYI + TRANSFM(4,4)*PYI

C****************************************************************

C      goto 321

c--  Beginn der Newton Fit Routine:

      DO JLOOP=1,JMAX

C****************************************************************

C---  POTENZTERME BERECHEN
C  Z.B. QXPOW(1)=0.,QXPOW(2)=1.,QXPOW(3)=QXI,QXPOW(4)=QXI**2

        DO IPOW=2,MORDNG
          QXPOW(IPOW+1)=QXPOW(IPOW)*QXI
          PXPOW(IPOW+1)=PXPOW(IPOW)*PX
          QYPOW(IPOW+1)=QYPOW(IPOW)*QYI
          PYPOW(IPOW+1)=PYPOW(IPOW)*PY
        END DO

        FFX=0.D0
        DFFX=0.D0
        FFY=0.D0
        DFFY=0.D0

C--- PARTIELLE ABLEITUNGEN DER ERZEUGENDEN-FUNKTION BERECHEN

        DO I=0,MORDNG-1
          DO J=0,MORDNG-1
            DO K=0,MORDNG-1
              DO L=0,MORDNG-1

                I1=I+1 !IN DEN FOLGENDEN BERECHNUNGEN SIND
                       !DIE I,J,K,L MATH.
                J1=J+1 !INDIZES, DIE I1,J1,K1,L1 DIE
                       ! ENTSPRECHENDEN FORTRAN
                K1=K+1 !INDIZES
                L1=L+1

                I2=I+2
                J2=J+2
                K2=K+2
                L2=L+2

                IF(I+J+K+L.GT.0 .AND. I+J+K+L.LT.MORDNG)
     &              THEN !OHNE CLOSED ORBIT

                  FFX =
     &              FFX + dble(I)*  AKOEFF(I1,J1,K1,L1)*
     &              QXPOW(I2-1)*PXPOW(J2)* QYPOW(K2)*  PYPOW(L2)

                  DFFX =
     &              DFFX + dble(I*J)*AKOEFF(I1,J1,K1,L1)*
     &              QXPOW(I2-1)*PXPOW(J2-1)*QYPOW(K2)*PYPOW(L2)
                  FFY =
     &              FFY  + dble(K)*  AKOEFF(I1,J1,K1,L1)*
     &              QXPOW(I2)*  PXPOW(J2)* QYPOW(K2-1)*  PYPOW(L2)

                  DFFY =
     &              DFFY + dble(K*L)*AKOEFF(I1,J1,K1,L1)*
     &              QXPOW(I2)*PXPOW(J2)*QYPOW(K2-1)*PYPOW(L2-1)

                ENDIF

              ENDDO
            ENDDO
          ENDDO
        ENDDO

        FFX=FFX-PXI
        FFY=FFY-PYI

C--- NEUE SCHAETZWERTE BERECHEN

        DXX=0.0
        IF(DFFX.NE.0.0) DXX  = FFX/DFFX
        DYY=0.0
        IF(DFFY.NE.0.0) DYY  = FFY/DFFY
        PX   = PX - DXX
        PY   = PY - DYY

        IF((DABS(DYY)+DABS(DXX)).LT.YACC) GOTO 123

      ENDDO

123   CONTINUE

      IF (JLOOP.GE.JMAX) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '*** WARNING SR IDTRMSHGF: NEWTOWN-FIT FAILED ***'
        WRITE(LUNGFO,*)'Z,ZP,Y,YP:'
        WRITE(LUNGFO,*)ZW,ZPW,YW,YPW
        WRITE(LUNGFO,*)'FFX,DXX,FFY,DYY:'
        WRITE(LUNGFO,*)FFX,DXX,FFY,DYY
        WRITE(LUNGFO,*)'FFX,DXX,FFY,DYY:'
        WRITE(LUNGFO,*)FFX,DXX,FFY,DYY
        WRITE(6,*)
        WRITE(6,*)
        WRITE(6,*)
     &    '*** WARNING SR IDTRMSHGF: NEWTOWN-FIT FAILED ***'
        WRITE(LUNGFO,*)'Z,ZP,Y,YP:'
        WRITE(LUNGFO,*)ZW,ZPW,YW,YPW
        WRITE(6,*)'FFX,DXX,FFY,DYY:'
        WRITE(6,*)FFX,DXX,FFY,DYY

      ENDIF

c-- Ende der Newton Fit Routine:

321   CONTINUE

CC Hier werden die End-Koordinaten berechnet

C****************************************************************
C---  POTENZTERME BERECHEN
C  Z.B. QXPOW(1)=0.,QXPOW(2)=1.,QXPOW(3)=QXI,QXPOW(4)=QXI**2

      DO IPOW=2,MORDNG
C          QXPOW(IPOW+1)=QXPOW(IPOW)*QXI
        PXPOW(IPOW+1)=PXPOW(IPOW)*PX
C          QYPOW(IPOW+1)=QYPOW(IPOW)*QYI
        PYPOW(IPOW+1)=PYPOW(IPOW)*PY
      END DO

C--- KOORDINATEN BERECHNEN

      QX=0.0D0
      QY=0.0D0

      DO I=0,MORDNG-1
        DO J=0,MORDNG-1
          DO K=0,MORDNG-1
            DO L=0,MORDNG-1

              I1=I+1 !IN DEN FOLGENDEN BERECHNUNGEN
                     !SIND DIE I,J,K,L MATH.
              J1=J+1 !INDIZES, DIE I1,J1,K1,L1 DIE
                     !ENTSPRECHENDEN FORTRAN
              K1=K+1 !INDIZES
              L1=L+1

              I2=I+2
              J2=J+2
              K2=K+2
              L2=L+2

              IF(I+J+K+L.GT.0 .AND. I+J+K+L.LT.MORDNG)
     &            THEN !OHNE CLOSED ORBIT

                QX =  QX + dble(J)*  AKOEFF(I1,J1,K1,L1)*
     &            QXPOW(I2)*PXPOW(J2-1)* QYPOW(K2)*  PYPOW(L2)

                QY = QY + dble(L)*  AKOEFF(I1,J1,K1,L1)*
     &            QXPOW(I2)*  PXPOW(J2)* QYPOW(K2)*  PYPOW(L2-1)

              ENDIF

            ENDDO
          ENDDO
        ENDDO
      ENDDO

C****************************************************************

1234  CONTINUE

C     UMSETZTEN DER KANONISCHEN VARIABLEN IN KOORDINATEN:

      ZW  = QX
      YW  = QY

      XL=XF0+ZW*EWZF(1)+YW*EWYF(1)
      YL=YF0+ZW*EWZF(2)+YW*EWYF(2)
      ZL=ZF0+ZW*EWZF(3)+YW*EWYF(3)

      IF (A0SCALE.NE.0.0D0) THEN

        CALL MYBFELD(XL,YL,ZL,BXF,BYF,BZF,AXF,AYF,AZF)

      ELSE

        AXF=0.D0
        AYF=0.D0
        AZF=0.D0

      ENDIF


      AXR=AXF*EWSF(1)
     &  +AYF*EWSF(2)+AZF*EWSF(3)
      AYR=AXF*EWYF(1)
     &  +AYF*EWYF(2)+AZF*EWYF(3)
      AZR=AXF*EWZF(1)
     &  +AYF*EWZF(2)+AZF*EWZF(3)

c18.1.2018{
c        PAX=PX-(AZR-AZRF0)/BRHOABS
c        PAY=PY-(AYR-AYRF0)/BRHOABS

      if (icharge.gt.0) then
        pax=px-azr/brhoabs+pxf0
        pay=py-ayr/brhoabs+pyf0
      else
        pax=px+azr/brhoabs+pxf0
        pay=py+ayr/brhoabs+pyf0
      endif
c18.1.2018}

      SNENN2 = 1.0D0 - PAX*PAX - PAY*PAY

c spezielle Einschub falls SNENN2<0 wird. Dann soll diese Subroutine
c nicht hier aussteigen sondern irgenwoanders im BETA-CODE. Dazu wird
c XPF und ZPF mit Faktor 1.D6 multipliziert:

      IF ( SNENN2 .GT. 0.0) THEN
        SNENN = DSQRT(SNENN2)
        ZPW = PAX/SNENN
        YPW = PAY/SNENN
      ELSE
        WRITE(6,*)'*** WARNING IN IDTRMSHGF:'
        WRITE(6,*)
     &    '*** NEGATIVE ROOT OF CANONICAL MOMENTUM -> INSTABILITY'
        ZPW = PX*1.0D6
        YPW = PY*1.0D6
      ENDIF

      YF=YL
      ZF=ZL

      YPF=YPW
      ZPF=ZPW

cmsh20171128 VXF=V0*EWSF(1)
cmsh20171128 VYF=VXF*YPF
cmsh20171128 VZF=VXF*ZPF

c18.1.2018{
c        VXF=V0*vxinn
c        VYF=v0*vyinn+vxf*ypf
c        VZF=v0*vzinn+vxf*zpf
      VXF=V0/sqrt(1.0d0+zpf**2+ypf**2)
      VYF=VXF*YPF
      VZF=VXF*ZPF
c18.1.2018}

      RETURN
      END
+DECK,USTEP.
*CMZ :  4.01/00 12/03/2023  14.28.40  by  Michael Scheer
*CMZ :  3.03/02 15/12/2015  16.08.16  by  Michael Scheer
*CMZ :  3.03/01 07/10/2015  14.45.17  by  Michael Scheer
*CMZ :  3.02/04 12/12/2014  15.55.26  by  Michael Scheer
*CMZ :  3.00/00 14/03/2013  11.59.45  by  Michael Scheer
*CMZ :  2.66/20 06/06/2012  15.22.24  by  Michael Scheer
*CMZ :  2.66/13 08/12/2010  09.44.42  by  Michael Scheer
*CMZ :  2.63/03 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.61/02 20/03/2007  16.42.23  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine ustep(x,y,z,vx,vy,vz,vxp,vyp,vzp,dt,gamma,dgamma)

c user routine, called after each tracking step

      implicit none

+seq,ustep.
+seq,uservar.

      double precision x,y,z,vx,vy,vz,vxp,vyp,vzp,dt,gamma,dgamma

c     x,y,z is the current position of the electron in meter
c     vx,vy,vz is the current velocity of the electron in meter/sec
c     vxp,vyp,vzp the derivative of the velocity in meter/sec**2
c     dt the time step in sec
c     gamma the current gamma factor
c     dgamma the energy loss of step in terms of gamma

      return
      end
+DECK,util_spline_inter_status.
*CMZ :  3.02/00 24/09/2014  13.51.08  by  Michael Scheer
*CMZ :  3.01/03 19/03/2014  12.24.14  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.66/20 07/06/2011  14.38.25  by  Michael Scheer
*CMZ : 00.00/09 07/06/2011  13.46.51  by  Michael Scheer
*CMZ : 00.00/07 08/09/2009  09.23.13  by  Michael Scheer
*CMZ : 00.00/05 06/03/2007  16.31.51  by  Michael Scheer
*CMZ : 00.00/02 25/08/2006  15.27.06  by  Michael Scheer
*CMZ : 00.00/01 23/02/96  14.56.50  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.27.54  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE UTIL_SPLINE_INTER_STATUS(XA,YA,Y2A,N,X,Y,MODE,ISTAT)
+seq,gplhint.

C---  INTERPOLATES Y(X) VIA SPLINE

C--   INPUT:

C-       N: NUMBER OF X,Y-VALUES
C-       XA:   ARRAY OF X-VALUES
C-       YA:   ARRAY OF Y-VALUES
C-       YA2:  ARRAY SPLINE COEFFICIENTS
C-       X: Y(X) IS CALCULATED
C-       MODE: CONTROL FLAG:
C-             MODE.GE.0: USE VALUES OF LAST CALL TO START WITH
C-             MODE.LT.0: NEW INITIALIZATION

C--   OUTPUT:

C-       Y: Y(X) IS CALCULATED

      IMPLICIT NONE

      INTEGER NOLD,N,KLO,KHI,KLOLD,K,MODE,ISTAT

      REAL*8 Y,X,XA1OLD,XANOLD,H,A,B,eps

      REAL*8 XA(*),YA(*),Y2A(*),xx

      save klold,nold,xa1old,xanold

      DATA KLOLD/1/,NOLD/-99/
      DATA XA1OLD/-9999.D0/,XANOLD/-9999./

      ISTAT=0

      EPS=ABS(XA(N)-XA(1))/1.0D10
      XX=X

      IF(XA(1).LT.XA(N)) THEN

        IF(XX.LT.XA(1).AND.XX.GT.XA(1)-EPS) THEN
          XX=XA(1)
        ELSE IF(XX.GT.XA(N).AND.XX.LT.XA(N)+EPS) THEN
          XX=XA(N)
        ENDIF

        IF(XX.LT.XA(1).OR.XX.GT.XA(N)) THEN
          WRITE(6,*)'XA(1), XA(N):',XA(1), XA(N)
          WRITE(6,*)'X:',X
          WRITE(6 ,*)'***ERROR IN UTIL_SPLINE_INTER: X OUT OF RANGE ***'
          STOP
        ENDIF

      ELSE

        IF(XX.LT.XA(N).AND.XX.GT.XA(N)-EPS) THEN
          XX=XA(N)
        ELSE IF(XX.GT.XA(1).AND.XX.LT.XA(N)+EPS) THEN
          XX=XA(1)
        ENDIF

        IF(XX.LT.XA(N).OR.XX.GT.XA(1)) THEN
          WRITE(6,*)'XA(1), XA(N):',XA(1), XA(N)
          WRITE(6,*)'X:',X
          WRITE(6 ,*)'***ERROR IN UTIL_SPLINE_INTER: X OUT OF RANGE ***'
          ISTAT=-1
          return
        ENDIF

      ENDIF

      IF (MODE.LT.0.OR.KLOLD.GE.N) THEN
        KLO=1
      ELSE IF(NOLD.EQ.N
     &    .AND. XA(1).EQ.XA1OLD
     &    .AND. XA(N).EQ.XANOLD
     &    .AND. xx.GT.XA(KLOLD)
     &    ) THEN
        KLO=KLOLD
      ELSE
        KLO=1
      ENDIF


      IF (xx.LT.XA(KLO+1)) THEN
        KHI=KLO+1
        GOTO 2
      ENDIF

      KHI=N
1     IF (KHI-KLO.GT.1) THEN
        K=(KHI+KLO)/2
        IF(XA(K).GT.xx)THEN
          KHI=K
        ELSE
          KLO=K
        ENDIF
        GOTO 1
      ENDIF

2     H=XA(KHI)-XA(KLO)

      IF (H.le.0.0D0) THEN
        ISTAT=-2
        RETURN
      ENDIF

      A=(XA(KHI)-xx)/H
      B=(xx-XA(KLO))/H
      Y=A*YA(KLO)+B*YA(KHI)+
     &  (A*(A+1.D0)*(A-1.D0)*Y2A(KLO)+B*(B+1.D0)*
     &  (B-1.D0)*Y2A(KHI))*(H**2)/6.D0

      KLOLD=KLO
      NOLD=N
      XA1OLD=XA(1)
      XANOLD=XA(N)

      RETURN
      END

+DECK,fibonacci.
*CMZ :  4.00/04 17/05/2019  14.22.20  by  Michael Scheer
*CMZ :  2.63/05 22/07/2009  07.48.55  by  Michael Scheer
*CMZ :  2.63/04 22/07/2009  07.39.04  by  Michael Scheer
*CMZ :  2.63/03 15/05/2009  12.38.54  by  Michael Scheer
*CMZ :  2.63/02 05/03/2008  17.56.28  by  Michael Scheer
*-- Author :    Michael Scheer   30/01/2008
      subroutine fibonacci(npoles,xpol,eta,icutfibo)
+seq,gplhint.

c calculates Fibonacci-series for quasi-periodic undulator according
c to program qpu_field of Sasaki and Bahrdt

c xpol contains on return poles to be shimmed

      implicit none

+seq,contrl.

      integer npoles,nmax,m,icuts,ii,iisum,k,j,i,ifibo1,ifibo2,ifibo,
     &  icutfibo,ifind,kcut

      double precision eta
      real xpol(npoles)

      integer, dimension(:), allocatable :: iflag,iiflag

      nmax=10*npoles

      allocate(iflag(nmax))
      allocate(iiflag(nmax))

      xpol=0.0

      open(unit=99,file='fibonacci_available_cuts.dat',status='unknown')
      write(99,*)'* ',icode
      write(99,*)'* ',code

      ifibo1=0
      do m=2, nmax
        ifibo2=INT(m/(1.0d0+eta))+1
        ifibo=ifibo2-ifibo1
        if(ifibo.lt.1) then
          iflag(m-1)=0
        else
          iflag(m-1)=(-1)**(m-1)
        endif
        ifibo1=ifibo2
      enddo

c------------------------ start loop over quais periodc stuctures ------
      icuts=nmax-npoles+1
      ifind=0
      kcut=0

      do i=1,icuts

        ii=0
        iisum=0

        do j=i,i+npoles-1
          if(abs(iflag(j)).ge.0.5)then
            ii=ii+1
            iisum=iisum+iflag(j)
            iiflag(ii)=(j-i+1)*iflag(j)
          endif
        enddo

        if(iisum.eq.0.and.mod(ii,2).eq.0.and.ii.gt.0) then

          if (i.ge.icutfibo.and.kcut.eq.0) then
            kcut=1
            icutfibo=i
            ifind=1
            do k=1,ii
              xpol(abs(iiflag(k)))=iiflag(k)
            enddo
          endif

          write(99,*)i

        endif

      enddo    ! i1=1,icuts

9999  if (ifind.eq.0) then

        icutfibo=-1

+self,qpu.
        if (iuout.ne.0) then
          call uout
        endif
+self.

        write(6,*)
        write(6,*)'*** Warning in FIBONACCI:'
        write(6,*)'*************************************'
        write(6,*)' did not find quasiperiodic structure'
        write(6,*)'*************************************'
        write(6,*)

        write(lungfo,*)
        write(lungfo,*)'*** Warning in FIBONACCI:'
        write(lungfo,*)'*************************************'
        write(lungfo,*)' did not find quasiperiodic structure'
        write(lungfo,*)'*************************************'
        write(lungfo,*)

        xpol=0.

        if (ibatch.eq.0) then
          call sleep(3)
        endif

      endif

      close(99)

      open(unit=99,file='fibonacci_used_cut.dat',status='unknown')
      write(99,*)'* ',icode
      write(99,*)'* ',code
      do k=1,npoles
        write(99,*)k,xpol(k)
      enddo
      close(99)

      deallocate(iflag)
      deallocate(iiflag)

      return
      end
+DECK,util_bisec.
*CMZ :  2.63/03 15/05/2009  11.26.16  by  Michael Scheer
*CMZ :  2.63/02 01/02/2008  16.04.42  by  Michael Scheer
*CMZ : 00.00/02 25/08/2006  15.27.06  by  Michael Scheer
*CMZ : 00.00/01 23/02/96  14.56.50  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.27.54  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE UTIL_bisec(n,xa,x,i)
+seq,gplhint.

c returns i with:
c x.ge.x(i) .and. x.lt.x(i+1), if x(1).lt.x(n)
c or
c x.le.x(i) .and. x.gt.x(i+1), if x(n).lt.x(1)

      IMPLICIT NONE

      REAL*8 XA(*),x
      integer n,i,klo,khi,k

      i=-1

      if (n.lt.2) then
        return
      else if (x.eq.xa(1)) then
        i=1
        return
      else if (x.eq.xa(n)) then
        i=n-1
        return
      endif

      if (xa(1).lt.xa(n)) then

        if (x.lt.xa(1).or.x.gt.xa(n)) return

        klo=1
        KHI=N

1       IF (KHI-KLO.GT.1) THEN
          K=(KHI+KLO)/2
          IF(XA(K).GT.X)THEN
            KHI=K
          ELSE
            KLO=K
          ENDIF
          GOTO 1
        ENDIF

      else if (xa(n).lt.xa(1)) then

        if (x.lt.xa(n).or.x.gt.xa(1)) return

        klo=1
        Khi=n

2       IF (KHI-KLO.GT.1) THEN

          K=(KHI+KLO)/2

          IF(XA(K).LT.X)THEN
            Khi=K
          ELSE
            Klo=K
          ENDIF

          GOTO 2

        ENDIF

      endif !xa(1).lt.xa(n)

      i=klo

      RETURN
      END
+DECK,util_spline_integral_window.
*CMZ :  2.70/05 02/01/2013  12.50.20  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  11.03.55  by  Michael Scheer
*CMZ :  2.63/03 15/05/2009  12.38.54  by  Michael Scheer
*CMZ : 00.00/02 17/08/2004  09.47.26  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.25.29  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine util_spline_integral_window(x,y,n,xmin,xmax,result
     &  ,coef,work1,work2,work3,work4,mode,istat)
+seq,gplhint.

c---  calculates integral of y(x) in interval [xmin,xmax] via splines

      implicit none

      real*8 x(*),y(*),result,xmin,xmax,ymin,ymax,cmin,cmax
      real*8 coef(*),work1(*),work2(*),work3(*),work4(*)

      integer i,n,mode,imn,imx,i1,i2,istat

      result=0.0d0
      istat=-1

      if (x(1).gt.x(n)) return

c---  spline-coefficients

      if (mode.lt.0) then
        call util_spline_coef(x,y,n,-9999.0d0,-9999.0d0,coef,work1,work2,work3,work4)
      endif

      if (xmin.lt.x(1)) then
        istat=-2
        return
      endif
      if (xmax.gt.x(n)) then
        istat=-3
        return
      endif

c intervals

      call util_bisec(n,x,xmin,imn)
      call util_bisec(n,x,xmax,imx)

      if (imn.eq.imx) then

c from xmin to xmax

        call util_spline_inter(x,y,coef,n,xmin,ymin,0)
        call util_spline_inter(x,y,coef,n,xmax,ymax,0)

        cmin=coef(imn)+(coef(imn+1)-coef(imn))/(x(imn+1)-x(imn))*(xmin-x(imn))
        cmax=coef(imn)+(coef(imn+1)-coef(imn))/(x(imn+1)-x(imn))*(xmax-x(imn))

        result=result+
     &    (xmax-xmin)*0.5d0
     &    *(ymin+ymax)-
     &    (xmax-xmin)**3/24.d0
     &    *(cmin+cmax)

        return

      endif

      i1=imn+1
      i2=imx-1

c--- integration

c from xmin to x(imn+1)
      call util_spline_inter(x,y,coef,n,xmin,ymin,0)
      cmin=coef(imn)+(coef(imn+1)-coef(imn))/(x(imn+1)-x(imn))*(xmin-x(imn))
      result=result+
     &  (x(imn+1)-xmin)*0.5d0
     &  *(ymin+y(imn+1))-
     &  (x(imn+1)-xmin)**3/24.d0
     &  *(cmin+coef(imn+1))

c from x(imx) to xmax
      call util_spline_inter(x,y,coef,n,xmax,ymax,0)
      cmax=coef(imx)+(coef(imx+1)-coef(imx))/(x(imx+1)-x(imx))*(xmax-x(imx))
      result=result+
     &  (xmax-x(imx))*0.5d0
     &  *(ymax+y(imx))
     &  -(xmax-x(imx))**3/24.d0
     &  *(cmax+coef(imx))

      do i=i1,i2

        result=result+
     &    (x(i+1)-x(i))*0.5d0
     &    *(y(i)+y(i+1))
     &    -(x(i+1)-x(i))**3/24.d0
     &    *(coef(i)+coef(i+1))

      enddo

      istat=0

      return
      end
+DECK,UTIL_SPLINE_COEF.
*CMZ :  4.00/11 28/05/2021  09.18.09  by  Michael Scheer
*CMZ :  3.03/02 19/11/2015  13.56.50  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.67/05 16/05/2012  12.45.37  by  Michael Scheer
*CMZ : 00.00/07 12/10/2009  12.17.45  by  Michael Scheer
*CMZ : 00.00/02 14/04/2003  12.46.09  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.27.48  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE UTIL_SPLINE_COEF(X,Y,N,YP1,YPN,Y2,AA,BB,CC,C)
+seq,gplhint.

C--- CALCULATES SPLINE COEFFICIENTS

C--   INPUT:

C-       N: NUMBER OF X,Y-VALUES
C-       X: ARRAY OF X-VALUES
C-       Y: ARRAY OF Y-VALUES
C-       YP1:  SECOND DERIVATIVE AT FIRST X-VALUE
C-       YPN:  SECOND DERIVATIVE AT LAST X-VALUE

C--   OUPUT:

C-       Y2:   SPLINE-COEFFICIENTS

C--   WORKINGSPACE: AA(N),BB(N),CC(N),C(N)


      IMPLICIT NONE

      INTEGER N,J
      double precision  X(N),Y(N),Y2(N),AA(N),BB(N),CC(N),C(N)

      double precision YP1,YPN

      double precision xx(3),yy(3),a(3),yp(3),xopt,yopt
      INTEGER ifail

      IF (N.LT.3) then
        if (abs(yp1).eq.9999.0d0) then
          y2(1)=0.0d0
        else
          y2(1)=yp1
        endif
        if (abs(ypn).eq.9999.0d0) then
          y2(n)=0.0d0
        else
          y2(n)=ypn
        endif
        RETURN
      endif

      if (abs(yp1).eq.9999.0d0) then
        xx=x(1:3)
        yy=y(1:3)
        call UTIL_PARABEL(xx,yy,A,YP,XOPT,yopt,IFAIL)
        if (ifail.eq.0) then
          y2(1)=2.0d0*a(3)
        else
          y2(1)=0.0d0
        endif
      else
        Y2(1)=YP1
      endif

      if (abs(ypn).eq.9999.0d0) then
        xx=x(n-2:n)
        yy=y(n-2:n)
        call UTIL_PARABEL(xx,yy,A,YP,XOPT,yopt,IFAIL)
        if (ifail.eq.0) then
          y2(n)=2.0d0*a(3)
        else
          y2(N)=0.0d0
        endif
      else
        Y2(N)=YPN
      endif

      C(1)=Y2(1)
      C(N)=y2(n)

      BB(1)=1.D0
      CC(1)=0.D0
      CC(N)=1.D0

      DO J=2,N-1
        if(x(j+1).eq.x(j)) then
          write(6,*)
          write(6,*)
     &      '*** Error in util_spline_coef: Intervall of zero length'
          write(6,*)'j, x(j), x(j+1):',j,x(j),x(j+1)
          write(6,*)
          stop
        endif
          AA(J)=(X(J  )-X(J-1))/6.D0
          BB(J)=(X(J+1)-X(J-1))/3.D0
          CC(J)=(X(J+1)-X(J  ))/6.D0
          C(J)=(Y(J+1)-Y(J  ))/(X(J+1)-X(J  ))
     &          -(Y(J  )-Y(J-1))/(X(J  )-X(J-1))
      ENDDO !J

      DO J=2,N-1

          BB(J)=BB(J)-AA(J)*CC(J-1)
           C(J)= C(J)-AA(J)* C(J-1)
C          AA(J)=AA(J)-AA(J)*BB(J-1)

          CC(J)=CC(J)/BB(J)
           C(J)= C(J)/BB(J)
          BB(J)=1.D0

      ENDDO !J

      DO J=N-1,2,-1
         Y2(J)=C(J)-CC(J)*Y2(J+1)
      ENDDO

      RETURN
      END
+DECK,util_spline_coef_f90.
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.63/03 21/05/2008  13.37.36  by  Michael Scheer
*CMZ :  2.47/07 14/04/2003  15.17.05  by  Michael Scheer
*CMZ :  2.20/09 03/04/2001  11.03.37  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.55.48  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.48  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE UTIL_SPLINE_COEF_F90(X,Y,N,YP1,YPN,Y2)
+seq,gplhint.

C--- CALCULATES SPLINE COEFFICIENTS

C--   INPUT:

C-       N: NUMBER OF X,Y-VALUES
C-       X: ARRAY OF X-VALUES
C-       Y: ARRAY OF Y-VALUES
C-       YP1:  SECOND DERIVATIVE AT FIRST X-VALUE
C-       YPN:  SECOND DERIVATIVE AT LAST X-VALUE

C--   OUPUT:

C-       Y2:   SPLINE-COEFFICIENTS

C--   WORKINGSPACE: AA(N),BB(N),CC(N),C(N)


      IMPLICIT NONE

      INTEGER N,J
      DOUBLE PRECISION  X(N),Y(N),Y2(N)
      DOUBLE PRECISION YP1,YPN

      DOUBLE PRECISION, DIMENSION (:), ALLOCATABLE :: AA,BB,CC,C

      double precision xx(3),yy(3),a(3),yp(3),xopt,yopt
      INTEGER ifail

      ALLOCATE(AA(N))
      ALLOCATE(BB(N))
      ALLOCATE(CC(N))
      ALLOCATE(C(N))

      IF (N.LT.3) then
        if (abs(yp1).eq.9999.0d0) then
          y2(1)=0.0d0
        else
          y2(1)=yp1
        endif
        if (abs(ypn).eq.9999.0d0) then
          y2(n)=0.0d0
        else
          y2(n)=ypn
        endif
        GOTO 999
      endif

      if (abs(yp1).eq.9999.0d0) then
        xx=x(1:3)
        yy=y(1:3)
        call UTIL_PARABEL(xx,yy,A,YP,XOPT,yopt,IFAIL)
        if (ifail.eq.0) then
          y2(1)=2.0d0*a(3)
        else
          y2(1)=0.0d0
        endif
      else
        Y2(1)=YP1
      endif

      if (abs(ypn).eq.9999.0d0) then
        xx=x(n-2:n)
        yy=y(n-2:n)
        call UTIL_PARABEL(xx,yy,A,YP,XOPT,yopt,IFAIL)
        if (ifail.eq.0) then
          y2(n)=2.0d0*a(3)
        else
          y2(N)=0.0d0
        endif
      else
        Y2(N)=YPN
      endif

      C(1)=Y2(1)
      C(N)=y2(n)

      BB(1)=1.D0
      CC(1)=0.D0
      CC(N)=1.D0

      DO J=2,N-1
          AA(J)=(X(J  )-X(J-1))/6.D0
          BB(J)=(X(J+1)-X(J-1))/3.D0
          CC(J)=(X(J+1)-X(J  ))/6.D0
          C(J)=(Y(J+1)-Y(J  ))/(X(J+1)-X(J  ))
     &          -(Y(J  )-Y(J-1))/(X(J  )-X(J-1))
      ENDDO !J

      DO J=2,N-1

          BB(J)=BB(J)-AA(J)*CC(J-1)
           C(J)= C(J)-AA(J)* C(J-1)
C030414          AA(J)=AA(J)-AA(J)*BB(J-1)

          CC(J)=CC(J)/BB(J)
           C(J)= C(J)/BB(J)
          BB(J)=1.D0

      ENDDO !J

      DO J=N-1,2,-1
         Y2(J)=C(J)-CC(J)*Y2(J+1)
      ENDDO

999   CONTINUE

      DEALLOCATE(AA)
      DEALLOCATE(BB)
      DEALLOCATE(CC)
      DEALLOCATE(C)

      RETURN
      END
+DECK,WFILL0.
*CMZ :  4.01/03 28/06/2023  13.05.56  by  Michael Scheer
*CMZ :  4.00/11 11/06/2021  12.58.32  by  Michael Scheer
*CMZ :  4.00/07 29/04/2020  12.10.47  by  Michael Scheer
*CMZ :  4.00/04 05/08/2019  11.36.57  by  Michael Scheer
*CMZ :  3.02/03 04/11/2014  13.04.08  by  Michael Scheer
*CMZ :  3.02/00 10/09/2014  11.51.49  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.10.30  by  Michael Scheer
*CMZ :  2.66/09 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.66/07 25/02/2010  12.59.17  by  Michael Scheer
*CMZ :  2.66/06 24/11/2009  14.22.00  by  Michael Scheer
*CMZ :  2.65/03 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  2.64/01 19/08/2009  15.11.55  by  Michael Scheer
*CMZ :  2.64/00 14/08/2009  14.31.12  by  Michael Scheer
*CMZ :  2.63/05 14/08/2009  13.06.13  by  Michael Scheer
*CMZ :  2.48/04 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.37/04 03/12/2001  20.47.32  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.10  by  Michael Scheer
*CMZ :  2.37/01 14/11/2001  11.04.48  by  Michael Scheer
*CMZ :  2.33/00 27/04/2001  15.15.42  by  Michael Scheer
*CMZ :  2.31/01 25/04/2001  15.49.16  by  Michael Scheer
*CMZ :  2.30/02 12/04/2001  19.03.14  by  Michael Scheer
*CMZ :  2.20/03 23/02/2001  11.33.57  by  Michael Scheer
*CMZ :  2.20/01 24/11/2000  15.17.32  by  Michael Scheer
*CMZ :  2.16/08 01/11/2000  18.49.06  by  Michael Scheer
*CMZ :  2.16/06 27/08/2000  21.54.15  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  2.13/00 30/11/99  14.54.00  by  Michael Scheer
*CMZ :  2.10/01 17/03/99  17.04.42  by  Michael Scheer
*CMZ :  2.02/00 12/02/99  18.05.25  by  Michael Scheer
*CMZ :  1.03/06 11/06/98  18.25.54  by  Michael Scheer
*CMZ :  1.03/00 16/01/98  14.52.08  by  Michael Scheer
*CMZ :  1.00/04 21/10/97  13.41.08  by  Michael Scheer
*CMZ :  1.00/01 20/10/97  14.55.47  by  Michael Scheer
*CMZ : 00.01/05 01/02/95  10.49.58  by  Michael Scheer
*CMZ : 00.01/04 30/01/95  17.35.35  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  11.19.37  by  Michael Scheer
*CMZ : 00.01/01 23/06/94  10.04.05  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.56.31  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.36  by  Michael Scheer
*-- Author :  Michael Scheer
      SUBROUTINE WFILL0
+seq,gplhint.

+SEQ,TRACKF90U.
+SEQ,SOURCEF90U.

      use clustermod
      use bunchmod

C--- REFERENCE ORBIT IS SCANNED AND SOURCE POINT ARE DETECTED
C    SOURCE POINTS ARE POINTS OF WHICH LIGHT PASSES COLLIMATOR

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,TRACK.
+SEQ,COLLI.
+seq,sourcef90.
+SEQ,PHYCON.
+SEQ,SPECDIP.
+seq,uservar.

      INTEGER INSIDE,IPOI,IOVER,IBFCNT,IL,JLIGHT,I,J,ISA,ISE,ICEN,IBSIGN
      INTEGER IBUFFP,lun,ins
      PARAMETER (IBUFFP=1000)
      INTEGER IBUFFT(IBUFFP,2)

      DOUBLE PRECISION FLEFT,FRIGHT,FUP,FDOWN,BLEFT,BRIGHT,BUP,BDOWN
      DOUBLE PRECISION BMAG2,B0CUT2,BCUT2,BHYS2,TOPANG,OPANG
      DOUBLE PRECISION DIRVER0,DIRVERU,DIRVERD
      DOUBLE PRECISION DIRHOR0,DIRHORL,DIRHORR
      DOUBLE PRECISION DVERUF,DVERDF,DHORLF,DHORRF,DVERUB,DVERDB,DHORLB,DHORRB
      DOUBLE PRECISION DHOLD,DVOLD,DXF,dtf,DXB,X0,Y0,Z0
      DOUBLE PRECISION ANGMXHF,ANGMXVF,ANGMXHB,ANGMXVB
      DOUBLE PRECISION BY,BYOLD,DYU,DYD,DZR,DZL
      DOUBLE PRECISION X1,X2,Y1,Y2,Z1,Z2
      DOUBLE PRECISION VX1,VY1,VZ1
      double precision dxanf,dxend

      integer IBUFF,ixanf,ixend,jxanf,jxend

      integer ISTAT
      double precision, dimension (:), allocatable :: xbuff,ybuff

      IF (IUNDULATOR.EQ.0
     &    .AND.
     &    IAMPLI.EQ.0
     &    .AND.
     &    icluster.EQ.0
     &    .AND
     &    .IBL0CUT.GT.-2) THEN

        INSIDE=0  !IF CURRENT POINT OF CO INSIDE SOURCE, INSIDE=1
        IBFCNT=0  !BUFFER COUNTER

C---  LIMITS OF THE TWO PINHOLES

        IF(WID1*WID2*HIG1*HIG2.LE.0. .OR. CX1.GT.CX2) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN WFILL0 ***'
          WRITE(LUNGFO,*)'COLLIMATOR HAS MEANINGLESS DIMENSIONS'
          WRITE(LUNGFO,*)'CHECK VARIABLES CX1,CX2,WID1,WID2,HIG1,HIG2'
          WRITE(LUNGFO,*)'IN NAMELIST PINHOLE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN WFILL0 ***'
          WRITE(6,*)'COLLIMATOR HAS MEANINGLESS DIMENSIONS'
          WRITE(6,*)'CHECK VARIABLES CX1,CX2,WID1,WID2,HIG1,HIG2'
          WRITE(6,*)'IN NAMELIST PINHOLE'
          WRITE(6,*)
          STOP
        ENDIF

        FLEFT=CZ1-WID1/2.
        FRIGHT=CZ1+WID1/2.
        FUP=CY1+HIG1/2.
        FDOWN=CY1-HIG1/2.

        BLEFT=CZ2-WID2/2.
        BRIGHT=CZ2+WID2/2.
        BUP=CY2+HIG2/2.
        BDOWN=CY2-HIG2/2.

C--- LOOP OVER ALL POINTS OF THE REFERENCE ORBIT, THE DIRECTION OF THE
C     ELECTRON IS CALCULATED, THE OPENING ANGLE OF THE LIGHT IS ADDED,
C     THIS NEW DIRECTION IS EXTRAPOLATED TO EACH PINHOLE, THE TRAJECTORY
C     POINT IS CHECKED, IF IT BELONGS TO THE SOURCE OR NOT

        BHYS2=WBL0HYS**2

        IF (WBL0HYS.LE.0.D0) BHYS2=1.D0

        B0CUT2=WBL0CUT**2
        BCUT2=B0CUT2*BHYS2 !CUT ON MAGNETIC FIELD
        IF (IBL0CUT.LT.0) BCUT2=BCUT2-1.0D-30
        OPANG=DABS(WGWINFC/DMYGAMMA) !OPENING ANGLE

        IF (OPANG.GT.PI1/4.D0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '*** WARNING IN WFILL0: WGWINFC CORRESPONDS TO ANGLE GREATER THAN 90 DEGREE'
C         WRITE(LUNGFO,*)'SET TO 45 DEGREE'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)
     &      '*** WARNING IN WFILL0: WGWINFC CORRESPONDS TO ANGLE GREATER THAN 90 DEGREE'
C         WRITE(6,*)'SET TO 45 DEGREE'
          WRITE(6,*)
C         WGWINFC=PI1/4.D0*DMYGAMMA
C         OPANG=PI1/4.D0
        ENDIF !(OPANG.GT.PI1/4.D0)
        TOPANG=DTAN(OPANG) !TANGENS OF OPENING ANGLE

        DHOLD=WTRA(3,2,1)/WTRA(1,2,1)
        DVOLD=WTRA(2,2,1)/WTRA(1,2,1)

        BYOLD=WTRA(2,3,1)

        DO IPOI=1,NCO

C- DIRECTIONS

C           DIRHOR0=VZ/VX, HOR. DIRECTION

          DIRHOR0=WTRA(3,2,IPOI)/WTRA(1,2,IPOI)
          DIRHORR=(DIRHOR0+TOPANG)/(1.D0-DIRHOR0*TOPANG) !TAN(X+Y)=...
          DIRHORL=(DIRHOR0-TOPANG)/(1.D0+DIRHOR0*TOPANG) !TAN(X-Y)=...

C        DIRVER0=VY/VX, VER. DIRECTION

          DIRVER0=WTRA(2,2,IPOI)/WTRA(1,2,IPOI)
          DIRVERU=(DIRVER0+TOPANG)/(1.D0-DIRVER0*TOPANG) !TAN(X+Y)=...
          DIRVERD=(DIRVER0-TOPANG)/(1.D0+DIRVER0*TOPANG) !TAN(X-Y)=...

C- POSITION AND DISTANCES

          X0=WTRA(1,1,IPOI)
          Y0=WTRA(2,1,IPOI)
          Z0=WTRA(3,1,IPOI)

          BY=WTRA(2,3,IPOI)
          IF (IBL0CUT.GT.0.AND.(BY.GE.0.D0 .AND. BYOLD.LT.0.D0
     &        .OR.BY.LE.0.D0 .AND. BYOLD.GT.0.D0)) THEN
            IBSIGN=1
          ELSE
            IBSIGN=0
          ENDIF

          DXF=CX1-X0 !POSITIVE, IF ELECTRON IN FRONT OF THE PINHOLE
          DXB=CX2-X0

          DYD=Y0+DIRVERD*DXF
          DYU=Y0+DIRVERU*DXF
          DZR=Z0+DIRHORR*DXF
          DZL=Z0+DIRHORL*DXF

          DVERUF=FUP-DYD
          DVERDF=FDOWN-DYU
          DHORLF=FLEFT-DZR
          DHORRF=FRIGHT-DZL

C--- IF LIGHT CONE HITS EDGE OF PINHOLE CUT CONE

          IF  (DXF.GT.0.0 .AND.
     &        FUP.LT.DYU
     &        .AND.
     &        FUP.GT.DYD
     &        )
     &        THEN
            DIRVERU=(FUP-Y0)/DXF
          ENDIF

          IF  (DXF.GT.0.0 .AND.
     &        FDOWN.LT.DYU
     &        .AND.
     &        FDOWN.GT.DYD
     &        )
     &        THEN
            DIRVERD=(FDOWN-Y0)/DXF
          ENDIF

          IF  (DXF.GT.0.0 .AND.
     &        FRIGHT.LT.DZR
     &        .AND.
     &        FRIGHT.GT.DZL
     &        )
     &        THEN
            DIRHORR=(FRIGHT-Z0)/DXF
          ENDIF

          IF  (DXF.GT.0.0 .AND.
     &        FLEFT.LT.DZR
     &        .AND.
     &        FLEFT.GT.DZL
     &        )
     &        THEN
            DIRHORL=(FLEFT-Z0)/DXF
          ENDIF

          DVERUB=BUP-(Y0+DIRVERD*DXB)
          DVERDB=BDOWN-(Y0+DIRVERU*DXB)
          DHORLB=BLEFT-(Z0+DIRHORR*DXB)
          DHORRB=BRIGHT-(Z0+DIRHORL*DXB)

          IF  (
     &      DVERUF.GE.0. .AND. DVERDF.LE.0.    .AND.
     &      DHORLF.LE.0. .AND. DHORRF.GE.0.
     &      .AND.
     &      DXF.GE.0
     &      .AND.
     &      DVERUB.GE.0. .AND. DVERDB.LE.0.    .AND.
     &      DHORLB.LE.0. .AND. DHORRB.GE.0.
     &      .AND.
     &      DXB.GE.0
     &        ) THEN

            IOVER=1

          ELSE

            IOVER=0

          ENDIF

C- CHECK SPACING OF POINTS
C  DELTA OF ANGLE MUST BE LOWER THAN THE MAXIMUM OF THE LIGHT CONE
C  AND OPENING ANGLE OF THE PINHOLE

          IF(DXF.NE.0.0) THEN
            ANGMXHF=DMAX1(DABS(WID1/DXF),DABS(TOPANG))
            ANGMXVF=DMAX1(DABS(HIG1/DXF),DABS(TOPANG))
          ENDIF
          IF(DXB.NE.0.0) THEN
            ANGMXHB=DMAX1(DABS(WID2/DXB),DABS(TOPANG))
            ANGMXVB=DMAX1(DABS(HIG2/DXB),DABS(TOPANG))
          ENDIF

          IF(
     &        DABS((DIRHOR0-DHOLD)/(1.D0+DIRHOR0*DHOLD)).GE.ANGMXHF
     &        .OR.
     &        DABS((DIRVER0-DVOLD)/(1.D0+DIRVER0*DVOLD)).GE.ANGMXVF
     &        .OR.
     &        DABS((DIRHOR0-DHOLD)/(1.D0+DIRHOR0*DHOLD)).GE.ANGMXHB
     &        .OR.
     &        DABS((DIRVER0-DVOLD)/(1.D0+DIRVER0*DVOLD)).GE.ANGMXVB
     &        )
     &        THEN

            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN WFILL0 ***'
            WRITE(LUNGFO,*)'SPACING OF POINTS IN REFERENCE ORBIT TOO LARGE'
            WRITE(LUNGFO,*)'INCREASE NUMBER OF POINTS OR OPENING ANGLE'
            WRITE(LUNGFO,*)'(WGWINFC IN NAMELIST COLLIN)'
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN WFILL0 ***'
            WRITE(6,*)'SPACING OF POINTS IN REFERENCE ORBIT TOO LARGE'
            WRITE(6,*)'INCREASE NUMBER OF POINTS OR OPENING ANGLE'
            WRITE(6,*)'(WGWINFC IN NAMELIST COLLIN)'
            WRITE(6,*)
            STOP

          ENDIF

          DHOLD=DIRHOR0
          DVOLD=DIRVER0

          BMAG2=WTRA(1,3,IPOI)*WTRA(1,3,IPOI)+    !SQUARE OF MAG.-FIELD
     &      WTRA(2,3,IPOI)*WTRA(2,3,IPOI)+
     &      WTRA(3,3,IPOI)*WTRA(3,3,IPOI)

          IF (
     &        BMAG2.GT.BCUT2
     &        .AND.
     &        IOVER.EQ.1 .AND. INSIDE.EQ.0
     &        ) THEN

            IBFCNT=IBFCNT+1

            IF (IBFCNT.GT.IBUFFP) THEN
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*) '*** ERROR IN WFILL0 ***'
              WRITE(LUNGFO,*) '    TOO MANY SOURCES'
              WRITE(LUNGFO,*) '    INCREASE IBUFFP IN SUBROUTINE WFILL0'
              WRITE(LUNGFO,*) '    OR REDUCED NUMBER OF SOURCES TO BE TREATED'
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)'     Number of sources:',IBFCNT
              WRITE(LUNGFO,*)'     Begin and end of sources (x,y,z):'
              DO JLIGHT=1,IBFCNT-1
                WRITE(LUNGFO,*)
                WRITE(LUNGFO,*)'     '
     &            ,JLIGHT,(SNGL(WTRA(I,1,IBUFFT(JLIGHT,1))),I=1,3)
                WRITE(LUNGFO,*)'     ',
     &            JLIGHT,(SNGL(WTRA(I,1,IBUFFT(JLIGHT,2))),I=1,3)
              ENDDO
              WRITE(LUNGFO,*)
              WRITE(6,*)
              WRITE(6,*) '*** ERROR IN WFILL0 ***'
              WRITE(6,*) '    TOO MANY SOURCES'
              WRITE(6,*) '    INCREASE IBUFFP IN SUBROUTINE WFILL0'
              WRITE(6,*) '    OR REDUCED NUMBER OF SOURCES TO BE TREATED'
              WRITE(6,*)
              WRITE(6,*)
              WRITE(6,*)'     Number of sources:',IBFCNT
              WRITE(6,*)'     Begin and end of sources (x,y,z):'
              DO JLIGHT=1,IBFCNT-1
                WRITE(6,*)
                WRITE(6,*)'     '
     &            ,JLIGHT,(SNGL(WTRA(I,1,IBUFFT(JLIGHT,1))),I=1,3)
                WRITE(6,*)'     ',
     &            JLIGHT,(SNGL(WTRA(I,1,IBUFFT(JLIGHT,2))),I=1,3)
              ENDDO
              WRITE(6,*)
              STOP
            ENDIF

            IBUFFT(IBFCNT,1)=IPOI
            INSIDE=1
            BCUT2=B0CUT2/BHYS2
            IF (IBL0CUT.LT.0) BCUT2=BCUT2-1.0D-30

          END IF

          IF (
     &        INSIDE.EQ.1 .AND.
     &        (BMAG2.LT.BCUT2.OR.IBSIGN.EQ.1.OR.
     &        IOVER.NE.1 .OR. IPOI.EQ.NCO)
     &        ) THEN

            IBUFFT(IBFCNT,2)=IPOI
            INSIDE=0
            BCUT2=B0CUT2*BHYS2
            IF (IBL0CUT.LT.0) BCUT2=BCUT2-1.0D-30

          END IF

          BYOLD=BY

        END DO !LOOP OVER ALL CO-POINTS

C--- EXTEND SOURCE A LITTLE BIT

        DO IL=1,IBFCNT
          IF (IBUFFT(IL,1).EQ.IBUFFT(IL,2)) THEN
            IBUFFT(IL,1)=MAX(1,IBUFFT(IL,1)-1)
            IBUFFT(IL,2)=MIN(NCO,IBUFFT(IL,2)+1)
          ENDIF
        ENDDO  !IBFCNT

        IF (ISOUREXT.GT.0) THEN
          DO IL=1,IBFCNT
            IBUFFT(IL,1)=MAX(1,IBUFFT(IL,1)-ISOUREXT)
            IBUFFT(IL,2)=MIN(NCO,IBUFFT(IL,2)+ISOUREXT)
          END DO
        ENDIF

C--- CHECK ON DOUBLE COUNTING

        DO IL=1,IBFCNT-1
          IF (IBUFFT(IL,2).GE.IBUFFT(IL+1,1)) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN WFILL0 ***'
            WRITE(LUNGFO,*)'SOURCES HAVE COMMON POINTS'
            WRITE(LUNGFO,*)
     &        'PROBABLY THRESHOLD WBL0CUT OR WGWINFC (NAMELIST COLLIN)'
            WRITE(LUNGFO,*)'MUST BE INCREASED'
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN WFILL0 ***'
            WRITE(6,*)'SOURCES HAVE COMMON POINTS'
            WRITE(6,*)
     &        'PROBABLY THRESHOLD WBL0CUT OR WGWINFC (NAMELIST COLLIN)'
            WRITE(6,*)'MUST BE INCREASED'
            WRITE(6,*)
            IF (ISOUREXT.LT.0) THEN
              WRITE(LUNGFO,*)'*** ERROR IGNORED DUE TO FLAG ISOUREXT ***'
              WRITE(6,*)'*** ERROR IGNORED DUE TO FLAG ISOUREXT ***'
            ELSE
              STOP
            ENDIF
          END IF
        END DO

      ELSE  !IUNDULATOR

        IBFCNT=1
        IBUFFT(1,1)=1
        IBUFFT(1,2)=NCO

      ENDIF !IUNDULATOR

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     SR WFILL0:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Parameters:'
      WRITE(LUNGFO,*)'     WGWINFC:',WGWINFC
      WRITE(LUNGFO,*)'     WBL0CUT:',WBL0CUT
      WRITE(LUNGFO,*)'     WBL0HYS:',WBL0HYS
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Pinhole of collimators:'
      WRITE(LUNGFO,*)'     (X,Y,Z), width, height:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,'(6H       ,5(1PE12.4))')
     &  SNGL(CX1),SNGL(CY1),SNGL(CZ1),SNGL(WID1),SNGL(HIG1)
      WRITE(LUNGFO,'(6H       ,5(1PE12.4))')
     &  SNGL(CX2),SNGL(CY2),SNGL(CZ2),SNGL(WID2),SNGL(HIG2)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     Number of sources:',IBFCNT

      IF (IBFCNT.EQ.0) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN WFILL0: NO SOURCE FOUND ***'
        WRITE(LUNGFO,*)'CHECK COLLIMATOR, MAG. FIELD...'
        WRITE(LUNGFO,*)'*** PROGRAMM WAVE TERMINATED ***'

        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN WFILL0: NO SOURCE FOUND ***'
        WRITE(6,*)'CHECK COLLIMATOR, MAG. FIELD...'
        WRITE(6,*)
        WRITE(6,*)'*** PROGRAMM WAVE TERMINATED ***'

        STOP

      ENDIF !(IBFCNT.GT.0)

      WRITE(LUNGFO,*)'     Begin and end of sources (x,y,z):'
      DO JLIGHT=1,IBFCNT
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     '
     &    ,JLIGHT,(SNGL(WTRA(I,1,IBUFFT(JLIGHT,1))),I=1,3)
        WRITE(LUNGFO,*)'     ',
     &    JLIGHT,(SNGL(WTRA(I,1,IBUFFT(JLIGHT,2))),I=1,3)
      ENDDO
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Horiz., vert. slopes and mag. field'
      WRITE(LUNGFO,*)
     &  '     at begin and end of sources:'
      DO JLIGHT=1,IBFCNT
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'     ',JLIGHT,
     &    SNGL(WTRA(3,2,IBUFFT(JLIGHT,1))/WTRA(1,2,IBUFFT(JLIGHT,1)))
     &    ,SNGL(WTRA(2,2,IBUFFT(JLIGHT,1))/WTRA(1,2,IBUFFT(JLIGHT,1)))
     &    ,SNGL(DSQRT(
     &    WTRA(1,3,IBUFFT(JLIGHT,1))**2+
     &    WTRA(2,3,IBUFFT(JLIGHT,1))**2+
     &    WTRA(3,3,IBUFFT(JLIGHT,1))**2))
        WRITE(LUNGFO,*)'     ',JLIGHT,
     &    SNGL(WTRA(3,2,IBUFFT(JLIGHT,2))/WTRA(1,2,IBUFFT(JLIGHT,2)))
     &    ,SNGL(WTRA(2,2,IBUFFT(JLIGHT,2))/WTRA(1,2,IBUFFT(JLIGHT,2)))
     &    ,SNGL(DSQRT(
     &    WTRA(1,3,IBUFFT(JLIGHT,2))**2+
     &    WTRA(2,3,IBUFFT(JLIGHT,2))**2+
     &    WTRA(3,3,IBUFFT(JLIGHT,2))**2))
      ENDDO
      WRITE(LUNGFO,*)

C--- WRITE FILE FILEL0

      IF(IWFILL0.NE.0) THEN
        IF (LUNL0.NE.6) THEN
+SELF,IF=VMS.
          OPEN (UNIT=LUNL0,FILE=FILEL0,FORM ='FORMATTED'
     &      ,STATUS = 'NEW')
+SELF,IF=LINUX,WINDOWS,HPUX,TRUE64.
          OPEN (UNIT=LUNL0,FILE=FILEL0,FORM ='FORMATTED'
     &      ,STATUS = 'UNKNOWN')
+SELF.
        ENDIF

        WRITE(LUNL0,*)ICODE
        WRITE(LUNL0,*)DMYGAMMA
        WRITE(LUNL0,*)IBFCNT
        WRITE(LUNL0,*)WGWINFC,WBL0CUT,WBL0HYS
        WRITE(LUNL0,*)CX1,CY1,CZ1,WID1,HIG1
        WRITE(LUNL0,*)CX2,CY2,CZ2,WID2,HIG2

        DO JLIGHT=1,IBFCNT
          WRITE(LUNL0,*)IBUFFT(JLIGHT,1),IBUFFT(JLIGHT,2)
          WRITE(LUNL0,*)((WTRA(I,J,IBUFFT(JLIGHT,1)),I=1,3),J=1,4)
          WRITE(LUNL0,*)((WTRA(I,J,IBUFFT(JLIGHT,2)),I=1,3),J=1,4)
        ENDDO

        IF (LUNL0.NE.6) then
          flush(lunl0)
          CLOSE(LUNL0)
        endif

C     WRITE(6,*)'*** SR WFILL0: SOURCE WRITTEN TO FILE ***'
C     WRITE(6,*)'FILE:',FILEL0
C     WRITE(LUNGFO,*)
C     WRITE(LUNGFO,*)
C     WRITE(LUNGFO,*)'*** SR WFILL0: SOURCE WRITTEN TO FILE ***'
C     WRITE(LUNGFO,*)'FILE:',FILEL0
C     WRITE(LUNGFO,*)
      ENDIF

C- COPY SOURCES TO COMMON SOURCE

      NSOURCE=IBFCNT

      IF (ISPECDIP.GT.0.AND.NDIP.GT.NSOURCE) THEN
        ALLOCATE(SOURCEG(3,2,NDIP))
        ALLOCATE(SOURCEA(3,4,NDIP))
        ALLOCATE(SOURCEE(3,4,NDIP))
        ALLOCATE(SOURCEAO(3,4,NDIP))
        ALLOCATE(SOURCEEO(3,4,NDIP))
        ALLOCATE(SOURCEN(3,4,NDIP))
        ALLOCATE(SOURCET(3,NDIP))
        ALLOCATE(ISOURAE(2,NDIP))
        ALLOCATE(ISOURCEN(NDIP))
        ALLOCATE(WTRA2IS(NDIP))
      ELSE  !(ISPECDIP.NE.0.AND.NDIP.GT.NSOURCE)
        ALLOCATE(SOURCEG(3,2,NSOURCE))
        ALLOCATE(SOURCEA(3,4,NSOURCE))
        ALLOCATE(SOURCEE(3,4,NSOURCE))
        ALLOCATE(SOURCEAO(3,4,NSOURCE))
        ALLOCATE(SOURCEEO(3,4,NSOURCE))
        ALLOCATE(SOURCEN(3,4,NSOURCE))
        ALLOCATE(SOURCET(3,NSOURCE))
        ALLOCATE(ISOURAE(2,NSOURCE))
        ALLOCATE(ISOURCEN(NSOURCE))
        ALLOCATE(WTRA2IS(NSOURCE))
      ENDIF !(ISPECDIP.NE.0.AND.NDIP.GT.NSOURCE)

      sourceg=0.0d0
      sourcea=0.0d0
      sourcee=0.0d0
      sourceao=0.0d0
      sourceeo=0.0d0
      sourcet=0.0d0
      wtra2is=0.0d0
      isourae=0
      isourcen=0

      DO JLIGHT=1,NSOURCE

      ISA=IBUFFT(JLIGHT,1)
      ISE=IBUFFT(JLIGHT,2)
      ICEN=ISA+(ISE-ISA)/2

        SOURCEG(1,1,JLIGHT)=WTRA(1,5,ISA)
        SOURCEG(2,1,JLIGHT)=WTRA(2,5,ISA)
        SOURCEG(3,1,JLIGHT)=WTRA(3,5,ISA)

        SOURCEG(1,2,JLIGHT)=WTRA(1,5,ISE)
        SOURCEG(2,2,JLIGHT)=WTRA(2,5,ISE)
        SOURCEG(3,2,JLIGHT)=WTRA(3,5,ISE)

        DO I=1,3

          DO J=1,2
            SOURCEA(I,J,JLIGHT)=WTRA(I,J,ISA)
            SOURCEE(I,J,JLIGHT)=WTRA(I,J,ISE)
            ISOURAE(1,JLIGHT)=ISA
            ISOURAE(2,JLIGHT)=ISE
            ISOURCEN(JLIGHT)=ICEN
            SOURCEN(I,J,JLIGHT)=WTRA(I,J,ICEN)
          ENDDO   !J=1,2

          SOURCEA(I,4,JLIGHT)=WTRA(I,3,ISA)
          SOURCEE(I,4,JLIGHT)=WTRA(I,3,ISE)
          ISOURCEN(JLIGHT)=ICEN
          SOURCEN(I,4,JLIGHT)=WTRA(I,3,ICEN)

          SOURCET(1,JLIGHT)=WTIM0(ISA)
          SOURCET(2,JLIGHT)=WTIM0(ISE)
          SOURCET(3,JLIGHT)=WTIM0(ICEN)

      ENDDO !I=1,3

c Wegen IAMPLI, damit MYINUM keinen Einfluss hat. 12.8.2009,
c Nachtrag: Hat es aber trotzdem, da wtra2is von MYINUM abhaengt.

        DXF=XSTOP-SOURCEE(1,1,JLIGHT)
        DTF=DXF/WTRA(1,2,ISE)

        IF (DXF.LT.1.0D-6) THEN
          SOURCEE(1,1,JLIGHT)=XSTOP
          SOURCEE(2,1,JLIGHT)=SOURCEE(2,1,JLIGHT)
     &      +SOURCEE(2,2,JLIGHT)*DTF
          SOURCEE(3,1,JLIGHT)=SOURCEE(3,1,JLIGHT)
     &      +SOURCEE(3,2,JLIGHT)*DTF
          SOURCET(2,JLIGHT)=SOURCET(2,JLIGHT)+DTF
        ENDIF

        WTRA2IS(JLIGHT)=0.0D0

        IBUFF=0
        DXANF=1.0D30
        DXEND=1.0D30
        ixanf=-1
        ixend=-1

        allocate(xbuff(ise-isa+1))
        allocate(ybuff(ise-isa+1))

        DO IPOI=ISA,ISE

          X1=WTRA(1,1,IPOI)
          Y1=WTRA(2,1,IPOI)
          Z1=WTRA(3,1,IPOI)

          if (ipoi.lt.nco) then
            VX1=(WTRA(1,2,IPOI)+wtra(1,2,ipoi+1))/2.0d0
            Vy1=(WTRA(2,2,IPOI)+wtra(2,2,ipoi+1))/2.0d0
            Vz1=(WTRA(3,2,IPOI)+wtra(3,2,ipoi+1))/2.0d0
          else
            VX1=(WTRA(1,2,IPOI)+wtra(1,2,ipoi-1))/2.0d0
            Vy1=(WTRA(2,2,IPOI)+wtra(2,2,ipoi-1))/2.0d0
            Vz1=(WTRA(3,2,IPOI)+wtra(3,2,ipoi-1))/2.0d0
          endif

          dxf=abs(x1-xianf)
          IF (dxf.LT.DXANF) then
            DXANF=dxf
            jxanf=ipoi
          endif
          if (dxf.lt.1.0d0-9) ixanf=ipoi

          dxf=abs(x1-xiend)
          IF (dxf.LT.DXend) then
            DXend=dxf
            jxend=ipoi
          endif
          if (dxf.lt.1.0d0-9) ixend=ipoi

          IF (X1.GE.XIANF-1.0d-9.AND.X1.LE.XIEND+1.0d-9) THEN
            IBUFF=IBUFF+1
            xbuff(ibuff)=wtim0(ipoi)
            ybuff(ibuff)=0.5d0*vx1*((vy1/vx1)**2+(vz1/vx1)**2)
          endif

        enddo

        if (xianf.ge.xstart.and.ixanf.lt.0) then
          write(lungfo,*)
          write(lungfo,*)
     &      '*** Warning in WFILL0: XIANF NOT POINT OF THE TRAJECTORY ARRAY'
          write(lungfo,*)'closest x:',wtra(1,1,jxanf)
          write(lungfo,*)
          write(lungfo,*)'ROIS may be used to force XIANF onto trajectory'
          write(6,*)
          write(6,*)
     &      '*** Warning in WFILL0: XIANF NOT POINT OF THE TRAJECTORY ARRAY'
          write(6,*)'closest x:',wtra(1,1,jxanf)
          write(6,*)
          write(6,*)'ROIS may be used to force XIANF onto trajectory'
          write(6,*)
        endif

        if (xiend.le.xstop.and.ixend.lt.0) then
          write(lungfo,*)
          write(lungfo,*)
     &      '*** Warning in WFILL0: XIEND NOT POINT OF THE TRAJECTORY ARRAY'
          write(lungfo,*)'closest x:',wtra(1,1,jxend)
          write(lungfo,*)
          write(lungfo,*)'ROIS may be used to force XIEND onto trajectory'
          write(lungfo,*)
          write(6,*)
          write(6,*)
     &      '*** Warning in WFILL0: XIANF NOT POINT OF THE TRAJECTORY ARRAY'
          write(6,*)'closest x:',wtra(1,1,jxend)
          write(6,*)
          write(6,*)
          write(6,*)'ROIS may be used to force XEND onto trajectory'
        endif

        call util_higher_simpson_equidist_integral(ibuff,xbuff,ybuff
     &    ,dxf,istat)

        WTRA2IS(JLIGHT)=0.0D0
      DO IPOI=ISA,ISE-1
          X1=WTRA(1,1,IPOI)
          Y1=WTRA(2,1,IPOI)
          Z1=WTRA(3,1,IPOI)
          X2=WTRA(1,1,IPOI+1)
          Y2=WTRA(2,1,IPOI+1)
          Z2=WTRA(3,1,IPOI+1)
          IF (X2.NE.X1
     &     .AND.X1.GE.XIANF.AND.X1.LE.XIEND
     &     .AND.X2.GE.XIANF.AND.X2.LE.XIEND
     &      ) THEN
         WTRA2IS(JLIGHT)=WTRA2IS(JLIGHT)
     &           +0.5D0*(X2-X1)*(((Y2-Y1)/(X2-X1))**2+((Z2-Z1)/(X2-X1))**2)
          ENDIF    !(X2.NE.X1)
      ENDDO !ISA,ISE

        wtra2is(jlight)=(wtra2is(jlight)+dxf)/2.0d0 ! Mittelung scheint besser zu sein.

        deallocate(xbuff)
        deallocate(ybuff)

      ENDDO   !NSOURCE

      IF (ISPECDIP.GT.0.AND.NDIP.GT.NSOURCE) NSOURCE=NDIP

      if (icluster.lt.0.and.ibunch.ne.0.and.iubunch.eq.3) then
        open(newunit=lun,file='wave.ins')
        read(lun,*) ins
        close(lun)
        if (ins.eq.0) then
          open(newunit=lun,file='wave_source.clu')
          write(lun,*) sourcea,sourcee
          flush(lun)
          close(lun)
          open(newunit=lun,file='wave.status')
          write(lun,*) '0'
          flush(lun)
          close(lun)
          stop '--- WAVE terminated in WFILL0 due to ICLUSTER ---'
        else
          open(newunit=lun,file='wave_source.clu')
          read(lun,*) sourceaclu,sourceeclu
          close(lun)
        endif
      endif

      RETURN
      END
+DECK,util_higher_simpson_equi_int.
*CMZ :  2.63/05 13/08/2009  15.38.27  by  Michael Scheer
*-- Author :    Michael Scheer   13/08/2009
      subroutine util_higher_simpson_equidist_integral(n,x,f,sum,istat)
+seq,gplhint.

      implicit none

      double precision x(*),f(*),sum,sumeve,sumodd,dx
      integer n,i,istat

      istat=-1

      if (n.lt.2) return

      sum=0.0d0
      sumeve=0.0d0
      sumodd=0.0d0

      dx=(x(n)-x(1))/(n-1)

      if (n.ge.8) then
        do i=5,n-4
          sumeve=sumeve+f(i)
        enddo
        sum=(
     &    (17.0d0*f(1)+59.0d0*f(2)+43.0d0*f(3)+49.0d0*f(4))/48.0d0
     &   +sumeve
     &    +(17.0d0*f(n)+59.0d0*f(n-1)+43.0d0*f(n-2)+49.0d0*f(n-3))/48.0d0
     &    )*dx
      else if (n.eq.7) then
        sum=(f(1)+4.0d0*(f(2)+f(4)+f(6))+2.0d0*(f(3)+f(5))+f(7))*dx/3.0d0
      else if (n.eq.6) then
        sum=(f(3)+f(4)+(5.0d0*f(1)+13.0d0*f(2)
     &    +13.0d0*f(5)+5.0d0*f(6))/12.0d0)*dx
      else if (n.eq.5) then
        sum=(f(1)+4.0d0*(f(2)+f(4))+2.0d0*f(3)+f(5))*dx/3.0d0
      else if (n.eq.4) then
        sum=(5.0d0*f(1)+13.0d0*f(2)
     &    +13.0d0*f(3)+5.0d0*f(4))*dx/12.0d0
      else if (n.eq.3) then
        sum=(f(1)+4.0d0*f(2)+f(3))*dx/3.0d0
      else if (n.eq.2) then
        sum=(f(1)+f(2))*dx/2.0d0
      endif

      istat=0

      return
      end
+DECK,util_spline_integral_buff.
*CMZ :  2.68/00 25/05/2012  11.03.55  by  Michael Scheer
*CMZ :  2.66/20 06/07/2011  10.48.03  by  Michael Scheer
*CMZ :  2.63/05 14/08/2009  12.21.34  by  Michael Scheer
*CMZ : 00.00/02 17/08/2004  09.47.26  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.25.29  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine util_spline_integral_buff(x,y,n,result,nbuff,margin
     &  ,coef,work1,work2,work3,work4,istat)
+seq,gplhint.

c---  calculates integral of y(x) via splines

      implicit none

      integer ibuff,n,istat,nbuff,margin,mbuff,i1,i2,nbfull

      double precision x(n),y(n),result,
     &  coef(n),work1(n),work2(n),work3(n),work4(n),sum

      istat=-1
      result=0.0d0

      mbuff=nbuff+2*margin

      if (n.le.mbuff.or.3*margin.ge.n) then
        call util_spline_integral(x,y,n,result
     &    ,coef,work1,work2,work3,work4)
        return
      endif

      nbfull=n/nbuff

      call util_spline_integral_window(
     &  x,y,nbuff+margin,x(1),x(nbuff),result
     &  ,coef,work1,work2,work3,work4,-1,istat)

      if (istat.ne.0) then
        result=0.0d0
        return
      endif

      i2=nbuff

      do ibuff=1,nbfull-2
        i1=i2
        i2=i1+nbuff
        call util_spline_integral_window(
     &    x(i1-margin),y(i1-margin),mbuff,x(i1),x(i2),sum
     &    ,coef,work1,work2,work3,work4,-1,istat)
        if (istat.ne.0) then
          result=0.0d0
          return
        endif
        result=result+sum
      enddo !nbfull

      call util_spline_integral_window(
     &  x(i2),y(i2),n-i2+1,x(i2),x(n),sum
     &  ,coef,work1,work2,work3,work4,-1,istat)

      if (istat.ne.0) then
        result=0.0d0
        return
      endif

      result=result+sum

      return
      end
+DECK,pininr.
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.66/07 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.66/06 18/11/2009  13.56.29  by  Michael Scheer
*CMZ :  2.66/03 28/10/2009  13.07.43  by  Michael Scheer
*CMZ :  2.66/01 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  2.65/02 29/09/2009  09.46.33  by  Michael Scheer
*CMZ :  2.65/01 21/09/2009  14.35.04  by  Michael Scheer
*CMZ :  2.65/00 18/09/2009  07.26.13  by  Michael Scheer
*CMZ :  2.64/07 16/09/2009  12.42.25  by  Michael Scheer
*CMZ :  2.64/06 15/09/2009  15.03.21  by  Michael Scheer
*CMZ :  2.64/05 14/09/2009  09.10.19  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine pininr
+seq,gplhint.

+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,WFOLDF90U.

C--- INITIALIZE CYLINDRICAL GRID OF OBERSERVATION POINTS OF PINHOLE

      implicit none

+seq,cmpara.
+seq,contrl.
+seq,myfiles.
+seq,observf90.
+seq,depola.
+seq,wfoldf90.
+seq,sourcef90.
+seq,phycon.

      double precision r,phi
      integer iob,iphi,ir

      if (mpinr.eq.1) then
        mpinr=2
        write(6,*)
        write(6,*)
     &    '*** Warning in PININR: MPINR set form 1 to minimum value of 2'
        write(6,*)
        write(lungfo,*)
        write(lungfo,*)
     &    '*** Warning in PININR: MPINR set form 1 to minimum value of 2'
        write(lungfo,*)
      endif

      if (pinrad.eq.0.0d0) pinrad=pinr

      if (pinrad.eq.9999.0d0) then
        pinrad=-1.0d0
        do iob=1,nobsv
          r=sqrt(obsv(2,iob)**2+obsv(3,iob)**2)
          if (r.gt.pinrad) pinrad=r
        enddo
      endif

      if (abs(mpinr).eq.9999) then
        mpinr=(sqrt(2.)*max(mpinz,mpiny)/2)*2+1
      endif

      if (obsvdr.eq.9999.0d0) then
        obsvdr=min(obsvdz,obsvdy)
      endif

      if (obsvdr.ne.0.0d0) then
        mpinr=nint(pinrad/obsvdr)+2
        pinrad=obsvdr*(mpinr-1)
      else if (mpinr.gt.1) then
        obsvdr=pinrad/(mpinr-1)
      else
        stop '*** Error in PININR: Bad MPINR or OBSVDR!'
      endif !(obsvdz.ne.0.d0)

      if (pinrad.lt.sqrt((pinw/2.0d0)**2+(pinh/2.0d0)**2)) then
        print*,
     &    '*** Error in PININR: PINRAD.LT.SQRT((PINW/2.0D0)**2+(PINH/2.0d0)**2)'
        print*,'*** Please check PINRAD, OBSVDR etc.'
        stop '*** Program WAVE aborted ***'
      endif

C--- DATA OF PINHOLE ARE TAKEN FORM NAMELIST

      obsvdphi=obsvdphi/360.0d0*twopi1

      if (iquadphi.ne.0.and.(istokes.ne.0.or.iphase.ne.0)) then
c        iquadphi=0
        write(lungfo,*)' '
        write(lungfo,*)'*** Warning in PININR: IQUADPHI and ISTOKES/IPHASE are incompatible!'
        write(lungfo,*)'*** In general, only S0 will be correct'
c        write(lungfo,*)'*** Warning in PININR: IQUADPHI set to zero'
        write(6,*)' '
        write(6,*)'*** Warning in PININR: IQUADPHI and ISTOKES/IPHASE are incompatible!'
        write(6,*)'*** In general, only S0 will be correct'
c        write(6,*)'*** Warning in PININR: IQUADPHI set to zero'
      endif

      if (iquadphi.eq.0) then
        if (obsvdphi.ne.0.0d0) then
          mpinphi=nint(twopi1/obsvdphi)
        else
          obsvdphi=twopi1/mpinphi
        endif
      else
        if (obsvdphi.ne.0.0d0) then
          mpinphi=nint(pi1/2.0d0/obsvdphi)+1
        else if (mpinphi.gt.1) then
          obsvdphi=pi1/2.0d0/(mpinphi-1)
        else
          obsvdphi=twopi1
        endif
      endif

      IF (IF1DIM.NE.0.AND.MPINR.NE.1) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN PININR ***'
        WRITE(LUNGFO,*)'FLAG IF1DIM SET BUT'
        WRITE(LUNGFO,*)'MPINZ NOT EQUAL ONE, ADJUSTED'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN PININR ***'
        WRITE(6,*)'FLAG IF1DIM SET BUT'
        WRITE(6,*)'MPINZ NOT EQUAL ONE, ADJUSTED'
        WRITE(6,*)
        MPINR=1
      ENDIF

      if (iusem.ne.0) then
        stop '*** error in pininr: iusem not allowed here! '
      endif !iusem

      nobsvr=mpinr
      nobsvphi=mpinphi
      nobsvrphi=nobsvr*nobsvphi

      if (nobsvrphi.le.0) then
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN PININR ***'
        WRITE(LUNGFO,*)'Number of observation points not positive!'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN PININR ***'
        WRITE(6,*)'Number of observation points not positive!'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      if (nobsvrphi.le.0) then
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN PININR ***'
        WRITE(LUNGFO,*)'Number of observation points not positive!'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN PININR ***'
        WRITE(6,*)'Number of observation points not positive!'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

c- increase pinhole; size of rectangular pinhole is already calculated in PININ

      mobsvr=nobsvr  !store values
      mobsvphi=nobsvphi
      mobsvrphi=nobsvrphi

      if (obsvdz*(nobsvz-1)/2.0d0.gt.(obsvdr*(nobsvr-1))) then
        nobsvr=obsvdz*(nobsvz-1)/2.0d0/obsvdr+1
      endif

      if (obsvdy*(nobsvy-1)/2.0d0.gt.(obsvdr*(nobsvr-1))) then
        nobsvr=obsvdy*(nobsvy-1)/2.0d0/obsvdr+1
      endif

      nobsvrphi=nobsvr*nobsvphi

      if (iobsvrphi_a.ne.nobsv) then
        if (iobsvrphi_a.ne.0) deallocate(obsvrphi)
        allocate(obsvrphi(3,nobsvrphi))
        iobsvrphi_a=nobsvrphi
      endif !(iobsv_a.lt.nobsv)

      if (iobsvr_a.ne.nobsvr) then
        if (iobsvr_a.ne.0) deallocate(obsvr)
        allocate(obsvr(nobsvr))
        iobsvr_a=nobsvr
      endif !(iobsvy_a.lt.nobsvy)

      if (iobsvphi_a.ne.nobsvphi) then
        if (iobsvphi_a.ne.0) deallocate(obsvphi)
        allocate(obsvphi(nobsvphi))
        iobsvphi_a=nobsvphi
      endif !(iobsv_a.lt.nobsv)

      iob=0
      do iphi=1,nobsvphi
        do ir=1,nobsvr
          iob=iob+1
          obsvrphi(1,iob)=pincen(1)
          r=obsvdr*(ir-1)
          phi=obsvdphi*(iphi-1)
          obsvrphi(2,iob)=r
          obsvrphi(3,iob)=phi
        enddo
      enddo

      do ir=1,nobsvr
        obsvr(ir)=obsvrphi(2,ir)
      enddo

      do iphi=1,nobsvphi
        iob=(iphi-1)*nobsvr+1
        obsvphi(iphi)=obsvrphi(3,iob)
      enddo

      write(lungfo,*)
      write(lungfo,*)'      Subroutine PININR:'
      write(lungfo,*)
      write(lungfo,*)'      NOBSVR, PINRAD, OBSVDR:',
     &  MPINR, SNGL(PINR), SNGL(OBSVDR)
      write(lungfo,*)'      IQUADPHI, NOBSVPHI, OBSVDPHI:',
     &  IQUADPHI,NOBSVPHI,SNGL(OBSVDPHI)
      write(lungfo,*)

      return
      end
+DECK,util_spline_coef_fake_periode.
*CMZ :  2.64/05 26/08/2009  13.43.24  by  Michael Scheer
*CMZ : 00.00/02 14/04/2003  12.46.09  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.27.48  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine util_spline_coef_fake_periode(X,Y,N,Y2,AA,BB,CC,C)
+seq,gplhint.

C--- CALCULATES SPLINE COEFFICIENTS

C--   INPUT:

C-       N: NUMBER OF X,Y-VALUES
C-       X: ARRAY OF X-VALUES
C-       Y: ARRAY OF Y-VALUES

C--   OUPUT:

C-       Y2:   SPLINE-COEFFICIENTS

C--   WORKINGSPACE: AA(N),BB(N),CC(N),C(N)

c fake yp1 and ypn by simple guess to emulate periodic spline
c we assume y(n)=y(1)
C-       YP1:  SECOND DERIVATIVE AT FIRST X-VALUE
C-       YPN:  SECOND DERIVATIVE AT LAST X-VALUE

      IMPLICIT NONE

      INTEGER N,J
      REAL*8  X(N),Y(N),Y2(N),AA(N),BB(N),CC(N),C(N)

      REAL*8 YP1,YPN

      double precision xx(3),yy(3),a(3),yp(3),xopt,yopt
      INTEGER ifail

      IF (N.LT.3) then
        do j=1,n
          y2(j)=0.0d0
        enddo
        RETURN
      endif

      if (y(n).ne.0.0d0.or.y(n).ne.0.0d0) then
        if (abs(y(n)-y(1))/abs(y(n)-y(1)).gt.1.0d-9) then
          ifail=9
          do j=1,n
            y2(j)=0.0d0
          enddo
          return
        endif
      endif

      xx(1)=x(1)-(x(n)-x(n-1))
      xx(2)=x(1)
      xx(3)=x(2)
      yy(1)=y(n-1)
      yy(2)=y(1)
      yy(3)=y(2)

      call UTIL_PARABEL(xx,yy,A,YP,XOPT,yopt,IFAIL)

      if (ifail.eq.0) then
        y2(1)=2.0d0*a(3)
        yp1=y2(1)
        ypn=yp1
        y2(n)=ypn
      else
        do j=1,n
          y2(j)=0.0d0
        enddo
        RETURN
      endif

      C(1)=Y2(1)
      C(N)=y2(n)

      BB(1)=1.D0
      CC(1)=0.D0
      CC(N)=1.D0

      DO J=2,N-1
          AA(J)=(X(J  )-X(J-1))/6.D0
          BB(J)=(X(J+1)-X(J-1))/3.D0
          CC(J)=(X(J+1)-X(J  ))/6.D0
          C(J)=(Y(J+1)-Y(J  ))/(X(J+1)-X(J  ))
     &          -(Y(J  )-Y(J-1))/(X(J  )-X(J-1))
      ENDDO !J

      DO J=2,N-1

          BB(J)=BB(J)-AA(J)*CC(J-1)
           C(J)= C(J)-AA(J)* C(J-1)

          CC(J)=CC(J)/BB(J)
           C(J)= C(J)/BB(J)
          BB(J)=1.D0

      ENDDO !J

      DO J=N-1,2,-1
         Y2(J)=C(J)-CC(J)*Y2(J+1)
      ENDDO

      RETURN
      END
+DECK,cyltocart.
*CMZ :  4.01/04 15/11/2023  12.38.14  by  Michael Scheer
*CMZ :  4.01/03 28/06/2023  13.07.07  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.66/02 26/10/2009  14.33.39  by  Michael Scheer
*CMZ :  2.65/01 08/10/2009  09.58.11  by  Michael Scheer
*CMZ :  2.65/00 18/09/2009  08.30.19  by  Michael Scheer
*CMZ :  2.64/06 15/09/2009  09.52.14  by  Michael Scheer
*CMZ :  2.64/05 14/09/2009  10.06.11  by  Michael Scheer
*-- Author :    Michael Scheer   01/09/2009
      subroutine cyltocart(isour)
+seq,gplhint.

+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,AFREQF90U.
+SEQ,SPECTF90U.
+SEQ,WFOLDF90U.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEq,observf90.
+SEQ,DEPOLA.
+SEq,wfoldf90.
+seq,sourcef90.
+SEQ,FREQS.
+SEQ,PHYCON.
+SEQ,SPECTF90.

c
c Alte Version 154 wieder  hervorgeholt, da sie besser mit MPINR=0 uebereinstimmt.
c
c

c fill AFREQ and SPECPOW by interpolating AFREQRPHI and SPECPOWRPHI

      double precision, dimension(:,:,:), allocatable :: fr,coefr
      double precision, dimension(:,:), allocatable :: phas
      double precision, dimension(:), allocatable :: w1,w2,w3,w4,
     &  fp,coefp,obsvedge,frw

      double complex af2,af3
c     &  ,expom

      double precision y,z,r,phi,pihalf,phiedge,yp12,
     &  phiy,phiz,phiy1,phiz1,
     &  dist0,dist02,ddist,h2,cenxexi,dvlen,
     &  dphase,dphi,pi2phaser2,pi2phaser3,pi2phasephi2,pi2phasephi3,
     &  af2r,af2i,af3r,af3i,
     &  af2ro,af2io,af3ro,af3io

      integer ixy,iphi,ir,ifreq,iphas,iobrp,istat,medge,
     &  ifirst,ilast,iedge,isour,jphi,nphi,ical

      data ical/0/

      if (ical.eq.0) then

        medge=3
        yp12=9999.0d0

        allocate(phas(4,nobsv))

        allocate(frw(nobsvr))
        allocate(fr(nobsvr,4,nobsvphi))
        allocate(coefr(nobsvr,4,nobsvphi))

        allocate(fp(nobsvphi+2*medge+1))
        allocate(obsvedge(nobsvphi+2*medge+1))
        allocate(coefp(nobsvphi+2*medge+1))

        allocate(w1(max(nobsvr,nobsvphi+2*medge+1)))
        allocate(w2(max(nobsvr,nobsvphi+2*medge+1)))
        allocate(w3(max(nobsvr,nobsvphi+2*medge+1)))
        allocate(w4(max(nobsvr,nobsvphi+2*medge+1)))

        pihalf=pi1/2.0d0

        ifirst=medge+1

        if (iquadphi.eq.0) then
          ilast=ifirst+nobsvphi
          obsvedge(ilast)=obsvphi(nobsvphi)+obsvdphi
        else
          ilast=ifirst+nobsvphi-1
        endif

        do iphi=1,nobsvphi
          obsvedge(ifirst+iphi-1)=obsvphi(iphi)
        enddo

        do iedge=1,medge
          obsvedge(ilast+iedge)=obsvedge(ilast+iedge-1)+obsvdphi
        enddo

        do iedge=1,medge
          obsvedge(ifirst-iedge)=obsvedge(ifirst-iedge+1)-obsvdphi
        enddo

        ical=1

      endif

        cenxexi=(min(sourceeo(1,1,isour),xiend)
     &    +max(sourceao(1,1,isour),xianf))/2.d0
        dvlen=
     &    min(sourceeo(1,1,isour),xiend)-
     &    max(sourceao(1,1,isour),xianf)
        if (iampli.lt.0) then
          dvlen=dvlen*(-iampli)
        endif
        dist0=pincen(1)-cenxexi
        dist02=dist0**2

      do ifreq=1,nfreq

        iobrp=0
        ixy=1

        pi2phasephi2=0.0d0
        pi2phasephi3=0.0d0
        do iphi=1,nobsvphi

          phiy1=-twopi1
          phiz1=-twopi1

          pi2phaser2=0.0d0
          pi2phaser3=0.0d0
          do ir=1,nobsvr

            iobrp=iobrp+1
            ifrob=ifreq+nfreq*(iobrp-1)

            h2=(obsvr(ir)/dist0)**2
            if (h2.lt.0.01) then
              ddist=dist0*(h2/2.0d0-h2**2/8.0d0)
            else
              ddist=dist0*(sqrt(1.0d0+h2)-1.0d0)
            endif

            dphase=ddist/freq(ifreq)*wtoe1*1.0d9*twopi1

            af2=afreqrphi(2,IFROB)
            af3=afreqrphi(3,IFROB)
            af2r=dreal(af2)
            af2i=dimag(af2)
            af3r=dreal(af3)
            af3i=dimag(af3)

            phiy=atan2(af2i,af2r)
            phiz=atan2(af3i,af3r)

            fr(ir,1,iphi)=abs(af2)
            fr(ir,2,iphi)=phiy-dphase
            fr(ir,3,iphi)=abs(af3)
            fr(ir,4,iphi)=phiz-dphase

c            print*,ir,iphi,phiz+dphase,phiz-dphase

            phiy1=phiy
            phiz1=phiz
            af2ro=af2r
            af2io=af2i
            af3ro=af3r
            af3io=af3i

          enddo !nobsvr

          do iphas=2,4,2
            frw(1)=fr(1,iphas,iphi)
            do ir=2,nobsvr
              frw(ir)=fr(ir,iphas,iphi)
              phiy1=frw(ir-1)
              phiy=frw(ir)
              dphi=phiy-phiy1

              if (dphi.gt.pi1) then
                dphi=dphi-twopi1
              else if (dphi.lt.-pi1) then
                dphi=dphi+twopi1
              endif
              fr(ir,iphas,iphi)=fr(ir-1,iphas,iphi)+dphi

            enddo
          enddo

          do iphas=1,4
            call util_spline_coef(obsvr,
     &        fr(1,iphas,iphi),nobsvr,yp12,yp12,coefr(1,iphas,iphi),
     &        w1,w2,w3,w4)
          enddo

        enddo !nobsvphi

        do iphas=1,4

          do ixy=1,nobsv

            y=obsv(2,ixy)
            z=obsv(3,ixy)
            r=sqrt(y**2+z**2)

            if (iquadphi.eq.0) then
              phi=atan2(y,z)
            else
              if (z.ne.0.0d0) then
                phi=atan(y/z)
              else
                phi=pi1/2.0d0
              endif
              phi=abs(phi)
            endif

            if (phi.lt.0.0d0) phi=phi+twopi1

            do iphi=1,nobsvphi

              call util_spline_inter_status(
     &          obsvr,fr(1,iphas,iphi),coefr(1,iphas,iphi),
     &          nobsvr,r,fp(iphi+medge),0,
     &          istat)

              if (istat.ne.0) then
                stop
     &            '*** Error: Bad return from util_spline_inter_status in CYLTOCART'
              endif

            enddo !iphi

            if (iquadphi.eq.0) then

              nphi=nobsvphi+1+2*medge
              ifirst=medge+1
              ilast=ifirst+nobsvphi

              fp(ilast)=fp(ifirst) !Periode vervollstaendigen

              do iedge=1,medge
                fp(ilast+iedge)=fp(ifirst+iedge)
              enddo

              do iedge=1,medge
                fp(ifirst-iedge)=fp(ilast-iedge)
              enddo

            else !if (iquadphi.eq.0)

              nphi=nobsvphi+2*medge
              ifirst=medge+1
              ilast=ifirst+nobsvphi-1

              do iedge=1,medge
                phiedge=mod(pihalf+iedge*obsvdphi,twopi1)
                if (phiedge.gt.3.0d0*pihalf) then
                  phiedge=twopi1-phiedge
                else if (phiedge.gt.pi1) then
                  phiedge=phiedge-pi1
                else if (phiedge.gt.pihalf) then
                  phiedge=pi1-phiedge
                endif
                jphi=ifirst+nint(phiedge/obsvdphi)
                fp(ilast+iedge)=fp(jphi)
              enddo

              do iedge=1,medge
                phiedge=mod(iedge*obsvdphi,twopi1)
                if (phiedge.gt.3.0d0*pihalf) then
                  phiedge=twopi1-phiedge
                else if (phiedge.gt.pi1) then
                  phiedge=phiedge-pi1
                else if (phiedge.gt.pihalf) then
                  phiedge=pi1-phiedge
                endif
                jphi=ifirst+nint(phiedge/obsvdphi)
                fp(ifirst-iedge)=fp(jphi)
              enddo

            endif !iquadphi

            call util_spline_coef(obsvedge,fp,nphi,
     &        yp12,yp12,coefp,
     &        w1,w2,w3,w4)

            call util_spline_inter_status(
     &        obsvedge,fp,coefp,nphi,phi,phas(iphas,ixy),0,istat)

            if (iphas.eq.4) then

              h2=(r/dist0)**2

              if (h2.lt.0.01) then
                ddist=dist0*(h2/2.0d0-h2**2/8.0d0)
              else
                ddist=dist0*(sqrt(1.0d0+h2)-1.0d0)
              endif

              dphase=ddist/freq(ifreq)*wtoe1*1.0d9*twopi1

              afreq(2,ifreq+nfreq*(ixy-1))=
     &          phas(1,ixy)*
     &          cmplx(cos(phas(2,ixy)+dphase),sin(phas(2,ixy)+dphase))

              afreq(3,ifreq+nfreq*(ixy-1))=
     &          phas(3,ixy)*
     &          cmplx(cos(phas(4,ixy)+dphase),sin(phas(4,ixy)+dphase))

            endif

            if (istat.ne.0) then
              stop
     &          '*** Error: Bad return from util_spline_inter_status in CYLTOCART'
            endif

          enddo !ixy

        enddo !iphas

      enddo !ifreq

c power

      iphas=1
      do ixy=1,nobsv

        y=obsv(2,ixy)
        z=obsv(3,ixy)
        r=sqrt(y**2+z**2)

        if (iquadphi.eq.0) then
          phi=atan2(y,z)
        else
          if (z.ne.0.0d0) then
            phi=atan(y/z)
          else
            phi=pi1/2.0d0
          endif
          phi=abs(phi)
        endif

        if (phi.lt.0.0d0) phi=phi+twopi1

        iobrp=0
        do iphi=1,nobsvphi

          if (ixy.eq.1) then

            do ir=1,nobsvr
              iobrp=iobrp+1
              ifrob=isour+nsource*(iobrp-1)
              fr(ir,iphas,iphi)=specpowrphi(ifrob)
            enddo

            call util_spline_coef(obsvr,fr(1,iphas,iphi),nobsvr,yp12,yp12,
     &        coefr(1,iphas,iphi),
     &        w1,w2,w3,w4)

          endif !ixy.eq.1

          call util_spline_inter_status(
     &      obsvr,fr(1,iphas,iphi),coefr(1,iphas,iphi),nobsvr,r,
     &      fp(iphi+medge),0,istat)

          if (istat.ne.0) then
            stop
     &        '*** Error: Bad return from util_spline_inter_status in CYLTOCART'
          endif

        enddo !iphi

        if (iquadphi.eq.0) then

          ifirst=medge+1
          ilast=ifirst+nobsvphi
          fp(ilast)=fp(ifirst) !Periode vervollstaendigen

          do iedge=1,medge
            fp(ilast+iedge)=fp(ifirst+iedge)
          enddo

          do iedge=1,medge
            fp(ifirst-iedge)=fp(ilast-iedge)
          enddo

        else !if (iquadphi.eq.0)

          ifirst=medge+1
          ilast=ifirst+nobsvphi-1

          do iedge=1,medge
            phiedge=mod(pihalf+iedge*obsvdphi,twopi1)
            if (phiedge.gt.3.0d0*pihalf) then
              phiedge=twopi1-phiedge
            else if (phiedge.gt.pi1) then
              phiedge=phiedge-pi1
            else if (phiedge.gt.pihalf) then
              phiedge=pi1-phiedge
            endif
            jphi=ifirst+nint(phiedge/obsvdphi)
            fp(ilast+iedge)=fp(jphi)
          enddo

          do iedge=1,medge
            phiedge=mod(iedge*obsvdphi,twopi1)
            if (phiedge.gt.3.0d0*pihalf) then
              phiedge=twopi1-phiedge
            else if (phiedge.gt.pi1) then
              phiedge=phiedge-pi1
            else if (phiedge.gt.pihalf) then
              phiedge=pi1-phiedge
            endif
            jphi=ifirst+nint(phiedge/obsvdphi)
            fp(ifirst-iedge)=fp(jphi)
          enddo

        endif !iquadphi

        call util_spline_coef(obsvedge,fp,nphi,
     &    yp12,yp12,coefp,
     &    w1,w2,w3,w4)

        call util_spline_inter_status(
     &    obsvedge,fp,coefp,nphi,phi,
     &    specpow(isour+nsource*(ixy-1)),0,istat)

        if (istat.ne.0) then
          stop
     &      '*** Error: Bad return from util_spline_inter_status in CYLTOCART'
        endif

      enddo !ixy

      if (isour.eq.nsource) then
        deallocate(phas)
        deallocate(fr)
        deallocate(fp)
        deallocate(obsvedge)
        deallocate(coefr)
        deallocate(coefp)

        deallocate(w1)
        deallocate(w2)
        deallocate(w3)
        deallocate(w4)
      endif

      call cyltocartb(isour)

      return
      end
+DECK,souintrphi.
*CMZ :  4.01/04 14/11/2023  11.43.26  by  Michael Scheer
*CMZ :  4.01/03 02/06/2023  13.04.35  by  Michael Scheer
*CMZ :  4.01/02 14/05/2023  12.29.56  by  Michael Scheer
*CMZ :  4.00/15 07/04/2022  09.03.04  by  Michael Scheer
*CMZ :  4.00/14 22/12/2021  18.07.25  by  Michael Scheer
*CMZ :  4.00/13 07/11/2021  15.12.27  by  Michael Scheer
*CMZ :  4.00/04 03/08/2019  10.03.49  by  Michael Scheer
*CMZ :  3.06/00 28/02/2019  16.55.53  by  Michael Scheer
*CMZ :  3.05/06 17/07/2018  11.15.17  by  Michael Scheer
*CMZ :  3.05/04 27/06/2018  13.51.32  by  Michael Scheer
*CMZ :  3.05/03 22/05/2018  07.39.43  by  Michael Scheer
*CMZ :  3.02/05 07/04/2015  15.54.15  by  Michael Scheer
*CMZ :  3.02/04 22/01/2015  13.26.27  by  Michael Scheer
*CMZ :  3.02/03 06/11/2014  14.51.14  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  14.04.56  by  Michael Scheer
*CMZ :  2.69/00 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.68/05 17/10/2012  13.51.54  by  Michael Scheer
*CMZ :  2.68/02 30/05/2012  09.20.31  by  Michael Scheer
*CMZ :  2.67/04 11/05/2012  11.18.26  by  Michael Scheer
*CMZ :  2.67/02 28/03/2012  08.52.46  by  Michael Scheer
*CMZ :  2.67/00 13/02/2012  10.58.17  by  Michael Scheer
*CMZ :  2.66/20 06/07/2011  10.49.00  by  Michael Scheer
*CMZ :  2.66/13 25/06/2010  15.12.53  by  Michael Scheer
*CMZ :  2.66/12 25/05/2010  06.05.46  by  Michael Scheer
*CMZ :  2.66/10 04/05/2010  10.02.54  by  Michael Scheer
*CMZ :  2.66/09 04/05/2010  10.01.19  by  Michael Scheer
*CMZ :  2.66/07 10/03/2010  09.23.32  by  Michael Scheer
*CMZ :  2.66/06 27/11/2009  16.13.00  by  Michael Scheer
*CMZ :  2.66/05 18/11/2009  10.22.04  by  Michael Scheer
*CMZ :  2.66/04 17/11/2009  10.06.11  by  Michael Scheer
*CMZ :  2.66/03 05/11/2009  12.46.46  by  Michael Scheer
*CMZ :  2.66/00 26/10/2009  14.33.39  by  Michael Scheer
*CMZ :  2.65/02 08/10/2009  09.58.11  by  Michael Scheer
*CMZ :  2.65/00 18/09/2009  09.44.26  by  Michael Scheer
*CMZ :  2.64/07 17/09/2009  16.07.45  by  Michael Scheer
*CMZ :  2.64/06 15/09/2009  11.26.04  by  Michael Scheer
*CMZ :  2.64/05 11/09/2009  15.30.45  by  Michael Scheer
*-- Author :    Michael Scheer   04/09/2009

      SUBROUTINE SOUINTRPHI(ISOUR,INSIDE)
+seq,gplhint.

+SEQ,TRACKF90U.
+SEQ,WORKF90U.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,AFREQF90U.
+SEQ,AMPLIF90U.

      use bunchmod
      use clustermod

C--- EVALUATE INTEGRALES FOR A SINGLE SOURCE
C---- RESULTS ARE STORE IN AFREQRPHI AND SPECPOWRPHI

         IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,PHYCON.
+SEQ,TRACK.
+seq,sourcef90.
+SEQ,COLLI.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,FREQS.
+SEQ,AMPLI.
+SEQ,B0SCGLOB.
+SEQ,PRIMKIN.
+seq,ustep.
+SEQ,USERVAR.
+seq,datetime.

      double precision, dimension (:), allocatable :: ampzmax
      integer, dimension (:), allocatable :: kobs,iinside,jinside

      COMPLEX*16 ZIOM,ZI,ZIDOM,ZONE,ZICR1,ZIC,daff(3),baff(3)
      COMPLEX*16 EXPOM,DEXPOMPH1,DEXPOMPH,DDEXPOMPH,DEXPOM,EXPOMV2
      COMPLEX*16 DMODU,DMODU0,DDMODU,AX,AY,AZ,AX0,AY0,AZ0,bx0,by0,bz0
      COMPLEX*16 APOL,APOLH,APOLR,APOLL,APOL45,bxc,byc,bzc

      DOUBLE PRECISION T0,T1,T2,TENDSOU,X0,X1,X2,X10,Y1,Y2,Z1,Z2,XENDSOU,R0
     &  ,T,DT,DT2,DT0,DTIM00,DTIM01,VXP,VYP,VZP,TENDSOU1
     &  ,R02
c     &  ,H2,H2R2
     &  ,PHI,FREQR,CORRR0,R00,R2,POW
     &  ,X2B,Y2B,Z2B
     &  ,DGAMMA,DGAMSUM,BETA,GAMGAM,GAMGAM0,AMPDT,sqnphsp,sqnbunch,
     &  sqbunnor
     &  ,are(6),aim(6),
     &  xn1,slopein,slope,drn1,drn2,zn1,yn1,wi
      DOUBLE PRECISION STOK1,STOK2,STOK3,STOK4

      DOUBLE PRECISION VX1,VY1,VZ1,BX1,BY1,BZ1
      DOUBLE PRECISION VX2,VY2,VZ2,BX2,BY2,BZ2,AX2D,AY2D,AZ2D
      DOUBLE PRECISION ECDUM,BS,BSQ,ECMAXS,bs1
      DOUBLE PRECISION TS,DPHASE,DPHSOUR(2,2),phase
      DOUBLE PRECISION C1,OM,DOM,GAMMA

      DOUBLE PRECISION BX,BY,BZ,RX,RY,RZ,PX,PY,PZ,RNBX,RNBY,RNBZ
      DOUBLE PRECISION R1,RNX,RNY,RNZ,DOM1,DOM2,BET1N,DUM11,R,BPX,BPY,BPZ
      DOUBLE PRECISION WGANG,OPANG
      double precision br2,rnr2,br4,rnr4,b3,yp2zp2i,
c     &  yp2zp2ia,
     &  f(3),yp(3),ypp,a(3),fdt(3),filo,fihi,dfdt

      DOUBLE PRECISION RARG(5),C

      DOUBLE PRECISION DROIX,DTPHASE,DXEXI,CENXEXI,roi(nroip)
      DOUBLE PRECISION BET1NO,XRPHI,YRPHI,ZRPHI,speck

      double precision fillb(41)
      double precision, save :: soura(3,4),soure(3,4)

      INTEGER INSIDE
      INTEGER ISOUR,IOBSV,IFREQ,JFREQ,IZAEHL,NZAEHL,IX10,I,ICAL,ICOMP
+self,if=-windows.
      INTEGER*8
+self,if=windows.
      INTEGER
+self.
     &  NZAEHL10,MZAEHL,kzaehl,iizaehl,ir1,ir2
      INTEGER ICSPL,IROI,II,IZTOTS,IWARNBET1N,LSTEP,
     &  MCOUNT,NCOUNT,NCOUNT10,N10,ICOUNT,
     &  jobsv,nelec,norad,iwarnwi

      INTEGER NTUPP,IC
      PARAMETER (NTUPP=38)
      REAL*8 FILLT(NTUPP)
      CHARACTER(5) CTUP(NTUPP)

      data ctup /'t','x','y','z','rx','ry','rz','rt','p','expr','expi','roi'
     &  ,'iob','ie','yob','zob','bet1n','om','dt','by2','isou'
     &  ,'spec','reax','imax','reay','imay','reaz','imaz','dom1',
     &  'betx','bety','betz','betxp','betyp','betzp','nx','ny','nz'/

      DATA ICAL/0/
      DATA ZI/(0.0D0,1.0D0)/
      DATA ZONE/(1.0D0,0.0D0)/
      DATA IWARNBET1N/0/

      allocate(ampzmax(nfreq),kobs(nfreq),
     &  iinside(nobsvrphi),jinside(nobsvrphi))

      IF (ICAL.EQ.0) THEN

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'       SUBROUTINE SOUINTRPHI:'
        WRITE(LUNGFO,*)'       (triggered by MPINR)'
        WRITE(LUNGFO,*)

        if (icluster.lt.0.and.ibunch.ne.0.and.iubunch.eq.3) then
          soura(1:3,1:4)=sourceaclu(1:3,1:4)
          soure(1:3,1:4)=sourceeclu(1:3,1:4)
        else
          soura(1:3,1:4)=sourceao(1:3,1:4,isour)
          soure(1:3,1:4)=sourceeo(1:3,1:4,isour)
        endif

        if(ibunch.ne.0) then
          write(lungfo,*)
          write(lungfo,*)
     &      '*** Warning in SOUINTRPHI: Use of IBUNCH may result in problems,'
          write(lungfo,*)
     &      '*** since radiation cone might be not centered and lacking cylindrical symmetry '
          write(lungfo,*)
          write(6,*)
          write(6,*)
     &      '*** Warning in SOUINTRPHI: Use of IBUNCH may result in problems,'
          write(6,*)
     &      '*** since radiation cone might be not centered and lacking cylindrical symmetry '
          write(6,*)
        endif

        IF (NFREQ.GT.NDFREQ) THEN
          WRITE(LUNGFO,*)
     &      '*** ERROR IN SOUINTRPHI: NUMBER OF MAXIMUM PHOTON ENERGIES EXCEEDED'
          WRITE(LUNGFO,*)
     &      'INCREASE PARAMETER NDFREQP IN CMPARA.CMN'
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED  ***'
          WRITE(6,*)
     &      '*** ERROR IN SOUINTRPHI: NUMBER OF MAXIMUM PHOTON ENERGIES EXCEEDED'
          WRITE(6,*)
     &      'INCREASE PARAMETER NDFREQP IN CMPARA.CMN'
          WRITE(6,*)'*** PROGRAM WAVE ABORTED  ***'
          STOP
        ENDIF    !(NFREQ.GT.NDFREQP)

        DO II=1,NSOURCE
          DO I=1,NROIA
            IWARNROI(I,II)=0
          ENDDO
        ENDDO

        IF (ISPECMODE.EQ.1) THEN
          DTIM00=DTMCO
        ELSE
          DTIM00=DTIM0
        ENDIF

        DTIM01=1.D0/DTIM00

        C=CLIGHT1
        C1=1.D0/CLIGHT1

        DOM=(FREQ(2)-FREQ(1))/HBAREV1
        OM=FREQ(1)/HBAREV1
        ZIDOM=ZI*DOM
        ZIOM=ZI*OM
        ZIC=ZI*CLIGHT1

        IF (IWFILINT.LT.0) THEN
+self,if=-mhbook.
          CALL hbookm(NIDSOURCE,'RADIATION INTEGRALS$',NTUPP
     &      , '//WAVE',1024,CTUP)
+self,if=mhbook.
          CALL hbookm(NIDSOURCE,'RADIATION INTEGRALS',NTUPP
     &      , '//WAVE',nlpoi/jwfilint+2*jwfilint,CTUP)
+self.
        ENDIF !(IWFILINT.LT.0)

        nphsp=nbunch
        nelec=neinbunch*nphsp

c Flux density is normalized to number of electrons per bunch or bunch charge
c and dmycurr. The field is normalized such, that flux dens = ABS(field)**2
        if (ibunch.ne.0.and.bunchcharge.ne.0.0d0) then
          sqnbunch=nbunch
          sqnphsp=sqrt(bunchcharge/echarge1)
     &      *neinbunch
     &      /(bunchcharge/echarge1)
          bunnor=1.0d0/nbunch
        else
          sqnbunch=nbunch
          sqnphsp=sqrt(dble(neinbunch))
          bunnor=1.0d0/nbunch
        endif

        if (ibunphase.eq.0) then
          sqbunnor=sqrt(dfloat(neinbunch))/sqrt(dfloat(nbunch))
        else
          sqbunnor=1.0d0/sqrt(dfloat(nbunch))
        endif

      ENDIF !ICAL

      IF (ielec.eq.1) THEN

        WRITE(LUNGFO,*)'            SOURCE NUMBER',ISOUR,':'
        WRITE(LUNGFO,*)

        do ifreq=1,nfreq
          ampzmax(ifreq)=0.0d0
          azcos(ifreq)=1.0d0
          azsin(ifreq)=0.0d0
        enddo
        kobs=iobunch

        X1=xelec

        IF (NROI.LT.0) THEN
          DROIX=(XENDSOU-X1)/(NROIA-1)
          DO IROI=1,NROIA
            ROIX(IROI)=X1+(IROI-1)*DROIX
            ROIP(IROI)=1.0D0
          ENDDO
        ENDIF   !(NROI.LT.0)

        ROIX(1)=ROIX(1)-1.0D-6
        ROIX(NROIA)=ROIX(NROIA)+1.0D-6

        DO IROI=1,NROIA
          IPOIROI(IROI)=0
          if (ical.eq.0) then
            roi(iroi)=roix(iroi)
          endif
        ENDDO
      ENDIF !ielec.eq.1

      phaserphi=0.0d0
      LSTEP=0
      DGAMSUM=0.0D0

      gamma=egamma
      beta=dsqrt((1.d0-1.d0/gamma)*(1.d0+1.d0/gamma))

c error? 16feb07        WGANG2=(WGWINFC/GAMMA)**2+2.0D0/(GAMMA**2*(1.0D0+DMYBETA))
C ERROR 11jan08        WGANG2=(WGWINFC/GAMMA)**2
      WGANG=WGWINFC/GAMMA

      ICSPL=0

      INSIDE=0
      IINSIDE=0
      jinside=0

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS     T=-R0*C1
      T=0.0D0 !WICHTIG HIER WEGEN TENDSOU-T WEITER UNTEN

      R0=OBSVRPHI(1,1)-soura(1,1)

      IF (ISPECMODE.EQ.1) THEN
        T0=DWT(1)
        T1=T0
        T2=DWT(MCO)
        XENDSOU=DWX(MCO)    !FINAL X
      ELSE
        T0=SOURCET(1,ISOUR)
        T1=T0
        T2=SOURCET(2,ISOUR)
        XENDSOU=soure(1,1)    !FINAL X
      ENDIF

      TENDSOU=T2-T1

      X1=xelec
      Y1=yelec
      Z1=zelec

      VX1=vxelec
      VY1=vyelec
      VZ1=vzelec

      BX1=soura(1,4)
      BY1=soura(2,4)
      BZ1=soura(3,4)
      BS1=SQRT(BX1**2+BY1**2+BZ1**2)

      IZTOTS=0

      X0=X1
      X2=X1
      X10=(XENDSOU-X0)/10.1D0

      NZAEHL=NLPOIO
      DT0=TENDSOU/NZAEHL

      DT=DT0

      if (ielec.eq.1) then

        KZAEHL=0

        IR1=-1
        DO IROI=1,NROIA
          IF (ROIX(IROI).GT.X1.AND.ROIX(IROI).LT.XENDSOU.AND.IR1.EQ.-1) THEN
            IR1=IROI
            GOTO 11
          ENDIF
        ENDDO

11      DO IROI=1,NROIA
          IR2=IROI
          IF (roi(IROI).GT.XENDSOU) THEN
            roi(IROI)=XENDSOU
            IR2=IR2-1
            IF (roi(IR2).LT.X1) THEN
              roi(IR2)=X1
            ENDIF
            GOTO 12
          ENDIF
        ENDDO

12      CONTINUE

        KZAEHL=KZAEHL+NZAEHL*ROIP(IR2)*(XENDSOU-roi(IR2))/(XENDSOU-X1)

        IF (IR1.NE.-1) THEN

          KZAEHL=KZAEHL+NZAEHL*ROIP(IR1-1)*(roi(IR1)-X1)/(XENDSOU-X1)

          DO IROI=IR1,IR2-1
            IF (roi(IROI).GT.X1.OR.roi(IROI)+1.LT.XENDSOU) THEN
              KZAEHL=KZAEHL+NZAEHL*ROIP(IROI)*(roi(IROI+1)-roi(IROI))/(XENDSOU-X1)
            ELSE IF (roi(IROI).GT.X1.OR.roi(IROI)+1.LT.XENDSOU) THEN
              KZAEHL=KZAEHL+NZAEHL*ROIP(IROI)*(roi(IROI+1)-roi(IROI))/(XENDSOU-X1)
            ENDIF
          ENDDO

        ENDIF

      endif !ielec.eq.1

      IF (X1.LT.ROIX(1).OR.XENDSOU.GT.ROIX(NROIA)) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN SOUINTRPHI: X OUTSIDE ROIS ***'
        WRITE(LUNGFO,*)'CHECK NAMELIST $ROIN'
        WRITE(LUNGFO,*)' *** PROGRAM WAVE ABORTED ***'
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN SOUINTRPHI: X OUTSIDE ROIS ***'
        WRITE(6,*)'CHECK NAMELIST $ROIN'
        WRITE(6,*)' *** PROGRAM WAVE ABORTED ***'
        STOP
      ENDIF   !IROI

      X2=X1
      Y2=Y1
      Z2=Z1

      VX2=VX1
      VY2=VY1
      VZ2=VZ1

      BX2=BX1
      BY2=BY1
      BZ2=BZ1
      BS=BS1

C--- LOOP OVER STEPS

      DO IROI=1,NROIA
        IPOIROI(IROI)=0
      ENDDO

      IROI=1
      DO I=1,NROIA
        IF (X1.GE.ROIX(I)) THEN
          IROI=I
        ENDIF !(X1.GE.ROIX(I))
      ENDDO   !IROI

      DT=DT0/ROIP(IROI)

      NZAEHL=MAX(5,NINT((TENDSOU-T)/DT))
      DT=(TENDSOU-T)/NZAEHL

      TENDSOU1=TENDSOU-DT
      DT2=DT/2.D0

C- CHECK STEPS SIZE

      IF (IWARNROI(IROI,ISOUR).EQ.0) THEN
        IF (DT.GT.DTIM00) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      '*** WARNING IN SOUINTRPHI, SOURCE, ROI:',ISOUR,IROI
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
          WRITE(LUNGFO,*)'SIZE FOR TRAJECTORY!'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
          WRITE(6,*)
          WRITE(6,*)
     &      '*** WARNING IN SOUINTRPHI, SOURCE, ROI:',ISOUR,IROI
          WRITE(6,*)
          WRITE(6,*)'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
          WRITE(6,*)'SIZE FOR TRAJECTORY!'
          WRITE(6,*)
          WRITE(6,*)
     &      'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
          WRITE(6,*)
          IWARNROI(IROI,ISOUR)=1
        ENDIF !DT
      ENDIF !IWARNROI

      IROI=IROI+1

      IZAEHL=0 !LOOP COUNTER

      nutrack=ielec
      nustep=izaehl

      if (ielec.eq.1) then
        iizaehl=0 !total number of steps in souintana
        NZAEHL10=KZAEHL*nelec*nobsvrphi/10
        MZAEHL=NZAEHL10
        IX10=1
      endif

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS     T=-R0*C1

      T=-DT
      TS=-DT

      expom1rphi=ZONE
      DEXPOMPH1=ZONE

      IF (IFREQ2P.EQ.0) THEN
        DO JFREQ=1,NFREQ
          EXPOM2P0(1,JFREQ)=ZONE
        ENDDO
      ENDIF

      afferphi=(0.0D0,0.0D0)
      yp2zp2i=0.0d0
c      yp2zp2ia=0.0d0
      f=0.0d0

1000  IZAEHL=IZAEHL+1

      nustep=izaehl

      IF (ISOUR.eq.1.and.IIZAEHL.GE.MZAEHL) THEN
        CALL date_and_time(dtday,dttime,dtzone,idatetime)
        WRITE(6,*)' ',IX10,' ',dttime(1:2),':',dttime(3:4),':',dttime(5:6)
        IX10=IX10+1
        if (ix10.eq.10) then
          mzaehl=NZAEHL10*9.9
        else
          MZAEHL=MZAEHL+NZAEHL10
        endif
      ENDIF

      IF (IROI.LE.NROIA) THEN

        IF (X2.GE.ROIX(IROI)) THEN

          DT=DT0/ROIP(IROI)
          NZAEHL=NINT((TENDSOU-T)/DT)

          IF (ISPECMODE.EQ.1) THEN
            DT=(TENDSOU-T)/(NZAEHL-1)
          ELSE
            DT=(TENDSOU-T)/NZAEHL
          ENDIF

          TENDSOU1=TENDSOU-DT

          DT2=DT/2.D0

          IF (IWARNROI(IROI,ISOUR).EQ.0) THEN

            IF (DT.GT.DTIM00) THEN

              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          '*** WARNING IN SOUINTRPHI, SOURCE, ROI:',ISOUR,IROI
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
              WRITE(LUNGFO,*)'SIZE FOR TRAJECTORY!'
              WRITE(LUNGFO,*)
              WRITE(LUNGFO,*)
     &          'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
              WRITE(6,*)
              WRITE(6,*)
     &          '*** WARNING IN SOUINTRPHI, SOURCE, ROI:',ISOUR,IROI
              WRITE(6,*)
              WRITE(6,*)'STEP SIZE FOR SOURCE POINT IS LARGER THAN STEP'
              WRITE(6,*)'SIZE FOR TRAJECTORY!'
              WRITE(6,*)
              WRITE(6,*)
     &          'CHANGE NLPOI OR ROI-PARAMETERS OR BE AWARE OF STRANGE RESULTS!'
              WRITE(6,*)

              IWARNROI(IROI,ISOUR)=1

            ENDIF !DT

          ENDIF !IWARNROI

          IROI=IROI+1

        ENDIF   !X2

      ENDIF   !IROI

      IPOIROI(IROI)=IPOIROI(IROI)+1

      T=T+DT

      IF (LSTEP.EQ.1) THEN

        IF (X2.LE.XENDSOU) THEN

          DT=(MIN(XENDSOU,XIEND)-X2)/VX2
          DT2=DT/2.0D0

        ELSE

          TS=TS-DT
          T=T-DT

          DT=(MIN(XENDSOU,XIEND)-X1)/VX2
          DT2=DT/2.0D0

          X2=X1
          Y2=Y1
          Z2=Z1

          VX2=VX1
          VY2=VY1
          VZ2=VZ1

          BX2=BX1
          BY2=BY1
          BZ2=BZ1

        ENDIF

      ENDIF

      X1=X2
      Y1=Y2
      Z1=Z2

      VX1=VX2
      VY1=VY2
      VZ1=VZ2

      BX1=BX2
      BY1=BY2
      BZ1=BZ2
      BS1=BS

      IF (ISPECMODE.NE.1) THEN

C GET MAGNETIC FIELD {

        X2B=X1+VX1*DT2
        Y2B=Y1+VY1*DT2
        Z2B=Z1+VZ1*DT2
        norad=0
        if (ibmasksp.ne.0) then
          ibmasksp=-abs(ibmasksp)
          call mybfeld(x2b,y2b,z2b,bx2,by2,bz2,ax2d,ay2d,az2d)
          if ((bx2**2+by2**2+bz2**2).ne.0.0d0) then
            norad=1
          endif
          ibmasksp=-ibmasksp
        endif

        X2=WSOU(1,1,IZAEHL)
        Y2=WSOU(2,1,IZAEHL)
        Z2=WSOU(3,1,IZAEHL)

        VX2=WSOU(1,2,IZAEHL)
        VY2=WSOU(2,2,IZAEHL)
        VZ2=WSOU(3,2,IZAEHL)

        VXP=WSOU(1,3,IZAEHL)
        VYP=WSOU(2,3,IZAEHL)
        VZP=WSOU(3,3,IZAEHL)

        DT=   wsou(1,4,IZAEHL)
        BETA= wsou(2,4,IZAEHL)
        GAMMA=wsou(3,4,IZAEHL)

        bX2=WSOU(1,5,IZAEHL)
        bY2=WSOU(2,5,IZAEHL)
        bZ2=WSOU(3,5,IZAEHL)

        BX=VX2*C1
        BY=VY2*C1
        BZ=VZ2*C1

        BPX=VXP*C1
        BPY=VYP*C1
        BPZ=VZP*C1

C MOVE ONE STEP }

      ELSE  !ISPECMODE

        CALL WAVE_TRACK_INTER(TS,X2,Y2,Z2,VX2,VY2,VZ2,VXP,VYP,VZP,BS,ICSPL,
     &    GAMMA)

        norad=0
        if (ibmasksp.ne.0) then
          ibmasksp=-abs(ibmasksp)
          call mybfeld(x2b,y2b,z2b,bx2,by2,bz2,ax2d,ay2d,az2d)
          if ((bx2**2+by2**2+bz2**2).ne.0.0d0) then
            norad=1
          endif
          ibmasksp=-ibmasksp
        endif

        IF (IENELOSS.NE.0) THEN
          BETA=DSQRT((1.D0-1.D0/GAMMA)*(1.D0+1.D0/GAMMA))
        ENDIF

        BSQ=BS*BS
        BY2=BSQ

        BX=VX2*C1
        BY=VY2*C1
        BZ=VZ2*C1

        BPX=VXP*C1
        BPY=VYP*C1
        BPZ=VZP*C1

      ENDIF !ISPECMODE

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION {

C REAL PART OF INTEGRAND {

      DO JOBSV=1,NOBSVRPHI

        if (jobsv.eq.1.and.iobunch.ne.-9999) then
          iobsv=iobunch
        else if (jobsv.eq.iobunch) then
          iobsv=1
        else
          iobsv=jobsv
        endif

        ILIOB=ISOUR+NSOURCE*(IOBSV-1)

        XRPHI=OBSVRPHI(1,IOBSV)
        YRPHI=OBSVRPHI(2,IOBSV)*SIN(OBSVRPHI(3,IOBSV))
        ZRPHI=OBSVRPHI(2,IOBSV)*COS(OBSVRPHI(3,IOBSV))

        r=sqrt((xrphi-x1)**2+((yrphi-y1)**2+(zrphi-z1)**2))
        PHASE=(r-r0)*c1 ! needed for phase of field amplitude
        if (izaehl.eq.1) then
          phaserphi(iobsv)=phase
          expom1rphi(iobsv)=cdexp(dcmplx(0.0d0,phaserphi(iobsv)*om))
        endif

        RX=XRPHI-X2
        RY=YRPHI-Y2
        RZ=ZRPHI-Z2

        R=SQRT(RX*RX+RY*RY+RZ*RZ)
        R1=1.D0/R
        ZICR1=ZIC*R1

        RNX=RX*R1
        RNY=RY*R1
        RNZ=RZ*R1

C--- THE DISTANCE R IS INTRODUCED HERE EXPLICITLY (S. PROGRAM OF CHAOEN WANG

        BET1N=(1.0D0-BX*RNX)-BY*RNY-BZ*RNZ
c 20090928{
        br2=by**2+bz**2
        rnr2=rny**2+rnz**2
        b3=beta**3
        br4=br2**2
        rnr4=rnr2**2

        if(br2.lt.1.0d-4.and.rnr2.lt.1.0d-4) then
          bet1n=
     &      1.0d0/(1.0d0+beta)/gamma**2
     &      +beta*(rnr2/2.0d0
     &      +rnr4/8.0d0)
     &      +(br2/2.0d0
     &      -br2*rnr2/4.0d0
     &      -br2*rnr4/16.0d0)/beta
     &      +b3*br4*(1.0d0/8.0d0
     &      -rnr2/16.0d0
     &      -rnr4/64.0d0)
     &      -by*rny
     &      -bz*rnz
        endif
c }20090928

        OPANG=BX/BETA*RNX+BY/BETA*RNY+BZ/BETA*RNZ

        IF (ABS(OPANG).LE.1.0D0) THEN
          OPANG=ACOS(OPANG)
        ELSE IF (OPANG.GT.1.0D0) THEN
          OPANG=0.0D0
        ELSE
          OPANG=-PI1
        ENDIF

        DUM11=1.0D0/BET1N
        DOM1=1.0D0/(R*BET1N*BET1N)

        IF (IOBSV.EQ.1) THEN
          IF (IZAEHL.EQ.1) THEN
            BET1NO=BET1N
          ELSE IF (iundulator.eq.0
     &        .and.(BET1N-BET1NO)/BET1N.GT.0.05.AND.IWARNBET1N.EQ.0) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** WARNING IN SOUINTRPHI  ***'
            WRITE(LUNGFO,*)'DISCONTINUITY IN INTEGRAND'
            WRITE(LUNGFO,*)
     &        'Check results carefully, change BMOVECUT, MYINUM, NLPOI etc.'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'ISTEP,X,BET1N,BET1NO:',IZAEHL,SNGL(X1),SNGL(BET1N),SNGL(BET1NO)
            WRITE(LUNGFO,*)'FURTHER WARNINGS ARE SUPPRESSED!'
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)'*** WARNING IN SOUINTRPHI  ***'
            WRITE(6,*)'DISCONTINUITY IN INTEGRAND'
            WRITE(6,*)
     &        'Check results carefully, change BMOVECUT, MYINUM, NLPOI etc.'
            WRITE(6,*)
            WRITE(6,*)'ISTEP,X,BET1N,BET1NO:',IZAEHL,SNGL(X1),SNGL(BET1N),SNGL(BET1NO)
            WRITE(6,*)
            WRITE(6,*)'FURTHER WARNINGS ARE SUPPRESSED!'
            WRITE(6,*)
            IWARNBET1N=1
          ENDIF
          BET1NO=BET1N
        ENDIF

        RNBX=RNX-BX
        RNBY=RNY-BY
        RNBZ=RNZ-BZ

        PX=(RNBY*BPZ-RNBZ*BPY)
        PY=(RNBZ*BPX-RNBX*BPZ)
        PZ=(RNBX*BPY-RNBY*BPX)

        IF (IVELOFIELD.EQ.0) THEN !2 WEGEN POWER
          DOM2=C*DOM1*R1/GAMMA**2
          RARG(1)=(RNY*PZ-RNZ*PY)*DOM1+(RNX-BX)*DOM2
          RARG(2)=(RNZ*PX-RNX*PZ)*DOM1+(RNY-BY)*DOM2
          RARG(3)=(RNX*PY-RNY*PX)*DOM1+(RNZ-BZ)*DOM2
        ELSE IF (IVELOFIELD.EQ.1) THEN
          RARG(1)=(RNY*PZ-RNZ*PY)*DOM1
          RARG(2)=(RNZ*PX-RNX*PZ)*DOM1
          RARG(3)=(RNX*PY-RNY*PX)*DOM1
        ELSE IF (IVELOFIELD.LT.0) THEN
          DOM2=C*DOM1*R1/GAMMA**2
          RARG(1)=(RNX-BX)*DOM2
          RARG(2)=(RNY-BY)*DOM2
          RARG(3)=(RNZ-BZ)*DOM2
        ELSE   !IVELOFIELD
          WRITE(6,*)
     &      '*** ERROR IN SOUINTRPHI: BAD VALUE OF IVELOFIELD  ***'
          WRITE(6,*) '*** PROGRAM WAVE ABORTED  ***'
          STOP
        ENDIF  !IVELOFIELD

        IF (iinside(iobsv).EQ.0.AND.OPANG.LE.WGANG) THEN
          if (iobsv.eq.1) then
            DPHSOUR(1,1)=BET1N*DT*FREQ(1)/HBAREV1
            DPHSOUR(1,2)=BET1N*DT*FREQ(NFREQ)/HBAREV1
          endif
          iinside(iobsv)=1
          INSIDE=1
          jinside(iobsv)=jinside(iobsv)+1
          IF (jinside(iobsv).GT.1) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** WARNING IN SOUINTRPHI  ***'
            WRITE(LUNGFO,*)'*** SOURCE:',ISOUR
            WRITE(LUNGFO,*)'STRANGE SOURCE, CONTAINS SEVERAL SOURCES'
            WRITE(LUNGFO,*)'SOURCE AND OBSERVATION POINT:'
            WRITE(LUNGFO,*)
     &        ISOUR,OBSVRPHI(1,IOBSV),OBSVRPHI(2,IOBSV),OBSVRPHI(3,IOBSV)
            WRITE(LUNGFO,*)
     &        'RESULTS OF SPECTRUM CALCULATIONS MAY BE UNRELIABLE'
            WRITE(LUNGFO,*)'*** CHECK COLLIMATOR, PINHOLE, WGWINFC ... ***'
            WRITE(6,*)
            WRITE(6,*)'*** WARNING IN SOUINTRPHI  ***'
            WRITE(6,*)'*** SOURCE:',ISOUR
            WRITE(6,*)'*** STRANGE SOURCE, CONTAINS SEVERAL SOURCES'
            WRITE(6,*)'SOURCE AND OBSERVATION POINT:',
     &        ISOUR,OBSVRPHI(1,IOBSV),OBSVRPHI(2,IOBSV),OBSVRPHI(3,IOBSV)
            WRITE(6,*)
            WRITE(6,*)'*** CHECK COLLIMATOR, PINHOLE, WGWINFC ... ***'
            WRITE(6,*)'WARNING OF SPECTRUM CALCULATIONS ARE UNRELIABLE'
            jinside(iobsv)=jinside(iobsv)-1   !SUPRESS LOTS OF WARNINGS
          ENDIF   !jinside(iobsv)
        ELSE IF (iinside(iobsv).EQ.1.AND.OPANG.GT.WGANG) THEN
          iinside(iobsv)=0
        ENDIF   !iinside(iobsv)

        IF (iinside(iobsv).NE.0) THEN

C DO NOT USE, RESULTS IN NUMERICAL PROBLEMS      RARG(4)=T+R*C1

          DPHASE=BET1N*DT

          RARG(4)=phaserphi(iobsv)
          RARG(5)=(RARG(1)*RARG(1)+RARG(2)*RARG(2)+RARG(3)*RARG(3))*DUM11

          if (norad.ne.0) rarg=0.0d0

C REAL PART OF INTEGRAND }

C COMPLEX PART OF INTEGRAND {

C    ASSUMES FREQ(I+1)=2*FREQ(I)   FOR IFREQ2P=2
C    OR FREQ(I+1)=FREQ(I)+DELTA    FOR IFREQ2P>2

C--- LOOP OVER ALL FREQUENCES

          IFREQ=1
          if (nelec.gt.1) then
            dexpbunch=phexp(ifreq)
          else
            dexpbunch=(1.0d0,0.0d0)
          endif

          IFROB=IFREQ+NFREQ*(IOBSV-1)

          OM=FREQ(IFREQ)/HBAREV1
          ZIOM=ZI*OM

          EXPOM=expom1rphi(iobsv)
          DEXPOMPH1=EXP(ZIOM*DPHASE)
          DEXPOMPH=DEXPOMPH1

          IF(IFREQ2P.GT.2) THEN
            DEXPOM=EXP(ZIDOM*phaserphi(iobsv))
            DDEXPOMPH=EXP(ZIDOM*DPHASE)
          ELSE IF(IFREQ2P.EQ.0) THEN
            EXPOM2P0(2,IFREQ)=EXP(ZIOM*DPHASE)
            EXPOM=EXPOM2P0(1,IFREQ)
          ENDIF   !IFREQ2P

          IF (X2.GE.XIANF.AND.X2.LE.XIEND) THEN

            SPECPOWRPHI(ILIOB)=SPECPOWRPHI(ILIOB)+RARG(5)*DT

            DO ICOMP=1,3
              daff(icomp)=RARG(ICOMP)/BET1N/OM*EXPOM*(ZONE-DEXPOMPH)*DEXPbunch/sqnphsp
              afferphi(icomp,ifrob)=afferphi(icomp,ifrob)+daff(icomp)
            ENDDO   !ICOMP

c            baff(1)=conjg(rny*daff(3)-rnz*daff(2))
c            baff(2)=conjg(rnz*daff(1)-rnx*daff(3))
c            baff(3)=conjg(rnx*daff(2)-rny*daff(1))

            baff(1)=(rny*daff(3)-rnz*daff(2))
            baff(2)=(rnz*daff(1)-rnx*daff(3))
            baff(3)=(rnx*daff(2)-rny*daff(1))

            afferphi(4:6,ifrob)=afferphi(4:6,ifrob)+baff(1:3)/clight1

          ENDIF   !XIANF

          IF (IWFILINT.NE.0) THEN
            IF (MOD(IZAEHL,JWFILINT).EQ.0) THEN
              IF (IWFILINT.LT.0) THEN
                FILLT(1)=T
                FILLT(2)=X2
                FILLT(3)=Y2
                FILLT(4)=Z2
                FILLT(5)=RARG(1)
                FILLT(6)=RARG(2)
                FILLT(7)=RARG(3)
                FILLT(8)=RARG(4)
                FILLT(9)=RARG(5)
                FILLT(10)=dREAL(EXPOM)
                FILLT(11)=dIMAG(EXPOM)
                FILLT(12)=IROI-1
                FILLT(13)=IOBSV
                FILLT(14)=IFREQ
                FILLT(17)=BET1N
                FILLT(18)=OM
                FILLT(19)=DT
                FILLT(20)=BY2
                FILLT(21)=ISOUR
                FILLT(15)=YRPHI
                FILLT(16)=ZRPHI
                FILLT(22)=
     &            (
     &            REAL(afferphi(1,ifrob))*REAL(afferphi(1,ifrob))
     &            +IMAG(afferphi(1,ifrob))*IMAG(afferphi(1,ifrob))
     &            +REAL(afferphi(2,ifrob))*REAL(afferphi(2,ifrob))
     &            +IMAG(afferphi(2,ifrob))*IMAG(afferphi(2,ifrob))
     &            +REAL(afferphi(3,ifrob))*REAL(afferphi(3,ifrob))
     &            +IMAG(afferphi(3,ifrob))*IMAG(afferphi(3,ifrob))
     &            )*SPECNOR*bunnor
                FILLT(23)=dREAL(afferphi(1,ifrob))*SPECNOR*bunnor
                FILLT(24)=dIMAG(afferphi(1,ifrob))*SPECNOR*bunnor
                FILLT(25)=dREAL(afferphi(2,ifrob))*SPECNOR*bunnor
                FILLT(26)=dIMAG(afferphi(2,ifrob))*SPECNOR*bunnor
                FILLT(27)=dREAL(afferphi(3,ifrob))*SPECNOR*bunnor
                FILLT(28)=dIMAG(afferphi(3,ifrob))*SPECNOR*bunnor
                FILLT(29)=DOM1
                FILLT(30)=bx
                FILLT(31)=by
                FILLT(32)=bz
                FILLT(33)=bpx
                FILLT(34)=bpy
                FILLT(35)=bpz
                FILLT(36)=rnx
                FILLT(37)=rny
                FILLT(38)=rnz

                CALL hfm(NIDSOURCE,FILLT)

              ELSE IF (ISOUR.EQ.IWFILINT.AND.IOBSV.EQ.1) THEN

                WRITE(LUNINT,*) IZAEHL,IFREQ,X2
                WRITE(LUNINT,*) (RARG(1),IC=1,3)
                WRITE(LUNINT,*) RARG(4)*OM,RARG(5)
                WRITE(LUNINT,*)REAL(EXPOM),IMAG(EXPOM)
                WRITE(LUNINT,*)RARG(1)*REAL(EXPOM),RARG(1)*IMAG(EXPOM)
                WRITE(LUNINT,*)RARG(2)*REAL(EXPOM),RARG(2)*IMAG(EXPOM)
                WRITE(LUNINT,*)RARG(3)*REAL(EXPOM),RARG(3)*IMAG(EXPOM)

              ENDIF !IWFILINT.LT.0
            ENDIF !JFILINT
          ENDIF !IWFILINT.NE.0

          DO IFREQ=2,NFREQ

            IFROB=IFREQ+NFREQ*(IOBSV-1)

            IF (IFREQ2P.GT.2) THEN
              OM=OM+DOM
              EXPOM=EXPOM*DEXPOM
              DEXPOMPH=DEXPOMPH*DDEXPOMPH
            ELSE IF(IFREQ2P.EQ.2) THEN
              OM=OM*2.0D0
              EXPOM=EXPOM*EXPOM
              DEXPOMPH=DEXPOMPH*DEXPOMPH
            ELSE IF(IFREQ2P.EQ.0) THEN
              OM=FREQ(IFREQ)/HBAREV1
              ZIOM=ZI*OM
              EXPOM2P0(2,IFREQ)=EXP(ZIOM*DPHASE)
              EXPOM=EXPOM2P0(1,IFREQ)
              DEXPOMPH=EXPOM2P0(2,IFREQ)
            ELSE
              OM=FREQ(IFREQ)/HBAREV1
              ZIOM=ZI*OM
              DEXPOMPH=EXP(ZIOM*DPHASE)
            ENDIF

            if (nelec.gt.1) then
              dexpbunch=phexp(ifreq)
            endif

            IF (X2.GE.XIANF.AND.X2.LE.XIEND.and.norad.eq.0) THEN
              EXPOMV2=1.0D0/BET1N/OM*EXPOM*(ZONE-DEXPOMPH)

              DO ICOMP=1,3
                daff(icomp)=RARG(ICOMP)*EXPOMV2*DEXPbunch/sqnphsp
c                print*,izaehl,ifrob,icomp,rarg(icomp),expomv2,dexpbunch,sqnphsp
c                print*,daff
                afferphi(ICOMP,ifrob)=afferphi(ICOMP,ifrob)+daff(icomp)
              ENDDO

c              baff(1)=conjg(rny*daff(3)-rnz*daff(2))
c              baff(2)=conjg(rnz*daff(1)-rnx*daff(3))
c              baff(3)=conjg(rnx*daff(2)-rny*daff(1))

              baff(1)=(rny*daff(3)-rnz*daff(2))
              baff(2)=(rnz*daff(1)-rnx*daff(3))
              baff(3)=(rnx*daff(2)-rny*daff(1))

              afferphi(4:6,ifrob)=afferphi(4:6,ifrob)+baff(1:3)/clight1

            ENDIF !XIEND

            IF (IWFILINT.NE.0) THEN
              IF (MOD(IZAEHL,JWFILINT).EQ.0) THEN
                IF (IWFILINT.LT.0) THEN
                  FILLT(1)=T
                  FILLT(2)=X2
                  FILLT(3)=Y2
                  FILLT(4)=Z2
                  FILLT(5)=RARG(1)
                  FILLT(6)=RARG(2)
                  FILLT(7)=RARG(3)
                  FILLT(8)=RARG(4)
                  FILLT(9)=RARG(5)
                  FILLT(10)=dREAL(EXPOM)
                  FILLT(11)=dIMAG(EXPOM)
                  FILLT(12)=IROI-1
                  FILLT(13)=IOBSV
                  FILLT(14)=IFREQ
                  FILLT(17)=BET1N
                  FILLT(18)=OM
                  FILLT(19)=DT
                  FILLT(20)=BY2
                  FILLT(21)=ISOUR
                  FILLT(15)=YRPHI
                  FILLT(16)=ZRPHI
                  FILLT(22)=
     &              (
     &              REAL(afferphi(1,ifrob))*REAL(afferphi(1,ifrob))
     &              +IMAG(afferphi(1,ifrob))*IMAG(afferphi(1,ifrob))
     &              +REAL(afferphi(2,ifrob))*REAL(afferphi(2,ifrob))
     &              +IMAG(afferphi(2,ifrob))*IMAG(afferphi(2,ifrob))
     &              +REAL(afferphi(3,ifrob))*REAL(afferphi(3,ifrob))
     &              +IMAG(afferphi(3,ifrob))*IMAG(afferphi(3,ifrob))
     &              )*SPECNOR*bunnor
                  FILLT(23)=dREAL(afferphi(1,ifrob))*SPECNOR*bunnor
                  FILLT(24)=dIMAG(afferphi(1,ifrob))*SPECNOR*bunnor
                  FILLT(25)=dREAL(afferphi(2,ifrob))*SPECNOR*bunnor
                  FILLT(26)=dIMAG(afferphi(2,ifrob))*SPECNOR*bunnor
                  FILLT(27)=dREAL(afferphi(3,ifrob))*SPECNOR*bunnor
                  FILLT(28)=dIMAG(afferphi(3,ifrob))*SPECNOR*bunnor
                  FILLT(29)=DOM1
                  FILLT(30)=bx
                  FILLT(31)=by
                  FILLT(32)=bz
                  FILLT(33)=bpx
                  FILLT(34)=bpy
                  FILLT(35)=bpz
                  FILLT(36)=rnx
                  FILLT(37)=rny
                  FILLT(38)=rnz
                  CALL hfm(NIDSOURCE,FILLT)

                ELSE IF (ISOUR.EQ.IWFILINT.AND.IOBSV.EQ.1) THEN

                  WRITE(LUNINT,*) IZAEHL,IFREQ,X2
                  WRITE(LUNINT,*) (RARG(1),IC=1,3)
                  WRITE(LUNINT,*) RARG(4)*OM,RARG(5)
                  WRITE(LUNINT,*)REAL(EXPOM),IMAG(EXPOM)
                  WRITE(LUNINT,*)RARG(1)*REAL(EXPOM),RARG(1)*IMAG(EXPOM)
                  WRITE(LUNINT,*)RARG(2)*REAL(EXPOM),RARG(2)*IMAG(EXPOM)
                  WRITE(LUNINT,*)RARG(3)*REAL(EXPOM),RARG(3)*IMAG(EXPOM)

                ENDIF !IWFILINT.LT.0
              ENDIF !JWFILINT
            ENDIF !IWFILINT.NE.0

          ENDDO   !LOOP OVER ALL FREQUENCES

        ENDIF   !iinside(iobsv)

C COMPLEX PART OF INTEGRAND }

C CONTRIBUTION OF TIME STEP TO SYNCHROTRON RADIATION }

        phase=phaserphi(iobsv)
        phaserphi(iobsv)=phaserphi(iobsv)+DPHASE
        expom1rphi(iobsv)=expom1rphi(iobsv)*DEXPOMPH1

        IF(IFREQ2P.EQ.0) THEN

          DO JFREQ=1,NFREQ
            OM=FREQ(JFREQ)/HBAREV1
            ZIOM=ZI*OM
            EXPOM2P0(1,JFREQ)=EXPOM2P0(1,JFREQ)*EXPOM2P0(2,JFREQ)
          ENDDO
        ENDIF

        IF (iinside(iobsv).NE.0.and.iobsv.eq.1) THEN
          DPHSOUR(2,1)=BET1N*DT*FREQ(1)/HBAREV1
          DPHSOUR(2,2)=BET1N*DT*FREQ(NFREQ)/HBAREV1
        ENDIF

      ENDDO !IOBSV=1,NOBSVRPHI

      IIZAEHL=IIZAEHL+nobsvrphi !total step counter

      TS=TS+DT

C--- END OF LOOP OVER TIME STEPS

c      yp2zp2ia=yp2zp2ia
c     &  +((vy1/vx1)**2+(vy2/vx2)**2+(vz1/vx1)**2+(vz2/vx2)**2)*beta*clight1*dt2

      f(3)=((vy2/vx2)**2+(vz2/vx2)**2)
      fdt(3)=dt

      if (lstep.eq.1) then
        yp(1)=(f(2)-f(1))/fdt(2)
        yp(3)=(f(3)-f(2))/fdt(3)
        yp(2)=(yp(3)+yp(1))/2.0d0
        ypp=(yp(3)-yp(1))/(fdt(2)+fdt(3))*2.0d0
        a(3)=ypp/2.0d0
        a(2)=yp(2)-2.0d0*a(3)*fdt(2)
        a(1)=f(2)-a(2)*fdt(2)-a(3)*fdt(2)**2
        dfdt=fdt(2)+fdt(3)
        fihi=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        dfdt=0.0d0
        filo=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        yp2zp2i=yp2zp2i+fihi-filo
        yp2zp2i=yp2zp2i*beta*clight1
      else if (izaehl.ge.3) then
        yp(1)=(f(2)-f(1))/fdt(2)
        yp(3)=(f(3)-f(2))/fdt(3)
        yp(2)=(yp(3)+yp(1))/2.0d0
        ypp=(yp(3)-yp(1))/(fdt(2)+fdt(3))*2.0d0
        a(3)=ypp/2.0d0
        a(2)=yp(2)-2.0d0*a(3)*fdt(2)
        a(1)=f(2)-a(2)*fdt(2)-a(3)*fdt(2)**2
        dfdt=fdt(2)+fdt(3)
        fihi=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        dfdt=fdt(2)
        filo=a(1)*dfdt+a(2)/2.0d0*dfdt**2+a(3)/3.0d0*dfdt**3
        yp2zp2i=yp2zp2i+fihi-filo
      endif

      f(1)=f(2)
      fdt(1)=fdt(2)
      f(2)=f(3)
      fdt(2)=fdt(3)

      if (ispecmode.eq.2) then
        if (izaehl.lt.ipoisou(isour)) goto 1000
      else
        IF (X2.LT.XENDSOU-VX2*DT.AND.X2.LT.(XIEND-VX2*DT).AND.LSTEP.EQ.0)
     &    GOTO 1000
        IF (LSTEP.EQ.0) THEN
          LSTEP=1
          GOTO 1000
        ENDIF
      endif

      IF (IAMPLI.LT.0) THEN

        if (nelec.eq.1) then
          print*,' '
          print*,'Starting phase repetition, counting from one to 10 to show progress:'
          print*,' '
        endif

        DXEXI=MIN(soure(1,1),XIEND)
     &    -MAX(soura(1,1),XIANF)
        if (ampr2corr.eq.-9999.0d0) ampr2corr=dxexi
        CENXEXI=(MIN(soure(1,1),XIEND)
     &    +MAX(soura(1,1),XIANF))/2.D0
        GAMGAM0=(SOURCEG(1,1,ISOUR)*(egamma/dmygamma))**2
        GAMGAM=(
     &    (SOURCEG(1,1,ISOUR)+SOURCEG(2,2,ISOUR))*(egamma/dmygamma)
     &    )**2

        XRPHI=OBSVRPHI(1,1)

        slopein=sqrt(vyin**2+vzin**2)/vxin
        slope=sqrt(vyelec**2+vzelec**2)/vxelec

        if (myinum.gt.nlpoi/dxexi) then
          WI=(WTRA2IS(ISOUR)
     &      -DXEXI/2.0D0*slopein**2) !wi is detour for on-axis particle
     &      *(dmygamma/egamma)**2
        else
          if (iwarnwi.eq.0) then
            write(lungfo,*)
            write(lungfo,*)'*** Warning in SOUINTANA:'
            write(lungfo,*)'*** MYINUM is rather small with respect to NLPOI'
            write(lungfo,*)'*** Length of trajectories are now calculated by simple'
            write(lungfo,*)'*** integration with SOUINTANA, which might be poor'
            write(lungfo,*)
            write(lungfo,*)
            write(6,*)'*** Warning in SOUINTANA:'
            write(6,*)'*** MYINUM is rather small with respect to NLPOI'
            write(6,*)'*** Length of trajectories are now calculated by simple'
            write(6,*)'*** integration with SOUINTANA, which might be poor'
            write(6,*)
            iwarnwi=1
          endif
          wi=(yp2zp2i/2.0d0
     &      -DXEXI/2.0D0*slopein**2) !wi is detour for on-axis particle
     &      *(dmygamma/egamma)**2
        endif

        xn1=cenxexi
        yn1=(xn1-cenxexi)*vyelec/vxelec
        zn1=(xn1-cenxexi)*vyelec/vxelec

        drn2=(
     &    (yn1+dxexi*vyelec/vxelec)**2+
     &    (zn1+dxexi*vzelec/vxelec)**2
     &    )/
     &    (2.0d0*(xrphi-xn1-dxexi))

        drn1=(
     &    yn1**2+
     &    zn1**2
     &    )/
     &    (2.0d0*(xrphi-xn1))

        DTPHASE=(
     &    WI+DXEXI*(slope**2/2.0d0+1.0d0/(2.0D0*GAMGAM0))
     &    +drn2-drn1)
     &    /CLIGHT1*GAMGAM0/GAMGAM

        AMPDT=AMPSHIFT(1)/CLIGHT1/2.0D0/GAMGAM0
        FREQR=2.0D0*PI1/DTPHASE*HBAREV1

        ICOUNT=0
        NCOUNT=NFREQ*NOBSVRPHI*ABS(IAMPLI)
        NCOUNT10=NCOUNT/10
        MCOUNT=NCOUNT10
        N10=0

      ENDIF !IAMPLI

      DO IFREQ=1,NFREQ

        DO IOBSV=1,NOBSVRPHI

          ILIOBFR=ISOUR+NSOURCE*(IOBSV-1+NOBSVRPHI*(IFREQ-1))
          IFROB=IFREQ+NFREQ*(IOBSV-1)
          IOBFR=IOBSV+NOBSVRPHI*(IFREQ-1)

          IF (IAMPLI.LT.0) THEN

            YRPHI=OBSVRPHI(2,IOBSV)*SIN(OBSVRPHI(3,IOBSV))
            ZRPHI=OBSVRPHI(2,IOBSV)*COS(OBSVRPHI(3,IOBSV))

            OM=FREQ(IFREQ)/HBAREV1

            AX0=afferphi(1,ifrob)
            AY0=afferphi(2,ifrob)
            AZ0=afferphi(3,ifrob)

            AX=AX0
            AY=AY0
            AZ=AZ0

            BX0=afferphi(4,ifrob)
            BY0=afferphi(5,ifrob)
            BZ0=afferphi(6,ifrob)

            BXc=BX0
            BYc=BY0
            BZc=BZ0

            afferphi(1:6,ifrob)=(0.0D0,0.0D0)

            R0=XRPHI-CENXEXI
            R02=R0*R0
            R00=R0

c            H2=(YRPHI-vyelec)**2+(ZRPHI-vzelec)**2
c            H2R2=H2/R02
c
c            DTPHASE=(
c     &        WTRA2IS(ISOUR)+
c     &        (
c     &        H2R2+1.0D0/GAMGAM0
c     &        )*DXEXI/2.0D0)/CLIGHT1
c     &        *GAMGAM0/GAMGAM
c     &        +AMPDT

            xn1=cenxexi
            yn1=(xn1-cenxexi)*vyelec/vxelec
            zn1=(xn1-cenxexi)*vzelec/vxelec

            drn2=(
     &        (yn1+dxexi*vyelec/vxelec-yrphi)**2+
     &        (zn1+dxexi*vzelec/vxelec-zrphi)**2
     &        )/
     &        (2.0d0*(xrphi-xn1-dxexi))

            drn1=(
     &        (yn1-yrphi)**2+
     &        (zn1-zrphi)**2
     &        )/
     &        (2.0d0*(xrphi-xn1))

          DTPHASE=(
     &      WI+DXEXI*(slope**2/2.0d0+1.0d0/(2.0D0*GAMGAM0))
     &      +drn2-drn1)
     &      /CLIGHT1*GAMGAM0/GAMGAM
     &      +AMPDT

            PHI=2.D0*PI1*FREQ(IFREQ)*ECHARGE1/HPLANCK1*DTPHASE

            DMODU=EXP(ZI*PHI)
            DMODU0=DMODU
            DDMODU=ZONE

            DO I=1,-IAMPLI

              R0=xrphi+DXEXI/2.D0*(-IAMPLI-2*(I-1)-1)-CENXEXI
              CORRR0=R00/R0
            !corrects for mistake of averaging over 1/r2, if e.g.
            !the repeated device is a long undulator
     &        *(R0/(R0-ampr2corr/2.0d0))**2
              R02=R0*R0

c              H2=(YRPHI-vyelec)**2+(ZRPHI-vzelec)**2
c              H2R2=H2/R02

c              DTPHASE=(
c     &          WTRA2IS(ISOUR)+
c     &          (
c     &          H2R2+1.0D0/GAMGAM0
c     &          )*DXEXI/2.0D0)/CLIGHT1
c     &          *GAMGAM0/GAMGAM+AMPDT

              xn1=cenxexi-dxexi/2.d0*(-iampli-2*(i-1)-1)
     &          *((R0-ampr2corr/2.0d0)/R0)**2 !empirically, due to depth of field
              yn1=(xn1-cenxexi)*vyelec/vxelec
              zn1=(xn1-cenxexi)*vzelec/vxelec

              drn2=(
     &          (yn1+dxexi*vyelec/vxelec-yrphi)**2+
     &          (zn1+dxexi*vzelec/vxelec-zrphi)**2
     &          )/
     &          (2.0d0*(xrphi-xn1-dxexi))

              drn1=(
     &          (yn1-yrphi)**2+
     &          (zn1-zrphi)**2
     &          )/
     &          (2.0d0*(xrphi-xn1))

              DTPHASE=(
     &          WI+DXEXI*(slope**2/2.0d0+1.0d0/(2.0D0*GAMGAM0))
     &          +drn2-drn1)
     &          /CLIGHT1*GAMGAM0/GAMGAM
     &          +AMPDT

              PHI=2.D0*PI1*FREQ(IFREQ)*ECHARGE1/HPLANCK1*DTPHASE

              DMODU=EXP(ZI*PHI)
              DMODU0=DMODU
              DDMODU=ZONE

              afferphi(1,ifrob)=afferphi(1,ifrob)+AX
              afferphi(2,ifrob)=afferphi(2,ifrob)+AY
              afferphi(3,ifrob)=afferphi(3,ifrob)+AZ

              afferphi(4,ifrob)=afferphi(1,ifrob)+BXc
              afferphi(5,ifrob)=afferphi(2,ifrob)+BYc
              afferphi(6,ifrob)=afferphi(3,ifrob)+BZc

              IF (AMPRAN.NE.0.D0) THEN
                PHI=2.D0*PI1*XRANA(I)/FREQR*FREQ(IFREQ)
                DDMODU=EXP(ZI*PHI)
              ENDIF   !(AMPRAN.NE.0.D0)

              DMODU=DMODU0*DDMODU

              AX0=AX0*DMODU0
              AY0=AY0*DMODU0
              AZ0=AZ0*DMODU0

              AX=AX0*CORRR0
              AY=AY0*CORRR0
              AZ=AZ0*CORRR0

              AX=AX*DMODU
              AY=AY*DMODU
              AZ=AZ*DMODU

              BX0=BX0*DMODU0
              BY0=BY0*DMODU0
              BZ0=BZ0*DMODU0

              BXc=BX0*CORRR0
              BYc=BY0*CORRR0
              BZc=BZ0*CORRR0

              BXc=BXc*DMODU
              BYc=BYc*DMODU
              BZc=BZc*DMODU

              IF (IFREQ.EQ.1) THEN
                ILIOB=ISOUR+NSOURCE*(IOBSV-1)
                IF (I.EQ.1) THEN
                  POW=SPECPOWRPHI(ILIOB)
                  SPECPOWRPHI(ILIOB)=0.0D0
                ENDIF !(I.EQ.1) THEN
                R02=(OBSVRPHI(1,IOBSV)-CENXEXI)**2
     &            +OBSVRPHI(2,IOBSV)**2+OBSVRPHI(3,IOBSV)**2
                R2=(OBSVRPHI(1,IOBSV)-CENXEXI-DXEXI*(I-ABS(IAMPLI)/2+1))**2
     &            +OBSVRPHI(2,IOBSV)**2+OBSVRPHI(3,IOBSV)**2
                SPECPOWRPHI(ILIOB)=SPECPOWRPHI(ILIOB)+POW*R02/R2
     &            *R2/(sqrt(R2)-ampr2corr/2.0d0)**2/nelec
              ENDIF !IFREQ.EQ.1

              ICOUNT=ICOUNT+1
              IF (nelec.eq.1.and.ICOUNT.EQ.MCOUNT) THEN
                N10=N10+1
                CALL date_and_time(dtday,dttime,dtzone,idatetime)
                WRITE(6,*)' ',N10,ICOUNT/(NFREQ*NOBSVRPHI),' ',
     &            dttime(1:2),':',dttime(3:4),':',dttime(5:6)
                MCOUNT=MCOUNT+NCOUNT10
                IF (N10.EQ.9) MCOUNT=NCOUNT
              ENDIF

            ENDDO !IAMPLI

          ENDIF   !(IAMPLI.LT.0)

          if (ihbunch.ne.0.and.iobsv.eq.1) then
            fillb(1)=ibun
            fillb(2)=isub
            fillb(3)=ielec
            fillb(4)=bunchx
            fillb(5)=xelec
            fillb(6)=yelec
            fillb(7)=zelec
            fillb(8)=vyelec/vxelec
            fillb(9)=vzelec/vxelec
            fillb(10)=x2
            fillb(11)=y2
            fillb(12)=z2
            fillb(13)=vy2/vx2
            fillb(14)=vz2/vx2
            fillb(15)=egamma*emassg1
            fillb(16)=gamma*emassg1
            fillb(17)=xrphi
            fillb(18)=yrphi
            fillb(19)=zrphi
            fillb(20)=ifreq
            fillb(21)=freq(ifreq)
            speck=
     &        DREAL(
     &        afferphi(1,IFROB)*CONJG(afferphi(1,IFROB))
     &        +afferphi(2,IFROB)*CONJG(afferphi(2,IFROB))
     &        +afferphi(3,IFROB)*CONJG(afferphi(3,IFROB))
     &        )*specnor*bunnor
            fillb(22)=speck*nelec

            if (istokes.ne.0) then

              APOLH=
     &          afferphi(1,IFROB)*CONJG(VSTOKES(1,1))
     &          +afferphi(2,IFROB)*CONJG(VSTOKES(1,2))
     &          +afferphi(3,IFROB)*CONJG(VSTOKES(1,3))

              APOLR=
     &          afferphi(1,IFROB)*CONJG(VSTOKES(2,1))
     &          +afferphi(2,IFROB)*CONJG(VSTOKES(2,2))
     &          +afferphi(3,IFROB)*CONJG(VSTOKES(2,3))

              APOLL=
     &          afferphi(1,IFROB)*CONJG(VSTOKES(3,1))
     &          +afferphi(2,IFROB)*CONJG(VSTOKES(3,2))
     &          +afferphi(3,IFROB)*CONJG(VSTOKES(3,3))

              APOL45=
     &          afferphi(1,IFROB)*CONJG(VSTOKES(4,1))
     &          +afferphi(2,IFROB)*CONJG(VSTOKES(4,2))
     &          +afferphi(3,IFROB)*CONJG(VSTOKES(4,3))

              STOK1=
     &          APOLR*CONJG(APOLR)+
     &          APOLL*CONJG(APOLL)

              STOK2=-STOK1+
     &          2.0d0*APOLH*CONJG(APOLH)

              STOK3=
     &          2.0d0*APOL45*CONJG(APOL45)-
     &          STOK1

              STOK4=
     &          APOLR*CONJG(APOLR)-
     &          APOLL*CONJG(APOLL)

              fillb(23)=stok1*specnor*bunnor*nelec
              fillb(24)=stok2*specnor*bunnor*nelec
              fillb(25)=stok3*specnor*bunnor*nelec
              fillb(26)=stok4*specnor*bunnor*nelec

            else
              fillb(23)=fillb(22)
              fillb(24:26)=0.0d0
            endif !istokes

            fillb(27)=specpowrphi(isour)*pownor*bunnor*nelec
            fillb(28)=isour
            fillb(29)=t2

            call hfm(nidbunch,fillb)

          endif ! iobsv=1

          if (
     &        (ibunphase.eq.1.and.ielec.eq.1.and.iobunch.eq.-9999)
     &        .or.
     &        isub.eq.neinbunch
     &        ) then
            are(1:6)=dreal(afferphi(1:6,ifrob))
            aim(1:6)=dimag(afferphi(1:6,ifrob))
            ampz(ifreq)=sqrt(are(3)**2+aim(3)**2)
            if (ampz(ifreq).gt.ampzmax(ifreq)) then
              ampzmax(ifreq)=ampz(ifreq)
              kobs(ifreq)=iobsv
            endif
          endif

        ENDDO !NOBSVRPHI

        if (ibunphase.eq.1
     &    .or.isub.eq.neinbunch
     &    ) then
          ifrob=ifreq+nfreq*(kobs(ifreq)-1)
          are(1:6)=dreal(afferphi(1:6,ifrob))
          aim(1:6)=dimag(afferphi(1:6,ifrob))
          ampz(ifreq)=sqrt(are(3)**2+aim(3)**2)
          if (ampz(ifreq).ne.0.0d0) then
            azcos(ifreq)=are(3)/ampz(ifreq)
            azsin(ifreq)=aim(3)/ampz(ifreq)
          else
            azcos(ifreq)=1.0d0
            azsin(ifreq)=0.0d0
          endif
        endif

        DO IOBSV=1,NOBSVRPHI

          ifrob=ifreq+nfreq*(iobsv-1)

          if (ibunphase.eq.1) then
            are(1:6)=dreal(afferphi(1:6,ifrob))
            aim(1:6)=dimag(afferphi(1:6,ifrob))

            afferphi(1:6,ifrob)=dcmplx(
     &        azcos(ifreq)*are+azsin(ifreq)*aim,
     &        -azsin(ifreq)*are+azcos(ifreq)*aim
     &        )
          endif

          unphrphi(1:6,ifrob)=unphrphi(1:6,ifrob)+afferphi(1:6,ifrob)

          if (isub.eq.neinbunch) then

cold *** This does not work, we really need to call cyltocart for each bunch
cold            if (ibunphase.eq.0) then
cold
coldc destroy phase information between bunches by synchronization
cold
cold
ccold if ibunphase.ne.0, we have done it already
cold              are(1:3)=dreal(unphrphi(1:3,ifrob))
cold              aim(1:3)=dimag(unphrphi(1:3,ifrob))
cold
cold              unphrphi(1:3,ifrob)=dcmplx(
cold     &          azcos(ifreq)*are+azsin(ifreq)*aim,
cold     &          -azsin(ifreq)*are+azcos(ifreq)*aim
cold     &          )
cold            endif

            afreqrphi(1:6,ifrob)=afreqrphi(1:6,ifrob)
     &        +unphrphi(1:6,ifrob)
cold     &        *sqbunnor

            unphrphi(1:6,IFROB)=(0.0d0,0.0d0)

          endif !isub.eq.neinbunch

        ENDDO !NOBSVRPHI

      ENDDO !IFREQ

cold      if (ielec.ne.nelec) return
      if (isub.ne.neinbunch) return

      call cyltocart(isour)

      do iobsv=1,nobsv

        do ifreq=1,nfreq

          iliobfr=isour+nsource*(iobsv-1+nobsv*(ifreq-1))
          ifrob=ifreq+nfreq*(iobsv-1)
          iobfr=iobsv+nobsv*(ifreq-1)

          om=freq(ifreq)/hbarev1

          if(speccut.gt.0.0d0) then
            if (ispecmode.eq.1) ecmaxs=ecmax(isour)
            if(freq(ifreq).gt.speccut*ecdipev1*dmyenergy**2*ecmaxs) then
              afreq(1:6,ifrob)=(0.0d0,0.0d0)
            endif
          endif

          afreq(1:6,ifrob)=afreq(1:6,ifrob)*reflec(1)

          if (ipola.eq.0) then

            spec(iliobfr)=spec(iliobfr)+
     &        dreal(
     &        afreq(1,ifrob)*conjg(afreq(1,ifrob))
     &        +afreq(2,ifrob)*conjg(afreq(2,ifrob))
     &        +afreq(3,ifrob)*conjg(afreq(3,ifrob))
     &        )*specnor*bunnor

            reaima(1:3,1,iobfr)=reaima(1:3,1,iobfr)+
     &        dreal(afreq(1:3,ifrob))/sqnbunch

            reaima(1:3,2,iobfr)=reaima(1:3,2,iobfr)+
     &        dimag(afreq(1:3,ifrob))/sqnbunch

            reaima(6:8,1,iobfr)=reaima(6:8,1,iobfr)+
     &        dreal(afreq(4:6,ifrob))/sqnbunch

            reaima(6:8,2,iobfr)=reaima(6:8,2,iobfr)+
     &        dimag(afreq(4:6,ifrob))/sqnbunch

          else    !ipola

            apol=
     &        afreq(1,ifrob)*conjg(vpola(1))
     &        +afreq(2,ifrob)*conjg(vpola(2))
     &        +afreq(3,ifrob)*conjg(vpola(3))

            spec(iliobfr)=spec(iliobfr)+
     &        dreal(apol*conjg(apol))*specnor*bunnor

            reaima(1:3,1,iobfr)=reaima(1:3,1,iobfr)+
     &        dreal(afreq(1:3,ifrob))/sqnbunch

            reaima(1:3,2,iobfr)=reaima(1:3,2,iobfr)+
     &        dimag(afreq(1:3,ifrob))/sqnbunch

            reaima(6:8,1,iobfr)=reaima(6:8,1,iobfr)+
     &        dreal(afreq(4:6,ifrob))/sqnbunch

            reaima(6:8,2,iobfr)=reaima(6:8,2,iobfr)+
     &        dimag(afreq(4:6,ifrob))/sqnbunch

          endif   !ipola

          if (istokes.ne.0) then

            apolh=
     &        afreq(1,ifrob)*conjg(vstokes(1,1))
     &        +afreq(2,ifrob)*conjg(vstokes(1,2))
     &        +afreq(3,ifrob)*conjg(vstokes(1,3))

            apolr=
     &        afreq(1,ifrob)*conjg(vstokes(2,1))
     &        +afreq(2,ifrob)*conjg(vstokes(2,2))
     &        +afreq(3,ifrob)*conjg(vstokes(2,3))

            apoll=
     &        afreq(1,ifrob)*conjg(vstokes(3,1))
     &        +afreq(2,ifrob)*conjg(vstokes(3,2))
     &        +afreq(3,ifrob)*conjg(vstokes(3,3))

            apol45=
     &        afreq(1,ifrob)*conjg(vstokes(4,1))
     &        +afreq(2,ifrob)*conjg(vstokes(4,2))
     &        +afreq(3,ifrob)*conjg(vstokes(4,3))

            stok1=
     &        apolr*conjg(apolr)+
     &        apoll*conjg(apoll)

            stok2=-stok1+
     &        2.*apolh*conjg(apolh)

            stok3=
     &        2.*apol45*conjg(apol45)-
     &        stok1

            stok4=
     &        apolr*conjg(apolr)-
     &        apoll*conjg(apoll)

            stokes(1,iobfr)=stokes(1,iobfr)+
     &        stok1*specnor*bunnor

            stokes(2,iobfr)=stokes(2,iobfr)+
     &        stok2*specnor*bunnor

            stokes(3,iobfr)=stokes(3,iobfr)+
     &        stok3*specnor*bunnor

            stokes(4,iobfr)=stokes(4,iobfr)+
     &        stok4*specnor*bunnor

          endif   !istokes

          afreq(1:6,ifrob)=(0.0d0,0.0d0)

        enddo !ifreq

        iliob=isour+nsource*(iobsv-1)
        specpow(iliob)=specpow(iliob)*pownor

      enddo !nobsv


      if (mpinr.ne.0) then

c only used for Ntuple 5700 so far, 28.3.2012

        do iobsv=1,nobsvrphi

          do ifreq=1,nfreq

            iliobfr=isour+nsource*(iobsv-1+nobsvrphi*(ifreq-1))
            ifrob=ifreq+nfreq*(iobsv-1)
            iobfr=iobsv+nobsvrphi*(ifreq-1)

            om=freq(ifreq)/hbarev1

            if(speccut.gt.0.0d0) then
              if(freq(ifreq).gt.speccut*ecdipev1*dmyenergy**2*ecmaxs) then
                afreqrphi(1:6,ifrob)=(0.0d0,0.0d0)
              endif
            endif

            afreqrphi(1,ifrob)=afreqrphi(1,ifrob)*reflec(1)
            afreqrphi(2,ifrob)=afreqrphi(2,ifrob)*reflec(2)
            afreqrphi(3,ifrob)=afreqrphi(3,ifrob)*reflec(3)

            afreqrphi(4,ifrob)=afreqrphi(4,ifrob)*reflec(1)
            afreqrphi(5,ifrob)=afreqrphi(5,ifrob)*reflec(2)
            afreqrphi(6,ifrob)=afreqrphi(6,ifrob)*reflec(3)

            if (ipola.eq.0) then

              specrphi(iliobfr)=specrphi(iliobfr)+
     &          dreal(
     &          afreqrphi(1,ifrob)*conjg(afreqrphi(1,ifrob))
     &          +afreqrphi(2,ifrob)*conjg(afreqrphi(2,ifrob))
     &          +afreqrphi(3,ifrob)*conjg(afreqrphi(3,ifrob))
     &          )*specnor*bunnor

              reaimarphi(1:3,1,iobfr)=reaimarphi(1:3,1,iobfr)+
     &          dreal(afreqrphi(1:3,ifrob))/sqnbunch

              reaimarphi(1:3,2,iobfr)=reaimarphi(1:3,2,iobfr)+
     &          dimag(afreqrphi(1:3,ifrob))/sqnbunch

              reaimarphi(6:8,1,iobfr)=reaimarphi(6:8,1,iobfr)+
     &          dreal(afreqrphi(4:6,ifrob))/sqnbunch

              reaimarphi(6:8,2,iobfr)=reaimarphi(6:8,2,iobfr)+
     &          dimag(afreqrphi(4:6,ifrob))/sqnbunch

            else    !ipola

              apol=
     &          afreqrphi(1,ifrob)*conjg(vpola(1))
     &          +afreqrphi(2,ifrob)*conjg(vpola(2))
     &          +afreqrphi(3,ifrob)*conjg(vpola(3))

              specrphi(iliobfr)=specrphi(iliobfr)+
     &          dreal(apol*conjg(apol))*specnor*bunnor

              reaimarphi(1:3,1,iobfr)=reaimarphi(1:3,1,iobfr)+
     &          dreal(afreqrphi(1:3,ifrob))/sqnbunch

              reaimarphi(1:3,2,iobfr)=reaimarphi(1:3,2,iobfr)+
     &          dimag(afreqrphi(1:3,ifrob))/sqnbunch

              reaimarphi(6:8,1,iobfr)=reaimarphi(6:8,1,iobfr)+
     &          dreal(afreqrphi(4:6,ifrob))/sqnbunch

              reaimarphi(6:8,2,iobfr)=reaimarphi(6:8,2,iobfr)+
     &          dimag(afreqrphi(4:6,ifrob))/sqnbunch

            endif   !ipola

            afreqrphi(1:6,ifrob)=(0.0d0,0.0d0)

          enddo !ifreq

      enddo !nobsvrphi

      endif !(mpinr.ne.0) then

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '       phase advance per step at beginning and end of source for'
      WRITE(LUNGFO,*)
     &  '       lowest and highest photon energy at selected observation point:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       beginning:',SNGL(DPHSOUR(1,1)),SNGL(DPHSOUR(1,2))
      WRITE(LUNGFO,*)'       end:      ',SNGL(DPHSOUR(2,1)),SNGL(DPHSOUR(2,2))
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       ROIs (boundary, precision, points):'
      WRITE(LUNGFO,*)

      DO IROI=1,NROIA-1
        WRITE(LUNGFO,*)
     &    IROI,SNGL(ROIX(IROI)),SNGL(ROIP(IROI)),IPOIROI(IROI+1)
      ENDDO
      WRITE(LUNGFO,*)
     &  NROI,SNGL(ROIX(NROIA))

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'       SOURCE, TOTAL NUMBER OF STEPS:',ISOUR,IZAEHL
      WRITE(LUNGFO,*)'       (controlled by NLPOI and namelist $ROIN)'
      WRITE(LUNGFO,*)

      ICAL=1

      do iobsv=1,nobsvrphi
        if (iinside(iobsv).ne.0) then
          inside=1
          exit
        endif
      enddo

      deallocate(ampzmax,kobs,iinside,jinside)

      RETURN
      END
+DECK,hfreqc1.
*CMZ :  4.00/15 07/04/2022  22.40.53  by  Michael Scheer
*CMZ :  4.00/14 30/12/2021  15.41.22  by  Michael Scheer
*CMZ :  4.00/13 07/12/2021  18.47.10  by  Michael Scheer
*CMZ :  4.00/04 23/08/2019  15.47.38  by  Michael Scheer
*CMZ :  3.04/01 03/04/2018  14.26.06  by  Michael Scheer
*CMZ :  3.03/02 05/01/2016  16.07.19  by  Michael Scheer
*CMZ :  3.03/00 24/09/2015  13.19.47  by  Michael Scheer
*CMZ :  3.02/06 08/06/2015  13.32.31  by  Michael Scheer
*CMZ :  3.02/04 06/03/2015  15.42.52  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/11 20/02/2013  16.35.31  by  Michael Scheer
*CMZ :  2.68/05 28/09/2012  11.38.54  by  Michael Scheer
*CMZ :  2.68/02 31/05/2012  14.03.31  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  10.38.44  by  Michael Scheer
*CMZ :  2.66/15 09/11/2010  16.06.02  by  Michael Scheer
*CMZ :  2.66/14 09/11/2010  14.11.04  by  Michael Scheer
*CMZ :  2.66/09 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.66/07 17/12/2009  16.10.22  by  Michael Scheer
*CMZ :  2.66/04 17/12/2009  16.08.16  by  Michael Scheer
*CMZ :  2.66/03 12/11/2009  16.27.11  by  Michael Scheer
*CMZ :  2.65/01 08/10/2009  09.58.11  by  Michael Scheer
*CMZ :  2.63/05 14/09/2009  15.19.42  by  Michael Scheer
*CMZ :  2.61/03 27/03/2007  13.23.57  by  Michael Scheer
*CMZ :  2.53/03 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.53/02 25/01/2005  18.15.44  by  Michael Scheer
*CMZ :  2.52/13 09/12/2004  13.09.09  by  Michael Scheer
*CMZ :  2.52/00 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.48/04 17/03/2004  13.47.13  by  Michael Scheer
*CMZ :  2.40/02 14/03/2002  15.46.20  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  14.22.45  by  Michael Scheer
*CMZ :  2.16/07 01/09/2000  14.36.07  by  Michael Scheer
*CMZ :  2.16/04 28/06/2000  17.43.04  by  Michael Scheer
*CMZ :  2.16/01 15/06/2000  15.47.11  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  16.17.53  by  Michael Scheer
*CMZ :  2.13/04 24/01/2000  16.35.38  by  Michael Scheer
*CMZ :  2.13/03 10/01/2000  17.32.03  by  Michael Scheer
*CMZ :  2.13/00 02/12/99  13.23.58  by  Michael Scheer
*CMZ :  1.03/00 16/01/98  11.16.49  by  Michael Scheer
*CMZ :  1.00/00 24/09/97  10.31.27  by  Michael Scheer
*CMZ : 00.01/06 14/02/95  10.59.52  by  Michael Scheer
*CMZ : 00.01/05 31/01/95  17.02.40  by  Michael Scheer
*CMZ : 00.01/04 30/01/95  13.06.10  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  16.43.29  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.52.08  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.39  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE HFREQC1
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,OBSERVF90U.

C--- HISTOGRAMS FOR SPECTRA OF SINGLE OBSERVATION POINTS OR PINHOLE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,whbook.
+seq,pawcmn.

+SEQ,SPECT.
+SEQ,FREQS.
+SEq,observf90.

      INTEGER ID,IFREQ,ICEN
      INTEGER ICYCLE,MFREQ

      REAL*4 FLOW,FHIG,DF
      DOUBLE PRECISION WEIGHT

      DF=FREQ(2)-FREQ(1)
      FLOW=FREQ(1)-DF/2.
      FHIG=FREQ(NFREQ)+DF/2.

      if (ifreq2p.eq.1.or.freqlow.eq.freqhig) then
        DF=freqhig-freqlow
        FLOW=freqlow-DF/2.
        FHIG=freqlow+DF/2.
      else if (ifreq2p.eq.-1) then
        DF=freqhig-freqlow
        FLOW=freqlow
        FHIG=freqhig
      endif

      IF (IPIN.ne.0) THEN

        ICEN=ICBRILL

        ID=ICFREQ
        MFREQ=max(1,NINT((FHIG-FLOW)/DF))
        call hbook1m(ID,'SELECTED FLUX DENSITY x 1.E-6 ',
     &    MFREQ,FLOW,FHIG,VMX)
        DO IFREQ=1,NFREQ,IHFREQ
          CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.
     &      ,SPECTOT(ICEN+NOBSV*(IFREQ-1))*1.0d-6)
        ENDDO   !NFREQ
        CALL MHROUT(ID,ICYCLE,' ')
        CALL hdeletm(ID)

        IF (IFOLD.ne.0) THEN
          ID=ICFREQF
          MFREQ=max(1,NINT((FHIG-FLOW)/DF))
          call hbook1m(ID,'SELECTED FLUX DENSITY (FOLDED) x 1.E-6 ',
     &      MFREQ,FLOW,FHIG,VMX)
          DO IFREQ=1,NFREQ,IHFREQ
            CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.
     &        ,SPECTOTF(ICEN+NOBSV*(IFREQ-1))*1.0d-6)
          ENDDO   !NFREQ
          CALL MHROUT(ID,ICYCLE,' ')
          CALL hdeletm(ID)
        ENDIF   !IFOLD

        IF (ISTOKES.NE.0) THEN

          ID=ICFRS0
          call hbook1m(ID,'SELECTED S0 x 1.E-6 '
     &      ,NFREQ,FLOW,FHIG,VMX)
          DO IFREQ=1,NFREQ,IHFREQ
            CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &        dble(STOKEC(1,IFREQ)*1.0d-6))
          ENDDO   !NFREQ
          CALL MHROUT(ID,ICYCLE,' ')
          CALL hdeletm(ID)

          ID=ICFRS1
          call hbook1m(ID,'SELECTED S1 x 1.E-6 '
     &      ,NFREQ,FLOW,FHIG,VMX)
          DO IFREQ=1,NFREQ,IHFREQ
            CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &        dble(STOKEC(2,IFREQ)*1.0d-6))
          ENDDO   !NFREQ
          CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

          ID=ICFRS2
          call hbook1m(ID,'SELECTED S2 x 1.E-6 '
     &      ,NFREQ,FLOW,FHIG,VMX)
          DO IFREQ=1,NFREQ,IHFREQ
            CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &        dble(STOKEC(3,IFREQ)*1.0d-6))
          ENDDO   !NFREQ
          CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

          ID=ICFRS3
          call hbook1m(ID,'SELECTED S3 x 1.E-6 '
     &      ,NFREQ,FLOW,FHIG,VMX)
          DO IFREQ=1,NFREQ,IHFREQ
            CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &        dble(stokEC(4,IFREQ)*1.E-6))
          ENDDO   !NFREQ
          CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

          ID=ICFRP
          call hbook1m(ID,'SELECTED P'
     &      ,NFREQ,FLOW,FHIG,VMX)
          DO IFREQ=1,NFREQ,IHFREQ
            WEIGHT=0.0d0
            IF (STOKEC(1,IFREQ).NE.0.0)
     &        WEIGHT=SQRT
     &        ((STOKEC(2,IFREQ)/STOKEC(1,IFREQ))**2
     &        +(STOKEC(3,IFREQ)/STOKEC(1,IFREQ))**2
     &        +(STOKEC(4,IFREQ)/STOKEC(1,IFREQ))**2)
            CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
          ENDDO   !NFREQ
          CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

          ID=ICFRP1
          call hbook1m(ID,'SELECTED P1'
     &      ,NFREQ,FLOW,FHIG,VMX)
          DO IFREQ=1,NFREQ,IHFREQ
            WEIGHT=0.0
            IF (STOKEC(1,IFREQ).NE.0.0)
     &        WEIGHT=STOKEC(2,IFREQ)/STOKEC(1,IFREQ)
            CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
          ENDDO   !NFREQ
          CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

          ID=ICFRP2
          call hbook1m(ID,'SELECTED P2'
     &      ,NFREQ,FLOW,FHIG,VMX)
          DO IFREQ=1,NFREQ,IHFREQ
            WEIGHT=0.0
            IF (STOKEC(1,IFREQ).NE.0.0)
     &        WEIGHT=STOKEC(3,IFREQ)/STOKEC(1,IFREQ)
            CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
          ENDDO   !NFREQ
          CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

          ID=ICFRP3
          call hbook1m(ID,'SELECTED P3'
     &      ,NFREQ,FLOW,FHIG,VMX)
          DO IFREQ=1,NFREQ,IHFREQ
            WEIGHT=0.0
            IF (STOKEC(1,IFREQ).NE.0.0)
     &        WEIGHT=STOKEC(4,IFREQ)/stokec(1,IFREQ)
            CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
          ENDDO   !NFREQ
          CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

          ID=ICFRP23
          call hbook1m(ID,'SELECTED P23'
     &      ,NFREQ,FLOW,FHIG,VMX)
          DO IFREQ=1,NFREQ,IHFREQ
            WEIGHT=0.0
            IF (stokec(1,IFREQ).NE.0.0)
     &        WEIGHT=SQRT((stokec(3,IFREQ)/stokec(1,IFREQ))**2
     &        +(stokec(4,IFREQ)/stokec(1,IFREQ))**2)
            CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
          ENDDO   !NFREQ
          CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

              ID=ICFRG3
              call hbook1m(ID,'SELECTED G3 x 1.e-6'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (stokec(1,IFREQ).NE.0.0)
     &            WEIGHT=stokec(4,IFREQ)/stokec(1,IFREQ)*stokec(4,IFREQ)*1.0d-6
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

              ID=ICFRG23
              call hbook1m(ID,'SELECTED G23 x 1.e-6'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (stokec(1,IFREQ).NE.0.0)
     &            WEIGHT=(stokec(3,IFREQ)/stokec(1,IFREQ)*stokec(3,IFREQ)
     &            +stokec(4,IFREQ)/stokec(1,IFREQ)*stokec(4,IFREQ))*1.0d-6
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

              IF (IEFOLD.NE.0) THEN

                ID=ICFRS0E
                call hbook1m(ID,'SELECTED S0_E x 1.E-6 '
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO IFREQ=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &              dble(stokece(1,IFREQ)*1.e-6))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

                ID=ICFRS1E
                call hbook1m(ID,'SELECTED S1_E x 1.E-6 '
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO IFREQ=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &              dble(stokece(2,IFREQ)*1.e-6))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

                ID=ICFRS2E
                call hbook1m(ID,'SELECTED S2_E x 1.E-6 '
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO IFREQ=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &              dble(stokece(3,IFREQ)*1.e-6))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

                ID=ICFRS3E
                call hbook1m(ID,'SELECTED S3_E x 1.E-6 '
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO IFREQ=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &              dble(stokece(4,IFREQ)*1.e-6))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

                ID=ICFRPE
                call hbook1m(ID,'SELECTED P_E'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO IFREQ=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (stokece(1,IFREQ).NE.0.0)
     &              WEIGHT=SQRT
     &              ((stokece(2,IFREQ)/stokece(1,IFREQ))**2
     &              +(stokece(3,IFREQ)/stokece(1,IFREQ))**2
     &              +(stokece(4,IFREQ)/stokece(1,IFREQ))**2)
                  CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

                ID=ICFRP1E
                call hbook1m(ID,'SELECTED P1_E'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO IFREQ=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (stokece(1,IFREQ).NE.0.0)
     &              WEIGHT=stokece(2,IFREQ)/stokece(1,IFREQ)
                  CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

                ID=ICFRP2E
                call hbook1m(ID,'SELECTED P2_E'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO IFREQ=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (stokece(1,IFREQ).NE.0.0)
     &              WEIGHT=stokece(3,IFREQ)/stokece(1,IFREQ)
                  CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

                ID=ICFRP3E
                call hbook1m(ID,'SELECTED P3_E'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO IFREQ=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (stokece(1,IFREQ).NE.0.0)
     &              WEIGHT=stokece(4,IFREQ)/stokece(1,IFREQ)
                  CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

                ID=ICFRP23E
                call hbook1m(ID,'SELECTED P23_E'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO IFREQ=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (stokece(1,IFREQ).NE.0.0)
     &              WEIGHT=SQRT((stokece(3,IFREQ)/stokece(1,IFREQ))**2
     &              +(stokece(4,IFREQ)/stokece(1,IFREQ))**2)
                  CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

                ID=ICFRG3E
                call hbook1m(ID,'SELECTED G3_E x 1.E-6 '
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO IFREQ=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (stokece(1,IFREQ).NE.0.0)
     &              WEIGHT=stokece(4,IFREQ)/stokece(1,IFREQ)*stokece(4,IFREQ)
                  CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight*1.0d-6)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

                ID=ICFRG23E
                call hbook1m(ID,'SELECTED G23_E x 1.E-6 '
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO IFREQ=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (stokece(1,IFREQ).NE.0.0)
     &              WEIGHT=stokece(3,IFREQ)/stokece(1,IFREQ)*stokece(3,IFREQ)
     &              +stokece(4,IFREQ)/stokece(1,IFREQ)*stokece(4,IFREQ)
                  CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight*1.0d-6)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

              ENDIF !IEFOLD

            IF (IFOLD.NE.0) THEN

              ID=ICFRS0F
              call hbook1m(ID,'SELECTED S0 (folded) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(stokECF(1,IFREQ)*1.e-6))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

              ID=ICFRS1F
              call hbook1m(ID,'SELECTED S1 (folded) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(stokECF(2,IFREQ)*1.e-6))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

              ID=ICFRS2F
              call hbook1m(ID,'SELECTED S2 (folded) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(stokECF(3,IFREQ)*1.e-6))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

              ID=ICFRS3F
              call hbook1m(ID,'SELECTED S3 (folded) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(stokECF(4,IFREQ)*1.e-6))
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

              ID=ICFRPF
              call hbook1m(ID,'SELECTED P (folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECF(1,IFREQ).NE.0.0)
     &            WEIGHT=SQRT
     &            ((STOKECF(2,IFREQ)/STOKECF(1,IFREQ))**2
     &            +(STOKECF(3,IFREQ)/STOKECF(1,IFREQ))**2
     &            +(STOKECF(4,IFREQ)/STOKECF(1,IFREQ))**2)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

              ID=ICFRP1F
              call hbook1m(ID,'SELECTED P1 (folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECF(1,IFREQ).NE.0.0)
     &            WEIGHT=STOKECF(2,IFREQ)/STOKECF(1,IFREQ)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

              ID=ICFRP2F
              call hbook1m(ID,'SELECTED P2 (folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECF(1,IFREQ).NE.0.0)
     &            WEIGHT=STOKECF(3,IFREQ)/STOKECF(1,IFREQ)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

              ID=ICFRP3F
              call hbook1m(ID,'SELECTED P3 (folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECF(1,IFREQ).NE.0.0)
     &            WEIGHT=STOKECF(4,IFREQ)/STOKECF(1,IFREQ)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

              ID=ICFRP23F
              call hbook1m(ID,'SELECTED P23 (folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECF(1,IFREQ).NE.0.0)
     &            WEIGHT=SQRT((STOKECF(3,IFREQ)/STOKECF(1,IFREQ))**2
     &            +(STOKECF(4,IFREQ)/STOKECF(1,IFREQ))**2)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

              ID=ICFRG3F
              call hbook1m(ID,'SELECTED G3 (folded) x 1.e-6'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECF(1,IFREQ).NE.0.0)
     &            WEIGHT=STOKECF(4,IFREQ)/STOKECF(1,IFREQ)*STOKECF(4,IFREQ)*1.0d-6
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

              ID=ICFRG23F
              call hbook1m(ID,'SELECTED G23 (folded) x 1.e-6'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECF(1,IFREQ).NE.0.0)
     &            WEIGHT=(STOKECF(3,IFREQ)/STOKECF(1,IFREQ)*STOKECF(3,IFREQ)
     &            +STOKECF(4,IFREQ)/STOKECF(1,IFREQ)*STOKECF(4,IFREQ))*1.0d-6
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

              IF (IEFOLD.NE.0) THEN

                ID=ICFRS0EF
                call hbook1m(ID,'SELECTED S0_E (folded) x 1.E-6 '
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO IFREQ=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &              dble(stokECEF(1,IFREQ)*1.e-6))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

                ID=ICFRS1EF
                call hbook1m(ID,'SELECTED S1_E (folded) x 1.E-6 '
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO IFREQ=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &              dble(stokECEF(2,IFREQ)*1.e-6))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

                ID=ICFRS2EF
                call hbook1m(ID,'SELECTED S2_E (folded) x 1.E-6 '
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO IFREQ=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &              dble(stokECEF(3,IFREQ)*1.e-6))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

                ID=ICFRS3EF
                call hbook1m(ID,'SELECTED S3_E (folded) x 1.E-6 '
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO IFREQ=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &              dble(stokECEF(4,IFREQ)*1.e-6))
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

                ID=ICFRPEF
                call hbook1m(ID,'SELECTED P_E (folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO IFREQ=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (STOKECEF(1,IFREQ).NE.0.0)
     &              WEIGHT=SQRT
     &              ((STOKECEF(2,IFREQ)/STOKECEF(1,IFREQ))**2
     &              +(STOKECEF(3,IFREQ)/STOKECEF(1,IFREQ))**2
     &              +(STOKECEF(4,IFREQ)/STOKECEF(1,IFREQ))**2)
                  CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

                ID=ICFRP1EF
                call hbook1m(ID,'SELECTED P1_E (folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO IFREQ=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (STOKECEF(1,IFREQ).NE.0.0)
     &              WEIGHT=STOKECEF(2,IFREQ)/STOKECEF(1,IFREQ)
                  CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

                ID=ICFRP2EF
                call hbook1m(ID,'SELECTED P2_E (folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO IFREQ=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (STOKECEF(1,IFREQ).NE.0.0)
     &              WEIGHT=STOKECEF(3,IFREQ)/STOKECEF(1,IFREQ)
                  CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

                ID=ICFRP3EF
                call hbook1m(ID,'SELECTED P3_E (folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO IFREQ=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (STOKECEF(1,IFREQ).NE.0.0)
     &              WEIGHT=STOKECEF(4,IFREQ)/STOKECEF(1,IFREQ)
                  CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

                ID=ICFRP23EF
                call hbook1m(ID,'SELECTED P23_E (folded)'
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO IFREQ=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (STOKECEF(1,IFREQ).NE.0.0)
     &              WEIGHT=SQRT((STOKECEF(3,IFREQ)/STOKECEF(1,IFREQ))**2
     &              +(STOKECEF(4,IFREQ)/STOKECEF(1,IFREQ))**2)
                  CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

                ID=ICFRG3EF
                call hbook1m(ID,'SELECTED G3_E (folded) x 1.E-6 '
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO IFREQ=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (STOKECEF(1,IFREQ).NE.0.0)
     &              WEIGHT=STOKECEF(4,IFREQ)/STOKECEF(1,IFREQ)*STOKECEF(4,IFREQ)*1.0d-6
                  CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

                ID=ICFRG23EF
                call hbook1m(ID,'SELECTED G23_E (folded) x 1.E-6 '
     &            ,NFREQ,FLOW,FHIG,VMX)
                DO IFREQ=1,NFREQ,IHFREQ
                  WEIGHT=0.0
                  IF (STOKECEF(1,IFREQ).NE.0.0)
     &              WEIGHT=STOKECEF(3,IFREQ)/STOKECEF(1,IFREQ)*STOKECEF(3,IFREQ)
     &              +STOKECEF(4,IFREQ)/STOKECEF(1,IFREQ)*STOKECEF(4,IFREQ)
                  CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight*1.0d-6)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ENDIF !IEFOLD

            ENDIF !IFOLD

          ENDIF !ISTOKES

          IF (IBRILL.NE.0) THEN

            ID=ICFRB0
            call hbook1m(ID,'SELECTED B0 x 1.E-12'
     &        ,MFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,dble(brillC(1,IFREQ))*1.E-12)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

            ID=ICFRB1
            call hbook1m(ID,'SELECTED B1 x 1.E-12'
     &        ,MFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,dble(brillC(2,IFREQ))*1.E-12)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

            ID=ICFRB2
            call hbook1m(ID,'SELECTED B2 x 1.E-12'
     &        ,MFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,dble(brillC(3,IFREQ))*1.E-12)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

            ID=ICFRB3
            call hbook1m(ID,'SELECTED B3 x 1.E-12'
     &        ,MFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,dble(brillC(4,IFREQ))*1.E-12)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

            IF (IEFOLD.NE.0) THEN

              ID=ICFRB0E
              call hbook1m(ID,'SELECTED B0_E x 1.E-12'
     &          ,MFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,dble(brillCE(1,IFREQ))*1.E-12)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRB1E
              call hbook1m(ID,'SELECTED B1_E x 1.E-12'
     &          ,MFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,dble(brillCE(2,IFREQ))*1.E-12)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRB2E
              call hbook1m(ID,'SELECTED B2_E x 1.E-12'
     &          ,MFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,dble(brillCE(3,IFREQ))*1.E-12)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRB3E
              call hbook1m(ID,'SELECTED B3_E x 1.E-12'
     &          ,MFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,dble(brillCE(4,IFREQ))*1.E-12)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

            ENDIF !IEFOLD

            IF (IFOLD.ne.2.and.ifold.ne.0) THEN

              ID=ICFRB0F
              call hbook1m(ID,'SELECTED B0 x 1.E-12 (FOLDED)'
     &          ,MFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,dble(brillCF(1,IFREQ))*1.E-12)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

              ID=ICFRB1F
              call hbook1m(ID,'SELECTED B1 x 1.E-12 (FOLDED)'
     &          ,MFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,dble(brillCF(2,IFREQ))*1.E-12)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

              ID=ICFRB2F
              call hbook1m(ID,'SELECTED B2 x 1.E-12 (FOLDED)'
     &          ,MFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,dble(brillCF(3,IFREQ))*1.E-12)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

              ID=ICFRB3F
              call hbook1m(ID,'SELECTED B3 x 1.E-12 (FOLDED)'
     &          ,MFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,dble(brillCF(4,IFREQ))*1.E-12)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)

              IF (IEFOLD.NE.0) THEN

                ID=ICFRB0EF
                call hbook1m(ID,'SELECTED B0_E x 1.E-12 (FOLDED)'
     &            ,MFREQ,FLOW,FHIG,VMX)
                DO IFREQ=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,dble(brillCEF(1,IFREQ))*1.E-12)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                ID=ICFRB1EF
                call hbook1m(ID,'SELECTED B1_E x 1.E-12 (FOLDED)'
     &            ,MFREQ,FLOW,FHIG,VMX)
                DO IFREQ=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,dble(brillCEF(2,IFREQ))*1.E-12)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                ID=ICFRB2EF
                call hbook1m(ID,'SELECTED B2_E x 1.E-12 (FOLDED)'
     &            ,MFREQ,FLOW,FHIG,VMX)
                DO IFREQ=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,dble(brillCEF(3,IFREQ))*1.E-12)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

                ID=ICFRB3EF
                call hbook1m(ID,'SELECTED B3_E x 1.E-12 (FOLDED)'
     &            ,MFREQ,FLOW,FHIG,VMX)
                DO IFREQ=1,NFREQ,IHFREQ
                  CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,dble(brillCEF(4,IFREQ))*1.E-12)
                ENDDO   !NFREQ
                CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ENDIF !IEFOLD
            ENDIF !IFOLD.NE.2

          ENDIF !IBRILL

        ELSE    !IPIN

          ICEN=ICBRILL

          ID=ICFREQ
          MFREQ=max(1,NINT((FHIG-FLOW)/DF))
          call hbook1m(ID,'SELECTED FLUX DENSITY x 1.E-6 ',
     &      MFREQ,FLOW,FHIG,VMX)
          DO IFREQ=1,NFREQ,IHFREQ
            CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.
     &        ,specTOT(ICEN+NOBSV*(IFREQ-1))*1.0d-6)
          ENDDO   !NFREQ
          CALL MHROUT(ID,ICYCLE,' ')
          CALL hdeletm(ID)

          IF (IFOLD.NE.0) THEN
            ID=ICFREQF
            MFREQ=max(1,NINT((FHIG-FLOW)/DF))
            call hbook1m(ID,'SELECTED FLUX DENSITY  x 1.E-6 (FOLDED)',
     &        MFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.
     &          ,specTOTF(ICEN+NOBSV*(IFREQ-1))*1.0d-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
            call hdeletm(ID)
          ENDIF   !IFOLD

        ENDIF    !IPIN

      RETURN
      END
+DECK,hfreqc2.
*CMZ :  4.00/14 30/12/2021  15.41.22  by  Michael Scheer
*CMZ :  4.00/13 07/12/2021  18.47.10  by  Michael Scheer
*CMZ :  4.00/04 23/08/2019  15.47.38  by  Michael Scheer
*CMZ :  3.02/04 06/03/2015  15.42.52  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.69/00 24/10/2012  15.53.13  by  Michael Scheer
*CMZ :  2.68/05 28/09/2012  11.48.48  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  10.38.44  by  Michael Scheer
*CMZ :  2.66/03 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.65/01 08/10/2009  09.58.11  by  Michael Scheer
*CMZ :  2.63/05 14/09/2009  15.19.42  by  Michael Scheer
*CMZ :  2.61/03 27/03/2007  13.23.57  by  Michael Scheer
*CMZ :  2.53/03 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.53/02 25/01/2005  18.15.44  by  Michael Scheer
*CMZ :  2.52/13 09/12/2004  13.09.09  by  Michael Scheer
*CMZ :  2.52/00 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.48/04 17/03/2004  13.47.13  by  Michael Scheer
*CMZ :  2.40/02 14/03/2002  15.46.20  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  14.22.45  by  Michael Scheer
*CMZ :  2.16/07 01/09/2000  14.36.07  by  Michael Scheer
*CMZ :  2.16/04 28/06/2000  17.43.04  by  Michael Scheer
*CMZ :  2.16/01 15/06/2000  15.47.11  by  Michael Scheer
*CMZ :  2.13/09 09/03/2000  16.17.53  by  Michael Scheer
*CMZ :  2.13/04 24/01/2000  16.35.38  by  Michael Scheer
*CMZ :  2.13/03 10/01/2000  17.32.03  by  Michael Scheer
*CMZ :  2.13/00 02/12/99  13.23.58  by  Michael Scheer
*CMZ :  1.03/00 16/01/98  11.16.49  by  Michael Scheer
*CMZ :  1.00/00 24/09/97  10.31.27  by  Michael Scheer
*CMZ : 00.01/06 14/02/95  10.59.52  by  Michael Scheer
*CMZ : 00.01/05 31/01/95  17.02.40  by  Michael Scheer
*CMZ : 00.01/04 30/01/95  13.06.10  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  16.43.29  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.52.08  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.39  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE HFREQC2
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,OBSERVF90U.

C--- HISTOGRAMS FOR SPECTRA OF SINGLE OBSERVATION POINTS OR PINHOLE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,whbook.
+seq,pawcmn.

+SEQ,SPECT.
+SEQ,FREQS.
+SEq,observf90.

      INTEGER ID,IFREQ,ICEN
      INTEGER ICYCLE,MFREQ

      REAL*4 FLOW,FHIG,DF
      DOUBLE PRECISION WEIGHT


        DF=FREQ(2)-FREQ(1)
        FLOW=FREQ(1)-DF/2.
        FHIG=FREQ(NFREQ)+DF/2.

        IF (FLOW.LT.0.) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** WARNING SR HFREQC2 ***'
          WRITE(LUNGFO,*)'LOW EDGE OF HISTOGRAM NEGATIV'
          WRITE(LUNGFO,*)'BE CAREFUL IF X-AXIS IS PLOTTED WITH LOGARITHMIC SCALE'
          WRITE(LUNGFO,*)
        ENDIF

        IF(IPIN.EQ.0) THEN

          ICEN=ICBRILL

          ID=ICFREQ
          call hbook1m(ID,'SELECTED FLUX DENSITY x 1.E-6 ',NFREQ,FLOW,FHIG,VMX)

          DO IFREQ=1,NFREQ,IHFREQ
            CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.
     &        ,SPECTOT(ICEN+NOBSV*(IFREQ-1))*1.0d-6)
          ENDDO   !NFREQ
          CALL MHROUT(ID,ICYCLE,' ')
           call hdeletm(ID)

        IF (IFOLD.EQ.2) THEN

            ID=ICFREQF
            call hbook1m(ID,
     &'SELECTED FLUX DENSITY x 1.E-6 (FOLDED)',NFREQ,FLOW,FHIG,VMX)

            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.
     &          ,SPECTOTF(ICEN+NOBSV*(IFREQ-1))*1.0d-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
            CALL hdeletm(ID)

        ENDIF !IFOLD.EQ.2

          IF (ISTOKES.NE.0) THEN

            ID=ICFRS0
            call hbook1m(ID,'SELECTED S0 x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(stokEC(1,IFREQ))*1.E-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
            CALL hdeletm(ID)

            ID=ICFRS1
            call hbook1m(ID,'SELECTED S1 x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(stokEC(2,IFREQ))*1.E-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
            CALL hdeletm(ID)

            ID=ICFRS2
            call hbook1m(ID,'SELECTED S2 x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(stokEC(3,ifreq))*1.E-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
            CALL hdeletm(ID)

            ID=ICFRS3
            call hbook1m(ID,'SELECTED S3 x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(stokEC(4,ifreq))*1.E-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
            CALL hdeletm(ID)

            ID=ICFRP
            call hbook1m(ID,'SELECTED P'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKEC(1,IFREQ).NE.0.0)
     &          WEIGHT=SQRT
     &          ((STOKEC(2,IFREQ)/STOKEC(1,IFREQ))**2
     &          +(STOKEC(3,IFREQ)/STOKEC(1,IFREQ))**2
     &          +(STOKEC(4,IFREQ)/STOKEC(1,IFREQ))**2)
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
            CALL hdeletm(ID)

            ID=ICFRP1
            call hbook1m(ID,'SELECTED P1'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKEC(1,IFREQ).NE.0.0)
     &          WEIGHT=STOKEC(2,IFREQ)/STOKEC(1,IFREQ)
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
            CALL hdeletm(ID)

            ID=ICFRP2
            call hbook1m(ID,'SELECTED P2'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKEC(1,IFREQ).NE.0.0)
     &          WEIGHT=STOKEC(3,IFREQ)/STOKEC(1,IFREQ)
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
            CALL hdeletm(ID)

            ID=ICFRP3
            call hbook1m(ID,'SELECTED P3'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKEC(1,IFREQ).NE.0.0)
     &          WEIGHT=STOKEC(4,IFREQ)/STOKEC(1,IFREQ)
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
            CALL hdeletm(ID)

            ID=ICFRP23
            call hbook1m(ID,'SELECTED P23'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKEC(1,IFREQ).NE.0.0)
     &          WEIGHT=SQRT((STOKEC(3,IFREQ)/STOKEC(1,IFREQ))**2
     &          +(STOKEC(4,IFREQ)/STOKEC(1,IFREQ))**2)
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
            CALL hdeletm(ID)

            ID=ICFRG3
            call hbook1m(ID,'SELECTED G3 x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKEC(1,IFREQ).NE.0.0)
     &          WEIGHT=STOKEC(4,IFREQ)/STOKEC(1,IFREQ)*STOKEC(4,IFREQ)
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight*1.0d-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
            CALL hdeletm(ID)

            ID=ICFRG23
            call hbook1m(ID,'SELECTED G23 x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKEC(1,IFREQ).NE.0.0)
     &          WEIGHT=STOKEC(3,IFREQ)/STOKEC(1,IFREQ)*STOKEC(3,IFREQ)
     &          +STOKEC(4,IFREQ)/STOKEC(1,IFREQ)*STOKEC(4,IFREQ)
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight*1.0d-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
            CALL hdeletm(ID)

            IF (IEFOLD.NE.0) THEN

              ID=ICFRS0E
              call hbook1m(ID,'SELECTED S0_E x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(stokECE(1,IFREQ))*1.E-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

              ID=ICFRS1E
              call hbook1m(ID,'SELECTED S1_E x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(stokECE(2,IFREq))*1.0d-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

              ID=ICFRS2E
              call hbook1m(ID,'SELECTED S2_E x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(stokECE(3,IFREq))*1.0d-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

              ID=ICFRS3E
              call hbook1m(ID,'SELECTED S3_E x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(stokECE(4,IFREq))*1.0d-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

              ID=ICFRPE
              call hbook1m(ID,'SELECTED P_E'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECE(1,IFREQ).NE.0.0)
     &            WEIGHT=SQRT
     &            ((STOKECE(2,IFREQ)/STOKECE(1,IFREQ))**2
     &            +(STOKECE(3,IFREQ)/STOKECE(1,IFREQ))**2
     &            +(STOKECE(4,IFREQ)/STOKECE(1,IFREQ))**2)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

              ID=ICFRP1E
              call hbook1m(ID,'SELECTED P1_E'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECE(1,IFREQ).NE.0.0)
     &            WEIGHT=STOKECE(2,IFREQ)/STOKECE(1,IFREQ)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

              ID=ICFRP2E
              call hbook1m(ID,'SELECTED P2_E'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECE(1,IFREQ).NE.0.0)
     &            WEIGHT=STOKECE(3,IFREQ)/STOKECE(1,IFREQ)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

              ID=ICFRP3E
              call hbook1m(ID,'SELECTED P3_E'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECE(1,IFREQ).NE.0.0)
     &            WEIGHT=STOKECE(4,IFREQ)/STOKECE(1,IFREQ)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

              ID=ICFRP23E
              call hbook1m(ID,'SELECTED P23_E'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECE(1,IFREQ).NE.0.0)
     &            WEIGHT=SQRT((STOKECE(3,IFREQ)/STOKECE(1,IFREQ))**2
     &            +(STOKECE(4,IFREQ)/STOKECE(1,IFREQ))**2)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

              ID=ICFRG3E
              call hbook1m(ID,'SELECTED G3_E x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECE(1,IFREQ).NE.0.0)
     &            WEIGHT=STOKECE(4,IFREQ)/STOKECE(1,IFREQ)*STOKECE(4,IFREQ)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight*1.0d-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

              ID=ICFRG23E
              call hbook1m(ID,'SELECTED G23_E x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECE(1,IFREQ).NE.0.0)
     &            WEIGHT=STOKECE(3,IFREQ)/STOKECE(1,IFREQ)*STOKECE(3,IFREQ)
     &            +STOKECE(4,IFREQ)/STOKECE(1,IFREQ)*STOKECE(4,IFREQ)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight*1.0d-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
              CALL hdeletm(ID)

            ENDIF !IEFOLD

          IF (IFOLD.EQ.2) THEN

            ID=ICFRS0F
            call hbook1m(ID,'SELECTED S0 x 1.E-6 (FOLDED)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(stokECF(1,IFREq))*1.0d-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
            CALL hdeletm(ID)

            ID=ICFRS1F
            call hbook1m(ID,'SELECTED S1 x 1.E-6 (FOLDED)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(stokECF(2,IFREq))*1.0d-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
            CALL hdeletm(ID)

            ID=ICFRS2F
            call hbook1m(ID,'SELECTED S2 x 1.E-6 (FOLDED)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(stokECF(3,IFREq))*1.0d-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
            CALL hdeletm(ID)

            ID=ICFRS3F
            call hbook1m(ID,'SELECTED S3 x 1.E-6 (FOLDED)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(stokECF(4,IFREq))*1.0d-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
            CALL hdeletm(ID)

            ID=ICFRPF
            call hbook1m(ID,'SELECTED P (FOLDED)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKECF(1,IFREQ).NE.0.0)
     &          WEIGHT=SQRT
     &          ((STOKECF(2,IFREQ)/STOKECF(1,IFREQ))**2
     &          +(STOKECF(3,IFREQ)/STOKECF(1,IFREQ))**2
     &          +(STOKECF(4,IFREQ)/STOKECF(1,IFREQ))**2)
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
            CALL hdeletm(ID)

            ID=ICFRP1F
            call hbook1m(ID,'SELECTED P1 (FOLDED)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKECF(1,IFREQ).NE.0.0)
     &          WEIGHT=STOKECF(2,IFREQ)/STOKECF(1,IFREQ)
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
            CALL hdeletm(ID)

            ID=ICFRP2F
            call hbook1m(ID,'SELECTED P2 (FOLDED)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKECF(1,IFREQ).NE.0.0)
     &          WEIGHT=STOKECF(3,IFREQ)/STOKECF(1,IFREQ)
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
            CALL hdeletm(ID)

            ID=ICFRP3F
            call hbook1m(ID,'SELECTED P3 (FOLDED)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKECF(1,IFREQ).NE.0.0)
     &          WEIGHT=STOKECF(4,IFREQ)/STOKECF(1,IFREQ)
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP23F
            call hbook1m(ID,'SELECTED P23 (FOLDED)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKECF(1,IFREQ).NE.0.0)
     &          WEIGHT=SQRT((STOKECF(3,IFREQ)/STOKECF(1,IFREQ))**2
     &          +(STOKECF(4,IFREQ)/STOKECF(1,IFREQ))**2)
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRG3F
            call hbook1m(ID,'SELECTED G3 x 1.E-6 (FOLDED)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKECF(1,IFREQ).NE.0.0)
     &          WEIGHT=STOKECF(4,IFREQ)/STOKECF(1,IFREQ)*STOKECF(4,IFREQ)
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight*1.0d-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRG23F
            call hbook1m(ID,'SELECTED G23 x 1.E-6 (FOLDED)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKECF(1,IFREQ).NE.0.0)
     &          WEIGHT=STOKECF(3,IFREQ)/STOKECF(1,IFREQ)*STOKECF(3,IFREQ)
     &          +STOKECF(4,IFREQ)/STOKECF(1,IFREQ)*STOKECF(4,IFREQ)
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight*1.0d-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            IF (IEFOLD.NE.0) THEN

              ID=ICFRS0EF
              call hbook1m(ID,'SELECTED S0_E x 1.E-6 (FOLDED)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(stokECEF(1,IFREq))*1.0d-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRS1EF
              call hbook1m(ID,'SELECTED S1_E x 1.E-6 (FOLDED)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(stokECEF(2,IFREq))*1.0d-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRS2EF
              call hbook1m(ID,'SELECTED S2_E x 1.E-6 (FOLDED)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(stokECEF(3,IFREq))*1.0d-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRS3EF
              call hbook1m(ID,'SELECTED S3_E x 1.E-6 (FOLDED)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(stokECEF(4,IFREq))*1.0d-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRPEF
              call hbook1m(ID,'SELECTED P_E (FOLDED)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECEF(1,IFREQ).NE.0.0)
     &            WEIGHT=SQRT
     &            ((STOKECEF(2,IFREQ)/STOKECEF(1,IFREQ))**2
     &            +(STOKECEF(3,IFREQ)/STOKECEF(1,IFREQ))**2
     &            +(STOKECEF(4,IFREQ)/STOKECEF(1,IFREQ))**2)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP1EF
              call hbook1m(ID,'SELECTED P1_E (FOLDED)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECEF(1,IFREQ).NE.0.0)
     &            WEIGHT=STOKECEF(2,IFREQ)/STOKECEF(1,IFREQ)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP2EF
              call hbook1m(ID,'SELECTED P2_E (FOLDED)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECEF(1,IFREQ).NE.0.0)
     &            WEIGHT=STOKECEF(3,IFREQ)/STOKECEF(1,IFREQ)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP3EF
              call hbook1m(ID,'SELECTED P3_E (FOLDED)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECEF(1,IFREQ).NE.0.0)
     &            WEIGHT=STOKECEF(4,IFREQ)/STOKECEF(1,IFREQ)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP23EF
              call hbook1m(ID,'SELECTED P23_E (FOLDED)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECEF(1,IFREQ).NE.0.0)
     &            WEIGHT=SQRT((STOKECEF(3,IFREQ)/STOKECEF(1,IFREQ))**2
     &            +(STOKECEF(4,IFREQ)/STOKECEF(1,IFREQ))**2)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRG3EF
              call hbook1m(ID,'SELECTED G3_E x 1.E-6 (FOLDED)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECEF(1,IFREQ).NE.0.0)
     &            WEIGHT=STOKECEF(4,IFREQ)/STOKECEF(1,IFREQ)*STOKECEF(4,IFREQ)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight*1.0d-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRG23EF
              call hbook1m(ID,'SELECTED G23_E x 1.E-6 (FOLDED)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECEF(1,IFREQ).NE.0.0)
     &            WEIGHT=STOKECEF(3,IFREQ)/STOKECEF(1,IFREQ)*STOKECEF(3,IFREQ)
     &            +STOKECEF(4,IFREQ)/STOKECEF(1,IFREQ)*STOKECEF(4,IFREQ)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight*1.0d-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

            ENDIF !IEFOLD
            ENDIF !IEFOLD.EQ.2

          ENDIF !ISTOKES

          IF (IBRILL.NE.0) THEN

            ID=ICFRB0
            call hbook1m(ID,'SELECTED B0 x 1.E-12'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(brillC(1,IFREQ))*1.0e-12)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRB1
            call hbook1m(ID,'SELECTED B1 x 1.E-12'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(brillC(2,IFREQ))*1.0e-12)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRB2
            call hbook1m(ID,'SELECTED B2 x 1.E-12'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(brillC(3,IFREQ))*1.0e-12)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRB3
            call hbook1m(ID,'SELECTED B3 x 1.E-12'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(brillC(4,IFREQ))*1.0e-12)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            IF (IEFOLD.NE.0) THEN

              ID=ICFRB0E
              call hbook1m(ID,'SELECTED B0_E x 1.E-12'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(brillCE(1,IFREQ))*1.0e-12)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRB1E
              call hbook1m(ID,'SELECTED B1_E x 1.E-12'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(brillCE(2,IFREQ))*1.0e-12)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRB2E
              call hbook1m(ID,'SELECTED B2_E x 1.E-12'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(brillCE(3,IFREQ))*1.0e-12)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRB3E
              call hbook1m(ID,'SELECTED B3_E x 1.E-12'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(brillCE(4,IFREQ))*1.0e-12)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

            ENDIF !IEFOLD

          IF (IFOLD.EQ.2) THEN

            ID=ICFRB0F
            call hbook1m(ID,'SELECTED B0 x 1.E-12 (FOLDED)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(brillCF(1,IFREQ))*1.0e-12)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRB1F
            call hbook1m(ID,'SELECTED B1 x 1.E-12 (FOLDED)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(brillCF(2,IFREQ))*1.0e-12)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRB2F
            call hbook1m(ID,'SELECTED B2 x 1.E-12 (FOLDED)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(brillCF(3,IFREQ))*1.0e-12)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRB3F
            call hbook1m(ID,'SELECTED B3 x 1.E-12 (FOLDED)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(brillCF(4,IFREQ))*1.0e-12)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            IF (IEFOLD.NE.0) THEN

              ID=ICFRB0EF
              call hbook1m(ID,'SELECTED B0_E x 1.E-12 (FOLDED)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(brillCEF(1,IFREQ))*1.0e-12)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRB1EF
              call hbook1m(ID,'SELECTED B1_E x 1.E-12 (FOLDED)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(brillCEF(2,IFREQ))*1.0e-12)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRB2EF
              call hbook1m(ID,'SELECTED B2_E x 1.E-12 (FOLDED)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(brillCEF(3,IFREQ))*1.0e-12)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRB3EF
              call hbook1m(ID,'SELECTED B3_E x 1.E-12 (FOLDED)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(brillCEF(4,IFREQ))*1.0e-12)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

            ENDIF !IEFOLD
          ENDIF !IFOLD.NE.2

          ENDIF !IBRILL

        ELSE  !IPIN

          ICEN=ICBRILL

          ID=ICFREQ
          call hbook1m(ID,'SELECTED FLUX DENSITY x 1.E-6 ',NFREQ,FLOW,FHIG,VMX)

          DO IFREQ=1,NFREQ,IHFREQ
            CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.
     &        ,SPECTOT(ICEN+NOBSV*(IFREQ-1))*1.d-6)
          ENDDO   !NFREQ
          CALL MHROUT(ID,ICYCLE,' ')
           call hdeletm(ID)

          IF (IFOLD.NE.0) THEN
            ID=ICFREQF
            MFREQ=NINT((FHIG-FLOW)/DF)
            call hbook1m(ID,'SELECTED FLUX DENSITY  x 1.E-6 (FOLDED)',
     &        MFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.
     &          ,SPECTOTF(ICEN+NOBSV*(IFREQ-1))*1.0d-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)
          ENDIF   !IFOLD

          IF (ISTOKES.NE.0) THEN

            ID=ICFRS0
            call hbook1m(ID,'SELECTED S0 x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(stokEC(1,IFREQ))*1.E-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRS1
            call hbook1m(ID,'SELECTED S1 x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(stokEC(2,IFREQ))*1.E-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRS2
            call hbook1m(ID,'SELECTED S2 x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(stokEC(3,IFREQ))*1.E-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRS3
            call hbook1m(ID,'SELECTED S3 x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(stokEC(4,IFREQ))*1.E-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP
            call hbook1m(ID,'SELECTED P'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKEC(1,IFREQ).NE.0.0)
     &          WEIGHT=SQRT
     &          ((STOKEC(2,IFREQ)/STOKEC(1,IFREQ))**2
     &          +(STOKEC(3,IFREQ)/STOKEC(1,IFREQ))**2
     &          +(STOKEC(4,IFREQ)/STOKEC(1,IFREQ))**2)
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP1
            call hbook1m(ID,'SELECTED P1'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKEC(1,IFREQ).NE.0.0)
     &          WEIGHT=STOKEC(2,IFREQ)/STOKEC(1,IFREQ)
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP2
            call hbook1m(ID,'SELECTED P2'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKEC(1,IFREQ).NE.0.0)
     &          WEIGHT=STOKEC(3,IFREQ)/STOKEC(1,IFREQ)
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP3
            call hbook1m(ID,'SELECTED P3'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKEC(1,IFREQ).NE.0.0)
     &          WEIGHT=STOKEC(4,IFREQ)/STOKEC(1,IFREQ)
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP23
            call hbook1m(ID,'SELECTED P23'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKEC(1,IFREQ).NE.0.0)
     &          WEIGHT=SQRT((STOKEC(3,IFREQ)/STOKEC(1,IFREQ))**2
     &          +(STOKEC(4,IFREQ)/STOKEC(1,IFREQ))**2)
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRG3
            call hbook1m(ID,'SELECTED G3 x 1.E-6 '
     &                    ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKEC(1,IFREQ).NE.0.0)
     &          WEIGHT=STOKEC(4,IFREQ)/STOKEC(1,IFREQ)*STOKEC(4,IFREQ)
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight*1.0d-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRG23
            call hbook1m(ID,'SELECTED G23 x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKEC(1,IFREQ).NE.0.0)
     &          WEIGHT=(STOKEC(3,IFREQ)/STOKEC(1,IFREQ)*STOKEC(3,IFREQ)
     &          +STOKEC(4,IFREQ)/STOKEC(1,IFREQ)*STOKEC(4,IFREQ))
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight*1.0d-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            IF (IEFOLD.NE.0) THEN

              ID=ICFRS0E
              call hbook1m(ID,'SELECTED S0_E x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(stokECE(1,IFREQ))*1.E-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRS1E
              call hbook1m(ID,'SELECTED S1_E x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(stokECE(2,IFREQ))*1.E-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRS2E
              call hbook1m(ID,'SELECTED S2_E x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(stokECE(3,IFREQ))*1.E-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRS3E
              call hbook1m(ID,'SELECTED S3_E x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(stokECE(4,IFREQ))*1.E-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRPE
              call hbook1m(ID,'SELECTED P_E'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECE(1,IFREQ).NE.0.0)
     &            WEIGHT=SQRT
     &            ((STOKECE(2,IFREQ)/STOKECE(1,IFREQ))**2
     &            +(STOKECE(3,IFREQ)/STOKECE(1,IFREQ))**2
     &            +(STOKECE(4,IFREQ)/STOKECE(1,IFREQ))**2)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP1E
              call hbook1m(ID,'SELECTED P1_E'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECE(1,IFREQ).NE.0.0)
     &            WEIGHT=STOKECE(2,IFREQ)/STOKECE(1,IFREQ)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP2E
              call hbook1m(ID,'SELECTED P2_E'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECE(1,IFREQ).NE.0.0)
     &            WEIGHT=STOKECE(3,IFREQ)/STOKECE(1,IFREQ)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP3E
              call hbook1m(ID,'SELECTED P3_E'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECE(1,IFREQ).NE.0.0)
     &            WEIGHT=STOKECE(4,IFREQ)/STOKECE(1,IFREQ)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP23E
              call hbook1m(ID,'SELECTED P23_E'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECE(1,IFREQ).NE.0.0)
     &            WEIGHT=SQRT((STOKECE(3,IFREQ)/STOKECE(1,IFREQ))**2
     &            +(STOKECE(4,IFREQ)/STOKECE(1,IFREQ))**2)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRG3E
              call hbook1m(ID,'SELECTED G3_E x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECE(1,IFREQ).NE.0.0)
     &            WEIGHT=STOKECE(4,IFREQ)/STOKECE(1,IFREQ)*STOKECE(4,IFREQ)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight*1.0d-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRG23E
              call hbook1m(ID,'SELECTED G23_E x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECE(1,IFREQ).NE.0.0)
     &            WEIGHT=(STOKECE(3,IFREQ)/STOKECE(1,IFREQ)*STOKECE(3,IFREQ)
     &            +STOKECE(4,IFREQ)/STOKECE(1,IFREQ)*STOKECE(4,IFREQ))
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight*1.0d-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

            ENDIF !IEFOLD

          ENDIF !ISTOKES

          IF (IBRILL.NE.0) THEN

            ID=ICFRB0
            call hbook1m(ID,'SELECTED B0 x 1.E-12'
     &        ,NFREQ,FLOW,FHIG,VMX)
          DO IFREQ=1,NFREQ,IHFREQ
            CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &        dble(brillC(1,IFREQ))*1.0e-12)
          ENDDO   !NFREQ
          CALL MHROUT(ID,ICYCLE,' ')
           call hdeletm(ID)

          ID=ICFRB1
          call hbook1m(ID,'SELECTED B1 x 1.E-12'
     &      ,NFREQ,FLOW,FHIG,VMX)
          DO IFREQ=1,NFREQ,IHFREQ
            CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &        dble(brillC(2,IFREQ))*1.0e-12)
          ENDDO   !NFREQ
          CALL MHROUT(ID,ICYCLE,' ')
           call hdeletm(ID)

          ID=ICFRB2
          call hbook1m(ID,'SELECTED B2 x 1.E-12'
     &      ,NFREQ,FLOW,FHIG,VMX)
          DO IFREQ=1,NFREQ,IHFREQ
            CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &        dble(brillC(3,IFREQ))*1.0e-12)
          ENDDO   !NFREQ
          CALL MHROUT(ID,ICYCLE,' ')
           call hdeletm(ID)

          ID=ICFRB3
          call hbook1m(ID,'SELECTED B3 x 1.E-12'
     &      ,NFREQ,FLOW,FHIG,VMX)
          DO IFREQ=1,NFREQ,IHFREQ
            CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &        dble(brillC(4,IFREQ))*1.0e-12)
          ENDDO   !NFREQ
          CALL MHROUT(ID,ICYCLE,' ')
           call hdeletm(ID)

          IF (IEFOLD.NE.0) THEN

            ID=ICFRB0E
            call hbook1m(ID,'SELECTED B0_E x 1.E-12'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(brillCE(1,IFREQ))*1.0e-12)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRB1E
            call hbook1m(ID,'SELECTED B1_E x 1.E-12'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(brillCE(2,IFREQ))*1.0e-12)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRB2E
            call hbook1m(ID,'SELECTED B2_E x 1.E-12'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(brillCE(3,IFREQ))*1.0e-12)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRB3E
            call hbook1m(ID,'SELECTED B3_E x 1.E-12'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(brillCE(4,IFREQ))*1.0e-12)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

          ENDIF !IEFOLD

        ENDIF !IBRILL

        IF (IFOLD.NE.0) THEN

          IF (ISTOKES.NE.0) THEN

            ID=ICFRS0F
            call hbook1m(ID,'SELECTED S0 (folded) x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(stokECF(1,IFREQ))*1.E-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRS1F
            call hbook1m(ID,'SELECTED S1 (folded) x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(stokECF(2,IFREQ))*1.E-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRS2F
            call hbook1m(ID,'SELECTED S2 (folded) x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(stokECF(3,IFREQ))*1.E-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRS3F
            call hbook1m(ID,'SELECTED S3 (folded) x 1.E-6 '
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(stokECF(4,IFREQ))*1.E-6)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRPF
            call hbook1m(ID,'SELECTED P (folded)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKECF(1,IFREQ).NE.0.0)
     &          WEIGHT=SQRT
     &          ((STOKECF(2,IFREQ)/STOKECF(1,IFREQ))**2
     &          +(STOKECF(3,IFREQ)/STOKECF(1,IFREQ))**2
     &          +(STOKECF(4,IFREQ)/STOKECF(1,IFREQ))**2)
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP1F
            call hbook1m(ID,'SELECTED P1 (folded)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKECF(1,IFREQ).NE.0.0)
     &          WEIGHT=STOKECF(2,IFREQ)/STOKECF(1,IFREQ)
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP2F
            call hbook1m(ID,'SELECTED P2 (folded)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKECF(1,IFREQ).NE.0.0)
     &          WEIGHT=STOKECF(3,IFREQ)/STOKECF(1,IFREQ)
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP3F
            call hbook1m(ID,'SELECTED P3 (folded)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKECF(1,IFREQ).NE.0.0)
     &          WEIGHT=STOKECF(4,IFREQ)/STOKECF(1,IFREQ)
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRP23F
            call hbook1m(ID,'SELECTED P23 (folded)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKECF(1,IFREQ).NE.0.0)
     &          WEIGHT=SQRT((STOKECF(3,IFREQ)/STOKECF(1,IFREQ))**2
     &          +(STOKECF(4,IFREQ)/STOKECF(1,IFREQ))**2)
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRG3F
            call hbook1m(ID,'SELECTED G3 (folded)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKECF(1,IFREQ).NE.0.0)
     &          WEIGHT=STOKECF(4,IFREQ)/STOKECF(1,IFREQ)*STOKECF(4,IFREQ)
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRG23F
            call hbook1m(ID,'SELECTED G23 (folded)'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              WEIGHT=0.0
              IF (STOKECF(1,IFREQ).NE.0.0)
     &          WEIGHT=(STOKECF(3,IFREQ)/STOKECF(1,IFREQ)*STOKECF(3,IFREQ)
     &          +STOKECF(4,IFREQ)/STOKECF(1,IFREQ)*STOKECF(4,IFREQ))
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            IF (IEFOLD.NE.0) THEN

              ID=ICFRS0EF
              call hbook1m(ID,'SELECTED S0_E (folded) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(stokECEF(1,IFREQ))*1.E-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRS1EF
              call hbook1m(ID,'SELECTED S1_E (folded) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(stokECEF(2,IFREQ))*1.E-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRS2EF
              call hbook1m(ID,'SELECTED S2_E (folded) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(stokECEF(3,IFREQ))*1.E-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRS3EF
              call hbook1m(ID,'SELECTED S3_E (folded) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(stokECEF(4,IFREQ))*1.E-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRPEF
              call hbook1m(ID,'SELECTED P_E (folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECEF(1,IFREQ).NE.0.0)
     &            WEIGHT=SQRT
     &            ((STOKECEF(2,IFREQ)/STOKECEF(1,IFREQ))**2
     &            +(STOKECEF(3,IFREQ)/STOKECEF(1,IFREQ))**2
     &            +(STOKECEF(4,IFREQ)/STOKECEF(1,IFREQ))**2)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP1EF
              call hbook1m(ID,'SELECTED P1_E (folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECEF(1,IFREQ).NE.0.0)
     &            WEIGHT=STOKECEF(2,IFREQ)/STOKECEF(1,IFREQ)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP2EF
              call hbook1m(ID,'SELECTED P2_E (folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECEF(1,IFREQ).NE.0.0)
     &            WEIGHT=STOKECEF(3,IFREQ)/STOKECEF(1,IFREQ)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP3EF
              call hbook1m(ID,'SELECTED P3_E (folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECEF(1,IFREQ).NE.0.0)
     &            WEIGHT=STOKECEF(4,IFREQ)/STOKECEF(1,IFREQ)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRP23EF
              call hbook1m(ID,'SELECTED P23_E (folded)'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECEF(1,IFREQ).NE.0.0)
     &            WEIGHT=SQRT((STOKECEF(3,IFREQ)/STOKECEF(1,IFREQ))**2
     &            +(STOKECEF(4,IFREQ)/STOKECEF(1,IFREQ))**2)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRG3EF
              call hbook1m(ID,'SELECTED G3_E (folded) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECEF(1,IFREQ).NE.0.0)
     &            WEIGHT=STOKECEF(4,IFREQ)/STOKECEF(1,IFREQ)*STOKECEF(4,IFREQ)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight*1.0d-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRG23EF
              call hbook1m(ID,'SELECTED G23_E (folded) x 1.E-6 '
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                WEIGHT=0.0
                IF (STOKECEF(1,IFREQ).NE.0.0)
     &            WEIGHT=STOKECEF(3,IFREQ)/STOKECEF(1,IFREQ)*STOKECEF(3,IFREQ)
     &            +STOKECEF(4,IFREQ)/STOKECEF(1,IFREQ)*STOKECEF(4,IFREQ)
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,weight*1.0d-6)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

            ENDIF !IEFOLD

          ENDIF !ISTOKES

          IF (IBRILL.NE.0) THEN

            ID=ICFRB0F
            call hbook1m(ID,'SELECTED B0 (folded) x 1.E-12'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(brillCF(1,IFREQ))*1.0e-12)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRB1F
            call hbook1m(ID,'SELECTED B1 (folded) x 1.E-12'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(brillCF(2,IFREQ))*1.0e-12)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRB2F
            call hbook1m(ID,'SELECTED B2 (folded) x 1.E-12'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(brillCF(3,IFREQ))*1.0e-12)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            ID=ICFRB3F
            call hbook1m(ID,'SELECTED B3 (folded) x 1.E-12'
     &        ,NFREQ,FLOW,FHIG,VMX)
            DO IFREQ=1,NFREQ,IHFREQ
              CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &          dble(brillCF(4,IFREQ))*1.0e-12)
            ENDDO   !NFREQ
            CALL MHROUT(ID,ICYCLE,' ')
             call hdeletm(ID)

            IF (IEFOLD.NE.0) THEN

              ID=ICFRB0EF
              call hbook1m(ID,'SELECTED B0_E (folded) x 1.E-12'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(brillCEF(1,IFREQ))*1.0e-12)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRB1EF
              call hbook1m(ID,'SELECTED B1_E (folded) x 1.E-12'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(brillCEF(2,IFREQ))*1.0e-12)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRB2EF
              call hbook1m(ID,'SELECTED B2 (folded) x 1.E-12'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(brillCEF(3,IFREQ))*1.0e-12)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

              ID=ICFRB3EF
              call hbook1m(ID,'SELECTED B3 (folded) x 1.E-12'
     &          ,NFREQ,FLOW,FHIG,VMX)
              DO IFREQ=1,NFREQ,IHFREQ
                CALL hfillm(ID,SNGL(FREQ(IFREQ)),0.,
     &            dble(brillCEF(4,IFREQ))*1.0e-12)
              ENDDO   !NFREQ
              CALL MHROUT(ID,ICYCLE,' ')
               call hdeletm(ID)

            ENDIF !IEFOLD

          ENDIF !IBRILL

        ENDIF !IFOLD

      ENDIF !IPIN

      RETURN
      END
+DECK,util_wait_3.
*CMZ :  4.00/04 17/05/2019  11.51.09  by  Michael Scheer
*CMZ : 00.00/02 06/10/2009  11.51.11  by  Michael Scheer
*-- Author :    Michael Scheer   23/01/2004
      subroutine util_wait_3
+seq,gplhint.
      call sleep(3)
      return
      end
+DECK,util_wait_1.
*CMZ :  4.00/04 17/05/2019  11.51.09  by  Michael Scheer
*CMZ :  2.66/00 06/10/2009  11.50.59  by  Michael Scheer
*CMZ : 00.00/02 06/01/2006  13.58.17  by  Michael Scheer
*-- Author :    Michael Scheer   23/01/2004
      subroutine util_wait_1
+seq,gplhint.
      call sleep(1)

      return
      end
+DECK,aphase.
*CMZ :  4.01/04 15/11/2023  12.38.14  by  Michael Scheer
*CMZ :  3.02/03 03/11/2014  12.10.03  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.66/03 12/05/2010  13.34.28  by  Michael Scheer
*-- Author :    Michael Scheer   27/10/2009
      subroutine aphase(isour)
+seq,gplhint.

c calculates phase of field amplitudes afreq and afreqrphi

+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,AFREQF90U.
+SEQ,SPECTF90U.
+SEQ,WFOLDF90U.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEq,observf90.
+SEQ,DEPOLA.
+SEq,wfoldf90.
+seq,sourcef90.
+SEQ,FREQS.
+SEQ,PHYCON.
+SEQ,SPECTF90.

      double precision cenxexi,dphase,phiy,phiz,phiy1,phiz1
     &  ,ddist,h2,dist0,dist02,dphi

      integer iphi,ir,isour,ifreq,iobrp,idphi2pi

      cenxexi=(min(sourceeo(1,1,isour),xiend)
     &  +max(sourceao(1,1,isour),xianf))/2.d0

      if (ipin.ne.0) then
        dist0=pincen(1)-cenxexi
      else
        dist0=obs1x-cenxexi
      endif

      dist02=dist0**2

      do ifreq=1,nfreq

        if (mpinr.ne.0) then

          iobrp=0

          do iphi=1,nobsvphi

            phiy1=0.0d0
            phiz1=0.0d0

            do ir=1,nobsvr

              iobrp=iobrp+1
              iobfr=iobrp+nobsvrphi*(ifreq-1)

              h2=(obsvr(ir)/dist0)**2
              if (h2.lt.0.01) then
                ddist=dist0*(h2/2.0d0-h2**2/8.0d0)
              else
                ddist=dist0*(sqrt(1.0d0+h2)-1.0d0)
              endif

              dphase=ddist/freq(ifreq)*wtoe1*1.0d9*twopi1
              dphase=0.0d0

c              phiy=atan2(reaimarphi(2,2,iobfr),reaimarphi(2,1,iobfr))
c              phiz=atan2(reaimarphi(3,2,iobfr),reaimarphi(3,1,iobfr))
              if (reaimarphi(2,1,iobfr).ne.0.0d0) then
                phiy=atan(reaimarphi(2,2,iobfr)/reaimarphi(2,1,iobfr))
              else
                phiy=sign(halfpi1,reaimarphi(2,2,iobfr))
              endif

              if (reaimarphi(3,1,iobfr).ne.0.0d0) then
                phiz=atan(reaimarphi(3,2,iobfr)/reaimarphi(3,1,iobfr))
              else
                phiz=sign(halfpi1,reaimarphi(3,2,iobfr))
              endif

              reaimarphi(4,1,iobfr)=
     &          sqrt(reaimarphi(2,1,iobfr)**2+reaimarphi(2,2,iobfr)**2)
              reaimarphi(4,2,iobfr)=phiy

              reaimarphi(5,1,iobfr)=
     &          sqrt(reaimarphi(3,1,iobfr)**2+reaimarphi(3,2,iobfr)**2)
              reaimarphi(5,2,iobfr)=phiz

              phiz1=phiz

            enddo !nobsvr

          enddo !iphi

        endif !(mpinr.ne.0) then

      enddo !nfreq

      return
      end
+DECK,ampfold.
*CMZ :  4.01/05 19/04/2024  10.29.48  by  Michael Scheer
*CMZ :  4.01/04 14/11/2023  13.37.28  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.66/03 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.51/02 08/10/2009  09.58.11  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  14.22.46  by  Michael Scheer
*CMZ :  2.13/10 14/04/2000  14.26.49  by  Michael Scheer
*CMZ :  2.13/04 21/01/2000  14.54.46  by  Michael Scheer
*CMZ :  2.13/03 11/01/2000  18.22.28  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.56.38  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.16  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE ampfold
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,AFREQF90U.

C--- CALCULATES FOLDING OF FIELD AMPLITUDES WITH ELECTRON PHASE SPACE
C    DISTRIBUTIONS (GAUSSIAN DISTRIBUTION)

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEq,observf90.
+SEQ,FREQS.
+seq,sourcef90.
+SEQ,SPECT.

      INTEGER IFREQ,IZ,IY,IOBSV,ICOMP,ireim,ieb,i1,i2

C--- CALCULATE FOURIER-COEFFICIENTS OF GAUSSIAN

c      CALL WGFOUR ! already done in WFOLD

      IF (nsource.gt.1) then
        write(6,*)' '
        write(6,*)' *** Warning in AMPFOLD: More than one source.'
        write(6,*)' Sigmas for folding procedure are taken for source',nsource/2+1
        write(6,*)' '
        write(lungfo,*)' '
        write(lungfo,*)' *** Warning in AMPFOLD: More than one source.'
        write(lungfo,*)' Sigmas for folding procedure are taken for source',nsource/2+1
        write(lungfo,*)' '
      endif

      IF (IFOLD.EQ.-2) then
        write(6,*)' '
        write(6,*)' *** Warning in AMPFOLD: Modus IFOLD.EQ.-2 not available.'
        write(6,*)' '
        write(lungfo,*)' '
        write(lungfo,*)' *** Warning in AMPFOLD: Modus IFOLD.EQ.-2 not available.'
        write(lungfo,*)' '
      endif

c14.11,2023      DO icomp=2,3
      do ieb=1,2

        if (ieb.eq.1) then
          i1=1
          i2=3
        else
          i1=6
          i2=8
        endif

        DO icomp=i1,i2
          DO ireim=1,2
            DO IFREQ=1,NFREQ
C--- PERFORM FOLDING
              CALL AFOLINT(icomp,ireim,IFREQ)
            ENDDO !IFREQ
          ENDDO !ireim
        ENDDO !icomp

      enddo !ieb=1,2

      do ieb=1,2

        if (ieb.eq.1) then
          i1=1
          i2=3
        else
          i1=6
          i2=8
        endif

        DO icomp=i1,i2
          DO ireim=1,2

            DO IFREQ=1,NFREQ

c DELETE INTENSITY IN EDGES

              DO IY=1,NOBSVY
                DO IZ=1,NOBSVZ

                  IOBSV=NOBSVZ*(IY-1)+IZ
                  IOBFR=IOBSV+NOBSV*(IFREQ-1)

                  IF (IPINCIRC.EQ.0) THEN

                    IF (
     &                  IY.LT.(NOBSVY-MOBSVY)/2+1
     &                  .OR.IY.GT.(NOBSVY-MOBSVY)/2+MOBSVY
     &                  .OR.IZ.LT.(NOBSVZ-MOBSVZ)/2+1
     &                  .OR.IZ.GT.(NOBSVZ-MOBSVZ)/2+MOBSVZ
     &                  ) THEN
                      reaima(icomp+2,ireim,iobfr)=0.0d0
                    ENDIF

                  ELSE  !IPINCIRC

                    IF (
     &                  (OBSVZ(IZ)-PINCEN(3))**2
     &                  +(OBSVY(IY)-PINCEN(2))**2
     &                  -PINR**2
     &                  .GT.1.D-10
     &                  ) THEN
                      reaima(icomp+2,ireim,iobfr)=0.0d0
                    ENDIF

                  ENDIF !IPINCIRC

                ENDDO !IZ
              ENDDO !IY

            ENDDO !IFREQ

          ENDDO !ireim
        ENDDO !icomp

      enddo !ieb=1,2

      RETURN
      END
+DECK,afolint.
*CMZ :  4.01/07 30/09/2024  14.57.39  by  Michael Scheer
*CMZ :  4.01/05 19/04/2024  12.22.35  by  Michael Scheer
*CMZ :  4.01/04 14/11/2023  13.46.13  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.66/03 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.51/02 08/10/2009  09.58.11  by  Michael Scheer
*CMZ :  2.34/09 24/09/2001  16.48.01  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  16.27.20  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.33  by  Michael Scheer
*CMZ :  2.15/00 08/05/2000  13.33.58  by  Michael Scheer
*CMZ :  2.14/02 27/04/2000  17.54.22  by  Michael Scheer
*CMZ :  2.13/10 14/04/2000  17.10.49  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.24.36  by  Michael Scheer
*CMZ :  2.13/03 20/12/99  17.39.24  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  14.43.03  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  11.21.35  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  18.07.26  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.22  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE AFOLINT(icomp,ireim,IFREQ)
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,AFREQF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,WFOLDF90U.

C--- FOLD FIELD AMPLITUDE DENSITY IN PINHOLE

C    IFOLD.EQ.-2: not available
C    IFOLD.EQ.-1: SR UTIL_FOLD_FOURIER IS USED
C    IFOLD.EQ.1: SR UTIL_FOLD_FUNCTION_GAUSS IS USED

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEq,wfoldf90.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.

      INTEGER IZA,IZE,IYA,IYE,IFREQ,IY,IZ,IMASH
     &       ,NF,NFOLD,IFAIL,IGZY,icomp,ireim,isour

      DOUBLE PRECISION ZKZ0,YKY0,GZ(NGCOEFP*LIDIMP),GY(NGCOEFP*LIDIMP),rea(nobsv*nfreq)

c14.11.2023      if (icomp.eq.1) return

      isour=nsource/2+1

      IF (IFOLD.EQ.1) THEN

        IYA=1+(NOBSVY-MOBSVY)/2
        IYE=NOBSVY-(NOBSVY-MOBSVY)/2

        IF (NOBSVZ.GT.1) THEN

          IZA=1+(NOBSVZ-MOBSVZ)/2
          IZE=NOBSVZ-(NOBSVZ-MOBSVZ)/2

          NF=NOBSV*(IFREQ-1)

          DO IY=1,NOBSVY

            DO IZ=1,NOBSVZ
              IMASH=IZ+(IY-1)*NOBSVZ
              IOBFR=imash+NOBSV*(IFREQ-1)
              wobs1(iz)=reaima(icomp,ireim,iobfr)
            ENDDO !IZ

            CALL UTIL_FOLD_FUNCTION_GAUSS(
     &        NOBSVZ,OBSVZ,WOBS1,WSIGZ(ISOUR),DGSIGZ(ISOUR),WOBS2,
     &        WOBS3,WOBS4,WOBS5,WOBS6,WOBS7)

            DO IZ=IZA,IZE
              IMASH=IZ+(IY-1)*NOBSVZ
              IOBFR=imash+NOBSV*(IFREQ-1)
              rea(iobfr)=wobs2(iz)
c              if (icomp.eq.2.or.icomp.eq.3) then
c                reaima(icomp+2,ireim,iobfr)=WOBS2(IZ)
c              else if (icomp.eq.1) then
c                reaima(11,ireim,iobfr)=WOBS2(IZ)
c              else if (icomp.gt.5) then
c                reaima(icomp+6,ireim,iobfr)=WOBS2(IZ)
c              endif
            ENDDO

          ENDDO   !IY

        ELSE !(NOBSVZ.GT.1)

          NF=NOBSV*(IFREQ-1)

          DO IY=1,NOBSVY
            IMASH=1+(IY-1)*NOBSVZ
            IOBFR=imash+NOBSV*(IFREQ-1)
              rea(iobfr)=reaima(icomp,ireim,iobfr)
c            if (icomp.eq.2.or.icomp.eq.3) then
c              reaima(icomp+2,ireim,iobfr)=reaima(icomp,ireim,iobfr)
c            else if (icomp.eq.1) then
c              reaima(11,ireim,iobfr)=reaima(icomp,ireim,iobfr)
c            else if (icomp.gt.5) then
c              reaima(icomp+6,ireim,iobfr)=reaima(icomp,ireim,iobfr)
c            endif
          ENDDO

        ENDIF !(NOBSVZ.GT.1)

        DO IZ=1,NOBSVZ

          DO IY=1,NOBSVY
            IMASH=IZ+(IY-1)*NOBSVZ
            IOBFR=imash+NOBSV*(IFREQ-1)
c            wobs1(iy)=reaima(icomp,ireim,iobfr)
            wobs1(iy)=rea(iobfr)
          ENDDO   !IY

            CALL UTIL_FOLD_FUNCTION_GAUSS(
     &        NOBSVY,OBSVY,WOBS1,WSIGY(ISOUR),DGSIGY(ISOUR),WOBS2,
     &        WOBS3,WOBS4,WOBS5,WOBS6,WOBS7)

          DO IY=IYA,IYE
            IMASH=IZ+(IY-1)*NOBSVZ
            IOBFR=imash+NOBSV*(IFREQ-1)
            if (icomp.eq.2.or.icomp.eq.3) then
              reaima(icomp+2,ireim,iobfr)=WOBS2(IY)
            else if (icomp.eq.1) then
              reaima(11,ireim,iobfr)=WOBS2(IY)
            else if (icomp.gt.5) then
              reaima(icomp+6,ireim,iobfr)=WOBS2(IY)
            endif
          ENDDO

        ENDDO  !IZ

      ELSE IF(IFOLD.EQ.-1) THEN

        IYA=1+(NOBSVY-MOBSVY)/2
        IYE=NOBSVY-(NOBSVY-MOBSVY)/2

        IF (NOBSVZ.GT.1) THEN

          IZA=1+(NOBSVZ-MOBSVZ)/2
          IZE=NOBSVZ-(NOBSVZ-MOBSVZ)/2

          ZKZ0=XKGAUSS(1,ISOUR)
          NFOLD=NINT(DSIGZ(ISOUR)/OBSVDZ)

          NF=NOBSV*(IFREQ-1)
          IGZY=1+NGCOEFP*(ISOUR-1)

          DO IY=1,NOBSVY

            DO IZ=1,NOBSVZ
              IMASH=IZ+(IY-1)*NOBSVZ
              IOBFR=imash+NOBSV*(IFREQ-1)
              wobs1(iz)=reaima(icomp,ireim,iobfr)
            ENDDO !IZ

            CALL UTIL_FOLD_FOURIER(OBSVZ,WOBS1,NOBSVZ,NFOLD
     &        ,GZ(IGZY),NGFOURZ,WOBS2,WOBS3,WOBS4,WOBS5,WOBS6,WOBS7,IFAIL)

            IF (IFAIL.NE.0) WRITE(LUNGFO,*)
     &        '*** WARNING IN AFOLINT: FAILURE IN UTIL_FOLD_FOURIER ***'

            DO IZ=IZA,IZE
              IMASH=IZ+(IY-1)*NOBSVZ
              IOBFR=imash+NOBSV*(IFREQ-1)
              rea(iobfr)=WOBS2(IZ)
c              if (icomp.eq.2.or.icomp.eq.3) then
c                reaima(icomp+2,ireim,iobfr)=WOBS2(IZ)
c              else if (icomp.eq.1) then
c                reaima(11,ireim,iobfr)=WOBS2(IZ)
c              else if (icomp.gt.5) then
c                reaima(icomp+6,ireim,iobfr)=WOBS2(IZ)
c              endif
            ENDDO

          ENDDO   !IY

        ELSE !(NOBSVZ.GT.1)

          NF=NOBSV*(IFREQ-1)
          IGZY=1+NGCOEFP*(ISOUR-1)
          DO IY=1,NOBSVY
            IMASH=1+(IY-1)*NOBSVZ
            IOBFR=imash+NOBSV*(IFREQ-1)
            if (icomp.eq.2.or.icomp.eq.3) then
              reaima(icomp+2,ireim,iobfr)=reaima(icomp,ireim,iobfr)
            else if (icomp.eq.1) then
              reaima(11,ireim,iobfr)=reaima(icomp,ireim,iobfr)
            else if (icomp.gt.5) then
              reaima(icomp+6,ireim,iobfr)=reaima(icomp,ireim,iobfr)
            endif
          ENDDO

        ENDIF !(NOBSVZ.GT.1)

        YKY0=YKGAUSS(1,ISOUR)
        NFOLD=NINT(DSIGY(ISOUR)/OBSVDY)

        DO IZ=1,NOBSVZ

          DO IY=1,NOBSVY
            IMASH=IZ+(IY-1)*NOBSVZ
            IOBFR=imash+NOBSV*(IFREQ-1)
c            wobs1(iy)=reaima(icomp,ireim,iobfr)
            wobs1(iy)=rea(iobfr)
          ENDDO   !IY

          CALL UTIL_FOLD_FOURIER(OBSVY,WOBS1,NOBSVY,NFOLD
     &      ,GY(IGZY),NGFOURY,WOBS2,WOBS3,WOBS4,WOBS5,WOBS6,WOBS7,IFAIL)

          IF (IFAIL.NE.0) WRITE(LUNGFO,*)
     &      '*** WARNING IN AFOLINT: FAILURE IN UTIL_FOLD_FOURIER ***'

          DO IY=IYA,IYE
            IMASH=IZ+(IY-1)*NOBSVZ
            IOBFR=imash+NOBSV*(IFREQ-1)
            if (icomp.eq.2.or.icomp.eq.3) then
              reaima(icomp+2,ireim,iobfr)=WOBS2(IY)
            else if (icomp.eq.1) then
              reaima(11,ireim,iobfr)=WOBS2(IY)
            else if (icomp.gt.5) then
              reaima(icomp+6,ireim,iobfr)=WOBS2(IY)
            endif
          ENDDO

        ENDDO  !IZ

      ENDIF !IFOLD

      RETURN
      END
+DECK,util_skip_comment_end.
*CMZ :  3.05/15 06/10/2018  11.25.38  by  Michael Scheer
*CMZ :  3.05/04 28/06/2018  15.52.47  by  Michael Scheer
*CMZ : 00.00/16 19/03/2014  12.14.18  by  Michael Scheer
*CMZ : 00.00/15 03/09/2012  09.26.58  by  Michael Scheer
*CMZ : 00.00/07 05/03/2008  15.43.44  by  Michael Scheer
*CMZ : 00.00/02 14/08/2006  13.22.55  by  Michael Scheer
*-- Author :    Michael Scheer   23/01/2004
      subroutine util_skip_comment_end(lun,ieof)

      implicit none

      integer lun,ieof
c      character com
      character(32) c2

      ieof=0

1     read(lun,'(a)',end=99) c2

      if (
     &    c2(1:1).ne.'!'.and.c2(1:1).ne.'*'.and.c2(1:1).ne.'#'
     &    .and.c2(1:1).ne.'%'.and.c2(1:1).ne.'@'.and.
     &    c2.ne.' !'.and.c2.ne.' *'.and.c2.ne.' #'
     &    .and.c2.ne.' %'.and.c2.ne.' @'.and.len_trim(c2).ne.0
     &    ) then
        backspace(lun)
      else
        goto 1
      endif

      return

99    ieof=1

      return
      end
+DECK,util_min_parabel.
*CMZ :  2.66/09 22/03/2010  15.00.25  by  Michael Scheer
*CMZ :  2.66/07 10/12/2009  10.40.02  by  Michael Scheer
*CMZ : 00.00/01 20/06/95  10.09.17  by  Michael Scheer
*-- Author :    Michael Scheer   26/01/95
      SUBROUTINE util_min_parabel(NDIM,X,F,XMN,FMN,WSX,WSF,JFAIL)
+seq,gplhint.

C--- TO FIND MINIMUM OF ARRAY FUNCTION F(X)

C     INPUT : F(NDIM)   ARRAY OF FUNCTION
C             X(NDIM)   ARRAY OF ARGUMENTS
C             WSX(NDIM) WORKINGSPACE
C             WSF(NDIM) WORKINGSPACE

C     OUTPUT:  XMN ARGUMENT WHERE FUNCTION REACHES EXTREMUM
C              FMN MINIMUM OF FUNCTION
C              JFAIL FLAG: =0, IF OK, =1 ELSE

      IMPLICIT NONE

      INTEGER NDIM,I,IFAIL,JFAIL

      REAL*8 X(NDIM),F(NDIM),XMN,FMN,WSX(NDIM),WSF(NDIM)
      REAL*8 XDUM(3),FDUM(3),A(3),FP(3),FMIN,XMIN

      FMIN=1.0D30
      DO I=1,NDIM
          WSX(I)=X(I)
          WSF(I)=F(I)
          IF (WSF(I).LT.FMIN) THEN
              FMIN=WSF(I)
              XMIN=WSX(I)
          ENDIF
      ENDDO

      CALL UTIL_SORT_FUNC(NDIM,WSF,WSX)

      DO I=1,3
         XDUM(I)=WSX(I)
         FDUM(I)=WSF(I)
      ENDDO

      CALL UTIL_PARABEL(XDUM,FDUM,A,FP,XMN,FMN,IFAIL)

      IF (IFAIL.NE.0.OR.FMN.LT.FMIN) THEN
          JFAIL=1
c          WRITE(6,*)
c          WRITE(6,*)'*** WARNING IN UTIL_MIN_PARABEL: SEARCH FAILED ***'
c          WRITE(6,*)'*** MINIMUM OF ARRAY TAKEN ***'
c          WRITE(6,*)
          FMN=FMIN
          XMN=XMIN
          RETURN
      ENDIF

      JFAIL=0

      RETURN
      END
+DECK,tralinshort.
*CMZ :  3.03/04 11/10/2017  11.28.21  by  Michael Scheer
*CMZ :  2.66/07 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.63/05 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  2.61/01 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.61/00 30/01/2007  18.56.07  by  Michael Scheer
*CMZ :  2.59/02 24/01/2007  14.57.52  by  Michael Scheer
*CMZ :  2.59/01 24/01/2007  14.30.15  by  Michael Scheer
*CMZ :  2.58/00 16/01/2007  16.51.31  by  Michael Scheer
*CMZ :  2.48/04 12/03/2004  15.40.31  by  Michael Scheer
*CMZ :  2.47/14 01/08/2003  13.37.51  by  Michael Scheer
*CMZ :  2.47/12 01/07/2003  14.03.43  by  Michael Scheer
*CMZ :  2.37/02 14/11/2001  12.53.09  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  15.28.35  by  Michael Scheer
*CMZ :  2.34/05 23/08/2001  17.35.09  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ : 00.01/12 10/10/96  15.17.26  by  Michael Scheer
*CMZ : 00.01/10 04/06/96  10.40.08  by  Michael Scheer
*-- Author :    Michael Scheer   01/06/96
      subroutine tralinshort(
     &  xi0,yi0,zi0,ypi0,zpi0,xe0,gamma,tfmh,tfmv,tfmdeh,tfmdev)
+seq,gplhint.

C SIMPLE ESTIMATE OF LINEAR TRANSFER MATRIX, light version of tralin

      IMPLICIT NONE

+SEQ,CONTRL.
+SEQ,TRALIN.
+SEQ,DEPOLA.
+SEQ,PHASETRACK.
+SEQ,PHYCON.

        double precision xe0,ydum,zdum,gamma,
     &    tfmh(2,2),tfmv(2,2),
     &    tfmdeh(2,2),tfmdev(2,2)

        DOUBLE PRECISION DTIM,BSHIFT,BETA,V0
      DOUBLE PRECISION XI,YI,ZI,XF,YF,ZF,YPF,ZPF
      DOUBLE PRECISION XI0,YI0,ZI0,YPI0,ZPI0
      DOUBLE PRECISION VXI,VYI,VZI,VXF,VYF,VZF,XF0,YF0,ZF0,ZPF0,YPF0
      DOUBLE PRECISION VXF0,VYF0,VZF0
        DOUBLE PRECISION WXI0,WYI0,WZI0
      DOUBLE PRECISION EWS(3),EWY(3),EWZ(3),EWSF(3),EWYF(3),EWZF(3)
        DOUBLE PRECISION DX,DY,DZ,DYP,DZP,WX,WY,WZ
     &    ,GAMMAL
     &    ,tfmo(4,4),gammao

      DATA BSHIFT/0.5D0/

        tfmo=tfm !if tralin has calculated tfm already
        gammao=gamma

        IF (IENELOSS.NE.0) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)
     &      ' *** WARNING IN TRALINSHORT: IENELOSS .NE. 0, NOT YET IMPLEMENTED ***'
          WRITE(LUNGFO,*)
     &      ' *** BE CAREFUL!! ***'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)
     &      ' *** WARNING IN TRALINSHORT: IENELOSS .NE. 0, NOT YET IMPLEMENTED ***'
          WRITE(6,*)
     &      ' *** BE CAREFUL!! ***'
          WRITE(6,*)
        ENDIF

        IF (DELTAZ.EQ.0.D0) DELTAZ=0.00001
        IF (DELTAY.EQ.0.D0) DELTAY=0.00001
        IF (DELTAZP.EQ.0.D0) DELTAZP=0.00001
        IF (DELTAYP.EQ.0.D0) DELTAYP=0.00001
        IF (DELTAE.EQ.0.D0) DELTAE=0.01

1     continue

      BETA=DSQRT((1.D0-1.D0/gamma)*(1.D0+1.D0/gamma))
        V0=CLIGHT1*BETA
        DTIM=1.D0/(v0*myinum)

        WXI0=V0/sqrt(1.0d0+(zpi0**2+ypi0**2))
        WYI0=wxi0*ypi0
        WZI0=wxi0*zpi0

C--- CLOSED ORBIT

        EWS(1)=wXI0/v0
        EWS(2)=wYI0/v0
        EWS(3)=wZI0/v0

C EWS = [EWS,(0,1,0)]

      EWZ(1)=-EWS(3)
      EWZ(2)=0.D0
      EWZ(3)=+EWS(1)

C EWY = [EWZ,EWS]

      EWY(1)=EWZ(2)*EWS(3)-EWZ(3)*EWS(2)
      EWY(2)=EWZ(3)*EWS(1)-EWZ(1)*EWS(3)
      EWY(3)=EWZ(1)*EWS(2)-EWZ(2)*EWS(1)

        CALL track(XI0,YI0,ZI0,WXI0,WYI0,WZI0
     &    ,xe0,ydum,zdum,1.0d0,0.0d0,0.0d0
     &    ,XF0,YF0,ZF0,VXF0,VYF0,VZF0,DTIM,BSHIFT,gamma,GAMMAL)

      ZPF0=VZF0/VXF0
      YPF0=VYF0/VXF0

      EWSF(1)=VXF0/V0
      EWSF(2)=VYF0/V0
      EWSF(3)=VZF0/V0

C EWSF = [EWSF,(0,1,0)]

      EWZF(1)=-EWSF(3)
      EWZF(2)=0.D0
      EWZF(3)=+EWSF(1)

C EWYF = [EWZF,EWSF]

      EWYF(1)=EWZF(2)*EWSF(3)-EWZF(3)*EWSF(2)
      EWYF(2)=EWZF(3)*EWSF(1)-EWZF(1)*EWSF(3)
      EWYF(3)=EWZF(1)*EWSF(2)-EWZF(2)*EWSF(1)

C--T(1:4,1):

      DZ=DELTAZ
      DY=0.0D0
      DZP=0.D0
      DYP=0.D0

      XI=XI0+DY*EWY(1)+DZ*EWZ(1)
      YI=YI0+DY*EWY(2)+DZ*EWZ(2)
      ZI=ZI0+DY*EWY(3)+DZ*EWZ(3)

      WX=V0/SQRT(1.D0+DZP**2+DYP**2)
      WY=DYP*WX
      WZ=DZP*WX

      VXI=WX*EWS(1)+WY*EWY(1)+WZ*EWZ(1)
      VYI=WX*EWS(2)+WY*EWY(2)+WZ*EWZ(2)
      VZI=WX*EWS(3)+WY*EWY(3)+WZ*EWZ(3)

      CALL TRACK(XI,YI,ZI,VXI,VYI,VZI
     &            ,XF0,YF0,ZF0,VXF0/V0,VYF0/V0,VZF0/V0
     &            ,XF,YF,ZF,VXF,VYF,VZF,DTIM,BSHIFT,gamma,GAMMAL)

      DX=XF-XF0
      DY=YF-YF0
      DZ=ZF-ZF0

      XF=DX*EWSF(1)+DY*EWSF(2)+DZ*EWSF(3)
      YF=DX*EWYF(1)+DY*EWYF(2)+DZ*EWYF(3)
      ZF=DX*EWZF(1)+DY*EWZF(2)+DZ*EWZF(3)

      WX=VXF*EWSF(1)+VYF*EWSF(2)+VZF*EWSF(3)
      WY=VXF*EWYF(1)+VYF*EWYF(2)+VZF*EWYF(3)
      WZ=VXF*EWZF(1)+VYF*EWZF(2)+VZF*EWZF(3)

      ZPF=WZ/WX
      YPF=WY/WX

      TFM(1,1)=ZF/DELTAZ
      TFM(2,1)=ZPF/DELTAZ
      TFM(3,1)=YF/DELTAZ
      TFM(4,1)=YPF/DELTAZ

C--T(1:4,2):

      DZ=0.D0
      DY=0.0D0
      DZP=DELTAZP
      DYP=0.D0

      XI=XI0+DY*EWY(1)+DZ*EWZ(1)
      YI=YI0+DY*EWY(2)+DZ*EWZ(2)
      ZI=ZI0+DY*EWY(3)+DZ*EWZ(3)

      WX=V0/SQRT(1.D0+DZP**2+DYP**2)
      WY=DYP*WX
      WZ=DZP*WX

      VXI=WX*EWS(1)+WY*EWY(1)+WZ*EWZ(1)
      VYI=WX*EWS(2)+WY*EWY(2)+WZ*EWZ(2)
      VZI=WX*EWS(3)+WY*EWY(3)+WZ*EWZ(3)

      CALL TRACK(XI,YI,ZI,VXI,VYI,VZI
     &            ,XF0,YF0,ZF0,VXF0/V0,VYF0/V0,VZF0/V0
     &            ,XF,YF,ZF,VXF,VYF,VZF,DTIM,BSHIFT,gamma,GAMMAL)


      DX=XF-XF0
      DY=YF-YF0
      DZ=ZF-ZF0

      XF=DX*EWSF(1)+DY*EWSF(2)+DZ*EWSF(3)
      YF=DX*EWYF(1)+DY*EWYF(2)+DZ*EWYF(3)
      ZF=DX*EWZF(1)+DY*EWZF(2)+DZ*EWZF(3)

      WX=VXF*EWSF(1)+VYF*EWSF(2)+VZF*EWSF(3)
      WY=VXF*EWYF(1)+VYF*EWYF(2)+VZF*EWYF(3)
      WZ=VXF*EWZF(1)+VYF*EWZF(2)+VZF*EWZF(3)

      ZPF=WZ/WX
      YPF=WY/WX

      TFM(1,2)=ZF/DELTAZP
      TFM(2,2)=ZPF/DELTAZP
      TFM(3,2)=YF/DELTAZP
      TFM(4,2)=YPF/DELTAZP

C--T(1:4,3):

      DZ=0.D0
      DY=DELTAY
      DZP=0.D0
      DYP=0.D0

      XI=XI0+DY*EWY(1)+DZ*EWZ(1)
      YI=YI0+DY*EWY(2)+DZ*EWZ(2)
      ZI=ZI0+DY*EWY(3)+DZ*EWZ(3)

      WX=V0/SQRT(1.D0+DZP**2+DYP**2)
      WY=DYP*WX
      WZ=DZP*WX

      VXI=WX*EWS(1)+WY*EWY(1)+WZ*EWZ(1)
      VYI=WX*EWS(2)+WY*EWY(2)+WZ*EWZ(2)
      VZI=WX*EWS(3)+WY*EWY(3)+WZ*EWZ(3)

      CALL TRACK(XI,YI,ZI,VXI,VYI,VZI
     &            ,XF0,YF0,ZF0,VXF0/V0,VYF0/V0,VZF0/V0
     &            ,XF,YF,ZF,VXF,VYF,VZF,DTIM,BSHIFT,gamma,GAMMAL)


      DX=XF-XF0
      DY=YF-YF0
      DZ=ZF-ZF0

      XF=DX*EWSF(1)+DY*EWSF(2)+DZ*EWSF(3)
      YF=DX*EWYF(1)+DY*EWYF(2)+DZ*EWYF(3)
      ZF=DX*EWZF(1)+DY*EWZF(2)+DZ*EWZF(3)

      WX=VXF*EWSF(1)+VYF*EWSF(2)+VZF*EWSF(3)
      WY=VXF*EWYF(1)+VYF*EWYF(2)+VZF*EWYF(3)
      WZ=VXF*EWZF(1)+VYF*EWZF(2)+VZF*EWZF(3)

      ZPF=WZ/WX
      YPF=WY/WX

      TFM(1,3)=ZF/DELTAY
      TFM(2,3)=ZPF/DELTAY
      TFM(3,3)=YF/DELTAY
      TFM(4,3)=YPF/DELTAY

C--T(1:4,4):

      DZ=0.D0
      DY=0.0D0
      DZP=0.D0
      DYP=DELTAYP

      XI=XI0+DY*EWY(1)+DZ*EWZ(1)
      YI=YI0+DY*EWY(2)+DZ*EWZ(2)
      ZI=ZI0+DY*EWY(3)+DZ*EWZ(3)

      WX=V0/SQRT(1.D0+DZP**2+DYP**2)
      WY=DYP*WX
      WZ=DZP*WX

      VXI=WX*EWS(1)+WY*EWY(1)+WZ*EWZ(1)
      VYI=WX*EWS(2)+WY*EWY(2)+WZ*EWZ(2)
      VZI=WX*EWS(3)+WY*EWY(3)+WZ*EWZ(3)

      CALL TRACK(XI,YI,ZI,VXI,VYI,VZI
     &            ,XF0,YF0,ZF0,VXF0/V0,VYF0/V0,VZF0/V0
     &            ,XF,YF,ZF,VXF,VYF,VZF,DTIM,BSHIFT,gamma,GAMMAL)


      DX=XF-XF0
      DY=YF-YF0
      DZ=ZF-ZF0

      XF=DX*EWSF(1)+DY*EWSF(2)+DZ*EWSF(3)
      YF=DX*EWYF(1)+DY*EWYF(2)+DZ*EWYF(3)
      ZF=DX*EWZF(1)+DY*EWZF(2)+DZ*EWZF(3)

      WX=VXF*EWSF(1)+VYF*EWSF(2)+VZF*EWSF(3)
      WY=VXF*EWYF(1)+VYF*EWYF(2)+VZF*EWYF(3)
      WZ=VXF*EWZF(1)+VYF*EWZF(2)+VZF*EWZF(3)

      ZPF=WZ/WX
      YPF=WY/WX

      TFM(1,4)=ZF/DELTAYP
      TFM(2,4)=ZPF/DELTAYP
      TFM(3,4)=YF/DELTAYP
      TFM(4,4)=YPF/DELTAYP

        if (gamma.eq.gammao) then
          tfmh(1:2,1:2)=tfm(1:2,1:2)
          tfmv(1:2,1:2)=tfm(3:4,3:4)
          gamma=gamma*(1.0d0+deltae)
          goto 1
        else
          tfmdeh(1:2,1:2)=tfm(1:2,1:2)
          tfmdev(1:2,1:2)=tfm(3:4,3:4)
c          tfmdeh=tfmh
c          tfmdev=tfmv
        endif

        tfm=tfmo !if tralin has calculated tfm already
        gamma=gammao

        RETURN
      END
+DECK,trackshort.
*CMZ :  4.00/16 22/07/2022  09.45.26  by  Michael Scheer
*CMZ :  4.00/15 29/04/2022  08.25.50  by  Michael Scheer
*CMZ :  3.07/00 05/03/2019  13.35.52  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.10.30  by  Michael Scheer
*CMZ :  2.67/02 16/03/2012  16.36.45  by  Michael Scheer
*CMZ :  2.66/00 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.65/02 28/09/2009  12.44.41  by  Michael Scheer
*CMZ :  2.63/05 10/08/2009  20.48.43  by  Michael Scheer
*CMZ :  2.61/02 14/03/2007  15.48.38  by  Michael Scheer
*CMZ :  2.53/04 09/02/2005  11.06.23  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  10.54.01  by  Michael Scheer
*CMZ :  2.47/17 12/09/2003  10.04.22  by  Michael Scheer
*CMZ :  2.47/12 24/06/2003  16.20.58  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  11.26.52  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  2.12/00 02/06/99  13.56.19  by  Michael Scheer
*CMZ : 00.02/01 18/12/96  11.40.20  by  Michael Scheer
*CMZ : 00.01/10 16/07/96  14.53.50  by  Michael Scheer
*CMZ : 00.01/09 11/04/96  17.41.50  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  09.51.12  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.41.55  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.31  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE TRACKSHORT(ISNORDER,Xi,Yi,Zi,VXi,VYi,VZi,
     &  XF0,YF0,ZF0,EWSFX,EWSFY,EWSFZ,
     &  X2,Y2,Z2,t2,VX2,VY2,VZ2,DTIM,BSHIFT,GAMMA0,BMOVECUT
     &  ,IUSTEP,IENELOSS,GAMMAL)
+seq,gplhint.

C---     INPUT:
C     ISNORDER   order of tracking
C     XI,YI,ZI    coordinates of electron at the starting point
C     VXI,VYI,VZI    velocity at the starting point
C     XF0,YF0,ZF0    point of the plane where tracking stops
C     EWSFX,EWSFY,EWSFZ normal vector of the plane
C     DTIM        time intervall of one tracking step
C     BSHIFT         fraction of step where magnetic field is
C              determined for this step
C     GAMMA       relativistic factor

C---  OUTPUT:
C     X2,Y2,Z2,T2    final coordinates and time-of-flight of the electron
C     VX2,VY2,VZ2    final velocity of the electron

      IMPLICIT NONE

      INTEGER ISNORDER,I,IROI1,IROI2,IUSTEP,IENELOSS,IWARN

      DOUBLE PRECISION X1,Y1,Z1,VX1,VY1,VZ1,X2,Y2,Z2,VX2,VY2,VZ2
     &  ,DTIM,BSHIFT,X2B,Y2B,Z2B,BX1,BY1,BZ1,BX2,BY2,BZ2
     &  ,DGAMSUM,GAMMA,GAMMAL,GAMMA0,DT,VXDUM,VYDUM,VZDUM,VXPDUM,VYPDUM,VZPDUM
     &  ,X2INT,Y2INT,Z2INT,DDT,DDDT,DDT2
     &  ,VX2INT,VY2INT,VZ2INT,VXPINT,VYPINT,VZPINT
     &  ,VXP,VYP,VZP,XOLD,YOLD,ZOLD,VXOLD,VYOLD,VZOLD
     &  ,X3INT,Y3INT,Z3INT,VX3INT,VY3INT,VZ3INT,DDDDT,DDDDT2
     &  ,EWSFX,EWSFY,EWSFZ,XF0,YF0,ZF0,DIST1,DIST2,DISTI
     &  ,AX1,AY1,AZ1,AX2,AY2,AZ2,vxi,vyi,vzi,xi,yi,zi
     &  ,X2BOUND,Y2BOUND,Z2BOUND,VX2BOUND,VY2BOUND,VZ2BOUND
     &  ,X1SAV,Y1SAV,Z1SAV,VX1SAV,VY1SAV,VZ1SAV,BX1SAV,BY1SAV,BZ1SAV
     &  ,AX1SAV,AY1SAV,AZ1SAV,T1SAV,X2SAV,DTIM0,BMOVECUT,BETA,VN

      DOUBLE PRECISION T1,T2,DGAMMA,VXSIGN

+SEQ,PHYCON.
+SEQ,B0SCGLOB.
+seq,sourcef90.

      integer :: idebug=0,ical=0

      DATA IWARN/0/

C VXSIGN takes care for the direction of flight, since particle must gain
c energy if tracked back

      x1=xi
      y1=yi
      z1=zi

      vx1=vxi
      vy1=vyi
      vz1=vzi

      IF (VX1.LT.0) THEN
        VXSIGN=-1.0D0
      ELSE
        VXSIGN=1.0D0
      ENDIF

      GAMMA=GAMMA0
      DGAMSUM=0.0D0

      VN=SQRT(VX1*VX1+VY1*VY1+VZ1*VZ1)

      DT=DTIM*BSHIFT
      DTIM0=DTIM

      T1=0.0

      BX1=0.D0
      BY1=0.D0
      BZ1=0.D0

      AX1=0.D0
      AY1=0.D0
      AZ1=0.D0

      XOLD=X1
      YOLD=Y1
      ZOLD=Z1
      VXOLD=VX1
      VYOLD=VY1
      VZOLD=VZ1

      X2=X1
      Y2=Y1
      Z2=Z1
      T2=T1

      VX2=VX1
      VY2=VY1
      VZ2=VZ1

      BX2=BX1
      BY2=BY1
      BZ2=BZ1

      IROI1=0
      IROI2=1

      DO I=1,NROI
        IF(X1.GE.ROIX(I)) THEN
          IROI1=I
          IROI2=IROI1+1
          GOTO 1000
        ENDIF
      ENDDO

C--- LOOP DER TRAJEKTORIE

1000  X1=X2
      Y1=Y2
      Z1=Z2

      T1=T2

      VX1=VX2
      VY1=VY2
      VZ1=VZ2

      AX1=AX2
      AY1=AY2
      AZ1=AZ2

      BX1=BX2
      BY1=BY2
      BZ1=BZ2

      IF (ISNORDER.EQ.0) THEN

        X2B=X1+VX1*DT
        Y2B=Y1+VY1*DT
        Z2B=Z1+VZ1*DT

      ELSE

        CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX1,BY1,BZ1,DT,X2B,Y2B,Z2B,
     &    VXDUM,VYDUM,VZDUM,VXPDUM,VYPDUM,VZPDUM,GAMMA,ICHARGE,BMOVECUT,
     &    IUSTEP,IENELOSS,DGAMMA)

      ENDIF

      CALL MYBFELD(X2B,Y2B,Z2B,BX2,BY2,BZ2,AX2,AY2,AZ2)

      CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DTIM,
     &  X2,Y2,Z2,VX2,VY2,VZ2,VXP,VYP,VZP,GAMMA,ICHARGE,BMOVECUT,
     &  IUSTEP,IENELOSS,DGAMMA)

      if (idebug.ne.0) then
        ical=ical+1
        write(77,*) ical,x1,z1,by2
      endif

C--- BOUNDARY CROSSING {

      IF (X2.GT.ROIX(IROI2)) THEN

        IF (IWARN.EQ.0.AND.DTIM.LT.0.0D0) THEN
          WRITE(16,*)
          WRITE(16,*)' *** WARNING IN TRACKSHORT:'
          WRITE(16,*)
     &      ' *** DTIM negative, boundary is probably treated wrong! ***'
          WRITE(6,*)
          WRITE(6,*)
          WRITE(6,*)' *** WARNING IN TRACKSHORT:'
          WRITE(6,*)
     &      ' *** DTIM negative, boundary is probably treated wrong! ***'
          WRITE(6,*)
          IWARN=1
        ENDIF

        X1SAV=X1
        Y1SAV=Y1
        Z1SAV=Z1

        T1SAV=T1

        VX1SAV=VX1
        VY1SAV=VY1
        VZ1SAV=VZ1

        AX1SAV=AX1
        AY1SAV=AY1
        AZ1SAV=AZ1

        BX1SAV=BX1
        BY1SAV=BY1
        BZ1SAV=BZ1

        X2SAV=X2

        DIST1=X1-ROIX(IROI2)
        DIST2=X2-ROIX(IROI2)

        DDT=DTIM*DABS(DIST1)/(DABS(DIST1)+DABS(DIST2))
        DDT2=DDT*BSHIFT

        IF(ISNORDER.EQ.0) THEN

          X2B=X1+VX1*DDT2
          Y2B=Y1+VY1*DDT2
          Z2B=Z1+VZ1*DDT2

        ELSE

          CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX1,BY1,BZ1,DDT2,
     &      X2B,Y2B,Z2B,
     &      VXDUM,VYDUM,VZDUM,VXPDUM,VYPDUM,VZPDUM,GAMMA,ICHARGE,BMOVECUT,
     &      IUSTEP,IENELOSS,DGAMMA)

        ENDIF

        CALL MYBFELD(X2B,Y2B,Z2B,BX2,BY2,BZ2,AX2,AY2,AZ2)

        CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DDT,
     &    X2INT,Y2INT,Z2INT,VX2INT,VY2INT,VZ2INT,
     &    VXPINT,VYPINT,VZPINT,GAMMA,ICHARGE,BMOVECUT,
     &    IUSTEP,IENELOSS,DGAMMA)

        DISTI=X2INT-ROIX(IROI2)

        DDDT=DDT
        IF (DIST1.NE.0.) DDDT=DDT-DDT*DISTI/DABS(DIST1)

        CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DDDT,
     &    X3INT,Y3INT,Z3INT,VX3INT,VY3INT,VZ3INT,
     &    VXPINT,VYPINT,VZPINT,GAMMA,ICHARGE,BMOVECUT,IUSTEP,IENELOSS,DGAMMA)

        DISTI=X3INT-ROIX(IROI2)
        DDDDT=DDDT
        IF (DIST1.NE.0.) DDDDT=DDDT-DDDT*DISTI/DABS(DIST1)
        DDDDT2=BSHIFT*DDDDT

        CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DDDDT,
     &    X2BOUND,Y2BOUND,Z2BOUND,VX2BOUND,VY2BOUND,VZ2BOUND,
     &    VXP,VYP,VZP,GAMMA,ICHARGE,BMOVECUT,IUSTEP,IENELOSS,DGAMMA)

        IF (IENELOSS.NE.0) THEN
          DGAMSUM=DGAMSUM+VXSIGN*DGAMMA
          IF (ABS(DGAMSUM).GT.GAMMA*1.0D-8) THEN
            GAMMA=GAMMA+DGAMSUM
            DGAMSUM=0.0D0
          ENDIF
          BETA=DSQRT((1.D0-1.D0/GAMMA)*(1.D0+1.D0/GAMMA))
          VN=SQRT(VX2BOUND*VX2BOUND+VY2BOUND*VY2BOUND+VZ2BOUND*VZ2BOUND)
          VX2BOUND=VX2BOUND/VN*CLIGHT1*BETA
          VY2BOUND=VY2BOUND/VN*CLIGHT1*BETA
          VZ2BOUND=VZ2BOUND/VN*CLIGHT1*BETA
        ENDIF

C NOW WE ARE ON THE BOUNDARY (X2BOUND) AND PRECEED TO OLD X2 (X2SAV)

        DTIM=DTIM*(X2SAV-X2BOUND)/(X2SAV-X1SAV)
        DT=DTIM*BSHIFT

        X1=X2BOUND
        Y1=Y2BOUND
        Z1=Z2BOUND

        VX1=VX2BOUND
        VY1=VY2BOUND
        VZ1=VZ2BOUND

        AX1=AX2
        AY1=AY2
        AZ1=AZ2

        BX1=BX2
        BY1=BY2
        BZ1=BZ2

        IF (ISNORDER.EQ.0) THEN

          X2B=X1+VX1*DT
          Y2B=Y1+VY1*DT
          Z2B=Z1+VZ1*DT

        ELSE

          CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX1,BY1,BZ1,DT,
     &      X2B,Y2B,Z2B,
     &      VXDUM,VYDUM,VZDUM,VXPDUM,VYPDUM,VZPDUM,GAMMA,ICHARGE,BMOVECUT,
     &      IUSTEP,IENELOSS,DGAMMA)

        ENDIF

        CALL MYBFELD(X2B,Y2B,Z2B,BX2,BY2,BZ2,AX2,AY2,AZ2)

        CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DTIM,
     &    X2,Y2,Z2,VX2,VY2,VZ2,VXP,VYP,VZP,GAMMA,ICHARGE,BMOVECUT,
     &    IUSTEP,IENELOSS,DGAMMA)

        IF (IENELOSS.NE.0) THEN
          DGAMSUM=DGAMSUM+VXSIGN*DGAMMA
          IF (ABS(DGAMSUM).GT.GAMMA*1.0D-8) THEN
            GAMMA=GAMMA+DGAMSUM
            DGAMSUM=0.0D0
          ENDIF
          BETA=DSQRT((1.D0-1.D0/GAMMA)*(1.D0+1.D0/GAMMA))
          VN=SQRT(VX2*VX2+VY2*VY2+VZ2*VZ2)
          VX2=VX2/VN*CLIGHT1*BETA
          VY2=VY2/VN*CLIGHT1*BETA
          VZ2=VZ2/VN*CLIGHT1*BETA
        ENDIF

        DIST1=X1-X2SAV
        DIST2=X2-X2SAV

        DDT=DTIM*DABS(DIST1)/(DABS(DIST1)+DABS(DIST2))
        DDT2=DDT*BSHIFT

        IF(ISNORDER.EQ.0) THEN

          X2B=X1+VX1*DDT2
          Y2B=Y1+VY1*DDT2
          Z2B=Z1+VZ1*DDT2

        ELSE

          CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX1,BY1,BZ1,DDT2,
     &      X2B,Y2B,Z2B,
     &      VXDUM,VYDUM,VZDUM,VXPDUM,VYPDUM,VZPDUM,GAMMA,ICHARGE,BMOVECUT,
     &      IUSTEP,IENELOSS,DGAMMA)

        ENDIF

        CALL MYBFELD(X2B,Y2B,Z2B,BX2,BY2,BZ2,AX2,AY2,AZ2)

        CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DDT,
     &    X2INT,Y2INT,Z2INT,VX2INT,VY2INT,VZ2INT,
     &    VXPINT,VYPINT,VZPINT,GAMMA,ICHARGE,BMOVECUT,
     &    IUSTEP,IENELOSS,DGAMMA)

        DISTI=X2INT-X2SAV

        DDDT=DDT
        IF (DIST1.NE.0.) DDDT=DDT-DDT*DISTI/DABS(DIST1)

        CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DDDT,
     &    X3INT,Y3INT,Z3INT,VX3INT,VY3INT,VZ3INT,
     &    VXPINT,VYPINT,VZPINT,GAMMA,ICHARGE,BMOVECUT,IUSTEP,IENELOSS,DGAMMA)

        DISTI=X3INT-X2SAV
        DDDDT=DDDT
        IF (DIST1.NE.0.) DDDDT=DDDT-DDDT*DISTI/DABS(DIST1)
        DDDDT2=BSHIFT*DDDDT

        CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DDDDT,
     &    X2,Y2,Z2,VX2,VY2,VZ2,
     &    VXP,VYP,VZP,GAMMA,ICHARGE,BMOVECUT,
     &    IUSTEP,IENELOSS,DGAMMA)

        IF (IENELOSS.NE.0) THEN
          DGAMSUM=DGAMSUM+VXSIGN*DGAMMA
          IF (ABS(DGAMSUM).GT.GAMMA*1.0D-8) THEN
            GAMMA=GAMMA+DGAMSUM
            DGAMSUM=0.0D0
          ENDIF
          BETA=DSQRT((1.D0-1.D0/GAMMA)*(1.D0+1.D0/GAMMA))
          VN=SQRT(VX2*VX2+VY2*VY2+VZ2*VZ2)
          VX2=VX2/VN*CLIGHT1*BETA
          VY2=VY2/VN*CLIGHT1*BETA
          VZ2=VZ2/VN*CLIGHT1*BETA
        ENDIF

        X1=X1SAV
        Y1=Y1SAV
        Z1=Z1SAV

        T1=T1SAV

        VX1=VX1SAV
        VY1=VY1SAV
        VZ1=VZ1SAV

        AX1=AX1SAV
        AY1=AY1SAV
        AZ1=AZ1SAV

        BX1=BX1SAV
        BY1=BY1SAV
        BZ1=BZ1SAV

        DTIM=DTIM0
        DT=DTIM*BSHIFT

        IROI1=IROI1+1
        IROI2=IROI1+1

      ELSE ! BOUNDARY CROSSED

        IF (IENELOSS.NE.0) THEN
          DGAMSUM=DGAMSUM+VXSIGN*DGAMMA
          IF (ABS(DGAMSUM).GT.GAMMA*1.0D-8) THEN
            GAMMA=GAMMA+DGAMSUM
            DGAMSUM=0.0D0
          ENDIF
          BETA=DSQRT((1.D0-1.D0/GAMMA)*(1.D0+1.D0/GAMMA))
          VN=SQRT(VX2*VX2+VY2*VY2+VZ2*VZ2)
          VX2=VX2/VN*CLIGHT1*BETA
          VY2=VY2/VN*CLIGHT1*BETA
          VZ2=VZ2/VN*CLIGHT1*BETA
        ENDIF

      ENDIF ! BOUNDARY CROSSED

C--- BOUNDARY CROSSING }

      T2=T1+DTIM

C EWSF IS NORMAL VECTOR OF PERPENDICULARE PLANE AT THE END OF THE REFERENCE ORBI
C DIST IS DISTANCE OF ELECTRON TO THIS PLANE
C TRACKING STOPS IF TRAJECTORIE HITS THIS PLANE

      DIST2=(X2-XF0)*EWSFX+(Y2-YF0)*EWSFY+(Z2-ZF0)*EWSFZ

      IF ( DIST2 .LT. 0.0  )  GOTO 1000


C--- ENDE OF TRAJECTORY, DIST2 NOT EXACTLY ZERO, CORRECT X2

      DIST1=(X1-XF0)*EWSFX+(Y1-YF0)*EWSFY+(Z1-ZF0)*EWSFZ

      DDT=DTIM*DABS(DIST1)/(DABS(DIST1)+DABS(DIST2))
      DDT2=DDT*BSHIFT

      IF(ISNORDER.EQ.0) THEN

        X2B=X1+VX1*DDT2
        Y2B=Y1+VY1*DDT2
        Z2B=Z1+VZ1*DDT2

      ELSE

        CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX1,BY1,BZ1,DDT2,
     &    X2B,Y2B,Z2B,
     &    VXDUM,VYDUM,VZDUM,VXPDUM,VYPDUM,VZPDUM,GAMMA,ICHARGE,BMOVECUT,
     &    IUSTEP,IENELOSS,DGAMMA)

      ENDIF

      CALL MYBFELD(X2B,Y2B,Z2B,BX2,BY2,BZ2,AX2,AY2,AZ2)

      CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DDT,
     &  X2INT,Y2INT,Z2INT,VX2INT,VY2INT,VZ2INT,
     &  VXPINT,VYPINT,VZPINT,GAMMA,ICHARGE,BMOVECUT,
     &  IUSTEP,IENELOSS,DGAMMA)

      DISTI=(X2INT-XF0)*EWSFX+(Y2INT-YF0)*EWSFY+(Z2INT-ZF0)*EWSFZ
      DDDT=DDT
      IF (DIST1.NE.0.) DDDT=DDT-DDT*DISTI/DABS(DIST1)

      CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DDDT,
     &  X3INT,Y3INT,Z3INT,VX3INT,VY3INT,VZ3INT,
     &  VXPINT,VYPINT,VZPINT,GAMMA,ICHARGE,BMOVECUT,IUSTEP,IENELOSS,DGAMMA)

      DISTI=(X3INT-XF0)*EWSFX+(Y3INT-YF0)*EWSFY+(Z3INT-ZF0)*EWSFZ
      DDDDT=DDDT
      IF (DIST1.NE.0.) DDDDT=DDDT-DDDT*DISTI/DABS(DIST1)
      DDDDT2=BSHIFT*DDDDT

      CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DDDDT,
     &  X2,Y2,Z2,VX2,VY2,VZ2,
     &  VXP,VYP,VZP,GAMMA,ICHARGE,BMOVECUT,
     &  IUSTEP,IENELOSS,DGAMMA)

      IF (IENELOSS.NE.0) THEN
        DGAMSUM=DGAMSUM+VXSIGN*DGAMMA
        IF (ABS(DGAMSUM).GT.GAMMA*1.0D-8) THEN
          GAMMA=GAMMA+DGAMSUM
          DGAMSUM=0.0D0
        ENDIF
        BETA=DSQRT((1.D0-1.D0/GAMMA)*(1.D0+1.D0/GAMMA))
        VN=SQRT(VX2*VX2+VY2*VY2+VZ2*VZ2)
        VX2=VX2/VN*CLIGHT1*BETA
        VY2=VY2/VN*CLIGHT1*BETA
        VZ2=VZ2/VN*CLIGHT1*BETA
      ENDIF

      T2=T1+DDDDT

      X1=XOLD
      Y1=YOLD
      Z1=ZOLD
      VX1=VXOLD
      VY1=VYOLD
      VZ1=VZOLD

      IF (IENELOSS.NE.0) THEN
        DGAMSUM=DGAMSUM+VXSIGN*DGAMMA
        GAMMA=GAMMA+DGAMSUM
        DGAMSUM=0.0D0
        BETA=DSQRT((1.D0-1.D0/GAMMA)*(1.D0+1.D0/GAMMA))
        VN=SQRT(VX2BOUND*VX2BOUND+VY2BOUND*VY2BOUND+VZ2BOUND*VZ2BOUND)
        VX2BOUND=VX2BOUND/VN*CLIGHT1*BETA
        VY2BOUND=VY2BOUND/VN*CLIGHT1*BETA
        VZ2BOUND=VZ2BOUND/VN*CLIGHT1*BETA
      ENDIF

      GAMMAL=GAMMA0-GAMMA

      RETURN
      END
+DECK,ubunch.
*CMZ :  3.02/03 03/11/2014  10.42.03  by  Michael Scheer
*CMZ :  2.68/05 02/10/2012  09.01.01  by  Michael Scheer
*CMZ :  2.66/20 06/07/2011  11.58.18  by  Michael Scheer
*CMZ :  2.66/12 24/06/2010  12.50.52  by  Michael Scheer
*CMZ :  2.66/08 12/03/2010  15.02.37  by  Michael Scheer
*CMZ :  2.66/07 10/03/2010  14.08.46  by  Michael Scheer
*-- Author :    Michael Scheer   24/02/2010
      subroutine ubunch(xbunch,ybunch,zbunch,ypbunch,zpbunch,gambunch,
     &  dtphase)
+seq,gplhint.

      use bunchmod

      implicit none

      double precision dtphase,xbunch,ybunch,zbunch,
     &  ypbunch,zpbunch,gambunch

      integer ical

      data ical/0/

      if (ical.eq.0) then

        xbunch=xbunch
        ybunch=ybunch
        zbunch=zbunch
        ypbunch=ypbunch
        zpbunch=zpbunch
        gambunch=gambunch
        dtphase=dtphase

        ical=1
      endif !ical

+self,if=ubunchalt.

c****************************************************************
c nicht aktuell, da weight nicht mehr im Konzept.

c****************************************************************




c *** MITTELWERT VON WEIGHT MSSTE EIGENTLICH EINS SEIN!!
c Was aber zu numerischen Problemen fhren kann, deshalb wird mit wscale
c fiktiv skaliert, so dass der inkohrente Teil des Spektrums nicht verrauscht.

      double precision bunwid,bunlen,bunchar
      double precision tpuls,wlen,dljit,dtphase0,omega,bundist,psi,
     &  dcell,wmicrobun,wsockel,sockel,wmean,wsum,wscale,weight

      real ran(1)

      integer ical,nsub,iubbunch,nelec,n

+seq,cmpara.
+seq,contrl.
+seq,wfoldf90.
+seq,ampli.
+seq,uservar.
+seq,phycon.

      data ical/0/

      if (ical.eq.0) then

          xbunch=xbunch
          ybunch=ybunch
          zbunch=zbunch
          ypbunch=ypbunch
          zpbunch=zpbunch
          gambunch=gambunch

          sockel=user(20)

          if (ibunch.ne.0) then
            bunlen=bunchlen
            bunchar=bunchcharge
            nelec=neinbunch
          else
            bunlen=ampbunchlen
            bunchar=ampbunchcharge
            nelec=-iamprep
          endif

          omega=ampfreq/hbarev1
          wlen=wtoe1/ampfreq*1.0d-9
          tpuls=ampbunchlen/clight1

          bunwid=user(13)
          bundist=user(131)

          if (user(12).eq.-9999.0d0) then
            user(12)=nint(bunlen/bundist)
            if (user(12).lt.1.0d0) user(12)=1.0d0
          endif

          nsub=user(12)

          if (sockel.lt.0.0d0.or.sockel.gt.1.0d0) then
            stop 'Error in UBUNCH: USER(20).lt.0.0d.or.USER(20).gt.1.0d0'
          endif

          if (sockel.ne.0.0d0) then
            wmicrobun=bunwid*(1.0d0-sockel)
            wsockel=sockel*bundist
            wmean=(wmicrobun+wsockel)/bundist
          endif

      endif !ical

      ical=ical+1

      if (user(10).eq.1) then

        if (sockel.ne.0.0d0) then

          call ranmar(ran,1)

          dtphase=ran(1)*tpuls
          iubbunch=int(dtphase*clight1/bundist)+1

          dcell=abs(dtphase*clight1-(iubbunch-1)*bundist)

          if (dcell.lt.bunwid) then

            weight=-cos(dcell/bunwid*twopi1)
            weight=(1.0d0+weight)*(1.0d0-sockel)+sockel

          else !(abs(dcell).lt.bundwid) then

            weight=sockel

          endif !(abs(dcell).lt.bundwid) then

          if (dtphase.lt.tpuls/2.0d0) then
            dtphase=dtphase+tpuls/2.0d0
            else
            dtphase=dtphase-tpuls/2.0d0
          endif

          wsum=wsum+weight/wmean
          weight=weight/wmean*bunchar/echarge1/nelec

        else  !sockel

          call ranmar(ran,1)
          iubbunch=int(ran(1)*nsub)+1

          call ranmar(ran,1)
          dljit=bunwid*(ran(1)-0.5)

          dtphase0=(iubbunch-1)*bundist/clight1
          dtphase=dtphase0+dljit/clight1

          ! 1+cos, da Mittelwert 1 betragen muss.
          weight=(1.0d0+cos(dljit/bunwid*twopi1))
          weight=weight*bunchar/echarge1/nelec
          dtphase=dtphase+bunwid/2.0d0/clight1

        endif !sockel

      else if (abs(user(10)).eq.2) then

        call ranmar(ran(1),1)
        dtphase=ran(1)*tpuls

        wscale=user(101)

        if (wscale.eq.-9999.0d0) then

          weight=0.0d0
          do n=1,4
            weight=weight+user(20+n)
          enddo

          if (weight.gt.0.d0) then
            wscale=1.0d0/weight
          else
            wscale=1.0d0
          endif

        endif

        weight=0.0d0
        do n=1,4
          psi=omega*dtphase
          weight=weight-user(20+n)*cos(n*psi)*wscale
        enddo

        weight=(1.0d0+weight)*(1.0d0-sockel)+sockel
        weight=weight*bunchar/echarge1/nelec/wscale**2

      endif !user(10)

+self. if=ubunchalt.
      return
      end

+DECK,bunch.
*CMZ :  3.06/00 14/02/2019  21.01.16  by  Michael Scheer
*CMZ :  3.02/03 03/11/2014  14.55.22  by  Michael Scheer
*CMZ :  3.02/00 10/09/2014  09.38.31  by  Michael Scheer
*CMZ :  3.01/08 01/07/2014  11.04.35  by  Michael Scheer
*CMZ :  2.66/12 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.66/09 25/03/2010  13.07.39  by  Michael Scheer
*CMZ :  2.66/08 16/03/2010  13.36.19  by  Michael Scheer
*CMZ :  2.66/07 10/03/2010  09.50.10  by  Michael Scheer
*-- Author :    Michael Scheer   24/02/2010
      subroutine bunch(dtphase)
+seq,gplhint.

      use bunchmod

      implicit none

      double precision dtphase,weight,wlen,bunchar,bunlen,wscale
      double precision tpuls,emod,psi,dpsidp,omega,p0,r56,bessel,
     &  freqr,dum

      integer ibuff,nbuffp
      parameter (nbuffp=1000)
      real ran(1),ranbuff(nbuffp)

      integer ical,nelec,iwarn,ifail,n,nharm,mode,ncoef,nbuff

+seq,cmpara.
+seq,contrl.
+seq,halbach.
+seq,wfoldf90.
+seq,ampli.
+seq,phycon.
+seq,cohfun.
+seq,trackf90.

      external coherentfun
      real coherentfun

+self,if=-nocern.
      real fspace(200),xlow,xhigh
+self,if=nocern.
      integer nfunp
      parameter (nfunp=200)
      real*8 fint(nfunp),coef(nfunp),xfun(nfunp)
+self.,if=nocern.

      data ical/0/
      data iwarn/0/

      if (ical.eq.0) then

        if (ibunch.ne.0) then
          bunlen=bunchlen
          bunchar=bunchcharge
          nharm=nbunchharm
          ncoefcf=nbunchharm
          nelec=neinbunch
          p0=bunchp0
          r56=bunchr56
          mode=iubunch
        else if (iampli.ne.0) then
          bunlen=ampbunchlen
          bunchar=ampbunchcharge
          nharm=nampbunchharm
          ncoefcf=nampbunchharm
          nelec=-iamprep
          p0=ampbunchp0
          r56=ampbunchr56
          mode=iampcoh
        else
            write(lungfo,*)
     &        '*** Error in BUNCH: IBUNCH nor IAMPLI .ne. 0'
            write(6,*)
     &        '*** Error in BUNCH: IBUNCH nor IAMPLI .ne. 0'
            stop '*** Program WAVE aborted ***'
        endif

        modecf=mode

        if (p0.le.0.0d0) p0=1.0d-30
        if (r56.le.0.0d0) r56=1.0d-30

        dtphase=(wtra2i+(1.d0/(dmygamma*dmygamma))
     &    *(xstop-xstart)/2.d0)/clight1
        freqr=2.d0*pi1/dtphase*hbarev1

        if (ampfreq.eq.-9999.d0) then
          ampfreq=freqr
        endif  !(imampli.gt.0.and.ampfreq.eq.-9999.d0)

        omega=ampfreq/hbarev1
        wlen=wtoe1/ampfreq*1.0d-9

        tpuls=bunlen/clight1

        if (mode.eq.2) then

          dpsidp=twopi1/wlen*r56/dmyenergy
          wscale=0.0d0

          do n=1,nharm
            emod=exp(-(n*espread*dmyenergy*dpsidp)**2/2.0d0)
            call util_bessel(n,n*p0*dpsidp,bessel,ifail)
            if (ifail.ne.0.and.iwarn.eq.0) then
              write(lungfo,*)'*** Warning: Error in BUNCH from call to UTIL_BESSEL ***'
              write(lungfo,*)'*** Warning: further warnings will be suppressed ***'
              write(6,*)'*** Warning: Error in BUNCH from call to UTIL_BESSEL ***'
              write(6,*)'*** Warning: further warnings will be suppressed ***'
              iwarn=1
            endif
            wscale=wscale+2.0d0*emod*bessel
          enddo

          if (wscale.gt.0.0d0) then
            wscale=1.0d0/wscale
          else
            wscale=1.0d0
          endif

        else if (mode.eq.3) then

          open(unit=21,file='wave_phasespace.dat',status='old')

        else if (mode.eq.4) then

          ccf(0)=1.0d0
          open(unit=99,file='fourier-bunch.dat',status='old')
11        call util_skip_comment(99)
          read(99,*,end=99)dum
          ncoef=ncoef+1
          if (ncoef.ge.nharm) goto 99
          if (ncoef.gt.ncoefcfp) then
            write(lungfo,*)
     &        '*** Error in BUNCH: Number of coefficients on file'
            write(lungfo,*)'fourier-bunch.dat exceeds',ncoef,' ***'
            write(6,*)
     &        '*** Error in BUNCH: Number of coefficients on file'
            write(6,*)'fourier-bunch.dat exceeds',ncoef,' ***'
            stop '*** Program WAVE aborted ***'
          endif
          goto 11
99        rewind(99)

          if (ncoef.lt.nharm) then
            write(lungfo,*)
     &        '*** Warning in BUNCH: Number of coefficients on file'
            write(lungfo,*)
     &        'fourier-bunch.dat less than NAMPBUNCHHARM or NBUNCHHARM ***'
            write(6,*)
     &        '*** Warning in BUNCH: Number of coefficients on file'
            write(6,*)
     &        'fourier-bunch.dat less than NAMPBUNCHHARM or NBUNCHHARM ***'
            nharm=ncoef
          endif

          do n=1,nharm
            call util_skip_comment(99)
            read(99,*)ccf(n)
          enddo
          close(99)

          ncoefcf=nharm

        endif !mode

          ! Besser wscale nicht verwenden, da der inkohaerente Untergrund sonst
          ! skaliert wird. Besser Untergrund separat berechen und nachtraeglich
          ! addieren
        if (iampincoh.eq.0) then
          wscale=1.0d0
        endif

        if (mode.ne.3) then

+self,if=-nocern.
          if (iampseed.ge.0) then
            call rluxgo(4,iampseed,0,0)
          endif
+self.,if=-nocern.

          cfbunlen=bunlen
          cfxlenfou=cfbunlen
          ncoefcf=nharm
+self,if=-nocern.
          xhigh=cfxlenfou/2.0d0
          xlow=-xhigh
          call funlxp(coherentfun,fspace,xlow,xhigh) !cernlib V152
+self,if=nocern.
          print*,'--- Warning in subroutine bunch: util_random_func_init'
          print*,'--- (replacement for funlpx of CERNLIB) not yet tested'
          print*,'--- in this context. Be careful!'
          call util_random_func_init(coherentfun,nfunp,xfun,fint,coef)
+self.,if=-nocern.

        endif !iubunch

        ical=1

        ibuff=0
        if (nelec.gt.nbuffp) then
          nbuff=nbuffp
        else
          nbuff=nelec
        endif

      endif !ical

      if (mode.eq.2) then
c siehe Salding et al, NIM A 539 (2005) 499-526

        call ranmar(ran,1)
        dtphase=ran(1)*tpuls

        psi=omega*dtphase

        if (psi.ne.0.0d0.and.p0.ne.0.0d0.and.dpsidp.ne.0.0d0) then
          weight=0.0d0
          do n=1,nharm
            emod=exp(-(n*espread*dmyenergy*dpsidp)**2/2.0d0)
            call util_bessel(n,n*p0*dpsidp,bessel,ifail)
            if (ifail.ne.0.and.iwarn.eq.0) then
              write(lungfo,*)'*** Warning: Error in BUNCH from call to UTIL_BESSEL ***'
              write(lungfo,*)'*** Warning: further warnings will be suppressed ***'
              write(6,*)'*** Warning: Error in BUNCH from call to UTIL_BESSEL ***'
              write(6,*)'*** Warning: further warnings will be suppressed ***'
              iwarn=1
            endif
            weight=weight-2.0d0*emod*bessel*cos(n*psi)*wscale
          enddo
          weight=(1.0d0+weight)
     &      *bunchar/echarge1/nelec/wscale**2
        else
          weight=bunchar/echarge1/nelec
        endif

        else if (mode.eq.3) then

          call util_skip_comment(21)
          read(21,*)egamma,bunchx,xelec,yelec,zelec,ypelec,zpelec
          dtphase=bunchx/clight1

        else if (mode.eq.4) then

          ibuff=ibuff+1
          if (ibuff.gt.nbuff) ibuff=1
          if (ibuff.eq.1) then
+self,if=-nocern.
            call funlux(fspace,ranbuff,nbuff) !cern V152
+self,if=nocern.
          call util_random_func(nfunp,xfun,fint,coef,nbuff,ranbuff)
+self.,if=-nocern.
          endif

          dtphase=ranbuff(ibuff)/clight1

      endif !mode

      if (weight.lt.0.0d0) weight=0.0d0

      return
      end
+DECK,util_bessel.
*CMZ :  2.66/07 04/03/2010  21.48.04  by  Michael Scheer
*-- Author :    Michael Scheer   04/03/2010
      subroutine util_bessel(n,x,bessel,jfail)
+seq,gplhint.

c Calculates BESSEL-function Jn(x)

      implicit none

      integer ndimp
      parameter(ndimp=1000)

      double complex z
     &  ,f(ndimp),g(ndimp),fp(ndimp),gp(ndimp),sig(ndimp),eta(ndimp),zlmin

      double precision x,bessel

      integer n,jfail

      if (n.ge.ndimp) then
        jfail=-9999
        return
      endif

      z=dcmplx(x,0.0d0)

c     CALL WCLBES(Z,ETA,ZLMIN,NL,F,G,FP,GP,SIG,KFN,MODE,JFAIL,JPR)

      zlmin=dcmplx(dble(n),0.0d0)
      call wclbes(z,eta,zlmin,0,f,g,fp,gp,sig,2,1,jfail,0) !CERN C309

      bessel=dreal(f(1))

      return
      end
+DECK,wpamp.
*CMZ :  4.01/07 02/05/2024  11.53.53  by  Michael Scheer
*CMZ :  4.01/03 12/06/2023  11.10.19  by  Michael Scheer
*CMZ :  4.00/17 15/11/2022  10.11.12  by  Michael Scheer
*CMZ :  4.00/15 14/03/2022  09.02.26  by  Michael Scheer
*CMZ :  4.00/06 05/12/2019  13.19.05  by  Michael Scheer
*CMZ :  4.00/04 05/08/2019  14.06.21  by  Michael Scheer
*CMZ :  4.00/02 12/04/2019  14.50.24  by  Michael Scheer
*CMZ :  3.08/01 02/04/2019  12.40.27  by  Michael Scheer
*CMZ :  3.07/01 29/03/2019  15.44.29  by  Michael Scheer
*CMZ :  3.03/02 02/03/2016  10.29.09  by  Michael Scheer
*CMZ :  3.02/00 28/08/2014  08.52.10  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.66/11 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.66/10 04/05/2010  11.49.38  by  Michael Scheer
*CMZ :  2.66/09 29/04/2010  11.46.31  by  Michael Scheer
*-- Author :    Michael Scheer   17/03/2010
      subroutine wpamp
+seq,gplhint.

+SEQ,TRACKF90U.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,REARGF90U.
+SEQ,WFOLDF90U.
+SEQ,AFREQF90U.
+SEQ,AMPLIF90U.

      use bunchmod
      use clustermod
      !use waveenv

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,TRACK.
+SEQ,OPTIC.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,SPECDIP.
+SEQ,COLLI.
+SEq,wfoldf90.
+SEQ,WUSEM.
+SEQ,AMPLI.
+SEQ,USERVAR.
+SEQ,PHYCON.
+SEQ,PRIMKIN.
+seq,strings.
+seq,waveenv.

      double precision rmax2,rabs2,rea1,rea2,wpspecnoro,specnoro,bunnoro,
     &  s1,s2,s3,s4,pow,powt,buno,dw

      real*8 corrins !NIDBUNCH

      integer kfreq,iobsv,jcode,jfreq,jobsv,lastch,ifrmx,iobmx,njobs,ijob,
     &  ifirstch,jliobfr,islash,i,iexist,lun,lun98

      character(2048) chfile
      character(256) cstat,cjobnum
      character cslash

      equivalence (cslash,islash)

      wpspecnor=0.0d0

+self,if=wpampold.
      if (nbunch.ne.1.and.neinbunch.ne.1) then
        write(6,*)
     &    ' '
        write(6,*)
     &    '*** Error in WPAMP: NBUNCH or NEINBUNCH must be 1 ***'
        write(6,*)
     &    '          *** Program WAVE aborted ***'
        write(lungfo,*)
     &    ' '
        write(lungfo,*)
     &    '*** Error in WPAMP: NBUNCH or NEINBUNCH must be 1 ***'
        write(lungfo,*)
     &    '          *** Program WAVE aborted ***'
        stop
      endif
+self.,if=wpampold.

      if (nsource.ne.1) then
        write(6,*)
     &    ' '
        write(6,*)
     &    '*** Error in WPAMP: More then one source not allowd for WPAMP ***'
        write(6,*)
     &    '          *** Program WAVE aborted ***'
        write(lungfo,*)
     &    ' '
        write(lungfo,*)
     &    '*** Error in WPAMP: More then one source not allowd for WPAMP ***'
        write(lungfo,*)
     &    '          *** Program WAVE aborted ***'
        stop
      endif

      if (icluster.gt.0) then

        write(lungfo,*)
        write(lungfo,*)'     WPAMP: Processing spawned runs'
        write(lungfo,*)'     (If some information is missing, please check wave.out of spawned runs, i.e. ....stage.1/wave.out etc.)'
        write(lungfo,*)

        call util_string_trim(trim(chwavedir),ifirstch,lastch)

        njobs=0
        reaima=0.0d0
        spec=0.0d0
        specpow=0.0d0

        corrins=dble(nwinstances)/dble(nwgood)
        if (corrins.ne.1.0d0) then
          print*,""
          print*,"*** Warning in WPAMP: NOT ALL INSTANCES HAVE FINISHED CORRECTLY: BE CAREFUL, ESPECIALLY WITH NORMALIZATION!!"
          print*,""
          write(lungfo,*)""
          write(lungfo,*)"*** Warning in WPAMP: NOT ALL INSTANCES HAVE FINISHED CORRECTLY: BE CAREFUL, ESPECIALLY WITH NORMALIZATION!!"
          write(lungfo,*)""
        endif

        if (istokes.ne.0) stokes=0.0d0

        do njobs=1,nwinstances

          if (iwstat(njobs).ne.0) cycle

          write(cjobnum,*)njobs

          chfile=
     &      chwavedir(ifirstch:lastch)//
     &      '/.stage.'//trim(adjustl(cjobnum))//
     &      '/wave_cluster.dat'

          open(newunit=lun,file=chfile(1:len_trim(chfile)),status='unknown',
     &      err=99)

          read(lun,*)jcode

          if (ibunch.ne.0) then

            if (nbunch.eq.1.and.neinbunch.ne.1) then

              do kfreq=1,nfreq
                do iobsv=1,nobsv

                  iobfr=iobsv+nobsv*(kfreq-1)

                  read(lun,*)
     &              jfreq,jobsv

                  if (jfreq.ne.kfreq.or.jobsv.ne.iobsv) then
                    write(lungfo,*)
     &                '*** Error in WPAMP: Bad photon enery or observation point ***'
                    write(6,*)
     &                '*** Error in WPAMP: Bad photon enery or observation point ***'
                    stop '*** Program WAVE aborted ***'
                  endif

                  do i=1,10
                    read(lun,*)rea1,rea2
                    reaima(i,1,iobfr)=rea1+reaima(i,1,iobfr)
                    reaima(i,2,iobfr)=rea2+reaima(i,2,iobfr)
                  enddo

                enddo !iobsv
              enddo !kfreq

              read(lun,*) wpspecnor

              if (njobs.eq.1) then
                read(lun,*)ecsour(1:4,nsource)
                read(lun,*)ecmax(nsource),speccut
              endif

              read(lun,*)pow
              specpow(nsource)=specpow(nsource)+pow*corrins

              close(lun)

              dw=(wpspecnoro-wpspecnor)/(wpspecnor+wpspecnoro)

              if (njobs.gt.1.and.Abs(dw).gt.1.0e-12) then
                print*,
     &            '*** Warning in WPAMP: Different normalizations on files ***'
                print*,"Deviation:",sngl(dw)
              else
                wpspecnoro=wpspecnor
              endif

+self,if=wpampold.
            else if (neinbunch.eq.1) then
+self,if=-wpampold.
            else if (nbunch.gt.1) then
+self.,if=wpampold.

              do kfreq=1,nfreq
                do iobsv=1,nobsv

                  iliobfr=nsource+nsource*(iobsv-1+nobsv*(kfreq-1))
                  read(lun,*)jliobfr

                  if (jliobfr.ne.iliobfr) then
                    write(lungfo,*)
     &                '*** Error in WPAMP: Bad photon enery or observation point ***'
                    write(6,*)
     &                '*** Error in WPAMP: Bad photon enery or observation point ***'
                    stop '*** Program WAVE aborted ***'
                  endif

                  read(lun,*)rea1
                  spec(iliobfr)=spec(iliobfr)+rea1*corrins

                  if (istokes.ne.0) then
                    iobfr=iobsv+nobsv*(kfreq-1)
                    read(lun,*)s1,s2,s3,s4
                    stokes(1,iobfr)=stokes(1,iobfr)+s1*corrins
                    stokes(2,iobfr)=stokes(2,iobfr)+s2*corrins
                    stokes(3,iobfr)=stokes(3,iobfr)+s3*corrins
                    stokes(4,iobfr)=stokes(4,iobfr)+s4*corrins
                  endif

                enddo !iobsv
              enddo !kfreq

              do kfreq=1,nfreq
                do iobsv=1,nobsv
                  iobfr=iobsv+nobsv*(kfreq-1)
                  do i=1,10
                    read(lun,*)rea1,rea2
                    reaima(i,1,iobfr)=rea1+reaima(i,1,iobfr)
                    reaima(i,2,iobfr)=rea2+reaima(i,2,iobfr)
                  enddo
                enddo !iobsv
              enddo !kfreq

              read(lun,*)specnor,bunnor

              if (njobs.eq.1) then
                read(lun,*)ecsour(1:4,nsource)
                read(lun,*)ecmax(nsource),speccut
              endif

              read(lun,*)pow
              specpow(nsource)=specpow(nsource)+pow

              close(lun)

              if (njobs.gt.1.and.(specnor.ne.specnoro.or.bunnor.ne.bunnoro))
     &          stop
     &          '*** Error in WPAMP: Different normalizations on files ***'

              specnoro=specnor
              bunnoro=bunnor

            endif !neinbunch

          endif !(ibunch.ne.0) then

        enddo !njobs

        write(lungfo,*)

        if (nbunch.eq.1.and.neinbunch.ne.1) then
          reaima=reaima/sqrt(dble(nwgood))
+self,if=wpampold.
        else if (neinbunch.eq.1) then
+self,if=-wpampold.
        else if (nbunch.gt.1) then
+self.,if=wpampold.
          spec=spec/nwgood
          if (istokes.ne.0) stokes=stokes/nwgood
        endif

c 2.5.2024        call wpafreq

      else if (icluster.lt.0) then

        print*,""
        print*," Writing wave_cluster.dat"
        print*,""

        open(newunit=lun,file='wave_cluster.dat',status='unknown')

        write(lun,*)icode

        if (iclubun.eq.1.and.neinbunch.ne.1) then

          do kfreq=1,nfreq
            do iobsv=1,nobsv

              iobfr=iobsv+nobsv*(kfreq-1)

              write(lun,*)
     &          kfreq,iobsv

              do i=1,10
                write(lun,*) reaima(i,1,iobfr),reaima(i,2,iobfr)
              enddo

              rabs2=
     &          reaima(1,1,iobfr)**2+
     &          reaima(1,2,iobfr)**2+
     &          reaima(2,1,iobfr)**2+
     &          reaima(2,2,iobfr)**2+
     &          reaima(3,1,iobfr)**2+
     &          reaima(3,2,iobfr)**2

              if(rabs2.gt.rmax2) then
                rmax2=rabs2
                ifrmx=kfreq
                iobmx=iobsv
              endif

            enddo !iobsv
          enddo !kfreq

          if (rmax2.gt.0.0d0) then

            wpspecnor=spec(iobmx+nobsv*(ifrmx-1))/rmax2
            write(lun,*) wpspecnor

          else
            write(lun,*)0.0d0
          endif

+self,if=wpampold.
        else if (neinbunch.eq.1) then
+self,if=-wpampold.
        else if (iclubun.gt.1) then
+self.
          do kfreq=1,nfreq
            do iobsv=1,nobsv

              iliobfr=nsource+nsource*(iobsv-1+nobsv*(kfreq-1))
              write(lun,*)iliobfr
              write(lun,*)spec(iliobfr)

              if (istokes.ne.0) then
                iobfr=iobsv+nobsv*(kfreq-1)
                write(lun,*)stokes(1,iobfr),stokes(2,iobfr),
     &            stokes(3,iobfr),stokes(4,iobfr)
              endif

            enddo !iobsv
          enddo !kfreq

          do kfreq=1,nfreq
            do iobsv=1,nobsv
                iobfr=iobsv+nobsv*(kfreq-1)
                do i=1,10
                  write(lun,*)reaima(i,1:2,iobfr)
                enddo
            enddo !iobsv
          enddo !kfreq

          write(lun,*) specnor,bunnor

        endif !(nbunch.eq.1) then

        write(lun,*)ecsour(1:4,nsource)
        write(lun,*)ecmax(nsource),speccut
        write(lun,*)specpow(nsource)

        flush(lun)
        close(lun)

      endif !icluster

      return

99    write(lungfo,*)
     &  '*** Error in WPAMP: File not found'
      write(6,*)
     &  '*** Error in WPAMP: File not found'
      stop '*** Program WAVE aborted ***'

      end
+DECK,wpafreq.
*CMZ :  4.00/04 02/08/2019  18.44.17  by  Michael Scheer
*CMZ :  3.08/01 31/03/2019  12.56.02  by  Michael Scheer
*CMZ :  3.07/01 29/03/2019  14.26.55  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.66/11 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.66/10 04/05/2010  12.39.03  by  Michael Scheer
*CMZ :  2.66/09 29/04/2010  11.46.31  by  Michael Scheer
*-- Author :    Michael Scheer   17/03/2010
      subroutine wpafreq
+seq,gplhint.

+SEQ,TRACKF90U.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,REARGF90U.
+SEQ,WFOLDF90U.
+SEQ,AFREQF90U.
+SEQ,AMPLIF90U.

      use bunchmod
      use clustermod

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,TRACK.
+SEQ,OPTIC.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,SPECDIP.
+SEQ,COLLI.
+SEq,wfoldf90.
+SEQ,WUSEM.
+SEQ,AMPLI.
+SEQ,USERVAR.
+SEQ,PHYCON.
+SEQ,PRIMKIN.
+seq,strings.

      complex*16 apolh,apolr,apol45,apoll,ax,ay,az
      double precision aza,aya,phi

      integer ifreq,iobsv,isour

      if (nbunch.eq.1.and.neinbunch.ne.1) then

        do iobsv=1,nobsv
          do ifreq=1,nfreq

            iobfr=iobsv+nobsv*(ifreq-1)

            ax=dcmplx(reaima(1,1,iobfr),reaima(1,2,iobfr))
            ay=dcmplx(reaima(2,1,iobfr),reaima(2,2,iobfr))
            az=dcmplx(reaima(3,1,iobfr),reaima(3,2,iobfr))

            spec(iobfr)=
     &        dreal(
     &        ax*conjg(ax)
     &        +ay*conjg(ay)
     &        +az*conjg(az)
     &        )*specnor

            if (istokes.ne.0) then

              apolh=
     &          ax*conjg(vstokes(1,1))
     &          +ay*conjg(vstokes(1,2))
     &          +az*conjg(vstokes(1,3))

              apolr=
     &          ax*conjg(vstokes(2,1))
     &          +ay*conjg(vstokes(2,2))
     &          +az*conjg(vstokes(2,3))

              apoll=
     &          ax*conjg(vstokes(3,1))
     &          +ay*conjg(vstokes(3,2))
     &          +az*conjg(vstokes(3,3))

              apol45=
     &          ax*conjg(vstokes(4,1))
     &          +ay*conjg(vstokes(4,2))
     &          +az*conjg(vstokes(4,3))

              stokes(1,iobfr)=(apolr*conjg(apolr)+apoll*conjg(apoll))
              stokes(2,iobfr)=(-stokes(1,iobfr)+2.*apolh*conjg(apolh))
              stokes(3,iobfr)=(2.*apol45*conjg(apol45)-stokes(1,iobfr))
              stokes(4,iobfr)=(apolr*conjg(apolr)-apoll*conjg(apoll))

              stokes(1:4,iobfr)=stokes(1:4,iobfr)*specnor

            endif !istokes

          enddo !ifreq
        enddo !iobsv

      else if (neinbunch.eq.1) then

        isour=1
        reaima=0.0d0

        if (specnor*bunnor.eq.0.0d0) then
          print*,'*** Warning in WPAFREQ: Zero normalization on cluster files'
          return
        endif

        wpspecnor=specnor*bunnor

        do iobsv=1,nobsv
          do ifreq=1,nfreq

            iliobfr=isour+nsource*(iobsv-1+nobsv*(ifreq-1))
            iobfr=iobsv+nobsv*(ifreq-1)

            if (istokes.eq.0) then

              reaima(3,1,iobfr)=sqrt(spec(iliobfr)/wpspecnor)

            else !istokes

              aza=sqrt((stokes(1,iobfr)+stokes(2,iobfr))/2.0d0/wpspecnor)
              aya=sqrt((stokes(1,iobfr)-stokes(2,iobfr))/2.0d0/wpspecnor)

              phi=0.0d0
              if (aza*aya.ne.0.0d0) then
                if (abs(stokes(3,iobfr)).gt.abs(stokes(2,iobfr))) then
                  phi=asin(stokes(3,iobfr))/2.0d0/aza/aya
                else
                  phi=acos(stokes(2,iobfr))/2.0d0/aza/aya
                endif
              endif

              reaima(2,1,iobfr)=aya*cos(phi)
              reaima(2,2,iobfr)=aya*sin(phi)
              reaima(3,1,iobfr)=aza
              reaima(3,2,iobfr)=0.0d0

            endif !istokes

          enddo !ifreq
        enddo !iobsv

      endif !nbunch

      return
      end
+DECK,coherentfun,T=F77.
*CMZ :  2.66/12 25/10/2012  15.10.37  by  Michael Scheer
*-- Author :    Michael Scheer   06/05/2010
      function coherentfun(x)
+seq,gplhint.

      use bunchmod

      double precision phi,fun,sig,wlen,emod,dpsidp,p0,r56,bessel,freqr,wscale,
     &  dtphase
      real coherentfun,x
      integer ical,icoef,nsigs,iwarn,ifail,n

      data ical/1/
      data nsigs/10/

+seq,cmpara.
+seq,contrl.
+seq,cohfun.
+seq,wfoldf90.
+seq,ampli.
+seq,phycon.
+seq,trackf90.

      if (ical.eq.1) then

        if (ibunch.ne.0) then
          p0=bunchp0
          r56=bunchr56
        else if (iampli.ne.0) then
          p0=ampbunchp0
          r56=ampbunchr56
        else
            write(lungfo,*)
     &        '*** Error in COHERENTFUN: IBUNCH nor IAMPLI .ne. 0'
            write(6,*)
     &        '*** Error in COHERENTFUN: IBUNCH nor IAMPLI .ne. 0'
            stop '*** Program WAVE aborted ***'
        endif

        sig=cfxlenfou/2.0d0/nsigs

        if (p0.le.0.0d0) p0=1.0d-30
        if (r56.le.0.0d0) r56=1.0d-30

        dtphase=(wtra2i+(1.d0/(dmygamma*dmygamma))
     &    *(xstop-xstart)/2.d0)/clight1
        freqr=2.d0*pi1/dtphase*hbarev1

        if (ampfreq.eq.-9999.d0) then
          ampfreq=freqr
        endif  !(imampli.gt.0.and.ampfreq.eq.-9999.d0)

        wlen=wtoe1/ampfreq*1.0d-9

        ical=1
      endif

      if (modecf.eq.1) then

        coherentfun=exp(-(x/sig)**2/2.0d0)/sqrttwopi1

      else if (modecf.eq.2) then

          dpsidp=twopi1/wlen*r56/dmyenergy
          wscale=0.0d0

          do n=1,ncoefcf
            emod=exp(-(n*espread*dmyenergy*dpsidp)**2/2.0d0)
            call util_bessel(n,n*p0*dpsidp,bessel,ifail)
            if (ifail.ne.0.and.iwarn.eq.0) then
              write(lungfo,*)'*** Warning: Error in COHERENTFUN from call to UTIL_BESSEL ***'
              write(lungfo,*)'*** Warning: further warnings will be suppressed ***'
              write(6,*)'*** Warning: Error in COHERENTFUN from call to UTIL_BESSEL ***'
              write(6,*)'*** Warning: further warnings will be suppressed ***'
              iwarn=1
            endif
            wscale=wscale+2.0d0*emod*bessel
          enddo

          if (wscale.gt.0.0d0) then
            wscale=1.0d0/wscale
          else
            wscale=1.0d0
          endif

          coherentfun=wscale

      else if (modecf.eq.4) then

        fun=ccf(0)
        phi=twopi1*x/cfxlenfou

        do icoef=1,ncoefcf
          fun=fun+ccf(icoef)*cos(icoef*phi)
        enddo
        coherentfun=fun

      else
        stop
     & '*** Error in COHERENTFUN: Undefined mode, please check IUBUNCH or IMAMPLI'
      endif

      return
      end
+DECK,sourcesteps.
*CMZ :  3.02/00 10/09/2014  11.06.20  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.10.30  by  Michael Scheer
*CMZ :  2.66/20 06/07/2011  10.49.51  by  Michael Scheer
*CMZ :  2.66/18 02/12/2010  15.09.50  by  Michael Scheer
*-- Author :    Michael Scheer   02/12/2010
      subroutine sourcesteps(isour,nsteps)
+seq,gplhint.

+SEQ,SOURCEF90U.

      implicit none

+seq,cmpara.
+seq,sourcef90.

      double precision x1,xendsou,roi(nroip),droix
+self,if=-windows.
      integer*8 kzaehl
+self,if=windows.
      integer kzaehl
+self.
      integer nsteps,iroi,ir1,ir2,isour,nzaehl

      if (nroi.lt.0) then
        droix=(xendsou-x1)/(nroia-1)
        do iroi=1,nroia
          roix(iroi)=x1+(iroi-1)*droix
          roip(iroi)=1.0d0
        enddo
      endif   !(nroi.lt.0)

      roix(1)=roix(1)-1.0d-6
      roix(nroia)=roix(nroia)+1.0d-6

      do iroi=1,nroia
          roi(iroi)=roix(iroi)
      enddo

      kzaehl=0
      x1=sourceao(1,1,isour)
      xendsou=sourceeo(1,1,isour)
      nzaehl=nlpoio

      ir1=-1
      do iroi=1,nroia
        if (roi(iroi).gt.x1.and.roi(iroi).lt.xendsou.and.ir1.eq.-1) then
          ir1=iroi
          goto 11
        endif
      enddo

11    do iroi=1,nroia
        ir2=iroi
        if (roi(iroi).gt.xendsou) then
          roi(iroi)=xendsou
          ir2=ir2-1
          if (roi(ir2).lt.x1) then
            roi(ir2)=x1
          endif
          goto 12
        endif
      enddo

12    continue

      kzaehl=kzaehl+nzaehl*roip(ir2)*(xendsou-roi(ir2))/(xendsou-x1)

      if (ir1.ne.-1) then

        kzaehl=kzaehl+nzaehl*roip(ir1-1)*(roi(ir1)-x1)/(xendsou-x1)

        do iroi=ir1,ir2-1
          if (roi(iroi).gt.x1.or.roi(iroi)+1.lt.xendsou) then
            kzaehl=kzaehl+nzaehl*roip(iroi)*(roi(iroi+1)-roi(iroi))/(xendsou-x1)
          else if (roi(iroi).gt.x1.or.roi(iroi)+1.lt.xendsou) then
            kzaehl=kzaehl+nzaehl*roip(iroi)*(roi(iroi+1)-roi(iroi))/(xendsou-x1)
          endif
        enddo

      endif

      if (kzaehl.gt.2**30) then
        stop '*** Error in sourcesteps: More then 2**30 steps found for source'
      endif

      nsteps=kzaehl+nbaddp

      return
      end
+DECK,util_spline_coef_periodic.
*CMZ :  4.01/02 17/03/2023  21.52.12  by  Michael Scheer
*CMZ :  2.66/18 10/12/2010  14.04.32  by  Michael Scheer
*CMZ : 00.00/07 10/12/2010  13.21.53  by  Michael Scheer
*-- Author :    Michael Scheer   10/12/2010
      subroutine util_spline_coef_periodic(x,y,n,ypp,aa,bb,cc,c,cn,ifail)
+seq,gplhint.

c--- calculates spline coefficients for periodic function
c--- the interval must be closed, i.e. x(n)-x(1)=periodelength and y(n)=y(1)

c--   input:

c-       n: number of x,y-values, must be at least five
c-       x: array of x-values
c-       y: array of y-values

c--   ouput:

c-       ypp:   spline-coefficients
c-     ifail:   error status

c--   workingspace: aa(n),bb(n),cc(n),c(n),cn(n)

      implicit none

      integer n,j,n1,n2,ifail
      real*8  x(n),y(n),ypp(n),aa(n),bb(n),cc(n),c(n),cn(n)

      if(n.lt.5) then
        ifail=-1
        return
      endif

      if(y(n).ne.y(1)) then
        ifail=-2
        return
      endif

      cn=0.0d0 !letzte Spalte der Matrix

c      y(n)=y(1)
c      ypp(n)=ypp(1)

c n=5
c      aa(1)*ypp(4)+bb(1)*ypp(1)+cc(1)*ypp(2)=c(1)
c      aa(2)*ypp(1)+bb(2)*ypp(2)+cc(2)*ypp(3)=c(2)
c      aa(3)*ypp(2)+bb(3)*ypp(3)+cc(3)*ypp(4)=c(3)
c      aa(4)*ypp(3)+bb(4)*ypp(4)+cc(4)*ypp(1)=c(4)

      n1=n-1
      n2=n-2

      aa(1)=(x(n)-x(n1))/6.d0
      bb(1)=(x(2)-x(1)+(x(n)-x(n1)))/3.d0
      cc(1)=(x(2)-x(1))/6.d0
      c(1)=(y(2)-y(1))/(x(2)-x(1))
     &    -(y(n)-y(n1))/(x(n)-x(n1))

      do j=2,n1
          aa(j)=(x(j  )-x(j-1))/6.d0
          bb(j)=(x(j+1)-x(j-1))/3.d0
          cc(j)=(x(j+1)-x(j  ))/6.d0
          c(j)=(y(j+1)-y(j  ))/(x(j+1)-x(j  ))
     &          -(y(j  )-y(j-1))/(x(j  )-x(j-1))
      enddo !j

c Auf Dreiecksmatrix bringen

c Oberste Zeile

      cc(1)=cc(1)/bb(1)
      aa(1)=aa(1)/bb(1)
      c(1) = c(1)/bb(1)
      bb(1)=1.0d0

c 2. Zeile, d.h. die erste regulaere, cn(j) ist die letzte Spalte der Matrix

      bb(2)=bb(2)/aa(2)
      cc(2)=cc(2)/aa(2)
      c(2) = c(2)/aa(2)
      aa(2)=1.0d0

      aa(2)=0.0d0
      bb(2)=bb(2)-cc(1)
      cn(2)=-aa(1)
      c(2) = c(2)-c(1)

      cc(2)=cc(2)/bb(2)
      cn(2)=cn(2)/bb(2)
      c(2) = c(2)/bb(2)

      bb(2)=1.0d0

c Nun die hoeheren bis n-3

      do j=3,n-3

        bb(j)=bb(j)/aa(j)
        cc(j)=cc(j)/aa(j)
        c(j) = c(j)/aa(j)

        aa(j)=0.0d0
        bb(j)=bb(j)-cc(j-1)
        cn(j)=-cn(j-1)
        c(j) = c(j)-c(j-1)

        cc(j)=cc(j)/bb(j)
        cn(j)=cn(j)/bb(j)
        c(j) = c(j)/bb(j)

        bb(j)=1.0d0

      enddo

c vorletzte Zeile

      bb(n2)=bb(n2)/aa(n2)
      cc(n2)=cc(n2)/aa(n2)
      c(n2) = c(n2)/aa(n2)
      aa(n2)=1.0d0

      aa(n2)=0.0d0
      bb(n2)=bb(n2)-cc(n2-1)
      cc(n2)=cc(n2)-cn(n2-1)
      c(n2) = c(n2)-c(n2-1)

      cc(n2)=cc(n2)/bb(n2)
      c(n2) = c(n2)/bb(n2)

      bb(n2)=1.0d0

c Letzte Zeile, benutze ypp als Puffer

      ypp=0.0d0
      ypp(n2)=aa(n1)/cc(n1)
      ypp(n1)=bb(n1)/cc(n1)
      c(n1)=c(n1)/cc(n1)
      cc(n1)=1.0d0
      ypp(1)=cc(n1)

c Oberste Zeile abziehen

      ypp(1)=0.0d0
      ypp(2)=-cc(1)
      ypp(n1)=ypp(n1)-aa(1)
      c(n1)=c(n1)-c(1)

      do j=2,n2

        c(n1)=c(n1)/ypp(j)
        ypp=ypp/ypp(j)

        ypp(j)=ypp(j)-bb(j)
        ypp(j+1)=ypp(j+1)-cc(j)
        ypp(n1)=ypp(n1)-cn(j)
        c(n1)=c(n1)-c(j)

      enddo

      c(n1)=c(n1)/ypp(n1)

c Ernten

      ypp(n1)=c(n1)

c Vorletzte Zeile

      bb(n2)=bb(n2)/cc(n2)
      c(n2)=c(n2)/cc(n2)
      cc(n2)=1.0d0

      c(n2)=c(n2)-c(n1)
      cc(n2)=0.0d0

      c(n2)=c(n2)/bb(n2)
      bb(n2)=1.0d0

      ypp(n2)=c(n2)

c Letzte Spalte nullen und normieren, letzte und vorletzte sind bereits fertig

      bb(1)=bb(1)/aa(1)
      cc(1)=cc(1)/aa(1)
      c(1)=c(1)/aa(1)
      aa(1)=1.0d0

      c(1)=c(1)-c(n1)
      aa(1)=0.0d0

      cc(1)=cc(1)/bb(1)
      c(1)=c(1)/bb(1)
      bb(1)=1.0d0

c Regulaere Zeilen
      do j=2,n-3

        bb(j)=bb(j)/cn(j)
        cc(j)=cc(j)/cn(j)
        c(j)=c(j)/cn(j)
        cn(j)=1.0d0

        c(j)=c(j)-c(n1)
        cn(j)=0.0d0

        cc(j)=cc(j)/bb(j)
        c(j)=c(j)/bb(j)
        bb(j)=1.0d0

      enddo

      do j=n-3,2,-1
         ypp(j)=c(j)-cc(j)*ypp(j+1)
      enddo

      ypp(1)=(c(1)-cc(1)*ypp(2)-aa(1)*ypp(n1))/bb(1)
      ypp(n)=ypp(1)

      ifail=0

      return
      end
+DECK,efield.
*CMZ :  2.66/20 21/11/2011  17.24.41  by  Michael Scheer
*-- Author :    Michael Scheer   18/11/2011
      subroutine efield(x,y,z,ex,ey,ez)
+seq,gplhint.

c calculates electrical field (ex,ey,ez) in V/m and corresponding
c dgamma for (x,y,z,dt)
c

c data format:
c x1 y1 z1 ex1 ey1 ez1
c       .
c x1 y1 znz ex111 ey111 ez11nx
c       .
c       .
c x1 y2 z1 ex121 ey121 ez121
c       .
c x1 yny znz ex1nynz ey1nynz ez1nynz
c       .
c       .
c xnx yny znz exnxnynz eynxnynz eznxnynz


+seq,contrl.
+seq,phycon.

      integer nedimp
      parameter (nedimp=100000)

      double precision x,y,z,xx,yy,zz,
     &  ex,ey,ez,f(6,nedimp),
     &  xmax,xmin,ymax,ymin,zmax,zmin,
     &  exmax,exmin,eymax,eymin,ezmax,ezmin,
     &  x1,x2,y1,y2,z1,z2

      integer ical,lunein,nx,ny,nz,ix,iy,iz,ieof,nread,ixold,iyold,izold,k,
     &  klo,khi,kd,nzy

      data ical/0/
      data lunein/0/

      if (ical.eq.0) then
        nread=0
        nx=0
        x1=1.0d30
        y1=1.0d30
        z1=1.0d30
        x2=-1.0d30
        y2=-1.0d30
        z2=-1.0d30
        open(unit=lunein,file='efield.dat')
1       call util_skip_comment_end(lunein,ieof)
        if (ieof.ne.0) goto 9
        read(lunein,*)xx,yy,zz,ex,ey,ez
        nread=nread+1
        if (nread.gt.nedimp) stop '*** Error in efield: Dimension exceeded ***'
        f(1,nread)=xx
        f(2,nread)=yy
        f(3,nread)=zz
        f(4,nread)=ex
        f(5,nread)=ey
        f(6,nread)=ez
        if (xx.gt.xmax) xmax=xx
        if (yy.gt.ymax) ymax=yy
        if (zz.gt.zmax) zmax=zz
        if (xx.lt.xmin) xmin=xx
        if (yy.lt.ymin) ymin=yy
        if (zz.lt.zmin) zmin=zz
        if (ex.gt.exmax) exmax=ex
        if (ey.gt.eymax) eymax=ey
        if (ez.gt.ezmax) ezmax=ez
        if (ex.lt.exmin) exmin=ex
        if (ey.lt.eymin) eymin=ey
        if (ez.lt.ezmin) ezmin=ez
        if (f(1,nread).ne.x1) then
          nx=nx+1
          x1=xx
        endif
        goto 1
9       close(lunein)

        z1=f(3,1)
        do k=2,nread
          if (f(3,k).ne.z1) then
            nz=k
            goto 99
          endif
        enddo
99      ny=nread/nx/nz

        write(lungfo,*)' '
        write(lungfo,*)'      E-Field routine efield called first time:'
        write(lungfo,*)' '
        if (nx.lt.2) stop '*** Error in efield: Less then two x-values found ***'
        if (ny.lt.2) stop '*** Error in efield: Less then two y-values found ***'
        if (nz.lt.2) stop '*** Error in efield: Less then two z-values found ***'
        write(lungfo,*)'         Number of data points:',nread
        write(lungfo,*)' '
        write(lungfo,*)'         xmin, xmax:',xmin,xmax
        write(lungfo,*)'         ymin, ymax:',ymin,ymax
        write(lungfo,*)'         zmin, zmax:',zmin,zmax
        write(lungfo,*)' '
        write(lungfo,*)'         Exmin, Exmax:',Exmin,Exmax
        write(lungfo,*)'         Eymin, Eymax:',Eymin,Eymax
        write(lungfo,*)'         Ezmin, Ezmax:',Ezmin,Ezmax
        write(lungfo,*)' '
        if (nx*ny*nz.ne.nread) stop '*** Error in efield: Invalid file efield.dat ***'
      endif !ical

      klo=1
      khi=nz
      kd=nz
      if (ical.gt.0) then
        z1=f(3,izold)
        z2=f(3,izold+1)
      endif

      if (z.ge.z1.and.z.lt.z2) then
        iz=izold
      else !
        if (ical.ne.0) then
          if (z.ge.z1) then
            KD=1
121         KHI=MIN(KLO+KD,nz)
            IF (z.GT.f(3,KHI)) THEN
              KD=2*KD
              KLO=KHI
              GOTO 121
            ENDIF
          ELSE
            KD=1
            KHI=KLO
122         KLO=MAX(KHI-KD,1)
            IF (z.LT.f(3,KLO)) THEN
              KD=2*KD
              KHI=KLO
              GOTO 122
            ENDIF
          endif
        endif !ical
131     IF (KHI-KLO.GT.1) THEN
          K=(KHI+KLO)/2
          IF(f(3,K).GT.z)THEN
            KHI=K
          ELSE
            KLO=K
          ENDIF
          GOTO 131
        ENDIF
        iz=klo
      endif !z

      klo=1
      khi=ny
      kd=ny
      if (ical.ne.0) then
        y1=f(2,iyold)
        y2=f(2,iyold+nz)
      endif

      if (y.ge.y1.and.y.lt.y2) then
        iy=iyold
      else !
        if (ical.ne.0) then
          if (y.ge.y1) then
            KD=1
221         KHI=MIN(KLO+KD,ny)
            IF (y.GT.f(2,khi+nz)) THEN
              KD=2*KD
              KLO=KHI
              GOTO 221
            ENDIF
          ELSE
            KD=1
            KHI=KLO
222         KLO=MAX(KHI-KD,1)
            IF (y.LT.f(2,klo+nz)) THEN
              KD=2*KD
              KHI=KLO
              GOTO 222
            ENDIF
          endif
        endif !ical
231     IF (KHI-KLO.GT.1) THEN
          K=(KHI+KLO)/2
          IF(f(2,k+nz).GT.y)THEN
            KHI=K
          ELSE
            KLO=K
          ENDIF
          GOTO 231
        ENDIF
        iy=klo
      endif !y

      klo=1
      khi=nx
      kd=nx
      nzy=nz+ny
      if (ical.ne.0) then
        x1=f(1,ixold)
        x2=f(1,ixold+nzy)
      endif

      if (x.ge.x1.and.x.lt.x2) then
        ix=ixold
      else !
        if (ical.ne.0) then
          if (x.ge.x1) then
            KD=1
21          KHI=MIN(KLO+KD,nx)
            IF (X.GT.f(1,KHI+nzy)) THEN
              KD=2*KD
              KLO=KHI
              GOTO 21
            ENDIF
          ELSE
            KD=1
            KHI=KLO
22          KLO=MAX(KHI-KD,1)
            IF (X.LT.f(1,KLO+nzy)) THEN
              KD=2*KD
              KHI=KLO
              GOTO 22
            ENDIF
          endif
        endif !ical
31      IF (KHI-KLO.GT.1) THEN
          K=(KHI+KLO)/2
          IF(f(1,K+nzy).GT.X)THEN
            KHI=K
          ELSE
            KLO=K
          ENDIF
          GOTO 31
        ENDIF
        ix=klo
      endif !x

      ixold=ix
      iyold=iy
      izold=iz

      ical=1

      return
      end
+DECK,estep.
*CMZ :  2.68/04 03/09/2012  13.22.46  by  Michael Scheer
*CMZ :  2.68/03 22/08/2012  14.13.20  by  Michael Scheer
*CMZ :  2.66/21 22/11/2011  13.51.05  by  Michael Scheer
*CMZ :  2.66/20 22/11/2011  10.17.35  by  Michael Scheer
*-- Author :    Michael Scheer   18/11/2011
      subroutine estep(x,y,z,vx,vy,vz,dt,gamma,dgamma)
+seq,gplhint.

c Simple approach to take electrical fields into account
c The energy and gamma of the particle is not changed, but returned in dgamma

+seq,primkin
+seq,efield.
+seq,b0scglob.
+seq,phycon.

      double precision x,y,z,vx,vy,vz,dt,gamma,dgamma
      double precision px,py,pz,qdt,eg,vn,pn,
     &  px0,py0,pz0,pn0,pn2,pn02,de,dpx,dpy,dpz,dtm

      if (efieldx.eq.0.0d0.and.efieldy.eq.0.0d0.and.efieldz.eq.0.0d0) then
        dgamma=0.0d0
        return
      endif

      qdt=icharge*echarge1*dt
      eg=emasskg1*gamma

      px0=vx*eg !SI-units
      py0=vy*eg
      pz0=vz*eg
      pn02=px0*px0+py0*py0+pz0*pz0
      pn0=sqrt(pn02)

      dpx=efieldx*qdt !SI-units
      dpy=efieldy*qdt
      dpz=efieldz*qdt

      px=px0+dpx !SI-units
      py=py0+dpy
      pz=pz0+dpz

      vn=sqrt(vx*vx+vy*vy+vz*vz)
      pn2=px*px+py*py+pz*pz
      pn=sqrt(pn2)

c total momentum and energy are kept!!
      vx=px/pn*vn
      vy=py/pn*vn
      vz=pz/pn*vn

      dtm=0.5d0*dt/(emasskg1*gamma) ! F=dp/dt, m=m_e*gamma, a=F/m*dp/dt/m_e/gamma

      x=x+dtm*dpx
      y=y+dtm*dpy
      z=z+dtm*dpz

      de=(vx*dpx+dpy*vy+dpz*vz)/echarge1/1.0d9 !GeV
      dgamma=de/dmyenergyP*dmygammaP

      return
      end
+DECK,hbookm.
*CMZ :  4.00/14 22/12/2021  13.41.56  by  Michael Scheer
*CMZ :  4.00/13 16/12/2021  12.18.27  by  Michael Scheer
*CMZ :  3.03/04 27/10/2017  09.47.16  by  Michael Scheer
*CMZ :  3.02/04 12/12/2014  16.03.51  by  Michael Scheer
*CMZ :  3.02/00 01/09/2014  11.11.30  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  16.20.53  by  Michael Scheer
*CMZ :  3.01/05 12/06/2014  11.35.31  by  Michael Scheer
*CMZ :  3.01/02 25/10/2013  16.22.19  by  Michael Scheer
*CMZ :  2.68/02 04/07/2012  13.35.03  by  Michael Scheer
*CMZ :  2.67/03 09/05/2012  16.32.43  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  12.52.39  by  Michael Scheer
*-- Author :    Michael Scheer   21/01/2012
      subroutine hbookm(nid,ctitle,nvar,cdir,irecl,chtags)
+seq,gplhint.
+self,if=mhbook.
      use mhbook_mod
+self.
      implicit none

+seq,contrl.
+seq,rootc,if=-noroot.
+seq,ntupinfo.

      integer nid,irecl,nvar,i,k,null
      character(7) cname,cname2 ! siehe auch nNTupMax und nHistoMax in waveroot
      character(*) cdir,ctitle
      character(*) chtags(1)
      character c1,cnull

c Wrapper for hbookn, e.g.
c hbookm(NIDTRAC+1,'TRANS. TRACKS',NTUP,'//WAVE',1024,CHTAGS)
c or TTree of root respectively

      equivalence(null,cnull)
      data null/0/

      ! siehe auch nNTupMax und nHistoMax in waveroot
      if (nid.gt.9999)
     & stop '*** Error in HBOOKM: Identifier of Ntuple exceeds 9999'

+self,if=-nohbook,if=-noroot.
      kindhis(nid)=4
      do i=1,len_trim(cname2)
        cname(i:i)=' '
        cname2(i:i)=' '
      enddo
+self.

+self,if=-nohbook.
      if (iroottrees.ge.0) then
        call hbookn(nid,ctitle,nvar,cdir,irecl,chtags)
        ntupnvar(nid)=nvar
        do i=1,nvar
          chntuptags(i,nid)=chtags(i)
        enddo
      endif
+self. ,if=-nohbook.

+self,if=-noroot.
      if (iroottrees.ne.0) then
        write(cname2,'(i6)')nid
        k=1
        cname(k:k)='n'
        do i=1,len_trim(cname2)
          c1=cname2(i:i)
          if (c1.ne.' ') then
            k=k+1
            cname(k:k)=c1
          endif
        enddo
        cname(len_trim(cname)+1:len_trim(cname)+1)=cnull
        call mshncreatef(nid,cname,ctitle,nvar,chtags,0)
      endif
+self.,if=-noroot.

+self,if=mshhbook.
      call msh_hbookn(int8(nid),ctitle,int8(nvar),cdir,int8(irecl),chtags)
+self.

+self,if=mhbook.
      call mh_path(cdir)
      call mh_bookn(nid,ctitle,nvar,chtags,irecl)
+self.

      return
      end
+DECK,hfm.
*CMZ :  4.01/07 02/05/2024  12.38.37  by  Michael Scheer
*CMZ :  4.01/05 20/04/2024  09.48.41  by  Michael Scheer
*CMZ :  4.00/15 14/03/2022  10.05.01  by  Michael Scheer
*CMZ :  4.00/14 10/02/2022  17.40.28  by  Michael Scheer
*CMZ :  4.00/13 16/12/2021  12.18.27  by  Michael Scheer
*CMZ :  3.02/00 01/09/2014  11.11.30  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  16.20.53  by  Michael Scheer
*CMZ :  3.01/05 13/06/2014  09.06.46  by  Michael Scheer
*CMZ :  2.68/05 28/09/2012  13.12.28  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  09.54.48  by  Michael Scheer
*-- Author :    Michael Scheer   19/01/2012
      subroutine hfm(nid,buffD)

      use clustermod
      use mhbook_mod

+seq,gplhint.

      implicit none

+seq,contrl.
+seq,uservar.
+seq,ntupinfo.

      double precision buffD(*)
      integer nid,i,k,nvar
      real buff(100),rlow(100),rhigh(100)
      character(80) tit
      character(10) chtag(100)
      character(7) cname,cname2
      character c

+self,if=mhbook.
      if (icluster.eq.0.or.icluster.eq.9999) then
        call mh_filln(nid,buffd)
        return
      endif

      if (icluster.lt.0) then
        if (nid.eq.3601) then
          write(nscr3601,*)buffd(1:36)
        else if (nid.eq.3600) then
          write(nscr3600,*)buffd(1:2)
        else if (nid.eq.3700) then
          write(nscr3700,*)buffd(1:34)
        else if (nid.eq.4600) then
          write(nscr4600,*)buffd(1:5)
        else if (nid.eq.4700) then
          write(nscr4700,*)buffd(1:12)
        else if (nid.eq.30) then
          write(nscr30,*)buffd(1:41)
        else if (nid.eq.7777) then
          write(nscr7777,*)buffd(1:14)
        endif
      else if ( ! they are filled in wpampntup
     &    nid.ne.3601.and.
     &    nid.ne.3600.and.
     &    nid.ne.3700.and.
     &    nid.ne.4600.and.
     &    nid.ne.4700.and.
     &    nid.ne.30.and.
     &    nid.ne.7777) then
        call mh_filln(nid,buffd)
        return
      endif
+self.

      if (iroottrees.ge.0) then
+self,if=-nohbook.
        nvar=ntupnvar(nid)
        do i=1,nvar
          buff(i)=buffD(i)
        enddo
+self.
+self,if=-nohbook.
        call hfn(nid,buff)
+self.,if=-nohbook.
+self,if=mshhbook.
        call msh_hfn(int8(nid),buffd)
+self.
      endif

      if (iroottrees.eq.0) return
+self,if=-noroot.
      call hfmcc(nid,buffD)
+self.,if=-noroot.

      return
      end
+DECK,hbook1m.
*CMZ :  4.00/14 30/12/2021  15.41.22  by  Michael Scheer
*CMZ :  4.00/13 16/12/2021  12.18.27  by  Michael Scheer
*CMZ :  3.02/04 12/12/2014  15.28.39  by  Michael Scheer
*CMZ :  3.02/00 01/09/2014  11.11.30  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  16.20.53  by  Michael Scheer
*CMZ :  3.01/05 11/06/2014  16.12.58  by  Michael Scheer
*CMZ :  2.69/00 24/10/2012  16.50.54  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  16.23.54  by  Michael Scheer
*-- Author :    Michael Scheer   19/01/2012
      subroutine hbook1m(id,ctitle,nbins,xmin,xmax,vmx)
+seq,gplhint.

+seq,contrl.
+seq,rootc,if=-noroot.

c creates 1D-histo for root.

      integer id,nbins,k,i,null
      real xmin,xmax,vmx
      character(*) ctitle
      character c1
      character(8) cname,cname2
      equivalence (c1,null)

      data null/0/

+self,if=debug.
      write(6,*)'Debug: Entered HBOOK1M'
+self.

+self,if=-noroot,-nohbook.
      kindhis(id)=1
      if (id.gt.249999) then !siehe auch waveroot
        write(6,*)
     &    '*** Error in HBOOK1M: Identifier ', id, ' exceeds 249999 ***'
        stop
      endif
+self.

+self,if=debug.
      write(6,*)' '
      write(6,*)'id:',id
      write(6,*)' '
      write(6,*)'ctitle:'
      write(6,*)ctitle
      write(6,*)'len_trim(ctitle):'
      write(6,*)len_trim(ctitle)
      write(6,*)'ctitle(1:len_trim(ctitle)):'
      write(6,*)ctitle(1:17)
      write(6,*)' '
+self.
+self,if=-nohbook.
      if (iroottrees.ge.0) then
       call hbook1(id,ctitle,nbins,xmin,xmax,vmx)
      endif
+self.,if=-nohbook.

+self,if=-noroot.
      if (iroottrees.ne.0) then
        cname=''
        write(cname2,'(i6)')id
        k=1
        cname(k:k)='h'
        do i=1,len_trim(cname2)
          c1=cname2(i:i)
          if (c1.ne.' ') then
            k=k+1
            cname(k:k)=c1
          endif
        enddo
        k=len_trim(cname)+1
        cname(k:k)=''
        call hbook1cc(id,cname(1:len_trim(cname)),
     &    ctitle(1:len_trim(ctitle)),nbins,dble(xmin),dble(xmax))
      endif
+self.

+self,if=mshhbook.
      call msh_hbook1(int8(id),ctitle,int8(nbins),
     &  dble(xmin),dble(xmax),dble(vmx))
+self.

+self,if=mhbook.
      call mh_book1(id,ctitle,nbins,dble(xmin),dble(xmax))
+self.
      return
      end

+DECK,hbook2m.
*CMZ :  4.00/14 30/12/2021  15.41.22  by  Michael Scheer
*CMZ :  4.00/13 19/12/2021  10.13.31  by  Michael Scheer
*CMZ :  3.02/04 12/12/2014  15.28.39  by  Michael Scheer
*CMZ :  3.02/00 01/09/2014  11.11.30  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  16.20.53  by  Michael Scheer
*CMZ :  2.69/00 24/10/2012  16.55.08  by  Michael Scheer
*CMZ :  2.67/04 14/05/2012  13.05.02  by  Michael Scheer
*CMZ :  2.67/01 21/02/2012  10.22.54  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  16.23.54  by  Michael Scheer
*-- Author :    Michael Scheer   19/01/2012
      subroutine hbook2m(id,ctitle,nxbins,xmin,xmax,nybins,ymin,ymax,vmx)
+seq,gplhint.

+seq,contrl.
+seq,rootc,if=-noroot.

c creates 2D-histo for root.

      integer id,nxbins,nybins,k,i
      real xmin,xmax,ymin,ymax,vmx
      character(*) ctitle
      character c1
      character(8) cname,cname2

+self,if=debug.
      write(6,*)'Debug: Entered HBOOK2M'
+self.

+self,if=-noroot,-nohbook.
      kindhis(id)=2

      if (id.gt.249099) then !siehe auch waveroot
        write(6,*)
     &    '*** Error in HBOOK2M: Identifier ', id, ' exceeds 249999 ***'
        stop
      endif
+self.

+self,if=debug.
      write(6,*)' '
      write(6,*)'id:',id
      write(6,*)' '
+self.
+self,if=-nohbook.
      if (iroottrees.ge.0) then
        call hbook2(id,ctitle,nxbins,xmin,xmax,nybins,ymin,ymax,vmx)
      endif
+self.
+self,if=mshhbook.
        call msh_hbook2(int8(id),ctitle,int8(nxbins),
     &    dble(xmin),dble(xmax),int8(nybins),dble(ymin),dble(ymax),dble(vmx))
+self.

+self,if=mhbook.
        call mh_book2(id,ctitle,nxbins,dble(xmin),dble(xmax),
     &    nybins,dble(ymin),dble(ymax))
+self.

+self,if=-noroot.
      if (iroottrees.ne.0) then
        cname=''
        write(cname2,'(i6)')id
        k=1
        cname(k:k)='h'
        do i=1,len_trim(cname2)
          c1=cname2(i:i)
          if (c1.ne.' ') then
            k=k+1
            cname(k:k)=c1
          endif
        enddo
        k=len_trim(cname)+1
        cname(k:k)=''
        call hbook2cc(id,cname,ctitle,
     &    nxbins,dble(xmin),dble(xmax),
     &    nybins,dble(ymin),dble(ymax))
      endif
+self.,if=-noroot.

+self,if=debug.
      write(6,*)' '
      write(6,*)'Debug: Leaving HBOOK1M'
      write(6,*)' '
+self.

      return
      end
+DECK,hdeletm.
*CMZ :  4.00/14 22/12/2021  13.41.56  by  Michael Scheer
*CMZ :  4.00/13 20/12/2021  15.51.01  by  Michael Scheer
*CMZ :  3.03/04 27/10/2017  09.47.51  by  Michael Scheer
*CMZ :  3.02/00 01/09/2014  11.11.30  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  16.20.53  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  13.30.11  by  Michael Scheer
*-- Author :    Michael Scheer   19/01/2012
      subroutine hdeletm(id)
+seq,gplhint.

+seq,contrl.
+seq,rootc,if=-noroot.

      integer id,kind(32)

      if (iroottrees.ne.0) then
+self,if=-noroot.
        call hkindm(id,kind,' ')
        call hdeletcc(id,kind(1))
+self.,if=-noroot.
      endif

      if (iroottrees.ge.0) then
+self,if=-nohbook.
        call hdelet(id)
+self.
+self,if=mshhbook.
        call msh_hdelet(int8(id))
+self.
+self,if=mhbook.
        call mh_delete(id)
+self.
      endif

+self,if=-noroot.
      kindhis(id)=0
+self.
      return
      end
+DECK,hfillm.
*CMZ :  4.00/14 22/12/2021  13.41.56  by  Michael Scheer
*CMZ :  4.00/13 16/12/2021  12.18.27  by  Michael Scheer
*CMZ :  3.02/00 01/09/2014  11.11.30  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  16.20.53  by  Michael Scheer
*CMZ :  3.01/05 12/06/2014  11.20.34  by  Michael Scheer
*CMZ :  2.70/07 14/01/2013  16.55.40  by  Michael Scheer
*CMZ :  2.68/05 28/09/2012  09.17.41  by  Michael Scheer
*CMZ :  2.67/01 21/02/2012  10.32.09  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  12.51.13  by  Michael Scheer
*-- Author :    Michael Scheer   21/01/2012
      subroutine hfillm(id,x,y,w)
+seq,gplhint.

      implicit none

+seq,contrl.
+seq,uservar.
+seq,rootc,if=-noroot.

      integer id,idold
      real x,y
      double precision w

      data idold/-9999/

+self,if=-nohbook.
      if (iroottrees.ge.0) call hfill(id,x,y,sngl(w))
+self.,if=-nohbook.

      if (iroottrees.ne.0) then
+self,if=-noroot.
        call hfillcc(id,kindhis(id),dble(x),dble(y),w)
+self.,if=-noroot.
      endif

      idold=id

+self,if=mshhbook.
      call msh_hfill(int8(id),dble(x),dble(y),w)
+self.

+self,if=mhbook.
      call mh_hfill(id,dble(x),dble(y),w)
+self.

      return
      end
+DECK,hkindm.
*CMZ :  4.00/14 31/12/2021  10.47.16  by  Michael Scheer
*CMZ :  3.02/03 10/11/2014  11.44.31  by  Michael Scheer
*CMZ :  3.02/00 01/09/2014  11.11.30  by  Michael Scheer
*CMZ :  3.01/07 23/06/2014  16.20.53  by  Michael Scheer
*CMZ :  3.01/06 17/06/2014  16.39.04  by  Michael Scheer
*CMZ :  2.68/05 24/09/2012  11.16.28  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  13.23.56  by  Michael Scheer
*-- Author :    Michael Scheer   17/02/2012
      subroutine hkindm(id,kind4,chopt)
+seq,gplhint.

      implicit none

+seq,contrl.
+seq,rootc,if=-noroot.

      integer*8 kind8(32)
      integer id,kind4(32)
      character(*) chopt

      kind4=0

      if (chopt.eq.'A'.and.iroottrees.ge.0) then
+self,if=-nohbook.
        call hkind(id,kind,chopt)
+self.
+self,if=mshhbook.
        kind8=int8(kind4)
        call msh_hkind(int8(id),kind8,chopt)
        kind4=int(kind8)
+self.
+self,if=mhbook.
        call mh_kind(id,kind4)
+self.
+self,if=-noroot.
      else
        kind4(1)=kindhis(int8(id))
+self.
      endif

      return
      end
+DECK,hsumm.
*CMZ :  4.00/14 30/12/2021  11.32.48  by  Michael Scheer
*CMZ :  3.02/04 23/01/2015  16.45.17  by  Michael Scheer
*CMZ :  3.02/00 29/08/2014  17.01.38  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  15.16.50  by  Michael Scheer
*-- Author :    Michael Scheer   17/02/2012
+self,if=mhbook.
      function hsumm(id)

+seq,gplhint.
      implicit none
      double precision hsumm,hsum_mh
      integer id

      hsumm=hsum_mh(id)

      return
      end

+self,if=mshhbook.
      function hsumm(id)

+seq,gplhint.
      implicit none
      double precision hsumm,msh_hsum
      integer id

      hsumm=msh_hsum(int8(id))

      return
      end
+self,if=-mshhbook,if=-mhbook.
      function hsumm(id)

+seq,gplhint.
      implicit none
      double precision hsumcc
      real hsumm,hsum
      integer id

+seq,contrl.
+seq,rootc,if=-noroot.

      if (iroottrees.ge.0) then
        hsumm=hsum(id)
      else
        hsumm=hsumcc(id,kindhis(id))
      endif

      return
      end
+self.
+DECK,hmaxm.
*CMZ :  4.00/14 30/12/2021  09.55.35  by  Michael Scheer
*CMZ :  3.02/04 23/01/2015  16.45.12  by  Michael Scheer
*CMZ :  3.02/03 03/11/2014  13.44.23  by  Michael Scheer
*CMZ :  3.02/00 01/09/2014  11.11.30  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  15.17.15  by  Michael Scheer
*-- Author :    Michael Scheer   17/02/2012
+self,if=mhbook.
      function hmaxm(id)
+seq,gplhint.
      implicit none
      double precision hmaxm,hmax_mh
      integer id

      hmaxm=hmax_mh(id)

      return
      end
+self,if=mshhbook.
      function hmaxm(id)
+seq,gplhint.
      implicit none
      double precision hmaxcc,hmaxm,msh_hmax
      integer id

      hmaxm=msh_hmax(int8(id))

      return
      end
+self,if=-mshhbook,if=-mhbook.
      function hmaxm(id)
+seq,gplhint.
      implicit none
      double precision hmaxcc
      real hmaxm,hmax
      integer id

+seq,contrl.
+seq,rootc,if=-noroot.

      if (iroottrees.ge.0) then
        hmaxm=hmax(id)
      else
        hmaxm=hmaxcc(id,kindhis(id))
      endif

      return
      end
+self.
+DECK,hoperam.
*CMZ :  4.00/14 30/12/2021  10.08.13  by  Michael Scheer
*CMZ :  3.02/05 22/03/2015  18.54.38  by  Michael Scheer
*CMZ :  3.02/00 01/09/2014  11.11.30  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  15.54.08  by  Michael Scheer
*-- Author :    Michael Scheer   21/01/2012
      subroutine hoperam(id1,coperator,id2,id3,w1,w2)
+seq,gplhint.

      implicit none

+seq,contrl.
+seq,rootc,if=-noroot.

      integer id1,id2,id3
      real w1,w2
      character(*) coperator

+self,if=-nohbook.
      if (iroottrees.ge.0) then
        call hopera(id1,coperator,id2,id3,w1,w2)
      endif
+self.
+self,if=-noroot.
      if (iroottrees.ne.0) then
        if (kindhis(id1).eq.1.and.kindhis(id2).eq.1) then
          call hoperacc(id1,kindhis(id1),coperator,id2,id3,kindhis(id3),
     &      dble(w1),dble(w2))
          kindhis(id3)=1
          else if (kindhis(id1).eq.2.and.kindhis(id2).eq.2) then
            call hoperacc(id1,kindhis(id1),coperator,id2,id3,kindhis(id3),
     &      dble(w1),dble(w2))
            kindhis(id3)=2
        endif
      endif
+self.,if=-noroot.
+self,if=mshhbook.
      call msh_hopera(int8(id1),coperator,int8(id2),int8(id3),
     &  dble(w1),dble(w2))
+self.,if=mshhbook.
+self,if=mhbook.
      call mh_opera(id1,coperator,id2,id3,dble(w1),dble(w2))
+self.

      return
      end
+DECK,roottohdf5.
*CMZ :  2.67/02 30/04/2012  15.42.57  by  Michael Scheer
*-- Author :    Michael Scheer   30/04/2012
      subroutine roottoh5
+seq,gplhint.

      print*,' '
      call system('roottohdf5_main.exe wave.root wave.h5')

      return
      end
+DECK,photon.
*CMZ :  4.00/15 27/04/2022  08.13.49  by  Michael Scheer
*CMZ :  4.00/13 29/11/2021  14.07.42  by  Michael Scheer
*CMZ :  4.00/07 27/04/2020  16.44.15  by  Michael Scheer
*CMZ :  4.00/04 17/05/2019  14.17.20  by  Michael Scheer
*CMZ :  3.06/00 19/02/2019  11.42.27  by  Michael Scheer
*CMZ :  3.05/06 17/07/2018  11.13.08  by  Michael Scheer
*CMZ :  3.05/04 28/06/2018  09.36.14  by  Michael Scheer
*CMZ :  3.03/04 27/10/2017  18.09.30  by  Michael Scheer
*CMZ :  3.02/03 03/11/2014  12.13.38  by  Michael Scheer
*CMZ :  3.02/00 15/10/2014  09.27.04  by  Michael Scheer
*CMZ :  3.01/06 20/06/2014  16.46.42  by  Michael Scheer
*CMZ :  2.70/07 14/01/2013  13.39.56  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  12.47.54  by  Michael Scheer
*CMZ :  2.68/05 28/09/2012  12.38.24  by  Michael Scheer
*CMZ :  2.68/02 08/06/2012  09.54.11  by  Michael Scheer
*CMZ :  2.67/06 24/05/2012  14.15.39  by  Michael Scheer
*CMZ :  2.67/05 16/05/2012  14.19.25  by  Michael Scheer
*CMZ :  2.67/04 15/05/2012  11.27.15  by  Michael Scheer
*CMZ :  2.67/03 09/05/2012  16.24.45  by  Michael Scheer
*-- Author :    Michael Scheer   09/05/2012
      subroutine photon(x,y,z,veln,gamma,bx,by,bz,dgamma,dtim,mode)
+seq,gplhint.

      use wave_g1

      implicit none

      integer mode,ical,i,ncy,ieof,iwarn

      double precision x,y,z,veln(3),bmag(3),bx,by,bz,ebeam,elmom,gamma,
     &  bparn,bper(3),bpern,epho,eec,bpervn(3),
     &  dgamma,b2per,
     &  pdum,dtim,ec,photons,de,deecg1,eecg1,g1,yrnint10,sigv,dum

      real rnrn(2),hrndm1m,xran(1),rr(2)
      real*8 fill(100)
      double precision, dimension (:), allocatable ::
     &  xrn,yrn,yrnint,coef,work1,work2,work3,work4,
     &  coefpsi,eecpsilog,sigpsi,cylog

+seq,contrl.
+seq,photon.
+seq,ustep.
+seq,uservar.
+seq,phycon.

      data ical/0/,iwarn/0/,ncy/0/

      save

      sigv=0.0d0
      nbing1=max(nbing1,10)

      if (mode.eq.-1) then

        if (ical.eq.0) then

          if (iphmode.lt.0) then
            ncy=11 !27.4.2020
!            ncy=0
!            open(unit=99,file='wave_cy.dat',status='old')
!1           call util_skip_comment_end(99,ieof)
!            if (ieof.ne.0) goto 9
!            read(99,*,end=9) dum
!            ncy=ncy+1
!            goto 1
!9           rewind(99)
            allocate(coefpsi(max(nbing1,ncy)))
            allocate(eecpsilog(max(nbing1,ncy)))
            allocate(cylog(max(nbing1,ncy)))
            allocate(sigpsi(max(nbing1,ncy)))
            do i=1,ncy
!              call util_skip_comment_end(99,ieof)
!              read(99,*)
              eecpsilog(i)=eecpsilog1(i)
              sigpsi(i)=sigpsi1(i)
              cylog(i)=cylog1(i)
            enddo
            eecpsilog(1:ncy)=log(eecpsilog(1:ncy))
            cylog(1:ncy)=log(cylog(1:ncy)/1000.0d0) !mrad -> rad
!            close(99)
          endif !iphmode.lt.0

          qfrms=0.0d0
          qfmean=0.0d0
          nqfphotons=0

          if (ihisini_c.eq.0.and.ihphotons.ne.0) then
            ihisini_c=-2
            call hisini
          endif !ihisini_c

          write(lungfo,*)' '
          write(lungfo,*)'     Subroutine photon (quantum fluctuations):'
          write(lungfo,*)' '

          if (iphmode.eq.1) then
+self,if=-nohbook.
            call hbook1m(idg1,'G1/(E/Ec)',nbing1,0.0,sngl(eecmaxg1),0.)

            deecg1=eecmaxg1/nbing1
            eecg1=deecg1/2.0d0

            do i=1,nbing1
              call util_g1_static(eecg1,g1)
              call hfillm(idg1,sngl(eecg1),0.,g1/eecg1)
              eecg1=eecg1+deecg1
            enddo

            write(lungfo,*)'     iphmode=1: G1-Histogram used to generate photons'
            write(lungfo,*)'     (user seeds are ignored)'
            write(lungfo,*)' '

+self,if=nohbook.

            write(lungfo,*)
     &        '     *** Error in photon:'
            write(lungfo,*)
     &        '     *** IPHMODE=1 requires HBOOK package of CERN, which is'
            write(lungfo,*)
     &        '     *** not available in this version of WAVE'
            write(lungfo,*)
     &        '     --- Program WAVE aborted ---'
            write(6,*)
     &        '     *** Error in photon:'
            write(6,*)
     &        '     *** IPHMODE=1 requires HBOOK package of CERN, which is'
            write(6,*)
     &        '     *** not available in this version of WAVE'
            write(6,*)
     &        '     --- Program WAVE aborted ---'

            stop

+self.,if=-nohbook.

          else !iphmode

            write(lungfo,*)'      number of sampling bins (NBING1)',nbing1
            write(lungfo,*)
     &        '      max. photon energy normalized to characteristic energy (EECMAXG1):'
            write(lungfo,*)
     &        '      ',eecmaxg1
            write(lungfo,*)' '

            if (iphmode.lt.0) then
              write(lungfo,*)'     transversal momentum is taken into account'
              write(lungfo,*)' '
            endif

            if (nbing1.le.2) then
              write(6,*)'*** Error in photon: NBING1 must be greater then 1'
              write(lungfo,*)'*** Error in photon: NBING1 must be greater then 1'
              stop
            endif

            allocate(xrn(max(nbing1,ncy)))
            allocate(yrn(max(nbing1,ncy)))
            allocate(yrnint(max(nbing1,ncy)))
            allocate(coef(max(nbing1,ncy)))
            allocate(work1(max(nbing1,ncy)))
            allocate(work2(max(nbing1,ncy)))
            allocate(work3(max(nbing1,ncy)))
            allocate(work4(max(nbing1,ncy)))

            deecg1=eecmaxg1/(nbing1-1)

            eecg1=0.0d0
            do i=1,10
              eecg1=eecg1+deecg1/10.0d0
              call util_g1_static(eecg1,g1)
              xrn(i)=eecg1
              yrn(i)=g1/eecg1
            enddo

            yrnint(1)=0.0d0
            do i=2,10
              yrnint(i)=yrnint(i-1)+(yrn(i)+yrn(i-1))/2.0d0*(xrn(i)-xrn(i-1))
            enddo
            yrnint10=yrnint(10)

            eecg1=0.0d0
            do i=10,nbing1
              eecg1=eecg1+deecg1
              call util_g1_static(eecg1,g1)
              xrn(i)=eecg1
              yrn(i)=g1/eecg1
            enddo

            call util_spline_running_integral(
     &        xrn(10:nbing1),yrn(10:nbing1),nbing1-10+1,yrnint(10:nbing1),
     &        coef,work1,work2,work3,work4)

            yrnint(10)=yrnint10
            yrnint(11:nbing1)=yrnint(11:nbing1)+yrnint10
            yrnint=yrnint/yrnint(nbing1)

            do i=2,nbing1
              if (yrnint(i).le.yrnint(i-1)) then
                stop '*** Error in photon: Bad integration of G1 ***'
              endif
            enddo

            call util_spline_coef(
     &        yrnint,xrn,nbing1,0.0d0,0.0d0,
     &        coef,work1,work2,work3,work4)

            if (iphmode.lt.0) then
              call util_spline_coef(
     &          eecpsilog,cylog,ncy,0.0d0,0.0d0,
     &          coefpsi,work1,work2,work3,work4)
            endif

          endif !iphmode

          !dgamma=-pdum*gamma**2*b**2*dt
          pdum=cgam1/2.0d0/pi1*clight1*(clight1/1.0d9)**2*emassg1

          ical=1

        endif !ical

        bmag(1)=bx
        bmag(2)=by
        bmag(3)=bz

        elmom=emassg1*dsqrt((gamma-1.0d0)*(gamma+1.0d0)) !GeV
        ebeam=emassg1*gamma !GeV

        bparn=(bmag(1)*veln(1)+bmag(2)*veln(2)+bmag(3)*veln(3))
        bper=bmag-bparn*veln
        b2per=bper(1)**2+bper(2)**2+bper(3)**2
        bpern=sqrt(b2per)
        bpervn=bper/bpern

        ec=ecdipkev1*bpern*ebeam**2*1.0d-6 !GeV

        !dgamma = pdum * gamma**2 * b2per * dtim
        !dN = 15*sqrt(3)/8 * dE/Ec = 3.2476 * de/ec

        de=pdum*b2per*gamma*ebeam*dtim !GeV

        if (ec.ne.0.0d0) then
          photons=3.2476d0*de/ec !number of photons
        else
          photons=0.0d0
        endif

        call util_random(2,rnrn)  !S. 39

        if (photons.ge.1.0d0.and.iwarn.eq.0) then
          write(6,*)'*** Warning in PHOTON: Step size to large, ***'
          write(6,*)'*** i.e. probabilty to generate photon is greater than one! ***'
          write(6,*)'*** Check NLPOI ***'
          write(lungfo,*)'*** Warning in PHOTON: Step size to large, ***'
          write(lungfo,*)'*** i.e. probabilty to generate photon is greater than one! ***'
          write(lungfo,*)'*** Check NLPOI ***'
          iwarn=1
        endif

        if(rnrn(1).le.photons) then

          if (iphmode.eq.1) then
+self,if=-nohbook
            eec=hrndm1m(idg1) !changes histogram
+self.
          else !iphmode
            call util_spline_inter(yrnint,xrn,coef,nbing1,
     &        dble(rnrn(2)),eec,-1)
            if (eec.lt.0.0d0) then
              print*,'*** Warning in PHOTON: Negative photon energy occured ***'
              print*,'rnrn:',rnrn
              print*,'setting Epho/Ec = 1.e-6'
              eec=1.0d-6
            endif
            if (iphmode.lt.0) then
              call util_spline_inter(eecpsilog,cylog,coefpsi,ncy,log(eec),
     &          sigv,-1)
              sigv=0.408*exp(sigv)/ebeam !rad
              call util_random_gauss(1,xran,rr)
              sigv=xran(1)*sigv
            else
              sigv=0.0d0
            endif !iphmode
          endif !iphmode

          epho=eec*ec
          dgamma=-epho/ebeam*gamma
          dpphoton=-(veln+sigv*bpervn)*epho
c          dpphoton(2)=dpphoton(2)*1.0d10

          nqfphotons=nqfphotons+1
          qfmean=qfmean+epho
          qfrms=qfrms+epho**2

          if (ihphotons.ne.0) then
            fill(1)=nutrack
            fill(2)=nustep
            fill(3)=x
            fill(4)=y
            fill(5)=z
            fill(6)=elmom*veln(1)*1.0d9
            fill(7)=elmom*veln(2)*1.0d9
            fill(8)=elmom*veln(3)*1.0d9
            fill(9)=ebeam*1.0d9
            fill(10)=-dpphoton(1)*1.0d9
            fill(11)=-dpphoton(2)*1.0d9
            fill(12)=-dpphoton(3)*1.0d9
            fill(13)=epho*1.0d9 !eV
            fill(14)=ec*1.0d9 !eV
            call hfm(nidphotons,fill)
          endif
        else
          dpphoton=0.0d0
          dgamma=0.0d0
        endif !(rnrn.le.wrad)

      else !mode
        write(6,*)'*** Error in photon: Invalid mode:', mode,'  ***'
        stop
      endif !mode

      return
      end
+DECK,MSHSYNCSPEC.
*CMZ :  2.67/02 08/05/2012  12.08.50  by  Michael Scheer
*CMZ :  1.01/00 07/10/2004  09.04.51  by  Michael Scheer
*CMZ :  1.00/03 04/10/2004  15.59.52  by  Michael Scheer
*-- Author :    Michael Scheer   01/10/2004
      SUBROUTINE MSHSYNCSPEC(MODE,Y,PSI,WRAD_C)
+seq,gplhint.

C--- CALCULATE normalized DIPOL SPECTRUM (G1)

      IMPLICIT NONE

      EXTERNAL FUNCTION DBSKR3
      DOUBLE PRECISION Y,PSI,WRAD_C,PER,PAR,XI,XX,XX1,BK13,BK23,DBSKR3

      INTEGER MODE

      IF (Y.LE.0.D0) THEN
        STOP '*** Error:     E/Ec is zero in MSHSYNCSPEC'
      ENDIF

      IF (MODE.EQ.1) THEN

        XX=PSI**2
        XX1=XX+1.D0
        XI=Y*DSQRT(XX1)**3/2.D0
        BK13=DBSKR3(XI,1)
        BK23=DBSKR3(XI,2)

        PAR=(Y*XX1*BK23)**2
        PER=Y*Y*XX*XX1*BK13**2

        WRAD_C=PAR+PER

      ELSE IF (MODE.EQ.-1) THEN

C USE ANALYTICAL FIT TO G1

        IF(Y.LT.4.) THEN
          WRAD_C = 391.8 * Y**0.333 * EXP(-Y*0.8307)-
     &      192.0 * Y**0.500 * EXP(-Y*0.7880)
        ELSE
          WRAD_C = 164.0 * Y**0.500 * EXP(-Y)
        END IF

        wrad_c=wrad_c * 0.007565 ! anders als in geant3 wird hier G1 berechnet

      ELSE !MODE

        STOP '*** ERROR IN MSHSYNCSPEC'

      ENDIF !MODE

      RETURN
      END
+DECK,SYNCSPEC.
*CMZ :  2.68/05 06/09/2012  08.27.06  by  Michael Scheer
*CMZ :  2.67/04 15/05/2012  11.19.49  by  Michael Scheer
*CMZ :  2.67/02 08/05/2012  12.08.50  by  Michael Scheer
*CMZ :  1.01/00 07/10/2004  09.04.51  by  Michael Scheer
*CMZ :  1.00/03 04/10/2004  15.59.52  by  Michael Scheer
*-- Author :    Michael Scheer   01/10/2004
      SUBROUTINE SYNCSPEC(MODE,Y,PSI,WRAD_C)
+seq,gplhint.

C--- CALCULATE normalized DIPOL SPECTRUM (G1)

      IMPLICIT NONE

      EXTERNAL FUNCTION DBSKR3
      DOUBLE PRECISION Y,PSI,WRAD_C,PER,PAR,XI,XX,XX1,BK13,BK23,DBSKR3

      INTEGER MODE

      IF (Y.LE.0.D0) THEN
        STOP '*** Error:     E/Ec is zero in SYNCSPEC'
      ENDIF

      IF (MODE.EQ.1) THEN

        XX=PSI**2
        XX1=XX+1.D0
        XI=Y*DSQRT(XX1)**3/2.D0
        BK13=DBSKR3(XI,1)
        BK23=DBSKR3(XI,2)

        PAR=(Y*XX1*BK23)**2
        PER=Y*Y*XX*XX1*BK13**2

        WRAD_C=PAR+PER

      ELSE IF (MODE.EQ.-1) THEN

        call util_g1_static(y,wrad_c)

      ELSE !MODE

        STOP '*** ERROR IN SYNCSPEC'

      ENDIF !MODE

      RETURN
      END
+DECK,util_g1.
*CMZ :  4.00/04 17/05/2019  14.17.20  by  Michael Scheer
*CMZ :  3.03/02 19/11/2015  13.51.04  by  Michael Scheer
*CMZ :  3.02/05 27/03/2015  15.15.42  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  12.47.25  by  Michael Scheer
*CMZ :  2.67/04 15/05/2012  10.53.28  by  Michael Scheer
*-- Author :    Michael Scheer   10/05/2012
      subroutine util_g1(y,g1)
+seq,gplhint.

c calculates G1(y) with an estimated precision of about 1.5e-3 for y<=30,
c and 1.5e-2 for y>30.


      implicit none

      integer ical,npoi,ieof,ipoi,npoilow,npoihigh

      double precision y,g1,g1_30,c_30,g1_5em5,c_5em5,y_30,y_5em5,ydum,g1dum,r1

      double precision, dimension(:), allocatable ::
     &  ywlow,ywhigh,coeflow,coefhigh,
     &  g1wlow,g1whigh,g1walow,g1wahigh,r1low,r1high,
     &  w1,w2,w3,w4

      save

      data ical/0/
      data y_30/30.0d0/
      data y_5em5/5.0d-5/
      data g1_30/6.580794488121591d-013/ !WAVE
      data g1_5em5/7.909860755922665E-002/ !WAVE

      if (ical.eq.0) then

        c_5em5=g1_5em5/y_5em5**(1.0d0/3.0d0)
        c_30=g1_30/(sqrt(y_30)*exp(-y_30))

        npoi=0
        npoilow=0
        npoihigh=0

        open(unit=99,file='wave-g1.dat',status='old',err=9999)

1       call util_skip_comment_end(99,ieof)
        if (ieof.ne.0) goto 9
        read(99,*)ydum
        npoi=npoi+1
        if (ydum.ge.y_5em5.and.ydum.le.4.0d0) then !zwei Abfragen wegen 4.0
          npoilow=npoilow+1
        endif
        if (ydum.ge.4.0d0.and.ydum.le.y_30) then
          npoihigh=npoihigh+1
        endif
        goto 1

9       rewind(99)

        allocate(ywlow(npoilow))
        allocate(g1wlow(npoilow))
        allocate(g1walow(npoilow))
        allocate(r1low(npoilow))
        allocate(ywhigh(npoihigh))
        allocate(g1whigh(npoihigh))
        allocate(g1wahigh(npoihigh))
        allocate(r1high(npoihigh))
        allocate(coeflow(npoilow))
        allocate(coefhigh(npoihigh))
        allocate(w1(max(npoilow,npoihigh)))
        allocate(w2(max(npoilow,npoihigh)))
        allocate(w3(max(npoilow,npoihigh)))
        allocate(w4(max(npoilow,npoihigh)))

        npoilow=0
        npoihigh=0
        do ipoi=1,npoi
          call util_skip_comment_end(99,ieof)
          read(99,*)ydum,g1dum
          if (ydum.ge.y_5em5.and.ydum.le.4.0d0) then
            npoilow=npoilow+1
            ywlow(npoilow)=ydum
            g1wlow(npoilow)=g1dum
            g1walow(npoilow)=
     &        391.8d0 * ydum**(1.0d0/3.0d0) * exp(-ydum*0.8307d0)
     &        -192.0d0 * sqrt(ydum) * exp(-ydum*0.7880d0)
          endif
          if (ydum.ge.4.0d0.and.ydum.le.y_30) then
            npoihigh=npoihigh+1
            ywhigh(npoihigh)=ydum
            g1whigh(npoihigh)=g1dum
            g1wahigh(npoihigh)=164.0d0*sqrt(ydum)* EXP(-ydum)
          endif
        enddo
        close(99)

        r1low(1:npoilow)=g1wlow(1:npoilow)/g1walow(1:npoilow)
        r1high(1:npoihigh)=g1whigh(1:npoihigh)/g1wahigh(1:npoihigh)

        call util_spline_coef(ywlow,r1low,npoilow,0.0d0,0.0d0,coeflow,
     &    w1,w2,w3,w4)
        call util_spline_coef(ywhigh,r1high,npoihigh,0.0d0,0.0d0,
     &    coefhigh,w1,w2,w3,w4)

        ical=1
      endif

      if (y.le.5.0d-5) then
        g1=c_5em5*y**(1.0d0/3.0d0)
      else if (y.ge.30.0d0) then
        g1=c_30*sqrt(y)*exp(-y)
      else

        if (y.ge.y_5em5.and.y.lt.4.0d0) then
          call util_spline_inter(ywlow,r1low,coeflow,npoilow,y,r1,-1)
          g1=r1*(
     &      391.8d0 * y**(1.0d0/3.0d0) * exp(-y*0.8307d0)
     &      -192.0d0 * sqrt(y) * exp(-y*0.7880d0))
        else if (y.ge.4.0d0.and.y.le.y_30) then
          call util_spline_inter(
     &      ywhigh,r1high,coefhigh,npoihigh,y,r1,-1)
          g1=r1*(164.0d0*sqrt(y)* EXP(-y))
        endif

      endif

+self,if=old.

      integer i,nbinp
      parameter (nbinp=2000)
      double precision y,yy,g1,ymax,dy,yymax,
     &  besk(nbinp),buff(nbinp),coef(nbinp),
     &  w1(nbinp),
     &  w2(nbinp),
     &  w3(nbinp),
     &  w4(nbinp)

      data ymax/2.0d0/

      g1=0.0d0
      yy=y
      yymax=ymax*abs(log10(y))
      print*,'yymax:',yymax

      dy=(yymax-y)/nbinp

      i=0
      do while (yy.le.yymax.and.i.lt.nbinp-1)
        i=i+1
        buff(i)=yy
        call util_mod_bessel(5.0d0/3.0d0,yy,besk(i))
        print*,yy,besk(i)
        yy=yy+dy
      enddo

      call util_spline_integral(buff,besk,i,g1,coef,w1,w2,w3,w4)
      g1=y*g1

+self.
      return
9999  stop '*** File wave-g1.dat not found ***'
      end
+DECK,pinin3.
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.68/05 17/09/2012  12.26.08  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  15.19.07  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE PININ3
+seq,gplhint.

+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,WFOLDF90U.

C--- INITIALIZE GRID OF OBERSERVATION POINTS OF PINHOLE for ipin.eq.3

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEq,observf90.
+SEQ,DEPOLA.
+SEq,wfoldf90.
+seq,sourcef90.

      if (ipin.ne.3) stop '*** ERROR IN PININ3: IPIN.NE.3'

      IF (IPINCIRC.NE.0) THEN
        PINW=2.D0*PINR
        PINH=2.D0*PINR
      ENDIF !IPINCIRC

      IF (OBSVDZ.NE.0.D0) THEN
        MPINZ=NINT(PINW/OBSVDZ)+1
        PINW=OBSVDZ*(MPINZ-1)
      ENDIF !(OBSVDZ.NE.0.D0)

      IF (OBSVDY.NE.0.D0) THEN
        MPINY=NINT(PINH/OBSVDY)+1
        PINH=OBSVDY*(MPINY-1)
      ENDIF !(OBSVDZ.NE.0.D0)

      mpinzorig=mpinz
      mpinyorig=mpiny

      IF (PINCEN(2).EQ.9999.) THEN
        IF     (IPBRILL.EQ.0) THEN
          PINCEN(2)=0.0
        ELSE IF (IPBRILL.EQ.1) THEN
          PINCEN(2)=PINH/2.D0
        ELSE IF (IPBRILL.EQ.2) THEN
          PINCEN(2)=PINH/2.D0
        ELSE IF (IPBRILL.EQ.3) THEN
          PINCEN(2)=-PINH/2.D0
        ELSE IF (IPBRILL.EQ.4) THEN
          PINCEN(2)=-PINH/2.D0
        ENDIF !IPBRILL
      ELSE IF (PINCEN(2).EQ.-9999.) THEN
        PINCEN(2)=YSTART+VYIN/VXIN*(PINCEN(1)-XSTART)
      ENDIF !PINCEN(2)

      IF (PINCEN(3).EQ.9999.) THEN
        IF     (IPBRILL.EQ.0) THEN
          PINCEN(3)=0.0
        ELSE IF (IPBRILL.EQ.1) THEN
          PINCEN(3)=PINW/2.D0
        ELSE IF (IPBRILL.EQ.2) THEN
          PINCEN(3)=-PINW/2.D0
        ELSE IF (IPBRILL.EQ.3) THEN
          PINCEN(3)=-PINW/2.D0
        ELSE IF (IPBRILL.EQ.4) THEN
          PINCEN(3)=PINW/2.D0
        ENDIF !IPBRILL
      ELSE IF (PINCEN(3).EQ.-9999.) THEN
        PINCEN(3)=ZSTART+VZIN/VXIN*(PINCEN(1)-XSTART)
      ENDIF !PINCEN(3)

      IF(NDOBSVZ*NDOBSVY.NE.NDOBSV) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*) '*** ERROR IN PININ ***'
        WRITE(LUNGFO,*) 'DIMENSION DECLARATIONS NOT CONSISTENT'
        WRITE(LUNGFO,*) 'NDOBSV MUST BE EQUAL TO NDOBSVZ*NDOBSVY'
        WRITE(LUNGFO,*) 'CHANGE PARAMETER IN CMPARA.CMN'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED  ***'
        WRITE(6,*)
        WRITE(6,*) '*** ERROR IN PININ ***'
        WRITE(6,*) 'DIMENSION DECLARATIONS NOT CONSISTENT'
        WRITE(6,*) 'NDOBSV MUST BE EQUAL TO NDOBSVZ*NDOBSVY'
        WRITE(6,*) 'CHANGE PARAMETER IN CMPARA.CMN'
        WRITE(6,*)
        WRITE(6,*)'*** PROGRAM WAVE ABORTED  ***'
        STOP
      ENDIF

      IF (IF1DIM.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN PININ3 ***'
        WRITE(LUNGFO,*)'FLAG IF1DIM SET BUT IPIN =3'
        WRITE(LUNGFO,*)'IF1DIM SET TO ZERO'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN PININ3 ***'
        WRITE(6,*)'FLAG IF1DIM SET BUT IPIN =3'
        WRITE(6,*)'IF1DIM SET TO ZERO'
        WRITE(6,*)
        IF1DIM=0
      ENDIF

      IF (mpinr.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN PININ3 ***'
        WRITE(LUNGFO,*)'FLAG MPINR SET BUT IPIN=3'
        WRITE(LUNGFO,*)'MPINR SET TO ZERO'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN PININ3 ***'
        WRITE(6,*)'FLAG MPINR SET BUT IPIN=3'
        WRITE(6,*)'MPINR SET TO ZERO'
        WRITE(6,*)
        MPINR=0
      ENDIF

C- DETERMINE RMS VALUES FOR FOLDING

      if (iemit.ne.0) CALL WSIGFOL

      IF (IFOLD.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN PININ3 ***'
        WRITE(LUNGFO,*)'FLAG IFOLD SET BUT IPIN=3'
        WRITE(LUNGFO,*)'IFOLD SET TO ZERO'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN PININ3 ***'
        WRITE(6,*)'FLAG IFOLD SET BUT IPIN=3'
        WRITE(6,*)'IFOLD SET TO ZERO'
        WRITE(6,*)
      ENDIF

      IF (IEFOLD.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN PININ3 ***'
        WRITE(LUNGFO,*)'FLAG IEFOLD SET BUT IPIN=3'
        WRITE(LUNGFO,*)'IEFOLD SET TO ZERO'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN PININ3 ***'
        WRITE(6,*)'FLAG IEFOLD SET BUT IPIN=3'
        WRITE(6,*)'IEFOLD SET TO ZERO'
        WRITE(6,*)
      ENDIF

      ifold=0
      iefold=0

      mpiny=1
      mpinz=1

      ihpin=0
      ihfold=0

      nobsv=1
      mobsv=1
      nobsvz=1
      nobsvy=1
      mobsvy=1
      mobsvz=1

      ipbrill=1
      icbrill=1

      obsv(1,1)=obs1x
      obsv(2,1)=obs1y
      obsv(3,1)=obs1z

      obsvy(1)=obs1y
      obsvz(1)=obs1z

      if (ihisini_c.ne.0) call hisini3

      RETURN
      END
+DECK,hfreq3.
*CMZ :  4.01/05 18/04/2024  13.59.40  by  Michael Scheer
*CMZ :  4.00/15 07/04/2022  07.14.03  by  Michael Scheer
*CMZ :  4.00/14 30/12/2021  15.41.22  by  Michael Scheer
*CMZ :  4.00/13 07/12/2021  18.47.10  by  Michael Scheer
*CMZ :  3.03/02 07/12/2015  17.18.10  by  Michael Scheer
*CMZ :  3.02/06 17/04/2015  16.27.01  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.13.36  by  Michael Scheer
*CMZ :  2.70/11 18/02/2013  16.49.40  by  Michael Scheer
*CMZ :  2.68/05 28/09/2012  12.17.08  by  Michael Scheer
*CMZ :  2.68/01 29/05/2012  16.50.03  by  Michael Scheer
*-- Author :    Michael Scheer   29/05/2012
      subroutine hfreq3
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.

      implicit none

+SEQ,CMPARA.
+SEQ,CONTRL.
+seq,whbook.
+seq,pawcmn.

+SEQ,SPECT.
+SEQ,FREQS.
+SEq,observf90.
+seq,sourcef90.
+SEQ,SPECDIP.
+SEq,phasef90.
+SEQ,AMPLI.
+SEQ,MYFILES.
+SEQ,PHYCON.

      integer ifreq,id,icycle,mfreq
      real df,flow,fhig,ff
      real*8 fstuple(5)

      if (ipin.ne.3) return

      df=freq(2)-freq(1)
      flow=freq(1)-df/2.
      fhig=freq(nfreq)+df/2.

      if (ifreq2p.eq.1.or.freqlow.eq.freqhig) then
          DF=freqhig-freqlow
          FLOW=freqlow-DF/2.
          FHIG=freqlow+DF/2.
      else if (ifreq2p.eq.-1) then
        DF=freqhig-freqlow
        ff=(freqlow+freqhig)/2.
        FLOW=ff-DF/2.
        FHIG=ff+DF/2.
      endif

      if (flow.lt.0.) then
        write(lungfo,*)
        write(lungfo,*)'*** WARNING IN HFREQ3 ***'
        write(lungfo,*)'LOW EDGE OF HISTOGRAM NEGATIVE'
        write(lungfo,*)'BE CAREFUL IF X-AXIS IS PLOTTED WITH LOGARITHMIC SCALE'
        write(lungfo,*)
      endif

      id=icfreq
      mfreq=nint((fhig-flow)/df)
      call hbook1m(id,'Mean flux-density in pinhole x 1.e-6',
     &  mfreq,flow,fhig,vmx)
      do ifreq=1,nfreq,ihfreq
        call hfillm(id,sngl(freq(ifreq)),0.,spectot(ifreq)*1.0d-6)
      enddo   !nfreq
      call mhrout(id,icycle,' ')

      id=idfreq
      mfreq=nint((fhig-flow)/df)
      call hbook1m(id,'Photon flux through pinhole',
     &  mfreq,flow,fhig,vmx)
      do ifreq=1,nfreq,ihfreq
        call hfillm(id,sngl(freq(ifreq)),0.,wfluxt(ifreq))
      enddo   !nfreq
      call mhrout(id,icycle,' ')

      do ifreq=1,nfreq
        fstuple(1)=freq(ifreq)
        fstuple(2)=wfluxt(ifreq)
        call hfm(nidfreqp,fstuple)
      enddo   !nfreq

      if (istokes.ne.0) then

        id=icfrs0
        mfreq=nint((fhig-flow)/df)
        call hbook1m(id,'Mean flux-density S0 through pinhole x 1.e-6',
     &    mfreq,flow,fhig,vmx)
        do ifreq=1,nfreq,ihfreq
          call hfillm(id,sngl(freq(ifreq)),0.,dble(stokes(1,ifreq))*1.0d-6)
        enddo   !nfreq
        call mhrout(id,icycle,' ')

        id=icfrs1
        mfreq=nint((fhig-flow)/df)
        call hbook1m(id,'Mean flux-density S1 through pinhole x 1.e-6',
     &    mfreq,flow,fhig,vmx)
        do ifreq=1,nfreq,ihfreq
          call hfillm(id,sngl(freq(ifreq)),0.,dble(stokes(2,ifreq))*1.0d-6)
        enddo   !nfreq
        call mhrout(id,icycle,' ')

        call mhrout(id,icycle,' ')
        id=icfrs2
        mfreq=nint((fhig-flow)/df)
        call hbook1m(id,'Mean flux-density S2 through pinhole x 1.e-6',
     &    mfreq,flow,fhig,vmx)
        do ifreq=1,nfreq,ihfreq
          call hfillm(id,sngl(freq(ifreq)),0.,dble(stokes(3,ifreq))*1.0d-6)
        enddo   !nfreq
        call mhrout(id,icycle,' ')

        call mhrout(id,icycle,' ')
        id=icfrs3
        mfreq=nint((fhig-flow)/df)
        call hbook1m(id,'Mean flux-density S3 through pinhole x 1.e-6',
     &    mfreq,flow,fhig,vmx)
        do ifreq=1,nfreq,ihfreq
          call hfillm(id,sngl(freq(ifreq)),0.,dble(stokes(4,ifreq))*1.0d-6)
        enddo   !nfreq
        call mhrout(id,icycle,' ')

        id=idfrs0
        mfreq=nint((fhig-flow)/df)
        call hbook1m(id,'Flux S0 through pinhole',
     &    mfreq,flow,fhig,vmx)
        do ifreq=1,nfreq,ihfreq
          call hfillm(id,sngl(freq(ifreq)),0.,dble(wstokes(1,ifreq)))
        enddo   !nfreq
        call mhrout(id,icycle,' ')

        id=idfrs1
        mfreq=nint((fhig-flow)/df)
        call hbook1m(id,'Flux S1 through pinhole',
     &    mfreq,flow,fhig,vmx)
        do ifreq=1,nfreq,ihfreq
          call hfillm(id,sngl(freq(ifreq)),0.,dble(wstokes(2,ifreq)))
        enddo   !nfreq
        call mhrout(id,icycle,' ')

        call mhrout(id,icycle,' ')
        id=idfrs2
        mfreq=nint((fhig-flow)/df)
        call hbook1m(id,'Flux S2 through pinhole',
     &    mfreq,flow,fhig,vmx)
        do ifreq=1,nfreq,ihfreq
          call hfillm(id,sngl(freq(ifreq)),0.,dble(wstokes(3,ifreq)))
        enddo   !nfreq
        call mhrout(id,icycle,' ')

        call mhrout(id,icycle,' ')
        id=idfrs3
        mfreq=nint((fhig-flow)/df)
        call hbook1m(id,'Flux S3 through pinhole',
     &    mfreq,flow,fhig,vmx)
        do ifreq=1,nfreq,ihfreq
          call hfillm(id,sngl(freq(ifreq)),0.,dble(wstokes(4,ifreq)))
        enddo   !nfreq
        call mhrout(id,icycle,' ')

        do ifreq=1,nfreq
          fstuple(1)=freq(ifreq)
          fstuple(2)=wstokes(1,ifreq)
          fstuple(3)=wstokes(2,ifreq)
          fstuple(4)=wstokes(3,ifreq)
          fstuple(5)=wstokes(4,ifreq)
          call hfm(4600,fstuple)
        enddo   !nfreq
      endif !istokes

      return
      end
+DECK,bmap,T=F77.
*CMZ :  4.00/16 09/08/2022  09.07.08  by  Michael Scheer
*CMZ :  4.00/07 07/06/2020  15.15.28  by  Michael Scheer
*CMZ :  3.05/05 13/07/2018  11.51.31  by  Michael Scheer
*CMZ :  3.03/04 29/11/2017  10.21.49  by  Michael Scheer
*CMZ :  3.02/00 10/09/2014  14.10.09  by  Michael Scheer
*CMZ :  3.01/04 26/05/2014  16.15.21  by  Michael Scheer
*CMZ :  3.01/00 06/05/2013  09.13.42  by  Michael Scheer
*CMZ :  2.68/05 01/10/2012  14.11.38  by  Michael Scheer
*CMZ :  2.68/04 04/09/2012  09.22.40  by  Michael Scheer
*CMZ :  2.68/03 31/08/2012  09.01.42  by  Michael Scheer
*CMZ :  2.68/02 02/07/2012  13.51.47  by  Michael Scheer
*-- Author :    Michael Scheer   18/06/2012
C**********************************************************************
      subroutine bmap(xin,yin,zin,bxout,byout,bzout)
C**********************************************************************
+seq,gplhint.

      implicit none

+seq,contrl.
+seq,bmessf90.
+seq,myfiles.

      double precision, dimension (:,:), allocatable :: bmappe

      double precision xin,yin,zin,x,y,z,bx,by,bz,step,stepy,xold,yold,
     &  bxout,byout,bzout,
c     &  bmxmin,bmxmax,bmymin,bmymax,bmzmin,bmzmax,
c     &  bmbxmin,bmbxmax,bmbymin,bmbymax,bmbzmin,bmbzmax,
     &  offsetx,offsety,offsetz,offsetbx,offsetby,offsetbz,
     &  scalex,scaley,scalez,scalebx,scaleby,scalebz,
     &  bmapdy,bmapdz,x1,x2,a3(3),x3(3),b3(3),
     &  b11,b12,b13,b21,b22,b23,b31,b32,b33,bb1,bb2,bb3,dy,dz

      double precision b111(3),b211(3), b121(3),b221(3)
      double precision b112(3),b212(3), b122(3),b222(3)
      double precision b112111(3),b212211(3), b122121(3),b222221(3)
      double precision blow(3),bhig(3),b(3),dxx,dyy,dzz,xx,yy,zz,y1,z1

      real*8 :: eps=1.0d-6

      integer ical,iwarnx,iwarny,iwarnz,nx,ny,nz,last,ntot,ianf,
     &  kd,ix1,ix2,iy1,iy2,iz1,iz2,nyz,i,k,
     &  kx1,kx2,kx3,ky1,ky2,ky3,kz1,kz2,kz3

      character(2048) cline

      data ical/0/
      data iwarnx/0/
      data iwarny/0/
      data iwarnz/0/
      data scalex,scaley,scalez/1.0d0,1.0d0,1.0d0/
      data scalebx,scaleby,scalebz/1.0d0,1.0d0,1.0d0/
      data xold/1.0d30/
      data yold/1.0d30/

      save

      iwarnbmap=0

      if (ical.eq.0) then

        write(lungfo,*)
        write(lungfo,*)'      Subroutine BMAP:'
        write(lungfo,*)
        write(lungfo,*)'      Reading file'
        write(lungfo,*)'      ',fileb0
        write(lungfo,*)

        bmxmin= 1.0d99
        bmxmax=-1.0d99
        bmymin= 1.0d99
        bmymax=-1.0d99
        bmzmin= 1.0d99
        bmzmax=-1.0d99

        bmbxmin= 1.0d99
        bmbxmax=-1.0d99
        bmbymin= 1.0d99
        bmbymax=-1.0d99
        bmbzmin= 1.0d99
        bmbzmax=-1.0d99

        offsetx=0.0d0
        offsety=0.0d0
        offsetz=0.0d0

        open(unit=lunb0,file=fileb0,status='old')
        ntot=0
        nx=-1
        ny=-1
        nz=0
 1      read(lunb0,'(a)',end=9) cline
        last=len_trim(cline)

        if (last.le.1.or.
     &      cline(1:1).eq.'%'.or.
     &      cline(1:1).eq.'!'.or.
     &      cline(1:1).eq.'#'.or.
     &      cline(1:1).eq.'*'.or.
     &      cline(1:1).eq.'@'.or.
     &      cline(1:2).eq.' %'.or.
     &      cline(1:2).eq.' !'.or.
     &      cline(1:2).eq.' #'.or.
     &      cline(1:2).eq.' *'.or.
     &      cline(1:2).eq.' @'
     &      ) then

          write(lungfo,*) cline(1:last)

          ianf=index(cline,"scaling")
          if (ianf.gt.0) then
            ianf=index(cline,"=")
            read(cline(ianf+1:last),*)scalex,scaley,scalez,
     &        scalebx,scaleby,scalebz
          endif

          ianf=index(cline,"offset")
          if (ianf.gt.0) then
            ianf=index(cline,"=")
            read(cline(ianf+1:last),*)offsetx,offsety,offsetz,
     &        offsetbx,offsetby,offsetbz
          endif

        else

          ntot=ntot+1
          read(cline(1:last),*)x,y,z,bx,by,bz

          x=x*scalex+offsetx
          y=y*scaley+offsety
          z=z*scalez+offsetz
          bx=bx*scalebx+offsetbx
          by=by*scaleby+offsetby
          bz=bz*scalebz+offsetbz

          if (x.lt.bmxmin) bmxmin=x
          if (x.gt.bmxmax) bmxmax=x
          if (y.lt.bmymin) bmymin=y
          if (y.gt.bmymax) bmymax=y
          if (z.lt.bmzmin) bmzmin=z
          if (z.gt.bmzmax) bmzmax=z
          if (bx.lt.bmbxmin) bmbxmin=bx
          if (bx.gt.bmbxmax) bmbxmax=bx
          if (by.lt.bmbymin) bmbymin=by
          if (by.gt.bmbymax) bmbymax=by
          if (bz.lt.bmbzmin) bmbzmin=bz
          if (bz.gt.bmbzmax) bmbzmax=bz

          if (ntot.eq.1) then
            xold=x
            yold=y
          endif

          if (ntot.eq.2.and.abs(x-xold).gt.eps) then
            write(6,*)'*** Error in BMAP: Bad file format! ***'
            write(6,*)'*** x must run latest! ***'
            write(lungfo,*)'*** Error in BMAP: Bad file format! ***'
            write(lungfo,*)'*** x must run latest! ***'
            stop '*** WAVE aborted ***'
          endif

          if (nx.eq.-1) then
            if (ny.eq.-1) then
              if (abs(y-yold).le.eps) then
                nz=nz+1
              else
                ny=nz+1
              endif
            else if (abs(x-xold).le.eps) then
              ny=ny+1
            else
              ny=ny/nz
              nx=0
            endif !ny
          endif !nx

        endif !line type

        goto 1
 9      rewind(lunb0)

        nx=ntot/(ny*nz)

        if (nx.lt.2.and.irfilb0.eq.6.or.nx.lt.3.and.irfilb0.eq.-6) then
          write(lungfo,*)'*** Error in BMAP: Too few data for field map on'
          write(lungfo,*)fileb0
          write(lungfo,*)'*** Program WAVE aborted ***'
          write(6,*)'*** Error in BMAP: Too few data for field map on'
          write(6,*)fileb0
          write(6,*)'*** Program WAVE aborted ***'
          stop
        else
          allocate(bmappe(6,ntot))
        endif

        ntot=0
 11     read(lunb0,'(a)',end=99) cline

        last=len_trim(cline)

        if (last.le.1.or.
     &      cline(1:1).eq.'%'.or.
     &      cline(1:1).eq.'!'.or.
     &      cline(1:1).eq.'#'.or.
     &      cline(1:1).eq.'*'.or.
     &      cline(1:1).eq.'@'.or.
     &      cline(1:2).eq.' %'.or.
     &      cline(1:2).eq.' !'.or.
     &      cline(1:2).eq.' #'.or.
     &      cline(1:2).eq.' *'.or.
     &      cline(1:2).eq.' @'
     &      ) then
        else
          ntot=ntot+1
          read(cline(1:last),*) x,y,z,bx,by,bz
          x=x*scalex+offsetx
          y=y*scaley+offsety
          z=z*scalez+offsetz
          bx=bx*scalebx+offsetbx
          by=by*scaleby+offsetby
          bz=bz*scalebz+offsetbz
          bmappe(1,ntot)=x
          bmappe(2,ntot)=y
          bmappe(3,ntot)=z
          bmappe(4,ntot)=bx
          bmappe(5,ntot)=by
          bmappe(6,ntot)=bz
        endif
        goto 11
 99     close(lunb0)

        step=1.0d0/myinum
        stepy=step/10.0d0
        bmapdy=1.0d0
        if (ny.gt.1) bmapdy=(bmymax-bmymin)/(ny-1)
        bmapdz=1.0d0
        if (nz.gt.1) bmapdz=(bmzmax-bmzmin)/(nz-1)

        ix1=1
        ix2=ntot
        nyz=ny*nz

        write(lungfo,*)
        write(lungfo,*)' nx, ny, nz, and number of data lines:',
     &    nx,ny,nz,ntot
        write(lungfo,*)' xmin, xmax                   :',sngl(bmxmin),sngl(bmxmax)
        write(lungfo,*)' ymin, ymax , step size of map:',sngl(bmymin),sngl(bmymax),sngl(bmapdy)
        write(lungfo,*)' zmin, zmax , step size of map:',sngl(bmzmin),sngl(bmzmax),sngl(bmapdz)
        write(lungfo,*)' Bxmin, Bxmax of map:',sngl(bmbxmin),sngl(bmbxmax)
        write(lungfo,*)' Bymin, Bymax of map:',sngl(bmbymin),sngl(bmbymax)
        write(lungfo,*)' Bzmin, Bzmax of map:',sngl(bmbzmin),sngl(bmbzmax)
        write(lungfo,*)

        ical=1
      endif

      if (bxout.eq.-9999.0d0) then
        xin=bmxmin
        return
      else if (bxout.eq.9999.0d0) then
        xin=bmxmax
        return
      endif

      x=xin
      y=yin
      z=zin

      IF (IWARNX.EQ.0.AND.(X.LT.BMXMIN-STEP.OR.X.GT.BMXMAX+STEP)) THEN
        WRITE(6,*)'*** WARNING: IN BMAP: X OUT OF RANGE'
        WRITE(6,*)'X:',X
        WRITE(6,*)'Y:',Y
        WRITE(6,*)'Z:',Z
        WRITE(LUNGFO,*)'*** WARNING IN BMAP: X OUT OF RANGE'
        WRITE(LUNGFO,*)'X:',X
        WRITE(LUNGFO,*)'Y:',Y
        WRITE(LUNGFO,*)'Z:',Z
        IWARNX=1
      ENDIF

      IF (IWARNX.NE.0.AND.(X.LT.BMXMIN-STEP.OR.X.GT.BMXMAX+STEP)) THEN
        BXOUT=0.0D0
        BYOUT=0.0D0
        BZOUT=0.0D0
        iwarnbmap=1
        RETURN
      ENDIF

      IF (ny.gt.1.and.(Y.LT.BMYMIN-STEPy.OR.Y.GT.BMYMAX+STEPy)) THEN
        if (iwarny.eq.0) then
          WRITE(6,*)'*** ERROR IN BMAP: Y OUT OF RANGE'
          WRITE(6,*)'X:',X
          WRITE(6,*)'Y:',Y
          WRITE(6,*)'Z:',Z
          WRITE(LUNGFO,*)'*** ERROR IN BMAP: Y OUT OF RANGE'
          WRITE(LUNGFO,*)'X:',X
          WRITE(LUNGFO,*)'Y:',Y
          WRITE(LUNGFO,*)'Z:',Z
          iwarny=1
        endif
        BXOUT=0.0D0
        BYOUT=0.0D0
        BZOUT=0.0D0
        iwarnbmap=1
        RETURN
c        STOP
      ENDIF

      IF (nz.gt.1.and.(Z.LT.BMZMIN-STEP.OR.Z.GT.BMZMAX+STEP)) THEN
        if (iwarnz.eq.0) then
          WRITE(6,*)'*** ERROR IN BMAP: Z OUT OF RANGE'
          WRITE(6,*)'X:',X
          WRITE(6,*)'Y:',Y
          WRITE(6,*)'Z:',Z
          WRITE(LUNGFO,*)'*** ERROR IN BMAP: Z OUT OF RANGE'
          WRITE(LUNGFO,*)'X:',X
          WRITE(LUNGFO,*)'Y:',Y
          WRITE(LUNGFO,*)'Z:',Z
          iwarnz=1
        endif
        BXOUT=0.0D0
        BYOUT=0.0D0
        BZOUT=0.0D0
        iwarnbmap=1
        RETURN
c        STOP
      ENDIF

      if (x.lt.bmxmin) then
        ix1=1
        ix2=2
      else if (x.gt.bmxmax) then
        ix1=nx-1
        ix2=nx
      else

        if (x.ge.bmappe(1,(ix1-1)*nyz+1)) then
c hunt up
          kd=1
111       ix2=min(ix1+kd,nx)
          if (x.gt.bmappe(1,nyz*(ix2-1)+1)) then
            kd=2*kd
            ix1=ix2
            goto 111
          endif
        else    !(x.ge.bmappe(1,ix1))
c hunt down
          kd=1
          ix2=ix1
22        ix1=max(ix2-kd,1)
          if (x.lt.bmappe(1,(ix1-1)*nyz+1)) then
            kd=2*kd
            ix2=ix1
            goto 22
          endif
        endif

1111    if (ix2-ix1.gt.1) then
          k=(ix2+ix1)/2
          if(bmappe(1,(k-1)*nyz+1).gt.x)then
            ix2=k
          else
            ix1=k
          endif
          goto 1111
        endif
      endif

      x1=bmappe(1,(ix1-1)*nyz+1)
      x2=bmappe(1,(ix2-1)*nyz+1)
      dxx=(x-x1)/(x2-x1)

      if (ny.gt.1) then
        if (y.lt.bmymin) then
          iy1=1
        else
          iy1=int((y-bmymin)/bmapdy)+1
          iy1=max(1,iy1)
        endif
        iy2=iy1+1
        if (iy2.gt.ny) then
          iy2=ny
          iy1=iy2-1
        endif
      else
        iy1=1
        iy2=1
      endif

      if (nz.gt.1) then
        if (z.lt.bmzmin) then
          iz1=1
        else
          iz1=int((z-bmzmin)/bmapdz)+1
          iz1=max(1,iz1)
        endif
        iz2=iz1+1
        if (iz2.gt.nz) then
          iz2=nz
          iz1=iz2-1
        endif
      else
        iz1=1
        iz2=1
      endif

      if (irfilb0.eq.6) then

        dyy=(y-(bmymin+(iy1-1)*bmapdy))/bmapdy
        dzz=(z-(bmzmin+(iz1-1)*bmapdz))/bmapdz

        do i=1,3

          b111(i)=bmappe(3+i,iz1+(iy1-1)*nz+(ix1-1)*nyz)
          b211(i)=bmappe(3+i,iz2+(iy1-1)*nz+(ix1-1)*nyz)
          b121(i)=bmappe(3+i,iz1+(iy2-1)*nz+(ix1-1)*nyz)
          b221(i)=bmappe(3+i,iz2+(iy2-1)*nz+(ix1-1)*nyz)
          b112(i)=bmappe(3+i,iz1+(iy1-1)*nz+(ix2-1)*nyz)
          b212(i)=bmappe(3+i,iz2+(iy1-1)*nz+(ix2-1)*nyz)
          b122(i)=bmappe(3+i,iz1+(iy2-1)*nz+(ix2-1)*nyz)
          b222(i)=bmappe(3+i,iz2+(iy2-1)*nz+(ix2-1)*nyz)

          b112111(i)=b111(i)+(b112(i)-b111(i))*dxx
          b122121(i)=b121(i)+(b122(i)-b121(i))*dxx
          b212211(i)=b211(i)+(b212(i)-b211(i))*dxx
          b222221(i)=b221(i)+(b222(i)-b221(i))*dxx

          blow(i)=b112111(i)+(b212211(i)-b112111(i))*dzz
          bhig(i)=b122121(i)+(b222221(i)-b122121(i))*dzz

          b(i)=blow(i)+(bhig(i)-blow(i))*dyy

        enddo

      else !ifilb0

        if (ix1.gt.1) then
          kx1=ix1-1
          kx2=ix1
          kx3=ix1+1
        else
          kx1=ix1
          kx2=ix1+1
          kx3=ix1+2
        endif

        if (ny.gt.1) then
          if (iy1.gt.1) then
            ky1=iy1-1
            ky2=iy1
            ky3=iy1+1
          else
            ky1=iy1
            ky2=iy1+1
            ky3=iy1+2
          endif
        else
          ky1=1
          ky2=1
          ky3=1
        endif

        if (nz.gt.1) then
          if (iz1.gt.1) then
            kz1=iz1-1
            kz2=iz1
            kz3=iz1+1
          else
            kz1=iz1
            kz2=iz1+1
            kz3=iz1+2
          endif
        else
          kz1=1
          kz2=1
          kz3=1
        endif

        x3(1)=0.0d0

        x1=bmappe(1,kz1+(ky1-1)*nz+(kx1-1)*nyz)
        xx=x-x1

        y1=bmappe(2,kz1+(ky1-1)*nz+(kx1-1)*nyz)
        yy=y-y1
        dy=bmappe(2,kz1+(ky2-1)*nz+(kx1-1)*nyz)-y1

        z1=bmappe(3,kz1+(ky1-1)*nz+(kx1-1)*nyz)
        zz=z-z1
        dz=bmappe(3,kz2+(ky1-1)*nz+(kx1-1)*nyz)-z1

        do i=1,3

          x3(2)=bmappe(1,kz1+(ky1-1)*nz+(kx2-1)*nyz)-x1
          x3(3)=bmappe(1,kz1+(ky1-1)*nz+(kx3-1)*nyz)-x1

          b3(1)=bmappe(3+i,kz1+(ky1-1)*nz+(kx1-1)*nyz)
          b3(2)=bmappe(3+i,kz1+(ky1-1)*nz+(kx2-1)*nyz)
          b3(3)=bmappe(3+i,kz1+(ky1-1)*nz+(kx3-1)*nyz)
          call parabel_short(x3,b3,a3)
          b11=a3(1)+(a3(2)+a3(3)*xx)*xx

          b3(1)=bmappe(3+i,kz1+(ky2-1)*nz+(kx1-1)*nyz)
          b3(2)=bmappe(3+i,kz1+(ky2-1)*nz+(kx2-1)*nyz)
          b3(3)=bmappe(3+i,kz1+(ky2-1)*nz+(kx3-1)*nyz)
          call parabel_short(x3,b3,a3)
          b21=a3(1)+(a3(2)+a3(3)*xx)*xx

          b3(1)=bmappe(3+i,kz1+(ky3-1)*nz+(kx1-1)*nyz)
          b3(2)=bmappe(3+i,kz1+(ky3-1)*nz+(kx2-1)*nyz)
          b3(3)=bmappe(3+i,kz1+(ky3-1)*nz+(kx3-1)*nyz)
          call parabel_short(x3,b3,a3)
          b31=a3(1)+(a3(2)+a3(3)*xx)*xx

          b3(1)=bmappe(3+i,kz2+(ky1-1)*nz+(kx1-1)*nyz)
          b3(2)=bmappe(3+i,kz2+(ky1-1)*nz+(kx2-1)*nyz)
          b3(3)=bmappe(3+i,kz2+(ky1-1)*nz+(kx3-1)*nyz)
          call parabel_short(x3,b3,a3)
          b12=a3(1)+(a3(2)+a3(3)*xx)*xx

          b3(1)=bmappe(3+i,kz2+(ky2-1)*nz+(kx1-1)*nyz)
          b3(2)=bmappe(3+i,kz2+(ky2-1)*nz+(kx2-1)*nyz)
          b3(3)=bmappe(3+i,kz2+(ky2-1)*nz+(kx3-1)*nyz)
          call parabel_short(x3,b3,a3)
          b22=a3(1)+(a3(2)+a3(3)*xx)*xx

          b3(1)=bmappe(3+i,kz2+(ky3-1)*nz+(kx1-1)*nyz)
          b3(2)=bmappe(3+i,kz2+(ky3-1)*nz+(kx2-1)*nyz)
          b3(3)=bmappe(3+i,kz2+(ky3-1)*nz+(kx3-1)*nyz)
          call parabel_short(x3,b3,a3)
          b32=a3(1)+(a3(2)+a3(3)*xx)*xx

          b3(1)=bmappe(3+i,kz3+(ky1-1)*nz+(kx1-1)*nyz)
          b3(2)=bmappe(3+i,kz3+(ky1-1)*nz+(kx2-1)*nyz)
          b3(3)=bmappe(3+i,kz3+(ky1-1)*nz+(kx3-1)*nyz)
          call parabel_short(x3,b3,a3)
          b13=a3(1)+(a3(2)+a3(3)*xx)*xx

          b3(1)=bmappe(3+i,kz3+(ky2-1)*nz+(kx1-1)*nyz)
          b3(2)=bmappe(3+i,kz3+(ky2-1)*nz+(kx2-1)*nyz)
          b3(3)=bmappe(3+i,kz3+(ky2-1)*nz+(kx3-1)*nyz)
          call parabel_short(x3,b3,a3)
          b23=a3(1)+(a3(2)+a3(3)*xx)*xx

          b3(1)=bmappe(3+i,kz3+(ky3-1)*nz+(kx1-1)*nyz)
          b3(2)=bmappe(3+i,kz3+(ky3-1)*nz+(kx2-1)*nyz)
          b3(3)=bmappe(3+i,kz3+(ky3-1)*nz+(kx3-1)*nyz)
          call parabel_short(x3,b3,a3)
          b33=a3(1)+(a3(2)+a3(3)*xx)*xx

          x3(2)=dy
          x3(3)=x3(2)+dy

          if (ny.gt.1) then

            b3(1)=b11
            b3(2)=b21
            b3(3)=b31
            call parabel_short(x3,b3,a3)
            bb1=a3(1)+(a3(2)+a3(3)*yy)*yy

            b3(1)=b12
            b3(2)=b22
            b3(3)=b32
            call parabel_short(x3,b3,a3)
            bb2=a3(1)+(a3(2)+a3(3)*yy)*yy

            b3(1)=b13
            b3(2)=b23
            b3(3)=b33
            call parabel_short(x3,b3,a3)
            bb3=a3(1)+(a3(2)+a3(3)*yy)*yy

          else
            bb3=b11
          endif

          if (nz.gt.1) then
            x3(2)=dz
            x3(3)=x3(2)+dz
            b3(1)=bb1
            b3(2)=bb2
            b3(3)=bb3
            call parabel_short(x3,b3,a3)
            b(i)=a3(1)+(a3(2)+a3(3)*zz)*zz
          else
            b(i)=bb1
          endif

        enddo !i=1,3

      endif !irfilb0

      bxout=b(1)
      byout=b(2)
      bzout=b(3)

      return
      end
+DECK,parabel_short.
*CMZ :  4.00/11 28/05/2021  09.13.10  by  Michael Scheer
*CMZ :  2.68/02 02/07/2012  11.19.55  by  Michael Scheer
*CMZ :  2.66/09 22/03/2010  15.23.05  by  Michael Scheer
*CMZ : 00.00/02 26/03/97  10.23.11  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.27.40  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE parabel_short(x,y,a)
+seq,gplhint.

C--- CALCULATES A(1),A(2),A(3)

      IMPLICIT NONE

      double precision A(3),X(3),Y(3),DXM,DXP,x0,a1,a2,dxm2,dxp2
      double precision DET,a22,fm,fp,f0

      x0=x(2)
      f0=y(2)

      fm=y(1)-f0
      fp=y(3)-f0

      dxm=x(1)-x0
      dxp=x(3)-x0

c fm=a1*dxm+a2*dxm**2
c fp=a1*dxp+a2*dxp**2

c (dxm dxm2) (a1) = (y(1))
c (dxp dxp2) (a2) = (y(3))

      dxm2=dxm*dxm
      dxp2=dxp*dxp

      det=dxm*dxp2-dxp*dxm2

      a1=(fm*dxp2-fp*dxm2)/det
      a2=(fp*dxm-fm*dxp)/det
      a22=2.0d0*a2

      a(1)=f0 + (a2*x0 -a1)*x0
      a(2)=a1 - a22*x0
      a(3)=a2

      RETURN
      END
+DECK,ubmask.
*CMZ :  2.68/02 31/07/2012  14.33.30  by  Michael Scheer
*-- Author :    Michael Scheer   31/07/2012
      subroutine ubmask(x,y,z,bx,by,bz)
+seq,gplhint.

      implicit none

+seq,b0scglob.

      double precision x,y,z,bx,by,bz

      if (ibmask.eq.-100) then
        bx=1.0d0
        by=1.0d0
        bz=1.0d0
      else if (ibmask.eq.-200) then
        bx=0.0d0*x
        by=0.0d0*y
        bz=0.0d0*z
      endif

      return
      end
+DECK,util_g1_static.
*CMZ :  3.05/05 12/07/2018  13.00.23  by  Michael Scheer
*CMZ :  3.03/02 19/11/2015  13.51.04  by  Michael Scheer
*CMZ :  3.02/05 27/03/2015  15.15.15  by  Michael Scheer
*CMZ :  3.01/03 19/03/2014  12.19.21  by  Michael Scheer
*CMZ :  2.68/05 03/09/2012  09.26.37  by  Michael Scheer
*-- Author :    Michael Scheer   10/05/2012
      subroutine util_g1_static(y,g1)
+seq,gplhint.

c calculates G1(y) with an estimated precision of about 1.5e-3 for y<=30,
c and 1.5e-2 for y>30.

      implicit none

      integer ical,npoi,ipoi,npoilow,npoihigh,ndatp
      parameter(ndatp=29)

      double precision y,g1,g1_30,c_30,g1_5em5,c_5em5,y_30,
     &  y_5em5,ydum,g1dum,r1

      double precision
     &  ywlow(ndatp),ywhigh(ndatp),coeflow(ndatp),coefhigh(ndatp),
     &  g1wlow(ndatp),g1whigh(ndatp),g1walow(ndatp),
     &  g1wahigh(ndatp),r1low(ndatp),r1high(ndatp),
     &  w1(ndatp),w2(ndatp),w3(ndatp),w4(ndatp),
     &  ystat(ndatp),g1stat(ndatp)

      data ical/0/
      data y_30/30.0d0/
      data y_5em5/5.0d-5/
      data g1_30/6.580794488121591d-013/ !WAVE
      data g1_5em5/7.909860755922665E-002/ !WAVE

* Numerisch mit WAVE berechnet 11.5.2012 (ISPECDIP=2)
        data ystat/
     &    5.0D-005, 7.0D-005, 2.0D-004, 5.0D-004, 1.0D-003,
     &    2.0D-003, 5.0D-003, 1.0D-002, 2.0D-002, 5.0D-002,
     &    0.10D0, 0.20D0, 0.50D0, 1.0D0, 2.0D0,
     &    3.0D0, 4.0D0, 5.0D0, 6.0D0, 7.0D0,
     &    8.0D0, 9.0D0, 10.00D0, 20.00D0, 30.00D0,
     &    40.0D0, 50.0D0, 60.0D0, 70.0D0
     &    /

        data g1stat/
     &    7.909860755922665D-002, 8.846122555950733D-002,
     &    0.125342415210665d0, 0.169701277907238d0, 0.2131391d0,
     &    0.2671962d0, 0.3584969d0, 0.4449725d0, 0.5472394d0,
     &    0.7015719d0, 0.8181855d0, 0.9033860d0, 0.8708191d0,
     &    0.65142282d0, 0.30163590d0, 0.128565710002655d0,
     &    5.282739666852105D-002,
     &    2.12481297D-002, 8.426079715722744D-003,
     &    3.307610970763407D-003, 1.288451614441198D-003,
     &    4.988932935072772D-004, 1.92238264D-004,
     &    1.19686345D-008, 6.58079455D-013, 3.42988745D-017,
     &    1.73478519D-021, 8.60693915D-026, 4.21333348D-030
     &    /

      save ical,c_5em5,c_30,
     &  ywlow,r1low,coeflow,npoilow,
     &  ywhigh,r1high,coefhigh,npoihigh

      if (ical.eq.0) then

        c_5em5=g1_5em5/y_5em5**(1.0d0/3.0d0)
        c_30=g1_30/(sqrt(y_30)*exp(-y_30))

        npoilow=0
        npoihigh=0

        do npoi=1,ndatp
          ydum=ystat(npoi)
          if (ydum.ge.y_5em5.and.ydum.le.4.0d0) then !zwei Abfragen wegen 4.0
            npoilow=npoilow+1
          endif
          if (ydum.ge.4.0d0.and.ydum.le.y_30) then
            npoihigh=npoihigh+1
          endif
        enddo

        npoi=ndatp

        npoilow=0
        npoihigh=0
        do ipoi=1,npoi
          ydum=ystat(ipoi)
          g1dum=g1stat(ipoi)
          if (ydum.ge.y_5em5.and.ydum.le.4.0d0) then
            npoilow=npoilow+1
            ywlow(npoilow)=ydum
            g1wlow(npoilow)=g1dum
            g1walow(npoilow)=
     &        391.8d0 * ydum**(1.0d0/3.0d0) * exp(-ydum*0.8307d0)
     &        -192.0d0 * sqrt(ydum) * exp(-ydum*0.7880d0)
          endif
          if (ydum.ge.4.0d0.and.ydum.le.y_30) then
            npoihigh=npoihigh+1
            ywhigh(npoihigh)=ydum
            g1whigh(npoihigh)=g1dum
            g1wahigh(npoihigh)=164.0d0*sqrt(ydum)*EXP(-ydum)
          endif
        enddo

        r1low(1:npoilow)=g1wlow(1:npoilow)/g1walow(1:npoilow)
        r1high(1:npoihigh)=g1whigh(1:npoihigh)/g1wahigh(1:npoihigh)

        call util_spline_coef(ywlow,r1low,npoilow,0.0d0,0.0d0,coeflow,
     &    w1,w2,w3,w4)
        call util_spline_coef(ywhigh,r1high,npoihigh,0.0d0,0.0d0,
     &    coefhigh,w1,w2,w3,w4)

        ical=1
      endif

      if (y.le.5.0d-5) then
        g1=c_5em5*y**(1.0d0/3.0d0)
      else if (y.ge.30.0d0) then
        g1=c_30*sqrt(y)*exp(-y)
      else

        if (y.ge.y_5em5.and.y.lt.4.0d0) then
          call util_spline_inter(ywlow,r1low,coeflow,npoilow,y,r1,-1)
          g1=r1*(
     &      391.8d0 * y**(1.0d0/3.0d0) * exp(-y*0.8307d0)
     &      -192.0d0 * sqrt(y) * exp(-y*0.7880d0))
        else if (y.ge.4.0d0.and.y.le.y_30) then
          call util_spline_inter(
     &      ywhigh,r1high,coefhigh,npoihigh,y,r1,-1)
          g1=r1*(164.0d0*sqrt(y)* EXP(-y))
        endif

      endif

+self,if=old.

      integer i,nbinp
      parameter (nbinp=2000)
      double precision y,yy,g1,ymax,dy,yymax,
     &  besk(nbinp),buff(nbinp),coef(nbinp),
     &  w1(nbinp),
     &  w2(nbinp),
     &  w3(nbinp),
     &  w4(nbinp)

      data ymax/2.0d0/

      g1=0.0d0
      yy=y
      yymax=ymax*abs(log10(y))
      print*,'yymax:',yymax

      dy=(yymax-y)/nbinp

      i=0
      do while (yy.le.yymax.and.i.lt.nbinp-1)
        i=i+1
        buff(i)=yy
        call util_mod_bessel(5.0d0/3.0d0,yy,besk(i))
        print*,yy,besk(i)
        yy=yy+dy
      enddo

      call util_spline_integral(buff,besk,i,g1,coef,w1,w2,w3,w4)
      g1=y*g1

+self.
      return
9999  stop '*** File wave-g1.dat not found ***'
      end
+DECK,util_spline_running_integral.
*CMZ :  4.00/11 28/05/2021  09.19.32  by  Michael Scheer
*CMZ :  3.01/03 19/03/2014  12.18.57  by  Michael Scheer
*CMZ :  2.68/05 03/09/2012  09.27.27  by  Michael Scheer
*CMZ : 00.00/11 11/02/2011  15.34.09  by  Michael Scheer
*-- Author :    Michael Scheer   11/02/2011
      SUBROUTINE util_spline_running_integral(X,Y,N,RESULT
     &                                 ,COEF,WORK1,WORK2,WORK3,WORK4)
+seq,gplhint.

C---  CALCULATES RUNNING INTERGRAL OF Y(X) VIA SPLINES

      IMPLICIT NONE

      INTEGER I,N
      double precision X(N),Y(N),RESULT(n)
      double precision COEF(N),WORK1(N),WORK2(N),WORK3(N),WORK4(N)

C---  SPLINE-COEFFICIENTS

      CALL UTIL_SPLINE_COEF(X,Y,N,-9999.0d0,-9999.0d0,COEF,
     &  WORK1,WORK2,WORK3,WORK4)

C--- INTEGRATION

      RESULT(1)=0.0D0
      DO I=1,N-1

        RESULT(i+1)=RESULT(i)
     &          +(X(I+1)-X(I))*0.5D0
     &          *(Y(I)+Y(I+1))
     &          -(X(I+1)-X(I))**3/24.D0
     &          *(COEF(I)+COEF(I+1))

      ENDDO

      RETURN
      END
+DECK,hisini3.
*CMZ :  4.00/14 30/12/2021  15.41.22  by  Michael Scheer
*CMZ :  3.03/00 18/08/2015  15.44.00  by  Michael Scheer
*CMZ :  3.02/03 23/10/2014  13.43.13  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.13.36  by  Michael Scheer
*CMZ :  2.68/05 17/09/2012  12.42.05  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE HISINI3
+seq,gplhint.

+SELF,IF=F90.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SELF.

      use bunchmod

C--- INITIALIZES HBOOK

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+seq,whbook.
+seq,pawcmn.
+SEQ,KLOTZ.
+SEq,phasef90.
+seq,sourcef90.
+SEq,observf90.
+seq,freqs.
+SEQ,photon.
+seq,ntuple2.

      real zmin,zmax,ymin,ymax
      CHARACTER(4) CHTAGS(22)
      CHARACTER(96) tit
      CHARACTER(4) CHSPEC(21)
      CHARACTER(4) CHPOW(8)
      CHARACTER(4) CHSTOK(12)

      data chspec/'isou','iobs','x','y','z','ener','spec'
     &  ,'iz','iy','iene'
     &  ,'re_x','im_x','re_y','im_y','re_z','im_z','rf_y','if_y','rf_z','if_z',
     &  'phi0'
     &  /

      data chpow/'x','y','z','pow','iz','iy','iobs','isou'/

      data chstok/'iobs','x','y','z','ener','s0','s1','s2','s3'
     &  ,'iz','iy','iene'
     &  /

      if (ispec.ne.0.and.ipin.eq.3) then

        if (ihisini_c.eq.0) call hisini

        write(6,*)' '
        write(6,*)'      HISINI3:'
        write(6,*)'      '
        write(6,*)'      For IPIN=3, not all histograms and ntuples are available'
        write(6,*)'      '

        write(lungfo,*)' '
        write(lungfo,*)'      HISINI3:'
        write(lungfo,*)'      '
        write(lungfo,*)'      For IPIN=3, not all histograms and ntuples are available'
        write(lungfo,*)'      '

        IF (IPINCIRC.NE.0) THEN
          PINW=2.D0*PINR
          PINH=2.D0*PINR
        ENDIF !IPINCIRC

        IF (PINCEN(2).EQ.9999.) THEN
          IF     (IPBRILL.EQ.0) THEN
            PINCEN(2)=0.0
          ELSE IF (IPBRILL.EQ.1) THEN
            PINCEN(2)=PINH/2.D0
          ELSE IF (IPBRILL.EQ.2) THEN
            PINCEN(2)=PINH/2.D0
          ELSE IF (IPBRILL.EQ.3) THEN
            PINCEN(2)=-PINH/2.D0
          ELSE IF (IPBRILL.EQ.4) THEN
            PINCEN(2)=-PINH/2.D0
          ENDIF !IPBRILL
        ELSE IF (PINCEN(2).EQ.-9999.) THEN
          PINCEN(2)=YSTART+VYIN/VXIN*(PINCEN(1)-XSTART)
        ENDIF !PINCEN(2)

        IF (PINCEN(3).EQ.9999.) THEN
          IF     (IPBRILL.EQ.0) THEN
            PINCEN(3)=0.0
          ELSE IF (IPBRILL.EQ.1) THEN
            PINCEN(3)=PINW/2.D0
          ELSE IF (IPBRILL.EQ.2) THEN
            PINCEN(3)=-PINW/2.D0
          ELSE IF (IPBRILL.EQ.3) THEN
            PINCEN(3)=-PINW/2.D0
          ELSE IF (IPBRILL.EQ.4) THEN
            PINCEN(3)=PINW/2.D0
          ENDIF !IPBRILL
        ELSE IF (PINCEN(3).EQ.-9999.) THEN
          PINCEN(3)=ZSTART+VZIN/VXIN*(PINCEN(1)-XSTART)
        ENDIF !PINCEN(3)

        ymin=pincen(2)-pinh/2.
        ymax=pincen(2)+pinh/2.
        zmin=pincen(3)-pinw/2.
        zmax=pincen(3)+pinw/2.
        tit='dist. in pinhole (ipin=3)'
        call hbook2m(idspec,tit,mpinzorig,zmin,zmax,mpinyorig,ymin,ymax,0.0)
        tit='hori. dist. in pinhole (ipin=3)'
        call hbook1m(idspec-1,tit,mpinzorig,zmin,zmax,0.0)
        tit='vert. dist. in pinhole (ipin=3)'
        call hbook1m(idspec-2,tit,mpinyorig,ymin,ymax,0.0)
+self,if=-mhbook.
        call hbookm(nidspec,'arrays spect, reaima (ipin=3)',21
     &    ,'//WAVE',1000,chspec)
        call hbookm(nidpow,'power density from spectrum (ipin=3)',8
     &    ,'//WAVE',1000,chpow)
        chtags(1)='egam'
        chtags(2)='flux'
        call hbookm(nidfreqp,'photon flux in pinhole (ipin=3)',2,
     &    '//WAVE',1000,chtags)
        if (istokes.ne.0) then
          call hbookm(nidstok,'stokes arrays (ipin=3)',12
     &      ,'//WAVE',1000,chstok)
          chtags(1)='egam'
          chtags(2)='s0'
          chtags(3)='s1'
          chtags(4)='s2'
          chtags(5)='s3'
          call hbookm(4600,'stokes flux in pinhole (ipin=3)',5,
     &      '//WAVE',1000,chtags)
        endif
+self,if=mhbook.
        call hbookm(nidspec,'arrays spect, reaima (ipin=3)',21
     &    ,'//WAVE',nsource*nobsv*nfreq,chspec)
        call hbookm(nidpow,'power density from spectrum (ipin=3)',8
     &    ,'//WAVE',nsource*nobsv,chpow)
        chtags(1)='egam'
        chtags(2)='flux'
        call hbookm(nidfreqp,'photon flux in pinhole (ipin=3)',2,
     &    '//WAVE',nfreq,chtags)
        if (istokes.ne.0) then
          call hbookm(nidstok,'stokes arrays (ipin=3)',12
     &      ,'//WAVE',1000,chstok)
          chtags(1)='egam'
          chtags(2)='s0'
          chtags(3)='s1'
          chtags(4)='s2'
          chtags(5)='s3'
          call hbookm(4600,'stokes flux in pinhole (ipin=3)',5,
     &      '//WAVE',nfreq,chtags)
        endif
+self.
      endif !ipin.eq.3

      RETURN
      END
+DECK,util_straight_line_fit.
*CMZ :  4.01/05 14/03/2024  09.52.21  by  Michael Scheer
*CMZ :  2.69/00 26/10/2012  09.35.15  by  Michael Scheer
*-- Author :    Michael Scheer   25/10/2012
      subroutine util_straight_line_fit(n,x,y,e,a,b,chi2,erra,errb,istat)
+seq,gplhint.

c Fit a and b, such that f = a*x+b and Sum(i,((a*xi+b-yi-fi)/ei)**2)=min
c See also grafit.kumac

c The uncertainties erra and errb of the fitted parameters a (slope) and b
c (offset) agree to the fits of MINUIT, except when the error e(i) are zero.
c Then the errors are such, that chi2/ndf is scaled to unity

      integer istat,n,i

      double precision x(n),y(n),e(n),chi2,wsum,wxy,wx,wy,wx2,
     &  d,ep,erra,errb,a,b,w,esuma

      wx=0.0d0
      wy=0.0d0
      wxy=0.0d0
      wx2=0.0d0
      wsum=0.0d0
      chi2=0.0d0
      erra=0.0d0
      errb=0.0d0
      istat=0

      if (n.lt.2) then
        istat=-1
        return
      else if (n.eq.2) then
        if (x(2).eq.x(1)) then
          istat=-2
          return
        endif
        a=(y(2)-y(1))/(x(2)-x(1))
        b=y(2)-a*x(2)
        return
      endif

      ep=1.0d0
      esuma=0.0d0
      do i=1,n
        if (e(i).lt.0.0d0) then
          istat=1
          return
        else if (e(i).eq.0.0d0) then
          ep=0.0d0
        endif
        esuma=esuma+abs(e(i))
      enddo

      if(esuma.ne.0.0d0.and.ep.eq.0.0d0) then
        istat=2
        return
      endif

      do i=1,n
        if (esuma.ne.0.0d0) then
          w=1.0d0/e(i)**2
        else
          w=1.0d0
        endif
        wx=wx+w*x(i)
        wy=wy+w*y(i)
        wx2=wx2+w*x(i)*x(i)
        wxy=wxy+w*x(i)*y(i)
        wsum=wsum+w
      enddo

      d=wsum*wx2-wx**2

      if (d.ne.0.0d0) then

        a=(wsum*wxy-wx*wy)/d
        b=(wx2*wy-wx*wxy)/d

        if (esuma.ne.0.0d0) then
          do i=1,n
            chi2=chi2+((a*x(i)+b-y(i))/e(i))**2
          enddo
          erra=sqrt(wsum/d)
          errb=sqrt(wx2/d)
        else
          do i=1,n
            chi2=chi2+(a*x(i)+b-y(i))**2
          enddo
          erra=sqrt(wsum/d*chi2/(n-2))
          errb=sqrt(wx2/d*chi2/(n-2))
        endif

      else
        istat=-1
        return
      endif

      return
      end
+DECK,PININ.
*CMZ :  4.01/07 06/05/2024  16.54.16  by  Michael Scheer
*CMZ :  4.01/04 22/11/2023  17.20.47  by  Michael Scheer
*CMZ :  4.00/15 12/02/2022  17.08.21  by  Michael Scheer
*CMZ :  4.00/13 04/12/2021  12.10.40  by  Michael Scheer
*CMZ :  4.00/01 05/04/2019  15.09.32  by  Michael Scheer
*CMZ :  3.06/00 25/02/2019  17.19.30  by  Michael Scheer
*CMZ :  3.02/08 24/06/2015  16.06.32  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.68/00 25/05/2012  11.59.38  by  Michael Scheer
*CMZ :  2.67/02 28/03/2012  08.22.03  by  Michael Scheer
*CMZ :  2.66/06 22/05/2010  16.48.23  by  Michael Scheer
*CMZ :  2.64/06 15/09/2009  11.10.54  by  Michael Scheer
*CMZ :  2.64/05 14/09/2009  15.19.42  by  Michael Scheer
*CMZ :  2.62/03 16/07/2007  11.51.09  by  Michael Scheer
*CMZ :  2.62/02 16/07/2007  06.52.55  by  Michael Scheer
*CMZ :  2.54/05 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.52/10 05/11/2004  16.59.34  by  Michael Scheer
*CMZ :  2.51/00 17/05/2004  17.43.59  by  Michael Scheer
*CMZ :  2.47/16 11/09/2003  15.10.02  by  Michael Scheer
*CMZ :  2.34/09 18/09/2001  22.52.09  by  Michael Scheer
*CMZ :  2.34/00 11/05/2001  12.38.34  by  Michael Scheer
*CMZ :  2.17/00 03/11/2000  09.47.59  by  Michael Scheer
*CMZ :  2.16/08 24/10/2000  12.09.17  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.16/00 27/05/2000  14.03.56  by  Michael Scheer
*CMZ :  2.15/00 08/05/2000  13.32.10  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.24.35  by  Michael Scheer
*CMZ :  2.13/02 14/12/99  16.24.13  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  14.47.16  by  Michael Scheer
*CMZ : 00.02/04 24/02/97  12.37.49  by  Michael Scheer
*CMZ : 00.02/00 19/11/96  14.57.13  by  Michael Scheer
*CMZ : 00.01/08 22/06/95  17.29.50  by  Michael Scheer
*CMZ : 00.01/06 01/02/95  16.35.43  by  Michael Scheer
*CMZ : 00.01/04 29/11/94  10.17.51  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  17.07.25  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.52.56  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.26  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE PININ
+seq,gplhint.

+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,WFOLDF90U.

C--- INITIALIZE GRID OF OBERSERVATION POINTS OF PINHOLE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEq,observf90.
+SEQ,DEPOLA.
+SEq,wfoldf90.
+seq,sourcef90.


      INTEGER IOB,IY,IZ,INCZ,INCY,ISOUR,INCZMX,INCYMX
      INTEGER N2POWZ,N2POWY,ICDUMZ,ICDUMY

      DOUBLE PRECISION OBSVDUM(3,1),x,y,z,xn,yn,zn,r,r0,pinwo,pinho,pinro

      INTEGER IFPHIR_A,iobsv
      DATA IFPHIR_A/0/

      pinwo=pinw
      pinho=pinh
      pinro=pinr

      IF (IPINCIRC.NE.0) THEN
        PINW=2.D0*PINR
        PINH=2.D0*PINR
      ENDIF !IPINCIRC

      IF (OBSVDZ.NE.0.D0) THEN
        MPINZ=NINT(PINW/OBSVDZ)+1
        if (mpinz.lt.3) then
          write(6,*)"*** Warning in pinin: OBSVDZ > PINW/2., will be adjusted ***"
          write(lungfo,*)"*** Warning in pinin: OBSVDZ > PINW/2., will be adjusted ***"
          mpinz=3
          obsvdz=pinw/2.0d0
        endif
        PINW=OBSVDZ*(MPINZ-1)
      ENDIF !(OBSVDZ.NE.0.D0)

      IF (OBSVDY.NE.0.D0) THEN
        MPINY=NINT(PINH/OBSVDY)+1
        if (mpiny.lt.3) then
          write(6,*)"*** Warning in pinin: OBSVDY > PINH/2., will be adjusted ***"
          write(lungfo,*)"*** Warning in pinin: OBSVDY > PINH/2., will be adjusted ***"
          mpiny=3
          obsvdy=pinh/2.0d0
        endif
        PINH=OBSVDY*(MPINY-1)
      ENDIF !(OBSVDZ.NE.0.D0)

      IF (IPINCIRC.NE.0) THEN
        PINR=min(pinw,pinh)/2.0d0
      ENDIF !IPINCIRC

      if (abs(pinwo-pinw).gt.pinw/10000.0d0) then
        print*,"*** Warning in PINI: PINW is adjusted, according to MPINZ and DOBSVDZ ***"
      endif

      if (abs(pinho-pinh).gt.pinh/10000.0d0) then
        print*,"*** Warning in PINI: PINH is adjusted, according to MPINY and DOBSVDY ***"
      endif

      if (abs(pinro-pinr).gt.pinr/10000.0d0) then
        print*,"*** Warning in PINI: PINR is adjusted, according to PINW and PINH ***"
      endif

      IF (PINCEN(2).EQ.9999.) THEN
        IF     (IPBRILL.EQ.0) THEN
          PINCEN(2)=0.0
        ELSE IF (IPBRILL.EQ.1) THEN
          PINCEN(2)=PINH/2.D0
        ELSE IF (IPBRILL.EQ.2) THEN
          PINCEN(2)=PINH/2.D0
        ELSE IF (IPBRILL.EQ.3) THEN
          PINCEN(2)=-PINH/2.D0
        ELSE IF (IPBRILL.EQ.4) THEN
          PINCEN(2)=-PINH/2.D0
        ENDIF !IPBRILL
      ELSE IF (PINCEN(2).EQ.-9999.) THEN
        PINCEN(2)=YSTART+VYIN/VXIN*(PINCEN(1)-XSTART)
      ENDIF !PINCEN(2)

      IF (PINCEN(3).EQ.9999.) THEN
        IF     (IPBRILL.EQ.0) THEN
          PINCEN(3)=0.0
        ELSE IF (IPBRILL.EQ.1) THEN
          PINCEN(3)=PINW/2.D0
        ELSE IF (IPBRILL.EQ.2) THEN
          PINCEN(3)=-PINW/2.D0
        ELSE IF (IPBRILL.EQ.3) THEN
          PINCEN(3)=-PINW/2.D0
        ELSE IF (IPBRILL.EQ.4) THEN
          PINCEN(3)=PINW/2.D0
        ENDIF !IPBRILL
      ELSE IF (PINCEN(3).EQ.-9999.) THEN
        PINCEN(3)=ZSTART+VZIN/VXIN*(PINCEN(1)-XSTART)
      ENDIF !PINCEN(3)

      IF(NDOBSVZ*NDOBSVY.NE.NDOBSV) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*) '*** ERROR IN PININ ***'
        WRITE(LUNGFO,*) 'DIMENSION DECLARATIONS NOT CONSISTENT'
        WRITE(LUNGFO,*) 'NDOBSV MUST BE EQUAL TO NDOBSVZ*NDOBSVY'
        WRITE(LUNGFO,*) 'CHANGE PARAMETER IN CMPARA.CMN'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED  ***'
        WRITE(6,*)
        WRITE(6,*) '*** ERROR IN PININ ***'
        WRITE(6,*) 'DIMENSION DECLARATIONS NOT CONSISTENT'
        WRITE(6,*) 'NDOBSV MUST BE EQUAL TO NDOBSVZ*NDOBSVY'
        WRITE(6,*) 'CHANGE PARAMETER IN CMPARA.CMN'
        WRITE(6,*)
        WRITE(6,*)'*** PROGRAM WAVE ABORTED  ***'
        STOP
      ENDIF

C--- DATA OF PINHOLE ARE TAKEN FORM NAMELIST

      IF (IF1DIM.NE.0.AND.
     &    (MEDGEZ.NE.0.OR.MMEDGEZ.NE.0.OR.MPINZ.NE.1)) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN PININ ***'
        WRITE(LUNGFO,*)'FLAG IF1DIM SET BUT'
        WRITE(LUNGFO,*)
     &    'MEDGEZ OR MMEDGEZ IN NAMELIST PINHOLE NOT ZERO OR MPINZ NOT EQUAL ONE'
        WRITE(LUNGFO,*)'ADJUSTED TO APPROPRIATE VALUES'
        WRITE(LUNGFO,*)
c        WRITE(6,*)
c        WRITE(6,*)
c        WRITE(6,*)'*** WARNING IN PININ ***'
c        WRITE(6,*)'FLAG IF1DIM SET BUT'
c        WRITE(6,*)
c     &    'MEDGEZ OR MMEDGEZ IN NAMELIST PINHOLE NOT ZERO OR MPINZ NOT EQUAL ONE'
c        WRITE(6,*)'ADJUSTED TO APPROPRIATE VALUES'
c        WRITE(6,*)
        MPINZ=1
        MEDGEZ=0
        MMEDGEZ=0
      ENDIF

      IF (IUSEM.NE.0) THEN
C MAKE MPINZ AND MPINY EVEN
        MPINZ=(MPINZ+1)/2*2
        MPINY=(MPINY+1)/2*2
      ENDIF !IUSEM

      NOBSVY=MPINY
      NOBSVZ=MPINZ
      NOBSV=NOBSVY*NOBSVZ
      IF (NOBSV.LE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN PININ ***'
        WRITE(LUNGFO,*)'*** NEGATIVE NUMBER OF OBSERVATION POINTS!'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN PININ ***'
        WRITE(6,*)'*** NEGATIVE NUMBER OF OBSERVATION POINTS!'
        WRITE(6,*)
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      OBSVDUM(1,1)=PINCEN(1)

      IF (MPINZ.GT.1) THEN
        OBSVDZ=PINW/DFLOAT(MPINZ-1)
        OBSVDUM(3,1)=PINCEN(3)-PINW/2.
      ELSE
        OBSVDZ=PINW
        OBSVDUM(3,1)=PINCEN(3)
      ENDIF

      IF (MPINY.GT.1) THEN
        OBSVDY=PINH/DFLOAT(MPINY-1)
        OBSVDUM(2,1)=PINCEN(2)-PINH/2.
      ELSE
        OBSVDY=PINH
        OBSVDUM(2,1)=PINCEN(2)
      ENDIF

      IF (IF1DIM.EQ.0.AND.(MEDGEZ.LT.1.OR.MEDGEY.LT.1)) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN PININ ***'
        WRITE(LUNGFO,*)'MEDGEZ OR MEDGEY IN NAMELIST PINHOLE LOWER THAN 1'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED  ***'
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN PININ ***'
        WRITE(6,*)'MEDGEZ OR MEDGEY IN NAMELIST PINHOLE LOWER THAN 1'
        WRITE(6,*)
        WRITE(6,*)'*** PROGRAM WAVE ABORTED  ***'
        STOP
      ENDIF

      IF (MMEDGEZ.LT.0.OR.MMEDGEY.LT.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN PININ ***'
        WRITE(LUNGFO,*)'MMEDGEZ OR MMEDGEY IN NAMELIST PINHOLE LOWER THAN 0'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED  ***'
        WRITE(6,*)
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN PININ ***'
        WRITE(6,*)'MMEDGEZ OR MMEDGEY IN NAMELIST PINHOLE LOWER THAN 0'
        WRITE(6,*)
        WRITE(6,*)'*** PROGRAM WAVE ABORTED  ***'
        STOP
      ENDIF

C- DETERMINE RMS VALUES FOR FOLDING

      IF (IFOLD.NE.0) CALL WSIGFOL

C- INCREASE PINHOLE

      MOBSVZ=NOBSVZ  !STORE VALUES
      MOBSVY=NOBSVY
      MOBSV=NOBSV

      INCZ=0
      INCY=0

      IF (IFOLD.NE.0.AND.IFOLD.NE.2) THEN

        INCZMX=-1
        INCYMX=-1
        DO ISOUR=1,NSOURCE
          INCZ=NINT(WSIGZ(ISOUR)*DGSIGZ(ISOUR)/OBSVDZ)
          IF(INCZ.GT.INCZMX) THEN
            INCZMX=INCZ
          ENDIF
          INCY=NINT(WSIGY(ISOUR)*DGSIGY(ISOUR)/OBSVDY)
          IF(INCY.GT.INCYMX) THEN
            INCYMX=INCY
          ENDIF
        ENDDO   !ISOUR

        INCZ=INCZMX
        INCY=INCYMX
        IF (IF1DIM.NE.0) INCZ=0

      ENDIF !IFOLD

C           FACTOR 2 FOR BOTH SIDES OF PINHOLE
      NOBSVZ=MOBSVZ+2*(INCZ+MEDGEZ+MMEDGEZ)
      NOBSVY=MOBSVY+2*(INCY+MEDGEY+MMEDGEY)

C--- ADJUST NUMBER OF POINTS ACCORDING TO POWERS OF IF FLAG IUSEM IS SET

      IF (IUSEM.NE.0) THEN

        N2POWZ=NINT(ALOG(FLOAT(NOBSVZ-1))/ALOG(2.))
        IF(NOBSVZ .GT. 2**N2POWZ) N2POWZ=N2POWZ+1
C150793        NOBSVZ=2**N2POWZ+1
        NOBSVZ=2**N2POWZ

        N2POWY=NINT(ALOG(FLOAT(NOBSVY-1))/ALOG(2.))
        IF(NOBSVY .GT. 2**N2POWY) N2POWY=N2POWY+1
C150793        NOBSVY=2**N2POWY+1
        NOBSVY=2**N2POWY

      ENDIF !IUSEM

      OBSVDUM(2,1)=OBSVDUM(2,1)-(NOBSVY-MOBSVY)/2*OBSVDY
      OBSVDUM(3,1)=OBSVDUM(3,1)-(NOBSVZ-MOBSVZ)/2*OBSVDZ

      NOBSV=NOBSVZ*NOBSVY
      IF (NOBSV.GT.4000000) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** ERROR IN PININ ***'
        WRITE(LUNGFO,*)'*** MORE THAN 4 000 0000 OBSERVATION POINTS ***'
        WRITE(LUNGFO,*)'NUMBER OF POINTS IN Y:',NOBSVY
        WRITE(LUNGFO,*)'NUMBER OF POINTS IN Z:',NOBSVZ
        IF (IFOLD.NE.0) WRITE(LUNGFO,*)'PLEASE CHECK PINHOLE SIZE AND RELATION TO BEAM EMITTANCE'
        WRITE(6,*)
        WRITE(6,*)'*** ERROR IN PININ ***'
        WRITE(6,*)'*** MORE THAN 1 000 000 OBSERVATION POINTS ***'
        WRITE(6,*)'NUMBER OF POINTS IN Y:',NOBSVY
        WRITE(6,*)'NUMBER OF POINTS IN Z:',NOBSVZ
        IF (IFOLD.NE.0) WRITE(6,*)'PLEASE CHECK PINHOLE SIZE AND RELATION TO BEAM EMITTANCE'
        STOP '*** PROGRAM WAVE ABORTED ***'
      ENDIF

      IF (IOBSV_A.NE.NOBSV) THEN
        IF (IOBSV_A.NE.0) DEALLOCATE(OBSV)
        ALLOCATE(OBSV(3,NOBSV))
        IOBSV_A=NOBSV
      ENDIF !(IOBSV_A.LT.NOBSV)

      IF (IOBSVZ_A.NE.NOBSVZ) THEN
        IF (IOBSVZ_A.NE.0) DEALLOCATE(OBSVZ)
        ALLOCATE(OBSVZ(NOBSVZ))
        IOBSVZ_A=NOBSVZ
      ENDIF !(IOBSVY_A.LT.NOBSVY)

      IF (IOBSVY_A.NE.NOBSVY) THEN
        IF (IOBSVY_A.NE.0) DEALLOCATE(OBSVY)
        ALLOCATE(OBSVY(NOBSVY))
        IOBSVY_A=NOBSVY
      ENDIF !(IOBSV_A.LT.NOBSV)

      OBSV(1,1)=OBSVDUM(1,1)
      OBSV(2,1)=OBSVDUM(2,1)
      OBSV(3,1)=OBSVDUM(3,1)

      IOB=0
      DO IY=1,NOBSVY
        DO IZ=1,NOBSVZ
          IOB=IOB+1
          OBSV(3,IOB)=OBSV(3,1)+OBSVDZ*(IZ-1)
          OBSV(2,IOB)=OBSV(2,1)+OBSVDY*(IY-1)
          OBSV(1,IOB)=OBSV(1,1)
        ENDDO
      ENDDO

      DO IZ=1,NOBSVZ
        OBSVZ(IZ)=OBSV(3,IZ)
      ENDDO

      DO IY=1,NOBSVY
        IOB=(IY-1)*NOBSVZ+1
        OBSVY(IY)=OBSV(2,IOB)
      ENDDO

      IF (IPIN.EQ.0) THEN
        ICBRILL=1
      ELSE !PIN
        IF (IPBRILL.EQ.0) THEN
          ICDUMZ=NOBSVZ/2+1
          ICDUMY=NOBSVY/2+1
          ICBRILL=ICDUMZ+NOBSVZ*(ICDUMY-1)
        ELSE IF (IPBRILL.EQ.1) THEN
          ICDUMZ=(NOBSVZ-MOBSVZ)/2+1
          ICDUMY=(NOBSVY-MOBSVY)/2+1
          ICBRILL=ICDUMZ+NOBSVZ*(ICDUMY-1)
        ELSE IF (IPBRILL.EQ.2) THEN
          ICDUMZ=(NOBSVZ-MOBSVZ)/2+MOBSVZ
          ICDUMY=(NOBSVY-MOBSVY)/2+1
          ICBRILL=ICDUMZ+NOBSVZ*(ICDUMY-1)
        ELSE IF (IPBRILL.EQ.3) THEN
          ICDUMZ=(NOBSVZ-MOBSVZ)/2+1
          ICDUMY=(NOBSVY-MOBSVY)/2+MOBSVY
          ICBRILL=ICDUMZ+NOBSVZ*(ICDUMY-1)
        ELSE IF (IPBRILL.EQ.4) THEN
          ICDUMZ=(NOBSVZ-MOBSVZ)/2+MOBSVZ
          ICDUMY=(NOBSVY-MOBSVY)/2+MOBSVY
          ICBRILL=ICDUMZ+NOBSVZ*(ICDUMY-1)
        ELSE
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN PININ: IPBRILL WRONG ***'
          WRITE(LUNGFO,*)'*** CHECK NAMELIST PINHOLE ***'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED  ***'
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN PININ: IPBRILL WRONG ***'
          WRITE(6,*)'*** CHECK NAMELIST PINHOLE ***'
          WRITE(6,*)
          WRITE(6,*)'*** PROGRAM WAVE ABORTED  ***'
          STOP
        ENDIF
      ENDIF   !IPIN

      IF (MPINR.NE.0) IRPHI=1
      IF (IPINCIRC.NE.0.AND.IFPHIR_A.NE.NOBSV) THEN
        ALLOCATE(FPHIR(NOBSV))
        IF (IRPHI.NE.0) THEN
          ALLOCATE(XC(NOBSV))
          ALLOCATE(YC(NOBSV))
        ENDIF
        IFPHIR_A=NOBSV
      ENDIF !IPINCIRC

      IF (MPINR.NE.0.AND.IPIN.EQ.0) THEN
        MPINR=0
        WRITE(6,*)
        WRITE(6,*)
     &    '*** WARNING IN PININ: IPIN.EQ.0, THEREFORE MPINR SET ZERO ***'
        WRITE(6,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '*** WARNING IN PININ: IPIN.EQ.0, THEREFORE MPINR SET ZERO ***'
        WRITE(LUNGFO,*)
      ENDIF

      IF (MPINR.NE.0.AND.IF1DIM.NE.0) THEN
        MPINR=0
        WRITE(6,*)
        WRITE(6,*)
     &    '*** WARNING IN PININ: IF1DIM.NE.0, THEREFORE MPINR SET ZERO ***'
        WRITE(6,*)
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '*** WARNING IN PININ: IF1DIM.EQ.0, THEREFORE MPINR SET ZERO ***'
        WRITE(LUNGFO,*)
      ENDIF

      IF (MPINR.NE.0) THEN
        CALL PININR
      ENDIF

      if (rpinsph.eq.-9999.0d0) rpinsph=pincen(1)

      if (rpinsph.ne.0) then
        r0=obsv(1,1)-rpinsph
        do iobsv=1,nobsv
          x=obsv(1,iobsv)-r0
          y=obsv(2,iobsv)
          z=obsv(3,iobsv)
          r=sqrt(x*x+y*y+z*z)
          xn=x/r
          yn=y/r
          zn=z/r
          obsv(1,iobsv)=r0+xn*rpinsph
          obsv(2,iobsv)=yn*rpinsph
          obsv(3,iobsv)=zn*rpinsph
        enddo
        if (mpinr.ne.0) then
          do iobsv=1,nobsvrphi
            x=obsvrphi(1,iobsv)-r0
            y=obsvrphi(2,iobsv)
            z=obsvrphi(3,iobsv)
            r=sqrt(x*x+y*y+z*z)
            xn=x/r
            yn=y/r
            zn=z/r
            obsvrphi(1,iobsv)=xn*rpinsph
            obsvrphi(2,iobsv)=yn*rpinsph
            obsvrphi(3,iobsv)=zn*rpinsph
          enddo
        endif

        DO iob=1,nobsv
          if (abs(obsv(2,iob)).lt.1.0d-12) obsv(2,iob)=0.0d0
          if (abs(obsv(3,iob)).lt.1.0d-12) obsv(3,iob)=0.0d0
        ENDDO

        DO IZ=1,NOBSVZ
          OBSVZ(IZ)=OBSV(3,IZ)
        ENDDO

        DO IY=1,NOBSVY
          IOB=(IY-1)*NOBSVZ+1
          OBSVY(IY)=OBSV(2,IOB)
        ENDDO

      endif

      RETURN
      END
+DECK,util_fold_function_gauss_lin.
*CMZ :  4.00/07 06/04/2020  08.51.14  by  Michael Scheer
*CMZ :  3.06/00 18/02/2019  19.28.56  by  Michael Scheer
*CMZ :  2.70/02 14/12/2012  10.35.01  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE util_fold_function_gauss_lin(NF,XF,F,SIGMA,DNSIGMA,FG,WS1,WS2)
+seq,gplhint.

C--- SUBROUTINE TO EVALUATE THE FOLDED FUNCTION FG(X)=INT{F(XF)*G(XF-X),DXF}

C--   INPUT:

C-       NF:   NUMBER OF XF,F-VALUES
C-       XF:   ARRAY OF X-VALUES (MUST BE IN ASCENDING ORDER)
C-       F: ARRAY OF FUNCTION-VALUES
C-       SIGMA:  SIGMA OF GAUSSIAN
C-       DNSIGMA: NUMBER OF SIGMAS TO BE CONSIDERED

C--   OUTPUT:

C-       FG:   FG(X0) IS CALCULATED

      IMPLICIT NONE

+SELF,IF=-VMS.
      EXTERNAL FUNCTION DERF
+SELF.

      INTEGER NF,IH,IL,I

      REAL*8 XF(NF),F(NF),SIGMA,X0,FG(NF),DNSIGMA
      REAL*8 WS1(NF),WS2(NF)

      REAL*8 XL,XH,YL,YH,H,
     &  XHXL,XH2,XL2,SN,S2,ROOT2,SNR21,DERF,FGH,FGL,R2PI1,DX,X02,S22,
     &  SQPI2,X02S2,X023S2,SR2PI1,EPS

      DATA ROOT2/1.4142135623731D0/
      DATA R2PI1/0.398942280401433D0/
      DATA SQPI2/1.2533141373155D0/

C- CHECK ASCENDING ORDER

      DO I=2,NF
        IF (XF(I).LE.XF(I-1))
     &    STOP '*** ERROR SR UTIL_FOLD_FUNCTION_GAUSS_LIN:
     &    ARRAY XF NOT IN ASCENDING ORDER ***'
      ENDDO

      EPS=(XF(NF)-XF(1))*1.0D-10

      DO IL=1,NF-1

        IH=IL+1

        XL=XF(IL)
        XH=XF(IH)
        YL=F(IL)
        YH=F(IH)

        XHXL=XH*XL
        XH2=XH*XH
        XL2=XL*XL

        H=XH-XL

        IF (H.LE.0.0D0) THEN
          PRINT*,
     &      '*** ERROR SR UTIL_FOLD_GAUSS_LIN:'
          PRINT*,
     &      '*** ARRAY XF NOT IN ASCENDING ORDER'
          STOP
        ENDIF

        WS1(IL)=(XH*YL-XL*YH)/h
        WS2(IL)=(YH-YL)/h

        FG(IL)=0.0D0

      ENDDO !NF-1

      FG(NF)=0.0D0

      SN=DNSIGMA*SIGMA
      S2=SIGMA*SIGMA
      S22=2.0D0*S2
      SNR21=1.0D0/(ROOT2*SIGMA)
      SR2PI1=R2PI1/SIGMA

      DO I=1,NF


        X0=XF(I)

        X02=X0*X0
        X02S2=S2+X02
        X023S2=S22+X02S2

        IF (X0-SN.GE.XF(1)-EPS.AND.X0+SN.LE.XF(NF)+EPS) THEN

C UPPER BRANCH

          DO IL=I,NF-1

            IH=IL+1

            XL=XF(IL)
            XH=XF(IH)

            IF (XL-X0.LE.SN) THEN

              IF (XH-X0.GT.SN) XH=X0+SN

              DX=XH-X0

              FGH=
     &          SR2PI1*(-EXP(-DX**2/S22)*S2*WS2(IL)
     &          +SQPI2*SIGMA*(WS1(IL)+X0*WS2(IL))*
     &          DERF(DX*SNR21))

              DX=XL-X0

              FGL=
     &          SR2PI1*(-EXP(-DX**2/S22)*S2*WS2(IL)
     &          +SQPI2*SIGMA*(WS1(IL)+X0*WS2(IL))*
     &          DERF(DX*SNR21))

              FG(I)=FG(I)+FGH-FGL

            ELSE
              GOTO 81
            ENDIF ! (X-SN.GE.XF(1).AND.X+SN.LE.XF(NF))

          ENDDO !IL

 81       CONTINUE

C LOWER BRANCH

          DO IH=I,2,-1

            IL=IH-1

            XL=XF(IL)
            XH=XF(IH)

            IF (X0-XH.LE.SN) THEN

              IF (X0-XL.GT.SN) XL=X0-SN

              DX=XH-X0

              FGH=
     &          SR2PI1*(
     &          -EXP(-DX**2/S22)*S2*(
     &          WS2(IL))
     &          +SQPI2*SIGMA*(
     &          WS1(IL)
     &          +X0*(WS2(IL)))*
     &          DERF(DX*SNR21))

              DX=XL-X0

              FGL=
     &          SR2PI1*(
     &          -EXP(-DX**2/S22)*S2*(
     &          WS2(IL))
     &          +SQPI2*SIGMA*(
     &          WS1(IL)
     &          +X0*(WS2(IL)))*
     &          DERF(DX*SNR21))

              FG(I)=FG(I)+FGH-FGL

            ELSE
              GOTO 82
            ENDIF ! (X-SN.GE.XF(1).AND.X+SN.LE.XF(NF))

          ENDDO !IH

 82       CONTINUE

        ELSE IF (X0+SN.GT.XF(NF)) THEN

          GOTO 88

        ENDIF ! (X-SN.GE.XF(1).AND.X+SN.LE.XF(NF))

      ENDDO !NF

 88   CONTINUE

      RETURN
      END
+DECK,bxfel.
*CMZ :  3.01/00 04/07/2013  08.32.02  by  Michael Scheer
*CMZ :  3.00/02 09/04/2013  15.30.14  by  Michael Scheer
*CMZ :  3.00/01 28/03/2013  10.01.42  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine bxfel(xin,y,z,bxout,byout,bzout,axout,ayout,azout)
+seq,gplhint.

c +PATCH,//WAVE/UFOR
c +DECK,bxfel.
      implicit none

+seq,contrl.
+seq,uservar.
+seq,phycon.
+seq, halbasy.

      double precision xin,x,y,z,bx,by,bz,ax,ay,az,
     &  bxout,byout,bzout,
     &  axout,ayout,azout,
     &  sectlen,consttap,dbytap,dener,ctaper,ctaper1,ctaper2,
     &  defl,zperlenm,zperlencm,
     &  bdefl,pdum,eharm1,park,wlen1,ahwpolundu

      integer ical,iundu

      data ical/0/

      if (ical.eq.0) then

        zperlenm=user(5)
        sectlen=user(4)
        zperlencm=zperlenm*100.0d0

        bdefl=ECHARGE1*zperlenm/(2.0d0*pi1*emasskg1*clight1)
        defl=bdefl*user(1)
        park=defl
        park=echarge1*dabs(user(1))*zperlenm/(2.*pi1*emasskg1*clight1)
        wlen1=(1+park**2/2.)/2./dmygamma**2*zlhalbasy*1.d9
        if (wlen1.ne.0.0d0) eharm1=wtoe1/wlen1

        consttap=dmyenergy**2/(1.0d0+defl**2/2.0d0)
        ahwpolundu=user(6)

        pdum=0.5d-9/pi1*cgam1*dmycur*(clight1*emassg1)**2
        dener=-pdum*user(1)**2/2.0d0
     &    *(ahwpolundu*zperlenm/2.0d0)
     &    /dmycur/1.0d9
     &    *dmygamma**2 !loss per undu in GeV

        if (defl.ne.0.0d0) then
          dbytap=user(3)*2.0d0*dmyenergy*dener/defl/consttap/bdefl !correction factor for taper
        else
          dbytap=0.0d0
        endif

        write(16,*)' '
        write(16,*)'     Subroutine bxfel called:'
        write(16,*)' '
        write(16,*)'     B0 [T] and K of undulator:             ',user(1), defl
        write(16,*)'     B0 of phaseshifter:                    ',user(2)
        write(16,*)'     Scaling of taper:                      ',user(3)
        write(16,*)'     Length of section [m]:                 ',user(4)
        write(16,*)'     Period-length of undulators [m]:       ',user(5)
        write(16,*)'     X-position of first undulator [m]:     ',user(7)
        write(16,*)'     X-position of second undulator [m]:    ',user(8)
        write(16,*)'     Period-length of phase-shifters [m]:   ',user(9)
        write(16,*)'     X-position of first phase-shifter [m]: ',user(10)
        write(16,*)'     X-position of second phase-shifter [m]:',user(11)
        write(16,*)' '

        if (user(3).ne.0.0d0.and.ieneloss.eq.0) then
          write(6,*)' '
          write(6,*)'*** Warning in BXFEL: Taper is not zero, but IENELOSS!'
          write(6,*)' '
          write(16,*)' '
          write(16,*)'*** Warning in BXFEL: Taper is not zero, but IENELOSS!'
          write(16,*)' '
        endif

        write(16,*)'     Energy loss per undulator [GeV]:',-dener

        if (user(1).ne.0.0) then
          write(16,*)'     Rel. taper for By:',dbytap/user(1)
        else
          write(16,*)'     Rel. taper for By: 0.0'
        endif

        ical=1
      endif !ical

      x=mod(xin,sectlen)

      bxout=0.0d0
      byout=0.0d0
      bzout=0.0d0
      axout=0.0d0
      ayout=0.0d0
      azout=0.0d0

      iundu=xin/(sectlen/2.0d0)
      if (user(1).ne.0.0d0) then
        ctaper=1.0d0+(dbytap*iundu)/user(1)
      else
        ctaper=1.0d0
      endif
      ctaper1=ctaper

c first undulator

      nhhalbasy=0
      pkhalbasy=0.0d0
      b0halbasy=user(1)*ctaper
      xlhalbasy=0.0d0
      xkhalbasy=0.0d0
      zlhalbasy=zperlenm
      zkhalbasy=twopi1/zlhalbasy
      ylhalbasy=zlhalbasy
      ykhalbasy=zkhalbasy
      ahwpol=ahwpolundu
      xcenhal=user(7)
      call bhalbasy(x,y,z,bx,by,bz,ax,ay,az)
      bxout=bxout+bx
      byout=byout+by
      bzout=bzout+bz
      axout=axout+ax
      ayout=ayout+ay
      azout=azout+az

c first phase-shifter
      nhhalbasy=0
      pkhalbasy=0.0d0
      b0halbasy=user(2)*ctaper
      xlhalbasy=0.0d0
      xkhalbasy=0.0d0
      zlhalbasy=user(9)
      zkhalbasy=twopi1/zlhalbasy
      ylhalbasy=zlhalbasy
      ykhalbasy=zkhalbasy
      ahwpol=1.0d0
      xcenhal=user(10)
      call bhalbasy(x,y,z,bx,by,bz,ax,ay,az)
      bxout=bxout+bx
      byout=byout+by
      bzout=bzout+bz
      axout=axout+ax
      ayout=ayout+ay
      azout=azout+az

      iundu=iundu+1
      if (user(1).ne.0.0d0) then
        ctaper=1.0d0+(dbytap*iundu)/user(1)
      else
        ctaper=1.0d0
      endif
      ctaper2=ctaper

c second undulator
      nhhalbasy=0
      pkhalbasy=0.0d0
      b0halbasy=user(1)*ctaper
      xlhalbasy=0.0d0
      xkhalbasy=0.0d0
      zlhalbasy=zperlenm
      zkhalbasy=twopi1/zlhalbasy
      ylhalbasy=zlhalbasy
      ykhalbasy=zkhalbasy
      ahwpol=ahwpolundu
      xcenhal=user(8)
      call bhalbasy(x,y,z,bx,by,bz,ax,ay,az)
      bxout=bxout+bx
      byout=byout+by
      bzout=bzout+bz
      axout=axout+ax
      ayout=ayout+ay
      azout=azout+az

c second phase-shifter
      nhhalbasy=0
      pkhalbasy=0.0d0
      b0halbasy=user(2)*ctaper
      xlhalbasy=0.0d0
      xkhalbasy=0.0d0
      zlhalbasy=user(9)
      zkhalbasy=twopi1/zlhalbasy
      ylhalbasy=zlhalbasy
      ykhalbasy=zkhalbasy
      ahwpol=1.0d0
      xcenhal=user(11)
      call bhalbasy(x,y,z,bx,by,bz,ax,ay,az)
      bxout=bxout+bx
      byout=byout+by
      bzout=bzout+bz
      axout=axout+ax
      ayout=ayout+ay
      azout=azout+az

c quadrupoles

      if (x.gt.sectlen/2.0d0) then
        ctaper=ctaper2
      else
        ctaper=ctaper1
      endif
      call bmagseq(x,y,z,bx,by,bz,ax,ay,az)
      bxout=bxout+bx*ctaper
      byout=byout+by*ctaper
      bzout=bzout+bz*ctaper
      axout=axout+ax*ctaper
      ayout=ayout+ay*ctaper
      azout=azout+az*ctaper

      return
      end
+DECK,bue.
*CMZ :  4.00/15 19/03/2022  09.37.41  by  Michael Scheer
*CMZ :  4.00/13 07/11/2021  17.42.14  by  Michael Scheer
*CMZ :  4.00/07 09/07/2020  12.43.50  by  Michael Scheer
*CMZ :  3.03/02 18/03/2016  16.15.39  by  Michael Scheer
*CMZ :  3.02/05 13/04/2015  11.55.17  by  Michael Scheer
*CMZ :  3.01/02 31/07/2013  14.44.36  by  Michael Scheer
*CMZ :  3.01/01 31/07/2013  12.20.54  by  Michael Scheer
*CMZ :  3.01/00 18/07/2013  13.37.20  by  Michael Scheer
*-- Author :    Michael Scheer   12/07/2013
      subroutine bue(xin,yin,zin,bxout,byout,bzout,axout,ayout,azout,imag)
+seq,gplhint.

      implicit none


+seq,contrl.
+seq,primkin.
+seq,mgsqc.
+SEQ,cmpara.
+SEQ,freqs.
+seq,halbasy.
+seq,ustep.
+seq,phycon.

      double precision xin,yin,zin,bxout,byout,bzout,axout,ayout,azout,
     &  halfshift,bx,by,bz,ax,ay,az,park,beff,consttap,dbytap,wlen1,dener,pdum,
     &  b0old,pkold,xlold,ylold,zlold,fasymold,ahwpold,
     &  hhold,xcenold,b0h,b0v,rhv,b0eff,
     &  phi,sphi(nmgsqp),cphi(nmgsqp),xphi,zphi,xx,zz

      integer imag,iwarn,ical,i,iahwfouro,nhold

      save ical
      data iwarn/0/
      data ical/0/

      bxout=0.0d0
      byout=0.0d0
      bzout=0.0d0

      axout=0.0d0
      ayout=0.0d0
      azout=0.0d0

      b0old=b0halbasy
      pkold=pkhalbasy
      xlold=xlhalbasy
      ylold=ylhalbasy
      zlold=zlhalbasy
      fasymold=fasym
      ahwpold=ahwpol
      iahwfouro=iahwfour
      nhold=nhhalbasy
      hhold=hhalbasy
      xcenold=xcenhal

      fasym=2.0d0
      pkhalbasy=0.0d0
      park=pmag(1,imag)
      b0v=pmag(2,imag)
      b0h=pmag(3,imag)
      zlhalbasy=pmag(6,imag)
      xlhalbasy=pmag(8,imag)
      nhhalbasy=pmag(9,imag)
      hhalbasy=pmag(10,imag)

      if (nhhalbasy.ne.0.and.hhalbasy.ne.0.0d0) then
        if (hhalbasy.eq.-9999.0d0) then
          if (ifreq2p.eq.1) then
            hhalbasy=freqlow
          else
            hhalbasy=(freqlow+freqhig)/2.0d0
          endif
        else if (hhalbasy.lt.0.0d0) then
          hhalbasy=-wtoe1/hhalbasy
        endif
        WLEN1=wtoe1/abs(hhalbasy/nhhalbasy)
        park=2.0d0*(wlen1/(zlhalbasy*1.0D9/2.0d0/dmygammap**2)-1.0d0)
        if (park.lt.0.0d0) then
          write(6,*)
     &      '*** Error in BUE:'
          write(6,*)
     &      'Inconsistent values for undulator of file magseq.in!'
          write(6,*)' '
          write(lungfo,*)
     &      '*** Error in BUE:'
          write(lungfo,*)
     &      'Inconsistent values for undulator of file magseq.in!'
          write(lungfo,*)' '
          stop
        endif
        park=sqrt(park)
      endif

      IF (park.NE.0.0) THEN

        B0EFF=park/(echarge1*zlhalbasy/(2.*PI1*EMASSKG1*CLIGHT1))

        if (b0h.eq.0.0d0.and.b0v.eq.0d0) then
          b0v=b0eff/sqrt(2.0d0)
          b0h=b0v
        else if (b0h.eq.0.0d0.and.b0v.ne.0d0) then
          b0v=b0v/abs(b0v)*b0eff
        else if (b0v.eq.0.0d0.and.b0h.ne.0d0) then
          b0h=b0h/abs(b0h)*b0eff
        else

          rhv=b0h/b0v

          b0h=b0eff/sqrt(1.0d0+1.0d0/rhv**2)*b0h/abs(b0h)
          b0v=b0h/rhv

        endif

        ! To avoid repetitions of initializations
        pmag(1,imag)=0.0d0
        pmag(2,imag)=b0v
        pmag(3,imag)=b0h
        pmag(9:10,imag)=0.0d0

      ENDIF

      if (b0v.eq.0.0d0.and.b0h.eq.0.0d0) return

      zkhalbasy=twopi1/zlhalbasy

      if(xlhalbasy.ne.0.0d0) then
        xkhalbasy=twopi1/xlhalbasy
        YKHALBASY=DSQRT(ZKHALBASY**2+XKHALBASY**2)
        ylhalbasy=twopi1/ykhalbasy
      else
        xkhalbasy=0.0d0
        YKHALBASY=ZKHALBASY
        YLHALBASY=ZLHALBASY
      endif

      ahwpol=(pmag(7,imag)-1.0d0)*2.0d0+1.0d0
      halfshift=pmag(4,imag)/2.0d0*zlhalbasy
      xcenhal=pmag(5,imag)-halfshift

c{ taper to adapt field strength to energy loss
      dbytap=0.0d0

      if (pmag(11,imag).ne.0.0d0) then

        if (ieneloss.eq.0.and.iwarn.eq.0) then
          write(lungfo,*)' '
          write(lungfo,*)'*** Warning in BUE: Taper found, but IENELOSS is zero!'
          write(lungfo,*)'*** Note: This factor scales the whole device. It is ment for a series of undulators ***'
          write(lungfo,*)' '
          write(6,*)' '
          write(6,*)'*** Warning in BUE: Taper found, but IENELOSS is zero!'
          write(6,*)'*** Note: This factor scales the whole device. It is ment for a series of undulators ***'
          write(6,*)' '
          iwarn=1
        endif

        beff=sqrt(b0h**2+b0v**2)
        park=beff*echarge1*zlhalbasy/(2.0d0*pi1*emasskg1*clight1)
        wlen1=(1+park**2/2.0d0)/2.0d0/dmygammaP**2*zlhalbasy*1.0d9
        consttap=dmyenergyP**2/(1.0d0+park**2/2.0d0)
        pdum=0.5d-9/pi1*cgam1*dmycur*(clight1*emassg1)**2
        dener=-pdum*beff**2/2.0d0
     &    *(ahwpol*zlhalbasy/2.0d0)
     &    /dmycur/1.0d9
     &    *dmygammaP**2 !loss per undu in GeV
        if (dmygammaP.ne.0.0d0) then
          dener=dmyenergyP*(gammaustep-dmygammaP)/dmygammaP !actual loss
        endif
        if (park.ne.0.0d0) then
          dbytap=pmag(11,imag)*
     &      2.0d0*dmyenergyP*dener/park**2/consttap !correction factor for taper
        else
          dbytap=0.0d0
        endif
      endif
      b0halbasy=b0v*(1.0d0+dbytap)
c} taper

      if (ical.eq.0) then
        do i=1,mmag
          phi=pmag(13,i)
          sphi(i)=sin(phi)
          cphi(i)=cos(phi)
        enddo
        ical=1
      endif

      if (b0v.ne.0.0d0) then
        pkhalbasy=0.0d0
        phi=pmag(13,imag)
        xx=xin-xcenhal
        zz=zin-pmag(12,imag)
        if (phi.ne.0.0d0) then
          xphi= cphi(imag)*xx+sphi(imag)*zz
          zphi=-sphi(imag)*xx+cphi(imag)*zz
        else
          xphi=xx
          zphi=zz
        endif
        call bhalbasy2(xphi,yin,zphi,bx,by,bz,ax,ay,az)
        bxout=bxout+bx
        byout=byout+by
        bzout=bzout+bz
        axout=axout+ax
        ayout=ayout+ay
        azout=azout+az
      endif
      if (b0h.ne.0.0d0) then
        b0halbasy=b0h*(1.0d0+dbytap)
        xcenhal=pmag(5,imag)+halfshift
        phi=pmag(13,imag)
        xx=xin-xcenhal
        zz=zin-pmag(12,imag)
        if (phi.ne.0.0d0) then
          xphi= cphi(imag)*xx+sphi(imag)*zz
          zphi=-sphi(imag)*xx+cphi(imag)*zz
        else
          xphi=xx
          zphi=zz
        endif
        call bhalbasy2(xphi,yin,zphi,bx,by,bz,ax,ay,az)
        bxout=bxout-bx
        byout=byout+bz
        bzout=bzout-by
        axout=axout+ax
        ayout=ayout+ay
        azout=azout+az
      endif

      b0halbasy=b0old
      pkhalbasy=pkold
      xlhalbasy=xlold
      ylhalbasy=ylold
      zlhalbasy=zlold
      fasym=fasymold
      ahwpol=ahwpold
      iahwfour=iahwfouro
      nhhalbasy=nhold
      hhalbasy=hhold
      xcenhal=xcenold

      return
      end
+DECK,hlimitm.
*CMZ :  4.00/14 21/12/2021  10.43.42  by  Michael Scheer
*CMZ :  4.00/13 16/12/2021  12.18.27  by  Michael Scheer
*CMZ :  3.02/00 01/09/2014  11.11.30  by  Michael Scheer
*CMZ :  3.01/06 20/06/2014  17.35.22  by  Michael Scheer
*CMZ :  3.01/05 11/06/2014  16.01.34  by  Michael Scheer
*-- Author :    Michael Scheer   11/06/2014
      subroutine hlimitm(limit)
+seq,gplhint.
      implicit none

+seq,contrl.

      integer limit

+self,if=-nohbook.
      call hlimit(limit)
+self.
+self,if=mshhbook.
      call msh_hlimit(int8(limit))
+self.
+self,if=mhbook.
      call mh_limit(limit)
+self.

      return
      end
+DECK,hcdirm.
*CMZ :  3.01/06 23/06/2014  16.20.53  by  Michael Scheer
*CMZ :  3.01/05 12/06/2014  14.30.41  by  Michael Scheer
*CMZ :  0.01/03 09/06/2014  19.15.40  by  Michael Scheer
*CMZ :  0.01/01 01/06/2014  10.32.37  by  Michael Scheer
*-- Author :    Michael Scheer   29/04/2014
      subroutine hcdirm(chpath,chopt)
+seq,gplhint.

      character(*) chpath
      character chopt

+self,if=-nohbook.
      call hcdir(chpath,chopt)
+self.,if=-nohbook.
+self,if=mshnohbook.
      call msh_hcdir(chpath,chopt)
+self.
      return
      end
+DECK,hrendm.
*CMZ :  4.00/14 22/12/2021  14.17.18  by  Michael Scheer
*CMZ :  3.02/00 28/08/2014  15.38.08  by  Michael Scheer
*CMZ :  3.01/05 12/06/2014  08.56.14  by  Michael Scheer
*CMZ :  0.01/03 09/06/2014  18.39.35  by  Michael Scheer
*-- Author :    Michael Scheer   09/06/2014
      subroutine hrendm(chpath)
+seq,gplhint.

      implicit none

      character(*) chpath
+self,if=-nohbook.
      call hrend(chpath)
+self.
+self,if=mshhbook.
      call msh_hrend(chpath)
+self.
+self,if=mhbook.
      call mh_rend(chpath)
+self.
      return
      end
+DECK,hropenm.
*CMZ :  4.00/14 21/12/2021  10.52.20  by  Michael Scheer
*CMZ :  4.00/13 16/12/2021  12.18.27  by  Michael Scheer
*CMZ :  3.02/00 01/09/2014  11.11.30  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  16.20.53  by  Michael Scheer
*CMZ :  3.01/05 12/06/2014  09.50.37  by  Michael Scheer
*CMZ :  0.01/03 10/06/2014  09.35.54  by  Michael Scheer
*CMZ :  0.01/01 01/06/2014  10.32.37  by  Michael Scheer
*-- Author :    Michael Scheer   29/04/2014
      subroutine hropenm(lun,chpath,filehb,chopt,lrec,istat)
+seq,gplhint.

      implicit none

      integer lun,lrec,istat
      character(*) chpath,filehb,chopt

+self,if=-nohbook.
      call hropen(lun,chpath,filehb,chopt,lrec,istat)
+self.,if=-nohbook.

+self,if=mshhbook.
      call msh_hropen(int8(lun),chpath)
+self.

+self,if=mhbook.
      call mh_path(chpath)
      call mh_fopen(trim(chpath) // '.mhb')
+self.

      return
      end
+DECK,hldirm.
*CMZ :  4.00/13 19/12/2021  10.42.37  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  16.20.53  by  Michael Scheer
*CMZ :  3.01/05 12/06/2014  12.16.49  by  Michael Scheer
*CMZ :  0.01/03 11/06/2014  11.35.22  by  Michael Scheer
*CMZ :  0.01/02 06/06/2014  16.22.45  by  Michael Scheer
*CMZ :  0.01/01 01/06/2014  13.01.56  by  Michael Scheer
*CMZ :  0.01/00 29/04/2014  12.02.22  by  Michael Scheer
*CMZ :  0.00/02 29/04/2014  09.10.41  by  Michael Scheer
*CMZ :  0.00/01 28/04/2014  20.38.18  by  Michael Scheer
*-- Author :    Michael Scheer   26/04/2014
      subroutine hldirm(chpath,chopt)
+seq,gplhint.

      implicit none

      character(*) chpath,chopt

+self,if=-nohbook.
      call hldir(chpath,chopt)
+self.,if=-nohbook.
+self,if=mshhbook.
      write(99,*)'!'
      write(99,*)'! msh_hbook:'
      write(99,*)'!'
      call msh_hldir(chpath,chopt)
+self.
+self,if=mhbook.
      call mh_index
+self.
      return
      end
+DECK,hroutm.
*CMZ :  4.00/13 16/12/2021  12.18.27  by  Michael Scheer
*CMZ :  3.02/06 15/04/2015  12.14.45  by  Michael Scheer
*CMZ :  3.02/00 01/09/2014  11.11.30  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  16.20.53  by  Michael Scheer
*CMZ :  3.01/05 12/06/2014  09.02.36  by  Michael Scheer
*CMZ :  0.01/03 11/06/2014  12.18.23  by  Michael Scheer
*CMZ :  0.01/02 06/06/2014  16.06.01  by  Michael Scheer
*CMZ :  0.01/01 02/06/2014  10.26.01  by  Michael Scheer
*CMZ :  0.01/00 29/04/2014  12.04.58  by  Michael Scheer
*CMZ :  0.00/02 29/04/2014  09.07.49  by  Michael Scheer
*CMZ :  0.00/01 28/04/2014  20.49.27  by  Michael Scheer
*-- Author :    Michael Scheer   26/04/2014
+seq,gplhint.
      subroutine hroutm(id,icycle,chopt)

      implicit none

      integer id,icycle
      character(*) chopt

+self,if=-nohbook.
      call hrout(id,icycle,chopt)
+self.,if=-nohbook.
+self,if=mshhbook.
      call msh_hrout(int8(id))
+self.
+self,if=mhbook.
      call mh_rout(id)
+self.
      return
      end
+DECK,util_sort_func_integer.
*CMZ :  3.01/05 03/06/2014  08.39.05  by  Michael Scheer
*CMZ : 00.00/15 05/01/2012  13.52.39  by  Michael Scheer
*CMZ : 00.00/00 11/01/95  11.41.04  by  Michael Scheer
*-- Author :
      SUBROUTINE UTIL_SORT_FUNC_INTEGER(N,IA,IYA)
+seq,gplhint.

C--- HEAPSORT ROUTINE; SEE NUMERICAL RECIPES 8.2 S 231
C--- ARRAY YA IS FUNCTION OF IA AND SORTED ACCORDINGLY

      IMPLICIT NONE

      INTEGER N,L,IR,I,J

      integer IA(N),IRA
      integer IYA(N),IYYA

      if (n.lt.2) return

      L=N/2+1
      IR=N
10    CONTINUE
        IF(L.GT.1)THEN
          L=L-1
          IRA=IA(L)
          IYYA=IYA(L)
        ELSE
          IRA=IA(IR)
          IYYA=IYA(IR)
          IA(IR)=IA(1)
          IYA(IR)=IYA(1)
          IR=IR-1
          IF(IR.EQ.1)THEN
            IA(1)=IRA
            IYA(1)=IYYA
            RETURN
          ENDIF
        ENDIF
        I=L
        J=L+L
20      IF(J.LE.IR)THEN
          IF(J.LT.IR)THEN
            IF(IA(J).LT.IA(J+1))J=J+1
          ENDIF
          IF(IRA.LT.IA(J))THEN
            IA(I)=IA(J)
            IYA(I)=IYA(J)
            I=J
            J=J+J
          ELSE
            J=IR+1
          ENDIF
        GO TO 20
        ENDIF
        IA(I)=IRA
        IYA(I)=IYYA
      GO TO 10
      END
+DECK,htitlem.
*CMZ :  3.02/00 28/08/2014  15.25.03  by  Michael Scheer
*CMZ :  3.01/05 12/06/2014  09.41.03  by  Michael Scheer
*-- Author :    Michael Scheer   12/06/2014
      subroutine htitlem(chtit)
+seq,gplhint.

      implicit none

      character(*) chtit
+self,if=-nohbook
      call htitle(chtit)
+self.
      return
      end
+DECK,hfntm.
*CMZ :  3.02/00 01/09/2014  11.11.30  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  16.20.53  by  Michael Scheer
*CMZ :  3.01/05 12/06/2014  11.31.59  by  Michael Scheer
*-- Author :    Michael Scheer   12/06/2014
      subroutine hfntm(id)
+seq,gplhint.

      implicit none

      integer id

+self,if=-nohbook.
      call hfnt(id)
+self.,if=-nohbook.
+self,if=mshhbook.
      call msh_hfnt(int8(id))
+self.

      return
      end
+DECK,hbnamcm.
*CMZ :  3.02/00 01/09/2014  11.11.30  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  16.20.53  by  Michael Scheer
*CMZ :  3.01/05 12/06/2014  11.36.15  by  Michael Scheer
*CMZ :  0.01/03 10/06/2014  12.32.31  by  Michael Scheer
*CMZ :  0.01/02 06/06/2014  15.14.16  by  Michael Scheer
*CMZ :  0.01/01 01/06/2014  13.01.56  by  Michael Scheer
*CMZ :  0.01/00 29/04/2014  12.02.22  by  Michael Scheer
*CMZ :  0.00/02 29/04/2014  09.10.41  by  Michael Scheer
*CMZ :  0.00/01 28/04/2014  20.38.18  by  Michael Scheer
*-- Author :    Michael Scheer   26/04/2014
      subroutine hbnamcm(id,cvarnam,caddr,cvarline)
+seq,gplhint.

      implicit none

      character(*) cvarnam,cvarline
      character(32)caddr

      integer id

+self,if=-nohbook.
      call hbnamc(id,cvarnam,caddr,cvarline)
+self.,if=-nohbook.
+self,if=mshhbook.
      call msh_hbnamc(int8(id),cvarnam,caddr,cvarline)
+self.

      return
      end
+DECK,houtpum.
*CMZ :  3.02/00 01/09/2014  11.11.30  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  16.20.53  by  Michael Scheer
*CMZ :  3.01/05 12/06/2014  12.05.31  by  Michael Scheer
*-- Author :    Michael Scheer   12/06/2014
      subroutine houtpum(lun)
+seq,gplhint.
      implicit none
      integer lun

+self,if=-nohbook.
      call houtpu(lun)
+self.,if=-nohbook.
+self,if=mshhbook.
      call msh_houtpu(int8(lun))
+self.

      return
      end
+DECK,hbntm.
*CMZ :  3.02/00 15/10/2014  13.45.08  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  16.20.53  by  Michael Scheer
*CMZ :  3.01/05 13/06/2014  09.06.00  by  Michael Scheer
*CMZ :  0.01/03 09/06/2014  16.53.01  by  Michael Scheer
*CMZ :  0.01/02 06/06/2014  15.14.16  by  Michael Scheer
*CMZ :  0.01/01 01/06/2014  13.01.56  by  Michael Scheer
*CMZ :  0.01/00 29/04/2014  12.02.22  by  Michael Scheer
*CMZ :  0.00/02 29/04/2014  09.10.41  by  Michael Scheer
*CMZ :  0.00/01 28/04/2014  20.38.18  by  Michael Scheer
*-- Author :    Michael Scheer   26/04/2014
      subroutine hbntm(id,title,chopt)
+seq,gplhint.

      implicit none

      integer id
      character(*) title
      character chopt

+self,if=-nohbook.
      call hbnt(id,title,chopt)
+self.,if=-nohbook.
+self,if=mshhbook.
      call msh_hbnt(int8(id),title,chopt)
+self.

      return
      end
+DECK,hgivem.
*CMZ :  4.00/14 31/12/2021  11.06.17  by  Michael Scheer
*CMZ :  3.02/04 12/12/2014  15.08.21  by  Michael Scheer
*CMZ :  3.02/03 10/11/2014  16.17.19  by  Michael Scheer
*CMZ :  3.02/00 01/09/2014  11.11.30  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  16.20.53  by  Michael Scheer
*CMZ :  3.01/05 13/06/2014  09.09.29  by  Michael Scheer
*CMZ :  0.01/03 09/06/2014  16.23.45  by  Michael Scheer
*CMZ :  0.01/02 06/06/2014  15.14.16  by  Michael Scheer
*CMZ :  0.01/01 02/06/2014  09.51.44  by  Michael Scheer
*CMZ :  0.01/00 29/04/2014  12.04.58  by  Michael Scheer
*CMZ :  0.00/02 29/04/2014  09.07.49  by  Michael Scheer
*CMZ :  0.00/01 28/04/2014  20.49.27  by  Michael Scheer
*-- Author :    Michael Scheer   26/04/2014
      subroutine hgivem(id,title,nchax,xmin,xmax,nchay,ymin,ymax,nwt,loc)
+seq,gplhint.

      implicit none

      integer*8 nchax8,nwt8,loc8,nchay8
      double precision xmin8,xmax8,ymin8,ymax8
      integer nchax,nchay,nwt,loc
      integer id
      real*4 x,y,xmin,xmax,ymin,ymax
      character(*) title

+self,if=-nohbook.
      call hgive(id,title,nchax,xmin,xmax,nchay,ymin,ymax,nwt,loc)
+self.,if=-nohbook.
+self,if=mshhbook.
      call msh_hgive(int8(id),title,nchax8,
     &  xmin8,xmax8,nchay8,
     &  ymin8,ymax8,nwt8,loc8)
      nchax=int(nchax8)
      nchay=int(nchay8)
      nwt=int(nwt8)
      loc=int(loc8)
      xmin=sngl(xmin8)
      xmax=sngl(xmax8)
      ymin=sngl(ymin8)
      ymax=sngl(ymax8)
+self,if=mhbook.
      call mh_give(id,title,nchax,xmin8,xmax8,nchay,ymin8,ymax8,nwt,loc)
      xmin=sngl(xmin8)
      xmax=sngl(xmax8)
      ymin=sngl(ymin8)
      ymax=sngl(ymax8)
+self.
      return
      end
+DECK,hgivenm.
*CMZ :  3.02/00 11/10/2014  21.21.59  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  16.20.53  by  Michael Scheer
*CMZ :  3.01/05 13/06/2014  11.16.25  by  Michael Scheer
*CMZ :  0.01/03 11/06/2014  11.35.22  by  Michael Scheer
*CMZ :  0.01/02 06/06/2014  16.22.45  by  Michael Scheer
*CMZ :  0.01/01 01/06/2014  13.01.56  by  Michael Scheer
*CMZ :  0.01/00 29/04/2014  12.02.22  by  Michael Scheer
*CMZ :  0.00/02 29/04/2014  09.10.41  by  Michael Scheer
*CMZ :  0.00/01 28/04/2014  20.38.18  by  Michael Scheer
*-- Author :    Michael Scheer   26/04/2014
      subroutine hgivenm(id,title,nvar,chtag,rlow,rhigh)
+seq,gplhint.

      implicit none

+seq,ntupinfo.

      real rlow(nvar),rhigh(nvar)
      real*8 rlow8(nvar),rhigh8(nvar)
      character(*) title
      character(*) chtag(1)
      character(1024) cline
      integer nvar,id,i
      integer*8 nvar8

+self,if=-nohbook.
      call hgiven(id,title,nvar,chtag,rlow,rhigh)
      do i=1,nvar
        chtag(i)=chntuptags(i,id)
      enddo
+self.,if=-nohbook.
+self,if=mshhbook.
      call msh_hgiven(int8(id),title,nvar8,chtag,rlow8,rhigh8)
      nvar=int(nvar8)
      rlow=sngl(rlow8)
      rhigh=sngl(rhigh8)
+self.
      return
      end
+DECK,hscrm.
*CMZ :  3.02/00 28/08/2014  15.32.49  by  Michael Scheer
*CMZ :  3.01/05 13/06/2014  11.48.41  by  Michael Scheer
*-- Author :    Michael Scheer   13/06/2014
      subroutine hscrm(idoutp,iscratch,chopt)
+seq,gplhint.

      implicit none

      integer idoutp,iscratch
      character(*) chopt
+self,if=-nohbook.
      call hscr(idoutp,iscratch,chopt)
+self.
      return
      end
+DECK,hidallm.
*CMZ :  3.02/03 10/11/2014  13.03.11  by  Michael Scheer
*CMZ :  3.02/00 11/10/2014  21.23.39  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  16.20.53  by  Michael Scheer
*-- Author :    Michael Scheer   16/06/2014
      subroutine hidallm(idvect,nid)
+seq,gplhint.

      implicit none

      integer*8, dimension(:), allocatable :: idvect8

      integer idvect(*),nid
      integer*8 nid8,kid(1)

+self,if=-nohbook.
      call hidall(idvect,nid)
+self.
+self,if=mshhbook.
      kid(1)=-1
      call msh_hidall(kid,nid8) !get nid8
      allocate(idvect8(nid8))
      call msh_hidall(idvect8,nid8)
      nid=nid8
      idvect(1:nid)=int(idvect8)
      deallocate(idvect8)
+self.
      return
      end
+DECK,hgnparm.
*CMZ :  3.03/04 02/01/2018  13.11.31  by  Michael Scheer
*CMZ :  3.02/00 01/09/2014  11.51.42  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  16.20.53  by  Michael Scheer
*-- Author :    Michael Scheer   16/06/2014
      subroutine hgnparm(nid,chcaller)
+seq,gplhint.

      implicit none

      integer nid
      integer*8 nid8
      character(*) chcaller

+self,if=-nohbook.
      call hgnpar(nid,chcaller)
+self.
+self,if=mshhbook.
      nid8=nid
      call msh_hgnpar(nid8,chcaller)
      nid=int(nid8)
+self.
      return
      end
+DECK,hgnfm.
*CMZ :  3.02/00 11/10/2014  21.20.34  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  16.20.53  by  Michael Scheer
*-- Author :    Michael Scheer   16/06/2014
      subroutine hgnfm(nid,ieve,tup,ierr)
+seq,gplhint.

      implicit none

      integer nid,ieve,ierr,nidold
      integer*8 ierr8,nvar8

      real tup(*)
      real*8, dimension (:), allocatable :: tup8

      data nidold/-1/

+self,if=-nohbook.
      call hgnf(nid,ieve,tup,ierr)
+self.
+self,if=mshhbook.
      if (nidold.ne.nid) then
        if(nidold.ne.-1) deallocate(tup8)
        call msh_hgivenvar(int8(nid),nvar8)
        allocate(tup8(nvar8))
      endif

      call msh_hgnf(int8(nid),int8(ieve),tup8,ierr8)
      ierr=int(ierr8)
      tup(1:nvar8)=sngl(tup8)

      nidold=nid
+self.
      return
      end
+DECK,hnoentm.
*CMZ :  3.03/04 02/01/2018  15.25.04  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  16.20.53  by  Michael Scheer
*-- Author :    Michael Scheer   18/06/2014
      subroutine hnoentm(id,noent)
+seq,gplhint.

      implicit none

      integer*8 id8,n8
      integer id,noent

+self,if=-nohbook.
      call hnoent(id,noent)
+self.
+self,if=mshhbook.
      id8=id
      call msh_hnoent(id8,n8)
      noent=n8
+self.

      return
      end
+DECK,hijm.
*CMZ :  4.00/14 30/12/2021  08.56.54  by  Michael Scheer
*CMZ :  3.02/03 03/11/2014  14.37.56  by  Michael Scheer
*CMZ :  3.02/00 01/09/2014  11.49.55  by  Michael Scheer
*CMZ :  3.01/07 23/06/2014  16.20.53  by  Michael Scheer
*-- Author :    Michael Scheer   23/06/2014
      function hijm(id,ix,iy)
+seq,gplhint.

      implicit none
      double precision hij_mh
      real hijm,hij

+self,if=mshhbook.
      real*8 msh_hij
+self.,if=mshhbook.
      integer id,ix,iy

+self,if=-nohbook.
      hijm=hij(id,ix,iy)
+self.

+self,if=mshhbook.
      hijm=sngl(msh_hij(int8(id),int8(ix),int8(iy)))
+self.
+self,if=mhbook.
      hijm=sngl(hij_mh(id,ix,iy))
+self.
      return
      end
+DECK,util_file_delete.
*CMZ :  3.03/04 02/01/2018  14.56.04  by  Michael Scheer
*CMZ :  3.01/07 23/06/2014  15.51.32  by  Michael Scheer
*CMZ : 00.00/07 21/07/2009  14.58.29  by  Michael Scheer
*CMZ : 00.00/06 12/07/2007  15.45.32  by  Michael Scheer
*-- Author :    Michael Scheer   12/07/2007
      subroutine util_file_delete(file,istat)
+seq,gplhint.

      integer istat,lun

      character(*) file
      logical lexist,isopen

      istat=-1

      inquire(file=file,exist=lexist)

      if (lexist.eqv..false.) then
        istat=1
        return
      endif

      lun=1234567
      itry=0
1     itry=itry+1
      lun=lun+1
      inquire(unit=lun,opened=isopen)
      if (itry.gt.10) then
        istat=2
        return
      endif
      if (isopen) goto 1

      open(unit=lun,file=file,status='old')
      close(lun,status='delete')

      istat=0

      return
      end
+DECK,him.
*CMZ :  4.00/14 30/12/2021  09.39.43  by  Michael Scheer
*CMZ :  3.02/03 03/11/2014  13.39.06  by  Michael Scheer
*CMZ :  3.02/00 01/09/2014  11.11.30  by  Michael Scheer
*CMZ :  3.01/07 23/06/2014  16.20.53  by  Michael Scheer
*-- Author :    Michael Scheer   23/06/2014
      function him(id,ix)
+seq,gplhint.

      implicit none

      double precision hi_mh
      real him,hi

+self,if=mshhbook.
      real*8 msh_hi
+self.,if=mshhbook.
      integer id,ix

+self,if=-nohbook.
      him=hi(id,ix)
+self.

+self,if=mshhbook.
      him=sngl(msh_hi(int8(id),int8(ix)))
+self.
+self,if=mhbook.
      him=sngl(hi_mh(id,ix))
+self.
      return
      end
+DECK,util_spline_interpolation_f90.
*CMZ :  3.02/00 24/09/2014  13.52.37  by  Michael Scheer
*CMZ :  3.01/08 09/07/2014  08.54.01  by  Michael Scheer
*CMZ : 00.00/15 12/10/2013  12.19.05  by  Michael Scheer
*CMZ : 00.00/11 07/06/2011  14.38.25  by  Michael Scheer
*CMZ : 00.00/07 07/06/2011  13.46.51  by  Michael Scheer
*CMZ : 00.00/06 06/07/2007  16.55.15  by  Michael Scheer
*CMZ : 00.00/02 25/08/2006  15.16.22  by  Michael Scheer
*CMZ : 00.00/01 23/02/96  14.56.50  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.27.54  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE UTIL_SPLINE_INTERPOLATION_f90(N,XA,YA,X,Y,Y2A,MODE)

C---  INTERPOLATES Y(X) VIA SPLINE

C--   INPUT:

C-       N: NUMBER OF X,Y-VALUES
C-       XA:   ARRAY OF X-VALUES
C-       YA:   ARRAY OF Y-VALUES
C-       X: Y(X) IS CALCULATED
C-       MODE: CONTROL FLAG:
C-             MODE.GE.0: USE VALUES OF LAST CALL TO START WITH
C-             MODE.LT.0: NEW INITIALIZATION

C--   OUTPUT:

C-       Y: Y(X) IS CALCULATED
C-     Y2A: SECOND DERIVATE OF YA(XA), I.E. SPLINE COEFFICIENTS

      IMPLICIT NONE

      double precision Y,X,XA1OLD,XANOLD,H,A,B
      double precision XA(*),YA(*),Y2A(*)

      INTEGER NOLD,N,KLO,KHI,KLOLD,K,MODE

      DATA KLOLD/1/,NOLD/-99/
      DATA XA1OLD/-9999.D0/,XANOLD/-9999./

      IF(N.lt.3) THEN
        STOP '*** ERROR IN UTIL_SPLINE_INTER_F90: LESS THAN 3 POINTS GIVEN***'
      ENDIF

      IF(XA(1).LT.XA(N).AND.(X.LT.XA(1).OR.X.GT.XA(N))
     &    .OR.
     &    XA(N).LT.XA(1).AND.(X.LT.XA(N).OR.X.GT.XA(1))) THEN
        WRITE(6,*)'XA(1), XA(N):',XA(1), XA(N)
        WRITE(6,*)'X:',X
        STOP '*** ERROR IN UTIL_SPLINE_INTER_F90: X OUT OF RANGE ***'
      ENDIF

      IF (MODE.LT.0.OR.KLOLD.GE.N) THEN
        CALL UTIL_SPLINE_COEF_F90(XA,YA,N,9999.0d0,9999.0d0,Y2A)
        KLO=1
      ELSE IF(NOLD.EQ.N
     &    .AND. XA(1).EQ.XA1OLD
     &    .AND. XA(N).EQ.XANOLD
     &    .AND. X.GT.XA(KLOLD)
     &    ) THEN
        KLO=KLOLD
      ELSE
        KLO=1
      ENDIF

      IF (X.LT.XA(KLO+1)) THEN
        KHI=KLO+1
        GOTO 2
      ENDIF

      KHI=N
1     IF (KHI-KLO.GT.1) THEN
        K=(KHI+KLO)/2
        IF(XA(K).GT.X)THEN
          KHI=K
        ELSE
          KLO=K
        ENDIF
        GOTO 1
      ENDIF

2     H=XA(KHI)-XA(KLO)

      IF (H.le.0.D0) THEN
        PRINT*,'*** ERROR IN UTIL_SPLINE_INTER_F90: BAD INPUT ***'
        STOP
      ENDIF

      A=(XA(KHI)-X)/H
      B=(X-XA(KLO))/H
      Y=A*YA(KLO)+B*YA(KHI)+
     &  (A*(A+1.D0)*(A-1.D0)*Y2A(KLO)+B*(B+1.D0)*
     &  (B-1.D0)*Y2A(KHI))*(H**2)/6.D0

      KLOLD=KLO
      NOLD=N
      XA1OLD=XA(1)
      XANOLD=XA(N)

      RETURN
      END
+DECK,util_get_free_lun.
*CMZ :  3.02/00 10/10/2014  16.01.29  by  Michael Scheer
*CMZ : 00.00/07 21/07/2009  14.58.29  by  Michael Scheer
*CMZ : 00.00/06 12/07/2007  15.45.32  by  Michael Scheer
*-- Author :    Michael Scheer   12/07/2007
      subroutine util_get_free_lun(lun)

      integer lun,luni

      logical isopen

      luni=abs(lun)

1     continue
      inquire(unit=luni,opened=isopen)
      if (isopen) then
        luni=luni+1
        goto 1
      endif

      lun=luni

      return
      end
+DECK,hrndm1m.
*CMZ :  3.02/00 09/09/2014  11.43.48  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  16.20.53  by  Michael Scheer
*CMZ :  3.01/05 12/06/2014  11.20.34  by  Michael Scheer
*CMZ :  2.70/07 14/01/2013  16.55.40  by  Michael Scheer
*CMZ :  2.68/05 28/09/2012  09.17.41  by  Michael Scheer
*CMZ :  2.67/01 21/02/2012  10.32.09  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  12.51.13  by  Michael Scheer
*-- Author :    Michael Scheer   21/01/2012
      function hrndm1m(id)
+seq,gplhint.

      implicit none

      integer id
      real hrndm1m

      hrndm1m=id

      stop '*** hrndm1m noch nicht fertig!'

      return
      end
+DECK,specdip4.
*CMZ :  4.01/07 29/10/2024  15.06.12  by  Michael Scheer
*CMZ :  4.01/03 12/06/2023  11.28.30  by  Michael Scheer
*CMZ :  3.08/01 02/04/2019  15.33.15  by  Michael Scheer
*CMZ :  3.02/00 18/09/2014  14.21.18  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE SPECDIP4
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,TRACKF90U.

C--- FILL ARRAY SPEC WITH DIPOL SPECTRUM FUNCTION

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,COLLI.
+SEQ,FREQS.
+seq,sourcef90.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,TRACK.
+SEQ,SPECDIP.
+SEQ,PHYCON.
+seq,datetime.

      INTEGER ISOUR,IFREQ,IOBSV,ISPLN,ITANG,I,IC,JC,IFAIL,J,JDX10,JX10,IX10
     &  ,IWARN,IEPS,IWARNOB

      DOUBLE PRECISION T,XT,YT,ZT,VXT,VYT,VZT,VXP,VYP,VZP,BS
      DOUBLE PRECISION RX,RY,RZ,RR3,RR,PSI,DFDTDP,PAR,PER,POWR,OBANG,OBANGMN
     &  ,ANG3(3),XT3(3),YT3(3),ZT3(3),VXT3(3),VYT3(3),VZT3(3),A(3),
     &  dum3(3)
      DOUBLE PRECISION Y,OMEGAC,BX,BY,BZ,BRX,BRY,BRZ,RN,VN,DUM,BRN

      DOUBLE PRECISION DX2,DZY2,EPS(6),DRRED,ANS,OM,
     &  APERANG,APERV(3),APERCORR,
     &  RXX,RYY,RZZ,RRN,RRR,
     &  GAMMA,speck

      REAL STOK1,STOK2,STOK3,STOK4

      COMPLEX*16 APOL,AFREQ(3),EXPOM
      COMPLEX*8 APOLH,APOLR,APOLL,APOL45

      integer :: ical=0
      save ical

      DATA JX10/0/

      CALL date_and_time(dtday,dttime,dtzone,idatetime)

      WRITE(6,*)
      WRITE(6,*)' Starting spectrum calculations according to SCHWINGER: '
     &  ,dttime(1:2),':',dttime(3:4),':',dttime(5:6)
      WRITE(6,*)

      if (ical.eq.0.and.iphase.ne.0) then
        write(lungfo,*)'*** WARNING IN SPECDIP4: Calculation for B-Field-Amplitude for phase propagation not yet implement ***'
        write(6,*)'*** WARNING IN SPECDIP4: Calculation for B-Field-Amplitude for phase propagation not yet implement ***'
        ical=1
      endif

      GAMMA=DMYGAMMA

      IF (APERTHICK.GT.0.0D0) THEN

        APERV(2)=SIN(APERVANG)
        APERV(3)=SIN(APERHANG)
        APERV(1)=SQRT(1.0D0-(APERV(2)**2+APERV(3)**2))

      ELSE

        APERV=0.0D0
        APERHANG=0.0D0
        APERVANG=0.0D0

      ENDIF

      IF (NOBSV.GT.1) THEN
        WRITE(6,*)' '
        WRITE(6,*)
     &    '      counting from 1 to 10 for first source to show progress:'
        WRITE(6,*)' '
      ENDIF

      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     Subroutine SPECDIP4 called to calculate spectra according to SCHWINGER'
      WRITE(LUNGFO,*)
     &  '     for found sources:'
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)
     &  '     photon energy cut-off parameter (SPECCUT): ',SNGL(SPECCUT)
      WRITE(LUNGFO,*)
      WRITE(LUNGFO,*)'     thickness of aperture pinhole [m]:',sngl(aperthick)
      WRITE(LUNGFO,*)'     hor. and vert. angle of aperture [rad]:',
     &  sngl(aperhang),sngl(apervang)
      WRITE(LUNGFO,*)

      JDX10=NOBSV/10
      JX10=JDX10
      IX10=1

      IF (JDX10.LT.1) JDX10=1

      DO ISOUR=1,NSOURCE

        IWARN=0
        IWARNOB=0
        DO JC=1,4
          DO IC=1,3
            SOURCEAO(IC,JC,ISOUR)=SOURCEA(IC,JC,ISOUR)
            SOURCEEO(IC,JC,ISOUR)=SOURCEE(IC,JC,ISOUR)
          ENDDO
        ENDDO
        CALL TRASOU(ISOUR)

        DO IOBSV=1,NOBSV

          DO I=1,MCO

            T=DWT(I)

            CALL WAVE_TRACK_INTER
     &        (T,XT,YT,ZT,VXT,VYT,VZT,VXP,VYP,VZP,BS,ISPLN,GAMMA)

            RX=OBSV(1,IOBSV)-XT
            RY=OBSV(2,IOBSV)-YT
            RZ=OBSV(3,IOBSV)-ZT

            IF (RX.LE.0.D0) THEN
              WRITE(LUNGFO,*)'*** ERROR IN SPECDIPA:'
              WRITE(LUNGFO,*)'BAD X-DISTANCE FROM SOURCE TO OBSERVER'
              WRITE(LUNGFO,*)'CHECK INPUT FILE'
              WRITE(6,*)'*** ERROR IN SPECDIPA:'
              WRITE(6,*)'BAD X-DISTANCE FROM SOURCE TO OBSERVER'
              WRITE(6,*)'CHECK INPUT FILE'
              STOP '--- PROGRAM WAVE ABORTED ---'
            ENDIF

            RR=RX*RX+RY*RY+RZ*RZ
            RN=SQRT(RR)
            VN=SQRT(VXT*VXT+VYT*VYT+VZT*VZT)
            VXT=VXT/VN
            VYT=VYT/VN
            VZT=VZT/VN
            OBANG=ACOS(MIN((RX*VXT+RY*VYT+RZ*VZT)/RN,1.D0))

            CALL MYBFELD(XT,YT,ZT,BX,BY,BZ,DUM,DUM,DUM)

            BS=BX*VXT+BY*VYT+BZ*VZT
            BX=BX-BS*VXT
            BY=BY-BS*VYT
            BZ=BZ-BS*VZT
            BS=SQRT(BX*BX+BY*BY+BZ*BZ)
            BRX=BY*RZ-BZ*RY
            BRY=BZ*RX-BX*RZ
            BRZ=BX*RY-BY*RX
            BRN=SQRT(BRX*BRX+BRY*BRY+BRZ*BRZ)

            IF (BS.NE.0.D0) THEN
              PSI=ACOS(MIN(BRN/BS/RN,1.D0))
     &          *SIGN(1.D0,BX*RX+BY*RY+BZ*RZ)
            ELSE
              PSI=0.D0
            ENDIF

            X0DIP(1)=XT
            Y0DIP(1)=YT
            Z0DIP(1)=ZT
            B0DIP(1)=BS

            IF (B0DIP(1).NE.0.D0) THEN
              RHODIP(1)=EMOM/B0DIP(1)/CLIGHT1
            ELSE
              WRITE(LUNGFO,*)'*** ERROR IN SPECDIP ***'
              WRITE(LUNGFO,*)'zero magnetic field for dipole ',ISOUR
              WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
              WRITE(6,*)'*** ERROR IN SPECDIPA ***'
              WRITE(6,*)'zero magnetic field for dipole ',ISOUR
              WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
              STOP
            ENDIF

            OMEGAC=1.5D0*GAMMA**3*CLIGHT1/RHODIP(1)
            ECDIP(1)=OMEGAC*HBAR1/ECHARGE1

            IF (APERTHICK.GT.0.0D0) THEN

              RXX=OBSV(1,ICBRILL)-X0DIP(ISOUR)
              RYY=OBSV(2,ICBRILL)-Y0DIP(ISOUR)
              RZZ=OBSV(3,ICBRILL)-Z0DIP(ISOUR)

              IF (RXX.LE.0.D0) THEN
                WRITE(LUNGFO,*)'*** ERROR IN SPECDIP:'
                WRITE(LUNGFO,*)'BAD X-DISTANCE FROM SOURCE TO OBSERVER'
                WRITE(LUNGFO,*)'CHECK INPUT FILE'
                WRITE(6,*)'*** ERROR IN SPECDIP:'
                WRITE(6,*)'BAD X-DISTANCE FROM SOURCE TO OBSERVER'
                WRITE(6,*)'CHECK INPUT FILE'
                STOP '--- PROGRAM WAVE ABORTED ---'
              ENDIF

              RRR=RXX*RXX+RYY*RYY+RZZ*RZZ
              RRN=SQRT(RRR)

              APERANG=ACOS((RXX*APERV(1)+RYY*APERV(2)+RZZ*APERV(3))/RRN)

              IF (IPINCIRC.EQ.0) THEN
                CALL THICKAPP(IPINCIRC,APERTHICK,PINW/2.0D0,APERANG,APERCORR)
              ELSE !IPINCIRC
                CALL THICKAPP(IPINCIRC,APERTHICK,PINR,APERANG,APERCORR)
              ENDIF

            ELSE !APERTHICK

              APERCORR=1.0D0

            ENDIF !APERTHICK

            DO IFREQ=1,NFREQ

              Y=FREQ(IFREQ)/ECDIP(1)

              ILIOBFR=ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1))
              IOBFR=IOBSV+NOBSV*(IFREQ-1)

              IF (XT.GE.XIANF.AND.XT.LE.XIEND) THEN
                speck=
     &            DFDTDP(Y,PSI,GAMMA,DMYCUR,BANWID,PAR,PER,POWR)/RR
     &            *APERCORR
                IF (SPECCUT.NE.0.D0.AND.Y.GT.SPECCUT) THEN
                  speck=0.0d0
                  PAR=0.D0
                  PER=0.D0
                  powr=0.0d0
                ENDIF   !SPECCUT

                SPEC(ILIOBFR)=SPEC(ILIOBFR)+speck

                speck=POWR/RHODIP(1)/RR*APERCORR
                SPECPOW(ISOUR+NSOURCE*(IOBSV-1))=
     &            SPECPOW(ISOUR+NSOURCE*(IOBSV-1))+speck

                EXPOM=(1.D0,0.D0)

                IF (IPIN.NE.0) THEN
                  DX2=RX*RX
                  DZY2=RZ*RZ+RY*RY
                  OM=FREQ(IFREQ)/(HBAREV1*CLIGHT1)

C       TO MAKE SURE THAT TAYLOR-EXPANSION IS VALID

                  IF (DZY2.GT.0.01D0*DX2) THEN
                    WRITE(LUNGFO,*)
     &                '*** ERROR IN SPECDIPA: OBSERVATION ANGLE TO LARGE ***'
                    WRITE(LUNGFO,*)'DECREASE SIZE OF PINHOLE OR WGWINFC ...'
                    WRITE(LUNGFO,*)'*** PROGRAM WAVE ABORTED ***'
                    WRITE(6,*)
     &                '*** ERROR IN SPECDIPA: OBSERVATION ANGLE TO LARGE ***'
                    WRITE(6,*)'DECREASE SIZE OF PINHOLE OR WGWINFC ...'
                    WRITE(6,*)'*** PROGRAM WAVE ABORTED ***'
                    STOP
                  ENDIF   !(DZY2.GT.0.01D0*DX2)

                  EPS(1)=DZY2/DX2
                  DO IEPS=2,6
                    EPS(IEPS)=EPS(IEPS-1)*EPS(1)
                  ENDDO !IEPS

c        TAYLOR-EXPANSION DONE WITH REDUCE
c       IN "WTAY1.RED";
c       on rounded;
c       on numval;
c       precision 13;
c       F:=SQRT(1+EPS);
c       DR:=TAY1(F,EPS,6);
c       ON FORT;
c       OUT "RED.FOR";
c       DR;
c       SHUT "RED.FOR";
C ans is actually reduce by 1.0 to avoid large overall phase

                  ans=-0.0205078125D0*eps(6)+0.02734375D0*eps(5)
     &              -0.0390625D0*eps(4)+
     &              0.0625D0*eps(3)-0.125D0*eps(2)+0.5D0*eps(1)

                  DRRED=-DABS(RX*ANS)
                  EXPOM=CDEXP(DCMPLX(0.D0,DRRED*OM))

                ENDIF !IPIN

                AFREQ(1)=(0.D0,0.D0)
                AFREQ(2)=afreq(2)+DCMPLX(0.D0,-SQRT(PER/RR/SPECNOR))*EXPOM
     &            *APERCORR
                AFREQ(3)=afreq(3)+DCMPLX(SQRT(PAR/RR/SPECNOR),0.D0)*EXPOM*SIGN(1.D0,PSI)
     &            *APERCORR

                IF (IWARNOB.EQ.0.AND.OBANGMN.GT.WGWINFC/GAMMA) THEN
                  WRITE(LUNGFO,*)'*** WARNING IN SPECDIPA:'
                  WRITE(LUNGFO,*)'problems finding tangent point'
                  WRITE(LUNGFO,*)'source number ',ISOUR
                  WRITE(LUNGFO,*)'observ. point ',sngl(obsv(1:3,iobsv))
                  WRITE(LUNGFO,*)
     &              'maybe low WBL0CUT or WGWINFC in namelist COLLIN causes problems'
                  WRITE(LUNGFO,*)
     &              '... or turn option IWIGGLER off and tune parameters'
                  WRITE(LUNGFO,*)
     &              'ISPECDIP, WBL0CUT ... by hand'
                  WRITE(LUNGFO,*)
                  WRITE(LUNGFO,*)' *** Photon flux set to zero! ***'
                  WRITE(LUNGFO,*)
                  WRITE(6,*)'*** WARNING IN SPECDIPA:'
                  WRITE(6,*)'problems finding tangent point'
                  WRITE(6,*)'source number ',ISOUR
                  WRITE(6,*)'observ. point ',sngl(obsv(1:3,iobsv))
                  WRITE(6,*)
     &              'maybe low WBL0CUT or WGWINFC in namelist COLLIN causes problems'
                  WRITE(6,*)
     &              '... or turn option IWIGGLER off and tune parameters'
                  WRITE(6,*)
     &              'ISPECDIP, WBL0CUT ... by hand'
                  WRITE(6,*)
                  WRITE(6,*)' *** Photon flux set to zero! ***'
                  WRITE(6,*)
                  IWARNOB=1
                ENDIF

                REAIMA(1,1,IOBFR)=DREAL(AFREQ(1))
                REAIMA(1,2,IOBFR)=DIMAG(AFREQ(1))
                REAIMA(2,1,IOBFR)=DREAL(AFREQ(2))
                REAIMA(2,2,IOBFR)=DIMAG(AFREQ(2))
                REAIMA(3,1,IOBFR)=DREAL(AFREQ(3))
                REAIMA(3,2,IOBFR)=DIMAG(AFREQ(3))
                IF (IPOLA.NE.0) THEN
                  APOL=
     &              AFREQ(1)*CONJG(VPOLA(1))
     &              +AFREQ(2)*CONJG(VPOLA(2))
     &              +AFREQ(3)*CONJG(VPOLA(3))
                  SPEC(ILIOBFR)=
     &              DREAL(APOL*CONJG(APOL))*SPECNOR
                ENDIF !IPOLA

                IF (ISTOKES.NE.0) THEN

                  APOLH=
     &              AFREQ(1)*CONJG(VSTOKES(1,1))
     &              +AFREQ(2)*CONJG(VSTOKES(1,2))
     &              +AFREQ(3)*CONJG(VSTOKES(1,3))

                  APOLR=
     &              AFREQ(1)*CONJG(VSTOKES(2,1))
     &              +AFREQ(2)*CONJG(VSTOKES(2,2))
     &              +AFREQ(3)*CONJG(VSTOKES(2,3))

                  APOLL=
     &              AFREQ(1)*CONJG(VSTOKES(3,1))
     &              +AFREQ(2)*CONJG(VSTOKES(3,2))
     &              +AFREQ(3)*CONJG(VSTOKES(3,3))

                  APOL45=
     &              AFREQ(1)*CONJG(VSTOKES(4,1))
     &              +AFREQ(2)*CONJG(VSTOKES(4,2))
     &              +AFREQ(3)*CONJG(VSTOKES(4,3))

                  STOK1=
     &              REAL(APOLR*CONJG(APOLR))+
     &              REAL(APOLL*CONJG(APOLL))

                  STOK2=-STOK1+
     &              2.*REAL(APOLH*CONJG(APOLH))

                  STOK3=
     &              2.*REAL(APOL45*CONJG(APOL45))-
     &              STOK1

                  STOK4=
     &              REAL(APOLR*CONJG(APOLR))-
     &              REAL(APOLL*CONJG(APOLL))

                  STOKES(1,IOBFR)=STOKES(1,IOBFR)+
     &              STOK1*SPECNOR

                  STOKES(2,IOBFR)=STOKES(2,IOBFR)+
     &              STOK2*SPECNOR

                  STOKES(3,IOBFR)=STOKES(3,IOBFR)+
     &              STOK3*SPECNOR

                  STOKES(4,IOBFR)=STOKES(4,IOBFR)+
     &              STOK4*SPECNOR

                ENDIF !ISTOKES

              ENDIF   !XIANF

              SPECTOT(IOBFR)=SPECTOT(IOBFR)
     &          +SPEC(ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1)))

            ENDDO   !IFREQ

            IF (NOBSV.GT.1.AND.ISOUR.EQ.1.AND.IOBSV.EQ.JX10.AND.IX10.LE.10) THEN
              JX10=JX10+JDX10
              CALL date_and_time(dtday,dttime,dtzone,idatetime)
              WRITE(6,*)' ',IX10,' ',dttime(1:2),':',dttime(3:4),':',dttime(5:6)
              IX10=IX10+1
            ENDIF

          enddo !mco

        ENDDO   !IOBSV

        IF (ISPECDIP.LE.-3.and.isour.eq.nsource) THEN
          DEALLOCATE(DWT)
          DEALLOCATE(DWX)
          DEALLOCATE(DWX2P)
          DEALLOCATE(DWB)
          DEALLOCATE(DWB2P)
          DEALLOCATE(DWY)
          DEALLOCATE(DWY2P)
          DEALLOCATE(DWZ)
          DEALLOCATE(DWZ2P)
          DEALLOCATE(tragam)
        ENDIF

        IF (ISOUR.EQ.1.and.nsource.gt.1) THEN
          WRITE(6,*)' '
          WRITE(6,*)' '
          WRITE(6,*)' sources treated so far:'
          WRITE(6,*)' '
        ENDIF

        CALL date_and_time(dtday,dttime,dtzone,idatetime)
        WRITE(6,2000)ISOUR,NSOURCE,dttime(1:2),dttime(3:4),dttime(5:6)
2000    FORMAT(10X,I4,' of',I4,2X,A,':',A,':',A)

      ENDDO   !ISOUR

      WRITE(6,*)' '

      RETURN
      END
+DECK,util_lower_case.
*CMZ :  3.05/12 08/03/2018  14.14.52  by  Michael Scheer
*CMZ : 00.00/16 13/10/2014  09.07.28  by  Michael Scheer
*-- Author :    Michael Scheer   13/10/2014
      subroutine util_lower_case(cline)

      implicit none

      character(*) cline

      integer i,ic1
      character c1
      equivalence (ic1,c1)

      ic1=0

      do i=1,len_trim(cline)
        c1=cline(i:i)
        if (ic1.ge.65.and.ic1.le.90) ic1=ic1+32
        cline(i:i)=c1
      enddo

      return
      end
+DECK,grndmm.
*CMZ :  3.02/03 27/10/2014  11.48.57  by  Michael Scheer
*-- Author :    Michael Scheer   24/10/2014
      subroutine grndmm(rvec,ndim)

      implicit none

      integer ndim
      real rvec(*)

+self,if=-grndm.
      call util_random(ndim,rvec)
+self,if=grndm.
      call grndm(rvec,ndim)
+self.

      return
      end
+DECK,util_random_init.
*CMZ :  3.06/00 22/01/2019  16.22.02  by  Michael Scheer
*CMZ :  3.03/02 17/11/2015  14.46.41  by  Michael Scheer
*CMZ :  3.02/03 05/09/2014  12.37.33  by  Michael Scheer
*-- Author :    Michael Scheer   05/09/2014
      subroutine util_random_init(isize,iseed)

c isize contains size if seed-array to be provided by the user
c For a simple use of the generated array call random_seed(isize), where
c isize is an integer

C IT SEEMS NOT TO WORK AS EXPECTED, MAYBE THE FIRST HALF OF THE SEEDS MUST BE
C SAVED TO THE SECOND HALF OF THE ARRAY!?

      use iso_fortran_env !, only: int64

      implicit none

      integer isize,n
      integer iseed(isize)

      n=isize
      call random_seed(size=isize)

C      if (isize.ne.64) then
      if (n.ne.64) then
        iseed(1)=-1
        print*,
     &    '*** Error in util_random_init: Dimension of seed-array must be 64:'
c     &    ,isize
        return
      endif

      call random_seed(get=iseed)
      iseed(33:64)=iseed(1:32)

      isize=n

      return
      end
+DECK,util_random_get_seed.
*CMZ :  3.03/02 17/11/2015  14.46.41  by  Michael Scheer
*CMZ :  3.02/03 05/09/2014  12.38.49  by  Michael Scheer
*-- Author :    Michael Scheer   05/09/2014
      subroutine util_random_get_seed(isize,iseed)

      use iso_fortran_env !, only: int64

      implicit none

      integer isize
      integer iseed(isize)

      call random_seed(get=iseed)

      return
      end
+DECK,util_random_set_seed.
*CMZ :  3.03/04 06/11/2017  16.07.30  by  Michael Scheer
*CMZ :  3.03/02 20/01/2016  10.34.45  by  Michael Scheer
*CMZ :  3.02/03 27/10/2014  10.39.03  by  Michael Scheer
*-- Author :    Michael Scheer   05/09/2014
      subroutine util_random_set_seed(isize,iseed)

c The actual size of the seed array is at least 64
c If iseed(1:n) are set zero, the behaviour is unclear to me, but it seems
c to reduce the used seed array to iseed(n+1:64), but what else is changed?
c So be careful!

      use iso_fortran_env !, only: int64

      implicit none

      integer isize
      integer iseed(isize),myseed(64)

      if (isize.lt.64) then
        myseed(1:64-isize)=0
        myseed(isize+1:64)=iseed(1:isize)
        call random_seed(put=myseed)
      else
        call random_seed(put=iseed)
      endif

      return
      end
+DECK,rndm.
*CMZ :  3.02/03 03/11/2014  10.43.51  by  Michael Scheer
*-- Author :    Michael Scheer   27/10/2014
      function rndm(r)

      implicit none

      real rndm,r,rn(1)

      call util_random(1,rn)

      rndm=rn(1)

      return
      end
+DECK,util_random.
*CMZ :  3.03/02 29/02/2016  16.24.34  by  Michael Scheer
*CMZ :  3.02/03 05/09/2014  12.29.51  by  Michael Scheer
*-- Author :    Michael Scheer   05/09/2014
      subroutine util_random(n,r)
+seq,random.

      real r(n)

      call random_number(r)

      irancalls=irancalls+n

      return
      end
+DECK,norran.
*CMZ :  4.00/15 27/04/2022  08.14.32  by  Michael Scheer
*CMZ :  3.02/03 03/11/2014  12.11.22  by  Michael Scheer
*-- Author :    Michael Scheer   27/10/2014
      subroutine norran(rn,rr)

      real rn(1),rr(2)
      call util_random_gauss(1,rn,rr)

      return
      end
+DECK,util_random_gauss.
*CMZ :  4.00/15 27/04/2022  08.09.29  by  Michael Scheer
*CMZ :  3.06/00 14/01/2019  17.27.04  by  Michael Scheer
*CMZ :  3.03/02 18/01/2016  13.02.27  by  Michael Scheer
*CMZ :  3.02/03 30/10/2014  17.17.28  by  Michael Scheer
*-- Author :    Michael Scheer   05/09/2014
      subroutine util_random_gauss(n,g,rr)

      implicit none

c Based on textbook "Numerical Recipies"
c The subroutine util_random is called, which can be initialized
c and controlled by util_random_init, util_random_set_seed, and
c util_random_get_seed.

      real g(n),r,v1,v2,fac,rr(2)
      integer n,i

      if (n.eq.1) then
1       call util_random(2,rr)
        v1=2.*rr(1)-1.
        v2=2.*rr(2)-1.
        r=v1*v1+v2*v2
        if (r.ge.1..or.r.eq.0.0) goto 1
        fac=sqrt(-2.*log(r)/r)
        g(1)=v1*fac
      else
        do i=1,(n/2*2),2
11      call util_random(2,rr)
        v1=2.*rr(1)-1.
        v2=2.*rr(2)-1.
        r=v1*v1+v2*v2
        if (r.ge.1..or.r.eq.0.0) goto 11
        fac=sqrt(-2.*log(r)/r)
        g(i)=v1*fac
        g(i+1)=v2*fac
        enddo
      endif

      if (mod(n,2).ne.0) then
12      call util_random(2,rr)
        v1=2.*rr(1)-1.
        v2=2.*rr(2)-1.
        r=v1*v1+v2*v2
        if (r.ge.1..or.r.eq.0.0) goto 12
        fac=sqrt(-2.*log(r)/r)
        g(n)=v1*fac
      endif

      return
      end
+DECK,rnorml.
*CMZ :  4.00/15 27/04/2022  08.15.12  by  Michael Scheer
*CMZ :  3.02/03 27/10/2014  12.27.38  by  Michael Scheer
*-- Author :    Michael Scheer   27/10/2014
      subroutine rnorml(rn,n,rr)

      real rn(*),rr(2)
      call util_random_gauss(n,rn,rr)

      return
      end
+DECK,ranmar.
*CMZ :  3.02/03 27/10/2014  12.30.42  by  Michael Scheer
*-- Author :    Michael Scheer   27/10/2014
      subroutine ranmar(rn,n)

      real rn(*)
      call util_random(n,rn)

      return
      end
+DECK,rmarin.
*CMZ :  3.02/03 27/10/2014  14.17.33  by  Michael Scheer
*-- Author :    Michael Scheer   27/10/2014
      subroutine rmarin(iseed,ntot1in,ntot2in)

c dummy routine for rmarin of CERNLIB

      integer iseed,ntot1in,ntot2in

      return
      end
+DECK,util_random_func_init.
*CMZ :  3.02/03 03/11/2014  14.19.56  by  Michael Scheer
*-- Author :    Michael Scheer   27/10/2014
      subroutine util_random_func_init(func,n,x,fint,coef)

c Initializes the array fwork for the external function func to be used
c by subroutine util_random_func

      implicit none

      real*8 fint(*),x(*),coef(*)
      real*8, dimension (:), allocatable :: w1,w2,w3,w4,fwork

      external function func
      real func,ff

      integer i,n

      allocate(fwork(n))
      allocate(w1(n))
      allocate(w2(n))
      allocate(w3(n))
      allocate(w4(n))

      do i=1,n
        ff=func(sngl(x(i)))
        fwork(i)=dble(ff)
      enddo

      call util_spline_running_integral(x,fwork,n,fint,coef,w1,w2,w3,w4)
      fint(1:n)=fint(1:n)/fint(n)
      call util_spline_coef(fint,x,n,0.0d0,0.0d0,coef,w1,w2,w3,w4)

      deallocate(fwork)
      deallocate(w1)
      deallocate(w2)
      deallocate(w3)
      deallocate(w4)

      return
      end
+DECK,util_random_func.
*CMZ :  3.02/03 27/10/2014  17.36.49  by  Michael Scheer
*-- Author :    Michael Scheer   27/10/2014
      subroutine util_random_func(n,x,fint,coef,nran,ran)

      implicit none

      real*8 x(*),fint(*),coef(*),r8
      real ran(*),rn(1000)

      integer i,n,loop,l,nran,l1

      loop=nran/1000

      if (loop.gt.0) then
        do l=1,loop
          call util_random(1000,rn)
          l1=(l-1)*1000
          do i=1,1000
            call util_spline_inter(fint,x,
     &        coef,n,dble(rn(i)),r8,-1)
            ran(l1+i)=sngl(r8)
          enddo
        enddo
      endif

      call util_random(nran-loop*1000,rn)
      l1=loop*1000
      do i=1,nran-loop*1000
        call util_spline_inter(fint,x,coef,n,dble(rn(i)),r8,-1)
        ran(l1+i)=sngl(r8)
      enddo

      return
      end
+DECK,util_string_split.
*CMZ :  4.00/11 04/06/2021  11.36.50  by  Michael Scheer
*CMZ : 00.00/06 07/03/2007  17.00.51  by  Michael Scheer
*CMZ : 00.00/05 07/03/2007  12.58.44  by  Michael Scheer
*-- Author :    Michael Scheer   07/03/2007
      subroutine util_string_split(cline,ndim,nwords,ipos,istat)

c Input:
c      cline
c      ndim: max. number of words

c Output:
c      nwords: number of words
c      ipos(1:2,iword): start and end position of word in cline

      implicit none

        integer ilen,istat,jx,nwords,ndim,ipos(2,ndim),ic,iblank,in

        character(*) cline
        character c1

        equivalence(c1,ic)
        ic=0
        istat=-1

        ilen=len(cline)

        in=0
        nwords=0

        do jx=1,ilen

          c1=cline(jx:jx)

          if (ic.le.32.or.ic.ge.127) then
c found invisible character
            iblank=1
          else
            iblank=0
          endif

          if (iblank.eq.1) then

            if (in.eq.1) then
c found end of word
c 4.6.2021              if (jx.lt.ilen) then
                ipos(2,nwords)=jx-1
c 4.6.2021              else
c 4.6.2021                ipos(2,nwords)=jx
c 4.6.2021              endif
              in=0
            endif

          else !iblank

            if (in.eq.0) then
c found beginning of word
              nwords=nwords+1
              if (nwords.gt.ndim) return
              ipos(1,nwords)=jx
              ipos(2,nwords)=ilen
              in=1
            endif

          endif !iblank

        enddo

        if (nwords.gt.0) istat=0

      return
      end
+DECK,adjust_input.
*CMZ :  4.00/07 09/01/2020  14.11.19  by  Michael Scheer
*CMZ :  3.03/02 17/12/2015  16.14.05  by  Michael Scheer
*-- Author :    Michael Scheer   11/12/2015
      subroutine adjust_input(nvar_adjust,chvar_adjust,var_adjust)

c Reads wave_adjust.in,
c sets variables chvar_adjust(1:nvar_adjust) to var_adjust(nvar_adjust),
c and writes wave.in

      implicit none

      double precision var_adjust(1000)

      integer lchvar_adjust(1000),loop,nvar_adjust,ivar,max_adjust,iblank,ic1
      integer i,k,ifound,l

      character(128) chvar_adjust(1000)
      character(1024) command_adjust, chfile_adjust,cpwd
      character(512) cline1
      character(256) cline
      character c1
      equivalence(c1,ic1)

      open(unit=99,file='wave.in')
      open(unit=98,file='wave_adjust.in',status='old')

2     read(98,'(a)',end=89)cline

      l=len_trim(cline)

      do i=1,l
        c1=cline(i:i)
        if (c1.eq."!") then
          write(99,'(a)')cline(1:len_trim(cline))
          goto 2
        else if (ic1.eq.32.or.ic1.eq.9) then
          continue
        else
          goto 21
        endif
      enddo

21    do ivar=1,nvar_adjust

        lchvar_adjust(ivar)=len_trim(chvar_adjust(ivar))

        ifound=0

        do i=1,l
          if(cline(i:i+lchvar_adjust(ivar)-1).eq.trim(chvar_adjust(ivar))) then
            ifound=i
            goto 8
          endif
        enddo

8       if (ifound.eq.0.and.ivar.eq.1) then
          write(99,'(a)')cline(1:len_trim(cline))
        else if(ifound.ne.0) then
          do k=i,l
            if (cline(k:k).eq."=") then
              goto 81
            endif
          enddo
81        cline1(1:k)=cline(1:k)
          write(cline1(k+1:k+20),'(g20.14)') var_adjust(ivar)
          cline1(k+21:k+21+l)=cline(i+lchvar_adjust(ivar):l)
          ifound=0
          do i=k,l
            if (cline(i:i).eq."!") then
              ifound=i
              goto 82
            endif
          enddo
82        if (ifound.ne.0) then
            cline1(k+21:k+22)=' '
            cline1(k+22:k+22+l)=cline(i:l)
          endif
          write(99,'(a)')cline1(1:len_trim(cline1))
        endif

      enddo !nvar_adjust
      goto 2

89    close(98)
      close(99)

      return
      end
+DECK,util_string_substring.
*CMZ : 00.00/16 19/03/2014  12.14.29  by  Michael Scheer
*CMZ : 00.00/15 03/09/2012  09.29.49  by  Michael Scheer
*CMZ : 00.00/06 08/03/2007  14.02.27  by  Michael Scheer
*CMZ : 00.00/05 07/03/2007  12.58.44  by  Michael Scheer
*-- Author :    Michael Scheer   07/03/2007
      subroutine util_string_substring(cline,substring,ianf,iend,istat)

c Input:
c      cline, substring

c If substring is passed as variable, full length of substring is checked,
c i.e. pending invisible characters are tested as well

c Output:
c      ianf,iend: start and end position of substring, 0 if not found
c      istat: error, i.e. string not found

c Evtl. besser FORTRAN-functions scan oder index benutzen

      implicit none

        integer ilenl,ilens,istat,ianf,iend,i

        character(*) cline,substring

        istat=-1
        ianf=0
        iend=0

        ilenl=len(cline)
        ilens=len(substring)

        if (ilens.gt.ilenl) return

        do i=1,ilenl-ilens+1
          if (cline(i:i+ilens-1).eq.substring) then
            ianf=i
            iend=ianf+ilens-1
            istat=0
            return
          endif
        enddo

      return
      end
+DECK,util_spline_inter_deriv.
*CMZ :  3.02/00 24/09/2014  13.51.08  by  Michael Scheer
*CMZ :  3.01/03 19/03/2014  12.24.14  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.63/03 21/05/2008  13.37.36  by  Michael Scheer
*CMZ : 00.00/02 27/06/2003  15.56.18  by  Michael Scheer
*CMZ : 00.00/01 23/02/96  14.56.50  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.27.54  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE UTIL_SPLINE_INTER_DERIV(XA,YA,Y2A,N,X,Y,YP,MODE)
+seq,gplhint.

C---  INTERPOLATES Y(X) VIA SPLINE

C--   INPUT:

C-       N: NUMBER OF X,Y-VALUES
C-       XA:   ARRAY OF X-VALUES
C-       YA:   ARRAY OF Y-VALUES
C-       YA2:  ARRAY SPLINE COEFFICIENTS
C-       X: Y(X) IS CALCULATED
C-       MODE: CONTROL FLAG:
C-             MODE.GE.0: USE VALUES OF LAST CALL TO START WITH
C-             MODE.LT.0: NEW INITIALIZATION

C--   OUTPUT:

C-       Y:  Y(X) IS CALCULATED
C-      YP: DY/DX IS CALCULATED

      IMPLICIT NONE

      INTEGER NOLD,N,KLO,KHI,KLOLD,K,MODE

      REAL*8 Y,X,XA1OLD,XANOLD,H,A,B,YP,H26
      REAL*8 A2,A3,B2,B3,XL,YL,XH,YH,Y2L,Y2H

      REAL*8 XA(*),YA(*),Y2A(*)

      save klold,nold,xa1old,xanold

      DATA KLOLD/1/,NOLD/-99/
      DATA XA1OLD/-9999.D0/,XANOLD/-9999./

      IF(     XA(1).LT.XA(N).AND.(X.LT.XA(1).OR.X.GT.XA(N))
     &    .OR.
     &    XA(N).LT.XA(1).AND.(X.LT.XA(N).OR.X.GT.XA(1))) THEN
        WRITE(6,*)'XA(1), XA(N):',XA(1), XA(N)
        WRITE(6,*)'X:',X
        STOP '***SR UTIL_SPLINE_INTER_DERIV: X OUT OF RANGE ***'
      ENDIF

      IF (MODE.LT.0.OR.KLOLD.GE.N) THEN
        KLO=1
      ELSE IF(NOLD.EQ.N
     &    .AND. XA(1).EQ.XA1OLD
     &    .AND. XA(N).EQ.XANOLD
     &    .AND. X.GT.XA(KLOLD)
     &    ) THEN
        KLO=KLOLD
      ELSE
        KLO=1
      ENDIF


      IF (X.LT.XA(KLO+1)) THEN
      KHI=KLO+1
      GOTO 2
      ENDIF

      KHI=N
1     IF (KHI-KLO.GT.1) THEN
        K=(KHI+KLO)/2
        IF(XA(K).GT.X)THEN
          KHI=K
        ELSE
          KLO=K
        ENDIF
      GOTO 1
      ENDIF

2     XL=XA(KLO)
      XH=XA(KHI)
      YL=YA(KLO)
      YH=YA(KHI)

      H=XH-XL

      IF (H.EQ.0.D0) STOP '*** ERROR SR UTIL_SPLINE_INTER_DERIV: BAD INPUT ***'

      A=(XH-X)/H
      B=(X-XL)/H
      A2=A*A
      A3=A2*A
      B2=B*B
      B3=B2*B
      Y2L=Y2A(KLO)
      Y2H=Y2A(KHI)
      H26=H*H/6.D0

      Y=A*YL+B*YH + (A*(A-1.D0)*(A+1.D0)*Y2L + B*(B-1.D0)*(B+1.D0)*Y2H)*H26

      YP=(YH-YL)/H
     & +((3.D0*B2-1.D0)*Y2H-(3.D0*A2-1.D0)*Y2L)/6.D0*H

      KLOLD=KLO
      NOLD=N
      XA1OLD=XA(1)
      XANOLD=XA(N)

      RETURN
      END
+DECK,util_break.
*CMZ :  4.01/04 17/11/2023  11.59.33  by  Michael Scheer
*CMZ :  4.00/17 04/10/2022  08.10.22  by  Michael Scheer
*CMZ :  4.00/11 27/05/2021  09.41.25  by  Michael Scheer
*CMZ :  3.02/04 03/12/2014  15.11.16  by  Michael Scheer
*-- Author :    Michael Scheer   03/12/2014
      subroutine util_break
+seq,debugwave.
      return
      end
+DECK,util_string_trim,T=F77.
*CMZ :  4.00/15 13/03/2022  17.05.32  by  Michael Scheer
*CMZ :  3.03/02 01/11/2016  12.45.16  by  Michael Scheer
*CMZ : 00.00/06 07/01/2008  14.32.30  by  Michael Scheer
*CMZ :  1.19/07 22/08/2002  15.44.21  by  Michael Scheer
*-- Author :    Michael Scheer   09/11/2001
      subroutine util_string_trim(cline,nfirst,nlast)

      implicit none

      integer nfirst,i,ic,nlast
      character(*) cline
      character c1

      equivalence (ic,c1)

      nfirst=-1
      nlast=-1

      do i=1,len(cline)
        c1=cline(i:i)
        if (c1.ne.' '.and.ic.ne.9) then !no blanks, no tabs
          nfirst=i
          goto 1
        endif
      enddo

1     if (nfirst.le.0) return

      do i=len(cline),nfirst,-1
        c1=cline(i:i)
        if (c1.ne.' '.and.ic.ne.9) then !no blanks, no tabs
          nlast=i
          return
        endif
      enddo

      return
      end
+DECK,fexist.
*CMZ :  3.03/02 01/03/2016  17.57.48  by  Michael Scheer
*-- Author :    Michael Scheer   01/03/2016
      subroutine fexist(file,iexist)

      implicit none

      integer iexist
      logical lexist
      character(*) file

      iexist=0

      inquire(file=file,exist=lexist)

      if (lexist.eqv..true.) iexist=1

      return
      end
+DECK,wpampntup.
*CMZ :  4.01/07 02/05/2024  12.36.06  by  Michael Scheer
*CMZ :  4.01/05 20/04/2024  09.47.23  by  Michael Scheer
*CMZ :  4.00/17 15/11/2022  10.12.04  by  Michael Scheer
*CMZ :  4.00/15 14/03/2022  09.02.26  by  Michael Scheer
*CMZ :  4.00/04 05/08/2019  15.46.18  by  Michael Scheer
*CMZ :  3.08/01 02/04/2019  12.38.49  by  Michael Scheer
*CMZ :  3.07/01 29/03/2019  12.42.19  by  Michael Scheer
*CMZ :  3.03/02 01/03/2016  20.59.13  by  Michael Scheer
*CMZ :  3.02/00 28/08/2014  08.52.10  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.66/11 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.66/10 04/05/2010  11.49.38  by  Michael Scheer
*CMZ :  2.66/09 29/04/2010  11.46.31  by  Michael Scheer
*-- Author :    Michael Scheer   17/03/2010
      subroutine wpampntup
+seq,gplhint.

+SEQ,TRACKF90U.
+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,REARGF90U.
+SEQ,WFOLDF90U.
+SEQ,AFREQF90U.
+SEQ,AMPLIF90U.

      use bunchmod
      use clustermod
      !use waveenv

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,TRACK.
+SEQ,OPTIC.
+seq,sourcef90.
+SEQ,FREQS.
+SEq,observf90.
+SEQ,SPECT.
+SEQ,SPECDIP.
+SEQ,COLLI.
+SEq,wfoldf90.
+SEQ,WUSEM.
+SEQ,AMPLI.
+SEQ,USERVAR.
+SEQ,PHYCON.
+SEQ,PRIMKIN.
+seq,photon.
+seq,strings.
+seq,waveenv.

      double precision rmax2,rabs2,rea1,rea2,wpspecnoro,specnoro,bunnoro,
     &  s1,s2,s3,s4

      real*8 count,fillb(100) !NIDBUNCH

      integer ifreq,iobsv,jcode,jfreq,jobsv,lastch,ifrmx,iobmx,njobs,ijob,
     &  ifirstch,isour,jliobfr,islash,i,iexist,lun99,lun98,iclo

      character(2048) chfile
      character(256) cstat,cjobnum
      character cslash

      equivalence (cslash,islash)

      iclo=icluster

      if (icluster.gt.0) then

        icluster=9999

        call util_string_trim(trim(chwavedir),ifirstch,lastch)

        do njobs=1,nwinstances

          if (iwstat(njobs).ne.0) cycle

          write(cjobnum,*)njobs

          chfile=
     &      chwavedir(ifirstch:lastch)//
     &      '/.stage.'//trim(adjustl(cjobnum))//
     &      '/wave_cluster.dat'

          open(newunit=lun99,file=chfile(1:len_trim(chfile)),status='old',
     &      err=99)

          read(lun99,*)jcode

          if (ibunch.ne.0) then

            if (ihphotons.ne.0) then

              chfile=
     &          chwavedir(ifirstch:lastch)//
     &          '/.stage.'//trim(adjustl(cjobnum))//
     &          '/msh_hbook_ntuple_7777.scr'

              call fexist(chfile,iexist)

              if (iexist.eq.1) then
                open(newunit=lun99,file=chfile)
13611           read(lun99,*,end=93611) fillb(1:14)
                call hfm(7777,fillb)
                goto 13611
93611           close(lun99)
              endif

            endif

            if (ihfreq.ne.0) then

              chfile=
     &          chwavedir(ifirstch:lastch)//
     &          '/.stage.'//trim(adjustl(cjobnum))//
     &          '/msh_hbook_ntuple_3601.scr'

              call fexist(chfile,iexist)

              if (iexist.eq.1) then
                open(newunit=lun99,file=chfile)
1361            read(lun99,*,end=9361) fillb(1:36)
                call hfm(3601,fillb)
                goto 1361
9361            close(lun99)
              endif

              chfile=
     &          chwavedir(ifirstch:lastch)//
     &          '/.stage.'//trim(adjustl(cjobnum))//
     &          '/msh_hbook_ntuple_3600.scr'

              call fexist(chfile,iexist)
              if (iexist.eq.1) then
                open(newunit=lun99,file=chfile)
136             read(lun99,*,end=936) fillb(1:2)
                call hfm(3600,fillb)
                goto 136
936             close(lun99)
              endif

              chfile=
     &          chwavedir(ifirstch:lastch)//
     &          '/.stage.'//trim(adjustl(cjobnum))//
     &          '/msh_hbook_ntuple_3700.scr'

              call fexist(chfile,iexist)
              if (iexist.eq.1) then
                open(newunit=lun99,file=chfile)
137             read(lun99,*,end=937) fillb(1:34)
                call hfm(3700,fillb)
                goto 137
937             close(lun99)
              endif

              if (istokes.ne.0) then

                chfile=
     &            chwavedir(ifirstch:lastch)//
     &            '/.stage.'//trim(adjustl(cjobnum))//
     &            '/msh_hbook_ntuple_4600.scr'

                call fexist(chfile,iexist)
                if (iexist.eq.1) then
                  open(newunit=lun99,file=chfile)
146               read(lun99,*,end=946) fillb(1:5)
                  call hfm(4600,fillb)
                  goto 146
946               close(lun99)
                endif

                chfile=
     &            chwavedir(ifirstch:lastch)//
     &            '/.stage.'//trim(adjustl(cjobnum))//
     &            '/msh_hbook_ntuple_4700.scr'

                call fexist(chfile,iexist)
                if (iexist.eq.1) then
                  open(newunit=lun99,file=chfile)
147               read(lun99,*,end=947) fillb(1:12)
                  call hfm(4700,fillb)
                  goto 147
947               close(lun99)
                endif

              endif !istokes

            endif !ihfreq

            if (ihbunch.ne.0) then

              chfile=
     &          chwavedir(ifirstch:lastch)//
     &          '/.stage.'//trim(adjustl(cjobnum))//
     &          '/msh_hbook_ntuple_30.scr'

              open(newunit=lun99,file=chfile)
              do i=1,nbunch*neinbunch/nwgood
                do iobsv=1,nobsv
                  do ifreq=1,nfreq
                    read(lun99,*,end=991) fillb(1:41)
                    if (iobsv.eq.1.and.ifreq.eq.1) count=count+1.0d0
                    if (nbunch.eq.1) then
                      fillb(2)=count
                    else
                      fillb(1)=count
                    endif
                    fillb(3)=count
                    call hfm(nidbunch,fillb)
                  enddo
                enddo
              enddo
991           close(lun99)

            endif !(ihbunch.ne.0) then

          endif !(ibunch.ne.0) then

        enddo !instances

      endif !icluster

      icluster=iclo
      return

99    write(lungfo,*)
     &    '*** Error in WPAMPNTUP: File not found'
      write(6,*)
     &  '*** Error in WPAMPNTUP: File not found'
      stop '*** Program WAVE aborted ***'

      close(lun98)
      end
+DECK,POWFOLD.
*CMZ :  3.03/02 22/03/2016  13.20.03  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.66/03 29/04/2010  11.46.31  by  Michael Scheer
*CMZ :  2.51/02 08/10/2009  09.58.11  by  Michael Scheer
*CMZ :  2.16/08 23/10/2000  14.22.46  by  Michael Scheer
*CMZ :  2.13/10 14/04/2000  14.26.49  by  Michael Scheer
*CMZ :  2.13/04 21/01/2000  14.54.46  by  Michael Scheer
*CMZ :  2.13/03 11/01/2000  18.22.28  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.56.38  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.16  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE POWFOLD
+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.

C--- CALCULATES FOLDING OF POWER-DENSITY IN PINHOLE WITH ELECTRON PHASE SPACE
C    DISTRIBUTIONS (GAUSSIAN DISTRIBUTION)

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEq,observf90.
+SEQ,FREQS.
+seq,sourcef90.
+SEQ,SPECT.
+SEQ,wfoldF90.

      double precision, dimension(:,:), allocatable :: poww,powwf
      double precision, dimension(:), allocatable :: powz,powy,powfz,powfy
     &  ,w1,w2,w3,w4,coef

      integer iz,iy,iobsv,isour,i

      allocate(poww(nobsvz,nobsvy))
      allocate(powwf(nobsvz,nobsvy))
      allocate(w1(max(nobsvz,nobsvy)))
      allocate(w2(max(nobsvz,nobsvy)))
      allocate(w3(max(nobsvz,nobsvy)))
      allocate(w4(max(nobsvz,nobsvy)))
      allocate(coef(max(nobsvz,nobsvy)))

      allocate(powz(nobsvz))
      allocate(powy(nobsvy))
      allocate(powfz(nobsvz))
      allocate(powfy(nobsvy))

      specpowf=0.0d0
      specpowtf=0.0d0

      do isour=1,nsource

        iobsv=0
        do iy=1,nobsvy
          do iz=1,nobsvz
            iobsv=iobsv+1
            poww(iz,iy)=SPECPOW(ISOUR+(IOBSV-1)*NSOURCE)
          enddo
        enddo

       do iy=(nobsvy-mobsvy)/2+1,(nobsvy-mobsvy)/2+mobsvy
         powz=poww(1:nobsvz,iy)
         if (dgsigz(isour).gt.0.0d0.and.wsigz(isour).gt.0.0d0) then
           call util_fold_function_gauss(
     &        nobsvz,obsvz,powz,wsigz(isour),dgsigz(1),powfz,
     &        coef,w1,w2,w3,w4)
         else
           write(lungfo,*)"*** Warning in powfold: Dgsigz or wsigz is zero for source",isour
           write(6,*)"*** Warning in powfold: Dgsigz or wsigz is zero for source",isour
           powfz=powz
         endif
         powwf(1:nobsvz,iy)=powfz
       enddo !iy

       do iz=1,nobsvz
         powy=powwf(iz,1:nobsvy)
         if (dgsigy(isour).gt.0.0d0.and.wsigy(isour).gt.0.0d0) then
           call util_fold_function_gauss(
     &        nobsvy,obsvy,powy,wsigy(isour),dgsigy(1),powfy,
     &        coef,w1,w2,w3,w4)
         else
           write(lungfo,*)"*** Warning in powfold: Dgsigy or wsigy is zero for source",isour
           write(6,*)"*** Warning in powfold: Dgsigy or wsigy is zero for source",isour
           powfy=powy
         endif
         powwf(iz,1:nobsvy)=powfy
       enddo !iz

       do iy=(nobsvy-mobsvy)/2+1,(nobsvy-mobsvy)/2+mobsvy
         do iz=(nobsvz-mobsvz)/2+1,(nobsvz-mobsvz)/2+mobsvz
           iobsv=nobsvz*(iy-1)+iz
           SPECPOWf(ISOUR+(IOBSV-1)*NSOURCE)=powwf(iz,iy)
           specpowtf(iobsv)=specpowtf(iobsv)+specpowf(isour+nsource*(iobsv-1))
         enddo
       enddo

      enddo !isour=1,nsource

      return
      end
+DECK,util_parabola_to_zero.
*CMZ :  3.03/02 16/02/2017  12.20.02  by  Michael Scheer
*-- Author :    Michael Scheer   16/02/2017
      subroutine util_parabola_to_zero(x,y,a,x0,ifail)

      ! Calculates parabola y(i)=a*(x(i)-x0)**2

      implicit none

      double precision x(2),y(2),a,x0,sq
      integer ifail

      ifail=-1

      if (y(1)*y(2).le.0.0d0.or.y(1).eq.y(2).or.x(1).eq.x(2)) then
        return
      endif

      sq=sqrt(y(1)/y(2))
      x0=(x(1)-x(2)*sq)/(1.0d0-sq)
      a=y(1)/(x(1)-x0)**2

      ifail=0

      return
      end
+DECK,bsx.
*CMZ :  3.04/00 04/01/2018  15.10.31  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.66/07 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.52/11 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  1.02/00 18/12/97  13.35.57  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  15.24.44  by  Michael Scheer
*CMZ : 00.00/05 29/04/94  19.35.51  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.43  by  Michael Scheer
*-- Author : Michael Scheer
C***********************************************************************
      SUBROUTINE bsx(XI,YI,ZI,BX,BY,BZ,IMAG)
+seq,gplhint.
      IMPLICIT NONE
      INTEGER IMAG

+SEQ,MGSQC.

      DOUBLE PRECISION Y,Z,BX,BY,BZ,G,XI,YI,ZI,PHI,SPHI,CPHI,XCEN,ZCEN,DX,DZ
      DOUBLE PRECISION AY1,AY2,XLEN2,BY1,BY2,FRINGE

+SEQ,CONTRL.
+SEQ,PHYCON.

      DATA FRINGE/1000.0D0/

      PHI=PMAG(5,IMAG)
      CPHI=DCOS(PHI)
      SPHI=DSIN(PHI)
      XCEN=PMAG(3,IMAG)
      ZCEN=PMAG(4,IMAG)

      XLEN2=PMAG(1,IMAG)/2.0D0

      IF (IWFILF.NE.99) THEN

        DX=XI-XCEN
        DZ=ZI-ZCEN
        Z=-SPHI*DX+CPHI*DZ
        Y=YI

        AY1=(DX-XLEN2)*FRINGE
        AY2=(-DX-XLEN2)*FRINGE

        IF (AY1.GT.70.) THEN
          BY1=0.0D0
        ELSE IF (AY1.LT.-70.) THEN
          BY1=1.0D0
        ELSE
          BY1=1.0D0/(1.0D0+DEXP(AY1))
        ENDIF

        IF (AY2.GT.70.) THEN
          BY2=0.0D0
        ELSE IF (AY2.LT.-70.) THEN
          BY2=1.0D0
        ELSE
          BY2=1.0D0/(1.0D0+DEXP(AY2))
        ENDIF

        ! Potential according to Wille (3.49)
        ! PHI = 1/2 G (z**2*y-y**3/3)
        ! Bx = 0
        ! By = dPHI/dy = G/2 * (z**2-y**2)
        ! Bz = dPHI/dz = G * z*y

        G=PMAG(2,IMAG)*EMOM/CLIGHT1*BY1*BY2

        BX=0.0D0
        BY=G/2.0d0*(Z**2-y**2)
        BZ=G*Z*Y

      ELSE

        BX=0.0D0
        BY=0.0D0
        BZ=0.0D0

      ENDIF !IWFILF

      RETURN
      END
+DECK,bdh.
*CMZ :  3.04/00 04/01/2018  17.28.38  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.65/03 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.63/02 25/03/2008  09.35.21  by  Michael Scheer
*CMZ :  2.52/11 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  1.02/00 19/12/97  17.58.18  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  14.07.41  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.46.47  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.43  by  Michael Scheer
*-- Author : Michael Scheer
C***********************************************************************
      SUBROUTINE BDh(XI,YI,ZI,BX,BY,BZ,IMAG)

+seq,gplhint.

      IMPLICIT NONE

      INTEGER IMAG

+SEQ,MGSQC.

      DOUBLE PRECISION X,Y,Z,BX,BY,BZ,BZ0,BZ1,BZ2,XLEN2,XI,YI,ZI,AZ1,AZ2

+SEQ,CONTRL.
+SEQ,PHYCON.

c pmag(1,imag): deflection angle (rad)
c pmag(2,imag): bending radius (T)
c pmag(3,imag): Center of magnet (m)
c pmag(4,imag): Width of edge

      IF (
     &    IWFILF.ne.99.
     &    .AND.
     &    PMAG(1,IMAG)*PMAG(2,IMAG).NE.0.
     &    ) THEN

        X=XI-PMAG(3,IMAG)

        Y=YI
        Z=ZI

        BX=0.0d0
        BY=0.0d0

        BZ0=EMOM/CLIGHT1/PMAG(2,IMAG)
        XLEN2=DABS(PMAG(2,IMAG)*sin(pmag(1,imag)/2.0d0))


        AZ1=(+X-XLEN2)*PMAG(4,IMAG)
        AZ2=(-X-XLEN2)*PMAG(4,IMAG)

        IF (AZ1.GT.70.0D0) THEN
          BZ1=0.
        ELSE IF (AZ1.LT.-70.) THEN
          BZ1=1.00D0
        ELSE
          BZ1=1.0D0/(1.0D0+DEXP(AZ1))
        ENDIF

        IF (AZ2.GT.70.0D0) THEN
          BZ2=0.0D0
        ELSE IF (AZ2.LT.-70.0D0) THEN
          BZ2=1.0D0
        ELSE
          BZ2=1.0D0/(1.0D0+DEXP(AZ2))
        ENDIF

        BZ=BZ0*BZ1*BZ2*CORR(IMAG)

      ELSE

        Bx=0.0d0
        By=0.0d0
        BZ=0.0d0

      ENDIF

      RETURN
      END
+DECK,bfoumag.
*CMZ :  4.00/13 01/09/2021  14.42.02  by  Michael Scheer
*CMZ :  3.04/00 19/01/2018  12.10.01  by  Michael Scheer
*CMZ :  3.01/00 16/07/2013  09.32.23  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.68/02 27/06/2012  16.34.34  by  Michael Scheer
*CMZ :  2.54/05 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.53/05 11/02/2005  09.55.20  by  Michael Scheer
*CMZ :  2.52/14 20/12/2004  17.10.56  by  Michael Scheer
*CMZ :  2.52/09 21/10/2004  15.47.48  by  Michael Scheer
*CMZ :  2.52/06 14/10/2004  09.16.20  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.34/07 04/09/2001  16.15.01  by  Michael Scheer
*CMZ :  2.16/08 01/11/2000  18.41.44  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  17.26.51  by  Michael Scheer
*CMZ : 00.01/11 11/09/96  17.24.24  by  Michael Scheer
*CMZ : 00.01/10 11/09/96  12.42.14  by  Michael Scheer
*CMZ : 00.01/07 16/03/95  14.21.07  by  Michael Scheer
*CMZ : 00.01/02 24/11/94  15.45.58  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  18.05.04  by  Michael Scheer
*CMZ : 00.00/03 29/04/94  10.18.17  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.37  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BFOUmag(XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,axout,ayout,azout,im)

+seq,gplhint.

      IMPLICIT NONE

+SEQ,CONTRL.
c+SEQ,CMPARA.
+SEQ,FOURIER.
+SEQ,PHYCON.

      DOUBLE PRECISION DNULL
      COMPLEX*16 CDEXPOMX,CEXPOMZ,CDEXPOMZ

      double precision xin,yin,zin,xcen,bxout,byout,bzout
      double precision
     &  xk0four,xl0four,yk0four,zk0four,zl0four,
     &  xkfour,xlfour,ykfour,zkfour,zlfour,
     &  DSNXKX,DCSXKX,DSHYKY,DCHYKY,DSNZKZ,DCSZKZ,axout,ayout,azout
     &  ,BXH,BYH,BZH,AXH,AYH,AZH,AN,AM,X,ak,expomy,expomy1,dexpomy

      integer imag,im,i,kmag,k

      DATA DNULL/0.0D0/

      if (im.lt.0) then
        imag=-im
      else
        imag=im
      endif

      kmag=0
      do i=1,nfoumags
        if (nint(xfoubounds(1,i)).eq.imag) then
          kmag=i
          exit
        endif
      enddo

      if (kmag.eq.0) then
        stop "*** Error in BFOUMAG: Magnet not found ***"
      endif

      xcen=(xfoubounds(3,kmag)+xfoubounds(2,kmag))/2.0d0
      zl0four=xfoubounds(3,kmag)-xfoubounds(2,kmag)
      if (zl0four.ne.0.0d0) then
        zk0four=twopi1/zl0four
      else
        zk0four=0.0d0
      endif

      xl0four=xfoubounds(4,kmag)
      if (xl0four.ne.0.0d0) then
        xk0four=twopi1/xl0four
      else
        xk0four=0.0d0
      endif
      yk0four=sqrt(xk0four**2+zk0four**2)
      x=dmod(xin-xcen,zl0four)

      if (x.gt.zl0four/2.0d0) then
        x=x-zl0four
      else if (x.lt.-zl0four/2.0d0) then
        x=x+zl0four
      endif

      cdexpomx=cdexp(dcmplx(dnull,xk0four*(-zin)))
      dcsxkx=dreal(cdexpomx)
      dsnxkx=dimag(cdexpomx)

      dexpomy=dexp(yk0four*yin)
      expomy=1.0D0

      cdexpomz=cdexp(dcmplx(dnull,zk0four*x))
      cexpomz=dcmplx(1.0d0,dnull)

      bxh=0.0d0
      byh=foumags(1,kmag)/2.0d0
      bzh=0.0d0

      axh=0.0d0
      ayh=0.0d0
      azh=0.0d0

      do k=2,nint(xfoubounds(5,kmag))

        zkfour=zk0four*k
        xkfour=xk0four
        ykfour=sqrt(zkfour**2+xkfour**2)

        if (xk0four.ne.0.0d0) then
          expomy=dexp(ykfour*yin)
        else
          expomy=expomy*dexpomy
        endif
        expomy1=1.0d0/expomy
        dchyky=(expomy+expomy1)*0.5d0
        dshyky=(expomy-expomy1)*0.5d0

        cexpomz=cexpomz*cdexpomz
        dcszkz=dreal(cexpomz)
        dsnzkz=dimag(cexpomz)

        ak=foumags(k,kmag)

        bxh=bxh-ak*xkfour/ykfour*dsnxkx*dshyky*dcszkz
        byh=byh+ak*                    dcsxkx*dchyky*dcszkz
        bzh=bzh-ak*zkfour/ykfour*dcsxkx*dshyky*dsnzkz

        AXH=AXH+ak/ZKFOUR*DCSXKX*DCHYKY*DSNZKZ
        AZH=AZH+0.0
        AYH=AYH+ak/ZKFOUR*XKFOUR/YKFOUR*DSNXKX*DSHYKY*DSNZKZ

      enddo

      if (im.gt.0) then
        bzout=-bxh
        byout= byh
        bxout= bzh
        azout=-axh
        ayout= ayh
        axout= azh
      else
        bzout= byh
        byout= bxh
        bxout= bzh
        azout= ayh
        ayout= axh
        axout= azh
      endif

      return
      end
+DECK,wbetfnback.
*CMZ :  4.00/15 05/04/2022  11.53.19  by  Michael Scheer
*CMZ :  3.04/00 11/01/2018  11.45.58  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.09.17  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.68/05 25/10/2012  15.10.37  by  Michael Scheer
*CMZ :  2.68/02 08/06/2012  09.23.03  by  Michael Scheer
*CMZ :  2.67/02 26/04/2012  14.49.41  by  Michael Scheer
*CMZ :  2.66/09 25/06/2010  12.15.46  by  Michael Scheer
*CMZ :  2.66/07 20/01/2010  16.25.35  by  Michael Scheer
*CMZ :  2.63/05 23/10/2009  09.19.41  by  Michael Scheer
*CMZ :  2.61/02 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  10.55.32  by  Michael Scheer
*CMZ :  2.47/12 16/04/2004  09.24.47  by  Michael Scheer
*CMZ :  2.16/08 29/10/2000  16.15.48  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.33  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.37  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.24.36  by  Michael Scheer
*CMZ :  1.03/06 10/06/98  14.43.03  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  10.46.38  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.56.09  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.10  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE WBETFNback
+seq,gplhint.

+SEQ,TRACKF90U,IF=F90.
+SEQ,WBETAF90U,IF=F90.

      implicit none

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,DEPOLA.
+seq,wbetaf90.
+SEQ,TRACK.
+SEQ,OPTIC.
+SEQ,tralin.
+SEQ,PHYCON.
+seq,ustep.

      INTEGER IT,IP,IPP,IPP2,jfail,ical,ifail

      DOUBLE PRECISION X0,Y0,Z0,YP0,ZP0
      DOUBLE PRECISION X1,Y1,Z1,YP1,ZP1
      DOUBLE PRECISION X2,Y2,Z2,t2
      DOUBLE PRECISION XF0,YF0,ZF0
      DOUBLE PRECISION X1T,Y1T,Z1T

      DOUBLE PRECISION V0,VX0,VY0,VZ0
      DOUBLE PRECISION VX1,VY1,VZ1
      DOUBLE PRECISION VX2,VY2,VZ2
      DOUBLE PRECISION VXF0,VYF0,VZF0
      DOUBLE PRECISION VX1T,VY1T,VZ1T

      DOUBLE PRECISION UNX,UNY,UNZ
      DOUBLE PRECISION VNX,VNY,VNZ,VN
      DOUBLE PRECISION WNX,WNY,WNZ
      DOUBLE PRECISION EWSFX,EWSFY,EWSFZ,BSHIFT

      DOUBLE PRECISION EPS0HO,EPS0VO,DUMP,DUMM,SPLYP0,SPLYPN,gammal

      DOUBLE PRECISION DS2,ALPHA,ALPHAP,BETA,GAMA,
     &  betmxh,betmnh,betcenh,
     &  betmxv,betmnv,betcenv

      double precision X2E,Y2E,Z2E,VX2E,VY2E,VZ2E,GAMMAE,
     &  xpar(3),ypar(3),a(3),yp(3),xopt,yopt

      DOUBLE PRECISION, DIMENSION (:), ALLOCATABLE ::
     &  XBUFF,YBUFF,Y2BUFF,AABUFF,BBBUFF,CCBUFF,CBUFF

      DATA BSHIFT/0.5D0/,ical/0/

      if (ical.ne.0) return
      ical=1

      IF (IENELOSS.NE.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    ' *** WARNING IN WBETFNBACK: IENELOSS .NE. 0, NOT YET IMPLEMENTED ***'
        WRITE(LUNGFO,*)
     &    ' *** BE CAREFUL!! ***'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)
     &    ' *** WARNING IN WBETFNBACK: IENELOSS .NE. 0, NOT YET IMPLEMENTED ***'
        WRITE(6,*)
     &    ' *** BE CAREFUL!! ***'
        WRITE(6,*)
      ENDIF

      X0=WSXYZ(1,nco)
      Y0=WSXYZ(2,nco)
      Z0=WSXYZ(3,nco)
      XF0=WSXYZ(1,1)

      VX0=-WVXYZ(1,nco)
      VY0=-WVXYZ(2,nco)
      VZ0=-WVXYZ(3,nco)
      V0=SQRT(VX0**2+VY0**2+VZ0**2)

      YP0=VY0/VX0
      ZP0=VZ0/VX0

      IF (YP0.NE.0.0 .OR. Y0.NE.0
     &   .OR.ZP0.NE.0.0 .OR. Z0.NE.0) THEN

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*) '*** WARNING IN WBETFNBACK ***'
          WRITE(LUNGFO,*) 'START VALUES OF REFERENCE ORBIT NOT ZERO !!??'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*) '*** WARNING IN WBETFNBACK ***'
          WRITE(6,*) 'START VALUES OF REFERENCE ORBIT NOT ZERO !!??'
          WRITE(6,*)
C         STOP '*** ERROR IN WBETFNBACK ***'

      ENDIF

      EPS0HO=EPS0H
      EPS0VO=EPS0V

      IF (EPS0H.LT.5.D-9) THEN

          EPS0H=5.D-9

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*) '*** WARNING SR WBETFNBACK ***'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*) 'HORIZ. EMITTANCE LOWER THAN 5.E-9'
          WRITE(LUNGFO,*) 'FOR CALCULATION OF BETA-FUNCTION SET 5.E-9'
          WRITE(LUNGFO,*) 'OLD VALUE RESTORED AFTERWARD'
          WRITE(LUNGFO,*)

      ENDIF

      IF (EPS0V.LT.5.D-9) THEN

          EPS0V=5.D-9

          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*) '*** WARNING SR WBETFNBACK ***'
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*) 'VERTICAL. EMITTANCE LOWER THAN 5.E-9'
          WRITE(LUNGFO,*) 'FOR CALCULATION OF BETA-FUNCTION SET 5.E-9'
          WRITE(LUNGFO,*) 'OLD VALUE RESTORED AFTERWARD'
          WRITE(LUNGFO,*)

      ENDIF

1     continue

C--- CALCULATE PRINCIPAL TRAJECTORIES

      DO IT=1,4

C--- REFERENCE ORBIT

        X0=WSXYZ(1,nco)
        Y0=WSXYZ(2,nco)
        Z0=WSXYZ(3,nco)

        VX0=-WVXYZ(1,nco)
        VY0=-WVXYZ(2,nco)
        VZ0=-WVXYZ(3,nco)

        YP0=VY0/VX0
        ZP0=VZ0/VX0

C--- NORMAL VECTOR OF ENTRANCE PLANE I.E Ex-VECTOR OF REFERENCE SYSTEM

        UNX=VX0/V0
        UNY=VY0/V0
        UNZ=VZ0/V0

C--- VECTOR Ey OF REFERENCE SYSTEM

        VN=SQRT(UNX**2+UNY**2)
        VNX=-UNY/VN
        VNY= UNX/VN
        VNZ=0.0d0

C--- VECTOR Ez OF REFERENCE SYSTEM

        WNX=UNY*VNZ-UNZ*VNY
        WNY=UNZ*VNX-UNX*VNZ
        WNZ=UNX*VNY-UNY*VNX

C COORDINATES IN REFERENCE SYSTEM

        IF (IT.EQ.1) THEN

          ALPHA=-.5D0*BETAPH

          X1=0.0d0
          Y1=0.0d0
          Z1=SQRT(EPS0H*BETAH)

          YP1=0.0d0
          ZP1=-SQRT(EPS0H/BETAH)*ALPHA

        ELSE IF (IT.EQ.2) THEN

          X1=0.0d0
          Y1=0.0d0
          Z1=0.0d0

          YP1=0.0d0
          ZP1=-SQRT(EPS0H/BETAH)

        ELSE IF (IT.EQ.3) THEN

          ALPHA=-.5D0*BETAPV

          X1=0.0d0
          Y1=SQRT(EPS0V*BETAV)
          Z1=0.0d0

          YP1=-SQRT(EPS0V/BETAV)*ALPHA
          ZP1=0.0d0

        ELSE IF (IT.EQ.4) THEN

          X1=0.0d0
          Y1=0.0d0
          Z1=0.0d0

          YP1=-SQRT(EPS0V/BETAV)
          ZP1=0.0d0

        ENDIF

C ABSOLUTE COORDINATES (LAB.-SYSTEM)

        X1T=X0+X1*UNX+Y1*VNX+Z1*WNX
        Y1T=Y0+X1*UNY+Y1*VNY+Z1*WNY
        Z1T=Z0+X1*UNZ+Y1*VNZ+Z1*WNZ

        X1=X1T
        Y1=Y1T
        Z1=Z1T

        VX1=V0/SQRT(1.D0+ZP1**2+YP1**2)
        VY1=VX1*YP1
        VZ1=VX1*ZP1

        VX1T=VX1*UNX+VY1*VNX+VZ1*WNX
        VY1T=VX1*UNY+VY1*VNY+VZ1*WNY
        VZ1T=VX1*UNZ+VY1*VNZ+VZ1*WNZ

        VX1=VX1T
        VY1=VY1T
        VZ1=VZ1T

        ZP1=VZ1/VX1
        YP1=VY1/VX1

        gammae=dmygamma*(1.0d0+deltae)

        IF (IT.LE.2) THEN
          WBETA(IT+1,1)=(X1-X0)**2+(Z1-Z0)**2
          WBETA(9+IT+1,1)=(X1-X0)**2+(Z1-Z0)**2
        ELSE
          WBETA(IT+1,1)=(X1-X0)**2+(Y1-Y0)**2
          WBETA(9+IT+1,1)=(X1-X0)**2+(Y1-Y0)**2
        ENDIF

C--- LOOP OVER POINTS

        WBETA(1,1)=x0

        DO IP=1,NCO-1

C--- MOVE PARTICLE TO PLANE THAT CORRESPOND TO NEXT POINT OF REF.ORBIT

          IPP=IP+1

          XF0=WSXYZ(1,IPP)
          YF0=WSXYZ(2,IPP)
          ZF0=WSXYZ(3,IPP)

          VXF0=WVXYZ(1,IPP)
          VYF0=WVXYZ(2,IPP)
          VZF0=WVXYZ(3,IPP)

          EWSFX=VXF0/V0
          EWSFY=VYF0/V0
          EWSFZ=VZF0/V0

C For the particle with energy deviation, we also take
c the normal reference orbit!?

          nutrack=-3

          CALL TRACKSHORT(ISNORDER,X1,Y1,Z1,VX1,VY1,VZ1,
     &      XF0,YF0,ZF0,EWSFX,EWSFY,EWSFZ,
     &      X2E,Y2E,Z2E,T2,VX2E,VY2E,VZ2E,DTIM0,BSHIFT,GAMMAE,BMOVECUT,IUSTEP,
     &      IENELOSS,GAMMAL)

          nutrack=-3

          CALL TRACKSHORT(ISNORDER,X1,Y1,Z1,VX1,VY1,VZ1,
     &      XF0,YF0,ZF0,EWSFX,EWSFY,EWSFZ,
     &      X2,Y2,Z2,T2,VX2,VY2,VZ2,DTIM0,BSHIFT,DMYGAMMA,BMOVECUT,IUSTEP,
     &      IENELOSS,GAMMAL)

          IF (IT.LE.2) THEN
            WBETA(IT+1,IPP)=(X2-XF0)**2+(Z2-ZF0)**2
            WBETA(9+IT+1,IPP)=(X2e-XF0)**2+(Z2e-ZF0)**2
          ELSE
            WBETA(IT+1,IPP)=(X2-XF0)**2+(Y2-YF0)**2
            WBETA(9+IT+1,IPP)=(X2e-XF0)**2+(Y2e-YF0)**2
          ENDIF

          if(it.eq.1) WBETA(1,IPP)=wbeta(1,ip)+(x2-x1)

          X1=X2
          Y1=Y2
          Z1=Z2

          VX1=VX2
          VY1=VY2
          VZ1=VZ2

        ENDDO !IP

      ENDDO !IT

c{30.4.2010: Correct for different step size of last step

      if (nco.gt.2) then
        x2=wbeta(1,nco-1)+ds0
        xpar(1)=wbeta(1,nco-2)
        xpar(2)=wbeta(1,nco-1)
        xpar(3)=wbeta(1,nco)
        do it=1,4
          ypar(1)=wbeta(it+1,nco-2)
          ypar(2)=wbeta(it+1,nco-1)
          ypar(3)=wbeta(it+1,nco)
          call UTIL_PARABEL(xpar,ypar,A,YP,XOPT,yopt,IFAIL)
          if (ifail.ne.0) then
            wbeta(it+1,nco)=wbeta(it+1,nco-1)+
     &        (wbeta(it+1,nco)-wbeta(it+1,nco-1))/
     &        (wbeta(1,nco)-wbeta(1,nco-1))*ds0
          else
            wbeta(it+1,nco)=a(1)+a(2)*x2+a(3)*x2**2
          endif
        enddo
        do it=10,13
          ypar(1)=wbeta(it+1,nco-2)
          ypar(2)=wbeta(it+1,nco-1)
          ypar(3)=wbeta(it+1,nco)
          call UTIL_PARABEL(xpar,ypar,A,YP,XOPT,yopt,IFAIL)
          if (ifail.ne.0) then
            wbeta(it+1,nco)=wbeta(it+1,nco-1)+
     &        (wbeta(it+1,nco)-wbeta(it+1,nco-1))/
     &        (wbeta(1,nco)-wbeta(1,nco-1))*ds0
          else
            wbeta(it+1,nco)=a(1)+a(2)*x2+a(3)*x2**2
          endif
        enddo
        wbeta(1,nco)=x2
      endif

c}30.4.2010: Correct for different step size of last step

C--- CALCULATE BETA-FUNCTIONS

      DO IP=1,NCO

C21.7.92     WBETA(1,IP)=WSXYZ(1,IP)
c16.12.2009          WBETA(1,IP)=-DFLOAT(NCO-1)*DS0/2.+DFLOAT(IP-1)*DS0
c30.4.2010        WBETA(1,IP)=x0+DFLOAT(IP-1)*DS0

        WBETA(2,IP)=(WBETA(2,IP)+WBETA(3,IP))/EPS0H
        WBETA(4,IP)=(WBETA(4,IP)+WBETA(5,IP))/EPS0V
        WBETA(11,IP)=(WBETA(11,IP)+WBETA(12,IP))/EPS0H
        WBETA(13,IP)=(WBETA(13,IP)+WBETA(14,IP))/EPS0V

      ENDDO !IP

C{ CALCULATE DERIVATIVES AND INTEGRALS

      ALLOCATE(XBUFF(NCO))
      ALLOCATE(YBUFF(NCO))
      ALLOCATE(Y2BUFF(NCO))
      ALLOCATE(AABUFF(NCO))
      ALLOCATE(BBBUFF(NCO))
      ALLOCATE(CCBUFF(NCO))
      ALLOCATE(CBUFF(NCO))

c{ e-dev

      DO IPP=0,1

        IPP2=IPP*2

        DO IP=1,NCO
          XBUFF(IP)=WBETA(1,IP)
          YBUFF(IP)=WBETA(11+IPP2,IP)
        ENDDO

        if (ipp.eq.0) then
          call util_min_parabel(nco,xbuff,ybuff,xmx,betmnh,aabuff,bbbuff,jfail)
          call util_max_parabel(nco,xbuff,ybuff,xmx,betmxh,aabuff,bbbuff,jfail)
          betcenh=ybuff(nco/2+1)
        endif

        if (ipp.eq.1) then
          call util_min_parabel(nco,xbuff,ybuff,xmx,betmnv,aabuff,bbbuff,jfail)
          call util_max_parabel(nco,xbuff,ybuff,xmx,betmxv,aabuff,bbbuff,jfail)
          betcenv=ybuff(nco/2+1)
        endif

        DUMP=(YBUFF(3)-YBUFF(2))/DS0
        DUMM=(YBUFF(2)-YBUFF(1))/DS0
        SPLYP0=(DUMP-DUMM)/DS0

        DUMP=(YBUFF(NCO)-YBUFF(NCO-1))/DS0
        DUMM=(YBUFF(NCO-1)-YBUFF(NCO-2))/DS0
        SPLYPN=(DUMP-DUMM)/DS0

        CALL UTIL_SPLINE_COEF(XBUFF,YBUFF,NCO,SPLYP0,SPLYPN,Y2BUFF,
     &    AABUFF,BBBUFF,CCBUFF,CBUFF)

        CALL UTIL_SPLINE_INTER_DERIV(XBUFF,YBUFF,Y2BUFF,NCO,
     &    XBUFF(1),WBETA(11+IPP2,1),WBETA(12+IPP2,1),-1)

        DO IP=2,NCO

          CALL UTIL_SPLINE_INTER_DERIV(XBUFF,YBUFF,Y2BUFF,NCO,
     &      XBUFF(IP),WBETA(11+IPP2,IP),WBETA(12+IPP2,IP),0)

        ENDDO

      ENDDO ! HORI and VERT

      DO IPP=0,1

        IPP2=IPP*2

        DO IP=1,NCO
          XBUFF(IP)=WBETA(1,IP)
          YBUFF(IP)=1.D0/WBETA(11+IPP2,IP)
        ENDDO

        DUMP=(YBUFF(3)-YBUFF(2))/DS0
        DUMM=(YBUFF(2)-YBUFF(1))/DS0
        SPLYP0=(DUMP-DUMM)/DS0

        DUMP=(YBUFF(NCO)-YBUFF(NCO-1))/DS0
        DUMM=(YBUFF(NCO-1)-YBUFF(NCO-2))/DS0
        SPLYPN=(DUMP-DUMM)/DS0

      ENDDO ! HORI and VERT

c} e-dev

      DO IPP=0,1

        IPP2=IPP*2

        DO IP=1,NCO
          XBUFF(IP)=WBETA(1,IP)
          YBUFF(IP)=WBETA(2+IPP2,IP)
        ENDDO

        if (ipp.eq.0) then
          call util_min_parabel(nco,xbuff,ybuff,xmx,betmnh,aabuff,bbbuff,jfail)
          call util_max_parabel(nco,xbuff,ybuff,xmx,betmxh,aabuff,bbbuff,jfail)
          betcenh=ybuff(nco/2+1)
        endif

        if (ipp.eq.1) then
          call util_min_parabel(nco,xbuff,ybuff,xmx,betmnv,aabuff,bbbuff,jfail)
          call util_max_parabel(nco,xbuff,ybuff,xmx,betmxv,aabuff,bbbuff,jfail)
          betcenv=ybuff(nco/2+1)
        endif

        DUMP=(YBUFF(3)-YBUFF(2))/DS0
        DUMM=(YBUFF(2)-YBUFF(1))/DS0
        SPLYP0=(DUMP-DUMM)/DS0

        DUMP=(YBUFF(NCO)-YBUFF(NCO-1))/DS0
        DUMM=(YBUFF(NCO-1)-YBUFF(NCO-2))/DS0
        SPLYPN=(DUMP-DUMM)/DS0

        CALL UTIL_SPLINE_COEF(XBUFF,YBUFF,NCO,SPLYP0,SPLYPN,Y2BUFF,
     &    AABUFF,BBBUFF,CCBUFF,CBUFF)

        CALL UTIL_SPLINE_INTER_DERIV(XBUFF,YBUFF,Y2BUFF,NCO,
     &    XBUFF(1),WBETA(2+IPP2,1),WBETA(3+IPP2,1),-1)

        DO IP=2,NCO

          CALL UTIL_SPLINE_INTER_DERIV(XBUFF,YBUFF,Y2BUFF,NCO,
     &      XBUFF(IP),WBETA(2+IPP2,IP),WBETA(3+IPP2,IP),0)

        ENDDO

      ENDDO ! HORI and VERT

c{e-dev
      DO IPP=0,1

        IPP2=IPP*2

        DO IP=1,NCO
          XBUFF(IP)=WBETA(1,IP)
          YBUFF(IP)=1.D0/WBETA(11+IPP2,IP)
        ENDDO

        DUMP=(YBUFF(12)-YBUFF(2))/DS0
        DUMM=(YBUFF(11)-YBUFF(1))/DS0
        SPLYP0=(DUMP-DUMM)/DS0

        DUMP=(YBUFF(NCO)-YBUFF(NCO-1))/DS0
        DUMM=(YBUFF(NCO-1)-YBUFF(NCO-2))/DS0
        SPLYPN=(DUMP-DUMM)/DS0

        CALL UTIL_SPLINE_COEF(XBUFF,YBUFF,NCO,SPLYP0,SPLYPN,Y2BUFF,
     &    AABUFF,BBBUFF,CCBUFF,CBUFF)

        WBETA(14+IPP,1)=0.D0

        DO IP=2,NCO

          WBETA(14+IPP,IP) = WBETA(14+IPP,IP-1)
     &      +(XBUFF(IP)-XBUFF(IP-1))*0.5D0
     &      *(YBUFF(IP-1)+YBUFF(IP))
     &      -(XBUFF(IP)-XBUFF(IP-1))**3/24.D0
     &      *(Y2BUFF(IP-1)+Y2BUFF(IP))

        ENDDO

      ENDDO ! HORI and VERT

c}e-dev

      DO IPP=0,1

        IPP2=IPP*2

        DO IP=1,NCO
          XBUFF(IP)=WBETA(1,IP)
          YBUFF(IP)=1.D0/WBETA(2+IPP2,IP)
        ENDDO

        DUMP=(YBUFF(3)-YBUFF(2))/DS0
        DUMM=(YBUFF(2)-YBUFF(1))/DS0
        SPLYP0=(DUMP-DUMM)/DS0

        DUMP=(YBUFF(NCO)-YBUFF(NCO-1))/DS0
        DUMM=(YBUFF(NCO-1)-YBUFF(NCO-2))/DS0
        SPLYPN=(DUMP-DUMM)/DS0

        CALL UTIL_SPLINE_COEF(XBUFF,YBUFF,NCO,SPLYP0,SPLYPN,Y2BUFF,
     &    AABUFF,BBBUFF,CCBUFF,CBUFF)

        WBETA(8+IPP,1)=0.D0

        DO IP=2,NCO

          WBETA(8+IPP,IP) = WBETA(8+IPP,IP-1)
     &      +(XBUFF(IP)-XBUFF(IP-1))*0.5D0
     &      *(YBUFF(IP-1)+YBUFF(IP))
     &      -(XBUFF(IP)-XBUFF(IP-1))**3/24.D0
     &      *(Y2BUFF(IP-1)+Y2BUFF(IP))

        ENDDO

      ENDDO ! HORI and VERT

      DEALLOCATE(XBUFF)
      DEALLOCATE(YBUFF)
      DEALLOCATE(Y2BUFF)
      DEALLOCATE(AABUFF)
      DEALLOCATE(BBBUFF)
      DEALLOCATE(CCBUFF)
      DEALLOCATE(CBUFF)

C} CALCULATE DERIVATIVES AND INTEGRALS

      DS2=DS0*2.D0

      DO IP=3,NCO-2
        WBETAK(1,IP)=(WBETA(3,IP+1)-WBETA(3,IP-1))/DS2
        WBETAK(2,IP)=(WBETA(5,IP+1)-WBETA(5,IP-1))/DS2
      ENDDO

      WBETAK(1,2)=WBETAK(1,3)-(WBETAK(1,4)-WBETAK(1,3))
      WBETAK(1,NCO-1)=WBETAK(1,NCO-2)+(WBETAK(1,NCO-2)-WBETAK(1,NCO-3))
      WBETAK(2,2)=WBETAK(2,3)-(WBETAK(2,4)-WBETAK(2,3))
      WBETAK(2,NCO-1)=WBETAK(2,NCO-2)+(WBETAK(2,NCO-2)-WBETAK(2,NCO-3))

      WBETAK(1,1)=WBETAK(1,2)-(WBETAK(1,3)-WBETAK(1,2))
      WBETAK(1,NCO)=WBETAK(1,NCO-1)+(WBETAK(1,NCO-1)-WBETAK(1,NCO-2))
      WBETAK(2,1)=WBETAK(2,2)-(WBETAK(2,3)-WBETAK(2,2))
      WBETAK(2,NCO)=WBETAK(2,NCO-1)+(WBETAK(2,NCO-1)-WBETAK(2,NCO-2))

C--- DETERMINATION OF GRADIENT Kz=-(kz-1/rho**2)
C    AND Ky=ky=-kz

      DO IP=1,NCO
        DO IT=1,2

          ALPHA=-WBETA(1+IT*2,IP)/2.D0
          ALPHAP=-WBETAK(IT,IP)/2.D0
          BETA=WBETA(2*IT,IP)
          GAMA=(1+ALPHA**2)/BETA
          WBETAK(IT,IP)=(ALPHAP+GAMA)/BETA

        ENDDO !IT
      ENDDO !IP

C--- RECALCULATE MAGNETIC FIELD FROM Ky+Kz=1/rho**2

      DO IP=1,NCO

        IF(WBETAK(2,IP)+WBETAK(1,IP).GE.0.0d0) THEN
          WBETAK(3,IP)=SQRT(WBETAK(2,IP)+WBETAK(1,IP))*EMOM/CLIGHT1
        ELSE
          WBETAK(3,IP)=0.0d0
        ENDIF

      ENDDO !IP

      EPS0H=EPS0HO
      EPS0V=EPS0VO

      write(lungfo,*)
      write(lungfo,*)'      Subroutine WBETFNBACK:'
      write(lungfo,*)' '

      write(lungfo,*)'      Max., min., and value of horizontal beta-function in the center:'
      write(lungfo,*)' '
      write(lungfo,*)'      ',sngl(betmxh),sngl(betmnh),sngl(betcenh)
      write(lungfo,*)' '

      write(lungfo,*)'      Max., min., and value of vertical beta-function in the center:'
      write(lungfo,*)' '
      write(lungfo,*)'      ',sngl(betmxv),sngl(betmnv),sngl(betcenv)
      write(lungfo,*)' '

      RETURN
      END
+DECK,util_rotate_vector_to_y_axis.
*CMZ :  4.00/11 26/02/2021  14.51.21  by  Michael Scheer
*CMZ :  1.25/00 15/03/2018  16.03.32  by  Michael Scheer
*-- Author :    Michael Scheer   08/03/2018
      subroutine util_rotate_vector_to_y_axis(vin,rotmat,istat)

      implicit none

      double precision cosphi,sinphi,costhe,sinthe,vin(3),
     &  vx,vy,vz,vn,rotmat(3,3),rotphi(3,3),rotthe(3,3),wx,wy,wz

      double precision :: eps=1.0d-9

      integer istat

      istat=0
      vn=sqrt(vin(1)**2+vin(2)**2+vin(3)**2)

      rotmat=0.0d0

      if (vn.eq.0.0d0) then
        istat=-1
        return
      endif

      vx=vin(1)/vn
      vy=vin(2)/vn
      vz=vin(3)/vn

      ! special cases vin is perpendicular to x-axis
      if (abs(vx).lt.eps) then
        rotmat(1,1)=1.0d0
        vn = sqrt(vy**2+vz**2)
        vy = vy/vn
        vz = vz/vn
        rotmat(2,2)=vy
        rotmat(2,3)=vz
        rotmat(3,2)=-vz
        rotmat(3,3)=vy
        istat=0
        return
      endif

      ! special cases vin is perpendicular to z-axis
      if (abs(vz).lt.eps) then
        rotmat(3,3)=1.0d0
        vn = sqrt(vy**2+vx**2)
        vy = vy/vn
        vx = vx/vn
        rotmat(1,1)=vy
        rotmat(1,2)=-vx
        rotmat(2,1)=vx
        rotmat(2,2)=vy
        istat=0
        return
      endif

      if (vx**2+vz**2.gt.eps) then
        cosphi=vx/sqrt(vx**2+vz**2)
        sinphi=vz/sqrt(vx**2+vz**2)
      else
        cosphi=1.0d0
        sinphi=0.0d0
      endif

      wx=cosphi*vx+sinphi*vz
      wy=vy
      wz=-sinphi*vx+cosphi*vz

      if (wx**2+wy**2.gt.1.0d-9) then
        costhe=wy/sqrt(wx**2+wy**2)
        sinthe=wx/sqrt(wx**2+wy**2)
      else
        costhe=1.0d0
        sinthe=0.0d0
      endif

      rotphi(1,1)=cosphi
      rotphi(1,2)=0.0d0
      rotphi(1,3)=sinphi

      rotphi(2,1)=0.0d0
      rotphi(2,2)=1.0d0
      rotphi(2,3)=0.0d0

      rotphi(3,1)=-sinphi
      rotphi(3,2)=0.0d0
      rotphi(3,3)=cosphi

      rotthe(1,1)=costhe
      rotthe(1,2)=-sinthe
      rotthe(1,3)=0.0d0

      rotthe(2,1)=sinthe
      rotthe(2,2)=costhe
      rotthe(2,3)=0.0d0

      rotthe(3,1)=0.0d0
      rotthe(3,2)=0.0d0
      rotthe(3,3)=1.0d0

      rotmat(1,1)=
     &  rotthe(1,1)*rotphi(1,1)+rotthe(1,2)*rotphi(2,1)+rotthe(1,3)*rotphi(3,1)
      rotmat(1,2)=
     &  rotthe(1,1)*rotphi(1,2)+rotthe(1,2)*rotphi(2,2)+rotthe(1,3)*rotphi(3,2)
      rotmat(1,3)=
     &  rotthe(1,1)*rotphi(1,3)+rotthe(1,2)*rotphi(2,3)+rotthe(1,3)*rotphi(3,3)

      rotmat(2,1)=
     &  rotthe(2,1)*rotphi(1,1)+rotthe(2,2)*rotphi(2,1)+rotthe(2,3)*rotphi(3,1)
      rotmat(2,2)=
     &  rotthe(2,1)*rotphi(1,2)+rotthe(2,2)*rotphi(2,2)+rotthe(2,3)*rotphi(3,2)
      rotmat(2,3)=
     &  rotthe(2,1)*rotphi(1,3)+rotthe(2,2)*rotphi(2,3)+rotthe(2,3)*rotphi(3,3)

      rotmat(3,1)=
     &  rotthe(3,1)*rotphi(1,1)+rotthe(3,2)*rotphi(2,1)+rotthe(3,3)*rotphi(3,1)
      rotmat(3,2)=
     &  rotthe(3,1)*rotphi(1,2)+rotthe(3,2)*rotphi(2,2)+rotthe(3,3)*rotphi(3,2)
      rotmat(3,3)=
     &  rotthe(3,1)*rotphi(1,3)+rotthe(3,2)*rotphi(2,3)+rotthe(3,3)*rotphi(3,3)

      return
      end
+DECK,undumag_bwireana.
*CMZ :  4.00/11 26/02/2021  15.54.27  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  10.15.11  by  Michael Scheer
*-- Author :    Michael Scheer   07/03/2018
      subroutine undumag_bwireana(wire7,xin,yin,zin,bxout,byout,bzout)

c Units: A, T and m

      implicit none

      double precision xin,yin,zin,bxout,byout,bzout,
     &  rx,ry,rz,dxl,dyl,dzl,xl,yl,zl,dbx,dby,dbz,xc,yc,zc,r,
     &  bx,by,bz,wire7(7),r3,curr,tiny,rmu04pi,
     &  x0,y0,z0,cen(3),wrot(6),wwrot(6),costhe,sinthe,sinphi,cosphi,
     &  dl(3),dln(3),dlabs,xh,byl,byh,xr,yr,zr,xrr,yrr,zrr,rl,rh,
     &  bxr,byr,bzr,bxrr,byrr,bzrr,bzl,bzh,curnor,dlxy

      data tiny/1.0d-6/
      data rmu04pi/1.0d-7/

      integer iseg,nseg

      bxout=0.0d0
      byout=0.0d0
      bzout=0.0d0

      curr=wire7(1)
      curnor=curr*rmu04pi

      dl(1)=wire7(5)-wire7(2)
      dl(2)=wire7(6)-wire7(3)
      dl(3)=wire7(7)-wire7(4)

      dlabs=sqrt(dl(1)**2+dl(2)**2+dl(3)**2)
      if (dlabs*curr.eq.0.0d0) return
      dln=dl/dlabs

c translate and rotate wire such, that it is centered a (0,0,0) and on the
c x-axis

      dlxy=sqrt(dln(1)**2+dln(2)**2)
      if (dlxy.gt.0.0d0) then
        costhe=dln(1)/dlxy
        sinthe=dln(2)/dlxy
      else
        costhe=1.0d0
        sinthe=0.0d0
      endif

      wrot(1)=costhe*wire7(2)+sinthe*wire7(3)
      wrot(2)=-sinthe*wire7(2)+costhe*wire7(3)
      wrot(3)=wire7(4)

      wrot(4)=costhe*wire7(5)+sinthe*wire7(6)
      wrot(5)=-sinthe*wire7(5)+costhe*wire7(6)
      wrot(6)=wire7(7)

      xr=costhe*xin+sinthe*yin
      yr=-sinthe*xin+costhe*yin
      zr=zin

      dl=wrot(4:6)-wrot(1:3)
      dln=dl/dlabs
      cosphi=dln(1)
      sinphi=dln(3)

      wwrot(1)=cosphi*wrot(1)+sinphi*wrot(3)
      wwrot(2)=wrot(2)
      wwrot(3)=-sinphi*wrot(1)+cosphi*wrot(3)

      wwrot(4)=cosphi*wrot(4)+sinphi*wrot(6)
      wwrot(5)=wrot(5)
      wwrot(6)=-sinphi*wrot(4)+cosphi*wrot(6)

      xrr=cosphi*xr+sinphi*zr
      yrr=yr
      zrr=-sinphi*xr+cosphi*zr

      cen(1)=(wwrot(1)+wwrot(4))/2.0d0
      cen(2)=(wwrot(2)+wwrot(5))/2.0d0
      cen(3)=(wwrot(3)+wwrot(6))/2.0d0

      x0=xrr-cen(1)
      y0=yrr-cen(2)
      z0=zrr-cen(3)

      xl=-(wwrot(4)-wwrot(1))/2.0d0
      xh=-xl
      rl=sqrt((xl-x0)**2+y0**2+z0**2)
      rh=sqrt((xh-x0)**2+y0**2+z0**2)

      byl=((rl**2+rl*(xl-x0))*(-z0))/(rl**2*(y0**2+z0**2))
      byh=((rh**2+rh*(xh-x0))*(-z0))/(rh**2*(y0**2+z0**2))

      bzl=-((rl**2+rl*(xl-x0))*(-y0))/(rl**2*(y0**2+z0**2))
      bzh=-((rh**2+rh*(xh-x0))*(-y0))/(rh**2*(y0**2+z0**2))

      bxrr=0.0d0
      byrr=byh-byl
      bzrr=bzh-bzl

      bxr=cosphi*bxrr-sinphi*bzrr
      byr=byrr
      bzr=sinphi*bxrr+cosphi*bzrr

      bxout=(costhe*bxr-sinthe*byr)*curnor
      byout=(sinthe*bxr+costhe*byr)*curnor
      bzout=bzr*curnor

      if (abs(bxout)+abs(byout)+abs(bzout).gt.10.0d0) then
        print*,"Undumag_bwireana: Field above 10 Tesla"
        print*,"wire7"
        print*,"xin,yin,zin:",xin,yin,zin
      endif

      return
      end
+DECK,undumag_bpeq.
*CMZ :  4.00/07 05/08/2020  17.14.48  by  Michael Scheer
*CMZ :  3.05/00 27/04/2018  15.48.43  by  Michael Scheer
*CMZ :  1.22/00 05/07/2017  09.56.06  by  Michael Scheer
*CMZ :  1.20/01 22/06/2017  12.00.01  by  Michael Scheer
*CMZ :  1.20/00 22/06/2017  11.20.28  by  Michael Scheer
*CMZ :  1.15/02 31/03/2017  11.58.51  by  Michael Scheer
*CMZ :  1.13/01 07/03/2017  16.25.11  by  Michael Scheer
*CMZ :  1.11/06 22/02/2017  16.40.57  by  Michael Scheer
*CMZ :  1.11/03 16/01/2017  12.22.22  by  Michael Scheer
*CMZ :  1.10/02 30/11/2016  15.09.58  by  Michael Scheer
*CMZ :  0.00/06 16/06/2016  14.14.37  by  Michael Scheer
*CMZ :  0.00/00 20/04/2016  12.41.34  by  Michael Scheer
*CMZ :  1.17/14 13/04/2016  10.30.41  by  Michael Scheer
*CMZ :  0.99/07 16/02/2004  15.18.01  by  Michael Scheer
*CMZ :  0.99/03 12/02/2004  10.50.28  by  Michael Scheer
*CMZ :  0.99/02 12/02/2004  10.20.35  by  Michael Scheer
*CMZ :  0.99/01 11/02/2004  13.54.20  by  Michael Scheer
*CMZ :  0.99/00 29/01/2004  14.14.29  by  Michael Scheer
*CMZ :  0.00/08 23/01/2004  15.31.25  by  Michael Scheer
*CMZ :  0.00/06 14/01/2004  16.32.20  by  Michael Scheer
*CMZ :  0.00/05 23/12/2003  16.08.27  by  Michael Scheer
*CMZ :  0.00/04 19/12/2003  18.32.08  by  Michael Scheer
*-- Author :    Michael Scheer   19/12/2003
      subroutine undumag_bpeq(x1,x2,a,b,zin,qx,qy,qz,tiny,
+self,if=verbose,debug1.
     &  imag,iplan,icorn,
+self.
     &  reverse,iwarn)

      implicit none

+seq,seqdebug.

      double precision x1,x2,a,b,zin,z,tiny,twopi,pi,f1,f2,dum1,dum2
      double precision qx,qy,qz,xi1,xi2,abz2,a2z2b2,
     &  are1,aim1,are2,aim2,arei1,aimi1,arei2,aimi2,dphi,dphi1,dphi2,phi1,phi2,
     &  sdum,dum,xpi(5),reverse,x1r,x2r,y1,y2,a21,ab,z2,a2,b2,az,a2z2,
     &  arem,aimm,arep,aimp,phim1,phip1,phim2,phip2,xm1,xp1,xm2,xp2

      double precision ra21,rho1,rho2,x2rxz,x1rxz,
     &  arg1,arg2,arg31,arg32,arg4

+self,if=debug1.
      double precision dx,x,ddphi,phi
      integer istep,i
+self.
      integer iwarn
+self,if=-nowarnings.
      integer lunwarn
+self.
+self,if=verbose,debug1.
     &  ,imag,iplan,icorn
+self.
      parameter (pi=3.1415926535897932385d0)
      parameter (twopi=6.2831853071795864769d0)
+self,if=verbose,debug1.
      write(6,*)
      write(6,*),'imag,iplan,icorn: ',imag,iplan,icorn
+self.
c      if (zin.lt.0.d0) write(lunwarn,*),'neg. z: ',zin

+self,if=-nowarnings.
      lunwarn=iwarn
+self.,if=-nowarnings.
      iwarn=0

      xm1=1.d30
      xp1=1.d30
      xm2=1.d30
      xp2=1.d30
      dphi1=0.d0
      dphi2=0.d0
      iwarn=0

      if (abs(zin).lt.tiny) then
+self,if=-nowarnings.
        iwarnbound=iwarnbound+1
        if (iwarnbound.le.nwarnbound) then
          write(lunwarn,*)
          write(lunwarn,*)'*** Warning in undumag_bpeq: Magnet boundary hit'
          write(lunwarn,*)'z changed by ',tiny ,'mm'
          write(lunwarn,*)'z: ',zin
          write(lunwarn,*)
        endif
+self.
        z=sign(tiny,zin)
        iwarn=1
      else
        z=zin
      endif

      if (x1.gt.x2) then
        x1r=x2
        x2r=x1
        reverse=-1.d0
      else
        x1r=x1
        x2r=x2
        reverse=1.d0
      endif

c-------------------------------------------------------------------------

      y1=a*x1+b
      y2=a*x2+b
      z2=z*z

      ab=a*b
      a2=a*a
      b2=b*b
      az=a*z
      a2z2=a2*z2
      abz2=ab*z2
      a2z2b2=a2z2+b2

      a21=1.d0+a2
      ra21=Sqrt(a21)

      rho1=Sqrt(x1**2+y1**2+z2)
      rho2=Sqrt(x2**2+y2**2+z2)

      arg1=(ab+x1*a21)/ra21+rho1
      arg2=(ab+x2*a21)/ra21+rho2

      arg31=((b*(y1+rho1)+z2)**2 + (z*(a21*x1+a*(b+rho1)))**2)/(x1**2+z**2)
      arg32=((b*(y2+rho2)+z2)**2 + (z*(a21*x2+a*(b+rho2)))**2)/(x2**2+z**2)

      if (
     &    ra21.eq.0.d0.or.arg2.eq.0.d0.or.arg32.eq.0.d0
     &    .or.sign(1.d0,arg1).ne.sign(1.d0,arg2)
     &    .or.sign(1.d0,arg31).ne.sign(1.d0,arg32)
     &   ) then
+self,if=-nowarnings.
        iwarnbound=iwarnbound+1
        if (iwarnbound.le.nwarnbound) then
          write(lunwarn,*)'*** Warning in undumag_bpeq: Numerical problems while calculating Bx'
        endif
+self.
        iwarn=10
        goto 9999
      endif

      arg4=Log(arg1/arg2)/ra21

      qx=Log(arg31/arg32)/2.d0-a*arg4

c-------------------------------------------------------------------------

      x2rxz=x2+Sqrt(x2**2+z2)
      x1rxz=x1+Sqrt(x1**2+z2)

      if (x2rxz.eq.0.0d0.or.x1rxz.eq.0.0d0.or.sign(1.d0,x2rxz).ne.sign(1.d0,x1rxz)) then
+self,if=-nowarnings.
        iwarnbound=iwarnbound+1
        if (iwarnbound.le.nwarnbound) then
          write(lunwarn,*)'*** Warning in undumag_bpeq: Numerical problems while calculating By'
        endif
+self.
        iwarn=11
        goto 9999
      endif

      qy=Log(x2rxz/x1rxz)+arg4

c-------------------------------------------------------------------------

      f1=((az+b)*(az-b))**2*a2z2b2-4.0d0*abz2**2
      f2=a21*z2+b2;

      sdum=f1*f2

      dum=(((1.0d0+3.0d0*a21)*z2+b2)*a2z2+(a2z2-b2)*b2)*b2

      if (sdum.gt.0.d0.and.dum.ne.0.d0) then

        dum1=2.0d0*sqrt(sdum)*abs(ab)*z2
        dum2=abz2*a2z2b2**2

        xi1=(+dum1-dum2)/dum
        xi2=(-dum1-dum2)/dum

      else

        xi1=-1.d30
        xi2=-1.d30

      endif

c--------------

      if (xi1.gt.xi2) then
        xpi(1)=xi1
        xi1=xi2
        xi2=xpi(1)
      else if (xi1.eq.xi2) then
        xi2=-1.d30
      endif

c On the way from x1 to x2, the atan2 may be not continuous. So we check,
c xi1, and xi2 and add +/- pi, respectivly

      if (xi1.lt.x1r.or.xi1.gt.x2r) then
        xi1=-1.d30
      endif

      if (xi2.lt.x1r.or.xi2.gt.x2r) then
        xi2=-1.d30
      endif

c----------

      if (xi1.ne.-1.d30) then

c is it real null or pi?

        xm1=xi1-tiny
        xp1=xi1+tiny

        call areim(xm1,a,b,z,arem,aimm)
        call areim(xi1,a,b,z,arei1,aimi1)
        call areim(xp1,a,b,z,arep,aimp)

        if (arem.eq.0.d0.and.aimm.eq.0.d0) then
c          print*,'*** Error 21 in undumag_bpeq: 0/0' !increase tiny...
c          stop
          iwarn=21
          goto 9999
        endif

        if (arep.eq.0.d0.and.aimp.eq.0.d0) then
c          print*,'*** Error 22 in undumag_bpeq: 0/0' !increase tiny...
c          stop
          iwarn=21
          goto 9999
        endif

        phim1=atan2(aimm,arem)
        phip1=atan2(aimp,arep)

        if (sign(1.d0,phim1).eq.sign(1.d0,phip1)) then
          xi1=-1.d30
        else
          dphi1=pi*nint((phim1-phip1)/pi)
        endif
+self,if=-nowarnings.
        if (abs(arei1).lt.tiny.and.abs(aimi1).lt.tiny) then
          print*, '*** Warning in undumag_bpeq: eps/eps'
          print*, 'arei1 / aimi1'
          print*,'Check if really null'
          print*, arei1,' / ',aimi1
          iwarn=31
        endif
+self.
        if (arei1.gt.tiny) then
          xi1=-1.d30
+self,if=-nowarnings.
        else if (arei1.gt.-tiny) then
c d.h. sehr Nahe am moeglichen Phasensprung
          write(lunwarn,*)'*** Warning in undumag_bpeq: arei1.gt.-tiny'
          write(lunwarn,*)'close to jump'
          iwarn=32
+self.
        endif

      endif !xi1.ne.-1.d30

c--------------

      if (xi2.ne.-1.d30) then

        xm2=xi2-tiny
        xp2=xi2+tiny

        call areim(xm2,a,b,z,arem,aimm)
        call areim(xi2,a,b,z,arei2,aimi2)
        call areim(xp2,a,b,z,arep,aimp)

        if (arem.eq.0.d0.and.aimm.eq.0.d0) then
          print*,'*** Error 23 in undumag_bpeq: 0/0' !increase tiny...
c          stop
          iwarn=23
          goto 9999
        endif

        if (arep.eq.0.d0.and.aimp.eq.0.d0) then
          print*,'*** Error 24 in undumag_bpeq: 0/0' !increase tiny...
c          stop
          iwarn=24
          goto 9999
c          stop '*** Error in undumag_bpeq: 0/0'
        endif

        phim2=atan2(aimm,arem)
        phip2=atan2(aimp,arep)

        if (sign(1.d0,phim2).eq.sign(1.d0,phip2)) then
          xi2=-1.d30
        else
          dphi2=pi*nint((phim2-phip2)/pi)
        endif

        if (arei2.eq.0.d0.and.aimi2.eq.0.d0) then
c          print*,'*** Error 25 in undumag_bpeq: 0/0' !increase tiny...
c          stop
          iwarn=25
          goto 9999
c          stop '*** Error in undumag_bpeq: 0/0'
        endif

+self,if=-nowarnings.
        if (abs(arei2).lt.tiny.and.abs(aimi2).lt.tiny) then
          print*, '*** Warning in undumag_bpeq: eps/eps'
          print*, 'arei2 / aimi2'
          print*,'Check if really null'
          print*, arei2,' / ',aimi2
          iwarn=41
        endif
+self.

        if (arei2.gt.tiny) then
          xi2=-1.d30
+self,if=-nowarnings.
        else if (arei2.gt.-tiny) then
          write(lunwarn,*)'*** Warning in undumag_bpeq: arei2.gt.-tiny'
          write(lunwarn,*)'close to jump'
          iwarn=42
+self.
        endif

      endif !xi2.ne.-1.d30

      call areim(x1r,a,b,z,are1,aim1)

      if (are1.eq.0.d0.and.aim1.eq.0.d0) then
+self,if=-nowarnings.
        print*, '*** Warning in undumag_bpeq while calculating Bz: 0/0'
        write(lunwarn,*)'x1r:'
        write(lunwarn,*)x1r
        write(lunwarn,*)'a,b,z:'
        write(lunwarn,*)a,b,z
+self.
        iwarn=4
        phi1=0.d0
      else
        phi1=atan2(aim1,are1)
      endif

+self,if=-nowarnings.
      if (abs(are1).lt.tiny.and.abs(aim1).lt.tiny) then
        print*, '*** Warning in undumag_bpeq: eps/eps'
        print*,'calculation of phi1'
        print*,'are1 / aim1'
        print*, are1,' / ',aim1
        iwarn=51
      endif
+self.

      call areim(x2r,a,b,z,are2,aim2)

      if (are2.eq.0.d0.and.aim2.eq.0.d0) then
+self,if=-nowarnings.
        write(lunwarn,*)'*** Warning in undumag_bpeq while calculating Bz: 0/0'
        write(lunwarn,*)'x2r:'
        write(lunwarn,*)x2r
        write(lunwarn,*)'a,b,z:'
        write(lunwarn,*)a,b,z
+self.
        iwarn=5
        phi2=0.d0
      else
        phi2=atan2(aim2,are2)
      endif

+self,if=-nowarnings.
      if (abs(are2).lt.tiny.and.abs(aim2).lt.tiny) then
        print*, '*** Warning in undumag_bpeq: eps/eps'
        print*,'calculation of phi2'
        print*, 'are2 / aim2'
        print*, are2,' / ',aim2
        iwarn=52
      endif
+self.

      dphi=dphi1+dphi2

      if (abs(dphi).gt.twopi) then

c probably two nulls detected due to numerical problems, but actually only one

+self,if=-nowarnings.
        write(lunwarn,*)'*** Warning in undumag_bpeq while calculating Bz: |dphi| > 2*pi'
        write(lunwarn,*)'*** reduced by 2*pi'

        write(lunwarn,*)'first and second null:'
        write(lunwarn,*)'z,x1r,x2r,xi1,xi2:'
        write(lunwarn,'(5e15.5e3)')z,x1r,x2r,xi1,xi2

        write(lunwarn,*)'are1,aim1,phi1:'
        write(lunwarn,'(3e15.5e3)')are1,aim1,phi1*180.d0/pi

        write(lunwarn,*)'are2,aim2,phi2:'
        write(lunwarn,'(3e15.5e3)')are2,aim2,phi2*180.d0/pi

        print*,"phim1, phip1:",phim1*180.d0/pi,phip1*180.0d0/pi
        print*,"phim2, phip2:",phim2*180.d0/pi,phip2*180.0d0/pi
+self.,if=-nowarnings.

        if (dphi.gt.twopi) dphi=dphi-twopi
        if (dphi.lt.-twopi) dphi=dphi+twopi

        iwarn=6

      endif

      dphi=phi2-phi1+dphi
      if (dphi.gt.twopi) then
        dphi=dphi-twopi
      else if (dphi.lt.-twopi) then
        dphi=dphi+twopi
      endif

      qz=-reverse*dphi

+self,if=debug1.
      write(6,*)
      call areim(x1r,a,b,z,are1,aim1)
      phi1=atan2(aim1,are1)
      istep=51
      dx=(x2r-x1r)/(istep-1)
      ddphi=0.d0
      do i=1,istep
        x=x1r+(i-1)*dx
        if (x.gt.xp1) then
          ddphi=ddphi+dphi1*180./pi
          xp1=1.d30
        endif
        if (x.gt.xp2) then
          ddphi=ddphi+dphi2*180./pi
          xp2=1.d30
        endif
        call areim(x,a,b,z,arem,aimm)
        phi=atan2(aimm,arem)*180./pi
        write(6,*)sngl(x),
     &    sngl(phi),sngl(ddphi),sngl(phi+ddphi)
      enddo

+self.
9999  continue

c      if (iseqdebug.ne.0.and.iwarn.ne.0.and.iwarn.ne.1) then
c        print*,x1,x2,a,b,zin,qx,qy,qz,dphi,reverse,iwarn
c        iseqdebug=2
c      endif

      if (qx.ne.qx) then
        qx=0.0d0
        iwarn=0
      endif
      if (qy.ne.qy) then
        qy=0.0d0
        iwarn=0
      endif
      if (qz.ne.qz) then
        qz=0.0d0
        iwarn=0
      endif
      return
      end
+DECK,aaaaab.
*CMZ :  4.01/00 12/03/2023  17.09.02  by  Michael Scheer
*CMZ :  4.00/07 05/08/2020  13.30.57  by  Michael Scheer
*CMZ :  4.00/04 21/05/2019  15.44.29  by  Michael Scheer
*CMZ :  3.07/01 27/03/2019  11.23.54  by  Michael Scheer
*CMZ :  3.05/02 15/05/2018  16.57.09  by  Michael Scheer
*CMZ :  3.05/01 04/05/2018  15.45.09  by  Michael Scheer
*CMZ :  3.05/00 25/04/2018  14.52.43  by  Michael Scheer
*CMZ :  3.02/00 01/09/2014  12.19.54  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.17.36  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  15.45.11  by  Michael Scheer
*CMZ :  2.70/04 18/12/2012  10.57.04  by  Michael Scheer
*CMZ :  2.20/01 09/11/2009  13.07.19  by  Michael Scheer
*CMZ :  2.16/08 01/11/2000  17.02.50  by  Michael Scheer
*-- Author :    Michael Scheer   01/11/2000
+seq,spectf90m.
+seq,ompmod.
+seq,phyconmod.
+seq,clustermod.
+seq,mhbook_module.
+seq,undumagf90m.
+seq,commandlinef90m.
      SUBROUTINE AAAAAb

      use ompmod

      RETURN
      END
+DECK,argsum.
*CMZ :  4.01/04 14/11/2023  11.45.54  by  Michael Scheer
*CMZ :  4.01/03 02/06/2023  13.01.26  by  Michael Scheer
*CMZ :  4.00/14 11/02/2022  10.26.56  by  Michael Scheer
*CMZ :  3.05/01 08/05/2018  16.08.32  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.10  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  15.45.11  by  Michael Scheer
*CMZ :  2.69/02 07/11/2012  13.59.21  by  Michael Scheer
*CMZ :  2.68/05 28/09/2012  12.15.44  by  Michael Scheer
*CMZ :  2.67/00 13/02/2012  10.58.17  by  Michael Scheer
*CMZ :  2.65/03 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.64/04 14/09/2009  15.19.42  by  Michael Scheer
*CMZ :  2.64/03 21/08/2009  17.32.56  by  Michael Scheer
*CMZ :  2.64/02 21/08/2009  17.24.35  by  Michael Scheer
*CMZ :  2.64/01 20/08/2009  15.20.55  by  Michael Scheer
*CMZ :  2.63/05 03/08/2009  16.11.05  by  Michael Scheer
*CMZ :  2.52/12 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.52/11 08/12/2004  13.37.55  by  Michael Scheer
*CMZ :  2.51/02 30/06/2004  16.42.15  by  Michael Scheer
*CMZ :  2.50/00 29/04/2004  15.29.30  by  Michael Scheer
*CMZ :  2.20/01 24/11/2000  21.15.06  by  Michael Scheer
*CMZ :  2.16/08 31/10/2000  14.40.08  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  17.26.23  by  Michael Scheer
*CMZ :  2.13/07 17/02/2000  15.11.12  by  Michael Scheer
*CMZ :  2.13/04 21/01/2000  11.57.55  by  Michael Scheer
*CMZ :  2.13/03 17/01/2000  17.27.08  by  Michael Scheer
*CMZ :  2.12/02 15/06/99  15.16.33  by  Michael Scheer
*CMZ :  2.12/00 27/05/99  10.08.55  by  Michael Scheer
*CMZ :  2.11/01 19/05/99  14.09.50  by  Michael Scheer
*CMZ :  2.10/01 19/03/99  14.13.05  by  Michael Scheer
*CMZ :  2.00/00 06/01/99  11.12.16  by  Michael Scheer
*CMZ : 00.01/02 24/11/94  15.25.26  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.46.43  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.46  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE ARGSUM(ISOUR,IOBSV,IBUFF)

+seq,gplhint.

+SEQ,SPECTF90U.
+SEQ,SOURCEF90U.
+SEQ,REARGF90U.
+SEQ,OBSERVF90U.
+SEQ,AFREQF90U.
+SEQ,AMPLIF90U.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,PHYCON.
+seq,sourcef90.
+SEQ,SPECT.
+SEQ,FREQS.
+SEQ,AMPLI.
+SEq,observf90.
+SEQ,MYFILES.

      INTEGER ISOUR,IOBSV,IFREQ,IPOI,ICOMP,IST,ICAL,JOBSV,IBUFF

      INTEGER NTUPP
      PARAMETER (NTUPP=22)
      REAL*8 FILLT(NTUPP)

      COMPLEX*16 APOL,EXPOM,DEXPOM,ZIOM,AX0,AY0,AZ0,AX,AY,AZ,ZI,ZONE,
     &  DMODU,DMODU0,DDMODU,daff(3),baff(3),bx0,by0,bz0,bx,by,bz
      COMPLEX*8 APOLH,APOLR,APOLL,APOL45

      DOUBLE PRECISION OM,DOM,DT,DT2,T,rnx,rny,rnz,rn
      DOUBLE PRECISION :: RSPECNOR=1.0d0 !11.2.2022

      DOUBLE PRECISION RARG(8),
     &  DXEXI,CENXEXI,DTPHASE,FREQR,GAMMA21,GAMGAM,R0,R02,H2,R00,H2R2,
     &  PHI,CORRR0,GAMGAM0,AMPDT,R2,POW

      REAL*4 STOK1,STOK2,STOK3,STOK4

      INTEGER I

      DATA ICAL/0/

      DATA ZI/(0.0D0,1.0D0)/
      DATA ZONE/(1.0D0,0.0D0)/

      save

      IF (ICAL.EQ.0) THEN

        print*,"*** Warning in ARGSUM: Ntuple of source not uptodate, use OMP version or ISPECMODE=2"
c11.2.2022        RSPECNOR=DSQRT(SPECNOR) to be consistent with hfreq and souintana

        DO IFREQ=1,NFREQ
          DO JOBSV=1,NOBSV

            IOBFR=JOBSV+NOBSV*(IFREQ-1)

            REAIMA=0.0d0

            IF (ISTOKES.NE.0) THEN
              DO IST=1,4  !LOOP OVER COMPONENTS OF STOKES VECTOR
                STOKES(IST,IOBFR)=0.0
              ENDDO   !IST
            ENDIF

          ENDDO   !JOBSV
        ENDDO   !IFREQ

        ICAL=1

      ENDIF   !ICAL

C--- PERFORMS INTEGRATION FOR ALL FREQUENCES

C    ASSUMES FREQ(I+1)=FREQ(I)*2   FOR IFREQ2P=2
C    OR FREQ(I+1)=FREQ(I)+DELTA    FOR IFREQ2P>2

      IF (ISOUR.NE.ISOURO) THEN

        DO IFREQ=1,NFREQ
          IFROB=IFREQ+NFREQ*(IOBSV-1)
          AFREQ(1:6,IFROB)=(0.0d0,0.0d0)
        ENDDO

        SPECPOW(ISOUR+NSOURCE*(IOBSV-1))=0.D0

      ENDIF !ISOUR

      DOM=(FREQ(2)-FREQ(1))/HBAREV1

C-- LOOP OVER TIME STEPS (ACTUAL INTEGRATION)

      IF (IBUFF.EQ.1) THEN
        T=-REARGUM(6,1)
      ENDIF

      DO IPOI=1,IARGUM

        DT=REARGUM(6,IPOI)
        DT2=DT*0.5D0

        T=T+DT

        RARG(1)=REARGUM(1,IPOI)*DT
        RARG(2)=REARGUM(2,IPOI)*DT
        RARG(3)=REARGUM(3,IPOI)*DT

        RARG(4)=REARGUM(4,IPOI)
        RARG(5)=REARGUM(5,IPOI)*DT

        RARG(6:8)=REARGUM(9:11,IPOI)

        rn=norm2(rarg(6:8))
        rnx=rarg(6)/rn
        rny=rarg(7)/rn
        rnz=rarg(8)/rn

        OM=FREQ(1)/HBAREV1
        IF (IVELOFIELD.EQ.2) THEN
          ZIOM=DCMPLX(0.0D0,OM)
        ELSE
          ZIOM=DCMPLX(1.0D0,0.0D0)
        ENDIF

        EXPOM=CDEXP(DCMPLX(0.D0,RARG(4)*OM))

        IF(IFREQ2P.GT.2) DEXPOM=CDEXP(DCMPLX(0.D0,RARG(4)*DOM))

        IFROB=1+NFREQ*(IOBSV-1)
        DO ICOMP=1,3
          daff(icomp)=ZIOM*DCMPLX(RARG(ICOMP))*EXPOM*REFLEC(ICOMP)
          AFREQ(ICOMP,IFROB)=AFREQ(ICOMP,IFROB)+daff(icomp)
        ENDDO

c        baff(1)=conjg(rny*daff(3)-rnz*daff(2))
c        baff(2)=conjg(rnz*daff(1)-rnx*daff(3))
c        baff(3)=conjg(rnx*daff(2)-rny*daff(1))

        baff(1)=(rny*daff(3)-rnz*daff(2))
        baff(2)=(rnz*daff(1)-rnx*daff(3))
        baff(3)=(rnx*daff(2)-rny*daff(1))

        afreq(4:6,IFROB)=afreq(4:6,IFROB)+baff(1:3)/clight1

C--- LOOP OVER ALL FREQUENCES

        DO IFREQ=2,NFREQ

            OM=FREQ(IFREQ)/HBAREV1
            IF (IVELOFIELD.EQ.2) THEN
              ZIOM=DCMPLX(0.0D0,OM)
            ELSE
              ZIOM=DCMPLX(1.0D0,0.0D0)
            ENDIF

            IF    (IFREQ2P.LT.2) THEN
              EXPOM=CDEXP(DCMPLX(0.D0,RARG(4)*OM))
            ELSE IF(IFREQ2P.EQ.2) THEN
              EXPOM=EXPOM*EXPOM
            ELSE
              EXPOM=EXPOM*DEXPOM
            ENDIF

            IFROB=IFREQ+NFREQ*(IOBSV-1)
            DO ICOMP=1,3
              daff(icomp)=ZIOM*DCMPLX(RARG(ICOMP))*EXPOM
     &          *REFLEC(ICOMP)
              AFREQ(ICOMP,IFROB)=AFREQ(ICOMP,IFROB)+daff(icomp)
            ENDDO

c            baff(1)=conjg(rny*daff(3)-rnz*daff(2))
c            baff(2)=conjg(rnz*daff(1)-rnx*daff(3))
c            baff(3)=conjg(rnx*daff(2)-rny*daff(1))

            baff(1)=(rny*daff(3)-rnz*daff(2))
            baff(2)=(rnz*daff(1)-rnx*daff(3))
            baff(3)=(rnx*daff(2)-rny*daff(1))

            afreq(4:6,IFROB)=afreq(4:6,IFROB)+baff(1:3)/clight1

          ENDDO   !LOOP OVER ALL FREQUENCES

        ILIOB=ISOUR+NSOURCE*(IOBSV-1)
        SPECPOW(ILIOB)=SPECPOW(ILIOB)+RARG(5)

        IF(IWFILINT.EQ.-ISOUR.AND.IOBSV.EQ.1) THEN

          IFREQ=1
          IOBSV=1

          FILLT(1)=T
          FILLT(2)=WSOU(1,1,IPOI)
          FILLT(3)=WSOU(2,1,IPOI)
          FILLT(4)=WSOU(3,1,IPOI)
          FILLT(5)=RARG(1)
          FILLT(6)=RARG(2)
          FILLT(7)=RARG(3)
          FILLT(8)=RARG(4)
          FILLT(9)=MIN(RARG(5),1.D30)
          FILLT(10)=DREAL(EXPOM)
          FILLT(11)=DIMAG(EXPOM)
          FILLT(12)=0.0d0
          FILLT(13)=IOBSV
          FILLT(14)=IFREQ
          IF (NOBSV.EQ.1) THEN
            FILLT(15)=OBS1Y
            FILLT(16)=OBS1Z
          ELSE
            FILLT(15)=OBSV(2,IOBSV)
            FILLT(16)=OBSV(3,IOBSV)
          ENDIF
          FILLT(17)=0.0d0
          FILLT(18)=0.0d0
          FILLT(19)=0.0d0
          FILLT(20)=0.0d0
          IFROB=IFREQ+NFREQ*(IOBSV-1)
          FILLT(21)=
     &      DREAL(
     &      AFREQ(1,IFROB)*CONJG(AFREQ(1,IFROB))
     &      +AFREQ(2,IFROB)*CONJG(AFREQ(2,IFROB))
     &      +AFREQ(3,IFROB)*CONJG(AFREQ(3,IFROB))
     &      )*SPECNOR
          FILLT(22)=0.0d0

          CALL hfm(NIDSOURCE,FILLT)

        ENDIF !IWFILINT.EQ.-ISOUR

      ENDDO   !LOOP OVER TIME STEPS

      IF (NSADD.NE.0) THEN

        IF (IAMPLI.LT.0) THEN

          GAMGAM0=SOURCEG(1,1,ISOUR)**2
          GAMGAM=(SOURCEG(1,1,ISOUR)+SOURCEG(2,2,ISOUR))**2
          GAMMA21=1.0D0/GAMGAM0
          DXEXI=MIN(SOURCEEO(1,1,ISOUR),XIEND)
     &      -MAX(SOURCEAO(1,1,ISOUR),XIANF)
          CENXEXI=(MIN(SOURCEEO(1,1,ISOUR),XIEND)
     &      +MAX(SOURCEAO(1,1,ISOUR),XIANF))/2.D0
          DTPHASE=(WTRA2IS(ISOUR)+GAMMA21*DXEXI/2.D0)/CLIGHT1
     &    *GAMGAM0/GAMGAM
          AMPDT=AMPSHIFT(1)/CLIGHT1/2.0D0/GAMGAM0
          DTPHASE=DTPHASE+AMPDT
          FREQR=2.D0*PI1/DTPHASE*HBAREV1
          POW=SPECPOW(ILIOB)
          SPECPOW(ILIOB)=0.0D0

          DO I=1,-IAMPLI
            R02=(OBSV(1,IOBSV)-CENXEXI)**2+OBSV(2,IOBSV)**2+OBSV(3,IOBSV)**2
            R2=(OBSV(1,IOBSV)-CENXEXI-DXEXI*(I-ABS(IAMPLI)/2+1))**2
     &        +OBSV(2,IOBSV)**2+OBSV(3,IOBSV)**2
            SPECPOW(ILIOB)=SPECPOW(ILIOB)+POW*R02/R2
          ENDDO

          DO IFREQ=1,NFREQ

            ILIOBFR=ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1))
            IFROB=IFREQ+NFREQ*(IOBSV-1)
            IOBFR=IOBSV+NOBSV*(IFREQ-1)

            OM=FREQ(IFREQ)/HBAREV1

            AX0=AFREQ(1,IFROB)
            AY0=AFREQ(2,IFROB)
            AZ0=AFREQ(3,IFROB)

            AX=AX0
            AY=AY0
            AZ=AZ0

            BX0=AFREQ(4,IFROB)
            BY0=AFREQ(5,IFROB)
            BZ0=AFREQ(6,IFROB)

            BX=AX0
            BY=AY0
            BZ=AZ0

            AFREQ(1:6,IFROB)=(0.0D0,0.0D0)

            R0=OBSV(1,NOBSV/2+1)-CENXEXI
            R02=R0*R0
            R00=R0
            H2=(OBSV(2,IOBSV))**2+(OBSV(3,IOBSV))**2
            H2R2=H2/R02

            DTPHASE=(WTRA2IS(ISOUR)+(H2R2+GAMMA21)*DXEXI/2.D0)/CLIGHT1
     &        *GAMGAM0/GAMGAM
     &        +AMPDT
            PHI=2.D0*PI1*FREQ(IFREQ)*ECHARGE1/HPLANCK1*DTPHASE

            DMODU=EXP(ZI*PHI)
            DMODU0=DMODU
            DDMODU=ZONE

            DO I=1,-IAMPLI

              R0=OBSV(1,NOBSV/2+1)+DXEXI/2.D0*(-IAMPLI-2*(I-1)-1)
              CORRR0=R00/R0
              R02=R0*R0
              H2=(OBSV(2,IOBSV))**2+(OBSV(3,IOBSV))**2
              H2R2=H2/R02

              GAMGAM=(SOURCEG(1,1,ISOUR)+(I-1)*SOURCEG(2,2,ISOUR))**2
              DTPHASE=(WTRA2IS(ISOUR)+(H2R2+GAMMA21)*DXEXI/2.D0)/CLIGHT1
     &          *GAMGAM0/GAMGAM+AMPDT
              PHI=2.D0*PI1*FREQ(IFREQ)*ECHARGE1/HPLANCK1*DTPHASE

              DMODU=EXP(ZI*PHI)
              DMODU0=DMODU
              DDMODU=ZONE

              AFREQ(1,IFROB)=AFREQ(1,IFROB)+AX
              AFREQ(2,IFROB)=AFREQ(2,IFROB)+AY
              AFREQ(3,IFROB)=AFREQ(3,IFROB)+AZ
              AFREQ(4,IFROB)=AFREQ(4,IFROB)+BX
              AFREQ(5,IFROB)=AFREQ(5,IFROB)+BY
              AFREQ(6,IFROB)=AFREQ(6,IFROB)+BZ

              IF (AMPRAN.NE.0.D0) THEN
                PHI=2.D0*PI1*XRANA(I)/FREQR*FREQ(IFREQ)
                DDMODU=EXP(ZI*PHI)
              ENDIF   !(AMPRAN.NE.0.D0)

              AX0=AX0*DMODU0
              AY0=AY0*DMODU0
              AZ0=AZ0*DMODU0

              AX=AX0*CORRR0
              AY=AY0*CORRR0
              AZ=AZ0*CORRR0

              DMODU=DMODU0*DDMODU
              AX=AX*DMODU
              AY=AY*DMODU
              AZ=AZ*DMODU

              BX0=BX0*DMODU0
              BY0=BY0*DMODU0
              BZ0=BZ0*DMODU0

              BX=BX0*CORRR0
              BY=BY0*CORRR0
              BZ=BZ0*CORRR0

              BX=BX*DMODU
              BY=BY*DMODU
              BZ=BZ*DMODU

            ENDDO !IAMPLI

          ENDDO !IFREQ

        ENDIF  !(IAMPLI.LT.0)

        DO IFREQ=1,NFREQ

          ILIOBFR=ISOUR+NSOURCE*(IOBSV-1+NOBSV*(IFREQ-1))
          IOBFR=IOBSV+NOBSV*(IFREQ-1)
          IFROB=IFREQ+NFREQ*(IOBSV-1)

          IF (IPOLA.EQ.0) THEN

            SPEC(ILIOBFR)=
     &        DREAL(
     &        AFREQ(1,IFROB)*CONJG(AFREQ(1,IFROB))
     &        +AFREQ(2,IFROB)*CONJG(AFREQ(2,IFROB))
     &        +AFREQ(3,IFROB)*CONJG(AFREQ(3,IFROB))
     &        )*SPECNOR

            REAIMA(1:3,1,IOBFR)=REAIMA(1:3,1,IOBFR)+
     &        DREAL(AFREQ(1:3,IFROB))*rspecnor
            REAIMA(1:3,2,IOBFR)=REAIMA(1:3,2,IOBFR)+
     &        DIMAG(AFREQ(1:3,IFROB))*rspecnor
            REAIMA(6:8,1,IOBFR)=REAIMA(6:8,1,IOBFR)+
     &        DREAL(AFREQ(1:3,IFROB))*rspecnor
            REAIMA(6:8,2,IOBFR)=REAIMA(6:8,2,IOBFR)+
     &        DIMAG(AFREQ(1:3,IFROB))*rspecnor

          ELSE    !IPOLA

            APOL=
     &        AFREQ(1,IFROB)*CONJG(VPOLA(1))
     &        +AFREQ(2,IFROB)*CONJG(VPOLA(2))
     &        +AFREQ(3,IFROB)*CONJG(VPOLA(3))

            SPEC(ILIOBFR)=
     &        DREAL(APOL*CONJG(APOL))*SPECNOR

            REAIMA(1:3,1,IOBFR)=REAIMA(1:3,1,IOBFR)+
     &        DREAL(AFREQ(1:3,IFROB))*rspecnor
            REAIMA(1:3,2,IOBFR)=REAIMA(1:3,2,IOBFR)+
     &        DIMAG(AFREQ(1:3,IFROB))*rspecnor
            REAIMA(6:8,1,IOBFR)=REAIMA(6:8,1,IOBFR)+
     &        DREAL(AFREQ(1:3,IFROB))*rspecnor
            REAIMA(6:8,2,IOBFR)=REAIMA(6:8,2,IOBFR)+
     &        DIMAG(AFREQ(1:3,IFROB))*rspecnor

          ENDIF   !IPOLA

          IOBFR=IOBSV+NOBSV*(IFREQ-1)
          IFROB=IFREQ+NFREQ*(IOBSV-1)

          IF (ISTOKES.NE.0) THEN

            APOLH=
     &        AFREQ(1,IFROB)*CONJG(VSTOKES(1,1))
     &        +AFREQ(2,IFROB)*CONJG(VSTOKES(1,2))
     &        +AFREQ(3,IFROB)*CONJG(VSTOKES(1,3))

            APOLR=
     &        AFREQ(1,IFROB)*CONJG(VSTOKES(2,1))
     &        +AFREQ(2,IFROB)*CONJG(VSTOKES(2,2))
     &        +AFREQ(3,IFROB)*CONJG(VSTOKES(2,3))

            APOLL=
     &        AFREQ(1,IFROB)*CONJG(VSTOKES(3,1))
     &        +AFREQ(2,IFROB)*CONJG(VSTOKES(3,2))
     &        +AFREQ(3,IFROB)*CONJG(VSTOKES(3,3))

            APOL45=
     &        AFREQ(1,IFROB)*CONJG(VSTOKES(4,1))
     &        +AFREQ(2,IFROB)*CONJG(VSTOKES(4,2))
     &        +AFREQ(3,IFROB)*CONJG(VSTOKES(4,3))

            STOK1=
     &        REAL(APOLR*CONJG(APOLR))+
     &        REAL(APOLL*CONJG(APOLL))

            STOK2=-STOK1+
     &        2.*REAL(APOLH*CONJG(APOLH))

            STOK3=
     &        2.*REAL(APOL45*CONJG(APOL45))-
     &        STOK1

            STOK4=
     &        REAL(APOLR*CONJG(APOLR))-
     &        REAL(APOLL*CONJG(APOLL))


            STOKES(1,IOBFR)=STOKES(1,IOBFR)+
     &        STOK1*SPECNOR

            STOKES(2,IOBFR)=STOKES(2,IOBFR)+
     &        STOK2*SPECNOR

            STOKES(3,IOBFR)=STOKES(3,IOBFR)+
     &        STOK3*SPECNOR

            STOKES(4,IOBFR)=STOKES(4,IOBFR)+
     &        STOK4*SPECNOR
          ENDIF

        ENDDO !IFREQ

        ILIOB=ISOUR+NSOURCE*(IOBSV-1)
        SPECPOW(ILIOB)=SPECPOW(ILIOB)*pownor

      ENDIF !NSADD

      RETURN
      END
+DECK,util_min_max.
*CMZ :  3.05/09 31/07/2018  14.03.38  by  Michael Scheer
*-- Author :    Michael Scheer   31/07/2018
      subroutine util_min_max(n,x,kmin,kmax,xmin,xmax)

      implicit none

      integer n,kmin,kmax,i
      double precision x(n),xmin,xmax

      xmin=1.0d30
      xmax=-1.0d30

      do i=1,n
        if(x(i).lt.xmin) then
          xmin=x(i)
          kmin=i
        endif
        if(x(i).gt.xmax) then
          xmax=x(i)
          kmax=i
        endif
      enddo

      end
+DECK,util_min_max_sngl.
*CMZ :  3.05/09 31/07/2018  14.23.52  by  Michael Scheer
*-- Author :    Michael Scheer   31/07/2018
      subroutine util_min_max_sngl(n,x,kmin,kmax,xmin,xmax)

      implicit none

      integer n,kmin,kmax,i
      real x(n),xmin,xmax

      xmin=1.0e30
      xmax=-1.0e30

      do i=1,n
        if(x(i).lt.xmin) then
          xmin=x(i)
          kmin=i
        endif
        if(x(i).gt.xmax) then
          xmax=x(i)
          kmax=i
        endif
      enddo

      end
+DECK,util_plane.
*CMZ :  4.00/11 02/07/2021  09.54.16  by  Michael Scheer
*CMZ : 00.00/19 07/06/2016  12.17.28  by  Michael Scheer
*-- Author :    Michael Scheer   07/06/2016
      subroutine util_plane(p1,p2,p3,p,vnor,dist,iover,istat)

      implicit none

      double precision p1(3),p2(3),p3(3),p(3),vnor(3),dist,
     &  v21(3),v31(3),vp1(3),vin(3),v32(3),vcross(3),vp2(3),vp3(3)
      integer iover,istat

      istat=0

      v21=p2-p1
      v31=p3-p1
      v32=p3-p2

      vnor(1)=v21(2)*v31(3)-v21(3)*v31(2)
      vnor(2)=v21(3)*v31(1)-v21(1)*v31(3)
      vnor(3)=v21(1)*v31(2)-v21(2)*v31(1)
      dist=norm2(vnor)

      if (dist.le.0.0d0) then
        istat=-1
        goto 9999
      endif

      vnor=vnor/dist
      vp1=p-p1
      vp2=p-p2
      vp3=p-p3

      dist=vp1(1)*vnor(1)+vp1(2)*vnor(2)+vp1(3)*vnor(3)
      vin=vp1-dist*vnor

      iover=1

      vcross(1)=v21(2)*vin(3)-v21(3)*vin(2)
      vcross(2)=v21(3)*vin(1)-v21(1)*vin(3)
      vcross(3)=v21(1)*vin(2)-v21(2)*vin(1)

      if (vcross(1)*vnor(1)+vcross(2)*vnor(2)+vcross(3)*vnor(3).le.0.0d0) then
        iover=0
        goto 9999
      endif

      vin=vp2-dist*vnor

      vcross(1)=v32(2)*vin(3)-v32(3)*vin(2)
      vcross(2)=v32(3)*vin(1)-v32(1)*vin(3)
      vcross(3)=v32(1)*vin(2)-v32(2)*vin(1)

      if (vcross(1)*vnor(1)+vcross(2)*vnor(2)+vcross(3)*vnor(3).le.0.0d0) then
        iover=0
        goto 9999
      endif

      vin=vp3-dist*vnor

      vcross(1)=v31(2)*vin(3)-v31(3)*vin(2)
      vcross(2)=v31(3)*vin(1)-v31(1)*vin(3)
      vcross(3)=v31(1)*vin(2)-v31(2)*vin(1)

      if (vcross(1)*vnor(1)+vcross(2)*vnor(2)+vcross(3)*vnor(3).ge.0.0d0) then
        iover=0
        goto 9999
      endif

9999  continue

      return
      end
+DECK,util_invert_matrix_2x2.
*CMZ :  3.05/11 11/01/2018  11.54.22  by  Michael Scheer
*-- Author :    Michael Scheer   10/01/2018
      subroutine util_invert_matrix_2x2(a,ainv,ifail)

c +PATCH,//UTIL/UTIL
c +DECK,util_invert_matrix_2x2.

      ! Calcutate

      implicit none

      double precision a(2,2),ainv(2,2),uni(2,2)
      integer :: ifail

      data uni/1.0d0,0.0d0,0.0d0,1.0d0/

      call util_solve_matrix_2x2(a,uni,ainv,ifail)

      return
      end
+DECK,util_solve_matrix_2x2.
*CMZ :  3.05/11 15/08/2018  15.03.26  by  Michael Scheer
*-- Author :    Michael Scheer   15/08/2018
*CMZ :          11/01/2018  11.54.22  by  Michael Scheer
*-- Author :    Michael Scheer   10/01/2018
      subroutine util_solve_matrix_2x2(a,b,x,ifail)

c +PATCH,//UTIL/UTIL
c +DECK,util_solve_matrix_2x2.

      ! Calculate matrix x, such that b=x*a

      implicit none

      double precision x(2,2),a(2,2),b(2,2),det
      integer :: ifail

      ifail=0
      det=a(1,1)*a(2,2)-a(1,2)*a(2,1)
      if (abs(det).lt.1.0d-30) then
        ifail=-1
        return
      endif

      x(1,1)=(-a(2,1)*b(1,2)+a(2,2)*b(1,1))/det
      x(1,2)=(+a(1,1)*b(1,2)-a(1,2)*b(1,1))/det
      x(2,1)=(-a(2,1)*b(2,2)+a(2,2)*b(2,1))/det
      x(2,2)=(+a(1,1)*b(2,2)-a(1,2)*b(2,1))/det

c      print*,x(1,1)*a(1,1)+x(1,2)*a(2,1)
c      print*,x(1,1)*a(1,2)+x(1,2)*a(2,2)
c      print*,x(2,1)*a(1,1)+x(2,2)*a(2,1)
c      print*,x(2,1)*a(1,2)+x(2,2)*a(2,2)

      return
      end
+DECK,util_rotate_vector_to_x_axis.
*CMZ :  3.05/23 28/11/2018  09.28.33  by  Michael Scheer
*-- Author :    Michael Scheer   08/03/2018
      subroutine util_rotate_vector_to_x_axis(vin,rotmat,istat)

      implicit none

      double precision cosphi,sinphi,costhe,sinthe,vin(3),
     &  vx,vy,vz,vn,rotmat(3,3),rotphi(3,3),rotthe(3,3)

      integer istat

      istat=0
      vn=sqrt(vin(1)**2+vin(2)**2+vin(3)**2)

      rotmat=0.0d0

      if (vn.eq.0.0d0) then
        istat=-1
        return
      endif

      vx=vin(1)/vn
      vy=vin(2)/vn
      vz=vin(3)/vn

      if (vy**2+vz**2.lt.1.0d-9) then
        rotmat(1,1)=1.0d0
        rotmat(1,2)=0.0d0
        rotmat(1,3)=0.0d0
        rotmat(2,1)=0.0d0
        rotmat(2,2)=1.0d0
        rotmat(2,3)=0.0d0
        rotmat(3,1)=0.0d0
        rotmat(3,2)=0.0d0
        rotmat(3,3)=1.0d0
        return
      endif

      costhe=vz
      sinthe=sqrt(1.0d0-min(1.0d0,costhe**2))

      if (sinthe.lt.1.0d-9) then
        rotmat(1,1)=0.0d0
        rotmat(1,2)=0.0d0
        rotmat(1,3)=1.0d0
        rotmat(2,1)=0.0d0
        rotmat(2,2)=1.0d0
        rotmat(2,3)=0.0d0
        rotmat(3,1)=-1.0d0
        rotmat(3,2)=0.0d0
        rotmat(3,3)=0.0d0
        return
      endif

      if (vz.lt.0.0d0) sinthe=-sinthe

      if (abs(vz).lt.1.0d-9) then
        cosphi=vx
        sinphi=vy
        rotmat(1,1)=cosphi
        rotmat(1,2)=sinphi
        rotmat(1,3)=0.0d0
        rotmat(2,1)=-sinphi
        rotmat(2,2)=cosphi
        rotmat(2,3)=0.0d0
        rotmat(3,1)=0.0d0
        rotmat(3,2)=0.0d0
        rotmat(3,3)=1.0d0
        return
      endif

      cosphi=vx/sinthe
      sinphi=sqrt(1.0d0-min(1.0d0,cosphi**2))
      if(vy.lt.0.0d0) sinphi=-sinphi

      rotphi(1,1)=cosphi
      rotphi(1,2)=sinphi
      rotphi(1,3)=0.0d0
      rotphi(2,1)=-sinphi
      rotphi(2,2)=cosphi
      rotphi(2,3)=0.0d0
      rotphi(3,1)=0.0d0
      rotphi(3,2)=0.0d0
      rotphi(3,3)=1.0d0

      rotthe(1,1)=sinthe
      rotthe(1,2)=0.0d0
      rotthe(1,3)=costhe

      rotthe(2,1)=0.0
      rotthe(2,2)=1.0d0
      rotthe(2,3)=0.0

      rotthe(3,1)=-costhe
      rotthe(3,2)=0.0d0
      rotthe(3,3)=sinthe

      rotmat(1,1)=
     &  rotthe(1,1)*rotphi(1,1)+rotthe(1,2)*rotphi(2,1)+rotthe(1,3)*rotphi(3,1)
      rotmat(1,2)=
     &  rotthe(1,1)*rotphi(1,2)+rotthe(1,2)*rotphi(2,2)+rotthe(1,3)*rotphi(3,2)
      rotmat(1,3)=
     &  rotthe(1,1)*rotphi(1,3)+rotthe(1,2)*rotphi(2,3)+rotthe(1,3)*rotphi(3,3)

      rotmat(2,1)=
     &  rotthe(2,1)*rotphi(1,1)+rotthe(2,2)*rotphi(2,1)+rotthe(2,3)*rotphi(3,1)
      rotmat(2,2)=
     &  rotthe(2,1)*rotphi(1,2)+rotthe(2,2)*rotphi(2,2)+rotthe(2,3)*rotphi(3,2)
      rotmat(2,3)=
     &  rotthe(2,1)*rotphi(1,3)+rotthe(2,2)*rotphi(2,3)+rotthe(2,3)*rotphi(3,3)

      rotmat(3,1)=
     &  rotthe(3,1)*rotphi(1,1)+rotthe(3,2)*rotphi(2,1)+rotthe(3,3)*rotphi(3,1)
      rotmat(3,2)=
     &  rotthe(3,1)*rotphi(1,2)+rotthe(3,2)*rotphi(2,2)+rotthe(3,3)*rotphi(3,2)
      rotmat(3,3)=
     &  rotthe(3,1)*rotphi(1,3)+rotthe(3,2)*rotphi(2,3)+rotthe(3,3)*rotphi(3,3)

      return
      end
+DECK,util_body.
*CMZ :  3.05/12 23/08/2018  11.48.02  by  Michael Scheer
*-- Author :    Michael Scheer   23/08/2018
      subroutine util_body

      implicit none

      include 'phyconparam.cmn'

      return
      end
+DECK,util_check_inf_and_nan.
*CMZ :  3.05/12 23/08/2018  11.53.21  by  Michael Scheer
*-- Author :    Michael Scheer   23/08/2018
      subroutine util_check_inf_and_nan(n,x,infnan,istatus)

      implicit none

      double precision x(*)
      integer n,i,istatus,infnan(*)

      istatus=0

      do i=1,n
        if (x(i).ne.x(i)) then
          infnan(i)=1
          istatus=istatus+1
        else if (1.0d0/x(i).eq.0.0d0) then
          infnan(i)=-1
          istatus=istatus+1
        endif
      enddo

      return
      end
+DECK,util_check_inf_and_nan_sngl.
*CMZ :  3.05/12 23/08/2018  11.56.03  by  Michael Scheer
*-- Author :    Michael Scheer   23/08/2018
      subroutine util_check_inf_and_nan_sngl(n,x,infnan,istatus)

      implicit none

      real x(*)
      integer n,i,istatus,infnan(*)

      istatus=0

      do i=1,n
        if (x(i).ne.x(i)) then
          infnan(i)=1
          istatus=istatus+1
        else if (1.0/x(i).eq.0.0) then
          infnan(i)=-1
          istatus=istatus+1
        endif
      enddo

      return
      end
+DECK,util_determinante_4.
*CMZ :  3.05/13 30/08/2018  16.19.30  by  Michael Scheer
*CMZ : 00.00/02 27/06/2005  19.03.55  by  Michael Scheer
*CMZ : 00.00/01 05/06/96  16.08.05  by  Michael Scheer
*-- Author :    Michael Scheer   03/06/96
      SUBROUTINE UTIL_DETERMINANTE_4(A,DET,ifail)

C CALCULATES DETERMINANT OF MATRIX A(3,3)

      IMPLICIT NONE

      DOUBLE PRECISION A(4,4),DET
      integer ifail

      ifail=0

      det=
     &   a(1,1)*a(2,2)*a(3,3)*a(4,4)
     &  -a(1,1)*a(2,2)*a(3,4)*a(4,3)
     &  -a(1,1)*a(2,3)*a(3,2)*a(4,4)
     &  +a(1,1)*a(2,3)*a(3,4)*a(4,2)
     &  +a(1,1)*a(2,4)*a(3,2)*a(4,3)
     &  -a(1,1)*a(2,4)*a(3,3)*a(4,2)
     &  -a(1,2)*a(2,1)*a(3,3)*a(4,4)
     &  +a(1,2)*a(2,1)*a(3,4)*a(4,3)
     &  +a(1,2)*a(2,3)*a(3,1)*a(4,4)
     &  -a(1,2)*a(2,3)*a(3,4)*a(4,1)
     &  -a(1,2)*a(2,4)*a(3,1)*a(4,3)
     &  +a(1,2)*a(2,4)*a(3,3)*a(4,1)
     &  +a(1,3)*a(2,1)*a(3,2)*a(4,4)
     &  -a(1,3)*a(2,1)*a(3,4)*a(4,2)
     &  -a(1,3)*a(2,2)*a(3,1)*a(4,4)
     &  +a(1,3)*a(2,2)*a(3,4)*a(4,1)
     &  +a(1,3)*a(2,4)*a(3,1)*a(4,2)
     &  -a(1,3)*a(2,4)*a(3,2)*a(4,1)
     &  -a(1,4)*a(2,1)*a(3,2)*a(4,3)
     &  +a(1,4)*a(2,1)*a(3,3)*a(4,2)
     &  +a(1,4)*a(2,2)*a(3,1)*a(4,3)
     &  -a(1,4)*a(2,2)*a(3,3)*a(4,1)
     &  -a(1,4)*a(2,3)*a(3,1)*a(4,2)
     &  +a(1,4)*a(2,3)*a(3,2)*a(4,1)

      if (det.ne.det) then
        ifail=1
      else if (1.0d0/det.eq.0.0d0) then
        ifail=2
      endif

      RETURN
      END
+DECK,util_interpol_linear.
*CMZ :  3.05/22 08/11/2018  13.06.16  by  Michael Scheer
*CMZ :  1.16/00 07/05/2017  12.11.52  by  Michael Scheer
*CMZ :  1.15/10 10/04/2017  12.35.04  by  Michael Scheer
*CMZ : 00.00/15 15/04/2013  19.27.04  by  Michael Scheer
*CMZ : 00.00/07 09/05/2008  08.29.47  by  Michael Scheer
*-- Author :    Michael Scheer   08/05/2008
      subroutine util_interpol_linear(n,xa,ya,x,y,ifail)

      implicit none

      double precision xa(n),ya(n),x,y,xa1old,xanold

      integer nold,n,klo,khi,klold,k,ifail

      save

      data klold/1/,nold/-99/
      data xa1old/-9999.0d0/,xanold/-9999.0d0/

      ifail=-1
      if (n.lt.2) return

      klo=1
      khi=n

      klo=1

      if (klold.ge.n) then
        khi=n
      else if(nold.eq.n
     &    .and. xa(1).eq.xa1old
     &    .and. xa(n).eq.xanold
     &    ) then
        if (x.gt.xa(klold)) then
          klo=klold
        else if (klold.gt.1) then
          if (x.gt.xa(klold-1)) klo=klold-1
        endif
      endif

      if (x.lt.xa(klo+1)) then
        khi=klo+1
        goto 3
      endif

      if (xa(1).lt.xa(n)) then

        khi=n

1       if (khi-klo.gt.1) then
          k=(khi+klo)/2
          if(xa(k).gt.x)then
            khi=k
          else
            klo=k
          endif
          goto 1
        endif

      else if (xa(n).lt.xa(1)) then

        if (x.lt.xa(n).or.x.gt.xa(1)) return

        khi=n

2       if (khi-klo.gt.1) then

          k=(khi+klo)/2

          if(xa(k).lt.x)then
            khi=k
          else
            klo=k
          endif

          goto 2

        endif

      endif !xa(1).lt.xa(n)

3     continue

      y=ya(klo)+(ya(khi)-ya(klo))/(xa(khi)-xa(klo))*(x-xa(klo))

      ifail=0
      nold=n
      klold=klo
      xa1old=xa(1)
      xanold=xa(n)

      return
      end
+DECK,util_plane_hit.
*CMZ :  3.05/28 07/01/2019  13.02.07  by  Michael Scheer
*CMZ :  3.05/26 07/12/2018  12.21.13  by  Michael Scheer
*CMZ :  3.05/20 01/11/2018  15.08.03  by  Michael Scheer
*CMZ : 00.00/19 07/06/2016  12.17.28  by  Michael Scheer
*-- Author :    Michael Scheer   07/06/2016
      subroutine util_plane_hit(p1,p2,p3,p,v,hit,dist,distn,vnorm,istat)

      implicit none

      double precision p1(3),p2(3),p3(3),p(3),v(3),p21(3),p31(3),pp1(3),
     &  a(3,3),x(3),hit(3),dist,distn,vnorm(3)

c Calculates point hit in plane (p1,p2,p3), where r=p+dist*v hits the plane,
c i.e. dist is distance from p to then plane in the direction of v, while
c distn is the distance to the plane

      integer istat

      istat=0

      p21=p2-p1
      p31=p3-p1
      pp1=p-p1

      a(1:3,1)=v(1:3)
      a(1:3,2)=p21(1:3)
      a(1:3,3)=p31(1:3)

      call util_solve_3x3(a,pp1,istat)
      if (istat.ne.0) return

      hit=p-pp1(1)*v
      x=hit-p
      dist=sqrt(x(1)**2+x(2)**2+x(3)**2)

      if (x(1)*v(1)+x(2)*v(2)+x(3)*v(3).lt.0.0d0) then
        dist=-dist
      endif

      call util_vnorm_of_plane(p1,p2,p3,vnorm,istat)
      if (istat.ne.0) return

      distn=vnorm(1)*x(1)+vnorm(2)*x(2)+vnorm(3)*x(3)

      return
      end
+DECK,util_plane_hit_hesse.
*CMZ :  3.05/28 07/01/2019  13.00.10  by  Michael Scheer
*CMZ :  3.05/26 07/12/2018  12.07.54  by  Michael Scheer
*CMZ :  3.05/20 01/11/2018  15.08.03  by  Michael Scheer
*CMZ : 00.00/19 07/06/2016  12.17.28  by  Michael Scheer
*-- Author :    Michael Scheer   07/06/2016
      subroutine util_plane_hit_hesse(pp,vp,pl,vl,hit,dist,distn,istat)

      implicit none

      double precision pp(3),vp(3),pl(3),vl(3),hit(3),p1(3),p2(3),
     &  u(3),v(3),w(3),vln,vpn,dist,distn

      integer istat

      vpn=sqrt(vp(1)**2+vp(2)**2+vp(3)**2)
      if (vpn.eq.0.0d0) then
        istat=-1
        return
      endif

      vln=sqrt(vl(1)**2+vl(2)**2+vl(3)**2)
      if (vln.eq.0.0d0) then
        istat=-2
        return
      endif

      u=vp/vpn

      if (abs(u(3)).lt.0.5d0) then
        v(1)=-u(2)
        v(2)=u(1)
        v(3)=0.0d0
      else
        v(1)=0.0d0
        v(2)=-u(3)
        v(3)=u(2)
      endif

      w(1)=u(2)*v(3)-u(3)*v(2)
      w(2)=u(3)*v(1)-u(1)*v(3)
      w(3)=u(1)*v(2)-u(2)*v(1)

      p1=pp+v
      p2=pp+w

      call util_plane_hit(pp,p1,p2,pl,vl,hit,dist,distn,u,istat)

      return
      end
+DECK,util_solve_3x3.
*CMZ :  4.00/17 31/10/2022  15.40.27  by  Michael Scheer
*CMZ :  4.00/11 28/05/2021  09.15.52  by  Michael Scheer
*CMZ :  3.05/20 31/10/2018  16.15.03  by  Michael Scheer
*CMZ : 00.00/16 20/07/2015  09.58.29  by  Michael Scheer
*-- Author :    Michael Scheer   20/07/2015
      subroutine util_solve_3x3(a,x,ifail)

      implicit none

      double precision a(3,3),x(3),det,dws,ws(3,3),xs(3)

      integer ifail,i

      call util_determinante_3(a,det)
      if (det.eq.0.0d0) then
        ifail=-1
        return
      endif

      xs=x

      do i=1,3
        ws=a
        ws(1:3,i)=xs
        call util_determinante_3(ws,dws)
        x(i)=dws/det
      enddo

      ifail=0

      return
      end
+DECK,util_determinante_3.
*CMZ : 00.00/02 27/06/2005  19.03.55  by  Michael Scheer
*CMZ : 00.00/01 05/06/96  16.08.05  by  Michael Scheer
*-- Author :    Michael Scheer   03/06/96
      SUBROUTINE UTIL_DETERMINANTE_3(A,DET)

C CALCULATES DETERMINANT OF MATRIX A(3,3)

      IMPLICIT NONE

      DOUBLE PRECISION A(3,3),DET

      DET=
     &   A(1,1)*(A(2,2)*A(3,3)-A(3,2)*A(2,3))
     &  -A(2,1)*(A(1,2)*A(3,3)-A(3,2)*A(1,3))
     &  +A(3,1)*(A(1,2)*A(2,3)-A(2,2)*A(1,3))

      RETURN
      END
+DECK,util_interpol_on_grid.
*CMZ :  3.05/22 08/11/2018  13.08.23  by  Michael Scheer
*-- Author :    Michael Scheer   08/11/2018
      subroutine util_interpol_on_grid(ndat,xdat,ydat,ngrid,xgrid,ygrid,istat)

c +PATCH,//UTIL/MAIN
c +DECK,util_interpol_on_grid.

      implicit none

      double precision xdat(ndat),ydat(ndat),xgrid(ngrid),ygrid(ngrid)

      integer ndat,ngrid,i,ifail,istat

      do i=1,ngrid
        call util_interpol_linear(ndat,xdat,ydat,xgrid(i),ygrid(i),ifail)
        if (ifail.ne.0) then
          print*,"*** Error, Bad return from util_interpol_linear ***"
          istat=i
          return
        endif
      enddo

      return
      end
+DECK,util_interpol_extrapol_on_grid.
*CMZ :  3.05/22 08/11/2018  13.48.34  by  Michael Scheer
*-- Author :    Michael Scheer   08/11/2018
      subroutine util_interpol_extrapol_on_grid(
     &  ndat,xdat,ydat,ngrid,xgrid,ygrid,istat)

c +PATCH,//UTIL/MAIN
c +DECK,util_interpol_extrapol_on_grid.

      implicit none

      double precision xdat(ndat),ydat(ndat),xgrid(ngrid),ygrid(ngrid)

      integer ndat,ngrid,i,istat,ifail

      do i=1,ngrid
        call util_interpol_extrapol_linear(ndat,xdat,ydat,xgrid(i),ygrid(i),ifail)
        istat=istat+ifail
      enddo

      return
      end
+DECK,util_interpol_extrapol_linear.
*CMZ :  3.05/23 23/11/2018  18.06.23  by  Michael Scheer
*CMZ :  1.16/00 07/05/2017  12.11.52  by  Michael Scheer
*CMZ :  1.15/10 10/04/2017  12.35.04  by  Michael Scheer
*CMZ : 00.00/15 15/04/2013  19.27.04  by  Michael Scheer
*CMZ : 00.00/07 09/05/2008  08.29.47  by  Michael Scheer
*-- Author :    Michael Scheer   08/05/2008
      subroutine util_interpol_extrapol_linear(n,xa,ya,x,y,ifail)

      implicit none

      double precision xa(n),ya(n),x,y,xa1old,xanold

      integer nold,n,klo,khi,klold,k,ifail

      save

      data klold/1/,nold/-99/
      data xa1old/-9999.0d0/,xanold/-9999.0d0/

      ifail=-1
      if (n.lt.2) return

      if (xa(1).eq.xa(2).or.xa(n-1).eq.xa(n)) then
        return
      else if (xa(1).lt.xa(2)) then
        if (x.lt.xa(1)) then
          y=ya(1)+(ya(2)-ya(1))/(xa(2)-xa(1))*(x-xa(1))
          ifail=0
          return
        else if (x.gt.xa(n)) then
          y=ya(n)+(ya(n)-ya(n-1))/(xa(n)-xa(n-1))*(x-xa(n))
          ifail=0
          return
        endif
      else
        if (x.gt.xa(1)) then
          y=ya(1)+(ya(2)-ya(1))/(xa(2)-xa(1))*(x-xa(1))
          ifail=0
          return
        else if (x.lt.xa(n)) then
          y=ya(n)+(ya(n)-ya(n-1))/(xa(n)-xa(n-1))*(x-xa(n))
          ifail=0
          return
        endif
      endif

      klo=1
      khi=n

      klo=1

      if (klold.ge.n) then
        khi=n
      else if(nold.eq.n
     &    .and. xa(1).eq.xa1old
     &    .and. xa(n).eq.xanold
     &    ) then
        if (x.gt.xa(klold)) then
          klo=klold
        else if (klold.gt.1) then
          if (x.gt.xa(klold-1)) klo=klold-1
        endif
      endif

      if (x.lt.xa(klo+1)) then
        khi=klo+1
        goto 3
      endif

      if (xa(1).lt.xa(n)) then

        khi=n

1       if (khi-klo.gt.1) then
          k=(khi+klo)/2
          if(xa(k).gt.x)then
            khi=k
          else
            klo=k
          endif
          goto 1
        endif

      else if (xa(n).lt.xa(1)) then

        if (x.lt.xa(n).or.x.gt.xa(1)) return

        khi=n

2       if (khi-klo.gt.1) then

          k=(khi+klo)/2

          if(xa(k).lt.x)then
            khi=k
          else
            klo=k
          endif

          goto 2

        endif

      endif !xa(1).lt.xa(n)

3     continue

      y=ya(klo)+(ya(khi)-ya(klo))/(xa(khi)-xa(klo))*(x-xa(klo))

      ifail=0
      nold=n
      klold=klo
      xa1old=xa(1)
      xanold=xa(n)

      return
      end
+DECK,util_atan.
*CMZ :  3.05/23 21/11/2018  13.03.11  by  Michael Scheer
*-- Author :    Michael Scheer   21/11/2018
      subroutine util_atan(x,y,grad,rad)

      implicit none

      double precision x,y,grad,rad

      rad=atan2(y,x)
      if (rad.lt.0.0d0) rad=rad+6.283185307180d0
      grad=rad*57.295779513082323d0

      return
      end
+DECK,util_atan2.
*CMZ :  3.05/23 21/11/2018  13.03.11  by  Michael Scheer
*-- Author :    Michael Scheer   21/11/2018
      function util_atan2(y,x)

      implicit none

      double precision x,y,util_atan2

      util_atan2=atan2(y,x)
      if (util_atan2.lt.0.0d0) util_atan2=util_atan2+6.2831853071795862d0

      return
      end
+DECK,util_minmax_real_array.
*CMZ :  3.05/23 22/11/2018  13.21.09  by  Michael Scheer
*-- Author :    Michael Scheer   22/11/2018
      subroutine util_minmax_real_array(n,x,xmin,xmax,kmin,kmax)

      implicit none

      real x(n),xmin,xmax
      integer i,n,kmin,kmax

      xmin=1.0e30
      xmax=-1.0e30

      do i=1,n
        if (x(i).lt.xmin) then
          xmin=x(i)
          kmin=i
        endif
        if (x(i).gt.xmax) then
          xmax=x(i)
          kmax=i
        endif
      enddo

      return
      end
+DECK,util_minmax_array.
*CMZ :  3.05/23 22/11/2018  13.21.09  by  Michael Scheer
*-- Author :    Michael Scheer   22/11/2018
      subroutine util_minmax_array(n,x,xmin,xmax,kmin,kmax)

      implicit none

      real*8 x(n),xmin,xmax
      integer i,n,kmin,kmax

      xmin=1.0e30
      xmax=-1.0e30

      do i=1,n
        if (x(i).lt.xmin) then
          xmin=x(i)
          kmin=i
        endif
        if (x(i).gt.xmax) then
          xmax=x(i)
          kmax=i
        endif
      enddo

      return
      end
+DECK,util_mat_mul_vec_3x3.
*CMZ :  4.00/14 28/12/2021  10.33.13  by  Michael Scheer
*CMZ :  3.05/23 28/11/2018  08.59.05  by  Michael Scheer
*CMZ : 00.00/02 21/07/2004  15.43.47  by  Michael Scheer
*-- Author :    Michael Scheer   21/07/2004
      subroutine util_mat_mul_vec_3x3(a,vin,w)

      implicit none

      double precision a(3,3),v(3),w(3),vin(3)

      v=vin

      w(1)=a(1,1)*v(1)+a(1,2)*v(2)+a(1,3)*v(3)
      w(2)=a(2,1)*v(1)+a(2,2)*v(2)+a(2,3)*v(3)
      w(3)=a(3,1)*v(1)+a(3,2)*v(2)+a(3,3)*v(3)

      return
      end
+DECK,util_rotate_vector.
*CMZ :  3.05/23 11/04/2018  12.04.00  by  Michael Scheer
*-- Author :    Michael Scheer   06/04/2018
      subroutine util_rotate_vector(vin,axis,angle,vout,istat)

      implicit none

      double precision vin(3),vout(3),axis(3),angle,vn(3),vnor,
     &  anor,ex(3),ey(3),ez(3),
     &  cosz,cosx

      integer istat

      istat=0

      vnor=sqrt(vin(1)**2+vin(2)**2+vin(3)**2)

      if (vnor.eq.0.0d0) then
        istat=1
        vout=vin
        return
      endif

      anor=sqrt(axis(1)**2+axis(2)**2+axis(3)**2)

      if (anor.eq.0.0d0) then
        istat=2
        vout=vin
        return
      endif

      if (angle.eq.0.0d0) then
        vout=vin
        return
      endif

      vn=vin/vnor
      ez=axis/anor

      ey(1)=ez(2)*vn(3)-ez(3)*vn(2)
      ey(2)=ez(3)*vn(1)-ez(1)*vn(3)
      ey(3)=ez(1)*vn(2)-ez(2)*vn(1)

      if (ey(1).eq.0.0d0.and.ey(2).eq.0.0d0.and.ey(3).eq.0.0d0) then
        vout=vin
        return
      endif

      ey=ey/sqrt(ey(1)**2+ey(2)**2+ey(3)**2)

      ex(1)=ey(2)*ez(3)-ey(3)*ez(2)
      ex(2)=ey(3)*ez(1)-ey(1)*ez(3)
      ex(3)=ey(1)*ez(2)-ey(2)*ez(1)

      cosx=vin(1)*ex(1)+vin(2)*ex(2)+vin(3)*ex(3)
      cosz=vin(1)*ez(1)+vin(2)*ez(2)+vin(3)*ez(3)

      vout=cosx*(cos(angle)*ex+sin(angle)*ey)+cosz*ez

      return
      end
+DECK,util_vnorm_of_plane.
*CMZ :  3.05/28 07/01/2019  12.28.26  by  Michael Scheer
*CMZ : 00.00/02 26/01/2004  16.28.03  by  Michael Scheer
*-- Author :    Michael Scheer   26/01/2004
      subroutine util_vnorm_of_plane(p1,p2,p3,vnorm,istat)

c +PATCH,//UTIL/FOR
c +DECK,util_vnorm_of_plane.

      implicit none

      double precision p1(3),p2(3),p3(3),vnorm(3),p12(3),p23(3),vn
      integer istat

      p12=p2-p1
      p23=p3-p2

      vnorm(1)=p12(2)*p23(3)-p12(3)*p23(2)
      vnorm(2)=p12(3)*p23(1)-p12(1)*p23(3)
      vnorm(3)=p12(1)*p23(2)-p12(2)*p23(1)

      vn=vnorm(1)**2+vnorm(2)**2+vnorm(3)**2

      if (vn.ne.0.0d0) then
        istat=0
        vnorm=vnorm/sqrt(vn)
      else
        istat=-1
      endif

      return
      end
+DECK,mrad_fringe_quintic_spline.
*CMZ :  3.06/00 18/01/2019  13.43.27  by  Michael Scheer
*CMZ :  3.05/26 06/12/2018  13.05.06  by  Michael Scheer
*CMZ :  3.05/23 12/11/2018  16.38.44  by  Michael Scheer
*-- Author :    Michael Scheer   12/11/2018
      subroutine mrad_fringe_quintic_spline(
     &  xin,y,z,bx,by,bz,ax,ay,az,fint,gap,fringe,istatus)

      implicit none

      double precision, intent(in) :: xin,y,z,gap,fint
      double precision, intent(out) :: bx,by,bz,fringe,ax,ay,az !ax,ay,az dummy
      double precision fb,fa,fc,fringe2,fringe3,fringe4,fringe5,
     &  x2,x3,x4,x5,x,y2,y3

      integer, intent(out) :: istatus

      include 'phyconparam.cmn'

      istatus=0

      x=xin

      bx=0.0d0
      by=1.0d0
      bz=0.0d0

      ax=0.0d0
      ay=0.0d0
      az=0.0d0

      if (gap.le.0.0d0.or.fint.le.0.0d0) then
        istatus=-1
        goto 9999
      endif

      !Int(y=0,by,0->fringe)=1/2
      fringe=231.0d0*fint*gap/25.0d0

      if(x.lt.0.0d0) then
        by=0.0d0
        return
      else if (x.gt.fringe) then
        by=1.0d0
      else

        fringe2=fringe*fringe
        fringe3=fringe2*fringe
        fringe4=fringe2*fringe2
        fringe5=fringe3*fringe2

        x2=x*x
        x3=x2*x
        x4=x2*x2
        x5=x3*x2
        y2=y*y
        y3=y2*y

        fa=10.0d0/fringe3
        fb=-15.0d0/fringe4
        fc=6.0d0/fringe5

        bx=y*(3.0d0*Fa*x2+4.0d0*fb*x3+5.0d0*fc*x4)
     &    +y3*(-fa-4.0d0*fb*x-10.0d0*fc*x2) !This term is not Maxwell conform
c      by=(fa*x3+fb*x4+fc*x5)+y2*x*(3.0d0*fa+6.0d0*fb*x+10.0d0*fc*x2) ! The sign seems to be wrong in the manual
        by=(fa*x3+fb*x4+fc*x5)-y2*x*(3.0d0*fa+6.0d0*fb*x+10.0d0*fc*x2)

      endif

9999  continue

      return
      end
+DECK,csbend.
*CMZ :  4.01/07 23/11/2024  14.57.16  by  Michael Scheer
*CMZ :  4.00/13 28/10/2021  11.24.17  by  Michael Scheer
*CMZ :  4.00/11 02/07/2021  10.12.35  by  Michael Scheer
*CMZ :  3.06/00 11/02/2019  13.10.51  by  Michael Scheer
*CMZ :  3.05/28 07/01/2019  14.51.12  by  Michael Scheer
*-- Author :    Michael Scheer   22/12/2018
      subroutine csbend(cbmodel,strength,angle,dlength,edge,seclen,
     &  posi,fint,hgap,de,ebeam,bmovecut,ds,istatus)

      ! angle and edge in degree

      implicit none

      double precision strength,angle,dlength,seclen,posi(4,3),fringe,hgap,
     &  gamma,elmom,brho,rho,ang,fint,gap,edge(2),beta,ds,dtim,dtim0,dt,
     &  x2b,y2b,z2b,x2,y2,z2,x1,y1,z1,vxp,vyp,vzp,vx1,vy1,vz1,vx2,vy2,vz2,
     &  s1,s2,dgamma,edg1,edg2,efx2,efy2,efz2,bx2,by2,bz2,ang1,ang2,slen,dang,
     &  fringe2,fringe3,x3,fa,fb,x4,x5,y3,fringe4,fringe5,fc,ex,ey,ez,dbint,
     &  de,dde,bmovecut,ebeam

      integer istatus
      integer :: icharge=-1

      character(32) cbmodel

+seq,phyconparam.
      double precision util_atan2

      istatus=0

      if (abs(angle/2.0d0-edge(1)).gt.1.0d-12 .or.
     &    abs(angle/2.0d0-edge(2)).gt.1.0d-12) then
        stop "*** Error in csbend: Edge-angle .ne. half the deflection angle ***"
      endif

      if (angle*dlength.eq.0.0d0) then
        istatus=-2
        return
      endif

      de=0.0d0

      ang=angle*grarad1
      edg1=edge(1)*grarad1
      edg2=edge(2)*grarad1
      ex=cos(edg1)
      ez=sin(edg1)
      gamma=ebeam/emassg1 !GeV
      beta=dsqrt((1.0d0-1.0d0/gamma)*(1.0d0+1.0d0/gamma))
      elmom=emassg1*dsqrt((gamma-1.0d0)*(gamma+1.0d0)) !GeV
      brho=elmom*1.0d9/clight1
      rho=dlength/ang
      strength=brho/rho
      posi=0.0d0
      gap=2.0d0*hgap
      dtim0=ds/clight1/beta
      dtim=dtim0

      if (cbmodel.eq."hard-edge") then

        posi(1,3)=-sin(ang/2.0d0)*rho
        posi(3,3)=-(1.0d0-cos(ang/2.0d0))*rho

        posi(1,1)=-posi(1,3)
        posi(3,1)=posi(3,3)

        posi(4,2)=ang*rho/2.0d0
        posi(4,3)=ang*rho

        seclen=2.0d0*abs(posi(1,3))

        dtim=rho*ang/2.0d0/clight1/beta
        dde=powcon1*strength**2*gamma*ebeam*dtim !GeV
        de=de+dde

      else if (cbmodel.eq."linear"
     &    .or.cbmodel.eq."cubic-spline"
     &    .or.cbmodel.eq."quintic-spline"
     &    ) then

        x2=0.0d0
        y2=0.0d0
        z2=0.0d0
        s2=0.0d0

        vx2=cos(edg1)*beta*clight1
        vy2=0.0d0
        vz2=sin(edg1)*beta*clight1

        if (cbmodel.eq."linear") then
          fringe=6.0d0*fint*gap
        else if (cbmodel.eq."cubic-spline") then
          fringe=70.0d0/9.0d0*fint*gap
          fringe2=fringe*fringe
          fringe3=fringe2*fringe
          fb=-2.0d0/fringe3
          fa=3.0d0/fringe2
        else if (cbmodel.eq."quintic-spline") then
          fringe=231.0d0*fint*gap/25.0d0
          fringe2=fringe*fringe
          fringe3=fringe2*fringe
          fringe4=fringe2*fringe2
          fringe5=fringe3*fringe2
          fa=10.0d0/fringe3
          fb=-15.0d0/fringe4
          fc=6.0d0/fringe5
        else
          stop "*** Model not yet defined in csbend ***"
        endif

        y2b=0.0d0

        do while (x2.lt.fringe+3.0d0*ds)

          x1=x2
          y1=y2
          z1=z2
          s1=s2

          vx1=vx2
          vy1=vy2
          vz1=vz2

          x2b=x1+vx1*dtim/2.0d0
          y2b=y1+vy1*dtim/2.0d0
          z2b=z1+vz1*dtim/2.0d0

          bz2=0.0d0

          if (x2b.lt.fringe) then

            if (cbmodel.eq."linear") then
              bx2=y2b/fringe
              by2=x2b/fringe
            else if (cbmodel.eq."cubic-spline") then
              x2=x2b*x2b
              x3=x2*x2b
              bx2=(2.0d0*fa*x2b+3.0d0*fb*x2)*y2b
              by2=fa*x2+fb*x3+y2b**2*(-fa-3.0d0*fb*x2b)
            else if (cbmodel.eq."quintic-spline") then

              x2=x2b*x2b
              x3=x2*x2b
              x4=x2*x2
              x5=x3*x2
              y2=y2b*y2b
              y3=y2*y2b

              bx2=y2b*(3.0d0*Fa*x2+4.0d0*fb*x3+5.0d0*fc*x4)
     &          +y3*(-fa-4.0d0*fb*x2b-10.0d0*fc*x2) !This term is not Maxwell conform
c             by2=(fa*x3+fb*x4+fc*x5)+y2*x2b*(3.0d0*fa+6.0d0*fb*x2b+10.0d0*fc*x2) ! The sign seems to be wrong in the manual
              by2=(fa*x3+fb*x4+fc*x5)-y2*x2b*(3.0d0*fa+6.0d0*fb*x2b+10.0d0*fc*x2)

            endif

            bx2=bx2*strength
            by2=by2*strength

          else
            bx2=0.0d0
            by2=strength
          endif

          dde=powcon1*by2**2*gamma*ebeam*dtim !GeV
          de=de+dde

          call bmovetayl(x1,y1,z1,vx1,vy1,vz1,bx2,by2,bz2,dtim,
     &      x2,y2,z2,vx2,vy2,vz2,vxp,vyp,vzp,gamma,icharge,bmovecut,
     &      0,0,dgamma)

          s2=s2+ds

        enddo !fringe

        ang1=util_atan2(vz1,vx1)
        ang2=util_atan2(vz2,vx2)

        x2=x2+rho*sin(ang2)
        z2=z2+rho*(1.0d0-cos(ang2))
        s2=s2+rho*ang2

        dtim=rho*ang2/clight1/beta
        dde=powcon1*strength**2*gamma*ebeam*dtim !GeV
        de=de+dde

        posi(1,1)=-x2
        posi(3,1)=-z2
        posi(1,3)=x2
        posi(3,3)=-z2
        posi(4,1)=0.0d0
        posi(4,2)=s2
        posi(4,3)=2.0d0*s2

        seclen=2.0d0*x2

      else
        stop "*** Model not yet defined in csbend ***"
      endif !model

      return
      end
+DECK,waveinstances.
*CMZ :  4.01/03 12/06/2023  11.06.51  by  Michael Scheer
*CMZ :  4.01/00 05/12/2022  09.54.57  by  Michael Scheer
*CMZ :  4.00/17 15/11/2022  10.06.37  by  Michael Scheer
*CMZ :  4.00/15 01/06/2022  16.29.17  by  Michael Scheer
*CMZ :  4.00/13 03/12/2021  16.25.25  by  Michael Scheer
*CMZ :  4.00/07 18/05/2020  09.47.26  by  Michael Scheer
*CMZ :  4.00/06 05/12/2019  13.13.01  by  Michael Scheer
*CMZ :  4.00/05 30/11/2019  15.57.36  by  Michael Scheer
*CMZ :  4.00/04 25/11/2019  15.41.55  by  Michael Scheer
*CMZ :  4.00/03 09/05/2019  10.59.58  by  Michael Scheer
*CMZ :  4.00/02 12/04/2019  15.05.49  by  Michael Scheer
*CMZ :  4.00/01 11/04/2019  14.40.23  by  Michael Scheer
*CMZ :  4.00/00 04/04/2019  12.29.10  by  Michael Scheer
*CMZ :  3.08/01 03/04/2019  11.56.15  by  Michael Scheer
*CMZ :  3.07/01 29/03/2019  14.35.23  by  Michael Scheer
*-- Author :    Michael Scheer   27/03/2019
      subroutine waveinstances

      use omp_lib
      use clustermod
      !use waveenv
      use bunchmod
      !use waveenv

      implicit none

+seq,contrl.
+seq,cmpara.
+seq,myfiles.
+seq,b0scglob.
+seq,freqs.
+seq,berror.
+seq,ampli.
+seq,photon.
+seq,random.
+seq,waveenv.

      integer lun0,lunin,lunclu,kins,ins,m1,m2,n1,n2,irun,istat,lunout,ianf,iend,ipid,
     &  lunfis,ieof,l1,l2,ialldone,masterpid,n1ins,n2ins,lpid,npids,i,idum,
     &  lunpid,lun10,i10,k10,ndim,kcount,lstat,kempty,k1,k2,ierr,kbuncherr,
     &  kstat,luni,lun,lunsi,iel1,iel2,lunspai,lunspao,iutil_fexist,nread,
     &  nfirst,nlast,icheckpid,lunbun,lunbu,ni,nl,nwords

      integer inspid(maxinstp),iwruns(0:maxinstp),ipos(2,maxinstp)
      integer :: iline=0

      real rn(1)

      logical lexist

      character(2048) cline,cstage,cstage0,cins,clineb,cline1
      character(64) c64,cpid

      print*,""
      print*,""

      WRITE(6,*)
      WRITE(6,*)'          *********************************************'
      WRITE(6,*)'          *          PROGRAM WAVE                     *'
      WRITE(6,*)'          *                                           *'
      WRITE(6,*)
+SEQ,WVERSION.
      WRITE(6,*)'          *                                           *'
      WRITE(6,*)'          *          Michael Scheer                   *'
      WRITE(6,*)'          *              BESSY                        *'
      WRITE(6,*)'          *********************************************'
      WRITE(6,*)

+seq,gplhint.

      !call wavesystem

      kbuncherr=0

1     continue

      open(newunit=lunin,file="wave.in",status='old')
      read(lunin,contrl)
      read(lunin,randomn)
      read(lunin,cluster)
      read(lunin,b0scglobn)
      read(lunin,myfiles)
      read(lunin,bunchn)
      read(lunin,freqn)
      read(lunin,berrorn)
      read(lunin,photonn)
      close(lunin)

      if (kampli.ne.0.or.iundulator.eq.2) then
        !if (iundulator.eq.2) mthreads=-1
        ibunch=0
        if (mthreads.lt.0.or.mthreads.gt.OMP_GET_MAX_THREADS()) then
          mthreads=OMP_GET_MAX_THREADS()
        else if (mthreads.eq.0) then
          mthreads=1
        endif
        mampthreads=mthreads
        iamppin=ipin
        iamppincirc=ipincirc
      endif

      if (ibunch.ne.0) then
        if (nbunch.le.0) nbunch=1
        if (neinbunch.le.0) neinbunch=1
      endif

      if (kbuncherr.gt.0) then
        neinbunch=kbuncherr
      else if (kbuncherr.lt.0) then
        nbunch=kbuncherr
      endif

      nwinstances=1

      if (icluster.lt.0) then
        open(newunit=lunclu,file="wave.ins",status='old')
        read(lunclu,*)iwinstance,nwinstances
        close(lunclu)
      endif

      if (
     &    ipin.eq.0.and.ibunch.eq.0
     &    .or.
     &    ibunch.ne.0.and.neinbunch*nbunch.eq.1
     &    ) then
        mthreads=0
      endif

      if (mthreads.lt.0.or.mthreads.gt.OMP_GET_MAX_THREADS()) then
        mthreads=OMP_GET_MAX_THREADS()
      endif

      if (ibunch.ne.0.and.icluster.eq.0.and.mthreads.ne.0) then
        if (mthreads.lt.0) then
          mthreads=OMP_GET_MAX_THREADS()
        endif
        icluster=1
      endif

C--- RANDOM NUMBERS

      if (kbuncherr.eq.0) then
        open(newunit=lunin,file="WAVE_CODE.DAT")
        call util_skip_comment_end(lunin,ieof)
        if (ieof.ne.0) then
          irun=1
          rewind(lunin)
          write(lunin,*) irun
        else
          read(lunin,*)irun
          irun=irun+1
        endif
        close(lunin)
      endif

      irnsize=64

      if (irnmode.lt.0) then
        open(newunit=lun,file='wave.seeds',status='old')
        read(lun,*)irnsize
        do i=1,irnsize
          read(lun,*)idum,irnseed(i)
        enddo
        close(lun)
        call util_random_set_seed(irnsize,irnseed)
      else if (irnmode.eq.1) then
        call util_random_set_seed(irnsize,irnseed)
      else
        call util_random_init(irnsize,irnseed)
      endif

      if (icluster.lt.0) then
        irnsize=64
        irnseed=irnseed+(iwinstance-1)
        call util_random_set_seed(irnsize,irnseed)
      endif

      call util_random_get_seed(irnsize,irnseedi)

      open(newunit=lunsi,file='wave_start.seeds')
      write(lunsi,*)irnsize,irun
      do i=1,irnsize
        write(lunsi,*)i,irnseedi(i)
      enddo
      close(lunsi)

      nbuncho=nbunch
      neinbuncho=neinbunch

      if (ibunch.eq.0.and.icluster.ne.0) then
        print*,"*** WARNING in WAVEINSTANCES: ICLUSTER .ne. 0, but IBUNCH .eq. 0 ***"
        print*,"ICLUSTER set ICLUSTER=0"
        icluster=0
        return
      endif

      wppath=trim(chwavedir)
      call util_string_split_sep(wppath,maxinstp,nwords,ipos,chpathsep,istat)
      chwstage=wppath(ipos(1,nwords):ipos(2,nwords))

      open(newunit=lunclu,file="wave.pid",status='old')
      read(lunclu,*)lpid
      if (lpid.ne.kpid) then
        stop "*** ERROR  in waveinstances: Bad PID ***"
      endif
      close(lunclu)

      nwinstances=1
      nwgood=1

      if (icluster.lt.0) then
        open(newunit=lunclu,file="wave.ins",status='old')
        read(lunclu,*)iwinstance,nwinstances
        close(lunclu)
      endif

      if (icluster.ge.0) then
        nwinstances=max(icluster,mthreads,1)
        if (ibunch.ne.0) mthreads=0
        if (nwinstances.gt.maxinstp) then
          print*,"--- Warning in waveinstances: Number of instances limited to ",
     &      maxinstp
          nwinstances=maxinstp
        endif
        if (ibunch.ne.0) then
          if (nbunch.eq.1.and.neinbunch.ge.1) then
            if (neinbunch.lt.nwinstances) then
              nwinstances=neinbunch
            endif
            if (neinbunch/nwinstances.lt.2) then
              nwinstances=1
            endif
          else if (nbunch.gt.1.and.neinbunch.eq.1) then
            if (nbunch.lt.nwinstances) then
              nwinstances=nbunch
            endif
          endif
        endif !(ibunch.ne.0) then
        iwstat=1
        inspid=0
        masterpid=kpid
      else
        inspid(iwinstance)=kpid
        goto 9999
      endif

      if (ibunch.ne.0.and.iubunch.eq.3) then
        open(newunit=lunspai,file="wave_phasespace.dat")
        nread=0
        ieof=0
        do i=1,nbunch*neinbunch
          call util_skip_comment_end(lunspai,ieof)
          read(lunspai,'(a)',iostat=ierr) cline
          if (ierr.ne.0) then
            if (nread.eq.0) then
              print*,"*** Error in waveinstaces: no electrons from wave_phasespace.dat ***"
              stop '*** Program WAVE aborted ***'
            else if (neinbunch.eq.1) then
              print*,"*** Warning in waveinstaces: Could read only",
     &          nread," electrons from wave_phasespace.dat ***"
              print*,"Setting NBUNCH = ",(nread/nwinstances)*nwinstances
              NBUNCH=(nread/nwinstances)*nwinstances
              exit
            else if (nbunch.eq.1) then
              print*,"*** Warning in waveinstaces: Could read only",
     &          nread," electrons from wave_phasespace.dat ***"
              print*,"Setting NEINBUNCH = ",(nread/nwinstances)*nwinstances
              NEINBUNCH=(nread/nwinstances)*nwinstances
              exit
            else
              print*,"*** Error in waveinstaces: Could read only",
     &          nread," electrons from wave_phasespace.dat ***"
              stop '*** Program WAVE aborted ***'
            endif
          endif
          nread=nread+1
        enddo
        close(lunspai)
      endif !iubunch

      if (icluster.gt.0) then

        open(newunit=lunclu,file="wave.ins")
        write(lunclu,*)"0 ",nwinstances
        close(lunclu)

        ! Set up the working directories

        open(newunit=lunbun,file="wave_ibunch.tmp")
        open(newunit=lunout,file="wave.tmp")
        open(newunit=lunin,file="wave.in",status='old')

        do while (.true.)

          read(lunin,'(a)',end=99)cline1
          iline=iline+1
          cline=cline1

          !print*,iline,trim(cline)
          call util_string_trim(cline1,nfirst,nlast)
          !if (nfirst.lt.0) cycle
          if (nfirst.lt.0) then
            write(lunout,'(a)') trim(cline)
            write(lunbun,'(a)') trim(cline)
            cycle
          endif

          if (nfirst.lt.0.or.cline1(nfirst:nfirst).eq.'!') then
            write(lunout,'(a)') trim(cline)
            write(lunbun,'(a)') trim(cline)
            cycle
          endif

          call util_lower_case(cline1)

          c64="CODE="
          call util_string_substring_igncase(cline1,trim(c64),ianf,iend,istat)
          if (istat.eq.0) then
            write(lunout,'(a)') trim(cline)
            write(lunbun,'(a)') trim(cline)
            cycle
          endif

          c64="irnmode=0"
          call util_string_substring_igncase(cline1,trim(c64),ianf,iend,istat)
          if (istat.eq.0) then
            cline(ianf:iend)="IRNMODE=2"
          endif

          c64="iclubun="
          call util_string_substring_igncase(cline1,trim(c64),ianf,iend,istat)
          if (istat.eq.0) then
            write(c64,*) nbunch
            call util_string_trim(c64,ni,nl)
            cline="      ICLUBUN=" // c64(ni:nl)
          endif

          c64="icluster="
          call util_string_substring_igncase(cline1,trim(c64),ianf,iend,istat)
          if (istat.eq.0) then
            cline="      ICLUSTER=-1"
          endif

          c64="mthreads="
          call util_string_substring_igncase(cline1,trim(c64),ianf,iend,istat)
          if (istat.eq.0) then
            cline="      MTHREADS=0"
          endif

          if (nbunch.gt.1) then
            c64="nbunch="
            call util_string_substring_igncase(cline1,trim(c64),ianf,iend,kstat)
            c64="neinbunch="
            call util_string_substring_igncase(cline1,trim(c64),ianf,iend,istat)
            if (kstat.eq.0.and.istat.ne.0) then
                write(c64,*) nbunch/nwinstances
                write(lunout,'(a)')"      NBUNCH=" // trim(c64)
                write(lunbun,'(a)')"      NBUNCH=" // trim(c64)
                cycle
            endif
          else if (neinbunch.gt.1) then
            c64="neinbunch="
            call util_string_substring_igncase(cline1,trim(c64),ianf,iend,kstat)
            if (kstat.eq.0) then
                write(c64,*) neinbunch/nwinstances
                write(lunout,'(a)')"      NEINBUNCH=" // trim(c64)
                write(lunbun,'(a)')"      NEINBUNCH=" // trim(c64)
                cycle
            endif
          endif

          if (ibunch.eq.-1) then
            c64="ibunch="
            call util_string_substring_igncase(cline1,trim(c64),ianf,iend,kstat)
            if (kstat.eq.0) then
                write(c64,*) neinbunch/nwinstances
                write(lunout,'(a)')"      IBUNCH=1"
                write(lunbun,'(a)')"      IBUNCH=-1"
                cycle
            endif
          endif

          write(lunout,'(a)') trim(cline)
          write(lunbun,'(a)') trim(cline)

        enddo

99      close(lunout)
        close(lunbun)
        close(lunin)

        kins=1
        if (ibunch.ne.0.and.iubunch.eq.3) kins=0

        do ins=kins,nwinstances

          cstage=trim(chwavedir)//"/.stage."
          call util_string_trim(cstage,m1,m2)
          write(cins,*)ins
          call util_string_trim(cins,n1,n2)
          cstage=cstage(m1:m2)//cins(n1:n2)

          kempty=0
          call wave_delete_dir(trim(cstage),kempty,istat)
          call wave_make_dir(trim(cstage),istat)
          if (istat.ne.0) then
            print*,"*** Error waveinstances: Can't create sub-directory"
            print*,trim(cstage)
          endif
          if (kins.eq.0.and.ins.eq.0.or.kins.eq.1.and.ins.eq.1) then
            call wave_copy_file('wave_ibunch.tmp',trim(cstage)//'/wave.in',istat)
            if (istat.ne.0) then
              print*,"*** Error waveinstances: Can't copy wave_ibunch.tmp to ",
     &          trim(cstage)//'/wave.in'
            endif
          else
            call wave_copy_file('wave.tmp',trim(cstage)//'/wave.in',istat)
            if (istat.ne.0) then
              print*,"*** Error waveinstances: Can't copy wave.tmp to ",
     &          trim(cstage)//'/wave.in'
            endif
          endif

          open(newunit=lunin,file=trim(cstage)//"/WAVE_CODE.DAT")

          call util_random(1,rn)
          irun=rn(1)*10000000-1
          write(lunin,*)irun
          iwruns(ins)=irun
          close(lunin)

          open(newunit=lunclu,file=trim(cstage)//"/wave.ins")
          write(lunclu,*)ins,nwinstances
          close(lunclu)

          if (kmagseq.ne.0) then
            call wave_copy_file(trim(filemg),trim(cstage),istat)
          endif

          if (irfilf.ne.0) then
            call wave_copy_file(trim(filef),trim(cstage),istat)
          endif

          if (irbtab.ne.0) then
            call wave_copy_file(trim(filetb),trim(cstage),istat)
          endif

          if (kbpolyh.ne.0) then
            call wave_copy_file("wave_bpolyharm_coef.dat",trim(cstage),istat)
          endif

          if (kbpoly3d.ne.0) then
            call wave_copy_file(trim(file3dfit),trim(cstage),istat)
          endif

          if (kbpoly2dh.ne.0) then
            call wave_copy_file(trim(file2dhfit),trim(cstage),istat)
          endif

          if (kbpharm.ne.0) then
            call wave_copy_file(trim(filephfit),trim(cstage),istat)
          endif

          if (kbpoly3d.ne.0) then
            call wave_copy_file(trim(file3dfit),trim(cstage),istat)
          endif

          if (irfilp.ne.0) then
            call wave_copy_file(trim(filep),trim(cstage),istat)
          endif

          if (kbgenesis.ne.0) then
            call wave_copy_file(trim(filegeni),trim(cstage),istat)
            call wave_copy_file(trim(filegenl),trim(cstage),istat)
          endif

          if (irfilb0.ne.0) then
            call wave_copy_file(trim(fileb0),trim(cstage),istat)
          endif

          if (imagspln.gt.0) then
            call wave_copy_file("magjob.dat",trim(cstage),istat)
          endif

          if (irfill0.ne.0) then
            call wave_copy_file(trim(filel0),trim(cstage),istat)
          endif

          if (ifreq2p.eq.0) then
            call wave_copy_file(trim(filefr),trim(cstage),istat)
          endif

          if (irfilsp0.ne.0) then
            call wave_copy_file(trim(filesp0),trim(cstage),istat)
          endif

          if (irfilsto.ne.0) then
            call wave_copy_file(trim(filesto),trim(cstage),istat)
          endif

          if (iampli.gt.0) then
            call wave_copy_file(trim(fileampli),trim(cstage),istat)
          endif

          if (ifilter.ne.0) then
            call wave_copy_file(trim(fileabs),trim(cstage),istat)
          endif

          if (ifilmul.ne.0) then
            open(newunit=lunfis,file=trim(fileam))
            do while (.true.)
              call util_skip_comment_end(lunfis,ieof)
              if (ieof.ne.0) exit
              read(lunfis,'(a)')cline
              call util_string_trim(cline,n1,n2)
              call wave_copy_file(cline(n1:n2),trim(cstage),istat)
            enddo
            close(lunfis)
          endif

          if (ieffi.ne.0) then
            call wave_copy_file(trim(fileff),trim(cstage),istat)
          endif

          if (iefield.ne.0) then
            call wave_copy_file("efield.dat",trim(cstage),istat)
          endif

          if (iubunch.eq.4) then
            call wave_copy_file("fourier-bunch.dat",trim(cstage),istat)
          endif

          if (nberror.ne.0.and.nberrmod.eq.-1) then
            call wave_copy_file("fibonacci_available_cut.dat",trim(cstage),istat)
            call wave_copy_file("fibonacci_used_cut.dat",trim(cstage),istat)
          endif

          if (ibmask.eq.100.or.jbmask.eq.100) then
            call wave_copy_file("wave.bmask",trim(cstage),istat)
          endif

          open(newunit=lunfis,file="wave_input-files.lis")
          do while (.true.)
            call util_skip_comment_end(lunfis,ieof)
            if (ieof.ne.0) exit
            read(lunfis,'(a)')cline
            call util_string_trim(cline,n1,n2)
            if (cline(n1:n2).eq.'wave.in') cycle
            call wave_copy_file(cline(n1:n2),trim(cstage),istat)
          enddo
          close(lunfis)

        enddo !instances

        !Create instances of WAVE

        call util_string_trim(chwavehome,l1,l2)
        call util_string_trim(chwavedir,m1,m2)

        print*,""
        call zeit(6)

        print*,""
        print*,"     Spawning WAVE instances"
        print*,""

        if (iubunch.eq.3) then
          open(newunit=lunspai,file="wave_phasespace.dat",status='old')
        endif

        do ins=kins,nwinstances

          cstage=trim(chwavedir)//"/.stage."
          call util_string_trim(cstage,m1,m2)

          write(cins,*)ins
          call util_string_trim(cins,n1,n2)
          cstage=cstage(m1:m2)//cins(n1:n2)

          if (iubunch.eq.3) then
            open(newunit=lunspao,file=trim(cstage)//"/wave_phasespace.dat")
            iel1=nbunch*neinbunch/nwinstances*(ins-1)+1
            iel2=nbunch*neinbunch/nwinstances*ins
            if (ins.eq.0) then
              iel1=1
              iel2=1
            else if (ins.eq.1) then
              rewind(lunspai)
            endif
            nread=0
            do i=iel1,iel2
              call util_skip_comment_end(lunspai,ieof)
              read(lunspai,'(a)',iostat=ierr) cline
              if (ierr.ne.0) then
                if (nread.eq.0) then
                  print*,"*** Error in waveinstaces: no electrons from wave_phasespace.dat ***"
                  stop '*** Program WAVE aborted ***'
                else if (neinbunch.eq.1) then
                  print*,"*** Warning in waveinstaces: Could read only",
     &              nread," electrons from wave_phasespace.dat ***"
                  print*,"Setting NBUNCH = ",(nread/nwinstances)*nwinstances
                  kbuncherr=-(nread/nwinstances)*nwinstances
                  close(lunspai)
                  close(lunspao)
                  goto 1
                else if (nbunch.eq.1) then
                  print*,"*** Warning in waveinstaces: Could read only",
     &              nread," electrons from wave_phasespace.dat ***"
                  print*,"Setting NEINBUNCH = ",(nread/nwinstances)*nwinstances
                  close(lunspai)
                  close(lunspao)
                  kbuncherr=(nread/nwinstances)*nwinstances
                  goto 1
                else
                  print*,"*** Error in waveinstaces: Could read only",
     &              nread," electrons from wave_phasespace.dat ***"
                  stop '*** Program WAVE aborted ***'
                endif
              endif
              nread=nread+1
              write(lunspao,'(a)') trim(cline)
            enddo
            flush(lunspao)
            close(lunspao)
          endif !iubunch

          call util_string_trim(chplatform,k1,k2)
          chplatform=chplatform(k1:k2)
          call util_upper_case(chplatform)

          if (chplatform.eq.'LINUX'.or.chplatform.eq.'CYGWIN') then

            if (ins.gt.0.and.iubunch.eq.3) then
              call wave_copy_file(trim(cstage0)//'/wave_source.clu',
     &          trim(cstage)//'/wave_source.clu',istat)
              if (istat.ne.0) then
                print*,"*** Error waveinstances: Can't copy wave_source.clu to "
              endif
            endif

            cline="ln -s "
     &        // chwavehome(l1:l2) // "/bin/wave.exe "
     &        // chwavehome(l1:l2) // "/bin/wave_spawned.exe 2>/dev/null"

            istat=system(trim(cline))

            cline="cd " // trim(cstage) // " && "  // chwavehome(l1:l2)
     &        // "/bin/wave_spawned.exe > " //
     &        trim(cstage) // "/wave.log 2>&1 &"

            print*,trim(cline)
            istat=system(trim(cline))

            ipid=0
            do while(ipid.eq.0)
              inquire(file=trim(cstage)//"/wave.pid",exist=lexist)
              if (lexist.eqv..true.) then
                open(newunit=lunpid,file=trim(cstage)//"/wave.pid",status='old')
                read(lunpid,*)inspid(ins)
                close(lunpid)
                exit
              endif
              call sleep(1)
            enddo

          else if (chplatform.eq.'WINDOWS') then

            if (ins.gt.0.and.ibunch.eq.3) then
              call wave_copy_file(trim(cstage0)//'\wave_source.clu',
     &          trim(cstage)//'/wave_source.clu',istat)
              if (istat.ne.0) then
                print*,"*** Error waveinstances: Can't copy wave_source.clu to "
              endif
            endif

            cline="cd " // trim(cstage) // " && START /b cmd "  // chwavehome(l1:l2)
     &        // "\bin\wave_spawned.exe > " //
     &        trim(cstage) // "/wave.log"

            print*,trim(cline)
            istat=system(trim(cline))

          endif !LINUX

          if (ins.eq.0) then
            cstage0=cstage
            do while (.true.)
              call sleep(1)
              inquire(file=trim(cstage)//"/wave.status",exist=lexist)
              if (lexist.eqv..true.) then
                open(newunit=lun0,file=trim(cstage)//'/wave.status')
                read(lun0,*)istat
                close(lun0)
                if (istat.eq.0) exit
              endif
              print*,"Waiting for job on stage.0"
            enddo
          endif !(ins.gt.0) then

        enddo !instances

        if (iubunch.eq.3) close(lunspai)

        !Check instances

        istat=0
        kstat=0
        ialldone=0
        k10=0

        do while (ialldone.lt.nwinstances)

          call sleep(3)

          do ins=1,nwinstances

            if (iwstat(ins).le.0) then
              cycle
            endif

            call wave_check_pid(inspid(ins),icheckpid)

            if (icheckpid.eq.-1) then
              print*,"*** Warning in waveinstances: Could not check if subprocess is running."
              print*,"*** Check wave.log in subdirectories .stage..., if program hangs"
            endif

            write(cins,*) ins
            call util_string_trim(cins,n1,n2)

            cstage=trim(chwavedir)//"/.stage."
            call util_string_trim(cstage,m1,m2)
            cstage=cstage(m1:m2)//cins(n1:n2)

            inquire(file=trim(cstage)//"/wave.status",exist=lexist)
            if (lexist.eqv..false.) cycle

            open(newunit=lunin,file=trim(cstage)//"/wave.status")
            read(lunin,*)kstat
            iwstat(ins)=kstat
            close(lunin)

            if (iwstat(ins).eq.0) then
              print*,""
              print*,"--- WAVE instance",ins," has finished ---"
              ialldone=ialldone+1
              if (ialldone.eq.nwinstances) exit
            else if (iwstat(ins).ne.1.or.icheckpid.eq.0) then
              print*,""
              print*,"--- WAVE instance",ins," has probably crashed ---"
              print*,"*** Will be ignored, be careful ***"
              print*,""
              iwstat(ins)=-1
              ialldone=ialldone+1
              if (ialldone.eq.nwinstances) exit
            endif

          enddo !nwinstances

          if (ialldone.lt.nwinstances.and.kcount.eq.0) then
            print*,""
            CALL ZEIT(6)
            print*,"     Counting from 1 to 10 to show progress"
            print*,""
            kcount=1
          endif

          cline=trim(cstage)//"/wave.n10"
          inquire(file=trim(cline),exist=lexist)

          if ((lexist.eqv..true.) .and. kcount.gt.0.and.iwstat(ins).ne.-1) then
            open(newunit=lun10,
     &        file=trim(cstage)//"/wave.n10")
            read(lun10,'(a)',end=8)c64
            read(lun10,*,end=8)i10
 8          close(lun10)
            if (i10.gt.k10) then
              print*,i10,"  ",c64
              k10=i10
            endif
          endif

        enddo

        nwgood=0
        if (iwbunch.ne.0) then
          open(newunit=lunbu,file="wave_phasespace_bunch.dat",status='new')
          close(lunbu)
          open(newunit=lunbu,file="wave_phasespace_bunch.dat",access='append')
        endif
        do ins=1,nwinstances
          if (iwstat(ins).eq.0) then
            nwgood=nwgood+1
            if (iwbunch.ne.0) then
              cstage=trim(chwavedir)//"/.stage."
              call util_string_trim(cstage,m1,m2)
              write(cins,*)ins
              call util_string_trim(cins,n1,n2)
              cstage=cstage(m1:m2)//cins(n1:n2)
              cline=trim(cstage)//chpathsep//"wave_phasespace_bunch.dat"
              open(newunit=lunbun,file=trim(cline))
              do while (.true.)
                read(lunbun,'(a)',end=91)cline
                write(lunbu,*)trim(cline)
              enddo
91            close(lunbun)
            endif
          endif
        enddo
        if (iwbunch.ne.0) close(lunbu)

        print*,""

        if (nwgood.eq.0) then
          print*,"*** Error in waveinstances: All instances crashed ***"
          print*,"*** Check log files .stage.../wave.log ***"
          print*,"*** Check if needed files are not listed in wave_input-files.lis ***"
          stop "*** Program WAVE aborted ***"
        endif

      endif !icluster

9999  continue

      return
      end
+DECK,waveenvironment.
*CMZ :  4.00/17 15/11/2022  10.09.59  by  Michael Scheer
*CMZ :  4.00/07 11/05/2020  16.00.17  by  Michael Scheer
*CMZ :  3.07/01 27/03/2019  10.40.38  by  Michael Scheer
*-- Author :    Michael Scheer   27/03/2019
      subroutine waveenvironment

      !use waveenv

      implicit none
+seq,waveenv.

      call get_environment_variable("HOME",chuserhome)
      call get_environment_variable("WAVE",chwavehome)
      call get_environment_variable("PWD",chwavedir)
      call getlog(chuser)

      return
      end
+DECK,run_undumag.
*CMZ :  4.01/02 07/05/2023  12.03.20  by  Michael Scheer
*CMZ :  4.00/17 15/11/2022  10.06.37  by  Michael Scheer
*CMZ :  4.00/16 23/07/2022  09.11.30  by  Michael Scheer
*CMZ :  4.00/15 05/07/2022  13.36.34  by  Michael Scheer
*CMZ :  4.00/14 10/02/2022  22.33.53  by  Michael Scheer
*CMZ :  4.00/11 29/04/2021  19.23.47  by  Michael Scheer
*CMZ :  4.00/10 25/09/2020  11.24.30  by  Michael Scheer
*CMZ :  4.00/07 04/06/2020  21.18.28  by  Michael Scheer
*CMZ :  4.00/04 17/05/2019  14.17.20  by  Michael Scheer
*CMZ :  4.00/03 16/04/2019  09.27.10  by  Michael Scheer
*CMZ :  4.00/01 12/04/2019  13.07.58  by  Michael Scheer
*-- Author :    Michael Scheer   11/04/2019
      subroutine run_undumag(kbundumag,lungfo)

      !use waveenv

      implicit none

+seq,waveenv.
+seq,klotz.
+seq,undumagc.

      double precision xend,x,perlen

      integer kbundumag,luntmp,lunclc,lunmat,istat,lunnam,lund,ki,ke,kio,keo,
     &  kip,kep,kim,kem,indi,inde,nwords,ipos(2,10),
     &  iutil_fexist,lungfo,i,k,k1end,k2end,k1,k2,ixsym,nendpol,nendmag

      character(250) cval,cend
      character(16) c16
      character(32) c32
      character(4) cind,cindo,cpol,cmag
      character(2048) cline,cline1,chnamtmp,chclctmp,chundutmp

      if (FracDivFe_h.eq.0.0d0) FracDivFe_h=1.0d0
      if (fracdivfez_h.eq.0.0d0) fracdivfez_h=1.0d0

      if (kbundumag.gt.2) then
        chundutmp=trim(chwavehome) // chpathsep // "undumag" // chpathsep // trim(chundumag_h)
      else
        chundutmp=trim(chwavehome) // chpathsep // "undumag" // chpathsep // trim(chundumag)
      endif

      if (iutil_fexist(trim(chundutmp)).eq.0) goto 92

      if (kbundumag.eq.1 .or. kbundumag.eq.3 .or. kbundumag.eq.0) then

        return

      else if (kbundumag.eq.2.or.kbundumag.eq.4) then

        if (iutil_fexist(trim(chundutmp)).eq.0) goto 92

        chnamtmp=trim(chwavehome) // chpathsep // "undumag" // chpathsep // trim(chundunam)

        open(newunit=lund,file=trim(chnamtmp),err=90)
        open(newunit=lunnam,file="undumag.nam")

        if (kbundumag.eq.4) then
          nxmapu=nxmapu_h
          xmapminu=xmapminu_h
          xmapmaxu=xmapmaxu_h
          nymapu=nymapu_h
          ymapminu=ymapminu_h
          ymapmaxu=ymapmaxu_h
          nzmapu=nzmapu_h
          zmapminu=zmapminu_h
          zmapmaxu=zmapmaxu_h
        endif

        do while (.true.)

          read(lund,'(a)',end=9)cline
          call util_string_split_sep(cline,10,nwords,ipos,'=',istat)
          if (nwords.gt.0) then
            call util_string_split_pos_1(cline,k,'!',istat)
            c32=adjustl(cline(ipos(1,1):ipos(2,1)))
            call util_lower_case(c32)
          else
            c32=''
          endif

          if (c32.eq.'nuthreads') then

            write(cval,*) muthreads
            call util_string_trim(cval,k1,k2)
            call util_string_split_pos_1(cline,k,'!',istat)
            if (istat.eq.0) then
              write(lunnam,'(a)')" nuthreads=" // cval(k1:k2) // " " // cline(k:len_trim(cline))
            else
              write(lunnam,'(a)')" nuthreads=" // cval(k1:k2)
            endif

          else if (c32.eq.'ebeam') then

            write(cval,*) uebeam
            call util_string_trim(cval,k1,k2)
            call util_string_split_pos_1(cline,k,'!',istat)
            if (istat.eq.0) then
              write(lunnam,'(a)')" ebeam=" // cval(k1:k2) // " " // cline(k:len_trim(cline))
            else
              write(lunnam,'(a)')" ebeam=" // cval(k1:k2)
            endif

          else if (c32.eq.'dxmap') then

            write(cval,*) dxmapu
            call util_string_trim(cval,k1,k2)
            call util_string_split_pos_1(cline,k,'!',istat)
            if (istat.eq.0) then
              write(lunnam,'(a)')" dxmap=" // cval(k1:k2) // " " // cline(k:len_trim(cline))
            else
              write(lunnam,'(a)')" dxmap=" // cval(k1:k2)
            endif

          else if (c32.eq.'kmapmode') then
            write(lunnam,'(a)')" kmapmode=1"

          else if (c32.eq.'kmapnohead') then
            write(lunnam,'(a)')" kmapnohead=1"

          else if (c32.eq.'knointmap') then
            write(lunnam,'(a)')" knointmap=1"

          else if (c32.eq.'nxmap') then

            if (kbundumag.eq.2.and.nxmapu.lt.3) nxmapu=3

            write(cval,*) nxmapu
            call util_string_trim(cval,k1,k2)
            call util_string_split_pos_1(cline,k,'!',istat)
            if (istat.eq.0) then
              write(lunnam,'(a)')" nxmap=" // cval(k1:k2) // " " // cline(k:len_trim(cline))
            else
              write(lunnam,'(a)')" nxmap=" // cval(k1:k2)
            endif

          else if (c32.eq.'xmapmin') then

            write(cval,*) xmapminu
            call util_string_trim(cval,k1,k2)
            call util_string_split_pos_1(cline,k,'!',istat)
            if (istat.eq.0) then
              write(lunnam,'(a)')" xmapmin=" // cval(k1:k2) // " " // cline(k:len_trim(cline))
            else
              write(lunnam,'(a)')" xmapmin=" // cval(k1:k2)
            endif

          else if (c32.eq.'xmapmax') then

            write(cval,*) xmapmaxu
            call util_string_trim(cval,k1,k2)
            call util_string_split_pos_1(cline,k,'!',istat)
            if (istat.eq.0) then
              write(lunnam,'(a)')" xmapmax=" // cval(k1:k2) // " " // cline(k:len_trim(cline))
            else
              write(lunnam,'(a)')" xmapmax=" // cval(k1:k2)
            endif

          else if (c32.eq.'nymap') then

            if (nymapu.lt.3) nymapu=3

            write(cval,*) nymapu
            call util_string_trim(cval,k1,k2)
            call util_string_split_pos_1(cline,k,'!',istat)
            if (istat.eq.0) then
              write(lunnam,'(a)')" nymap=" // cval(k1:k2) // " " // cline(k:len_trim(cline))
            else
              write(lunnam,'(a)')" nymap=" // cval(k1:k2)
            endif

          else if (c32.eq.'ymapmin') then

            write(cval,*) ymapminu
            call util_string_trim(cval,k1,k2)
            call util_string_split_pos_1(cline,k,'!',istat)
            if (istat.eq.0) then
              write(lunnam,'(a)')" ymapmin=" // cval(k1:k2) // " " // cline(k:len_trim(cline))
            else
              write(lunnam,'(a)')" ymapmin=" // cval(k1:k2)
            endif

          else if (c32.eq.'ymapmax') then

            write(cval,*) ymapmaxu
            call util_string_split_pos_1(cline,k,'!',istat)
            call util_string_trim(cval,k1,k2)
            if (istat.eq.0) then
              write(lunnam,'(a)')" ymapmax=" // cval(k1:k2) // " " // cline(k:len_trim(cline))
            else
              write(lunnam,'(a)')" ymapmax=" // cval(k1:k2)
            endif

          else if (c32.eq.'nzmap') then

            if (nzmapu.lt.3) nzmapu=3

            write(cval,*) nzmapu
            call util_string_split_pos_1(cline,k,'!',istat)
            call util_string_trim(cval,k1,k2)
            if (istat.eq.0) then
              write(lunnam,'(a)')" nzmap=" // cval(k1:k2) // " " // cline(k:len_trim(cline))
            else
              write(lunnam,'(a)')" nzmap=" // cval(k1:k2)
            endif

          else if (c32.eq.'zmapmin') then

            write(cval,*) zmapminu
            call util_string_split_pos_1(cline,k,'!',istat)
            call util_string_trim(cval,k1,k2)
            if (istat.eq.0) then
              write(lunnam,'(a)')" zmapmin=" // cval(k1:k2) // " " // cline(k:len_trim(cline))
            else
              write(lunnam,'(a)')" zmapmin=" // cval(k1:k2)
            endif

          else if (c32.eq.'zmapmax') then

            write(cval,*) zmapmaxu
            call util_string_split_pos_1(cline,k,'!',istat)
            call util_string_trim(cval,k1,k2)
            if (istat.eq.0) then
              write(lunnam,'(a)')" zmapmax=" // cval(k1:k2) // " " // cline(k:len_trim(cline))
            else
              write(lunnam,'(a)')" zmapmax=" // cval(k1:k2)
            endif

          else if (c32.eq.'randox') then
            write(cval,*) urandox
            call util_string_split_pos_1(cline,k,'!',istat)
            call util_string_trim(cval,k1,k2)
            if (istat.eq.0) then
              write(lunnam,'(a)')" randox=" // cval(k1:k2) // " " // cline(k:len_trim(cline))
            else
              write(lunnam,'(a)')" randox=" // cval(k1:k2)
            endif

          else if (c32.eq.'randoy') then
            write(cval,*) urandoy
            call util_string_split_pos_1(cline,k,'!',istat)
            call util_string_trim(cval,k1,k2)
            if (istat.eq.0) then
              write(lunnam,'(a)')" randoy=" // cval(k1:k2) // " " // cline(k:len_trim(cline))
            else
              write(lunnam,'(a)')" randoy=" // cval(k1:k2)
            endif

          else if (c32.eq.'randoz') then
            write(cval,*) urandox
            call util_string_split_pos_1(cline,k,'!',istat)
            call util_string_trim(cval,k1,k2)
            if (istat.eq.0) then
              write(lunnam,'(a)')" randoz=" // cval(k1:k2) // " " // cline(k:len_trim(cline))
            else
              write(lunnam,'(a)')" randoz=" // cval(k1:k2)
            endif

          else if (c32.eq.'window') then
            write(cval,*) uwwindow
            call util_string_split_pos_1(cline,k,'!',istat)
            call util_string_trim(cval,k1,k2)
            if (istat.eq.0) then
              write(lunnam,'(a)')" window=" // cval(k1:k2) // " " // cline(k:len_trim(cline))
            else
              write(lunnam,'(a)')" window=" // cval(k1:k2)
            endif
          else if (c32.eq.'corrtiny') then
            if (kbundumag.eq.2) then
              write(cval,*) ucorrtiny
            else if (kbundumag.eq.4) then
              write(cval,*) ucorrtiny_h
            endif
            call util_string_split_pos_1(cline,k,'!',istat)
            call util_string_trim(cval,k1,k2)
            if (istat.eq.0) then
              write(lunnam,'(a)')" corrtiny=" // cval(k1:k2) // " " // cline(k:len_trim(cline))
            else
              write(lunnam,'(a)')" corrtiny=" // cval(k1:k2)
            endif

          else if (c32.eq.'ixsym') then

            call util_string_split_pos_1(cline,k,'!',istat)

            if (kbundumag.eq.4.and.umagspac_h.ne.upolspac_h.and.ixsym.ne.0) then
              print*,''
              print*,"*** Error in run_undumag: In undumag_nam.tmp is ixsym not zero, but"
              print*,"*** UMAGSPAC_H and UPOLSPAC_H are different!"
              print*,''
              stop "*** Program WAVE aborted ***"
            endif

            if (kbundumag.eq.4.and.ixsym_h.eq.1) then
              write(lunnam,'(a)')" ixsym=1 " // cline(k:len_trim(cline))
            else
              write(lunnam,'(a)')" ixsym=0 " // cline(k:len_trim(cline))
            endif

          else if (c32.eq.'iysym') then

            call util_string_split_pos_1(cline,k,'!',istat)

            if (kbundumag.eq.4.and.iysym_h.eq.1) then
              write(lunnam,'(a)')" iysym=1 " // cline(k:len_trim(cline))
            else
              write(lunnam,'(a)')" iysym=0 " // cline(k:len_trim(cline))
            endif

          else if (c32.eq.'izsym') then

            call util_string_split_pos_1(cline,k,'!',istat)

            if (kbundumag.eq.4.and.izsym_h.eq.1) then
              write(lunnam,'(a)')" izsym=1 " // cline(k:len_trim(cline))
            else
              write(lunnam,'(a)')" izsym=0 " // cline(k:len_trim(cline))
            endif

          else
            write(lunnam,'(a)')trim(cline)
          endif
        enddo

9       flush(lunnam)
        close(lunnam)
        close(lund)

        if (kbundumag.eq.2) then

          if (uairgap.lt.0.0d0) then
            print*,"*** Error in run_undumag: Negative airgap (UAIRGAP) in namelist UNDUMAGN ***"
            stop "*** Program WAVE aborted ***"
          endif

          open(newunit=lunmat,file="undumag_mu.dat")
          write(lunmat,*)umupar,uksiper," ! mu_Par and ksi_Per"
          flush(lunmat)
          close(lunmat)

          open(newunit=lunclc,file="undumag.clc")

+self,if=-oldapple.

          write(lunclc,'(a)') "* Written by WAVE"
          write(lunclc,'(a)') "* AppleII"
          write(lunclc,'(a)') " "
          write(lunclc,'(a)') "& User_Comment"
          write(cval,*)kwrun
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') trim(chwcom) // " (Run " // cval(k1:k2) // ")"
          write(lunclc,'(a)') " "
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') '*---------- Variables'
          write(lunclc,'(a)') ' '

          write(c16,'(I16)')nunduper
          write(lunclc,'(a)') "$nPeriods=" // adjustl(c16)
          write(c16,'(g16.6)')umaglx
          write(lunclc,'(a)') "$LxMag=" // adjustl(c16)
          write(c16,'(g16.6)')umagly
          write(lunclc,'(a)') "$LyMag=" // adjustl(c16)
          write(c16,'(g16.6)')umaglz
          write(lunclc,'(a)') "$LzMag=" // adjustl(c16)

          write(c16,'(g16.6)') uairgap
          write(lunclc,'(a)') '$AirGap=' // adjustl(c16)
          write(lunclc,'(a)') '$PerLen=4.*($LxMag+$AirGap)'

          write(c16,'(g16.6)')ucoating
          write(lunclc,'(a)') '$Mcoating=' // adjustl(c16)
          write(c16,'(g16.6)')undugap
          write(lunclc,'(a)') '$FullGap=' // adjustl(c16)
          write(lunclc,'(a)') '$matrec=1'
          write(c16,'(g16.7)')umagbc
          write(lunclc,'(a)') '$Br='  // adjustl(c16)
          write(c16,'(g16.7)')umupar
          write(lunclc,'(a)') '$Mu='  // adjustl(c16)
          write(c16,'(g16.7)')uksiper
          write(lunclc,'(a)') '$KsiPerp=' // adjustl(c16)
          write(c16,'(g16.7)')US2SHIFT
          write(lunclc,'(a)') '$S2Shift=' // adjustl(c16)
          write(c16,'(g16.7)')US3SHIFT
          write(lunclc,'(a)') '$S3Shift=' // adjustl(c16)
          write(c16,'(g16.7)')undusplit
          write(lunclc,'(a)') '$zSlit=' // adjustl(c16)
          write(lunclc,'(a)') '$xMagCen=0.0'
          write(c16,'(I16)') nudivx
          write(lunclc,'(a)') '$nMagDivX=' // adjustl(c16)
          write(c16,'(I16)') nuhdivx
          write(lunclc,'(a)') '$nHalfMagDivX=' // adjustl(c16)
          write(c16,'(I16)') nudivy
          write(lunclc,'(a)') '$nMagDivY=' // adjustl(c16)
          write(c16,'(I16)') nudivz
          write(lunclc,'(a)') '$nMagDivZ=' // adjustl(c16)

          write(lunclc,'(a)') '$E1Br = $Br / 4.'
          write(lunclc,'(a)') '$E2Br = - $Br * 3. / 4.'
          write(lunclc,'(a)') '$PerLen = 4. * ( $LxMag + $AirGap )'
          write(lunclc,'(a)') '$HalfGap = $FullGap / 2.'
          write(lunclc,'(a)') '$HalfPerLen = $PerLen / 2.'
          write(lunclc,'(a)') '$LxHalfMag = $LxMag / 2.'
          write(lunclc,'(a)') '$yMagCen = - $HalfGap - $LyMag / 2.'
          write(lunclc,'(a)') '$zMagCen = - $LzMag / 2. - $zSlit / 2.'
          write(lunclc,'(a)') '$hS3Shift = $S3Shift / 2.'
          write(lunclc,'(a)') '$hS2Shift = $S2Shift / 2.'

          write(lunclc,'(a)') '$x1LRMagCen = $xMagCen + $LxHalfMag / 2. - $hS3Shift - $hS2Shift'
          write(lunclc,'(a)') '$x2LRMagCen = $x1LRMagCen + $LxHalfMag / 2. + $AirGap + $LxMag / 2.'
          write(lunclc,'(a)') '$x3LRMagCen = $x2LRMagCen + $LxHalfMag + $AirGap + $LxHalfMag / 2.'
          write(lunclc,'(a)') '$x4LRMagCen = $x3LRMagCen + $LxHalfMag'
          write(lunclc,'(a)') '$x5LRMagCen = $x4LRMagCen + $LxHalfMag / 2. + $AirGap + $LxMag / 2.'
          write(lunclc,'(a)') '$x6LRMagCen = $x5LRMagCen + $LxMag / 2. + $AirGap + $LxHalfMag / 2.'
          write(lunclc,'(a)') '$x1LLMagCen = $x1LRMagCen + $S3Shift + $S2Shift'
          write(lunclc,'(a)') '$x2LLMagCen = $x2LRMagCen + $S3Shift + $S2Shift'
          write(lunclc,'(a)') '$x3LLMagCen = $x3LRMagCen + $S3Shift + $S2Shift'
          write(lunclc,'(a)') '$x4LLMagCen = $x4LRMagCen + $S3Shift + $S2Shift'
          write(lunclc,'(a)') '$x5LLMagCen = $x5LRMagCen + $S3Shift + $S2Shift'
          write(lunclc,'(a)') '$x6LLMagCen = $x6LRMagCen + $S3Shift + $S2Shift'
          write(lunclc,'(a)') '$x1ULMagCen = $x1LRMagCen'
          write(lunclc,'(a)') '$x2ULMagCen = $x2LRMagCen'
          write(lunclc,'(a)') '$x3ULMagCen = $x3LRMagCen'
          write(lunclc,'(a)') '$x4ULMagCen = $x4LRMagCen'
          write(lunclc,'(a)') '$x5ULMagCen = $x5LRMagCen'
          write(lunclc,'(a)') '$x6ULMagCen = $x6LRMagCen'
          write(lunclc,'(a)') '$x1URMagCen = $x1LLMagCen - $S2Shift * 2.'
          write(lunclc,'(a)') '$x2URMagCen = $x2LLMagCen - $S2Shift * 2.'
          write(lunclc,'(a)') '$x3URMagCen = $x3LLMagCen - $S2Shift * 2.'
          write(lunclc,'(a)') '$x4URMagCen = $x4LLMagCen - $S2Shift * 2.'
          write(lunclc,'(a)') '$x5URMagCen = $x5LLMagCen - $S2Shift * 2.'
          write(lunclc,'(a)') '$x6URMagCen = $x6LLMagCen - $S2Shift * 2.'
          write(lunclc,'(a)') '$yUMagCen = - $yMagCen'
          write(lunclc,'(a)') '$zLLMagCen = - $zMagCen'
          write(lunclc,'(a)') '$zULMagCen = - $zMagCen'
          write(lunclc,'(a)') '$yModCen = - 2. * $yMagCen'
          write(lunclc,'(a)') '$zModCen = - 2. * $zMagCen'

          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '$white=0'
          write(lunclc,'(a)') '$black=1'
          write(lunclc,'(a)') '$red=2'
          write(lunclc,'(a)') '$green=3'
          write(lunclc,'(a)') '$blue=4'
          write(lunclc,'(a)') '$yellow=5'
          write(lunclc,'(a)') '$magenta=6'
          write(lunclc,'(a)') '$cyan=7'
          write(lunclc,'(a)') ' '

           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '* Upstream endpoles'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '$x1E1LLMagCen = $x1LLMagCen - $PerLen'
           write(lunclc,'(a)') '$x2E1LLMagCen = $x2LLMagCen - $PerLen'
           write(lunclc,'(a)') '$x3E1LLMagCen = $x3LLMagCen - $PerLen'
           write(lunclc,'(a)') '$x1E1ULMagCen = $x1ULMagCen - $PerLen'
           write(lunclc,'(a)') '$x2E1ULMagCen = $x2ULMagCen - $PerLen'
           write(lunclc,'(a)') '$x3E1ULMagCen = $x3ULMagCen - $PerLen'
           write(lunclc,'(a)') '$x1E1LRMagCen = $x1LRMagCen - $PerLen'
           write(lunclc,'(a)') '$x2E1LRMagCen = $x2LRMagCen - $PerLen'
           write(lunclc,'(a)') '$x3E1LRMagCen = $x3LRMagCen - $PerLen'
           write(lunclc,'(a)') '$x1E1URMagCen = $x1URMagCen - $PerLen'
           write(lunclc,'(a)') '$x2E1URMagCen = $x2URMagCen - $PerLen'
           write(lunclc,'(a)') '$x3E1URMagCen = $x3URMagCen - $PerLen'
           write(lunclc,'(a)') '$x1E2LLMagCen = $x1LLMagCen - $HalfPerLen'
           write(lunclc,'(a)') '$x2E2LLMagCen = $x2LLMagCen - $HalfPerLen'
           write(lunclc,'(a)') '$x3E2LLMagCen = $x3LLMagCen - $HalfPerLen'
           write(lunclc,'(a)') '$x1E2ULMagCen = $x1ULMagCen - $HalfPerLen'
           write(lunclc,'(a)') '$x2E2ULMagCen = $x2ULMagCen - $HalfPerLen'
           write(lunclc,'(a)') '$x3E2ULMagCen = $x3ULMagCen - $HalfPerLen'
           write(lunclc,'(a)') '$x1E2LRMagCen = $x1LRMagCen - $HalfPerLen'
           write(lunclc,'(a)') '$x2E2LRMagCen = $x2LRMagCen - $HalfPerLen'
           write(lunclc,'(a)') '$x3E2LRMagCen = $x3LRMagCen - $HalfPerLen'
           write(lunclc,'(a)') '$x1E2URMagCen = $x1URMagCen - $HalfPerLen'
           write(lunclc,'(a)') '$x2E2URMagCen = $x2URMagCen - $HalfPerLen'
           write(lunclc,'(a)') '$x3E2URMagCen = $x3URMagCen - $HalfPerLen'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '* Downstream endpoles'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '$dxED0 = ( $nPeriods + 1.0 ) * $PerLen'
           write(lunclc,'(a)') '$dxED1 = ( $nPeriods + 2.0 ) * $PerLen'
           write(lunclc,'(a)') '$dxED2 = ( $nPeriods + 1.5 ) * $PerLen'
           write(lunclc,'(a)') '$x1D0LLMagCen = $x1E1LLMagCen + $dxED0'
           write(lunclc,'(a)') '$x2D0LLMagCen = $x2E1LLMagCen + $dxED0'
           write(lunclc,'(a)') '$x3D0LLMagCen = $x3E1LLMagCen + $dxED0'
           write(lunclc,'(a)') '$x1D0LRMagCen = $x1E1LRMagCen + $dxED0'
           write(lunclc,'(a)') '$x2D0LRMagCen = $x2E1LRMagCen + $dxED0'
           write(lunclc,'(a)') '$x3D0LRMagCen = $x3E1LRMagCen + $dxED0'
           write(lunclc,'(a)') '$x1D0ULMagCen = $x1E1ULMagCen + $dxED0'
           write(lunclc,'(a)') '$x2D0ULMagCen = $x2E1ULMagCen + $dxED0'
           write(lunclc,'(a)') '$x3D0ULMagCen = $x3E1ULMagCen + $dxED0'
           write(lunclc,'(a)') '$x1D0URMagCen = $x1E1URMagCen + $dxED0'
           write(lunclc,'(a)') '$x2D0URMagCen = $x2E1URMagCen + $dxED0'
           write(lunclc,'(a)') '$x3D0URMagCen = $x3E1URMagCen + $dxED0'
           write(lunclc,'(a)') '$x1D1LLMagCen = $x1E1LLMagCen + $dxED1'
           write(lunclc,'(a)') '$x2D1LLMagCen = $x2E1LLMagCen + $dxED1'
           write(lunclc,'(a)') '$x3D1LLMagCen = $x3E1LLMagCen + $dxED1'
           write(lunclc,'(a)') '$x1D1LRMagCen = $x1E1LRMagCen + $dxED1'
           write(lunclc,'(a)') '$x2D1LRMagCen = $x2E1LRMagCen + $dxED1'
           write(lunclc,'(a)') '$x3D1LRMagCen = $x3E1LRMagCen + $dxED1'
           write(lunclc,'(a)') '$x1D1ULMagCen = $x1E1ULMagCen + $dxED1'
           write(lunclc,'(a)') '$x2D1ULMagCen = $x2E1ULMagCen + $dxED1'
           write(lunclc,'(a)') '$x3D1ULMagCen = $x3E1ULMagCen + $dxED1'
           write(lunclc,'(a)') '$x1D1URMagCen = $x1E1URMagCen + $dxED1'
           write(lunclc,'(a)') '$x2D1URMagCen = $x2E1URMagCen + $dxED1'
           write(lunclc,'(a)') '$x3D1URMagCen = $x3E1URMagCen + $dxED1'
           write(lunclc,'(a)') '$x1D2LLMagCen = $x1E1LLMagCen + $dxED2'
           write(lunclc,'(a)') '$x2D2LLMagCen = $x2E1LLMagCen + $dxED2'
           write(lunclc,'(a)') '$x3D2LLMagCen = $x3E1LLMagCen + $dxED2'
           write(lunclc,'(a)') '$x1D2LRMagCen = $x1E1LRMagCen + $dxED2'
           write(lunclc,'(a)') '$x2D2LRMagCen = $x2E1LRMagCen + $dxED2'
           write(lunclc,'(a)') '$x3D2LRMagCen = $x3E1LRMagCen + $dxED2'
           write(lunclc,'(a)') '$x1D2ULMagCen = $x1E1ULMagCen + $dxED2'
           write(lunclc,'(a)') '$x2D2ULMagCen = $x2E1ULMagCen + $dxED2'
           write(lunclc,'(a)') '$x3D2ULMagCen = $x3E1ULMagCen + $dxED2'
           write(lunclc,'(a)') '$x1D2URMagCen = $x1E1URMagCen + $dxED2'
           write(lunclc,'(a)') '$x2D2URMagCen = $x2E1URMagCen + $dxED2'
           write(lunclc,'(a)') '$x3D2URMagCen = $x3E1URMagCen + $dxED2'
           write(lunclc,'(a)') '$colormag = $red'
           write(lunclc,'(a)') '$e1colormag = $magenta'
           write(lunclc,'(a)') '$e2colormag = $green'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '*---------- Magnets'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '* Lower right girder'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Magnet'
           write(lunclc,'(a)') 'Block mag1 HMag1 $colormag                 !key, name, mother, color'
           write(lunclc,'(a)') '$x1LRMagCen $yMagCen $zMagCen              !position'
           write(lunclc,'(a)') '$Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Magnet'
           write(lunclc,'(a)') 'Block mag2 Mag2 $colormag                  !key, name, mother, color'
           write(lunclc,'(a)') '$x2LRMagCen $yMagCen $zMagCen              !position'
           write(lunclc,'(a)') '$Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                       !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Magnet'
           write(lunclc,'(a)') 'Block mag3 HMag3 $colormag                 !key, name, mother, color'
           write(lunclc,'(a)') '$x3LRMagCen $yMagCen $zMagCen              !position'
           write(lunclc,'(a)') '$Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Magnet'
           write(lunclc,'(a)') 'Block mag4 HMag4 $colormag                 !key, name, mother, color'
           write(lunclc,'(a)') '$x4LRMagCen $yMagCen $zMagCen              !position'
           write(lunclc,'(a)') '$Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Magnet'
           write(lunclc,'(a)') 'Block mag5 Mag5 $colormag                  !key, name, mother, color'
           write(lunclc,'(a)') '$x5LRMagCen $yMagCen $zMagCen              !position'
           write(lunclc,'(a)') '$Br 0.0 -1.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                       !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Magnet'
           write(lunclc,'(a)') 'Block mag6 HMag6 $colormag                 !key, name, mother, color'
           write(lunclc,'(a)') '$x6LRMagCen $yMagCen $zMagCen              !position'
           write(lunclc,'(a)') '$Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '* Upper right girder'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Magnet'
           write(lunclc,'(a)') 'Block mag7 HMag7 $colormag                 !key, name, mother, color'
           write(lunclc,'(a)') '$x1URMagCen $yUMagCen $zMagCen             !position'
           write(lunclc,'(a)') '$Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Magnet'
           write(lunclc,'(a)') 'Block mag8 Mag8 $colormag                  !key, name, mother, color'
           write(lunclc,'(a)') '$x2URMagCen $yUMagCen $zMagCen             !position'
           write(lunclc,'(a)') '$Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                       !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Magnet'
           write(lunclc,'(a)') 'Block mag9 HMag9 $colormag                 !key, name, mother, color'
           write(lunclc,'(a)') '$x3URMagCen $yUMagCen $zMagCen             !position'
           write(lunclc,'(a)') '$Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Magnet'
           write(lunclc,'(a)') 'Block mag10 HMag10 $colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x4URMagCen $yUMagCen $zMagCen             !position'
           write(lunclc,'(a)') '$Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Magnet'
           write(lunclc,'(a)') 'Block mag11 Mag11 $colormag                !key, name, mother, color'
           write(lunclc,'(a)') '$x5URMagCen $yUMagCen $zMagCen             !position'
           write(lunclc,'(a)') '$Br 0.0 -1.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                       !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Magnet'
           write(lunclc,'(a)') 'Block mag12 HMag12 $colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x6URMagCen $yUMagCen $zMagCen             !position'
           write(lunclc,'(a)') '$Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '* Lower left girder'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Magnet'
           write(lunclc,'(a)') 'Block mag13 HMag13 $colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x1LLMagCen $yMagCen $zLLMagCen            !position'
           write(lunclc,'(a)') '$Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Magnet'
           write(lunclc,'(a)') 'Block mag14 Mag14 $colormag                !key, name, mother, color'
           write(lunclc,'(a)') '$x2LLMagCen $yMagCen $zLLMagCen            !position'
           write(lunclc,'(a)') '$Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                       !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Magnet'
           write(lunclc,'(a)') 'Block mag15 HMag15 $colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x3LLMagCen $yMagCen $zLLMagCen            !position'
           write(lunclc,'(a)') '$Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Magnet'
           write(lunclc,'(a)') 'Block mag16 HMag16 $colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x4LLMagCen $yMagCen $zLLMagCen            !position'
           write(lunclc,'(a)') '$Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
           write(lunclc,'(a)') '& Magnet'
           write(lunclc,'(a)') 'Block mag17 Mag17 $colormag                !key, name, mother, color'
           write(lunclc,'(a)') '$x5LLMagCen $yMagCen $zLLMagCen            !position'
           write(lunclc,'(a)') '$Br 0.0 -1.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                       !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention'
           write(lunclc,'(a)') '& Magnet'
           write(lunclc,'(a)') 'Block mag18 HMag18 $colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x6LLMagCen $yMagCen $zLLMagCen            !position'
           write(lunclc,'(a)') '$Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '* Upper right girder'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Magnet'
           write(lunclc,'(a)') 'Block mag19 HMag19 $colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x1LRMagCen $yUMagCen $zULMagCen           !position'
           write(lunclc,'(a)') '$Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Magnet'
           write(lunclc,'(a)') 'Block mag20 Mag20 $colormag                !key, name, mother, color'
           write(lunclc,'(a)') '$x2LRMagCen $yUMagCen $zULMagCen           !position'
           write(lunclc,'(a)') '$Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                       !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Magnet'
           write(lunclc,'(a)') 'Block mag21 HMag21 $colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x3LRMagCen $yUMagCen $zULMagCen           !position'
           write(lunclc,'(a)') '$Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Magnet'
           write(lunclc,'(a)') 'Block mag22 HMag22 $colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x4LRMagCen $yUMagCen $zULMagCen           !position'
           write(lunclc,'(a)') '$Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Magnet'
           write(lunclc,'(a)') 'Block mag23 Mag23 $colormag                !key, name, mother, color'
           write(lunclc,'(a)') '$x5LRMagCen $yUMagCen $zULMagCen           !position'
           write(lunclc,'(a)') '$Br 0.0 -1.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                       !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Magnet'
           write(lunclc,'(a)') 'Block mag24 HMag24 $colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x6LRMagCen $yUMagCen $zULMagCen           !position'
           write(lunclc,'(a)') '$Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '* Lower right girder'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag25 Mag25 $e1colormag              !key, name, mother, color'
           write(lunclc,'(a)') '$x1E1LRMagCen $yMagCen $zMagCen            !position'
           write(lunclc,'(a)') '$E1Br 1.0 0.0 0.0 $matrec                  !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag26 Mag26 $e1colormag              !key, name, mother, color'
           write(lunclc,'(a)') '$x2E1LRMagCen $yMagCen $zMagCen            !position'
           write(lunclc,'(a)') '$E1Br 0.0 1.0 0.0 $matrec                  !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                       !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag27 HMag27 $e1colormag             !key, name, mother, color'
           write(lunclc,'(a)') '$x3E1LRMagCen $yMagCen $zMagCen            !position'
           write(lunclc,'(a)') '$E1Br -1.0 0.0 0.0 $matrec                 !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '* Upper right girder'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag28 HMag28 $e1colormag             !key, name, mother, color'
           write(lunclc,'(a)') '$x1E1URMagCen $yUMagCen $zMagCen           !position'
           write(lunclc,'(a)') '$E1Br -1.0 0.0 0.0 $matrec                 !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag29 Mag29 $e1colormag              !key, name, mother, color'
           write(lunclc,'(a)') '$x2E1URMagCen $yUMagCen $zMagCen           !position'
           write(lunclc,'(a)') '$E1Br 0.0 1.0 0.0 $matrec                  !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                       !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag30 HMag30 $e1colormag             !key, name, mother, color'
           write(lunclc,'(a)') '$x3E1URMagCen $yUMagCen $zMagCen           !position'
           write(lunclc,'(a)') '$E1Br 1.0 0.0 0.0 $matrec                  !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '* Lower left girder'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag31 HMag31 $e1colormag              !key, name, mother, color'
           write(lunclc,'(a)') '$x1E1LLMagCen $yMagCen $zLLMagCen           !position'
           write(lunclc,'(a)') '$E1Br 1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                    !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag32 Mag32 $e1colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x2E1LLMagCen $yMagCen $zLLMagCen           !position'
           write(lunclc,'(a)') '$E1Br 0.0 1.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                        !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.         !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag33 HMag33 $e1colormag              !key, name, mother, color'
           write(lunclc,'(a)') '$x3E1LLMagCen $yMagCen $zLLMagCen           !position'
           write(lunclc,'(a)') '$E1Br -1.0 0.0 0.0 $matrec                  !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                    !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '* Lower right girder'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag34 HMag34 $e1colormag              !key, name, mother, color'
           write(lunclc,'(a)') '$x1E1LRMagCen $yUMagCen $zULMagCen          !position'
           write(lunclc,'(a)') '$E1Br -1.0 0.0 0.0 $matrec                  !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                    !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag35 Mag35 $e1colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x2E1LRMagCen $yUMagCen $zULMagCen          !position'
           write(lunclc,'(a)') '$E1Br 0.0 1.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                        !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.         !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag36 HMag36 $e1colormag              !key, name, mother, color'
           write(lunclc,'(a)') '$x3E1LRMagCen $yUMagCen $zULMagCen          !position'
           write(lunclc,'(a)') '$E1Br 1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                    !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag37 HMag37 $e2colormag              !key, name, mother, color'
           write(lunclc,'(a)') '$x1E2LRMagCen $yMagCen $zMagCen             !position'
           write(lunclc,'(a)') '$E2Br 1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                    !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag38 Mag38 $e2colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x2E2LRMagCen $yMagCen $zMagCen             !position'
           write(lunclc,'(a)') '$E2Br 0.0 1.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                        !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.         !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag39 HMag39 $e2colormag              !key, name, mother, color'
           write(lunclc,'(a)') '$x3E2LRMagCen $yMagCen $zMagCen             !position'
           write(lunclc,'(a)') '$E2Br -1.0 0.0 0.0 $matrec                  !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                    !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '* Upper right girder'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag40 HMag40 $e2colormag              !key, name, mother, color'
           write(lunclc,'(a)') '$x1E2URMagCen $yUMagCen $zMagCen            !position'
           write(lunclc,'(a)') '$E2Br -1.0 0.0 0.0 $matrec                  !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                    !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag41 Mag41 $e2colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x2E2URMagCen $yUMagCen $zMagCen            !position'
           write(lunclc,'(a)') '$E2Br 0.0 1.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                        !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.         !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag42 HMag42 $e2colormag              !key, name, mother, color'
           write(lunclc,'(a)') '$x3E2URMagCen $yUMagCen $zMagCen            !position'
           write(lunclc,'(a)') '$E2Br 1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                    !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '* Lower left girder'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag43 HMag43 $e2colormag              !key, name, mother, color'
           write(lunclc,'(a)') '$x1E2LLMagCen $yMagCen $zLLMagCen           !position'
           write(lunclc,'(a)') '$E2Br 1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                    !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag44 Mag44 $e2colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x2E2LLMagCen $yMagCen $zLLMagCen           !position'
           write(lunclc,'(a)') '$E2Br 0.0 1.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                        !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.         !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag45 HMag45 $e2colormag              !key, name, mother, color'
           write(lunclc,'(a)') '$x3E2LLMagCen $yMagCen $zLLMagCen           !position'
           write(lunclc,'(a)') '$E2Br -1.0 0.0 0.0 $matrec                  !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                    !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '* Lower right girder'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag46 HMag46 $e2colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x1E2LRMagCen $yUMagCen $zULMagCen           !position'
           write(lunclc,'(a)') '$E2Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag47 Mag47 $e2colormag                !key, name, mother, color'
           write(lunclc,'(a)') '$x2E2LRMagCen $yUMagCen $zULMagCen           !position'
           write(lunclc,'(a)') '$E2Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                         !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag48 HMag48 $e2colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x3E2LRMagCen $yUMagCen $zULMagCen           !position'
           write(lunclc,'(a)') '$E2Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag49 HMag49 $e2colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x1D0LRMagCen $yMagCen $zMagCen              !position'
           write(lunclc,'(a)') '$Br 1.0 0.0 0.0 $matrec                      !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag50 Mag50 $e2colormag                !key, name, mother, color'
           write(lunclc,'(a)') '$x2D0LRMagCen $yMagCen $zMagCen              !position'
           write(lunclc,'(a)') '$Br 0.0 1.0 0.0 $matrec                      !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                         !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag51 HMag51 $e2colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x3D0LRMagCen $yMagCen $zMagCen              !position'
           write(lunclc,'(a)') '$Br -1.0 0.0 0.0 $matrec                     !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag52 HMag52 $e1colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x1D1LRMagCen $yMagCen $zMagCen              !position'
           write(lunclc,'(a)') '$E1Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag53 Mag53 $e1colormag                !key, name, mother, color'
           write(lunclc,'(a)') '$x2D1LRMagCen $yMagCen $zMagCen              !position'
           write(lunclc,'(a)') '$E1Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                         !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag54 HMag54 $e1colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x3D1LRMagCen $yMagCen $zMagCen              !position'
           write(lunclc,'(a)') '$E1Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '* Upper right girder'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag55 HMag55 $e2colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x1D0URMagCen $yUMagCen $zMagCen             !position'
           write(lunclc,'(a)') '$Br -1.0 0.0 0.0 $matrec                     !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag56 Mag56 $e2colormag                !key, name, mother, color'
           write(lunclc,'(a)') '$x2D0URMagCen $yUMagCen $zMagCen             !position'
           write(lunclc,'(a)') '$Br 0.0 1.0 0.0 $matrec                      !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                         !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag57 HMag57 $e2colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x3D0URMagCen $yUMagCen $zMagCen             !position'
           write(lunclc,'(a)') '$Br 1.0 0.0 0.0 $matrec                      !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag58 HMag58 $e1colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x1D1URMagCen $yUMagCen $zMagCen             !position'
           write(lunclc,'(a)') '$E1Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag59 Mag59 $e1colormag                !key, name, mother, color'
           write(lunclc,'(a)') '$x2D1URMagCen $yUMagCen $zMagCen             !position'
           write(lunclc,'(a)') '$E1Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                         !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag60 HMag60 $e1colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x3D1URMagCen $yUMagCen $zMagCen             !position'
           write(lunclc,'(a)') '$E1Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '* Lower left girder'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag61 HMag61 $e2colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x1D0LLMagCen $yMagCen $zLLMagCen            !position'
           write(lunclc,'(a)') '$Br 1.0 0.0 0.0 $matrec                      !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag62 Mag62 $e2colormag                !key, name, mother, color'
           write(lunclc,'(a)') '$x2D0LLMagCen $yMagCen $zLLMagCen            !position'
           write(lunclc,'(a)') '$Br 0.0 1.0 0.0 $matrec                      !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                         !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag63 HMag63 $e2colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x3D0LLMagCen $yMagCen $zLLMagCen            !position'
           write(lunclc,'(a)') '$Br -1.0 0.0 0.0 $matrec                     !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag64 HMag64 $e1colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x1D1LLMagCen $yMagCen $zLLMagCen            !position'
           write(lunclc,'(a)') '$E1Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag65 Mag65 $e1colormag                !key, name, mother, color'
           write(lunclc,'(a)') '$x2D1LLMagCen $yMagCen $zLLMagCen            !position'
           write(lunclc,'(a)') '$E1Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                         !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag66 HMag66 $e1colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x3D1LLMagCen $yMagCen $zLLMagCen            !position'
           write(lunclc,'(a)') '$E1Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '* Upper left girder'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag67 HMag67 $e2colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x1D0ULMagCen $yUMagCen $zULMagCen           !position'
           write(lunclc,'(a)') '$Br -1.0 0.0 0.0 $matrec                     !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag68 Mag68 $e2colormag                !key, name, mother, color'
           write(lunclc,'(a)') '$x2D0ULMagCen $yUMagCen $zULMagCen           !position'
           write(lunclc,'(a)') '$Br 0.0 1.0 0.0 $matrec                      !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                         !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag69 HMag69 $e2colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x3D0ULMagCen $yUMagCen $zULMagCen           !position'
           write(lunclc,'(a)') '$Br 1.0 0.0 0.0 $matrec                      !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '* Lower right girder'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag70 HMag70 $e1colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x1D1LRMagCen $yUMagCen $zULMagCen           !position'
           write(lunclc,'(a)') '$E1Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag71 Mag71 $e1colormag                !key, name, mother, color'
           write(lunclc,'(a)') '$x2D1LRMagCen $yUMagCen $zULMagCen           !position'
           write(lunclc,'(a)') '$E1Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                         !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag72 HMag72 $e1colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x3D1LRMagCen $yUMagCen $zULMagCen           !position'
           write(lunclc,'(a)') '$E1Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag73 HMag73 $e2colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x1D2LRMagCen $yMagCen $zMagCen              !position'
           write(lunclc,'(a)') '$E2Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag74 Mag74 $e2colormag                !key, name, mother, color'
           write(lunclc,'(a)') '$x2D2LRMagCen $yMagCen $zMagCen              !position'
           write(lunclc,'(a)') '$E2Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                         !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag75 HMag75 $e2colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x3D2LRMagCen $yMagCen $zMagCen              !position'
           write(lunclc,'(a)') '$E2Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '* Upper right girder'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag76 HMag76 $e2colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x1D2URMagCen $yUMagCen $zMagCen             !position'
           write(lunclc,'(a)') '$E2Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag77 Mag77 $e2colormag                !key, name, mother, color'
           write(lunclc,'(a)') '$x2D2URMagCen $yUMagCen $zMagCen             !position'
           write(lunclc,'(a)') '$E2Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                         !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag78 HMag78 $e2colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x3D2URMagCen $yUMagCen $zMagCen             !position'
           write(lunclc,'(a)') '$E2Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '* Lower left girder'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag79 HMag79 $e2colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x1D2LLMagCen $yMagCen $zLLMagCen            !position'
           write(lunclc,'(a)') '$E2Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag80 Mag80 $e2colormag                !key, name, mother, color'
           write(lunclc,'(a)') '$x2D2LLMagCen $yMagCen $zLLMagCen            !position'
           write(lunclc,'(a)') '$E2Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                         !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag81 HMag81 $e2colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x3D2LLMagCen $yMagCen $zLLMagCen            !position'
           write(lunclc,'(a)') '$E2Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '* Lower right girder'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag82 HMag82 $e2colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x1D2LRMagCen $yUMagCen $zULMagCen           !position'
           write(lunclc,'(a)') '$E2Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag83 Mag83 $e2colormag                !key, name, mother, color'
           write(lunclc,'(a)') '$x2D2LRMagCen $yUMagCen $zULMagCen           !position'
           write(lunclc,'(a)') '$E2Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxMag $LyMag $LzMag                         !dimension'
           write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Special_Magnet'
           write(lunclc,'(a)') 'Block mag84 HMag84 $e2colormag               !key, name, mother, color'
           write(lunclc,'(a)') '$x3D2LRMagCen $yUMagCen $zULMagCen           !position'
           write(lunclc,'(a)') '$E2Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index' //
     &      ''
           write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
           write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Module'
           write(lunclc,'(a)') '0. 0. 0. 1 1        !offset of module, number and number of associated module'
           write(lunclc,'(a)') '$nPeriods           !number of arrays within module'
           write(lunclc,'(a)') '$PerLen 1. 0. 0. 0. !spacing and direction of arrangement, rotation angle'
           write(lunclc,'(a)') '1. 1. 1.            !scaling and symmetry of magnetization vector'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') '& Materials'
           write(lunclc,'(a)') '1                       ! number of material files'
           write(lunclc,'(a)') '1 1 1 undumag_mu.dat    ! number, type, mode, and filename'
           write(lunclc,'(a)') ''
           write(lunclc,'(a)') ''

+self,if=oldapple.

          write(lunclc,'(a)') "* Written by WAVE"
          write(lunclc,'(a)') "* AppleII"
          write(lunclc,'(a)') " "
          write(lunclc,'(a)') "& User_Comment"
          write(cval,*)kwrun
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') trim(chwcom) // " (Run " // cval(k1:k2) // ")"
          write(lunclc,'(a)') " "
          write(lunclc,'(a)') ' '


          write(lunclc,'(a)') '*---------- Variables'
          write(lunclc,'(a)') ' '

          write(c16,'(I16)')nunduper
          write(lunclc,'(a)') "$nPeriods=" // adjustl(c16)
          write(c16,'(g16.6)')umaglx
          write(lunclc,'(a)') "$LxMag=" // adjustl(c16)
          write(c16,'(g16.6)')umagly
          write(lunclc,'(a)') "$LyMag=" // adjustl(c16)
          write(c16,'(g16.6)')umaglz
          write(lunclc,'(a)') "$LzMag=" // adjustl(c16)

          write(c16,'(g16.6)') uairgap
          write(lunclc,'(a)') '$AirGap=' // adjustl(c16)
          write(lunclc,'(a)') '$PerLen=4.*($LxMag+$AirGap)'

          write(c16,'(g16.6)')ucoating
          write(lunclc,'(a)') '$Mcoating=' // adjustl(c16)
          write(c16,'(g16.6)')undugap
          write(lunclc,'(a)') '$FullGap=' // adjustl(c16)
          write(lunclc,'(a)') '$matrec=1'
          write(c16,'(g16.7)')umagbc
          write(lunclc,'(a)') '$Br='  // adjustl(c16)
          write(c16,'(g16.7)')umupar
          write(lunclc,'(a)') '$Mu='  // adjustl(c16)
          write(c16,'(g16.7)')uksiper
          write(lunclc,'(a)') '$KsiPerp=' // adjustl(c16)
          write(c16,'(g16.7)')US2SHIFT
          write(lunclc,'(a)') '$S2Shift=' // adjustl(c16)
          write(c16,'(g16.7)')US3SHIFT
          write(lunclc,'(a)') '$S3Shift=' // adjustl(c16)
          write(c16,'(g16.7)')undusplit
          write(lunclc,'(a)') '$zSlit=' // adjustl(c16)
          write(lunclc,'(a)') '$xMagCen=0.0'
          write(c16,'(I16)') nudivx
          write(lunclc,'(a)') '$nMagDivX=' // adjustl(c16)
          write(c16,'(I16)') nuhdivx
          write(lunclc,'(a)') '$nHalfMagDivX=' // adjustl(c16)
          write(c16,'(I16)') nudivy
          write(lunclc,'(a)') '$nMagDivY=' // adjustl(c16)
          write(c16,'(I16)') nudivz
          write(lunclc,'(a)') '$nMagDivZ=' // adjustl(c16)

          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '$white=0'
          write(lunclc,'(a)') '$black=1'
          write(lunclc,'(a)') '$red=2'
          write(lunclc,'(a)') '$green=3'
          write(lunclc,'(a)') '$blue=4'
          write(lunclc,'(a)') '$yellow=5'
          write(lunclc,'(a)') '$magenta=6'
          write(lunclc,'(a)') '$cyan=7'
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') '$AirGap=$PerLen/4.-$LxMag'
          write(lunclc,'(a)') '$E1Br = $Br / 4.'
          write(lunclc,'(a)') '$E2Br = - $Br * 3. / 4.'
          write(lunclc,'(a)') '$HalfGap = $FullGap / 2.'
          write(lunclc,'(a)') '$HalfPerLen = $PerLen / 2.'
          write(lunclc,'(a)') '$LxHalfMag = $LxMag / 2.'
          write(lunclc,'(a)') '$yMagCen = - $HalfGap - $LyMag / 2.'
          write(lunclc,'(a)') '$zMagCen = - $LzMag / 2. - $zSlit / 2.'
          write(lunclc,'(a)') '$hS3Shift = $S3Shift / 2.'
          write(lunclc,'(a)') '$hS2Shift = $S2Shift / 2.'
          write(lunclc,'(a)') '$x1LRMagCen = $xMagCen + $LxHalfMag / 2. - $hS3Shift - $hS2Shift'
          write(lunclc,'(a)') '$x2LRMagCen = $x1LRMagCen + $LxHalfMag / 2. + $AirGap + $LxMag / 2.'
          write(lunclc,'(a)') '$x3LRMagCen = $x2LRMagCen + $LxHalfMag + $AirGap + $LxHalfMag / 2.'
          write(lunclc,'(a)') '$x4LRMagCen = $x3LRMagCen + $LxHalfMag'
          write(lunclc,'(a)') '$x5LRMagCen = $x4LRMagCen + $LxHalfMag / 2. + $AirGap + $LxMag / 2.'
          write(lunclc,'(a)') '$x6LRMagCen = $x5LRMagCen + $LxMag / 2. + $AirGap + $LxHalfMag / 2.'
          write(lunclc,'(a)') '$x1LLMagCen = $x1LRMagCen + $S3Shift + $S2Shift'
          write(lunclc,'(a)') '$x2LLMagCen = $x2LRMagCen + $S3Shift + $S2Shift'
          write(lunclc,'(a)') '$x3LLMagCen = $x3LRMagCen + $S3Shift + $S2Shift'
          write(lunclc,'(a)') '$x4LLMagCen = $x4LRMagCen + $S3Shift + $S2Shift'
          write(lunclc,'(a)') '$x5LLMagCen = $x5LRMagCen + $S3Shift + $S2Shift'
          write(lunclc,'(a)') '$x6LLMagCen = $x6LRMagCen + $S3Shift + $S2Shift'
          write(lunclc,'(a)') '$x1ULMagCen = $x1LRMagCen'
          write(lunclc,'(a)') '$x2ULMagCen = $x2LRMagCen'
          write(lunclc,'(a)') '$x3ULMagCen = $x3LRMagCen'
          write(lunclc,'(a)') '$x4ULMagCen = $x4LRMagCen'
          write(lunclc,'(a)') '$x5ULMagCen = $x5LRMagCen'
          write(lunclc,'(a)') '$x6ULMagCen = $x6LRMagCen'
          write(lunclc,'(a)') '$x1URMagCen = $x1LLMagCen - $S2Shift * 2.'
          write(lunclc,'(a)') '$x2URMagCen = $x2LLMagCen - $S2Shift * 2.'
          write(lunclc,'(a)') '$x3URMagCen = $x3LLMagCen - $S2Shift * 2.'
          write(lunclc,'(a)') '$x4URMagCen = $x4LLMagCen - $S2Shift * 2.'
          write(lunclc,'(a)') '$x5URMagCen = $x5LLMagCen - $S2Shift * 2.'
          write(lunclc,'(a)') '$x6URMagCen = $x6LLMagCen - $S2Shift * 2.'
          write(lunclc,'(a)') '$yUMagCen = - $yMagCen'
          write(lunclc,'(a)') '$zLLMagCen = - $zMagCen'
          write(lunclc,'(a)') '$zULMagCen = - $zMagCen'
          write(lunclc,'(a)') '$yModCen = - 2. * $yMagCen'
          write(lunclc,'(a)') '$zModCen = - 2. * $zMagCen'
          write(lunclc,'(a)') '$x1E1LLMagCen = $x1LLMagCen - $PerLen'
          write(lunclc,'(a)') '$x2E1LLMagCen = $x2LLMagCen - $PerLen'
          write(lunclc,'(a)') '$x3E1LLMagCen = $x3LLMagCen - $PerLen'
          write(lunclc,'(a)') '$x1E1ULMagCen = $x1ULMagCen - $PerLen'
          write(lunclc,'(a)') '$x2E1ULMagCen = $x2ULMagCen - $PerLen'
          write(lunclc,'(a)') '$x3E1ULMagCen = $x3ULMagCen - $PerLen'
          write(lunclc,'(a)') '$x1E1LRMagCen = $x1LRMagCen - $PerLen'
          write(lunclc,'(a)') '$x2E1LRMagCen = $x2LRMagCen - $PerLen'
          write(lunclc,'(a)') '$x3E1LRMagCen = $x3LRMagCen - $PerLen'
          write(lunclc,'(a)') '$x1E1URMagCen = $x1URMagCen - $PerLen'
          write(lunclc,'(a)') '$x2E1URMagCen = $x2URMagCen - $PerLen'
          write(lunclc,'(a)') '$x3E1URMagCen = $x3URMagCen - $PerLen'
          write(lunclc,'(a)') '$x1E2LLMagCen = $x1LLMagCen - $HalfPerLen'
          write(lunclc,'(a)') '$x2E2LLMagCen = $x2LLMagCen - $HalfPerLen'
          write(lunclc,'(a)') '$x3E2LLMagCen = $x3LLMagCen - $HalfPerLen'
          write(lunclc,'(a)') '$x1E2ULMagCen = $x1ULMagCen - $HalfPerLen'
          write(lunclc,'(a)') '$x2E2ULMagCen = $x2ULMagCen - $HalfPerLen'
          write(lunclc,'(a)') '$x3E2ULMagCen = $x3ULMagCen - $HalfPerLen'
          write(lunclc,'(a)') '$x1E2LRMagCen = $x1LRMagCen - $HalfPerLen'
          write(lunclc,'(a)') '$x2E2LRMagCen = $x2LRMagCen - $HalfPerLen'
          write(lunclc,'(a)') '$x3E2LRMagCen = $x3LRMagCen - $HalfPerLen'
          write(lunclc,'(a)') '$x1E2URMagCen = $x1URMagCen - $HalfPerLen'
          write(lunclc,'(a)') '$x2E2URMagCen = $x2URMagCen - $HalfPerLen'
          write(lunclc,'(a)') '$x3E2URMagCen = $x3URMagCen - $HalfPerLen'
          write(lunclc,'(a)') '$dxED0 = ( $nPeriods + 1.0 ) * $PerLen'
          write(lunclc,'(a)') '$dxED1 = ( $nPeriods + 2.0 ) * $PerLen'
          write(lunclc,'(a)') '$dxED2 = ( $nPeriods + 1.5 ) * $PerLen'
          write(lunclc,'(a)') '$x1D0LLMagCen = $x1E1LLMagCen + $dxED0'
          write(lunclc,'(a)') '$x2D0LLMagCen = $x2E1LLMagCen + $dxED0'
          write(lunclc,'(a)') '$x3D0LLMagCen = $x3E1LLMagCen + $dxED0'
          write(lunclc,'(a)') '$x1D0LRMagCen = $x1E1LRMagCen + $dxED0'
          write(lunclc,'(a)') '$x2D0LRMagCen = $x2E1LRMagCen + $dxED0'
          write(lunclc,'(a)') '$x3D0LRMagCen = $x3E1LRMagCen + $dxED0'
          write(lunclc,'(a)') '$x1D0ULMagCen = $x1E1ULMagCen + $dxED0'
          write(lunclc,'(a)') '$x2D0ULMagCen = $x2E1ULMagCen + $dxED0'
          write(lunclc,'(a)') '$x3D0ULMagCen = $x3E1ULMagCen + $dxED0'
          write(lunclc,'(a)') '$x1D0URMagCen = $x1E1URMagCen + $dxED0'
          write(lunclc,'(a)') '$x2D0URMagCen = $x2E1URMagCen + $dxED0'
          write(lunclc,'(a)') '$x3D0URMagCen = $x3E1URMagCen + $dxED0'
          write(lunclc,'(a)') '$x1D1LLMagCen = $x1E1LLMagCen + $dxED1'
          write(lunclc,'(a)') '$x2D1LLMagCen = $x2E1LLMagCen + $dxED1'
          write(lunclc,'(a)') '$x3D1LLMagCen = $x3E1LLMagCen + $dxED1'
          write(lunclc,'(a)') '$x1D1LRMagCen = $x1E1LRMagCen + $dxED1'
          write(lunclc,'(a)') '$x2D1LRMagCen = $x2E1LRMagCen + $dxED1'
          write(lunclc,'(a)') '$x3D1LRMagCen = $x3E1LRMagCen + $dxED1'
          write(lunclc,'(a)') '$x1D1ULMagCen = $x1E1ULMagCen + $dxED1'
          write(lunclc,'(a)') '$x2D1ULMagCen = $x2E1ULMagCen + $dxED1'
          write(lunclc,'(a)') '$x3D1ULMagCen = $x3E1ULMagCen + $dxED1'
          write(lunclc,'(a)') '$x1D1URMagCen = $x1E1URMagCen + $dxED1'
          write(lunclc,'(a)') '$x2D1URMagCen = $x2E1URMagCen + $dxED1'
          write(lunclc,'(a)') '$x3D1URMagCen = $x3E1URMagCen + $dxED1'
          write(lunclc,'(a)') '$x1D2LLMagCen = $x1E1LLMagCen + $dxED2'
          write(lunclc,'(a)') '$x2D2LLMagCen = $x2E1LLMagCen + $dxED2'
          write(lunclc,'(a)') '$x3D2LLMagCen = $x3E1LLMagCen + $dxED2'
          write(lunclc,'(a)') '$x1D2LRMagCen = $x1E1LRMagCen + $dxED2'
          write(lunclc,'(a)') '$x2D2LRMagCen = $x2E1LRMagCen + $dxED2'
          write(lunclc,'(a)') '$x3D2LRMagCen = $x3E1LRMagCen + $dxED2'
          write(lunclc,'(a)') '$x1D2ULMagCen = $x1E1ULMagCen + $dxED2'
          write(lunclc,'(a)') '$x2D2ULMagCen = $x2E1ULMagCen + $dxED2'
          write(lunclc,'(a)') '$x3D2ULMagCen = $x3E1ULMagCen + $dxED2'
          write(lunclc,'(a)') '$x1D2URMagCen = $x1E1URMagCen + $dxED2'
          write(lunclc,'(a)') '$x2D2URMagCen = $x2E1URMagCen + $dxED2'
          write(lunclc,'(a)') '$x3D2URMagCen = $x3E1URMagCen + $dxED2'
          write(lunclc,'(a)') '$colormag = $red'
          write(lunclc,'(a)') '$e1colormag = $magenta'
          write(lunclc,'(a)') '$e2colormag = $green'

          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '*---------- Magnets'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '* Lower right girder'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') '& Magnet'
          write(lunclc,'(a)') 'Block mag1 HMag1 $colormag                 !key, name, mother, color'
          write(lunclc,'(a)') '$x1LRMagCen $yMagCen $zMagCen              !position'
          write(lunclc,'(a)') '$Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Magnet'
          write(lunclc,'(a)') 'Block mag2 Mag2 $colormag                  !key, name, mother, color'
          write(lunclc,'(a)') '$x2LRMagCen $yMagCen $zMagCen              !position'
          write(lunclc,'(a)') '$Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                       !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Magnet'
          write(lunclc,'(a)') 'Block mag3 HMag3 $colormag                 !key, name, mother, color'
          write(lunclc,'(a)') '$x3LRMagCen $yMagCen $zMagCen              !position'
          write(lunclc,'(a)') '$Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Magnet'
          write(lunclc,'(a)') 'Block mag4 HMag4 $colormag                 !key, name, mother, color'
          write(lunclc,'(a)') '$x4LRMagCen $yMagCen $zMagCen              !position'
          write(lunclc,'(a)') '$Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Magnet'
          write(lunclc,'(a)') 'Block mag5 Mag5 $colormag                  !key, name, mother, color'
          write(lunclc,'(a)') '$x5LRMagCen $yMagCen $zMagCen              !position'
          write(lunclc,'(a)') '$Br 0.0 -1.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                       !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Magnet'
          write(lunclc,'(a)') 'Block mag6 HMag6 $colormag                 !key, name, mother, color'
          write(lunclc,'(a)') '$x6LRMagCen $yMagCen $zMagCen              !position'
          write(lunclc,'(a)') '$Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '* Upper right girder'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Magnet'
          write(lunclc,'(a)') 'Block mag7 HMag7 $colormag                 !key, name, mother, color'
          write(lunclc,'(a)') '$x1URMagCen $yUMagCen $zMagCen             !position'
          write(lunclc,'(a)') '$Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Magnet'
          write(lunclc,'(a)') 'Block mag8 Mag8 $colormag                  !key, name, mother, color'
          write(lunclc,'(a)') '$x2URMagCen $yUMagCen $zMagCen             !position'
          write(lunclc,'(a)') '$Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                       !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Magnet'
          write(lunclc,'(a)') 'Block mag9 HMag9 $colormag                 !key, name, mother, color'
          write(lunclc,'(a)') '$x3URMagCen $yUMagCen $zMagCen             !position'
          write(lunclc,'(a)') '$Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Magnet'
          write(lunclc,'(a)') 'Block mag10 HMag10 $colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x4URMagCen $yUMagCen $zMagCen             !position'
          write(lunclc,'(a)') '$Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Magnet'
          write(lunclc,'(a)') 'Block mag11 Mag11 $colormag                !key, name, mother, color'
          write(lunclc,'(a)') '$x5URMagCen $yUMagCen $zMagCen             !position'
          write(lunclc,'(a)') '$Br 0.0 -1.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                       !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Magnet'
          write(lunclc,'(a)') 'Block mag12 HMag12 $colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x6URMagCen $yUMagCen $zMagCen             !position'
          write(lunclc,'(a)') '$Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '* Lower left girder'
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') '& Magnet'
          write(lunclc,'(a)') 'Block mag13 HMag13 $colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x1LLMagCen $yMagCen $zLLMagCen            !position'
          write(lunclc,'(a)') '$Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Magnet'
          write(lunclc,'(a)') 'Block mag14 Mag14 $colormag                !key, name, mother, color'
          write(lunclc,'(a)') '$x2LLMagCen $yMagCen $zLLMagCen            !position'
          write(lunclc,'(a)') '$Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                       !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Magnet'
          write(lunclc,'(a)') 'Block mag15 HMag15 $colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x3LLMagCen $yMagCen $zLLMagCen            !position'
          write(lunclc,'(a)') '$Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Magnet'
          write(lunclc,'(a)') 'Block mag16 HMag16 $colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x4LLMagCen $yMagCen $zLLMagCen            !position'
          write(lunclc,'(a)') '$Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
          write(lunclc,'(a)') '& Magnet'
          write(lunclc,'(a)') 'Block mag17 Mag17 $colormag                !key, name, mother, color'
          write(lunclc,'(a)') '$x5LLMagCen $yMagCen $zLLMagCen            !position'
          write(lunclc,'(a)') '$Br 0.0 -1.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                       !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention'
          write(lunclc,'(a)') '& Magnet'
          write(lunclc,'(a)') 'Block mag18 HMag18 $colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x6LLMagCen $yMagCen $zLLMagCen            !position'
          write(lunclc,'(a)') '$Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '* Upper right girder'
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') '& Magnet'
          write(lunclc,'(a)') 'Block mag19 HMag19 $colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x1LRMagCen $yUMagCen $zULMagCen           !position'
          write(lunclc,'(a)') '$Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Magnet'
          write(lunclc,'(a)') 'Block mag20 Mag20 $colormag                !key, name, mother, color'
          write(lunclc,'(a)') '$x2LRMagCen $yUMagCen $zULMagCen           !position'
          write(lunclc,'(a)') '$Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                       !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Magnet'
          write(lunclc,'(a)') 'Block mag21 HMag21 $colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x3LRMagCen $yUMagCen $zULMagCen           !position'
          write(lunclc,'(a)') '$Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Magnet'
          write(lunclc,'(a)') 'Block mag22 HMag22 $colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x4LRMagCen $yUMagCen $zULMagCen           !position'
          write(lunclc,'(a)') '$Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Magnet'
          write(lunclc,'(a)') 'Block mag23 Mag23 $colormag                !key, name, mother, color'
          write(lunclc,'(a)') '$x5LRMagCen $yUMagCen $zULMagCen           !position'
          write(lunclc,'(a)') '$Br 0.0 -1.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                       !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Magnet'
          write(lunclc,'(a)') 'Block mag24 HMag24 $colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x6LRMagCen $yUMagCen $zULMagCen           !position'
          write(lunclc,'(a)') '$Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '* Lower right girder'
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag25 Mag25 $e1colormag              !key, name, mother, color'
          write(lunclc,'(a)') '$x1E1LRMagCen $yMagCen $zMagCen            !position'
          write(lunclc,'(a)') '$E1Br 1.0 0.0 0.0 $matrec                  !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag26 Mag26 $e1colormag              !key, name, mother, color'
          write(lunclc,'(a)') '$x2E1LRMagCen $yMagCen $zMagCen            !position'
          write(lunclc,'(a)') '$E1Br 0.0 1.0 0.0 $matrec                  !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                       !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag27 HMag27 $e1colormag             !key, name, mother, color'
          write(lunclc,'(a)') '$x3E1LRMagCen $yMagCen $zMagCen            !position'
          write(lunclc,'(a)') '$E1Br -1.0 0.0 0.0 $matrec                 !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '* Upper right girder'
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag28 HMag28 $e1colormag             !key, name, mother, color'
          write(lunclc,'(a)') '$x1E1URMagCen $yUMagCen $zMagCen           !position'
          write(lunclc,'(a)') '$E1Br -1.0 0.0 0.0 $matrec                 !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag29 Mag29 $e1colormag              !key, name, mother, color'
          write(lunclc,'(a)') '$x2E1URMagCen $yUMagCen $zMagCen           !position'
          write(lunclc,'(a)') '$E1Br 0.0 1.0 0.0 $matrec                  !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                       !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag30 HMag30 $e1colormag             !key, name, mother, color'
          write(lunclc,'(a)') '$x3E1URMagCen $yUMagCen $zMagCen           !position'
          write(lunclc,'(a)') '$E1Br 1.0 0.0 0.0 $matrec                  !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                   !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention'
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '* Lower left girder'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag31 HMag31 $e1colormag              !key, name, mother, color'
          write(lunclc,'(a)') '$x1E1LLMagCen $yMagCen $zLLMagCen           !position'
          write(lunclc,'(a)') '$E1Br 1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                    !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag32 Mag32 $e1colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x2E1LLMagCen $yMagCen $zLLMagCen           !position'
          write(lunclc,'(a)') '$E1Br 0.0 1.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                        !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.         !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag33 HMag33 $e1colormag              !key, name, mother, color'
          write(lunclc,'(a)') '$x3E1LLMagCen $yMagCen $zLLMagCen           !position'
          write(lunclc,'(a)') '$E1Br -1.0 0.0 0.0 $matrec                  !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                    !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention'
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '* Lower right girder'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag34 HMag34 $e1colormag              !key, name, mother, color'
          write(lunclc,'(a)') '$x1E1LRMagCen $yUMagCen $zULMagCen          !position'
          write(lunclc,'(a)') '$E1Br -1.0 0.0 0.0 $matrec                  !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                    !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag35 Mag35 $e1colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x2E1LRMagCen $yUMagCen $zULMagCen          !position'
          write(lunclc,'(a)') '$E1Br 0.0 1.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                        !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.         !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag36 HMag36 $e1colormag              !key, name, mother, color'
          write(lunclc,'(a)') '$x3E1LRMagCen $yUMagCen $zULMagCen          !position'
          write(lunclc,'(a)') '$E1Br 1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                    !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag37 HMag37 $e2colormag              !key, name, mother, color'
          write(lunclc,'(a)') '$x1E2LRMagCen $yMagCen $zMagCen             !position'
          write(lunclc,'(a)') '$E2Br 1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                    !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag38 Mag38 $e2colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x2E2LRMagCen $yMagCen $zMagCen             !position'
          write(lunclc,'(a)') '$E2Br 0.0 1.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                        !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.         !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag39 HMag39 $e2colormag              !key, name, mother, color'
          write(lunclc,'(a)') '$x3E2LRMagCen $yMagCen $zMagCen             !position'
          write(lunclc,'(a)') '$E2Br -1.0 0.0 0.0 $matrec                  !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                    !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention'
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '* Upper right girder'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag40 HMag40 $e2colormag              !key, name, mother, color'
          write(lunclc,'(a)') '$x1E2URMagCen $yUMagCen $zMagCen            !position'
          write(lunclc,'(a)') '$E2Br -1.0 0.0 0.0 $matrec                  !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                    !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag41 Mag41 $e2colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x2E2URMagCen $yUMagCen $zMagCen            !position'
          write(lunclc,'(a)') '$E2Br 0.0 1.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                        !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.         !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag42 HMag42 $e2colormag              !key, name, mother, color'
          write(lunclc,'(a)') '$x3E2URMagCen $yUMagCen $zMagCen            !position'
          write(lunclc,'(a)') '$E2Br 1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                    !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention'
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '* Lower left girder'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag43 HMag43 $e2colormag              !key, name, mother, color'
          write(lunclc,'(a)') '$x1E2LLMagCen $yMagCen $zLLMagCen           !position'
          write(lunclc,'(a)') '$E2Br 1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                    !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag44 Mag44 $e2colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x2E2LLMagCen $yMagCen $zLLMagCen           !position'
          write(lunclc,'(a)') '$E2Br 0.0 1.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                        !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.         !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag45 HMag45 $e2colormag              !key, name, mother, color'
          write(lunclc,'(a)') '$x3E2LLMagCen $yMagCen $zLLMagCen           !position'
          write(lunclc,'(a)') '$E2Br -1.0 0.0 0.0 $matrec                  !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                    !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention'
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '* Lower right girder'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag46 HMag46 $e2colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x1E2LRMagCen $yUMagCen $zULMagCen           !position'
          write(lunclc,'(a)') '$E2Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag47 Mag47 $e2colormag                !key, name, mother, color'
          write(lunclc,'(a)') '$x2E2LRMagCen $yUMagCen $zULMagCen           !position'
          write(lunclc,'(a)') '$E2Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                         !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag48 HMag48 $e2colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x3E2LRMagCen $yUMagCen $zULMagCen           !position'
          write(lunclc,'(a)') '$E2Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag49 HMag49 $e2colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x1D0LRMagCen $yMagCen $zMagCen              !position'
          write(lunclc,'(a)') '$Br 1.0 0.0 0.0 $matrec                      !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag50 Mag50 $e2colormag                !key, name, mother, color'
          write(lunclc,'(a)') '$x2D0LRMagCen $yMagCen $zMagCen              !position'
          write(lunclc,'(a)') '$Br 0.0 1.0 0.0 $matrec                      !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                         !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag51 HMag51 $e2colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x3D0LRMagCen $yMagCen $zMagCen              !position'
          write(lunclc,'(a)') '$Br -1.0 0.0 0.0 $matrec                     !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag52 HMag52 $e1colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x1D1LRMagCen $yMagCen $zMagCen              !position'
          write(lunclc,'(a)') '$E1Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag53 Mag53 $e1colormag                !key, name, mother, color'
          write(lunclc,'(a)') '$x2D1LRMagCen $yMagCen $zMagCen              !position'
          write(lunclc,'(a)') '$E1Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                         !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag54 HMag54 $e1colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x3D1LRMagCen $yMagCen $zMagCen              !position'
          write(lunclc,'(a)') '$E1Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '* Upper right girder'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag55 HMag55 $e2colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x1D0URMagCen $yUMagCen $zMagCen             !position'
          write(lunclc,'(a)') '$Br -1.0 0.0 0.0 $matrec                     !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag56 Mag56 $e2colormag                !key, name, mother, color'
          write(lunclc,'(a)') '$x2D0URMagCen $yUMagCen $zMagCen             !position'
          write(lunclc,'(a)') '$Br 0.0 1.0 0.0 $matrec                      !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                         !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag57 HMag57 $e2colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x3D0URMagCen $yUMagCen $zMagCen             !position'
          write(lunclc,'(a)') '$Br 1.0 0.0 0.0 $matrec                      !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag58 HMag58 $e1colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x1D1URMagCen $yUMagCen $zMagCen             !position'
          write(lunclc,'(a)') '$E1Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag59 Mag59 $e1colormag                !key, name, mother, color'
          write(lunclc,'(a)') '$x2D1URMagCen $yUMagCen $zMagCen             !position'
          write(lunclc,'(a)') '$E1Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                         !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag60 HMag60 $e1colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x3D1URMagCen $yUMagCen $zMagCen             !position'
          write(lunclc,'(a)') '$E1Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '* Lower left girder'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag61 HMag61 $e2colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x1D0LLMagCen $yMagCen $zLLMagCen            !position'
          write(lunclc,'(a)') '$Br 1.0 0.0 0.0 $matrec                      !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag62 Mag62 $e2colormag                !key, name, mother, color'
          write(lunclc,'(a)') '$x2D0LLMagCen $yMagCen $zLLMagCen            !position'
          write(lunclc,'(a)') '$Br 0.0 1.0 0.0 $matrec                      !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                         !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag63 HMag63 $e2colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x3D0LLMagCen $yMagCen $zLLMagCen            !position'
          write(lunclc,'(a)') '$Br -1.0 0.0 0.0 $matrec                     !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag64 HMag64 $e1colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x1D1LLMagCen $yMagCen $zLLMagCen            !position'
          write(lunclc,'(a)') '$E1Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag65 Mag65 $e1colormag                !key, name, mother, color'
          write(lunclc,'(a)') '$x2D1LLMagCen $yMagCen $zLLMagCen            !position'
          write(lunclc,'(a)') '$E1Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                         !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag66 HMag66 $e1colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x3D1LLMagCen $yMagCen $zLLMagCen            !position'
          write(lunclc,'(a)') '$E1Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '* Upper left girder'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag67 HMag67 $e2colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x1D0ULMagCen $yUMagCen $zULMagCen           !position'
          write(lunclc,'(a)') '$Br -1.0 0.0 0.0 $matrec                     !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag68 Mag68 $e2colormag                !key, name, mother, color'
          write(lunclc,'(a)') '$x2D0ULMagCen $yUMagCen $zULMagCen           !position'
          write(lunclc,'(a)') '$Br 0.0 1.0 0.0 $matrec                      !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                         !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag69 HMag69 $e2colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x3D0ULMagCen $yUMagCen $zULMagCen           !position'
          write(lunclc,'(a)') '$Br 1.0 0.0 0.0 $matrec                      !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '* Lower right girder'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag70 HMag70 $e1colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x1D1LRMagCen $yUMagCen $zULMagCen           !position'
          write(lunclc,'(a)') '$E1Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag71 Mag71 $e1colormag                !key, name, mother, color'
          write(lunclc,'(a)') '$x2D1LRMagCen $yUMagCen $zULMagCen           !position'
          write(lunclc,'(a)') '$E1Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                         !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag72 HMag72 $e1colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x3D1LRMagCen $yUMagCen $zULMagCen           !position'
          write(lunclc,'(a)') '$E1Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag73 HMag73 $e2colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x1D2LRMagCen $yMagCen $zMagCen              !position'
          write(lunclc,'(a)') '$E2Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag74 Mag74 $e2colormag                !key, name, mother, color'
          write(lunclc,'(a)') '$x2D2LRMagCen $yMagCen $zMagCen              !position'
          write(lunclc,'(a)') '$E2Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                         !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag75 HMag75 $e2colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x3D2LRMagCen $yMagCen $zMagCen              !position'
          write(lunclc,'(a)') '$E2Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '* Upper right girder'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag76 HMag76 $e2colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x1D2URMagCen $yUMagCen $zMagCen             !position'
          write(lunclc,'(a)') '$E2Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag77 Mag77 $e2colormag                !key, name, mother, color'
          write(lunclc,'(a)') '$x2D2URMagCen $yUMagCen $zMagCen             !position'
          write(lunclc,'(a)') '$E2Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                         !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag78 HMag78 $e2colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x3D2URMagCen $yUMagCen $zMagCen             !position'
          write(lunclc,'(a)') '$E2Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '* Lower left girder'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag79 HMag79 $e2colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x1D2LLMagCen $yMagCen $zLLMagCen            !position'
          write(lunclc,'(a)') '$E2Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag80 Mag80 $e2colormag                !key, name, mother, color'
          write(lunclc,'(a)') '$x2D2LLMagCen $yMagCen $zLLMagCen            !position'
          write(lunclc,'(a)') '$E2Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                         !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag81 HMag81 $e2colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x3D2LLMagCen $yMagCen $zLLMagCen            !position'
          write(lunclc,'(a)') '$E2Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '* Lower right girder'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag82 HMag82 $e2colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x1D2LRMagCen $yUMagCen $zULMagCen           !position'
          write(lunclc,'(a)') '$E2Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag83 Mag83 $e2colormag                !key, name, mother, color'
          write(lunclc,'(a)') '$x2D2LRMagCen $yUMagCen $zULMagCen           !position'
          write(lunclc,'(a)') '$E2Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxMag $LyMag $LzMag                         !dimension'
          write(lunclc,'(a)') '$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Special_Magnet'
          write(lunclc,'(a)') 'Block mag84 HMag84 $e2colormag               !key, name, mother, color'
          write(lunclc,'(a)') '$x3D2LRMagCen $yUMagCen $zULMagCen           !position'
          write(lunclc,'(a)') '$E2Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index'
          write(lunclc,'(a)') '$LxHalfMag $LyMag $LzMag                     !dimension'
          write(lunclc,'(a)') '$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Module'
          write(lunclc,'(a)') '0. 0. 0. 1 1        !offset of module, number and number of associated module'
          write(lunclc,'(a)') '$nPeriods           !number of arrays within module'
          write(lunclc,'(a)') '$PerLen 1. 0. 0. 0. !spacing and direction of arrangement, rotation angle'
          write(lunclc,'(a)') '1. 1. 1.            !scaling and symmetry of magnetization vector'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') ' '

          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') '& Materials'
          write(lunclc,'(a)') '1                    ! number of material files'
          write(lunclc,'(a)') '1 1 1 undumag_mu.dat ! number, type, mode, and filename'
          write(lunclc,'(a)') ' '
          write(lunclc,'(a)') ' '

+self.,if=-oldapple.

          flush(lunclc)
          close(lunclc)
          close(luntmp)

        else if (kbundumag.eq.4) then

          open(newunit=lunmat,file="undumag_mu.dat")
          write(lunmat,*)umupar,uksiper," ! mu_Par and ksi_Per"
          flush(lunmat)
          close(lunmat)

          if (uperlen_h.gt.0.0d0) then
            umaglx_h=uperlen_h/2.0d0-umagspac_h-upollx_h-upolspac_h
          else
            uperlen_h=2.0d0*(umaglx_h+umagspac_h+upollx_h+upolspac_h)
          endif

          open(newunit=lunclc,file="undumag.clc")

          write(lunclc,'(a)') "*! Lines written by WAVE"
          write(lunclc,'(a)') "*! Hybrid"
          write(lunclc,'(a)') " "
          write(lunclc,'(a)') "& User_Comment"
          write(cval,*)kwrun
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') trim(chwcom) // " (Run " // cval(k1:k2) // ")"
          write(lunclc,'(a)') " "

          write(lunclc,'(a)') " "

          write(cval,*)nperiod_h
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') "$nPeriods=" // cval(k1:k2)

          write(cval,'(g12.6)')undugap_h
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') "$FullGap=" // cval(k1:k2)

          write(lunclc,'(a)') " "
          write(cval,'(g12.6)')abs(umagbc_h)
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') "$Br=" // cval(k1:k2)
          write(cval,'(g12.6)')abs(umupar_h)
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') "$Mu=" // cval(k1:k2)
          write(cval,'(g12.6)')abs(uksiper_h)
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') "$KsiPerp=" // cval(k1:k2)
          write(lunclc,'(a)') "$MagMat=1"
          write(lunclc,'(a)') " "

          write(cval,'(g12.6)')umaglx_h
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') "$LxMag=" // cval(k1:k2)
          write(cval,'(g12.6)')umagly_h
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') "$LyMag=" // cval(k1:k2)
          write(cval,'(g12.6)')umaglz_h
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') "$LzMagFull=" // cval(k1:k2)
          write(cval,'(g12.6)')UMAGCH_H
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') "$ChamfM=" // cval(k1:k2)
          write(lunclc,'(a)') " "

          write(cval,'(g12.6)')UCOATING_H
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') "$MCoating=" // cval(k1:k2)
          write(lunclc,'(a)') " "

          write(cval,'(g12.6)')UMAGSPAC_H
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') "$AirGap=" // cval(k1:k2)
          write(lunclc,'(a)') " "

          write(cval,*)numdivx_h
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') "$nMagDivX=" // cval(k1:k2)
          write(cval,*)numdivy_h
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') "$nMagDivY=" // cval(k1:k2)
          write(cval,*)max(numdivz_h/2,1)
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') "$nMagDivZHalf=" // cval(k1:k2)

          write(lunclc,'(a)') " "

          write(lunclc,'(a)') "$IronMat=2"
          write(lunclc,'(a)') " "

          write(cval,'(g12.6)')upollx_h
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') "$LxPol=" // cval(k1:k2)
          write(cval,'(g12.6)')upolly_h
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') "$LyPol=" // cval(k1:k2)
          write(cval,'(g12.6)')upollz_h
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') "$LzPolFull=" // cval(k1:k2)
          write(cval,'(g12.6)')UPOLCH_H
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') "$ChamfP=" // cval(k1:k2)

          write(lunclc,'(a)') " "
          write(cval,'(g12.6)')UPOLSPAC_H
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') "$KeeperGap=" // cval(k1:k2) // "                 ! Be careful with ixsym, if keeper- and airgap are different"
          write(lunclc,'(a)') " "

          write(cval,*)nupdivx_h
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') "$nPolDivX=" // cval(k1:k2)
          if (nupdivx_h/2*2.eq.nupdivx_h) then
            write(cval,*)nupdivx_h/2
          else
            write(cval,*)nupdivx_h/2+1
          endif
          write(lunclc,'(a)') "$nPolDivXHalf=" // cval(k1:k2)
          write(cval,*)nupdivy_h
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') "$nPolDivY=" // cval(k1:k2)
          write(cval,*)max(nupdivz_h/2,1)
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') "$nPolDivZHalf=" // cval(k1:k2)
          write(lunclc,'(a)') " "
          write(cval,'(g12.6)')max(FracDivFe_h,1.0d0)
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') "$FracDivFeY=" // cval(k1:k2)
          write(cval,'(g12.6)')max(FracDivFeZ_h,1.0d0)
          call util_string_trim(cval,k1,k2)
          write(lunclc,'(a)') "$FracDivFeZ=" // cval(k1:k2)
          write(lunclc,'(a)') " "

          nendpol=0
          nendmag=0
          xend=0.0d0
          perlen=2.0d0*(upollx_h+umaglx_h+umagspac_h+upolspac_h)

          do i=1,nspec_h

            if (abs(msmag_h(i)).eq.1) then

              nendmag=nendmag+1
              write(cend,*)nendmag

              call util_string_trim(cend,k1end,k2end)

              cline="$LxEndMag" // cend(k1end:k2end) // "="
              call util_string_trim(cline,k1,k2)
              cline=cline(k1:k2)
              write(cval,'(g12.6)')usmaglx_h(i)
              call util_string_trim(cval,k1,k2)
              write(lunclc,'(a)')trim(cline) // cval(k1:k2)

              cline="$LyEndMag" // cend(k1end:k2end) // "="
              call util_string_trim(cline,k1,k2)
              cline=cline(k1:k2)
              write(cval,'(g12.6)')usmagly_h(i)
              call util_string_trim(cval,k1,k2)
              write(lunclc,'(a)')trim(cline) // cval(k1:k2)

              cline="$LzEndMagFull" // cend(k1end:k2end) // "="
              call util_string_trim(cline,k1,k2)
              cline=cline(k1:k2)
              write(cval,'(g12.6)')usmaglz_h(i)
              call util_string_trim(cval,k1,k2)
              write(lunclc,'(a)')trim(cline) // cval(k1:k2)

              cline="$ChamfEndMag" // cend(k1end:k2end) // "="
              call util_string_trim(cline,k1,k2)
              cline=cline(k1:k2)
              write(cval,'(g12.6)')usmagch_h(i)
              call util_string_trim(cval,k1,k2)
              write(lunclc,'(a)')trim(cline) // cval(k1:k2)

              cline="$SpacerEndMag" // cend(k1end:k2end) // "="
              call util_string_trim(cline,k1,k2)
              cline=cline(k1:k2)
              write(cval,'(g12.6)')usmagspac_h(i)
              call util_string_trim(cval,k1,k2)
              write(lunclc,'(a)')trim(cline) // cval(k1:k2)

              cline="$YoffsetEndMag" // cend(k1end:k2end) // "="
              call util_string_trim(cline,k1,k2)
              cline=cline(k1:k2)
              write(cval,'(g12.6)')usmagdy_h(i)
              call util_string_trim(cval,k1,k2)
              write(lunclc,'(a)')trim(cline) // cval(k1:k2)

            else

              nendpol=nendpol+1
              write(cval,*)nendpol
              call util_string_trim(cend,k1end,k2end)

              cline="$LxEndPol" // cend(k1end:k2end) // "="
              call util_string_trim(cline,k1,k2)
              cline=cline(k1:k2)
              write(cval,'(g12.6)')usmaglx_h(i)
              call util_string_trim(cval,k1,k2)
              write(lunclc,'(a)')trim(cline) // cval(k1:k2)

              cline="$LyEndPol" // cend(k1end:k2end) // "="
              call util_string_trim(cline,k1,k2)
              cline=cline(k1:k2)
              write(cval,'(g12.6)')usmagly_h(i)
              call util_string_trim(cval,k1,k2)
              write(lunclc,'(a)')trim(cline) // cval(k1:k2)

              cline="$LzEndPolFull" // cend(k1end:k2end) // "="
              call util_string_trim(cline,k1,k2)
              cline=cline(k1:k2)
              write(cval,'(g12.6)')usmaglz_h(i)
              call util_string_trim(cval,k1,k2)
              write(lunclc,'(a)')trim(cline) // cval(k1:k2)

              cline="$ChamfEndPol" // cend(k1end:k2end) // "="
              call util_string_trim(cline,k1,k2)
              cline=cline(k1:k2)
              write(cval,'(g12.6)')usmagch_h(i)
              call util_string_trim(cval,k1,k2)
              write(lunclc,'(a)')trim(cline) // cval(k1:k2)

              cline="$SpacerEndPol" // cend(k1end:k2end) // "="
              call util_string_trim(cline,k1,k2)
              cline=cline(k1:k2)
              write(cval,'(g12.6)')usmagspac_h(i)
              call util_string_trim(cval,k1,k2)
              write(lunclc,'(a)')trim(cline) // cval(k1:k2)

              cline="$YoffsetEndPol" // cend(k1end:k2end) // "="
              call util_string_trim(cline,k1,k2)
              cline=cline(k1:k2)
              write(cval,'(g12.6)')usmagdy_h(i)
              call util_string_trim(cval,k1,k2)
              write(lunclc,'(a)')trim(cline) // cval(k1:k2)

            endif

            write(lunclc,'(a)') " "

          enddo !nspec_h

          write(lunclc,'(a)') " "

          write(lunclc,'(a)') "$Mcol=2"
          write(lunclc,'(a)') "$Pcol=4"
          write(lunclc,'(a)') " "
          write(lunclc,'(a)') "$PerLen = 2. * ( $KeeperGap + $LxPol + $AirGap + $LxMag ) "
          write(lunclc,'(a)') " "
          write(lunclc,'(a)') "$LzMag = $LzMagFull / 2."
          write(lunclc,'(a)') "$LzPol = $LzPolFull / 2."
          write(lunclc,'(a)') " "
          write(lunclc,'(a)') "$xShift  = ( $nPeriods - 1 ) * $PerLen"
          write(lunclc,'(a)') " "
          write(lunclc,'(a)') "$xMag1 = - $xShift - $LxPol / 2. - $AirGap - $LxMag / 2."
          write(lunclc,'(a)') "$xMag2 = $xMag1 - $PerLen / 2."
          write(lunclc,'(a)') " "
          write(lunclc,'(a)') "$yMag = - $FullGap / 2. - $LyMag / 2."
          write(lunclc,'(a)') "$zMag  = - $LzMag / 2."
          write(lunclc,'(a)') " "
          write(lunclc,'(a)') "$xPol1 = - $xShift -  $PerLen / 2."
          write(lunclc,'(a)') "$xPol2 = $xPol1 - $PerLen / 2."
          write(lunclc,'(a)') " "
          write(lunclc,'(a)') "$yPol = - $FullGap / 2. - $LyPol / 2."
          write(lunclc,'(a)') "$zPol  = - $LzPol / 2."
          write(lunclc,'(a)') " "
          write(lunclc,'(a)') " "
          write(lunclc,'(a)') "! Central pole, see under special magnets"
          write(lunclc,'(a)') "$LxHalfPol = $LxPol / 2."
          write(lunclc,'(a)') "$xHPol1 = - $LxPol / 4."
          write(lunclc,'(a)') " "

          nendpol=0
          nendmag=0
          xend=-dble(nperiod_h)*perlen-upollx_h/2.0d0-umagspac_h
          xend=xend-usmaglx_h(1)-usmagspac_h(1)

          write(lunclc,'(a)')
     &      "$xSpec0  = - $nPeriods * $PerLen - $LxPol / 2. - $AirGap"
          cindo='0'
          kio=1
          keo=1

          do i=1,nspec_h

            write(cind,'(I4)') i
            call util_string_trim(cind,indi,inde)

            xend=xend-usmaglx_h(i)-usmagspac_h(i)
            x=xend+usmaglx_h(i)/2.0d0

            if (abs(msmag_h(i)).eq.1) then

              nendmag=nendmag+1
              write(cmag,'(I4)') nendmag
              call util_string_trim(cmag,kim,kem)

              cline=
     &          "$xSpec" // cind(indi:inde) // " = $xSpec" // cindo(kio:keo) //
     &          " - $LxEndMag" // cmag(kim:kem) //
     &          " - $SpacerEndMag" // cmag(kim:kem)
              write(lunclc,'(a)')trim(cline)

              cline=
     &          "$xEndMag" // cmag(kim:kem) // " = $xSpec" // cind(indi:inde) //
     &          " + $LxEndMag" // cmag(kim:kem) // " / 2. "
              write(lunclc,'(a)')trim(cline)

              cline="$yEndMag" // cmag(kim:kem) // " = $yMag + $YoffsetEndMag" // cmag(kim:kem)
              write(lunclc,'(a)')trim(cline)

            else

              nendpol=nendpol+1
              write(cpol,'(I4)') nendpol
              call util_string_trim(cpol,kip,kep)

              cline=
     &          "$xSpec" // cind(indi:inde) // " = $xSpec" // cindo(kio:keo) //
     &          " - $LxEndPol" // cpol(kip:kep) // " - $SpacerEndPol" // cpol(kip:kep)
              write(lunclc,'(a)')trim(cline)

              cline=
     &          "$xEndPol" // cpol(kip:kep) // " = $xSpec" // cind(indi:inde) //
     &          " + $LxEndPol" // cpol(kip:kep) // " / 2. "
              write(lunclc,'(a)')trim(cline)

              cline="$yEndPol" // cpol(kip:kep) // " = $yPol + $YoffsetEndPol" // cpol(kip:kep)
              write(lunclc,'(a)')trim(cline)

            endif

            write(lunclc,'(a)') " "

            cindo=cind
            kio=indi
            keo=inde

          enddo !nspec_h

          if (kbundumag.eq.4) then

            if (ixsym_h.ne.0) then
              write(lunclc,'(a)') "$ixsym=1 ! overwrites value of undumag.nam"
            else
              write(lunclc,'(a)') "$ixsym=0 ! overwrites value of undumag.nam"
            endif

            write(lunclc,'(a)')
     &        "$kxsym=int[$ixsym/($ixsym-0.0001)]"
            write(lunclc,'(a)')
     &        "$IronMatSym=$IronMat*abs[$kxsym]"

            if (iysym_h.ne.0) then
              write(lunclc,'(a)') "$iysym=1 ! overwrites value of undumag.nam"
            else
              write(lunclc,'(a)') "$iysym=0 ! overwrites value of undumag.nam"
            endif

            if (izsym_h.ne.0) then
              write(lunclc,'(a)') "$izsym=1 ! overwrites value of undumag.nam"
            else
              write(lunclc,'(a)') "$izsym=0 ! overwrites value of undumag.nam"
            endif

          endif

          write(lunclc,'(a)') " "
          write(lunclc,'(a)') "*-------------------------------------"
          write(lunclc,'(a)') " "
          write(lunclc,'(a)') "! Section of magnetic items"
          write(lunclc,'(a)') " "
          write(lunclc,'(a)') " "

          write(lunclc,'(a)') "!   /---\"
          write(lunclc,'(a)') "!   |   |"
          write(lunclc,'(a)') "!   | > |    First main magnet"
          write(lunclc,'(a)') "!   |   |"
          write(lunclc,'(a)') "!   -----"
          write(lunclc,'(a)') " "

          write(lunclc,'(a)') "& Magnet"
          write(lunclc,'(a)') "BlockChamf mag1 Mag1 $Mcol                  !key, name, mother, color "
          write(lunclc,'(a)') "$xMag1 $yMag $zMag                          !position of magnet"
          write(lunclc,'(a)') "$Br 1.0 0.0 0.0 $MagMat                     !length bc and components of mag. vector, material index"
          write(lunclc,'(a)') "$LxMag $LyMag $LzMag $ChamfM                !dimensions"
          write(lunclc,'(a)') "$nMagDivX $nMagDivY $nMagDivZHalf 1. 1.     !segmentation"
          write(lunclc,'(a)') " "

          write(lunclc,'(a)') " "
          write(lunclc,'(a)') "!   /---\"
          write(lunclc,'(a)') "!   |   |"
          write(lunclc,'(a)') "!   |   |    First full pole"
          write(lunclc,'(a)') "!   |   |"
          write(lunclc,'(a)') "!   -----"
          write(lunclc,'(a)') " "

          write(lunclc,'(a)') "& Pole"
          write(lunclc,'(a)') "BlockChamf pol1 Pol1 $Pcol                                !key, name, mother, color "
          write(lunclc,'(a)') "$xPol1 $yPol $zPol                                        !position of magnet"
          write(lunclc,'(a)') "$IronMat                                                  !material index"
          write(lunclc,'(a)') "$LxPol $LyPol $LzPol $ChamfP                              !dimensions"
          write(lunclc,'(a)') "$nPolDivX $nPolDivY $nPolDivZHalf $FracDivFeY $FracDivFeZ !segmentation"
          write(lunclc,'(a)') " "

          write(lunclc,'(a)') "!   /---\"
          write(lunclc,'(a)') "!   |   |"
          write(lunclc,'(a)') "!   | < |    Second main magnet"
          write(lunclc,'(a)') "!   |   |"
          write(lunclc,'(a)') "!   -----"
          write(lunclc,'(a)') " "

          write(lunclc,'(a)') "& Magnet"
          write(lunclc,'(a)') "BlockChamf mag2 Mag2 $Mcol                  !key, name, mother, color "
          write(lunclc,'(a)') "$xMag2 $yMag $zMag                          !position of magnet"
          write(lunclc,'(a)') "$Br -1.0 0.0 0.0 $MagMat                    !length bc and components of mag. vector, material index"
          write(lunclc,'(a)') "$LxMag $LyMag $LzMag $ChamfM                !dimensions"
          write(lunclc,'(a)') "$nMagDivX $nMagDivY $nMagDivZHalf 1. 1.     !segmentation"
          write(lunclc,'(a)') " "

          write(lunclc,'(a)') "!   /---\"
          write(lunclc,'(a)') "!   |   |"
          write(lunclc,'(a)') "!   |   |    Second full pole"
          write(lunclc,'(a)') "!   |   |"
          write(lunclc,'(a)') "!   -----"
          write(lunclc,'(a)') " "

          write(lunclc,'(a)') "& Pole"
          write(lunclc,'(a)') "BlockChamf pol2 Pol2 $Pcol                                !key, name, mother, color "
          write(lunclc,'(a)') "$xPol2 $yPol $zPol                                        !position of magnet"
          write(lunclc,'(a)') "$IronMat                                                  !material index"
          write(lunclc,'(a)') "$LxPol $LyPol $LzPol $ChamfP                              !dimensions"
          write(lunclc,'(a)') "$nPolDivX $nPolDivY $nPolDivZHalf $FracDivFeY $FracDivFeZ !segmentation"
          write(lunclc,'(a)') " "
          write(lunclc,'(a)') " "

          write(lunclc,'(a)') "*------------------------------------------------------------------------"
          write(lunclc,'(a)') "& Module"
          write(lunclc,'(a)') "0. 0. 0.            !offset of module"
          write(lunclc,'(a)') "$nPeriods           !number of arrays within module"
          write(lunclc,'(a)') "$PerLen 1. 0. 0. 0. !spacing and direction of arrangement, rotation angle"
          write(lunclc,'(a)') " 1. 1. 1.           !scaling of magnetization vector"
          write(lunclc,'(a)') "*------------------------------------------------------------------------"
          write(lunclc,'(a)') " "
          write(lunclc,'(a)') " "

          write(lunclc,'(a)') "!   /---|"
          write(lunclc,'(a)') "!   |   |"
          write(lunclc,'(a)') "!   |   |    First half pole in the center (see $ixsym)"
          write(lunclc,'(a)') "!   |   |"
          write(lunclc,'(a)') "!   -----"
          write(lunclc,'(a)') " "
          write(lunclc,'(a)') "& Special_Pole"
          write(lunclc,'(a)') "BlockUsChamf hpol1 HPol1 $Pcol                                !key, name, mother, color "
          write(lunclc,'(a)') "$xHPol1 $yPol $zPol                                           !position of magnet"
          write(lunclc,'(a)') "$IronMatSym                                                   !material index"
          write(lunclc,'(a)') "$LxHalfPol $LyPol $LzPol $ChamfP                              !dimensions"
          write(lunclc,'(a)') "$nPolDivXHalf $nPolDivY $nPolDivZHalf $FracDivFeY $FracDivFeZ !segmentation"
          write(lunclc,'(a)') " "

          nendmag=0
          nendpol=0

          do i=1,nspec_h

            if (abs(msmag_h(i)).eq.1) then

              nendmag=nendmag+1
              write(cend,*)nendmag
              call util_string_trim(cend,k1end,k2end)

              write(lunclc,'(a)') " "
              write(lunclc,'(a)') "!   /---\"
              write(lunclc,'(a)') "!   |   |"
              if (nendmag/2*2.eq.nendmag) then
                write(lunclc,'(a)') "!   | < |    End magnet " // cend(k1end:k2end)
              else
                write(lunclc,'(a)') "!   | > |    End magnet " // cend(k1end:k2end)
              endif
              write(lunclc,'(a)') "!   |   |"
              write(lunclc,'(a)') "!   -----"

              write(lunclc,'(a)') " "
              write(lunclc,'(a)') "& Special_Magnet"
              write(lunclc,'(a)') "BlockChamf" //
     &          " emag" // cend(k1end:k2end) //
     &          " Emag" // cend(k1end:k2end) // " $Mcol" //
     &          " !key, name, mother, color "

              write(lunclc,'(a)') "$xEndMag" // cend(k1end:k2end) //
     &          " $yEndMag" // cend(k1end:k2end) //
     &          " $zMag" // "    !position of magnet"

              if (nendmag/2*2.eq.nendmag) then
                write(lunclc,'(a)') "$Br -1. 0. 0. $MagMat                            !length bc and components of mag. vector, material index"
              else
                write(lunclc,'(a)') "$Br 1. 0. 0. $MagMat                             !length bc and components of mag. vector, material index"
              endif

              write(lunclc,'(a)') "$LxEndMag" // cend(k1end:k2end) //
     &          " $LyEndMag" // cend(k1end:k2end) //
     &          " $LzMag $ChamfM    !dimensions"

              write(lunclc,'(a)') "$nMagDivX $nMagDivY $nMagDivZHalf 1. 1.          !segmentation"

            else

              nendpol=nendpol+1
              write(cend,*)nendpol
              call util_string_trim(cend,k1end,k2end)

              write(lunclc,'(a)') " "
              write(lunclc,'(a)') " "
              write(lunclc,'(a)') "!   /---\"
              write(lunclc,'(a)') "!   |   |"
              write(lunclc,'(a)') "!   |   |    End pole " // cend(k1end:k2end)
              write(lunclc,'(a)') "!   |   |"
              write(lunclc,'(a)') "!   -----"

              write(lunclc,'(a)') " "
              write(lunclc,'(a)') "& Special_Pole"
              write(lunclc,'(a)') "BlockChamf" //
     &          " epol" // cend(k1end:k2end) //
     &          " Epol" // cend(k1end:k2end) // " $Pcol" //
     &          "                    !key, name, mother, color "

              write(lunclc,'(a)') "$xEndPol" // cend(k1end:k2end) //
     &          " $yEndPol" // cend(k1end:k2end) //
     &          " $zPol" // "                                                                !position of pole"

              write(lunclc,'(a)')
     &          "$IronMat                                                                    !material index"

              write(lunclc,'(a)') "$LxEndPol" // cend(k1end:k2end) //
     &          " $LyEndPol" // cend(k1end:k2end) //
     &          " $LzPol $ChamfP                                                             !dimensions"

              write(lunclc,'(a)') "$nPolDivX $nPolDivY $nPolDivZHalf $FracDivFeY $FracDivFeZ !segmentation"

            endif

            write(lunclc,'(a)') " "

          enddo !nspec_h


          write(lunclc,'(a)') "*------------------------------------------------------------------------"
          write(lunclc,'(a)') "& Materials"
          write(lunclc,'(a)') "2 ! number of materials"
          write(lunclc,'(a)') "1 1 1 undumag_mu.dat               ! number, type, mode, and filename"
          write(lunclc,'(a)') "2 2 3 " // trim(CHUNDUIRON_H) // " ! number, type, mode, and filename"
          write(lunclc,'(a)') "*------------------------------------------------------------------------"

88        flush(lunclc)
          close(lunclc)

        endif !(kbundumag.eq.4)

      endif !(kbundumag.lt.0) then

c      stop "Ende in run_undumag"
      if (kbunduverb_c.eq.0) then
        cline=trim(chundutmp) // " > undumag.log"
      else
        cline=trim(chundutmp)
      endif

      print*,''
      print*, "     --- Spawning UNDUMAG run ---"
      print*,''
      print*,"      ",trim(cline)
      print*,''

      istat=system(trim(cline))

      if (istat.ne.0) then
        print*,"*** Error in run_undumag: Bad return status, check undumag.log ***"
        stop "*** Program WAVE aborted ***"
      endif

      open(newunit=lund,file="undumag.stat")
      read(lund,*)istat
      if (istat.ne.0) then
        print*,''
        print*,"     *** UNDUMAG has crashed ***"
        print*,''
        stop "*** Program WAVE aborted ***"
      else
        print*,''
        print*,"     --- UNDUMAG has finished ---"
        print*,''
      endif
      close(lund)

      kbundumag=1

      return

 90   continue
      write(lungfo,*)"*** Error in run_undumag: File"
      write(lungfo,*)trim(chundunam)
      write(lungfo,*)"not found, Check the namelist UNDUMAGN in wave.in ***"
      write(lungfo,*)"*** Program WAVE aborted ***"
      write(6,*)"*** Error in run_undumag: File"
      write(6,*)trim(chundunam)
      write(6,*)"not found, Check the namelist UNDUMAGN in wave.in ***"
      write(6,*)"*** Program WAVE aborted ***"
      stop
 91   continue
      write(lungfo,*)"*** Error in run_undumag: File"
      write(lungfo,*)trim(chunduclc)
      write(lungfo,*)"not found, Check the namelist UNDUMAGN in wave.in ***"
      write(lungfo,*)"*** Program WAVE aborted ***"
      write(6,*)" Error in run_undumag: File"
      write(6,*)trim(chunduclc)
      write(6,*)"not found, Check the namelist UNDUMAGN in wave.in ***"
      write(6,*)"*** Program WAVE aborted ***"
      stop
 92   continue
      write(lungfo,*)"*** Error in run_undumag: File"
      write(lungfo,*)trim(chundutmp)
      write(lungfo,*)"not found, Check the namelist UNDUMAGN in wave.in ***"
      write(lungfo,*)"*** Program WAVE aborted ***"
      write(6,*)"*** Error in run_undumag: File"
      write(6,*)trim(chundutmp)
      write(6,*)"not found, Check the namelist UNDUMAGN in wave.in ***"
      write(6,*)"*** Program WAVE aborted ***"
      stop

      end
+DECK,util_test_python3,T=F77.
*CMZ :  4.00/17 03/11/2022  12.52.10  by  Michael Scheer
*CMZ :  4.00/07 12/05/2020  09.51.13  by  Michael Scheer
*CMZ :  4.00/04 28/06/2019  12.34.52  by  Michael Scheer
*-- Author : Michael Scheer
! Check python3
      subroutine util_test_python3(chpycom,ifound)

      implicit none

      integer luno,ifound,nfirst,nlast,kstat
      real r(1)

      character(*) chpycom
      character(1024) chpy,cline
      character(16) chran

      if (trim(chpycom).eq.'none') then
        ifound=0
        return
      endif

      call random_number(r)
      write(chran,*)int(r*10**8)
      call  util_string_trim(chran,nfirst,nlast)
      chpy=".testpython3" // chran(nfirst:nlast) // ".py"

      open(newunit=luno,file=trim(chpy))

      write(luno,'(a)') 'import sys'
      write(luno,'(a)') 'sys.exit()'
      flush(luno)
      close(luno)

      if (trim(chpycom).eq.'auto') then
        cline='python3 ' // trim(chpy)
        ifound=system(trim(cline))
        if (ifound.eq.0) then
          ifound=1
          chpycom='python3'
        else
          cline='/usr/bin/python3 ' // trim(chpy)
          ifound=system(trim(cline))
          if (ifound.eq.0) then
            ifound=1
            chpycom='/usr/bin/python3'
          else
            ifound=0
          endif
        endif
      else
        cline=trim(chpycom) // " " // trim(chpy)
        ifound=system(trim(cline))
        if (ifound.eq.0) then
          ifound=1
        else
          ifound=0
        endif
      endif

      call util_file_delete(trim(chpy),kstat)

      return
      end
+DECK,util_guess_platform,T=F77.
*CMZ :  4.00/07 10/05/2020  17.50.18  by  Michael Scheer
*CMZ :  4.00/04 16/05/2019  12.37.48  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine util_guess_platform(chos)

      implicit none

      integer iwin,ianf,iend

      character(*) chos
      character(1024) cshell,csub,chsy,cpath

      call get_environment_variable('OS',chsy)
      call get_environment_variable('SHELL',cshell)
      call get_environment_variable('PATH',cpath)

      chos='UNKNOWN'

      csub="windows"

      call util_lower_case(chsy)
      call util_string_substring(chsy,trim(csub),ianf,iend,iwin)

      print*,iwin

      if (len_trim(cshell).eq.0.and.iwin.eq.0) then
        chos='WINDOWS'
      else if (len_trim(cshell).ne.0.and.iwin.eq.0) then
        chos='CYGWIN'
      else if (len_trim(cshell).ne.0.and.iwin.ne.0) then
        chos='LINUX'
      endif

      return
      end
+DECK,util_get_compiler.
*CMZ :  4.00/04 16/05/2019  14.32.08  by  Michael Scheer
*-- Author :    Michael Scheer   16/05/2019
      subroutine util_get_compiler(chcomp,length)

      use ISO_FORTRAN_ENV

      implicit none

      integer length
      character(*) chcomp
      character (len = :), allocatable :: res

      res=compiler_version()
      chcomp=res
      length=len(res)

      end
+DECK,wave_make_dir,T=F77.
*CMZ :  4.00/17 21/11/2022  15.33.16  by  Michael Scheer
*CMZ :  4.00/11 21/11/2020  11.27.00  by  Michael Scheer
*CMZ :  4.00/04 28/06/2019  13.21.55  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine wave_make_dir(chdir,istat)
      !use waveenv

      implicit none

+seq,waveenv.

      integer luno,istat,kstat,nfirst,nlast,iutil_fexist
      real r(1)

      character(*) chdir
      character(1024) chpy,cline
      character(16) chran

      if (iutil_fexist(trim(chdir)).ne.0) then
        istat=1
        return
      endif

      if (kpython.ne.0) then
        call random_number(r)
        write(chran,*)int(r*10**8)
        call  util_string_trim(chran,nfirst,nlast)
        chpy=".mkdir" // chran(nfirst:nlast) // ".py"
        open(newunit=luno,file=trim(chpy))
        write(luno,'(a)')
     &    'import os'
        write(luno,'(a)')
     &    'if os.path.exists("' // trim(chdir) // '") == False:'
        write(luno,'(a)')
     &    '    os.mkdir("' // trim(chdir) // '");'
        flush(luno)
        close(luno)
        cline=trim(chpythonhome) // chpathsep // trim(chpythoncom) // " " // trim(chpy)
        istat=system(trim(cline))
        call util_file_delete(trim(chpy),kstat)
      else
        istat=system(trim(chmkdir) // " " // trim(chdir))
      endif !kpython

      istat=-1
      if (iutil_fexist(trim(chdir)).ne.0) then
        istat=0
      endif

      return
      end
+DECK,wave_delete_dir,T=F77.
*CMZ :  4.00/17 21/11/2022  15.32.48  by  Michael Scheer
*CMZ :  4.00/11 21/11/2020  11.56.57  by  Michael Scheer
*CMZ :  4.00/04 28/06/2019  13.21.55  by  Michael Scheer
*-- Author : Michael Scheer

! For kempty.ne.0, directory must be empty

      subroutine wave_delete_dir(chdir,kempty,istat)
      !use waveenv

      implicit none

+seq,waveenv.

      integer luno,istat,kstat,nfirst,nlast,iutil_fexist,kempty
      real r(1)

      character(*) chdir
      character(1024) chpy,cline
      character(16) chran

      if (iutil_fexist(trim(chdir)).eq.0) then
        istat=0
        return
      endif

      if (kpython.ne.0) then
        call random_number(r)
        write(chran,*)int(r*10**8)
        call  util_string_trim(chran,nfirst,nlast)
        if (kempty.ne.0) then
          chpy=".rmemptydir" // chran(nfirst:nlast) // ".py"
          open(newunit=luno,file=trim(chpy))
          write(luno,'(a)')
     &      'import os'
          write(luno,'(a)')
     &      'os.rmdir("' // trim(chdir) // '");'
          flush(luno)
          close(luno)
        else
          chpy=".rmtree" // chran(nfirst:nlast) // ".py"
          open(newunit=luno,file=trim(chpy))
          write(luno,'(a)')
     &      'import shutil'
          write(luno,'(a)')
     &      'shutil.rmtree("' // trim(chdir) // '");'
          flush(luno)
          close(luno)
        endif !kempty

        cline=trim(chpythonhome) // chpathsep // trim(chpythoncom) // " " // trim(chpy)
        istat=system(trim(cline))

        call util_file_delete(trim(chpy),kstat)

      else
        if (kempty.eq.0) then
          istat=system(trim(chrmtree) // " " // trim(chdir))
        else
          istat=system(trim(chrmdir) // " " // trim(chdir))
        endif
      endif

        istat=-1
        if (iutil_fexist(trim(chdir)).eq.0) then
        istat=0
      endif

      return
      end
+DECK,wave_copy_file,T=F77.
*CMZ :  4.00/17 28/11/2022  15.02.19  by  Michael Scheer
*CMZ :  4.00/11 21/11/2020  11.38.49  by  Michael Scheer
*CMZ :  4.00/07 27/04/2020  15.32.49  by  Michael Scheer
*CMZ :  4.00/04 28/06/2019  13.30.29  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine wave_copy_file(chsrc,chdest,istat)
      !use waveenv

      implicit none

+seq,waveenv.

      integer luno,istat,nfirst,nlast,kstat,iutil_fexist
      real r(1)

      character(*) chsrc,chdest
      character(1024) chpy,cline
      character(16) chran

      if (iutil_fexist(chsrc).eq.0) then
        print*,""
        print*,"*** Error in wave_copy_file: File not found!"
        print*,"*** " // trim(chsrc)
        print*,""
        stop "*** Program WAVE aborted ***"
      endif

      if (kpython.ne.0) then

        call random_number(r)
        write(chran,*)int(r*10**8)
        call  util_string_trim(chran,nfirst,nlast)

        chpy=".rcopy" // chran(nfirst:nlast) // ".py"
        open(newunit=luno,file=trim(chpy))
        write(luno,'(a)')
     &    'import shutil'
        write(luno,'(a)')
     &    'shutil.copy("'// trim(chsrc) // '","' // trim(chdest) //'");'
        flush(luno)
        close(luno)

        cline=trim(chpythonhome) // chpathsep // trim(chpythoncom) // " " // trim(chpy)
        istat=system(trim(cline))

        call util_file_delete(trim(chpy),kstat)

      else
        call system(
     &    trim(chcpfile) // " " // trim(chsrc) // " " // trim(chdest))
      endif

      return
      end
+DECK,wave_type_file.
*CMZ :  4.00/04 17/05/2019  11.44.11  by  Michael Scheer
*-- Author :    Michael Scheer   17/05/2019
      subroutine wave_type_file(chfile)

      implicit none

      integer lunin

      character(*) chfile
      character(1024) cline

      open(newunit=lunin,file=trim(chfile),status='old',err=999)
      do while (.true.)
        read(lunin,'(a)',end=99,err=99) cline
        print*,trim(cline)
      enddo
99    close(lunin)

999   return
      end
+DECK,wave_print_file.
*CMZ :  4.00/04 17/05/2019  12.18.45  by  Michael Scheer
*-- Author :    Michael Scheer   17/05/2019
      subroutine wave_print_file(luno,chfile)

      implicit none

      integer luno,lunin

      character(*) chfile
      character(1024) cline

      open(newunit=lunin,file=trim(chfile),status='old',err=999)
      do while (.true.)
        read(lunin,'(a)',end=99,err=99) cline
        write(luno,'(a)') trim(cline)
      enddo
99    close(lunin)

999   return
      end
+DECK,wave_move_file,T=F77.
*CMZ :  4.00/17 28/11/2022  15.15.17  by  Michael Scheer
*CMZ :  4.00/04 28/06/2019  13.31.09  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine wave_move_file(chsrc,chdest,istat)
      !use waveenv

      implicit none

+seq,waveenv.

      integer luno,istat,nfirst,nlast,kstat
      real r(1)

      character(*) chsrc,chdest
      character(1024) chpy,cline
      character(16) chran

      if (kpython.ne.0) then

        call random_number(r)
        write(chran,*)int(r*10**8)
        call  util_string_trim(chran,nfirst,nlast)

        chpy=".rcopy" // chran(nfirst:nlast) // ".py"
        open(newunit=luno,file=trim(chpy))
        write(luno,'(a)')
     &    'import shutil'
        write(luno,'(a)')
     &    'shutil.copystat("'// trim(chsrc) // ',' // trim(chdest) //'");'
        flush(luno)
        close(luno)

        cline=trim(chpythonhome) // " " // trim(chpy)
        istat=system(trim(cline))

        call util_file_delete(trim(chpy),kstat)

      else
        call system(
     &    trim(chmvfile) // " " // trim(chsrc) // " " // trim(chdest))
      endif

      return
      end
+DECK,util_fexist.
*CMZ :  4.00/04 01/12/2017  12.08.50  by  Michael Scheer
*-- Author :    Michael Scheer   01/12/2017
      function iutil_fexist(filename)

c +PATCH,//UTIL/FOR
c +DECK,util_fexist.

      integer iutil_fexist
      character(*) filename

      logical lexist

      inquire(file=filename,exist=lexist)

      iutil_fexist=0

      if (lexist.eqv..true.) then
        iutil_fexist=1
      endif

      return
      end
+DECK,wavesystem,T=F77.
*CMZ :  4.00/17 28/11/2022  15.21.16  by  Michael Scheer
*CMZ :  4.00/07 29/05/2020  12.50.49  by  Michael Scheer
*CMZ :  4.00/04 01/07/2019  14.04.23  by  Michael Scheer
*CMZ :  4.00/03 09/05/2019  10.59.58  by  Michael Scheer
*CMZ :  4.00/02 12/04/2019  15.05.49  by  Michael Scheer
*CMZ :  4.00/01 11/04/2019  14.40.23  by  Michael Scheer
*CMZ :  4.00/00 04/04/2019  12.29.10  by  Michael Scheer
*CMZ :  3.08/01 03/04/2019  11.56.15  by  Michael Scheer
*CMZ :  3.07/01 29/03/2019  14.35.23  by  Michael Scheer
*-- Author :    Michael Scheer   27/03/2019
      subroutine wavesystem

      use iso_c_binding
      use iso_fortran_env !, only: int64
      !use waveenv

      implicit none

+seq,gplhint.
+seq,waveenv.

      integer :: nbacksl=0, nslash=0, inam=0,idebsys=0

      integer lunin,iutil_fexist,k1,k2,istat,luns,ipos(2,1000),i,nwords
      character(1024) cline,chos,chsys,chshell,chpath,chtest,chpy
      character c1

      kpython=0
      chpythonhome='/usr/bin'
      chpythoncom='python3'
      chplatform='UNKNOWN'
      chwavepath='auto'
      chrmtree='rm -r -f' ! system command to remove directory tree, even if not empty
      chrmdir='rmdir' ! system command to remove empty directory
      chmvfile='mv' ! system command to move  file
      chrmfile='rm' ! system command to remove file
      chmkdir='mkdir' ! system command to create directory
      chcptree='cp -a' ! system command to copy tree
      chcpfile='cp' ! system command to copy file
      chpathsep='/'     ! path seperator

      chpy=trim(chpythonhome) // chpathsep // trim(chpythoncom)

      if (iutil_fexist('wave_platform.nam').ne.0) then
        inam=1
        open(newunit=lunin,file="wave_platform.nam",status='old')
        read(lunin,platformn)
        close(lunin)
        call util_string_split_sep(chpythonpath,1000,nwords,ipos,chpathsep,istat)
        chpythonhome=chpythonpath(1:ipos(2,nwords-1))
        chpythoncom=chpythonpath(ipos(1,nwords):len_trim(chpythonpath))
        chpythonpath=''
        if (idebsys.ne.0) then
          print*
          print*,"calling util_test_python3:"
          print*,trim(chpythonhome) // chpathsep // trim(chpythoncom),kpython
        endif
        call util_test_python3(trim(chpythonhome) // chpathsep // trim(chpythoncom),kpython)
        if (kpython.eq.0) then
          print*," "
          print*,"--------------------------------------- ---------------------"
          print*,"Python3 seems not to be available..., check wave_platform.nam"
          print*,"-----------------------------------    ----------------------"
          print*," "
        endif
        call util_string_trim(chwavepath,k1,k2)
        cline=chwavepath(k1:k2)
        if (cline.eq.'auto'.or.cline.eq.'AUTO'.or.cline.eq.'') then
          chwavepath=trim(chwavehome) // chpathsep // 'bin'
          call util_string_trim(chwavepath,k1,k2)
          chwavepath=chwavepath(k1:k2)
        endif
      endif

      call get_environment_variable("SHELL", chshell)
      call get_environment_variable("PATH",chpath)
      call get_environment_variable("HOME",chuserhome)
      call get_environment_variable("PYTHONHOME",chpythonhome)
      call get_environment_variable("PYTHONPATH",chpythonpath)

      !if (len_trim(chpythonpath).eq.0) chpythonpath=chpythonhome

      if (idebsys.ne.0) then
        print*
        print*,"chshell:"
        print*,trim(chshell)
        print*,""
        print*,"chpath:"
        print*,trim(chpath)
        print*,""
        print*,"chpythonhome:"
        print*,trim(chpythonhome)
        print*,""
        print*,"chuserhome:"
        print*,trim(chuserhome)
      endif

      do i=1,len_trim(chpath)
        c1=chpath(i:i)
        if (c1.eq.'/') then
          nslash=nslash+1
        else if (c1.eq.'\') then
          nbacksl=nbacksl+1
        endif
      enddo

      if (idebsys.ne.0) then
        print*
        print*,"nbacksl, nslash:",nbacksl,nslash
      endif

      if (nbacksl.gt.nslash) then

        call get_environment_variable("OS", chos)
        chsys=chos

        if (idebsys.ne.0) then
          print*
          print*,"OS:",trim(chos)
        endif

        if (len_trim(chos).gt.0) then
          chplatform='WINDOWS'
          call get_environment_variable("HOMEPATH",chuserhome)
        else
          print*,'Warning in wavesystem: Assumed WINDOWS, but system-variable OS is not set??'
        endif

        chplatform='WINDOWS'
        chpythoncom='python'
        chwavepath='auto'
        chrmtree='rmdir /s /q' ! system command to remove directory tree, even if not empty
        chrmdir='rmdir' ! system command to remove empty directory
        chmvfile='move' ! system command to move  file
        chrmfile='del' ! system command to remove file
        chmkdir='mkdir' ! system command to create directory
        chcptree='xcopy /h' ! system command to copy tree
        chcpfile='copy' ! system command to copy file
        chpathsep='\'     ! path seperator      else

      else !(nbacksl.gt.nslash) then

        istat = system('uname > .wavesystem')

        if (istat.eq.0) then
          open(newunit=luns,file='.wavesystem',status='old')
          read(luns,'(a)') chsys
          close(luns)
          chplatform=chsys(1:5)
          if (chsys(1:5).ne.'MINGW') chplatform='LINUX'
        endif !uname

      endif !(nbacksl.gt.nslash) then

      call hostnm(chhostname)
      if (idebsys.ne.0) then
        print*
        print*,"chhostname:",trim(chhostname)
      endif

      call getcwd(chwavedir)
      chcwd=chwavedir
      chcompiler=compiler_version()

      call getlog(chuser)

      if (inam.eq.0.and.chplatform.ne.'LINUX' .and.
     &    chplatform.ne.'WINDOWS' .and.
     &    chplatform.ne.'MINGW') then
        print*
        print*,'*** Warning in wavesystem: System seems not to be Windows, Linux, or MINGW ***'
        print*,'*** Provide wavesystem.nam or be aware of problems ***'
        print*
      endif !(chplatform.eq.'LINUX') then

      call get_environment_variable("WAVE",chwavehome)

      if (idebsys.ne.0) then
        print*
        print*,"chwavehome:",trim(chwavehome)
        print*,"chplatform:",trim(chplatform)
      endif

      if (len_trim(chwavehome).eq.0) then
        if (idebsys.ne.0) then
          print*,""
          print*,"*** Warning in wavesystem: System variable WAVE not defined ***"
        endif
        call util_string_split_sep(chwavedir,1000,nwords,ipos,chpathsep,istat)
        chtest=chwavedir(1:ipos(2,nwords-1))
        chtest=trim(chtest) // chpathsep // 'bin' // chpathsep // 'wave.exe'
        if (idebsys.ne.0) then
          print*
          print*,"chtest:",trim(chtest)
          print*,"Check wave.exe:",iutil_fexist(trim(chtest))
        endif
        if (iutil_fexist(trim(chtest)).ne.0) then
          chwavehome=chwavedir(1:ipos(2,nwords-1))
          chwavepath=chwavedir(1:ipos(2,nwords-1)) // chpathsep // 'bin'
          if (idebsys.ne.0) then
            print*,"*** Assuming WAVE:", trim(chwavehome)
            print*,"*** Assuming Path:", trim(chwavepath)
          endif
        else
          print*,""
          print*,"*** Warning in wavesystem, could not find: " //
     &      trim(chtest)
          print*,"*** WAVE not properly installed ***"
          print*
        endif
      endif

      if (inam.eq.0.and.len_trim(chpythonhome).eq.0) then

        if (chplatform.eq.'LINUX' .or. chplatform.eq.'MINGW') then

          istat = system('which python3 > .wavesystem')
          open(newunit=luns,file='.wavesystem',status='old')
          read(luns,'(a)') cline
          call util_string_split_sep(cline,1000,nwords,ipos,chpathsep,istat)
          chpythonhome=cline(1:ipos(2,2))
          close(luns)

        else

          call util_string_trim(chwavehome,k1,k2)
          cline=chwavehome(k1:k2) // '\python_home\python.exe'

          if (idebsys.ne.0) then
            print*
            print*,"Check python_home:",trim(cline)
            if (iutil_fexist(cline).ne.0) then
              print*,"Found python.exe in python_home."
            else
              stop "*** python.exe not found in python_home ***"
            endif
          endif

          if (iutil_fexist(cline).ne.0) then
            chpythonhome=chwavepath(k1:k2) // '\python_home\python.exe'
          else
            istat = system('where python')
            if (idebsys.ne.0) then
              print*,"istat after 'where python':",istat
            endif
            if (istat.eq.0) then
              istat = system('where python > .wavesystem')
              if (idebsys.ne.0) then
                print*,"istat after 'where python > .wavesystem':",istat
              endif
              if (istat.eq.0) then
                open(newunit=luns,file='.wavesystem',status='old')
                read(luns,'(a)') chpythonhome
                close(luns)
              endif
            endif
          endif !(iutil_fexist(ch).ne.0) then
        endif !(chplatform.eq.'LINUX') then
      endif !(inam.eq.0) then

      if (len_trim(chpythonhome).gt.0) then

        chpy=trim(chpythonhome) // trim(chpathsep) // trim(chpythoncom)

        if (idebsys.ne.0) then
          print*,""
          print*,"Testing phyton:"
          print*,trim(chpy)
        endif

        call util_test_python3(chpy,kpython)

        if (idebsys.ne.0) then
          print*,""
          print*,"kpython:",kpython
        endif

      else
        kpython=0
      endif !(len_trim(chpythonhome).gt.0) then

      if (kpython.eq.0) then
        print*," "
        print*,"---------------------------------------------------------"
        print*,"*** Warning in wavesystem ***"
        print*
        print*,"Python3 seems not to be available nor wave_platform.nam"
        print*,"---------------------------------------------------------"
        print*," "
      endif

      return
      end
+DECK,util_upper_case.
*CMZ :  4.00/04 28/06/2019  14.45.39  by  Michael Scheer
*CMZ : 00.00/16 13/10/2014  09.07.28  by  Michael Scheer
*-- Author :    Michael Scheer   13/10/2014
      subroutine util_upper_case(cline)

      implicit none

      character(*) cline

      integer i,ic1
      character c1
      equivalence (ic1,c1)

      ic1=0

      do i=1,len_trim(cline)
        c1=cline(i:i)
        if (ic1.ge.97.and.ic1.le.122) ic1=ic1-32
        cline(i:i)=c1
      enddo

      return
      end
+DECK,wave_check_pid,T=F77.
*CMZ :  4.00/17 28/11/2022  15.15.17  by  Michael Scheer
*CMZ :  4.00/11 21/11/2020  12.01.26  by  Michael Scheer
*CMZ :  4.00/07 12/05/2020  13.45.30  by  Michael Scheer
*CMZ :  4.00/04 19/11/2019  17.28.12  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine wave_check_pid(ipid,istat)

      !use waveenv

      implicit none
      integer ipid,istat,nfirst,nlast,luno,kstat
      real r(1)
      character(16) chran, chpid, cstat
      character(1024) chpy,cline,chpyout

+seq,waveenv.

      write(chpid,*) ipid

      if (kpython.ne.0) then
        call random_number(r)
        write(chran,*)int(r*10**8)
        call  util_string_trim(chran,nfirst,nlast)
        chpy=".rcheckpid" // chran(nfirst:nlast) // ".py"
        chpyout=".rcheckpid" // chran(nfirst:nlast) // ".out"
        write(chpid,*) ipid
        open(newunit=luno,file=trim(chpy))
        write(luno,'(a)') 'import psutil'
        write(luno,'(a)') 'fout = open("' // trim(chpyout) // '","w")'
        write(luno,'(a)') 'fout.write(str(psutil.pid_exists(' // trim(chpid) //'))' // '+ "\n")'
        flush(luno)
        close(luno)
        cline=trim(chpythonhome) // chpathsep // trim(chpythoncom) // " " // trim(chpy)
        istat=system(trim(cline))
        open(newunit=luno,file=trim(chpyout))
        read(luno,*) cstat
        close(luno)
        if (cstat.eq.'True') then
          istat = 1
        else
          istat = 0
        endif
        call util_file_delete(trim(chpy),kstat)
        call util_file_delete(trim(chpyout),kstat)
      else
        if (chplatform.eq.'WINDOWS') then
          call util_check_pid_windows(ipid,istat)
        else if (chplatform.eq.'LINUX' .or. chplatform.eq.'MINGW') then
          call util_check_pid_linux(ipid,istat)
        else
          print*,
     &      "*** Warning in wave_check_pid: No python, don't know how to check process ***"
          istat=-1
        endif
      endif

      return
      end
+DECK,util_rnorml,T=F77.
*CMZ :  4.00/07 05/05/2020  21.22.42  by  Michael Scheer
*CMZ :  4.00/05 29/11/2019  12.01.22  by  Michael Scheer
*-- Author :    Michael Scheer   28/08/2014

c Based on RNORML of CERNLIB, call to RANMAR substituted

cmsh Generated with: cpp -E -DCERNLIB_DOUBLE -DCERNLIB_UNIX rnorml.F

# 1 "rnorml.F"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "rnorml.F"
*
* $Id: rnorml.F,v 1.1.1.1 1996/04/01 15:02:55 mclareni Exp $
*
* $Log: rnorml.F,v $
* Revision 1.1.1.1 1996/04/01 15:02:55 mclareni
* Mathlib gen
*
*
# 1 "/usr/include/gen/pilot.h" 1 3 4
# 10 "rnorml.F" 2
      SUBROUTINE util_RNORML(DEVIAS,NDEV)
C Generator of a vector of independent Gaussian-distributed
C (pseudo-)random numbers, of mean zero and variance one,
C making use of a uniform pseudo-random generator (RANMAR).
C The algorithm for converting uniform numbers to Gaussian
C is that of "Ratio of Uniforms with Quadratic Bounds." The
C method is in principle exact (apart from rounding errors),
C and is based on the variant published by Joseph Leva in
C ACM TOMS vol. 18(1992), page 449 for the method and 454 for
C the Fortran algorithm (ACM No. 712).
C It requires at least 2 and on average 2.74 uniform deviates
C per Gaussian (normal) deviate.
C WARNING -- The uniform generator should not produce exact zeroes,
C since the pair (0.0, 0.5) provokes a floating point exception.
      SAVE S, T, A, B, R1, R2
      DIMENSION U(2), DEVIAS(*)
      DATA S, T, A, B / 0.449871, -0.386595, 0.19600, 0.25472/
      DATA R1, R2/ 0.27597, 0.27846/
C generate pair of uniform deviates
      DO 200 IDEV = 1, NDEV
cmsh   50 CALL RANMAR(U,2)
   50 CALL util_random(2,U)
      V = 1.7156 * (U(2) - 0.5)
      X = U(1) - S
      Y = ABS(V) - T
      Q = X**2 + Y*(A*Y - B*X)
C accept P if inside inner ellipse
      IF (Q .LT. R1) GO TO 100
C reject P if outside outer ellipse
      IF (Q .GT. R2) GO TO 50
C reject P if outside acceptance region
      IF (V**2 .GT. -4.0 *ALOG(U(1)) *U(1)**2) GO TO 50
C ratio of P's coordinates is normal deviate
  100 DEVIAT = V/U(1)
cmsh  200 DEVIAS(IDEV) = DEVIAT
      DEVIAS(IDEV) = DEVIAT
 200  continue
      RETURN
      END
+DECK,util_string_substring_igncase.
*CMZ :  4.00/06 05/12/2019  13.07.35  by  Michael Scheer
*CMZ : 00.00/16 19/03/2014  12.14.29  by  Michael Scheer
*CMZ : 00.00/15 03/09/2012  09.29.49  by  Michael Scheer
*CMZ : 00.00/06 08/03/2007  14.02.27  by  Michael Scheer
*CMZ : 00.00/05 07/03/2007  12.58.44  by  Michael Scheer
*-- Author :    Michael Scheer   07/03/2007
      subroutine util_string_substring_igncase(cline,substring,ianf,iend,istat)

c Input:
c      cline, substring

c If substring is passed as variable, full length of substring is checked,
c i.e. pending invisible characters are tested as well

c Output:
c      ianf,iend: start and end position of substring, 0 if not found
c      istat: error, i.e. string not found

c Evtl. besser FORTRAN-functions scan oder index benutzen

      implicit none

      integer ilenl,ilens,istat,ianf,iend,i

      character(*) cline,substring
      character (len = :), allocatable ::  clow,sublow

      istat=-1
      ianf=0
      iend=0

      ilenl=len(cline)
      ilens=len(substring)

      clow=cline
      sublow=substring
      call util_lower_case(clow)
      call util_lower_case(sublow)

      if (ilens.gt.ilenl) return

      do i=1,ilenl-ilens+1
        if (clow(i:i+ilens-1).eq.sublow) then
          ianf=i
          iend=ianf+ilens-1
          istat=0
          return
        endif
      enddo

      return
      end
+DECK,util_fold_gauss_lin.
*CMZ :  4.00/07 06/04/2020  14.51.16  by  Michael Scheer
*CMZ :  3.06/00 18/02/2019  19.28.56  by  Michael Scheer
*CMZ :  2.70/02 14/12/2012  10.35.01  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE util_fold_gauss_lin(NF,XF,F,SIGMA,DNSIGMA,IX,FG,WS1,WS2)
+seq,gplhint.

C--- SUBROUTINE TO EVALUATE THE FOLDED FUNCTION FG=INT{F(XF)*G(XF-X),DXF}

C--   INPUT:

C-       NF:   NUMBER OF XF,F-VALUES
C-       XF:   ARRAY OF X-VALUES (MUST BE IN ASCENDING ORDER)
C-       F: ARRAY OF FUNCTION-VALUES
C-       SIGMA:  SIGMA OF GAUSSIAN
C-       DNSIGMA: NUMBER OF SIGMAS TO BE CONSIDERED
C-       RESULT FG REFERES TO XF(IX)

C--   OUTPUT:

C-       FG:   FG(X0) IS CALCULATED

      IMPLICIT NONE

+SELF,IF=-VMS.
      EXTERNAL FUNCTION DERF
+SELF.

      INTEGER NF,IH,IL,I,ix

      REAL*8 XF(NF),F(NF),SIGMA,X0,FG,DNSIGMA
      REAL*8 WS1(NF),WS2(NF)

      REAL*8 XL,XH,YL,YH,H,
     &  XHXL,XH2,XL2,SN,S2,ROOT2,SNR21,DERF,FGH,FGL,R2PI1,DX,X02,S22,
     &  SQPI2,X02S2,X023S2,SR2PI1,EPS

      DATA ROOT2/1.4142135623731D0/
      DATA R2PI1/0.398942280401433D0/
      DATA SQPI2/1.2533141373155D0/

C- CHECK ASCENDING ORDER

      DO I=2,NF
        IF (XF(I).LE.XF(I-1))
     &    STOP '*** ERROR IN UTIL_FOLD_GAUSS_LIN:
     &    ARRAY XF NOT IN ASCENDING ORDER ***'
      ENDDO

      EPS=(XF(NF)-XF(1))*1.0D-10

      DO IL=1,NF-1

        IH=IL+1

        XL=XF(IL)
        XH=XF(IH)
        YL=F(IL)
        YH=F(IH)

        XHXL=XH*XL
        XH2=XH*XH
        XL2=XL*XL

        H=XH-XL

        IF (H.LE.0.0D0) THEN
          PRINT*,
     &      '*** ERROR SR UTIL_FOLD_GAUSS_LIN:'
          PRINT*,
     &      '*** ARRAY XF NOT IN ASCENDING ORDER'
          STOP
        ENDIF

        WS1(IL)=(XH*YL-XL*YH)/h
        WS2(IL)=(YH-YL)/h

      ENDDO !NF-1

      FG=0.0D0

      SN=DNSIGMA*SIGMA
      S2=SIGMA*SIGMA
      S22=2.0D0*S2
      SNR21=1.0D0/(ROOT2*SIGMA)
      SR2PI1=R2PI1/SIGMA

c      DO I=1,NF

        I=IX

        X0=XF(I)

        X02=X0*X0
        X02S2=S2+X02
        X023S2=S22+X02S2

        IF (X0-SN.GE.XF(1)-EPS.AND.X0+SN.LE.XF(NF)+EPS) THEN

C UPPER BRANCH

          DO IL=I,NF-1

            IH=IL+1

            XL=XF(IL)
            XH=XF(IH)

            IF (XL-X0.LE.SN) THEN

              IF (XH-X0.GT.SN) XH=X0+SN

              DX=XH-X0

              FGH=
     &          SR2PI1*(-EXP(-DX**2/S22)*S2*WS2(IL)
     &          +SQPI2*SIGMA*(WS1(IL)+X0*WS2(IL))*
     &          DERF(DX*SNR21))

              DX=XL-X0

              FGL=
     &          SR2PI1*(-EXP(-DX**2/S22)*S2*WS2(IL)
     &          +SQPI2*SIGMA*(WS1(IL)+X0*WS2(IL))*
     &          DERF(DX*SNR21))

              FG=FG+FGH-FGL

            ELSE
              GOTO 81
            ENDIF ! (X-SN.GE.XF(1).AND.X+SN.LE.XF(NF))

          ENDDO !IL

 81       CONTINUE

C LOWER BRANCH

          DO IH=I,2,-1

            IL=IH-1

            XL=XF(IL)
            XH=XF(IH)

            IF (X0-XH.LE.SN) THEN

              IF (X0-XL.GT.SN) XL=X0-SN

              DX=XH-X0

              FGH=
     &          SR2PI1*(
     &          -EXP(-DX**2/S22)*S2*(
     &          WS2(IL))
     &          +SQPI2*SIGMA*(
     &          WS1(IL)
     &          +X0*(WS2(IL)))*
     &          DERF(DX*SNR21))

              DX=XL-X0

              FGL=
     &          SR2PI1*(
     &          -EXP(-DX**2/S22)*S2*(
     &          WS2(IL))
     &          +SQPI2*SIGMA*(
     &          WS1(IL)
     &          +X0*(WS2(IL)))*
     &          DERF(DX*SNR21))

              FG=FG+FGH-FGL

            ELSE
              GOTO 82
            ENDIF ! (X-SN.GE.XF(1).AND.X+SN.LE.XF(NF))

          ENDDO !IH

 82       CONTINUE

        ELSE IF (X0+SN.GT.XF(NF)) THEN

          GOTO 88

        ENDIF ! (X-SN.GE.XF(1).AND.X+SN.LE.XF(NF))

c      ENDDO !NF

 88   CONTINUE

      RETURN
      END
+DECK,get_zeit.
*CMZ :  4.00/07 27/04/2020  20.39.04  by  Michael Scheer
*CMZ :  3.01/02 25/02/2014  14.52.02  by  Michael Scheer
*CMZ :  2.70/06 07/01/2013  13.42.44  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  13.41.59  by  Michael Scheer
*CMZ :  2.66/20 18/10/2011  08.06.47  by  Michael Scheer
*CMZ :  2.66/18 01/12/2010  10.11.23  by  Michael Scheer
*CMZ :  2.66/13 23/11/2010  09.59.43  by  Michael Scheer
*CMZ :  2.63/00 10/01/2008  12.40.35  by  Michael Scheer
*CMZ :  2.58/01 17/01/2007  10.59.07  by  Michael Scheer
*CMZ :  2.57/04 13/01/2006  11.10.13  by  Michael Scheer
*CMZ :  2.57/03 09/12/2005  11.19.05  by  Michael Scheer
*CMZ :  2.52/15 03/01/2005  15.51.05  by  Michael Scheer
*CMZ :  2.47/22 03/12/2003  10.29.33  by  Michael Scheer
*CMZ :  2.46/02 21/01/2003  16.21.35  by  Michael Scheer
*CMZ :  2.41/09 14/08/2002  17.26.05  by  Michael Scheer
*CMZ :  2.39/00 03/01/2002  12.30.43  by  Michael Scheer
*CMZ :  2.20/01 02/01/2001  11.38.55  by  Michael Scheer
*CMZ :  2.15/00 01/05/2000  11.48.08  by  Michael Scheer
*CMZ :  2.13/04 24/01/2000  17.57.30  by  Michael Scheer
*CMZ :  2.13/00 06/10/99  16.32.34  by  Michael Scheer
*CMZ :  1.03/06 01/07/98  10.29.18  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.57.32  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.41  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE get_zeit(chtime)
+seq,gplhint.

C To determine date and time and write it to logical unit LUN

      IMPLICIT NONE
      character(8) chtime

+seq,datetime.

      CALL date_and_time(dtday,dttime,dtzone,idatetime)
      chtime=dttime(1:2)//':'//dttime(3:4)//':'//dttime(5:6)

      RETURN
      END
+DECK,bundugap.
*CMZ :  4.01/02 02/05/2023  14.50.26  by  Michael Scheer
*CMZ :  4.00/11 27/03/2021  12.33.38  by  Michael Scheer
*CMZ :  4.00/07 06/05/2020  14.51.17  by  Michael Scheer
*-- Author :    Michael Scheer   05/05/2020
      subroutine bundugap(xin,yin,zin,bxout,byout,bzout,axout,ayout,azout,kini)

! Calculates Beff according to NIM A 60711 of Johannes Bahrdt and Efim Gluskin
! and uses it for the field model of subroutine bhalbasy2

      implicit none

+seq,contrl.
+seq,undugap.
+seq,phycon.

      integer kini,nundugappol
      integer :: ical=0,lung

      double precision x,y,z,bx,by,bz,ax,ay,az,r,beff,
     &  xin,yin,zin,bxout,byout,bzout,axout,ayout,azout,
     &  zkz,yky,xkx,x2,dsnzkz,dsnxkx,dshyky,dcszkz,dcsxkx,dchyky,
     &  xlundugap2,xkundugap2,bxh,byh,bzh,axh,ayh,azh,ahwmod,xl,yl,zl,
     &  ylundugap2,ykundugap2,zl2,
     &  zlundugap2,zkundugap2,poll,overhang,polwid,polhig

      double precision wlen1,totlen,totlen2,park,eharm1

      double precision atilde,btilde,ctilde,dtilde
      parameter (atilde=5.939, btilde=-11.883, ctilde=16.354,dtilde=-8.550) ! Eq. 5

      save

C--- K-VALUES

      if (kini.gt.0) ical=0

      if (ical.eq.0) then

        if (zlundugap.le.0.0d0) then
          write(lungfo,*)""
          write(lungfo,*)"*** error in bundugap: zero or negative period-lenght ***"
          write(lungfo,*)""
          write(lungfo,*)"*** Program WAVE aborted ***"
          print*,""
          print*,"*** Error in bundugap: Zero or negative period-lenght ***"
          print*,""
          print*,"*** Program WAVE aborted ***"
          stop
        endif

        r = undufullgap/zlundugap

        Beff = undugapa * exp(undugapb*r+undugapc*r*r)
        Poll = undufullgap * atilde * exp(r*(btilde+r*(ctilde+dtilde*r)))
        PolWid = 0.040 * r * 3.0
        PolHig = 0.030 * r * 3.0
        Overhang = 0.005 * r * 3.0

        xl = xlundugap
        yl = ylundugap
        zl = zlundugap

C--- K-VALUES

        XKundugap=0.0D0
        YKundugap=0.0D0
        ZKundugap=0.0D0

        IF (Zl.NE.0.0D0) ZKundugap=2.0d0*PI1/Zl
        IF (Yl.NE.0.0D0) YKundugap=2.0d0*PI1/Yl
        IF (Xl.NE.0.0D0) XKundugap=2.0d0*PI1/Xl

C--- ADJUST K-VALUES

        YKundugap=DSQRT(ZKundugap**2+XKundugap**2)
        Yl=2.0d0*PI1/YKundugap

C--- BENDING RADIUS AND DEVICE LENGTH

        PARK=ECHARGE1*DABS(beff)*Zl/(2.*PI1*EMASSKG1*CLIGHT1)
        WLEN1=(1+PARK**2/2.)/2./DMYGAMMA**2*Zl*1.0d9

        TOTLEN=Zl*((undugappol-1.0D0)/2.0D0+1.0D0)
        TOTLEN2=TOTLEN/2.0D0

        IF (WLEN1.NE.0.00) EHARM1=WTOE1/WLEN1

        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     Parameters of undulator model based on Beff(Gap) - Fit:'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)
     &    '     Fit parameters:  ',SNGL(undugapa),sngl(undugapb),sngl(undugapc)
        WRITE(LUNGFO,*)
     &    '     Full Gap and pol-length [mm]:  ',sngl(undufullgap*1000.), sngl(Poll*1000.)
        WRITE(LUNGFO,*)
     &    '     Pol-width and -height [mm]:  ',sngl(PolWid*1000.),sngl(PolHig*1000.)
        WRITE(LUNGFO,*)
     &    '     Overhang of magnets [mm]:  ',sngl(Overhang*1000.)
        WRITE(LUNGFO,*)
     &    '     Width and height of  magnets [mm]:  ',
     &    sngl(polwid+2.0d0*Overhang*1000.),
     &    sngl(polhig+Overhang*1000.)
        WRITE(LUNGFO,*)
     &    '     l0, l0x, l0y [mm]: ',
     &    SNGL(Zlundugap*1000.),SNGL(Xlundugap*1000.),SNGL(Ylundugap*1000.)
        WRITE(LUNGFO,*)
     &    '     Beff [T] and deflection parameter K: ',sngl(beff),sngl(park)
        WRITE(LUNGFO,*)
     &    '     wavelength [nm] and energy of first harmonic: ',sngl(wlen1),sngl(eharm1)

        write(lungfo,*)

        open(newunit=lung,file='bundugap.par')
        write(lung,*)"   UMAGLY_H=",sngl((polhig+overhang)*1000.0d0)
        write(lung,*)"   UMAGLZ_H=",sngl((polwid+2.0d0*overhang)*1000.0d0)
        write(lung,*)"   UPOLLY_H=",sngl((polhig*1000.0d0))
        write(lung,*)"   UPOLLZ_H=",sngl((polwid*1000.0d0))
        close(lung)

        ical=1
      endif !ical

      Nundugappol=undugappol
      AHWMOD=-ISIGN(1,-(MOD(Nundugappol,4)-2))/2.0d0

      X=XIN

      IF (DABS(XIN).GT.TOTLEN2) THEN
        BXOUT=0.0d0
        BYOUT=0.0d0
        BZOUT=0.0d0
        AXOUT=0.0d0
        AYOUT=0.0d0
        AZOUT=0.0d0
        RETURN
      ENDIF

      IF (DABS(X).LE.TOTLEN2-Zl/2.0d0) THEN

        XKX=XKundugap*(-ZIN)
        YKY=YKundugap*YIN
        ZKZ=ZKundugap*X

        DSNXKX=DSIN(XKX)
        DCSXKX=DCOS(XKX)
        DSHYKY=DSINH(YKY)
        DCHYKY=DSQRT(1.0d0+DSHYKY*DSHYKY)
        DSNZKZ=DSIN(ZKZ)
        DCSZKZ=DCOS(ZKZ)

        BXH=-XKundugap/YKundugap*beff*DSNXKX*DSHYKY*DCSZKZ
        BYH=                 beff*DCSXKX*DCHYKY*DCSZKZ
        BZH=-ZKundugap/YKundugap*beff*DCSXKX*DSHYKY*DSNZKZ

        AXH=beff/ZKundugap*                    DCSXKX*DCHYKY*DSNZKZ
        AYH=beff/ZKundugap*XKundugap/YKundugap*DSNXKX*DSHYKY*DSNZKZ
        AZH=0.0d0

        BZOUT=-BXH
        BYOUT=BYH
        BXOUT=BZH

        AZOUT=-AXH
        AYOUT=AYH
        AXOUT=AZH

        RETURN

      ELSE

        XKundugap2=XKundugap

        ZKundugap2=ZKundugap
        Zl2=2.0d0*PI1/ZKundugap2
        YKundugap2=DSQRT(ZKundugap2**2+XKundugap2**2)
        Yl=2.0d0*PI1/YKundugap2

        X2=X+TOTLEN2+Zl/2.0d0

        XKX=XKundugap2*(-ZIN)
        YKY=YKundugap2*YIN
        ZKZ=ZKundugap2*(X2)

        DSNXKX=DSIN(XKX)
        DCSXKX=DCOS(XKX)
        DSHYKY=DSINH(YKY)
        DCHYKY=DSQRT(1.0d0+DSHYKY*DSHYKY)
        DSNZKZ=DSIN(ZKZ)
        DCSZKZ=DCOS(ZKZ)

        BXH=-XKundugap2/YKundugap2*beff*DSNXKX*DSHYKY*DCSZKZ
        BYH=                 beff*DCSXKX*DCHYKY*DCSZKZ
        BZH=-ZKundugap2/YKundugap2*beff*DCSXKX*DSHYKY*DSNZKZ

        AXH=beff/ZKundugap2*                    DCSXKX*DCHYKY*DSNZKZ
        AYH=beff/ZKundugap2*XKundugap2/YKundugap2*DSNXKX*DSHYKY*DSNZKZ
        AZH=0.0d0

        ZKundugap2=ZKundugap*2.0d0
        Zl2=2.0d0*PI1/ZKundugap2
        YKundugap2=DSQRT(ZKundugap2**2+XKundugap2**2)
        Yl=2.0d0*PI1/YKundugap2

        XKX=XKundugap2*(-ZIN)
        YKY=YKundugap2*YIN
        ZKZ=ZKundugap2*(X2)

        DSNXKX=DSIN(XKX)
        DCSXKX=DCOS(XKX)
        DSHYKY=DSINH(YKY)
        DCHYKY=DSQRT(1.0d0+DSHYKY*DSHYKY)
        DSNZKZ=DSIN(ZKZ)
        DCSZKZ=DCOS(ZKZ)

        BXH=BXH-XKundugap2/YKundugap2*beff*DSNXKX*DSHYKY*DCSZKZ
        BYH=BYH+                      beff*DCSXKX*DCHYKY*DCSZKZ
        BZH=BZH-ZKundugap2/YKundugap2*beff*DCSXKX*DSHYKY*DSNZKZ

        AXH=AXH+beff/ZKundugap2*                    DCSXKX*DCHYKY*DSNZKZ
        AYH=AYH+beff/ZKundugap2*XKundugap2/YKundugap2*DSNXKX*DSHYKY*DSNZKZ
        AZH=0.0d0

        BZOUT=BXH*AHWMOD
        BYOUT=-BYH*AHWMOD
        BXOUT=-BZH*AHWMOD

        AZOUT=AXH*AHWMOD
        AYOUT=-AYH*AHWMOD
        AXOUT=-AZH*AHWMOD
      endif

      return
      end subroutine bundugap
+DECK,util_string_split_sep.
*CMZ :  4.00/11 07/07/2021  15.28.57  by  Michael Scheer
*CMZ : 00.00/06 07/03/2007  17.00.51  by  Michael Scheer
*CMZ : 00.00/05 07/03/2007  12.58.44  by  Michael Scheer
*-- Author :    Michael Scheer   07/03/2007
      subroutine util_string_split_sep(cline,ndim,nwords,ipos,chsep,istat)

c Input:
c      cline
c      ndim: max. number of words
c      chsep: Seperator

c Output:
c      nwords: number of words
c      ipos(1:2,iword): start and end position of word in cline

      implicit none

      integer ilen,istat,jx,nwords,ndim,ipos(2,ndim),ic,isep,in

      character(*) cline
      character c1,chsep

      equivalence(c1,ic)

      istat=-1

      ilen=len_trim(cline)

      in=0
      nwords=0

      ipos=0

      if (ilen.eq.0) return

      do jx=1,ilen

        c1=cline(jx:jx)

        if (c1.eq.chsep) then
          isep=1
        else
          isep=0
        endif

        if (isep.eq.1) then

          if (in.eq.1) then
c found end of word
c 4.6.2021             if (jx.lt.ilen) then
            ipos(2,nwords)=jx-1
c 4.6.2021             else
c 4.6.2021               ipos(2,nwords)=jx
c 4.6.2021             endif
            in=0
          endif

        else !isep

          if (in.eq.0) then
c found beginning of word
            nwords=nwords+1
            if (nwords.gt.ndim) return
            ipos(1,nwords)=jx
            ipos(2,nwords)=ilen
            in=1
          endif

        endif !isep

      enddo

      if (ipos(1,nwords).ne.0.and.ipos(2,nwords).eq.0) then
        ipos(2,nwords)=len_trim(cline)
      endif

      if (nwords.gt.0) istat=0

      return
      end
+DECK,util_check_pid_linux,T=F77.
*CMZ :  4.00/07 12/05/2020  13.53.23  by  Michael Scheer
*CMZ :  4.00/04 19/11/2019  17.28.12  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine util_check_pid_linux(pid,istat)

      implicit none

      integer pid,istat,nfirst,nlast,luno,kstat,lpid,ifound,i
      real r(1)
      character(16) chran, chpid, cstat
      character(1024) chpy,cline,chpyout

      write(chpid,*) pid
      call  util_string_trim(chpid,nfirst,nlast)
      chpid=chpid(nfirst:nlast)
      lpid = nlast-nfirst+1

      call random_number(r)
      write(chran,*)int(r*10**8)
      call  util_string_trim(chran,nfirst,nlast)
      chpy=".w" // chran(nfirst:nlast) // ".pid"
      istat = system("ps -a > " // trim(chpy))
      if (istat.ne.0) then
        istat = -1
        return
      endif
      open(newunit=luno,file=trim(chpy))
      ifound=0
      do while (.true.)
        read(luno,*,end=91) cstat
        call  util_string_trim(cstat,nfirst,nlast)
        cstat=cstat(nfirst:nlast)
        do i=1,16
          if (cstat(i:i).eq.' ') exit
        enddo
        if (cstat(1:i-1) .eq. chpid(1:lpid)) then
          ifound=1
          exit
        endif
      enddo

 91   close(luno)

      istat = system("rm " // trim(chpy))
      if (istat.ne.0) then
        istat = -1
        return
      endif

      istat=ifound

      return
      end
+DECK,util_check_pid_windows,T=F77.
*CMZ :  4.00/07 12/05/2020  13.52.08  by  Michael Scheer
*CMZ :  4.00/04 19/11/2019  17.28.12  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine util_check_pid_windows(pid,istat)

      implicit none

      integer pid,istat,nfirst,nlast,luno,kstat,lpid,ifound,i
      real r(1)
      character(16) chran, chpid, cstat
      character(1024) chpy,cline,chpyout

      write(chpid,*) pid
      call  util_string_trim(chpid,nfirst,nlast)
      chpid=chpid(nfirst:nlast)
      lpid = nlast-nfirst+1

      call random_number(r)
      write(chran,*)int(r*10**8)
      call  util_string_trim(chran,nfirst,nlast)
      chpy=".w" // chran(nfirst:nlast) // ".pid"
      istat = system('tasklist /nh /fi "pid eq "' // trim(chpid) // '" > ' // trim(chpy))
      if (istat.ne.0) then
        istat = -1
        return
      endif
      open(newunit=luno,file=trim(chpy))
      ifound=0
      do while (.true.)
        read(luno,*,end=91) cstat
        call  util_string_trim(cstat,nfirst,nlast)
        cstat=cstat(nfirst:nlast)
        do i=1,16
          if (cstat(i:i).eq.' ') exit
        enddo
        if (cstat(1:i-1) .eq. chpid(1:lpid)) then
          ifound=1
          exit
        endif
      enddo

 91   close(luno)

      istat = system("rm " // trim(chpy))
      if (istat.ne.0) then
        istat = -1
        return
      endif

      istat=ifound

      return
      end
+DECK,wavesystemcheck,T=F77.
*CMZ :  4.01/00 14/03/2023  11.10.53  by  Michael Scheer
*CMZ :  4.00/17 28/11/2022  15.21.16  by  Michael Scheer
*CMZ :  4.00/07 29/05/2020  12.52.31  by  Michael Scheer
*CMZ :  4.00/04 01/07/2019  14.04.23  by  Michael Scheer
*CMZ :  4.00/03 09/05/2019  10.59.58  by  Michael Scheer
*CMZ :  4.00/02 12/04/2019  15.05.49  by  Michael Scheer
*CMZ :  4.00/01 11/04/2019  14.40.23  by  Michael Scheer
*CMZ :  4.00/00 04/04/2019  12.29.10  by  Michael Scheer
*CMZ :  3.08/01 03/04/2019  11.56.15  by  Michael Scheer
*CMZ :  3.07/01 29/03/2019  14.35.23  by  Michael Scheer
*-- Author :    Michael Scheer   27/03/2019
      subroutine wavesystemcheck

      use iso_c_binding
      use iso_fortran_env !, only: int64
      !use waveenv

      implicit none

+seq,gplhint.
+seq,waveenv.

      integer :: nbacksl=0, nslash=0, inam=0

      integer lunin,iutil_fexist,k1,k2,istat,luns,ipos(2,1000),i,nwords
      character(1024) cline,chos,chsys,chshell,chpath,chtest,chpy
      character c1

      kpython=0

      chpythonhome='/usr/bin'
      chpythoncom='python3'
      chplatform='UNKNOWN'
      chwavepath='auto'
      chrmtree='rm -r -f' ! system command to remove directory tree, even if not empty
      chrmdir='rmdir' ! system command to remove empty directory
      chmvfile='mv' ! system command to move  file
      chrmfile='rm' ! system command to remove file
      chmkdir='mkdir' ! system command to create directory
      chcptree='cp -a' ! system command to copy tree
      chcpfile='cp' ! system command to copy file
      chpathsep='/'     ! path seperator

      chpy=trim(chpythonhome) // chpathsep // trim(chpythoncom)

      print*,""
      print*,"-- Checking wave_platform.nam --"
      print*,""

      if (iutil_fexist('wave_platform.nam').ne.0) then
        print*,"-- wave_platform.nam found --"
        print*,"-- Reading namelist PLATFORMN --"
        inam=1
        open(newunit=lunin,file="wave_platform.nam",status='old')
        read(lunin,platformn)
        close(lunin)
        call util_string_split_sep(chpythonpath,1000,nwords,ipos,chpathsep,istat)
        chpythonhome=chpythonpath(1:ipos(2,nwords-1))
        chpythoncom=chpythonpath(ipos(1,nwords):len_trim(chpythonpath))
        chpythonpath=''
        print*,"  Python home: ",trim(chpythonhome)
        print*,"  File seperator: ",trim(chpathsep)
        print*,"  Python command: ",trim(chpythoncom)
        print*,""
        print*,"-- Testing Python --"

        call util_test_python3(trim(chpythonhome) // chpathsep // trim(chpythoncom),kpython)

        if (kpython.eq.0) then
          print*," "
          print*,"--------------------------------------- ---------------------"
          print*,"Python3 seems not to be available..., check wave_platform.nam"
          print*,"-----------------------------------    ----------------------"
          print*," "
        endif

        call util_string_trim(chwavepath,k1,k2)
        cline=chwavepath(k1:k2)

        if (cline.eq.'auto'.or.cline.eq.'AUTO'.or.cline.eq.'') then
          chwavepath=trim(chwavehome) // chpathsep // 'bin'
          call util_string_trim(chwavepath,k1,k2)
          chwavepath=chwavepath(k1:k2)
        endif
      else
        print*,"-- wave_platform.nam not found --"
        print*,"-- Will try to guess system -- "
      endif

      print*,""
      print*,"-- Checking SHELL, PATH, and HOME ---"

      call get_environment_variable("SHELL", chshell)
      call get_environment_variable("PATH",chpath)
      call get_environment_variable("HOME",chuserhome)

      print*,""
      print*,"  - Shell is: "
      print*,trim(chshell)
      print*,""
      print*,"  - Path is: "
      print*,trim(chpath)
      print*,""
      print*,"  - Home is: "
      print*,trim(chuserhome)
      print*,""

      do i=1,len_trim(chpath)
        c1=chpath(i:i)
        if (c1.eq.'/') then
          nslash=nslash+1
        else if (c1.eq.'\') then
          nbacksl=nbacksl+1
        endif
      enddo

      if (nbacksl.gt.nslash) then
        print*,"-- Found more backslashes then slashes in PATH, guess WINDOWS system --"
        print*,""

        call get_environment_variable("OS", chos)
        chsys=chos

        if (len_trim(chos).gt.0) then
          chplatform='WINDOWS'
          call get_environment_variable("HOMEPATH",chuserhome)
        else
          print*,'Warning in wavesystemcheck: Assumed WINDOWS, but system-variable OS is not set??'
        endif

        chplatform='WINDOWS'
        chpythonhome=''
        chpythoncom='python'
        chwavepath='auto'
        chrmtree='rmdir /s /q' ! system command to remove directory tree, even if not empty
        chrmdir='rmdir' ! system command to remove empty directory
        chmvfile='move' ! system command to move  file
        chrmfile='del' ! system command to remove file
        chmkdir='mkdir' ! system command to create directory
        chcptree='xcopy /h' ! system command to copy tree
        chcpfile='copy' ! system command to copy file
        chpathsep='\'     ! path seperator      else

      else

        print*,"-- Found less backslashes then slashes in PATH, guess LINUX like system --"

        print*,"-- Will now execute 'uname > .wavesystem' --"
        print*,""

        istat = system('uname > .wavesystem')

        if (istat.eq.0) then
          open(newunit=luns,file='.wavesystem',status='old')
          read(luns,'(a)') chsys
          close(luns)
          chplatform=chsys(1:5)
          if (chsys(1:5).ne.'MINGW') chplatform='LINUX'
        endif !uname

      endif !(nbacksl.gt.nslash) then

      print*,""
      print*,"-- System is " // trim(chplatform) // " --"

      call hostnm(chhostname)
      call getcwd(chwavedir)

      chcwd=chwavedir
      chcompiler=compiler_version()

      call getlog(chuser)

      if (inam.eq.0.and.chplatform.ne.'LINUX' .and.
     &    chplatform.ne.'WINDOWS' .and.
     &    chplatform.ne.'MINGW') then
        print*
        print*,'*** Warning in wavesystemcheck: System seems not to be Windows, Linux, or MINGW ***'
        print*,'*** Provide wavesystem.nam or be aware of problems ***'
        print*
      endif !(chplatform.eq.'LINUX') then

      call get_environment_variable("WAVE",chwavehome)

      if (len_trim(chwavehome).eq.0) then
        call util_string_split_sep(chwavedir,1000,nwords,ipos,chpathsep,istat)
        chtest=chwavedir(1:ipos(2,nwords-1))
        chtest=trim(chtest) // chpathsep // 'bin' // chpathsep // 'wave.exe'
        if (iutil_fexist(trim(chtest)).ne.0) then
          chwavehome=chwavedir(1:ipos(2,nwords-1))
        else
          print*,""
          print*,"*** Warning in wavesystemcheck, could not find: " //
     &      trim(chtest)
          print*,"*** WAVE not properly installed ***"
          print*
        endif
      endif

      print*,""
      if (inam.eq.0) then

        if (chplatform.eq.'LINUX' .or. chplatform.eq.'MINGW') then
          print*,"-- Trying to find python3 path using command 'which' --"
          istat = system('which python3 > .wavesystem')
          open(newunit=luns,file='.wavesystem',status='old')
          read(luns,'(a)') chpythonpath
          close(luns)
        else
          print*,"-- Trying to find python3 path using command 'where' --"
          istat = system('where python')
          if (istat.eq.0) then
            istat = system('where python > .wavesystem')
            if (istat.eq.0) then
              open(newunit=luns,file='.wavesystem',status='old')
              read(luns,'(a)') chpythonpath
              close(luns)
            endif
          endif
        endif !(chplatform.eq.'LINUX') then

        call util_test_python3(chpythonpath,kpython)
        chtest=chpythonpath
        call util_string_split_sep(chtest,1000,nwords,ipos,chpathsep,istat)
        chpythonhome=chpathsep // chtest(ipos(1,1):ipos(2,nwords-1))
        chpythoncom=chtest(ipos(1,nwords):ipos(2,nwords))

      endif

      if (kpython.eq.0.and.inam.eq.0) then
        print*," "
        print*,"---------------------------------------------------------"
        print*,"*** Warning in wavesystemcheck ***"
        print*
        print*,"Python3 seems not to be available nor wave_platform.nam"
        print*,"---------------------------------------------------------"
        print*," "
      else
        print*,""
        print*,"-- Python command is: " // trim(chpythoncom)
      endif

      return
      end
+DECK,UTIL_STRING_SPLIT_POS_1.
*CMZ :  4.00/07 04/06/2020  09.56.14  by  Michael Scheer
*CMZ : 00.00/06 07/03/2007  17.00.51  by  Michael Scheer
*CMZ : 00.00/05 07/03/2007  12.58.44  by  Michael Scheer
*-- Author :    Michael Scheer   07/03/2007
      subroutine util_string_split_pos_1(cline,ipos,chsep,istat)

c Input:
c      cline, chsep

c Output:
c      ipos: First position of chsep in cline

      implicit none

      integer istat,ipos,jx

      character(*) cline
      character chsep

      istat=-1
      ipos=-1

      do jx=1,len_trim(cline)
        if (cline(jx:jx).eq.chsep) then
          ipos=jx
          istat=0
          exit
        endif
      enddo

      return
      end
+DECK,btap.
*CMZ :  4.00/07 10/07/2020  09.20.19  by  Michael Scheer
*CMZ :  4.00/03 07/05/2019  14.24.38  by  Michael Scheer
*CMZ :  3.05/23 23/11/2018  18.01.47  by  Michael Scheer
*CMZ :  3.04/00 19/01/2018  13.23.56  by  Michael Scheer
*CMZ :  3.03/02 16/02/2017  13.03.18  by  Michael Scheer
*CMZ :  3.01/04 09/05/2014  14.31.02  by  Michael Scheer
*CMZ :  3.01/03 20/03/2014  13.03.02  by  Michael Scheer
*CMZ :  2.63/02 24/01/2008  15.24.28  by  Michael Scheer
*CMZ :  2.52/11 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.52/09 29/10/2004  12.30.03  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  2.13/10 25/03/2000  14.36.30  by  Michael Scheer
*CMZ :  2.13/11 22/03/2000  13.00.11  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.25.04  by  Michael Scheer
*CMZ :  2.13/00 03/12/99  16.05.55  by  Michael Scheer
*CMZ :  2.11/00 10/05/99  17.40.30  by  Michael Scheer
*CMZ :  1.04/00 25/11/98  14.08.28  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  15.07.21  by  Michael Scheer
*CMZ : 00.02/05 03/03/97  12.25.12  by  Michael Scheer
*CMZ : 00.01/12 15/10/96  12.15.47  by  Michael Scheer
*CMZ : 00.01/02 24/11/94  15.56.48  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.48.39  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.35  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BTAP(X,Y,Z,BX,BY,BZ,AX,AY,AZ)
+seq,gplhint.

      IMPLICIT NONE

      INTEGER ISYM,ICAL,I,NPOINT,IWARNY,IWARN,IMONO,ifaili,ieof,ifaile,lunt
+self,if=btabparab.
      INTEGER ILOW,IHIGH
+self.

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.

      DOUBLE PRECISION XA(NBTABP),BYA(NBTABP),Y2A(NBTABP)
      DOUBLE PRECISION XSCALE,BYSCALE,X,Y,Z,BX,BY,BZ,TOTLEN,TOTLEN2
      DOUBLE PRECISION AX,AY,AZ,apl,aph,x0l,x0h,xx,bb
+self,if=btabparab.
      DOUBLE PRECISION AL(3),AH(3)
+self.

      CHARACTER(60) BTAPCOM

+self,if=btabparab.
      DATA ILOW/0/
      DATA IHIGH/0/
+self.
      DATA ISYM/0/,ICAL/0/
      DATA IWARN/0/

      save

      IF (ICAL.NE.1) THEN

        ical=1
        IWARNY=0

        OPEN (newUNIT=lunt,FILE = FILEFTV,STATUS = 'OLD',FORM = 'FORMATTED')

        call util_skip_comment_end(lunt,ieof)
        READ(lunt,'(1A60)') BTAPCOM
        call util_skip_comment_end(lunt,ieof)
        READ(lunt,*) XSCALE,BYSCALE

        npoint=0

1       continue
        call util_skip_comment_end(lunt,ieof)
        if (ieof.ne.0) goto 9
        READ(lunt,*,end=9) xx,bb
        npoint=npoint+1
        IF (NPOINT.GT.NBTABP) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN BTAP ***'
          WRITE(LUNGFO,*)'DIMENSION EXCEEDED, INCREASE NBTABP***'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN BTAP ***'
          WRITE(6,*)'DIMENSION EXCEEDED, INCREASE NBTABP***'
          WRITE(6,*)
          STOP
        ENDIF

        xa(npoint)=xx
        bya(npoint)=bb
        goto 1
9       close(lunt)

        IF (ABS(NPOINT).LT.2) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN BTAP ***'
          WRITE(LUNGFO,*)
     &      'LESS THAN TWO POINTS ON DATA FILE OF MAGNETIC FIELD'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN BTAP ***'
          WRITE(6,*)'LESS THAN TWO POINTS ON DATA FILE OF MAGNETIC FIELD'
          WRITE(6,*)
          STOP
        ENDIF

        IF (NPOINT.GT.0.AND.NPOINT.LT.3) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN BTAP ***'
          WRITE(LUNGFO,*)
     &      'LESS THAN THREE POINTS ON DATA FILE OF MAGNETIC FIELD'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN BTAP ***'
          WRITE(6,*)'LESS THAN THREE POINTS ON DATA FILE OF MAGNETIC FIELD'
          WRITE(6,*)
        ENDIF

        call util_parabola_to_zero(xa(1:2),bya(1:2),apl,x0l,ifaili)
        call util_parabola_to_zero(xa(npoint-1:npoint),bya(npoint-1:npoint),
     &    aph,x0h,ifaile)

        call util_sort_func(npoint,xa,bya)

        CALL UTIL_CHECK_MONOTON(NPOINT,XA,IMONO)
        IF (ABS(IMONO).NE.2) THEN
          PRINT *,'*** ERROR IN BTAP: Field data not monoton'
          WRITE(LUNGFO,*)'*** ERROR IN BTAP: FIELD DATA NOT MONOTON'
          STOP '*** Program WAVE aborted'
        ENDIF

        WRITE (LUNGFO,*)
        WRITE (LUNGFO,*)'     Subroutine BTAP: Magnetic field data read from file'
        WRITE (LUNGFO,*)'     ',fileftv
        WRITE (LUNGFO,*)
        WRITE (LUNGFO,*)'     BTAP comment:',BTAPCOM
        WRITE (LUNGFO,*)

        CALL SPLINETB(XA,BYA,NPOINT,0.D0,0.D0,Y2A)

      ENDIF !(ICAL)

      IF(Y.NE.0..AND.IWARNY.EQ.0) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING SR BTAP ***'
        WRITE(LUNGFO,*)'Y-COORDINATE OF ELECTRON NOT ZERO'
        WRITE(LUNGFO,*)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING SR BTAP ***'
        WRITE(6,*)'Y-COORDINATE OF ELECTRON NOT ZERO'
        WRITE(6,*)
        IWARNY=1
      ENDIF

      IF(IWARN.EQ.0.AND.
     &    (X.LT.XA(1)-1./MYINUM.OR.X.GT.XA(NPOINT)+1./MYINUM)) THEN
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'*** WARNING IN BTAP ***'
        WRITE(LUNGFO,*)'X MORE THAN ONE STEP OUT OF TABLE'
        WRITE(LUNGFO,*)
        WRITE(LUNGFO,*)'X, XMIN, XMAX:'
        WRITE(LUNGFO,*)X,XA(1),XA(NPOINT)
        WRITE(6,*)
        WRITE(6,*)'*** WARNING IN BTAP ***'
        WRITE(6,*)'X MORE THAN ONE STEP OUT OF TABLE'
        WRITE(6,*)
        WRITE(6,*)'X, XMIN, XMAX:'
        WRITE(6,*)X,XA(1),XA(NPOINT)
+self,if=btabparab.
        print*,'Field and vector potential extrapolated form parabola'
+self,if=-btabparab.
        print*,'Field and vector potential smoothed to zero'
+self.
        IWARN=1
      ENDIF

      IF(X.LT.XA(1)) THEN
+self,if=btabparab.
        IF (ILOW.NE.1) THEN
          CALL PARABEL(XA(1),BYA(1),XA(2),BYA(2),XA(3),BYA(3),AL)
          ILOW=1
        ENDIF   ! ILOW

        BX=0.
        BY=AL(1)+AL(2)*X+AL(3)*X*X
        BZ=0.

        AX=0.5*BY*Z
        AY=0.0
        AZ=-0.5*BY*X
+self,if=-btabparab.
        BX=0.0D0
        BZ=0.0D0
        if (x.lt.x0l.or.ifaili.ne.0) then
          if (ifaili.eq.-1) then
            print*,"*** WARNING IN BTAP: Failed to find extrapolation parabola at intrance"
            ifaili=-2
          endif
          BY=0.0D0
        else
          by=apl*(x-x0l)**2
        endif
        AX=0.5*BY*Z
        AY=0.0
        AZ=-0.5*BY*X
+self.
        RETURN
      ENDIF !X.LT.XA(1)

      IF(X.GT.XA(NPOINT)) THEN
+self,if=btabparab.
        IF (IHIGH.NE.1) THEN
          CALL PARABEL(XA(NPOINT-2),BYA(NPOINT-2)
     &      ,XA(NPOINT-1),BYA(NPOINT-1)
     &      ,XA(NPOINT)  ,BYA(NPOINT)  ,AH)
          IHIGH=1
        ENDIF   ! IHIGH

        BX=0.
        BY=AH(1)+AH(2)*X+AH(3)*X*X
        BZ=0.

        AX=0.5*BY*Z
        AY=0.0
        AZ=-0.5*BY*X

+self,if=-btabparab.
        BX=0.0D0
        BZ=0.0D0
        if (x.gt.x0h.or.ifaile.ne.0) then
          if (ifaile.eq.-1) then
            print*,"*** WARNING IN BTAP: Failed to find extrapolation parabola at exit"
            ifaile=-2
          endif
          BY=0.0D0
        else
          by=aph*(x-x0h)**2
        endif
        AX=0.5*BY*Z
        AY=0.0
        AZ=-0.5*BY*X
+self.

        RETURN
      ENDIF !X.GT.XA(NPOINT)

C22.3.93 --------------------------------------------------------

c      write(6,*)ical,npoint,x,by
      CALL SPLINTap(NPOINT,xa,bya,y2a,X,BY)

      BX=0.
      BZ=0.

      AX=0.5*BY*Z
      AY=0.0
      AZ=-0.5*BY*X

      RETURN
      END
+DECK,splintap.
*CMZ :  4.00/07 10/07/2020  09.13.35  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.66/19 07/06/2011  14.08.31  by  Michael Scheer
*CMZ :  2.41/13 22/08/2002  17.16.36  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  2.13/10 25/03/2000  14.36.03  by  Michael Scheer
*CMZ :  2.11/00 11/05/99  18.02.35  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  15.14.32  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  18.40.22  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.36  by  Michael Scheer
*-- Author : Michael Scheer
C************************************************************************
      SUBROUTINE splintap(N,xa,ya,Y2a,x,by)
+seq,gplhint.

      IMPLICIT NONE
      INTEGER N,KLO,KHI,K,KD
      DOUBLE PRECISION bY,X,H,A,B

+SEQ,CMPARA.
      DOUBLE PRECISION XA(NBTABP),YA(NBTABP),Y2A(NBTABP)

      save

      DATA KLO/1/

      IF(     XA(1).LT.XA(N).AND.(X.LT.XA(1).OR.X.GT.XA(N))
     &  .OR.
     &  XA(N).LT.XA(1).AND.(X.LT.XA(N).OR.X.GT.XA(1)))
     &  STOP '***SR splintap: X OUT OF RANGE ***'

      IF (X.GE.XA(KLO)) THEN

C HUNT UP
        KD=1
11      KHI=MIN(KLO+KD,N)
        IF (X.GT.XA(KHI)) THEN
          KD=2*KD
          KLO=KHI
          GOTO 11
        ENDIF

      ELSE    !(X.GE.XA(KLO))

C HUNT DOWN
        KD=1
        KHI=KLO
22      KLO=MAX(KHI-KD,1)
        IF (X.LT.XA(KLO)) THEN
          KD=2*KD
          KHI=KLO
          GOTO 22
        ENDIF

      ENDIF

 1    IF (KHI-KLO.GT.1) THEN
        K=(KHI+KLO)/2
        IF(XA(K).GT.X)THEN
          KHI=K
        ELSE
          KLO=K
        ENDIF
        GOTO 1
      ENDIF

 2    H=XA(KHI)-XA(KLO)

      IF (H.LE.0.) THEN
        WRITE(6,*) 'Bad XA input.'
        STOP
      ENDIF

      A=(XA(KHI)-X)/H
      B=(X-XA(KLO))/H
      by=A*YA(KLO)+B*YA(KHI)+
     &  ((A**3-A)*Y2A(KLO)+(B**3-B)*Y2A(KHI))*(H**2)/6.

      RETURN
      END
+DECK,UTIL_SPLINE_INTER_HUNT.
*CMZ :  4.00/07 10/07/2020  08.22.44  by  Michael Scheer
*CMZ : 00.00/11 07/06/2011  14.38.25  by  Michael Scheer
*CMZ : 00.00/07 07/05/2008  13.09.13  by  Michael Scheer
*CMZ : 00.00/02 27/06/2003  09.36.13  by  Michael Scheer
*CMZ : 00.00/01 23/02/96  14.56.50  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.27.54  by  Michael Scheer
*-- Author :
      SUBROUTINE UTIL_SPLINE_INTER_HUNT(XA,YA,Y2A,N,X,Y)

C---  INTERPOLATES Y(X) VIA SPLINE

C--   INPUT:

C-       N: NUMBER OF X,Y-VALUES
C-       XA:   ARRAY OF X-VALUES
C-       YA:   ARRAY OF Y-VALUES
C-       YA2:  ARRAY SPLINE COEFFICIENTS
C-       X: Y(X) IS CALCULATED

C--   OUTPUT:

C-       Y: Y(X) IS CALCULATED

      IMPLICIT NONE

      INTEGER N,KLO,KHI,KLOLD,K,KD

      REAL*8 Y,X,H,A,B

      REAL*8 XA(N),YA(N),Y2A(N)

      DATA KLOLD/1/

      save

      IF(     XA(1).LT.XA(N).AND.(X.LT.XA(1).OR.X.GT.XA(N))
     &    .OR.
     &    XA(N).LT.XA(1).AND.(X.LT.XA(N).OR.X.GT.XA(1))) THEN
        WRITE(6,*)'XA(1), XA(N):',XA(1), XA(N)
        WRITE(6,*)'X:',X
        WRITE(6,*)'X(1),X(N):',XA(1),XA(N)
        STOP '*** ERROR IN UTIL_SPLINE_INTER_HUNT: X OUT OF RANGE ***'
      ENDIF

      IF (KLOLD.GT.N) THEN
        KLO=1
      ELSE
        KLO=KLOLD
      ENDIF

      IF (X.GE.XA(KLO)) THEN

C HUNT UP

        KD=1
1       KHI=MIN(KLO+KD,N)
        IF (X.GT.XA(KHI)) THEN
          KD=2*KD
          KLO=KHI
          GOTO 1
        ENDIF


      ELSE  !(X.GE.XA(KLO))

C HUNT DOWN
        KD=1
        KHI=KLO
2       KLO=MAX(KHI-KD,1)
        IF (X.LT.XA(KLO)) THEN
          KD=2*KD
          KHI=KLO
          GOTO 2
        ENDIF

      ENDIF

3     IF (KHI-KLO.GT.1) THEN
        K=(KHI+KLO)/2
        IF(XA(K).GT.X)THEN
          KHI=K
        ELSE
          KLO=K
        ENDIF
        GOTO 3
      ENDIF

      H=XA(KHI)-XA(KLO)

      IF (H.le.0.D0) STOP '*** ERROR SR UTIL_SPLINE_INTER: BAD INPUT ***'

      A=(XA(KHI)-X)/H
      B=(X-XA(KLO))/H

      Y=A*YA(KLO)+B*YA(KHI)+
     &  (A*(A*A-1.0d0)*Y2A(KLO)+B*(B*B-1.0d0)*Y2A(KHI))*(H**2)/6.D0

      KLOLD=KLO

      RETURN
      END
+DECK,undumag_wind_to_fila.
*CMZ :  4.00/11 04/02/2021  15.09.44  by  Michael Scheer
*CMZ :  2.01/03 24/01/2019  10.41.25  by  Michael Scheer
*CMZ :  1.25/04 03/04/2018  11.55.41  by  Michael Scheer
*CMZ :  1.25/02 22/03/2018  14.48.44  by  Michael Scheer
*CMZ :  1.25/01 16/03/2018  16.51.35  by  Michael Scheer
*CMZ :  1.25/00 15/03/2018  21.53.23  by  Michael Scheer
*-- Author :    Michael Scheer   08/03/2018
      subroutine undumag_wind_to_fila(k)

      use undumagf90m

      use commandlinef90m

      implicit none

+seq,phycon.

      double precision, dimension (:), allocatable :: y,z

      double precision h,w,r,barl,curr,cw,vx,vy,vz,phi,alpha,cosa,sina,
     &  cosphi,sinphi,cosphi1,sinphi2,cosphi2,sinphi1,costhe,sinthe,
     &  xc,yc,zc,x0,y0,z0,dphi,dr,dy,ro,ri,xr1,zr1,xr2,zr2,dz,vn,
     &  xi,xo,zi,zo,wx,wy,wz,ux,uy,uz,rotmat(3,3),vnor(3),rmat(3,3)

      integer k,iw,ir,nz,ny,nphi,iphi,iy,iz,kolor,ical,istat,i,j,kold

      data ical/0/

      save ical,iw

      !rotate (vx,vy,vz) to y-axis

      if (ical.eq.0) then
        ical=1
      endif

      iw=ncwires
      kold=iw

      curr=wind(1,k)*wind(18,k)*wind(19,k)

      x0=wind(2,k)
      y0=wind(3,k)
      z0=wind(4,k)

      vx=wind(5,k)
      vy=wind(6,k)
      vz=wind(7,k)

      vn=sqrt(vx**2+vy**2+vz**2)
      if (vn.eq.0.0d0) then
        write(lun6,*)
        write(lun6,*)"*** Error in undumag_wind_to_fila: Zero normal vector for coil",k
        stop
      endif
      vx=vx/vn
      vy=vy/vn
      vz=vz/vn

      alpha=wind(8,k)
      xo=wind(9,k)/2.0d0
      zi=wind(10,k)/2.0d0
      zo=wind(11,k)/2.0d0
      ri=wind(12,k)
      h=wind(13,k)
      ny=wind(14,k)
      nz=wind(15,k)
      nphi=wind(16,k)
      kolor=wind(17,k)

      w=zo-zi
      xi=xo-w
      ro=ri+w

      yc=0.0d0

      if (xi.lt.ri) then
        write(lun6,*)
        write(lun6,*)"*** Error in undumag_wind_to_fila: The inner length is smaller than twice the inner radius ***"
        stop
      endif

      allocate(y(ny),z(nz))

      dphi=pi1/2.0d0/nphi
      dy=h/ny
      dz=w/nz

      do iz=1,nz
        z(iz)=zi+(iz-0.5d0)*dz
      enddo

      do iy=1,ny
        y(iy)=yc-h/2.0d0+(iy-0.5d0)*dy
      enddo

      cw=curr/(ny*nz)

      ! first x bar
      do iy=1,ny
        do iz=1,nz
          iw=iw+1
          wire(1,iw)=8 ! windings flag
          wire(2,iw)=cw
          wire(3,iw)=+xi-ri
          wire(4,iw)=+y(iy)
          wire(5,iw)=-z(iz)
          wire(6,iw)=-xi+ri
          wire(7,iw)=+y(iy)
          wire(8,iw)=-z(iz)
          wire(9,iw)=kolor
          wire(10,iw)=k ! windings number
        enddo
      enddo

      ! first arc
      xc=-xi+ri
      zc=-zi+ri
      sinphi1=0.0d0
      cosphi1=1.0d0
      do iphi=1,nphi
        sinphi2=sin(iphi*dphi)
        cosphi2=cos(iphi*dphi)
        do iy=1,ny
          do iz=1,nz
            iw=iw+1
            r=ri+(iz-0.5d0)*dz
            wire(1,iw)=2
            wire(2,iw)=cw
            wire(3,iw)=+xc-r*sinphi1
            wire(4,iw)=+y(iy)
            wire(5,iw)=+zc-r*cosphi1
            wire(6,iw)=+xc-r*sinphi2
            wire(7,iw)=+y(iy)
            wire(8,iw)=+zc-r*cosphi2
            wire(9,iw)=kolor
            wire(10,iw)=k ! windings number
          enddo
        enddo
        sinphi1=sinphi2
        cosphi1=cosphi2
      enddo

      ! first z bar
      do iy=1,ny
        do iz=1,nz
          iw=iw+1
          wire(1,iw)=8 ! windings flag
          wire(2,iw)=cw
          wire(3,iw)=-xi-(iz-0.5d0)*dz
          wire(4,iw)=+y(iy)
          wire(5,iw)=-zi+ri
          wire(6,iw)=wire(3,iw)
          wire(7,iw)=+y(iy)
          wire(8,iw)=+zi-ri
          wire(9,iw)=kolor
          wire(10,iw)=k ! windings number
        enddo
      enddo

      ! second arc
      xc=-xi+ri
      zc=zi-ri
      sinphi1=0.0d0
      cosphi1=1.0d0
      do iphi=1,nphi
        sinphi2=sin(iphi*dphi)
        cosphi2=cos(iphi*dphi)
        do iy=1,ny
          do iz=1,nz
            iw=iw+1
            r=ri+(iz-0.5d0)*dz
            wire(1,iw)=2
            wire(2,iw)=cw
            wire(3,iw)=+xc-r*cosphi1
            wire(4,iw)=+y(iy)
            wire(5,iw)=+zc+r*sinphi1
            wire(6,iw)=+xc-r*cosphi2
            wire(7,iw)=+y(iy)
            wire(8,iw)=+zc+r*sinphi2
            wire(9,iw)=kolor
            wire(10,iw)=k ! windings number
          enddo
        enddo
        sinphi1=sinphi2
        cosphi1=cosphi2
      enddo

      ! second x bar
      do iy=1,ny
        do iz=1,nz
          iw=iw+1
          wire(1,iw)=8 ! windings flag
          wire(2,iw)=cw
          wire(3,iw)=-xi+ri
          wire(4,iw)=+y(iy)
          wire(5,iw)=+z(iz)
          wire(6,iw)=+xi-ri
          wire(7,iw)=+y(iy)
          wire(8,iw)=+z(iz)
          wire(9,iw)=kolor
          wire(10,iw)=k ! windings number
        enddo
      enddo

      ! third arc
      xc=xi-ri
      zc=zi-ri
      sinphi1=0.0d0
      cosphi1=1.0d0
      do iphi=1,nphi
        sinphi2=sin(iphi*dphi)
        cosphi2=cos(iphi*dphi)
        do iy=1,ny
          do iz=1,nz
            iw=iw+1
            r=ri+(iz-0.5d0)*dz
            wire(1,iw)=2
            wire(2,iw)=cw
            wire(3,iw)=+xc+r*sinphi1
            wire(4,iw)=+y(iy)
            wire(5,iw)=+zc+r*cosphi1
            wire(6,iw)=+xc+r*sinphi2
            wire(7,iw)=+y(iy)
            wire(8,iw)=+zc+r*cosphi2
            wire(9,iw)=kolor
            wire(10,iw)=k ! windings number
          enddo
        enddo
        sinphi1=sinphi2
        cosphi1=cosphi2
      enddo

      ! second z bar
      do iy=1,ny
        do iz=1,nz
          iw=iw+1
          wire(1,iw)=8 ! windings flag
          wire(2,iw)=cw
          wire(3,iw)=+xi+(iz-0.5d0)*dz
          wire(4,iw)=+y(iy)
          wire(5,iw)=+zi-ri
          wire(6,iw)=wire(3,iw)
          wire(7,iw)=+y(iy)
          wire(8,iw)=-zi+ri
          wire(9,iw)=kolor
          wire(10,iw)=k ! windings number
        enddo
      enddo

      ! fourth arc
      xc=xi-ri
      zc=-zi+ri
      sinphi1=0.0d0
      cosphi1=1.0d0
      do iphi=1,nphi
        sinphi2=sin(iphi*dphi)
        cosphi2=cos(iphi*dphi)
        do iy=1,ny
          do iz=1,nz
            iw=iw+1
            r=ri+(iz-0.5d0)*dz
            wire(1,iw)=2
            wire(2,iw)=cw
            wire(3,iw)=+xc+r*cosphi1
            wire(4,iw)=+y(iy)
            wire(5,iw)=+zc-r*sinphi1
            wire(6,iw)=+xc+r*cosphi2
            wire(7,iw)=+y(iy)
            wire(8,iw)=+zc-r*sinphi2
            wire(9,iw)=kolor
            wire(10,iw)=k ! windings number
          enddo
        enddo
        sinphi1=sinphi2
        cosphi1=cosphi2
      enddo

      !rotate and translate coil

      vnor(1)=vx
      vnor(2)=vy
      vnor(3)=vz
      call util_rotate_vector_to_y_axis(vnor,rotmat,istat)

      do i=1,3
        do j=1,3
          rmat(i,j)=rotmat(j,i)
        enddo
      enddo

      cosa=cos(alpha/180.0d0*pi1)
      sina=sin(alpha/180.0d0*pi1)

      do i=kold+1,iw
        wx=cosa*wire(3,i)+sina*wire(5,i)
        wy=wire(4,i)
        wz=-sina*wire(3,i)+cosa*wire(5,i)
        wire(3:5,i)=rmat(1:3,1)*wx+rmat(1:3,2)*wy+rmat(1:3,3)*wz
        wx=wire(6,i)
        wy=wire(7,i)
        wz=wire(8,i)
        wx=cosa*wire(6,i)+sina*wire(8,i)
        wy=wire(7,i)
        wz=-sina*wire(6,i)+cosa*wire(8,i)
        wire(6:8,i)=rmat(1:3,1)*wx+rmat(1:3,2)*wy+rmat(1:3,3)*wz
        wire(3,i)=wire(3,i)+x0
        wire(4,i)=wire(4,i)+y0
        wire(5,i)=wire(5,i)+z0
        wire(6,i)=wire(6,i)+x0
        wire(7,i)=wire(7,i)+y0
        wire(8,i)=wire(8,i)+z0
      enddo

      deallocate(y,z)

      ncwires=iw

      return
      end
+DECK,btabxyz.
*CMZ :  4.00/11 19/04/2021  16.49.53  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.54/04 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.16/08 01/11/2000  18.41.44  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ : 00.01/08 31/05/95  13.30.40  by  Michael Scheer
*CMZ : 00.01/02 24/11/94  16.00.44  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  18.02.31  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.57  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BTABxyz(XIN,DUMY,DUMZ,BX,BY,BZ,AX,AY,AZ)
+seq,gplhint.

C     BTABxyz reads By and Bz from data files and interpolatEs fields

      IMPLICIT NONE

+SEQ,CONTRL.

      INTEGER ICAL

      DOUBLE PRECISION XIN,DUMY,DUMZ,DUMZY,XS,XE,XS1,XS2,XE1,XE2
      DOUBLE PRECISION AX,AY,AZ,BX,BY,BZ
      DOUBLE PRECISION AXX,AYY,AZZ,BXX,BYY,BZZ
      DOUBLE PRECISION AXXX,AYYY,AZZZ,BXXX,BYYY,BZZZ

      DATA ICAL/0/
      DATA XS1,XS2,XE1,XE2/4*0.0/

      DUMZY=DUMY
      DUMZY=DUMZ

      BXX=0.
      BYY=0.
      BZZ=0.

      AXX=0.
      AYY=0.
      AZZ=0.

      BXXX=0.
      BYYY=0.
      BZZZ=0.

      AXXX=0.
      AYYY=0.
      AZZZ=0.

      XS=XSTART
      XE=XSTOP

      CALL BTAB (XIN,0.D0,0.D0, BXX, BYY, BZZ, AXX, AYY, AZZ)

      IF (ICAL.EQ.0) THEN

         XS1=XSTART
         XE1=XSTOP

      ENDIF !ICAL

      CALL BTABX(XIN,0.D0,0.D0,BX,BY,BZ,AX,AY,AZ,XS,XE)

      IF (ICAL.EQ.0) THEN

          XS2=XSTART
          XE2=XSTOP

          IF (XS1.NE.XS2) XSTART=DMIN1(XS1,XS2)
          IF (XE1.NE.XE2)  XSTOP=DMAX1(XE1,XE2)

      ENDIF !ICAL

      CALL BTABZ(XIN,0.D0,0.D0,BXXX,BYYY,BZZZ,AXXX,AYYY,AZZZ,XS,XE)

      IF (ICAL.EQ.0) THEN

          XS2=XSTART
          XE2=XSTOP

          IF (XS1.NE.XS2) XSTART=DMIN1(XS1,XS2)
          IF (XE1.NE.XE2)  XSTOP=DMAX1(XE1,XE2)

          ICAL=1

      ENDIF !ICAL

      BX=bx+BXX+BXXX
      BY=by+BYY+BYYY
      BZ=bz+BZZ+BZZZ

      AX=ax+AXX+AXXX
      AY=ay+AYY+AYYY
      AZ=az+AZZ+AZZZ

      RETURN
      END
+DECK,btabx.
*CMZ :  4.00/15 28/03/2022  12.42.45  by  Michael Scheer
*CMZ :  4.00/11 19/04/2021  17.04.06  by  Michael Scheer
*CMZ :  3.01/04 21/03/2014  14.02.03  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.54/04 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.52/09 29/10/2004  12.30.12  by  Michael Scheer
*CMZ :  2.41/10 14/08/2002  17.34.01  by  Michael Scheer
*CMZ :  2.16/04 17/07/2000  15.36.32  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.34  by  Michael Scheer
*CMZ :  2.13/05 08/02/2000  17.25.04  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  15.07.21  by  Michael Scheer
*CMZ : 00.01/08 31/05/95  13.36.58  by  Michael Scheer
*CMZ : 00.01/02 24/11/94  15.57.38  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.48.44  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.59  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BTABx(XIN,Y,Z,BX,BY,BZ,AX,AY,AZ,XS,XE)
+seq,gplhint.

C     BTAB-Version for longitudinal field Bx

      IMPLICIT NONE

      CHARACTER(60) BTABCOM

      INTEGER :: ISYM,ICAL,I,NPOINT,ILOW,IHIGH,IWARN,ieof=0

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEQ,B0SCGLOB.

      DOUBLE PRECISION XA(NBTABP),BYA(NBTABP),Y2A(NBTABP)
      DOUBLE PRECISION XSCALE,BYSCALE,X,Y,Z,BX,BY,BZ,XIN,TOTLEN,TOTLEN2
      DOUBLE PRECISION AL(3),AH(3),AX,AY,AZ
      DOUBLE PRECISION XS,XE,ZDUM

      integer luntbx

      COMMON/BTABCx/XA,BYA,Y2A

      DATA ILOW/0/
      DATA IHIGH/0/
      DATA ISYM/0/,ICAL/0/

      IF (ICAL.NE.1) THEN

        ZDUM=Z

        OPEN (newUNIT=luntbx,FILE = FILETBx,STATUS = 'OLD',FORM = 'FORMATTED')

        if (irbtabzy.gt.0.or.irbtabxyz.gt.0) then
          READ(luntbx,'(1A60)') BTABCOM
          READ(luntbx,*) XSCALE,BYSCALE
          READ(luntbx,*) NPOINT
        else
          btabcom=trim(filetbx)
          xscale=1.0d0
          if (irbtabzy.eq.-2.or.irbtabxyz.eq.-2) xscale=0.001d0
          byscale=1.0d0
          npoint=0
          do while (ieof.eq.0)
            call util_skip_comment_end(luntbx,ieof)
            read(luntbx,*)x,by
            if (ieof.ne.0) then
              rewind(luntbz)
              exit
            endif
            npoint=npoint+1
          enddo
        endif

        IF (NPOINT.GT.NBTABP.OR.-2*NPOINT-1.GT.NBTABP) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN BTABX ***'
          WRITE(LUNGFO,*)'DIMENSION EXCEEDED, INCREASE NBTABP***'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN BTABX ***'
          WRITE(6,*)'DIMENSION EXCEEDED, INCREASE NBTABP***'
          WRITE(6,*)
          STOP
        ENDIF

        IF (ABS(NPOINT).LT.2) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN BTABX ***'
          WRITE(LUNGFO,*)
     &      'LESS THAN TWO POINTS ON DATA FILE OF MAGNETIC FIELD'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN BTABX ***'
          WRITE(6,*)'LESS THAN TWO POINTS ON DATA FILE OF MAGNETIC FIELD'
          WRITE(6,*)
        ENDIF

        IF (NPOINT.GT.0.AND.NPOINT.LT.3) THEN
          WRITE(LUNGFO,*)
          WRITE(LUNGFO,*)'*** ERROR IN BTABX ***'
          WRITE(LUNGFO,*)
     &      'LESS THAN THREE POINTS ON DATA FILE OF MAGNETIC FIELD'
          WRITE(LUNGFO,*)
          WRITE(6,*)
          WRITE(6,*)'*** ERROR IN BTABX ***'
          WRITE(6,*)'LESS THAN THREE POINTS ON DATA FILE OF MAGNETIC FIELD'
          WRITE(6,*)
        ENDIF

        IF (NPOINT.LT.0) THEN
          ISYM=1
          NPOINT=-NPOINT
        ENDIF

        DO I=1,NPOINT
          READ(luntbx,*)XA(I),BYA(I)
          XA(I)=XA(I)*XSCALE-XSHBTAB
          BYA(I)=BYA(I)*BYSCALE
        END DO

        CLOSE(luntbx)

        call util_sort_func(npoint,xa,bya)

C--- SYMMETRISIEREN

        IF (ISYM.EQ.1) THEN

          IF(XA(1).LT.0.) THEN
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)'*** ERROR IN BTABZ ***'
            WRITE(LUNGFO,*)'FIRST X-VALUE ON DATA FILE LOWER ZERO'
            WRITE(LUNGFO,*)'SYMMETRY OPTION REQUIRES POSITIV X-VALUES'
            WRITE(LUNGFO,*)
            WRITE(LUNGFO,*)
            WRITE(6,*)
            WRITE(6,*)'*** ERROR IN BTABZ ***'
            WRITE(6,*)'FIRST X-VALUE ON DATA FILE LOWER ZERO'
            WRITE(6,*)'SYMMETRY OPTION REQUIRES POSITIV X-VALUES'
            WRITE(6,*)
            STOP
          ENDIF !XA

          IF(XA(1).NE.0) THEN

            DO I=1,NPOINT        !SHIFT
              XA(I+NPOINT)= XA(I)
              BYA(I+NPOINT)=BYA(I)
            END DO

            DO I=1,NPOINT
              XA(I)=-XA(2*NPOINT-I+1)
              BYA(I)=-BYA(2*NPOINT-I+1)
            END DO

            NPOINT=2*NPOINT

          ELSE

            DO I=1,NPOINT        !SHIFT
              XA(2*NPOINT-I)= XA(NPOINT-I+1)
              BYA(2*NPOINT-I)=BYA(NPOINT-I+1)
            END DO

            DO I=1,NPOINT-1
              XA(I) =-XA(2*NPOINT-I)
              BYA(I)=-BYA(2*NPOINT-I)
            END DO

            NPOINT=2*NPOINT-1

          ENDIF

        ENDIF

        TOTLEN=DABS(XA(NPOINT)-XA(1))
        TOTLEN2=TOTLEN/2.D0
        DEVLEN=TOTLEN
        DEVLEN2=TOTLEN2

        WRITE (LUNGFO,*)
        WRITE (LUNGFO,*)'     SR BTABX: Magnetic field data read from file'
        WRITE (LUNGFO,*)'     ',FILETBx
        WRITE (LUNGFO,*)
        WRITE (LUNGFO,*)'     BTABX comment:',BTABCOM
        WRITE (LUNGFO,*)
        WRITE (LUNGFO,*)'     Length of device:     ',TOTLEN
        WRITE (LUNGFO,*)'     Half length of device:',TOTLEN2
        WRITE (LUNGFO,*)

C060793  CALL SPLINETB(XA,BYA,NPOINT,2.D30,2.D30,Y2A)
        CALL SPLINETB(XA,BYA,NPOINT,0.D0,0.D0,Y2A)

        IF (XS.EQ.9999.)  XSTART=XA(1)
        IF (XE.EQ.9999.)  XSTOP=XA(NPOINT)

        ICAL=1

      ENDIF !(ICAL)

      IF(Y.NE.0.) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'*** ERROR IN BTABZ ***'
         WRITE(LUNGFO,*)'Y-COORDINATE OF ELECTRON NOT ZERO'
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)'*** ERROR IN BTABZ ***'
         WRITE(6,*)'Y-COORDINATE OF ELECTRON NOT ZERO'
         WRITE(6,*)
         STOP
      ENDIF

      IF (XIN.EQ.9999.) THEN
          X=XSTART
      ELSE
          X=XIN
      ENDIF

      IF(X.LT.XA(1)-1./MYINUM.OR.X.GT.XA(NPOINT)+1./MYINUM) THEN
        IF (IWARN.EQ.0) THEN
         WRITE(LUNGFO,*)
         WRITE(LUNGFO,*)'*** WARNING IN BTABZ ***'
         WRITE(LUNGFO,*)'X MORE THAN ONE STEP OUT OF TABLE'
         WRITE(LUNGFO,*)'X:',X
         WRITE(LUNGFO,*)
         WRITE(6,*)
         WRITE(6,*)'*** WARNING IN BTABZ ***'
         WRITE(6,*)'X MORE THAN ONE STEP OUT OF TABLE'
         WRITE(6,*)'X:',X
         WRITE(6,*)
         IWARN=1
       ENDIF
       BX=0.0D0
       BY=0.0D0
       BZ=0.0D0
       AX=0.0D0
       AY=0.0D0
       AZ=0.0D0
       RETURN
      ENDIF

      IF(X.LT.XA(1)) THEN
          IF (ILOW.NE.1) THEN
         CALL PARABEL(XA(1),BYA(1),XA(2),BYA(2),XA(3),BYA(3),AL)
          ILOW=1
          ENDIF   ! ILOW

          Bx=0.
          By=0.
          Bz=AL(1)+AL(2)*X+AL(3)*X*X

          AX=-0.5*Bz*y
          Ay= 0.5*Bz*x
          Az= 0.0

          RETURN
      ENDIF !X.LT.XA(1)

      IF(X.GT.XA(NPOINT)) THEN

          IF (IHIGH.NE.1) THEN

         CALL PARABEL(XA(NPOINT-2),BYA(NPOINT-2)
     &                      ,XA(NPOINT-1),BYA(NPOINT-1)
     &                      ,XA(NPOINT)  ,BYA(NPOINT)  ,AH)

          IHIGH=1
          ENDIF   ! IHIGH

          By=0.
          Bx=0.
          Bz=AH(1)+AH(2)*X+AH(3)*X*X

          AX=-0.5*Bz*y
          Ay= 0.5*Bz*x
          Az= 0.0

          RETURN

      ENDIF !X.GT.XA(NPOINT)


      CALL SPLINTBx(NPOINT,X,Bx)

      Bz=0.
      By=0.

      AX=-0.5*Bz*y
      Ay= 0.5*Bz*x
      Az= 0.0

      RETURN
      END
+DECK,splintbx.
*CMZ :  4.00/11 19/04/2021  17.04.59  by  Michael Scheer
*CMZ :  3.01/03 19/03/2014  12.24.14  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.66/19 07/06/2011  14.08.31  by  Michael Scheer
*CMZ :  2.63/03 07/05/2008  14.17.54  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  1.03/06 09/06/98  15.14.32  by  Michael Scheer
*CMZ : 00.01/02 18/11/94  18.41.04  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.55.02  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.59  by  Michael Scheer
*-- Author : Michael Scheer
C************************************************************************
      SUBROUTINE SPLINTBx(N,X,Y)
+seq,gplhint.

      INTEGER NOLD,N,KLO,KHI,KLOLD,K
      DOUBLE PRECISION Y,X,XA1OLD,XANOLD,H,A,B

+SEQ,CMPARA.
      DOUBLE PRECISION XA(NBTABP),YA(NBTABP),Y2A(NBTABP)
      COMMON/BTABCx/XA,YA,Y2A

      save klold,nold,xa1old,xanold

      DATA KLOLD/1/,NOLD/-99/
      DATA XA1OLD/-9999.D0/,XANOLD/-9999./

      IF(     XA(1).LT.XA(N).AND.(X.LT.XA(1).OR.X.GT.XA(N))
     &  .OR.
     &  XA(N).LT.XA(1).AND.(X.LT.XA(N).OR.X.GT.XA(1)))
     &  STOP '***SR SPLINTBx: X OUT OF RANGE ***'

      IF (NOLD.ne.N) then
        klo=1
      else IF (
     &    XA(1).EQ.XA1OLD
     &    .AND. XA(N).EQ.XANOLD
     &    .AND. X.GT.XA(KLOLD)
     &    ) THEN
        KLO=KLOLD
      ELSE
        KLO=1
      ENDIF

      IF (X.LT.XA(KLO+1)) THEN
      KHI=KLO+1
      GOTO 2
      ENDIF

      KHI=N
1     IF (KHI-KLO.GT.1) THEN
        K=(KHI+KLO)/2
        IF(XA(K).GT.X)THEN
          KHI=K
        ELSE
          KLO=K
        ENDIF
      GOTO 1
      ENDIF

2     H=XA(KHI)-XA(KLO)
      IF (H.LE.0.) THEN
        WRITE(6,*) 'Bad XA input.'
        STOP
      ENDIF
      A=(XA(KHI)-X)/H
      B=(X-XA(KLO))/H
      Y=A*YA(KLO)+B*YA(KHI)+
     *      ((A**3-A)*Y2A(KLO)+(B**3-B)*Y2A(KHI))*(H**2)/6.

      KLOLD=KLO
      NOLD=N
      XA1OLD=XA(1)
      XANOLD=XA(N)


      RETURN
      END
+DECK,trajectory_to_bfield_ini.
*CMZ :  4.00/11 21/04/2021  12.06.18  by  Michael Scheer
*-- Author :    Michael Scheer   21/04/2021
      subroutine trajectory_to_bfield_ini
      implicit none

+seq,contrl.
+seq,myfiles.
+seq,phyconparam.

      double precision, dimension (:,:), allocatable :: xyz,bxyz
      double precision x,y,z

      integer lunt,i,nstep,istat
      logical lexist

      character(128) chfilebx,chfileby,chfilebz

      inquire(file=trim(filetr),exist=lexist)
      if (lexist.eqv..false.) then
        print*,'*** Error in trajectory_to_bfield_ini: File'
        print*,trim(filetr)
        print*,"not found ***"
        write(lungfo,*)'*** Error in trajectory_to_bfield_ini: File'
        write(lungfo,*)trim(filetr)
        write(lungfo,*)"not found ***"
        return
      endif

      chfilebx='trajectory_to_bfield_bx.dat'
      chfileby='trajectory_to_bfield_by.dat'
      chfilebz='trajectory_to_bfield_bz.dat'

      filetbx=chfilebx
      filetb=chfileby
      filetbz=chfilebz

      irbtabxyz=1

      open(newunit=lunt,file=trim(filetr),status='old')

      nstep=0

      do while(.true.)
        call util_skip_comment(lunt)
        read(lunt,*,end=9)x,y,z
        nstep=nstep+1
      enddo
9     continue

      allocate(xyz(3,nstep),bxyz(3,nstep))

      rewind(lunt)
      do i=1,nstep
        call util_skip_comment(lunt)
        read(lunt,*)xyz(:,i)
      enddo
      close(lunt)

      call trajectory_to_bfield(nstep,emasskg1,echarge1,dmyenergy,
     &  xyz,bxyz,istat)

      open(newunit=lunt,file=chfilebx)
      write(lunt,*)icode,trim(code)
      write(lunt,*)'1. 1.'
      write(lunt,*)nstep
      do i=1,nstep
        write(lunt,*)xyz(1,i),bxyz(1,i)
      enddo
      close(lunt)

      open(newunit=lunt,file=chfileby)
      write(lunt,*)icode,trim(code)
      write(lunt,*)'1. 1.'
      write(lunt,*)nstep
      do i=1,nstep
        write(lunt,*)xyz(1,i),bxyz(2,i)
      enddo
      close(lunt)

      open(newunit=lunt,file=chfilebz)
      write(lunt,*)icode,trim(code)
      write(lunt,*)'1. 1.'
      write(lunt,*)nstep
      do i=1,nstep
        write(lunt,*)xyz(1,i),bxyz(3,i)
      enddo
      close(lunt)

      deallocate(xyz,bxyz)

      return
      end
+DECK,trajectory_to_bfield.
*CMZ :  4.00/11 21/04/2021  12.07.45  by  Michael Scheer
*-- Author :    Michael Scheer   19/04/2021
      subroutine trajectory_to_bfield(nstep,rmass,charge,ebeam,xyz,bxyz,istat)

      implicit none

+seq,phyconparam.

      double precision, dimension (:),  allocatable ::
     &  x,y,z,xp,yp,zp,xpp,ypp,zpp,aa,bb,cc,c,t

      double precision rmass,dmass,charge,ebeam,xyz(3,nstep),bxyz(3,nstep),
     &  beta,gamma,a,b,ax,ay,az,bn,v0,bx,by,bz

      integer nstep,istat,i

      ! x(i) = xyz(1,i)
      ! y(i) = xyz(2,i)
      ! z(i) = xyz(3,i)

      istat=0

      gamma=ebeam/emassg1
      beta=dsqrt((1.0d0-1.0d0/gamma)*(1.0d0+1.0d0/gamma))
      v0=clight1*beta
      dmass=rmass*gamma

      allocate(t(nstep),
     &  x(nstep),y(nstep),z(nstep),
     &  xp(nstep),yp(nstep),zp(nstep),
     &  xpp(nstep),ypp(nstep),zpp(nstep),
     &  aa(nstep),bb(nstep),cc(nstep),c(nstep))

      x=xyz(1,:)
      y=xyz(2,:)
      z=xyz(3,:)

      t(1)=0.0d0
      do i=2,nstep
        t(i)=t(i-1)+sqrt((x(i)-x(i-1))**2+(y(i)-y(i-1))**2+(z(i)-z(i-1))**2)/v0
      enddo

      call util_spline_coef_deriv(t,x,nstep,9999.0d0,9999.0d0,xp,xpp,
     &  aa,bb,cc,c)
      call util_spline_coef_deriv(t,y,nstep,9999.0d0,9999.0d0,yp,ypp,
     &  aa,bb,cc,c)
      call util_spline_coef_deriv(t,z,nstep,9999.0d0,9999.0d0,zp,zpp,
     &  aa,bb,cc,c)

      do i=1,nstep
        ax=xpp(i)
        ay=ypp(i)
        az=zpp(i)
        a=sqrt(ax*ax+ay*ay+az*az)
        b=a/v0*dmass/charge
        bx=(yp(i)*zpp(i)-zp(i)*ypp(i))
        by=(zp(i)*xpp(i)-xp(i)*zpp(i))
        bz=(xp(i)*ypp(i)-yp(i)*xpp(i))
        bn=b/sqrt(bx*bx+by*by+bz*bz)
        bxyz(1,i)=bx*bn
        bxyz(2,i)=by*bn
        bxyz(3,i)=bz*bn
      enddo

      deallocate(t,x,y,z,xp,yp,zp,xpp,ypp,zpp,aa,bb,cc,c)

      return
      end
+DECK,bhalbastandalone.
*CMZ :  4.00/11 07/05/2021  07.29.16  by  Michael Scheer
*CMZ :  3.05/06 17/07/2018  11.15.16  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.67/04 11/05/2012  11.18.26  by  Michael Scheer
*CMZ :  2.64/01 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.36/00 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ : 00.01/10 21/08/96  12.30.33  by  Michael Scheer
*CMZ : 00.01/04 30/11/94  14.09.41  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.47.18  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.12.57  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE BHALBAstandalone(XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT
     &  ,AXOUT,AYOUT,AZOUT,b0halba,xlhalba,ylhalba,zlhalba,perhal)

+seq,gplhint.

C Calculates magnetic field according to Halbach's formulas
C Inside the routine the coodinate system corresponds to
C Halbach's convention i.e. Z is the longitudinal coordinate
C Input and Output are converted according to the coordinate
C system of WAVE

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.

+SEQ,PHYCON.

      INTEGER ICAL

      DOUBLE PRECISION XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT,
     &  XKX,YKY,ZKZ,DSNXKX,DCSXKX,DSHYKY,DCHYKY,DSNZKZ,DCSZKZ
     &  ,BXH,BYH,BZH,AXH,AYH,AZH,perhal,b0halba,xkhalba,ykhalba,zkhalba,
     &  zlenhal2,zlhalba,xlhalba,ylhalba,zlenhal

      DOUBLE PRECISION PARK,WLEN1,EHARM1

      save

      DATA ICAL/0/

      IF (ICAL.EQ.0) THEN

        IF (PERHAL.LT.0.0d0) THEN
          ZLHALBA=-ZLENHAL/PERHAL
          XLHALBA= XLHALBA/PERHAL
        ENDIF

        XKHALBA=0.0d0
        YKHALBA=0.0d0
        ZKHALBA=0.0d0

        IF (ZLHALBA.NE.0.0d0) ZKHALBA=2.0d0*PI1/ZLHALBA
        IF (YLHALBA.NE.0.0d0) YKHALBA=2.0d0*PI1/YLHALBA
        IF (XLHALBA.NE.0.0d0) XKHALBA=2.0d0*PI1/XLHALBA

C--- ADJUST K-VALUES

        YKHALBA=DSQRT(ZKHALBA*ZKHALBA+XKHALBA*XKHALBA)
        YLHALBA=2.0d0*PI1/YKHALBA

        IF(PERHAL.GE.0) ZLENHAL=PERHAL*ZLHALBA     !29.10.91

        ZLENHAL2=ZLENHAL/2.0d0

C--- BENDING RADIUS

        PARK=ECHARGE1*DABS(B0HALBA)*ZLHALBA/(2.*PI1*EMASSKG1*CLIGHT1)
        WLEN1=(1+PARK**2/2.)/2./DMYGAMMA**2*ZLHALBA*1.D9
        IF (WLEN1.NE.0.0) EHARM1=WTOE1/WLEN1

        ICAL =1

      ENDIF

      IF (KHALBA.LT.0.AND.ABS(XIN).GT.ZLENHAL2) THEN
        BXOUT=0.0D0
        BYOUT=0.0D0
        BZOUT=0.0D0
        AXOUT=0.0D0
        AYOUT=0.0D0
        AZOUT=0.0D0
        RETURN
      ENDIF

      XKX=XKHALBA*(-ZIN)
      YKY=YKHALBA*YIN
      ZKZ=ZKHALBA*XIN

      DSNXKX=DSIN(XKX)
      DCSXKX=DCOS(XKX)
      DSHYKY=DSINH(YKY)
      DCHYKY=DSQRT(1.D0+DSHYKY*DSHYKY)
      DSNZKZ=DSIN(ZKZ)
      DCSZKZ=DCOS(ZKZ)

      BXH=-XKHALBA/YKHALBA*B0HALBA*DSNXKX*DSHYKY*DCSZKZ
      BYH=                 B0HALBA*DCSXKX*DCHYKY*DCSZKZ
      BZH=-ZKHALBA/YKHALBA*B0HALBA*DCSXKX*DSHYKY*DSNZKZ

      AXH=B0HALBA/ZKHALBA*                DCSXKX*DCHYKY*DSNZKZ
      AYH=B0HALBA/ZKHALBA*XKHALBA/YKHALBA*DSNXKX*DSHYKY*DSNZKZ
      AZH=0.

      BZOUT=-BXH
      BYOUT=BYH
      BXOUT=BZH

      AZOUT=-AXH
      AYOUT= AYH
      AXOUT= AZH

      RETURN
      END
+DECK,util_rfft.
*CMZ : 00.00/15 24/10/2012  14.33.54  by  Michael Scheer
*CMZ : 00.00/06 31/10/2007  17.15.57  by  Michael Scheer
*-- Author :    Michael Scheer   30/10/2007
      subroutine util_rfft(n,f,cfft,ifail)

c +PATCH,//UTIL/FOR
c +DECK,util_rfft.

c fft of f(0:n-1), n is power of 2
c
c output: fft(odd)  = coef_cos
c         fft(even) = coef_sin
c         f = fft(1) + fft(2)*cos(k) +fft(4)*cos(2*k) ...
c           +          fft(3)*sin(k) +fft(5)*sin(2*k) ...

      implicit none

      real f(0:n-1)
      complex cfft(0:n/2-1)

      integer n,ifail,ipow,i

      ifail=0
      ipow=nint(alog(float(n))/alog(2.0))

      if (2**ipow.gt.n) ipow=ipow-1

      if (n.ne.2**ipow) then
        ifail=-1
        return
      endif

      do i=0,n/2-1
        cfft(i)=cmplx(f(2*i),f(2*i+1))
      enddo

      call rfstft(-ipow,cfft)

      do i=1,n/2-1
        cfft(i)=cmplx(
     &     real(cfft(i)+conjg(cfft(i))),
     &    -imag(cfft(i)-conjg(cfft(i)))
     &    )
      enddo

      return
      end

+DECK,bfoursincos.
*CMZ :  4.00/11 16/05/2021  13.16.14  by  Michael Scheer
*CMZ :  3.03/02 15/12/2015  15.57.23  by  Michael Scheer
*CMZ :  3.01/02 24/01/2014  17.44.47  by  Michael Scheer
*CMZ :  3.01/00 04/07/2013  08.33.03  by  Michael Scheer
*CMZ :  3.00/01 02/04/2013  13.47.23  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.23  by  Michael Scheer
*CMZ :  2.63/05 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.61/06 12/04/2007  09.47.01  by  Michael Scheer
*CMZ :  2.58/01 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.57/05 24/08/2006  16.44.25  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.35.17  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  14.47.19  by  Michael Scheer
*CMZ : 00.00/07 01/06/94  10.41.53  by  Michael Scheer
*-- Author : Michael Scheer
C-----------------------------------------------------------
      subroutine bfoursincos(xin,yin,zin,
     &  bxout,byout,bzout,axout,ayout,azout,
     &  nfour,xl0,zl0,cfft,init)

C--------------------------------------------------------------------
      ! NOTE: The interpretation and as in util_rfft, NOT AS IN BFOUR
      ! xin is longitudinal
C--------------------------------------------------------------------

      implicit none

      integer :: nfour,iallo=0,nfourold=-1,init,kinit,i,k

      double precision :: xin,yin,zin,bxout,byout,bzout,axout,ayout,azout,
     &  xl0,zl0,bxh,byh,bzh,axh,ayh,azh,a0,dchyky,dcsxkx,dcszkz,dexpomy,
     &  dshyky,dsnxkx,dsnzkz,expomy,expomy1,xk0four,zk0four,
     &  dnull=0.0d0

      double precision, dimension(:), allocatable :: ac,as,xkfour,ykfour,zkfour

      double complex cdexpomx,cdexpomz,cexpomz

      complex cfft(0:nfour-1)

+seq,phyconparam.

      save

      if (init.ne.0.or.nfourold.ne.nfour) then

        nfourold=nfour

        if (iallo.ne.0) then
          deallocate(ac,as,xkfour,ykfour,zkfour)
        endif

        allocate(ac(nfour-1),as(nfour-1),
     &    xkfour(nfour-1),ykfour(nfour-1),zkfour(nfour-1))
        iallo=1

        if (xl0.ne.0.0d0) then
          zk0four=twopi1/xl0
        else
          zk0four=0.0d0
        endif

        if (zl0.ne.0.0d0) then
          xk0four=twopi1/zl0
        else
          xk0four=0.0d0
        endif

        do i=1,nfour-1
          zkfour(i)=zk0four*dble(i)
          xkfour(i)=xk0four
          ykfour(i)=dsqrt(zkfour(i)**2+xkfour(i)**2)
        end do

      endif

      a0=dble(real(cfft(0)))
      ac(1:nfour-1)=dble(real(cfft(1:nfour-1)))
      as(1:nfour-1)=dble(imag(cfft(1:nfour-1)))

c if changed, consider following loop and sr mybfeld

+self,if=dipaxaz.
      axh= a0/4.0d0*xin
      ayh=0.
      azh=-a0/4.0d0*(-zin)
+self.

+self,if=dipaz.
      axh=0.
      ayh=0.
      azh=a0/2.0d0*zin  ! (-zin) is x here
+self.

+self,if=-dipaxaz,if=-dipaz.
      axh= a0/2.0d0*xin !xin is here z
      ayh=0.
      azh=0.
+self.

      cdexpomx=cdexp(dcmplx(dnull,xkfour(1)*(-zin)))
      dcsxkx=dreal(cdexpomx)
      dsnxkx=dimag(cdexpomx)

      dexpomy=dexp(ykfour(1)*yin)
      expomy=1.0d0

      cdexpomz=cdexp(dcmplx(dnull,zkfour(1)*xin))
      cexpomz=dcmplx(1.0d0,dnull)

      bxh=0.0d0
      byh=a0
      bzh=0.0d0

      do k=1,nfour-1

        if (xk0four.ne.0.0d0) then
          expomy=dexp(ykfour(k)*yin)
        else
          expomy=expomy*dexpomy
        endif

        expomy1=1.0d0/expomy
        dchyky=(expomy+expomy1)*0.5d0
        dshyky=(expomy-expomy1)*0.5d0

        cexpomz=cexpomz*cdexpomz
        dcszkz=dreal(cexpomz)
        dsnzkz=dimag(cexpomz)

        bxh=bxh-xkfour(k)/ykfour(k)*dsnxkx*dshyky*(ac(k)*dcszkz+as(k)*dsnzkz)
        byh=byh+                    dcsxkx*dchyky*(ac(k)*dcszkz+as(k)*dsnzkz)
        bzh=bzh-zkfour(k)/ykfour(k)*dcsxkx*dshyky*(ac(k)*dsnzkz-as(k)*dcszkz)

+self,if=halaxaz.
        axh=axh+0.5d0/zkfour(k)*dcsxkx*dchyky*(ac(k)*dsnzkz-as(k)*dcszkz)
        if (xkfour(k).ne.0.0) then
          azh=azh-0.5d0/xkfour(k)*dsnxkx*dchyky*(ac(k)*dcszkz+as(k)*dsnzkz)
        else
          azh=azh-0.5d0*(-zin)*dchyky*(ac(k)*dcszkz+as(k)*dsnzkz)
        endif
+self.

+self,if=halaz.
        axh=axh+0.0
        if (xkfour(k).ne.0.0) then
          azh=azh-ac(k)/xkfour(k)*dsnxkx*dchyky*dcszkz
        else
          azh=azh-ac(k)*(-zin)*dchyky*dcszkz
        endif
+self.

+self,if=-halaxaz,if=-halaz.
        axh=axh+ac(k)/zkfour(k)*dcsxkx*dchyky*dsnzkz
        azh=azh+0.0
+self.

        ayh=ayh+ac(k)/zkfour(k)*xkfour(k)/ykfour(k)*dsnxkx*dshyky*dsnzkz

      enddo

      bzout=-bxh
      byout= byh
      bxout= bzh

      azout=-axh
      ayout= ayh
      axout= azh

      return
      end
+DECK,bfourtabzy.
*CMZ :  4.00/11 18/05/2021  19.13.31  by  Michael Scheer
*-- Author : Michael Scheer
C-----------------------------------------------------------
      subroutine bfourtabzy(xin,yin,zin,bxout,byout,bzout,axout,ayout,azout)

      use fbtabzymod

      implicit none

+seq,contrl.
+seq,myfiles.

      integer :: nxbyfbtold,nxbzfbtold,nfourzyold,
     &  nxy,npow2,i,ifail,klinold,lunfft

      double precision
     &  xin,yin,zin,bxout,byout,bzout,axout,ayout,azout,
     &  bxf,byf,bzf,axf,ayf,azf,xiny,xinz

      complex, dimension(:), allocatable :: cffty,cfftz

      double precision, dimension(:), allocatable :: bypp,bzpp,
     &  ws1,ws2,ws3,ws4,bfft

      real, dimension(:), allocatable :: rbfft

      double precision xby1old,xbynold,by1old,bynold,
     &  xbz1old,xbznold,bz1old,bznold,dx,b,x,xi,xe,xc

      save

      if (inifbt.ne.0.or.nfourzyold.ne.nfourzy.or.
     &    nxbyfbt.ne.nxbyfbtold.or.xbyfbt(1).ne.xby1old.or.xbyfbt(nxbyfbt).ne.xbynold.or.
     &    nxbzfbt.ne.nxbzfbtold.or.xbzfbt(1).ne.xbz1old.or.xbzfbt(nxbzfbt).ne.xbznold.or.
     &    klinearfbt.ne.klinold
     &    ) then

        xi=xstart
        xc=xinter
        xe=xstop

        call fbtab_ini(xin,irbtab,irbtabzy,irbtabxyz)

        klinold=klinearfbt
        npow2=2**(nint(alog(float(nfourzy)/alog(2.)))+1)

        nfourzyold=nfourzy

        nxbyfbtold=nxbyfbt
        xby1old=xbyfbt(1)
        xbynold=xbyfbt(nxbyfbt)
        by1old=byfbt(1)
        bynold=byfbt(nxbyfbt)

        nxbzfbtold=nxbzfbt
        xbz1old=xbzfbt(1)
        xbznold=xbzfbt(nxbzfbt)
        bz1old=bzfbt(1)
        bznold=bzfbt(nxbzfbt)

        if (klinearfbt.eq.0) then

          if (iallofbt.ne.0) then
            deallocate(bypp,bzpp,ws1,ws2,ws3,ws4,cffty,cfftz,bfft,rbfft)
          endif

          nxy=max(nxbyfbt,nxbzfbt)
          allocate(bypp(nxbyfbt),bzpp(nxbzfbt),ws1(nxy),ws2(nxy),ws3(nxy),ws4(nxy))
          allocate(cffty(0:npow2/2-1),cfftz(0:npow2/2-1),
     &      bfft(npow2),rbfft(npow2))

          call util_spline_coef(xbyfbt,byfbt,nxbyfbt,0.0d0,0.0d0,bypp,
     &      ws1,ws2,ws3,ws4)

          dx=(xbyfbt(nxbyfbt)-xbyfbt(1))/dble(npow2)
          x=xbyfbt(1)
          call util_spline_inter(xbyfbt,byfbt,bypp,nxbyfbt,xbyfbt(1),bfft(1),-1)

          rbfft(1)=sngl(bfft(1))
          do i=2,npow2
            x=x+dx
            call util_spline_inter(xbyfbt,byfbt,bypp,nxbyfbt,x,bfft(i),0)
            rbfft(i)=sngl(bfft(i))
          enddo

          call util_rfft(npow2,rbfft,cffty,ifail)

          if (ifail.ne.0) then
            print*,"*** Error in bfourtabzy: Util_rfft failed ***"
            stop "*** Program WAVE aborted ***"
          endif

          open(newunit=lunfft,file=trim(filetb)//".fft")
          do i=0,npow2/2-1
            write(lunfft,*)i,real(cffty(i)),imag(cffty(i))
          enddo
          flush(lunfft)
          close(lunfft)

          call util_spline_coef(xbzfbt,bzfbt,nxbzfbt,0.0d0,0.0d0,bzpp,
     &      ws1,ws2,ws3,ws4)

          dx=(xbzfbt(nxbzfbt)-xbzfbt(1))/dble(npow2)
          x=xbzfbt(1)
          call util_spline_inter(xbzfbt,bzfbt,bzpp,nxbzfbt,xbzfbt(1),bfft(1),-1)

          rbfft(1)=sngl(bfft(1))
          do i=2,npow2
            x=x+dx
            call util_spline_inter(xbzfbt,bzfbt,bzpp,nxbzfbt,x,bfft(i),0)
            rbfft(i)=sngl(bfft(i))
          enddo

          call util_rfft(npow2,rbfft,cfftz,ifail)

          if (ifail.ne.0) then
            print*,"*** Error in bfourtabzy: Util_rfft failed ***"
            stop "*** Program WAVE aborted ***"
          endif

          open(newunit=lunfft,file=trim(filetbz)//".fft")
          do i=0,npow2/2-1
            write(lunfft,*)i,real(cfftz(i)),imag(cfftz(i))
          enddo
          flush(lunfft)
          close(lunfft)

          iallofbt=1

        else !klinearfbt

          if (iallofbt.ne.0) then
            deallocate(bypp,bzpp,ws1,ws2,ws3,ws4,cffty,cfftz,bfft,rbfft)
          endif

          nxy=max(nxbyfbt,nxbzfbt)
          allocate(bypp(nxbyfbt),bzpp(nxbzfbt),ws1(nxy),ws2(nxy),ws3(nxy),ws4(nxy))
          allocate(cffty(0:npow2/2-1),cfftz(0:npow2/2-1),
     &      bfft(npow2),rbfft(npow2))

          dx=(xbyfbt(nxbyfbt)-xbyfbt(1))/dble(npow2)
          x=xbyfbt(1)-dx
          do i=1,npow2
            x=x+dx
            call util_interpol_linear(nxbyfbt,xbyfbt,byfbt,x,bfft(i),ifail)
            if (ifail.ne.0) then
              print*,"*** Error in bfourtabzy: Util_interpol_linear failed ***"
              stop "*** Program WAVE aborted ***"
            endif
            rbfft(i)=sngl(bfft(i))
          enddo

          call util_rfft(npow2,rbfft,cffty,ifail)

          dx=(xbyfbt(nxbzfbt)-xbzfbt(1))/dble(npow2)
          x=xbzfbt(1)-dx
          do i=1,npow2
            x=x+dx
            call util_interpol_linear(nxbzfbt,xbzfbt,bzfbt,x,bfft(i),ifail)
            if (ifail.ne.0) then
              print*,"*** Error in bfourtabzy: Util_interpol_linear failed ***"
              stop "*** Program WAVE aborted ***"
          endif
            rbfft(i)=sngl(bfft(i))
          enddo

          call util_rfft(npow2,rbfft,cfftz,ifail)

          if (ifail.ne.0) then
            print*,"*** Error in bfourtabzy: Util_rfft failed ***"
            stop "*** Program WAVE aborted ***"
          endif

          if (ifourzy0.eq.11) then
            cffty(0)=(0.0,0.0)
            cfftz(0)=(0.0,0.0)
          else if (ifourzy0.eq.10) then
            cfftz(0)=(0.0,0.0)
          else if (ifourzy0.eq.1) then
            cffty(0)=(0.0,0.0)
          endif

          iallofbt=1

        endif !klinearfbt

        if (xi.eq.9999.0d0) xstart=dmin1(xbyfbt(1),xbzfbt(1))
        if (xe.eq.9999.0d0) xstop=dmax1(xbyfbt(nxbyfbt),xbzfbt(nxbzfbt))

      endif !inifbt

      bxout=0.0d0
      byout=0.0d0
      bzout=0.0d0

      axout=0.0d0
      ayout=0.0d0
      azout=0.0d0

      xiny=xin+fourysh

      if (xiny.ge.xbyfbt(1).and.xiny.le.xbyfbt(nxbyfbt)) then
        call bfoursincos(xiny-xbyfbt(1),yin,zin,
     &    bxout,byout,bzout,axout,ayout,azout,
     &    npow2/2,xbyfbt(nxbyfbt)-xbyfbt(1),0.0d0,cffty,inifbt)
      endif

      xinz=xin+fourzsh

      if (xinz.ge.xbzfbt(1).and.xinz.le.xbzfbt(nxbzfbt)) then
        call bfoursincos(xinz-xbzfbt(1),yin,zin,
     &    bxf,byf,bzf,axf,ayf,azf,
     &    npow2/2,xbzfbt(nxbzfbt)-xbzfbt(1),0.0d0,cfftz,0)
        bxout=bxout+bxf
        byout=byout+bzf
        bzout=bzout+byf
        axout=bxout+axf
        ayout=byout+azf
        azout=bzout+ayf
      endif

      return
      end
+DECK,fbtab_ini.
*CMZ :  4.00/11 17/05/2021  14.09.13  by  Michael Scheer
*-- Author :    Michael Scheer   17/05/2021
      subroutine fbtab_ini(x,irbtab,irbtabzy,irbtabxyz)

      use fbtabzymod

      implicit none
+seq,cmpara.

      DOUBLE PRECISION x,y,z,bx,by,bz,ax,ay,az,
     &  XA(NBTABP),BYA(NBTABP),Y2A(NBTABP),
     &  XAz(NBTABP),BzA(NBTABP),z2A(NBTABP)

      integer irbtab,irbtabzy,irbtabxyz

      integer :: ical=0

      COMMON/BTABC/XA,BYA,Y2A
      COMMON/BTABCz/XAz,BzA,z2A

      save ical

      if (ical.ne.0) return

      if (nfbtabc.eq.0) then
        if(irbtabxyz.ne.0) then
          call btabxyz(x,0.0d0,0.0d0,bx,by,bz,ax,ay,az)
        else if(irbtabzy.ne.0) then
          call btabzy(x,0.0d0,0.0d0,bx,by,bz,ax,ay,az)
        else if(irbtab.ne.0) then
          call btab(x,0.0d0,0.0d0,bx,by,bz,ax,ay,az)
        else
          irbtab=1
          call btab(x,0.0d0,0.0d0,bx,by,bz,ax,ay,az)
          irbtab=0
        endif
      endif

      nxbyfbt=nfbtabc
      allocate(xbyfbt(nxbyfbt),byfbt(nxbyfbt))
      xbyfbt(1:nxbyfbt)=xa(1:nxbyfbt)
      byfbt(1:nxbyfbt)=bya(1:nxbyfbt)

      if (nfbtabcz.eq.0) then
        call btabz(x,0.0d0,0.0d0,bx,by,bz,ax,ay,az,0.0d0,0.0d0)
      endif

      nxbzfbt=nfbtabc
      allocate(xbzfbt(nxbzfbt),bzfbt(nxbzfbt))
      xbzfbt(1:nxbzfbt)=xaz(1:nxbzfbt)
      bzfbt(1:nxbzfbt)=bza(1:nxbzfbt)

      ical=1

      return
      end
+DECK,util_string_replace.
*CMZ :  4.00/11 04/06/2021  10.29.44  by  Michael Scheer
*-- Author :    Michael Scheer   23/08/2018
      subroutine util_string_replace(cline,chsubstring,chreplace,lensub,lenrep,
     &  n1,n2,istat)

+seq,gplhint.

c +PATCH,//UTIL/FOR
c +DECK,util_string_replace.


c Replaces in cline of chsubstring(1:lensub) by chreplace(1:lenrep)
c starting from n1-th to n2-th occurence

      implicit none

      integer istat,l1,l2,nc1,nc2,jstat
      integer lensub,lenrep,leni,leno,n1,n2,ndone

      character(*) cline,chsubstring,chreplace
      !character(2048) cline

      istat=-1

      if (lensub.le.0) then
        leni=len_trim(chsubstring)
      else
        leni=lensub
      endif

      if (lenrep.le.0) then
        leno=len_trim(chreplace)
      else
        leno=lenrep
      endif

      if (len_trim(cline)+leno-leni.gt.len(cline)) return

      jstat=0
      ndone=1

      nc1=max(1,n1)

      if (n2.le.0) then
        nc2=len(cline)
      else
        nc2=n2
      endif

      do ndone=nc1,nc2
        call util_string_substring_counter(cline,chsubstring(1:leni),nc1,
     &    l1,l2,jstat)
        if (jstat.ne.0) exit
        cline=cline(1:l1-1) // chreplace(1:leno)// cline(l2+1:len_trim(cline))
      enddo

      istat=n2-n1+1

      return
      end
+DECK,util_string_substring_counter.
*CMZ :  4.00/11 04/09/2020  17.43.31  by  Michael Scheer
*CMZ : 00.00/20 06/12/2016  18.30.31  by  Michael Scheer
*CMZ : 00.00/16 19/03/2014  12.14.29  by  Michael Scheer
*CMZ : 00.00/15 03/09/2012  09.29.49  by  Michael Scheer
*CMZ : 00.00/06 08/03/2007  14.02.27  by  Michael Scheer
*CMZ : 00.00/05 07/03/2007  12.58.44  by  Michael Scheer
*-- Author :    Michael Scheer   07/03/2007
      subroutine util_string_substring_counter(cline,substring,ncount,
     &  ianf,iend,istat)

c Input:
c      cline, substring, ncount

c If substring is passed as variable, full length of substring is checked,
c i.e. pending invisible characters are tested as well
c Probably, you want to test trim(substring)!

c Output:
c      ianf,iend: start and end position of ncountth occurence of substring, 0 if not found
c      istat: error, i.e. string not found

c Evtl. besser FORTRAN-functions scan oder index benutzen

      implicit none

        integer ilenl,ilens,istat,ianf,iend,i,ncount,nfound

        character(*) cline,substring

        istat=-1
        ianf=0
        iend=0

        ilenl=len(cline)
        ilens=len(substring)

        if (ilens.gt.ilenl) return

        nfound=0
        do i=1,ilenl-ilens+1
          if (cline(i:i+ilens-1).eq.substring) then
            nfound=nfound+1
            if (nfound.eq.ncount) then
              ianf=i
              iend=ianf+ilens-1
              istat=0
              return
             endif
          endif
        enddo

      return
      end
+DECK,powgraz.
*CMZ :  4.00/11 15/06/2021  11.16.36  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine powgraz

+seq,spectf90u.
      use sourcef90
      use observf90

      implicit none
c      include 'uservar.cmn'

+seq,cmpara.
+seq,spect.
+seq,observ.
+seq,sourcef90.

      double precision sou(3),x,y,z,dx,dy,dz,dxs,dys,dzs

      integer :: iobsv,isour,lun,lunob,k

      do isour=1,nsource
        do iobsv=1,nobsv
          k=isour+(iobsv-1)*nsource
          dxs=obsv(1,iobsv)-schwingercen(1,iobsv,isour)
          dys=obsv(2,iobsv)-schwingercen(2,iobsv,isour)
          dzs=obsv(3,iobsv)-schwingercen(3,iobsv,isour)
          specpowtgraz(iobsv)=specpowtgraz(iobsv)+specpow(k)*
     &      sqrt((dys**2+dzs**2)/(dxs**2+dys**2+dzs**2))
        enddo !nobsv
      enddo ! nsource

      return
      end
+DECK,mrad_fringe_cubic_spline.
*CMZ :  3.06/00 18/01/2019  12.48.01  by  Michael Scheer
*CMZ :  3.05/28 04/01/2019  17.40.38  by  Michael Scheer
*CMZ :  3.05/26 06/12/2018  11.57.05  by  Michael Scheer
*CMZ :  3.05/23 12/11/2018  13.44.45  by  Michael Scheer
*-- Author :    Michael Scheer   12/11/2018
      subroutine mrad_fringe_cubic_spline(
     &  xin,y,z,bx,by,bz,ax,ay,az,fint,gap,fringe,istatus)

      implicit none

      double precision, intent(in) :: xin,y,z,gap,fint
      double precision, intent(out) :: bx,by,bz,fringe,ax,ay,az !ax,ay,az dummy
      double precision fb,fa,fringe2,fringe3,x2,x3,x

      integer, intent(out) :: istatus

      include 'phyconparam.cmn'

      istatus=0

      x=xin

      bx=0.0d0
      by=1.0d0
      bz=0.0d0

      ax=0.0d0
      ay=0.0d0
      az=0.0d0

      if (gap.le.0.0d0.or.fint.le.0.0d0) then
        goto 9999
      endif

      !Int(y=0,by,0->fringe)=1/2

      fringe=70.0d0/9.0d0*fint*gap

      if(x.lt.0.0d0) then
        by=0.0d0
        return
      else if (x.gt.fringe) then
        by=1.0d0
      else

        fringe2=fringe*fringe
        fringe3=fringe2*fringe

        x2=x*x
        x3=x2*x

        fb=-2.0d0/fringe3
        fa=3.0d0/fringe2

        bx=(2.0d0*fa*x+3.0d0*fb*x2)*y
        by=fa*x2+fb*x3+y**2*(-fa-3.0d0*fb*x)

      endif

9999  continue

      return
      end
+DECK,mrad_fringe_linear.
*CMZ :  3.05/26 06/12/2018  11.57.49  by  Michael Scheer
*CMZ :  3.05/23 27/11/2018  11.49.31  by  Michael Scheer
*-- Author :    Michael Scheer   12/11/2018
      subroutine mrad_fringe_linear(
     &  xin,y,z,bx,by,bz,ax,ay,az,fint,gap,fringe,istatus)

      implicit none

      double precision, intent(in) :: xin,y,z,gap,fint
      double precision, intent(out) :: bx,by,bz,fringe,ax,ay,az !ax,ay,az dummy
      double precision fa,x

      integer, intent(out) :: istatus

      include 'phyconparam.cmn'

      istatus=0

      x=xin

      bx=0.0d0
      by=1.0d0
      bz=0.0d0

      ax=0.0d0
      ay=0.0d0
      az=0.0d0

      if (gap.le.0.0d0.or.fint.le.0.0d0) then
        goto 9999
      endif

      fringe=6.0d0*fint*gap

      if(x.lt.0.0d0) then
        by=0.0d0
        return
      else if (x.gt.fringe) then
        by=1.0d0
      else
        fa=1.0d0/fringe
        bx=y*fa
        by=x*fa
      endif

9999  continue

      return
      end
+DECK,mrad_fringe_quintic_spline_msh.
*CMZ :  3.05/23 12/11/2018  16.49.45  by  Michael Scheer
*-- Author :    Michael Scheer   12/11/2018
      subroutine mrad_fringe_quintic_spline_msh(
     &  xin,y,z,bx,by,bz,ax,ay,az,fint,gap,fringe,istatus)

      implicit none

      double precision, intent(in) :: xin,y,z,gap,fint
      double precision, intent(out) :: bx,by,bz,fringe,ax,ay,az !ax,ay,az dummy
      double precision fb,fa,fc,fringe2,fringe3,fringe4,fringe5,
     &  x2,x3,x4,x5,x,y2,y3

      integer, intent(out) :: istatus

      include 'phyconparam.cmn'

      istatus=0

      x=xin

      bx=0.0d0
      by=0.0d0
      bz=0.0d0

      ax=0.0d0
      ay=0.0d0
      az=0.0d0

      if (gap.le.0.0d0.or.fint.le.0.0d0) then
        istatus=-1
        goto 9999
      endif

      fringe=231.0d0*fint*gap/25.0d0

      if(x.lt.0.0d0) then
        return
      else if (x.gt.fringe) then
        x=fringe
      endif

      fringe2=fringe*fringe
      fringe3=fringe2*fringe
      fringe4=fringe2*fringe2
      fringe5=fringe3*fringe2

      x2=x*x
      x3=x2*x
      x4=x2*x2
      x5=x3*x2
      y2=y*y
      y3=y2*y

      fa=10.0d0/fringe3
      fb=-15.0d0/fringe4
      fc=6.0d0/fringe5

      bx=y*(3.0d0*Fa*x2+4.0d0*fb*x3+5.0d0*fc*x4)
c     &  +y3*(-fa-4.0d0*fb*x-10.0d0*fc*x2) ! it is not Maxwell conform
c      bx=x2*y*(-3.0d0*fa-4.0d0*fb*x-5.0d0*fc*x2)
      by=(fa*x3+fb*x4+fc*x5)-y2*x*(3.0d0*fa+6.0d0*fb*x+10.0d0*fc*x2)

      bx=y*(3.0d0*Fa*x2+4.0d0*fb*x3+5.0d0*fc*x4)
     &  +y3*(-fa-4.0d0*fb*x-10.0d0*fc*x2)
      by=(fa*x3+fb*x4+fc*x5)-y2*x*(3.0d0*fa+6.0d0*fb*x+10.0d0*fc*x2)
     &  +y**4*(fb+5.0d0*fc*x) !this makes it Maxwell conform

9999  if (istatus.ne.0) then
        print*,""
        print*,"*** Error in mrad_quintic_fringe_spline_msh:",istatus
        print*,""
      endif

      return
      end
+DECK,mrad_rect_fringe_linear.
*CMZ :  3.05/23 13/11/2018  14.03.15  by  Michael Scheer
*-- Author :    Michael Scheer   12/11/2018
      subroutine mrad_rect_fringe_linear(
     &  xin,y,z,bx,by,bz,ax,ay,az,fint,gap,fringe,istatus)

      implicit none

      double precision, intent(in) :: xin,y,z,gap,fint
      double precision, intent(out) :: bx,by,bz,fringe,ax,ay,az !ax,ay,az dummy
      double precision fa,x

      integer, intent(out) :: istatus

      include 'phyconparam.cmn'

      istatus=0

      x=xin

      bx=0.0d0
      by=0.0d0
      bz=0.0d0

      ax=0.0d0
      ay=0.0d0
      az=0.0d0

      if (gap.le.0.0d0.or.fint.le.0.0d0) then
        istatus=-1
        goto 9999
      endif

      fringe=6.0d0*fint*gap

      if(x.lt.0.0d0) then
        return
      else if (x.gt.fringe) then
        x=fringe
      endif

      fa=1.0d0/fringe

      bx=y*fa
      by=x*fa

9999  return
      end
+DECK,bbend.
*CMZ :  4.01/07 09/01/2025  08.41.22  by  Michael Scheer
*CMZ :  4.00/11 27/07/2021  13.26.18  by  Michael Scheer
*-- Author :    Michael Scheer   01/07/2021
      subroutine bbend(xin,yin,zin,bxout,byout,bzout,axout,ayout,azout,
     &  fint,gap,center,b,pin,vnin,pout,vnout,
     &  modus,istatus,inowarn)

      implicit none

      double precision xin,yin,zin,bxout,byout,bzout,axout,ayout,azout,
     &  fringe,gap,Center(3),B(3),Pin(3),vnin(3),Pout(3),vnout(3),bout(3),bn(3),
     &  bnn,dum(3),r(3),rn(3),rnn,dumn,rin(3),
     &  qin(3),qout(3),distin,distout,x,y,z,vnormorb(3),fint

      integer :: modus, istatus, inowarn, ibad=0,istat,iover, ical=0

c The orbit plane contains the points Center,Pin, and Pout. The field vector
c B is normal to the orbit plane.
c The entrace plane is perpendicular the orbit plane, phiin is the
c angle around B, and Pin is a point in the plane;  the exit plane is defined
c accordingly

c The field is calculated with respect to the entrace or exit plane closer to
c xin,yin,zin. Yin is the distance to the orbit plane.

c      save rino

      istatus=0
      !ical=ical+1

      axout=0.0d0
      ayout=0.0d0
      azout=0.0d0

      bxout=0.0d0
      byout=0.0d0
      bzout=0.0d0

      bnn=norm2(b)
      if (bnn.eq.0.0d0) goto 9999

      bn=b/bnn

      rin(1)=xin
      rin(2)=yin
      rin(3)=zin

      call util_plane(pout,center,pin,rin,vnormorb,y,iover,istat)

      if (istat.ne.0) then
        if (inowarn.eq.0) then
          print*,"*** Error in bbend: Could not calculate distance to orbit plane  ***"
        endif
        istatus=-2
        return
      endif

      if (norm2(abs(vnormorb)-abs(bn)).gt.1.0d-9) then
        if (inowarn.eq.0) then
          print*,"*** Error in bbend: Normal vector of  orbit plane not parallel to B ***"
        endif
        istatus=-1
        return
      endif

      dumn=norm2(vnin)
      if (dumn.eq.0.0d0) then
        if (inowarn.eq.0) then
          print*,"*** Error in bbend: Zero normal vector of  entrance plane ***"
        endif
        istatus=-1
        return
      else
        vnin=vnin/dumn
      endif

      dumn=norm2(vnout)
      if (dumn.eq.0.0d0) then
        if (inowarn.eq.0) then
          print*,"*** Error in bbend: Zero normal vector of exit plane ***"
        endif
        istatus=-1
        return
      else
        vnout=vnout/dumn
      endif

      if (abs(dot_product(vnin,bn)).gt.1.0d-9) then
        if (inowarn.eq.0) then
          print*,"*** Error in bbend: Normal vector of  entrance plane not perpendicular to B ***"
        endif
        istatus=-1
        return
      endif

      if (abs(dot_product(vnout,bn)).gt.1.0d-9) then
        if (inowarn.eq.0) then
          print*,"*** Error in bbend: Normal vector of  exit plane not perpendicular to B ***"
        endif
        istatus=-1
        return
      endif

      call util_vcross(vnin,bn,qin)
      qin=pin+qin

      call util_plane(pin,pin+bn,qin,rin,vnin,distin,iover,istat)

      if (istat.ne.0) then
        if (inowarn.eq.0) then
          print*,"*** Error in bbend: Could not calculate distance to entrance plane  ***"
        endif
        istatus=-3
        return
      endif

      if (distin.lt.0.0d0) then
        goto 9999 ! outside planes
      endif

      call util_vcross(vnout,bn,qout)
      qout=pout+qout

      call util_plane(pout,pout+bn,qout,rin,vnout,distout,iover,istat)

c      if (ical.ge.4729) then
c        print*, ical,rin,distin,distout
c        stop
c      endif

      if (distout.gt.0.0d0) then
        goto 9999 ! outside planes
      endif

      if (istat.ne.0) then
        if (inowarn.eq.0) then
          print*,"*** Error in bbend: Could not calculate distance to exit plane  ***"
        endif
        istatus=-4
        return
      endif

      if (fint.le.0.0d0.or.gap.le.0.0d0) then

        byout=bnn

      else

        if (abs(distin).le.abs(distout)) then
          x=distin
        else
          x=-distout
        endif !distin

        if (modus.eq.3) then
          call mrad_fringe_cubic_spline(x,y,zin,
     &      bout(1),bout(2),bout(3),axout,ayout,azout,fint,gap,fringe,
     &      istatus)
        else if (modus.eq.5) then
          call mrad_fringe_quintic_spline(x,y,zin,
     &      bout(1),bout(2),bout(3),axout,ayout,azout,fint,gap,fringe,
     &      istatus)
        else
          bout=b
          goto 9999
        endif !modus

        if (istat.ne.0) then
          if (inowarn.eq.0) then
            print*,"*** Error in bbend: Bad return from mrad_fringe_cubic_spline  ***"
          endif
        endif

        if (norm2(bout).eq.0.0d0) goto 9999

        if (abs(distin).le.abs(distout)) then
          bout=(-bout(1)*vnin+bout(2)*bn)*bnn
        else
          bout=(bout(1)*vnout+bout(2)*bn)*bnn
        endif !distin

        bxout=bout(1)
        byout=bout(2)
        bzout=bout(3)

      endif !fringe

c      if (ical.gt.0) then
c        write(88,*) xin,zin,byout,atan2(rin(3)-rino(3),rin(1)-rino(1))*57.29577951308232
c      endif
c      rino=rin
c      ical=ical+1

9999  continue

      return
      end
+DECK,hdeletnomh.
*CMZ :  4.00/14 22/12/2021  13.42.33  by  Michael Scheer
*CMZ :  4.00/13 20/12/2021  15.50.51  by  Michael Scheer
*CMZ :  3.03/04 27/10/2017  09.47.51  by  Michael Scheer
*CMZ :  3.02/00 01/09/2014  11.11.30  by  Michael Scheer
*CMZ :  3.01/06 23/06/2014  16.20.53  by  Michael Scheer
*CMZ :  2.67/00 17/02/2012  13.30.11  by  Michael Scheer
*-- Author :    Michael Scheer   19/01/2012
      subroutine hdeletnomh(id)
+seq,gplhint.

+seq,contrl.
+seq,rootc,if=-noroot.

      integer id,kind(32)

      if (iroottrees.ne.0) then
+self,if=-noroot.
        call hkindm(id,kind,' ')
        call hdeletcc(id,kind(1))
+self.,if=-noroot.
      endif

      if (iroottrees.ge.0) then
+self,if=-nohbook.
        call hdelet(id)
+self.
+self,if=mshhbook.
        call msh_hdelet(int8(id))
+self.
      endif

+self,if=-noroot.
      kindhis(id)=0
+self.
      return
      end
+DECK,wbmap_for_spectra.
*CMZ :  4.00/15 09/03/2022  15.57.19  by  Michael Scheer
*-- Author :    Michael Scheer   28/09/95
      subroutine wbmap_for_spectra
+seq,gplhint.

c--- to write 3d field map for program spectra

      implicit none

      external dcosd,dsind
      double precision dcosd,dsind

+seq,contrl.
+seq,cmpara.
+seq,myfiles.
+seq,bmap.

      double precision :: dx=0.0d0,dy=0.0d0,dz=0.0d,
     &  bx,by,bz,ax,ay,az,x,y,z,r,phi

      integer ix,iy,iz,lunmap

      open(newunit=lunmap,file=filebmap,status='new')

      if (xmapmn.eq.9999.) xmapmn=xstart
      if (xmapmx.eq.9999.) xmapmx=xstop

      if (xmapmx.lt.xmapmn) then
        write(lungfo,*)
        write(lungfo,*)'*** Error in wbmap_to_spectra xmapmx.lt.xmapmn'
        write(lungfo,*)'Check namelist wbmap in wave.in'
        write(lungfo,*)
        write(6,*)
        write(6,*)'*** Error in wbmap_to_spectra xmapmx.lt.xmapmn'
        write(6,*)'Check namelist wbmap in wave.in'
        write(6,*)
        stop '*** Program WAVE aborted ***'
      endif

      if (ymapmx.lt.ymapmn) then
        write(lungfo,*)
        write(lungfo,*)'*** error in wbmap_to_spectra ymapmx.lt.ymapmn'
        write(lungfo,*)'check namelist wbmap in wave.in'
        write(lungfo,*)
        write(6,*)
        write(6,*)'*** error in wbmap_to_spectra ymapmx.lt.ymapmn'
        write(6,*)'check namelist wbmap in wave.in'
        write(6,*)
        stop '*** Program WAVE aborted ***'
      endif

      if (zmapmx.lt.zmapmn) then
        write(lungfo,*)
        write(lungfo,*)'*** error in wbmap_to_spectra zmapmx.lt.zmapmn'
        write(lungfo,*)'check namelist wbmap in wave.in'
        write(lungfo,*)
        write(6,*)
        write(6,*)'*** error in wbmap_to_spectra zmapmx.lt.zmapmn'
        write(6,*)'check namelist wbmap in wave.in'
        write(6,*)
        stop '*** Program WAVE aborted ***'
      endif

      if (nmapx.eq.-9999) nmapx=nint((xstop-xstart)*myinum)+1

      if (nmapx.gt.1) dx=(xmapmx-xmapmn)/(nmapx-1)
      if (nmapy.gt.1) dy=(ymapmx-ymapmn)/(nmapy-1)
      if (nmapz.gt.1) dz=(zmapmx-zmapmn)/(nmapz-1)

      write(lunmap,*) sngl(dz*1000.0d0),sngl(dy*1000.0d0),sngl(dx*1000.0d0),
     &  nmapz,nmapy,nmapx

      do iz=1,nmapz
        do iy=1,nmapy
          do ix=1,nmapx
            x=xmapmn+(ix-1)*dx
            y=ymapmn+(iy-1)*dy
            z=-(zmapmn+(iz-1)*dz)
            call mybfeld(x,y,z,bx,by,bz,ax,ay,az)
            write(lunmap,*)sngl(bx),sngl(by),sngl(-bz)
            enddo
          enddo
        enddo

      flush (lunmap)
      close (lunmap)

      write(lungfo,*)
      write(lungfo,*)'     Subroutine wbmap_to_spectra: field map written'
      write(lungfo,*)'       File:        ',filebmap
      write(lungfo,*)'       nx,xmin,xmax:',nmapx,xmapmn,xmapmx
      write(lungfo,*)'       ny,ymin,ymax:',nmapy,ymapmn,ymapmx
      write(lungfo,*)'       nz,zmin,zmax:',nmapz,zmapmn,zmapmx
      write(lungfo,*)

      return
      end
+DECK,bhalbasy2arg.
*CMZ :  4.00/15 24/03/2022  07.43.56  by  Michael Scheer
*CMZ :          24/03/2022  07.14.23  by  Michael Scheer
      subroutine bhalbasy2arg(xin,yin,zin,xcen,b0halbasy,ahwpol,
     &  zlhalbasy,xlhalbasy,bxout,byout,bzout,axout,ayout,azout)

+seq,gplhint.

c subroutine calculates magnetic field and vector potential for simple
c wavelength shifter model with end poles. the field of the single poles
c corresponds to halbachs formula.
c input and output correspond to lab.-system, where x is coordinate on
c longitudinal axis

      implicit none

      double precision xin,yin,zin,bxout,byout,bzout,axout,ayout,azout,
     &  xkx,yky,zkz,dsnxkx,dcsxkx,dshyky,dchyky,dsnzkz,dcszkz
     &  ,bxh,byh,bzh,axh,ayh,azh,ahwmod,totlen,totlen2,ahwpol,
     &  x,x2,xcen,b0halbasy,
     &  zlhalbasy,ylhalbasy,xlhalbasy,
     &  zkhalbasy,ykhalbasy,xkhalbasy,
     &  zlhalbasy2,xlhalbasy2,
     &  zkhalbasy2,ykhalbasy2,xkhalbasy2

+seq,phycon.

c--- k-values

      xkhalbasy=0.0d0
      ykhalbasy=0.0d0
      zkhalbasy=0.0d0

      if (zlhalbasy.ne.0.0d0) zkhalbasy=2.0d0*pi1/zlhalbasy
      if (ylhalbasy.ne.0.0d0) ykhalbasy=2.0d0*pi1/ylhalbasy
      if (xlhalbasy.ne.0.0d0) xkhalbasy=2.0d0*pi1/xlhalbasy

c--- adjust k-values

      ykhalbasy=dsqrt(zkhalbasy**2+xkhalbasy**2)
      ylhalbasy=2.0d0*pi1/ykhalbasy

c--- bending radius and device length

      totlen=zlhalbasy*((ahwpol-1.0d0)/2.0d0+1.0d0)
      totlen2=totlen/2.0d0

      totlen=zlhalbasy*((ahwpol-1.0d0)/2.0d0+1.0d0)
      totlen2=totlen/2.0d0

      x=xin-xcen
      if (dabs(xin).gt.totlen2) then
        bxout=0.0
        byout=0.0
        bzout=0.0
        axout=0.0
        ayout=0.0
        azout=0.0
        return
      endif

      if (dabs(x).le.totlen2-zlhalbasy/2.0d0) then

        xkx=xkhalbasy*(-zin)
        yky=ykhalbasy*yin
        zkz=zkhalbasy*x

        dsnxkx=dsin(xkx)
        dcsxkx=dcos(xkx)
        dshyky=dsinh(yky)
        dchyky=dsqrt(1.0d0+dshyky*dshyky)
        dsnzkz=dsin(zkz)
        dcszkz=dcos(zkz)

        bxh=-xkhalbasy/ykhalbasy*b0halbasy*dsnxkx*dshyky*dcszkz
        byh=                     b0halbasy*dcsxkx*dchyky*dcszkz
        bzh=-zkhalbasy/ykhalbasy*b0halbasy*dcsxkx*dshyky*dsnzkz

        axh=b0halbasy/zkhalbasy*                    dcsxkx*dchyky*dsnzkz
        ayh=b0halbasy/zkhalbasy*xkhalbasy/ykhalbasy*dsnxkx*dshyky*dsnzkz
        azh=0.0

        bzout=-bxh
        byout=byh
        bxout=bzh

        azout=-axh
        ayout=ayh
        axout=azh

      else

        ahwmod=-isign(1,-(mod(nint(ahwpol),4)-2))/2.0d0

        xkhalbasy2=xkhalbasy

        zkhalbasy2=zkhalbasy
        zlhalbasy2=2.0d0*pi1/zkhalbasy2
        ykhalbasy2=dsqrt(zkhalbasy2**2+xkhalbasy2**2)
        ylhalbasy=2.0d0*pi1/ykhalbasy2

        x2=x+totlen2+zlhalbasy/2.0d0

        xkx=xkhalbasy2*(-zin)
        yky=ykhalbasy2*yin
        zkz=zkhalbasy2*(x2)

        dsnxkx=dsin(xkx)
        dcsxkx=dcos(xkx)
        dshyky=dsinh(yky)
        dchyky=dsqrt(1.0d0+dshyky*dshyky)
        dsnzkz=dsin(zkz)
        dcszkz=dcos(zkz)

        bxh=-xkhalbasy2/ykhalbasy2*b0halbasy*dsnxkx*dshyky*dcszkz
        byh=                      b0halbasy*dcsxkx*dchyky*dcszkz
        bzh=-zkhalbasy2/ykhalbasy2*b0halbasy*dcsxkx*dshyky*dsnzkz

        axh=b0halbasy/zkhalbasy2*                    dcsxkx*dchyky*dsnzkz
        ayh=b0halbasy/zkhalbasy2*xkhalbasy2/ykhalbasy2*dsnxkx*dshyky*dsnzkz
        azh=0.0

        zkhalbasy2=zkhalbasy*2.0d0
        zlhalbasy2=2.0d0*pi1/zkhalbasy2
        ykhalbasy2=dsqrt(zkhalbasy2**2+xkhalbasy2**2)
        ylhalbasy=2.0d0*pi1/ykhalbasy2

        xkx=xkhalbasy2*(-zin)
        yky=ykhalbasy2*yin
        zkz=zkhalbasy2*(x2)

        dsnxkx=dsin(xkx)
        dcsxkx=dcos(xkx)
        dshyky=dsinh(yky)
        dchyky=dsqrt(1.0d0+dshyky*dshyky)
        dsnzkz=dsin(zkz)
        dcszkz=dcos(zkz)

        bxh=bxh-xkhalbasy2/ykhalbasy2*b0halbasy*dsnxkx*dshyky*dcszkz
        byh=byh+                      b0halbasy*dcsxkx*dchyky*dcszkz
        bzh=bzh-zkhalbasy2/ykhalbasy2*b0halbasy*dcsxkx*dshyky*dsnzkz

        axh=axh+b0halbasy/zkhalbasy2*                    dcsxkx*dchyky*dsnzkz
        ayh=ayh+b0halbasy/zkhalbasy2*xkhalbasy2/ykhalbasy2*dsnxkx*dshyky*dsnzkz
        azh=0.0

        bzout=bxh*ahwmod
        byout=-byh*ahwmod
        bxout=-bzh*ahwmod

        azout=axh*ahwmod
        ayout=-ayh*ahwmod
        axout=-azh*ahwmod

      endif

      return
      end
+DECK,uradfield.
*CMZ :  4.01/02 08/05/2023  13.25.03  by  Michael Scheer
*CMZ :  4.00/15 10/04/2022  10.51.04  by  Michael Scheer
*CMZ :  4.00/13 16/11/2021  17.18.53  by  Michael Scheer
*CMZ :  3.05/05 09/07/2018  15.22.23  by  Michael Scheer
*CMZ :  3.05/04 05/07/2018  08.56.42  by  Michael Scheer
*CMZ :  3.04/00 23/01/2018  17.17.28  by  Michael Scheer
*CMZ :  3.03/04 04/12/2017  15.56.53  by  Michael Scheer
*CMZ :  3.03/02 18/11/2015  12.56.22  by  Michael Scheer
*CMZ :  3.02/04 13/03/2015  10.36.11  by  Michael Scheer
*CMZ :  2.70/00 12/11/2012  11.53.09  by  Michael Scheer
*CMZ :  2.68/04 04/09/2012  09.38.42  by  Michael Scheer
*CMZ :  2.68/03 29/08/2012  12.25.27  by  Michael Scheer
*-- Author :    Michael Scheer   22/08/2012
      subroutine uradfield(x,y,z,bxout,byout,bzout,ex,ey,ez,gamma,istatus,
     &  modewave)

c Author: Michael Scheer, Michael.Scheer@Helmholtz-Berlin.de

c NO WARRANTY

+seq,gplhint.

C     SPECIAL VERSION FOR WAVE

      implicit none

      double precision :: x,y,z,bx,by,bz,ex,ey,ez,tolerance=0.001d0,
     &  bxout,byout,bzout,gamma,axout,ayout,azout

      integer :: istatus,modewave

      ex=0.0d0
      ey=0.0d0
      ez=0.0d0

      call mybfeld(x,y,z,bxout,byout,bzout,axout,ayout,azout)

      return
      end
+DECK,iutil_date_time.
*CMZ :  4.00/15 02/06/2022  09.35.26  by  Michael Scheer
*CMZ :  3.01/02 25/02/2014  14.52.02  by  Michael Scheer
*CMZ :  2.70/06 07/01/2013  13.42.44  by  Michael Scheer
*CMZ :  2.70/05 02/01/2013  13.41.59  by  Michael Scheer
*CMZ :  2.66/20 18/10/2011  08.06.47  by  Michael Scheer
*CMZ :  2.66/18 01/12/2010  10.11.23  by  Michael Scheer
*CMZ :  2.66/13 23/11/2010  09.59.43  by  Michael Scheer
*CMZ :  2.63/00 10/01/2008  12.40.35  by  Michael Scheer
*CMZ :  2.58/01 17/01/2007  10.59.07  by  Michael Scheer
*CMZ :  2.57/04 13/01/2006  11.10.13  by  Michael Scheer
*CMZ :  2.57/03 09/12/2005  11.19.05  by  Michael Scheer
*CMZ :  2.52/15 03/01/2005  15.51.05  by  Michael Scheer
*CMZ :  2.47/22 03/12/2003  10.29.33  by  Michael Scheer
*CMZ :  2.46/02 21/01/2003  16.21.35  by  Michael Scheer
*CMZ :  2.41/09 14/08/2002  17.26.05  by  Michael Scheer
*CMZ :  2.39/00 03/01/2002  12.30.43  by  Michael Scheer
*CMZ :  2.20/01 02/01/2001  11.38.55  by  Michael Scheer
*CMZ :  2.15/00 01/05/2000  11.48.08  by  Michael Scheer
*CMZ :  2.13/04 24/01/2000  17.57.30  by  Michael Scheer
*CMZ :  2.13/00 06/10/99  16.32.34  by  Michael Scheer
*CMZ :  1.03/06 01/07/98  10.29.18  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.57.32  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.14.41  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine iutil_date_time

+seq,gplhint.

      implicit none
      ! calculates date and time as numbers and corresponding string
+seq,datetime.

      ! real: util_time
      ! integer i_util_time, i_util_date,idatetime(8)
      ! integer*8 i_util_date_time
      ! string: ch_i_util_date_time, dtday,dttime,dtzone

      integer i,k
      character(6) c6
      call date_and_time(dtday,dttime,dtzone,idatetime)

      read(dttime,*) util_time

      i_util_time=nint(util_time)
      write(c6,'(i6)') i_util_time

      ch_i_util_date_time=trim(dtday) // c6
      read(ch_i_util_date_time,'(i6)') i_util_date
      read(ch_i_util_date_time,*) i_util_date_time
      k=0
      do i=1,len_trim(ch_i_util_date_time)
        if (ch_i_util_date_time(i:i).ne.' ') then
          k=k+1
          ch_i_util_date_time(k:k)=ch_i_util_date_time(i:i)
        endif
      enddo

      return
      end
+DECK,modules.
*CMZ :  4.01/00 12/03/2023  22.19.43  by  Michael Scheer
*-- Author :    Michael Scheer   01/11/2000
+seq,spectf90m.
+seq,ompmod.
+seq,phyconmod.
+seq,clustermod.
+seq,mhbook_module.
+seq,undumagf90m.
+seq,commandlinef90m.
+seq,bmessf90m.
+seq,trackf90m.
+seq,sourcef90m.
+seq,observf90m.
+seq,f1k.
+seq,fourbtabzy.
+seq,afreqf90m.
+seq,bunchf90m.
+seq,wfoldf90m.
+seq,reargf90m.
+seq,workf90m.
+seq,amplif90m.
+seq,bmpot3dm.
+seq,bpharmf90m.
+seq,bpoly3df90m.
+seq,bpoly2dhf90m.
+seq,bwpolyederf90m.
+seq,usemf90m.
+seq,wbetaf90m.
+seq,waveg1.
+seq,phasef90m.
+seq,phasewsf90m.
+seq,souintmod.
      subroutine modules
      end
+DECK,bundumap,T=F77.
*CMZ :  4.01/03 01/06/2023  12.27.44  by  Michael Scheer
*CMZ :  4.01/02 07/05/2023  10.14.22  by  Michael Scheer
*CMZ :  4.00/16 09/08/2022  09.07.08  by  Michael Scheer
*CMZ :  4.00/07 07/06/2020  15.15.28  by  Michael Scheer
*CMZ :  3.05/05 13/07/2018  11.51.31  by  Michael Scheer
*CMZ :  3.03/04 29/11/2017  10.21.49  by  Michael Scheer
*CMZ :  3.02/00 10/09/2014  14.10.09  by  Michael Scheer
*CMZ :  3.01/04 26/05/2014  16.15.21  by  Michael Scheer
*CMZ :  3.01/00 06/05/2013  09.13.42  by  Michael Scheer
*CMZ :  2.68/05 01/10/2012  14.11.38  by  Michael Scheer
*CMZ :  2.68/04 04/09/2012  09.22.40  by  Michael Scheer
*CMZ :  2.68/03 31/08/2012  09.01.42  by  Michael Scheer
*CMZ :  2.68/02 02/07/2012  13.51.47  by  Michael Scheer
*-- Author :    Michael Scheer   18/06/2012
C**********************************************************************
      subroutine bundumap(xin,yin,zin,bxout,byout,bzout,xsta,xsto)
C**********************************************************************
+seq,gplhint.

      implicit none

+seq,undumagc.

      double precision, dimension (:,:), allocatable :: bmappe

      double precision xin,yin,zin,x,y,z,bx,by,bz,step,stepy,xold,yold,
     &  bxout,byout,bzout,xsta,xsto,
     &  bmxmin,bmxmax,bmymin,bmymax,bmzmin,bmzmax,
     &  bmbxmin,bmbxmax,bmbymin,bmbymax,bmbzmin,bmbzmax,
     &  bmapdy,bmapdz,x1,x2,a3(3),x3(3),b3(3),
     &  b11,b12,b13,b21,b22,b23,b31,b32,b33,bb1,bb2,bb3,dy,dz

      double precision b111(3),b211(3), b121(3),b221(3)
      double precision b112(3),b212(3), b122(3),b222(3)
      double precision b112111(3),b212211(3), b122121(3),b222221(3)
      double precision blow(3),bhig(3),b(3),dxx,dyy,dzz,xx,yy,zz,y1,z1

      real*8 :: eps=1.0d-6

      integer:: ical,iwarnx,iwarny,iwarnz,nx,ny,nz,last,ntot,ianf,
     &  kd,ix1,ix2,iy1,iy2,iz1,iz2,nyz,i,k,lunm,iwarnbmap,
     &  kx1,kx2,kx3,ky1,ky2,ky3,kz1,kz2,kz3,lungfo=16,ifail

      character(2048) cline

      data ical/0/
      data iwarnx/0/
      data iwarny/0/
      data iwarnz/0/
      data xold/1.0d30/
      data yold/1.0d30/

      save

      iwarnbmap=0

      if (ical.eq.0) then

        bmxmin= 1.0d99
        bmxmax=-1.0d99
        bmymin= 1.0d99
        bmymax=-1.0d99
        bmzmin= 1.0d99
        bmzmax=-1.0d99

        bmbxmin= 1.0d99
        bmbxmax=-1.0d99
        bmbymin= 1.0d99
        bmbymax=-1.0d99
        bmbzmin= 1.0d99
        bmbzmax=-1.0d99

        ifail=0
        open(newunit=lunm,file='undumag.map',status='old',iostat=ifail)
        if (ifail.ne.0) then
          print*,''
          print*,'*** Error in bundumap: Could not open file undumag.map ***'
          print*,''
          stop "*** Program WAVE aborted ***"
        endif
        ntot=0
        nx=-1
        ny=-1
        nz=0
 1      read(lunm,'(a)',end=9) cline
        last=len_trim(cline)

        if (
     &      cline(1:1).ne.'%'.and.
     &      cline(1:1).ne.'!'.and.
     &      cline(1:1).ne.'#'.and.
     &      cline(1:1).ne.'*'.and.
     &      cline(1:1).ne.'@'.and.
     &      cline(1:2).ne.' %'.and.
     &      cline(1:2).ne.' !'.and.
     &      cline(1:2).ne.' #'.and.
     &      cline(1:2).ne.' *'.and.
     &      cline(1:2).ne.' @'
     &      ) then

          ntot=ntot+1
          read(cline(1:last),*)x,y,z,bx,by,bz

          x=x/1000.0d0
          y=y/1000.0d0
          z=z/1000.0d0

          if (x.lt.bmxmin) bmxmin=x
          if (x.gt.bmxmax) bmxmax=x
          if (y.lt.bmymin) bmymin=y
          if (y.gt.bmymax) bmymax=y
          if (z.lt.bmzmin) bmzmin=z
          if (z.gt.bmzmax) bmzmax=z
          if (bx.lt.bmbxmin) bmbxmin=bx
          if (bx.gt.bmbxmax) bmbxmax=bx
          if (by.lt.bmbymin) bmbymin=by
          if (by.gt.bmbymax) bmbymax=by
          if (bz.lt.bmbzmin) bmbzmin=bz
          if (bz.gt.bmbzmax) bmbzmax=bz

          if (ntot.eq.1) then
            xold=x
            yold=y
          endif

          if (ntot.eq.2.and.abs(x-xold).gt.eps) then
            write(6,*)'*** Error in BUNDUMAP: Bad file format! ***'
            write(6,*)'*** x must run latest! ***'
            write(6,*)'*** Is it a 3d map? ***'
            write(lungfo,*)'*** Error in BUNDUMAP: Bad file format! ***'
            write(lungfo,*)'*** x must run latest! ***'
            write(lungfo,*)'*** Is it a 3d map? ***'
            stop '*** WAVE aborted ***'
          endif

          if (nx.eq.-1) then
            if (ny.eq.-1) then
              if (abs(y-yold).le.eps) then
                nz=nz+1
              else
                ny=nz+1
              endif
            else if (abs(x-xold).le.eps) then
              ny=ny+1
            else
              ny=ny/nz
              nx=0
            endif !ny
          endif !nx

        endif !line type

        goto 1
 9      rewind(lunm)

        nx=ntot/(ny*nz)

        if (nx.lt.3.and.kbundumap_c.eq.1.or.nx.lt.2.and.kbundumap_c.eq.2) then
          write(lungfo,*)'*** Error in BMAP: Too few data for field map on undumag.map'
          write(lungfo,*)'*** Program WAVE aborted ***'
          write(6,*)'*** Error in BMAP: Too few data for field map on undumag.map'
          write(6,*)'*** Program WAVE aborted ***'
          stop
        else
          allocate(bmappe(6,ntot))
        endif

        ntot=0
 11     read(lunm,'(a)',end=99) cline

        last=len_trim(cline)

        if (
     &      cline(1:1).ne.'%'.and.
     &      cline(1:1).ne.'!'.and.
     &      cline(1:1).ne.'#'.and.
     &      cline(1:1).ne.'*'.and.
     &      cline(1:1).ne.'@'.and.
     &      cline(1:2).ne.' %'.and.
     &      cline(1:2).ne.' !'.and.
     &      cline(1:2).ne.' #'.and.
     &      cline(1:2).ne.' *'.and.
     &      cline(1:2).ne.' @'
     &      ) then
          ntot=ntot+1
          read(cline(1:last),*) x,y,z,bx,by,bz
          x=x/1000.0d0
          y=y/1000.0d0
          z=z/1000.0d0
          bmappe(1,ntot)=x
          bmappe(2,ntot)=y
          bmappe(3,ntot)=z
          bmappe(4,ntot)=bx
          bmappe(5,ntot)=by
          bmappe(6,ntot)=bz
        endif
        goto 11
 99     close(lunm)

        step=1.0d0
        stepy=step/10.0d0
        bmapdy=1.0d0
        if (ny.gt.1) bmapdy=(bmymax-bmymin)/(ny-1)
        bmapdz=1.0d0
        if (nz.gt.1) bmapdz=(bmzmax-bmzmin)/(nz-1)

        ix1=1
        ix2=ntot
        nyz=ny*nz

        ical=1
      endif

      if (xsta.eq.9999.0d0.or.xsto.eq.9999.0d0) then
        if (xsta.eq.9999.0d0) xsta=bmxmin
        if (xsto.eq.9999.0d0) xsto=bmxmax
        return
      endif

      if (bxout.eq.-9999.0d0) then
        xin=bmxmin
        return
      else if (bxout.eq.9999.0d0) then
        xin=bmxmax
        return
      endif

      x=xin
      y=yin
      z=zin

      IF (IWARNX.EQ.0.AND.(X.LT.BMXMIN-STEP.OR.X.GT.BMXMAX+STEP)) THEN
        WRITE(6,*)'*** WARNING: IN BMAP: X OUT OF RANGE'
        WRITE(6,*)'X:',X
        WRITE(6,*)'Y:',Y
        WRITE(6,*)'Z:',Z
        WRITE(LUNGFO,*)'*** WARNING IN BUNDUMAP: X OUT OF RANGE'
        WRITE(LUNGFO,*)'X:',X
        WRITE(LUNGFO,*)'Y:',Y
        WRITE(LUNGFO,*)'Z:',Z
        IWARNX=1
      ENDIF

      if (x.lt.bmxmin) then
        ix1=1
        ix2=2
      else if (x.gt.bmxmax) then
        ix1=nx-1
        ix2=nx
      else

        if (x.ge.bmappe(1,(ix1-1)*nyz+1)) then
c hunt up
          kd=1
111       ix2=min(ix1+kd,nx)
          if (x.gt.bmappe(1,nyz*(ix2-1)+1)) then
            kd=2*kd
            ix1=ix2
            goto 111
          endif
        else    !(x.ge.bmappe(1,ix1))
c hunt down
          kd=1
          ix2=ix1
22        ix1=max(ix2-kd,1)
          if (x.lt.bmappe(1,(ix1-1)*nyz+1)) then
            kd=2*kd
            ix2=ix1
            goto 22
          endif
        endif

1111    if (ix2-ix1.gt.1) then
          k=(ix2+ix1)/2
          if(bmappe(1,(k-1)*nyz+1).gt.x)then
            ix2=k
          else
            ix1=k
          endif
          goto 1111
        endif
      endif

      x1=bmappe(1,(ix1-1)*nyz+1)
      x2=bmappe(1,(ix2-1)*nyz+1)
      dxx=(x-x1)/(x2-x1)

      if (ny.gt.1) then
        if (y.lt.bmymin) then
          iy1=1
        else
          iy1=int((y-bmymin)/bmapdy)+1
          iy1=max(1,iy1)
        endif
        iy2=iy1+1
        if (iy2.gt.ny) then
          iy2=ny
          iy1=iy2-1
        endif
      else
        iy1=1
        iy2=1
      endif

      if (nz.gt.1) then
        if (z.lt.bmzmin) then
          iz1=1
        else
          iz1=int((z-bmzmin)/bmapdz)+1
          iz1=max(1,iz1)
        endif
        iz2=iz1+1
        if (iz2.gt.nz) then
          iz2=nz
          iz1=iz2-1
        endif
      else
        iz1=1
        iz2=1
      endif

      if (kbundumap_c.eq.2) then

        dyy=(y-(bmymin+(iy1-1)*bmapdy))/bmapdy
        dzz=(z-(bmzmin+(iz1-1)*bmapdz))/bmapdz

        do i=1,3

          b111(i)=bmappe(3+i,iz1+(iy1-1)*nz+(ix1-1)*nyz)
          b211(i)=bmappe(3+i,iz2+(iy1-1)*nz+(ix1-1)*nyz)
          b121(i)=bmappe(3+i,iz1+(iy2-1)*nz+(ix1-1)*nyz)
          b221(i)=bmappe(3+i,iz2+(iy2-1)*nz+(ix1-1)*nyz)
          b112(i)=bmappe(3+i,iz1+(iy1-1)*nz+(ix2-1)*nyz)
          b212(i)=bmappe(3+i,iz2+(iy1-1)*nz+(ix2-1)*nyz)
          b122(i)=bmappe(3+i,iz1+(iy2-1)*nz+(ix2-1)*nyz)
          b222(i)=bmappe(3+i,iz2+(iy2-1)*nz+(ix2-1)*nyz)

          b112111(i)=b111(i)+(b112(i)-b111(i))*dxx
          b122121(i)=b121(i)+(b122(i)-b121(i))*dxx
          b212211(i)=b211(i)+(b212(i)-b211(i))*dxx
          b222221(i)=b221(i)+(b222(i)-b221(i))*dxx

          blow(i)=b112111(i)+(b212211(i)-b112111(i))*dzz
          bhig(i)=b122121(i)+(b222221(i)-b122121(i))*dzz

          b(i)=blow(i)+(bhig(i)-blow(i))*dyy

        enddo

      else

        if (ix1.gt.1) then
          kx1=ix1-1
          kx2=ix1
          kx3=ix1+1
        else
          kx1=ix1
          kx2=ix1+1
          kx3=ix1+2
        endif

        if (ny.gt.1) then
          if (iy1.gt.1) then
            ky1=iy1-1
            ky2=iy1
            ky3=iy1+1
          else
            ky1=iy1
            ky2=iy1+1
            ky3=iy1+2
          endif
        else
          ky1=1
          ky2=1
          ky3=1
        endif

        if (nz.gt.1) then
          if (iz1.gt.1) then
            kz1=iz1-1
            kz2=iz1
            kz3=iz1+1
          else
            kz1=iz1
            kz2=iz1+1
            kz3=iz1+2
          endif
        else
          kz1=1
          kz2=1
          kz3=1
        endif

        x3(1)=0.0d0

        x1=bmappe(1,kz1+(ky1-1)*nz+(kx1-1)*nyz)
        xx=x-x1

        y1=bmappe(2,kz1+(ky1-1)*nz+(kx1-1)*nyz)
        yy=y-y1
        dy=bmappe(2,kz1+(ky2-1)*nz+(kx1-1)*nyz)-y1

        z1=bmappe(3,kz1+(ky1-1)*nz+(kx1-1)*nyz)
        zz=z-z1
        dz=bmappe(3,kz2+(ky1-1)*nz+(kx1-1)*nyz)-z1

        do i=1,3

          x3(2)=bmappe(1,kz1+(ky1-1)*nz+(kx2-1)*nyz)-x1
          x3(3)=bmappe(1,kz1+(ky1-1)*nz+(kx3-1)*nyz)-x1

          b3(1)=bmappe(3+i,kz1+(ky1-1)*nz+(kx1-1)*nyz)
          b3(2)=bmappe(3+i,kz1+(ky1-1)*nz+(kx2-1)*nyz)
          b3(3)=bmappe(3+i,kz1+(ky1-1)*nz+(kx3-1)*nyz)
          call parabel_short(x3,b3,a3)
          b11=a3(1)+(a3(2)+a3(3)*xx)*xx

          b3(1)=bmappe(3+i,kz1+(ky2-1)*nz+(kx1-1)*nyz)
          b3(2)=bmappe(3+i,kz1+(ky2-1)*nz+(kx2-1)*nyz)
          b3(3)=bmappe(3+i,kz1+(ky2-1)*nz+(kx3-1)*nyz)
          call parabel_short(x3,b3,a3)
          b21=a3(1)+(a3(2)+a3(3)*xx)*xx

          b3(1)=bmappe(3+i,kz1+(ky3-1)*nz+(kx1-1)*nyz)
          b3(2)=bmappe(3+i,kz1+(ky3-1)*nz+(kx2-1)*nyz)
          b3(3)=bmappe(3+i,kz1+(ky3-1)*nz+(kx3-1)*nyz)
          call parabel_short(x3,b3,a3)
          b31=a3(1)+(a3(2)+a3(3)*xx)*xx

          b3(1)=bmappe(3+i,kz2+(ky1-1)*nz+(kx1-1)*nyz)
          b3(2)=bmappe(3+i,kz2+(ky1-1)*nz+(kx2-1)*nyz)
          b3(3)=bmappe(3+i,kz2+(ky1-1)*nz+(kx3-1)*nyz)
          call parabel_short(x3,b3,a3)
          b12=a3(1)+(a3(2)+a3(3)*xx)*xx

          b3(1)=bmappe(3+i,kz2+(ky2-1)*nz+(kx1-1)*nyz)
          b3(2)=bmappe(3+i,kz2+(ky2-1)*nz+(kx2-1)*nyz)
          b3(3)=bmappe(3+i,kz2+(ky2-1)*nz+(kx3-1)*nyz)
          call parabel_short(x3,b3,a3)
          b22=a3(1)+(a3(2)+a3(3)*xx)*xx

          b3(1)=bmappe(3+i,kz2+(ky3-1)*nz+(kx1-1)*nyz)
          b3(2)=bmappe(3+i,kz2+(ky3-1)*nz+(kx2-1)*nyz)
          b3(3)=bmappe(3+i,kz2+(ky3-1)*nz+(kx3-1)*nyz)
          call parabel_short(x3,b3,a3)
          b32=a3(1)+(a3(2)+a3(3)*xx)*xx

          b3(1)=bmappe(3+i,kz3+(ky1-1)*nz+(kx1-1)*nyz)
          b3(2)=bmappe(3+i,kz3+(ky1-1)*nz+(kx2-1)*nyz)
          b3(3)=bmappe(3+i,kz3+(ky1-1)*nz+(kx3-1)*nyz)
          call parabel_short(x3,b3,a3)
          b13=a3(1)+(a3(2)+a3(3)*xx)*xx

          b3(1)=bmappe(3+i,kz3+(ky2-1)*nz+(kx1-1)*nyz)
          b3(2)=bmappe(3+i,kz3+(ky2-1)*nz+(kx2-1)*nyz)
          b3(3)=bmappe(3+i,kz3+(ky2-1)*nz+(kx3-1)*nyz)
          call parabel_short(x3,b3,a3)
          b23=a3(1)+(a3(2)+a3(3)*xx)*xx

          b3(1)=bmappe(3+i,kz3+(ky3-1)*nz+(kx1-1)*nyz)
          b3(2)=bmappe(3+i,kz3+(ky3-1)*nz+(kx2-1)*nyz)
          b3(3)=bmappe(3+i,kz3+(ky3-1)*nz+(kx3-1)*nyz)
          call parabel_short(x3,b3,a3)
          b33=a3(1)+(a3(2)+a3(3)*xx)*xx

          x3(2)=dy
          x3(3)=x3(2)+dy

          if (ny.gt.1) then

            b3(1)=b11
            b3(2)=b21
            b3(3)=b31
            call parabel_short(x3,b3,a3)
            bb1=a3(1)+(a3(2)+a3(3)*yy)*yy

            b3(1)=b12
            b3(2)=b22
            b3(3)=b32
            call parabel_short(x3,b3,a3)
            bb2=a3(1)+(a3(2)+a3(3)*yy)*yy

            b3(1)=b13
            b3(2)=b23
            b3(3)=b33
            call parabel_short(x3,b3,a3)
            bb3=a3(1)+(a3(2)+a3(3)*yy)*yy

          else
            bb3=b11
          endif

          if (nz.gt.1) then
            x3(2)=dz
            x3(3)=x3(2)+dz
            b3(1)=bb1
            b3(2)=bb2
            b3(3)=bb3
            call parabel_short(x3,b3,a3)
            b(i)=a3(1)+(a3(2)+a3(3)*zz)*zz
          else
            b(i)=bb1
          endif

        enddo !i=1,3

      endif !kbundumap_c

      bxout=b(1)
      byout=b(2)
      bzout=b(3)

      return
      end
+DECK,util_get_electron,T=F77.
*CMZ :  4.01/05 15/04/2024  15.07.21  by  Michael Scheer
*CMZ :  4.01/02 11/05/2023  12.10.27  by  Michael Scheer
*-- Author :    Michael Scheer   08/05/2023
      subroutine util_get_electron(xbeta,betah,alphah,betav,alphav,emith,emitv,
     &  disph,dispph,dispv,disppv,
     &  espread,bunchlen,xelec,yelec,zelec,ypelec,zpelec,deelec,modebunch)

      implicit none

      double precision xbeta,betah,alphah,betav,alphav,emith,emitv,
     &  ebeam,xelec,yelec,zelec,ypelec,zpelec,deelec,
     &  s0h,beta0h,gamma0h,espread,bunchlen,
     &  s1h,beta1h,betap1h,alpha1h,gamma1h,phase1h,
     &  s2h,beta2h,betap2h,alpha2h,gamma2h,phase2h,
     &  s0v,beta0v,gamma0v,
     &  s1v,beta1v,betap1v,alpha1v,gamma1v,pvase1v,
     &  s2v,beta2v,betap2v,alpha2v,gamma2v,pvase2v,
     &  sigz,sigzp,sigy,sigyp,
     &  disph,dispph,dispv,disppv

      integer,parameter :: ng=6
      real rr(2),g(ng)

      integer :: modebunch

      if (emith.ne.0.0d0) then

        s1h=xbeta
        s2h=xelec
        beta1h=betah
        betap1h=-2.0d0*alphah

        call util_beta_function_drift(
     &    s0h,beta0h,gamma0h,
     &    s1h,beta1h,betap1h,alpha1h,gamma1h,phase1h,
     &    s2h,beta2h,betap2h,alpha2h,gamma2h,phase2h)

        sigz=sqrt(emith*beta0h)
        sigzp=sqrt(emith/beta0h)

      else

        sigz=0.0d0
        sigzp=0.0d0

      endif

      if (emitv.ne.0.0d0) then

        s1v=xbeta
        s2v=xelec
        beta1v=betav
        betap1v=-2.0d0*alphav

        call util_beta_function_drift(
     &    s0v,beta0v,gamma0v,
     &    s1v,beta1v,betap1v,alpha1v,gamma1v,pvase1v,
     &    s2v,beta2v,betap2v,alpha2v,gamma2v,pvase2v)

        sigy=sqrt(emitv*beta0v)
        sigyp=sqrt(emitv/beta0v)

      else

        sigy=0.0d0
        sigyp=0.0d0

      endif

      call util_random_gauss(ng,g,rr)

      deelec=g(1)*espread
      xelec=xelec+g(2)*bunchlen

      zelec=g(3)*sigz+deelec*disph
      zpelec=g(4)*sigzp+deelec*dispph

      yelec=g(5)*sigy+deelec*dispv
      ypelec=g(6)*sigyp+deelec*disppv

      zelec=zelec+(xelec-s0h)*zpelec
      yelec=yelec+(xelec-s0v)*ypelec

      return
      end
+DECK,util_beta_function_drift.
*CMZ : 00.00/15 09/10/2012  13.45.25  by  Michael Scheer
*-- Author :    Michael Scheer   05/10/2012
      subroutine util_beta_function_drift(
     &  s0,beta0,gamma0,
     &  s1,beta1,betap1,alpha1,gamma1,phase1,
     &  s2,beta2,betap2,alpha2,gamma2,phase2)

      real*8 s1,beta1,betap1,alpha1,gamma1,phase1,phase2,
     &  s2,beta2,betap2,alpha2,gamma2,beta0,gamma0,s0

c Calculates beta(s2) etc. from beta(s1) and betap(s1)
c beta(s)=beta0+(s-s0)**2/beta(0)

      alpha1=-betap1/2.0d0
      gamma1=(1.0d0+alpha1**2)/beta1
      s0=s1+alpha1/gamma1
      beta0=1.0d0/gamma1
      gamma0=1.0d0/beta0
      phase1=atan((s1-s0)/beta0)

      beta2=beta0+(s2-s0)**2/beta0
      betap2=2.0d0*(s2-s0)/beta0
      alpha2=-(s2-s0)/beta0
      gamma2=(1.0d0+alpha2**2)/beta2
      phase2=atan((s2-s0)/beta0)

      return
      end
+DECK,util_spline_integral_2d.
*CMZ :  4.01/07 16/08/2024  17.10.30  by  Michael Scheer
*CMZ :  4.01/03 17/05/2023  11.24.58  by  Michael Scheer
*CMZ :  4.01/02 12/05/2023  11.49.33  by  Michael Scheer
*CMZ : 00.00/16 21/11/2014  14.53.59  by  Michael Scheer
*-- Author :    Michael Scheer   21/11/2014
      subroutine util_spline_integral_2d(nx,ny,x,y,f,result,istat,kalloc)
+seq,gplhint.

      implicit none

      double precision x(nx),y(ny),f(nx,ny),result
      integer :: istat,nx,ny,ix,iy,kstat,kalloc,nxyo=0,kallo=0

      double precision, allocatable :: fb(:),fb2(:),coef(:),
     &  w1(:),w2(:),w3(:),w4(:)

      save

      if (kalloc.eq.0) then
        if (kallo.eq.0) then
          kalloc=1
        else
          if (max(nx,ny).gt.nxyo) then
            deallocate(fb)
            deallocate(fb2)
            deallocate(coef)
            deallocate(w1)
            deallocate(w2)
            deallocate(w3)
            deallocate(w4)
            kalloc=1
          endif
        endif
      endif

      if (kalloc.gt.0) then
        allocate(fb(max(nx,ny)))
        allocate(fb2(max(nx,ny)))
        allocate(coef(max(nx,ny)))
        allocate(w1(max(nx,ny)))
        allocate(w2(max(nx,ny)))
        allocate(w3(max(nx,ny)))
        allocate(w4(max(nx,ny)))
        kallo=1
        kalloc=0
      else if (kalloc.lt.0) then
        deallocate(fb)
        deallocate(fb2)
        deallocate(coef)
        deallocate(w1)
        deallocate(w2)
        deallocate(w3)
        deallocate(w4)
        return
      endif

      kstat=0

      if (ny.gt.nx) then
        do ix=1,nx
          fb(1:ny)=f(ix,1:ny)
          call util_spline_integral_stat(y,fb,ny,fb2(ix)
     &      ,coef,w1,w2,w3,w4,istat)
          kstat=kstat+istat
        enddo
        call util_spline_integral_stat(x,fb2,nx,result
     &    ,coef,w1,w2,w3,w4,istat)
        kstat=kstat+istat
      else !nx.gt.ny?
        do iy=1,ny
          fb(1:nx)=f(1:nx,iy)
          call util_spline_integral_stat(x,fb,nx,fb2(iy)
     &      ,coef,w1,w2,w3,w4,istat)
          kstat=kstat+istat
        enddo
        call util_spline_integral_stat(y,fb2,ny,result
     &    ,coef,w1,w2,w3,w4,istat)
        kstat=kstat+istat
      endif !nx.gt.ny

      nxyo=max(nx,ny)

      return
      end
+DECK,UTIL_SPLINE_INTEGRAL_STAT.
*CMZ :  4.01/07 16/08/2024  14.55.31  by  Michael Scheer
*CMZ :  4.01/03 16/05/2023  19.38.31  by  Michael Scheer
*CMZ : 00.00/02 17/08/2004  09.47.26  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.25.29  by  Michael Scheer
*-- Author :
      SUBROUTINE UTIL_SPLINE_INTEGRAL_STAT(X,Y,N,RESULT
     &                                 ,COEF,WORK1,WORK2,WORK3,WORK4,ISTAT)

C---  CALCULATES INTERGRAL OF Y(X) VIA SPLINES

      IMPLICIT NONE

      INTEGER I,N,ISTAT
      REAL*8 X(N),Y(N),RESULT
      REAL*8 COEF(N),WORK1(N),WORK2(N),WORK3(N),WORK4(N)

C---  SPLINE-COEFFICIENTS

      CALL UTIL_SPLINE_COEF_STATus(X,Y,N,0.0d0,0.0d0,COEF,WORK1,WORK2,WORK3,WORK4,ISTAT)

C--- INTEGRATION

      RESULT=0.0D0
      DO I=1,N-1

      RESULT=RESULT
     &          +(X(I+1)-X(I))*0.5D0
     &          *(Y(I)+Y(I+1))
     &          -(X(I+1)-X(I))**3/24.D0
     &          *(COEF(I)+COEF(I+1))

      ENDDO

      RETURN
      END
+DECK,UTIL_SPLINE_COEF_STATUS.
*CMZ :  4.01/03 17/05/2023  11.21.58  by  Michael Scheer
*CMZ : 00.00/20 18/11/2016  15.04.18  by  Michael Scheer
*CMZ : 00.00/19 19/11/2015  13.56.50  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.67/05 16/05/2012  12.45.37  by  Michael Scheer
*CMZ : 00.00/07 12/10/2009  12.17.45  by  Michael Scheer
*CMZ : 00.00/02 14/04/2003  12.46.09  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.27.48  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE UTIL_SPLINE_COEF_STATUS(X,Y,N,YP1,YPN,Y2,AA,BB,CC,C,istat)

C--- CALCULATES SPLINE COEFFICIENTS

C--   INPUT:

C-       N: NUMBER OF X,Y-VALUES
C-       X: ARRAY OF X-VALUES
C-       Y: ARRAY OF Y-VALUES
C-       YP1:  SECOND DERIVATIVE AT FIRST X-VALUE
C-       YPN:  SECOND DERIVATIVE AT LAST X-VALUE

C--   OUPUT:

C-       Y2:   SPLINE-COEFFICIENTS
c:       istat: STATUS

C--   WORKINGSPACE: AA(N),BB(N),CC(N),C(N)


      IMPLICIT NONE

      INTEGER N,J
      REAL*8  X(N),Y(N),Y2(N),AA(N),BB(N),CC(N),C(N)

      REAL*8 YP1,YPN

      double precision xx(3),yy(3),a(3),yp(3),xopt,yopt
      INTEGER ifail,istat

      istat=0

      IF (N.LT.3) then
        if (abs(yp1).eq.9999.0d0) then
          y2(1)=0.0d0
        else
          y2(1)=yp1
        endif
        if (abs(ypn).eq.9999.0d0) then
          y2(n)=0.0d0
        else
          y2(n)=ypn
        endif
        RETURN
      endif

      if (abs(yp1).eq.9999.0d0) then
        xx=x(1:3)
        yy=y(1:3)
        call UTIL_PARABEL(xx,yy,A,YP,XOPT,yopt,IFAIL)
        if (ifail.eq.0) then
          y2(1)=2.0d0*a(3)
        else
          print*,"*** Warning in util_spline_coef: Calculation of yp1 by util_parabel failed ***"
          print*,"*** Setting second derivative of first point to zero ***"
          y2(1)=0.0d0
        endif
      else
        Y2(1)=YP1
      endif

      if (abs(ypn).eq.9999.0d0) then
        xx=x(n-2:n)
        yy=y(n-2:n)
        call UTIL_PARABEL(xx,yy,A,YP,XOPT,yopt,IFAIL)
        if (ifail.eq.0) then
          y2(n)=2.0d0*a(3)
        else
          print*,"*** Warning in util_spline_coef: Calculation of ypn by util_parabel failed ***"
          print*,"*** Setting second derivative of last point to zero ***"
          y2(N)=0.0d0
        endif
      else
        Y2(N)=YPN
      endif

      C(1)=Y2(1)
      C(N)=y2(n)

      BB(1)=1.D0
      CC(1)=0.D0
      CC(N)=1.D0

      DO J=2,N-1
        if(x(j+1).le.x(j)) then
          write(6,*)
          write(6,*)
     &      '*** Error in util_spline_coef: Intervall of zero length or bad ordering of data'
          write(6,*)'j, x(j), x(j+1):',j,x(j),x(j+1)
          write(6,*)
          istat=-1
          return
        endif

        AA(J)=(X(J  )-X(J-1))/6.D0
        BB(J)=(X(J+1)-X(J-1))/3.D0
        CC(J)=(X(J+1)-X(J  ))/6.D0
        C(J)=(Y(J+1)-Y(J  ))/(X(J+1)-X(J  ))
     &    -(Y(J  )-Y(J-1))/(X(J  )-X(J-1))
      ENDDO !J

      DO J=2,N-1

        BB(J)=BB(J)-AA(J)*CC(J-1)
        C(J)= C(J)-AA(J)* C(J-1)
C          AA(J)=AA(J)-AA(J)*BB(J-1)

        CC(J)=CC(J)/BB(J)
        C(J)= C(J)/BB(J)
        BB(J)=1.D0

      ENDDO !J

      DO J=N-1,2,-1
        Y2(J)=C(J)-CC(J)*Y2(J+1)
        if (Abs(y2(j)).lt.1.0d-15) y2(j)=0.0d0
      ENDDO

      RETURN
      END
+DECK,CYLTOCARTB,T=F77.
*CMZ :  4.01/04 15/11/2023  12.38.14  by  Michael Scheer
*CMZ :  4.01/03 14/06/2023  09.25.01  by  Michael Scheer
*CMZ :  3.00/00 11/03/2013  15.12.11  by  Michael Scheer
*CMZ :  2.66/02 26/10/2009  14.33.39  by  Michael Scheer
*CMZ :  2.65/01 08/10/2009  09.58.11  by  Michael Scheer
*CMZ :  2.65/00 18/09/2009  08.30.19  by  Michael Scheer
*CMZ :  2.64/06 15/09/2009  09.52.14  by  Michael Scheer
*CMZ :  2.64/05 14/09/2009  10.06.11  by  Michael Scheer
*-- Author :    Michael Scheer   01/09/2009
      subroutine cyltocartb(isour)
+seq,gplhint.

+SEQ,SOURCEF90U.
+SEQ,OBSERVF90U.
+SEQ,AFREQF90U.
+SEQ,SPECTF90U.
+SEQ,WFOLDF90U.

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,MYFILES.
+SEq,observf90.
+SEQ,DEPOLA.
+SEq,wfoldf90.
+seq,sourcef90.
+SEQ,FREQS.
+SEQ,PHYCON.
+SEQ,SPECTF90.

c
c Alte Version 154 wieder  hervorgeholt, da sie besser mit MPINR=0 uebereinstimmt.
c
c

c fill AFREQ(5:6) by interpolating AFREQRPHI

      double precision, dimension(:,:,:), allocatable :: fr,coefr
      double precision, dimension(:,:), allocatable :: phas
      double precision, dimension(:), allocatable :: w1,w2,w3,w4,
     &  fp,coefp,obsvedge,frw

      double complex af2,af3
c     &  ,expom

      double precision y,z,r,phi,pihalf,phiedge,yp12,
     &  phiy,phiz,phiy1,phiz1,
     &  dist0,dist02,ddist,h2,cenxexi,dvlen,
     &  dphase,dphi,pi2phaser2,pi2phaser3,pi2phasephi2,pi2phasephi3,
     &  af2r,af2i,af3r,af3i,
     &  af2ro,af2io,af3ro,af3io

      integer ixy,iphi,ir,ifreq,iphas,iobrp,istat,medge,
     &  ifirst,ilast,iedge,isour,jphi,nphi,ical

      data ical/0/

      if (ical.eq.0) then

        print*,''
        print*,'*** Warning in cyltocartb: Calculation of magnetic components of radiation field not yet tested ***'
        print*,''

        medge=3
        yp12=9999.0d0

        allocate(phas(4,nobsv))

        allocate(frw(nobsvr))
        allocate(fr(nobsvr,4,nobsvphi))
        allocate(coefr(nobsvr,4,nobsvphi))

        allocate(fp(nobsvphi+2*medge+1))
        allocate(obsvedge(nobsvphi+2*medge+1))
        allocate(coefp(nobsvphi+2*medge+1))

        allocate(w1(max(nobsvr,nobsvphi+2*medge+1)))
        allocate(w2(max(nobsvr,nobsvphi+2*medge+1)))
        allocate(w3(max(nobsvr,nobsvphi+2*medge+1)))
        allocate(w4(max(nobsvr,nobsvphi+2*medge+1)))

        pihalf=pi1/2.0d0

        ifirst=medge+1

        if (iquadphi.eq.0) then
          ilast=ifirst+nobsvphi
          obsvedge(ilast)=obsvphi(nobsvphi)+obsvdphi
        else
          ilast=ifirst+nobsvphi-1
        endif

        do iphi=1,nobsvphi
          obsvedge(ifirst+iphi-1)=obsvphi(iphi)
        enddo

        do iedge=1,medge
          obsvedge(ilast+iedge)=obsvedge(ilast+iedge-1)+obsvdphi
        enddo

        do iedge=1,medge
          obsvedge(ifirst-iedge)=obsvedge(ifirst-iedge+1)-obsvdphi
        enddo

        ical=1

      endif

        cenxexi=(min(sourceeo(1,1,isour),xiend)
     &    +max(sourceao(1,1,isour),xianf))/2.d0
        dvlen=
     &    min(sourceeo(1,1,isour),xiend)-
     &    max(sourceao(1,1,isour),xianf)
        if (iampli.lt.0) then
          dvlen=dvlen*(-iampli)
        endif
        dist0=pincen(1)-cenxexi
        dist02=dist0**2

      do ifreq=1,nfreq

        iobrp=0
        ixy=1

        pi2phasephi2=0.0d0
        pi2phasephi3=0.0d0
        do iphi=1,nobsvphi

          phiy1=-twopi1
          phiz1=-twopi1

          pi2phaser2=0.0d0
          pi2phaser3=0.0d0
          do ir=1,nobsvr

            iobrp=iobrp+1
            ifrob=ifreq+nfreq*(iobrp-1)

            h2=(obsvr(ir)/dist0)**2
            if (h2.lt.0.01) then
              ddist=dist0*(h2/2.0d0-h2**2/8.0d0)
            else
              ddist=dist0*(sqrt(1.0d0+h2)-1.0d0)
            endif

            dphase=ddist/freq(ifreq)*wtoe1*1.0d9*twopi1

            af2=afreqrphi(5,IFROB)
            af3=afreqrphi(6,IFROB)
            af2r=dreal(af2)
            af2i=dimag(af2)
            af3r=dreal(af3)
            af3i=dimag(af3)

            phiy=atan2(af2i,af2r)
            phiz=atan2(af3i,af3r)

            fr(ir,1,iphi)=abs(af2)
            fr(ir,2,iphi)=phiy-dphase
            fr(ir,3,iphi)=abs(af3)
            fr(ir,4,iphi)=phiz-dphase

c            print*,ir,iphi,phiz+dphase,phiz-dphase

            phiy1=phiy
            phiz1=phiz
            af2ro=af2r
            af2io=af2i
            af3ro=af3r
            af3io=af3i

          enddo !nobsvr

          do iphas=2,4,2
            frw(1)=fr(1,iphas,iphi)
            do ir=2,nobsvr
              frw(ir)=fr(ir,iphas,iphi)
              phiy1=frw(ir-1)
              phiy=frw(ir)
              dphi=phiy-phiy1

              if (dphi.gt.pi1) then
                dphi=dphi-twopi1
              else if (dphi.lt.-pi1) then
                dphi=dphi+twopi1
              endif
              fr(ir,iphas,iphi)=fr(ir-1,iphas,iphi)+dphi

            enddo
          enddo

          do iphas=1,4
            call util_spline_coef(obsvr,
     &        fr(1,iphas,iphi),nobsvr,yp12,yp12,coefr(1,iphas,iphi),
     &        w1,w2,w3,w4)
          enddo

        enddo !nobsvphi

        do iphas=1,4

          do ixy=1,nobsv

            y=obsv(2,ixy)
            z=obsv(3,ixy)
            r=sqrt(y**2+z**2)

            if (iquadphi.eq.0) then
              phi=atan2(y,z)
            else
              if (z.ne.0.0d0) then
                phi=atan(y/z)
              else
                phi=pi1/2.0d0
              endif
              phi=abs(phi)
            endif

            if (phi.lt.0.0d0) phi=phi+twopi1

            do iphi=1,nobsvphi

              call util_spline_inter_status(
     &          obsvr,fr(1,iphas,iphi),coefr(1,iphas,iphi),
     &          nobsvr,r,fp(iphi+medge),0,
     &          istat)

              if (istat.ne.0) then
                stop
     &            '*** Error: Bad return from util_spline_inter_status in CYLTOCART'
              endif

            enddo !iphi

            if (iquadphi.eq.0) then

              nphi=nobsvphi+1+2*medge
              ifirst=medge+1
              ilast=ifirst+nobsvphi

              fp(ilast)=fp(ifirst) !Periode vervollstaendigen

              do iedge=1,medge
                fp(ilast+iedge)=fp(ifirst+iedge)
              enddo

              do iedge=1,medge
                fp(ifirst-iedge)=fp(ilast-iedge)
              enddo

            else !if (iquadphi.eq.0)

              nphi=nobsvphi+2*medge
              ifirst=medge+1
              ilast=ifirst+nobsvphi-1

              do iedge=1,medge
                phiedge=mod(pihalf+iedge*obsvdphi,twopi1)
                if (phiedge.gt.3.0d0*pihalf) then
                  phiedge=twopi1-phiedge
                else if (phiedge.gt.pi1) then
                  phiedge=phiedge-pi1
                else if (phiedge.gt.pihalf) then
                  phiedge=pi1-phiedge
                endif
                jphi=ifirst+nint(phiedge/obsvdphi)
                fp(ilast+iedge)=fp(jphi)
              enddo

              do iedge=1,medge
                phiedge=mod(iedge*obsvdphi,twopi1)
                if (phiedge.gt.3.0d0*pihalf) then
                  phiedge=twopi1-phiedge
                else if (phiedge.gt.pi1) then
                  phiedge=phiedge-pi1
                else if (phiedge.gt.pihalf) then
                  phiedge=pi1-phiedge
                endif
                jphi=ifirst+nint(phiedge/obsvdphi)
                fp(ifirst-iedge)=fp(jphi)
              enddo

            endif !iquadphi

            call util_spline_coef(obsvedge,fp,nphi,
     &        yp12,yp12,coefp,
     &        w1,w2,w3,w4)

            call util_spline_inter_status(
     &        obsvedge,fp,coefp,nphi,phi,phas(iphas,ixy),0,istat)

            if (iphas.eq.4) then

              h2=(r/dist0)**2

              if (h2.lt.0.01) then
                ddist=dist0*(h2/2.0d0-h2**2/8.0d0)
              else
                ddist=dist0*(sqrt(1.0d0+h2)-1.0d0)
              endif

              dphase=ddist/freq(ifreq)*wtoe1*1.0d9*twopi1

              afreq(5,ifreq+nfreq*(ixy-1))=
     &          phas(1,ixy)*
     &          cmplx(cos(phas(2,ixy)+dphase),sin(phas(2,ixy)+dphase))

              afreq(6,ifreq+nfreq*(ixy-1))=
     &          phas(3,ixy)*
     &          cmplx(cos(phas(4,ixy)+dphase),sin(phas(4,ixy)+dphase))

            endif

            if (istat.ne.0) then
              stop
     &          '*** Error: Bad return from util_spline_inter_status in CYLTOCART'
            endif

          enddo !ixy

        enddo !iphas

      enddo !ifreq

      if (isour.eq.nsource) then
        deallocate(phas)
        deallocate(fr)
        deallocate(fp)
        deallocate(obsvedge)
        deallocate(coefr)
        deallocate(coefp)

        deallocate(w1)
        deallocate(w2)
        deallocate(w3)
        deallocate(w4)
      endif

      return
      end
+DECK,UOUT_PHOTON.
*CMZ :  4.01/04 17/10/2023  13.35.53  by  Michael Scheer
*CMZ :  2.15/00 15/03/2007  11.13.54  by  Michael Scheer
*CMZ : 00.02/05 19/03/97  14.10.43  by  Michael Scheer
*CMZ : 00.02/04 26/02/97  10.23.26  by  Michael Scheer
*-- Author :    Michael Scheer   25/02/97

      SUBROUTINE UOUT_photon

+seq,spectf90u.

C     INTERFACE FUER PHOTON
C     USER(1) MUSS KRITISCHE ENERGIE ENTHALTEN

C     EIGENTLICH IST DIE KRITISCHE ENERGIE UND GAMMA UNWICHTIG,
C     ABER VORERST FUER CHECKS MITAUSGEBEN.
C     PINCEN(2) MUSS NULL SEIN (FAKTOR 2)
C
C     AUSGEBEN WIRD dFLUX/dTHETA[mrad]

      IMPLICIT NONE

+SEQ,CMPARA.
+SEQ,CONTRL.
+SEQ,SPECT.
+SEQ,OBSERV.
+SEQ,FREQS.
+SEQ,USERVAR.


      INTEGER IFREQ
      DOUBLE PRECISION EGAMMA,PHOTONS

      WRITE(6,*)
      WRITE(6,*)'SUBROUTINE UOUT_PHOTON:'
      WRITE(6,*)'======================='
      WRITE(6,*)
      WRITE(6,*)'Writing file WAVE.PHOTON for program PHOTON'
      WRITE(6,*)'Ecrit:',ecphoton
      WRITE(6,*)


      IF (IPIN.NE.1) STOP '*** ERROR IN UOUT_PHOTON: IPIN.NE.1'
      IF (IF1DIM.NE.1) STOP '*** ERROR IN UOUT_PHOTON: IF1DIM.NE.1'
      IF (PINCEN(2).NE.0.0)STOP
     &  '*** ERROR IN UOUT_PHOTON: PINCEN(2).NE.0.0'

      OPEN(UNIT=99,FILE='WAVE.PHOTON',STATUS='NEW')

      WRITE(99,*)'WAVE.PHOTON'
      WRITE(99,*)ICODE,' ',CODE
      WRITE(99,*)ECPHOTON,DMYGAMMA
      WRITE(99,*)PINW,PINH
      WRITE(99,*)OBSVDZ,OBSVDY
      WRITE(99,*)PINCEN
      WRITE(99,*)NFREQ

      DO IFREQ=1,NFREQ
        EGAMMA=FREQ(IFREQ)/ECPHOTON
        PHOTONS=WFLUXT(IFREQ)
     &    /1.327D13 ! 1.327e13 * Ebeam**2  * Icurr * H2(y) yields flux-dens.
     &    /BANWID*0.001D0
     &    *(PINCEN(1)/PINW/1000.0D0)
     &    /(DMYCUR*1000.0D0)
     &    /DMYENERGY**2
     &    /2.D0
        WRITE(99,*)EGAMMA,PHOTONS
      ENDDO

      CLOSE(99)

      RETURN
      END
+DECK,util_zeit_kommentar.
*CMZ :  4.01/04 22/01/2018  16.49.42  by  Michael Scheer
*CMZ : 00.00/20 19/08/2016  15.08.19  by  Michael Scheer
*CMZ : 00.00/15 04/01/2013  12.22.07  by  Michael Scheer
*CMZ : 00.00/05 27/02/2007  16.32.04  by  Michael Scheer
*CMZ : 00.00/02 04/08/2006  14.56.41  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.25.58  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine util_zeit_kommentar(lun,comment)

c to determine date and time and write it to logical unit lun

      implicit none

      integer lun

      character(*) comment

      character spacer(50)
      character(10) dtday,dttime,dtzone
      integer idatetime(8),ilast

      data spacer/50*' '/

      call date_and_time(dtday,dttime,dtzone,idatetime)

      ilast=len_trim(comment)

      write(lun,*)
      write(lun,*)
      if (ilast.gt.0) then
        write(lun,*)comment(1:ilast),spacer,dttime(1:2),':',dttime(3:4),':',dttime(5:6),' '
     &    ,dtday(7:8),'.',dtday(5:6),'.',dtday(3:4)
      else
        write(lun,*)spacer,dttime(1:2),':',dttime(3:4),':',dttime(5:6),' '
     &    ,dtday(7:8),'.',dtday(5:6),'.',dtday(3:4)
      endif
      write(lun,*)

      return
      end
+DECK,util_fourier_spline.
*CMZ :  4.01/05 24/03/2024  13.11.02  by  Michael Scheer
*CMZ : 00.00/02 22/04/99  17.27.52  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.25.29  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE UTIL_fourier_spline(nx,X,Y,Nom,OM,ftcos,ftsin,IFAIL)

C---  CALCULATES INTEGRAL(F(x)*SIN(omega*x)) AND INTEGRAL(F(x)*COS(omega*x))

      IMPLICIT NONE

      INTEGER NX,NOM,IOM,Ix,IFAIL

      real*8, parameter :: pi1=3.141592653589793D0

      complex*16 :: fw,ci=(0.0d0,1.0d0),ex0oma,ex1oma,ex0x1oma,ft(nom),cn,cd,
     &  ex00,dexpom,dexpomx,ddexpomx

      REAL*8 X(NX),om(nom),yp(nx),ypp(nx),const,a0,y(nx),ftcos(nom),ftsin(nom),
     &  oma,oma2,oma3,oma4,x0,x02,x03,x1,x12,x13,y0,y1,ypp0,ypp1,dx,dom

      IFAIL=0
      const=1.0d0/sqrt(2.0d0*pi1)


      call util_coef_spline(nx,x,y,0.0d0,0.0d0,yp,ypp,ifail)
      if (ifail.ne.0) return

      dx=x(2)-x(1)
      dom=om(2)-om(1)

      dexpom=exp(ci*x(1)*dom)
      ex00=exp(ci*x(1)*om(1))
      dexpomx=exp(ci*dx*om(1))
      ddexpomx=exp(ci*dx*dom)

      DO IOM=1,nom

        oma=om(iom)

        if (abs(oma).lt.1.0d-9) then

          a0=0.0d0
          do ix=1,nx-1
            a0=a0
     &        +(X(ix+1)-X(ix))*0.5D0
     &        *(y(ix)+y(ix+1))
     &        -(X(ix+1)-X(ix))**3/24.D0
     &        *(ypp(ix)+ypp(ix+1))
          enddo

          ft(iom)=dcmplx(a0*const,0.0d0)

          ex00=ex00*dexpom
          dexpomx=dexpomx*ddexpomx
          cycle

        endif

        oma2=oma*oma
        oma3=oma2*oma
        oma4=oma3*oma

        fw=dcmplx(0.0d0,0.0d0)
        ex0oma=ex00

        do ix=1,nx-1

          x0=x(ix)
          x02=x0*x0
          x03=x02*x0
          x1=x(ix+1)
          x12=x1*x1
          x13=x12*x1
          y0=y(ix)
          y1=y(ix+1)
          ypp0=ypp(ix)
          ypp1=ypp(ix+1)

          ex1oma=ex0oma*dexpomx
          ex0x1oma=ex0oma*ex1oma

          cn=(-(ex0oma*(2.0d0*x12*ypp1*ci*oma2
     &      +x12*ypp0*ci*oma2-4.0d0*x1*x0*ypp1*ci*oma2-2.0d0*x1*x0*ypp0*ci*oma2-
     &      6.0d0*x1*y1*oma3+6.0d0*x1*ypp1*oma+2.0d0*x02*ypp1*ci*oma2+
     &      x02*ypp0*ci*oma2+6.0d0*x0*y1*oma3-6.0d0*x0*ypp1*oma+6.0d0*y1*ci
     &      *oma2-6.0d0*y0*ci*oma2-6.0d0*ypp1*ci+6.0d0*ypp0*ci)+
     &      ex1oma*(x12*ypp1*ci*oma2+2.0d0*
     &      x12*ypp0*ci*oma2-2.0d0*x1*x0*ypp1*ci*oma2-4.0d0*x1*x0*ypp0*ci*oma2+
     &      6.0d0*x1*y0*oma3-6.0d0*x1*ypp0*oma+
     &      x02*ypp1*ci*oma2+
     &      2.0d0*x02*ypp0*ci*oma2-6.0d0*x0*y0
     &      *oma3+6.0d0*x0*ypp0*oma-6.0d0*y1*ci*oma2+6.0d0*y0
     &      *ci*oma2+6.0d0*ypp1*ci-6.0d0*ypp0*ci))*ci)

          cd=6.0d0*ex0x1oma*(x1-x0)*oma4

          if (abs(cd).ge.1.0d-12) fw=fw+cn/cd

          ex0oma=ex0oma*dexpomx

        enddo !ix

        ft(iom)=fw*const

        ex00=ex00*dexpom
        dexpomx=dexpomx*ddexpomx

      enddo !oma

      ftcos=dreal(ft)
      ftsin=dimag(ft)

      return
      end
+DECK,util_fourier_spline_complex.
*CMZ :  4.01/05 28/03/2024  08.39.34  by  Michael Scheer
*CMZ : 00.00/02 22/04/99  17.27.52  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.25.29  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE UTIL_fourier_spline_complex(nx,X,Y,Nom,OM,ft,IFAIL)

C---  CALCULATES INTEGRAL(F(x)*SIN(omega*x)) AND INTEGRAL(F(x)*COS(omega*x))

      IMPLICIT NONE

      INTEGER NX,NOM,IOM,Ix,IFAIL,ic

      real*8, parameter :: pi1=3.141592653589793D0

      complex*16 :: y(nx),fw,ci=(0.0d0,1.0d0),ex0oma,ex1oma,ex0x1oma,ft(nom),cn,cd,
     &  ex00,dexpom,dexpomx,ddexpomx

      REAL*8 X(NX),om(nom),yp(nx),ypp(nx),const,a0,yr(nx),
     &  oma,oma2,oma3,oma4,x0,x02,x03,x1,x12,x13,y0,y1,ypp0,ypp1,dx,dom

      IFAIL=0
      const=1.0d0/sqrt(2.0d0*pi1)

      dx=x(2)-x(1)
      dom=om(2)-om(1)

      dexpom=exp(ci*x(1)*dom)
      ddexpomx=exp(ci*dx*dom)

      do ic=1,2

        if (ic.eq.1) then
          yr(1:nx)=dreal(y(1:nx))
        else
          yr(1:nx)=dimag(y(1:nx))
        endif

        call util_coef_spline(nx,x,yr,0.0d0,0.0d0,yp,ypp,ifail)
        if (ifail.ne.0) return

        ex00=exp(ci*x(1)*om(1))
        dexpomx=exp(ci*dx*om(1))

        DO IOM=1,nom

          oma=om(iom)

          if (abs(oma).lt.1.0d-9) then
            a0=0.0d0
            do ix=1,nx-1
              a0=a0
     &          +(X(ix+1)-X(ix))*0.5D0
     &          *(Yr(ix)+Yr(ix+1))
     &          -(X(ix+1)-X(ix))**3/24.D0
     &          *(ypp(ix)+ypp(ix+1))
            enddo
            if (ic.eq.1) then
              ft(iom)=dcmplx(a0*const,0.0d0)
            else
              ft(iom)=ft(iom)+dcmplx(0.0d0,a0*const)
            endif
            ex00=ex00*dexpom
            dexpomx=dexpomx*ddexpomx
            cycle
          endif

          oma2=oma*oma
          oma3=oma2*oma
          oma4=oma3*oma

          fw=dcmplx(0.0d0,0.0d0)
          ex0oma=ex00

          do ix=1,nx-1

            x0=x(ix)
            x02=x0*x0
            x03=x02*x0
            x1=x(ix+1)
            x12=x1*x1
            x13=x12*x1
            y0=yr(ix)
            y1=yr(ix+1)
            ypp0=ypp(ix)
            ypp1=ypp(ix+1)

            ex1oma=ex0oma*dexpomx
            ex0x1oma=ex0oma*ex1oma

            cn=(-(ex0oma*(2.0d0*x12*ypp1*ci*oma2
     &        +x12*ypp0*ci*oma2-4.0d0*x1*x0*ypp1*ci*oma2-2.0d0*x1*x0*ypp0*ci*oma2-
     &        6.0d0*x1*y1*oma3+6.0d0*x1*ypp1*oma+2.0d0*x02*ypp1*ci*oma2+
     &        x02*ypp0*ci*oma2+6.0d0*x0*y1*oma3-6.0d0*x0*ypp1*oma+6.0d0*y1*ci
     &        *oma2-6.0d0*y0*ci*oma2-6.0d0*ypp1*ci+6.0d0*ypp0*ci)+
     &        ex1oma*(x12*ypp1*ci*oma2+2.0d0*
     &        x12*ypp0*ci*oma2-2.0d0*x1*x0*ypp1*ci*oma2-4.0d0*x1*x0*ypp0*ci*oma2+
     &        6.0d0*x1*y0*oma3-6.0d0*x1*ypp0*oma+
     &        x02*ypp1*ci*oma2+
     &        2.0d0*x02*ypp0*ci*oma2-6.0d0*x0*y0
     &        *oma3+6.0d0*x0*ypp0*oma-6.0d0*y1*ci*oma2+6.0d0*y0
     &        *ci*oma2+6.0d0*ypp1*ci-6.0d0*ypp0*ci))*ci)

            cd=6.0d0*ex0x1oma*(x1-x0)*oma4

            if (abs(cd).ge.1.0d-12) fw=fw+cn/cd

            ex0oma=ex0oma*dexpomx

          enddo !ix

          if (ic.eq.1) then
            ft(iom)=fw*const
          else
            ft(iom)=ft(iom)+ci*fw*const
          endif

          ex00=ex00*dexpom
          dexpomx=dexpomx*ddexpomx

        enddo !oma

      enddo !ic

      return
      end
+DECK,util_fourier_linear_complex.
*CMZ :  4.01/05 28/03/2024  11.30.43  by  Michael Scheer
*CMZ : 00.00/02 22/04/99  17.27.52  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.25.29  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine util_fourier_linear_complex(nx,x,y,nom,om,ft,ifail)

c---  calculates integral(f(x)*sin(omega*x)) and integral(f(x)*cos(omega*x))

      implicit none

      integer nx,nom,iom,ix,ifail,ic

      real*8, parameter :: pi1=3.141592653589793d0

      complex*16 :: y(nx),fw,ci=(0.0d0,1.0d0),ex0oma,ft(nom),cn,dexpomx,dexpom,ex00,
     &  ddexpomx

      real*8 x(nx),om(nom),const,a0,yr(nx),oma,dom,dx

      ifail=0
      const=1.0d0/sqrt(2.0d0*pi1)

      dx=x(2)-x(1)
      dom=om(2)-om(1)

      dexpomx=exp(-ci*dx*om(1))
      ddexpomx=exp(-ci*dx*dom)

      do ic=1,2

        if (ic.eq.1) then
          yr(1:nx)=dreal(y(1:nx))
        else
          yr(1:nx)=dimag(y(1:nx))
        endif

        ex00=exp(-ci*x(1)*om(1))
        dexpom=exp(-ci*x(1)*dom)

        do iom=1,nom

          oma=om(iom)

          if (abs(oma).lt.1.0d-9) then
            a0=0.0d0
            do ix=1,nx-1
              a0=a0+(yr(ix)+yr(ix+1))/2.0d0*dx
            enddo
            if (ic.eq.1) then
              ft(iom)=dcmplx(a0*const,0.0d0)
            else
              ft(iom)=ft(iom)+dcmplx(0.0d0,a0*const)
            endif
            ex00=ex00*dexpom
            dexpomx=dexpomx*ddexpomx
            cycle
          endif

          ex0oma=ex00

          cn=yr(1)*ex0oma/2.0d0
          fw=cn*dx
          ex0oma=ex0oma*dexpomx

          do ix=2,nx-1
            cn=yr(ix)*ex0oma
            fw=fw+cn*dx
            ex0oma=ex0oma*dexpomx
          enddo !ix

          cn=yr(nx)*ex0oma/2.0d0
          fw=fw+cn*dx

          if (ic.eq.1) then
            ft(iom)=fw*const
          else
            ft(iom)=ft(iom)+ci*fw*const
          endif

          ex00=ex00*dexpom
          dexpomx=dexpomx*ddexpomx

        enddo !oma

      enddo !ic

      return
      end
+DECK,util_fourier_complex_2d.
*CMZ :  4.01/05 28/03/2024  18.50.01  by  Michael Scheer
*CMZ : 00.00/02 22/04/99  17.27.52  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.25.29  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine util_fourier_complex_2d(nx,ny,x,y,f,nomx,nomy,omx,omy,ft,ispline,ifail)

      implicit none

      integer nx,ny,nomx,nomy,ispline,ifail

      complex*16 :: f(nx,ny),ft(nomx,nomy)

      real*8 x(nx),y(ny),omx(nomx),omy(nomy)

      if (ispline.eq.0) then
        call util_fourier_spline_complex_2d(nx,ny,x,y,f,nomx,nomy,omx,omy,ft,ifail)
      else
        call util_fourier_linear_complex_2d(nx,ny,x,y,f,nomx,nomy,omx,omy,ft,ifail)
      endif

      return
      end
+DECK,util_fourier_spline_complex_2d.
*CMZ :  4.01/05 28/03/2024  18.45.57  by  Michael Scheer
*CMZ : 00.00/02 22/04/99  17.27.52  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.25.29  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine util_fourier_spline_complex_2d(nx,ny,x,y,f,nomx,nomy,omx,omy,ft,ifail)

      implicit none

      integer nx,ny,nomx,nomy,ix,iy,ifail,jfail

      complex*16 :: f(nx,ny),ft(nomx,nomy),fxy(max(nx,ny)),ftxy(max(nx,ny)),ftx(nomx,ny)

      real*8 x(nx),y(ny),omx(nomx),omy(nomy)

      ifail=0

      do iy=1,ny
        fxy(1:nx)=f(1:nx,iy)
        call util_fourier_spline_complex(nx,x,fxy,nomx,omx,ftxy,jfail)
        ftx(1:nomx,iy)=ftxy(1:nomx)
        ifail=ifail+jfail
      enddo !ny

      do ix=1,nomx
        fxy(1:ny)=ftx(ix,1:ny)
        call util_fourier_spline_complex(ny,y,fxy,nomy,omy,ftxy,jfail)
        ft(ix,1:nomy)=ftxy(1:nomy)
        ifail=ifail+jfail
      enddo !ny

      return
      end
+DECK,UTIL_COEF_SPLINE.
*CMZ :  4.01/05 17/03/2024  10.34.16  by  Michael Scheer
*CMZ : 00.00/07 07/05/2008  14.02.20  by  Michael Scheer
*CMZ : 00.00/02 14/04/2004  14.25.24  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.27.48  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE UTIL_coef_SPLINE(n,X,Y,YP1,YPN,YP,Y2,istatus)

C--- CALCULATES SPLINE COEFFICIENTS

C--   INPUT:

C-       N: NUMBER OF X,Y-VALUES
C-       X: ARRAY OF X-VALUES
C-       Y: ARRAY OF Y-VALUES
C-       YP1:  SECOND DERIVATIVE AT FIRST X-VALUE
C-       YPN:  SECOND DERIVATIVE AT LAST X-VALUE

C--   OUPUT:

C-       YP:   DERIVATIVES AT XA
C-       Y2:   SPLINE-COEFFICIENTS
C-  ISTATUS:   EXIT-CODE


      IMPLICIT NONE

      INTEGER N,J,I,I1,istatus

      REAL*8  X(N),Y(N),YP(N),Y2(N),AA(N),BB(N),CC(N),C(N)
      REAL*8 YP1,YPN

      double precision xx(3),yy(3),a(3),yp3(3),xopt,yopt
      INTEGER ifail

      istatus=0

      IF (N.LT.3) then
        istatus=-1
        RETURN
      endif

      if (abs(yp1).eq.9999.0d0) then
        xx=x(1:3)
        yy=y(1:3)
        call UTIL_PARABEL(xx,yy,A,YP3,XOPT,yopt,IFAIL)
        if (ifail.eq.0) then
          y2(1)=2.0d0*a(3)
        else
          y2(1)=0.0d0
        endif
      else
        Y2(1)=YP1
      endif

      if (abs(ypn).eq.9999.0d0) then
        xx=x(n-2:n)
        yy=y(n-2:n)
        call UTIL_PARABEL(xx,yy,A,YP3,XOPT,yopt,IFAIL)
        if (ifail.eq.0) then
          y2(n)=2.0d0*a(3)
        else
          y2(N)=0.0d0
        endif
      else
        Y2(N)=YPN
      endif

      C(1)=Y2(1)
      C(N)=y2(n)

      BB(1)=1.D0
      CC(1)=0.D0
      CC(N)=1.D0

      DO J=2,N-1
        AA(J)=(X(J  )-X(J-1))/6.D0
        BB(J)=(X(J+1)-X(J-1))/3.D0
        CC(J)=(X(J+1)-X(J  ))/6.D0
        C(J)=(Y(J+1)-Y(J  ))/(X(J+1)-X(J  ))
     &    -(Y(J  )-Y(J-1))/(X(J  )-X(J-1))
      ENDDO !J

      DO J=2,N-1

        BB(J)=BB(J)-AA(J)*CC(J-1)
        C(J)= C(J)-AA(J)* C(J-1)

        CC(J)=CC(J)/BB(J)
        C(J)= C(J)/BB(J)
        BB(J)=1.D0

      ENDDO !J

      DO J=N-1,2,-1
        Y2(J)=C(J)-CC(J)*Y2(J+1)
      ENDDO

      DO I=1,N-1
        I1=I+1
        YP(I)=(Y(I1)-Y(I))/(X(I1)-X(I))-
     &    (Y2(I1)+2.D0*Y2(I))/6.D0*(X(I1)-X(I))
      ENDDO

      I1=N
      I=N-1

      YP(N)=(Y(I1)-Y(I))/(X(I1)-X(I))+
     &  (2.D0*Y2(I1)+Y2(I))/6.D0*(X(I1)-X(I))

      RETURN
      END
+DECK,util_fourier_linear_complex_2d.
*CMZ :  4.01/05 28/03/2024  14.33.20  by  Michael Scheer
*CMZ : 00.00/02 22/04/99  17.27.52  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.25.29  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine util_fourier_linear_complex_2d(nx,ny,x,y,f,nomx,nomy,omx,omy,ft,ifail)

      implicit none

      integer nx,ny,nomx,nomy,ix,iy,ifail,jfail

      complex*16 :: f(nx,ny),ft(nomx,nomy),fxy(max(nx,ny)),ftxy(max(nx,ny)),ftx(nomx,ny)

      real*8 x(nx),y(ny),omx(nomx),omy(nomy)

      ifail=0

      do iy=1,ny
        fxy(1:nx)=f(1:nx,iy)
        call util_fourier_linear_complex(nx,x,fxy,nomx,omx,ftxy,jfail)
        ftx(1:nomx,iy)=ftxy(1:nomx)
        ifail=ifail+jfail
      enddo !ny

      do ix=1,nomx
        fxy(1:ny)=ftx(ix,1:ny)
        call util_fourier_linear_complex(ny,y,fxy,nomy,omy,ftxy,jfail)
        ft(ix,1:nomy)=ftxy(1:nomy)
        ifail=ifail+jfail
      enddo !ny

      return
      end
+DECK,util_zeit_kommentar_delta.
*CMZ :  4.01/05 16/04/2024  12.38.45  by  Michael Scheer
*CMZ :  2.05/04 16/12/2023  12.06.33  by  Michael Scheer
*CMZ :  2.04/19 16/09/2023  16.33.50  by  Michael Scheer
*CMZ :  2.03/00 26/07/2022  07.55.50  by  Michael Scheer
*CMZ :  2.02/02 01/07/2022  17.30.28  by  Michael Scheer
*CMZ :  2.02/00 29/03/2021  09.26.44  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  18.24.11  by  Michael Scheer
*CMZ : 00.00/15 04/01/2013  12.22.07  by  Michael Scheer
*CMZ : 00.00/05 27/02/2007  16.32.04  by  Michael Scheer
*CMZ : 00.00/02 04/08/2006  14.56.41  by  Michael Scheer
*CMZ : 00.00/00 10/01/95  15.25.58  by  Michael Scheer
*-- Author : Michael Scheer
      subroutine util_zeit_kommentar_delta(lun,comment,iset)

c to determine date and time and write it to logical unit lun

      implicit none

      integer lun,ilast

      character(*) comment

      character spacer(30)
      character(10) dtday,dttime,dtzone
      character(32) c32
      character(2048) :: cblank=''
      character(2048) cline

      real :: seconds=0.0,secondso=0.0
      integer idatetime(8),iyear,imonth,iday,ihour,iminute,isec
      integer iyearo,imontho,idayo,ihouro,iminuteo,iseco,kday,khour,kminit,ksec

      integer :: ical=0,linlen,iset,iseconds,isecondso

      data spacer/30*' '/

      save

      call date_and_time(dtday,dttime,dtzone,idatetime)

      iyear=idatetime(1)
      imonth=idatetime(2)
      iday=idatetime(3)
      ihour=idatetime(5)
      iminute=idatetime(6)
      isec=idatetime(7)

      ilast=len_trim(comment)

      write(lun,*)
      if (ilast.gt.0) then
        write(cline,*)comment(1:ilast),spacer,dttime(1:2),':',dttime(3:4),':',
     &    dttime(5:6),' ',dtday(7:8),'.',dtday(5:6),'.',dtday(3:4)
      else
        write(cline,*)spacer,dttime(1:2),':',dttime(3:4),':',dttime(5:6),' '
     &    ,dtday(7:8),'.',dtday(5:6),'.',dtday(3:4)
      endif

      ilast=len_trim(cline)

      if (ilast.lt.64) then
        write(lun,'(a)') cblank(1:64-ilast) // cline(1:ilast)
      else
        write(lun,'(a)') trim(cline)
      endif

      if (ical.gt.0.and.iset.eq.0) then
        cline='  delta time: '
        seconds=secnds(secondso)
        iseconds=nint(seconds)
        kday=0
        khour=0
        kminit=0
        ksec=0
        if (iseconds.ge.3600*24) then
          kday=iseconds/(3600*24)
          iseconds=iseconds-kday*3600*24
          write(c32,*)kday
          cline=trim(cline) // trim(c32) // ' days '
        endif
        if (iseconds.ge.3600) then
          khour=iseconds/3600
          iseconds=iseconds-khour*3600
          write(c32,*)khour
          cline=trim(cline) // trim(c32) // ' hours '
        endif
        if (iseconds.ge.60) then
          kminit=iseconds/60
          iseconds=iseconds-kminit*60
          write(c32,*)kminit
          cline=trim(cline) // trim(c32) // ' minutes '
        endif
        write(c32,*)iseconds
        cline=trim(cline) // trim(c32) // ' seconds'
        write(lun,*) trim(cline)
      endif

      write(lun,*)''

      if (ical.eq.0.or.iset.ne.0) then
        secondso=secnds(0.0)
        isecondso=nint(secondso)
        iyearo=iyear
        imontho=imonth
        idayo=iday
        ihouro=ihour
        iminuteo=iminute
        iseco=isec
      endif

      ical=1

      return
      end
+DECK,UTIL_SIMPSON_INTEGRAL,T=F77.
*CMZ :  4.01/07 16/05/2024  10.08.43  by  Michael Scheer
*CMZ : 00.00/02 21/08/2006  11.07.41  by  Michael Scheer
*-- Author :    Michael Scheer   21/08/2006
      subroutine util_simpson_integral(n,x,f,sum)

      implicit none

      double precision x(n),f(n),sum
      integer n,i

      sum=0.0d0

      do i=1,n-1
        sum=sum+(f(i+1)+f(i))*(x(i+1)-x(i))/2.d0
      enddo

      return
      end
+DECK,sbend.
*CMZ :  4.01/07 19/01/2025  09.27.21  by  Michael Scheer
*-- Author :    Michael Scheer   23/11/2024
      subroutine sbend(nmag,imag,cbmodel,rho,dbrho,angi,fint,hgap,
     &  cposmodel,xpos,zpos,angex,ebeam,b0,bmovecut,ds,icharge,fringe,fa,fb,fc,istatus)

cdbuff dcbuff
      implicit none

      integer, parameter :: lp=1000

      real*8 r,rho,angle,fint,hgap,posi(7,2),posdum(7,5),ebeam,de,bmovecut,ds,
     &  fringe,fa,fb,fc,b0,a,sina,cosa,d,e1,e2,vx,vz,angi,phi,zenith(3,3),apara(3),zp(3),xopt,zopt,
     &  X2,Y2,Z2,VX2,VY2,VZ2,DTIM,GAMMA,beta,dbrho,da,agoal,v0,anga(2,lp),xe,ze,xi,zi,
     &  y2a(lp),cen(3),ango,arot,vin(3),vout(3),xexit,zexit,dx,dz,xpos,zpos,angex,vrot(3),adjust

      integer nmag,imag,icharge,istatus,i,l
      character(32) cbmodel,cposmodel

+seq,mgsqc.
+seq,phyconparam.

      call sbend_fringe(cbmodel,fint,hgap,fringe,fa,fb,fc,istatus)
      if (istatus.ne.0) then
        print*,"*** Warning in SBEND: Bad return from SBEND_FRINGE, be careful ***"
      endif

      call sbend_int_fringe(cbmodel,fringe,fa,fb,fc,ebeam,b0,bmovecut,ds,posdum,icharge,istatus)
      if (istatus.ne.0) then
        print*,"*** Warning in SBEND_INT_FRINGE: Bad return from SBEND_FRINGE, be careful ***"
      endif

      angle=angi*grarad1
      gamma=ebeam/emassg1
      beta=dsqrt((1.d0-1.d0/gamma)*(1.d0+1.d0/gamma))
      dtim=ds/(clight1*beta)
      v0=beta*clight1

      r=icharge*rho

      if (rho.lt.0.0d0) then
        agoal=angi*grarad1/2.0d0
      else
        agoal=-angi*grarad1/2.0d0
      endif

      da=abs(atan(posdum(6,2)/posdum(4,2)))

      vin=[cos(agoal),0.0d0,-sin(agoal)]
      adjust=0.0d0

      posi(4,1)=vin(1)
      posi(6,1)=vin(3)
      posi(4,2)=vin(1)
      posi(6,2)=-vin(3)

      xe=abs(r*vin(3))
      ze=r*(1.0d0-vin(1))

      if (nmag.gt.0) then
        pmag(3,imag)=posi(4,1)
        pmag(4,imag)=posi(6,1)
        pmag(7,imag)=posi(4,2)
        pmag(8,imag)=posi(6,2)
      else
        pmag(3,imag)=1.0d0
        pmag(4,imag)=0.0d0
        pmag(7,imag)=1.0d0
        pmag(8,imag)=0.0d0
      endif

      if (cbmodel.eq.'hard-edge') then
        pmag(9,imag)=0.0d0
      else if (cbmodel.eq.'linear') then
        pmag(9,imag)=1.0d0
      else if (cbmodel.eq.'cubic-spline') then
        pmag(9,imag)=3.0d0
      else if (cbmodel.eq.'quintic-spline') then
        pmag(9,imag)=5.0d0
      else
        pmag(9,imag)=0.0d0
        cbmodel="hard-edge"
      endif

      pmag(10,imag)=dbrho/r
c        pmag(11,imag)=edge(1)
c        pmag(12,imag)=edge(2)
      pmag(13,imag)=fint
      pmag(14,imag)=2.0d0*hgap

      pmag(15,imag)=fringe
      pmag(16,imag)=fa
      pmag(17,imag)=fb
      pmag(18,imag)=fc

      do l=1,lp

        if (l.eq.1) then
          angle=angi*grarad1-da
          adjust=-fringe/2.0d0
        else if (l.eq.2) then
          angle=angi*grarad1+da
          adjust=fringe/2.0d0
        endif

        if (rho.lt.0.0d0) then
          a=abs(angle)/2.0d0
        else
          a=-abs(angle)/2.0d0
        endif

        sina=sin(a)
        cosa=cos(a)

        d=adjust

        posi(1,2)=xe+d*cosa
        posi(3,2)=ze+d*sina

        posi(1,1)=-posi(1,2)
        posi(3,1)= posi(3,2)

        pmag(1,imag)=posi(1,1)
        pmag(2,imag)=posi(3,1)

        pmag(5,imag)=posi(1,2)
        pmag(6,imag)=posi(3,2)

        call TRACKBEND(posi(1,1),0.0d0,posi(3,1),v0*vin(1),0.0d0,v0*vin(3),
     &    posi(1,2),posi(2,2),posi(3,2),
     &    vin(1),0.0d0,-vin(3),
     &    X2,Y2,Z2,VX2,VY2,VZ2,zenith,DTIM,GAMMA,iabs(nmag),imag,
     &    bmovecut,0,icharge,0)
        vout=[vx2/v0,0.0d0,vz2/v0]

        if (l.ge.3) then
          anga(1:2,l-1)=anga(1:2,l)
        endif

        anga(1,l)=adjust
        anga(2,l)=abs(acos(dot_product(vin,vout)))
        angle=anga(2,l)

        if (l.ge.2) then
          call util_adjust(angi*grarad1/1.0d0,anga(1,l-1),anga(2,l-1),anga(1,l),anga(2,l))
          adjust=anga(1,l)
        endif

        if (abs((anga(2,l)*radgra1-angi/1.0d0)/(anga(2,l)*radgra1+angi/2.0d0)).le.1.0d-9) then
          exit
        endif

      enddo !Loop to adjust angle

      call util_parabel(
     &  [zenith(1,1),zenith(1,2),zenith(1,3)],
     &  [zenith(3,1),zenith(3,2),zenith(3,3)],
     &  apara,zp,xopt,zopt,istatus)

      if (l.ge.lp) then
        print*,"*** Warning in SBEND: Adjustment of angle failed, be careful ***"
      else
        istatus=0
      endif

      if (angex.ne.0.0d0) then

        cen=0.0d0
        phi=icharge*angex*grarad1
        vrot=[0.0d0,1.0d0,0.0d0]

        vin=[pmag(1,imag),0.0d0,pmag(2,imag)]
        call util_rotate(cen,vrot,phi,vin,vout,istatus)
        pmag(1,imag)=vout(1)
        pmag(2,imag)=vout(3)

        vin=[xopt,0.0d0,zopt]
        call util_rotate(cen,vrot,phi,vin,vout,istatus)
        xopt=vout(1)
        zopt=vout(3)

        vin=[pmag(3,imag),0.0d0,pmag(4,imag)]
        call util_rotate(cen,vrot,phi,vin,vout,istatus)
        pmag(3,imag)=vout(1)
        pmag(4,imag)=vout(3)

        vin=[pmag(5,imag),0.0d0,pmag(6,imag)]
        call util_rotate(cen,vrot,phi,vin,vout,istatus)
        pmag(5,imag)=vout(1)
        pmag(6,imag)=vout(3)

        vin=[pmag(7,imag),0.0d0,pmag(8,imag)]
        call util_rotate(cen,vrot,phi,vin,vout,istatus)
        pmag(7,imag)=vout(1)
        pmag(8,imag)=vout(3)

      endif

      if (cposmodel.eq.'entrance') then
        dx=xpos-pmag(1,imag)
        dz=zpos-pmag(2,imag)
      else if (cposmodel.eq.'zenith') then
        dx=xpos-xopt
        dz=zpos-zopt
      else if (cposmodel.eq.'exit') then
        dx=xpos-pmag(5,imag)
        dz=zpos-pmag(6,imag)
      endif

      pmag(1,imag)=pmag(1,imag)+dx
      pmag(2,imag)=pmag(2,imag)+dz
      pmag(5,imag)=pmag(5,imag)+dx
      pmag(6,imag)=pmag(6,imag)+dz

      return
      end
+DECK,sbend_fringe.
*CMZ :  4.01/07 24/11/2024  16.01.01  by  Michael Scheer
*-- Author :    Michael Scheer   23/11/2024
      subroutine sbend_fringe(cbmodel,fint,hgap,fringe,fa,fb,fc,istatus)

cdbuff dcbuff
      implicit none

      double precision fint,hgap,gap,fringe,fa,fb,fc,fringe1,fringe2,fringe3,fringe4,fringe5

      integer istatus
      character(32) cbmodel

*KEEP,phyconparam.
      include 'phyconparam.cmn'
*KEND.

      istatus=0
      fa=0.0d0
      fb=0.0d0
      fc=0.0d0
      gap=2.0d0*hgap

      if (cbmodel.eq."hard-edge") then
        fringe=0.0d0
      else if (cbmodel.eq."linear") then
        fringe=6.0d0*fint*gap
        fa=1.0d0/fringe
      else if (cbmodel.eq."cubic-spline") then
        fringe=70.0d0/9.0d0*fint*gap
        fringe2=fringe*fringe
        fringe3=fringe2*fringe
        fb=-2.0d0/fringe3
        fa=3.0d0/fringe2
      else if (cbmodel.eq."quintic-spline") then
        fringe=231.0d0*fint*gap/25.0d0
        fringe2=fringe*fringe
        fringe3=fringe2*fringe
        fringe4=fringe2*fringe2
        fringe5=fringe3*fringe2
        fa=10.0d0/fringe3
        fb=-15.0d0/fringe4
        fc=6.0d0/fringe5
      else
        istatus=-1
        fringe=0.0d0
      endif

      end
+DECK,bfringe.
*CMZ :  4.01/07 13/01/2025  22.09.50  by  Michael Scheer
*-- Author :    Michael Scheer   23/11/2024
      subroutine bfringe(cbmodel,x,y,z,b0,bx,by,bz,fringe,fa,fb,fc,icharge,istatus)

      implicit none

cdbuff dcbuff

      double precision, intent(in) :: x,y,z,b0,fringe,fa,fb,fc
      double precision, intent(out) :: bx,by,bz
      double precision x2,x3,x4,x5,y2,y3

      character(32), intent(in) :: cbmodel

      integer, intent(in) :: icharge
      integer, intent(out) :: istatus

      include 'phyconparam.cmn'

      istatus=0

      bx=0.0d0
      by=0.0d0
      bz=0.0d0

      if(x.lt.0.0d0) return

      if (cbmodel.eq."quintic-spline") then
        x2=x*x
        x3=x2*x
        x4=x2*x2
        x5=x3*x2
        y2=y*y
        y3=y2*y
        bx=y*(3.0d0*Fa*x2+4.0d0*fb*x3+5.0d0*fc*x4)
     &    +y3*(-fa-4.0d0*fb*x-10.0d0*fc*x2) !This term is not Maxwell conform
c             by2=(fa*x3+fb*x4+fc*x5)+y2*x*(3.0d0*fa+6.0d0*fb*x+10.0d0*fc*x2) ! The sign seems to be wrong in the manual
        by=(fa*x3+fb*x4+fc*x5)-y2*x*(3.0d0*fa+6.0d0*fb*x+10.0d0*fc*x2)
      else if (cbmodel.eq.'cubic-spline') then
        x2=x*x
        x3=x2*x
        bx=(2.0d0*fa*x+3.0d0*fb*x2)*y
        by=(fa*x2+fb*x3+y**2*(-fa-3.0d0*fb*x))
      else if (cbmodel.eq.'linear') then
        bx=y*fa
        by=x*fa
      else
        stop "*** Bad model in bfringe ***"
      endif

      bx=bx*b0
      by=by*b0

      return
      end
+DECK,util_solve_matrix_3x3.
*CMZ :  4.01/07 06/10/2023  12.12.36  by  Michael Scheer
*-- Author :    Michael Scheer   15/08/2018
      subroutine util_solve_matrix_3x3(a,b,x,ifail)

c +PATCH,//UTIL/UTIL
c +DECK,util_solve_matrix_3x3.

      ! Calculate matrix x, such that b=x*a

      implicit none

      double precision x(3,3),a(3,3),b(3,3),det,v(3)
      integer :: ifail,i

      ifail=0
      call util_determinante_3(a,det)
      if (abs(det).lt.1.0d-30) then
        ifail=-1
        return
      endif

      do i=1,3
        v=b(1:3,i)
        call util_solve_3x3(a,v,ifail)
        if (ifail.ne.0) return
        x(1:3,i)=v
      enddo

      return
      end
+DECK,bybend.
*CMZ :  4.01/07 16/01/2025  10.57.38  by  Michael Scheer
*CMZ :  4.00/11 26/07/2021  09.08.58  by  Michael Scheer
*CMZ :  3.06/00 11/02/2019  12.49.34  by  Michael Scheer
*CMZ :  3.04/00 19/01/2018  16.33.13  by  Michael Scheer
*CMZ :  3.03/02 16/02/2016  12.18.47  by  Michael Scheer
*CMZ :  3.01/00 15/07/2013  08.04.32  by  Michael Scheer
*CMZ :  2.68/03 07/08/2012  13.09.30  by  Michael Scheer
*CMZ :  2.66/07 04/12/2009  16.11.19  by  Michael Scheer
*CMZ :  2.52/11 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  1.02/00 19/12/97  16.15.53  by  Michael Scheer
*CMZ :  1.01/00 28/10/97  12.14.09  by  Michael Scheer
*CMZ : 00.01/08 01/04/95  16.54.24  by  Michael Scheer
*CMZ : 00.01/07 10/03/95  11.22.55  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  15.21.20  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.48.03  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.42  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE bybend(nmag,im,XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT)
+seq,gplhint.

      IMPLICIT NONE

      INTEGER nmag,IM

+SEQ,CONTRL.
+SEQ,MGSQC.

      DOUBLE PRECISION XIN,YIN,ZIN,BX,BY,BZ,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT
      DOUBLE PRECISION dist,fint,gap,fringe,fa,fb,fc,xrs(3),
     &  strength,pin(3),center(3),pout(3),vnin(3),vnout(3),b(3),edge(2),x,y,z,x2,x3,x4,x5,y2,y3

      integer istatus,modus

      x=xin
      y=yin
      z=zin

      BXOUT=0.0d0
      BYOUT=0.0d0
      BZOUT=0.0d0

      AXOUT=0.0d0
      AYOUT=0.0d0
      AZOUT=0.0d0

      BX=0.0d0
      BY=0.0d0
      BZ=0.0d0

      dist=dot_product([pmag(1,im),0.0d0, pmag(2,im)]-[x,y,z],[pmag(3,im), 0.0d0, pmag(4,im)])

      if (dist.ge.0.0d0) return

      modus=int(pmag(9,im))
      strength=pmag(10,im)
      fringe=pmag(15,im)
      fa=pmag(16,im)
      fb=pmag(17,im)
      fc=pmag(18,im)

      if (dist.ge.-fringe) then
        x=-dist
        if (modus.eq.0) then
          byout=1.0d0
        else if (modus.eq.1) then
          bxout=y*fa
          byout=x*fa
        else if (modus.eq.3) then
          x2=x*x
          x3=x2*x
          bxout=(2.0d0*fa*x+3.0d0*fb*x2)*y
          byout=fa*x2+fb*x3+y**2*(-fa-3.0d0*fb*x)
        else if (modus.eq.5) then
          x2=x*x
          x3=x2*x
          x4=x3*x
          x5=x4*x
          y2=y*y
          y3=y2*y
          bxout=y*(3.0d0*Fa*x2+4.0d0*fb*x3+5.0d0*fc*x4)
     &      +y3*(-fa-4.0d0*fb*x-10.0d0*fc*x2) !This term is not Maxwell conform
          !byout=(fa*x3+fb*x4+fc*x5)+y2*x*(3.0d0*fa+6.0d0*fb*x+10.0d0*fc*x2) ! The sign seems to be wrong in the manual
          byout=(fa*x3+fb*x4+fc*x5)-y2*x*(3.0d0*fa+6.0d0*fb*x+10.0d0*fc*x2)
        endif
        byout=byout*strength
        bxout=-bxout*strength
        return
      endif

      dist=dot_product([pmag(5,im),0.0d0, pmag(6,im)]-[x,y,z],[pmag(7,im), 0.0d0, pmag(8,im)])
      if (dist.lt.0.0d0) return

      if (dist.le.fringe) then
        x=dist
        if (modus.eq.0) then
          byout=1.0d0
        else if (modus.eq.1) then
          bxout=y*fa
          byout=x*fa
        else if (modus.eq.3) then
          x2=x*x
          x3=x2*x
          bxout=(2.0d0*fa*x+3.0d0*fb*x2)*y
          byout=fa*x2+fb*x3+y**2*(-fa-3.0d0*fb*x)
        else if (modus.eq.5) then
          x2=x*x
          x3=x2*x
          x4=x3*x
          x5=x4*x
          y2=y*y
          y3=y2*y
          bxout=y*(3.0d0*Fa*x2+4.0d0*fb*x3+5.0d0*fc*x4)
     &      +y3*(-fa-4.0d0*fb*x-10.0d0*fc*x2) !This term is not Maxwell conform
          !byout=(fa*x3+fb*x4+fc*x5)+y2*x*(3.0d0*fa+6.0d0*fb*x+10.0d0*fc*x2) ! The sign seems to be wrong in the manual
          byout=(fa*x3+fb*x4+fc*x5)-y2*x*(3.0d0*fa+6.0d0*fb*x+10.0d0*fc*x2)
        endif
        byout=byout*strength
        bxout=bxout*strength
      else
        byout=strength
      endif

      return
      end
+DECK,TRACKBEND.
*CMZ :  4.01/07 18/01/2025  11.16.27  by  Michael Scheer
*CMZ :  4.00/15 05/04/2022  11.56.08  by  Michael Scheer
*CMZ :  3.04/00 04/01/2018  18.10.43  by  Michael Scheer
*CMZ :  2.70/12 01/03/2013  16.28.24  by  Michael Scheer
*CMZ :  2.66/20 06/07/2011  09.41.56  by  Michael Scheer
*CMZ :  2.63/05 12/05/2010  13.34.28  by  Michael Scheer
*CMZ :  2.61/02 14/03/2007  15.48.38  by  Michael Scheer
*CMZ :  2.53/01 24/01/2005  10.55.32  by  Michael Scheer
*CMZ :  2.34/07 06/09/2001  11.25.52  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.36  by  Michael Scheer
*CMZ :  2.12/00 02/06/99  13.56.19  by  Michael Scheer
*CMZ :  1.02/00 19/12/97  17.09.57  by  Michael Scheer
*CMZ : 00.02/01 18/12/96  11.40.20  by  Michael Scheer
*CMZ : 00.01/10 16/07/96  14.53.50  by  Michael Scheer
*CMZ : 00.01/09 11/04/96  17.41.50  by  Michael Scheer
*CMZ : 00.01/02 21/11/94  09.51.12  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.41.55  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.11.31  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE TRACKBEND(Xin,Yin,Zin,VXin,VYin,VZin,XF0,YF0,ZF0,EWSFX,EWSFY,EWSFZ,
     &  X2,Y2,Z2,VX2,VY2,VZ2,zenith,DTIM,GAMMA,nmag,IMAG,
     &  BMOVECUT,iustep,icharge,ieneloss)
+seq,gplhint.

C--- CLONE OF TRACKSHORT, BUT CALLING BYBEND INSTEAD OF MYBFELD


C---     INPUT:
C     Xin,Yin,Zin    coordinates of electron at the starting point
C     VXin,VYin,VZin    velocity at the starting point
C     XF0,YF0,ZF0    point of the plane where tracking stops
C     EWSFX,EWSFY,EWSFZ normal vector of the plane
C     DTIM        time intervall of one tracking step
C     ICHARGE particle charge
C     GAMMA       relativistic factor

C---  OUTPUT:
C     X2,Y2,Z2    final coordinates of the electron
C     VX2,VY2,VZ2    final velocity of the electron
c     zenith of arc

      IMPLICIT NONE

      INTEGER IM,IUSTEP,IENELOSS,nmag,IMAG,icharge,ido

      DOUBLE PRECISION :: xin,yin,zin,vxin,vyin,vzin,X1,Y1,Z1,VX1,VY1,VZ1,X2,Y2,Z2,VX2,VY2,VZ2
     &  ,DTIM,BSHIFT=0.5D0,X2B,Y2B,Z2B,BX1,BY1,BZ1,BX2,BY2,BZ2
     &  ,GAMMA,DT,VXDUM,VYDUM,VZDUM,VXPDUM,VYPDUM,VZPDUM
     &  ,X2INT,Y2INT,Z2INT,DDT,DDDT,DDT2
     &  ,VX2INT,VY2INT,VZ2INT,VXPINT,VYPINT,VZPINT
     &  ,VXP,VYP,VZP,XOLD,YOLD,ZOLD,VXOLD,VYOLD,VZOLD
     &  ,X3INT,Y3INT,Z3INT,VX3INT,VY3INT,VZ3INT,DDDDT,DDDDT2
     &  ,EWSFX,EWSFY,EWSFZ,XF0,YF0,ZF0,DIST1,DIST2,DISTI,BMOVECUT,
     &  ax,ay,az,zenith(3,3)

      DOUBLE PRECISION T1,T2,DGAMMA

+SEQ,PHYCON.

      x1=xin
      y1=yin
      z1=zin
      vx1=vxin
      vy1=vyin
      vz1=vzin

      zenith(1:3,1)=[xin,yin,zin]
      zenith(1:3,2)=[xin,yin,zin]
      zenith(1:3,3)=[xin,yin,zin]

      IF (IENELOSS.NE.0) THEN
        WRITE(16,*)
        WRITE(16,*)
     &    ' *** WARNING IN TRACKBMAG: IENELOSS .NE. 0, NOT YET IMPLEMENTED ***'
        WRITE(16,*)
     &    ' *** BE CAREFUL!! ***'
        WRITE(16,*)
        WRITE(6,*)
        WRITE(6,*)
     &    ' *** WARNING IN TRACKBMAG: IENELOSS .NE. 0, NOT YET IMPLEMENTED ***'
        WRITE(6,*)
     &    ' *** BE CAREFUL!! ***'
        WRITE(6,*)
      ENDIF

      DT=DTIM*BSHIFT

      T1=0.0

      BX1=0.D0
      BY1=0.D0
      BZ1=0.D0

      XOLD=X1
      YOLD=Y1
      ZOLD=Z1
      VXOLD=VX1
      VYOLD=VY1
      VZOLD=VZ1

      X2=X1
      Y2=Y1
      Z2=Z1
      T2=T1

      VX2=VX1
      VY2=VY1
      VZ2=VZ1

      BX2=BX1
      BY2=BY1
      BZ2=BZ1

C--- LOOP DER TRAJEKTORIE

      ido=1

c      open(unit=66)
1000  X1=X2
      Y1=Y2
      Z1=Z2

      T1=T2

      VX1=VX2
      VY1=VY2
      VZ1=VZ2

      BX1=BX2
      BY1=BY2
      BZ1=BZ2

      X2B=X1+VX1*DT
      Y2B=Y1+VY1*DT
      Z2B=Z1+VZ1*DT

      CALL BYBEND(nmag,imag,X2B,Y2B,Z2B,BX2,BY2,BZ2,ax,ay,az)

      CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DTIM,
     &  X2,Y2,Z2,VX2,VY2,VZ2,VXP,VYP,VZP,GAMMA,ICHARGE,BMOVECUT,
     &  IUSTEP,IENELOSS,DGAMMA)

      if (ido.eq.1) then
        if (vzin.gt.0.0d0) then
          zenith(1:3,1)=zenith(1:3,2)
          zenith(1:3,2)=zenith(1:3,3)
          zenith(1:3,3)=[x2,y2,z2]
          if (z2.lt.z1) ido=0
        else
          zenith(1:3,1)=zenith(1:3,2)
          zenith(1:3,2)=zenith(1:3,3)
          zenith(1:3,3)=[x2,y2,z2]
          if (z2.gt.z1) ido=0
        endif
      endif

      T2=T1+DTIM

C EWSF IS NORMAL VECTOR OF PERPENDICULARE PLANE AT THE END OF THE REFERENCE ORBI
C DIST IS DISTANCE OF ELECTRON TO THIS PLANE
C TRACKING STOPS IF TRAJECTORIE HITS THIS PLANE

      DIST2=(X2-XF0)*EWSFX+(Y2-YF0)*EWSFY+(Z2-ZF0)*EWSFZ

c      write(66,*)x2,z2,vx2,vz2,by2

      IF ( DIST2 .LT. 0.0  )  GOTO 1000

C--- ENDE OF TRAJECTORY, DIST2 NOT EXACTLY ZERO, CORRECT X2

      DIST1=(X1-XF0)*EWSFX+(Y1-YF0)*EWSFY+(Z1-ZF0)*EWSFZ

      DDT=DTIM*DABS(DIST1)/(DABS(DIST1)+DABS(DIST2))
      DDT2=DDT*BSHIFT

      X2B=X1+VX1*DDT2
      Y2B=Y1+VY1*DDT2
      Z2B=Z1+VZ1*DDT2

      CALL BYBEND(nmag,imag,X2B,Y2B,Z2B,BX2,BY2,BZ2,ax,ay,az)

       CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DDT,
     &   X2INT,Y2INT,Z2INT,VX2INT,VY2INT,VZ2INT,
     &   VXPINT,VYPINT,VZPINT,GAMMA,ICHARGE,BMOVECUT,IUSTEP,IENELOSS,DGAMMA)

       DISTI=(X2INT-XF0)*EWSFX+(Y2INT-YF0)*EWSFY+(Z2INT-ZF0)*EWSFZ
       DDDT=DDT
       IF (DIST1.NE.0.) DDDT=DDT-DDT*DISTI/DABS(DIST1)

       CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DDDT,
     &   X3INT,Y3INT,Z3INT,VX3INT,VY3INT,VZ3INT,
     &   VXPINT,VYPINT,VZPINT,GAMMA,ICHARGE,BMOVECUT,IUSTEP,IENELOSS,DGAMMA)

       DISTI=(X3INT-XF0)*EWSFX+(Y3INT-YF0)*EWSFY+(Z3INT-ZF0)*EWSFZ
       DDDDT=DDDT
       IF (DIST1.NE.0.) DDDDT=DDDT-DDDT*DISTI/DABS(DIST1)
       DDDDT2=BSHIFT*DDDDT

       CALL BMOVETAYL(X1,Y1,Z1,VX1,VY1,VZ1,BX2,BY2,BZ2,DDDDT,
     &   X2,Y2,Z2,VX2,VY2,VZ2,
     &   VXP,VYP,VZP,GAMMA,ICHARGE,BMOVECUT,IUSTEP,IENELOSS,DGAMMA)

       T2=T1+DDDDT

       X1=XOLD
       Y1=YOLD
       Z1=ZOLD
       VX1=VXOLD
       VY1=VYOLD
       VZ1=VZOLD
c       write(66,*)x2,z2,vx2,vz2,by2
c       close(66)
      RETURN
      END
+DECK,sbend_int_fringe.
*CMZ :  4.01/07 13/01/2025  22.54.56  by  Michael Scheer
*-- Author :    Michael Scheer   23/11/2024
      subroutine sbend_int_fringe(cbmodel,fringe,fa,fb,fc,ebeam,b0,bmovecut,ds,posi,icharge,
     &  istatus)

      implicit none

cdbuff dcbuff
      real*8 angle,fint,hgap,posi(7,5),ebeam,de,bmovecut,ds,v(3),dgsum,t,
     &  fringe,fa,fb,fc,beta,gamma,dtim,dtim0,angi,s,x2,x1,y2,y1,z2,z1,vx1,vx2,vy2,vy1,
     &  vz2,vz1,vn,hit(3),dist1,distn,ang,b0,ds2,xb,yb,zb,bx,by,bz,dgamma,vxp,vyp,vzp,v0

      integer :: iustep=0,ieneloss=0,icharge,istatus
      character(32) cbmodel

+seq,phyconparam.

      gamma=ebeam/emassg1 !GeV
      beta=dsqrt((1.0d0-1.0d0/gamma)*(1.0d0+1.0d0/gamma))
      v0=beta*clight1

      posi=0.0d0

      posi(1:7,1)=[0.0d0,0.0d0,0.0d0,1.0d0,0.0d0,0.0d0,0.0d0]
      posi(1:7,2)=[fringe,0.0d0,0.0d0,1.0d0,0.0d0,0.0d0,0.0d0]

      if (cbmodel.eq.'hard-edge') then
        return
      endif

      t=0.0d0

      x2=0.0d0
      y2=0.0d0
      z2=0.0d0

      vx2=v0
      vy2=0.0d0
      vz2=0.0d0

      s=0.0d0

      de=0.0d0
      dtim0=ds/clight1/beta
      dtim=dtim0

      ang=atan2(vz2,vx2)
      if (ang.lt.0.0d0) ang=ang+twopi1

      !track throught fringe

      do while (.true.)

        x1=x2
        y1=y2
        z1=z2

        vx1=vx2
        vy1=vy2
        vz1=vz2

        vn=sqrt(vx1**2+(vy1**2+vz1**2))

        call util_plane_hit_hesse(
     &    posi(1:3,2),posi(4:6,2),
     &    [x1,y1,z1],[vx1,vy1,vz1],
     &    hit,dist1,distn,istatus)

        if (dist1.le.ds) exit

        xb=x1+vx1*dtim/2.0d0
        yb=y1+vy1*dtim/2.0d0
        zb=z1+vz1*dtim/2.0d0

        call bfringe(cbmodel,xb,yb,zb,b0,bx,by,bz,fringe,fa,fb,fc,icharge,istatus)

        call bmovetayl(x1,y1,z1,vx1,vy1,vz1,bx,by,bz,dtim,
     &    x2,y2,z2,vx2,vy2,vz2,vxp,vyp,vzp,gamma,icharge,bmovecut,
     &    iustep,ieneloss,dgamma)

        t=t+dtim
        s=s+sqrt((x2-x1)**2+(y2-y1)**2+(z2-z1)**2)

        dgsum=dgsum+dgamma

      enddo !while

      dtim=dtim0*dist1/ds

      xb=x1+vx1*dtim/2.0d0
      yb=y1+vy1*dtim/2.0d0
      zb=z1+vz1*dtim/2.0d0

      call bfringe(cbmodel,xb,yb,zb,b0,bx,by,bz,fringe,fa,fb,fc,icharge,istatus)

      call bmovetayl(x1,y1,z1,vx1,vy1,vz1,bx,by,bz,dtim,
     &  x2,y2,z2,vx2,vy2,vz2,vxp,vyp,vzp,gamma,icharge,bmovecut,
     &  iustep,ieneloss,dgamma)

      t=t+dtim
      dtim=dtim0*(dist1)/ds

      s=s+sqrt((x2-x1)**2+(y2-y1)**2+(z2-z1)**2)
      vn=sqrt(vx1**2+(vy1**2+vz1**2))

      posi(1:7,2)=[x2,y2,z2,vx2/vn,vy2/vn,vz2/vn,s]

      end
+DECK,util_rotate.
*CMZ :  2.02/01 14/10/2021  05.12.31  by  Michael Scheer
*-- Author :    Michael Scheer   06/04/2018
      subroutine util_rotate(cen,vrot,phi,vin,vout,istat)

c +PATCH,//UTIL/FOR
c +DECK,util_rotate.
      implicit none

      double precision cen(3),phi,vin(3),vout(3),vrot(3),vlen,o(3),
     &  r(3),s,c,c1,rm(3,3)

      integer istat

      istat=0

      vlen=norm2(vrot)
      if (vlen.eq.0.0d0) then
        vout=vin
        istat=1
        return
      endif

      o=vrot/vlen
      s=sin(phi)
      c=cos(phi)
      c1=1.0d0-c

      rm(1,1)=o(1)*o(1)*c1+c
      rm(2,2)=o(2)*o(2)*c1+c
      rm(3,3)=o(3)*o(3)*c1+c

      rm(1,2)=o(1)*o(2)*c1-o(3)*s
      rm(1,3)=o(1)*o(3)*c1+o(2)*s

      rm(2,1)=o(1)*o(2)*c1+o(3)*s
      rm(2,3)=o(2)*o(3)*c1-o(1)*s

      rm(3,1)=o(1)*o(3)*c1-o(2)*s
      rm(3,2)=o(2)*o(3)*c1+o(1)*s

      r=vin-cen

      vout(1)=rm(1,1)*r(1)+rm(1,2)*r(2)+rm(1,3)*r(3)+cen(1)
      vout(2)=rm(2,1)*r(1)+rm(2,2)*r(2)+rm(2,3)*r(3)+cen(2)
      vout(3)=rm(3,1)*r(1)+rm(3,2)*r(2)+rm(3,3)*r(3)+cen(3)

      return
      end
+DECK,UTIL_SKIP_COMMENTBLOCK_END.
*CMZ :  4.01/07 15/01/2025  11.57.17  by  Michael Scheer
*CMZ :  3.05/15 06/10/2018  11.25.38  by  Michael Scheer
*CMZ :  3.05/04 28/06/2018  15.52.47  by  Michael Scheer
*CMZ : 00.00/16 19/03/2014  12.14.18  by  Michael Scheer
*CMZ : 00.00/15 03/09/2012  09.26.58  by  Michael Scheer
*CMZ : 00.00/07 05/03/2008  15.43.44  by  Michael Scheer
*CMZ : 00.00/02 14/08/2006  13.22.55  by  Michael Scheer
*-- Author :    Michael Scheer   23/01/2004
      subroutine util_skip_commentblock_end(lun,ieof)

      implicit none

      integer lun,ieof,ib
      character(32) c2

      ieof=0
      ib=0

1     read(lun,'(a)',end=99) c2

      if (c2(1:1).eq.'{') then
        ib=1
      else if (c2(1:1).eq.'}') then
        ib=0
      endif

      if (ib.eq.0.and.c2(1:1).ne.'}'.and.
     &    c2(1:1).ne.'!'.and.c2(1:1).ne.'*'.and.c2(1:1).ne.'#'
     &    .and.c2(1:1).ne.'%'.and.c2(1:1).ne.'@'.and.
     &    c2.ne.' !'.and.c2.ne.' *'.and.c2.ne.' #'
     &    .and.c2.ne.' %'.and.c2.ne.' @'.and.len_trim(c2).ne.0
     &    ) then
        backspace(lun)
      else
        goto 1
      endif

      return

99    ieof=1

      return
      end
+DECK,bysandwich.
*CMZ :  4.01/07 18/01/2025  16.41.01  by  Michael Scheer
*CMZ :  4.00/11 26/07/2021  09.08.58  by  Michael Scheer
*CMZ :  3.06/00 11/02/2019  12.49.34  by  Michael Scheer
*CMZ :  3.04/00 19/01/2018  16.33.13  by  Michael Scheer
*CMZ :  3.03/02 16/02/2016  12.18.47  by  Michael Scheer
*CMZ :  3.01/00 15/07/2013  08.04.32  by  Michael Scheer
*CMZ :  2.68/03 07/08/2012  13.09.30  by  Michael Scheer
*CMZ :  2.66/07 04/12/2009  16.11.19  by  Michael Scheer
*CMZ :  2.52/11 15/03/2007  11.13.54  by  Michael Scheer
*CMZ :  2.15/00 28/04/2000  10.32.33  by  Michael Scheer
*CMZ :  1.02/00 19/12/97  16.15.53  by  Michael Scheer
*CMZ :  1.01/00 28/10/97  12.14.09  by  Michael Scheer
*CMZ : 00.01/08 01/04/95  16.54.24  by  Michael Scheer
*CMZ : 00.01/07 10/03/95  11.22.55  by  Michael Scheer
*CMZ : 00.01/02 04/11/94  15.21.20  by  Michael Scheer
*CMZ : 00.00/04 29/04/94  17.48.03  by  Michael Scheer
*CMZ : 00.00/00 28/04/94  16.13.42  by  Michael Scheer
*-- Author : Michael Scheer
      SUBROUTINE bysandwich(nmag,im,XIN,YIN,ZIN,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT)
+seq,gplhint.

      IMPLICIT NONE

      INTEGER nmag,IM

+SEQ,CONTRL.
+SEQ,MGSQC.

      DOUBLE PRECISION XIN,YIN,ZIN,BX,BY,BZ,BXOUT,BYOUT,BZOUT,AXOUT,AYOUT,AZOUT
      DOUBLE PRECISION dist,fint,gap,fringe,fa,fb,fc,xrs(3),
     &  strength,pin(3),center(3),pout(3),vnin(3),vnout(3),b(3),edge(2),x,y,z,x2,x3,x4,x5,y2,y3

      integer istatus,modus

      x=xin
      y=yin
      z=zin

      BXOUT=0.0d0
      BYOUT=0.0d0
      BZOUT=0.0d0

      AXOUT=0.0d0
      AYOUT=0.0d0
      AZOUT=0.0d0

      BX=0.0d0
      BY=0.0d0
      BZ=0.0d0

      dist=dot_product([pmag(1,im),pmag(2,im), pmag(3,im)]-[x,y,z],[pmag(4,im),pmag(5,im), pmag(6,im)])

      if (dist.ge.0.0d0) return

      modus=int(pmag(13,im))
      strength=pmag(14,im)
      fringe=pmag(15,im)
      fa=pmag(16,im)
      fb=pmag(17,im)
      fc=pmag(18,im)

      if (dist.ge.-fringe) then
        x=-dist
        if (modus.eq.0) then
          byout=1.0d0
        else if (modus.eq.1) then
          bxout=y*fa
          byout=x*fa
        else if (modus.eq.3) then
          x2=x*x
          x3=x2*x
          bxout=(2.0d0*fa*x+3.0d0*fb*x2)*y
          byout=fa*x2+fb*x3+y**2*(-fa-3.0d0*fb*x)
        else if (modus.eq.5) then
          x2=x*x
          x3=x2*x
          x4=x3*x
          x5=x4*x
          y2=y*y
          y3=y2*y
          bxout=y*(3.0d0*Fa*x2+4.0d0*fb*x3+5.0d0*fc*x4)
     &      +y3*(-fa-4.0d0*fb*x-10.0d0*fc*x2) !This term is not Maxwell conform
          !byout=(fa*x3+fb*x4+fc*x5)+y2*x*(3.0d0*fa+6.0d0*fb*x+10.0d0*fc*x2) ! The sign seems to be wrong in the manual
          byout=(fa*x3+fb*x4+fc*x5)-y2*x*(3.0d0*fa+6.0d0*fb*x+10.0d0*fc*x2)
        endif
        byout=byout*strength
        bxout=-bxout*strength
        return
      endif

      dist=dot_product([pmag(7,im),pmag(8,im), pmag(9,im)]-[x,y,z],[pmag(10,im),pmag(11,im), pmag(12,im)])
      if (dist.lt.0.0d0) return

      if (dist.le.fringe) then
        x=dist
        if (modus.eq.0) then
          byout=1.0d0
        else if (modus.eq.1) then
          bxout=y*fa
          byout=x*fa
        else if (modus.eq.3) then
          x2=x*x
          x3=x2*x
          bxout=(2.0d0*fa*x+3.0d0*fb*x2)*y
          byout=fa*x2+fb*x3+y**2*(-fa-3.0d0*fb*x)
        else if (modus.eq.5) then
          x2=x*x
          x3=x2*x
          x4=x3*x
          x5=x4*x
          y2=y*y
          y3=y2*y
          bxout=y*(3.0d0*Fa*x2+4.0d0*fb*x3+5.0d0*fc*x4)
     &      +y3*(-fa-4.0d0*fb*x-10.0d0*fc*x2) !This term is not Maxwell conform
          !byout=(fa*x3+fb*x4+fc*x5)+y2*x*(3.0d0*fa+6.0d0*fb*x+10.0d0*fc*x2) ! The sign seems to be wrong in the manual
          byout=(fa*x3+fb*x4+fc*x5)-y2*x*(3.0d0*fa+6.0d0*fb*x+10.0d0*fc*x2)
        endif
        byout=byout*strength
        bxout=bxout*strength
      else
        byout=strength
      endif

      return
      end
